
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.13.y-ckt,stable] Linux 3.13.11-ckt24 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.13.y-ckt,stable] Linux 3.13.11-ckt24</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 28, 2015, 4:46 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438101981-5362-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6887641/mbox/"
   >mbox</a>
|
   <a href="/patch/6887641/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6887641/">/patch/6887641/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 2A5019F380
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 28 Jul 2015 16:47:18 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 7EF5120739
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 28 Jul 2015 16:47:10 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 4637220721
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 28 Jul 2015 16:47:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752996AbbG1Qqo (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 28 Jul 2015 12:46:44 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:52582 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751580AbbG1Qq2 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 28 Jul 2015 12:46:28 -0400
Received: from 1.general.kamal.us.vpn ([10.172.68.52] helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1ZK81J-0003FN-5P; Tue, 28 Jul 2015 16:46:26 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1ZK81G-0001P6-Tt; Tue, 28 Jul 2015 09:46:22 -0700
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.13.y-ckt stable] Linux 3.13.11-ckt24
Date: Tue, 28 Jul 2015 09:46:21 -0700
Message-Id: &lt;1438101981-5362-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1438101981-5362-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1438101981-5362-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 3.13
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - July 28, 2015, 4:46 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_header">index 859a6fa..0856c9a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 * Marvell Armada 370 / Armada XP Ethernet Controller (NETA)
 
 Required properties:
<span class="p_del">-- compatible: should be &quot;marvell,armada-370-neta&quot;.</span>
<span class="p_add">+- compatible: &quot;marvell,armada-370-neta&quot; or &quot;marvell,armada-xp-neta&quot;.</span>
 - reg: address and length of the register set for the device.
 - interrupts: interrupt for the device
 - phy: A phandle to a phy node defining the PHY address (as the reg
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">index 01ef408..8faff12 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_chunk">@@ -91,5 +91,5 @@</span> <span class="p_context"> mpp61         61       gpo, dev(wen1), uart1(txd), audio(rclk)</span>
 mpp62         62       gpio, dev(a2), uart1(cts), tdm(drx), pcie(clkreq0),
                        audio(mclk), uart0(cts)
 mpp63         63       gpo, spi0(sck), tclk
<span class="p_del">-mpp64         64       gpio, spi0(miso), spi0-1(cs1)</span>
<span class="p_del">-mpp65         65       gpio, spi0(mosi), spi0-1(cs2)</span>
<span class="p_add">+mpp64         64       gpio, spi0(miso), spi0(cs1)</span>
<span class="p_add">+mpp65         65       gpio, spi0(mosi), spi0(cs2)</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">index bfa0a2e..86dec67 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_chunk">@@ -41,15 +41,15 @@</span> <span class="p_context"> mpp20         20       gpio, ge0(rxd4), ge1(rxd2), lcd(d20), ptp(clk)</span>
 mpp21         21       gpio, ge0(rxd5), ge1(rxd3), lcd(d21), mem(bat)
 mpp22         22       gpio, ge0(rxd6), ge1(rxctl), lcd(d22), sata0(prsnt)
 mpp23         23       gpio, ge0(rxd7), ge1(rxclk), lcd(d23), sata1(prsnt)
<span class="p_del">-mpp24         24       gpio, lcd(hsync), sata1(prsnt), nf(bootcs-re), tdm(rst)</span>
<span class="p_del">-mpp25         25       gpio, lcd(vsync), sata0(prsnt), nf(bootcs-we), tdm(pclk)</span>
<span class="p_del">-mpp26         26       gpio, lcd(clk), tdm(fsync), vdd(cpu1-pd)</span>
<span class="p_add">+mpp24         24       gpio, lcd(hsync), sata1(prsnt), tdm(rst)</span>
<span class="p_add">+mpp25         25       gpio, lcd(vsync), sata0(prsnt), tdm(pclk)</span>
<span class="p_add">+mpp26         26       gpio, lcd(clk), tdm(fsync)</span>
 mpp27         27       gpio, lcd(e), tdm(dtx), ptp(trig)
 mpp28         28       gpio, lcd(pwm), tdm(drx), ptp(evreq)
<span class="p_del">-mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk), vdd(cpu0-pd)</span>
<span class="p_add">+mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk)</span>
 mpp30         30       gpio, tdm(int1), sd0(clk)
<span class="p_del">-mpp31         31       gpio, tdm(int2), sd0(cmd), vdd(cpu0-pd)</span>
<span class="p_del">-mpp32         32       gpio, tdm(int3), sd0(d0), vdd(cpu1-pd)</span>
<span class="p_add">+mpp31         31       gpio, tdm(int2), sd0(cmd)</span>
<span class="p_add">+mpp32         32       gpio, tdm(int3), sd0(d0)</span>
 mpp33         33       gpio, tdm(int4), sd0(d1), mem(bat)
 mpp34         34       gpio, tdm(int5), sd0(d2), sata0(prsnt)
 mpp35         35       gpio, tdm(int6), sd0(d3), sata1(prsnt)
<span class="p_chunk">@@ -57,21 +57,18 @@</span> <span class="p_context"> mpp36         36       gpio, spi(mosi)</span>
 mpp37         37       gpio, spi(miso)
 mpp38         38       gpio, spi(sck)
 mpp39         39       gpio, spi(cs0)
<span class="p_del">-mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), vdd(cpu1-pd),</span>
<span class="p_del">-                       pcie(clkreq0)</span>
<span class="p_add">+mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), pcie(clkreq0)</span>
 mpp41         41       gpio, spi(cs2), uart2(rts), lcd(vga-vsync), sata1(prsnt),
                        pcie(clkreq1)
<span class="p_del">-mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer),</span>
<span class="p_del">-                       vdd(cpu0-pd)</span>
<span class="p_del">-mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout),</span>
<span class="p_del">-                       vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer)</span>
<span class="p_add">+mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout)</span>
 mpp44         44       gpio, uart2(cts), uart3(rxd), spi(cs4), pcie(clkreq2),
                        mem(bat)
 mpp45         45       gpio, uart2(rts), uart3(txd), spi(cs5), sata1(prsnt)
 mpp46         46       gpio, uart3(rts), uart1(rts), spi(cs6), sata0(prsnt)
 mpp47         47       gpio, uart3(cts), uart1(cts), spi(cs7), pcie(clkreq3),
                        ref(clkout)
<span class="p_del">-mpp48         48       gpio, tclk, dev(burst/last)</span>
<span class="p_add">+mpp48         48       gpio, dev(clkout), dev(burst/last)</span>
 
 * Marvell Armada XP (mv78260 and mv78460 only)
 
<span class="p_chunk">@@ -83,9 +80,9 @@</span> <span class="p_context"> mpp51         51       gpio, dev(ad16)</span>
 mpp52         52       gpio, dev(ad17)
 mpp53         53       gpio, dev(ad18)
 mpp54         54       gpio, dev(ad19)
<span class="p_del">-mpp55         55       gpio, dev(ad20), vdd(cpu0-pd)</span>
<span class="p_del">-mpp56         56       gpio, dev(ad21), vdd(cpu1-pd)</span>
<span class="p_del">-mpp57         57       gpio, dev(ad22), vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp55         55       gpio, dev(ad20)</span>
<span class="p_add">+mpp56         56       gpio, dev(ad21)</span>
<span class="p_add">+mpp57         57       gpio, dev(ad22)</span>
 mpp58         58       gpio, dev(ad23)
 mpp59         59       gpio, dev(ad24)
 mpp60         60       gpio, dev(ad25)
<span class="p_chunk">@@ -95,6 +92,3 @@</span> <span class="p_context"> mpp63         63       gpio, dev(ad28)</span>
 mpp64         64       gpio, dev(ad29)
 mpp65         65       gpio, dev(ad30)
 mpp66         66       gpio, dev(ad31)
<span class="p_del">-</span>
<span class="p_del">-Notes:</span>
<span class="p_del">-* {1} vdd(cpu2-3-pd) only available on mv78460.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 34dca2e..d2cf49b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 13
 SUBLEVEL = 11
<span class="p_del">-EXTRAVERSION = -ckt23</span>
<span class="p_add">+EXTRAVERSION = -ckt24</span>
 NAME = King of Alienated Frog Porn
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/include/asm/cmpxchg.h b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">index 03cd689..90de5c5 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -25,10 +25,11 @@</span> <span class="p_context"> __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)</span>
 	&quot;	scond   %3, [%1]	\n&quot;
 	&quot;	bnz     1b		\n&quot;
 	&quot;2:				\n&quot;
<span class="p_del">-	: &quot;=&amp;r&quot;(prev)</span>
<span class="p_del">-	: &quot;r&quot;(ptr), &quot;ir&quot;(expected),</span>
<span class="p_del">-	  &quot;r&quot;(new) /* can&#39;t be &quot;ir&quot;. scond can&#39;t take limm for &quot;b&quot; */</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(prev)	/* Early clobber, to prevent reg reuse */</span>
<span class="p_add">+	: &quot;r&quot;(ptr),	/* Not &quot;m&quot;: llock only supports reg direct addr mode */</span>
<span class="p_add">+	  &quot;ir&quot;(expected),</span>
<span class="p_add">+	  &quot;r&quot;(new)	/* can&#39;t be &quot;ir&quot;. scond can&#39;t take LIMM for &quot;b&quot; */</span>
<span class="p_add">+	: &quot;cc&quot;, &quot;memory&quot;); /* so that gcc knows memory is being written here */</span>
 
 	return prev;
 }
<span class="p_header">diff --git a/arch/arm/kvm/interrupts.S b/arch/arm/kvm/interrupts.S</span>
<span class="p_header">index ddc1553..d0b9920 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts.S</span>
<span class="p_chunk">@@ -159,13 +159,9 @@</span> <span class="p_context"> __kvm_vcpu_return:</span>
 	@ Don&#39;t trap coprocessor accesses for host kernel
 	set_hstr vmexit
 	set_hdcr vmexit
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11)), after_vfp_restore</span>
 
 #ifdef CONFIG_VFPv3
<span class="p_del">-	@ Save floating point registers we if let guest use them.</span>
<span class="p_del">-	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_del">-	bne	after_vfp_restore</span>
<span class="p_del">-</span>
 	@ Switch VFP/NEON hardware state to the host&#39;s
 	add	r7, vcpu, #VCPU_VFP_GUEST
 	store_vfp_state r7
<span class="p_chunk">@@ -177,6 +173,8 @@</span> <span class="p_context"> after_vfp_restore:</span>
 	@ Restore FPEXC_EN which we clobbered on entry
 	pop	{r2}
 	VFPFMXR FPEXC, r2
<span class="p_add">+#else</span>
<span class="p_add">+after_vfp_restore:</span>
 #endif
 
 	@ Reset Hyp-role
<span class="p_chunk">@@ -458,7 +456,7 @@</span> <span class="p_context"> switch_to_guest_vfp:</span>
 	push	{r3-r7}
 
 	@ NEON/VFP used.  Turn on VFP access.
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmtrap, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
 
 	@ Switch VFP/NEON hardware state to the guest&#39;s
 	add	r7, r0, #VCPU_VFP_HOST
<span class="p_header">diff --git a/arch/arm/kvm/interrupts_head.S b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">index 6f18695..b6f6137 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_chunk">@@ -570,8 +570,13 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 .endm
 
 /* Configures the HCPTR (Hyp Coprocessor Trap Register) on entry/return
<span class="p_del">- * (hardware reset value is 0). Keep previous value in r2. */</span>
<span class="p_del">-.macro set_hcptr operation, mask</span>
<span class="p_add">+ * (hardware reset value is 0). Keep previous value in r2.</span>
<span class="p_add">+ * An ISB is emited on vmexit/vmtrap, but executed on vmexit only if</span>
<span class="p_add">+ * VFP wasn&#39;t already enabled (always executed on vmtrap).</span>
<span class="p_add">+ * If a label is specified with vmexit, it is branched to if VFP wasn&#39;t</span>
<span class="p_add">+ * enabled.</span>
<span class="p_add">+ */</span>
<span class="p_add">+.macro set_hcptr operation, mask, label = none</span>
 	mrc	p15, 4, r2, c1, c1, 2
 	ldr	r3, =\mask
 	.if \operation == vmentry
<span class="p_chunk">@@ -580,6 +585,17 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 	bic	r3, r2, r3		@ Don&#39;t trap defined coproc-accesses
 	.endif
 	mcr	p15, 4, r3, c1, c1, 2
<span class="p_add">+	.if \operation != vmentry</span>
<span class="p_add">+	.if \operation == vmexit</span>
<span class="p_add">+	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	beq	1f</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	.if \label != none</span>
<span class="p_add">+	b	\label</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+1:</span>
<span class="p_add">+	.endif</span>
 .endm
 
 /* Configures the HDCR (Hyp Debug Configuration Register) on entry/return
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">index 6d20b7d..fdda6dd 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -15,6 +15,10 @@</span> <span class="p_context"> ccflags-y := -shared -fno-common -fno-builtin</span>
 ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \
 		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
 
<span class="p_add">+# Workaround for bare-metal (ELF) toolchains that neglect to pass -shared</span>
<span class="p_add">+# down to collect2, resulting in silent corruption of the vDSO image.</span>
<span class="p_add">+ccflags-y += -Wl,-shared</span>
<span class="p_add">+</span>
 obj-y += vdso.o
 extra-y += vdso.lds vdso-offsets.h
 CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
<span class="p_header">diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c</span>
<span class="p_header">index baa758d..76c1e6c 100644</span>
<span class="p_header">--- a/arch/arm64/mm/context.c</span>
<span class="p_header">+++ b/arch/arm64/mm/context.c</span>
<span class="p_chunk">@@ -92,6 +92,14 @@</span> <span class="p_context"> static void reset_context(void *info)</span>
 	unsigned int cpu = smp_processor_id();
 	struct mm_struct *mm = current-&gt;active_mm;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * current-&gt;active_mm could be init_mm for the idle thread immediately</span>
<span class="p_add">+	 * after secondary CPU boot or hotplug. TTBR0_EL1 is already set to</span>
<span class="p_add">+	 * the reserved value, so no need to reset any context.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mm == &amp;init_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	smp_rmb();
 	asid = cpu_last_asid + cpu;
 
<span class="p_header">diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">index 023747b..e3a24b7 100644</span>
<span class="p_header">--- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -46,13 +46,13 @@</span> <span class="p_context"> struct page *follow_huge_addr(struct mm_struct *mm, unsigned long address,</span>
 
 int pmd_huge(pmd_t pmd)
 {
<span class="p_del">-	return !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
<span class="p_add">+	return pmd_val(pmd) &amp;&amp; !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
 }
 
 int pud_huge(pud_t pud)
 {
 #ifndef __PAGETABLE_PMD_FOLDED
<span class="p_del">-	return !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
<span class="p_add">+	return pud_val(pud) &amp;&amp; !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
 #else
 	return 0;
 #endif
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index 0cb8742..8fc4347 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -240,7 +240,7 @@</span> <span class="p_context"> static void __init free_unused_memmap(void)</span>
 		 * memmap entries are valid from the bank end aligned to
 		 * MAX_ORDER_NR_PAGES.
 		 */
<span class="p_del">-		prev_end = ALIGN(start + __phys_to_pfn(reg-&gt;size),</span>
<span class="p_add">+		prev_end = ALIGN(__phys_to_pfn(reg-&gt;base + reg-&gt;size),</span>
 				 MAX_ORDER_NR_PAGES);
 	}
 
<span class="p_header">diff --git a/arch/mips/include/asm/mach-generic/spaces.h b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">index 9488fa5..afc96ec 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_chunk">@@ -94,7 +94,11 @@</span> <span class="p_context"></span>
 #endif
 
 #ifndef FIXADDR_TOP
<span class="p_add">+#ifdef CONFIG_KVM_GUEST</span>
<span class="p_add">+#define FIXADDR_TOP		((unsigned long)(long)(int)0x7ffe0000)</span>
<span class="p_add">+#else</span>
 #define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
 #endif
<span class="p_add">+#endif</span>
 
 #endif /* __ASM_MACH_GENERIC_SPACES_H */
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index bdc5eeb..538abbf 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -810,7 +810,7 @@</span> <span class="p_context"> int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)</span>
 
 	/* If nothing is dirty, don&#39;t bother messing with page tables. */
 	if (is_dirty) {
<span class="p_del">-		memslot = &amp;kvm-&gt;memslots-&gt;memslots[log-&gt;slot];</span>
<span class="p_add">+		memslot = id_to_memslot(kvm-&gt;memslots, log-&gt;slot);</span>
 
 		ga = memslot-&gt;base_gfn &lt;&lt; PAGE_SHIFT;
 		ga_end = ga + (memslot-&gt;npages &lt;&lt; PAGE_SHIFT);
<span class="p_header">diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">index 36a8bdd..72b83b0 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_chunk">@@ -124,7 +124,16 @@</span> <span class="p_context"> static inline void power_pmu_bhrb_read(struct cpu_hw_events *cpuhw) {}</span>
 
 static bool regs_use_siar(struct pt_regs *regs)
 {
<span class="p_del">-	return !!regs-&gt;result;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we take a performance monitor exception the regs are setup</span>
<span class="p_add">+	 * using perf_read_regs() which overloads some fields, in particular</span>
<span class="p_add">+	 * regs-&gt;result to tell us whether to use SIAR.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However if the regs are from another exception, eg. a syscall, then</span>
<span class="p_add">+	 * they have not been setup using perf_read_regs() and so regs-&gt;result</span>
<span class="p_add">+	 * is something random.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return ((TRAP(regs) == 0xf00) &amp;&amp; regs-&gt;result);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index 261bf79..1dea9c0 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -417,11 +417,10 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 		return -ENODEV;
 
 	dn = dlpar_configure_connector(drc_index, parent);
<span class="p_add">+	of_node_put(parent);</span>
 	if (!dn)
 		return -EINVAL;
 
<span class="p_del">-	of_node_put(parent);</span>
<span class="p_del">-</span>
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
<span class="p_header">diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c</span>
<span class="p_header">index 27bb554..7ef2862 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ldc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ldc.c</span>
<span class="p_chunk">@@ -2307,7 +2307,7 @@</span> <span class="p_context"> void *ldc_alloc_exp_dring(struct ldc_channel *lp, unsigned int len,</span>
 	if (len &amp; (8UL - 1))
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	buf = kzalloc(len, GFP_KERNEL);</span>
<span class="p_add">+	buf = kzalloc(len, GFP_ATOMIC);</span>
 	if (!buf)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index 331b63c..6b019cf 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -572,7 +572,7 @@</span> <span class="p_context"> struct kvm_arch {</span>
 	struct kvm_pic *vpic;
 	struct kvm_ioapic *vioapic;
 	struct kvm_pit *vpit;
<span class="p_del">-	int vapics_in_nmi_mode;</span>
<span class="p_add">+	atomic_t vapics_in_nmi_mode;</span>
 	struct mutex apic_map_lock;
 	struct kvm_apic_map *apic_map;
 
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index 298781d..1406ffd 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> static void pit_do_work(struct kthread_work *work)</span>
 		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
 		 * VCPU0, and only if its LVT0 is in EXTINT mode.
 		 */
<span class="p_del">-		if (kvm-&gt;arch.vapics_in_nmi_mode &gt; 0)</span>
<span class="p_add">+		if (atomic_read(&amp;kvm-&gt;arch.vapics_in_nmi_mode) &gt; 0)</span>
 			kvm_for_each_vcpu(i, vcpu, kvm)
 				kvm_apic_nmi_wd_deliver(vcpu);
 	}
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 4a0de62..701fd95 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -1115,10 +1115,10 @@</span> <span class="p_context"> static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)</span>
 		if (!nmi_wd_enabled) {
 			apic_debug(&quot;Receive NMI setting on APIC_LVT0 &quot;
 				   &quot;for cpu %d\n&quot;, apic-&gt;vcpu-&gt;vcpu_id);
<span class="p_del">-			apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode++;</span>
<span class="p_add">+			atomic_inc(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 		}
 	} else if (nmi_wd_enabled)
<span class="p_del">-		apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode--;</span>
<span class="p_add">+		atomic_dec(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 }
 
 static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
<span class="p_chunk">@@ -1685,6 +1685,7 @@</span> <span class="p_context"> void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,</span>
 
 	apic_update_ppr(apic);
 	hrtimer_cancel(&amp;apic-&gt;lapic_timer.timer);
<span class="p_add">+	apic_manage_nmi_watchdog(apic, kvm_apic_get_reg(apic, APIC_LVT0));</span>
 	update_divide_count(apic);
 	start_apic_timer(apic);
 	apic-&gt;irr_pending = true;
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index 4f25ec0..31f0a42 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -84,6 +84,17 @@</span> <span class="p_context"> static const struct dmi_system_id pci_crs_quirks[] __initconst = {</span>
 			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),
 		},
 	},
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/931368 */</span>
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/1033299 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_use_crs,</span>
<span class="p_add">+		.ident = &quot;Foxconn K8M890-8237A&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Foxconn&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_NAME, &quot;K8M890-8237A&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* Now for the blacklist.. */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">index 75efea0..03eae64 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_chunk">@@ -167,10 +167,12 @@</span> <span class="p_context"> acpi_status __init acpi_enable_subsystem(u32 flags)</span>
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
<span class="p_del">-	status = acpi_tb_initialize_facs();</span>
<span class="p_del">-	if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-		ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_del">-		return_ACPI_STATUS(status);</span>
<span class="p_add">+	if (!(flags &amp; ACPI_NO_FACS_INIT)) {</span>
<span class="p_add">+		status = acpi_tb_initialize_facs();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
 	}
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index 5d7c98a..65d93f4 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -169,11 +169,7 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *gas,</span>
 	if (!addr || !length)
 		return;
 
<span class="p_del">-	/* Resources are never freed */</span>
<span class="p_del">-	if (gas-&gt;space_id == ACPI_ADR_SPACE_SYSTEM_IO)</span>
<span class="p_del">-		request_region(addr, length, desc);</span>
<span class="p_del">-	else if (gas-&gt;space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)</span>
<span class="p_del">-		request_mem_region(addr, length, desc);</span>
<span class="p_add">+	acpi_reserve_region(addr, length, gas-&gt;space_id, 0, desc);</span>
 }
 
 static void __init acpi_reserve_resources(void)
<span class="p_header">diff --git a/drivers/acpi/resource.c b/drivers/acpi/resource.c</span>
<span class="p_header">index 0bdacc5..9e1ea53 100644</span>
<span class="p_header">--- a/drivers/acpi/resource.c</span>
<span class="p_header">+++ b/drivers/acpi/resource.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/device.h&gt;
 #include &lt;linux/export.h&gt;
 #include &lt;linux/ioport.h&gt;
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
 #include &lt;linux/slab.h&gt;
 
 #ifdef CONFIG_X86
<span class="p_chunk">@@ -538,3 +539,164 @@</span> <span class="p_context"> int acpi_dev_get_resources(struct acpi_device *adev, struct list_head *list,</span>
 	return c.count;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_get_resources);
<span class="p_add">+</span>
<span class="p_add">+struct reserved_region {</span>
<span class="p_add">+	struct list_head node;</span>
<span class="p_add">+	u64 start;</span>
<span class="p_add">+	u64 end;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static LIST_HEAD(reserved_io_regions);</span>
<span class="p_add">+static LIST_HEAD(reserved_mem_regions);</span>
<span class="p_add">+</span>
<span class="p_add">+static int request_range(u64 start, u64 end, u8 space_id, unsigned long flags,</span>
<span class="p_add">+			 char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int length = end - start + 1;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = space_id == ACPI_ADR_SPACE_SYSTEM_IO ?</span>
<span class="p_add">+		request_region(start, length, desc) :</span>
<span class="p_add">+		request_mem_region(start, length, desc);</span>
<span class="p_add">+	if (!res)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	res-&gt;flags &amp;= ~flags;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int add_region_before(u64 start, u64 end, u8 space_id,</span>
<span class="p_add">+			     unsigned long flags, char *desc,</span>
<span class="p_add">+			     struct list_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct reserved_region *reg;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	reg = kmalloc(sizeof(*reg), GFP_KERNEL);</span>
<span class="p_add">+	if (!reg)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = request_range(start, end, space_id, flags, desc);</span>
<span class="p_add">+	if (error) {</span>
<span class="p_add">+		kfree(reg);</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	reg-&gt;start = start;</span>
<span class="p_add">+	reg-&gt;end = end;</span>
<span class="p_add">+	list_add_tail(&amp;reg-&gt;node, head);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_reserve_region - Reserve an I/O or memory region as a system resource.</span>
<span class="p_add">+ * @start: Starting address of the region.</span>
<span class="p_add">+ * @length: Length of the region.</span>
<span class="p_add">+ * @space_id: Identifier of address space to reserve the region from.</span>
<span class="p_add">+ * @flags: Resource flags to clear for the region after requesting it.</span>
<span class="p_add">+ * @desc: Region description (for messages).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Reserve an I/O or memory region as a system resource to prevent others from</span>
<span class="p_add">+ * using it.  If the new region overlaps with one of the regions (in the given</span>
<span class="p_add">+ * address space) already reserved by this routine, only the non-overlapping</span>
<span class="p_add">+ * parts of it will be reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returned is either 0 (success) or a negative error code indicating a resource</span>
<span class="p_add">+ * reservation problem.  It is the code of the first encountered error, but the</span>
<span class="p_add">+ * routine doesn&#39;t abort until it has attempted to request all of the parts of</span>
<span class="p_add">+ * the new region that don&#39;t overlap with other regions reserved previously.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The resources requested by this routine are never released.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int acpi_reserve_region(u64 start, unsigned int length, u8 space_id,</span>
<span class="p_add">+			unsigned long flags, char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct list_head *regions;</span>
<span class="p_add">+	struct reserved_region *reg;</span>
<span class="p_add">+	u64 end = start + length - 1;</span>
<span class="p_add">+	int ret = 0, error = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (space_id == ACPI_ADR_SPACE_SYSTEM_IO)</span>
<span class="p_add">+		regions = &amp;reserved_io_regions;</span>
<span class="p_add">+	else if (space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)</span>
<span class="p_add">+		regions = &amp;reserved_mem_regions;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (list_empty(regions))</span>
<span class="p_add">+		return add_region_before(start, end, space_id, flags, desc, regions);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(reg, regions, node)</span>
<span class="p_add">+		if (reg-&gt;start == end + 1) {</span>
<span class="p_add">+			/* The new region can be prepended to this one. */</span>
<span class="p_add">+			ret = request_range(start, end, space_id, flags, desc);</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				reg-&gt;start = start;</span>
<span class="p_add">+</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		} else if (reg-&gt;start &gt; end) {</span>
<span class="p_add">+			/* No overlap.  Add the new region here and get out. */</span>
<span class="p_add">+			return add_region_before(start, end, space_id, flags,</span>
<span class="p_add">+						 desc, &amp;reg-&gt;node);</span>
<span class="p_add">+		} else if (reg-&gt;end == start - 1) {</span>
<span class="p_add">+			goto combine;</span>
<span class="p_add">+		} else if (reg-&gt;end &gt;= start) {</span>
<span class="p_add">+			goto overlap;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The new region goes after the last existing one. */</span>
<span class="p_add">+	return add_region_before(start, end, space_id, flags, desc, regions);</span>
<span class="p_add">+</span>
<span class="p_add">+ overlap:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The new region overlaps an existing one.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The head part of the new region immediately preceding the existing</span>
<span class="p_add">+	 * overlapping one can be combined with it right away.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (reg-&gt;start &gt; start) {</span>
<span class="p_add">+		error = request_range(start, reg-&gt;start - 1, space_id, flags, desc);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			ret = error;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			reg-&gt;start = start;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+ combine:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The new region is adjacent to an existing one.  If it extends beyond</span>
<span class="p_add">+	 * that region all the way to the next one, it is possible to combine</span>
<span class="p_add">+	 * all three of them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (reg-&gt;end &lt; end) {</span>
<span class="p_add">+		struct reserved_region *next = NULL;</span>
<span class="p_add">+		u64 a = reg-&gt;end + 1, b = end;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!list_is_last(&amp;reg-&gt;node, regions)) {</span>
<span class="p_add">+			next = list_next_entry(reg, node);</span>
<span class="p_add">+			if (next-&gt;start &lt;= end)</span>
<span class="p_add">+				b = next-&gt;start - 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		error = request_range(a, b, space_id, flags, desc);</span>
<span class="p_add">+		if (!error) {</span>
<span class="p_add">+			if (next &amp;&amp; next-&gt;start == b + 1) {</span>
<span class="p_add">+				reg-&gt;end = next-&gt;end;</span>
<span class="p_add">+				list_del(&amp;next-&gt;node);</span>
<span class="p_add">+				kfree(next);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				reg-&gt;end = end;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else if (next) {</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				ret = error;</span>
<span class="p_add">+</span>
<span class="p_add">+			reg = next;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret ? ret : error;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(acpi_reserve_region);</span>
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 9c0809c..1efa300 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4224,7 +4224,7 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;PIONEER DVD-RW  DVR-216D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 
 	/* devices that don&#39;t properly handle queued TRIM commands */
<span class="p_del">-	{ &quot;Micron_M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Micron_M500_*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
 	{ &quot;Crucial_CT???M500SSD*&quot;,	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Micron_M550*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Crucial_CT*M550SSD*&quot;,	NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
<span class="p_header">diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c</span>
<span class="p_header">index 9e885cf..c1d343e 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regmap.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regmap.c</span>
<span class="p_chunk">@@ -808,11 +808,10 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(devm_regmap_init);</span>
 static void regmap_field_init(struct regmap_field *rm_field,
 	struct regmap *regmap, struct reg_field reg_field)
 {
<span class="p_del">-	int field_bits = reg_field.msb - reg_field.lsb + 1;</span>
 	rm_field-&gt;regmap = regmap;
 	rm_field-&gt;reg = reg_field.reg;
 	rm_field-&gt;shift = reg_field.lsb;
<span class="p_del">-	rm_field-&gt;mask = ((BIT(field_bits) - 1) &lt;&lt; reg_field.lsb);</span>
<span class="p_add">+	rm_field-&gt;mask = GENMASK(reg_field.msb, reg_field.lsb);</span>
 	rm_field-&gt;id_size = reg_field.id_size;
 	rm_field-&gt;id_offset = reg_field.id_offset;
 }
<span class="p_chunk">@@ -1939,7 +1938,7 @@</span> <span class="p_context"> int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,</span>
 					  &amp;ival);
 			if (ret != 0)
 				return ret;
<span class="p_del">-			memcpy(val + (i * val_bytes), &amp;ival, val_bytes);</span>
<span class="p_add">+			map-&gt;format.format_val(val + (i * val_bytes), ival, 0);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 873b2d7..bb0a1f0 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -1845,11 +1845,11 @@</span> <span class="p_context"> static struct rbd_obj_request *rbd_obj_request_create(const char *object_name,</span>
 	rbd_assert(obj_request_type_valid(type));
 
 	size = strlen(object_name) + 1;
<span class="p_del">-	name = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	name = kmalloc(size, GFP_NOIO);</span>
 	if (!name)
 		return NULL;
 
<span class="p_del">-	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_KERNEL);</span>
<span class="p_add">+	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);</span>
 	if (!obj_request) {
 		kfree(name);
 		return NULL;
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index 3266347..00aa6d6 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -78,12 +78,17 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe04e) },
 	{ USB_DEVICE(0x0489, 0xe056) },
 	{ USB_DEVICE(0x0489, 0xe057) },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe05f) },</span>
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076) },</span>
 	{ USB_DEVICE(0x0489, 0xe078) },
 	{ USB_DEVICE(0x04c5, 0x1330) },
 	{ USB_DEVICE(0x04CA, 0x3004) },
 	{ USB_DEVICE(0x04CA, 0x3005) },
 	{ USB_DEVICE(0x04CA, 0x3006) },
 	{ USB_DEVICE(0x04CA, 0x3008) },
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300b) },</span>
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300d) },</span>
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300f) },</span>
 	{ USB_DEVICE(0x04CA, 0x3010) },
 	{ USB_DEVICE(0x0930, 0x0219) },
 	{ USB_DEVICE(0x0930, 0x0220) },
<span class="p_chunk">@@ -107,6 +112,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408) },
 	{ USB_DEVICE(0x13d3, 0x3423) },
 	{ USB_DEVICE(0x13d3, 0x3432) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474) },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
<span class="p_chunk">@@ -130,12 +136,17 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe04e), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3006), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -159,6 +170,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU22 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE03C), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 3171710..a363f7f 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -156,12 +156,17 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe04e), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3005), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3006), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -185,6 +190,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
<span class="p_chunk">@@ -1249,6 +1255,8 @@</span> <span class="p_context"> static int btusb_setup_intel(struct hci_dev *hdev)</span>
 	}
 	fw_ptr = fw-&gt;data;
 
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+</span>
 	/* This Intel specific command enables the manufacturer mode of the
 	 * controller.
 	 *
<span class="p_header">diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">index b8e2014..051aadb 100644</span>
<span class="p_header">--- a/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">+++ b/drivers/char/agp/intel-gtt.c</span>
<span class="p_chunk">@@ -583,7 +583,7 @@</span> <span class="p_context"> static inline int needs_ilk_vtd_wa(void)</span>
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
<span class="p_del">-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||</span>
<span class="p_add">+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||</span>
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &amp;&amp;
 	     intel_iommu_gfx_mapped)
 		return 1;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 7116dcb3..3802733 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -618,6 +618,9 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	ibmvtpm-&gt;dev = dev;</span>
<span class="p_add">+	ibmvtpm-&gt;vdev = vio_dev;</span>
<span class="p_add">+</span>
 	crq_q = &amp;ibmvtpm-&gt;crq_queue;
 	crq_q-&gt;crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);
 	if (!crq_q-&gt;crq_addr) {
<span class="p_chunk">@@ -662,8 +665,6 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 
 	crq_q-&gt;index = 0;
 
<span class="p_del">-	ibmvtpm-&gt;dev = dev;</span>
<span class="p_del">-	ibmvtpm-&gt;vdev = vio_dev;</span>
 	TPM_VPRIV(chip) = (void *)ibmvtpm;
 
 	spin_lock_init(&amp;ibmvtpm-&gt;rtce_lock);
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index 12fbec7..fc0e502 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -418,15 +418,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 	exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);
 
 	if (mct_int_type == MCT_INT_SPI) {
<span class="p_del">-		evt-&gt;irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_del">-		if (request_irq(evt-&gt;irq, exynos4_mct_tick_isr,</span>
<span class="p_del">-				IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_del">-				evt-&gt;name, mevt)) {</span>
<span class="p_del">-			pr_err(&quot;exynos-mct: cannot register IRQ %d\n&quot;,</span>
<span class="p_del">-				evt-&gt;irq);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (evt-&gt;irq == -1)</span>
 			return -EIO;
<span class="p_del">-		}</span>
<span class="p_del">-		irq_force_affinity(mct_irqs[MCT_L0_IRQ + cpu], cpumask_of(cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+		irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span>
<span class="p_add">+		enable_irq(evt-&gt;irq);</span>
 	} else {
 		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);
 	}
<span class="p_chunk">@@ -439,10 +436,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
 	evt-&gt;set_mode(CLOCK_EVT_MODE_UNUSED, evt);
<span class="p_del">-	if (mct_int_type == MCT_INT_SPI)</span>
<span class="p_del">-		free_irq(evt-&gt;irq, this_cpu_ptr(&amp;percpu_mct_tick));</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (mct_int_type == MCT_INT_SPI) {</span>
<span class="p_add">+		if (evt-&gt;irq != -1)</span>
<span class="p_add">+			disable_irq_nosync(evt-&gt;irq);</span>
<span class="p_add">+	} else {</span>
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
<span class="p_add">+	}</span>
 }
 
 static int exynos4_mct_cpu_notify(struct notifier_block *self,
<span class="p_chunk">@@ -474,7 +473,7 @@</span> <span class="p_context"> static struct notifier_block exynos4_mct_cpu_nb = {</span>
 
 static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, cpu;</span>
 	struct mct_clock_event_device *mevt = this_cpu_ptr(&amp;percpu_mct_tick);
 	struct clk *mct_clk, *tick_clk;
 
<span class="p_chunk">@@ -501,7 +500,25 @@</span> <span class="p_context"> static void __init exynos4_timer_resources(struct device_node *np, void __iomem</span>
 		WARN(err, &quot;MCT: can&#39;t request IRQ %d (%d)\n&quot;,
 		     mct_irqs[MCT_L0_IRQ], err);
 	} else {
<span class="p_del">-		irq_set_affinity(mct_irqs[MCT_L0_IRQ], cpumask_of(0));</span>
<span class="p_add">+		for_each_possible_cpu(cpu) {</span>
<span class="p_add">+			int mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_add">+			struct mct_clock_event_device *pcpu_mevt =</span>
<span class="p_add">+				per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span>
<span class="p_add">+			if (request_irq(mct_irq,</span>
<span class="p_add">+					exynos4_mct_tick_isr,</span>
<span class="p_add">+					IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_add">+					pcpu_mevt-&gt;name, pcpu_mevt)) {</span>
<span class="p_add">+				pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span>
<span class="p_add">+									cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = mct_irq;</span>
<span class="p_add">+		}</span>
 	}
 
 	err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index b44f4dd..7673a4e 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -918,7 +918,8 @@</span> <span class="p_context"> static int sg_to_link_tbl(struct scatterlist *sg, int sg_count,</span>
 		sg_count--;
 		link_tbl_ptr--;
 	}
<span class="p_del">-	be16_add_cpu(&amp;link_tbl_ptr-&gt;len, cryptlen);</span>
<span class="p_add">+	link_tbl_ptr-&gt;len = cpu_to_be16(be16_to_cpu(link_tbl_ptr-&gt;len)</span>
<span class="p_add">+					+ cryptlen);</span>
 
 	/* tag end of link table */
 	link_tbl_ptr-&gt;j_extent = DESC_PTR_LNKTBL_RETURN;
<span class="p_chunk">@@ -2556,6 +2557,7 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		break;
 	default:
 		dev_err(dev, &quot;unknown algorithm type %d\n&quot;, t_alg-&gt;algt.type);
<span class="p_add">+		kfree(t_alg);</span>
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index 29c8a06..b01f711 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -316,7 +316,8 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
<span class="p_del">-	int seen_current = 0;</span>
<span class="p_add">+	int current_cleaned = 0;</span>
<span class="p_add">+	struct mv_xor_desc *hw_desc;</span>
 
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;%s %d\n&quot;, __func__, __LINE__);
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;current_desc %x\n&quot;, current_desc);
<span class="p_chunk">@@ -328,38 +329,57 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 
 	list_for_each_entry_safe(iter, _iter, &amp;mv_chan-&gt;chain,
 					chain_node) {
<span class="p_del">-		prefetch(_iter);</span>
<span class="p_del">-		prefetch(&amp;_iter-&gt;async_tx);</span>
 
<span class="p_del">-		/* do not advance past the current descriptor loaded into the</span>
<span class="p_del">-		 * hardware channel, subsequent descriptors are either in</span>
<span class="p_del">-		 * process or have not been submitted</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (seen_current)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		/* clean finished descriptors */</span>
<span class="p_add">+		hw_desc = iter-&gt;hw_desc;</span>
<span class="p_add">+		if (hw_desc-&gt;status &amp; XOR_DESC_SUCCESS) {</span>
<span class="p_add">+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,</span>
<span class="p_add">+								cookie);</span>
 
<span class="p_del">-		/* stop the search if we reach the current descriptor and the</span>
<span class="p_del">-		 * channel is busy</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_del">-			seen_current = 1;</span>
<span class="p_del">-			if (busy)</span>
<span class="p_add">+			/* done processing desc, clean slot */</span>
<span class="p_add">+			mv_xor_clean_slot(iter, mv_chan);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* break if we did cleaned the current */</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 0;</span>
 				break;
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mv_xor_clean_slot(iter, mv_chan))</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((busy == 0) &amp;&amp; !list_empty(&amp;mv_chan-&gt;chain)) {
<span class="p_del">-		struct mv_xor_desc_slot *chain_head;</span>
<span class="p_del">-		chain_head = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_del">-					struct mv_xor_desc_slot,</span>
<span class="p_del">-					chain_node);</span>
<span class="p_del">-</span>
<span class="p_del">-		mv_xor_start_new_chain(mv_chan, chain_head);</span>
<span class="p_add">+		if (current_cleaned) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * current descriptor cleaned and removed, run</span>
<span class="p_add">+			 * from list head</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			iter = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_add">+					  struct mv_xor_desc_slot,</span>
<span class="p_add">+					  chain_node);</span>
<span class="p_add">+			mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (!list_is_last(&amp;iter-&gt;chain_node, &amp;mv_chan-&gt;chain)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * descriptors are still waiting after</span>
<span class="p_add">+				 * current, trigger them</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				iter = list_entry(iter-&gt;chain_node.next,</span>
<span class="p_add">+						  struct mv_xor_desc_slot,</span>
<span class="p_add">+						  chain_node);</span>
<span class="p_add">+				mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * some descriptors are still waiting</span>
<span class="p_add">+				 * to be cleaned</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tasklet_schedule(&amp;mv_chan-&gt;irq_tasklet);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cookie &gt; 0)
<span class="p_header">diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h</span>
<span class="p_header">index d074922..5d14e4b 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.h</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.h</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"></span>
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_DESCRIPTOR_SWAP		BIT(14)
<span class="p_add">+#define XOR_DESC_SUCCESS		0x40000000</span>
 
 #define XOR_CURR_DESC(chan)	(chan-&gt;mmr_high_base + 0x10 + (chan-&gt;idx * 4))
 #define XOR_NEXT_DESC(chan)	(chan-&gt;mmr_high_base + 0x00 + (chan-&gt;idx * 4))
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">index eb89653..c5e96a3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_chunk">@@ -505,6 +505,7 @@</span> <span class="p_context"> int qxl_hw_surface_alloc(struct qxl_device *qdev,</span>
 
 	cmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_SURFACE_CMD_CREATE;
<span class="p_add">+	cmd-&gt;flags = QXL_SURF_FLAG_KEEP_DATA;</span>
 	cmd-&gt;u.surface_create.format = surf-&gt;surf.format;
 	cmd-&gt;u.surface_create.width = surf-&gt;surf.width;
 	cmd-&gt;u.surface_create.height = surf-&gt;surf.height;
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">index 7b95c75..729debf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_chunk">@@ -122,8 +122,10 @@</span> <span class="p_context"> static struct qxl_bo *qxlhw_handle_to_bo(struct qxl_device *qdev,</span>
 	qobj = gem_to_qxl_bo(gobj);
 
 	ret = qxl_release_list_add(release, qobj);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(gobj);</span>
 		return NULL;
<span class="p_add">+	}</span>
 
 	return qobj;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index fff7ea0..9ee6440 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -4083,6 +4083,31 @@</span> <span class="p_context"> void cik_compute_ring_set_wptr(struct radeon_device *rdev,</span>
 	WDOORBELL32(ring-&gt;doorbell_index, ring-&gt;wptr);
 }
 
<span class="p_add">+static void cik_compute_stop(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 j, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	cik_srbm_select(rdev, ring-&gt;me, ring-&gt;pipe, ring-&gt;queue, 0);</span>
<span class="p_add">+	/* Disable wptr polling. */</span>
<span class="p_add">+	tmp = RREG32(CP_PQ_WPTR_POLL_CNTL);</span>
<span class="p_add">+	tmp &amp;= ~WPTR_POLL_EN;</span>
<span class="p_add">+	WREG32(CP_PQ_WPTR_POLL_CNTL, tmp);</span>
<span class="p_add">+	/* Disable HQD. */</span>
<span class="p_add">+	if (RREG32(CP_HQD_ACTIVE) &amp; 1) {</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 1);</span>
<span class="p_add">+		for (j = 0; j &lt; rdev-&gt;usec_timeout; j++) {</span>
<span class="p_add">+			if (!(RREG32(CP_HQD_ACTIVE) &amp; 1))</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			udelay(1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_RPTR, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_WPTR, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cik_srbm_select(rdev, 0, 0, 0, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * cik_cp_compute_enable - enable/disable the compute CP MEs
  *
<span class="p_chunk">@@ -4096,6 +4121,15 @@</span> <span class="p_context"> static void cik_cp_compute_enable(struct radeon_device *rdev, bool enable)</span>
 	if (enable)
 		WREG32(CP_MEC_CNTL, 0);
 	else {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * To make hibernation reliable we need to clear compute ring</span>
<span class="p_add">+		 * configuration before halting the compute ring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mutex_lock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX]);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX]);</span>
<span class="p_add">+		mutex_unlock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+</span>
 		WREG32(CP_MEC_CNTL, (MEC_ME1_HALT | MEC_ME2_HALT));
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik_sdma.c b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">index cdcba5f..087c5a2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_chunk">@@ -195,6 +195,17 @@</span> <span class="p_context"> static void cik_sdma_gfx_stop(struct radeon_device *rdev)</span>
 	}
 	rdev-&gt;ring[R600_RING_TYPE_DMA_INDEX].ready = false;
 	rdev-&gt;ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready = false;
<span class="p_add">+</span>
<span class="p_add">+	/* FIXME use something else than big hammer but after few days can not</span>
<span class="p_add">+	 * seem to find good combination so reset SDMA blocks as it seems we</span>
<span class="p_add">+	 * do not shut them down properly. This fix hibernation and does not</span>
<span class="p_add">+	 * affect suspend to ram.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, SOFT_RESET_SDMA | SOFT_RESET_SDMA1);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, 0);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index 2c83be9..13d6ac4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -79,10 +79,12 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	mutex_lock(&amp;mode_config-&gt;mutex);</span>
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
<span class="p_add">+	mutex_unlock(&amp;mode_config-&gt;mutex);</span>
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index cc4b092..5bdef2c 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -40,9 +40,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/i2c/i2c-hid.h&gt;
 
 /* flags */
<span class="p_del">-#define I2C_HID_STARTED		(1 &lt;&lt; 0)</span>
<span class="p_del">-#define I2C_HID_RESET_PENDING	(1 &lt;&lt; 1)</span>
<span class="p_del">-#define I2C_HID_READ_PENDING	(1 &lt;&lt; 2)</span>
<span class="p_add">+#define I2C_HID_STARTED		0</span>
<span class="p_add">+#define I2C_HID_RESET_PENDING	1</span>
<span class="p_add">+#define I2C_HID_READ_PENDING	2</span>
 
 #define I2C_HID_PWR_ON		0x00
 #define I2C_HID_PWR_SLEEP	0x01
<span class="p_header">diff --git a/drivers/hwmon/mcp3021.c b/drivers/hwmon/mcp3021.c</span>
<span class="p_header">index d219c06..972444a 100644</span>
<span class="p_header">--- a/drivers/hwmon/mcp3021.c</span>
<span class="p_header">+++ b/drivers/hwmon/mcp3021.c</span>
<span class="p_chunk">@@ -31,14 +31,11 @@</span> <span class="p_context"></span>
 /* output format */
 #define MCP3021_SAR_SHIFT	2
 #define MCP3021_SAR_MASK	0x3ff
<span class="p_del">-</span>
 #define MCP3021_OUTPUT_RES	10	/* 10-bit resolution */
<span class="p_del">-#define MCP3021_OUTPUT_SCALE	4</span>
 
 #define MCP3221_SAR_SHIFT	0
 #define MCP3221_SAR_MASK	0xfff
 #define MCP3221_OUTPUT_RES	12	/* 12-bit resolution */
<span class="p_del">-#define MCP3221_OUTPUT_SCALE	1</span>
 
 enum chips {
 	mcp3021,
<span class="p_chunk">@@ -54,7 +51,6 @@</span> <span class="p_context"> struct mcp3021_data {</span>
 	u16 sar_shift;
 	u16 sar_mask;
 	u8 output_res;
<span class="p_del">-	u8 output_scale;</span>
 };
 
 static int mcp3021_read16(struct i2c_client *client)
<span class="p_chunk">@@ -84,13 +80,7 @@</span> <span class="p_context"> static int mcp3021_read16(struct i2c_client *client)</span>
 
 static inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)
 {
<span class="p_del">-	if (val == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	val = val * data-&gt;output_scale - data-&gt;output_scale / 2;</span>
<span class="p_del">-</span>
<span class="p_del">-	return val * DIV_ROUND_CLOSEST(data-&gt;vdd,</span>
<span class="p_del">-			(1 &lt;&lt; data-&gt;output_res) * data-&gt;output_scale);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(data-&gt;vdd * val, 1 &lt;&lt; data-&gt;output_res);</span>
 }
 
 static ssize_t show_in_input(struct device *dev, struct device_attribute *attr,
<span class="p_chunk">@@ -132,14 +122,12 @@</span> <span class="p_context"> static int mcp3021_probe(struct i2c_client *client,</span>
 		data-&gt;sar_shift = MCP3021_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3021_SAR_MASK;
 		data-&gt;output_res = MCP3021_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3021_OUTPUT_SCALE;</span>
 		break;
 
 	case mcp3221:
 		data-&gt;sar_shift = MCP3221_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3221_SAR_MASK;
 		data-&gt;output_res = MCP3221_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3221_OUTPUT_SCALE;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">index 50fea6c..c0d183a 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_chunk">@@ -62,6 +62,9 @@</span> <span class="p_context"></span>
 #define	AT91_TWI_UNRE		0x0080	/* Underrun Error */
 #define	AT91_TWI_NACK		0x0100	/* Not Acknowledged */
 
<span class="p_add">+#define	AT91_TWI_INT_MASK \</span>
<span class="p_add">+	(AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY | AT91_TWI_NACK)</span>
<span class="p_add">+</span>
 #define	AT91_TWI_IER		0x0024	/* Interrupt Enable Register */
 #define	AT91_TWI_IDR		0x0028	/* Interrupt Disable Register */
 #define	AT91_TWI_IMR		0x002c	/* Interrupt Mask Register */
<span class="p_chunk">@@ -117,13 +120,12 @@</span> <span class="p_context"> static void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)</span>
 
 static void at91_disable_twi_interrupts(struct at91_twi_dev *dev)
 {
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IDR,</span>
<span class="p_del">-		       AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);</span>
 }
 
 static void at91_twi_irq_save(struct at91_twi_dev *dev)
 {
<span class="p_del">-	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; 0x7;</span>
<span class="p_add">+	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; AT91_TWI_INT_MASK;</span>
 	at91_disable_twi_interrupts(dev);
 }
 
<span class="p_chunk">@@ -213,6 +215,14 @@</span> <span class="p_context"> static void at91_twi_write_data_dma_callback(void *data)</span>
 	dma_unmap_single(dev-&gt;dev, sg_dma_address(&amp;dev-&gt;dma.sg),
 			 dev-&gt;buf_len, DMA_TO_DEVICE);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When this callback is called, THR/TX FIFO is likely not to be empty</span>
<span class="p_add">+	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the</span>
<span class="p_add">+	 * Status Register to be sure that the STOP bit has been sent and the</span>
<span class="p_add">+	 * transfer is completed. The NACK interrupt has already been enabled,</span>
<span class="p_add">+	 * we just have to enable TXCOMP one.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);
 }
 
<span class="p_chunk">@@ -307,7 +317,7 @@</span> <span class="p_context"> static void at91_twi_read_data_dma_callback(void *data)</span>
 	/* The last two bytes have to be read without using dma */
 	dev-&gt;buf += dev-&gt;buf_len - 2;
 	dev-&gt;buf_len = 2;
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY | AT91_TWI_TXCOMP);</span>
 }
 
 static void at91_twi_read_data_dma(struct at91_twi_dev *dev)
<span class="p_chunk">@@ -368,7 +378,7 @@</span> <span class="p_context"> static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)</span>
 	/* catch error flags */
 	dev-&gt;transfer_status |= status;
 
<span class="p_del">-	if (irqstatus &amp; AT91_TWI_TXCOMP) {</span>
<span class="p_add">+	if (irqstatus &amp; (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {</span>
 		at91_disable_twi_interrupts(dev);
 		complete(&amp;dev-&gt;cmd_complete);
 	}
<span class="p_chunk">@@ -381,6 +391,34 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	int ret;
 	bool has_unre_flag = dev-&gt;pdata-&gt;has_unre_flag;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on</span>
<span class="p_add">+	 * read flag but shows the state of the transmission at the time the</span>
<span class="p_add">+	 * Status Register is read. According to the programmer datasheet,</span>
<span class="p_add">+	 * TXCOMP is set when both holding register and internal shifter are</span>
<span class="p_add">+	 * empty and STOP condition has been sent.</span>
<span class="p_add">+	 * Consequently, we should enable NACK interrupt rather than TXCOMP to</span>
<span class="p_add">+	 * detect transmission failure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Besides, the TXCOMP bit is already set before the i2c transaction</span>
<span class="p_add">+	 * has been started. For read transactions, this bit is cleared when</span>
<span class="p_add">+	 * writing the START bit into the Control Register. So the</span>
<span class="p_add">+	 * corresponding interrupt can safely be enabled just after.</span>
<span class="p_add">+	 * However for write transactions managed by the CPU, we first write</span>
<span class="p_add">+	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP</span>
<span class="p_add">+	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,</span>
<span class="p_add">+	 * the interrupt handler would be called immediately and the i2c command</span>
<span class="p_add">+	 * would be reported as completed.</span>
<span class="p_add">+	 * Also when a write transaction is managed by the DMA controller,</span>
<span class="p_add">+	 * enabling the TXCOMP interrupt in this function may lead to a race</span>
<span class="p_add">+	 * condition since we don&#39;t know whether the TXCOMP interrupt is enabled</span>
<span class="p_add">+	 * before or after the DMA has started to write into THR. So the TXCOMP</span>
<span class="p_add">+	 * interrupt is enabled later by at91_twi_write_data_dma_callback().</span>
<span class="p_add">+	 * Immediately after in that DMA callback, we still need to send the</span>
<span class="p_add">+	 * STOP condition manually writing the corresponding bit into the</span>
<span class="p_add">+	 * Control Register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	dev_dbg(dev-&gt;dev, &quot;transfer: %s %d bytes.\n&quot;,
 		(dev-&gt;msg-&gt;flags &amp; I2C_M_RD) ? &quot;read&quot; : &quot;write&quot;, dev-&gt;buf_len);
 
<span class="p_chunk">@@ -411,26 +449,24 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 		 * seems to be the best solution.
 		 */
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_read_data_dma(dev);
<span class="p_del">-			/*</span>
<span class="p_del">-			 * It is important to enable TXCOMP irq here because</span>
<span class="p_del">-			 * doing it only when transferring the last two bytes</span>
<span class="p_del">-			 * will mask NACK errors since TXCOMP is set when a</span>
<span class="p_del">-			 * NACK occurs.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER,</span>
<span class="p_del">-			       AT91_TWI_TXCOMP);</span>
<span class="p_del">-		} else</span>
<span class="p_add">+		} else {</span>
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-			       AT91_TWI_TXCOMP | AT91_TWI_RXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_RXRDY);</span>
<span class="p_add">+		}</span>
 	} else {
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_write_data_dma(dev);
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 		} else {
 			at91_twi_write_next_byte(dev);
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-				AT91_TWI_TXCOMP | AT91_TWI_TXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_TXRDY);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/i2c/i2c-mux.c b/drivers/i2c/i2c-mux.c</span>
<span class="p_header">index 2d0847b..4bcefdb 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-mux.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-mux.c</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"> static int i2c_mux_master_xfer(struct i2c_adapter *adap,</span>
 
 	ret = priv-&gt;select(parent, priv-&gt;mux_priv, priv-&gt;chan_id);
 	if (ret &gt;= 0)
<span class="p_del">-		ret = parent-&gt;algo-&gt;master_xfer(parent, msgs, num);</span>
<span class="p_add">+		ret = __i2c_transfer(parent, msgs, num);</span>
 	if (priv-&gt;deselect)
 		priv-&gt;deselect(parent, priv-&gt;mux_priv, priv-&gt;chan_id);
 
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca9541.c b/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_header">index c4f08ad..c0b2d30 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int pca9541_reg_write(struct i2c_client *client, u8 command, u8 val)</span>
 		buf[0] = command;
 		buf[1] = val;
 		msg.buf = buf;
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, &amp;msg, 1);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, &amp;msg, 1);</span>
 	} else {
 		union i2c_smbus_data data;
 
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> static int pca9541_reg_read(struct i2c_client *client, u8 command)</span>
 				.buf = &amp;val
 			}
 		};
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, msg, 2);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, msg, 2);</span>
 		if (ret == 2)
 			ret = val;
 		else if (ret &gt;= 0)
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">index bad5b84..0a87600 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_chunk">@@ -133,7 +133,7 @@</span> <span class="p_context"> static int pca954x_reg_write(struct i2c_adapter *adap,</span>
 		msg.len = 1;
 		buf[0] = val;
 		msg.buf = buf;
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, &amp;msg, 1);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, &amp;msg, 1);</span>
 	} else {
 		union i2c_smbus_data data;
 		ret = adap-&gt;algo-&gt;smbus_xfer(adap, client-&gt;addr,
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 1d3e371..1d7745c6 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1922,9 +1922,15 @@</span> <span class="p_context"> static void free_pt_##LVL (unsigned long __pt)			\</span>
 	pt = (u64 *)__pt;					\
 								\
 	for (i = 0; i &lt; 512; ++i) {				\
<span class="p_add">+		/* PTE present? */				\</span>
 		if (!IOMMU_PTE_PRESENT(pt[i]))			\
 			continue;				\
 								\
<span class="p_add">+		/* Large PTE? */				\</span>
<span class="p_add">+		if (PM_PTE_LEVEL(pt[i]) == 0 ||			\</span>
<span class="p_add">+		    PM_PTE_LEVEL(pt[i]) == 7)			\</span>
<span class="p_add">+			continue;				\</span>
<span class="p_add">+								\</span>
 		p = (unsigned long)IOMMU_PTE_PAGE(pt[i]);	\
 		FN(p);						\
 	}							\
<span class="p_header">diff --git a/drivers/leds/led-class.c b/drivers/leds/led-class.c</span>
<span class="p_header">index f37d63c..825545c 100644</span>
<span class="p_header">--- a/drivers/leds/led-class.c</span>
<span class="p_header">+++ b/drivers/leds/led-class.c</span>
<span class="p_chunk">@@ -178,6 +178,7 @@</span> <span class="p_context"> void led_classdev_resume(struct led_classdev *led_cdev)</span>
 }
 EXPORT_SYMBOL_GPL(led_classdev_resume);
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
 static int led_suspend(struct device *dev)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
<span class="p_chunk">@@ -197,11 +198,9 @@</span> <span class="p_context"> static int led_resume(struct device *dev)</span>
 
 	return 0;
 }
<span class="p_add">+#endif</span>
 
<span class="p_del">-static const struct dev_pm_ops leds_class_dev_pm_ops = {</span>
<span class="p_del">-	.suspend        = led_suspend,</span>
<span class="p_del">-	.resume         = led_resume,</span>
<span class="p_del">-};</span>
<span class="p_add">+static SIMPLE_DEV_PM_OPS(leds_class_dev_pm_ops, led_suspend, led_resume);</span>
 
 /**
  * led_classdev_register - register a new object of led_classdev class.
<span class="p_header">diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c</span>
<span class="p_header">index 28a9012..b3b0697 100644</span>
<span class="p_header">--- a/drivers/md/dm-stats.c</span>
<span class="p_header">+++ b/drivers/md/dm-stats.c</span>
<span class="p_chunk">@@ -795,6 +795,8 @@</span> <span class="p_context"> static int message_stats_create(struct mapped_device *md,</span>
 		return -EINVAL;
 
 	if (sscanf(argv[2], &quot;/%u%c&quot;, &amp;divisor, &amp;dummy) == 1) {
<span class="p_add">+		if (!divisor)</span>
<span class="p_add">+			return -EINVAL;</span>
 		step = end - start;
 		if (do_div(step, divisor))
 			step++;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index 579b582..8ce970c 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -204,6 +204,27 @@</span> <span class="p_context"> static void in(struct sm_metadata *smm)</span>
 	smm-&gt;recursion_count++;
 }
 
<span class="p_add">+static int apply_bops(struct sm_metadata *smm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int r = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_add">+		struct block_op bop;</span>
<span class="p_add">+</span>
<span class="p_add">+		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		r = commit_bop(smm, &amp;bop);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int out(struct sm_metadata *smm)
 {
 	int r = 0;
<span class="p_chunk">@@ -216,21 +237,8 @@</span> <span class="p_context"> static int out(struct sm_metadata *smm)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	if (smm-&gt;recursion_count == 1) {</span>
<span class="p_del">-		while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_del">-			struct block_op bop;</span>
<span class="p_del">-</span>
<span class="p_del">-			r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_del">-			if (r) {</span>
<span class="p_del">-				DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			r = commit_bop(smm, &amp;bop);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (smm-&gt;recursion_count == 1)</span>
<span class="p_add">+		apply_bops(smm);</span>
 
 	smm-&gt;recursion_count--;
 
<span class="p_chunk">@@ -700,6 +708,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 		}
 		old_len = smm-&gt;begin;
 
<span class="p_add">+		r = apply_bops(smm);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		r = sm_ll_commit(&amp;smm-&gt;ll);
 		if (r)
 			goto out;
<span class="p_chunk">@@ -767,6 +781,12 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	if (r)
 		return r;
 
<span class="p_add">+	r = apply_bops(smm);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return sm_metadata_commit(sm);
 }
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">index fb504f1..5930aee 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_chunk">@@ -606,6 +606,10 @@</span> <span class="p_context"> static int af9013_set_frontend(struct dvb_frontend *fe)</span>
 			}
 		}
 
<span class="p_add">+		/* Return an error if can&#39;t find bandwidth or the right clock */</span>
<span class="p_add">+		if (i == ARRAY_SIZE(coeff_lut))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24116.c b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">index 2916d7c..7bc68b3 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_chunk">@@ -963,6 +963,10 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	struct cx24116_state *state = fe-&gt;demodulator_priv;
 	int i, ret;
 
<span class="p_add">+	/* Validate length */</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
<span class="p_add">+                return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO &quot;cx24116: %s(&quot;, __func__);
<span class="p_chunk">@@ -974,10 +978,6 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 		printk(&quot;) toneburst=%d\n&quot;, toneburst);
 	}
 
<span class="p_del">-	/* Validate length */</span>
<span class="p_del">-	if (d-&gt;msg_len &gt; (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DiSEqC message */
 	for (i = 0; i &lt; d-&gt;msg_len; i++)
 		state-&gt;dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d-&gt;msg[i];
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24117.c b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">index 0dbc067..a4bb6a1 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_chunk">@@ -1033,7 +1033,7 @@</span> <span class="p_context"> static int cx24117_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	dev_dbg(&amp;state-&gt;priv-&gt;i2c-&gt;dev, &quot;)\n&quot;);
 
 	/* Validate length */
<span class="p_del">-	if (d-&gt;msg_len &gt; 15)</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
 		return -EINVAL;
 
 	/* DiSEqC message */
<span class="p_header">diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">index 93eeaf7..0b4f8fe 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int s5h1420_send_master_cmd (struct dvb_frontend* fe,</span>
 	int result = 0;
 
 	dprintk(&quot;enter %s\n&quot;, __func__);
<span class="p_del">-	if (cmd-&gt;msg_len &gt; 8)</span>
<span class="p_add">+	if (cmd-&gt;msg_len &gt; sizeof(cmd-&gt;msg))</span>
 		return -EINVAL;
 
 	/* setup for DISEQC */
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 42e4c88..a651096 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1861,9 +1861,11 @@</span> <span class="p_context"> static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span>
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
<span class="p_del">-			if (!mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			goto cmd_abort;</span>
<span class="p_add">+			if (mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_add">+				goto cmd_abort;</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				goto start_new_req;</span>
<span class="p_add">+			break;</span>
 		case MMC_BLK_RETRY:
 			if (retry++ &lt; 5)
 				break;
<span class="p_header">diff --git a/drivers/mtd/maps/dc21285.c b/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">index f8a7dd1..70a3db3 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/dc21285.c</span>
<span class="p_chunk">@@ -38,9 +38,9 @@</span> <span class="p_context"> static void nw_en_write(void)</span>
 	 * we want to write a bit pattern XXX1 to Xilinx to enable
 	 * the write gate, which will be open for about the next 2ms.
 	 */
<span class="p_del">-	spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
 	nw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);
<span class="p_del">-	spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
 
 	/*
 	 * let the ISA bus to catch on...
<span class="p_header">diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">index 5073cbc..32d5e40 100644</span>
<span class="p_header">--- a/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">+++ b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_chunk">@@ -199,6 +199,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -222,6 +223,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 
 unlock:
 	dev-&gt;open++;
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -232,6 +234,7 @@</span> <span class="p_context"> error_release:</span>
 error_put:
 	module_put(dev-&gt;tr-&gt;owner);
 	kref_put(&amp;dev-&gt;ref, blktrans_dev_release);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -245,6 +248,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		return;
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (--dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -258,6 +262,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		__put_mtd_device(dev-&gt;mtd);
 	}
 unlock:
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 453437b..e23fbcc 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -293,6 +293,7 @@</span> <span class="p_context"> struct mvneta_port {</span>
 	unsigned int link;
 	unsigned int duplex;
 	unsigned int speed;
<span class="p_add">+	unsigned int tx_csum_limit;</span>
 };
 
 /* The mvneta_tx_desc and mvneta_rx_desc structures describe the
<span class="p_chunk">@@ -2280,8 +2281,10 @@</span> <span class="p_context"> static int mvneta_change_mtu(struct net_device *dev, int mtu)</span>
 
 	dev-&gt;mtu = mtu;
 
<span class="p_del">-	if (!netif_running(dev))</span>
<span class="p_add">+	if (!netif_running(dev)) {</span>
<span class="p_add">+		netdev_update_features(dev);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/* The interface is running, so we have to force a
 	 * reallocation of the RXQs
<span class="p_chunk">@@ -2304,9 +2307,26 @@</span> <span class="p_context"> static int mvneta_change_mtu(struct net_device *dev, int mtu)</span>
 	mvneta_start_dev(pp);
 	mvneta_port_up(pp);
 
<span class="p_add">+	netdev_update_features(dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_add">+static netdev_features_t mvneta_fix_features(struct net_device *dev,</span>
<span class="p_add">+					     netdev_features_t features)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mvneta_port *pp = netdev_priv(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pp-&gt;tx_csum_limit &amp;&amp; dev-&gt;mtu &gt; pp-&gt;tx_csum_limit) {</span>
<span class="p_add">+		features &amp;= ~(NETIF_F_IP_CSUM | NETIF_F_TSO);</span>
<span class="p_add">+		netdev_info(dev,</span>
<span class="p_add">+			    &quot;Disable IP checksum for MTU greater than %dB\n&quot;,</span>
<span class="p_add">+			    pp-&gt;tx_csum_limit);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return features;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Get mac address */
 static void mvneta_get_mac_addr(struct mvneta_port *pp, unsigned char *addr)
 {
<span class="p_chunk">@@ -2623,6 +2643,7 @@</span> <span class="p_context"> static const struct net_device_ops mvneta_netdev_ops = {</span>
 	.ndo_set_rx_mode     = mvneta_set_rx_mode,
 	.ndo_set_mac_address = mvneta_set_mac_addr,
 	.ndo_change_mtu      = mvneta_change_mtu,
<span class="p_add">+	.ndo_fix_features    = mvneta_fix_features,</span>
 	.ndo_get_stats64     = mvneta_get_stats64,
 	.ndo_do_ioctl        = mvneta_ioctl,
 };
<span class="p_chunk">@@ -2846,6 +2867,9 @@</span> <span class="p_context"> static int mvneta_probe(struct platform_device *pdev)</span>
 		}
 	}
 
<span class="p_add">+	if (of_device_is_compatible(dn, &quot;marvell,armada-370-neta&quot;))</span>
<span class="p_add">+		pp-&gt;tx_csum_limit = 1600;</span>
<span class="p_add">+</span>
 	pp-&gt;tx_ring_size = MVNETA_MAX_TXD;
 	pp-&gt;rx_ring_size = MVNETA_MAX_RXD;
 
<span class="p_chunk">@@ -2917,6 +2941,7 @@</span> <span class="p_context"> static int mvneta_remove(struct platform_device *pdev)</span>
 
 static const struct of_device_id mvneta_match[] = {
 	{ .compatible = &quot;marvell,armada-370-neta&quot; },
<span class="p_add">+	{ .compatible = &quot;marvell,armada-xp-neta&quot; },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(of, mvneta_match);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index 5db6849..cc15399 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -194,11 +194,13 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc)</span>
 
 	ath9k_hw_disable_interrupts(ah);
 
<span class="p_del">-	if (!ath_drain_all_txq(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ath_stoprecv(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_add">+	if (AR_SREV_9300_20_OR_LATER(ah)) {</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/wireless/rndis_wlan.c b/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_header">index 8169a85..14fa655 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_chunk">@@ -358,9 +358,9 @@</span> <span class="p_context"> struct ndis_80211_pmkid {</span>
 #define CAP_MODE_80211G		4
 #define CAP_MODE_MASK		7
 
<span class="p_del">-#define WORK_LINK_UP		(1&lt;&lt;0)</span>
<span class="p_del">-#define WORK_LINK_DOWN		(1&lt;&lt;1)</span>
<span class="p_del">-#define WORK_SET_MULTICAST_LIST	(1&lt;&lt;2)</span>
<span class="p_add">+#define WORK_LINK_UP		0</span>
<span class="p_add">+#define WORK_LINK_DOWN		1</span>
<span class="p_add">+#define WORK_SET_MULTICAST_LIST	2</span>
 
 #define RNDIS_WLAN_ALG_NONE	0
 #define RNDIS_WLAN_ALG_WEP	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 6c0dcf5..6996c77 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(of_n_size_cells);</span>
 #ifdef CONFIG_NUMA
 int __weak of_node_to_nid(struct device_node *np)
 {
<span class="p_del">-	return numa_node_id();</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/pcmcia/topic.h b/drivers/pcmcia/topic.h</span>
<span class="p_header">index 615a45a..582688fe 100644</span>
<span class="p_header">--- a/drivers/pcmcia/topic.h</span>
<span class="p_header">+++ b/drivers/pcmcia/topic.h</span>
<span class="p_chunk">@@ -104,6 +104,9 @@</span> <span class="p_context"></span>
 #define TOPIC_EXCA_IF_CONTROL		0x3e	/* 8 bit */
 #define TOPIC_EXCA_IFC_33V_ENA		0x01
 
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN		0x3e	/* 16-bit */</span>
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN_WBEN	0x0400</span>
<span class="p_add">+</span>
 static void topic97_zoom_video(struct pcmcia_socket *sock, int onoff)
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
<span class="p_chunk">@@ -138,6 +141,7 @@</span> <span class="p_context"> static int topic97_override(struct yenta_socket *socket)</span>
 static int topic95_override(struct yenta_socket *socket)
 {
 	u8 fctrl;
<span class="p_add">+	u16 ppbcn;</span>
 
 	/* enable 3.3V support for 16bit cards */
 	fctrl = exca_readb(socket, TOPIC_EXCA_IF_CONTROL);
<span class="p_chunk">@@ -146,6 +150,18 @@</span> <span class="p_context"> static int topic95_override(struct yenta_socket *socket)</span>
 	/* tell yenta to use exca registers to power 16bit cards */
 	socket-&gt;flags |= YENTA_16BIT_POWER_EXCA | YENTA_16BIT_POWER_DF;
 
<span class="p_add">+	/* Disable write buffers to prevent lockups under load with numerous</span>
<span class="p_add">+	   Cardbus cards, observed on Tecra 500CDT and reported elsewhere on the</span>
<span class="p_add">+	   net.  This is not a power-on default according to the datasheet</span>
<span class="p_add">+	   but some BIOSes seem to set it. */</span>
<span class="p_add">+	if (pci_read_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, &amp;ppbcn) == 0</span>
<span class="p_add">+	    &amp;&amp; socket-&gt;dev-&gt;revision &lt;= 7</span>
<span class="p_add">+	    &amp;&amp; (ppbcn &amp; TOPIC_PCI_CFG_PPBCN_WBEN)) {</span>
<span class="p_add">+		ppbcn &amp;= ~TOPIC_PCI_CFG_PPBCN_WBEN;</span>
<span class="p_add">+		pci_write_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, ppbcn);</span>
<span class="p_add">+		dev_info(&amp;socket-&gt;dev-&gt;dev, &quot;Disabled ToPIC95 Cardbus write buffers.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-370.c b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">index ae1f760..bb525b1 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_chunk">@@ -358,11 +358,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6710_mpp_modes[] = {</span>
 	MPP_MODE(64,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;miso&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs1&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs1&quot;)),</span>
 	MPP_MODE(65,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;mosi&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs2&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs2&quot;)),</span>
 };
 
 static struct mvebu_pinctrl_soc_info armada_370_pinctrl_info;
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">index 843a51f..d918c51 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_chunk">@@ -14,10 +14,7 @@</span> <span class="p_context"></span>
  * available: mv78230, mv78260 and mv78460. From a pin muxing
  * perspective, the mv78230 has 49 MPP pins. The mv78260 and mv78460
  * both have 67 MPP pins (more GPIOs and address lines for the memory
<span class="p_del">- * bus mainly). The only difference between the mv78260 and the</span>
<span class="p_del">- * mv78460 in terms of pin muxing is the addition of two functions on</span>
<span class="p_del">- * pins 43 and 56 to access the VDD of the CPU2 and 3 (mv78260 has two</span>
<span class="p_del">- * cores, mv78460 has four cores).</span>
<span class="p_add">+ * bus mainly).</span>
  */
 
 #include &lt;linux/err.h&gt;
<span class="p_chunk">@@ -159,20 +156,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(24,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata1&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-re&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;rst&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;hsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(25,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata0&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-we&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;pclk&quot;,       V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(26,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;fsync&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS)),</span>
 	MPP_MODE(27,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;trig&quot;,       V_MV78230_PLUS),
<span class="p_chunk">@@ -187,8 +181,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int0&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(30,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
<span class="p_chunk">@@ -196,13 +189,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(31,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;cmd&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(32,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d0&quot;,         V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(33,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d1&quot;,         V_MV78230_PLUS),
<span class="p_chunk">@@ -234,7 +225,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;spi&quot;, &quot;cs1&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vga-hsync&quot;,  V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq0&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(41,
<span class="p_chunk">@@ -249,15 +239,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;rxd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int7&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(43,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;txd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;rts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;spi&quot;, &quot;cs3&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_chunk">@@ -286,7 +274,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq3&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;tclk&quot;, NULL,        V_MV78230_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;clkout&quot;,     V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x2, &quot;dev&quot;, &quot;burst/last&quot;, V_MV78230_PLUS)),
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_chunk">@@ -308,16 +296,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad19&quot;,       V_MV78260_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(56,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(57,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(58,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad23&quot;,       V_MV78260_PLUS)),
<span class="p_header">diff --git a/drivers/platform/x86/dell-laptop.c b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">index c608b1d..eb1b398 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_chunk">@@ -272,7 +272,6 @@</span> <span class="p_context"> static struct dmi_system_id dell_quirks[] = {</span>
 };
 
 static struct calling_interface_buffer *buffer;
<span class="p_del">-static struct page *bufferpage;</span>
 static DEFINE_MUTEX(buffer_mutex);
 
 static int hwswitch_state;
<span class="p_chunk">@@ -814,12 +813,11 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 	 * Allocate buffer below 4GB for SMI data--only 32-bit physical addr
 	 * is passed to SMI handler.
 	 */
<span class="p_del">-	bufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_del">-	if (!bufferpage) {</span>
<span class="p_add">+	buffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_add">+	if (!buffer) {</span>
 		ret = -ENOMEM;
 		goto fail_buffer;
 	}
<span class="p_del">-	buffer = page_address(bufferpage);</span>
 
 	ret = dell_setup_rfkill();
 
<span class="p_chunk">@@ -888,7 +886,7 @@</span> <span class="p_context"> fail_backlight:</span>
 fail_filter:
 	dell_cleanup_rfkill();
 fail_rfkill:
<span class="p_del">-	free_page((unsigned long)bufferpage);</span>
<span class="p_add">+	free_page((unsigned long)buffer);</span>
 fail_buffer:
 	platform_device_del(platform_device);
 fail_platform_device2:
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index 19ec951..0a13f7d 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -462,8 +462,9 @@</span> <span class="p_context"> const struct ideapad_rfk_data ideapad_rfk_data[] = {</span>
 static int ideapad_rfk_set(void *data, bool blocked)
 {
 	struct ideapad_rfk_priv *priv = data;
<span class="p_add">+	int opcode = ideapad_rfk_data[priv-&gt;dev].opcode;</span>
 
<span class="p_del">-	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, priv-&gt;dev, !blocked);</span>
<span class="p_add">+	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, opcode, !blocked);</span>
 }
 
 static struct rfkill_ops ideapad_rfk_ops = {
<span class="p_header">diff --git a/drivers/pnp/system.c b/drivers/pnp/system.c</span>
<span class="p_header">index 49c1720..515f338 100644</span>
<span class="p_header">--- a/drivers/pnp/system.c</span>
<span class="p_header">+++ b/drivers/pnp/system.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
  *	Bjorn Helgaas &lt;bjorn.helgaas@hp.com&gt;
  */
 
<span class="p_add">+#include &lt;linux/acpi.h&gt;</span>
 #include &lt;linux/pnp.h&gt;
 #include &lt;linux/device.h&gt;
 #include &lt;linux/init.h&gt;
<span class="p_chunk">@@ -22,25 +23,41 @@</span> <span class="p_context"> static const struct pnp_device_id pnp_dev_table[] = {</span>
 	{&quot;&quot;, 0}
 };
 
<span class="p_add">+#ifdef CONFIG_ACPI</span>
<span class="p_add">+static bool __reserve_range(u64 start, unsigned int length, bool io, char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 space_id = io ? ACPI_ADR_SPACE_SYSTEM_IO : ACPI_ADR_SPACE_SYSTEM_MEMORY;</span>
<span class="p_add">+	return !acpi_reserve_region(start, length, space_id, IORESOURCE_BUSY, desc);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static bool __reserve_range(u64 start, unsigned int length, bool io, char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = io ? request_region(start, length, desc) :</span>
<span class="p_add">+		request_mem_region(start, length, desc);</span>
<span class="p_add">+	if (res) {</span>
<span class="p_add">+		res-&gt;flags &amp;= ~IORESOURCE_BUSY;</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static void reserve_range(struct pnp_dev *dev, struct resource *r, int port)
 {
 	char *regionid;
 	const char *pnpid = dev_name(&amp;dev-&gt;dev);
 	resource_size_t start = r-&gt;start, end = r-&gt;end;
<span class="p_del">-	struct resource *res;</span>
<span class="p_add">+	bool reserved;</span>
 
 	regionid = kmalloc(16, GFP_KERNEL);
 	if (!regionid)
 		return;
 
 	snprintf(regionid, 16, &quot;pnp %s&quot;, pnpid);
<span class="p_del">-	if (port)</span>
<span class="p_del">-		res = request_region(start, end - start + 1, regionid);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		res = request_mem_region(start, end - start + 1, regionid);</span>
<span class="p_del">-	if (res)</span>
<span class="p_del">-		res-&gt;flags &amp;= ~IORESOURCE_BUSY;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	reserved = __reserve_range(start, end - start + 1, !!port, regionid);</span>
<span class="p_add">+	if (!reserved)</span>
 		kfree(regionid);
 
 	/*
<span class="p_chunk">@@ -49,7 +66,7 @@</span> <span class="p_context"> static void reserve_range(struct pnp_dev *dev, struct resource *r, int port)</span>
 	 * have double reservations.
 	 */
 	dev_info(&amp;dev-&gt;dev, &quot;%pR %s reserved\n&quot;, r,
<span class="p_del">-		 res ? &quot;has been&quot; : &quot;could not be&quot;);</span>
<span class="p_add">+		 reserved ? &quot;has been&quot; : &quot;could not be&quot;);</span>
 }
 
 static void reserve_resources_of_dev(struct pnp_dev *dev)
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index 3427e35..d1db4fb 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -773,7 +773,7 @@</span> <span class="p_context"> static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)</span>
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev-&gt;constraints;
<span class="p_del">-	char buf[80] = &quot;&quot;;</span>
<span class="p_add">+	char buf[160] = &quot;&quot;;</span>
 	int count = 0;
 	int ret;
 
<span class="p_header">diff --git a/drivers/s390/kvm/virtio_ccw.c b/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_header">index d629717..9effcf5 100644</span>
<span class="p_header">--- a/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_header">+++ b/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_chunk">@@ -58,6 +58,7 @@</span> <span class="p_context"> struct virtio_ccw_device {</span>
 	unsigned long indicators;
 	unsigned long indicators2;
 	struct vq_config_block *config_block;
<span class="p_add">+	unsigned int config_ready;</span>
 };
 
 struct vq_info_block {
<span class="p_chunk">@@ -504,8 +505,11 @@</span> <span class="p_context"> static void virtio_ccw_get_config(struct virtio_device *vdev,</span>
 	if (ret)
 		goto out_free;
 
<span class="p_del">-	memcpy(vcdev-&gt;config, config_area, sizeof(vcdev-&gt;config));</span>
<span class="p_del">-	memcpy(buf, &amp;vcdev-&gt;config[offset], len);</span>
<span class="p_add">+	memcpy(vcdev-&gt;config, config_area, offset + len);</span>
<span class="p_add">+	if (buf)</span>
<span class="p_add">+		memcpy(buf, &amp;vcdev-&gt;config[offset], len);</span>
<span class="p_add">+	if (vcdev-&gt;config_ready &lt; offset + len)</span>
<span class="p_add">+		vcdev-&gt;config_ready = offset + len;</span>
 
 out_free:
 	kfree(config_area);
<span class="p_chunk">@@ -528,6 +532,9 @@</span> <span class="p_context"> static void virtio_ccw_set_config(struct virtio_device *vdev,</span>
 	if (!config_area)
 		goto out_free;
 
<span class="p_add">+	/* Make sure we don&#39;t overwrite fields. */</span>
<span class="p_add">+	if (vcdev-&gt;config_ready &lt; offset)</span>
<span class="p_add">+		virtio_ccw_get_config(vdev, 0, NULL, offset);</span>
 	memcpy(&amp;vcdev-&gt;config[offset], buf, len);
 	/* Write the config area to the host. */
 	memcpy(config_area, vcdev-&gt;config, sizeof(vcdev-&gt;config));
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index aac8293..c01e581 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -264,7 +264,7 @@</span> <span class="p_context"></span>
 #define IPR_RUNTIME_RESET				0x40000000
 
 #define IPR_IPL_INIT_MIN_STAGE_TIME			5
<span class="p_del">-#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 15</span>
<span class="p_add">+#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 30</span>
 #define IPR_IPL_INIT_STAGE_UNKNOWN			0x0
 #define IPR_IPL_INIT_STAGE_TRANSOP			0xB0000000
 #define IPR_IPL_INIT_STAGE_MASK				0xff000000
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_srp.c b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">index 2700a5a..4c25a86 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_chunk">@@ -389,6 +389,36 @@</span> <span class="p_context"> static void srp_reconnect_work(struct work_struct *work)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_add">+ * @shost: SCSI host for which to count the number of scsi_request_fn() callers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To do: add support for scsi-mq in this function.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct scsi_device *sdev;</span>
<span class="p_add">+	struct request_queue *q;</span>
<span class="p_add">+	int request_fn_active = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	shost_for_each_device(sdev, shost) {</span>
<span class="p_add">+		q = sdev-&gt;request_queue;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_add">+		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return request_fn_active;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Wait until ongoing shost-&gt;hostt-&gt;queuecommand() calls have finished. */</span>
<span class="p_add">+static void srp_wait_for_queuecommand(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (scsi_request_fn_active(shost))</span>
<span class="p_add">+		msleep(20);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __rport_fail_io_fast(struct srp_rport *rport)
 {
 	struct Scsi_Host *shost = rport_to_shost(rport);
<span class="p_chunk">@@ -402,8 +432,10 @@</span> <span class="p_context"> static void __rport_fail_io_fast(struct srp_rport *rport)</span>
 
 	/* Involve the LLD if possible to terminate all I/O on the rport. */
 	i = to_srp_internal(shost-&gt;transportt);
<span class="p_del">-	if (i-&gt;f-&gt;terminate_rport_io)</span>
<span class="p_add">+	if (i-&gt;f-&gt;terminate_rport_io) {</span>
<span class="p_add">+		srp_wait_for_queuecommand(shost);</span>
 		i-&gt;f-&gt;terminate_rport_io(rport);
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -501,26 +533,6 @@</span> <span class="p_context"> void srp_start_tl_fail_timers(struct srp_rport *rport)</span>
 EXPORT_SYMBOL(srp_start_tl_fail_timers);
 
 /**
<span class="p_del">- * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_del">- */</span>
<span class="p_del">-static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_device *sdev;</span>
<span class="p_del">-	struct request_queue *q;</span>
<span class="p_del">-	int request_fn_active = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	shost_for_each_device(sdev, shost) {</span>
<span class="p_del">-		q = sdev-&gt;request_queue;</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_del">-		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return request_fn_active;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * srp_reconnect_rport() - reconnect to an SRP target port
  *
  * Blocks SCSI command queueing before invoking reconnect() such that
<span class="p_chunk">@@ -554,8 +566,7 @@</span> <span class="p_context"> int srp_reconnect_rport(struct srp_rport *rport)</span>
 	if (res)
 		goto out;
 	scsi_target_block(&amp;shost-&gt;shost_gendev);
<span class="p_del">-	while (scsi_request_fn_active(shost))</span>
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+	srp_wait_for_queuecommand(shost);</span>
 	res = i-&gt;f-&gt;reconnect(rport);
 	pr_debug(&quot;%s (state %d): transport.reconnect() returned %d\n&quot;,
 		 dev_name(&amp;shost-&gt;shost_gendev), rport-&gt;state, res);
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index 5fc2f0a..8cdd422 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -817,9 +817,6 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 
 	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);
 	mesg = master-&gt;cur_msg;
<span class="p_del">-	master-&gt;cur_msg = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
 	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);
 
 	if (master-&gt;cur_msg_prepared &amp;&amp; master-&gt;unprepare_message) {
<span class="p_chunk">@@ -830,9 +827,13 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 		}
 	}
 
<span class="p_del">-	trace_spi_message_done(mesg);</span>
<span class="p_del">-</span>
<span class="p_add">+	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+	master-&gt;cur_msg = NULL;</span>
 	master-&gt;cur_msg_prepared = false;
<span class="p_add">+	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_spi_message_done(mesg);</span>
 
 	mesg-&gt;state = NULL;
 	if (mesg-&gt;complete)
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">index ea96537..d060b1f 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_chunk">@@ -1075,7 +1075,8 @@</span> <span class="p_context"> static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)</span>
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) &amp;&amp; (frag == 0))
<span class="p_del">-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			alloc_sz = max_t(u16, tmp_len, 1658);</span>
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index d3e8336a..6f396a4 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -1471,6 +1471,10 @@</span> <span class="p_context"> static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {</span>
 //        DBG_PRT(MSG_LEVEL_DEBUG, KERN_INFO &quot;pDevice-&gt;pCurrRD = %x, works = %d\n&quot;, pRD, works);
 		if (works++ &gt; 15)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		if (!pRD-&gt;pRDInfo-&gt;skb)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		if (device_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
 				DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index ce396ec..c565bf6 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -54,9 +54,6 @@</span> <span class="p_context"></span>
 static int __read_mostly sysrq_enabled = CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE;
 static bool __read_mostly sysrq_always_enabled;
 
<span class="p_del">-unsigned short platform_sysrq_reset_seq[] __weak = { KEY_RESERVED };</span>
<span class="p_del">-int sysrq_reset_downtime_ms __weak;</span>
<span class="p_del">-</span>
 static bool sysrq_on(void)
 {
 	return sysrq_enabled || sysrq_always_enabled;
<span class="p_chunk">@@ -565,6 +562,7 @@</span> <span class="p_context"> void handle_sysrq(int key)</span>
 EXPORT_SYMBOL(handle_sysrq);
 
 #ifdef CONFIG_INPUT
<span class="p_add">+static int sysrq_reset_downtime_ms;</span>
 
 /* Simple translation table for the SysRq keys */
 static const unsigned char sysrq_xlate[KEY_CNT] =
<span class="p_chunk">@@ -945,23 +943,8 @@</span> <span class="p_context"> static bool sysrq_handler_registered;</span>
 
 static inline void sysrq_register_handler(void)
 {
<span class="p_del">-	unsigned short key;</span>
 	int error;
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First check if a __weak interface was instantiated. */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(sysrq_reset_seq); i++) {</span>
<span class="p_del">-		key = platform_sysrq_reset_seq[i];</span>
<span class="p_del">-		if (key == KEY_RESERVED || key &gt; KEY_MAX)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		sysrq_reset_seq[sysrq_reset_seq_len++] = key;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * DT configuration takes precedence over anything that would</span>
<span class="p_del">-	 * have been defined via the __weak interface.</span>
<span class="p_del">-	 */</span>
 	sysrq_of_get_keyreset_config();
 
 	error = input_register_handler(&amp;sysrq_handler);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 46321cd..06cdbb4 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1336,6 +1336,11 @@</span> <span class="p_context"> skip_countries:</span>
 		goto alloc_fail8;
 	}
 
<span class="p_add">+	if (quirks &amp; CLEAR_HALT_CONDITIONS) {</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress));</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, epwrite-&gt;bEndpointAddress));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 alloc_fail8:
 	if (acm-&gt;country_codes) {
<span class="p_chunk">@@ -1622,6 +1627,10 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
 
<span class="p_add">+	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */</span>
<span class="p_add">+	.driver_info = CLEAR_HALT_CONDITIONS,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* Nokia S60 phones expose two ACM channels. The first is
 	 * a modem and is picked up by the standard AT-command
 	 * information below. The second is &#39;vendor-specific&#39; but
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index 0f76e4a..9c40036 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -129,3 +129,4 @@</span> <span class="p_context"> struct acm {</span>
 #define NOT_A_MODEM			8
 #define NO_DATA_INTERFACE		16
 #define IGNORE_DEVICE			32
<span class="p_add">+#define CLEAR_HALT_CONDITIONS		128</span>
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 4c2c65b..7ae56bb 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	snoop(&amp;urb-&gt;dev-&gt;dev, &quot;urb complete\n&quot;);
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE, NULL, 0);
<span class="p_del">-	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == USB_DIR_IN)</span>
<span class="p_add">+	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN)</span>
 		snoop_urb_data(urb, urb-&gt;actual_length);
 
 	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 9d61876..5b154d2 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -2535,9 +2535,6 @@</span> <span class="p_context"> static unsigned hub_is_wusb(struct usb_hub *hub)</span>
 #define HUB_LONG_RESET_TIME	200
 #define HUB_RESET_TIMEOUT	800
 
<span class="p_del">-static int hub_port_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, unsigned int delay, bool warm);</span>
<span class="p_del">-</span>
 /* Is a USB 3.0 port in the Inactive or Complinance Mode state?
  * Port worm reset is required to recover
  */
<span class="p_chunk">@@ -2618,44 +2615,6 @@</span> <span class="p_context"> static int hub_port_wait_reset(struct usb_hub *hub, int port1,</span>
 	return 0;
 }
 
<span class="p_del">-static void hub_port_finish_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, int *status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (*status) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_del">-		msleep(10 + 40);</span>
<span class="p_del">-		if (udev) {</span>
<span class="p_del">-			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_del">-</span>
<span class="p_del">-			update_devnum(udev, 0);</span>
<span class="p_del">-			/* The xHC may think the device is already reset,</span>
<span class="p_del">-			 * so ignore the status.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_del">-				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* FALL THROUGH */</span>
<span class="p_del">-	case -ENOTCONN:</span>
<span class="p_del">-	case -ENODEV:</span>
<span class="p_del">-		usb_clear_port_feature(hub-&gt;hdev,</span>
<span class="p_del">-				port1, USB_PORT_FEAT_C_RESET);</span>
<span class="p_del">-		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (udev)</span>
<span class="p_del">-			usb_set_device_state(udev, *status</span>
<span class="p_del">-					? USB_STATE_NOTATTACHED</span>
<span class="p_del">-					: USB_STATE_DEFAULT);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */
 static int hub_port_reset(struct usb_hub *hub, int port1,
 			struct usb_device *udev, unsigned int delay, bool warm)
<span class="p_chunk">@@ -2678,13 +2637,9 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 		 * If the caller hasn&#39;t explicitly requested a warm reset,
 		 * double check and see if one is needed.
 		 */
<span class="p_del">-		status = hub_port_status(hub, port1,</span>
<span class="p_del">-					&amp;portstatus, &amp;portchange);</span>
<span class="p_del">-		if (status &lt; 0)</span>
<span class="p_del">-			goto done;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (hub_port_warm_reset_required(hub, portstatus))</span>
<span class="p_del">-			warm = true;</span>
<span class="p_add">+		if (hub_port_status(hub, port1, &amp;portstatus, &amp;portchange) == 0)</span>
<span class="p_add">+			if (hub_port_warm_reset_required(hub, portstatus))</span>
<span class="p_add">+				warm = true;</span>
 	}
 
 	/* Reset the port */
<span class="p_chunk">@@ -2709,11 +2664,19 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 
 		/* Check for disconnect or reset */
 		if (status == 0 || status == -ENOTCONN || status == -ENODEV) {
<span class="p_del">-			hub_port_finish_reset(hub, port1, udev, &amp;status);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_RESET);</span>
 
 			if (!hub_is_superspeed(hub-&gt;hdev))
 				goto done;
 
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_add">+</span>
 			/*
 			 * If a USB 3.0 device migrates from reset to an error
 			 * state, re-issue the warm reset.
<span class="p_chunk">@@ -2747,6 +2710,26 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 		port1);
 
 done:
<span class="p_add">+	if (status == 0) {</span>
<span class="p_add">+		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_add">+		msleep(10 + 40);</span>
<span class="p_add">+		if (udev) {</span>
<span class="p_add">+			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_add">+</span>
<span class="p_add">+			update_devnum(udev, 0);</span>
<span class="p_add">+			/* The xHC may think the device is already reset,</span>
<span class="p_add">+			 * so ignore the status.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_add">+				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_DEFAULT);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (udev)</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_NOTATTACHED);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!hub_is_superspeed(hub-&gt;hdev))
 		up_read(&amp;ehci_cf_port_reset_rwsem);
 
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index 09cf013..90a6406 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -134,6 +134,13 @@</span> <span class="p_context"> static int omap_wdt_start(struct watchdog_device *wdog)</span>
 
 	pm_runtime_get_sync(wdev-&gt;dev);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the watchdog is disabled. This is unfortunately required</span>
<span class="p_add">+	 * because writing to various registers with the watchdog running has no</span>
<span class="p_add">+	 * effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	omap_wdt_disable(wdev);</span>
<span class="p_add">+</span>
 	/* initialize prescaler */
 	while (readl_relaxed(base + OMAP_WATCHDOG_WPS) &amp; 0x01)
 		cpu_relax();
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 699af4e..9b3751a 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -2907,17 +2907,6 @@</span> <span class="p_context"> restart:</span>
 				vfsmnt = &amp;mnt-&gt;mnt;
 				continue;
 			}
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Filesystems needing to implement special &quot;root names&quot;</span>
<span class="p_del">-			 * should do so with -&gt;d_dname()</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (IS_ROOT(dentry) &amp;&amp;</span>
<span class="p_del">-			   (dentry-&gt;d_name.len != 1 ||</span>
<span class="p_del">-			    dentry-&gt;d_name.name[0] != &#39;/&#39;)) {</span>
<span class="p_del">-				WARN(1, &quot;Root dentry has weird name &lt;%.*s&gt;\n&quot;,</span>
<span class="p_del">-				     (int) dentry-&gt;d_name.len,</span>
<span class="p_del">-				     dentry-&gt;d_name.name);</span>
<span class="p_del">-			}</span>
 			if (!error)
 				error = is_mounted(vfsmnt) ? 1 : 2;
 			break;
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index 4353522..be26704 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -576,7 +576,7 @@</span> <span class="p_context"> int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, &quot;Can&#39;t allocate blocks for &quot;
 				 &quot;non-extent mapped inodes with bigalloc&quot;);
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_add">+		return -EUCLEAN;</span>
 	}
 
 	goal = ext4_find_goal(inode, map-&gt;m_lblk, partial);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 6040097..638de3d 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1749,19 +1749,32 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
<span class="p_del">-	/* As soon as we unlock the page, it can go away, but we have</span>
<span class="p_del">-	 * references to buffers so we are safe */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to release the page lock before we start the</span>
<span class="p_add">+	 * journal, so grab a reference so the page won&#39;t disappear</span>
<span class="p_add">+	 * out from under us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	get_page(page);</span>
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		goto out_no_pagelock;</span>
 	}
<span class="p_del">-</span>
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_add">+	lock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	if (page-&gt;mapping != mapping) {</span>
<span class="p_add">+		/* The page got truncated from under us */</span>
<span class="p_add">+		ext4_journal_stop(handle);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (inline_data) {
 		ret = ext4_journal_get_write_access(handle, inode_bh);
 
<span class="p_chunk">@@ -1786,6 +1799,8 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_no_pagelock:</span>
 	brelse(inode_bh);
 	return ret;
 }
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 9fb3e6c..a07af5b 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -832,6 +832,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
<span class="p_add">+	sync_blockdev(sb-&gt;s_bdev);</span>
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index 73f6bcb..faf00af 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -1026,6 +1026,7 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto err_fput;
 
 	fuse_conn_init(fc);
<span class="p_add">+	fc-&gt;release = fuse_free_conn;</span>
 
 	fc-&gt;dev = sb-&gt;s_dev;
 	fc-&gt;sb = sb;
<span class="p_chunk">@@ -1040,7 +1041,6 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		fc-&gt;dont_mask = 1;
 	sb-&gt;s_flags |= MS_POSIXACL;
 
<span class="p_del">-	fc-&gt;release = fuse_free_conn;</span>
 	fc-&gt;flags = d.flags;
 	fc-&gt;user_id = d.user_id;
 	fc-&gt;group_id = d.group_id;
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index d19b30a..a4a8ed5 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -1017,6 +1017,11 @@</span> <span class="p_context"> static int __init init_hugetlbfs_fs(void)</span>
 	int error;
 	int i;
 
<span class="p_add">+	if (!hugepages_supported()) {</span>
<span class="p_add">+		pr_info(&quot;hugetlbfs: disabling because there are no supported hugepage sizes\n&quot;);</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	error = bdi_init(&amp;hugetlbfs_backing_dev_info);
 	if (error)
 		return error;
<span class="p_header">diff --git a/fs/inode.c b/fs/inode.c</span>
<span class="p_header">index e846a32..644875b 100644</span>
<span class="p_header">--- a/fs/inode.c</span>
<span class="p_header">+++ b/fs/inode.c</span>
<span class="p_chunk">@@ -1631,8 +1631,8 @@</span> <span class="p_context"> int file_remove_suid(struct file *file)</span>
 		error = security_inode_killpriv(dentry);
 	if (!error &amp;&amp; killsuid)
 		error = __remove_suid(dentry, killsuid);
<span class="p_del">-	if (!error &amp;&amp; (inode-&gt;i_sb-&gt;s_flags &amp; MS_NOSEC))</span>
<span class="p_del">-		inode-&gt;i_flags |= S_NOSEC;</span>
<span class="p_add">+	if (!error)</span>
<span class="p_add">+		inode_has_no_xattr(inode);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 7f34f47..b892355 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	unsigned long	blocknr;
 
 	if (is_journal_aborted(journal))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EIO;</span>
 
 	if (!jbd2_journal_get_log_tail(journal, &amp;first_tid, &amp;blocknr))
 		return 1;
<span class="p_chunk">@@ -463,10 +463,9 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	 * jbd2_cleanup_journal_tail() doesn&#39;t get called all that often.
 	 */
 	if (journal-&gt;j_flags &amp; JBD2_BARRIER)
<span class="p_del">-		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_NOFS, NULL);</span>
 
<span class="p_del">-	__jbd2_update_log_tail(journal, first_tid, blocknr);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return __jbd2_update_log_tail(journal, first_tid, blocknr);</span>
 }
 
 
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index f2d78a3..e8d62d7 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -885,9 +885,10 @@</span> <span class="p_context"> int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
  *
  * Requires j_checkpoint_mutex
  */
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 {
 	unsigned long freed;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 
<span class="p_chunk">@@ -897,7 +898,10 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	 * space and if we lose sb update during power failure we&#39;d replay
 	 * old transaction with possibly newly overwritten data.
 	 */
<span class="p_del">-	jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
 	freed = block - journal-&gt;j_tail;
 	if (block &lt; journal-&gt;j_tail)
<span class="p_chunk">@@ -913,6 +917,9 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	journal-&gt;j_tail_sequence = tid;
 	journal-&gt;j_tail = block;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -1331,7 +1338,7 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 	return jbd2_journal_start_thread(journal);
 }
 
<span class="p_del">-static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
<span class="p_add">+static int jbd2_write_superblock(journal_t *journal, int write_op)</span>
 {
 	struct buffer_head *bh = journal-&gt;j_sb_buffer;
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_chunk">@@ -1370,7 +1377,10 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
 		printk(KERN_ERR &quot;JBD2: Error %d detected when updating &quot;
 		       &quot;journal superblock for %s.\n&quot;, ret,
 		       journal-&gt;j_devname);
<span class="p_add">+		jbd2_journal_abort(journal, ret);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1383,10 +1393,11 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
  * Update a journal&#39;s superblock information about log tail and write it to
  * disk, waiting for the IO to complete.
  */
<span class="p_del">-void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
<span class="p_add">+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 				     unsigned long tail_block, int write_op)
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,
<span class="p_chunk">@@ -1395,13 +1406,18 @@</span> <span class="p_context"> void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 	sb-&gt;s_sequence = cpu_to_be32(tail_tid);
 	sb-&gt;s_start    = cpu_to_be32(tail_block);
 
<span class="p_del">-	jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	ret = jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Log is no longer empty */
 	write_lock(&amp;journal-&gt;j_state_lock);
 	WARN_ON(!sb-&gt;s_sequence);
 	journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1952,7 +1968,14 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 		return -EIO;
 
 	mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-	jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		err = jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+	}</span>
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
<span class="p_chunk">@@ -1968,7 +1991,8 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	J_ASSERT(journal-&gt;j_head == journal-&gt;j_tail);
 	J_ASSERT(journal-&gt;j_tail_sequence == journal-&gt;j_transaction_sequence);
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 958e94a..df7bf37 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -2141,6 +2141,8 @@</span> <span class="p_context"> unlock:</span>
 	return err;
 }
 
<span class="p_add">+static bool fs_fully_visible(struct file_system_type *fs_type, int *new_mnt_flags);</span>
<span class="p_add">+</span>
 /*
  * create a new mount for userspace and request it to be added into the
  * namespace&#39;s tree
<span class="p_chunk">@@ -2172,6 +2174,10 @@</span> <span class="p_context"> static int do_new_mount(struct path *path, const char *fstype, int flags,</span>
 			flags |= MS_NODEV;
 			mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;
 		}
<span class="p_add">+		if (type-&gt;fs_flags &amp; FS_USERNS_VISIBLE) {</span>
<span class="p_add">+			if (!fs_fully_visible(type, &amp;mnt_flags))</span>
<span class="p_add">+				return -EPERM;</span>
<span class="p_add">+		}</span>
 	}
 
 	mnt = vfs_kern_mount(type, flags, name, data);
<span class="p_chunk">@@ -2990,9 +2996,10 @@</span> <span class="p_context"> bool current_chrooted(void)</span>
 	return chrooted;
 }
 
<span class="p_del">-bool fs_fully_visible(struct file_system_type *type)</span>
<span class="p_add">+static bool fs_fully_visible(struct file_system_type *type, int *new_mnt_flags)</span>
 {
 	struct mnt_namespace *ns = current-&gt;nsproxy-&gt;mnt_ns;
<span class="p_add">+	int new_flags = *new_mnt_flags;</span>
 	struct mount *mnt;
 	bool visible = false;
 
<span class="p_chunk">@@ -3011,16 +3018,37 @@</span> <span class="p_context"> bool fs_fully_visible(struct file_system_type *type)</span>
 		if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)
 			continue;
 
<span class="p_del">-		/* This mount is not fully visible if there are any child mounts</span>
<span class="p_del">-		 * that cover anything except for empty directories.</span>
<span class="p_add">+		/* Verify the mount flags are equal to or more permissive</span>
<span class="p_add">+		 * than the proposed new mount.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_READONLY) &amp;&amp;</span>
<span class="p_add">+		    !(new_flags &amp; MNT_READONLY))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_NODEV) &amp;&amp;</span>
<span class="p_add">+		    !(new_flags &amp; MNT_NODEV))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_ATIME) &amp;&amp;</span>
<span class="p_add">+		    ((mnt-&gt;mnt.mnt_flags &amp; MNT_ATIME_MASK) != (new_flags &amp; MNT_ATIME_MASK)))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* This mount is not fully visible if there are any</span>
<span class="p_add">+		 * locked child mounts that cover anything except for</span>
<span class="p_add">+		 * empty directories.</span>
 		 */
 		list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) {
 			struct inode *inode = child-&gt;mnt_mountpoint-&gt;d_inode;
<span class="p_add">+			/* Only worry about locked mounts */</span>
<span class="p_add">+			if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED))</span>
<span class="p_add">+				continue;</span>
 			if (!S_ISDIR(inode-&gt;i_mode))
 				goto next;
 			if (inode-&gt;i_nlink &gt; 2)
 				goto next;
 		}
<span class="p_add">+		/* Preserve the locked attributes */</span>
<span class="p_add">+		*new_mnt_flags |= mnt-&gt;mnt.mnt_flags &amp; (MNT_LOCK_READONLY | \</span>
<span class="p_add">+							MNT_LOCK_NODEV    | \</span>
<span class="p_add">+							MNT_LOCK_ATIME);</span>
 		visible = true;
 		goto found;
 	next:	;
<span class="p_header">diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c</span>
<span class="p_header">index fa6d721..4495cad 100644</span>
<span class="p_header">--- a/fs/nfs/nfs3xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs3xdr.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,</span>
 	if (args-&gt;npages != 0)
 		xdr_write_pages(xdr, args-&gt;pages, 0, args-&gt;len);
 	else
<span class="p_del">-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);</span>
<span class="p_add">+		xdr_reserve_space(xdr, args-&gt;len);</span>
 
 	error = nfsacl_encode(xdr-&gt;buf, base, args-&gt;inode,
 			    (args-&gt;mask &amp; NFS_ACL) ?
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index 89db382..b1b513c 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1490,6 +1490,8 @@</span> <span class="p_context"> restart:</span>
 					spin_unlock(&amp;state-&gt;state_lock);
 				}
 				nfs4_put_open_state(state);
<span class="p_add">+				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+					&amp;state-&gt;flags);</span>
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
 			}
<span class="p_header">diff --git a/fs/proc/root.c b/fs/proc/root.c</span>
<span class="p_header">index 87dbcbe..af81d10 100644</span>
<span class="p_header">--- a/fs/proc/root.c</span>
<span class="p_header">+++ b/fs/proc/root.c</span>
<span class="p_chunk">@@ -110,9 +110,6 @@</span> <span class="p_context"> static struct dentry *proc_mount(struct file_system_type *fs_type,</span>
 		ns = task_active_pid_ns(current);
 		options = data;
 
<span class="p_del">-		if (!capable(CAP_SYS_ADMIN) &amp;&amp; !fs_fully_visible(fs_type))</span>
<span class="p_del">-			return ERR_PTR(-EPERM);</span>
<span class="p_del">-</span>
 		/* Does the mounter have privilege over the pid namespace? */
 		if (!ns_capable(ns-&gt;user_ns, CAP_SYS_ADMIN))
 			return ERR_PTR(-EPERM);
<span class="p_chunk">@@ -155,7 +152,7 @@</span> <span class="p_context"> static struct file_system_type proc_fs_type = {</span>
 	.name		= &quot;proc&quot;,
 	.mount		= proc_mount,
 	.kill_sb	= proc_kill_sb,
<span class="p_del">-	.fs_flags	= FS_USERNS_MOUNT,</span>
<span class="p_add">+	.fs_flags	= FS_USERNS_VISIBLE | FS_USERNS_MOUNT,</span>
 };
 
 void __init proc_root_init(void)
<span class="p_header">diff --git a/fs/sysfs/mount.c b/fs/sysfs/mount.c</span>
<span class="p_header">index 834ec2c..f4d0799 100644</span>
<span class="p_header">--- a/fs/sysfs/mount.c</span>
<span class="p_header">+++ b/fs/sysfs/mount.c</span>
<span class="p_chunk">@@ -113,9 +113,6 @@</span> <span class="p_context"> static struct dentry *sysfs_mount(struct file_system_type *fs_type,</span>
 	int error;
 
 	if (!(flags &amp; MS_KERNMOUNT)) {
<span class="p_del">-		if (!capable(CAP_SYS_ADMIN) &amp;&amp; !fs_fully_visible(fs_type))</span>
<span class="p_del">-			return ERR_PTR(-EPERM);</span>
<span class="p_del">-</span>
 		for (type = KOBJ_NS_TYPE_NONE; type &lt; KOBJ_NS_TYPES; type++) {
 			if (!kobj_ns_current_may_mount(type))
 				return ERR_PTR(-EPERM);
<span class="p_chunk">@@ -160,7 +157,7 @@</span> <span class="p_context"> static struct file_system_type sysfs_fs_type = {</span>
 	.name		= &quot;sysfs&quot;,
 	.mount		= sysfs_mount,
 	.kill_sb	= sysfs_kill_sb,
<span class="p_del">-	.fs_flags	= FS_USERNS_MOUNT,</span>
<span class="p_add">+	.fs_flags	= FS_USERNS_VISIBLE | FS_USERNS_MOUNT,</span>
 };
 
 int __init sysfs_init(void)
<span class="p_header">diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c</span>
<span class="p_header">index 14e58f2..98d4948 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_symlink.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_symlink.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> xfs_readlink_bmap(</span>
 			cur_chunk += sizeof(struct xfs_dsymlink_hdr);
 		}
 
<span class="p_del">-		memcpy(link + offset, bp-&gt;b_addr, byte_cnt);</span>
<span class="p_add">+		memcpy(link + offset, cur_chunk, byte_cnt);</span>
 
 		pathlen -= byte_cnt;
 		offset += byte_cnt;
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index 32fb16a..62a309b 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -561,6 +561,7 @@</span> <span class="p_context"> typedef u64 acpi_integer;</span>
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
<span class="p_add">+#define ACPI_NO_FACS_INIT               0x80</span>
 
 /*
  * Initialization state
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index d9099b1..1652d53 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -297,6 +297,9 @@</span> <span class="p_context"> int acpi_check_region(resource_size_t start, resource_size_t n,</span>
 
 int acpi_resources_are_enforced(void);
 
<span class="p_add">+int acpi_reserve_region(u64 start, unsigned int length, u8 space_id,</span>
<span class="p_add">+			unsigned long flags, char *desc);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_HIBERNATION
 void __init acpi_no_s4_hw_signature(void);
 #endif
<span class="p_chunk">@@ -456,6 +459,13 @@</span> <span class="p_context"> static inline int acpi_check_region(resource_size_t start, resource_size_t n,</span>
 	return 0;
 }
 
<span class="p_add">+static inline int acpi_reserve_region(u64 start, unsigned int length,</span>
<span class="p_add">+				      u8 space_id, unsigned long flags,</span>
<span class="p_add">+				      char *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -ENXIO;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct acpi_table_header;
 static inline int acpi_table_parse(char *id,
 				int (*handler)(struct acpi_table_header *))
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 121f11f..a917265 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -1815,6 +1815,7 @@</span> <span class="p_context"> struct file_system_type {</span>
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
<span class="p_add">+#define FS_USERNS_VISIBLE	32	/* FS must already be visible */</span>
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
<span class="p_chunk">@@ -1901,7 +1902,6 @@</span> <span class="p_context"> extern int vfs_ustat(dev_t, struct kstatfs *);</span>
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);
<span class="p_del">-extern bool fs_fully_visible(struct file_system_type *);</span>
 
 extern int current_umask(void);
 
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index 723c75c..57f4e93 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -404,6 +404,16 @@</span> <span class="p_context"> static inline spinlock_t *huge_pte_lockptr(struct hstate *h,</span>
 	return &amp;mm-&gt;page_table_lock;
 }
 
<span class="p_add">+static inline bool hugepages_supported(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some platform decide whether they support huge pages at boot</span>
<span class="p_add">+	 * time. On these, such as powerpc, HPAGE_SHIFT is set to 0 when</span>
<span class="p_add">+	 * there is no such support</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return HPAGE_SHIFT != 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #else	/* CONFIG_HUGETLB_PAGE */
 struct hstate {};
 #define alloc_huge_page_node(h, nid) NULL
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index 0dae71e..e1fb0f6 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -1035,7 +1035,7 @@</span> <span class="p_context"> struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal);</span>
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
 int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
 			      unsigned long *block);
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 
 /* Commit management */
<span class="p_chunk">@@ -1157,7 +1157,7 @@</span> <span class="p_context"> extern int	   jbd2_journal_recover    (journal_t *journal);</span>
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
 extern void	   jbd2_journal_update_sb_errno(journal_t *);
<span class="p_del">-extern void	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
<span class="p_add">+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
 				unsigned long, int);
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
<span class="p_header">diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h</span>
<span class="p_header">index 53988cb..3a36a2c 100644</span>
<span class="p_header">--- a/include/linux/nfs_xdr.h</span>
<span class="p_header">+++ b/include/linux/nfs_xdr.h</span>
<span class="p_chunk">@@ -1155,7 +1155,7 @@</span> <span class="p_context"> struct nfs41_state_protection {</span>
 	struct nfs4_op_map allow;
 };
 
<span class="p_del">-#define NFS4_EXCHANGE_ID_LEN	(48)</span>
<span class="p_add">+#define NFS4_EXCHANGE_ID_LEN	(127)</span>
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
<span class="p_header">diff --git a/include/linux/of.h b/include/linux/of.h</span>
<span class="p_header">index 6e47b7f..bb7a1a9 100644</span>
<span class="p_header">--- a/include/linux/of.h</span>
<span class="p_header">+++ b/include/linux/of.h</span>
<span class="p_chunk">@@ -553,7 +553,10 @@</span> <span class="p_context"> static inline const char *of_prop_next_string(struct property *prop,</span>
 #if defined(CONFIG_OF) &amp;&amp; defined(CONFIG_NUMA)
 extern int of_node_to_nid(struct device_node *np);
 #else
<span class="p_del">-static inline int of_node_to_nid(struct device_node *device) { return 0; }</span>
<span class="p_add">+static inline int of_node_to_nid(struct device_node *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
<span class="p_add">+}</span>
 #endif
 
 /**
<span class="p_header">diff --git a/include/net/netfilter/nf_queue.h b/include/net/netfilter/nf_queue.h</span>
<span class="p_header">index c1d5b3e..8b5944e 100644</span>
<span class="p_header">--- a/include/net/netfilter/nf_queue.h</span>
<span class="p_header">+++ b/include/net/netfilter/nf_queue.h</span>
<span class="p_chunk">@@ -24,6 +24,8 @@</span> <span class="p_context"> struct nf_queue_entry {</span>
 struct nf_queue_handler {
 	int			(*outfn)(struct nf_queue_entry *entry,
 					 unsigned int queuenum);
<span class="p_add">+	void			(*nf_hook_drop)(struct net *net,</span>
<span class="p_add">+						struct nf_hook_ops *ops);</span>
 };
 
 void nf_register_queue_handler(const struct nf_queue_handler *qh);
<span class="p_header">diff --git a/include/net/netns/sctp.h b/include/net/netns/sctp.h</span>
<span class="p_header">index 3573a81..8ba379f 100644</span>
<span class="p_header">--- a/include/net/netns/sctp.h</span>
<span class="p_header">+++ b/include/net/netns/sctp.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> struct netns_sctp {</span>
 	struct list_head addr_waitq;
 	struct timer_list addr_wq_timer;
 	struct list_head auto_asconf_splist;
<span class="p_add">+	/* Lock that protects both addr_waitq and auto_asconf_splist */</span>
 	spinlock_t addr_wq_lock;
 
 	/* Lock that protects the local_addr_list writers */
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index 4046088..df3d7d3 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -220,6 +220,10 @@</span> <span class="p_context"> struct sctp_sock {</span>
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
<span class="p_add">+</span>
<span class="p_add">+	/* These must be the last fields, as they will skipped on copies,</span>
<span class="p_add">+	 * like on accept and peeloff operations</span>
<span class="p_add">+	 */</span>
 	struct list_head auto_asconf_list;
 	int do_auto_asconf;
 };
<span class="p_header">diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig</span>
<span class="p_header">index 2fac9cc..9d18628 100644</span>
<span class="p_header">--- a/kernel/power/Kconfig</span>
<span class="p_header">+++ b/kernel/power/Kconfig</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> config DPM_WATCHDOG</span>
 config DPM_WATCHDOG_TIMEOUT
 	int &quot;Watchdog timeout in seconds&quot;
 	range 1 120
<span class="p_del">-	default 12</span>
<span class="p_add">+	default 60</span>
 	depends on DPM_WATCHDOG
 
 config PM_TRACE
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index 886555f..9b6f5d2 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -383,11 +383,11 @@</span> <span class="p_context"> static int check_syslog_permissions(int type, bool from_file)</span>
 	 * already done the capabilities checks at open time.
 	 */
 	if (from_file &amp;&amp; type != SYSLOG_ACTION_OPEN)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto ok;</span>
 
 	if (syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		/*
 		 * For historical reasons, accept CAP_SYS_ADMIN too, with
 		 * a warning.
<span class="p_chunk">@@ -397,10 +397,11 @@</span> <span class="p_context"> static int check_syslog_permissions(int type, bool from_file)</span>
 				     &quot;CAP_SYS_ADMIN but no CAP_SYSLOG &quot;
 				     &quot;(deprecated).\n&quot;,
 				 current-&gt;comm, task_pid_nr(current));
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		}
 		return -EPERM;
 	}
<span class="p_add">+ok:</span>
 	return security_syslog(type);
 }
 
<span class="p_chunk">@@ -1130,10 +1131,6 @@</span> <span class="p_context"> int do_syslog(int type, char __user *buf, int len, bool from_file)</span>
 	if (error)
 		goto out;
 
<span class="p_del">-	error = security_syslog(type);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	switch (type) {
 	case SYSLOG_ACTION_CLOSE:	/* Close log */
 		break;
<span class="p_header">diff --git a/kernel/rcu/tiny.c b/kernel/rcu/tiny.c</span>
<span class="p_header">index 1254f31..ae359f0 100644</span>
<span class="p_header">--- a/kernel/rcu/tiny.c</span>
<span class="p_header">+++ b/kernel/rcu/tiny.c</span>
<span class="p_chunk">@@ -284,6 +284,11 @@</span> <span class="p_context"> static void __rcu_process_callbacks(struct rcu_ctrlblk *rcp)</span>
 
 	/* Move the ready-to-invoke callbacks to a local list. */
 	local_irq_save(flags);
<span class="p_add">+	if (rcp-&gt;donetail == &amp;rcp-&gt;rcucblist) {</span>
<span class="p_add">+		/* No callbacks ready, so just leave. */</span>
<span class="p_add">+		local_irq_restore(flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	RCU_TRACE(trace_rcu_batch_start(rcp-&gt;name, 0, rcp-&gt;qlen, -1));
 	list = rcp-&gt;rcucblist;
 	rcp-&gt;rcucblist = *rcp-&gt;donetail;
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index 2468f56..a62de24 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1081,6 +1081,9 @@</span> <span class="p_context"> static void parse_init(struct filter_parse_state *ps,</span>
 
 static char infix_next(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 
 	return ps-&gt;infix.string[ps-&gt;infix.tail++];
<span class="p_chunk">@@ -1096,6 +1099,9 @@</span> <span class="p_context"> static char infix_peek(struct filter_parse_state *ps)</span>
 
 static void infix_advance(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 	ps-&gt;infix.tail++;
 }
<span class="p_header">diff --git a/lib/bitmap.c b/lib/bitmap.c</span>
<span class="p_header">index e5c4ebe..c0634aa 100644</span>
<span class="p_header">--- a/lib/bitmap.c</span>
<span class="p_header">+++ b/lib/bitmap.c</span>
<span class="p_chunk">@@ -603,12 +603,12 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
<span class="p_del">-	int exp_digit, in_range;</span>
<span class="p_add">+	int at_start, in_range;</span>
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
<span class="p_del">-		exp_digit = 1;</span>
<span class="p_add">+		at_start = 1;</span>
 		in_range = 0;
 		a = b = 0;
 
<span class="p_chunk">@@ -637,11 +637,10 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 				break;
 
 			if (c == &#39;-&#39;) {
<span class="p_del">-				if (exp_digit || in_range)</span>
<span class="p_add">+				if (at_start || in_range)</span>
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
<span class="p_del">-				exp_digit = 1;</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -651,16 +650,18 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 			b = b * 10 + (c - &#39;0&#39;);
 			if (!in_range)
 				a = b;
<span class="p_del">-			exp_digit = 0;</span>
<span class="p_add">+			at_start = 0;</span>
 			totaldigits++;
 		}
 		if (!(a &lt;= b))
 			return -EINVAL;
 		if (b &gt;= nmaskbits)
 			return -ERANGE;
<span class="p_del">-		while (a &lt;= b) {</span>
<span class="p_del">-			set_bit(a, maskp);</span>
<span class="p_del">-			a++;</span>
<span class="p_add">+		if (!at_start) {</span>
<span class="p_add">+			while (a &lt;= b) {</span>
<span class="p_add">+				set_bit(a, maskp);</span>
<span class="p_add">+				a++;</span>
<span class="p_add">+			}</span>
 		}
 	} while (buflen &amp;&amp; c == &#39;,&#39;);
 	return 0;
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index b14f49b..784e1e0 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -39,6 +39,11 @@</span> <span class="p_context"> unsigned long hugepages_treat_as_movable;</span>
 int hugetlb_max_hstate __read_mostly;
 unsigned int default_hstate_idx;
 struct hstate hstates[HUGE_MAX_HSTATE];
<span class="p_add">+/*</span>
<span class="p_add">+ * Minimum page order among possible hugepage sizes, set to a proper value</span>
<span class="p_add">+ * at boot time.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int minimum_order __read_mostly = UINT_MAX;</span>
 
 __initdata LIST_HEAD(huge_boot_pages);
 
<span class="p_chunk">@@ -916,16 +921,13 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
  */
 void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_del">-	unsigned int order = 8 * sizeof(void *);</span>
 	unsigned long pfn;
<span class="p_del">-	struct hstate *h;</span>
 
<span class="p_del">-	/* Set scan step to minimum hugepage size */</span>
<span class="p_del">-	for_each_hstate(h)</span>
<span class="p_del">-		if (order &gt; huge_page_order(h))</span>
<span class="p_del">-			order = huge_page_order(h);</span>
<span class="p_del">-	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; order));</span>
<span class="p_del">-	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; order)</span>
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; minimum_order));</span>
<span class="p_add">+	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)</span>
 		dissolve_free_huge_page(pfn_to_page(pfn));
 }
 
<span class="p_chunk">@@ -1363,10 +1365,14 @@</span> <span class="p_context"> static void __init hugetlb_init_hstates(void)</span>
 	struct hstate *h;
 
 	for_each_hstate(h) {
<span class="p_add">+		if (minimum_order &gt; huge_page_order(h))</span>
<span class="p_add">+			minimum_order = huge_page_order(h);</span>
<span class="p_add">+</span>
 		/* oversize hugepages were init&#39;ed in early boot */
 		if (h-&gt;order &lt; MAX_ORDER)
 			hugetlb_hstate_alloc_pages(h);
 	}
<span class="p_add">+	VM_BUG_ON(minimum_order == UINT_MAX);</span>
 }
 
 static char * __init memfmt(char *buf, unsigned long n)
<span class="p_chunk">@@ -1960,11 +1966,7 @@</span> <span class="p_context"> module_exit(hugetlb_exit);</span>
 
 static int __init hugetlb_init(void)
 {
<span class="p_del">-	/* Some platform decide whether they support huge pages at boot</span>
<span class="p_del">-	 * time. On these, such as powerpc, HPAGE_SHIFT is set to 0 when</span>
<span class="p_del">-	 * there is no such support</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (HPAGE_SHIFT == 0)</span>
<span class="p_add">+	if (!hugepages_supported())</span>
 		return 0;
 
 	if (!size_to_hstate(default_hstate_size)) {
<span class="p_chunk">@@ -2080,6 +2082,9 @@</span> <span class="p_context"> static int hugetlb_sysctl_handler_common(bool obey_mempolicy,</span>
 	unsigned long tmp;
 	int ret;
 
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+</span>
 	tmp = h-&gt;max_huge_pages;
 
 	if (write &amp;&amp; h-&gt;order &gt;= MAX_ORDER)
<span class="p_chunk">@@ -2133,6 +2138,9 @@</span> <span class="p_context"> int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
 	unsigned long tmp;
 	int ret;
 
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+</span>
 	tmp = h-&gt;nr_overcommit_huge_pages;
 
 	if (write &amp;&amp; h-&gt;order &gt;= MAX_ORDER)
<span class="p_chunk">@@ -2158,6 +2166,8 @@</span> <span class="p_context"> out:</span>
 void hugetlb_report_meminfo(struct seq_file *m)
 {
 	struct hstate *h = &amp;default_hstate;
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return;</span>
 	seq_printf(m,
 			&quot;HugePages_Total:   %5lu\n&quot;
 			&quot;HugePages_Free:    %5lu\n&quot;
<span class="p_chunk">@@ -2174,6 +2184,8 @@</span> <span class="p_context"> void hugetlb_report_meminfo(struct seq_file *m)</span>
 int hugetlb_report_node_meminfo(int nid, char *buf)
 {
 	struct hstate *h = &amp;default_hstate;
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return 0;</span>
 	return sprintf(buf,
 		&quot;Node %d HugePages_Total: %5u\n&quot;
 		&quot;Node %d HugePages_Free:  %5u\n&quot;
<span class="p_chunk">@@ -2188,6 +2200,9 @@</span> <span class="p_context"> void hugetlb_show_meminfo(void)</span>
 	struct hstate *h;
 	int nid;
 
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for_each_node_state(nid, N_MEMORY)
 		for_each_hstate(h)
 			pr_info(&quot;Node %d hugepages_total=%u hugepages_free=%u hugepages_surp=%u hugepages_size=%lukB\n&quot;,
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index ee8fd6b..ae4778c8 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -839,7 +839,8 @@</span> <span class="p_context"> static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,</span>
 	if (err &lt; 0) {
 		if (err == -EIO)
 			c-&gt;status = Disconnected;
<span class="p_del">-		goto reterr;</span>
<span class="p_add">+		if (err != -ERESTARTSYS)</span>
<span class="p_add">+			goto reterr;</span>
 	}
 	if (req-&gt;status == REQ_STATUS_ERROR) {
 		p9_debug(P9_DEBUG_ERROR, &quot;req_status error %d\n&quot;, req-&gt;t_err);
<span class="p_header">diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c</span>
<span class="p_header">index cd8c3a4..b73eaba 100644</span>
<span class="p_header">--- a/net/bridge/br_ioctl.c</span>
<span class="p_header">+++ b/net/bridge/br_ioctl.c</span>
<span class="p_chunk">@@ -247,9 +247,7 @@</span> <span class="p_context"> static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)</span>
 		if (!ns_capable(dev_net(dev)-&gt;user_ns, CAP_NET_ADMIN))
 			return -EPERM;
 
<span class="p_del">-		spin_lock_bh(&amp;br-&gt;lock);</span>
 		br_stp_set_bridge_priority(br, args[1]);
<span class="p_del">-		spin_unlock_bh(&amp;br-&gt;lock);</span>
 		return 0;
 
 	case BRCTL_SET_PORT_PRIORITY:
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 7bbc8fe..a798d27 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -36,6 +36,8 @@</span> <span class="p_context"></span>
 
 static void br_multicast_start_querier(struct net_bridge *br,
 				       struct bridge_mcast_query *query);
<span class="p_add">+static void br_multicast_add_router(struct net_bridge *br,</span>
<span class="p_add">+				    struct net_bridge_port *port);</span>
 unsigned int br_mdb_rehash_seq;
 
 static inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)
<span class="p_chunk">@@ -920,6 +922,8 @@</span> <span class="p_context"> void br_multicast_enable_port(struct net_bridge_port *port)</span>
 #if IS_ENABLED(CONFIG_IPV6)
 	br_multicast_enable(&amp;port-&gt;ip6_query);
 #endif
<span class="p_add">+	if (port-&gt;multicast_router == 2 &amp;&amp; hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		br_multicast_add_router(br, port);</span>
 
 out:
 	spin_unlock(&amp;br-&gt;multicast_lock);
<span class="p_header">diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c</span>
<span class="p_header">index 656a6f3..886f6d6 100644</span>
<span class="p_header">--- a/net/bridge/br_stp_if.c</span>
<span class="p_header">+++ b/net/bridge/br_stp_if.c</span>
<span class="p_chunk">@@ -241,12 +241,13 @@</span> <span class="p_context"> bool br_stp_recalculate_bridge_id(struct net_bridge *br)</span>
 	return true;
 }
 
<span class="p_del">-/* called under bridge lock */</span>
<span class="p_add">+/* Acquires and releases bridge lock */</span>
 void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)
 {
 	struct net_bridge_port *p;
 	int wasroot;
 
<span class="p_add">+	spin_lock_bh(&amp;br-&gt;lock);</span>
 	wasroot = br_is_root_bridge(br);
 
 	list_for_each_entry(p, &amp;br-&gt;port_list, list) {
<span class="p_chunk">@@ -264,6 +265,7 @@</span> <span class="p_context"> void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)</span>
 	br_port_state_selection(br);
 	if (br_is_root_bridge(br) &amp;&amp; !wasroot)
 		br_become_root_bridge(br);
<span class="p_add">+	spin_unlock_bh(&amp;br-&gt;lock);</span>
 }
 
 /* called under bridge lock */
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index dbd9a47..7ec4e05 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int crush_decode_tree_bucket(void **p, void *end,</span>
 {
 	int j;
 	dout(&quot;crush_decode_tree_bucket %p to %p\n&quot;, *p, end);
<span class="p_del">-	ceph_decode_32_safe(p, end, b-&gt;num_nodes, bad);</span>
<span class="p_add">+	ceph_decode_8_safe(p, end, b-&gt;num_nodes, bad);</span>
 	b-&gt;node_weights = kcalloc(b-&gt;num_nodes, sizeof(u32), GFP_NOFS);
 	if (b-&gt;node_weights == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index 43128dd..35962f1 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -971,6 +971,8 @@</span> <span class="p_context"> int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)</span>
 	rc = 0;
 	if (neigh-&gt;nud_state &amp; (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
 		goto out_unlock_bh;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out_dead;</span>
 
 	if (!(neigh-&gt;nud_state &amp; (NUD_STALE | NUD_INCOMPLETE))) {
 		if (neigh-&gt;parms-&gt;mcast_probes + neigh-&gt;parms-&gt;app_probes) {
<span class="p_chunk">@@ -1024,6 +1026,13 @@</span> <span class="p_context"> out_unlock_bh:</span>
 		write_unlock(&amp;neigh-&gt;lock);
 	local_bh_enable();
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_dead:</span>
<span class="p_add">+	if (neigh-&gt;nud_state &amp; NUD_STALE)</span>
<span class="p_add">+		goto out_unlock_bh;</span>
<span class="p_add">+	write_unlock_bh(&amp;neigh-&gt;lock);</span>
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+	return 1;</span>
 }
 EXPORT_SYMBOL(__neigh_event_send);
 
<span class="p_chunk">@@ -1087,6 +1096,8 @@</span> <span class="p_context"> int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,</span>
 	if (!(flags &amp; NEIGH_UPDATE_F_ADMIN) &amp;&amp;
 	    (old &amp; (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out;</span>
 
 	if (!(new &amp; NUD_VALID)) {
 		neigh_del_timer(neigh);
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index a104ba3..32616f0 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -564,7 +564,7 @@</span> <span class="p_context"> static int pktgen_if_show(struct seq_file *seq, void *v)</span>
 			   &quot;     dst_min: %s  dst_max: %s\n&quot;,
 			   pkt_dev-&gt;dst_min, pkt_dev-&gt;dst_max);
 		seq_printf(seq,
<span class="p_del">-			   &quot;        src_min: %s  src_max: %s\n&quot;,</span>
<span class="p_add">+			   &quot;     src_min: %s  src_max: %s\n&quot;,</span>
 			   pkt_dev-&gt;src_min, pkt_dev-&gt;src_max);
 	}
 
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index a937b23..1216c57 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -366,9 +366,11 @@</span> <span class="p_context"> refill:</span>
 		for (order = NETDEV_FRAG_PAGE_MAX_ORDER; ;) {
 			gfp_t gfp = gfp_mask;
 
<span class="p_del">-			if (order)</span>
<span class="p_add">+			if (order) {</span>
 				gfp |= __GFP_COMP | __GFP_NOWARN |
 				       __GFP_NOMEMALLOC;
<span class="p_add">+				gfp &amp;= ~__GFP_WAIT;</span>
<span class="p_add">+			}</span>
 			nc-&gt;frag.page = alloc_pages(gfp, order);
 			if (likely(nc-&gt;frag.page))
 				break;
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index 8235166..fa5f321 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1938,8 +1938,10 @@</span> <span class="p_context"> bool skb_page_frag_refill(unsigned int sz, struct page_frag *pfrag, gfp_t prio)</span>
 	do {
 		gfp_t gfp = prio;
 
<span class="p_del">-		if (order)</span>
<span class="p_add">+		if (order) {</span>
 			gfp |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY;
<span class="p_add">+			gfp &amp;= ~__GFP_WAIT;</span>
<span class="p_add">+		}</span>
 		pfrag-&gt;page = alloc_pages(gfp, order);
 		if (likely(pfrag-&gt;page)) {
 			pfrag-&gt;offset = 0;
<span class="p_header">diff --git a/net/ieee802154/dgram.c b/net/ieee802154/dgram.c</span>
<span class="p_header">index 1865fdf..2bdd0cc 100644</span>
<span class="p_header">--- a/net/ieee802154/dgram.c</span>
<span class="p_header">+++ b/net/ieee802154/dgram.c</span>
<span class="p_chunk">@@ -313,6 +313,12 @@</span> <span class="p_context"> static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,</span>
 	sock_recv_ts_and_drops(msg, sk, skb);
 
 	if (saddr) {
<span class="p_add">+		/* Clear the implicit padding in struct sockaddr_ieee802154</span>
<span class="p_add">+		 * (16 bits between &#39;family&#39; and &#39;addr&#39;) and in struct</span>
<span class="p_add">+		 * ieee802154_addr_sa (16 bits at the end of the structure).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		memset(saddr, 0, sizeof(*saddr));</span>
<span class="p_add">+</span>
 		saddr-&gt;family = AF_IEEE802154;
 		saddr-&gt;addr = mac_cb(skb)-&gt;sa;
 		*addr_len = sizeof(*saddr);
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index e4d96d4..7d2d135 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -231,6 +231,8 @@</span> <span class="p_context"> int inet_listen(struct socket *sock, int backlog)</span>
 				err = 0;
 			if (err)
 				goto out;
<span class="p_add">+</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
 		}
 		err = inet_csk_listen_start(sk, backlog);
 		if (err)
<span class="p_header">diff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c</span>
<span class="p_header">index 1e625b0..629841b 100644</span>
<span class="p_header">--- a/net/ipv4/ipip.c</span>
<span class="p_header">+++ b/net/ipv4/ipip.c</span>
<span class="p_chunk">@@ -249,7 +249,8 @@</span> <span class="p_context"> ipip_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)</span>
 			return -EINVAL;
 	}
 
<span class="p_del">-	p.i_key = p.o_key = p.i_flags = p.o_flags = 0;</span>
<span class="p_add">+	p.i_key = p.o_key = 0;</span>
<span class="p_add">+	p.i_flags = p.o_flags = 0;</span>
 	if (p.iph.ttl)
 		p.iph.frag_off |= htons(IP_DF);
 
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index 84c69c4..fda904e 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -2522,10 +2522,13 @@</span> <span class="p_context"> static int do_tcp_setsockopt(struct sock *sk, int level,</span>
 
 	case TCP_FASTOPEN:
 		if (val &gt;= 0 &amp;&amp; ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_CLOSE |
<span class="p_del">-		    TCPF_LISTEN)))</span>
<span class="p_add">+		    TCPF_LISTEN))) {</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
<span class="p_add">+</span>
 			err = fastopen_init_queue(sk, val);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			err = -EINVAL;
<span class="p_add">+		}</span>
 		break;
 	case TCP_TIMESTAMP:
 		if (!tp-&gt;repair)
<span class="p_header">diff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">index f195d93..ee6518d 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_fastopen.c</span>
<span class="p_chunk">@@ -84,8 +84,6 @@</span> <span class="p_context"> void tcp_fastopen_cookie_gen(__be32 src, __be32 dst,</span>
 	__be32 path[4] = { src, dst, 0, 0 };
 	struct tcp_fastopen_context *ctx;
 
<span class="p_del">-	tcp_fastopen_init_key_once(true);</span>
<span class="p_del">-</span>
 	rcu_read_lock();
 	ctx = rcu_dereference(tcp_fastopen_ctx);
 	if (ctx) {
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index 8cec1ba..cfc5ec6 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -248,6 +248,7 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 {
 	struct ieee80211_local *local =
 		container_of(work, struct ieee80211_local, restart_work);
<span class="p_add">+	struct ieee80211_sub_if_data *sdata;</span>
 
 	/* wait for scan work complete */
 	flush_workqueue(local-&gt;workqueue);
<span class="p_chunk">@@ -260,6 +261,8 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 	mutex_unlock(&amp;local-&gt;mtx);
 
 	rtnl_lock();
<span class="p_add">+	list_for_each_entry(sdata, &amp;local-&gt;interfaces, list)</span>
<span class="p_add">+		flush_delayed_work(&amp;sdata-&gt;dec_tailroom_needed_wk);</span>
 	ieee80211_scan_cancel(local);
 	ieee80211_reconfig(local);
 	rtnl_unlock();
<span class="p_header">diff --git a/net/netfilter/core.c b/net/netfilter/core.c</span>
<span class="p_header">index 1fbab0c..32c5db5 100644</span>
<span class="p_header">--- a/net/netfilter/core.c</span>
<span class="p_header">+++ b/net/netfilter/core.c</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> void nf_unregister_hook(struct nf_hook_ops *reg)</span>
 	static_key_slow_dec(&amp;nf_hooks_needed[reg-&gt;pf][reg-&gt;hooknum]);
 #endif
 	synchronize_net();
<span class="p_add">+	nf_queue_nf_hook_drop(reg);</span>
 }
 EXPORT_SYMBOL(nf_unregister_hook);
 
<span class="p_header">diff --git a/net/netfilter/nf_internals.h b/net/netfilter/nf_internals.h</span>
<span class="p_header">index 61a3c92..aba1d7d 100644</span>
<span class="p_header">--- a/net/netfilter/nf_internals.h</span>
<span class="p_header">+++ b/net/netfilter/nf_internals.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> int nf_queue(struct sk_buff *skb, struct nf_hook_ops *elem, u_int8_t pf,</span>
 	     unsigned int hook, struct net_device *indev,
 	     struct net_device *outdev, int (*okfn)(struct sk_buff *),
 	     unsigned int queuenum);
<span class="p_add">+void nf_queue_nf_hook_drop(struct nf_hook_ops *ops);</span>
 int __init netfilter_queue_init(void);
 
 /* nf_log.c */
<span class="p_header">diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c</span>
<span class="p_header">index 5d24b1f..df046ed 100644</span>
<span class="p_header">--- a/net/netfilter/nf_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nf_queue.c</span>
<span class="p_chunk">@@ -95,6 +95,23 @@</span> <span class="p_context"> bool nf_queue_entry_get_refs(struct nf_queue_entry *entry)</span>
 }
 EXPORT_SYMBOL_GPL(nf_queue_entry_get_refs);
 
<span class="p_add">+void nf_queue_nf_hook_drop(struct nf_hook_ops *ops)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct nf_queue_handler *qh;</span>
<span class="p_add">+	struct net *net;</span>
<span class="p_add">+</span>
<span class="p_add">+	rtnl_lock();</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	qh = rcu_dereference(queue_handler);</span>
<span class="p_add">+	if (qh) {</span>
<span class="p_add">+		for_each_net(net) {</span>
<span class="p_add">+			qh-&gt;nf_hook_drop(net, ops);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Any packet that leaves via this function must come back
  * through nf_reinject().
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">index b241654..f00707d 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_chunk">@@ -839,6 +839,27 @@</span> <span class="p_context"> static struct notifier_block nfqnl_dev_notifier = {</span>
 	.notifier_call	= nfqnl_rcv_dev_event,
 };
 
<span class="p_add">+static int nf_hook_cmp(struct nf_queue_entry *entry, unsigned long ops_ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return entry-&gt;elem == (struct nf_hook_ops *)ops_ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void nfqnl_nf_hook_drop(struct net *net, struct nf_hook_ops *hook)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfnl_queue_net *q = nfnl_queue_pernet(net);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	for (i = 0; i &lt; INSTANCE_BUCKETS; i++) {</span>
<span class="p_add">+		struct nfqnl_instance *inst;</span>
<span class="p_add">+		struct hlist_head *head = &amp;q-&gt;instance_table[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		hlist_for_each_entry_rcu(inst, head, hlist)</span>
<span class="p_add">+			nfqnl_flush(inst, nf_hook_cmp, (unsigned long)hook);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 nfqnl_rcv_nl_event(struct notifier_block *this,
 		   unsigned long event, void *ptr)
<span class="p_chunk">@@ -1046,7 +1067,8 @@</span> <span class="p_context"> static const struct nla_policy nfqa_cfg_policy[NFQA_CFG_MAX+1] = {</span>
 };
 
 static const struct nf_queue_handler nfqh = {
<span class="p_del">-	.outfn	= &amp;nfqnl_enqueue_packet,</span>
<span class="p_add">+	.outfn		= &amp;nfqnl_enqueue_packet,</span>
<span class="p_add">+	.nf_hook_drop	= &amp;nfqnl_nf_hook_drop,</span>
 };
 
 static int
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index a846125..7f63613 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1150,16 +1150,6 @@</span> <span class="p_context"> static void packet_sock_destruct(struct sock *sk)</span>
 	sk_refcnt_debug_dec(sk);
 }
 
<span class="p_del">-static int fanout_rr_next(struct packet_fanout *f, unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int x = atomic_read(&amp;f-&gt;rr_cur) + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (x &gt;= num)</span>
<span class="p_del">-		x = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return x;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static unsigned int fanout_demux_hash(struct packet_fanout *f,
 				      struct sk_buff *skb,
 				      unsigned int num)
<span class="p_chunk">@@ -1171,13 +1161,9 @@</span> <span class="p_context"> static unsigned int fanout_demux_lb(struct packet_fanout *f,</span>
 				    struct sk_buff *skb,
 				    unsigned int num)
 {
<span class="p_del">-	int cur, old;</span>
<span class="p_add">+	unsigned int val = atomic_inc_return(&amp;f-&gt;rr_cur);</span>
 
<span class="p_del">-	cur = atomic_read(&amp;f-&gt;rr_cur);</span>
<span class="p_del">-	while ((old = atomic_cmpxchg(&amp;f-&gt;rr_cur, cur,</span>
<span class="p_del">-				     fanout_rr_next(f, num))) != cur)</span>
<span class="p_del">-		cur = old;</span>
<span class="p_del">-	return cur;</span>
<span class="p_add">+	return val % num;</span>
 }
 
 static unsigned int fanout_demux_cpu(struct packet_fanout *f,
<span class="p_chunk">@@ -1224,7 +1210,7 @@</span> <span class="p_context"> static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,</span>
 			     struct packet_type *pt, struct net_device *orig_dev)
 {
 	struct packet_fanout *f = pt-&gt;af_packet_priv;
<span class="p_del">-	unsigned int num = f-&gt;num_members;</span>
<span class="p_add">+	unsigned int num = ACCESS_ONCE(f-&gt;num_members);</span>
 	struct packet_sock *po;
 	unsigned int idx;
 
<span class="p_header">diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c</span>
<span class="p_header">index 62ced65..4a719a5 100644</span>
<span class="p_header">--- a/net/rose/af_rose.c</span>
<span class="p_header">+++ b/net/rose/af_rose.c</span>
<span class="p_chunk">@@ -192,7 +192,8 @@</span> <span class="p_context"> static void rose_kill_by_device(struct net_device *dev)</span>
 
 		if (rose-&gt;device == dev) {
 			rose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);
<span class="p_del">-			rose-&gt;neighbour-&gt;use--;</span>
<span class="p_add">+			if (rose-&gt;neighbour)</span>
<span class="p_add">+				rose-&gt;neighbour-&gt;use--;</span>
 			rose-&gt;device = NULL;
 		}
 	}
<span class="p_header">diff --git a/net/sctp/output.c b/net/sctp/output.c</span>
<span class="p_header">index 777dba7..1bc7f5b 100644</span>
<span class="p_header">--- a/net/sctp/output.c</span>
<span class="p_header">+++ b/net/sctp/output.c</span>
<span class="p_chunk">@@ -601,7 +601,9 @@</span> <span class="p_context"> out:</span>
 	return err;
 no_route:
 	kfree_skb(nskb);
<span class="p_del">-	IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (asoc)</span>
<span class="p_add">+		IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
 
 	/* FIXME: Returning the &#39;err&#39; will effect all the associations
 	 * associated with a socket, although only one of the paths of the
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 39123d8..7fe4dec 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1533,8 +1533,10 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 
 	/* Supposedly, no process has access to the socket, but
 	 * the net layers still may.
<span class="p_del">-	 */</span>
<span class="p_del">-	sctp_local_bh_disable();</span>
<span class="p_add">+	 * Also, sctp_destroy_sock() needs to be called with addr_wq_lock</span>
<span class="p_add">+	 * held and that should be grabbed before socket lock.</span>
<span class="p_add">+ 	 */</span>
<span class="p_add">+	spin_lock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 	sctp_bh_lock_sock(sk);
 
 	/* Hold the sock, since sk_common_release() will put sock_put()
<span class="p_chunk">@@ -1544,7 +1546,7 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 	sk_common_release(sk);
 
 	sctp_bh_unlock_sock(sk);
<span class="p_del">-	sctp_local_bh_enable();</span>
<span class="p_add">+	spin_unlock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 
 	sock_put(sk);
 
<span class="p_chunk">@@ -3502,6 +3504,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 	if ((val &amp;&amp; sp-&gt;do_auto_asconf) || (!val &amp;&amp; !sp-&gt;do_auto_asconf))
 		return 0;
 
<span class="p_add">+	spin_lock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	if (val == 0 &amp;&amp; sp-&gt;do_auto_asconf) {
 		list_del(&amp;sp-&gt;auto_asconf_list);
 		sp-&gt;do_auto_asconf = 0;
<span class="p_chunk">@@ -3510,6 +3513,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 		    &amp;sock_net(sk)-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
 	}
<span class="p_add">+	spin_unlock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4000,18 +4004,28 @@</span> <span class="p_context"> static int sctp_init_sock(struct sock *sk)</span>
 	local_bh_disable();
 	percpu_counter_inc(&amp;sctp_sockets_allocated);
 	sock_prot_inuse_add(net, sk-&gt;sk_prot, 1);
<span class="p_add">+</span>
<span class="p_add">+	/* Nothing can fail after this block, otherwise</span>
<span class="p_add">+	 * sctp_destroy_sock() will be called without addr_wq_lock held</span>
<span class="p_add">+	 */</span>
 	if (net-&gt;sctp.default_auto_asconf) {
<span class="p_add">+		spin_lock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 		list_add_tail(&amp;sp-&gt;auto_asconf_list,
 		    &amp;net-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
<span class="p_del">-	} else</span>
<span class="p_add">+		spin_unlock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
<span class="p_add">+	} else {</span>
 		sp-&gt;do_auto_asconf = 0;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	local_bh_enable();
 
 	return 0;
 }
 
<span class="p_del">-/* Cleanup any SCTP per socket resources.  */</span>
<span class="p_add">+/* Cleanup any SCTP per socket resources. Must be called with</span>
<span class="p_add">+ * sock_net(sk)-&gt;sctp.addr_wq_lock held if sp-&gt;do_auto_asconf is true</span>
<span class="p_add">+ */</span>
 static void sctp_destroy_sock(struct sock *sk)
 {
 	struct sctp_sock *sp;
<span class="p_chunk">@@ -6954,6 +6968,19 @@</span> <span class="p_context"> void sctp_copy_sock(struct sock *newsk, struct sock *sk,</span>
 	newinet-&gt;mc_list = NULL;
 }
 
<span class="p_add">+static inline void sctp_copy_descendant(struct sock *sk_to,</span>
<span class="p_add">+					const struct sock *sk_from)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ancestor_size = sizeof(struct inet_sock) +</span>
<span class="p_add">+			    sizeof(struct sctp_sock) -</span>
<span class="p_add">+			    offsetof(struct sctp_sock, auto_asconf_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sk_from-&gt;sk_family == PF_INET6)</span>
<span class="p_add">+		ancestor_size += sizeof(struct ipv6_pinfo);</span>
<span class="p_add">+</span>
<span class="p_add">+	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Populate the fields of the newsk from the oldsk and migrate the assoc
  * and its messages to the newsk.
  */
<span class="p_chunk">@@ -6968,7 +6995,6 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	struct sk_buff *skb, *tmp;
 	struct sctp_ulpevent *event;
 	struct sctp_bind_hashbucket *head;
<span class="p_del">-	struct list_head tmplist;</span>
 
 	/* Migrate socket buffer sizes and all the socket level options to the
 	 * new socket.
<span class="p_chunk">@@ -6976,12 +7002,7 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	newsk-&gt;sk_sndbuf = oldsk-&gt;sk_sndbuf;
 	newsk-&gt;sk_rcvbuf = oldsk-&gt;sk_rcvbuf;
 	/* Brute force copy old sctp opt. */
<span class="p_del">-	if (oldsp-&gt;do_auto_asconf) {</span>
<span class="p_del">-		memcpy(&amp;tmplist, &amp;newsp-&gt;auto_asconf_list, sizeof(tmplist));</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_del">-		memcpy(&amp;newsp-&gt;auto_asconf_list, &amp;tmplist, sizeof(tmplist));</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_add">+	sctp_copy_descendant(newsk, oldsk);</span>
 
 	/* Restore the ep value that was overwritten with the above structure
 	 * copy.
<span class="p_header">diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">index 890a299..d29c119e 100644</span>
<span class="p_header">--- a/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">+++ b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static void xprt_free_allocation(struct rpc_rqst *req)</span>
 
 	dprintk(&quot;RPC:        free allocations for req= %p\n&quot;, req);
 	WARN_ON_ONCE(test_bit(RPC_BC_PA_IN_USE, &amp;req-&gt;rq_bc_pa_state));
<span class="p_del">-	xbufp = &amp;req-&gt;rq_private_buf;</span>
<span class="p_add">+	xbufp = &amp;req-&gt;rq_rcv_buf;</span>
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
 	xbufp = &amp;req-&gt;rq_snd_buf;
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
<span class="p_header">diff --git a/net/wireless/util.c b/net/wireless/util.c</span>
<span class="p_header">index 935dea9..d087c13 100644</span>
<span class="p_header">--- a/net/wireless/util.c</span>
<span class="p_header">+++ b/net/wireless/util.c</span>
<span class="p_chunk">@@ -855,7 +855,7 @@</span> <span class="p_context"> int cfg80211_change_iface(struct cfg80211_registered_device *rdev,</span>
 	     ntype == NL80211_IFTYPE_P2P_CLIENT))
 		return -EBUSY;
 
<span class="p_del">-	if (ntype != otype &amp;&amp; netif_running(dev)) {</span>
<span class="p_add">+	if (ntype != otype) {</span>
 		err = cfg80211_can_change_interface(rdev, dev-&gt;ieee80211_ptr,
 						    ntype);
 		if (err)
<span class="p_header">diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h</span>
<span class="p_header">index f79fa8b..5cb7de9 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima.h</span>
<span class="p_header">+++ b/security/integrity/ima/ima.h</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void ima_add_violation(struct file *file, const unsigned char *filename,</span>
 		       const char *op, const char *cause);
 int ima_init_crypto(void);
 void ima_putc(struct seq_file *m, void *data, int datalen);
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size);</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size);</span>
 struct ima_template_desc *ima_template_desc_current(void);
 int ima_init_template(void);
 
<span class="p_header">diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c</span>
<span class="p_header">index 468a3ba..35f3c90 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_fs.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_fs.c</span>
<span class="p_chunk">@@ -186,9 +186,9 @@</span> <span class="p_context"> static const struct file_operations ima_measurements_ops = {</span>
 	.release = seq_release,
 };
 
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size)</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	u32 i;</span>
 
 	for (i = 0; i &lt; size; i++)
 		seq_printf(m, &quot;%02x&quot;, *(digest + i));
<span class="p_header">diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">index f37a803..cf84e73 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_chunk">@@ -79,7 +79,8 @@</span> <span class="p_context"> static void ima_show_template_data_ascii(struct seq_file *m,</span>
 					 enum data_formats datafmt,
 					 struct ima_field_data *field_data)
 {
<span class="p_del">-	u8 *buf_ptr = field_data-&gt;data, buflen = field_data-&gt;len;</span>
<span class="p_add">+	u8 *buf_ptr = field_data-&gt;data;</span>
<span class="p_add">+	u32 buflen = field_data-&gt;len;</span>
 
 	switch (datafmt) {
 	case DATA_FMT_DIGEST_WITH_ALGO:
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index b7ecd63..3138402 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -395,7 +395,8 @@</span> <span class="p_context"> static int selinux_is_sblabel_mnt(struct super_block *sb)</span>
 
 	if (sbsec-&gt;behavior == SECURITY_FS_USE_XATTR ||
 	    sbsec-&gt;behavior == SECURITY_FS_USE_TRANS ||
<span class="p_del">-	    sbsec-&gt;behavior == SECURITY_FS_USE_TASK)</span>
<span class="p_add">+	    sbsec-&gt;behavior == SECURITY_FS_USE_TASK ||</span>
<span class="p_add">+	    sbsec-&gt;behavior == SECURITY_FS_USE_NATIVE)</span>
 		return 1;
 
 	/* Special handling for sysfs. Is genfs but also has setxattr handler*/
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 249d885..0440d36 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -3981,6 +3981,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_LIFEBOOK,
 	ALC269_FIXUP_LIFEBOOK_EXTMIC,
 	ALC269_FIXUP_LIFEBOOK_HP_PIN,
<span class="p_add">+	ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT,</span>
 	ALC269_FIXUP_AMIC,
 	ALC269_FIXUP_DMIC,
 	ALC269VB_FIXUP_AMIC,
<span class="p_chunk">@@ -3999,6 +4000,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_DELL3_MIC_NO_PRESENCE,
 	ALC269_FIXUP_HEADSET_MODE,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
<span class="p_add">+	ALC269_FIXUP_ASPIRE_HEADSET_MIC,</span>
 	ALC269_FIXUP_ASUS_X101_FUNC,
 	ALC269_FIXUP_ASUS_X101_VERB,
 	ALC269_FIXUP_ASUS_X101,
<span class="p_chunk">@@ -4118,6 +4120,10 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ }
 		},
 	},
<span class="p_add">+	[ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,</span>
<span class="p_add">+	},</span>
 	[ALC269_FIXUP_AMIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4236,6 +4242,15 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_headset_mode_no_hp_mic,
 	},
<span class="p_add">+	[ALC269_FIXUP_ASPIRE_HEADSET_MIC] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x19, 0x01a1913c }, /* headset mic w/o jack detect */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HEADSET_MODE,</span>
<span class="p_add">+	},</span>
 	[ALC286_FIXUP_SONY_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4386,6 +4401,8 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x029b, &quot;Acer 1810TZ&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x0349, &quot;Acer AOD260&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x047c, &quot;Acer AC700&quot;, ALC269_FIXUP_ACER_AC700),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x072d, &quot;Acer Aspire V5-571G&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x080d, &quot;Acer Aspire V5-122P&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0740, &quot;Acer AO725&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK_VENDOR(0x1025, &quot;Acer Aspire&quot;, ALC271_FIXUP_DMIC),
<span class="p_chunk">@@ -4543,6 +4560,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9084, &quot;Sony VAIO&quot;, ALC275_FIXUP_SONY_HWEQ),
 	SND_PCI_QUIRK_VENDOR(0x104d, &quot;Sony VAIO&quot;, ALC269_FIXUP_SONY_VAIO),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x159f, &quot;Lifebook E780&quot;, ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT),</span>
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
<span class="p_header">diff --git a/sound/soc/codecs/wm5102.c b/sound/soc/codecs/wm5102.c</span>
<span class="p_header">index a08e8bf..17f3f4f 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5102.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5102.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> struct wm5102_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct wm_adsp_region wm5102_dsp1_regions[] = {
<span class="p_header">diff --git a/sound/soc/codecs/wm5110.c b/sound/soc/codecs/wm5110.c</span>
<span class="p_header">index c4c9ed7..e513868 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5110.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5110.c</span>
<span class="p_chunk">@@ -129,7 +129,7 @@</span> <span class="p_context"> static int wm5110_sysclk_ev(struct snd_soc_dapm_widget *w,</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 #define WM5110_NG_SRC(name, base) \
<span class="p_header">diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c</span>
<span class="p_header">index 2f167a8..62bacb8 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8737.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8737.c</span>
<span class="p_chunk">@@ -494,7 +494,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-					    WM8737_VMIDSEL_MASK, 0x4);</span>
<span class="p_add">+					    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+					    2 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
<span class="p_chunk">@@ -508,7 +509,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-				    WM8737_VMIDSEL_MASK, 2);</span>
<span class="p_add">+				    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+				    1 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 		break;
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h</span>
<span class="p_header">index db94931..0bb4a64 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.h</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.h</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> extern int wm8903_mic_detect(struct snd_soc_codec *codec,</span>
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
<span class="p_del">-#define WM8903_VMID_RES_250K                         3</span>
<span class="p_add">+#define WM8903_VMID_RES_250K                         4</span>
 #define WM8903_VMID_RES_5K                           6
 
 /*
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 1c1fc61..475fc24 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static int wm8955_configure_clocking(struct snd_soc_codec *codec)</span>
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k &gt;&gt; 9) &amp; WM8955_K_17_9_MASK);
<span class="p_del">-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,</span>
 				    WM8955_K_8_0_MASK,
 				    pll.k &amp; WM8955_K_8_0_MASK);
 		if (pll.k)
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index edfd4ed..e04dbaa 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> SOC_SINGLE(&quot;PCM Playback -6dB Switch&quot;, WM8960_DACCTL1, 7, 1, 0),</span>
 SOC_ENUM(&quot;ADC Polarity&quot;, wm8960_enum[0]),
 SOC_SINGLE(&quot;ADC High Pass Filter Switch&quot;, WM8960_DACCTL1, 0, 1, 0),
 
<span class="p_del">-SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[2]),</span>
<span class="p_add">+SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[1]),</span>
 SOC_SINGLE_BOOL_EXT(&quot;DAC Deemphasis Switch&quot;, 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8997.c b/sound/soc/codecs/wm8997.c</span>
<span class="p_header">index 1392bb3..2dce615 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8997.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8997.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct wm8997_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct reg_default wm8997_sysclk_reva_patch[] = {
<span class="p_header">diff --git a/sound/soc/fsl/imx-wm8962.c b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">index 3a3d17c..6644525 100644</span>
<span class="p_header">--- a/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">+++ b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> static int imx_wm8962_probe(struct platform_device *pdev)</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;audmux internal port setup failed\n&quot;);
 		return ret;
 	}
<span class="p_del">-	imx_audmux_v2_configure_port(ext_port,</span>
<span class="p_add">+	ret = imx_audmux_v2_configure_port(ext_port,</span>
 			IMX_AUDMUX_V2_PTCR_SYN,
 			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
 	if (ret) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



