
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,pull] x86/platform updates for 4.16 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,pull] x86/platform updates for 4.16</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 29, 2018, 8:54 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;alpine.DEB.2.20.1801290949460.1849@nanos&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10189433/mbox/"
   >mbox</a>
|
   <a href="/patch/10189433/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10189433/">/patch/10189433/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9D99560388 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 29 Jan 2018 08:54:42 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8B0D728866
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 29 Jan 2018 08:54:42 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7E80F28874; Mon, 29 Jan 2018 08:54:42 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 02FD228866
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 29 Jan 2018 08:54:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751724AbeA2Iyg (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 29 Jan 2018 03:54:36 -0500
Received: from Galois.linutronix.de ([146.0.238.70]:40970 &quot;EHLO
	Galois.linutronix.de&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751603AbeA2Iyd (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 29 Jan 2018 03:54:33 -0500
Received: from hsi-kbw-5-158-153-52.hsi19.kabel-badenwuerttemberg.de
	([5.158.153.52] helo=nanos) by Galois.linutronix.de with esmtpsa
	(TLS1.2:DHE_RSA_AES_256_CBC_SHA256:256) (Exim 4.80)
	(envelope-from &lt;tglx@linutronix.de&gt;)
	id 1eg5AE-0007AS-MS; Mon, 29 Jan 2018 09:51:42 +0100
Date: Mon, 29 Jan 2018 09:54:30 +0100 (CET)
From: Thomas Gleixner &lt;tglx@linutronix.de&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
cc: LKML &lt;linux-kernel@vger.kernel.org&gt;, Ingo Molnar &lt;mingo@kernel.org&gt;
Subject: [GIT pull] x86/platform updates for 4.16
Message-ID: &lt;alpine.DEB.2.20.1801290949460.1849@nanos&gt;
User-Agent: Alpine 2.20 (DEB 67 2015-01-07)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Jan. 29, 2018, 8:54 a.m.</div>
<pre class="content">
Linus,

please pull the latest x86-platform-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-platform-for-linus

The platform support for x86 contains the following updates:

  - A set of updates for the UV platform to support new CPUs and to fix
    some of the UV4A BAU MRRs

  - The initial platform support for the jailhouse hypervisor to allow
    native Linux guests (inmates) in non-root cells.

  - A fix for the PCI initialization on Intel MID platforms

Thanks,

	tglx

------------------&gt;
Andrew Banman (1):
      x86/platform/uv/BAU: Replace hard-coded values with MMR definitions

Andy Shevchenko (1):
      x86/platform/intel-mid: Move PCI initialization to arch_init()

Arnd Bergmann (1):
      x86/jailhouse: Add PCI dependency

Jan Kiszka (14):
      x86/apic: Install an empty physflat_init_apic_ldr
      x86/platform: Control warm reset setup via legacy feature flag
      x86: Introduce and use MP IRQ trigger and polarity defines
      x86/jailhouse: Add infrastructure for running in non-root cell
      x86/jailhouse: Enable APIC and SMP support
      x86/jailhouse: Enable PMTIMER
      x86/jailhouse: Set up timekeeping
      x86/jailhouse: Avoid access of unsupported platform resources
      x86/jailhouse: Silence ACPI warning
      x86/jailhouse: Halt instead of failing to restart
      x86/jailhouse: Wire up IOAPIC for legacy UART ports
      x86/jailhouse: Initialize PCI support
      x86/jailhouse: Set X86_FEATURE_TSC_KNOWN_FREQ
      x86/jailhouse: Respect pci=lastbus command line settings

Mike Travis (6):
      x86/platform/UV: Update uv_mmrs.h to prepare for UV4A fixes
      x86/platform/UV: Fix UV4A support on new Intel Processors
      x86/platform/UV: Add references to access fixed UV4A HUB MMRs
      x86/platform/UV: Fix GAM MMR changes in UV4A
      x86/platform/UV: Fix GAM MMR references in the UV x2apic code
      x86/platform/UV: Fix UV4A BAU MMRs

Thomas Gleixner (1):
      x86/jailhouse: Hide x2apic code when CONFIG_X86_X2APIC=n


 arch/x86/Kconfig                        |   9 +
 arch/x86/include/asm/hypervisor.h       |   1 +
 arch/x86/include/asm/jailhouse_para.h   |  26 ++
 arch/x86/include/asm/mpspec_def.h       |  14 +-
 arch/x86/include/asm/uv/uv_bau.h        |   1 -
 arch/x86/include/asm/uv/uv_hub.h        |  14 +
 arch/x86/include/asm/uv/uv_mmrs.h       | 749 +++++++++++++++++++++++++++-----
 arch/x86/include/asm/x86_init.h         |   1 +
 arch/x86/include/uapi/asm/bootparam.h   |  22 +
 arch/x86/kernel/Makefile                |   2 +
 arch/x86/kernel/apic/apic_flat_64.c     |  16 +-
 arch/x86/kernel/apic/io_apic.c          |  20 +-
 arch/x86/kernel/apic/x2apic_uv_x.c      |  84 ++--
 arch/x86/kernel/cpu/hypervisor.c        |   4 +
 arch/x86/kernel/jailhouse.c             | 211 +++++++++
 arch/x86/kernel/mpparse.c               |  23 +-
 arch/x86/kernel/platform-quirks.c       |   1 +
 arch/x86/kernel/smpboot.c               |   4 +-
 arch/x86/pci/intel_mid_pci.c            |   1 +
 arch/x86/platform/intel-mid/intel-mid.c |   2 +-
 arch/x86/platform/intel-mid/sfi.c       |   5 +-
 arch/x86/platform/uv/tlb_uv.c           |   3 +-
 drivers/acpi/Kconfig                    |  32 +-
 23 files changed, 1052 insertions(+), 193 deletions(-)
 create mode 100644 arch/x86/include/asm/jailhouse_para.h
 create mode 100644 arch/x86/kernel/jailhouse.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index ff4e9cd99854..390be2eb153d 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -796,6 +796,15 @@</span> <span class="p_context"> config PARAVIRT_TIME_ACCOUNTING</span>
 config PARAVIRT_CLOCK
 	bool
 
<span class="p_add">+config JAILHOUSE_GUEST</span>
<span class="p_add">+	bool &quot;Jailhouse non-root cell support&quot;</span>
<span class="p_add">+	depends on X86_64 &amp;&amp; PCI</span>
<span class="p_add">+	select X86_PM_TIMER</span>
<span class="p_add">+	---help---</span>
<span class="p_add">+	  This option allows to run Linux as guest in a Jailhouse non-root</span>
<span class="p_add">+	  cell. You can leave this option disabled if you only want to start</span>
<span class="p_add">+	  Jailhouse and run Linux afterwards in the root cell.</span>
<span class="p_add">+</span>
 endif #HYPERVISOR_GUEST
 
 config NO_BOOTMEM
<span class="p_header">diff --git a/arch/x86/include/asm/hypervisor.h b/arch/x86/include/asm/hypervisor.h</span>
<span class="p_header">index 96aa6b9884dc..8c5aaba6633f 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hypervisor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hypervisor.h</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"> enum x86_hypervisor_type {</span>
 	X86_HYPER_XEN_PV,
 	X86_HYPER_XEN_HVM,
 	X86_HYPER_KVM,
<span class="p_add">+	X86_HYPER_JAILHOUSE,</span>
 };
 
 #ifdef CONFIG_HYPERVISOR_GUEST
<span class="p_header">diff --git a/arch/x86/include/asm/jailhouse_para.h b/arch/x86/include/asm/jailhouse_para.h</span>
new file mode 100644
<span class="p_header">index 000000000000..875b54376689</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/include/asm/jailhouse_para.h</span>
<span class="p_chunk">@@ -0,0 +1,26 @@</span> <span class="p_context"></span>
<span class="p_add">+/* SPDX-License-Identifier: GPL2.0 */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Jailhouse paravirt_ops implementation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (c) Siemens AG, 2015-2017</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Authors:</span>
<span class="p_add">+ *  Jan Kiszka &lt;jan.kiszka@siemens.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_X86_JAILHOUSE_PARA_H</span>
<span class="p_add">+#define _ASM_X86_JAILHOUSE_PARA_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_JAILHOUSE_GUEST</span>
<span class="p_add">+bool jailhouse_paravirt(void);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline bool jailhouse_paravirt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_X86_JAILHOUSE_PARA_H */</span>
<span class="p_header">diff --git a/arch/x86/include/asm/mpspec_def.h b/arch/x86/include/asm/mpspec_def.h</span>
<span class="p_header">index a6bec8028480..6fb923a34309 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mpspec_def.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mpspec_def.h</span>
<span class="p_chunk">@@ -128,9 +128,17 @@</span> <span class="p_context"> enum mp_irq_source_types {</span>
 	mp_ExtINT = 3
 };
 
<span class="p_del">-#define MP_IRQDIR_DEFAULT	0</span>
<span class="p_del">-#define MP_IRQDIR_HIGH		1</span>
<span class="p_del">-#define MP_IRQDIR_LOW		3</span>
<span class="p_add">+#define MP_IRQPOL_DEFAULT	0x0</span>
<span class="p_add">+#define MP_IRQPOL_ACTIVE_HIGH	0x1</span>
<span class="p_add">+#define MP_IRQPOL_RESERVED	0x2</span>
<span class="p_add">+#define MP_IRQPOL_ACTIVE_LOW	0x3</span>
<span class="p_add">+#define MP_IRQPOL_MASK		0x3</span>
<span class="p_add">+</span>
<span class="p_add">+#define MP_IRQTRIG_DEFAULT	0x0</span>
<span class="p_add">+#define MP_IRQTRIG_EDGE		0x4</span>
<span class="p_add">+#define MP_IRQTRIG_RESERVED	0x8</span>
<span class="p_add">+#define MP_IRQTRIG_LEVEL	0xc</span>
<span class="p_add">+#define MP_IRQTRIG_MASK		0xc</span>
 
 #define MP_APIC_ALL	0xFF
 
<span class="p_header">diff --git a/arch/x86/include/asm/uv/uv_bau.h b/arch/x86/include/asm/uv/uv_bau.h</span>
<span class="p_header">index 7cac79802ad2..7803114aa140 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uv/uv_bau.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uv/uv_bau.h</span>
<span class="p_chunk">@@ -48,7 +48,6 @@</span> <span class="p_context"></span>
 #define UV2_NET_ENDPOINT_INTD		0x28
 #define UV_NET_ENDPOINT_INTD		(is_uv1_hub() ?			\
 			UV1_NET_ENDPOINT_INTD : UV2_NET_ENDPOINT_INTD)
<span class="p_del">-#define UV_DESC_PSHIFT			49</span>
 #define UV_PAYLOADQ_GNODE_SHIFT		49
 #define UV_PTC_BASENAME			&quot;sgi_uv/ptc_statistics&quot;
 #define UV_BAU_BASENAME			&quot;sgi_uv/bau_tunables&quot;
<span class="p_header">diff --git a/arch/x86/include/asm/uv/uv_hub.h b/arch/x86/include/asm/uv/uv_hub.h</span>
<span class="p_header">index 036e26d63d9a..44cf6d6deb7a 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uv/uv_hub.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uv/uv_hub.h</span>
<span class="p_chunk">@@ -241,6 +241,7 @@</span> <span class="p_context"> static inline int uv_hub_info_check(int version)</span>
 #define UV2_HUB_REVISION_BASE		3
 #define UV3_HUB_REVISION_BASE		5
 #define UV4_HUB_REVISION_BASE		7
<span class="p_add">+#define UV4A_HUB_REVISION_BASE		8	/* UV4 (fixed) rev 2 */</span>
 
 #ifdef	UV1_HUB_IS_SUPPORTED
 static inline int is_uv1_hub(void)
<span class="p_chunk">@@ -280,6 +281,19 @@</span> <span class="p_context"> static inline int is_uv3_hub(void)</span>
 }
 #endif
 
<span class="p_add">+/* First test &quot;is UV4A&quot;, then &quot;is UV4&quot; */</span>
<span class="p_add">+#ifdef	UV4A_HUB_IS_SUPPORTED</span>
<span class="p_add">+static inline int is_uv4a_hub(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (uv_hub_info-&gt;hub_revision &gt;= UV4A_HUB_REVISION_BASE);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline int is_uv4a_hub(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #ifdef	UV4_HUB_IS_SUPPORTED
 static inline int is_uv4_hub(void)
 {
<span class="p_header">diff --git a/arch/x86/include/asm/uv/uv_mmrs.h b/arch/x86/include/asm/uv/uv_mmrs.h</span>
<span class="p_header">index 548d684a7960..ecb9ddef128f 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uv/uv_mmrs.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uv/uv_mmrs.h</span>
<span class="p_chunk">@@ -39,9 +39,11 @@</span> <span class="p_context"></span>
  *	#define UV2Hxxx	b
  *	#define UV3Hxxx	c
  *	#define UV4Hxxx	d
<span class="p_add">+ *	#define UV4AHxxx e</span>
  *	#define UVHxxx	(is_uv1_hub() ? UV1Hxxx :
  *			(is_uv2_hub() ? UV2Hxxx :
  *			(is_uv3_hub() ? UV3Hxxx :
<span class="p_add">+ *			(is_uv4a_hub() ? UV4AHxxx :</span>
  *					UV4Hxxx))
  *
  * If the MMR exists on all hub types &gt; 1 but have different addresses, the
<span class="p_chunk">@@ -49,8 +51,10 @@</span> <span class="p_context"></span>
  *	#define UV2Hxxx	b
  *	#define UV3Hxxx	c
  *	#define UV4Hxxx	d
<span class="p_add">+ *	#define UV4AHxxx e</span>
  *	#define UVHxxx	(is_uv2_hub() ? UV2Hxxx :
  *			(is_uv3_hub() ? UV3Hxxx :
<span class="p_add">+ *			(is_uv4a_hub() ? UV4AHxxx :</span>
  *					UV4Hxxx))
  *
  *	union uvh_xxx {
<span class="p_chunk">@@ -63,6 +67,7 @@</span> <span class="p_context"></span>
  *		} s2;
  *		struct uv3h_xxx_s {	 # Full UV3 definition (*)
  *		} s3;
<span class="p_add">+ *		(NOTE: No struct uv4ah_xxx_s members exist)</span>
  *		struct uv4h_xxx_s {	 # Full UV4 definition (*)
  *		} s4;
  *	};
<span class="p_chunk">@@ -99,6 +104,7 @@</span> <span class="p_context"></span>
 #define UV2_HUB_IS_SUPPORTED	1
 #define UV3_HUB_IS_SUPPORTED	1
 #define UV4_HUB_IS_SUPPORTED	1
<span class="p_add">+#define UV4A_HUB_IS_SUPPORTED	1</span>
 
 /* Error function to catch undefined references */
 extern unsigned long uv_undefined(char *str);
<span class="p_chunk">@@ -2779,35 +2785,47 @@</span> <span class="p_context"> union uvh_lb_bau_sb_activation_status_1_u {</span>
 	/*is_uv4_hub*/ UV4H_LB_BAU_SB_DESCRIPTOR_BASE_32)
 
 #define UVH_LB_BAU_SB_DESCRIPTOR_BASE_PAGE_ADDRESS_SHFT	12
<span class="p_del">-#define UVH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT	49</span>
<span class="p_del">-#define UVH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK	0x7ffe000000000000UL</span>
 
<span class="p_add">+#define UV1H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT	49</span>
 #define UV1H_LB_BAU_SB_DESCRIPTOR_BASE_PAGE_ADDRESS_MASK 0x000007fffffff000UL
<span class="p_add">+#define UV1H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK	0x7ffe000000000000UL</span>
 
<span class="p_del">-</span>
<span class="p_add">+#define UV2H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT	49</span>
 #define UV2H_LB_BAU_SB_DESCRIPTOR_BASE_PAGE_ADDRESS_MASK 0x000007fffffff000UL
<span class="p_add">+#define UV2H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK	0x7ffe000000000000UL</span>
 
<span class="p_add">+#define UV3H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT	49</span>
 #define UV3H_LB_BAU_SB_DESCRIPTOR_BASE_PAGE_ADDRESS_MASK 0x000007fffffff000UL
<span class="p_add">+#define UV3H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK	0x7ffe000000000000UL</span>
 
<span class="p_add">+#define UV4H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT	49</span>
 #define UV4H_LB_BAU_SB_DESCRIPTOR_BASE_PAGE_ADDRESS_MASK 0x00003ffffffff000UL
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-union uvh_lb_bau_sb_descriptor_base_u {</span>
<span class="p_del">-	unsigned long	v;</span>
<span class="p_del">-	struct uvh_lb_bau_sb_descriptor_base_s {</span>
<span class="p_del">-		unsigned long	rsvd_0_11:12;</span>
<span class="p_del">-		unsigned long	rsvd_12_48:37;</span>
<span class="p_del">-		unsigned long	node_id:14;			/* RW */</span>
<span class="p_del">-		unsigned long	rsvd_63:1;</span>
<span class="p_del">-	} s;</span>
<span class="p_del">-	struct uv4h_lb_bau_sb_descriptor_base_s {</span>
<span class="p_del">-		unsigned long	rsvd_0_11:12;</span>
<span class="p_del">-		unsigned long	page_address:34;		/* RW */</span>
<span class="p_del">-		unsigned long	rsvd_46_48:3;</span>
<span class="p_del">-		unsigned long	node_id:14;			/* RW */</span>
<span class="p_del">-		unsigned long	rsvd_63:1;</span>
<span class="p_del">-	} s4;</span>
<span class="p_del">-};</span>
<span class="p_add">+#define UV4H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK	0x7ffe000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4AH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT	53</span>
<span class="p_add">+#define UV4AH_LB_BAU_SB_DESCRIPTOR_BASE_PAGE_ADDRESS_MASK 0x000ffffffffff000UL</span>
<span class="p_add">+#define UV4AH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK	0xffe0000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT (			\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT :	\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT :	\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT :	\</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT :	\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_LB_BAU_SB_DESCRIPTOR_PAGE_ADDRESS_MASK (			\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_LB_BAU_SB_DESCRIPTOR_PAGE_ADDRESS_MASK :	\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_LB_BAU_SB_DESCRIPTOR_PAGE_ADDRESS_MASK :	\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_LB_BAU_SB_DESCRIPTOR_PAGE_ADDRESS_MASK :	\</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_LB_BAU_SB_DESCRIPTOR_PAGE_ADDRESS_MASK :	\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_LB_BAU_SB_DESCRIPTOR_PAGE_ADDRESS_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK (			\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK :	\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK :	\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK :	\</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK :	\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_MASK)</span>
 
 /* ========================================================================= */
 /*                               UVH_NODE_ID                                 */
<span class="p_chunk">@@ -3031,6 +3049,41 @@</span> <span class="p_context"> union uvh_node_present_table_u {</span>
 #define UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_MASK 0x001f000000000000UL
 #define UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_MASK 0x8000000000000000UL
 
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
 
 union uvh_rh_gam_alias210_overlay_config_0_mmr_u {
 	unsigned long	v;
<span class="p_chunk">@@ -3042,6 +3095,46 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_overlay_config_0_mmr_u {</span>
 		unsigned long	rsvd_53_62:10;
 		unsigned long	enable:1;			/* RW */
 	} s;
<span class="p_add">+	struct uv1h_rh_gam_alias210_overlay_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s1;</span>
<span class="p_add">+	struct uvxh_rh_gam_alias210_overlay_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} sx;</span>
<span class="p_add">+	struct uv2h_rh_gam_alias210_overlay_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s2;</span>
<span class="p_add">+	struct uv3h_rh_gam_alias210_overlay_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_alias210_overlay_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s4;</span>
 };
 
 /* ========================================================================= */
<span class="p_chunk">@@ -3064,6 +3157,41 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_overlay_config_0_mmr_u {</span>
 #define UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_MASK 0x001f000000000000UL
 #define UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_MASK 0x8000000000000000UL
 
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
 
 union uvh_rh_gam_alias210_overlay_config_1_mmr_u {
 	unsigned long	v;
<span class="p_chunk">@@ -3075,6 +3203,46 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_overlay_config_1_mmr_u {</span>
 		unsigned long	rsvd_53_62:10;
 		unsigned long	enable:1;			/* RW */
 	} s;
<span class="p_add">+	struct uv1h_rh_gam_alias210_overlay_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s1;</span>
<span class="p_add">+	struct uvxh_rh_gam_alias210_overlay_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} sx;</span>
<span class="p_add">+	struct uv2h_rh_gam_alias210_overlay_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s2;</span>
<span class="p_add">+	struct uv3h_rh_gam_alias210_overlay_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_alias210_overlay_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s4;</span>
 };
 
 /* ========================================================================= */
<span class="p_chunk">@@ -3097,6 +3265,41 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_overlay_config_1_mmr_u {</span>
 #define UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_MASK 0x001f000000000000UL
 #define UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_MASK 0x8000000000000000UL
 
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_SHFT 24</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_SHFT 48</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_BASE_MASK 0x00000000ff000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_M_ALIAS_MASK 0x001f000000000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
 
 union uvh_rh_gam_alias210_overlay_config_2_mmr_u {
 	unsigned long	v;
<span class="p_chunk">@@ -3108,6 +3311,46 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_overlay_config_2_mmr_u {</span>
 		unsigned long	rsvd_53_62:10;
 		unsigned long	enable:1;			/* RW */
 	} s;
<span class="p_add">+	struct uv1h_rh_gam_alias210_overlay_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s1;</span>
<span class="p_add">+	struct uvxh_rh_gam_alias210_overlay_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} sx;</span>
<span class="p_add">+	struct uv2h_rh_gam_alias210_overlay_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s2;</span>
<span class="p_add">+	struct uv3h_rh_gam_alias210_overlay_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_alias210_overlay_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	base:8;				/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_32_47:16;</span>
<span class="p_add">+		unsigned long	m_alias:5;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_53_62:10;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s4;</span>
 };
 
 /* ========================================================================= */
<span class="p_chunk">@@ -3126,6 +3369,21 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_overlay_config_2_mmr_u {</span>
 #define UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_SHFT 24
 #define UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_MASK 0x00003fffff000000UL
 
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
 
 union uvh_rh_gam_alias210_redirect_config_0_mmr_u {
 	unsigned long	v;
<span class="p_chunk">@@ -3134,6 +3392,31 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_redirect_config_0_mmr_u {</span>
 		unsigned long	dest_base:22;			/* RW */
 		unsigned long	rsvd_46_63:18;
 	} s;
<span class="p_add">+	struct uv1h_rh_gam_alias210_redirect_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s1;</span>
<span class="p_add">+	struct uvxh_rh_gam_alias210_redirect_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} sx;</span>
<span class="p_add">+	struct uv2h_rh_gam_alias210_redirect_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s2;</span>
<span class="p_add">+	struct uv3h_rh_gam_alias210_redirect_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_alias210_redirect_config_0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s4;</span>
 };
 
 /* ========================================================================= */
<span class="p_chunk">@@ -3152,6 +3435,21 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_redirect_config_0_mmr_u {</span>
 #define UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_SHFT 24
 #define UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_MASK 0x00003fffff000000UL
 
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
 
 union uvh_rh_gam_alias210_redirect_config_1_mmr_u {
 	unsigned long	v;
<span class="p_chunk">@@ -3160,6 +3458,31 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_redirect_config_1_mmr_u {</span>
 		unsigned long	dest_base:22;			/* RW */
 		unsigned long	rsvd_46_63:18;
 	} s;
<span class="p_add">+	struct uv1h_rh_gam_alias210_redirect_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s1;</span>
<span class="p_add">+	struct uvxh_rh_gam_alias210_redirect_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} sx;</span>
<span class="p_add">+	struct uv2h_rh_gam_alias210_redirect_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s2;</span>
<span class="p_add">+	struct uv3h_rh_gam_alias210_redirect_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_alias210_redirect_config_1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s4;</span>
 };
 
 /* ========================================================================= */
<span class="p_chunk">@@ -3178,6 +3501,21 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_redirect_config_1_mmr_u {</span>
 #define UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_SHFT 24
 #define UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_MASK 0x00003fffff000000UL
 
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV1H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UVXH_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV2H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV3H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_SHFT 24</span>
<span class="p_add">+#define UV4H_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR_DEST_BASE_MASK 0x00003fffff000000UL</span>
<span class="p_add">+</span>
 
 union uvh_rh_gam_alias210_redirect_config_2_mmr_u {
 	unsigned long	v;
<span class="p_chunk">@@ -3186,6 +3524,31 @@</span> <span class="p_context"> union uvh_rh_gam_alias210_redirect_config_2_mmr_u {</span>
 		unsigned long	dest_base:22;			/* RW */
 		unsigned long	rsvd_46_63:18;
 	} s;
<span class="p_add">+	struct uv1h_rh_gam_alias210_redirect_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s1;</span>
<span class="p_add">+	struct uvxh_rh_gam_alias210_redirect_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} sx;</span>
<span class="p_add">+	struct uv2h_rh_gam_alias210_redirect_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s2;</span>
<span class="p_add">+	struct uv3h_rh_gam_alias210_redirect_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_alias210_redirect_config_2_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_23:24;</span>
<span class="p_add">+		unsigned long	dest_base:22;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_46_63:18;</span>
<span class="p_add">+	} s4;</span>
 };
 
 /* ========================================================================= */
<span class="p_chunk">@@ -3384,6 +3747,162 @@</span> <span class="p_context"> union uvh_rh_gam_gru_overlay_config_mmr_u {</span>
 };
 
 /* ========================================================================= */
<span class="p_add">+/*                   UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR                    */</span>
<span class="p_add">+/* ========================================================================= */</span>
<span class="p_add">+#define UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR uv_undefined(&quot;UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR&quot;)</span>
<span class="p_add">+#define UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR uv_undefined(&quot;UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR&quot;)</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR 0x1603000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR 0x483000UL</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR (				\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR :		\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR :		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR :		\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_SHFT	26</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT	46</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK	0x00003ffffc000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK	0x000fc00000000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_SHFT	26</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT	46</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK	0x00003ffffc000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK	0x000fc00000000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT 52</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK 0x000ffffffc000000UL</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK 0x03f0000000000000UL</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+union uvh_rh_gam_mmioh_overlay_config0_mmr_u {</span>
<span class="p_add">+	unsigned long	v;</span>
<span class="p_add">+	struct uv3h_rh_gam_mmioh_overlay_config0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_25:26;</span>
<span class="p_add">+		unsigned long	base:20;			/* RW */</span>
<span class="p_add">+		unsigned long	m_io:6;				/* RW */</span>
<span class="p_add">+		unsigned long	n_io:4;</span>
<span class="p_add">+		unsigned long	rsvd_56_62:7;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_mmioh_overlay_config0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_25:26;</span>
<span class="p_add">+		unsigned long	base:20;			/* RW */</span>
<span class="p_add">+		unsigned long	m_io:6;				/* RW */</span>
<span class="p_add">+		unsigned long	n_io:4;</span>
<span class="p_add">+		unsigned long	rsvd_56_62:7;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s4;</span>
<span class="p_add">+	struct uv4ah_rh_gam_mmioh_overlay_config0_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_25:26;</span>
<span class="p_add">+		unsigned long	base:26;			/* RW */</span>
<span class="p_add">+		unsigned long	m_io:6;				/* RW */</span>
<span class="p_add">+		unsigned long	n_io:4;</span>
<span class="p_add">+		unsigned long	undef_62:1;			/* Undefined */</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s4a;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* ========================================================================= */</span>
<span class="p_add">+/*                   UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR                    */</span>
<span class="p_add">+/* ========================================================================= */</span>
<span class="p_add">+#define UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR uv_undefined(&quot;UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR&quot;)</span>
<span class="p_add">+#define UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR uv_undefined(&quot;UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR&quot;)</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR 0x1603000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR 0x483000UL</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR (				\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR :		\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR :		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR :		\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_SHFT	26</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT	46</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK	0x00003ffffc000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK	0x000fc00000000000UL</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_SHFT	26</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT	46</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_ENABLE_SHFT 63</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK	0x00003ffffc000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK	0x000fc00000000000UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT 52</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK 0x000ffffffc000000UL</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK 0x03f0000000000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+union uvh_rh_gam_mmioh_overlay_config1_mmr_u {</span>
<span class="p_add">+	unsigned long	v;</span>
<span class="p_add">+	struct uv3h_rh_gam_mmioh_overlay_config1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_25:26;</span>
<span class="p_add">+		unsigned long	base:20;			/* RW */</span>
<span class="p_add">+		unsigned long	m_io:6;				/* RW */</span>
<span class="p_add">+		unsigned long	n_io:4;</span>
<span class="p_add">+		unsigned long	rsvd_56_62:7;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_mmioh_overlay_config1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_25:26;</span>
<span class="p_add">+		unsigned long	base:20;			/* RW */</span>
<span class="p_add">+		unsigned long	m_io:6;				/* RW */</span>
<span class="p_add">+		unsigned long	n_io:4;</span>
<span class="p_add">+		unsigned long	rsvd_56_62:7;</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s4;</span>
<span class="p_add">+	struct uv4ah_rh_gam_mmioh_overlay_config1_mmr_s {</span>
<span class="p_add">+		unsigned long	rsvd_0_25:26;</span>
<span class="p_add">+		unsigned long	base:26;			/* RW */</span>
<span class="p_add">+		unsigned long	m_io:6;				/* RW */</span>
<span class="p_add">+		unsigned long	n_io:4;</span>
<span class="p_add">+		unsigned long	undef_62:1;			/* Undefined */</span>
<span class="p_add">+		unsigned long	enable:1;			/* RW */</span>
<span class="p_add">+	} s4a;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* ========================================================================= */</span>
 /*                   UVH_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR                     */
 /* ========================================================================= */
 #define UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR 0x1600030UL
<span class="p_chunk">@@ -3438,6 +3957,112 @@</span> <span class="p_context"> union uvh_rh_gam_mmioh_overlay_config_mmr_u {</span>
 };
 
 /* ========================================================================= */
<span class="p_add">+/*                  UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR                    */</span>
<span class="p_add">+/* ========================================================================= */</span>
<span class="p_add">+#define UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR uv_undefined(&quot;UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR&quot;)</span>
<span class="p_add">+#define UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR uv_undefined(&quot;UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR&quot;)</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR 0x1603800UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR 0x483800UL</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR (				\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR :		\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR :		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR :		\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH uv_undefined(&quot;UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH&quot;)</span>
<span class="p_add">+#define UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH uv_undefined(&quot;UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH&quot;)</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH 128</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH 128</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH (			\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH :	\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH :	\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH :	\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_SHFT 0</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK 0x0000000000007fffUL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_SHFT 0</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK 0x0000000000007fffUL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK 0x0000000000000fffUL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+union uvh_rh_gam_mmioh_redirect_config0_mmr_u {</span>
<span class="p_add">+	unsigned long	v;</span>
<span class="p_add">+	struct uv3h_rh_gam_mmioh_redirect_config0_mmr_s {</span>
<span class="p_add">+		unsigned long	nasid:15;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_15_63:49;</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_mmioh_redirect_config0_mmr_s {</span>
<span class="p_add">+		unsigned long	nasid:15;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_15_63:49;</span>
<span class="p_add">+	} s4;</span>
<span class="p_add">+	struct uv4ah_rh_gam_mmioh_redirect_config0_mmr_s {</span>
<span class="p_add">+		unsigned long	nasid:12;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_12_63:52;</span>
<span class="p_add">+	} s4a;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* ========================================================================= */</span>
<span class="p_add">+/*                  UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR                    */</span>
<span class="p_add">+/* ========================================================================= */</span>
<span class="p_add">+#define UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR uv_undefined(&quot;UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR&quot;)</span>
<span class="p_add">+#define UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR uv_undefined(&quot;UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR&quot;)</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR 0x1604800UL</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR 0x484800UL</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR (				\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR :		\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR :		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR :		\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR)</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH uv_undefined(&quot;UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH&quot;)</span>
<span class="p_add">+#define UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH uv_undefined(&quot;UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH&quot;)</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH 128</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH 128</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH (			\</span>
<span class="p_add">+	is_uv1_hub() ? UV1H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH :	\</span>
<span class="p_add">+	is_uv2_hub() ? UV2H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH :	\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH :	\</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_SHFT 0</span>
<span class="p_add">+#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK 0x0000000000007fffUL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_SHFT 0</span>
<span class="p_add">+#define UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK 0x0000000000007fffUL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UV4AH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK 0x0000000000000fffUL</span>
<span class="p_add">+</span>
<span class="p_add">+#define UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK (		\</span>
<span class="p_add">+	is_uv3_hub() ? UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK : \</span>
<span class="p_add">+	is_uv4a_hub() ? UV4AH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK : \</span>
<span class="p_add">+	/*is_uv4_hub*/ UV4H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK)</span>
<span class="p_add">+</span>
<span class="p_add">+union uvh_rh_gam_mmioh_redirect_config1_mmr_u {</span>
<span class="p_add">+	unsigned long	v;</span>
<span class="p_add">+	struct uv3h_rh_gam_mmioh_redirect_config1_mmr_s {</span>
<span class="p_add">+		unsigned long	nasid:15;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_15_63:49;</span>
<span class="p_add">+	} s3;</span>
<span class="p_add">+	struct uv4h_rh_gam_mmioh_redirect_config1_mmr_s {</span>
<span class="p_add">+		unsigned long	nasid:15;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_15_63:49;</span>
<span class="p_add">+	} s4;</span>
<span class="p_add">+	struct uv4ah_rh_gam_mmioh_redirect_config1_mmr_s {</span>
<span class="p_add">+		unsigned long	nasid:12;			/* RW */</span>
<span class="p_add">+		unsigned long	rsvd_12_63:52;</span>
<span class="p_add">+	} s4a;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* ========================================================================= */</span>
 /*                    UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR                      */
 /* ========================================================================= */
 #define UV1H_RH_GAM_MMR_OVERLAY_CONFIG_MMR 0x1600028UL
<span class="p_chunk">@@ -4138,88 +4763,6 @@</span> <span class="p_context"> union uv3h_gr0_gam_gr_config_u {</span>
 };
 
 /* ========================================================================= */
<span class="p_del">-/*                   UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR                   */</span>
<span class="p_del">-/* ========================================================================= */</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR		0x1603000UL</span>
<span class="p_del">-</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_SHFT	26</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT	46</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_SHFT 63</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK	0x00003ffffc000000UL</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK	0x000fc00000000000UL</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_del">-</span>
<span class="p_del">-union uv3h_rh_gam_mmioh_overlay_config0_mmr_u {</span>
<span class="p_del">-	unsigned long	v;</span>
<span class="p_del">-	struct uv3h_rh_gam_mmioh_overlay_config0_mmr_s {</span>
<span class="p_del">-		unsigned long	rsvd_0_25:26;</span>
<span class="p_del">-		unsigned long	base:20;			/* RW */</span>
<span class="p_del">-		unsigned long	m_io:6;				/* RW */</span>
<span class="p_del">-		unsigned long	n_io:4;</span>
<span class="p_del">-		unsigned long	rsvd_56_62:7;</span>
<span class="p_del">-		unsigned long	enable:1;			/* RW */</span>
<span class="p_del">-	} s3;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* ========================================================================= */</span>
<span class="p_del">-/*                   UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR                   */</span>
<span class="p_del">-/* ========================================================================= */</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR		0x1604000UL</span>
<span class="p_del">-</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_SHFT	26</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT	46</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_ENABLE_SHFT 63</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK	0x00003ffffc000000UL</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK	0x000fc00000000000UL</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_ENABLE_MASK 0x8000000000000000UL</span>
<span class="p_del">-</span>
<span class="p_del">-union uv3h_rh_gam_mmioh_overlay_config1_mmr_u {</span>
<span class="p_del">-	unsigned long	v;</span>
<span class="p_del">-	struct uv3h_rh_gam_mmioh_overlay_config1_mmr_s {</span>
<span class="p_del">-		unsigned long	rsvd_0_25:26;</span>
<span class="p_del">-		unsigned long	base:20;			/* RW */</span>
<span class="p_del">-		unsigned long	m_io:6;				/* RW */</span>
<span class="p_del">-		unsigned long	n_io:4;</span>
<span class="p_del">-		unsigned long	rsvd_56_62:7;</span>
<span class="p_del">-		unsigned long	enable:1;			/* RW */</span>
<span class="p_del">-	} s3;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* ========================================================================= */</span>
<span class="p_del">-/*                  UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR                   */</span>
<span class="p_del">-/* ========================================================================= */</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR		0x1603800UL</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH	128</span>
<span class="p_del">-</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_SHFT 0</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK 0x0000000000007fffUL</span>
<span class="p_del">-</span>
<span class="p_del">-union uv3h_rh_gam_mmioh_redirect_config0_mmr_u {</span>
<span class="p_del">-	unsigned long	v;</span>
<span class="p_del">-	struct uv3h_rh_gam_mmioh_redirect_config0_mmr_s {</span>
<span class="p_del">-		unsigned long	nasid:15;			/* RW */</span>
<span class="p_del">-		unsigned long	rsvd_15_63:49;</span>
<span class="p_del">-	} s3;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* ========================================================================= */</span>
<span class="p_del">-/*                  UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR                   */</span>
<span class="p_del">-/* ========================================================================= */</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR		0x1604800UL</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH	128</span>
<span class="p_del">-</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_SHFT 0</span>
<span class="p_del">-#define UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK 0x0000000000007fffUL</span>
<span class="p_del">-</span>
<span class="p_del">-union uv3h_rh_gam_mmioh_redirect_config1_mmr_u {</span>
<span class="p_del">-	unsigned long	v;</span>
<span class="p_del">-	struct uv3h_rh_gam_mmioh_redirect_config1_mmr_s {</span>
<span class="p_del">-		unsigned long	nasid:15;			/* RW */</span>
<span class="p_del">-		unsigned long	rsvd_15_63:49;</span>
<span class="p_del">-	} s3;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* ========================================================================= */</span>
 /*                       UV4H_LB_PROC_INTD_QUEUE_FIRST                       */
 /* ========================================================================= */
 #define UV4H_LB_PROC_INTD_QUEUE_FIRST			0xa4100UL
<span class="p_header">diff --git a/arch/x86/include/asm/x86_init.h b/arch/x86/include/asm/x86_init.h</span>
<span class="p_header">index aa4747569e23..fc2f082ac635 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/x86_init.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/x86_init.h</span>
<span class="p_chunk">@@ -212,6 +212,7 @@</span> <span class="p_context"> enum x86_legacy_i8042_state {</span>
 struct x86_legacy_features {
 	enum x86_legacy_i8042_state i8042;
 	int rtc;
<span class="p_add">+	int warm_reset;</span>
 	int no_vga;
 	int reserve_bios_regions;
 	struct x86_legacy_devices devices;
<span class="p_header">diff --git a/arch/x86/include/uapi/asm/bootparam.h b/arch/x86/include/uapi/asm/bootparam.h</span>
<span class="p_header">index afdd5ae0fcc4..aebf60357758 100644</span>
<span class="p_header">--- a/arch/x86/include/uapi/asm/bootparam.h</span>
<span class="p_header">+++ b/arch/x86/include/uapi/asm/bootparam.h</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
 #define SETUP_PCI			3
 #define SETUP_EFI			4
 #define SETUP_APPLE_PROPERTIES		5
<span class="p_add">+#define SETUP_JAILHOUSE			6</span>
 
 /* ram_size flags */
 #define RAMDISK_IMAGE_START_MASK	0x07FF
<span class="p_chunk">@@ -126,6 +127,27 @@</span> <span class="p_context"> struct boot_e820_entry {</span>
 	__u32 type;
 } __attribute__((packed));
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Smallest compatible version of jailhouse_setup_data required by this kernel.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define JAILHOUSE_SETUP_REQUIRED_VERSION	1</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The boot loader is passing platform information via this Jailhouse-specific</span>
<span class="p_add">+ * setup data structure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct jailhouse_setup_data {</span>
<span class="p_add">+	u16	version;</span>
<span class="p_add">+	u16	compatible_version;</span>
<span class="p_add">+	u16	pm_timer_address;</span>
<span class="p_add">+	u16	num_cpus;</span>
<span class="p_add">+	u64	pci_mmconfig_base;</span>
<span class="p_add">+	u32	tsc_khz;</span>
<span class="p_add">+	u32	apic_khz;</span>
<span class="p_add">+	u8	standard_ioapic;</span>
<span class="p_add">+	u8	cpu_ids[255];</span>
<span class="p_add">+} __attribute__((packed));</span>
<span class="p_add">+</span>
 /* The so-called &quot;zeropage&quot; */
 struct boot_params {
 	struct screen_info screen_info;			/* 0x000 */
<span class="p_header">diff --git a/arch/x86/kernel/Makefile b/arch/x86/kernel/Makefile</span>
<span class="p_header">index 81bb565f4497..aed9296dccd3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/Makefile</span>
<span class="p_header">+++ b/arch/x86/kernel/Makefile</span>
<span class="p_chunk">@@ -112,6 +112,8 @@</span> <span class="p_context"> obj-$(CONFIG_PARAVIRT_SPINLOCKS)+= paravirt-spinlocks.o</span>
 obj-$(CONFIG_PARAVIRT_CLOCK)	+= pvclock.o
 obj-$(CONFIG_X86_PMEM_LEGACY_DEVICE) += pmem.o
 
<span class="p_add">+obj-$(CONFIG_JAILHOUSE_GUEST)	+= jailhouse.o</span>
<span class="p_add">+</span>
 obj-$(CONFIG_EISA)		+= eisa.o
 obj-$(CONFIG_PCSPKR_PLATFORM)	+= pcspeaker.o
 
<span class="p_header">diff --git a/arch/x86/kernel/apic/apic_flat_64.c b/arch/x86/kernel/apic/apic_flat_64.c</span>
<span class="p_header">index 25a87028cb3f..fcce5a784c71 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/apic_flat_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/apic_flat_64.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/smp.h&gt;
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/ipi.h&gt;
<span class="p_add">+#include &lt;asm/jailhouse_para.h&gt;</span>
 
 #include &lt;linux/acpi.h&gt;
 
<span class="p_chunk">@@ -218,6 +219,15 @@</span> <span class="p_context"> static int physflat_acpi_madt_oem_check(char *oem_id, char *oem_table_id)</span>
 	return 0;
 }
 
<span class="p_add">+static void physflat_init_apic_ldr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * LDR and DFR are not involved in physflat mode, rather:</span>
<span class="p_add">+	 * &quot;In physical destination mode, the destination processor is</span>
<span class="p_add">+	 * specified by its local APIC ID [...].&quot; (Intel SDM, 10.6.2.1)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void physflat_send_IPI_allbutself(int vector)
 {
 	default_send_IPI_mask_allbutself_phys(cpu_online_mask, vector);
<span class="p_chunk">@@ -230,7 +240,8 @@</span> <span class="p_context"> static void physflat_send_IPI_all(int vector)</span>
 
 static int physflat_probe(void)
 {
<span class="p_del">-	if (apic == &amp;apic_physflat || num_possible_cpus() &gt; 8)</span>
<span class="p_add">+	if (apic == &amp;apic_physflat || num_possible_cpus() &gt; 8 ||</span>
<span class="p_add">+	    jailhouse_paravirt())</span>
 		return 1;
 
 	return 0;
<span class="p_chunk">@@ -251,8 +262,7 @@</span> <span class="p_context"> static struct apic apic_physflat __ro_after_init = {</span>
 	.dest_logical			= 0,
 	.check_apicid_used		= NULL,
 
<span class="p_del">-	/* not needed, but shouldn&#39;t hurt: */</span>
<span class="p_del">-	.init_apic_ldr			= flat_init_apic_ldr,</span>
<span class="p_add">+	.init_apic_ldr			= physflat_init_apic_ldr,</span>
 
 	.ioapic_phys_id_map		= NULL,
 	.setup_apic_routing		= NULL,
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index 8a7963421460..8ad2e410974f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -800,18 +800,18 @@</span> <span class="p_context"> static int irq_polarity(int idx)</span>
 	/*
 	 * Determine IRQ line polarity (high active or low active):
 	 */
<span class="p_del">-	switch (mp_irqs[idx].irqflag &amp; 0x03) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_add">+	switch (mp_irqs[idx].irqflag &amp; MP_IRQPOL_MASK) {</span>
<span class="p_add">+	case MP_IRQPOL_DEFAULT:</span>
 		/* conforms to spec, ie. bus-type dependent polarity */
 		if (test_bit(bus, mp_bus_not_pci))
 			return default_ISA_polarity(idx);
 		else
 			return default_PCI_polarity(idx);
<span class="p_del">-	case 1:</span>
<span class="p_add">+	case MP_IRQPOL_ACTIVE_HIGH:</span>
 		return IOAPIC_POL_HIGH;
<span class="p_del">-	case 2:</span>
<span class="p_add">+	case MP_IRQPOL_RESERVED:</span>
 		pr_warn(&quot;IOAPIC: Invalid polarity: 2, defaulting to low\n&quot;);
<span class="p_del">-	case 3:</span>
<span class="p_add">+	case MP_IRQPOL_ACTIVE_LOW:</span>
 	default: /* Pointless default required due to do gcc stupidity */
 		return IOAPIC_POL_LOW;
 	}
<span class="p_chunk">@@ -845,8 +845,8 @@</span> <span class="p_context"> static int irq_trigger(int idx)</span>
 	/*
 	 * Determine IRQ trigger mode (edge or level sensitive):
 	 */
<span class="p_del">-	switch ((mp_irqs[idx].irqflag &gt;&gt; 2) &amp; 0x03) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_add">+	switch (mp_irqs[idx].irqflag &amp; MP_IRQTRIG_MASK) {</span>
<span class="p_add">+	case MP_IRQTRIG_DEFAULT:</span>
 		/* conforms to spec, ie. bus-type dependent trigger mode */
 		if (test_bit(bus, mp_bus_not_pci))
 			trigger = default_ISA_trigger(idx);
<span class="p_chunk">@@ -854,11 +854,11 @@</span> <span class="p_context"> static int irq_trigger(int idx)</span>
 			trigger = default_PCI_trigger(idx);
 		/* Take EISA into account */
 		return eisa_irq_trigger(idx, bus, trigger);
<span class="p_del">-	case 1:</span>
<span class="p_add">+	case MP_IRQTRIG_EDGE:</span>
 		return IOAPIC_EDGE;
<span class="p_del">-	case 2:</span>
<span class="p_add">+	case MP_IRQTRIG_RESERVED:</span>
 		pr_warn(&quot;IOAPIC: Invalid trigger mode 2 defaulting to level\n&quot;);
<span class="p_del">-	case 3:</span>
<span class="p_add">+	case MP_IRQTRIG_LEVEL:</span>
 	default: /* Pointless default required due to do gcc stupidity */
 		return IOAPIC_LEVEL;
 	}
<span class="p_header">diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">index e1b8e8bf6b3c..46b675aaf20b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_chunk">@@ -137,6 +137,8 @@</span> <span class="p_context"> static int __init early_get_pnodeid(void)</span>
 	case UV3_HUB_PART_NUMBER_X:
 		uv_min_hub_revision_id += UV3_HUB_REVISION_BASE;
 		break;
<span class="p_add">+</span>
<span class="p_add">+	/* Update: UV4A has only a modified revision to indicate HUB fixes */</span>
 	case UV4_HUB_PART_NUMBER:
 		uv_min_hub_revision_id += UV4_HUB_REVISION_BASE - 1;
 		uv_cpuid.gnode_shift = 2; /* min partition is 4 sockets */
<span class="p_chunk">@@ -316,6 +318,7 @@</span> <span class="p_context"> static int __init uv_acpi_madt_oem_check(char *oem_id, char *oem_table_id)</span>
 	} else if (!strcmp(oem_table_id, &quot;UVH&quot;)) {
 		/* Only UV1 systems: */
 		uv_system_type = UV_NON_UNIQUE_APIC;
<span class="p_add">+		x86_platform.legacy.warm_reset = 0;</span>
 		__this_cpu_write(x2apic_extra_bits, pnodeid &lt;&lt; uvh_apicid.s.pnode_shift);
 		uv_set_apicid_hibit();
 		uv_apic = 1;
<span class="p_chunk">@@ -767,6 +770,7 @@</span> <span class="p_context"> static __init void map_gru_high(int max_pnode)</span>
 		return;
 	}
 
<span class="p_add">+	/* Only UV3 has distributed GRU mode */</span>
 	if (is_uv3_hub() &amp;&amp; gru.s3.mode) {
 		map_gru_distributed(gru.v);
 		return;
<span class="p_chunk">@@ -790,63 +794,61 @@</span> <span class="p_context"> static __init void map_mmr_high(int max_pnode)</span>
 		pr_info(&quot;UV: MMR disabled\n&quot;);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * This commonality works because both 0 &amp; 1 versions of the MMIOH OVERLAY</span>
<span class="p_del">- * and REDIRECT MMR regs are exactly the same on UV3.</span>
<span class="p_del">- */</span>
<span class="p_del">-struct mmioh_config {</span>
<span class="p_del">-	unsigned long overlay;</span>
<span class="p_del">-	unsigned long redirect;</span>
<span class="p_del">-	char *id;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static __initdata struct mmioh_config mmiohs[] = {</span>
<span class="p_del">-	{</span>
<span class="p_del">-		UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR,</span>
<span class="p_del">-		UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR,</span>
<span class="p_del">-		&quot;MMIOH0&quot;</span>
<span class="p_del">-	},</span>
<span class="p_del">-	{</span>
<span class="p_del">-		UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR,</span>
<span class="p_del">-		UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR,</span>
<span class="p_del">-		&quot;MMIOH1&quot;</span>
<span class="p_del">-	},</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* UV3 &amp; UV4 have identical MMIOH overlay configs */</span>
<span class="p_del">-static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)</span>
<span class="p_add">+/* UV3/4 have identical MMIOH overlay configs, UV4A is slightly different */</span>
<span class="p_add">+static __init void map_mmioh_high_uv34(int index, int min_pnode, int max_pnode)</span>
 {
<span class="p_del">-	union uv3h_rh_gam_mmioh_overlay_config0_mmr_u overlay;</span>
<span class="p_add">+	unsigned long overlay;</span>
 	unsigned long mmr;
 	unsigned long base;
<span class="p_add">+	unsigned long nasid_mask;</span>
<span class="p_add">+	unsigned long m_overlay;</span>
 	int i, n, shift, m_io, max_io;
 	int nasid, lnasid, fi, li;
 	char *id;
 
<span class="p_del">-	id = mmiohs[index].id;</span>
<span class="p_del">-	overlay.v = uv_read_local_mmr(mmiohs[index].overlay);</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_info(&quot;UV: %s overlay 0x%lx base:0x%x m_io:%d\n&quot;, id, overlay.v, overlay.s3.base, overlay.s3.m_io);</span>
<span class="p_del">-	if (!overlay.s3.enable) {</span>
<span class="p_add">+	if (index == 0) {</span>
<span class="p_add">+		id = &quot;MMIOH0&quot;;</span>
<span class="p_add">+		m_overlay = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR;</span>
<span class="p_add">+		overlay = uv_read_local_mmr(m_overlay);</span>
<span class="p_add">+		base = overlay &amp; UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_MASK;</span>
<span class="p_add">+		mmr = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR;</span>
<span class="p_add">+		m_io = (overlay &amp; UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_MASK)</span>
<span class="p_add">+			&gt;&gt; UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT;</span>
<span class="p_add">+		shift = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_M_IO_SHFT;</span>
<span class="p_add">+		n = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH;</span>
<span class="p_add">+		nasid_mask = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_NASID_MASK;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		id = &quot;MMIOH1&quot;;</span>
<span class="p_add">+		m_overlay = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR;</span>
<span class="p_add">+		overlay = uv_read_local_mmr(m_overlay);</span>
<span class="p_add">+		base = overlay &amp; UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_BASE_MASK;</span>
<span class="p_add">+		mmr = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR;</span>
<span class="p_add">+		m_io = (overlay &amp; UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_MASK)</span>
<span class="p_add">+			&gt;&gt; UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT;</span>
<span class="p_add">+		shift = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG1_MMR_M_IO_SHFT;</span>
<span class="p_add">+		n = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_DEPTH;</span>
<span class="p_add">+		nasid_mask = UVH_RH_GAM_MMIOH_REDIRECT_CONFIG1_MMR_NASID_MASK;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pr_info(&quot;UV: %s overlay 0x%lx base:0x%lx m_io:%d\n&quot;, id, overlay, base, m_io);</span>
<span class="p_add">+	if (!(overlay &amp; UVH_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_ENABLE_MASK)) {</span>
 		pr_info(&quot;UV: %s disabled\n&quot;, id);
 		return;
 	}
 
<span class="p_del">-	shift = UV3H_RH_GAM_MMIOH_OVERLAY_CONFIG0_MMR_BASE_SHFT;</span>
<span class="p_del">-	base = (unsigned long)overlay.s3.base;</span>
<span class="p_del">-	m_io = overlay.s3.m_io;</span>
<span class="p_del">-	mmr = mmiohs[index].redirect;</span>
<span class="p_del">-	n = UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH;</span>
 	/* Convert to NASID: */
 	min_pnode *= 2;
 	max_pnode *= 2;
 	max_io = lnasid = fi = li = -1;
 
 	for (i = 0; i &lt; n; i++) {
<span class="p_del">-		union uv3h_rh_gam_mmioh_redirect_config0_mmr_u redirect;</span>
<span class="p_add">+		unsigned long m_redirect = mmr + i * 8;</span>
<span class="p_add">+		unsigned long redirect = uv_read_local_mmr(m_redirect);</span>
<span class="p_add">+</span>
<span class="p_add">+		nasid = redirect &amp; nasid_mask;</span>
<span class="p_add">+		if (i == 0)</span>
<span class="p_add">+			pr_info(&quot;UV: %s redirect base 0x%lx(@0x%lx) 0x%04x\n&quot;,</span>
<span class="p_add">+				id, redirect, m_redirect, nasid);</span>
 
<span class="p_del">-		redirect.v = uv_read_local_mmr(mmr + i * 8);</span>
<span class="p_del">-		nasid = redirect.s3.nasid;</span>
 		/* Invalid NASID: */
 		if (nasid &lt; min_pnode || max_pnode &lt; nasid)
 			nasid = -1;
<span class="p_chunk">@@ -894,8 +896,8 @@</span> <span class="p_context"> static __init void map_mmioh_high(int min_pnode, int max_pnode)</span>
 
 	if (is_uv3_hub() || is_uv4_hub()) {
 		/* Map both MMIOH regions: */
<span class="p_del">-		map_mmioh_high_uv3(0, min_pnode, max_pnode);</span>
<span class="p_del">-		map_mmioh_high_uv3(1, min_pnode, max_pnode);</span>
<span class="p_add">+		map_mmioh_high_uv34(0, min_pnode, max_pnode);</span>
<span class="p_add">+		map_mmioh_high_uv34(1, min_pnode, max_pnode);</span>
 		return;
 	}
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/hypervisor.c b/arch/x86/kernel/cpu/hypervisor.c</span>
<span class="p_header">index bea8d3e24f50..479ca4728de0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/hypervisor.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/hypervisor.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> extern const struct hypervisor_x86 x86_hyper_ms_hyperv;</span>
 extern const struct hypervisor_x86 x86_hyper_xen_pv;
 extern const struct hypervisor_x86 x86_hyper_xen_hvm;
 extern const struct hypervisor_x86 x86_hyper_kvm;
<span class="p_add">+extern const struct hypervisor_x86 x86_hyper_jailhouse;</span>
 
 static const __initconst struct hypervisor_x86 * const hypervisors[] =
 {
<span class="p_chunk">@@ -45,6 +46,9 @@</span> <span class="p_context"> static const __initconst struct hypervisor_x86 * const hypervisors[] =</span>
 #ifdef CONFIG_KVM_GUEST
 	&amp;x86_hyper_kvm,
 #endif
<span class="p_add">+#ifdef CONFIG_JAILHOUSE_GUEST</span>
<span class="p_add">+	&amp;x86_hyper_jailhouse,</span>
<span class="p_add">+#endif</span>
 };
 
 enum x86_hypervisor_type x86_hyper_type;
<span class="p_header">diff --git a/arch/x86/kernel/jailhouse.c b/arch/x86/kernel/jailhouse.c</span>
new file mode 100644
<span class="p_header">index 000000000000..b68fd895235a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/kernel/jailhouse.c</span>
<span class="p_chunk">@@ -0,0 +1,211 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL2.0</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Jailhouse paravirt_ops implementation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (c) Siemens AG, 2015-2017</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Authors:</span>
<span class="p_add">+ *  Jan Kiszka &lt;jan.kiszka@siemens.com&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/acpi_pmtmr.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+#include &lt;asm/apic.h&gt;</span>
<span class="p_add">+#include &lt;asm/cpu.h&gt;</span>
<span class="p_add">+#include &lt;asm/hypervisor.h&gt;</span>
<span class="p_add">+#include &lt;asm/i8259.h&gt;</span>
<span class="p_add">+#include &lt;asm/irqdomain.h&gt;</span>
<span class="p_add">+#include &lt;asm/pci_x86.h&gt;</span>
<span class="p_add">+#include &lt;asm/reboot.h&gt;</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static __initdata struct jailhouse_setup_data setup_data;</span>
<span class="p_add">+static unsigned int precalibrated_tsc_khz;</span>
<span class="p_add">+</span>
<span class="p_add">+static uint32_t jailhouse_cpuid_base(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (boot_cpu_data.cpuid_level &lt; 0 ||</span>
<span class="p_add">+	    !boot_cpu_has(X86_FEATURE_HYPERVISOR))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hypervisor_cpuid_base(&quot;Jailhouse\0\0\0&quot;, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static uint32_t __init jailhouse_detect(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return jailhouse_cpuid_base();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void jailhouse_get_wallclock(struct timespec *now)</span>
<span class="p_add">+{</span>
<span class="p_add">+	memset(now, 0, sizeof(*now));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init jailhouse_timer_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	lapic_timer_frequency = setup_data.apic_khz * (1000 / HZ);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long jailhouse_get_tsc(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return precalibrated_tsc_khz;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init jailhouse_x2apic_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_X2APIC</span>
<span class="p_add">+	if (!x2apic_enabled())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We do not have access to IR inside Jailhouse non-root cells.  So</span>
<span class="p_add">+	 * we have to run in physical mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	x2apic_phys = 1;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This will trigger the switch to apic_x2apic_phys.  Empty OEM IDs</span>
<span class="p_add">+	 * ensure that only this APIC driver picks up the call.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	default_acpi_madt_oem_check(&quot;&quot;, &quot;&quot;);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init jailhouse_get_smp_config(unsigned int early)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ioapic_domain_cfg ioapic_cfg = {</span>
<span class="p_add">+		.type = IOAPIC_DOMAIN_STRICT,</span>
<span class="p_add">+		.ops = &amp;mp_ioapic_irqdomain_ops,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	struct mpc_intsrc mp_irq = {</span>
<span class="p_add">+		.type = MP_INTSRC,</span>
<span class="p_add">+		.irqtype = mp_INT,</span>
<span class="p_add">+		.irqflag = MP_IRQPOL_ACTIVE_HIGH | MP_IRQTRIG_EDGE,</span>
<span class="p_add">+	};</span>
<span class="p_add">+	unsigned int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	jailhouse_x2apic_init();</span>
<span class="p_add">+</span>
<span class="p_add">+	register_lapic_address(0xfee00000);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (cpu = 0; cpu &lt; setup_data.num_cpus; cpu++) {</span>
<span class="p_add">+		generic_processor_info(setup_data.cpu_ids[cpu],</span>
<span class="p_add">+				       boot_cpu_apic_version);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	smp_found_config = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (setup_data.standard_ioapic) {</span>
<span class="p_add">+		mp_register_ioapic(0, 0xfec00000, gsi_top, &amp;ioapic_cfg);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Register 1:1 mapping for legacy UART IRQs 3 and 4 */</span>
<span class="p_add">+		mp_irq.srcbusirq = mp_irq.dstirq = 3;</span>
<span class="p_add">+		mp_save_irq(&amp;mp_irq);</span>
<span class="p_add">+</span>
<span class="p_add">+		mp_irq.srcbusirq = mp_irq.dstirq = 4;</span>
<span class="p_add">+		mp_save_irq(&amp;mp_irq);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void jailhouse_no_restart(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_notice(&quot;Jailhouse: Restart not supported, halting\n&quot;);</span>
<span class="p_add">+	machine_halt();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init jailhouse_pci_arch_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pci_direct_init(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There are no bridges on the virtual PCI root bus under Jailhouse,</span>
<span class="p_add">+	 * thus no other way to discover all devices than a full scan.</span>
<span class="p_add">+	 * Respect any overrides via the command line, though.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pcibios_last_bus &lt; 0)</span>
<span class="p_add">+		pcibios_last_bus = 0xff;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init jailhouse_init_platform(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 pa_data = boot_params.hdr.setup_data;</span>
<span class="p_add">+	struct setup_data header;</span>
<span class="p_add">+	void *mapping;</span>
<span class="p_add">+</span>
<span class="p_add">+	x86_init.irqs.pre_vector_init	= x86_init_noop;</span>
<span class="p_add">+	x86_init.timers.timer_init	= jailhouse_timer_init;</span>
<span class="p_add">+	x86_init.mpparse.get_smp_config	= jailhouse_get_smp_config;</span>
<span class="p_add">+	x86_init.pci.arch_init		= jailhouse_pci_arch_init;</span>
<span class="p_add">+</span>
<span class="p_add">+	x86_platform.calibrate_cpu	= jailhouse_get_tsc;</span>
<span class="p_add">+	x86_platform.calibrate_tsc	= jailhouse_get_tsc;</span>
<span class="p_add">+	x86_platform.get_wallclock	= jailhouse_get_wallclock;</span>
<span class="p_add">+	x86_platform.legacy.rtc		= 0;</span>
<span class="p_add">+	x86_platform.legacy.warm_reset	= 0;</span>
<span class="p_add">+	x86_platform.legacy.i8042	= X86_LEGACY_I8042_PLATFORM_ABSENT;</span>
<span class="p_add">+</span>
<span class="p_add">+	legacy_pic			= &amp;null_legacy_pic;</span>
<span class="p_add">+</span>
<span class="p_add">+	machine_ops.emergency_restart	= jailhouse_no_restart;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (pa_data) {</span>
<span class="p_add">+		mapping = early_memremap(pa_data, sizeof(header));</span>
<span class="p_add">+		memcpy(&amp;header, mapping, sizeof(header));</span>
<span class="p_add">+		early_memunmap(mapping, sizeof(header));</span>
<span class="p_add">+</span>
<span class="p_add">+		if (header.type == SETUP_JAILHOUSE &amp;&amp;</span>
<span class="p_add">+		    header.len &gt;= sizeof(setup_data)) {</span>
<span class="p_add">+			pa_data += offsetof(struct setup_data, data);</span>
<span class="p_add">+</span>
<span class="p_add">+			mapping = early_memremap(pa_data, sizeof(setup_data));</span>
<span class="p_add">+			memcpy(&amp;setup_data, mapping, sizeof(setup_data));</span>
<span class="p_add">+			early_memunmap(mapping, sizeof(setup_data));</span>
<span class="p_add">+</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		pa_data = header.next;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!pa_data)</span>
<span class="p_add">+		panic(&quot;Jailhouse: No valid setup data found&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (setup_data.compatible_version &gt; JAILHOUSE_SETUP_REQUIRED_VERSION)</span>
<span class="p_add">+		panic(&quot;Jailhouse: Unsupported setup data structure&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	pmtmr_ioport = setup_data.pm_timer_address;</span>
<span class="p_add">+	pr_debug(&quot;Jailhouse: PM-Timer IO Port: %#x\n&quot;, pmtmr_ioport);</span>
<span class="p_add">+</span>
<span class="p_add">+	precalibrated_tsc_khz = setup_data.tsc_khz;</span>
<span class="p_add">+	setup_force_cpu_cap(X86_FEATURE_TSC_KNOWN_FREQ);</span>
<span class="p_add">+</span>
<span class="p_add">+	pci_probe = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Avoid that the kernel complains about missing ACPI tables - there</span>
<span class="p_add">+	 * are none in a non-root cell.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	disable_acpi();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool jailhouse_paravirt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return jailhouse_cpuid_base() != 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool jailhouse_x2apic_available(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The x2APIC is only available if the root cell enabled it. Jailhouse</span>
<span class="p_add">+	 * does not support switching between xAPIC and x2APIC.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return x2apic_enabled();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct hypervisor_x86 x86_hyper_jailhouse __refconst = {</span>
<span class="p_add">+	.name			= &quot;Jailhouse&quot;,</span>
<span class="p_add">+	.detect			= jailhouse_detect,</span>
<span class="p_add">+	.init.init_platform	= jailhouse_init_platform,</span>
<span class="p_add">+	.init.x2apic_available	= jailhouse_x2apic_available,</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/arch/x86/kernel/mpparse.c b/arch/x86/kernel/mpparse.c</span>
<span class="p_header">index 3a4b12809ab5..27d0a1712663 100644</span>
<span class="p_header">--- a/arch/x86/kernel/mpparse.c</span>
<span class="p_header">+++ b/arch/x86/kernel/mpparse.c</span>
<span class="p_chunk">@@ -281,7 +281,7 @@</span> <span class="p_context"> static void __init construct_default_ioirq_mptable(int mpc_default_type)</span>
 	int ELCR_fallback = 0;
 
 	intsrc.type = MP_INTSRC;
<span class="p_del">-	intsrc.irqflag = 0;	/* conforming */</span>
<span class="p_add">+	intsrc.irqflag = MP_IRQTRIG_DEFAULT | MP_IRQPOL_DEFAULT;</span>
 	intsrc.srcbus = 0;
 	intsrc.dstapic = mpc_ioapic_id(0);
 
<span class="p_chunk">@@ -324,10 +324,13 @@</span> <span class="p_context"> static void __init construct_default_ioirq_mptable(int mpc_default_type)</span>
 			 *  copy that information over to the MP table in the
 			 *  irqflag field (level sensitive, active high polarity).
 			 */
<span class="p_del">-			if (ELCR_trigger(i))</span>
<span class="p_del">-				intsrc.irqflag = 13;</span>
<span class="p_del">-			else</span>
<span class="p_del">-				intsrc.irqflag = 0;</span>
<span class="p_add">+			if (ELCR_trigger(i)) {</span>
<span class="p_add">+				intsrc.irqflag = MP_IRQTRIG_LEVEL |</span>
<span class="p_add">+						 MP_IRQPOL_ACTIVE_HIGH;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				intsrc.irqflag = MP_IRQTRIG_DEFAULT |</span>
<span class="p_add">+						 MP_IRQPOL_DEFAULT;</span>
<span class="p_add">+			}</span>
 		}
 
 		intsrc.srcbusirq = i;
<span class="p_chunk">@@ -419,7 +422,7 @@</span> <span class="p_context"> static inline void __init construct_default_ISA_mptable(int mpc_default_type)</span>
 	construct_ioapic_table(mpc_default_type);
 
 	lintsrc.type = MP_LINTSRC;
<span class="p_del">-	lintsrc.irqflag = 0;		/* conforming */</span>
<span class="p_add">+	lintsrc.irqflag = MP_IRQTRIG_DEFAULT | MP_IRQPOL_DEFAULT;</span>
 	lintsrc.srcbusid = 0;
 	lintsrc.srcbusirq = 0;
 	lintsrc.destapic = MP_APIC_ALL;
<span class="p_chunk">@@ -664,7 +667,7 @@</span> <span class="p_context"> static int  __init get_MP_intsrc_index(struct mpc_intsrc *m)</span>
 	if (m-&gt;irqtype != mp_INT)
 		return 0;
 
<span class="p_del">-	if (m-&gt;irqflag != 0x0f)</span>
<span class="p_add">+	if (m-&gt;irqflag != (MP_IRQTRIG_LEVEL | MP_IRQPOL_ACTIVE_LOW))</span>
 		return 0;
 
 	/* not legacy */
<span class="p_chunk">@@ -673,7 +676,8 @@</span> <span class="p_context"> static int  __init get_MP_intsrc_index(struct mpc_intsrc *m)</span>
 		if (mp_irqs[i].irqtype != mp_INT)
 			continue;
 
<span class="p_del">-		if (mp_irqs[i].irqflag != 0x0f)</span>
<span class="p_add">+		if (mp_irqs[i].irqflag != (MP_IRQTRIG_LEVEL |</span>
<span class="p_add">+					   MP_IRQPOL_ACTIVE_LOW))</span>
 			continue;
 
 		if (mp_irqs[i].srcbus != m-&gt;srcbus)
<span class="p_chunk">@@ -784,7 +788,8 @@</span> <span class="p_context"> static int  __init replace_intsrc_all(struct mpc_table *mpc,</span>
 		if (mp_irqs[i].irqtype != mp_INT)
 			continue;
 
<span class="p_del">-		if (mp_irqs[i].irqflag != 0x0f)</span>
<span class="p_add">+		if (mp_irqs[i].irqflag != (MP_IRQTRIG_LEVEL |</span>
<span class="p_add">+					   MP_IRQPOL_ACTIVE_LOW))</span>
 			continue;
 
 		if (nr_m_spare &gt; 0) {
<span class="p_header">diff --git a/arch/x86/kernel/platform-quirks.c b/arch/x86/kernel/platform-quirks.c</span>
<span class="p_header">index 39a59299bfa0..235fe6008ac8 100644</span>
<span class="p_header">--- a/arch/x86/kernel/platform-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/platform-quirks.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"> void __init x86_early_init_platform_quirks(void)</span>
 {
 	x86_platform.legacy.i8042 = X86_LEGACY_I8042_EXPECTED_PRESENT;
 	x86_platform.legacy.rtc = 1;
<span class="p_add">+	x86_platform.legacy.warm_reset = 1;</span>
 	x86_platform.legacy.reserve_bios_regions = 0;
 	x86_platform.legacy.devices.pnpbios = 1;
 
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index ed556d50d7ed..9adcae1b135c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -934,7 +934,7 @@</span> <span class="p_context"> static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle,</span>
 	 * the targeted processor.
 	 */
 
<span class="p_del">-	if (get_uv_system_type() != UV_NON_UNIQUE_APIC) {</span>
<span class="p_add">+	if (x86_platform.legacy.warm_reset) {</span>
 
 		pr_debug(&quot;Setting warm reset code and vector.\n&quot;);
 
<span class="p_chunk">@@ -1006,7 +1006,7 @@</span> <span class="p_context"> static int do_boot_cpu(int apicid, int cpu, struct task_struct *idle,</span>
 	/* mark &quot;stuck&quot; area as not stuck */
 	*trampoline_status = 0;
 
<span class="p_del">-	if (get_uv_system_type() != UV_NON_UNIQUE_APIC) {</span>
<span class="p_add">+	if (x86_platform.legacy.warm_reset) {</span>
 		/*
 		 * Cleanup possible dangling ends...
 		 */
<span class="p_header">diff --git a/arch/x86/pci/intel_mid_pci.c b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">index 511921045312..43867bc85368 100644</span>
<span class="p_header">--- a/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">+++ b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_chunk">@@ -300,6 +300,7 @@</span> <span class="p_context"> int __init intel_mid_pci_init(void)</span>
 	pci_root_ops = intel_mid_pci_ops;
 	pci_soc_mode = 1;
 	/* Continue with standard init */
<span class="p_add">+	acpi_noirq_set();</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">index 86676cec99a1..2c67bae6bb53 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> void __init x86_intel_mid_early_setup(void)</span>
 	x86_platform.calibrate_tsc = intel_mid_calibrate_tsc;
 	x86_platform.get_nmi_reason = intel_mid_get_nmi_reason;
 
<span class="p_del">-	x86_init.pci.init = intel_mid_pci_init;</span>
<span class="p_add">+	x86_init.pci.arch_init = intel_mid_pci_init;</span>
 	x86_init.pci.fixup_irqs = x86_init_noop;
 
 	legacy_pic = &amp;null_legacy_pic;
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/sfi.c b/arch/x86/platform/intel-mid/sfi.c</span>
<span class="p_header">index 19b43e3a9f0f..7be1e1fe9ae3 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/sfi.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/sfi.c</span>
<span class="p_chunk">@@ -96,8 +96,7 @@</span> <span class="p_context"> int __init sfi_parse_mtmr(struct sfi_table_header *table)</span>
 			pentry-&gt;freq_hz, pentry-&gt;irq);
 		mp_irq.type = MP_INTSRC;
 		mp_irq.irqtype = mp_INT;
<span class="p_del">-		/* triggering mode edge bit 2-3, active high polarity bit 0-1 */</span>
<span class="p_del">-		mp_irq.irqflag = 5;</span>
<span class="p_add">+		mp_irq.irqflag = MP_IRQTRIG_EDGE | MP_IRQPOL_ACTIVE_HIGH;</span>
 		mp_irq.srcbus = MP_BUS_ISA;
 		mp_irq.srcbusirq = pentry-&gt;irq;	/* IRQ */
 		mp_irq.dstapic = MP_APIC_ALL;
<span class="p_chunk">@@ -168,7 +167,7 @@</span> <span class="p_context"> int __init sfi_parse_mrtc(struct sfi_table_header *table)</span>
 			totallen, (u32)pentry-&gt;phys_addr, pentry-&gt;irq);
 		mp_irq.type = MP_INTSRC;
 		mp_irq.irqtype = mp_INT;
<span class="p_del">-		mp_irq.irqflag = 0xf;	/* level trigger and active low */</span>
<span class="p_add">+		mp_irq.irqflag = MP_IRQTRIG_LEVEL | MP_IRQPOL_ACTIVE_LOW;</span>
 		mp_irq.srcbus = MP_BUS_ISA;
 		mp_irq.srcbusirq = pentry-&gt;irq;	/* IRQ */
 		mp_irq.dstapic = MP_APIC_ALL;
<span class="p_header">diff --git a/arch/x86/platform/uv/tlb_uv.c b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">index 8538a6723171..c2e9285d1bf1 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/tlb_uv.c</span>
<span class="p_chunk">@@ -1751,7 +1751,8 @@</span> <span class="p_context"> static void activation_descriptor_init(int node, int pnode, int base_pnode)</span>
 		uv1 = 1;
 
 	/* the 14-bit pnode */
<span class="p_del">-	write_mmr_descriptor_base(pnode, (n &lt;&lt; UV_DESC_PSHIFT | m));</span>
<span class="p_add">+	write_mmr_descriptor_base(pnode,</span>
<span class="p_add">+		(n &lt;&lt; UVH_LB_BAU_SB_DESCRIPTOR_BASE_NODE_ID_SHFT | m));</span>
 	/*
 	 * Initializing all 8 (ITEMS_PER_DESC) descriptors for each
 	 * cpu even though we only use the first one; one descriptor can
<span class="p_header">diff --git a/drivers/acpi/Kconfig b/drivers/acpi/Kconfig</span>
<span class="p_header">index 46505396869e..d650c5b6ec90 100644</span>
<span class="p_header">--- a/drivers/acpi/Kconfig</span>
<span class="p_header">+++ b/drivers/acpi/Kconfig</span>
<span class="p_chunk">@@ -361,22 +361,6 @@</span> <span class="p_context"> config ACPI_PCI_SLOT</span>
 	  i.e., segment/bus/device/function tuples, with physical slots in
 	  the system.  If you are unsure, say N.
 
<span class="p_del">-config X86_PM_TIMER</span>
<span class="p_del">-	bool &quot;Power Management Timer Support&quot; if EXPERT</span>
<span class="p_del">-	depends on X86</span>
<span class="p_del">-	default y</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  The Power Management Timer is available on all ACPI-capable,</span>
<span class="p_del">-	  in most cases even if ACPI is unusable or blacklisted.</span>
<span class="p_del">-</span>
<span class="p_del">-	  This timing source is not affected by power management features</span>
<span class="p_del">-	  like aggressive processor idling, throttling, frequency and/or</span>
<span class="p_del">-	  voltage scaling, unlike the commonly used Time Stamp Counter</span>
<span class="p_del">-	  (TSC) timing source.</span>
<span class="p_del">-</span>
<span class="p_del">-	  You should nearly always say Y here because many modern</span>
<span class="p_del">-	  systems require this timer. </span>
<span class="p_del">-</span>
 config ACPI_CONTAINER
 	bool &quot;Container and Module Devices&quot;
 	default (ACPI_HOTPLUG_MEMORY || ACPI_HOTPLUG_CPU)
<span class="p_chunk">@@ -564,3 +548,19 @@</span> <span class="p_context"> config TPS68470_PMIC_OPREGION</span>
 	  using this, are probed.
 
 endif	# ACPI
<span class="p_add">+</span>
<span class="p_add">+config X86_PM_TIMER</span>
<span class="p_add">+	bool &quot;Power Management Timer Support&quot; if EXPERT</span>
<span class="p_add">+	depends on X86 &amp;&amp; (ACPI || JAILHOUSE_GUEST)</span>
<span class="p_add">+	default y</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  The Power Management Timer is available on all ACPI-capable,</span>
<span class="p_add">+	  in most cases even if ACPI is unusable or blacklisted.</span>
<span class="p_add">+</span>
<span class="p_add">+	  This timing source is not affected by power management features</span>
<span class="p_add">+	  like aggressive processor idling, throttling, frequency and/or</span>
<span class="p_add">+	  voltage scaling, unlike the commonly used Time Stamp Counter</span>
<span class="p_add">+	  (TSC) timing source.</span>
<span class="p_add">+</span>
<span class="p_add">+	  You should nearly always say Y here because many modern</span>
<span class="p_add">+	  systems require this timer.</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



