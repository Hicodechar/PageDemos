
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.2,00/46] 3.2.81-rc1 review - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.2,00/46] 3.2.81-rc1 review</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 13, 2016, 6:45 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1465843505.3529.222.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9173787/mbox/"
   >mbox</a>
|
   <a href="/patch/9173787/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9173787/">/patch/9173787/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	1CA5C6048C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Jun 2016 18:45:28 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1091A22230
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Jun 2016 18:45:28 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 05008265B9; Mon, 13 Jun 2016 18:45:28 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 96D9322230
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 13 Jun 2016 18:45:25 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1422966AbcFMSpS (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 13 Jun 2016 14:45:18 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:44137 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1422665AbcFMSpN (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 13 Jun 2016 14:45:13 -0400
Received: from [2a02:8011:400e:2:6f00:88c8:c921:d332] (helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_256_GCM_SHA384:256) (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1bCWrG-0008AF-Qe; Mon, 13 Jun 2016 19:45:10 +0100
Received: from ben by deadeye with local (Exim 4.87)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1bCWrG-0005Zr-Hm; Mon, 13 Jun 2016 19:45:10 +0100
Message-ID: &lt;1465843505.3529.222.camel@decadent.org.uk&gt;
Subject: Re: [PATCH 3.2 00/46] 3.2.81-rc1 review
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org
Cc: torvalds@linux-foundation.org, Guenter Roeck &lt;linux@roeck-us.net&gt;,
	akpm@linux-foundation.org
Date: Mon, 13 Jun 2016 19:45:05 +0100
In-Reply-To: &lt;lsq.1465767281.501580564@decadent.org.uk&gt;
References: &lt;lsq.1465767281.501580564@decadent.org.uk&gt;
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-bTMURcPixMZ0tP2NxRP7&quot;
X-Mailer: Evolution 3.20.2-2 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 2a02:8011:400e:2:6f00:88c8:c921:d332
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - June 13, 2016, 6:45 p.m.</div>
<pre class="content">
This is the combined diff for 3.2.81-rc1 relative to 3.2.80.

Ben.

--Â 

Ben Hutchings
One of the nice things about standards is that there are so many of
them.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index f0001eb33173..ac601c4b9f57 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -2699,6 +2699,8 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 					sector if the number is odd);
 				i = IGNORE_DEVICE (don&#39;t bind to this
 					device);
<span class="p_add">+				j = NO_REPORT_LUNS (don&#39;t use report luns</span>
<span class="p_add">+					command, uas only);</span>
 				l = NOT_LOCKABLE (don&#39;t try to lock and
 					unlock ejectable media);
 				m = MAX_SECTORS_64 (don&#39;t transfer more
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 5b500f93425b..f0d68d49ce83 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 80</span>
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_add">+SUBLEVEL = 81</span>
<span class="p_add">+EXTRAVERSION = -rc1</span>
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S</span>
<span class="p_header">index 82a52b2fb13f..ed3df443e02d 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall.S</span>
<span class="p_chunk">@@ -314,7 +314,7 @@</span> <span class="p_context"> tracesys_next:</span>
 	ldo	-16(%r30),%r29			/* Reference param save area */
 #endif
 
<span class="p_del">-	comiclr,&gt;&gt;=	__NR_Linux_syscalls, %r20, %r0</span>
<span class="p_add">+	comiclr,&gt;&gt;	__NR_Linux_syscalls, %r20, %r0</span>
 	b,n	.Lsyscall_nosys
 
 	LDREGX  %r20(%r19), %r19
<span class="p_header">diff --git a/arch/powerpc/include/asm/cputable.h b/arch/powerpc/include/asm/cputable.h</span>
<span class="p_header">index e30442c539ce..9b604c05fec3 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/cputable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/cputable.h</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"></span>
 #define PPC_FEATURE_PSERIES_PERFMON_COMPAT \
 					0x00000040
 
<span class="p_add">+/* Reserved - do not use		0x00000004 */</span>
 #define PPC_FEATURE_TRUE_LE		0x00000002
 #define PPC_FEATURE_PPC_LE		0x00000001
 
<span class="p_header">diff --git a/arch/powerpc/kernel/prom.c b/arch/powerpc/kernel/prom.c</span>
<span class="p_header">index fa1235b0503b..c021af8364a3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom.c</span>
<span class="p_chunk">@@ -159,7 +159,7 @@</span> <span class="p_context"> static struct ibm_pa_feature {</span>
 	{CPU_FTR_NOEXECUTE, 0, 0,	0, 6, 0},
 	{CPU_FTR_NODSISRALIGN, 0, 0,	1, 1, 1},
 	{0, MMU_FTR_CI_LARGE_PAGE, 0,	1, 2, 0},
<span class="p_del">-	{CPU_FTR_REAL_LE, PPC_FEATURE_TRUE_LE, 5, 0, 0},</span>
<span class="p_add">+	{CPU_FTR_REAL_LE, 0, PPC_FEATURE_TRUE_LE, 5, 0, 0},</span>
 };
 
 static void __init scan_features(unsigned long node, unsigned char *ftrs,
<span class="p_header">diff --git a/arch/s390/include/asm/hugetlb.h b/arch/s390/include/asm/hugetlb.h</span>
<span class="p_header">index 799ed0f1643d..dcd46cba4ec3 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 
 #define is_hugepage_only_range(mm, addr, len)	0
 #define hugetlb_free_pgd_range			free_pgd_range
<span class="p_add">+#define hugepages_supported()			(MACHINE_HAS_HPAGE)</span>
 
 void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,
 		     pte_t *ptep, pte_t pte);
<span class="p_header">diff --git a/arch/x86/include/asm/hugetlb.h b/arch/x86/include/asm/hugetlb.h</span>
<span class="p_header">index 48fa3915fd02..4e8225c25145 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hugetlb.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hugetlb.h</span>
<span class="p_chunk">@@ -3,6 +3,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/page.h&gt;
 
<span class="p_add">+#define hugepages_supported() cpu_has_pse</span>
 
 static inline int is_hugepage_only_range(struct mm_struct *mm,
 					 unsigned long addr,
<span class="p_header">diff --git a/arch/x86/include/asm/microcode.h b/arch/x86/include/asm/microcode.h</span>
<span class="p_header">index 24215072d0e1..3a7f5f5a405d 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode.h</span>
<span class="p_chunk">@@ -61,4 +61,5 @@</span> <span class="p_context"> static inline struct microcode_ops * __init init_amd_microcode(void)</span>
 }
 #endif
 
<span class="p_add">+extern bool check_current_patch_level(u32 *rev, bool early);</span>
 #endif /* _ASM_X86_MICROCODE_H */
<span class="p_header">diff --git a/arch/x86/include/asm/uaccess_64.h b/arch/x86/include/asm/uaccess_64.h</span>
<span class="p_header">index 1c66d30971ad..31fed191a41e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uaccess_64.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uaccess_64.h</span>
<span class="p_chunk">@@ -68,11 +68,10 @@</span> <span class="p_context"> int copy_to_user(void __user *dst, const void *src, unsigned size)</span>
 }
 
 static __always_inline __must_check
<span class="p_del">-int __copy_from_user(void *dst, const void __user *src, unsigned size)</span>
<span class="p_add">+int __copy_from_user_nocheck(void *dst, const void __user *src, unsigned size)</span>
 {
 	int ret = 0;
 
<span class="p_del">-	might_fault();</span>
 	if (!__builtin_constant_p(size))
 		return copy_user_generic(dst, (__force void *)src, size);
 	switch (size) {
<span class="p_chunk">@@ -112,11 +111,17 @@</span> <span class="p_context"> int __copy_from_user(void *dst, const void __user *src, unsigned size)</span>
 }
 
 static __always_inline __must_check
<span class="p_del">-int __copy_to_user(void __user *dst, const void *src, unsigned size)</span>
<span class="p_add">+int __copy_from_user(void *dst, const void __user *src, unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	might_fault();</span>
<span class="p_add">+	return __copy_from_user_nocheck(dst, src, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static __always_inline __must_check</span>
<span class="p_add">+int __copy_to_user_nocheck(void __user *dst, const void *src, unsigned size)</span>
 {
 	int ret = 0;
 
<span class="p_del">-	might_fault();</span>
 	if (!__builtin_constant_p(size))
 		return copy_user_generic((__force void *)dst, src, size);
 	switch (size) {
<span class="p_chunk">@@ -156,6 +161,13 @@</span> <span class="p_context"> int __copy_to_user(void __user *dst, const void *src, unsigned size)</span>
 }
 
 static __always_inline __must_check
<span class="p_add">+int __copy_to_user(void __user *dst, const void *src, unsigned size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	might_fault();</span>
<span class="p_add">+	return __copy_to_user_nocheck(dst, src, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static __always_inline __must_check</span>
 int __copy_in_user(void __user *dst, const void __user *src, unsigned size)
 {
 	int ret = 0;
<span class="p_chunk">@@ -221,13 +233,13 @@</span> <span class="p_context"> __must_check unsigned long __clear_user(void __user *mem, unsigned long len);</span>
 static __must_check __always_inline int
 __copy_from_user_inatomic(void *dst, const void __user *src, unsigned size)
 {
<span class="p_del">-	return copy_user_generic(dst, (__force const void *)src, size);</span>
<span class="p_add">+	return __copy_from_user_nocheck(dst, src, size);</span>
 }
 
 static __must_check __always_inline int
 __copy_to_user_inatomic(void __user *dst, const void *src, unsigned size)
 {
<span class="p_del">-	return copy_user_generic((__force void *)dst, src, size);</span>
<span class="p_add">+	return __copy_to_user_nocheck(dst, src, size);</span>
 }
 
 extern long __copy_user_nocache(void *dst, const void __user *src,
<span class="p_header">diff --git a/arch/x86/kernel/microcode_amd.c b/arch/x86/kernel/microcode_amd.c</span>
<span class="p_header">index f9b9eaa3bbe5..be2fa4d0e814 100644</span>
<span class="p_header">--- a/arch/x86/kernel/microcode_amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/microcode_amd.c</span>
<span class="p_chunk">@@ -123,13 +123,62 @@</span> <span class="p_context"> static int get_matching_microcode(int cpu, struct microcode_header_amd *mc_hdr,</span>
 	return 1;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Those patch levels cannot be updated to newer ones and thus should be final.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static u32 final_levels[] = {</span>
<span class="p_add">+	0x01000098,</span>
<span class="p_add">+	0x0100009f,</span>
<span class="p_add">+	0x010000af,</span>
<span class="p_add">+	0, /* T-101 terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Check the current patch level on this CPU.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @rev: Use it to return the patch level. It is set to 0 in the case of</span>
<span class="p_add">+ * error.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns:</span>
<span class="p_add">+ *  - true: if update should stop</span>
<span class="p_add">+ *  - false: otherwise</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool check_current_patch_level(u32 *rev, bool early)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 lvl, dummy, i;</span>
<span class="p_add">+	bool ret = false;</span>
<span class="p_add">+	u32 *levels;</span>
<span class="p_add">+</span>
<span class="p_add">+	rdmsr(MSR_AMD64_PATCH_LEVEL, lvl, dummy);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	if (early)</span>
<span class="p_add">+		levels = (u32 *)__pa_nodebug(&amp;final_levels);</span>
<span class="p_add">+	else</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		levels = final_levels;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; levels[i]; i++) {</span>
<span class="p_add">+		if (lvl == levels[i]) {</span>
<span class="p_add">+			lvl = 0;</span>
<span class="p_add">+			ret = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rev)</span>
<span class="p_add">+		*rev = lvl;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int apply_microcode_amd(int cpu)
 {
<span class="p_del">-	u32 rev, dummy;</span>
 	int cpu_num = raw_smp_processor_id();
 	struct ucode_cpu_info *uci = ucode_cpu_info + cpu_num;
 	struct microcode_amd *mc_amd = uci-&gt;mc;
 	struct cpuinfo_x86 *c = &amp;cpu_data(cpu);
<span class="p_add">+	u32 dummy, rev;</span>
 
 	/* We should bind the task to the CPU */
 	BUG_ON(cpu_num != cpu);
<span class="p_chunk">@@ -137,6 +186,9 @@</span> <span class="p_context"> static int apply_microcode_amd(int cpu)</span>
 	if (mc_amd == NULL)
 		return 0;
 
<span class="p_add">+	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	wrmsrl(MSR_AMD64_PATCH_LOADER, (u64)(long)&amp;mc_amd-&gt;hdr.data_code);
 	/* get patch id after patching */
 	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index da1a1261aac1..a7fd5b336ac7 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -5754,8 +5754,6 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 	kvm_x86_ops-&gt;prepare_guest_switch(vcpu);
 	if (vcpu-&gt;fpu_active)
 		kvm_load_guest_fpu(vcpu);
<span class="p_del">-	kvm_load_guest_xcr0(vcpu);</span>
<span class="p_del">-</span>
 	vcpu-&gt;mode = IN_GUEST_MODE;
 
 	/* We should set -&gt;mode before check -&gt;requests,
<span class="p_chunk">@@ -5776,6 +5774,8 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 		goto out;
 	}
 
<span class="p_add">+	kvm_load_guest_xcr0(vcpu);</span>
<span class="p_add">+</span>
 	srcu_read_unlock(&amp;vcpu-&gt;kvm-&gt;srcu, vcpu-&gt;srcu_idx);
 
 	kvm_guest_enter();
<span class="p_chunk">@@ -5805,6 +5805,9 @@</span> <span class="p_context"> static int vcpu_enter_guest(struct kvm_vcpu *vcpu)</span>
 
 	vcpu-&gt;mode = OUTSIDE_GUEST_MODE;
 	smp_wmb();
<span class="p_add">+</span>
<span class="p_add">+	kvm_put_guest_xcr0(vcpu);</span>
<span class="p_add">+</span>
 	local_irq_enable();
 
 	++vcpu-&gt;stat.exits;
<span class="p_chunk">@@ -6378,7 +6381,6 @@</span> <span class="p_context"> void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)</span>
 	 * and assume host would use all available bits.
 	 * Guest xcr0 would be loaded later.
 	 */
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
 	vcpu-&gt;guest_fpu_loaded = 1;
 	unlazy_fpu(current);
 	fpu_restore_checking(&amp;vcpu-&gt;arch.guest_fpu);
<span class="p_chunk">@@ -6387,8 +6389,6 @@</span> <span class="p_context"> void kvm_load_guest_fpu(struct kvm_vcpu *vcpu)</span>
 
 void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	kvm_put_guest_xcr0(vcpu);</span>
<span class="p_del">-</span>
 	if (!vcpu-&gt;guest_fpu_loaded)
 		return;
 
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index 7fd8ecf71337..8271185d4ad9 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -64,8 +64,9 @@</span> <span class="p_context"> static int hash_walk_new_entry(struct crypto_hash_walk *walk)</span>
 	struct scatterlist *sg;
 
 	sg = walk-&gt;sg;
<span class="p_del">-	walk-&gt;pg = sg_page(sg);</span>
 	walk-&gt;offset = sg-&gt;offset;
<span class="p_add">+	walk-&gt;pg = sg_page(walk-&gt;sg) + (walk-&gt;offset &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+	walk-&gt;offset = offset_in_page(walk-&gt;offset);</span>
 	walk-&gt;entrylen = sg-&gt;length;
 
 	if (walk-&gt;entrylen &gt; walk-&gt;total)
<span class="p_header">diff --git a/crypto/gcm.c b/crypto/gcm.c</span>
<span class="p_header">index 1e3356107af2..943cbceca426 100644</span>
<span class="p_header">--- a/crypto/gcm.c</span>
<span class="p_header">+++ b/crypto/gcm.c</span>
<span class="p_chunk">@@ -1103,6 +1103,21 @@</span> <span class="p_context"> static int crypto_rfc4543_setauthsize(struct crypto_aead *parent,</span>
 	return crypto_aead_setauthsize(ctx-&gt;child, authsize);
 }
 
<span class="p_add">+static void crypto_rfc4543_done(struct crypto_async_request *areq, int err)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct aead_request *req = areq-&gt;data;</span>
<span class="p_add">+	struct crypto_aead *aead = crypto_aead_reqtfm(req);</span>
<span class="p_add">+	struct crypto_rfc4543_req_ctx *rctx = crypto_rfc4543_reqctx(req);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		scatterwalk_map_and_copy(rctx-&gt;auth_tag, req-&gt;dst,</span>
<span class="p_add">+					 req-&gt;cryptlen,</span>
<span class="p_add">+					 crypto_aead_authsize(aead), 1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	aead_request_complete(req, err);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct aead_request *crypto_rfc4543_crypt(struct aead_request *req,
 						 int enc)
 {
<span class="p_chunk">@@ -1159,8 +1174,11 @@</span> <span class="p_context"> static struct aead_request *crypto_rfc4543_crypt(struct aead_request *req,</span>
 	scatterwalk_crypto_chain(assoc, payload, 0, 2);
 
 	aead_request_set_tfm(subreq, ctx-&gt;child);
<span class="p_del">-	aead_request_set_callback(subreq, req-&gt;base.flags, req-&gt;base.complete,</span>
<span class="p_del">-				  req-&gt;base.data);</span>
<span class="p_add">+	aead_request_set_callback(subreq, req-&gt;base.flags, crypto_rfc4543_done,</span>
<span class="p_add">+				  req);</span>
<span class="p_add">+	if (!enc)</span>
<span class="p_add">+		aead_request_set_callback(subreq, req-&gt;base.flags,</span>
<span class="p_add">+					  req-&gt;base.complete, req-&gt;base.data);</span>
 	aead_request_set_crypt(subreq, cipher, cipher, enc ? 0 : authsize, iv);
 	aead_request_set_assoc(subreq, assoc, assoclen);
 
<span class="p_header">diff --git a/drivers/acpi/acpica/dsmethod.c b/drivers/acpi/acpica/dsmethod.c</span>
<span class="p_header">index 5d797751e205..7e13b71aa10d 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/dsmethod.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/dsmethod.c</span>
<span class="p_chunk">@@ -266,6 +266,9 @@</span> <span class="p_context"> acpi_ds_begin_method_execution(struct acpi_namespace_node *method_node,</span>
 				obj_desc-&gt;method.mutex-&gt;mutex.
 				    original_sync_level =
 				    obj_desc-&gt;method.mutex-&gt;mutex.sync_level;
<span class="p_add">+</span>
<span class="p_add">+				obj_desc-&gt;method.mutex-&gt;mutex.thread_id =</span>
<span class="p_add">+				    acpi_os_get_thread_id();</span>
 			}
 		}
 
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index 1adb71733d05..fbfde7153f78 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -452,6 +452,7 @@</span> <span class="p_context"> void ahci_save_initial_config(struct device *dev,</span>
 		dev_info(dev, &quot;forcing port_map 0x%x -&gt; 0x%x\n&quot;,
 			 port_map, force_port_map);
 		port_map = force_port_map;
<span class="p_add">+		hpriv-&gt;saved_port_map = port_map;</span>
 	}
 
 	if (mask_port_map) {
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 636a8dd09ea0..e8e11ff97ece 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -2679,7 +2679,7 @@</span> <span class="p_context"> static int wait_for_msg_done(struct smi_info *smi_info)</span>
 		    smi_result == SI_SM_CALL_WITH_TICK_DELAY) {
 			schedule_timeout_uninterruptible(1);
 			smi_result = smi_info-&gt;handlers-&gt;event(
<span class="p_del">-				smi_info-&gt;si_sm, 100);</span>
<span class="p_add">+				smi_info-&gt;si_sm, jiffies_to_usecs(1));</span>
 		} else if (smi_result == SI_SM_CALL_WITHOUT_DELAY) {
 			smi_result = smi_info-&gt;handlers-&gt;event(
 				smi_info-&gt;si_sm, 0);
<span class="p_header">diff --git a/drivers/edac/i7core_edac.c b/drivers/edac/i7core_edac.c</span>
<span class="p_header">index 4c18b3c78f03..03e831e159e8 100644</span>
<span class="p_header">--- a/drivers/edac/i7core_edac.c</span>
<span class="p_header">+++ b/drivers/edac/i7core_edac.c</span>
<span class="p_chunk">@@ -1921,7 +1921,7 @@</span> <span class="p_context"> static int i7core_mce_check_error(struct notifier_block *nb, unsigned long val,</span>
 
 	i7_dev = get_i7core_dev(mce-&gt;socketid);
 	if (!i7_dev)
<span class="p_del">-		return NOTIFY_BAD;</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
 
 	mci = i7_dev-&gt;mci;
 	pvt = mci-&gt;pvt_info;
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index f8f790c0d252..7bcfd9d64672 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -1596,7 +1596,7 @@</span> <span class="p_context"> static int sbridge_mce_check_error(struct notifier_block *nb, unsigned long val,</span>
 
 	mci = get_mci_for_node_id(mce-&gt;socketid);
 	if (!mci)
<span class="p_del">-		return NOTIFY_BAD;</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
 	pvt = mci-&gt;pvt_info;
 
 	/*
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index 452bc512e6a7..e216c21110e4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -538,6 +538,35 @@</span> <span class="p_context"> int i915_resume(struct drm_device *dev)</span>
 	if (dev-&gt;switch_power_state == DRM_SWITCH_POWER_OFF)
 		return 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that we need to set the power state explicitly, since we</span>
<span class="p_add">+	 * powered off the device during freeze and the PCI core won&#39;t power</span>
<span class="p_add">+	 * it back up for us during thaw. Powering off the device during</span>
<span class="p_add">+	 * freeze is not a hard requirement though, and during the</span>
<span class="p_add">+	 * suspend/resume phases the PCI core makes sure we get here with the</span>
<span class="p_add">+	 * device powered on. So in case we change our freeze logic and keep</span>
<span class="p_add">+	 * the device powered we can also remove the following set power state</span>
<span class="p_add">+	 * call.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = pci_set_power_state(dev-&gt;pdev, PCI_D0);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		DRM_ERROR(&quot;failed to set PCI D0 power state (%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that pci_enable_device() first enables any parent bridge</span>
<span class="p_add">+	 * device and only then sets the power state for this device. The</span>
<span class="p_add">+	 * bridge enabling is a nop though, since bridge devices are resumed</span>
<span class="p_add">+	 * first. The order of enabling power and enabling the device is</span>
<span class="p_add">+	 * imposed by the PCI core as described above, so here we preserve the</span>
<span class="p_add">+	 * same order for the freeze/thaw phases.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * TODO: eventually we should remove pci_disable_device() /</span>
<span class="p_add">+	 * pci_enable_enable_device() from suspend/resume. Due to how they</span>
<span class="p_add">+	 * depend on the device enable refcount we can&#39;t anyway depend on them</span>
<span class="p_add">+	 * disabling/enabling the device.</span>
<span class="p_add">+	 */</span>
 	if (pci_enable_device(dev-&gt;pdev))
 		return -EIO;
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index a1a7d071eb17..cd8b34146146 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -90,6 +90,10 @@</span> <span class="p_context"> static bool radeon_atom_mode_fixup(struct drm_encoder *encoder,</span>
 	    &amp;&amp; (mode-&gt;crtc_vsync_start &lt; (mode-&gt;crtc_vdisplay + 2)))
 		adjusted_mode-&gt;crtc_vsync_start = adjusted_mode-&gt;crtc_vdisplay + 2;
 
<span class="p_add">+	/* vertical FP must be at least 1 */</span>
<span class="p_add">+	if (mode-&gt;crtc_vsync_start == mode-&gt;crtc_vdisplay)</span>
<span class="p_add">+		adjusted_mode-&gt;crtc_vsync_start++;</span>
<span class="p_add">+</span>
 	/* get the native mode for LVDS */
 	if (radeon_encoder-&gt;active_device &amp; (ATOM_DEVICE_LCD_SUPPORT))
 		radeon_panel_mode_fixup(encoder, adjusted_mode);
<span class="p_header">diff --git a/drivers/infiniband/core/ucm.c b/drivers/infiniband/core/ucm.c</span>
<span class="p_header">index b8a0b4a7811b..06c116bdcca0 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/ucm.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/ucm.c</span>
<span class="p_chunk">@@ -48,6 +48,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
 #include &lt;rdma/ib_cm.h&gt;
 #include &lt;rdma/ib_user_cm.h&gt;
 #include &lt;rdma/ib_marshall.h&gt;
<span class="p_chunk">@@ -1116,6 +1117,9 @@</span> <span class="p_context"> static ssize_t ib_ucm_write(struct file *filp, const char __user *buf,</span>
 	struct ib_ucm_cmd_hdr hdr;
 	ssize_t result;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (len &lt; sizeof(hdr))
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/core/ucma.c b/drivers/infiniband/core/ucma.c</span>
<span class="p_header">index b37b0c02a7b9..91e82b7dadfa 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/ucma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/ucma.c</span>
<span class="p_chunk">@@ -47,6 +47,7 @@</span> <span class="p_context"></span>
 #include &lt;rdma/ib_marshall.h&gt;
 #include &lt;rdma/rdma_cm.h&gt;
 #include &lt;rdma/rdma_cm_ib.h&gt;
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
 
 MODULE_AUTHOR(&quot;Sean Hefty&quot;);
 MODULE_DESCRIPTION(&quot;RDMA Userspace Connection Manager Access&quot;);
<span class="p_chunk">@@ -1268,6 +1269,9 @@</span> <span class="p_context"> static ssize_t ucma_write(struct file *filp, const char __user *buf,</span>
 	struct rdma_ucm_cmd_hdr hdr;
 	ssize_t ret;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (len &lt; sizeof(hdr))
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index f07c6e317771..9cdcb5038622 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -48,6 +48,8 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/uaccess.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;uverbs.h&quot;
 
 MODULE_AUTHOR(&quot;Roland Dreier&quot;);
<span class="p_chunk">@@ -580,6 +582,9 @@</span> <span class="p_context"> static ssize_t ib_uverbs_write(struct file *filp, const char __user *buf,</span>
 	struct ib_uverbs_file *file = filp-&gt;private_data;
 	struct ib_uverbs_cmd_hdr hdr;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(filp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof hdr)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/infiniband/hw/ipath/ipath_file_ops.c b/drivers/infiniband/hw/ipath/ipath_file_ops.c</span>
<span class="p_header">index 736d9edbdbe7..eed46ddd2331 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/ipath/ipath_file_ops.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/ipath/ipath_file_ops.c</span>
<span class="p_chunk">@@ -44,6 +44,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/cpu.h&gt;
 #include &lt;asm/pgtable.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;ipath_kernel.h&quot;
 #include &quot;ipath_common.h&quot;
 #include &quot;ipath_user_sdma.h&quot;
<span class="p_chunk">@@ -2239,6 +2241,9 @@</span> <span class="p_context"> static ssize_t ipath_write(struct file *fp, const char __user *data,</span>
 	ssize_t ret = 0;
 	void *dest;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof(cmd.type)) {
 		ret = -EINVAL;
 		goto bail;
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_file_ops.c b/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_header">index a7403248d83d..81c5bdb194dc 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_file_ops.c</span>
<span class="p_chunk">@@ -45,6 +45,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/export.h&gt;
 
<span class="p_add">+#include &lt;rdma/ib.h&gt;</span>
<span class="p_add">+</span>
 #include &quot;qib.h&quot;
 #include &quot;qib_common.h&quot;
 #include &quot;qib_user_sdma.h&quot;
<span class="p_chunk">@@ -1971,6 +1973,9 @@</span> <span class="p_context"> static ssize_t qib_write(struct file *fp, const char __user *data,</span>
 	ssize_t ret = 0;
 	void *dest;
 
<span class="p_add">+	if (WARN_ON_ONCE(!ib_safe_file_access(fp)))</span>
<span class="p_add">+		return -EACCES;</span>
<span class="p_add">+</span>
 	if (count &lt; sizeof(cmd.type)) {
 		ret = -EINVAL;
 		goto bail;
<span class="p_header">diff --git a/drivers/input/misc/pmic8xxx-pwrkey.c b/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_header">index b3cfb9c71e66..61f5b374a473 100644</span>
<span class="p_header">--- a/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_header">+++ b/drivers/input/misc/pmic8xxx-pwrkey.c</span>
<span class="p_chunk">@@ -98,7 +98,9 @@</span> <span class="p_context"> static int __devinit pmic8xxx_pwrkey_probe(struct platform_device *pdev)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (pdata-&gt;kpd_trigger_delay_us &gt; 62500) {</span>
<span class="p_add">+	/* Valid range of pwr key trigger delay is 1/64 sec to 2 seconds. */</span>
<span class="p_add">+	if (pdata-&gt;kpd_trigger_delay_us &gt; USEC_PER_SEC * 2 ||</span>
<span class="p_add">+	    pdata-&gt;kpd_trigger_delay_us &lt; USEC_PER_SEC / 64) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;invalid power key trigger delay\n&quot;);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -120,8 +122,8 @@</span> <span class="p_context"> static int __devinit pmic8xxx_pwrkey_probe(struct platform_device *pdev)</span>
 	pwr-&gt;phys = &quot;pmic8xxx_pwrkey/input0&quot;;
 	pwr-&gt;dev.parent = &amp;pdev-&gt;dev;
 
<span class="p_del">-	delay = (pdata-&gt;kpd_trigger_delay_us &lt;&lt; 10) / USEC_PER_SEC;</span>
<span class="p_del">-	delay = 1 + ilog2(delay);</span>
<span class="p_add">+	delay = (pdata-&gt;kpd_trigger_delay_us &lt;&lt; 6) / USEC_PER_SEC;</span>
<span class="p_add">+	delay = ilog2(delay);</span>
 
 	err = pm8xxx_readb(pdev-&gt;dev.parent, PON_CNTL_1, &amp;pon_cntl);
 	if (err &lt; 0) {
<span class="p_header">diff --git a/drivers/input/tablet/gtco.c b/drivers/input/tablet/gtco.c</span>
<span class="p_header">index 8ea6afe2e992..929215a2dcfa 100644</span>
<span class="p_header">--- a/drivers/input/tablet/gtco.c</span>
<span class="p_header">+++ b/drivers/input/tablet/gtco.c</span>
<span class="p_chunk">@@ -866,6 +866,14 @@</span> <span class="p_context"> static int gtco_probe(struct usb_interface *usbinterface,</span>
 		goto err_free_buf;
 	}
 
<span class="p_add">+	/* Sanity check that a device has an endpoint */</span>
<span class="p_add">+	if (usbinterface-&gt;altsetting[0].desc.bNumEndpoints &lt; 1) {</span>
<span class="p_add">+		dev_err(&amp;usbinterface-&gt;dev,</span>
<span class="p_add">+			&quot;Invalid number of endpoints\n&quot;);</span>
<span class="p_add">+		error = -EINVAL;</span>
<span class="p_add">+		goto err_free_urb;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * The endpoint is always altsetting 0, we know this since we know
 	 * this device only has one interrupt endpoint
<span class="p_chunk">@@ -887,7 +895,7 @@</span> <span class="p_context"> static int gtco_probe(struct usb_interface *usbinterface,</span>
 	 * HID report descriptor
 	 */
 	if (usb_get_extra_descriptor(usbinterface-&gt;cur_altsetting,
<span class="p_del">-				     HID_DEVICE_TYPE, &amp;hid_desc) != 0){</span>
<span class="p_add">+				     HID_DEVICE_TYPE, &amp;hid_desc) != 0) {</span>
 		err(&quot;Can&#39;t retrieve exta USB descriptor to get hid report descriptor length&quot;);
 		error = -EIO;
 		goto err_free_urb;
<span class="p_header">diff --git a/drivers/net/ethernet/atheros/atlx/atl2.c b/drivers/net/ethernet/atheros/atlx/atl2.c</span>
<span class="p_header">index 1feae5928a4b..12313c8cbe0c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/atheros/atlx/atl2.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/atheros/atlx/atl2.c</span>
<span class="p_chunk">@@ -1428,7 +1428,7 @@</span> <span class="p_context"> static int __devinit atl2_probe(struct pci_dev *pdev,</span>
 
 	err = -EIO;
 
<span class="p_del">-	netdev-&gt;hw_features = NETIF_F_SG | NETIF_F_HW_VLAN_RX;</span>
<span class="p_add">+	netdev-&gt;hw_features = NETIF_F_HW_VLAN_RX;</span>
 	netdev-&gt;features |= (NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX);
 
 	/* Init PHY as early as possible due to power saving issue  */
<span class="p_header">diff --git a/drivers/usb/core/hcd-pci.c b/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">index 76be3bae3ff8..8312f9547009 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd-pci.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd-pci.c</span>
<span class="p_chunk">@@ -70,6 +70,14 @@</span> <span class="p_context"> static void companion_common(struct pci_dev *pdev, struct usb_hcd *hcd,</span>
 				PCI_SLOT(companion-&gt;devfn) != slot)
 			continue;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Companion device should be either UHCI,OHCI or EHCI host</span>
<span class="p_add">+		 * controller, otherwise skip.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (companion-&gt;class != CL_UHCI &amp;&amp; companion-&gt;class != CL_OHCI &amp;&amp;</span>
<span class="p_add">+				companion-&gt;class != CL_EHCI)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		companion_hcd = pci_get_drvdata(companion);
 		if (!companion_hcd)
 			continue;
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index ab023b168732..e3f70d3fb44c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1789,6 +1789,11 @@</span> <span class="p_context"> no_bw:</span>
 	kfree(xhci-&gt;port_array);
 	kfree(xhci-&gt;rh_bw);
 
<span class="p_add">+	xhci-&gt;usb2_ports = NULL;</span>
<span class="p_add">+	xhci-&gt;usb3_ports = NULL;</span>
<span class="p_add">+	xhci-&gt;port_array = NULL;</span>
<span class="p_add">+	xhci-&gt;rh_bw = NULL;</span>
<span class="p_add">+</span>
 	xhci-&gt;page_size = 0;
 	xhci-&gt;page_shift = 0;
 	xhci-&gt;bus_state[0].bus_suspended = 0;
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 244e1b12259d..50af559183eb 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -134,7 +135,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI ||
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||
<span class="p_del">-		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI)) {</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 645687c08baf..e941e2d33265 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -114,6 +114,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x826B) }, /* Cygnal Integrated Products, Inc., Fasttrax GPS demonstration module */
 	{ USB_DEVICE(0x10C4, 0x8281) }, /* Nanotec Plug &amp; Drive */
 	{ USB_DEVICE(0x10C4, 0x8293) }, /* Telegesis ETRX2USB */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x82F4) }, /* Starizona MicroTouch */</span>
 	{ USB_DEVICE(0x10C4, 0x82F9) }, /* Procyon AVS */
 	{ USB_DEVICE(0x10C4, 0x8341) }, /* Siemens MC35PU GPRS Modem */
 	{ USB_DEVICE(0x10C4, 0x8382) }, /* Cygnal Integrated Products, Inc. */
<span class="p_chunk">@@ -123,6 +124,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8418) }, /* IRZ Automation Teleport SG-10 GSM/GPRS Modem */
 	{ USB_DEVICE(0x10C4, 0x846E) }, /* BEI USB Sensor Interface (VCP) */
 	{ USB_DEVICE(0x10C4, 0x8477) }, /* Balluff RFID */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x84B6) }, /* Starizona Hyperion */</span>
 	{ USB_DEVICE(0x10C4, 0x85EA) }, /* AC-Services IBUS-IF */
 	{ USB_DEVICE(0x10C4, 0x85EB) }, /* AC-Services CIS-IBUS */
 	{ USB_DEVICE(0x10C4, 0x85F8) }, /* Virtenio Preon32 */
<span class="p_chunk">@@ -146,6 +148,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0xF004) }, /* Elan Digital Systems USBcount50 */
 	{ USB_DEVICE(0x10C5, 0xEA61) }, /* Silicon Labs MobiData GPRS USB Modem */
 	{ USB_DEVICE(0x10CE, 0xEA6A) }, /* Silicon Labs MobiData GPRS USB Modem 100EU */
<span class="p_add">+	{ USB_DEVICE(0x12B8, 0xEC60) }, /* Link G4 ECU */</span>
<span class="p_add">+	{ USB_DEVICE(0x12B8, 0xEC62) }, /* Link G4+ ECU */</span>
 	{ USB_DEVICE(0x13AD, 0x9999) }, /* Baltech card reader */
 	{ USB_DEVICE(0x1555, 0x0004) }, /* Owen AC4 USB-RS485 Converter */
 	{ USB_DEVICE(0x166A, 0x0201) }, /* Clipsal 5500PACA C-Bus Pascal Automation Controller */
<span class="p_header">diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c</span>
<span class="p_header">index d582af4a1968..d2817421fc55 100644</span>
<span class="p_header">--- a/drivers/usb/storage/usb.c</span>
<span class="p_header">+++ b/drivers/usb/storage/usb.c</span>
<span class="p_chunk">@@ -453,7 +453,7 @@</span> <span class="p_context"> static void adjust_quirks(struct us_data *us)</span>
 			US_FL_CAPACITY_OK | US_FL_IGNORE_RESIDUE |
 			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |
 			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |
<span class="p_del">-			US_FL_INITIAL_READ10);</span>
<span class="p_add">+			US_FL_INITIAL_READ10 | US_FL_NO_REPORT_LUNS);</span>
 
 	p = quirks;
 	while (*p) {
<span class="p_chunk">@@ -497,6 +497,9 @@</span> <span class="p_context"> static void adjust_quirks(struct us_data *us)</span>
 		case &#39;i&#39;:
 			f |= US_FL_IGNORE_DEVICE;
 			break;
<span class="p_add">+		case &#39;j&#39;:</span>
<span class="p_add">+			f |= US_FL_NO_REPORT_LUNS;</span>
<span class="p_add">+			break;</span>
 		case &#39;l&#39;:
 			f |= US_FL_NOT_LOCKABLE;
 			break;
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 0aa424a02344..ebab116b0779 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -979,6 +979,11 @@</span> <span class="p_context"> static int __init init_hugetlbfs_fs(void)</span>
 	int error;
 	struct vfsmount *vfsmount;
 
<span class="p_add">+	if (!hugepages_supported()) {</span>
<span class="p_add">+		pr_info(&quot;hugetlbfs: disabling because there are no supported hugepage sizes\n&quot;);</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	error = bdi_init(&amp;hugetlbfs_backing_dev_info);
 	if (error)
 		return error;
<span class="p_header">diff --git a/fs/isofs/rock.c b/fs/isofs/rock.c</span>
<span class="p_header">index 17809499c752..e52a1ac168ef 100644</span>
<span class="p_header">--- a/fs/isofs/rock.c</span>
<span class="p_header">+++ b/fs/isofs/rock.c</span>
<span class="p_chunk">@@ -203,6 +203,8 @@</span> <span class="p_context"> int get_rock_ridge_filename(struct iso_directory_record *de,</span>
 	int retnamlen = 0;
 	int truncate = 0;
 	int ret = 0;
<span class="p_add">+	char *p;</span>
<span class="p_add">+	int len;</span>
 
 	if (!ISOFS_SB(inode-&gt;i_sb)-&gt;s_rock)
 		return 0;
<span class="p_chunk">@@ -267,12 +269,17 @@</span> <span class="p_context"> repeat:</span>
 					rr-&gt;u.NM.flags);
 				break;
 			}
<span class="p_del">-			if ((strlen(retname) + rr-&gt;len - 5) &gt;= 254) {</span>
<span class="p_add">+			len = rr-&gt;len - 5;</span>
<span class="p_add">+			if (retnamlen + len &gt;= 254) {</span>
 				truncate = 1;
 				break;
 			}
<span class="p_del">-			strncat(retname, rr-&gt;u.NM.name, rr-&gt;len - 5);</span>
<span class="p_del">-			retnamlen += rr-&gt;len - 5;</span>
<span class="p_add">+			p = memchr(rr-&gt;u.NM.name, &#39;\0&#39;, len);</span>
<span class="p_add">+			if (unlikely(p))</span>
<span class="p_add">+				len = p - rr-&gt;u.NM.name;</span>
<span class="p_add">+			memcpy(retname + retnamlen, rr-&gt;u.NM.name, len);</span>
<span class="p_add">+			retnamlen += len;</span>
<span class="p_add">+			retname[retnamlen] = &#39;\0&#39;;</span>
 			break;
 		case SIG(&#39;R&#39;, &#39;E&#39;):
 			kfree(rs.buffer);
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 1ace83d004be..402976ab746a 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -905,7 +905,8 @@</span> <span class="p_context"> static ssize_t environ_read(struct file *file, char __user *buf,</span>
 
 	mm = mm_for_maps(task);
 	ret = PTR_ERR(mm);
<span class="p_del">-	if (!mm || IS_ERR(mm))</span>
<span class="p_add">+	/* Ensure the process spawned far enough to have an environment. */</span>
<span class="p_add">+	if (!mm || IS_ERR(mm) || !mm-&gt;env_end)</span>
 		goto out_free;
 
 	ret = 0;
<span class="p_header">diff --git a/include/linux/hash.h b/include/linux/hash.h</span>
<span class="p_header">index b80506bdd733..44a3b95f16c1 100644</span>
<span class="p_header">--- a/include/linux/hash.h</span>
<span class="p_header">+++ b/include/linux/hash.h</span>
<span class="p_chunk">@@ -31,10 +31,29 @@</span> <span class="p_context"></span>
 #error Wordsize not 32 or 64
 #endif
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The above primes are actively bad for hashing, since they are</span>
<span class="p_add">+ * too sparse. The 32-bit one is mostly ok, the 64-bit one causes</span>
<span class="p_add">+ * real problems. Besides, the &quot;prime&quot; part is pointless for the</span>
<span class="p_add">+ * multiplicative hash.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Although a random odd number will do, it turns out that the golden</span>
<span class="p_add">+ * ratio phi = (sqrt(5)-1)/2, or its negative, has particularly nice</span>
<span class="p_add">+ * properties.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * These are the negative, (1 - phi) = (phi^2) = (3 - sqrt(5))/2.</span>
<span class="p_add">+ * (See Knuth vol 3, section 6.4, exercise 9.)</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define GOLDEN_RATIO_32 0x61C88647</span>
<span class="p_add">+#define GOLDEN_RATIO_64 0x61C8864680B583EBull</span>
<span class="p_add">+</span>
 static inline u64 hash_64(u64 val, unsigned int bits)
 {
 	u64 hash = val;
 
<span class="p_add">+#if BITS_PER_LONG == 64</span>
<span class="p_add">+	hash = hash * GOLDEN_RATIO_64;</span>
<span class="p_add">+#else</span>
 	/*  Sigh, gcc can&#39;t optimise this alone like it does for 32 bits. */
 	u64 n = hash;
 	n &lt;&lt;= 18;
<span class="p_chunk">@@ -49,6 +68,7 @@</span> <span class="p_context"> static inline u64 hash_64(u64 val, unsigned int bits)</span>
 	hash += n;
 	n &lt;&lt;= 2;
 	hash += n;
<span class="p_add">+#endif</span>
 
 	/* High bits are more random, so use them. */
 	return hash &gt;&gt; (64 - bits);
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index 4bc9445222f2..533471d8b43b 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -344,6 +344,15 @@</span> <span class="p_context"> static inline pgoff_t basepage_index(struct page *page)</span>
 	return __basepage_index(page);
 }
 
<span class="p_add">+#ifndef hugepages_supported</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Some platform decide whether they support huge pages at boot</span>
<span class="p_add">+ * time. Some of them, such as powerpc, set HPAGE_SHIFT to 0</span>
<span class="p_add">+ * when there is no such support</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define hugepages_supported() (HPAGE_SHIFT != 0)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #else
 struct hstate {};
 #define alloc_huge_page_node(h, nid) NULL
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index 700c94821db1..4b04097c748c 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -293,7 +293,6 @@</span> <span class="p_context"> struct header_ops {</span>
 	void	(*cache_update)(struct hh_cache *hh,
 				const struct net_device *dev,
 				const unsigned char *haddr);
<span class="p_del">-	bool	(*validate)(const char *ll_header, unsigned int len);</span>
 };
 
 /* These flag bits are private to the generic network queueing
<span class="p_chunk">@@ -1120,7 +1119,7 @@</span> <span class="p_context"> struct net_device {</span>
 
 	unsigned int		mtu;	/* interface MTU value		*/
 	unsigned short		type;	/* interface hardware type	*/
<span class="p_del">-	unsigned short		hard_header_len; /* maximum hardware hdr length	*/</span>
<span class="p_add">+	unsigned short		hard_header_len;	/* hardware hdr length	*/</span>
 
 	/* extra head- and tailroom the hardware may need, but not in all cases
 	 * can this be guaranteed, especially tailroom. Some cases also use
<span class="p_chunk">@@ -1729,24 +1728,6 @@</span> <span class="p_context"> static inline int dev_rebuild_header(struct sk_buff *skb)</span>
 	return dev-&gt;header_ops-&gt;rebuild(skb);
 }
 
<span class="p_del">-/* ll_header must have at least hard_header_len allocated */</span>
<span class="p_del">-static inline bool dev_validate_header(const struct net_device *dev,</span>
<span class="p_del">-				       char *ll_header, int len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (likely(len &gt;= dev-&gt;hard_header_len))</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (capable(CAP_SYS_RAWIO)) {</span>
<span class="p_del">-		memset(ll_header + len, 0, dev-&gt;hard_header_len - len);</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (dev-&gt;header_ops &amp;&amp; dev-&gt;header_ops-&gt;validate)</span>
<span class="p_del">-		return dev-&gt;header_ops-&gt;validate(ll_header, len);</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 typedef int gifconf_func_t(struct net_device * dev, char __user * bufptr, int len);
 extern int		register_gifconf(unsigned int family, gifconf_func_t * gifconf);
 static inline int unregister_gifconf(unsigned int family)
<span class="p_header">diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h</span>
<span class="p_header">index 88413e9d80b5..a3d6fac653cd 100644</span>
<span class="p_header">--- a/include/linux/usb_usual.h</span>
<span class="p_header">+++ b/include/linux/usb_usual.h</span>
<span class="p_chunk">@@ -67,6 +67,8 @@</span> <span class="p_context"></span>
 		/* Initial READ(10) (and others) must be retried */ \
 	US_FLAG(BROKEN_FUA,	0x01000000)			\
 		/* Cannot handle FUA in WRITE or READ CDBs */	\
<span class="p_add">+	US_FLAG(NO_REPORT_LUNS,	0x10000000)			\</span>
<span class="p_add">+		/* Cannot handle REPORT_LUNS */			\</span>
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };
<span class="p_header">diff --git a/include/rdma/ib.h b/include/rdma/ib.h</span>
new file mode 100644
<span class="p_header">index 000000000000..fcb21882d096</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/include/rdma/ib.h</span>
<span class="p_chunk">@@ -0,0 +1,21 @@</span> <span class="p_context"></span>
<span class="p_add">+#if !defined(_RDMA_IB_H)</span>
<span class="p_add">+#define _RDMA_IB_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The IB interfaces that use write() as bi-directional ioctl() are</span>
<span class="p_add">+ * fundamentally unsafe, since there are lots of ways to trigger &quot;write()&quot;</span>
<span class="p_add">+ * calls from various contexts with elevated privileges. That includes the</span>
<span class="p_add">+ * traditional suid executable error message writes, but also various kernel</span>
<span class="p_add">+ * interfaces that can write to file descriptors.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function provides protection for the legacy API by restricting the</span>
<span class="p_add">+ * calling context.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool ib_safe_file_access(struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return filp-&gt;f_cred == current_cred() &amp;&amp; segment_eq(get_fs(), USER_DS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _RDMA_IB_H */</span>
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 79166c2b8f8f..2fde51669cd9 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -1635,14 +1635,14 @@</span> <span class="p_context"> int khugepaged_enter_vma_merge(struct vm_area_struct *vma,</span>
 		 * page fault if needed.
 		 */
 		return 0;
<span class="p_del">-	if (vma-&gt;vm_ops)</span>
<span class="p_add">+	if (vma-&gt;vm_ops || (vm_flags &amp; VM_NO_THP))</span>
 		/* khugepaged not yet working on file or special mappings */
 		return 0;
 	/*
 	 * If is_pfn_mapping() is true is_learn_pfn_mapping() must be
 	 * true too, verify it here.
 	 */
<span class="p_del">-	VM_BUG_ON(is_linear_pfn_mapping(vma) || vm_flags &amp; VM_NO_THP);</span>
<span class="p_add">+	VM_BUG_ON(is_linear_pfn_mapping(vma));</span>
 	hstart = (vma-&gt;vm_start + ~HPAGE_PMD_MASK) &amp; HPAGE_PMD_MASK;
 	hend = vma-&gt;vm_end &amp; HPAGE_PMD_MASK;
 	if (hstart &lt; hend)
<span class="p_chunk">@@ -1817,6 +1817,24 @@</span> <span class="p_context"> static void __collapse_huge_page_copy(pte_t *pte, struct page *page,</span>
 	}
 }
 
<span class="p_add">+static bool hugepage_vma_check(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((!(vma-&gt;vm_flags &amp; VM_HUGEPAGE) &amp;&amp; !khugepaged_always()) ||</span>
<span class="p_add">+	    (vma-&gt;vm_flags &amp; VM_NOHUGEPAGE))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!vma-&gt;anon_vma || vma-&gt;vm_ops)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (is_vma_temporary_stack(vma))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If is_pfn_mapping() is true is_learn_pfn_mapping() must be</span>
<span class="p_add">+	 * true too, verify it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	VM_BUG_ON(is_linear_pfn_mapping(vma));</span>
<span class="p_add">+	return !(vma-&gt;vm_flags &amp; VM_NO_THP);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void collapse_huge_page(struct mm_struct *mm,
 			       unsigned long address,
 			       struct page **hpage,
<span class="p_chunk">@@ -1889,21 +1907,8 @@</span> <span class="p_context"> static void collapse_huge_page(struct mm_struct *mm,</span>
 	hend = vma-&gt;vm_end &amp; HPAGE_PMD_MASK;
 	if (address &lt; hstart || address + HPAGE_PMD_SIZE &gt; hend)
 		goto out;
<span class="p_del">-</span>
<span class="p_del">-	if ((!(vma-&gt;vm_flags &amp; VM_HUGEPAGE) &amp;&amp; !khugepaged_always()) ||</span>
<span class="p_del">-	    (vma-&gt;vm_flags &amp; VM_NOHUGEPAGE))</span>
<span class="p_add">+	if (!hugepage_vma_check(vma))</span>
 		goto out;
<span class="p_del">-</span>
<span class="p_del">-	if (!vma-&gt;anon_vma || vma-&gt;vm_ops)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	if (is_vma_temporary_stack(vma))</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If is_pfn_mapping() is true is_learn_pfn_mapping() must be</span>
<span class="p_del">-	 * true too, verify it here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	VM_BUG_ON(is_linear_pfn_mapping(vma) || vma-&gt;vm_flags &amp; VM_NO_THP);</span>
<span class="p_del">-</span>
 	pgd = pgd_offset(mm, address);
 	if (!pgd_present(*pgd))
 		goto out;
<span class="p_chunk">@@ -2133,25 +2138,11 @@</span> <span class="p_context"> static unsigned int khugepaged_scan_mm_slot(unsigned int pages,</span>
 			progress++;
 			break;
 		}
<span class="p_del">-</span>
<span class="p_del">-		if ((!(vma-&gt;vm_flags &amp; VM_HUGEPAGE) &amp;&amp;</span>
<span class="p_del">-		     !khugepaged_always()) ||</span>
<span class="p_del">-		    (vma-&gt;vm_flags &amp; VM_NOHUGEPAGE)) {</span>
<span class="p_del">-		skip:</span>
<span class="p_add">+		if (!hugepage_vma_check(vma)) {</span>
<span class="p_add">+skip:</span>
 			progress++;
 			continue;
 		}
<span class="p_del">-		if (!vma-&gt;anon_vma || vma-&gt;vm_ops)</span>
<span class="p_del">-			goto skip;</span>
<span class="p_del">-		if (is_vma_temporary_stack(vma))</span>
<span class="p_del">-			goto skip;</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If is_pfn_mapping() is true is_learn_pfn_mapping()</span>
<span class="p_del">-		 * must be true too, verify it here.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		VM_BUG_ON(is_linear_pfn_mapping(vma) ||</span>
<span class="p_del">-			  vma-&gt;vm_flags &amp; VM_NO_THP);</span>
<span class="p_del">-</span>
 		hstart = (vma-&gt;vm_start + ~HPAGE_PMD_MASK) &amp; HPAGE_PMD_MASK;
 		hend = vma-&gt;vm_end &amp; HPAGE_PMD_MASK;
 		if (hstart &gt;= hend)
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 9256590bdd0e..c52095ce40b4 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1889,11 +1889,7 @@</span> <span class="p_context"> module_exit(hugetlb_exit);</span>
 
 static int __init hugetlb_init(void)
 {
<span class="p_del">-	/* Some platform decide whether they support huge pages at boot</span>
<span class="p_del">-	 * time. On these, such as powerpc, HPAGE_SHIFT is set to 0 when</span>
<span class="p_del">-	 * there is no such support</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (HPAGE_SHIFT == 0)</span>
<span class="p_add">+	if (!hugepages_supported())</span>
 		return 0;
 
 	if (!size_to_hstate(default_hstate_size)) {
<span class="p_chunk">@@ -2010,6 +2006,9 @@</span> <span class="p_context"> static int hugetlb_sysctl_handler_common(bool obey_mempolicy,</span>
 	unsigned long tmp;
 	int ret;
 
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+</span>
 	tmp = h-&gt;max_huge_pages;
 
 	if (write &amp;&amp; h-&gt;order &gt;= MAX_ORDER)
<span class="p_chunk">@@ -2075,6 +2074,9 @@</span> <span class="p_context"> int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
 	unsigned long tmp;
 	int ret;
 
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return -ENOTSUPP;</span>
<span class="p_add">+</span>
 	tmp = h-&gt;nr_overcommit_huge_pages;
 
 	if (write &amp;&amp; h-&gt;order &gt;= MAX_ORDER)
<span class="p_chunk">@@ -2100,6 +2102,8 @@</span> <span class="p_context"> out:</span>
 void hugetlb_report_meminfo(struct seq_file *m)
 {
 	struct hstate *h = &amp;default_hstate;
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return;</span>
 	seq_printf(m,
 			&quot;HugePages_Total:   %5lu\n&quot;
 			&quot;HugePages_Free:    %5lu\n&quot;
<span class="p_chunk">@@ -2116,6 +2120,8 @@</span> <span class="p_context"> void hugetlb_report_meminfo(struct seq_file *m)</span>
 int hugetlb_report_node_meminfo(int nid, char *buf)
 {
 	struct hstate *h = &amp;default_hstate;
<span class="p_add">+	if (!hugepages_supported())</span>
<span class="p_add">+		return 0;</span>
 	return sprintf(buf,
 		&quot;Node %d HugePages_Total: %5u\n&quot;
 		&quot;Node %d HugePages_Free:  %5u\n&quot;
<span class="p_header">diff --git a/net/ax25/ax25_ip.c b/net/ax25/ax25_ip.c</span>
<span class="p_header">index a0c9956b5b23..cf0c47a26530 100644</span>
<span class="p_header">--- a/net/ax25/ax25_ip.c</span>
<span class="p_header">+++ b/net/ax25/ax25_ip.c</span>
<span class="p_chunk">@@ -232,24 +232,9 @@</span> <span class="p_context"> int ax25_rebuild_header(struct sk_buff *skb)</span>
 
 #endif
 
<span class="p_del">-static bool ax25_validate_header(const char *header, unsigned int len)</span>
<span class="p_del">-{</span>
<span class="p_del">-	ax25_digi digi;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!len)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (header[0])</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return ax25_addr_parse(header + 1, len - 1, NULL, NULL, &amp;digi, NULL,</span>
<span class="p_del">-			       NULL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 const struct header_ops ax25_header_ops = {
 	.create = ax25_hard_header,
 	.rebuild = ax25_rebuild_header,
<span class="p_del">-	.validate = ax25_validate_header,</span>
 };
 
 EXPORT_SYMBOL(ax25_hard_header);
<span class="p_header">diff --git a/net/batman-adv/routing.c b/net/batman-adv/routing.c</span>
<span class="p_header">index da587ad189f8..cc82ec55283b 100644</span>
<span class="p_header">--- a/net/batman-adv/routing.c</span>
<span class="p_header">+++ b/net/batman-adv/routing.c</span>
<span class="p_chunk">@@ -98,6 +98,15 @@</span> <span class="p_context"> static void _update_route(struct bat_priv *bat_priv,</span>
 		neigh_node = NULL;
 
 	spin_lock_bh(&amp;orig_node-&gt;neigh_list_lock);
<span class="p_add">+	/* curr_router used earlier may not be the current orig_node-&gt;router</span>
<span class="p_add">+	 * anymore because it was dereferenced outside of the neigh_list_lock</span>
<span class="p_add">+	 * protected region. After the new best neighbor has replace the current</span>
<span class="p_add">+	 * best neighbor the reference counter needs to decrease. Consequently,</span>
<span class="p_add">+	 * the code needs to ensure the curr_router variable contains a pointer</span>
<span class="p_add">+	 * to the replaced best neighbor.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	curr_router = rcu_dereference_protected(orig_node-&gt;router, true);</span>
<span class="p_add">+</span>
 	rcu_assign_pointer(orig_node-&gt;router, neigh_node);
 	spin_unlock_bh(&amp;orig_node-&gt;neigh_list_lock);
 
<span class="p_header">diff --git a/net/batman-adv/send.c b/net/batman-adv/send.c</span>
<span class="p_header">index 8a684eb738ad..20570dd6d6b7 100644</span>
<span class="p_header">--- a/net/batman-adv/send.c</span>
<span class="p_header">+++ b/net/batman-adv/send.c</span>
<span class="p_chunk">@@ -375,6 +375,9 @@</span> <span class="p_context"> void purge_outstanding_packets(struct bat_priv *bat_priv,</span>
 
 		if (pending) {
 			hlist_del(&amp;forw_packet-&gt;list);
<span class="p_add">+			if (!forw_packet-&gt;own)</span>
<span class="p_add">+				atomic_inc(&amp;bat_priv-&gt;bcast_queue_left);</span>
<span class="p_add">+</span>
 			forw_packet_free(forw_packet);
 		}
 	}
<span class="p_chunk">@@ -404,6 +407,9 @@</span> <span class="p_context"> void purge_outstanding_packets(struct bat_priv *bat_priv,</span>
 
 		if (pending) {
 			hlist_del(&amp;forw_packet-&gt;list);
<span class="p_add">+			if (!forw_packet-&gt;own)</span>
<span class="p_add">+				atomic_inc(&amp;bat_priv-&gt;batman_queue_left);</span>
<span class="p_add">+</span>
 			forw_packet_free(forw_packet);
 		}
 	}
<span class="p_header">diff --git a/net/batman-adv/soft-interface.c b/net/batman-adv/soft-interface.c</span>
<span class="p_header">index f9cc95728989..a8f4627a426e 100644</span>
<span class="p_header">--- a/net/batman-adv/soft-interface.c</span>
<span class="p_header">+++ b/net/batman-adv/soft-interface.c</span>
<span class="p_chunk">@@ -686,10 +686,16 @@</span> <span class="p_context"> void interface_rx(struct net_device *soft_iface,</span>
 	skb_pull_rcsum(skb, hdr_size);
 	skb_reset_mac_header(skb);
 
<span class="p_add">+	if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))</span>
<span class="p_add">+		goto dropped;</span>
<span class="p_add">+</span>
 	ethhdr = (struct ethhdr *)skb_mac_header(skb);
 
 	switch (ntohs(ethhdr-&gt;h_proto)) {
 	case ETH_P_8021Q:
<span class="p_add">+		if (!pskb_may_pull(skb, VLAN_ETH_HLEN))</span>
<span class="p_add">+			goto dropped;</span>
<span class="p_add">+</span>
 		vhdr = (struct vlan_ethhdr *)skb-&gt;data;
 		vid = ntohs(vhdr-&gt;h_vlan_TCI) &amp; VLAN_VID_MASK;
 
<span class="p_chunk">@@ -726,8 +732,6 @@</span> <span class="p_context"> void interface_rx(struct net_device *soft_iface,</span>
 	}
 
 	/* skb-&gt;dev &amp; skb-&gt;pkt_type are set here */
<span class="p_del">-	if (unlikely(!pskb_may_pull(skb, ETH_HLEN)))</span>
<span class="p_del">-		goto dropped;</span>
 	skb-&gt;protocol = eth_type_trans(skb, soft_iface);
 
 	/* should not be necessary anymore as we use skb_pull_rcsum()
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index e77373a44847..72a7ed82659b 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -920,14 +920,16 @@</span> <span class="p_context"> static int rtnl_fill_ifinfo(struct sk_buff *skb, struct net_device *dev,</span>
 		NLA_PUT_STRING(skb, IFLA_IFALIAS, dev-&gt;ifalias);
 
 	if (1) {
<span class="p_del">-		struct rtnl_link_ifmap map = {</span>
<span class="p_del">-			.mem_start   = dev-&gt;mem_start,</span>
<span class="p_del">-			.mem_end     = dev-&gt;mem_end,</span>
<span class="p_del">-			.base_addr   = dev-&gt;base_addr,</span>
<span class="p_del">-			.irq         = dev-&gt;irq,</span>
<span class="p_del">-			.dma         = dev-&gt;dma,</span>
<span class="p_del">-			.port        = dev-&gt;if_port,</span>
<span class="p_del">-		};</span>
<span class="p_add">+		struct rtnl_link_ifmap map;</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(&amp;map, 0, sizeof(map));</span>
<span class="p_add">+		map.mem_start   = dev-&gt;mem_start;</span>
<span class="p_add">+		map.mem_end     = dev-&gt;mem_end;</span>
<span class="p_add">+		map.base_addr   = dev-&gt;base_addr;</span>
<span class="p_add">+		map.irq         = dev-&gt;irq;</span>
<span class="p_add">+		map.dma         = dev-&gt;dma;</span>
<span class="p_add">+		map.port        = dev-&gt;if_port;</span>
<span class="p_add">+</span>
 		NLA_PUT(skb, IFLA_MAP, sizeof(map), &amp;map);
 	}
 
<span class="p_header">diff --git a/net/llc/af_llc.c b/net/llc/af_llc.c</span>
<span class="p_header">index f432d7b6d93a..7752b2ffbc43 100644</span>
<span class="p_header">--- a/net/llc/af_llc.c</span>
<span class="p_header">+++ b/net/llc/af_llc.c</span>
<span class="p_chunk">@@ -627,6 +627,7 @@</span> <span class="p_context"> static void llc_cmsg_rcv(struct msghdr *msg, struct sk_buff *skb)</span>
 	if (llc-&gt;cmsg_flags &amp; LLC_CMSG_PKTINFO) {
 		struct llc_pktinfo info;
 
<span class="p_add">+		memset(&amp;info, 0, sizeof(info));</span>
 		info.lpi_ifindex = llc_sk(skb-&gt;sk)-&gt;dev-&gt;ifindex;
 		llc_pdu_decode_dsap(skb, &amp;info.lpi_sap);
 		llc_pdu_decode_da(skb, info.lpi_mac);
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 7489bd301da5..c855673ceb23 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -1493,6 +1493,7 @@</span> <span class="p_context"> err_proto:</span>
 
 static int nf_conntrack_init_net(struct net *net)
 {
<span class="p_add">+	static atomic64_t unique_id;</span>
 	int ret;
 
 	atomic_set(&amp;net-&gt;ct.count, 0);
<span class="p_chunk">@@ -1504,7 +1505,8 @@</span> <span class="p_context"> static int nf_conntrack_init_net(struct net *net)</span>
 		goto err_stat;
 	}
 
<span class="p_del">-	net-&gt;ct.slabname = kasprintf(GFP_KERNEL, &quot;nf_conntrack_%p&quot;, net);</span>
<span class="p_add">+	net-&gt;ct.slabname = kasprintf(GFP_KERNEL, &quot;nf_conntrack_%llu&quot;,</span>
<span class="p_add">+				(u64)atomic64_inc_return(&amp;unique_id));</span>
 	if (!net-&gt;ct.slabname) {
 		ret = -ENOMEM;
 		goto err_slabname;
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index e1f73b65af15..446d22439492 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -7496,7 +7496,7 @@</span> <span class="p_context"> static int nl80211_netlink_notify(struct notifier_block * nb,</span>
 	struct cfg80211_registered_device *rdev;
 	struct wireless_dev *wdev;
 
<span class="p_del">-	if (state != NETLINK_URELEASE)</span>
<span class="p_add">+	if (state != NETLINK_URELEASE || notify-&gt;protocol != NETLINK_GENERIC)</span>
 		return NOTIFY_DONE;
 
 	rcu_read_lock();
<span class="p_header">diff --git a/net/x25/x25_facilities.c b/net/x25/x25_facilities.c</span>
<span class="p_header">index 36384a1fa9f2..887749c8054d 100644</span>
<span class="p_header">--- a/net/x25/x25_facilities.c</span>
<span class="p_header">+++ b/net/x25/x25_facilities.c</span>
<span class="p_chunk">@@ -271,6 +271,7 @@</span> <span class="p_context"> int x25_negotiate_facilities(struct sk_buff *skb, struct sock *sk,</span>
 
 	memset(&amp;theirs, 0, sizeof(theirs));
 	memcpy(new, ours, sizeof(*new));
<span class="p_add">+	memset(dte, 0, sizeof(*dte));</span>
 
 	len = x25_parse_facilities(skb, &amp;theirs, dte, &amp;x25-&gt;vc_facil_mask);
 	if (len &lt; 0)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



