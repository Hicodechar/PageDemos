
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,5/6] iommu/mediatek: Add mt8173 IOMMU driver - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,5/6] iommu/mediatek: Add mt8173 IOMMU driver</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=123111">Yong Wu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 16, 2015, 9:04 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1437037475-9065-6-git-send-email-yong.wu@mediatek.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6805361/mbox/"
   >mbox</a>
|
   <a href="/patch/6805361/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6805361/">/patch/6805361/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 617B4C05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Jul 2015 09:06:16 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 92B9820762
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Jul 2015 09:06:14 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id A147620732
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Jul 2015 09:06:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755054AbbGPJF5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 16 Jul 2015 05:05:57 -0400
Received: from mailgw02.mediatek.com ([210.61.82.184]:53954 &quot;EHLO
	mailgw02.mediatek.com&quot; rhost-flags-OK-FAIL-OK-FAIL) by
	vger.kernel.org with ESMTP id S1754545AbbGPJFv (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 16 Jul 2015 05:05:51 -0400
X-Listener-Flag: 11101
Received: from mtkhts07.mediatek.inc [(172.21.101.69)] by
	mailgw02.mediatek.com (envelope-from &lt;yong.wu@mediatek.com&gt;)
	(mhqrelay.mediatek.com ESMTP with TLS)
	with ESMTP id 857643972; Thu, 16 Jul 2015 17:05:48 +0800
Received: from mhfsdcap03.localdomain (10.17.3.153) by mtkhts07.mediatek.inc
	(172.21.101.73) with Microsoft SMTP Server id 14.3.181.6;
	Thu, 16 Jul 2015 17:05:46 +0800
From: Yong Wu &lt;yong.wu@mediatek.com&gt;
To: Joerg Roedel &lt;joro@8bytes.org&gt;, Thierry Reding &lt;treding@nvidia.com&gt;,
	Mark Rutland &lt;mark.rutland@arm.com&gt;,
	Matthias Brugger &lt;matthias.bgg@gmail.com&gt;
CC: Robin Murphy &lt;robin.murphy@arm.com&gt;, Will Deacon &lt;will.deacon@arm.com&gt;,
	Daniel Kurtz &lt;djkurtz@google.com&gt;, Tomasz Figa &lt;tfiga@google.com&gt;,
	Lucas Stach &lt;l.stach@pengutronix.de&gt;, Rob Herring &lt;robh+dt@kernel.org&gt;,
	Catalin Marinas &lt;catalin.marinas@arm.com&gt;,
	&lt;linux-mediatek@lists.infradead.org&gt;,
	Sasha Hauer &lt;kernel@pengutronix.de&gt;,
	&lt;srv_heupstream@mediatek.com&gt;, &lt;devicetree@vger.kernel.org&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;, &lt;linux-arm-kernel@lists.infradead.org&gt;,
	&lt;iommu@lists.linux-foundation.org&gt;, &lt;pebolle@tiscali.nl&gt;,
	&lt;arnd@arndb.de&gt;, &lt;mitchelh@codeaurora.org&gt;,
	&lt;cloud.chou@mediatek.com&gt;, &lt;frederic.chen@mediatek.com&gt;,
	&lt;yong.wu@mediatek.com&gt;
Subject: [PATCH v3 5/6] iommu/mediatek: Add mt8173 IOMMU driver
Date: Thu, 16 Jul 2015 17:04:34 +0800
Message-ID: &lt;1437037475-9065-6-git-send-email-yong.wu@mediatek.com&gt;
X-Mailer: git-send-email 1.7.9.5
In-Reply-To: &lt;1437037475-9065-1-git-send-email-yong.wu@mediatek.com&gt;
References: &lt;1437037475-9065-1-git-send-email-yong.wu@mediatek.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-MTK: N
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.2 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - July 16, 2015, 9:04 a.m.</div>
<pre class="content">
This patch adds support for mediatek m4u (MultiMedia Memory Management
Unit).
<span class="signed-off-by">
Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
---
 drivers/iommu/Kconfig     |   13 +
 drivers/iommu/Makefile    |    1 +
 drivers/iommu/mtk_iommu.c |  724 +++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 738 insertions(+)
 create mode 100644 drivers/iommu/mtk_iommu.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - July 21, 2015, 2:59 p.m.</div>
<pre class="content">
Hi Yong Wu,

On Thu, Jul 16, 2015 at 10:04:34AM +0100, Yong Wu wrote:
<span class="quote">&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; Unit).</span>

[...]
<span class="quote">
&gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +       void __iomem *base;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; +       writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +       writel(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>

This needs to be synchronous, so you probably want to call
mtk_iommu_tlb_sync at the end.
<span class="quote">
&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="quote">&gt; +                                   bool leaf, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +       void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; +       unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       writel(iova_start, base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; +       writel(iova_end, base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; +       writel(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);</span>

Why are you using writel instead of writel_relaxed? I asked this before
but I don&#39;t think you replied.

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - July 24, 2015, 5:43 a.m.</div>
<pre class="content">
On Tue, 2015-07-21 at 15:59 +0100, Will Deacon wrote:
<span class="quote">&gt; Hi Yong Wu,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Thu, Jul 16, 2015 at 10:04:34AM +0100, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; &gt; Unit).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +       void __iomem *base;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; +       writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; +       writel(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This needs to be synchronous, so you probably want to call</span>
<span class="quote">&gt; mtk_iommu_tlb_sync at the end.</span>

From our spec, we have to wait until HW done after tlb flush range.
But it don&#39;t need wait after tlb flush all.
so It isn&#39;t necessary to add mtk_iommu_tlb_sync in tlb_flush_all here.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="quote">&gt; &gt; +                                   bool leaf, void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +       void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; +       unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       writel(iova_start, base + REG_MMU_INVLD_START_A);</span>
<span class="quote">&gt; &gt; +       writel(iova_end, base + REG_MMU_INVLD_END_A);</span>
<span class="quote">&gt; &gt; +       writel(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why are you using writel instead of writel_relaxed? I asked this before</span>
<span class="quote">&gt; but I don&#39;t think you replied.</span>

Sorry, I didn&#39;t notice _relax last time. I will improve in next version.
Thanks very much.
<span class="quote">
&gt; </span>
<span class="quote">&gt; Will</span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - July 24, 2015, 4:55 p.m.</div>
<pre class="content">
On Fri, Jul 24, 2015 at 06:43:13AM +0100, Yong Wu wrote:
<span class="quote">&gt; On Tue, 2015-07-21 at 15:59 +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; On Thu, Jul 16, 2015 at 10:04:34AM +0100, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; &gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; &gt; +       void __iomem *base;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +       base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; &gt; +       writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; &gt; +       writel(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This needs to be synchronous, so you probably want to call</span>
<span class="quote">&gt; &gt; mtk_iommu_tlb_sync at the end.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; From our spec, we have to wait until HW done after tlb flush range.</span>
<span class="quote">&gt; But it don&#39;t need wait after tlb flush all.</span>
<span class="quote">&gt; so It isn&#39;t necessary to add mtk_iommu_tlb_sync in tlb_flush_all here.</span>

Okey doke, but I&#39;m surprised you don&#39;t need a subsequent DSB or read-back.
What if the writel is buffered on the way to the IOMMU?

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - July 27, 2015, 4:24 a.m.</div>
<pre class="content">
On Fri, 2015-07-24 at 17:55 +0100, Will Deacon wrote:
<span class="quote">&gt; On Fri, Jul 24, 2015 at 06:43:13AM +0100, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; On Tue, 2015-07-21 at 15:59 +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; &gt; On Thu, Jul 16, 2015 at 10:04:34AM +0100, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; &gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; &gt; &gt; +       void __iomem *base;</span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; +       base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; &gt; &gt; +       writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; &gt; &gt; +       writel(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; This needs to be synchronous, so you probably want to call</span>
<span class="quote">&gt; &gt; &gt; mtk_iommu_tlb_sync at the end.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; From our spec, we have to wait until HW done after tlb flush range.</span>
<span class="quote">&gt; &gt; But it don&#39;t need wait after tlb flush all.</span>
<span class="quote">&gt; &gt; so It isn&#39;t necessary to add mtk_iommu_tlb_sync in tlb_flush_all here.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Okey doke, but I&#39;m surprised you don&#39;t need a subsequent DSB or read-back.</span>
<span class="quote">&gt; What if the writel is buffered on the way to the IOMMU?</span>

Then I change to this:
 //==========
    writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);
    writel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);    
    dsb(ishst);
//===========
    dsb or mb(). which one is better here?
<span class="quote">
&gt; </span>
<span class="quote">&gt; Will</span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - July 27, 2015, 1:23 p.m.</div>
<pre class="content">
On 16/07/15 10:04, Yong Wu wrote:
<span class="quote">&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; Unit).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
[...]
<span class="quote">&gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; +       unsigned long offset = (unsigned long)ptr &amp; ~PAGE_MASK;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       dma_map_page(domain-&gt;data-&gt;dev, virt_to_page(ptr), offset,</span>
<span class="quote">&gt; +                    size, DMA_TO_DEVICE);</span>

Nit: this looks like it may as well be dma_map_single.

It would probably be worth following it with a matching unmap too, just 
to avoid any possible leakage bugs (especially if this M4U ever appears 
in a SoC supporting RAM above the 32-bit boundary).
<span class="quote">
 &gt; +}</span>
<span class="quote"> &gt; +</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="quote">&gt; +                             struct mtk_iommu_data *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; +       struct device_node *ofnode;</span>
<span class="quote">&gt; +       struct resource *res;</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ofnode = dev-&gt;of_node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="quote">&gt; +       data-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="quote">&gt; +       if (IS_ERR(data-&gt;base))</span>
<span class="quote">&gt; +               return PTR_ERR(data-&gt;base);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="quote">&gt; +       if (data-&gt;irq &lt; 0)</span>
<span class="quote">&gt; +               return data-&gt;irq;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="quote">&gt; +       if (IS_ERR(data-&gt;bclk))</span>
<span class="quote">&gt; +               return PTR_ERR(data-&gt;bclk);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;larb_nr = of_count_phandle_with_args(</span>
<span class="quote">&gt; +                                       ofnode, &quot;mediatek,larb&quot;, NULL);</span>
<span class="quote">&gt; +       if (data-&gt;larb_nr &lt; 0)</span>
<span class="quote">&gt; +               return data-&gt;larb_nr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; data-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; +               struct device_node *larbnode;</span>
<span class="quote">&gt; +               struct platform_device *plarbdev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               larbnode = of_parse_phandle(ofnode, &quot;mediatek,larb&quot;, i);</span>
<span class="quote">&gt; +               if (!larbnode)</span>
<span class="quote">&gt; +                       return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; +               of_node_put(larbnode);</span>
<span class="quote">&gt; +               if (!plarbdev)</span>
<span class="quote">&gt; +                       return -EPROBE_DEFER;</span>
<span class="quote">&gt; +               data-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; +       }</span>

At a glance this seems like a job for of_parse_phandle_with_args, but I 
may be missing something subtle.
<span class="quote">
&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_init_domain_context(struct mtk_iommu_domain *dom)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (dom-&gt;iop)</span>
<span class="quote">&gt; +               return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="quote">&gt; +       dom-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS |</span>
<span class="quote">&gt; +                       IO_PGTABLE_QUIRK_SHORT_SUPERSECTION |</span>
<span class="quote">&gt; +                       IO_PGTABLE_QUIRK_SHORT_MTK;</span>
<span class="quote">&gt; +       dom-&gt;cfg.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,</span>
<span class="quote">&gt; +       dom-&gt;cfg.ias = 32;</span>
<span class="quote">&gt; +       dom-&gt;cfg.oas = 32;</span>
<span class="quote">&gt; +       dom-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       dom-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;dom-&gt;cfg, dom);</span>
<span class="quote">&gt; +       if (!dom-&gt;iop) {</span>
<span class="quote">&gt; +               pr_err(&quot;Failed to alloc io pgtable\n&quot;);</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Update our support page sizes bitmap */</span>
<span class="quote">&gt; +       mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = mtk_iommu_hw_init(dom);</span>
<span class="quote">&gt; +       if (ret)</span>
<span class="quote">&gt; +               free_io_pgtable_ops(dom-&gt;iop);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>

I don&#39;t see that you need the above function at all - since your 
pagetable config is fixed and doesn&#39;t have any depency on which IOMMU 
you&#39;re attaching to, can&#39;t you just do all of that straight away in 
domain_alloc?
<span class="quote">
&gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* We only support unmanaged domains for now */</span>
<span class="quote">&gt; +       if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="quote">&gt; +               return NULL;</span>

Have you had a chance to play with the latest DMA mapping series now 
that I&#39;ve integrated the default domain changes? I think if you handled 
IOMMU_DOMAIN_DMA requests here and made them always return the 
(preallocated) private domain, you should be able to get rid of the 
tricks in attach_device completely.
<span class="quote">
&gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (!priv)</span>
<span class="quote">&gt; +               return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="quote">&gt; +       priv-&gt;domain.geometry.aperture_end = (1ULL &lt;&lt; 32) - 1;</span>

DMA_BIT_MASK(32) ?
<span class="quote">
&gt; +       priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return &amp;priv-&gt;domain;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *mtkdom;</span>
<span class="quote">&gt; +       struct iommu_group *group;</span>
<span class="quote">&gt; +       struct mtk_iommu_client_priv *devhead;</span>
<span class="quote">&gt; +       int ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!dev-&gt;archdata.dma_ops)/* Not a iommu client device */</span>
<span class="quote">&gt; +               return -ENODEV;</span>

I think archdata.dma_ops is the wrong thing to test here. It would be 
better to use archdata.iommu, since you go on to dereference that 
unconditionally anyway, plus then you only depend on your own of_xlate 
behaviour, rather than some quirk of the arch code (which could quietly 
change in future).
<span class="quote">
&gt; +       group = iommu_group_get(dev);</span>
<span class="quote">&gt; +       if (!group) {</span>
<span class="quote">&gt; +               group = iommu_group_alloc();</span>
<span class="quote">&gt; +               if (IS_ERR(group)) {</span>
<span class="quote">&gt; +                       dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; +                       return PTR_ERR(group);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; +       if (ret) {</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; +               goto err_group_put;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* get the mtk_iommu_domain from the iommu device */</span>
<span class="quote">&gt; +       devhead = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +       mtkdom = devhead-&gt;imudev-&gt;archdata.iommu;</span>
<span class="quote">&gt; +       ret = iommu_attach_group(&amp;mtkdom-&gt;domain, group);</span>
<span class="quote">&gt; +       if (ret)</span>
<span class="quote">&gt; +               dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +err_group_put:</span>
<span class="quote">&gt; +       iommu_group_put(group);</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
[...]
<span class="quote">&gt; +static struct iommu_ops mtk_iommu_ops = {</span>
<span class="quote">&gt; +       .domain_alloc   = mtk_iommu_domain_alloc,</span>
<span class="quote">&gt; +       .domain_free    = mtk_iommu_domain_free,</span>
<span class="quote">&gt; +       .attach_dev     = mtk_iommu_attach_device,</span>
<span class="quote">&gt; +       .detach_dev     = mtk_iommu_detach_device,</span>
<span class="quote">&gt; +       .map            = mtk_iommu_map,</span>
<span class="quote">&gt; +       .unmap          = mtk_iommu_unmap,</span>
<span class="quote">&gt; +       .map_sg         = default_iommu_map_sg,</span>
<span class="quote">&gt; +       .iova_to_phys   = mtk_iommu_iova_to_phys,</span>
<span class="quote">&gt; +       .add_device     = mtk_iommu_add_device,</span>
<span class="quote">&gt; +       .of_xlate       = mtk_iommu_of_xlate,</span>
<span class="quote">&gt; +       .pgsize_bitmap  = -1UL,</span>

As above, if you know the hardware only supports a single descriptor 
format with a fixed set of page sizes, why not just represent that directly?
<span class="quote">
&gt; +};</span>
<span class="quote">&gt; +</span>
[...]
<span class="quote">&gt; +static int mtk_iommu_suspend(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +       struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; +       void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; +       unsigned int i = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_PT_BASE_ADDR);</span>

Redundancy nit: any particular reason for saving this here rather than 
simply restoring it from mtkdom-&gt;cfg.arm_short_cfg.ttbr[0] on resume?
<span class="quote">
&gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_INT_MAIN_CONTROL);</span>

Nit: given that these are fairly arbitrary discontiguous registers so 
you can&#39;t have a simple loop over the array, it might be clearer to 
replace the array with an equivalent struct, e.g.:

struct mtk_iommu_suspend_regs {
	u32 standard_axi_mode;
	u32 dcm_dis;
	...
}

	...
	data-&gt;reg.dcm_dis = readl(base + REG_MMU_DCM_DIS);
	...

then since you refer to everything by name you don&#39;t have to worry about 
the length and order of array elements if anything ever changes.
<span class="quote">
&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; +       struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; +       void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; +       unsigned int i = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       writel(data-&gt;reg[i++], base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; +       writel(data-&gt;reg[i++], base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; +       writel(data-&gt;reg[i++], base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; +       writel(data-&gt;reg[i++], base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; +       writel(data-&gt;reg[i++], base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; +       writel(data-&gt;reg[i++], base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; +       writel(data-&gt;reg[i++], base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>

Other than that though, modulo the issues with the pagetable code I 
think this part of the driver is shaping up quite nicely.

Robin.

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=709">Russell King - ARM Linux</a> - July 27, 2015, 3:31 p.m.</div>
<pre class="content">
On Mon, Jul 27, 2015 at 02:23:26PM +0100, Robin Murphy wrote:
<span class="quote">&gt; On 16/07/15 10:04, Yong Wu wrote:</span>
<span class="quote">&gt; &gt;This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; &gt;Unit).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt;+static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; &gt;+{</span>
<span class="quote">&gt; &gt;+       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt;+       unsigned long offset = (unsigned long)ptr &amp; ~PAGE_MASK;</span>
<span class="quote">&gt; &gt;+</span>
<span class="quote">&gt; &gt;+       dma_map_page(domain-&gt;data-&gt;dev, virt_to_page(ptr), offset,</span>
<span class="quote">&gt; &gt;+                    size, DMA_TO_DEVICE);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: this looks like it may as well be dma_map_single.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It would probably be worth following it with a matching unmap too, just to</span>
<span class="quote">&gt; avoid any possible leakage bugs (especially if this M4U ever appears in a</span>
<span class="quote">&gt; SoC supporting RAM above the 32-bit boundary).</span>

Why not do the job properly?  Take a look at how I implemented the
streaming DMA API on Tegra SMMU (patch set recently sent out earlier
today).

There&#39;s no need for hacks like dma_map_page() (and discarding it&#39;s
return value) or dma_map_page() followed by dma_unmap_page().
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - July 27, 2015, 3:48 p.m.</div>
<pre class="content">
On Mon, Jul 27, 2015 at 05:24:31AM +0100, Yong Wu wrote:
<span class="quote">&gt; On Fri, 2015-07-24 at 17:55 +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; On Fri, Jul 24, 2015 at 06:43:13AM +0100, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; &gt; On Tue, 2015-07-21 at 15:59 +0100, Will Deacon wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On Thu, Jul 16, 2015 at 10:04:34AM +0100, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +       void __iomem *base;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +       base = domain-&gt;data-&gt;base;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +       writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +       writel(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; This needs to be synchronous, so you probably want to call</span>
<span class="quote">&gt; &gt; &gt; &gt; mtk_iommu_tlb_sync at the end.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; From our spec, we have to wait until HW done after tlb flush range.</span>
<span class="quote">&gt; &gt; &gt; But it don&#39;t need wait after tlb flush all.</span>
<span class="quote">&gt; &gt; &gt; so It isn&#39;t necessary to add mtk_iommu_tlb_sync in tlb_flush_all here.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Okey doke, but I&#39;m surprised you don&#39;t need a subsequent DSB or read-back.</span>
<span class="quote">&gt; &gt; What if the writel is buffered on the way to the IOMMU?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then I change to this:</span>
<span class="quote">&gt;  //==========</span>
<span class="quote">&gt;     writel_relaxed(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="quote">&gt;     writel_relaxed(F_ALL_INVLD, base + REG_MMU_INVALIDATE);    </span>
<span class="quote">&gt;     dsb(ishst);</span>
<span class="quote">&gt; //===========</span>
<span class="quote">&gt;     dsb or mb(). which one is better here?</span>

I think you should use mb();

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - July 27, 2015, 3:49 p.m.</div>
<pre class="content">
On 27/07/15 16:31, Russell King - ARM Linux wrote:
<span class="quote">&gt; On Mon, Jul 27, 2015 at 02:23:26PM +0100, Robin Murphy wrote:</span>
<span class="quote">&gt;&gt; On 16/07/15 10:04, Yong Wu wrote:</span>
<span class="quote">&gt;&gt;&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt;&gt;&gt; Unit).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;&gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt;&gt;&gt; +       unsigned long offset = (unsigned long)ptr &amp; ~PAGE_MASK;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       dma_map_page(domain-&gt;data-&gt;dev, virt_to_page(ptr), offset,</span>
<span class="quote">&gt;&gt;&gt; +                    size, DMA_TO_DEVICE);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Nit: this looks like it may as well be dma_map_single.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; It would probably be worth following it with a matching unmap too, just to</span>
<span class="quote">&gt;&gt; avoid any possible leakage bugs (especially if this M4U ever appears in a</span>
<span class="quote">&gt;&gt; SoC supporting RAM above the 32-bit boundary).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Why not do the job properly?  Take a look at how I implemented the</span>
<span class="quote">&gt; streaming DMA API on Tegra SMMU (patch set recently sent out earlier</span>
<span class="quote">&gt; today).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; There&#39;s no need for hacks like dma_map_page() (and discarding it&#39;s</span>
<span class="quote">&gt; return value) or dma_map_page() followed by dma_unmap_page().</span>

Indeed, as it happens I do have a branch where I prototyped that for the 
long-descriptor io-pgtable-arm code a while ago; this discussion has 
prompted me to dig it up again. Stay tuned, folks...

Robin.

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - July 29, 2015, 5:41 a.m.</div>
<pre class="content">
On Mon, 2015-07-27 at 16:49 +0100, Robin Murphy wrote:
<span class="quote">&gt; On 27/07/15 16:31, Russell King - ARM Linux wrote:</span>
<span class="quote">&gt; &gt; On Mon, Jul 27, 2015 at 02:23:26PM +0100, Robin Murphy wrote:</span>
<span class="quote">&gt; &gt;&gt; On 16/07/15 10:04, Yong Wu wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; &gt;&gt;&gt; Unit).</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt;&gt; [...]</span>
<span class="quote">&gt; &gt;&gt;&gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt;&gt;&gt; +       unsigned long offset = (unsigned long)ptr &amp; ~PAGE_MASK;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +       dma_map_page(domain-&gt;data-&gt;dev, virt_to_page(ptr), offset,</span>
<span class="quote">&gt; &gt;&gt;&gt; +                    size, DMA_TO_DEVICE);</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Nit: this looks like it may as well be dma_map_single.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; It would probably be worth following it with a matching unmap too, just to</span>
<span class="quote">&gt; &gt;&gt; avoid any possible leakage bugs (especially if this M4U ever appears in a</span>
<span class="quote">&gt; &gt;&gt; SoC supporting RAM above the 32-bit boundary).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Why not do the job properly?  Take a look at how I implemented the</span>
<span class="quote">&gt; &gt; streaming DMA API on Tegra SMMU (patch set recently sent out earlier</span>
<span class="quote">&gt; &gt; today).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; There&#39;s no need for hacks like dma_map_page() (and discarding it&#39;s</span>
<span class="quote">&gt; &gt; return value) or dma_map_page() followed by dma_unmap_page().</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Indeed, as it happens I do have a branch where I prototyped that for the </span>
<span class="quote">&gt; long-descriptor io-pgtable-arm code a while ago; this discussion has </span>
<span class="quote">&gt; prompted me to dig it up again. Stay tuned, folks...</span>

Hi Russell, Robin,

     From I see in arm-smmu-v3.c in v4.2-rc1, 
     
     The flush_pgtable seems like this:
//==========
	dma_addr_t dma_addr;

	dma_addr = dma_map_page(dev, ptr, size, DMA_TO_DEVICE);

	if (dma_mapping_error(dev, dma_addr))
		dev_err(dev, &quot;failed to flush pgtable at %p\n&quot;, ptr);
	else
		dma_unmap_page(dev, dma_addr, size, DMA_TO_DEVICE);
//==========
       I will change map like this and use dma_map_single instead.

       Is this also seems to be not proper?

       Then how to do it?  add this before unmap? :
       dma_sync_single_for_device(dev, dma_addr, size, DMA_TO_DEVICE);
<span class="quote">
&gt; </span>
<span class="quote">&gt; Robin.</span>
<span class="quote">&gt; </span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=123111">Yong Wu</a> - July 29, 2015, 6:32 a.m.</div>
<pre class="content">
On Mon, 2015-07-27 at 14:23 +0100, Robin Murphy wrote:
<span class="quote">&gt; On 16/07/15 10:04, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; &gt; Unit).</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; +       unsigned long offset = (unsigned long)ptr &amp; ~PAGE_MASK;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       dma_map_page(domain-&gt;data-&gt;dev, virt_to_page(ptr), offset,</span>
<span class="quote">&gt; &gt; +                    size, DMA_TO_DEVICE);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: this looks like it may as well be dma_map_single.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It would probably be worth following it with a matching unmap too, just </span>
<span class="quote">&gt; to avoid any possible leakage bugs (especially if this M4U ever appears </span>
<span class="quote">&gt; in a SoC supporting RAM above the 32-bit boundary).</span>

About the map, I will read and try to follow your patch:
iommu/io-pgtable-arm: Allow appropriate DMA API use.
<span class="quote">
&gt; </span>
<span class="quote">&gt;  &gt; +}</span>
<span class="quote">&gt;  &gt; +</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="quote">&gt; &gt; +                             struct mtk_iommu_data *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +       struct device_node *ofnode;</span>
<span class="quote">&gt; &gt; +       struct resource *res;</span>
<span class="quote">&gt; &gt; +       int i;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ofnode = dev-&gt;of_node;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="quote">&gt; &gt; +       data-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="quote">&gt; &gt; +       if (IS_ERR(data-&gt;base))</span>
<span class="quote">&gt; &gt; +               return PTR_ERR(data-&gt;base);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="quote">&gt; &gt; +       if (data-&gt;irq &lt; 0)</span>
<span class="quote">&gt; &gt; +               return data-&gt;irq;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="quote">&gt; &gt; +       if (IS_ERR(data-&gt;bclk))</span>
<span class="quote">&gt; &gt; +               return PTR_ERR(data-&gt;bclk);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;larb_nr = of_count_phandle_with_args(</span>
<span class="quote">&gt; &gt; +                                       ofnode, &quot;mediatek,larb&quot;, NULL);</span>
<span class="quote">&gt; &gt; +       if (data-&gt;larb_nr &lt; 0)</span>
<span class="quote">&gt; &gt; +               return data-&gt;larb_nr;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (i = 0; i &lt; data-&gt;larb_nr; i++) {</span>
<span class="quote">&gt; &gt; +               struct device_node *larbnode;</span>
<span class="quote">&gt; &gt; +               struct platform_device *plarbdev;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               larbnode = of_parse_phandle(ofnode, &quot;mediatek,larb&quot;, i);</span>
<span class="quote">&gt; &gt; +               if (!larbnode)</span>
<span class="quote">&gt; &gt; +                       return -EINVAL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               plarbdev = of_find_device_by_node(larbnode);</span>
<span class="quote">&gt; &gt; +               of_node_put(larbnode);</span>
<span class="quote">&gt; &gt; +               if (!plarbdev)</span>
<span class="quote">&gt; &gt; +                       return -EPROBE_DEFER;</span>
<span class="quote">&gt; &gt; +               data-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; At a glance this seems like a job for of_parse_phandle_with_args, but I </span>
<span class="quote">&gt; may be missing something subtle.</span>

It seems We can not use of_parse_phandle_with_args here.

The node of larb is.
//=========
larb0: larb@14021000 {
	compatible = &quot;mediatek,mt8173-smi-larb&quot;;
	reg = &lt;0 0x14021000 0 0x1000&gt;;
	mediatek,smi = &lt;&amp;smi_common&gt;;	
	power-domains = &lt;&amp;scpsys MT8173_POWER_DOMAIN_MM&gt;;
	clocks = &lt;&amp;mmsys CLK_MM_SMI_LARB0&gt;,
		 &lt;&amp;mmsys CLK_MM_SMI_LARB0&gt;;
	clock-names = &quot;apb&quot;, &quot;smi&quot;;
};
//==========
  of_parse_phandle_with_args(ofnode,&quot;mediatek,larb&quot;, &quot;mediatek,smi&quot;,
&amp;larb) will be wrong due to there is no item like &quot;mediatek,smi = &lt;1&gt;;&quot;
in larb.

And this code seems to be not simple if we use
of_parse_phandle_with_args. Both need a loop.

so I don&#39;t change it here, ok?
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_init_domain_context(struct mtk_iommu_domain *dom)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (dom-&gt;iop)</span>
<span class="quote">&gt; &gt; +               return 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="quote">&gt; &gt; +       dom-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS |</span>
<span class="quote">&gt; &gt; +                       IO_PGTABLE_QUIRK_SHORT_SUPERSECTION |</span>
<span class="quote">&gt; &gt; +                       IO_PGTABLE_QUIRK_SHORT_MTK;</span>
<span class="quote">&gt; &gt; +       dom-&gt;cfg.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,</span>
<span class="quote">&gt; &gt; +       dom-&gt;cfg.ias = 32;</span>
<span class="quote">&gt; &gt; +       dom-&gt;cfg.oas = 32;</span>
<span class="quote">&gt; &gt; +       dom-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       dom-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;dom-&gt;cfg, dom);</span>
<span class="quote">&gt; &gt; +       if (!dom-&gt;iop) {</span>
<span class="quote">&gt; &gt; +               pr_err(&quot;Failed to alloc io pgtable\n&quot;);</span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* Update our support page sizes bitmap */</span>
<span class="quote">&gt; &gt; +       mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = mtk_iommu_hw_init(dom);</span>
<span class="quote">&gt; &gt; +       if (ret)</span>
<span class="quote">&gt; &gt; +               free_io_pgtable_ops(dom-&gt;iop);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I don&#39;t see that you need the above function at all - since your </span>
<span class="quote">&gt; pagetable config is fixed and doesn&#39;t have any depency on which IOMMU </span>
<span class="quote">&gt; you&#39;re attaching to, can&#39;t you just do all of that straight away in </span>
<span class="quote">&gt; domain_alloc?</span>

Yes. We could move it into domain_alloc.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *priv;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* We only support unmanaged domains for now */</span>
<span class="quote">&gt; &gt; +       if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Have you had a chance to play with the latest DMA mapping series now </span>
<span class="quote">&gt; that I&#39;ve integrated the default domain changes? I think if you handled </span>
<span class="quote">&gt; IOMMU_DOMAIN_DMA requests here and made them always return the </span>
<span class="quote">&gt; (preallocated) private domain, you should be able to get rid of the </span>
<span class="quote">&gt; tricks in attach_device completely.</span>

  I can change it to this:
  if (type != IOMMU_DOMAIN_UNMANAGED &amp;&amp; type != IOMMU_DOMAIN_DMA)
               return NULL;
 
  If always return the (preallocated) private domain, I have to use a
global variable to restore the preallocated domain here!.

  And It also will print &quot;Incompatible range for DMA domain&quot; and return
fail.
Could we return 0 instead of -EFAULT in iommu_dma_init_domain if the
domain is the same. 
<span class="quote">
&gt; &gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (!priv)</span>
<span class="quote">&gt; &gt; +               return NULL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.aperture_end = (1ULL &lt;&lt; 32) - 1;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; DMA_BIT_MASK(32) ?</span>

Thanks.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +       priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return &amp;priv-&gt;domain;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_add_device(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *mtkdom;</span>
<span class="quote">&gt; &gt; +       struct iommu_group *group;</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_client_priv *devhead;</span>
<span class="quote">&gt; &gt; +       int ret;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       if (!dev-&gt;archdata.dma_ops)/* Not a iommu client device */</span>
<span class="quote">&gt; &gt; +               return -ENODEV;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think archdata.dma_ops is the wrong thing to test here. It would be </span>
<span class="quote">&gt; better to use archdata.iommu, since you go on to dereference that </span>
<span class="quote">&gt; unconditionally anyway, plus then you only depend on your own of_xlate </span>
<span class="quote">&gt; behaviour, rather than some quirk of the arch code (which could quietly </span>
<span class="quote">&gt; change in future).</span>

I will change archdata.iommu next time.
Current I used the dev-&gt;archdata.iommu of the iommu device(m4u device)
itself. then the m4u device will come here too. so I changed to
dev-&gt;archdata.dma_ops.

As before, If we use a global variable for the mtk_iommu_domain, we
could use archdata.iommu here.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +       group = iommu_group_get(dev);</span>
<span class="quote">&gt; &gt; +       if (!group) {</span>
<span class="quote">&gt; &gt; +               group = iommu_group_alloc();</span>
<span class="quote">&gt; &gt; +               if (IS_ERR(group)) {</span>
<span class="quote">&gt; &gt; +                       dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +                       return PTR_ERR(group);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       ret = iommu_group_add_device(group, dev);</span>
<span class="quote">&gt; &gt; +       if (ret) {</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +               goto err_group_put;</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* get the mtk_iommu_domain from the iommu device */</span>
<span class="quote">&gt; &gt; +       devhead = dev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +       mtkdom = devhead-&gt;imudev-&gt;archdata.iommu;</span>
<span class="quote">&gt; &gt; +       ret = iommu_attach_group(&amp;mtkdom-&gt;domain, group);</span>
<span class="quote">&gt; &gt; +       if (ret)</span>
<span class="quote">&gt; &gt; +               dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +err_group_put:</span>
<span class="quote">&gt; &gt; +       iommu_group_put(group);</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static struct iommu_ops mtk_iommu_ops = {</span>
<span class="quote">&gt; &gt; +       .domain_alloc   = mtk_iommu_domain_alloc,</span>
<span class="quote">&gt; &gt; +       .domain_free    = mtk_iommu_domain_free,</span>
<span class="quote">&gt; &gt; +       .attach_dev     = mtk_iommu_attach_device,</span>
<span class="quote">&gt; &gt; +       .detach_dev     = mtk_iommu_detach_device,</span>
<span class="quote">&gt; &gt; +       .map            = mtk_iommu_map,</span>
<span class="quote">&gt; &gt; +       .unmap          = mtk_iommu_unmap,</span>
<span class="quote">&gt; &gt; +       .map_sg         = default_iommu_map_sg,</span>
<span class="quote">&gt; &gt; +       .iova_to_phys   = mtk_iommu_iova_to_phys,</span>
<span class="quote">&gt; &gt; +       .add_device     = mtk_iommu_add_device,</span>
<span class="quote">&gt; &gt; +       .of_xlate       = mtk_iommu_of_xlate,</span>
<span class="quote">&gt; &gt; +       .pgsize_bitmap  = -1UL,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As above, if you know the hardware only supports a single descriptor </span>
<span class="quote">&gt; format with a fixed set of page sizes, why not just represent that directly?</span>

OK. I will write the fix page sizes here.
I wrote it following the arm-smmu.c:)
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_suspend(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; &gt; +       void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; &gt; +       unsigned int i = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Redundancy nit: any particular reason for saving this here rather than </span>
<span class="quote">&gt; simply restoring it from mtkdom-&gt;cfg.arm_short_cfg.ttbr[0] on resume?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; &gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +       data-&gt;reg[i++] = readl(base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Nit: given that these are fairly arbitrary discontiguous registers so </span>
<span class="quote">&gt; you can&#39;t have a simple loop over the array, it might be clearer to </span>
<span class="quote">&gt; replace the array with an equivalent struct, e.g.:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; struct mtk_iommu_suspend_regs {</span>
<span class="quote">&gt; 	u32 standard_axi_mode;</span>
<span class="quote">&gt; 	u32 dcm_dis;</span>
<span class="quote">&gt; 	...</span>
<span class="quote">&gt; }</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	...</span>
<span class="quote">&gt; 	data-&gt;reg.dcm_dis = readl(base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; 	...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; then since you refer to everything by name you don&#39;t have to worry about </span>
<span class="quote">&gt; the length and order of array elements if anything ever changes.</span>

Good idea. Thanks very much.
<span class="quote">
&gt; </span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int mtk_iommu_resume(struct device *dev)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="quote">&gt; &gt; +       struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="quote">&gt; &gt; +       void __iomem *base = data-&gt;base;</span>
<span class="quote">&gt; &gt; +       unsigned int i = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       writel(data-&gt;reg[i++], base + REG_MMU_PT_BASE_ADDR);</span>
<span class="quote">&gt; &gt; +       writel(data-&gt;reg[i++], base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="quote">&gt; &gt; +       writel(data-&gt;reg[i++], base + REG_MMU_DCM_DIS);</span>
<span class="quote">&gt; &gt; +       writel(data-&gt;reg[i++], base + REG_MMU_CTRL_REG);</span>
<span class="quote">&gt; &gt; +       writel(data-&gt;reg[i++], base + REG_MMU_IVRP_PADDR);</span>
<span class="quote">&gt; &gt; +       writel(data-&gt;reg[i++], base + REG_MMU_INT_CONTROL0);</span>
<span class="quote">&gt; &gt; +       writel(data-&gt;reg[i++], base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Other than that though, modulo the issues with the pagetable code I </span>
<span class="quote">&gt; think this part of the driver is shaping up quite nicely.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Robin.</span>
<span class="quote">&gt; </span>


--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7096">Will Deacon</a> - July 29, 2015, 10:31 a.m.</div>
<pre class="content">
On Wed, Jul 29, 2015 at 06:41:31AM +0100, Yong Wu wrote:
<span class="quote">&gt; On Mon, 2015-07-27 at 16:49 +0100, Robin Murphy wrote:</span>
<span class="quote">&gt; &gt; On 27/07/15 16:31, Russell King - ARM Linux wrote:</span>
<span class="quote">&gt; &gt; &gt; On Mon, Jul 27, 2015 at 02:23:26PM +0100, Robin Murphy wrote:</span>
<span class="quote">&gt; &gt; &gt;&gt; On 16/07/15 10:04, Yong Wu wrote:</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; This patch adds support for mediatek m4u (MultiMedia Memory Management</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; Unit).</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; Signed-off-by: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="quote">&gt; &gt; &gt;&gt; [...]</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; +static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; +       struct mtk_iommu_domain *domain = cookie;</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; +       unsigned long offset = (unsigned long)ptr &amp; ~PAGE_MASK;</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; +       dma_map_page(domain-&gt;data-&gt;dev, virt_to_page(ptr), offset,</span>
<span class="quote">&gt; &gt; &gt;&gt;&gt; +                    size, DMA_TO_DEVICE);</span>
<span class="quote">&gt; &gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; &gt;&gt; Nit: this looks like it may as well be dma_map_single.</span>
<span class="quote">&gt; &gt; &gt;&gt;</span>
<span class="quote">&gt; &gt; &gt;&gt; It would probably be worth following it with a matching unmap too, just to</span>
<span class="quote">&gt; &gt; &gt;&gt; avoid any possible leakage bugs (especially if this M4U ever appears in a</span>
<span class="quote">&gt; &gt; &gt;&gt; SoC supporting RAM above the 32-bit boundary).</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; Why not do the job properly?  Take a look at how I implemented the</span>
<span class="quote">&gt; &gt; &gt; streaming DMA API on Tegra SMMU (patch set recently sent out earlier</span>
<span class="quote">&gt; &gt; &gt; today).</span>
<span class="quote">&gt; &gt; &gt;</span>
<span class="quote">&gt; &gt; &gt; There&#39;s no need for hacks like dma_map_page() (and discarding it&#39;s</span>
<span class="quote">&gt; &gt; &gt; return value) or dma_map_page() followed by dma_unmap_page().</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Indeed, as it happens I do have a branch where I prototyped that for the </span>
<span class="quote">&gt; &gt; long-descriptor io-pgtable-arm code a while ago; this discussion has </span>
<span class="quote">&gt; &gt; prompted me to dig it up again. Stay tuned, folks...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hi Russell, Robin,</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;      From I see in arm-smmu-v3.c in v4.2-rc1, </span>
<span class="quote">&gt;      </span>
<span class="quote">&gt;      The flush_pgtable seems like this:</span>
<span class="quote">&gt; //==========</span>
<span class="quote">&gt; 	dma_addr_t dma_addr;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	dma_addr = dma_map_page(dev, ptr, size, DMA_TO_DEVICE);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	if (dma_mapping_error(dev, dma_addr))</span>
<span class="quote">&gt; 		dev_err(dev, &quot;failed to flush pgtable at %p\n&quot;, ptr);</span>
<span class="quote">&gt; 	else</span>
<span class="quote">&gt; 		dma_unmap_page(dev, dma_addr, size, DMA_TO_DEVICE);</span>
<span class="quote">&gt; //==========</span>
<span class="quote">&gt;        I will change map like this and use dma_map_single instead.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;        Is this also seems to be not proper?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;        Then how to do it?  add this before unmap? :</span>
<span class="quote">&gt;        dma_sync_single_for_device(dev, dma_addr, size, DMA_TO_DEVICE);</span>

Robin&#39;s proposed a series fixing this in the io-pgtable code:

  http://lists.linuxfoundation.org/pipermail/iommu/2015-July/013821.html

which is currently under review. Please take a look and give comments!
Once merged, the code you cite above will be removed.

Will
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/Kconfig b/drivers/iommu/Kconfig</span>
<span class="p_header">index f50dbf3..3178c12 100644</span>
<span class="p_header">--- a/drivers/iommu/Kconfig</span>
<span class="p_header">+++ b/drivers/iommu/Kconfig</span>
<span class="p_chunk">@@ -386,4 +386,17 @@</span> <span class="p_context"> config ARM_SMMU_V3</span>
 	  Say Y here if your system includes an IOMMU device implementing
 	  the ARM SMMUv3 architecture.
 
<span class="p_add">+config MTK_IOMMU</span>
<span class="p_add">+	bool &quot;MTK IOMMU Support&quot;</span>
<span class="p_add">+	depends on ARCH_MEDIATEK || COMPILE_TEST</span>
<span class="p_add">+	select IOMMU_API</span>
<span class="p_add">+	select IOMMU_DMA</span>
<span class="p_add">+	select IOMMU_IO_PGTABLE_SHORT</span>
<span class="p_add">+	select MEMORY</span>
<span class="p_add">+	select MTK_SMI</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Support for the IOMMUs on certain Mediatek SOCs.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N here.</span>
<span class="p_add">+</span>
 endif # IOMMU_SUPPORT
<span class="p_header">diff --git a/drivers/iommu/Makefile b/drivers/iommu/Makefile</span>
<span class="p_header">index 06df3e6..f4f2f2c 100644</span>
<span class="p_header">--- a/drivers/iommu/Makefile</span>
<span class="p_header">+++ b/drivers/iommu/Makefile</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> obj-$(CONFIG_ROCKCHIP_IOMMU) += rockchip-iommu.o</span>
 obj-$(CONFIG_TEGRA_IOMMU_GART) += tegra-gart.o
 obj-$(CONFIG_TEGRA_IOMMU_SMMU) += tegra-smmu.o
 obj-$(CONFIG_EXYNOS_IOMMU) += exynos-iommu.o
<span class="p_add">+obj-$(CONFIG_MTK_IOMMU) += mtk_iommu.o</span>
 obj-$(CONFIG_SHMOBILE_IOMMU) += shmobile-iommu.o
 obj-$(CONFIG_SHMOBILE_IPMMU) += shmobile-ipmmu.o
 obj-$(CONFIG_FSL_PAMU) += fsl_pamu.o fsl_pamu_domain.o
<span class="p_header">diff --git a/drivers/iommu/mtk_iommu.c b/drivers/iommu/mtk_iommu.c</span>
new file mode 100644
<span class="p_header">index 0000000..c1c90e6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/iommu/mtk_iommu.c</span>
<span class="p_chunk">@@ -0,0 +1,724 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (c) 2014-2015 MediaTek Inc.</span>
<span class="p_add">+ * Author: Yong Wu &lt;yong.wu@mediatek.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-mapping.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_iommu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/list.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;linux/iopoll.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+#include &lt;soc/mediatek/smi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;io-pgtable.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_PT_BASE_ADDR			0x000</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVALIDATE			0x020</span>
<span class="p_add">+#define F_ALL_INVLD				0x2</span>
<span class="p_add">+#define F_MMU_INV_RANGE				0x1</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_START_A			0x024</span>
<span class="p_add">+#define REG_MMU_INVLD_END_A			0x028</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INV_SEL				0x038</span>
<span class="p_add">+#define F_INVLD_EN0				BIT(0)</span>
<span class="p_add">+#define F_INVLD_EN1				BIT(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_STANDARD_AXI_MODE		0x048</span>
<span class="p_add">+#define REG_MMU_DCM_DIS				0x050</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CTRL_REG			0x110</span>
<span class="p_add">+#define F_MMU_PREFETCH_RT_REPLACE_MOD		BIT(4)</span>
<span class="p_add">+#define F_MMU_TF_PROTECT_SEL(prot)		(((prot) &amp; 0x3) &lt;&lt; 5)</span>
<span class="p_add">+#define F_COHERENCE_EN				BIT(8)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_IVRP_PADDR			0x114</span>
<span class="p_add">+#define F_MMU_IVRP_PA_SET(pa)			((pa) &gt;&gt; 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_CONTROL0			0x120</span>
<span class="p_add">+#define F_L2_MULIT_HIT_EN			BIT(0)</span>
<span class="p_add">+#define F_TABLE_WALK_FAULT_INT_EN		BIT(1)</span>
<span class="p_add">+#define F_PREETCH_FIFO_OVERFLOW_INT_EN		BIT(2)</span>
<span class="p_add">+#define F_MISS_FIFO_OVERFLOW_INT_EN		BIT(3)</span>
<span class="p_add">+#define F_PREFETCH_FIFO_ERR_INT_EN		BIT(5)</span>
<span class="p_add">+#define F_MISS_FIFO_ERR_INT_EN			BIT(6)</span>
<span class="p_add">+#define F_INT_L2_CLR_BIT			BIT(12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INT_MAIN_CONTROL		0x124</span>
<span class="p_add">+#define F_INT_TRANSLATION_FAULT			BIT(0)</span>
<span class="p_add">+#define F_INT_MAIN_MULTI_HIT_FAULT		BIT(1)</span>
<span class="p_add">+#define F_INT_INVALID_PA_FAULT			BIT(2)</span>
<span class="p_add">+#define F_INT_ENTRY_REPLACEMENT_FAULT		BIT(3)</span>
<span class="p_add">+#define F_INT_TLB_MISS_FAULT			BIT(4)</span>
<span class="p_add">+#define F_INT_MISS_TRANSATION_FIFO_FAULT	BIT(5)</span>
<span class="p_add">+#define F_INT_PRETETCH_TRANSATION_FIFO_FAULT	BIT(6)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_CPE_DONE			0x12C</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_ST1			0x134</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_FAULT_VA			0x13c</span>
<span class="p_add">+#define F_MMU_FAULT_VA_MSK			0xfffff000</span>
<span class="p_add">+#define F_MMU_FAULT_VA_WRITE_BIT		BIT(1)</span>
<span class="p_add">+#define F_MMU_FAULT_VA_LAYER_BIT		BIT(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define REG_MMU_INVLD_PA			0x140</span>
<span class="p_add">+#define REG_MMU_INT_ID				0x150</span>
<span class="p_add">+#define F_MMU0_INT_ID_LARB_ID(a)		(((a) &gt;&gt; 7) &amp; 0x7)</span>
<span class="p_add">+#define F_MMU0_INT_ID_PORT_ID(a)		(((a) &gt;&gt; 2) &amp; 0x1f)</span>
<span class="p_add">+</span>
<span class="p_add">+#define MTK_PROTECT_PA_ALIGN			128</span>
<span class="p_add">+#define MTK_IOMMU_LARB_MAX_NR			8</span>
<span class="p_add">+#define MTK_IOMMU_REG_NR			10</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_data {</span>
<span class="p_add">+	void __iomem		*base;</span>
<span class="p_add">+	int			irq;</span>
<span class="p_add">+	struct device		*dev;</span>
<span class="p_add">+	struct device		*larbdev[MTK_IOMMU_LARB_MAX_NR];</span>
<span class="p_add">+	struct clk		*bclk;</span>
<span class="p_add">+	phys_addr_t		protect_base; /* protect memory base */</span>
<span class="p_add">+	int			larb_nr;      /* local arbiter number */</span>
<span class="p_add">+	u32			reg[MTK_IOMMU_REG_NR];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_domain {</span>
<span class="p_add">+	struct imu_pgd_t	*pgd;</span>
<span class="p_add">+	spinlock_t		pgtlock; /* lock for modifying page table */</span>
<span class="p_add">+</span>
<span class="p_add">+	struct io_pgtable_cfg   cfg;</span>
<span class="p_add">+	struct io_pgtable_ops   *iop;</span>
<span class="p_add">+</span>
<span class="p_add">+	struct mtk_iommu_data   *data;</span>
<span class="p_add">+	struct iommu_domain	domain;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct mtk_iommu_client_priv {</span>
<span class="p_add">+	struct list_head	client;</span>
<span class="p_add">+	unsigned int		larbid;</span>
<span class="p_add">+	unsigned int		portid;</span>
<span class="p_add">+	struct device		*imudev;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct mtk_iommu_domain *to_mtk_domain(struct iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return container_of(dom, struct mtk_iommu_domain, domain);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_clear_intr(const struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = readl(data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	val |= F_INT_L2_CLR_BIT;</span>
<span class="p_add">+	writel(val, data-&gt;base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_flush_all(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base;</span>
<span class="p_add">+</span>
<span class="p_add">+	base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="p_add">+	writel(F_ALL_INVLD, base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_add_flush(unsigned long iova, size_t size,</span>
<span class="p_add">+				    bool leaf, void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	unsigned int iova_start = iova, iova_end = iova + size - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(F_INVLD_EN1 | F_INVLD_EN0, base + REG_MMU_INV_SEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(iova_start, base + REG_MMU_INVLD_START_A);</span>
<span class="p_add">+	writel(iova_end, base + REG_MMU_INVLD_END_A);</span>
<span class="p_add">+	writel(F_MMU_INV_RANGE, base + REG_MMU_INVALIDATE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_tlb_sync(void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	void __iomem *base = domain-&gt;data-&gt;base;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = readl_poll_timeout_atomic(base + REG_MMU_CPE_DONE, tmp,</span>
<span class="p_add">+					tmp != 0, 10, 1000000);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_warn(domain-&gt;data-&gt;dev,</span>
<span class="p_add">+			 &quot;Partial TLB flush timed out, falling back to full flush\n&quot;);</span>
<span class="p_add">+		mtk_iommu_tlb_flush_all(cookie);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	writel(0, base + REG_MMU_CPE_DONE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_flush_pgtable(void *ptr, size_t size, void *cookie)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *domain = cookie;</span>
<span class="p_add">+	unsigned long offset = (unsigned long)ptr &amp; ~PAGE_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	dma_map_page(domain-&gt;data-&gt;dev, virt_to_page(ptr), offset,</span>
<span class="p_add">+		     size, DMA_TO_DEVICE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_gather_ops mtk_iommu_gather_ops = {</span>
<span class="p_add">+	.tlb_flush_all = mtk_iommu_tlb_flush_all,</span>
<span class="p_add">+	.tlb_add_flush = mtk_iommu_tlb_add_flush,</span>
<span class="p_add">+	.tlb_sync = mtk_iommu_tlb_sync,</span>
<span class="p_add">+	.flush_pgtable = mtk_iommu_flush_pgtable,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mtk_iommu_isr(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_id;</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	u32 int_state, regval, fault_iova, fault_pa;</span>
<span class="p_add">+	unsigned int fault_larb, fault_port;</span>
<span class="p_add">+	bool layer, write;</span>
<span class="p_add">+</span>
<span class="p_add">+	int_state = readl(data-&gt;base + REG_MMU_FAULT_ST1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* read error info from registers */</span>
<span class="p_add">+	fault_iova = readl(data-&gt;base + REG_MMU_FAULT_VA);</span>
<span class="p_add">+	layer = fault_iova &amp; F_MMU_FAULT_VA_LAYER_BIT;</span>
<span class="p_add">+	write = fault_iova &amp; F_MMU_FAULT_VA_WRITE_BIT;</span>
<span class="p_add">+	fault_iova &amp;= F_MMU_FAULT_VA_MSK;</span>
<span class="p_add">+	fault_pa = readl(data-&gt;base + REG_MMU_INVLD_PA);</span>
<span class="p_add">+	regval = readl(data-&gt;base + REG_MMU_INT_ID);</span>
<span class="p_add">+	fault_larb = F_MMU0_INT_ID_LARB_ID(regval);</span>
<span class="p_add">+	fault_port = F_MMU0_INT_ID_PORT_ID(regval);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (report_iommu_fault(&amp;mtkdom-&gt;domain, data-&gt;dev, fault_iova,</span>
<span class="p_add">+			       write ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ)) {</span>
<span class="p_add">+		dev_err_ratelimited(</span>
<span class="p_add">+			data-&gt;dev,</span>
<span class="p_add">+			&quot;fault type=0x%x iova=0x%x pa=0x%x larb=%d port=%d layer=%d %s\n&quot;,</span>
<span class="p_add">+			int_state, fault_iova, fault_pa, fault_larb, fault_port,</span>
<span class="p_add">+			layer, write ? &quot;write&quot; : &quot;read&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mtk_iommu_tlb_flush_all(mtkdom);</span>
<span class="p_add">+	mtk_iommu_clear_intr(data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_parse_dt(struct platform_device *pdev,</span>
<span class="p_add">+			      struct mtk_iommu_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	struct device_node *ofnode;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	ofnode = dev-&gt;of_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);</span>
<span class="p_add">+	data-&gt;base = devm_ioremap_resource(&amp;pdev-&gt;dev, res);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;base))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (data-&gt;irq &lt; 0)</span>
<span class="p_add">+		return data-&gt;irq;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;bclk = devm_clk_get(dev, &quot;bclk&quot;);</span>
<span class="p_add">+	if (IS_ERR(data-&gt;bclk))</span>
<span class="p_add">+		return PTR_ERR(data-&gt;bclk);</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;larb_nr = of_count_phandle_with_args(</span>
<span class="p_add">+					ofnode, &quot;mediatek,larb&quot;, NULL);</span>
<span class="p_add">+	if (data-&gt;larb_nr &lt; 0)</span>
<span class="p_add">+		return data-&gt;larb_nr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; data-&gt;larb_nr; i++) {</span>
<span class="p_add">+		struct device_node *larbnode;</span>
<span class="p_add">+		struct platform_device *plarbdev;</span>
<span class="p_add">+</span>
<span class="p_add">+		larbnode = of_parse_phandle(ofnode, &quot;mediatek,larb&quot;, i);</span>
<span class="p_add">+		if (!larbnode)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		plarbdev = of_find_device_by_node(larbnode);</span>
<span class="p_add">+		of_node_put(larbnode);</span>
<span class="p_add">+		if (!plarbdev)</span>
<span class="p_add">+			return -EPROBE_DEFER;</span>
<span class="p_add">+		data-&gt;larbdev[i] = &amp;plarbdev-&gt;dev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_hw_init(const struct mtk_iommu_domain *mtkdom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+	u32 regval;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;bclk);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed to enable iommu clk(%d)\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(mtkdom-&gt;cfg.arm_short_cfg.ttbr[0], base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_MMU_PREFETCH_RT_REPLACE_MOD |</span>
<span class="p_add">+		F_MMU_TF_PROTECT_SEL(2) |</span>
<span class="p_add">+		F_COHERENCE_EN;</span>
<span class="p_add">+	writel(regval, base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_L2_MULIT_HIT_EN |</span>
<span class="p_add">+		F_TABLE_WALK_FAULT_INT_EN |</span>
<span class="p_add">+		F_PREETCH_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_OVERFLOW_INT_EN |</span>
<span class="p_add">+		F_PREFETCH_FIFO_ERR_INT_EN |</span>
<span class="p_add">+		F_MISS_FIFO_ERR_INT_EN;</span>
<span class="p_add">+	writel(regval, base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = F_INT_TRANSLATION_FAULT |</span>
<span class="p_add">+		F_INT_MAIN_MULTI_HIT_FAULT |</span>
<span class="p_add">+		F_INT_INVALID_PA_FAULT |</span>
<span class="p_add">+		F_INT_ENTRY_REPLACEMENT_FAULT |</span>
<span class="p_add">+		F_INT_TLB_MISS_FAULT |</span>
<span class="p_add">+		F_INT_MISS_TRANSATION_FIFO_FAULT |</span>
<span class="p_add">+		F_INT_PRETETCH_TRANSATION_FIFO_FAULT;</span>
<span class="p_add">+	writel(regval, base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+</span>
<span class="p_add">+	regval = ALIGN(data-&gt;protect_base, MTK_PROTECT_PA_ALIGN);</span>
<span class="p_add">+	regval = F_MMU_IVRP_PA_SET(regval);</span>
<span class="p_add">+	writel(regval, base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(0, base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel(0, base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (devm_request_irq(data-&gt;dev, data-&gt;irq, mtk_iommu_isr, 0,</span>
<span class="p_add">+			     dev_name(data-&gt;dev), (void *)mtkdom)) {</span>
<span class="p_add">+		writel(0, base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+		clk_disable_unprepare(data-&gt;bclk);</span>
<span class="p_add">+		dev_err(data-&gt;dev, &quot;Failed @ IRQ-%d Request\n&quot;, data-&gt;irq);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_config(struct mtk_iommu_domain *mtkdom,</span>
<span class="p_add">+			    struct device *dev, bool enable)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *cur, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	list_for_each_entry_safe(cur, next, &amp;head-&gt;client, client) {</span>
<span class="p_add">+		if (cur-&gt;larbid &gt;= data-&gt;larb_nr) {</span>
<span class="p_add">+			dev_err(data-&gt;dev, &quot;Invalid larb:%d\n&quot;, cur-&gt;larbid);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (enable) {</span>
<span class="p_add">+			mtk_smi_config_port(data-&gt;larbdev[cur-&gt;larbid],</span>
<span class="p_add">+					    cur-&gt;portid, true);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			mtk_smi_config_port(data-&gt;larbdev[cur-&gt;larbid],</span>
<span class="p_add">+					    cur-&gt;portid, false);</span>
<span class="p_add">+			list_del(&amp;cur-&gt;client);</span>
<span class="p_add">+			kfree(cur);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!enable)</span>
<span class="p_add">+		kfree(head);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_init_domain_context(struct mtk_iommu_domain *dom)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dom-&gt;iop)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_init(&amp;dom-&gt;pgtlock);</span>
<span class="p_add">+	dom-&gt;cfg.quirks = IO_PGTABLE_QUIRK_ARM_NS |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_SHORT_SUPERSECTION |</span>
<span class="p_add">+			IO_PGTABLE_QUIRK_SHORT_MTK;</span>
<span class="p_add">+	dom-&gt;cfg.pgsize_bitmap = mtk_iommu_ops.pgsize_bitmap,</span>
<span class="p_add">+	dom-&gt;cfg.ias = 32;</span>
<span class="p_add">+	dom-&gt;cfg.oas = 32;</span>
<span class="p_add">+	dom-&gt;cfg.tlb = &amp;mtk_iommu_gather_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+	dom-&gt;iop = alloc_io_pgtable_ops(ARM_SHORT_DESC, &amp;dom-&gt;cfg, dom);</span>
<span class="p_add">+	if (!dom-&gt;iop) {</span>
<span class="p_add">+		pr_err(&quot;Failed to alloc io pgtable\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Update our support page sizes bitmap */</span>
<span class="p_add">+	mtk_iommu_ops.pgsize_bitmap = dom-&gt;cfg.pgsize_bitmap;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_hw_init(dom);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		free_io_pgtable_ops(dom-&gt;iop);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_domain *mtk_iommu_domain_alloc(unsigned type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We only support unmanaged domains for now */</span>
<span class="p_add">+	if (type != IOMMU_DOMAIN_UNMANAGED)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_start = 0;</span>
<span class="p_add">+	priv-&gt;domain.geometry.aperture_end = (1ULL &lt;&lt; 32) - 1;</span>
<span class="p_add">+	priv-&gt;domain.geometry.force_aperture = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;priv-&gt;domain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_domain_free(struct iommu_domain *domain)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kfree(to_mtk_domain(domain));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_attach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				   struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *devpriv;</span>
<span class="p_add">+	struct device *imudev;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	devpriv = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	imudev = devpriv-&gt;imudev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Reserve one iommu domain as the m4u domain which</span>
<span class="p_add">+	 * all Multimedia modules share and free the others.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!imudev-&gt;archdata.iommu)</span>
<span class="p_add">+		imudev-&gt;archdata.iommu = priv;</span>
<span class="p_add">+	else if (imudev-&gt;archdata.iommu != priv)</span>
<span class="p_add">+		iommu_domain_free(domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get(dev);</span>
<span class="p_add">+	if (!group)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_init_domain_context(priv);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mtk_iommu_config(priv, dev, true);;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mtk_iommu_detach_device(struct iommu_domain *domain,</span>
<span class="p_add">+				    struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mtk_iommu_config(to_mtk_domain(domain), dev, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="p_add">+			 phys_addr_t paddr, size_t size, int prot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	ret = priv-&gt;iop-&gt;map(priv-&gt;iop, iova, paddr, size, prot);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t mtk_iommu_unmap(struct iommu_domain *domain,</span>
<span class="p_add">+			      unsigned long iova, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	size_t unmapsize;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	unmapsize = priv-&gt;iop-&gt;unmap(priv-&gt;iop, iova, size);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return unmapsize;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static phys_addr_t mtk_iommu_iova_to_phys(struct iommu_domain *domain,</span>
<span class="p_add">+					  dma_addr_t iova)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *priv = to_mtk_domain(domain);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	phys_addr_t pa;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+	pa = priv-&gt;iop-&gt;iova_to_phys(priv-&gt;iop, iova);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;priv-&gt;pgtlock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return pa;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_add_device(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom;</span>
<span class="p_add">+	struct iommu_group *group;</span>
<span class="p_add">+	struct mtk_iommu_client_priv *devhead;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.dma_ops)/* Not a iommu client device */</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	group = iommu_group_get(dev);</span>
<span class="p_add">+	if (!group) {</span>
<span class="p_add">+		group = iommu_group_alloc();</span>
<span class="p_add">+		if (IS_ERR(group)) {</span>
<span class="p_add">+			dev_err(dev, &quot;Failed to allocate IOMMU group\n&quot;);</span>
<span class="p_add">+			return PTR_ERR(group);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = iommu_group_add_device(group, dev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to add IOMMU group\n&quot;);</span>
<span class="p_add">+		goto err_group_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get the mtk_iommu_domain from the iommu device */</span>
<span class="p_add">+	devhead = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	mtkdom = devhead-&gt;imudev-&gt;archdata.iommu;</span>
<span class="p_add">+	ret = iommu_attach_group(&amp;mtkdom-&gt;domain, group);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to attach IOMMU group\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+err_group_put:</span>
<span class="p_add">+	iommu_group_put(group);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mtk_iommu_of_xlate(struct device *dev, struct of_phandle_args *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_client_priv *head, *priv, *next;</span>
<span class="p_add">+	struct platform_device *imupdev;</span>
<span class="p_add">+	struct device *imudev;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (args-&gt;args_count != 2) {</span>
<span class="p_add">+		dev_err(dev, &quot;invalid #iommu-cells(%d) property for IOMMU\n&quot;,</span>
<span class="p_add">+			args-&gt;args_count);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev-&gt;archdata.iommu) {</span>
<span class="p_add">+		/* Get the iommu device */</span>
<span class="p_add">+		imupdev = of_find_device_by_node(args-&gt;np);</span>
<span class="p_add">+		of_node_put(args-&gt;np);</span>
<span class="p_add">+		if (WARN_ON(!imupdev))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		imudev = &amp;imupdev-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+		head = kzalloc(sizeof(*head), GFP_KERNEL);</span>
<span class="p_add">+		if (!head)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev-&gt;archdata.iommu = head;</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;head-&gt;client);</span>
<span class="p_add">+		head-&gt;imudev = imudev;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		head = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv)</span>
<span class="p_add">+		goto err_free_mem;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;larbid = args-&gt;args[0];</span>
<span class="p_add">+	priv-&gt;portid = args-&gt;args[1];</span>
<span class="p_add">+	list_add_tail(&amp;priv-&gt;client, &amp;head-&gt;client);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err_free_mem:</span>
<span class="p_add">+	list_for_each_entry_safe(priv, next, &amp;head-&gt;client, client)</span>
<span class="p_add">+		kfree(priv);</span>
<span class="p_add">+	kfree(head);</span>
<span class="p_add">+	dev-&gt;archdata.iommu = NULL;</span>
<span class="p_add">+	return -ENOMEM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct iommu_ops mtk_iommu_ops = {</span>
<span class="p_add">+	.domain_alloc	= mtk_iommu_domain_alloc,</span>
<span class="p_add">+	.domain_free	= mtk_iommu_domain_free,</span>
<span class="p_add">+	.attach_dev	= mtk_iommu_attach_device,</span>
<span class="p_add">+	.detach_dev	= mtk_iommu_detach_device,</span>
<span class="p_add">+	.map		= mtk_iommu_map,</span>
<span class="p_add">+	.unmap		= mtk_iommu_unmap,</span>
<span class="p_add">+	.map_sg		= default_iommu_map_sg,</span>
<span class="p_add">+	.iova_to_phys	= mtk_iommu_iova_to_phys,</span>
<span class="p_add">+	.add_device	= mtk_iommu_add_device,</span>
<span class="p_add">+	.of_xlate	= mtk_iommu_of_xlate,</span>
<span class="p_add">+	.pgsize_bitmap	= -1UL,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct of_device_id mtk_iommu_of_ids[] = {</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8173-m4u&quot;, },</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_init_fn(struct device_node *np)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct platform_device *pdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	pdev = of_platform_device_create(np, NULL, platform_bus_type.dev_root);</span>
<span class="p_add">+	if (IS_ERR(pdev))</span>
<span class="p_add">+		return PTR_ERR(pdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	of_iommu_set_ops(np, &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+IOMMU_OF_DECLARE(mtkm4u, &quot;mediatek,mt8173-m4u&quot;, mtk_iommu_init_fn);</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain	*mtkdom;</span>
<span class="p_add">+	struct mtk_iommu_data   *data;</span>
<span class="p_add">+	struct device           *dev = &amp;pdev-&gt;dev;</span>
<span class="p_add">+	void __iomem	        *protect;</span>
<span class="p_add">+	int                     ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Protect memory. HW will access here while translation fault.*/</span>
<span class="p_add">+	protect = devm_kzalloc(dev, MTK_PROTECT_PA_ALIGN * 2, GFP_KERNEL);</span>
<span class="p_add">+	if (!protect)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	data-&gt;protect_base = virt_to_phys(protect);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mtk_iommu_parse_dt(pdev, data);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mtkdom = dev-&gt;archdata.iommu;</span>
<span class="p_add">+	if (!mtkdom)/* There is no iommu client device */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mtkdom-&gt;data = data;</span>
<span class="p_add">+	data-&gt;dev = dev;</span>
<span class="p_add">+	dev_set_drvdata(dev, mtkdom);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(&amp;pdev-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Destroy domain context */</span>
<span class="p_add">+	free_io_pgtable_ops(mtkdom-&gt;iop);</span>
<span class="p_add">+</span>
<span class="p_add">+	clk_disable_unprepare(mtkdom-&gt;data-&gt;bclk);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_suspend(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+	unsigned int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;reg[i++] = readl(base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	data-&gt;reg[i++] = readl(base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	data-&gt;reg[i++] = readl(base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	data-&gt;reg[i++] = readl(base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	data-&gt;reg[i++] = readl(base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	data-&gt;reg[i++] = readl(base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	data-&gt;reg[i++] = readl(base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mtk_iommu_resume(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mtk_iommu_domain *mtkdom = dev_get_drvdata(dev);</span>
<span class="p_add">+	struct mtk_iommu_data *data = mtkdom-&gt;data;</span>
<span class="p_add">+	void __iomem *base = data-&gt;base;</span>
<span class="p_add">+	unsigned int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	writel(data-&gt;reg[i++], base + REG_MMU_PT_BASE_ADDR);</span>
<span class="p_add">+	writel(data-&gt;reg[i++], base + REG_MMU_STANDARD_AXI_MODE);</span>
<span class="p_add">+	writel(data-&gt;reg[i++], base + REG_MMU_DCM_DIS);</span>
<span class="p_add">+	writel(data-&gt;reg[i++], base + REG_MMU_CTRL_REG);</span>
<span class="p_add">+	writel(data-&gt;reg[i++], base + REG_MMU_IVRP_PADDR);</span>
<span class="p_add">+	writel(data-&gt;reg[i++], base + REG_MMU_INT_CONTROL0);</span>
<span class="p_add">+	writel(data-&gt;reg[i++], base + REG_MMU_INT_MAIN_CONTROL);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct dev_pm_ops mtk_iommu_pm_ops = {</span>
<span class="p_add">+	SET_SYSTEM_SLEEP_PM_OPS(mtk_iommu_suspend, mtk_iommu_resume)</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mtk_iommu_driver = {</span>
<span class="p_add">+	.probe	= mtk_iommu_probe,</span>
<span class="p_add">+	.remove	= mtk_iommu_remove,</span>
<span class="p_add">+	.driver	= {</span>
<span class="p_add">+		.name = &quot;mtk-iommu&quot;,</span>
<span class="p_add">+		.of_match_table = mtk_iommu_of_ids,</span>
<span class="p_add">+		.pm = &amp;mtk_iommu_pm_ops,</span>
<span class="p_add">+	}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mtk_iommu_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = platform_driver_register(&amp;mtk_iommu_driver);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: Failed to register driver\n&quot;, __func__);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!iommu_present(&amp;platform_bus_type))</span>
<span class="p_add">+		bus_set_iommu(&amp;platform_bus_type, &amp;mtk_iommu_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(mtk_iommu_init);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



