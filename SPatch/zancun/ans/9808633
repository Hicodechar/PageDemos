
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.74 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.74</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 26, 2017, 5:28 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170626052858.GB16301@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9808633/mbox/"
   >mbox</a>
|
   <a href="/patch/9808633/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9808633/">/patch/9808633/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	BB53260209 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 26 Jun 2017 05:30:05 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B54A327FAD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 26 Jun 2017 05:30:05 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A7AC328414; Mon, 26 Jun 2017 05:30:05 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0211127FAD
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 26 Jun 2017 05:30:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751475AbdFZF37 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 26 Jun 2017 01:29:59 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:60922 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751453AbdFZF3r (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 26 Jun 2017 01:29:47 -0400
Received: from localhost (mobile-166-170-37-177.mycingular.net
	[166.170.37.177])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id DA765486;
	Mon, 26 Jun 2017 05:29:40 +0000 (UTC)
Date: Mon, 26 Jun 2017 07:28:58 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.74
Message-ID: &lt;20170626052858.GB16301@kroah.com&gt;
References: &lt;20170626052850.GA16301@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170626052850.GA16301@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 26, 2017, 5:28 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index ca64ca566099..7c77d7edb851 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3580,6 +3580,13 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 	spia_pedr=
 	spia_peddr=
 
<span class="p_add">+	stack_guard_gap=	[MM]</span>
<span class="p_add">+			override the default stack gap protection. The value</span>
<span class="p_add">+			is in page units and it defines how many pages prior</span>
<span class="p_add">+			to (for stacks growing down) resp. after (for stacks</span>
<span class="p_add">+			growing up) the main stack are reserved for no other</span>
<span class="p_add">+			mapping. Default value is 256 pages.</span>
<span class="p_add">+</span>
 	stacktrace	[FTRACE]
 			Enabled the stack tracer on boot up.
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index ba5a70b6e32c..1f75507acbf4 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 73</span>
<span class="p_add">+SUBLEVEL = 74</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arc/mm/mmap.c b/arch/arc/mm/mmap.c</span>
<span class="p_header">index 2e06d56e987b..cf4ae6958240 100644</span>
<span class="p_header">--- a/arch/arc/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arc/mm/mmap.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/arm/mm/mmap.c b/arch/arm/mm/mmap.c</span>
<span class="p_header">index 407dc786583a..c469c0665752 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/frv/mm/elf-fdpic.c b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">index 836f14707a62..efa59f1f8022 100644</span>
<span class="p_header">--- a/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">+++ b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current-&gt;mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			goto success;
 	}
 
<span class="p_header">diff --git a/arch/mips/kernel/branch.c b/arch/mips/kernel/branch.c</span>
<span class="p_header">index d8f9b357b222..e9fed8ca9b42 100644</span>
<span class="p_header">--- a/arch/mips/kernel/branch.c</span>
<span class="p_header">+++ b/arch/mips/kernel/branch.c</span>
<span class="p_chunk">@@ -816,8 +816,10 @@</span> <span class="p_context"> int __compute_return_epc_for_insn(struct pt_regs *regs,</span>
 			break;
 		}
 		/* Compact branch: BNEZC || JIALC */
<span class="p_del">-		if (insn.i_format.rs)</span>
<span class="p_add">+		if (!insn.i_format.rs) {</span>
<span class="p_add">+			/* JIALC: set $31/ra */</span>
 			regs-&gt;regs[31] = epc + 4;
<span class="p_add">+		}</span>
 		regs-&gt;cp0_epc += 8;
 		break;
 #endif
<span class="p_header">diff --git a/arch/mips/mm/mmap.c b/arch/mips/mm/mmap.c</span>
<span class="p_header">index 5c81fdd032c3..025cb31aa0a2 100644</span>
<span class="p_header">--- a/arch/mips/mm/mmap.c</span>
<span class="p_header">+++ b/arch/mips/mm/mmap.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static unsigned long arch_get_unmapped_area_common(struct file *filp,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">index 5aba01ac457f..4dda73c44fee 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	unsigned long task_size = TASK_SIZE;
 	int do_color_align, last_mmap;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -115,9 +115,10 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		else
 			addr = PAGE_ALIGN(addr);
 
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_chunk">@@ -141,7 +142,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	int do_color_align, last_mmap;
<span class="p_chunk">@@ -175,9 +176,11 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = COLOR_ALIGN(addr, last_mmap, pgoff);
 		else
 			addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/slice.c b/arch/powerpc/mm/slice.c</span>
<span class="p_header">index 0f432a702870..6ad12b244770 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/slice.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/slice.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int slice_area_is_free(struct mm_struct *mm, unsigned long addr,</span>
 	if ((mm-&gt;task_size - len) &lt; addr)
 		return 0;
 	vma = find_vma(mm, addr);
<span class="p_del">-	return (!vma || (addr + len) &lt;= vma-&gt;vm_start);</span>
<span class="p_add">+	return (!vma || (addr + len) &lt;= vm_start_gap(vma));</span>
 }
 
 static int slice_low_has_vma(struct mm_struct *mm, unsigned long slice)
<span class="p_header">diff --git a/arch/s390/mm/mmap.c b/arch/s390/mm/mmap.c</span>
<span class="p_header">index f2b6b1d9c804..126c4a9b9bf9 100644</span>
<span class="p_header">--- a/arch/s390/mm/mmap.c</span>
<span class="p_header">+++ b/arch/s390/mm/mmap.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -135,7 +135,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sh/mm/mmap.c b/arch/sh/mm/mmap.c</span>
<span class="p_header">index 6777177807c2..7df7d5944188 100644</span>
<span class="p_header">--- a/arch/sh/mm/mmap.c</span>
<span class="p_header">+++ b/arch/sh/mm/mmap.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index c690c8e16a96..7f0f7c01b297 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -118,7 +118,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/mm/hugetlbpage.c b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">index da1142401bf4..ffa842b4d7d4 100644</span>
<span class="p_header">--- a/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, HPAGE_SIZE);
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/tile/mm/hugetlbpage.c b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">index c034dc3fe2d4..c97ee6c7f949 100644</span>
<span class="p_header">--- a/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> unsigned long hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (current-&gt;mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/kernel/sys_x86_64.c b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">index 10e0272d789a..136ad7c1ce7b 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (end - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -186,7 +186,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/x86/mm/hugetlbpage.c b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">index 42982b26e32b..39bdaf3ac44a 100644</span>
<span class="p_header">--- a/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/mm/numa_32.c b/arch/x86/mm/numa_32.c</span>
<span class="p_header">index 47b6436e41c2..3686a1db25b2 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa_32.c</span>
<span class="p_chunk">@@ -100,5 +100,6 @@</span> <span class="p_context"> void __init initmem_init(void)</span>
 	printk(KERN_DEBUG &quot;High memory starts at vaddr %08lx\n&quot;,
 			(ulong) pfn_to_kaddr(highstart_pfn));
 
<span class="p_add">+	__vmalloc_start_set = true;</span>
 	setup_bootmem_allocator();
 }
<span class="p_header">diff --git a/arch/xtensa/kernel/syscall.c b/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">index 83cf49685373..3aaaae18417c 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/syscall.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		/* At this point:  (!vmm || addr &lt; vmm-&gt;vm_end). */
 		if (TASK_SIZE - len &lt; addr)
 			return -ENOMEM;
<span class="p_del">-		if (!vmm || addr + len &lt;= vmm-&gt;vm_start)</span>
<span class="p_add">+		if (!vmm || addr + len &lt;= vm_start_gap(vmm))</span>
 			return addr;
 		addr = vmm-&gt;vm_end;
 		if (flags &amp; MAP_SHARED)
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">index 1fa1deb6e91f..c395f9198fd2 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_chunk">@@ -212,8 +212,8 @@</span> <span class="p_context"> static ssize_t store_down_threshold(struct dbs_data *dbs_data, const char *buf,</span>
 	int ret;
 	ret = sscanf(buf, &quot;%u&quot;, &amp;input);
 
<span class="p_del">-	/* cannot be lower than 11 otherwise freq will not fall */</span>
<span class="p_del">-	if (ret != 1 || input &lt; 11 || input &gt; 100 ||</span>
<span class="p_add">+	/* cannot be lower than 1 otherwise freq will not fall */</span>
<span class="p_add">+	if (ret != 1 || input &lt; 1 || input &gt; 100 ||</span>
 			input &gt;= cs_tuners-&gt;up_threshold)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/iio/proximity/as3935.c b/drivers/iio/proximity/as3935.c</span>
<span class="p_header">index 9e6d1cdb7fcd..420478924a0c 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/as3935.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/as3935.c</span>
<span class="p_chunk">@@ -263,8 +263,6 @@</span> <span class="p_context"> static irqreturn_t as3935_interrupt_handler(int irq, void *private)</span>
 
 static void calibrate_as3935(struct as3935_state *st)
 {
<span class="p_del">-	mutex_lock(&amp;st-&gt;lock);</span>
<span class="p_del">-</span>
 	/* mask disturber interrupt bit */
 	as3935_write(st, AS3935_INT, BIT(5));
 
<span class="p_chunk">@@ -274,8 +272,6 @@</span> <span class="p_context"> static void calibrate_as3935(struct as3935_state *st)</span>
 
 	mdelay(2);
 	as3935_write(st, AS3935_TUNE_CAP, (st-&gt;tune_cap / TUNE_CAP_DIV));
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;st-&gt;lock);</span>
 }
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_chunk">@@ -312,6 +308,8 @@</span> <span class="p_context"> static int as3935_resume(struct device *dev)</span>
 	val &amp;= ~AS3935_AFE_PWR_BIT;
 	ret = as3935_write(st, AS3935_AFE_GAIN, val);
 
<span class="p_add">+	calibrate_as3935(st);</span>
<span class="p_add">+</span>
 err_resume:
 	mutex_unlock(&amp;st-&gt;lock);
 
<span class="p_header">diff --git a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">index e1907cd0c3b7..7613d1fee104 100644</span>
<span class="p_header">--- a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">+++ b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_chunk">@@ -123,15 +123,10 @@</span> <span class="p_context"> int pvr2_eeprom_analyze(struct pvr2_hdw *hdw)</span>
 	memset(&amp;tvdata,0,sizeof(tvdata));
 
 	eeprom = pvr2_eeprom_fetch(hdw);
<span class="p_del">-	if (!eeprom) return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	{</span>
<span class="p_del">-		struct i2c_client fake_client;</span>
<span class="p_del">-		/* Newer version expects a useless client interface */</span>
<span class="p_del">-		fake_client.addr = hdw-&gt;eeprom_addr;</span>
<span class="p_del">-		fake_client.adapter = &amp;hdw-&gt;i2c_adap;</span>
<span class="p_del">-		tveeprom_hauppauge_analog(&amp;fake_client,&amp;tvdata,eeprom);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!eeprom)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	tveeprom_hauppauge_analog(NULL, &amp;tvdata, eeprom);</span>
 
 	trace_eeprom(&quot;eeprom assumed v4l tveeprom module&quot;);
 	trace_eeprom(&quot;eeprom direct call results:&quot;);
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 47f37683893a..3dc9ed2e0774 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -793,7 +793,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(vb2_core_create_bufs);</span>
  */
 void *vb2_plane_vaddr(struct vb2_buffer *vb, unsigned int plane_no)
 {
<span class="p_del">-	if (plane_no &gt; vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
<span class="p_add">+	if (plane_no &gt;= vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
 		return NULL;
 
 	return call_ptr_memop(vb, vaddr, vb-&gt;planes[plane_no].mem_priv);
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index c30290f33430..fe51e9709210 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -375,8 +375,8 @@</span> <span class="p_context"> int omap_tll_init(struct usbhs_omap_platform_data *pdata)</span>
 				 * and use SDR Mode
 				 */
 				reg &amp;= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
<span class="p_del">-					| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF</span>
 					| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
<span class="p_add">+				reg |= OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;</span>
 			} else if (pdata-&gt;port_mode[i] ==
 					OMAP_EHCI_PORT_MODE_HSIC) {
 				/*
<span class="p_header">diff --git a/drivers/misc/c2port/c2port-duramar2150.c b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">index 5484301d57d9..3dc61ea7dc64 100644</span>
<span class="p_header">--- a/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">+++ b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_chunk">@@ -129,8 +129,8 @@</span> <span class="p_context"> static int __init duramar2150_c2port_init(void)</span>
 
 	duramar2150_c2port_dev = c2port_device_register(&quot;uc&quot;,
 					&amp;duramar2150_c2port_ops, NULL);
<span class="p_del">-	if (!duramar2150_c2port_dev) {</span>
<span class="p_del">-		ret = -ENODEV;</span>
<span class="p_add">+	if (IS_ERR(duramar2150_c2port_dev)) {</span>
<span class="p_add">+		ret = PTR_ERR(duramar2150_c2port_dev);</span>
 		goto free_region;
 	}
 
<span class="p_header">diff --git a/drivers/net/can/usb/gs_usb.c b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">index cbc99d5649af..ae5709354546 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_chunk">@@ -246,6 +246,8 @@</span> <span class="p_context"> static int gs_cmd_reset(struct gs_usb *gsusb, struct gs_can *gsdev)</span>
 			     sizeof(*dm),
 			     1000);
 
<span class="p_add">+	kfree(dm);</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_ap.c b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">index 3cdb40fea5ee..f5cedbbc552a 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_chunk">@@ -894,7 +894,7 @@</span> <span class="p_context"> int rtw_check_beacon_data(struct adapter *padapter, u8 *pbuf,  int len)</span>
 		return _FAIL;
 
 
<span class="p_del">-	if (len &gt; MAX_IE_SZ)</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; MAX_IE_SZ)</span>
 		return _FAIL;
 
 	pbss_network-&gt;IELength = len;
<span class="p_header">diff --git a/drivers/tty/serial/efm32-uart.c b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">index 195acc868763..5d476916191b 100644</span>
<span class="p_header">--- a/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">+++ b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #define UARTn_FRAME		0x04
 #define UARTn_FRAME_DATABITS__MASK	0x000f
 #define UARTn_FRAME_DATABITS(n)		((n) - 3)
<span class="p_add">+#define UARTn_FRAME_PARITY__MASK	0x0300</span>
 #define UARTn_FRAME_PARITY_NONE		0x0000
 #define UARTn_FRAME_PARITY_EVEN		0x0200
 #define UARTn_FRAME_PARITY_ODD		0x0300
<span class="p_chunk">@@ -572,12 +573,16 @@</span> <span class="p_context"> static void efm32_uart_console_get_options(struct efm32_uart_port *efm_port,</span>
 			16 * (4 + (clkdiv &gt;&gt; 6)));
 
 	frame = efm32_uart_read32(efm_port, UARTn_FRAME);
<span class="p_del">-	if (frame &amp; UARTn_FRAME_PARITY_ODD)</span>
<span class="p_add">+	switch (frame &amp; UARTn_FRAME_PARITY__MASK) {</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_ODD:</span>
 		*parity = &#39;o&#39;;
<span class="p_del">-	else if (frame &amp; UARTn_FRAME_PARITY_EVEN)</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_EVEN:</span>
 		*parity = &#39;e&#39;;
<span class="p_del">-	else</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
 		*parity = &#39;n&#39;;
<span class="p_add">+	}</span>
 
 	*bits = (frame &amp; UARTn_FRAME_DATABITS__MASK) -
 			UARTn_FRAME_DATABITS(4) + 4;
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index c3f4f2ab7b33..b403596818db 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -2511,6 +2511,7 @@</span> <span class="p_context"> struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,</span>
 		hcd-&gt;bandwidth_mutex = kmalloc(sizeof(*hcd-&gt;bandwidth_mutex),
 				GFP_KERNEL);
 		if (!hcd-&gt;bandwidth_mutex) {
<span class="p_add">+			kfree(hcd-&gt;address0_mutex);</span>
 			kfree(hcd);
 			dev_dbg(dev, &quot;hcd bandwidth mutex alloc failed\n&quot;);
 			return NULL;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index b627392ad52a..1d59d489a1ad 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -1318,7 +1318,13 @@</span> <span class="p_context"> static int hub_configure(struct usb_hub *hub,</span>
 	if (ret &lt; 0) {
 		message = &quot;can&#39;t read hub descriptor&quot;;
 		goto fail;
<span class="p_del">-	} else if (hub-&gt;descriptor-&gt;bNbrPorts &gt; USB_MAXCHILDREN) {</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	maxchild = USB_MAXCHILDREN;</span>
<span class="p_add">+	if (hub_is_superspeed(hdev))</span>
<span class="p_add">+		maxchild = min_t(unsigned, maxchild, USB_SS_MAXPORTS);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hub-&gt;descriptor-&gt;bNbrPorts &gt; maxchild) {</span>
 		message = &quot;hub has too many ports!&quot;;
 		ret = -ENODEV;
 		goto fail;
<span class="p_header">diff --git a/drivers/usb/dwc3/dwc3-exynos.c b/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_header">index 2f1fb7e7aa54..9eba51b92f72 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_chunk">@@ -148,7 +148,8 @@</span> <span class="p_context"> static int dwc3_exynos_probe(struct platform_device *pdev)</span>
 		exynos-&gt;axius_clk = devm_clk_get(dev, &quot;usbdrd30_axius_clk&quot;);
 		if (IS_ERR(exynos-&gt;axius_clk)) {
 			dev_err(dev, &quot;no AXI UpScaler clk specified\n&quot;);
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto axius_clk_err;</span>
 		}
 		clk_prepare_enable(exynos-&gt;axius_clk);
 	} else {
<span class="p_chunk">@@ -206,6 +207,7 @@</span> <span class="p_context"> err3:</span>
 	regulator_disable(exynos-&gt;vdd33);
 err2:
 	clk_disable_unprepare(exynos-&gt;axius_clk);
<span class="p_add">+axius_clk_err:</span>
 	clk_disable_unprepare(exynos-&gt;susp_clk);
 	clk_disable_unprepare(exynos-&gt;clk);
 	return ret;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index de014436fb22..43ce2cfcdb4d 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -1676,9 +1676,10 @@</span> <span class="p_context"> static void</span>
 gadgetfs_suspend (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
<span class="p_add">+	unsigned long		flags;</span>
 
 	INFO (dev, &quot;suspended from state %d\n&quot;, dev-&gt;state);
<span class="p_del">-	spin_lock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span>
 	switch (dev-&gt;state) {
 	case STATE_DEV_SETUP:		// VERY odd... host died??
 	case STATE_DEV_CONNECTED:
<span class="p_chunk">@@ -1689,7 +1690,7 @@</span> <span class="p_context"> gadgetfs_suspend (struct usb_gadget *gadget)</span>
 	default:
 		break;
 	}
<span class="p_del">-	spin_unlock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span>
 }
 
 static struct usb_gadget_driver gadgetfs_driver = {
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index 6610f7a023d3..64f404a1a072 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -442,23 +442,16 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 		/* Report reset and disconnect events to the driver */
 		if (dum-&gt;driver &amp;&amp; (disconnect || reset)) {
 			stop_activity(dum);
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
 			if (reset)
 				usb_gadget_udc_reset(&amp;dum-&gt;gadget, dum-&gt;driver);
 			else
 				dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
 		}
 	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {
<span class="p_del">-		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)</span>
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		} else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)</span>
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		}</span>
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
<span class="p_chunk">@@ -985,7 +978,9 @@</span> <span class="p_context"> static int dummy_udc_stop(struct usb_gadget *g)</span>
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
 	dum-&gt;driver = NULL;
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -2011,7 +2006,7 @@</span> <span class="p_context"> ss_hub_descriptor(struct usb_hub_descriptor *desc)</span>
 			HUB_CHAR_COMMON_OCPM);
 	desc-&gt;bNbrPorts = 1;
 	desc-&gt;u.ss.bHubHdrDecLat = 0x04; /* Worst case: 0.4 micro sec*/
<span class="p_del">-	desc-&gt;u.ss.DeviceRemovable = 0xffff;</span>
<span class="p_add">+	desc-&gt;u.ss.DeviceRemovable = 0;</span>
 }
 
 static inline void hub_descriptor(struct usb_hub_descriptor *desc)
<span class="p_chunk">@@ -2023,8 +2018,8 @@</span> <span class="p_context"> static inline void hub_descriptor(struct usb_hub_descriptor *desc)</span>
 			HUB_CHAR_INDV_PORT_LPSM |
 			HUB_CHAR_COMMON_OCPM);
 	desc-&gt;bNbrPorts = 1;
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[0] = 0xff;</span>
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[0] = 0;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;	/* PortPwrCtrlMask */</span>
 }
 
 static int dummy_hub_control(
<span class="p_header">diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">index 6706aef907f4..a47de8c31ce9 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_chunk">@@ -2425,11 +2425,8 @@</span> <span class="p_context"> static void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)</span>
 		nuke(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
<span class="p_del">-	if (driver) {</span>
<span class="p_del">-		spin_unlock(&amp;dev-&gt;lock);</span>
<span class="p_add">+	if (driver)</span>
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
<span class="p_del">-		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_del">-	}</span>
 
 	usb_reinit(dev);
 }
<span class="p_chunk">@@ -3275,8 +3272,6 @@</span> <span class="p_context"> next_endpoints:</span>
 		BIT(PCI_RETRY_ABORT_INTERRUPT))
 
 static void handle_stat1_irqs(struct net2280 *dev, u32 stat)
<span class="p_del">-__releases(dev-&gt;lock)</span>
<span class="p_del">-__acquires(dev-&gt;lock)</span>
 {
 	struct net2280_ep	*ep;
 	u32			tmp, num, mask, scratch;
<span class="p_chunk">@@ -3317,14 +3312,12 @@</span> <span class="p_context"> __acquires(dev-&gt;lock)</span>
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				ep0_start(dev);
<span class="p_del">-				spin_unlock(&amp;dev-&gt;lock);</span>
 				if (reset)
 					usb_gadget_udc_reset
 						(&amp;dev-&gt;gadget, dev-&gt;driver);
 				else
 					(dev-&gt;driver-&gt;disconnect)
 						(&amp;dev-&gt;gadget);
<span class="p_del">-				spin_lock(&amp;dev-&gt;lock);</span>
 				return;
 			}
 		}
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index 4cbd0633c5c2..a11c2c8bda53 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -1269,7 +1269,7 @@</span> <span class="p_context"> static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)</span>
 			time = 30;
 			break;
 		default:
<span class="p_del">-			time = 300;</span>
<span class="p_add">+			time = 50;</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1785,6 +1785,7 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 		pipe = td-&gt;pipe;
 		pipe_stop(r8a66597, pipe);
 
<span class="p_add">+		/* Select a different address or endpoint */</span>
 		new_td = td;
 		do {
 			list_move_tail(&amp;new_td-&gt;queue,
<span class="p_chunk">@@ -1794,7 +1795,8 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 				new_td = td;
 				break;
 			}
<span class="p_del">-		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address);</span>
<span class="p_add">+		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address &amp;&amp;</span>
<span class="p_add">+			td-&gt;pipe-&gt;info.epnum == new_td-&gt;pipe-&gt;info.epnum);</span>
 
 		start_transfer(r8a66597, new_td);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 30c4ae80c8f9..e8f990642281 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -198,6 +198,9 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;
 			pdev-&gt;device == 0x1042)
 		xhci-&gt;quirks |= XHCI_BROKEN_STREAMS;
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;</span>
<span class="p_add">+			pdev-&gt;device == 0x1142)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;</span>
 
 	if (xhci-&gt;quirks &amp; XHCI_RESET_ON_RESUME)
 		xhci_dbg_trace(xhci, trace_xhci_dbg_quirks,
<span class="p_header">diff --git a/fs/configfs/symlink.c b/fs/configfs/symlink.c</span>
<span class="p_header">index ec5c8325b503..0525ebc3aea2 100644</span>
<span class="p_header">--- a/fs/configfs/symlink.c</span>
<span class="p_header">+++ b/fs/configfs/symlink.c</span>
<span class="p_chunk">@@ -83,14 +83,13 @@</span> <span class="p_context"> static int create_link(struct config_item *parent_item,</span>
 	ret = -ENOMEM;
 	sl = kmalloc(sizeof(struct configfs_symlink), GFP_KERNEL);
 	if (sl) {
<span class="p_del">-		sl-&gt;sl_target = config_item_get(item);</span>
 		spin_lock(&amp;configfs_dirent_lock);
 		if (target_sd-&gt;s_type &amp; CONFIGFS_USET_DROPPING) {
 			spin_unlock(&amp;configfs_dirent_lock);
<span class="p_del">-			config_item_put(item);</span>
 			kfree(sl);
 			return -ENOENT;
 		}
<span class="p_add">+		sl-&gt;sl_target = config_item_get(item);</span>
 		list_add(&amp;sl-&gt;sl_list, &amp;target_sd-&gt;s_links);
 		spin_unlock(&amp;configfs_dirent_lock);
 		ret = configfs_create_link(sl, parent_item-&gt;ci_dentry,
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 595ebdb41846..a17da8b57fc6 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index db1a1427c27a..07ef85e19fbc 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -295,11 +295,7 @@</span> <span class="p_context"> show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)</span>
 
 	/* We don&#39;t show the stack guard page in /proc/maps */
 	start = vma-&gt;vm_start;
<span class="p_del">-	if (stack_guard_page_start(vma, start))</span>
<span class="p_del">-		start += PAGE_SIZE;</span>
 	end = vma-&gt;vm_end;
<span class="p_del">-	if (stack_guard_page_end(vma, end))</span>
<span class="p_del">-		end -= PAGE_SIZE;</span>
 
 	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);
 	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index f0ffa01c90d9..55f950afb60d 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1278,39 +1278,11 @@</span> <span class="p_context"> int clear_page_dirty_for_io(struct page *page);</span>
 
 int get_cmdline(struct task_struct *task, char *buffer, int buflen);
 
<span class="p_del">-/* Is the vma a continuation of the stack vma above it? */</span>
<span class="p_del">-static inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_end == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSDOWN);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline bool vma_is_anonymous(struct vm_area_struct *vma)
 {
 	return !vma-&gt;vm_ops;
 }
 
<span class="p_del">-static inline int stack_guard_page_start(struct vm_area_struct *vma,</span>
<span class="p_del">-					     unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_start == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsdown(vma-&gt;vm_prev, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Is the vma a continuation of the stack vma below it? */</span>
<span class="p_del">-static inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_start == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSUP);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int stack_guard_page_end(struct vm_area_struct *vma,</span>
<span class="p_del">-					   unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_end == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsup(vma-&gt;vm_next, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int vma_is_stack_for_task(struct vm_area_struct *vma, struct task_struct *t);
 
 extern unsigned long move_page_tables(struct vm_area_struct *vma,
<span class="p_chunk">@@ -2012,6 +1984,7 @@</span> <span class="p_context"> void page_cache_async_readahead(struct address_space *mapping,</span>
 				pgoff_t offset,
 				unsigned long size);
 
<span class="p_add">+extern unsigned long stack_guard_gap;</span>
 /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
 
<span class="p_chunk">@@ -2040,6 +2013,30 @@</span> <span class="p_context"> static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * m</span>
 	return vma;
 }
 
<span class="p_add">+static inline unsigned long vm_start_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_start = vma-&gt;vm_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSDOWN) {</span>
<span class="p_add">+		vm_start -= stack_guard_gap;</span>
<span class="p_add">+		if (vm_start &gt; vma-&gt;vm_start)</span>
<span class="p_add">+			vm_start = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_start;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long vm_end_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSUP) {</span>
<span class="p_add">+		vm_end += stack_guard_gap;</span>
<span class="p_add">+		if (vm_end &lt; vma-&gt;vm_end)</span>
<span class="p_add">+			vm_end = -PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_end;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long vma_pages(struct vm_area_struct *vma)
 {
 	return (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
<span class="p_header">diff --git a/include/uapi/linux/usb/ch11.h b/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">index 331499d597fa..9ce10d4a0245 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch11.h</span>
<span class="p_chunk">@@ -22,6 +22,9 @@</span> <span class="p_context"></span>
  */
 #define USB_MAXCHILDREN		31
 
<span class="p_add">+/* See USB 3.1 spec Table 10-5 */</span>
<span class="p_add">+#define USB_SS_MAXPORTS		15</span>
<span class="p_add">+</span>
 /*
  * Hub request types
  */
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index 6ead200370da..a079ed14f230 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1287,8 +1287,10 @@</span> <span class="p_context"> __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)</span>
 			ret = __irq_set_trigger(desc,
 						new-&gt;flags &amp; IRQF_TRIGGER_MASK);
 
<span class="p_del">-			if (ret)</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				irq_release_resources(desc);</span>
 				goto out_mask;
<span class="p_add">+			}</span>
 		}
 
 		desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \
<span class="p_header">diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c</span>
<span class="p_header">index 7fbba635a549..2c3a23d77704 100644</span>
<span class="p_header">--- a/kernel/time/alarmtimer.c</span>
<span class="p_header">+++ b/kernel/time/alarmtimer.c</span>
<span class="p_chunk">@@ -339,7 +339,7 @@</span> <span class="p_context"> void alarm_start_relative(struct alarm *alarm, ktime_t start)</span>
 {
 	struct alarm_base *base = &amp;alarm_bases[alarm-&gt;type];
 
<span class="p_del">-	start = ktime_add(start, base-&gt;gettime());</span>
<span class="p_add">+	start = ktime_add_safe(start, base-&gt;gettime());</span>
 	alarm_start(alarm, start);
 }
 EXPORT_SYMBOL_GPL(alarm_start_relative);
<span class="p_chunk">@@ -425,7 +425,7 @@</span> <span class="p_context"> u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)</span>
 		overrun++;
 	}
 
<span class="p_del">-	alarm-&gt;node.expires = ktime_add(alarm-&gt;node.expires, interval);</span>
<span class="p_add">+	alarm-&gt;node.expires = ktime_add_safe(alarm-&gt;node.expires, interval);</span>
 	return overrun;
 }
 EXPORT_SYMBOL_GPL(alarm_forward);
<span class="p_chunk">@@ -611,13 +611,21 @@</span> <span class="p_context"> static int alarm_timer_set(struct k_itimer *timr, int flags,</span>
 
 	/* start the timer */
 	timr-&gt;it.alarm.interval = timespec_to_ktime(new_setting-&gt;it_interval);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Rate limit to the tick as a hot fix to prevent DOS. Will be</span>
<span class="p_add">+	 * mopped up later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ktime_to_ns(timr-&gt;it.alarm.interval) &lt; TICK_NSEC)</span>
<span class="p_add">+		timr-&gt;it.alarm.interval = ktime_set(0, TICK_NSEC);</span>
<span class="p_add">+</span>
 	exp = timespec_to_ktime(new_setting-&gt;it_value);
 	/* Convert (if necessary) to absolute time */
 	if (flags != TIMER_ABSTIME) {
 		ktime_t now;
 
 		now = alarm_bases[timr-&gt;it.alarm.alarmtimer.type].gettime();
<span class="p_del">-		exp = ktime_add(now, exp);</span>
<span class="p_add">+		exp = ktime_add_safe(now, exp);</span>
 	}
 
 	alarm_start(&amp;timr-&gt;it.alarm.alarmtimer, exp);
<span class="p_header">diff --git a/mm/gup.c b/mm/gup.c</span>
<span class="p_header">index 4b0b7e7d1136..b599526db9f7 100644</span>
<span class="p_header">--- a/mm/gup.c</span>
<span class="p_header">+++ b/mm/gup.c</span>
<span class="p_chunk">@@ -312,11 +312,6 @@</span> <span class="p_context"> static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,</span>
 	/* mlock all present pages, but do not fault in new pages */
 	if ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
 		return -ENOENT;
<span class="p_del">-	/* For mm_populate(), just skip the stack guard page. */</span>
<span class="p_del">-	if ((*flags &amp; FOLL_POPULATE) &amp;&amp;</span>
<span class="p_del">-			(stack_guard_page_start(vma, address) ||</span>
<span class="p_del">-			 stack_guard_page_end(vma, address + PAGE_SIZE)))</span>
<span class="p_del">-		return -ENOENT;</span>
 	if (*flags &amp; FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (nonblocking)
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 43aee7ab143e..091fe9b06663 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1208,7 +1208,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * page_remove_rmap() in try_to_unmap_one(). So to determine page status
 	 * correctly, we save a copy of the page flags at this time.
 	 */
<span class="p_del">-	page_flags = p-&gt;flags;</span>
<span class="p_add">+	if (PageHuge(p))</span>
<span class="p_add">+		page_flags = hpage-&gt;flags;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		page_flags = p-&gt;flags;</span>
 
 	/*
 	 * unpoison always clear PG_hwpoison inside page lock
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 76dcee317714..e6fa13484447 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -2662,40 +2662,6 @@</span> <span class="p_context"> out_release:</span>
 }
 
 /*
<span class="p_del">- * This is like a special single-page &quot;expand_{down|up}wards()&quot;,</span>
<span class="p_del">- * except we must first make sure that &#39;address{-|+}PAGE_SIZE&#39;</span>
<span class="p_del">- * doesn&#39;t hit another vma.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)</span>
<span class="p_del">-{</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp; address == vma-&gt;vm_start) {</span>
<span class="p_del">-		struct vm_area_struct *prev = vma-&gt;vm_prev;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Is there a mapping abutting this one below?</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * That&#39;s only ok if it&#39;s the same stack mapping</span>
<span class="p_del">-		 * that has gotten split..</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (prev &amp;&amp; prev-&gt;vm_end == address)</span>
<span class="p_del">-			return prev-&gt;vm_flags &amp; VM_GROWSDOWN ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_downwards(vma, address - PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp; address + PAGE_SIZE == vma-&gt;vm_end) {</span>
<span class="p_del">-		struct vm_area_struct *next = vma-&gt;vm_next;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* As VM_GROWSDOWN but s/below/above/ */</span>
<span class="p_del">-		if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE)</span>
<span class="p_del">-			return next-&gt;vm_flags &amp; VM_GROWSUP ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_upwards(vma, address + PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
<span class="p_chunk">@@ -2715,10 +2681,6 @@</span> <span class="p_context"> static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (vma-&gt;vm_flags &amp; VM_SHARED)
 		return VM_FAULT_SIGBUS;
 
<span class="p_del">-	/* Check if we need to add a guard page to the stack */</span>
<span class="p_del">-	if (check_stack_guard_page(vma, address) &lt; 0)</span>
<span class="p_del">-		return VM_FAULT_SIGSEGV;</span>
<span class="p_del">-</span>
 	/* Use the zero-page for reads */
 	if (!(flags &amp; FAULT_FLAG_WRITE) &amp;&amp; !mm_forbids_zeropage(mm)) {
 		entry = pte_mkspecial(pfn_pte(my_zero_pfn(address),
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 455772a05e54..0990f8bc0fbe 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -288,6 +288,7 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	unsigned long retval;
 	unsigned long newbrk, oldbrk;
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_add">+	struct vm_area_struct *next;</span>
 	unsigned long min_brk;
 	bool populate;
 
<span class="p_chunk">@@ -332,7 +333,8 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	}
 
 	/* Check against existing mmap mappings. */
<span class="p_del">-	if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</span>
<span class="p_add">+	next = find_vma(mm, oldbrk);</span>
<span class="p_add">+	if (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))</span>
 		goto out;
 
 	/* Ok, looks good - let it rip. */
<span class="p_chunk">@@ -355,10 +357,22 @@</span> <span class="p_context"> out:</span>
 
 static long vma_compute_subtree_gap(struct vm_area_struct *vma)
 {
<span class="p_del">-	unsigned long max, subtree_gap;</span>
<span class="p_del">-	max = vma-&gt;vm_start;</span>
<span class="p_del">-	if (vma-&gt;vm_prev)</span>
<span class="p_del">-		max -= vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_add">+	unsigned long max, prev_end, subtree_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we</span>
<span class="p_add">+	 * allow two stack_guard_gaps between them here, and when choosing</span>
<span class="p_add">+	 * an unmapped area; whereas when expanding we only require one.</span>
<span class="p_add">+	 * That&#39;s a little inconsistent, but keeps the code here simpler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	max = vm_start_gap(vma);</span>
<span class="p_add">+	if (vma-&gt;vm_prev) {</span>
<span class="p_add">+		prev_end = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+		if (max &gt; prev_end)</span>
<span class="p_add">+			max -= prev_end;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max = 0;</span>
<span class="p_add">+	}</span>
 	if (vma-&gt;vm_rb.rb_left) {
 		subtree_gap = rb_entry(vma-&gt;vm_rb.rb_left,
 				struct vm_area_struct, vm_rb)-&gt;rb_subtree_gap;
<span class="p_chunk">@@ -451,7 +465,7 @@</span> <span class="p_context"> static void validate_mm(struct mm_struct *mm)</span>
 			anon_vma_unlock_read(anon_vma);
 		}
 
<span class="p_del">-		highest_address = vma-&gt;vm_end;</span>
<span class="p_add">+		highest_address = vm_end_gap(vma);</span>
 		vma = vma-&gt;vm_next;
 		i++;
 	}
<span class="p_chunk">@@ -620,7 +634,7 @@</span> <span class="p_context"> void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (vma-&gt;vm_next)
 		vma_gap_update(vma-&gt;vm_next);
 	else
<span class="p_del">-		mm-&gt;highest_vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 
 	/*
 	 * vma-&gt;vm_prev wasn&#39;t known when we followed the rbtree to find the
<span class="p_chunk">@@ -866,7 +880,7 @@</span> <span class="p_context"> again:			remove_next = 1 + (end &gt; next-&gt;vm_end);</span>
 			vma_gap_update(vma);
 		if (end_changed) {
 			if (!next)
<span class="p_del">-				mm-&gt;highest_vm_end = end;</span>
<span class="p_add">+				mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 			else if (!adjust_next)
 				vma_gap_update(next);
 		}
<span class="p_chunk">@@ -909,7 +923,7 @@</span> <span class="p_context"> again:			remove_next = 1 + (end &gt; next-&gt;vm_end);</span>
 		else if (next)
 			vma_gap_update(next);
 		else
<span class="p_del">-			mm-&gt;highest_vm_end = end;</span>
<span class="p_add">+			VM_WARN_ON(mm-&gt;highest_vm_end != vm_end_gap(vma));</span>
 	}
 	if (insert &amp;&amp; file)
 		uprobe_mmap(insert);
<span class="p_chunk">@@ -1741,7 +1755,7 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit left subtree if it looks promising */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &gt;= low_limit &amp;&amp; vma-&gt;vm_rb.rb_left) {
 			struct vm_area_struct *left =
 				rb_entry(vma-&gt;vm_rb.rb_left,
<span class="p_chunk">@@ -1752,12 +1766,13 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 			}
 		}
 
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 check_current:
 		/* Check if current node has a suitable gap */
 		if (gap_start &gt; high_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_end &gt;= low_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_end &gt;= low_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit right subtree if it looks promising */
<span class="p_chunk">@@ -1779,8 +1794,8 @@</span> <span class="p_context"> check_current:</span>
 			vma = rb_entry(rb_parent(prev),
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_left) {
<span class="p_del">-				gap_start = vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_del">-				gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+				gap_start = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+				gap_end = vm_start_gap(vma);</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1844,7 +1859,7 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit right subtree if it looks promising */
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 		if (gap_start &lt;= high_limit &amp;&amp; vma-&gt;vm_rb.rb_right) {
 			struct vm_area_struct *right =
 				rb_entry(vma-&gt;vm_rb.rb_right,
<span class="p_chunk">@@ -1857,10 +1872,11 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 check_current:
 		/* Check if current node has a suitable gap */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &lt; low_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_start &lt;= high_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_start &lt;= high_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit left subtree if it looks promising */
<span class="p_chunk">@@ -1883,7 +1899,7 @@</span> <span class="p_context"> check_current:</span>
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_right) {
 				gap_start = vma-&gt;vm_prev ?
<span class="p_del">-					vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+					vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1921,7 +1937,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct vm_unmapped_area_info info;
 
 	if (len &gt; TASK_SIZE - mmap_min_addr)
<span class="p_chunk">@@ -1932,9 +1948,10 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -1957,7 +1974,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -1972,9 +1989,10 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+				(!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -2099,21 +2117,19 @@</span> <span class="p_context"> find_vma_prev(struct mm_struct *mm, unsigned long addr,</span>
  * update accounting. This is shared with both the
  * grow-up and grow-down cases.
  */
<span class="p_del">-static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)</span>
<span class="p_add">+static int acct_stack_growth(struct vm_area_struct *vma,</span>
<span class="p_add">+			     unsigned long size, unsigned long grow)</span>
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
 	struct rlimit *rlim = current-&gt;signal-&gt;rlim;
<span class="p_del">-	unsigned long new_start, actual_size;</span>
<span class="p_add">+	unsigned long new_start;</span>
 
 	/* address space limit tests */
 	if (!may_expand_vm(mm, grow))
 		return -ENOMEM;
 
 	/* Stack limit test */
<span class="p_del">-	actual_size = size;</span>
<span class="p_del">-	if (size &amp;&amp; (vma-&gt;vm_flags &amp; (VM_GROWSUP | VM_GROWSDOWN)))</span>
<span class="p_del">-		actual_size -= PAGE_SIZE;</span>
<span class="p_del">-	if (actual_size &gt; READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
<span class="p_add">+	if (size &gt; READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
 		return -ENOMEM;
 
 	/* mlock limit tests */
<span class="p_chunk">@@ -2151,16 +2167,32 @@</span> <span class="p_context"> static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns</span>
 int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
<span class="p_add">+	struct vm_area_struct *next;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error = 0;
 
 	if (!(vma-&gt;vm_flags &amp; VM_GROWSUP))
 		return -EFAULT;
 
<span class="p_del">-	/* Guard against wrapping around to address 0. */</span>
<span class="p_del">-	if (address &lt; PAGE_ALIGN(address+4))</span>
<span class="p_del">-		address = PAGE_ALIGN(address+4);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	/* Guard against exceeding limits of the address space. */</span>
<span class="p_add">+	address &amp;= PAGE_MASK;</span>
<span class="p_add">+	if (address &gt;= TASK_SIZE)</span>
 		return -ENOMEM;
<span class="p_add">+	address += PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address + stack_guard_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Guard against overflow */</span>
<span class="p_add">+	if (gap_addr &lt; address || gap_addr &gt; TASK_SIZE)</span>
<span class="p_add">+		gap_addr = TASK_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	next = vma-&gt;vm_next;</span>
<span class="p_add">+	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr) {</span>
<span class="p_add">+		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
 
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
<span class="p_chunk">@@ -2206,7 +2238,7 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 				if (vma-&gt;vm_next)
 					vma_gap_update(vma-&gt;vm_next);
 				else
<span class="p_del">-					mm-&gt;highest_vm_end = address;</span>
<span class="p_add">+					mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 				spin_unlock(&amp;mm-&gt;page_table_lock);
 
 				perf_event_mmap(vma);
<span class="p_chunk">@@ -2227,6 +2259,8 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 				   unsigned long address)
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
<span class="p_add">+	struct vm_area_struct *prev;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error;
 
 	address &amp;= PAGE_MASK;
<span class="p_chunk">@@ -2234,6 +2268,17 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	if (error)
 		return error;
 
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address - stack_guard_gap;</span>
<span class="p_add">+	if (gap_addr &gt; address)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	prev = vma-&gt;vm_prev;</span>
<span class="p_add">+	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr) {</span>
<span class="p_add">+		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
 		return -ENOMEM;
<span class="p_chunk">@@ -2289,28 +2334,25 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	return error;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Note how expand_stack() refuses to expand the stack all the way to</span>
<span class="p_del">- * abut the next virtual mapping, *unless* that mapping itself is also</span>
<span class="p_del">- * a stack mapping. We want to leave room for a guard page, after all</span>
<span class="p_del">- * (the guard page itself is not added here, that is done by the</span>
<span class="p_del">- * actual page faulting logic)</span>
<span class="p_del">- *</span>
<span class="p_del">- * This matches the behavior of the guard page logic (see mm/memory.c:</span>
<span class="p_del">- * check_stack_guard_page()), which only allows the guard page to be</span>
<span class="p_del">- * removed under these circumstances.</span>
<span class="p_del">- */</span>
<span class="p_add">+/* enforced gap between the expanding stack and other mappings. */</span>
<span class="p_add">+unsigned long stack_guard_gap = 256UL&lt;&lt;PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init cmdline_parse_stack_guard_gap(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long val;</span>
<span class="p_add">+	char *endptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = simple_strtoul(p, &amp;endptr, 10);</span>
<span class="p_add">+	if (!*endptr)</span>
<span class="p_add">+		stack_guard_gap = val &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;stack_guard_gap=&quot;, cmdline_parse_stack_guard_gap);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_STACK_GROWSUP
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *next;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	next = vma-&gt;vm_next;</span>
<span class="p_del">-	if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE) {</span>
<span class="p_del">-		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_upwards(vma, address);
 }
 
<span class="p_chunk">@@ -2332,14 +2374,6 @@</span> <span class="p_context"> find_extend_vma(struct mm_struct *mm, unsigned long addr)</span>
 #else
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *prev;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	prev = vma-&gt;vm_prev;</span>
<span class="p_del">-	if (prev &amp;&amp; prev-&gt;vm_end == address) {</span>
<span class="p_del">-		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_downwards(vma, address);
 }
 
<span class="p_chunk">@@ -2437,7 +2471,7 @@</span> <span class="p_context"> detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		vma-&gt;vm_prev = prev;
 		vma_gap_update(vma);
 	} else
<span class="p_del">-		mm-&gt;highest_vm_end = prev ? prev-&gt;vm_end : 0;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = prev ? vm_end_gap(prev) : 0;</span>
 	tail_vma-&gt;vm_next = NULL;
 
 	/* Kill the cache */
<span class="p_header">diff --git a/mm/swap_cgroup.c b/mm/swap_cgroup.c</span>
<span class="p_header">index b5f7f24b8dd1..40dd0f9b00d6 100644</span>
<span class="p_header">--- a/mm/swap_cgroup.c</span>
<span class="p_header">+++ b/mm/swap_cgroup.c</span>
<span class="p_chunk">@@ -48,6 +48,9 @@</span> <span class="p_context"> static int swap_cgroup_prepare(int type)</span>
 		if (!page)
 			goto not_enough_page;
 		ctrl-&gt;map[idx] = page;
<span class="p_add">+</span>
<span class="p_add">+		if (!(idx % SWAP_CLUSTER_MAX))</span>
<span class="p_add">+			cond_resched();</span>
 	}
 	return 0;
 not_enough_page:
<span class="p_header">diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c</span>
<span class="p_header">index 980e9e9b6684..24ba31601fc9 100644</span>
<span class="p_header">--- a/net/mac80211/ibss.c</span>
<span class="p_header">+++ b/net/mac80211/ibss.c</span>
<span class="p_chunk">@@ -66,6 +66,8 @@</span> <span class="p_context"> ieee80211_ibss_build_presp(struct ieee80211_sub_if_data *sdata,</span>
 		    2 + (IEEE80211_MAX_SUPP_RATES - 8) +
 		    2 + sizeof(struct ieee80211_ht_cap) +
 		    2 + sizeof(struct ieee80211_ht_operation) +
<span class="p_add">+		    2 + sizeof(struct ieee80211_vht_cap) +</span>
<span class="p_add">+		    2 + sizeof(struct ieee80211_vht_operation) +</span>
 		    ifibss-&gt;ie_len;
 	presp = kzalloc(sizeof(*presp) + frame_len, GFP_KERNEL);
 	if (!presp)
<span class="p_chunk">@@ -486,14 +488,14 @@</span> <span class="p_context"> int ieee80211_ibss_csa_beacon(struct ieee80211_sub_if_data *sdata,</span>
 	struct beacon_data *presp, *old_presp;
 	struct cfg80211_bss *cbss;
 	const struct cfg80211_bss_ies *ies;
<span class="p_del">-	u16 capability = 0;</span>
<span class="p_add">+	u16 capability = WLAN_CAPABILITY_IBSS;</span>
 	u64 tsf;
 	int ret = 0;
 
 	sdata_assert_lock(sdata);
 
 	if (ifibss-&gt;privacy)
<span class="p_del">-		capability = WLAN_CAPABILITY_PRIVACY;</span>
<span class="p_add">+		capability |= WLAN_CAPABILITY_PRIVACY;</span>
 
 	cbss = cfg80211_get_bss(sdata-&gt;local-&gt;hw.wiphy, ifibss-&gt;chandef.chan,
 				ifibss-&gt;bssid, ifibss-&gt;ssid,
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 9f0915f72702..3bcabc2ba4a6 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -1455,12 +1455,16 @@</span> <span class="p_context"> ieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)</span>
 	 */
 	if (!ieee80211_hw_check(&amp;sta-&gt;local-&gt;hw, AP_LINK_PS) &amp;&amp;
 	    !ieee80211_has_morefrags(hdr-&gt;frame_control) &amp;&amp;
<span class="p_add">+	    !ieee80211_is_back_req(hdr-&gt;frame_control) &amp;&amp;</span>
 	    !(status-&gt;rx_flags &amp; IEEE80211_RX_DEFERRED_RELEASE) &amp;&amp;
 	    (rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP ||
 	     rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN) &amp;&amp;
<span class="p_del">-	    /* PM bit is only checked in frames where it isn&#39;t reserved,</span>
<span class="p_add">+	    /*</span>
<span class="p_add">+	     * PM bit is only checked in frames where it isn&#39;t reserved,</span>
 	     * in AP mode it&#39;s reserved in non-bufferable management frames
 	     * (cf. IEEE 802.11-2012 8.2.4.1.7 Power Management field)
<span class="p_add">+	     * BAR frames should be ignored as specified in</span>
<span class="p_add">+	     * IEEE 802.11-2012 10.2.1.2.</span>
 	     */
 	    (!ieee80211_is_mgmt(hdr-&gt;frame_control) ||
 	     ieee80211_is_bufferable_mmpdu(hdr-&gt;frame_control))) {
<span class="p_header">diff --git a/net/mac80211/wpa.c b/net/mac80211/wpa.c</span>
<span class="p_header">index d824c38971ed..e19ea1c53afa 100644</span>
<span class="p_header">--- a/net/mac80211/wpa.c</span>
<span class="p_header">+++ b/net/mac80211/wpa.c</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/unaligned.h&gt;
 #include &lt;net/mac80211.h&gt;
 #include &lt;crypto/aes.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 
 #include &quot;ieee80211_i.h&quot;
 #include &quot;michael.h&quot;
<span class="p_chunk">@@ -152,7 +153,7 @@</span> <span class="p_context"> ieee80211_rx_h_michael_mic_verify(struct ieee80211_rx_data *rx)</span>
 	data_len = skb-&gt;len - hdrlen - MICHAEL_MIC_LEN;
 	key = &amp;rx-&gt;key-&gt;conf.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];
 	michael_mic(key, hdr, data, data_len, mic);
<span class="p_del">-	if (memcmp(mic, data + data_len, MICHAEL_MIC_LEN) != 0)</span>
<span class="p_add">+	if (crypto_memneq(mic, data + data_len, MICHAEL_MIC_LEN))</span>
 		goto mic_fail;
 
 	/* remove Michael MIC from payload */
<span class="p_chunk">@@ -1044,7 +1045,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx)</span>
 		bip_aad(skb, aad);
 		ieee80211_aes_cmac(key-&gt;u.aes_cmac.tfm, aad,
 				   skb-&gt;data + 24, skb-&gt;len - 24, mic);
<span class="p_del">-		if (memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		if (crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_cmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_chunk">@@ -1094,7 +1095,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_cmac_256_decrypt(struct ieee80211_rx_data *rx)</span>
 		bip_aad(skb, aad);
 		ieee80211_aes_cmac_256(key-&gt;u.aes_cmac.tfm, aad,
 				       skb-&gt;data + 24, skb-&gt;len - 24, mic);
<span class="p_del">-		if (memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		if (crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_cmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_chunk">@@ -1198,7 +1199,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_gmac_decrypt(struct ieee80211_rx_data *rx)</span>
 		if (ieee80211_aes_gmac(key-&gt;u.aes_gmac.tfm, aad, nonce,
 				       skb-&gt;data + 24, skb-&gt;len - 24,
 				       mic) &lt; 0 ||
<span class="p_del">-		    memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		    crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_gmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



