
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.48 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.48</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 10, 2015, 7:25 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150710192529.GB19467@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6768111/mbox/"
   >mbox</a>
|
   <a href="/patch/6768111/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6768111/">/patch/6768111/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 81446C05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 10 Jul 2015 19:26:00 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 2BF2420787
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 10 Jul 2015 19:25:58 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 929B62056C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 10 Jul 2015 19:25:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S933115AbbGJTZv (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 10 Jul 2015 15:25:51 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:55437 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S933051AbbGJTZd (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 10 Jul 2015 15:25:33 -0400
Received: from localhost (unknown [216.9.110.2])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id D7F29BCC;
	Fri, 10 Jul 2015 19:25:29 +0000 (UTC)
Date: Fri, 10 Jul 2015 12:25:29 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.48
Message-ID: &lt;20150710192529.GB19467@kroah.com&gt;
References: &lt;20150710192522.GA19467@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150710192522.GA19467@kroah.com&gt;
User-Agent: Mutt/1.5.23+89 (0255b37be491) (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.5 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - July 10, 2015, 7:25 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f9041e6d4d19..25393e89051c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 47</span>
<span class="p_add">+SUBLEVEL = 48</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_mmu.h b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">index 9f7923193cda..7d35af3f3752 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -117,13 +117,14 @@</span> <span class="p_context"> static inline void kvm_set_s2pmd_writable(pmd_t *pmd)</span>
 	(__boundary - 1 &lt; (end) - 1)? __boundary: (end);		\
 })
 
<span class="p_add">+#define kvm_pgd_index(addr)                    pgd_index(addr)</span>
<span class="p_add">+</span>
 static inline bool kvm_page_empty(void *ptr)
 {
 	struct page *ptr_page = virt_to_page(ptr);
 	return page_count(ptr_page) == 1;
 }
 
<span class="p_del">-</span>
 #define kvm_pte_table_empty(ptep) kvm_page_empty(ptep)
 #define kvm_pmd_table_empty(pmdp) kvm_page_empty(pmdp)
 #define kvm_pud_table_empty(pudp) (0)
<span class="p_header">diff --git a/arch/arm/kvm/arm.c b/arch/arm/kvm/arm.c</span>
<span class="p_header">index 2e74a617147d..f6a52a2a3724 100644</span>
<span class="p_header">--- a/arch/arm/kvm/arm.c</span>
<span class="p_header">+++ b/arch/arm/kvm/arm.c</span>
<span class="p_chunk">@@ -441,6 +441,7 @@</span> <span class="p_context"> static void update_vttbr(struct kvm *kvm)</span>
 
 static int kvm_vcpu_first_run_init(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	struct kvm *kvm = vcpu-&gt;kvm;</span>
 	int ret;
 
 	if (likely(vcpu-&gt;arch.has_run_once))
<span class="p_chunk">@@ -452,12 +453,20 @@</span> <span class="p_context"> static int kvm_vcpu_first_run_init(struct kvm_vcpu *vcpu)</span>
 	 * Initialize the VGIC before running a vcpu the first time on
 	 * this VM.
 	 */
<span class="p_del">-	if (unlikely(!vgic_initialized(vcpu-&gt;kvm))) {</span>
<span class="p_del">-		ret = kvm_vgic_init(vcpu-&gt;kvm);</span>
<span class="p_add">+	if (unlikely(!vgic_initialized(kvm))) {</span>
<span class="p_add">+		ret = kvm_vgic_init(kvm);</span>
 		if (ret)
 			return ret;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Enable the arch timers only if we have an in-kernel VGIC</span>
<span class="p_add">+	 * and it has been properly initialized, since we cannot handle</span>
<span class="p_add">+	 * interrupts from the virtual timer with a userspace gic.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (irqchip_in_kernel(kvm) &amp;&amp; vgic_initialized(kvm))</span>
<span class="p_add">+		kvm_timer_enable(kvm);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/arm/kvm/interrupts.S b/arch/arm/kvm/interrupts.S</span>
<span class="p_header">index 0d68d4073068..a1467e7689f5 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts.S</span>
<span class="p_chunk">@@ -159,13 +159,9 @@</span> <span class="p_context"> __kvm_vcpu_return:</span>
 	@ Don&#39;t trap coprocessor accesses for host kernel
 	set_hstr vmexit
 	set_hdcr vmexit
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11)), after_vfp_restore</span>
 
 #ifdef CONFIG_VFPv3
<span class="p_del">-	@ Save floating point registers we if let guest use them.</span>
<span class="p_del">-	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_del">-	bne	after_vfp_restore</span>
<span class="p_del">-</span>
 	@ Switch VFP/NEON hardware state to the host&#39;s
 	add	r7, vcpu, #VCPU_VFP_GUEST
 	store_vfp_state r7
<span class="p_chunk">@@ -177,6 +173,8 @@</span> <span class="p_context"> after_vfp_restore:</span>
 	@ Restore FPEXC_EN which we clobbered on entry
 	pop	{r2}
 	VFPFMXR FPEXC, r2
<span class="p_add">+#else</span>
<span class="p_add">+after_vfp_restore:</span>
 #endif
 
 	@ Reset Hyp-role
<span class="p_chunk">@@ -467,7 +465,7 @@</span> <span class="p_context"> switch_to_guest_vfp:</span>
 	push	{r3-r7}
 
 	@ NEON/VFP used.  Turn on VFP access.
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmtrap, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
 
 	@ Switch VFP/NEON hardware state to the guest&#39;s
 	add	r7, r0, #VCPU_VFP_HOST
<span class="p_header">diff --git a/arch/arm/kvm/interrupts_head.S b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">index 76af93025574..2973b2d342fa 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_chunk">@@ -578,8 +578,13 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 .endm
 
 /* Configures the HCPTR (Hyp Coprocessor Trap Register) on entry/return
<span class="p_del">- * (hardware reset value is 0). Keep previous value in r2. */</span>
<span class="p_del">-.macro set_hcptr operation, mask</span>
<span class="p_add">+ * (hardware reset value is 0). Keep previous value in r2.</span>
<span class="p_add">+ * An ISB is emited on vmexit/vmtrap, but executed on vmexit only if</span>
<span class="p_add">+ * VFP wasn&#39;t already enabled (always executed on vmtrap).</span>
<span class="p_add">+ * If a label is specified with vmexit, it is branched to if VFP wasn&#39;t</span>
<span class="p_add">+ * enabled.</span>
<span class="p_add">+ */</span>
<span class="p_add">+.macro set_hcptr operation, mask, label = none</span>
 	mrc	p15, 4, r2, c1, c1, 2
 	ldr	r3, =\mask
 	.if \operation == vmentry
<span class="p_chunk">@@ -588,6 +593,17 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 	bic	r3, r2, r3		@ Don&#39;t trap defined coproc-accesses
 	.endif
 	mcr	p15, 4, r3, c1, c1, 2
<span class="p_add">+	.if \operation != vmentry</span>
<span class="p_add">+	.if \operation == vmexit</span>
<span class="p_add">+	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	beq	1f</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	.if \label != none</span>
<span class="p_add">+	b	\label</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+1:</span>
<span class="p_add">+	.endif</span>
 .endm
 
 /* Configures the HDCR (Hyp Debug Configuration Register) on entry/return
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index 524b4b57f650..c612e37166ad 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static void unmap_range(struct kvm *kvm, pgd_t *pgdp,</span>
 	phys_addr_t addr = start, end = start + size;
 	phys_addr_t next;
 
<span class="p_del">-	pgd = pgdp + pgd_index(addr);</span>
<span class="p_add">+	pgd = pgdp + kvm_pgd_index(addr);</span>
 	do {
 		next = kvm_pgd_addr_end(addr, end);
 		if (!pgd_none(*pgd))
<span class="p_chunk">@@ -264,7 +264,7 @@</span> <span class="p_context"> static void stage2_flush_memslot(struct kvm *kvm,</span>
 	phys_addr_t next;
 	pgd_t *pgd;
 
<span class="p_del">-	pgd = kvm-&gt;arch.pgd + pgd_index(addr);</span>
<span class="p_add">+	pgd = kvm-&gt;arch.pgd + kvm_pgd_index(addr);</span>
 	do {
 		next = kvm_pgd_addr_end(addr, end);
 		stage2_flush_puds(kvm, pgd, addr, next);
<span class="p_chunk">@@ -649,7 +649,7 @@</span> <span class="p_context"> static pmd_t *stage2_get_pmd(struct kvm *kvm, struct kvm_mmu_memory_cache *cache</span>
 	pud_t *pud;
 	pmd_t *pmd;
 
<span class="p_del">-	pgd = kvm-&gt;arch.pgd + pgd_index(addr);</span>
<span class="p_add">+	pgd = kvm-&gt;arch.pgd + kvm_pgd_index(addr);</span>
 	pud = pud_offset(pgd, addr);
 	if (pud_none(*pud)) {
 		if (!cache)
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index 681cb9080100..91f33c2051f2 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -41,6 +41,8 @@</span> <span class="p_context"> void kvm_inject_pabt(struct kvm_vcpu *vcpu, unsigned long addr);</span>
 static inline void vcpu_reset_hcr(struct kvm_vcpu *vcpu)
 {
 	vcpu-&gt;arch.hcr_el2 = HCR_GUEST_FLAGS;
<span class="p_add">+	if (test_bit(KVM_ARM_VCPU_EL1_32BIT, vcpu-&gt;arch.features))</span>
<span class="p_add">+		vcpu-&gt;arch.hcr_el2 &amp;= ~HCR_RW;</span>
 }
 
 static inline unsigned long *vcpu_pc(const struct kvm_vcpu *vcpu)
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">index 0d51874c838f..15a8a861264a 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -69,6 +69,8 @@</span> <span class="p_context"></span>
 #define PTRS_PER_S2_PGD (1 &lt;&lt; (KVM_PHYS_SHIFT - PGDIR_SHIFT))
 #define S2_PGD_ORDER	get_order(PTRS_PER_S2_PGD * sizeof(pgd_t))
 
<span class="p_add">+#define kvm_pgd_index(addr)    (((addr) &gt;&gt; PGDIR_SHIFT) &amp; (PTRS_PER_S2_PGD - 1))</span>
<span class="p_add">+</span>
 int create_hyp_mappings(void *from, void *to);
 int create_hyp_io_mappings(void *from, void *to, phys_addr_t);
 void free_boot_hyp_pgd(void);
<span class="p_header">diff --git a/arch/arm64/kvm/hyp.S b/arch/arm64/kvm/hyp.S</span>
<span class="p_header">index 5dfc8331c385..3aaf3bc4ad8a 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp.S</span>
<span class="p_chunk">@@ -629,6 +629,7 @@</span> <span class="p_context"> ENTRY(__kvm_tlb_flush_vmid_ipa)</span>
 	 * Instead, we invalidate Stage-2 for this IPA, and the
 	 * whole of Stage-1. Weep...
 	 */
<span class="p_add">+	lsr	x1, x1, #12</span>
 	tlbi	ipas2e1is, x1
 	/*
 	 * We have to ensure completion of the invalidation at Stage-2,
<span class="p_header">diff --git a/arch/arm64/kvm/reset.c b/arch/arm64/kvm/reset.c</span>
<span class="p_header">index 70a7816535cd..0b4326578985 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/reset.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/reset.c</span>
<span class="p_chunk">@@ -90,7 +90,6 @@</span> <span class="p_context"> int kvm_reset_vcpu(struct kvm_vcpu *vcpu)</span>
 			if (!cpu_has_32bit_el1())
 				return -EINVAL;
 			cpu_reset = &amp;default_regs_reset32;
<span class="p_del">-			vcpu-&gt;arch.hcr_el2 &amp;= ~HCR_RW;</span>
 		} else {
 			cpu_reset = &amp;default_regs_reset;
 		}
<span class="p_header">diff --git a/arch/mips/include/asm/mach-generic/spaces.h b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">index 9488fa5f8866..afc96ecb9004 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_chunk">@@ -94,7 +94,11 @@</span> <span class="p_context"></span>
 #endif
 
 #ifndef FIXADDR_TOP
<span class="p_add">+#ifdef CONFIG_KVM_GUEST</span>
<span class="p_add">+#define FIXADDR_TOP		((unsigned long)(long)(int)0x7ffe0000)</span>
<span class="p_add">+#else</span>
 #define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
 #endif
<span class="p_add">+#endif</span>
 
 #endif /* __ASM_MACH_GENERIC_SPACES_H */
<span class="p_header">diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">index 38265dc85318..65dfbd0c196d 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_chunk">@@ -124,7 +124,16 @@</span> <span class="p_context"> static inline void power_pmu_bhrb_read(struct cpu_hw_events *cpuhw) {}</span>
 
 static bool regs_use_siar(struct pt_regs *regs)
 {
<span class="p_del">-	return !!regs-&gt;result;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we take a performance monitor exception the regs are setup</span>
<span class="p_add">+	 * using perf_read_regs() which overloads some fields, in particular</span>
<span class="p_add">+	 * regs-&gt;result to tell us whether to use SIAR.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However if the regs are from another exception, eg. a syscall, then</span>
<span class="p_add">+	 * they have not been setup using perf_read_regs() and so regs-&gt;result</span>
<span class="p_add">+	 * is something random.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return ((TRAP(regs) == 0xf00) &amp;&amp; regs-&gt;result);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c</span>
<span class="p_header">index 27bb55485472..7ef28625c199 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ldc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ldc.c</span>
<span class="p_chunk">@@ -2307,7 +2307,7 @@</span> <span class="p_context"> void *ldc_alloc_exp_dring(struct ldc_channel *lp, unsigned int len,</span>
 	if (len &amp; (8UL - 1))
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	buf = kzalloc(len, GFP_KERNEL);</span>
<span class="p_add">+	buf = kzalloc(len, GFP_ATOMIC);</span>
 	if (!buf)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 5dab54accc56..96e743ac28f3 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -2440,9 +2440,19 @@</span> <span class="p_context"> config X86_DMA_REMAP</span>
 	depends on STA2X11
 
 config IOSF_MBI
<span class="p_del">-	tristate</span>
<span class="p_del">-	default m</span>
<span class="p_add">+	tristate &quot;Intel System On Chip IOSF Sideband support&quot;</span>
 	depends on PCI
<span class="p_add">+	---help---</span>
<span class="p_add">+	  Enables sideband access to mailbox registers on SoC&#39;s. The sideband is</span>
<span class="p_add">+	  available on the following platforms. This list is not meant to be</span>
<span class="p_add">+	  exclusive.</span>
<span class="p_add">+	   - BayTrail</span>
<span class="p_add">+	   - Cherryview</span>
<span class="p_add">+	   - Braswell</span>
<span class="p_add">+	   - Quark</span>
<span class="p_add">+</span>
<span class="p_add">+	  You should say Y if you are running a kernel on one of these</span>
<span class="p_add">+	  platforms.</span>
 
 source &quot;net/Kconfig&quot;
 
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index e9dc02968cf8..ac03bd7c8978 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -571,7 +571,7 @@</span> <span class="p_context"> struct kvm_arch {</span>
 	struct kvm_pic *vpic;
 	struct kvm_ioapic *vioapic;
 	struct kvm_pit *vpit;
<span class="p_del">-	int vapics_in_nmi_mode;</span>
<span class="p_add">+	atomic_t vapics_in_nmi_mode;</span>
 	struct mutex apic_map_lock;
 	struct kvm_apic_map *apic_map;
 
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index 298781d4cfb4..1406ffde3e35 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> static void pit_do_work(struct kthread_work *work)</span>
 		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
 		 * VCPU0, and only if its LVT0 is in EXTINT mode.
 		 */
<span class="p_del">-		if (kvm-&gt;arch.vapics_in_nmi_mode &gt; 0)</span>
<span class="p_add">+		if (atomic_read(&amp;kvm-&gt;arch.vapics_in_nmi_mode) &gt; 0)</span>
 			kvm_for_each_vcpu(i, vcpu, kvm)
 				kvm_apic_nmi_wd_deliver(vcpu);
 	}
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index 453e5fbbb7ae..6456734a4ca6 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -1109,10 +1109,10 @@</span> <span class="p_context"> static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)</span>
 		if (!nmi_wd_enabled) {
 			apic_debug(&quot;Receive NMI setting on APIC_LVT0 &quot;
 				   &quot;for cpu %d\n&quot;, apic-&gt;vcpu-&gt;vcpu_id);
<span class="p_del">-			apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode++;</span>
<span class="p_add">+			atomic_inc(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 		}
 	} else if (nmi_wd_enabled)
<span class="p_del">-		apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode--;</span>
<span class="p_add">+		atomic_dec(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 }
 
 static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index 4f25ec077552..bf001382d170 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -84,6 +84,17 @@</span> <span class="p_context"> static const struct dmi_system_id pci_crs_quirks[] __initconst = {</span>
 			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),
 		},
 	},
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/931368 */</span>
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/1033299 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_use_crs,</span>
<span class="p_add">+		.ident = &quot;Foxconn K8M890-8237A&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Foxconn&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_NAME, &quot;K8M890-8237A&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* Now for the blacklist.. */
 
<span class="p_chunk">@@ -124,8 +135,10 @@</span> <span class="p_context"> void __init pci_acpi_crs_quirks(void)</span>
 {
 	int year;
 
<span class="p_del">-	if (dmi_get_date(DMI_BIOS_DATE, &amp;year, NULL, NULL) &amp;&amp; year &lt; 2008)</span>
<span class="p_del">-		pci_use_crs = false;</span>
<span class="p_add">+	if (dmi_get_date(DMI_BIOS_DATE, &amp;year, NULL, NULL) &amp;&amp; year &lt; 2008) {</span>
<span class="p_add">+		if (iomem_resource.end &lt;= 0xffffffff)</span>
<span class="p_add">+			pci_use_crs = false;</span>
<span class="p_add">+	}</span>
 
 	dmi_check_system(pci_crs_quirks);
 
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index 533a509439ca..fbc693b7d24f 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> static void byt_set_pstate(struct cpudata *cpudata, int pstate)</span>
 
 	val |= vid;
 
<span class="p_del">-	wrmsrl(MSR_IA32_PERF_CTL, val);</span>
<span class="p_add">+	wrmsrl_on_cpu(cpudata-&gt;cpu, MSR_IA32_PERF_CTL, val);</span>
 }
 
 #define BYT_BCLK_FREQS 5
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 5967667e1a8f..1f354879bd06 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -927,7 +927,8 @@</span> <span class="p_context"> static int sg_to_link_tbl(struct scatterlist *sg, int sg_count,</span>
 		sg_count--;
 		link_tbl_ptr--;
 	}
<span class="p_del">-	be16_add_cpu(&amp;link_tbl_ptr-&gt;len, cryptlen);</span>
<span class="p_add">+	link_tbl_ptr-&gt;len = cpu_to_be16(be16_to_cpu(link_tbl_ptr-&gt;len)</span>
<span class="p_add">+					+ cryptlen);</span>
 
 	/* tag end of link table */
 	link_tbl_ptr-&gt;j_extent = DESC_PTR_LNKTBL_RETURN;
<span class="p_chunk">@@ -2563,6 +2564,7 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		break;
 	default:
 		dev_err(dev, &quot;unknown algorithm type %d\n&quot;, t_alg-&gt;algt.type);
<span class="p_add">+		kfree(t_alg);</span>
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 9cbef59d404a..935974090aa0 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1922,9 +1922,15 @@</span> <span class="p_context"> static void free_pt_##LVL (unsigned long __pt)			\</span>
 	pt = (u64 *)__pt;					\
 								\
 	for (i = 0; i &lt; 512; ++i) {				\
<span class="p_add">+		/* PTE present? */				\</span>
 		if (!IOMMU_PTE_PRESENT(pt[i]))			\
 			continue;				\
 								\
<span class="p_add">+		/* Large PTE? */				\</span>
<span class="p_add">+		if (PM_PTE_LEVEL(pt[i]) == 0 ||			\</span>
<span class="p_add">+		    PM_PTE_LEVEL(pt[i]) == 7)			\</span>
<span class="p_add">+			continue;				\</span>
<span class="p_add">+								\</span>
 		p = (unsigned long)IOMMU_PTE_PAGE(pt[i]);	\
 		FN(p);						\
 	}							\
<span class="p_header">diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c</span>
<span class="p_header">index 25f74191a788..62c3fb91e76f 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy_device.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy_device.c</span>
<span class="p_chunk">@@ -765,10 +765,11 @@</span> <span class="p_context"> static int genphy_config_advert(struct phy_device *phydev)</span>
 	if (phydev-&gt;supported &amp; (SUPPORTED_1000baseT_Half |
 				 SUPPORTED_1000baseT_Full)) {
 		adv |= ethtool_adv_to_mii_ctrl1000_t(advertise);
<span class="p_del">-		if (adv != oldadv)</span>
<span class="p_del">-			changed = 1;</span>
 	}
 
<span class="p_add">+	if (adv != oldadv)</span>
<span class="p_add">+		changed = 1;</span>
<span class="p_add">+</span>
 	err = phy_write(phydev, MII_CTRL1000, adv);
 	if (err &lt; 0)
 		return err;
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 1d7e8a3fb6cd..aa24f7de1b92 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -2905,17 +2905,6 @@</span> <span class="p_context"> restart:</span>
 				vfsmnt = &amp;mnt-&gt;mnt;
 				continue;
 			}
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Filesystems needing to implement special &quot;root names&quot;</span>
<span class="p_del">-			 * should do so with -&gt;d_dname()</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (IS_ROOT(dentry) &amp;&amp;</span>
<span class="p_del">-			   (dentry-&gt;d_name.len != 1 ||</span>
<span class="p_del">-			    dentry-&gt;d_name.name[0] != &#39;/&#39;)) {</span>
<span class="p_del">-				WARN(1, &quot;Root dentry has weird name &lt;%.*s&gt;\n&quot;,</span>
<span class="p_del">-				     (int) dentry-&gt;d_name.len,</span>
<span class="p_del">-				     dentry-&gt;d_name.name);</span>
<span class="p_del">-			}</span>
 			if (!error)
 				error = is_mounted(vfsmnt) ? 1 : 2;
 			break;
<span class="p_header">diff --git a/fs/inode.c b/fs/inode.c</span>
<span class="p_header">index e846a32e8d6e..644875bcc846 100644</span>
<span class="p_header">--- a/fs/inode.c</span>
<span class="p_header">+++ b/fs/inode.c</span>
<span class="p_chunk">@@ -1631,8 +1631,8 @@</span> <span class="p_context"> int file_remove_suid(struct file *file)</span>
 		error = security_inode_killpriv(dentry);
 	if (!error &amp;&amp; killsuid)
 		error = __remove_suid(dentry, killsuid);
<span class="p_del">-	if (!error &amp;&amp; (inode-&gt;i_sb-&gt;s_flags &amp; MS_NOSEC))</span>
<span class="p_del">-		inode-&gt;i_flags |= S_NOSEC;</span>
<span class="p_add">+	if (!error)</span>
<span class="p_add">+		inode_has_no_xattr(inode);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 2faa7eacb62b..fc99d185a477 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -3031,11 +3031,15 @@</span> <span class="p_context"> bool fs_fully_visible(struct file_system_type *type)</span>
 		if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)
 			continue;
 
<span class="p_del">-		/* This mount is not fully visible if there are any child mounts</span>
<span class="p_del">-		 * that cover anything except for empty directories.</span>
<span class="p_add">+		/* This mount is not fully visible if there are any</span>
<span class="p_add">+		 * locked child mounts that cover anything except for</span>
<span class="p_add">+		 * empty directories.</span>
 		 */
 		list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) {
 			struct inode *inode = child-&gt;mnt_mountpoint-&gt;d_inode;
<span class="p_add">+			/* Only worry about locked mounts */</span>
<span class="p_add">+			if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED))</span>
<span class="p_add">+				continue;</span>
 			if (!S_ISDIR(inode-&gt;i_mode))
 				goto next;
 			if (inode-&gt;i_nlink &gt; 2)
<span class="p_header">diff --git a/include/kvm/arm_arch_timer.h b/include/kvm/arm_arch_timer.h</span>
<span class="p_header">index 6d9aeddc09bf..327b155e7cc9 100644</span>
<span class="p_header">--- a/include/kvm/arm_arch_timer.h</span>
<span class="p_header">+++ b/include/kvm/arm_arch_timer.h</span>
<span class="p_chunk">@@ -60,7 +60,8 @@</span> <span class="p_context"> struct arch_timer_cpu {</span>
 
 #ifdef CONFIG_KVM_ARM_TIMER
 int kvm_timer_hyp_init(void);
<span class="p_del">-int kvm_timer_init(struct kvm *kvm);</span>
<span class="p_add">+void kvm_timer_enable(struct kvm *kvm);</span>
<span class="p_add">+void kvm_timer_init(struct kvm *kvm);</span>
 void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 			  const struct kvm_irq_level *irq);
 void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu);
<span class="p_chunk">@@ -73,11 +74,8 @@</span> <span class="p_context"> static inline int kvm_timer_hyp_init(void)</span>
 	return 0;
 };
 
<span class="p_del">-static inline int kvm_timer_init(struct kvm *kvm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_add">+static inline void kvm_timer_enable(struct kvm *kvm) {}</span>
<span class="p_add">+static inline void kvm_timer_init(struct kvm *kvm) {}</span>
 static inline void kvm_timer_vcpu_reset(struct kvm_vcpu *vcpu,
 					const struct kvm_irq_level *irq) {}
 static inline void kvm_timer_vcpu_init(struct kvm_vcpu *vcpu) {}
<span class="p_header">diff --git a/include/net/netns/sctp.h b/include/net/netns/sctp.h</span>
<span class="p_header">index 3573a81815ad..8ba379f9e467 100644</span>
<span class="p_header">--- a/include/net/netns/sctp.h</span>
<span class="p_header">+++ b/include/net/netns/sctp.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> struct netns_sctp {</span>
 	struct list_head addr_waitq;
 	struct timer_list addr_wq_timer;
 	struct list_head auto_asconf_splist;
<span class="p_add">+	/* Lock that protects both addr_waitq and auto_asconf_splist */</span>
 	spinlock_t addr_wq_lock;
 
 	/* Lock that protects the local_addr_list writers */
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index 0dfcc92600e8..2c2d388f884f 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -219,6 +219,10 @@</span> <span class="p_context"> struct sctp_sock {</span>
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
<span class="p_add">+</span>
<span class="p_add">+	/* These must be the last fields, as they will skipped on copies,</span>
<span class="p_add">+	 * like on accept and peeloff operations</span>
<span class="p_add">+	 */</span>
 	struct list_head auto_asconf_list;
 	int do_auto_asconf;
 };
<span class="p_header">diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c</span>
<span class="p_header">index a9a4a1b7863d..8d423bc649b9 100644</span>
<span class="p_header">--- a/net/bridge/br_ioctl.c</span>
<span class="p_header">+++ b/net/bridge/br_ioctl.c</span>
<span class="p_chunk">@@ -247,9 +247,7 @@</span> <span class="p_context"> static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)</span>
 		if (!ns_capable(dev_net(dev)-&gt;user_ns, CAP_NET_ADMIN))
 			return -EPERM;
 
<span class="p_del">-		spin_lock_bh(&amp;br-&gt;lock);</span>
 		br_stp_set_bridge_priority(br, args[1]);
<span class="p_del">-		spin_unlock_bh(&amp;br-&gt;lock);</span>
 		return 0;
 
 	case BRCTL_SET_PORT_PRIORITY:
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 11a2e6c8538f..7bbc8fe25261 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -1086,6 +1086,9 @@</span> <span class="p_context"> static void br_multicast_add_router(struct net_bridge *br,</span>
 	struct net_bridge_port *p;
 	struct hlist_node *slot = NULL;
 
<span class="p_add">+	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	hlist_for_each_entry(p, &amp;br-&gt;router_list, rlist) {
 		if ((unsigned long) port &gt;= (unsigned long) p)
 			break;
<span class="p_chunk">@@ -1113,12 +1116,8 @@</span> <span class="p_context"> static void br_multicast_mark_router(struct net_bridge *br,</span>
 	if (port-&gt;multicast_router != 1)
 		return;
 
<span class="p_del">-	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_del">-		goto timer;</span>
<span class="p_del">-</span>
 	br_multicast_add_router(br, port);
 
<span class="p_del">-timer:</span>
 	mod_timer(&amp;port-&gt;multicast_router_timer,
 		  now + br-&gt;multicast_querier_interval);
 }
<span class="p_header">diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c</span>
<span class="p_header">index 189ba1e7d851..9a0005aee9ad 100644</span>
<span class="p_header">--- a/net/bridge/br_stp_if.c</span>
<span class="p_header">+++ b/net/bridge/br_stp_if.c</span>
<span class="p_chunk">@@ -243,12 +243,13 @@</span> <span class="p_context"> bool br_stp_recalculate_bridge_id(struct net_bridge *br)</span>
 	return true;
 }
 
<span class="p_del">-/* called under bridge lock */</span>
<span class="p_add">+/* Acquires and releases bridge lock */</span>
 void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)
 {
 	struct net_bridge_port *p;
 	int wasroot;
 
<span class="p_add">+	spin_lock_bh(&amp;br-&gt;lock);</span>
 	wasroot = br_is_root_bridge(br);
 
 	list_for_each_entry(p, &amp;br-&gt;port_list, list) {
<span class="p_chunk">@@ -266,6 +267,7 @@</span> <span class="p_context"> void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)</span>
 	br_port_state_selection(br);
 	if (br_is_root_bridge(br) &amp;&amp; !wasroot)
 		br_become_root_bridge(br);
<span class="p_add">+	spin_unlock_bh(&amp;br-&gt;lock);</span>
 }
 
 /* called under bridge lock */
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index 7d95f69635c6..0f062c671da9 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -976,6 +976,8 @@</span> <span class="p_context"> int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)</span>
 	rc = 0;
 	if (neigh-&gt;nud_state &amp; (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
 		goto out_unlock_bh;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out_dead;</span>
 
 	if (!(neigh-&gt;nud_state &amp; (NUD_STALE | NUD_INCOMPLETE))) {
 		if (NEIGH_VAR(neigh-&gt;parms, MCAST_PROBES) +
<span class="p_chunk">@@ -1032,6 +1034,13 @@</span> <span class="p_context"> out_unlock_bh:</span>
 		write_unlock(&amp;neigh-&gt;lock);
 	local_bh_enable();
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_dead:</span>
<span class="p_add">+	if (neigh-&gt;nud_state &amp; NUD_STALE)</span>
<span class="p_add">+		goto out_unlock_bh;</span>
<span class="p_add">+	write_unlock_bh(&amp;neigh-&gt;lock);</span>
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+	return 1;</span>
 }
 EXPORT_SYMBOL(__neigh_event_send);
 
<span class="p_chunk">@@ -1095,6 +1104,8 @@</span> <span class="p_context"> int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,</span>
 	if (!(flags &amp; NEIGH_UPDATE_F_ADMIN) &amp;&amp;
 	    (old &amp; (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out;</span>
 
 	if (!(new &amp; NUD_VALID)) {
 		neigh_del_timer(neigh);
<span class="p_chunk">@@ -1244,6 +1255,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(neigh_update);</span>
  */
 void __neigh_set_probe_once(struct neighbour *neigh)
 {
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		return;</span>
 	neigh-&gt;updated = jiffies;
 	if (!(neigh-&gt;nud_state &amp; NUD_FAILED))
 		return;
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index 69ec61abfb37..8207f8d7f665 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -368,9 +368,11 @@</span> <span class="p_context"> refill:</span>
 		for (order = NETDEV_FRAG_PAGE_MAX_ORDER; ;) {
 			gfp_t gfp = gfp_mask;
 
<span class="p_del">-			if (order)</span>
<span class="p_add">+			if (order) {</span>
 				gfp |= __GFP_COMP | __GFP_NOWARN |
 				       __GFP_NOMEMALLOC;
<span class="p_add">+				gfp &amp;= ~__GFP_WAIT;</span>
<span class="p_add">+			}</span>
 			nc-&gt;frag.page = alloc_pages(gfp, order);
 			if (likely(nc-&gt;frag.page))
 				break;
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index 650dd58ebd05..8ebfa52e5d70 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1914,8 +1914,10 @@</span> <span class="p_context"> bool skb_page_frag_refill(unsigned int sz, struct page_frag *pfrag, gfp_t prio)</span>
 	do {
 		gfp_t gfp = prio;
 
<span class="p_del">-		if (order)</span>
<span class="p_add">+		if (order) {</span>
 			gfp |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY;
<span class="p_add">+			gfp &amp;= ~__GFP_WAIT;</span>
<span class="p_add">+		}</span>
 		pfrag-&gt;page = alloc_pages(gfp, order);
 		if (likely(pfrag-&gt;page)) {
 			pfrag-&gt;offset = 0;
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index 07bd8edef417..951fe55b1671 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -228,6 +228,8 @@</span> <span class="p_context"> int inet_listen(struct socket *sock, int backlog)</span>
 				err = 0;
 			if (err)
 				goto out;
<span class="p_add">+</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
 		}
 		err = inet_csk_listen_start(sk, backlog);
 		if (err)
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index 29d240b87af1..dc45221dc692 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -2684,10 +2684,13 @@</span> <span class="p_context"> static int do_tcp_setsockopt(struct sock *sk, int level,</span>
 
 	case TCP_FASTOPEN:
 		if (val &gt;= 0 &amp;&amp; ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_CLOSE |
<span class="p_del">-		    TCPF_LISTEN)))</span>
<span class="p_add">+		    TCPF_LISTEN))) {</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
<span class="p_add">+</span>
 			err = fastopen_init_queue(sk, val);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			err = -EINVAL;
<span class="p_add">+		}</span>
 		break;
 	case TCP_TIMESTAMP:
 		if (!tp-&gt;repair)
<span class="p_header">diff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">index f195d9316e55..ee6518d1afe5 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_fastopen.c</span>
<span class="p_chunk">@@ -84,8 +84,6 @@</span> <span class="p_context"> void tcp_fastopen_cookie_gen(__be32 src, __be32 dst,</span>
 	__be32 path[4] = { src, dst, 0, 0 };
 	struct tcp_fastopen_context *ctx;
 
<span class="p_del">-	tcp_fastopen_init_key_once(true);</span>
<span class="p_del">-</span>
 	rcu_read_lock();
 	ctx = rcu_dereference(tcp_fastopen_ctx);
 	if (ctx) {
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 48b181797d7b..84a60b82e235 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1264,16 +1264,6 @@</span> <span class="p_context"> static void packet_sock_destruct(struct sock *sk)</span>
 	sk_refcnt_debug_dec(sk);
 }
 
<span class="p_del">-static int fanout_rr_next(struct packet_fanout *f, unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int x = atomic_read(&amp;f-&gt;rr_cur) + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (x &gt;= num)</span>
<span class="p_del">-		x = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return x;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static unsigned int fanout_demux_hash(struct packet_fanout *f,
 				      struct sk_buff *skb,
 				      unsigned int num)
<span class="p_chunk">@@ -1285,13 +1275,9 @@</span> <span class="p_context"> static unsigned int fanout_demux_lb(struct packet_fanout *f,</span>
 				    struct sk_buff *skb,
 				    unsigned int num)
 {
<span class="p_del">-	int cur, old;</span>
<span class="p_add">+	unsigned int val = atomic_inc_return(&amp;f-&gt;rr_cur);</span>
 
<span class="p_del">-	cur = atomic_read(&amp;f-&gt;rr_cur);</span>
<span class="p_del">-	while ((old = atomic_cmpxchg(&amp;f-&gt;rr_cur, cur,</span>
<span class="p_del">-				     fanout_rr_next(f, num))) != cur)</span>
<span class="p_del">-		cur = old;</span>
<span class="p_del">-	return cur;</span>
<span class="p_add">+	return val % num;</span>
 }
 
 static unsigned int fanout_demux_cpu(struct packet_fanout *f,
<span class="p_chunk">@@ -1345,7 +1331,7 @@</span> <span class="p_context"> static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,</span>
 			     struct packet_type *pt, struct net_device *orig_dev)
 {
 	struct packet_fanout *f = pt-&gt;af_packet_priv;
<span class="p_del">-	unsigned int num = f-&gt;num_members;</span>
<span class="p_add">+	unsigned int num = ACCESS_ONCE(f-&gt;num_members);</span>
 	struct packet_sock *po;
 	unsigned int idx;
 
<span class="p_header">diff --git a/net/sctp/output.c b/net/sctp/output.c</span>
<span class="p_header">index 740ca5f7add0..e39e6d561592 100644</span>
<span class="p_header">--- a/net/sctp/output.c</span>
<span class="p_header">+++ b/net/sctp/output.c</span>
<span class="p_chunk">@@ -599,7 +599,9 @@</span> <span class="p_context"> out:</span>
 	return err;
 no_route:
 	kfree_skb(nskb);
<span class="p_del">-	IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (asoc)</span>
<span class="p_add">+		IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
 
 	/* FIXME: Returning the &#39;err&#39; will effect all the associations
 	 * associated with a socket, although only one of the paths of the
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index 604a6acdf92e..f940fdc540f5 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1532,8 +1532,10 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 
 	/* Supposedly, no process has access to the socket, but
 	 * the net layers still may.
<span class="p_add">+	 * Also, sctp_destroy_sock() needs to be called with addr_wq_lock</span>
<span class="p_add">+	 * held and that should be grabbed before socket lock.</span>
 	 */
<span class="p_del">-	local_bh_disable();</span>
<span class="p_add">+	spin_lock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 	bh_lock_sock(sk);
 
 	/* Hold the sock, since sk_common_release() will put sock_put()
<span class="p_chunk">@@ -1543,7 +1545,7 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 	sk_common_release(sk);
 
 	bh_unlock_sock(sk);
<span class="p_del">-	local_bh_enable();</span>
<span class="p_add">+	spin_unlock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 
 	sock_put(sk);
 
<span class="p_chunk">@@ -3511,6 +3513,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 	if ((val &amp;&amp; sp-&gt;do_auto_asconf) || (!val &amp;&amp; !sp-&gt;do_auto_asconf))
 		return 0;
 
<span class="p_add">+	spin_lock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	if (val == 0 &amp;&amp; sp-&gt;do_auto_asconf) {
 		list_del(&amp;sp-&gt;auto_asconf_list);
 		sp-&gt;do_auto_asconf = 0;
<span class="p_chunk">@@ -3519,6 +3522,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 		    &amp;sock_net(sk)-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
 	}
<span class="p_add">+	spin_unlock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4009,18 +4013,28 @@</span> <span class="p_context"> static int sctp_init_sock(struct sock *sk)</span>
 	local_bh_disable();
 	percpu_counter_inc(&amp;sctp_sockets_allocated);
 	sock_prot_inuse_add(net, sk-&gt;sk_prot, 1);
<span class="p_add">+</span>
<span class="p_add">+	/* Nothing can fail after this block, otherwise</span>
<span class="p_add">+	 * sctp_destroy_sock() will be called without addr_wq_lock held</span>
<span class="p_add">+	 */</span>
 	if (net-&gt;sctp.default_auto_asconf) {
<span class="p_add">+		spin_lock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 		list_add_tail(&amp;sp-&gt;auto_asconf_list,
 		    &amp;net-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
<span class="p_del">-	} else</span>
<span class="p_add">+		spin_unlock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
<span class="p_add">+	} else {</span>
 		sp-&gt;do_auto_asconf = 0;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	local_bh_enable();
 
 	return 0;
 }
 
<span class="p_del">-/* Cleanup any SCTP per socket resources.  */</span>
<span class="p_add">+/* Cleanup any SCTP per socket resources. Must be called with</span>
<span class="p_add">+ * sock_net(sk)-&gt;sctp.addr_wq_lock held if sp-&gt;do_auto_asconf is true</span>
<span class="p_add">+ */</span>
 static void sctp_destroy_sock(struct sock *sk)
 {
 	struct sctp_sock *sp;
<span class="p_chunk">@@ -6973,6 +6987,19 @@</span> <span class="p_context"> void sctp_copy_sock(struct sock *newsk, struct sock *sk,</span>
 	newinet-&gt;mc_list = NULL;
 }
 
<span class="p_add">+static inline void sctp_copy_descendant(struct sock *sk_to,</span>
<span class="p_add">+					const struct sock *sk_from)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ancestor_size = sizeof(struct inet_sock) +</span>
<span class="p_add">+			    sizeof(struct sctp_sock) -</span>
<span class="p_add">+			    offsetof(struct sctp_sock, auto_asconf_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sk_from-&gt;sk_family == PF_INET6)</span>
<span class="p_add">+		ancestor_size += sizeof(struct ipv6_pinfo);</span>
<span class="p_add">+</span>
<span class="p_add">+	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Populate the fields of the newsk from the oldsk and migrate the assoc
  * and its messages to the newsk.
  */
<span class="p_chunk">@@ -6987,7 +7014,6 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	struct sk_buff *skb, *tmp;
 	struct sctp_ulpevent *event;
 	struct sctp_bind_hashbucket *head;
<span class="p_del">-	struct list_head tmplist;</span>
 
 	/* Migrate socket buffer sizes and all the socket level options to the
 	 * new socket.
<span class="p_chunk">@@ -6995,12 +7021,7 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	newsk-&gt;sk_sndbuf = oldsk-&gt;sk_sndbuf;
 	newsk-&gt;sk_rcvbuf = oldsk-&gt;sk_rcvbuf;
 	/* Brute force copy old sctp opt. */
<span class="p_del">-	if (oldsp-&gt;do_auto_asconf) {</span>
<span class="p_del">-		memcpy(&amp;tmplist, &amp;newsp-&gt;auto_asconf_list, sizeof(tmplist));</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_del">-		memcpy(&amp;newsp-&gt;auto_asconf_list, &amp;tmplist, sizeof(tmplist));</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_add">+	sctp_copy_descendant(newsk, oldsk);</span>
 
 	/* Restore the ep value that was overwritten with the above structure
 	 * copy.
<span class="p_header">diff --git a/virt/kvm/arm/arch_timer.c b/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">index 5081e809821f..c6fe40568690 100644</span>
<span class="p_header">--- a/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">+++ b/virt/kvm/arm/arch_timer.c</span>
<span class="p_chunk">@@ -61,12 +61,14 @@</span> <span class="p_context"> static void timer_disarm(struct arch_timer_cpu *timer)</span>
 
 static void kvm_timer_inject_irq(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	int ret;</span>
 	struct arch_timer_cpu *timer = &amp;vcpu-&gt;arch.timer_cpu;
 
 	timer-&gt;cntv_ctl |= ARCH_TIMER_CTRL_IT_MASK;
<span class="p_del">-	kvm_vgic_inject_irq(vcpu-&gt;kvm, vcpu-&gt;vcpu_id,</span>
<span class="p_del">-			    timer-&gt;irq-&gt;irq,</span>
<span class="p_del">-			    timer-&gt;irq-&gt;level);</span>
<span class="p_add">+	ret = kvm_vgic_inject_irq(vcpu-&gt;kvm, vcpu-&gt;vcpu_id,</span>
<span class="p_add">+				  timer-&gt;irq-&gt;irq,</span>
<span class="p_add">+				  timer-&gt;irq-&gt;level);</span>
<span class="p_add">+	WARN_ON(ret);</span>
 }
 
 static irqreturn_t kvm_arch_timer_handler(int irq, void *dev_id)
<span class="p_chunk">@@ -307,12 +309,24 @@</span> <span class="p_context"> void kvm_timer_vcpu_terminate(struct kvm_vcpu *vcpu)</span>
 	timer_disarm(timer);
 }
 
<span class="p_del">-int kvm_timer_init(struct kvm *kvm)</span>
<span class="p_add">+void kvm_timer_enable(struct kvm *kvm)</span>
 {
<span class="p_del">-	if (timecounter &amp;&amp; wqueue) {</span>
<span class="p_del">-		kvm-&gt;arch.timer.cntvoff = kvm_phys_timer_read();</span>
<span class="p_add">+	if (kvm-&gt;arch.timer.enabled)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * There is a potential race here between VCPUs starting for the first</span>
<span class="p_add">+	 * time, which may be enabling the timer multiple times.  That doesn&#39;t</span>
<span class="p_add">+	 * hurt though, because we&#39;re just setting a variable to the same</span>
<span class="p_add">+	 * variable that it already was.  The important thing is that all</span>
<span class="p_add">+	 * VCPUs have the enabled variable set, before entering the guest, if</span>
<span class="p_add">+	 * the arch timers are enabled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (timecounter &amp;&amp; wqueue)</span>
 		kvm-&gt;arch.timer.enabled = 1;
<span class="p_del">-	}</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+void kvm_timer_init(struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	kvm-&gt;arch.timer.cntvoff = kvm_phys_timer_read();</span>
 }
<span class="p_header">diff --git a/virt/kvm/arm/vgic.c b/virt/kvm/arm/vgic.c</span>
<span class="p_header">index c324a52bb407..152ec76ccb42 100644</span>
<span class="p_header">--- a/virt/kvm/arm/vgic.c</span>
<span class="p_header">+++ b/virt/kvm/arm/vgic.c</span>
<span class="p_chunk">@@ -1042,6 +1042,7 @@</span> <span class="p_context"> static bool vgic_queue_irq(struct kvm_vcpu *vcpu, u8 sgi_source_id, int irq)</span>
 			  lr, irq, vgic_cpu-&gt;vgic_lr[lr]);
 		BUG_ON(!test_bit(lr, vgic_cpu-&gt;lr_used));
 		vgic_cpu-&gt;vgic_lr[lr] |= GICH_LR_PENDING_BIT;
<span class="p_add">+		__clear_bit(lr, (unsigned long *)vgic_cpu-&gt;vgic_elrsr);</span>
 		return true;
 	}
 
<span class="p_chunk">@@ -1055,6 +1056,7 @@</span> <span class="p_context"> static bool vgic_queue_irq(struct kvm_vcpu *vcpu, u8 sgi_source_id, int irq)</span>
 	vgic_cpu-&gt;vgic_lr[lr] = MK_LR_PEND(sgi_source_id, irq);
 	vgic_cpu-&gt;vgic_irq_lr_map[irq] = lr;
 	set_bit(lr, vgic_cpu-&gt;lr_used);
<span class="p_add">+	__clear_bit(lr, (unsigned long *)vgic_cpu-&gt;vgic_elrsr);</span>
 
 	if (!vgic_irq_is_edge(vcpu, irq))
 		vgic_cpu-&gt;vgic_lr[lr] |= GICH_LR_EOI;
<span class="p_chunk">@@ -1209,6 +1211,14 @@</span> <span class="p_context"> static bool vgic_process_maintenance(struct kvm_vcpu *vcpu)</span>
 	if (vgic_cpu-&gt;vgic_misr &amp; GICH_MISR_U)
 		vgic_cpu-&gt;vgic_hcr &amp;= ~GICH_HCR_UIE;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In the next iterations of the vcpu loop, if we sync the vgic state</span>
<span class="p_add">+	 * after flushing it, but before entering the guest (this happens for</span>
<span class="p_add">+	 * pending signals and vmid rollovers), then make sure we don&#39;t pick</span>
<span class="p_add">+	 * up any old maintenance interrupts here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memset(vgic_cpu-&gt;vgic_eisr, 0, sizeof(vgic_cpu-&gt;vgic_eisr[0]) * 2);</span>
<span class="p_add">+</span>
 	return level_pending;
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



