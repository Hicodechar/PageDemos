
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] x86/platform changes for v4.11 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] x86/platform changes for v4.11</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 20, 2017, 1:17 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170220131752.GA11678@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9582753/mbox/"
   >mbox</a>
|
   <a href="/patch/9582753/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9582753/">/patch/9582753/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4412F604A0 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Feb 2017 13:18:20 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2C2DD2885C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Feb 2017 13:18:20 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1F7162885E; Mon, 20 Feb 2017 13:18:20 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.3 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 647422886F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Feb 2017 13:18:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753344AbdBTNSO (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 20 Feb 2017 08:18:14 -0500
Received: from mail-wr0-f194.google.com ([209.85.128.194]:33969 &quot;EHLO
	mail-wr0-f194.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752821AbdBTNR7 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 20 Feb 2017 08:17:59 -0500
Received: by mail-wr0-f194.google.com with SMTP id 89so5282478wrr.1
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 20 Feb 2017 05:17:58 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=70+CTnxA87O0KipzlO/vsQYmsTHkI80WkPgWCpj2UWQ=;
	b=ivURgUqXXZu7vu73gcN7mZhvyx7a94D4u9mD8Aw+JHf6QOyOcO3FOZ7LSDK8xBsQ+7
	wl6EPslSFEgscB3n/KxPWwNV1mf8stWNhip+5hud3Y7acpX1VmjHHE6s1l2fG3OYZIDU
	Q52GA5yb2fXYffuiTHs1OcKF/Evjepvp50+oTl6OUGO3hFZcgCBz6Db8sU9hIHvsWDD1
	Q94xbFxzEBz7/vYI/9tWcmellcFDwKp7fjMa0+Bcq/ralhD3SJWMOSG0vSwPL0ezo8uX
	Qkey2fP5hHDFIuJLzfz33tHE6chttArq4hBU/ur2tbXsjvUvYDP3qWOZwCcN5SJBE5Vv
	A0Bg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=70+CTnxA87O0KipzlO/vsQYmsTHkI80WkPgWCpj2UWQ=;
	b=gSZGIYq64jsW9LHET+k1PtbD/xmplM1qf4zV8VIWAhnNzgMJlG///cbhxQ/cVb+1os
	Avf7izCrc5qiHGvSMlUbMQvwNPMfe6FNCWdpoPeEfEeJ9PoZuHwH+FqFaXfPLgd9uLit
	xse9sd7sYjmuZnnb9+OKz0WAdg7uRn0yNnjr68W5fjBunHYMrpo0Vyp7ujbB8mKetCZT
	Pbrz3nj7LNDiC/5/01JdQXJk0C1mF0eJmwzPjQKICKQi01Rojco2M65nytU4x9+ywPuu
	9JIJfIQYM3SwHRs5/64mihPRou5M/KILZ8yKhILPKeqiDh7Z9qlYpsglJvLwDun+P9Pz
	YC2A==
X-Gm-Message-State: AMke39nQaoYPA3ysz56Leoef+N1iCF+BMN+J4DabDAI9NPauP+i/02DKNG8t+JvFS/8wvQ==
X-Received: by 10.223.160.114 with SMTP id l47mr14939480wrl.73.1487596675545;
	Mon, 20 Feb 2017 05:17:55 -0800 (PST)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	g81sm13415991wmf.16.2017.02.20.05.17.53
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 20 Feb 2017 05:17:54 -0800 (PST)
Date: Mon, 20 Feb 2017 14:17:52 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [GIT PULL] x86/platform changes for v4.11
Message-ID: &lt;20170220131752.GA11678@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Feb. 20, 2017, 1:17 p.m.</div>
<pre class="content">
Linus,

Please pull the latest x86-platform-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-platform-for-linus

   # HEAD: d48085f0716f195ee7432de2dd110e2093c40fd5 x86/platform/UV/NMI: Fix uneccessary kABI breakage

Misc platform updates: SGI UV4 support additions, intel-mid Merrifield 
enhancements and purge of old code.


  out-of-topic modifications in x86-platform-for-linus:
  -------------------------------------------------------
  drivers/platform/x86/Kconfig       # a665ece8b471: x86/platform/intel: Remove P
  drivers/platform/x86/Makefile      # a665ece8b471: x86/platform/intel: Remove P
  drivers/platform/x86/intel_pmic_gpio.c# a665ece8b471: x86/platform/intel: Remove P
  include/linux/intel_pmic_gpio.h    # a665ece8b471: x86/platform/intel: Remove P

 Thanks,

	Ingo

------------------&gt;
Andy Shevchenko (10):
      x86/platform/intel-mid: Remove Moorestown code
      x86/platform/intel-mid: Get rid of duplication of IPC handler
      x86/platform/intel-mid: Enable GPIO keys on Merrifield
      x86/platform/intel-mid: Make intel_scu_device_register() static
      x86/platform/intel: Remove PMIC GPIO block support
      x86/platform/intel-mid: Enable RTC on Intel Merrifield
      x86/ioapic: Return suitable error code in mp_map_gsi_to_irq()
      x86/platform/intel-mid: Allocate RTC interrupt for Merrifield
      x86/platform/intel-mid: Don&#39;t shadow error code of mp_map_gsi_to_irq()
      x86/platform/intel-mid: Move watchdog registration to arch_initcall()

Ingo Molnar (1):
      x86/platform/UV: Clean up the UV APIC code

Mike Travis (2):
      x86/platform/UV: Fix panic with missing UVsystab support
      x86/platform/UV: Fix 2 socket config problem

travis@sgi.com (8):
      x86/platform/UV: Add Support for UV4 Hubless systems
      x86/platform/UV: Add Support for UV4 Hubless NMIs
      x86/platform/UV: Add basic CPU NMI health check
      x86/platform/UV: Verify NMI action is valid, default is standard
      x86/platform/UV: Initialize PCH GPP_D_0 NMI Pin to be NMI source
      x86/platform/UV: Ensure uv_system_init is called when necessary
      x86/platform/UV: Clean up the NMI code to match current coding style
      x86/platform/UV/NMI: Fix uneccessary kABI breakage


 arch/x86/include/asm/intel-mid.h                   |   5 +-
 arch/x86/include/asm/uv/uv.h                       |   2 +
 arch/x86/include/asm/uv/uv_hub.h                   |   3 +
 arch/x86/kernel/apic/io_apic.c                     |   4 +-
 arch/x86/kernel/apic/x2apic_uv_x.c                 | 548 +++++++++++----------
 arch/x86/kernel/smpboot.c                          |   3 +-
 arch/x86/platform/intel-mid/device_libs/Makefile   |   3 +-
 .../intel-mid/device_libs/platform_gpio_keys.c     |   3 +
 .../platform/intel-mid/device_libs/platform_ipc.c  |  68 ---
 .../platform/intel-mid/device_libs/platform_ipc.h  |  18 -
 .../intel-mid/device_libs/platform_mrfld_rtc.c     |  48 ++
 .../intel-mid/device_libs/platform_mrfld_wdt.c     |  12 +-
 .../intel-mid/device_libs/platform_msic_audio.c    |   3 +-
 .../intel-mid/device_libs/platform_msic_battery.c  |   3 +-
 .../intel-mid/device_libs/platform_msic_gpio.c     |   3 +-
 .../intel-mid/device_libs/platform_msic_ocd.c      |   3 +-
 .../device_libs/platform_msic_power_btn.c          |   3 +-
 .../intel-mid/device_libs/platform_msic_thermal.c  |   3 +-
 .../intel-mid/device_libs/platform_pmic_gpio.c     |  54 --
 arch/x86/platform/intel-mid/mrfld.c                |   1 +
 arch/x86/platform/intel-mid/sfi.c                  |  58 ++-
 arch/x86/platform/uv/uv_nmi.c                      | 459 ++++++++++++++---
 drivers/platform/x86/Kconfig                       |   7 -
 drivers/platform/x86/Makefile                      |   1 -
 drivers/platform/x86/intel_pmic_gpio.c             | 326 ------------
 include/linux/intel_pmic_gpio.h                    |  15 -
 26 files changed, 796 insertions(+), 860 deletions(-)
 delete mode 100644 arch/x86/platform/intel-mid/device_libs/platform_ipc.c
 delete mode 100644 arch/x86/platform/intel-mid/device_libs/platform_ipc.h
 create mode 100644 arch/x86/platform/intel-mid/device_libs/platform_mrfld_rtc.c
 delete mode 100644 arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c
 delete mode 100644 drivers/platform/x86/intel_pmic_gpio.c
 delete mode 100644 include/linux/intel_pmic_gpio.h
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77">Linus Torvalds</a> - Feb. 21, 2017, 12:20 a.m.</div>
<pre class="content">
On Mon, Feb 20, 2017 at 5:17 AM, Ingo Molnar &lt;mingo@kernel.org&gt; wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; Mike Travis (2):</span>
<span class="quote">&gt;      [...]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; travis@sgi.com (8):</span>
<span class="quote">&gt;      [...]</span>

Btw, can you be a bit more careful when applying patches to make sure
that the name and email address is actually good?

This seems to be due to some screw-up on Mike&#39;s part, since the
original email seems to have this crap in the headers:
<span class="from">
    From: &quot;&#39;Mike Travis&quot; &lt;travis@sgi.com&gt;, &#39;@sgi.com</span>

which should never have worked but Mike apparently screwed up some
script, and mail transport generally has a &quot;let any crap through&quot;
tendency, but I would have hoped that people who commit these things
actually react to how bad the end result is.

Mike, please fix whatever braindamage your mail sending model has.

But Ingo and Thomas (I see both of you committing those broken
patches), please also look at what downstream sends you, and catch it
early rather than have crap authorship information.

                    Linus
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Feb. 21, 2017, 7:58 a.m.</div>
<pre class="content">
* Linus Torvalds &lt;torvalds@linux-foundation.org&gt; wrote:
<span class="quote">
&gt; On Mon, Feb 20, 2017 at 5:17 AM, Ingo Molnar &lt;mingo@kernel.org&gt; wrote:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Mike Travis (2):</span>
<span class="quote">&gt; &gt;      [...]</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; travis@sgi.com (8):</span>
<span class="quote">&gt; &gt;      [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Btw, can you be a bit more careful when applying patches to make sure</span>
<span class="quote">&gt; that the name and email address is actually good?</span>

Yes, will be more careful, sorry about that!
<span class="quote">
&gt; This seems to be due to some screw-up on Mike&#39;s part, since the</span>
<span class="quote">&gt; original email seems to have this crap in the headers:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     From: &quot;&#39;Mike Travis&quot; &lt;travis@sgi.com&gt;, &#39;@sgi.com</span>

Yeah, that&#39;s god-awful ugly - I should have caught it at the latest when looking 
over the shortlog so there&#39;s really no excuse for missing it ...
<span class="quote">
&gt; which should never have worked but Mike apparently screwed up some</span>
<span class="quote">&gt; script, and mail transport generally has a &quot;let any crap through&quot;</span>
<span class="quote">&gt; tendency, but I would have hoped that people who commit these things</span>
<span class="quote">&gt; actually react to how bad the end result is.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Mike, please fix whatever braindamage your mail sending model has.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But Ingo and Thomas (I see both of you committing those broken</span>
<span class="quote">&gt; patches), please also look at what downstream sends you, and catch it</span>
<span class="quote">&gt; early rather than have crap authorship information.</span>

Yeah.

Thanks,

	Ingo
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/include/asm/intel-mid.h b/arch/x86/include/asm/intel-mid.h</span>
<span class="p_header">index 49da9f497b90..fe04491130ae 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/intel-mid.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/intel-mid.h</span>
<span class="p_chunk">@@ -27,7 +27,6 @@</span> <span class="p_context"> extern void intel_mid_pwr_power_off(void);</span>
 extern int intel_mid_pwr_get_lss_id(struct pci_dev *pdev);
 
 extern int get_gpio_by_name(const char *name);
<span class="p_del">-extern void intel_scu_device_register(struct platform_device *pdev);</span>
 extern int __init sfi_parse_mrtc(struct sfi_table_header *table);
 extern int __init sfi_parse_mtmr(struct sfi_table_header *table);
 extern int sfi_mrtc_num;
<span class="p_chunk">@@ -42,10 +41,8 @@</span> <span class="p_context"> struct devs_id {</span>
 	char name[SFI_NAME_LEN + 1];
 	u8 type;
 	u8 delay;
<span class="p_add">+	u8 msic;</span>
 	void *(*get_platform_data)(void *info);
<span class="p_del">-	/* Custom handler for devices */</span>
<span class="p_del">-	void (*device_handler)(struct sfi_device_table_entry *pentry,</span>
<span class="p_del">-			       struct devs_id *dev);</span>
 };
 
 #define sfi_device(i)								\
<span class="p_header">diff --git a/arch/x86/include/asm/uv/uv.h b/arch/x86/include/asm/uv/uv.h</span>
<span class="p_header">index 062921ef34e9..6686820feae9 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uv/uv.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uv/uv.h</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"> struct mm_struct;</span>
 
 extern enum uv_system_type get_uv_system_type(void);
 extern int is_uv_system(void);
<span class="p_add">+extern int is_uv_hubless(void);</span>
 extern void uv_cpu_init(void);
 extern void uv_nmi_init(void);
 extern void uv_system_init(void);
<span class="p_chunk">@@ -23,6 +24,7 @@</span> <span class="p_context"> extern const struct cpumask *uv_flush_tlb_others(const struct cpumask *cpumask,</span>
 
 static inline enum uv_system_type get_uv_system_type(void) { return UV_NONE; }
 static inline int is_uv_system(void)	{ return 0; }
<span class="p_add">+static inline int is_uv_hubless(void)	{ return 0; }</span>
 static inline void uv_cpu_init(void)	{ }
 static inline void uv_system_init(void)	{ }
 static inline const struct cpumask *
<span class="p_header">diff --git a/arch/x86/include/asm/uv/uv_hub.h b/arch/x86/include/asm/uv/uv_hub.h</span>
<span class="p_header">index 097b80c989c4..72e8300b1e8a 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uv/uv_hub.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uv/uv_hub.h</span>
<span class="p_chunk">@@ -772,6 +772,7 @@</span> <span class="p_context"> static inline int uv_num_possible_blades(void)</span>
 
 /* Per Hub NMI support */
 extern void uv_nmi_setup(void);
<span class="p_add">+extern void uv_nmi_setup_hubless(void);</span>
 
 /* BMC sets a bit this MMR non-zero before sending an NMI */
 #define UVH_NMI_MMR		UVH_SCRATCH5
<span class="p_chunk">@@ -799,6 +800,8 @@</span> <span class="p_context"> struct uv_hub_nmi_s {</span>
 	atomic_t	read_mmr_count;	/* count of MMR reads */
 	atomic_t	nmi_count;	/* count of true UV NMIs */
 	unsigned long	nmi_value;	/* last value read from NMI MMR */
<span class="p_add">+	bool		hub_present;	/* false means UV hubless system */</span>
<span class="p_add">+	bool		pch_owner;	/* indicates this hub owns PCH */</span>
 };
 
 struct uv_cpu_nmi_s {
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index 1e35dd06b090..86a959d02932 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -1107,12 +1107,12 @@</span> <span class="p_context"> int mp_map_gsi_to_irq(u32 gsi, unsigned int flags, struct irq_alloc_info *info)</span>
 
 	ioapic = mp_find_ioapic(gsi);
 	if (ioapic &lt; 0)
<span class="p_del">-		return -1;</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	pin = mp_find_ioapic_pin(ioapic, gsi);
 	idx = find_irq_entry(ioapic, pin, mp_INT);
 	if ((flags &amp; IOAPIC_MAP_CHECK) &amp;&amp; idx &lt; 0)
<span class="p_del">-		return -1;</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	return mp_map_pin_to_irq(gsi, idx, ioapic, pin, flags, info);
 }
<span class="p_header">diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">index 35690a168cf7..e9f8f8cdd570 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_chunk">@@ -41,40 +41,44 @@</span> <span class="p_context"></span>
 
 DEFINE_PER_CPU(int, x2apic_extra_bits);
 
<span class="p_del">-#define PR_DEVEL(fmt, args...)	pr_devel(&quot;%s: &quot; fmt, __func__, args)</span>
<span class="p_del">-</span>
<span class="p_del">-static enum uv_system_type uv_system_type;</span>
<span class="p_del">-static u64 gru_start_paddr, gru_end_paddr;</span>
<span class="p_del">-static u64 gru_dist_base, gru_first_node_paddr = -1LL, gru_last_node_paddr;</span>
<span class="p_del">-static u64 gru_dist_lmask, gru_dist_umask;</span>
<span class="p_del">-static union uvh_apicid uvh_apicid;</span>
<span class="p_del">-</span>
<span class="p_del">-/* info derived from CPUID */</span>
<span class="p_add">+static enum uv_system_type	uv_system_type;</span>
<span class="p_add">+static bool			uv_hubless_system;</span>
<span class="p_add">+static u64			gru_start_paddr, gru_end_paddr;</span>
<span class="p_add">+static u64			gru_dist_base, gru_first_node_paddr = -1LL, gru_last_node_paddr;</span>
<span class="p_add">+static u64			gru_dist_lmask, gru_dist_umask;</span>
<span class="p_add">+static union uvh_apicid		uvh_apicid;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Information derived from CPUID: */</span>
 static struct {
 	unsigned int apicid_shift;
 	unsigned int apicid_mask;
 	unsigned int socketid_shift;	/* aka pnode_shift for UV1/2/3 */
 	unsigned int pnode_mask;
 	unsigned int gpa_shift;
<span class="p_add">+	unsigned int gnode_shift;</span>
 } uv_cpuid;
 
 int uv_min_hub_revision_id;
 EXPORT_SYMBOL_GPL(uv_min_hub_revision_id);
<span class="p_add">+</span>
 unsigned int uv_apicid_hibits;
 EXPORT_SYMBOL_GPL(uv_apicid_hibits);
 
 static struct apic apic_x2apic_uv_x;
 static struct uv_hub_info_s uv_hub_info_node0;
 
<span class="p_del">-/* Set this to use hardware error handler instead of kernel panic */</span>
<span class="p_add">+/* Set this to use hardware error handler instead of kernel panic: */</span>
 static int disable_uv_undefined_panic = 1;
<span class="p_add">+</span>
 unsigned long uv_undefined(char *str)
 {
 	if (likely(!disable_uv_undefined_panic))
 		panic(&quot;UV: error: undefined MMR: %s\n&quot;, str);
 	else
 		pr_crit(&quot;UV: error: undefined MMR: %s\n&quot;, str);
<span class="p_del">-	return ~0ul;	/* cause a machine fault  */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Cause a machine fault: */</span>
<span class="p_add">+	return ~0ul;</span>
 }
 EXPORT_SYMBOL(uv_undefined);
 
<span class="p_chunk">@@ -85,18 +89,19 @@</span> <span class="p_context"> static unsigned long __init uv_early_read_mmr(unsigned long addr)</span>
 	mmr = early_ioremap(UV_LOCAL_MMR_BASE | addr, sizeof(*mmr));
 	val = *mmr;
 	early_iounmap(mmr, sizeof(*mmr));
<span class="p_add">+</span>
 	return val;
 }
 
 static inline bool is_GRU_range(u64 start, u64 end)
 {
 	if (gru_dist_base) {
<span class="p_del">-		u64 su = start &amp; gru_dist_umask; /* upper (incl pnode) bits */</span>
<span class="p_del">-		u64 sl = start &amp; gru_dist_lmask; /* base offset bits */</span>
<span class="p_add">+		u64 su = start &amp; gru_dist_umask; /* Upper (incl pnode) bits */</span>
<span class="p_add">+		u64 sl = start &amp; gru_dist_lmask; /* Base offset bits */</span>
 		u64 eu = end &amp; gru_dist_umask;
 		u64 el = end &amp; gru_dist_lmask;
 
<span class="p_del">-		/* Must reside completely within a single GRU range */</span>
<span class="p_add">+		/* Must reside completely within a single GRU range: */</span>
 		return (sl == gru_dist_base &amp;&amp; el == gru_dist_base &amp;&amp;
 			su &gt;= gru_first_node_paddr &amp;&amp;
 			su &lt;= gru_last_node_paddr &amp;&amp;
<span class="p_chunk">@@ -133,13 +138,14 @@</span> <span class="p_context"> static int __init early_get_pnodeid(void)</span>
 		break;
 	case UV4_HUB_PART_NUMBER:
 		uv_min_hub_revision_id += UV4_HUB_REVISION_BASE - 1;
<span class="p_add">+		uv_cpuid.gnode_shift = 2; /* min partition is 4 sockets */</span>
 		break;
 	}
 
 	uv_hub_info-&gt;hub_revision = uv_min_hub_revision_id;
 	uv_cpuid.pnode_mask = (1 &lt;&lt; m_n_config.s.n_skt) - 1;
 	pnode = (node_id.s.node_id &gt;&gt; 1) &amp; uv_cpuid.pnode_mask;
<span class="p_del">-	uv_cpuid.gpa_shift = 46;	/* default unless changed */</span>
<span class="p_add">+	uv_cpuid.gpa_shift = 46;	/* Default unless changed */</span>
 
 	pr_info(&quot;UV: rev:%d part#:%x nodeid:%04x n_skt:%d pnmsk:%x pn:%x\n&quot;,
 		node_id.s.revision, node_id.s.part_number, node_id.s.node_id,
<span class="p_chunk">@@ -147,11 +153,12 @@</span> <span class="p_context"> static int __init early_get_pnodeid(void)</span>
 	return pnode;
 }
 
<span class="p_del">-/* [copied from arch/x86/kernel/cpu/topology.c:detect_extended_topology()] */</span>
<span class="p_del">-#define SMT_LEVEL	0	/* leaf 0xb SMT level */</span>
<span class="p_del">-#define INVALID_TYPE	0	/* leaf 0xb sub-leaf types */</span>
<span class="p_del">-#define SMT_TYPE	1</span>
<span class="p_del">-#define CORE_TYPE	2</span>
<span class="p_add">+/* [Copied from arch/x86/kernel/cpu/topology.c:detect_extended_topology()] */</span>
<span class="p_add">+</span>
<span class="p_add">+#define SMT_LEVEL			0	/* Leaf 0xb SMT level */</span>
<span class="p_add">+#define INVALID_TYPE			0	/* Leaf 0xb sub-leaf types */</span>
<span class="p_add">+#define SMT_TYPE			1</span>
<span class="p_add">+#define CORE_TYPE			2</span>
 #define LEAFB_SUBTYPE(ecx)		(((ecx) &gt;&gt; 8) &amp; 0xff)
 #define BITS_SHIFT_NEXT_LEVEL(eax)	((eax) &amp; 0x1f)
 
<span class="p_chunk">@@ -165,11 +172,13 @@</span> <span class="p_context"> static void set_x2apic_bits(void)</span>
 		pr_info(&quot;UV: CPU does not have CPUID.11\n&quot;);
 		return;
 	}
<span class="p_add">+</span>
 	cpuid_count(0xb, SMT_LEVEL, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);
 	if (ebx == 0 || (LEAFB_SUBTYPE(ecx) != SMT_TYPE)) {
 		pr_info(&quot;UV: CPUID.11 not implemented\n&quot;);
 		return;
 	}
<span class="p_add">+</span>
 	sid_shift = BITS_SHIFT_NEXT_LEVEL(eax);
 	sub_index = 1;
 	do {
<span class="p_chunk">@@ -180,8 +189,9 @@</span> <span class="p_context"> static void set_x2apic_bits(void)</span>
 		}
 		sub_index++;
 	} while (LEAFB_SUBTYPE(ecx) != INVALID_TYPE);
<span class="p_del">-	uv_cpuid.apicid_shift = 0;</span>
<span class="p_del">-	uv_cpuid.apicid_mask = (~(-1 &lt;&lt; sid_shift));</span>
<span class="p_add">+</span>
<span class="p_add">+	uv_cpuid.apicid_shift	= 0;</span>
<span class="p_add">+	uv_cpuid.apicid_mask	= (~(-1 &lt;&lt; sid_shift));</span>
 	uv_cpuid.socketid_shift = sid_shift;
 }
 
<span class="p_chunk">@@ -192,10 +202,8 @@</span> <span class="p_context"> static void __init early_get_apic_socketid_shift(void)</span>
 
 	set_x2apic_bits();
 
<span class="p_del">-	pr_info(&quot;UV: apicid_shift:%d apicid_mask:0x%x\n&quot;,</span>
<span class="p_del">-		uv_cpuid.apicid_shift, uv_cpuid.apicid_mask);</span>
<span class="p_del">-	pr_info(&quot;UV: socketid_shift:%d pnode_mask:0x%x\n&quot;,</span>
<span class="p_del">-		uv_cpuid.socketid_shift, uv_cpuid.pnode_mask);</span>
<span class="p_add">+	pr_info(&quot;UV: apicid_shift:%d apicid_mask:0x%x\n&quot;, uv_cpuid.apicid_shift, uv_cpuid.apicid_mask);</span>
<span class="p_add">+	pr_info(&quot;UV: socketid_shift:%d pnode_mask:0x%x\n&quot;, uv_cpuid.socketid_shift, uv_cpuid.pnode_mask);</span>
 }
 
 /*
<span class="p_chunk">@@ -208,10 +216,8 @@</span> <span class="p_context"> static void __init uv_set_apicid_hibit(void)</span>
 	union uv1h_lb_target_physical_apic_id_mask_u apicid_mask;
 
 	if (is_uv1_hub()) {
<span class="p_del">-		apicid_mask.v =</span>
<span class="p_del">-			uv_early_read_mmr(UV1H_LB_TARGET_PHYSICAL_APIC_ID_MASK);</span>
<span class="p_del">-		uv_apicid_hibits =</span>
<span class="p_del">-			apicid_mask.s1.bit_enables &amp; UV_APICID_HIBIT_MASK;</span>
<span class="p_add">+		apicid_mask.v = uv_early_read_mmr(UV1H_LB_TARGET_PHYSICAL_APIC_ID_MASK);</span>
<span class="p_add">+		uv_apicid_hibits = apicid_mask.s1.bit_enables &amp; UV_APICID_HIBIT_MASK;</span>
 	}
 }
 
<span class="p_chunk">@@ -220,20 +226,26 @@</span> <span class="p_context"> static int __init uv_acpi_madt_oem_check(char *oem_id, char *oem_table_id)</span>
 	int pnodeid;
 	int uv_apic;
 
<span class="p_del">-	if (strncmp(oem_id, &quot;SGI&quot;, 3) != 0)</span>
<span class="p_add">+	if (strncmp(oem_id, &quot;SGI&quot;, 3) != 0) {</span>
<span class="p_add">+		if (strncmp(oem_id, &quot;NSGI&quot;, 4) == 0) {</span>
<span class="p_add">+			uv_hubless_system = true;</span>
<span class="p_add">+			pr_info(&quot;UV: OEM IDs %s/%s, HUBLESS\n&quot;,</span>
<span class="p_add">+				oem_id, oem_table_id);</span>
<span class="p_add">+		}</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	if (numa_off) {
 		pr_err(&quot;UV: NUMA is off, disabling UV support\n&quot;);
 		return 0;
 	}
 
<span class="p_del">-	/* Setup early hub type field in uv_hub_info for Node 0 */</span>
<span class="p_add">+	/* Set up early hub type field in uv_hub_info for Node 0 */</span>
 	uv_cpu_info-&gt;p_uv_hub_info = &amp;uv_hub_info_node0;
 
 	/*
 	 * Determine UV arch type.
<span class="p_del">-	 *   SGI: UV100/1000</span>
<span class="p_add">+	 *   SGI:  UV100/1000</span>
 	 *   SGI2: UV2000/3000
 	 *   SGI3: UV300 (truncated to 4 chars because of different varieties)
 	 *   SGI4: UV400 (truncated to 4 chars because of different varieties)
<span class="p_chunk">@@ -249,31 +261,32 @@</span> <span class="p_context"> static int __init uv_acpi_madt_oem_check(char *oem_id, char *oem_table_id)</span>
 
 	pnodeid = early_get_pnodeid();
 	early_get_apic_socketid_shift();
<span class="p_del">-	x86_platform.is_untracked_pat_range =  uv_is_untracked_pat_range;</span>
<span class="p_add">+</span>
<span class="p_add">+	x86_platform.is_untracked_pat_range = uv_is_untracked_pat_range;</span>
 	x86_platform.nmi_init = uv_nmi_init;
 
<span class="p_del">-	if (!strcmp(oem_table_id, &quot;UVX&quot;)) {		/* most common */</span>
<span class="p_add">+	if (!strcmp(oem_table_id, &quot;UVX&quot;)) {</span>
<span class="p_add">+		/* This is the most common hardware variant: */</span>
 		uv_system_type = UV_X2APIC;
 		uv_apic = 0;
 
<span class="p_del">-	} else if (!strcmp(oem_table_id, &quot;UVH&quot;)) {	/* only UV1 systems */</span>
<span class="p_add">+	} else if (!strcmp(oem_table_id, &quot;UVH&quot;)) {</span>
<span class="p_add">+		/* Only UV1 systems: */</span>
 		uv_system_type = UV_NON_UNIQUE_APIC;
<span class="p_del">-		__this_cpu_write(x2apic_extra_bits,</span>
<span class="p_del">-			pnodeid &lt;&lt; uvh_apicid.s.pnode_shift);</span>
<span class="p_add">+		__this_cpu_write(x2apic_extra_bits, pnodeid &lt;&lt; uvh_apicid.s.pnode_shift);</span>
 		uv_set_apicid_hibit();
 		uv_apic = 1;
 
<span class="p_del">-	} else	if (!strcmp(oem_table_id, &quot;UVL&quot;)) {	/* only used for */</span>
<span class="p_del">-		uv_system_type = UV_LEGACY_APIC;	/* very small systems */</span>
<span class="p_add">+	} else if (!strcmp(oem_table_id, &quot;UVL&quot;)) {</span>
<span class="p_add">+		/* Only used for very small systems:  */</span>
<span class="p_add">+		uv_system_type = UV_LEGACY_APIC;</span>
 		uv_apic = 0;
 
 	} else {
 		goto badbios;
 	}
 
<span class="p_del">-	pr_info(&quot;UV: OEM IDs %s/%s, System/HUB Types %d/%d, uv_apic %d\n&quot;,</span>
<span class="p_del">-		oem_id, oem_table_id, uv_system_type,</span>
<span class="p_del">-		uv_min_hub_revision_id, uv_apic);</span>
<span class="p_add">+	pr_info(&quot;UV: OEM IDs %s/%s, System/HUB Types %d/%d, uv_apic %d\n&quot;, oem_id, oem_table_id, uv_system_type, uv_min_hub_revision_id, uv_apic);</span>
 
 	return uv_apic;
 
<span class="p_chunk">@@ -294,6 +307,12 @@</span> <span class="p_context"> int is_uv_system(void)</span>
 }
 EXPORT_SYMBOL_GPL(is_uv_system);
 
<span class="p_add">+int is_uv_hubless(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return uv_hubless_system;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(is_uv_hubless);</span>
<span class="p_add">+</span>
 void **__uv_hub_info_list;
 EXPORT_SYMBOL_GPL(__uv_hub_info_list);
 
<span class="p_chunk">@@ -306,16 +325,18 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(uv_possible_blades);</span>
 unsigned long sn_rtc_cycles_per_second;
 EXPORT_SYMBOL(sn_rtc_cycles_per_second);
 
<span class="p_del">-/* the following values are used for the per node hub info struct */</span>
<span class="p_del">-static __initdata unsigned short *_node_to_pnode;</span>
<span class="p_del">-static __initdata unsigned short _min_socket, _max_socket;</span>
<span class="p_del">-static __initdata unsigned short _min_pnode, _max_pnode, _gr_table_len;</span>
<span class="p_del">-static __initdata struct uv_gam_range_entry *uv_gre_table;</span>
<span class="p_del">-static __initdata struct uv_gam_parameters *uv_gp_table;</span>
<span class="p_del">-static __initdata unsigned short *_socket_to_node;</span>
<span class="p_del">-static __initdata unsigned short *_socket_to_pnode;</span>
<span class="p_del">-static __initdata unsigned short *_pnode_to_socket;</span>
<span class="p_del">-static __initdata struct uv_gam_range_s *_gr_table;</span>
<span class="p_add">+/* The following values are used for the per node hub info struct */</span>
<span class="p_add">+static __initdata unsigned short		*_node_to_pnode;</span>
<span class="p_add">+static __initdata unsigned short		_min_socket, _max_socket;</span>
<span class="p_add">+static __initdata unsigned short		_min_pnode, _max_pnode, _gr_table_len;</span>
<span class="p_add">+static __initdata struct uv_gam_range_entry	*uv_gre_table;</span>
<span class="p_add">+static __initdata struct uv_gam_parameters	*uv_gp_table;</span>
<span class="p_add">+static __initdata unsigned short		*_socket_to_node;</span>
<span class="p_add">+static __initdata unsigned short		*_socket_to_pnode;</span>
<span class="p_add">+static __initdata unsigned short		*_pnode_to_socket;</span>
<span class="p_add">+</span>
<span class="p_add">+static __initdata struct uv_gam_range_s		*_gr_table;</span>
<span class="p_add">+</span>
 #define	SOCK_EMPTY	((unsigned short)~0)
 
 extern int uv_hub_info_version(void)
<span class="p_chunk">@@ -324,7 +345,7 @@</span> <span class="p_context"> extern int uv_hub_info_version(void)</span>
 }
 EXPORT_SYMBOL(uv_hub_info_version);
 
<span class="p_del">-/* Build GAM range lookup table */</span>
<span class="p_add">+/* Build GAM range lookup table: */</span>
 static __init void build_uv_gr_table(void)
 {
 	struct uv_gam_range_entry *gre = uv_gre_table;
<span class="p_chunk">@@ -342,25 +363,24 @@</span> <span class="p_context"> static __init void build_uv_gr_table(void)</span>
 
 	for (; gre-&gt;type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
 		if (gre-&gt;type == UV_GAM_RANGE_TYPE_HOLE) {
<span class="p_del">-			if (!ram_limit) {   /* mark hole between ram/non-ram */</span>
<span class="p_add">+			if (!ram_limit) {</span>
<span class="p_add">+				/* Mark hole between RAM/non-RAM: */</span>
 				ram_limit = last_limit;
 				last_limit = gre-&gt;limit;
 				lsid++;
 				continue;
 			}
 			last_limit = gre-&gt;limit;
<span class="p_del">-			pr_info(&quot;UV: extra hole in GAM RE table @%d\n&quot;,</span>
<span class="p_del">-				(int)(gre - uv_gre_table));</span>
<span class="p_add">+			pr_info(&quot;UV: extra hole in GAM RE table @%d\n&quot;, (int)(gre - uv_gre_table));</span>
 			continue;
 		}
 		if (_max_socket &lt; gre-&gt;sockid) {
<span class="p_del">-			pr_err(&quot;UV: GAM table sockid(%d) too large(&gt;%d) @%d\n&quot;,</span>
<span class="p_del">-				gre-&gt;sockid, _max_socket,</span>
<span class="p_del">-				(int)(gre - uv_gre_table));</span>
<span class="p_add">+			pr_err(&quot;UV: GAM table sockid(%d) too large(&gt;%d) @%d\n&quot;, gre-&gt;sockid, _max_socket, (int)(gre - uv_gre_table));</span>
 			continue;
 		}
 		sid = gre-&gt;sockid - _min_socket;
<span class="p_del">-		if (lsid &lt; sid) {		/* new range */</span>
<span class="p_add">+		if (lsid &lt; sid) {</span>
<span class="p_add">+			/* New range: */</span>
 			grt = &amp;_gr_table[indx];
 			grt-&gt;base = lindx;
 			grt-&gt;nasid = gre-&gt;nasid;
<span class="p_chunk">@@ -369,27 +389,32 @@</span> <span class="p_context"> static __init void build_uv_gr_table(void)</span>
 			lindx = indx++;
 			continue;
 		}
<span class="p_del">-		if (lsid == sid &amp;&amp; !ram_limit) {	/* update range */</span>
<span class="p_del">-			if (grt-&gt;limit == last_limit) {	/* .. if contiguous */</span>
<span class="p_add">+		/* Update range: */</span>
<span class="p_add">+		if (lsid == sid &amp;&amp; !ram_limit) {</span>
<span class="p_add">+			/* .. if contiguous: */</span>
<span class="p_add">+			if (grt-&gt;limit == last_limit) {</span>
 				grt-&gt;limit = last_limit = gre-&gt;limit;
 				continue;
 			}
 		}
<span class="p_del">-		if (!ram_limit) {		/* non-contiguous ram range */</span>
<span class="p_add">+		/* Non-contiguous RAM range: */</span>
<span class="p_add">+		if (!ram_limit) {</span>
 			grt++;
 			grt-&gt;base = lindx;
 			grt-&gt;nasid = gre-&gt;nasid;
 			grt-&gt;limit = last_limit = gre-&gt;limit;
 			continue;
 		}
<span class="p_del">-		grt++;				/* non-contiguous/non-ram */</span>
<span class="p_del">-		grt-&gt;base = grt - _gr_table;	/* base is this entry */</span>
<span class="p_add">+		/* Non-contiguous/non-RAM: */</span>
<span class="p_add">+		grt++;</span>
<span class="p_add">+		/* base is this entry */</span>
<span class="p_add">+		grt-&gt;base = grt - _gr_table;</span>
 		grt-&gt;nasid = gre-&gt;nasid;
 		grt-&gt;limit = last_limit = gre-&gt;limit;
 		lsid++;
 	}
 
<span class="p_del">-	/* shorten table if possible */</span>
<span class="p_add">+	/* Shorten table if possible */</span>
 	grt++;
 	i = grt - _gr_table;
 	if (i &lt; _gr_table_len) {
<span class="p_chunk">@@ -403,16 +428,15 @@</span> <span class="p_context"> static __init void build_uv_gr_table(void)</span>
 		}
 	}
 
<span class="p_del">-	/* display resultant gam range table */</span>
<span class="p_add">+	/* Display resultant GAM range table: */</span>
 	for (i = 0, grt = _gr_table; i &lt; _gr_table_len; i++, grt++) {
<span class="p_add">+		unsigned long start, end;</span>
 		int gb = grt-&gt;base;
<span class="p_del">-		unsigned long start = gb &lt; 0 ?  0 :</span>
<span class="p_del">-			(unsigned long)_gr_table[gb].limit &lt;&lt; UV_GAM_RANGE_SHFT;</span>
<span class="p_del">-		unsigned long end =</span>
<span class="p_del">-			(unsigned long)grt-&gt;limit &lt;&lt; UV_GAM_RANGE_SHFT;</span>
 
<span class="p_del">-		pr_info(&quot;UV: GAM Range %2d %04x 0x%013lx-0x%013lx (%d)\n&quot;,</span>
<span class="p_del">-			i, grt-&gt;nasid, start, end, gb);</span>
<span class="p_add">+		start = gb &lt; 0 ?  0 : (unsigned long)_gr_table[gb].limit &lt;&lt; UV_GAM_RANGE_SHFT;</span>
<span class="p_add">+		end = (unsigned long)grt-&gt;limit &lt;&lt; UV_GAM_RANGE_SHFT;</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_info(&quot;UV: GAM Range %2d %04x 0x%013lx-0x%013lx (%d)\n&quot;, i, grt-&gt;nasid, start, end, gb);</span>
 	}
 }
 
<span class="p_chunk">@@ -423,16 +447,19 @@</span> <span class="p_context"> static int uv_wakeup_secondary(int phys_apicid, unsigned long start_rip)</span>
 
 	pnode = uv_apicid_to_pnode(phys_apicid);
 	phys_apicid |= uv_apicid_hibits;
<span class="p_add">+</span>
 	val = (1UL &lt;&lt; UVH_IPI_INT_SEND_SHFT) |
 	    (phys_apicid &lt;&lt; UVH_IPI_INT_APIC_ID_SHFT) |
 	    ((start_rip &lt;&lt; UVH_IPI_INT_VECTOR_SHFT) &gt;&gt; 12) |
 	    APIC_DM_INIT;
<span class="p_add">+</span>
 	uv_write_global_mmr64(pnode, UVH_IPI_INT, val);
 
 	val = (1UL &lt;&lt; UVH_IPI_INT_SEND_SHFT) |
 	    (phys_apicid &lt;&lt; UVH_IPI_INT_APIC_ID_SHFT) |
 	    ((start_rip &lt;&lt; UVH_IPI_INT_VECTOR_SHFT) &gt;&gt; 12) |
 	    APIC_DM_STARTUP;
<span class="p_add">+</span>
 	uv_write_global_mmr64(pnode, UVH_IPI_INT, val);
 
 	return 0;
<span class="p_chunk">@@ -566,7 +593,7 @@</span> <span class="p_context"> static struct apic apic_x2apic_uv_x __ro_after_init = {</span>
 	.apic_id_registered		= uv_apic_id_registered,
 
 	.irq_delivery_mode		= dest_Fixed,
<span class="p_del">-	.irq_dest_mode			= 0, /* physical */</span>
<span class="p_add">+	.irq_dest_mode			= 0, /* Physical */</span>
 
 	.target_cpus			= online_target_cpus,
 	.disable_esr			= 0,
<span class="p_chunk">@@ -627,23 +654,22 @@</span> <span class="p_context"> static __init void get_lowmem_redirect(unsigned long *base, unsigned long *size)</span>
 		switch (i) {
 		case 0:
 			m_redirect = UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_0_MMR;
<span class="p_del">-			m_overlay = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR;</span>
<span class="p_add">+			m_overlay  = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_0_MMR;</span>
 			break;
 		case 1:
 			m_redirect = UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_1_MMR;
<span class="p_del">-			m_overlay = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR;</span>
<span class="p_add">+			m_overlay  = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_1_MMR;</span>
 			break;
 		case 2:
 			m_redirect = UVH_RH_GAM_ALIAS210_REDIRECT_CONFIG_2_MMR;
<span class="p_del">-			m_overlay = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR;</span>
<span class="p_add">+			m_overlay  = UVH_RH_GAM_ALIAS210_OVERLAY_CONFIG_2_MMR;</span>
 			break;
 		}
 		alias.v = uv_read_local_mmr(m_overlay);
 		if (alias.s.enable &amp;&amp; alias.s.base == 0) {
 			*size = (1UL &lt;&lt; alias.s.m_alias);
 			redirect.v = uv_read_local_mmr(m_redirect);
<span class="p_del">-			*base = (unsigned long)redirect.s.dest_base</span>
<span class="p_del">-							&lt;&lt; DEST_SHIFT;</span>
<span class="p_add">+			*base = (unsigned long)redirect.s.dest_base &lt;&lt; DEST_SHIFT;</span>
 			return;
 		}
 	}
<span class="p_chunk">@@ -652,8 +678,7 @@</span> <span class="p_context"> static __init void get_lowmem_redirect(unsigned long *base, unsigned long *size)</span>
 
 enum map_type {map_wb, map_uc};
 
<span class="p_del">-static __init void map_high(char *id, unsigned long base, int pshift,</span>
<span class="p_del">-			int bshift, int max_pnode, enum map_type map_type)</span>
<span class="p_add">+static __init void map_high(char *id, unsigned long base, int pshift, int bshift, int max_pnode, enum map_type map_type)</span>
 {
 	unsigned long bytes, paddr;
 
<span class="p_chunk">@@ -678,16 +703,19 @@</span> <span class="p_context"> static __init void map_gru_distributed(unsigned long c)</span>
 	int nid;
 
 	gru.v = c;
<span class="p_del">-	/* only base bits 42:28 relevant in dist mode */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only base bits 42:28 relevant in dist mode */</span>
 	gru_dist_base = gru.v &amp; 0x000007fff0000000UL;
 	if (!gru_dist_base) {
 		pr_info(&quot;UV: Map GRU_DIST base address NULL\n&quot;);
 		return;
 	}
<span class="p_add">+</span>
 	bytes = 1UL &lt;&lt; UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR_BASE_SHFT;
 	gru_dist_lmask = ((1UL &lt;&lt; uv_hub_info-&gt;m_val) - 1) &amp; ~(bytes - 1);
 	gru_dist_umask = ~((1UL &lt;&lt; uv_hub_info-&gt;m_val) - 1);
 	gru_dist_base &amp;= gru_dist_lmask; /* Clear bits above M */
<span class="p_add">+</span>
 	for_each_online_node(nid) {
 		paddr = ((u64)uv_node_to_pnode(nid) &lt;&lt; uv_hub_info-&gt;m_val) |
 				gru_dist_base;
<span class="p_chunk">@@ -695,11 +723,12 @@</span> <span class="p_context"> static __init void map_gru_distributed(unsigned long c)</span>
 		gru_first_node_paddr = min(paddr, gru_first_node_paddr);
 		gru_last_node_paddr = max(paddr, gru_last_node_paddr);
 	}
<span class="p_add">+</span>
 	/* Save upper (63:M) bits of address only for is_GRU_range */
 	gru_first_node_paddr &amp;= gru_dist_umask;
 	gru_last_node_paddr &amp;= gru_dist_umask;
<span class="p_del">-	pr_debug(&quot;UV: Map GRU_DIST base 0x%016llx  0x%016llx - 0x%016llx\n&quot;,</span>
<span class="p_del">-		gru_dist_base, gru_first_node_paddr, gru_last_node_paddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;UV: Map GRU_DIST base 0x%016llx  0x%016llx - 0x%016llx\n&quot;, gru_dist_base, gru_first_node_paddr, gru_last_node_paddr);</span>
 }
 
 static __init void map_gru_high(int max_pnode)
<span class="p_chunk">@@ -719,6 +748,7 @@</span> <span class="p_context"> static __init void map_gru_high(int max_pnode)</span>
 		map_gru_distributed(gru.v);
 		return;
 	}
<span class="p_add">+</span>
 	base = (gru.v &amp; mask) &gt;&gt; shift;
 	map_high(&quot;GRU&quot;, base, shift, shift, max_pnode, map_wb);
 	gru_start_paddr = ((u64)base &lt;&lt; shift);
<span class="p_chunk">@@ -772,8 +802,8 @@</span> <span class="p_context"> static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)</span>
 
 	id = mmiohs[index].id;
 	overlay.v = uv_read_local_mmr(mmiohs[index].overlay);
<span class="p_del">-	pr_info(&quot;UV: %s overlay 0x%lx base:0x%x m_io:%d\n&quot;,</span>
<span class="p_del">-		id, overlay.v, overlay.s3.base, overlay.s3.m_io);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;UV: %s overlay 0x%lx base:0x%x m_io:%d\n&quot;, id, overlay.v, overlay.s3.base, overlay.s3.m_io);</span>
 	if (!overlay.s3.enable) {
 		pr_info(&quot;UV: %s disabled\n&quot;, id);
 		return;
<span class="p_chunk">@@ -784,7 +814,8 @@</span> <span class="p_context"> static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)</span>
 	m_io = overlay.s3.m_io;
 	mmr = mmiohs[index].redirect;
 	n = UV3H_RH_GAM_MMIOH_REDIRECT_CONFIG0_MMR_DEPTH;
<span class="p_del">-	min_pnode *= 2;				/* convert to NASID */</span>
<span class="p_add">+	/* Convert to NASID: */</span>
<span class="p_add">+	min_pnode *= 2;</span>
 	max_pnode *= 2;
 	max_io = lnasid = fi = li = -1;
 
<span class="p_chunk">@@ -793,16 +824,18 @@</span> <span class="p_context"> static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)</span>
 
 		redirect.v = uv_read_local_mmr(mmr + i * 8);
 		nasid = redirect.s3.nasid;
<span class="p_add">+		/* Invalid NASID: */</span>
 		if (nasid &lt; min_pnode || max_pnode &lt; nasid)
<span class="p_del">-			nasid = -1;		/* invalid NASID */</span>
<span class="p_add">+			nasid = -1;</span>
 
 		if (nasid == lnasid) {
 			li = i;
<span class="p_del">-			if (i != n-1)		/* last entry check */</span>
<span class="p_add">+			/* Last entry check: */</span>
<span class="p_add">+			if (i != n-1)</span>
 				continue;
 		}
 
<span class="p_del">-		/* check if we have a cached (or last) redirect to print */</span>
<span class="p_add">+		/* Check if we have a cached (or last) redirect to print: */</span>
 		if (lnasid != -1 || (i == n-1 &amp;&amp; nasid != -1))  {
 			unsigned long addr1, addr2;
 			int f, l;
<span class="p_chunk">@@ -814,12 +847,9 @@</span> <span class="p_context"> static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)</span>
 				f = fi;
 				l = li;
 			}
<span class="p_del">-			addr1 = (base &lt;&lt; shift) +</span>
<span class="p_del">-				f * (1ULL &lt;&lt; m_io);</span>
<span class="p_del">-			addr2 = (base &lt;&lt; shift) +</span>
<span class="p_del">-				(l + 1) * (1ULL &lt;&lt; m_io);</span>
<span class="p_del">-			pr_info(&quot;UV: %s[%03d..%03d] NASID 0x%04x ADDR 0x%016lx - 0x%016lx\n&quot;,</span>
<span class="p_del">-				id, fi, li, lnasid, addr1, addr2);</span>
<span class="p_add">+			addr1 = (base &lt;&lt; shift) + f * (1ULL &lt;&lt; m_io);</span>
<span class="p_add">+			addr2 = (base &lt;&lt; shift) + (l + 1) * (1ULL &lt;&lt; m_io);</span>
<span class="p_add">+			pr_info(&quot;UV: %s[%03d..%03d] NASID 0x%04x ADDR 0x%016lx - 0x%016lx\n&quot;, id, fi, li, lnasid, addr1, addr2);</span>
 			if (max_io &lt; l)
 				max_io = l;
 		}
<span class="p_chunk">@@ -827,8 +857,7 @@</span> <span class="p_context"> static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)</span>
 		lnasid = nasid;
 	}
 
<span class="p_del">-	pr_info(&quot;UV: %s base:0x%lx shift:%d M_IO:%d MAX_IO:%d\n&quot;,</span>
<span class="p_del">-		id, base, shift, m_io, max_io);</span>
<span class="p_add">+	pr_info(&quot;UV: %s base:0x%lx shift:%d M_IO:%d MAX_IO:%d\n&quot;, id, base, shift, m_io, max_io);</span>
 
 	if (max_io &gt;= 0)
 		map_high(id, base, shift, m_io, max_io, map_uc);
<span class="p_chunk">@@ -841,36 +870,35 @@</span> <span class="p_context"> static __init void map_mmioh_high(int min_pnode, int max_pnode)</span>
 	int shift, enable, m_io, n_io;
 
 	if (is_uv3_hub() || is_uv4_hub()) {
<span class="p_del">-		/* Map both MMIOH Regions */</span>
<span class="p_add">+		/* Map both MMIOH regions: */</span>
 		map_mmioh_high_uv3(0, min_pnode, max_pnode);
 		map_mmioh_high_uv3(1, min_pnode, max_pnode);
 		return;
 	}
 
 	if (is_uv1_hub()) {
<span class="p_del">-		mmr = UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR;</span>
<span class="p_del">-		shift = UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR_BASE_SHFT;</span>
<span class="p_del">-		mmioh.v = uv_read_local_mmr(mmr);</span>
<span class="p_del">-		enable = !!mmioh.s1.enable;</span>
<span class="p_del">-		base = mmioh.s1.base;</span>
<span class="p_del">-		m_io = mmioh.s1.m_io;</span>
<span class="p_del">-		n_io = mmioh.s1.n_io;</span>
<span class="p_add">+		mmr	= UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR;</span>
<span class="p_add">+		shift	= UV1H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR_BASE_SHFT;</span>
<span class="p_add">+		mmioh.v	= uv_read_local_mmr(mmr);</span>
<span class="p_add">+		enable	= !!mmioh.s1.enable;</span>
<span class="p_add">+		base	= mmioh.s1.base;</span>
<span class="p_add">+		m_io	= mmioh.s1.m_io;</span>
<span class="p_add">+		n_io	= mmioh.s1.n_io;</span>
 	} else if (is_uv2_hub()) {
<span class="p_del">-		mmr = UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR;</span>
<span class="p_del">-		shift = UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR_BASE_SHFT;</span>
<span class="p_del">-		mmioh.v = uv_read_local_mmr(mmr);</span>
<span class="p_del">-		enable = !!mmioh.s2.enable;</span>
<span class="p_del">-		base = mmioh.s2.base;</span>
<span class="p_del">-		m_io = mmioh.s2.m_io;</span>
<span class="p_del">-		n_io = mmioh.s2.n_io;</span>
<span class="p_del">-	} else</span>
<span class="p_add">+		mmr	= UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR;</span>
<span class="p_add">+		shift	= UV2H_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR_BASE_SHFT;</span>
<span class="p_add">+		mmioh.v	= uv_read_local_mmr(mmr);</span>
<span class="p_add">+		enable	= !!mmioh.s2.enable;</span>
<span class="p_add">+		base	= mmioh.s2.base;</span>
<span class="p_add">+		m_io	= mmioh.s2.m_io;</span>
<span class="p_add">+		n_io	= mmioh.s2.n_io;</span>
<span class="p_add">+	} else {</span>
 		return;
<span class="p_add">+	}</span>
 
 	if (enable) {
 		max_pnode &amp;= (1 &lt;&lt; n_io) - 1;
<span class="p_del">-		pr_info(</span>
<span class="p_del">-		    &quot;UV: base:0x%lx shift:%d N_IO:%d M_IO:%d max_pnode:0x%x\n&quot;,</span>
<span class="p_del">-			base, shift, m_io, n_io, max_pnode);</span>
<span class="p_add">+		pr_info(&quot;UV: base:0x%lx shift:%d N_IO:%d M_IO:%d max_pnode:0x%x\n&quot;, base, shift, m_io, n_io, max_pnode);</span>
 		map_high(&quot;MMIOH&quot;, base, shift, m_io, max_pnode, map_uc);
 	} else {
 		pr_info(&quot;UV: MMIOH disabled\n&quot;);
<span class="p_chunk">@@ -888,16 +916,16 @@</span> <span class="p_context"> static __init void uv_rtc_init(void)</span>
 	long status;
 	u64 ticks_per_sec;
 
<span class="p_del">-	status = uv_bios_freq_base(BIOS_FREQ_BASE_REALTIME_CLOCK,</span>
<span class="p_del">-					&amp;ticks_per_sec);</span>
<span class="p_add">+	status = uv_bios_freq_base(BIOS_FREQ_BASE_REALTIME_CLOCK, &amp;ticks_per_sec);</span>
<span class="p_add">+</span>
 	if (status != BIOS_STATUS_SUCCESS || ticks_per_sec &lt; 100000) {
<span class="p_del">-		printk(KERN_WARNING</span>
<span class="p_del">-			&quot;unable to determine platform RTC clock frequency, &quot;</span>
<span class="p_del">-			&quot;guessing.\n&quot;);</span>
<span class="p_del">-		/* BIOS gives wrong value for clock freq. so guess */</span>
<span class="p_add">+		pr_warn(&quot;UV: unable to determine platform RTC clock frequency, guessing.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* BIOS gives wrong value for clock frequency, so guess: */</span>
 		sn_rtc_cycles_per_second = 1000000000000UL / 30000UL;
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		sn_rtc_cycles_per_second = ticks_per_sec;
<span class="p_add">+	}</span>
 }
 
 /*
<span class="p_chunk">@@ -908,19 +936,19 @@</span> <span class="p_context"> static void uv_heartbeat(unsigned long ignored)</span>
 	struct timer_list *timer = &amp;uv_scir_info-&gt;timer;
 	unsigned char bits = uv_scir_info-&gt;state;
 
<span class="p_del">-	/* flip heartbeat bit */</span>
<span class="p_add">+	/* Flip heartbeat bit: */</span>
 	bits ^= SCIR_CPU_HEARTBEAT;
 
<span class="p_del">-	/* is this cpu idle? */</span>
<span class="p_add">+	/* Is this CPU idle? */</span>
 	if (idle_cpu(raw_smp_processor_id()))
 		bits &amp;= ~SCIR_CPU_ACTIVITY;
 	else
 		bits |= SCIR_CPU_ACTIVITY;
 
<span class="p_del">-	/* update system controller interface reg */</span>
<span class="p_add">+	/* Update system controller interface reg: */</span>
 	uv_set_scir_bits(bits);
 
<span class="p_del">-	/* enable next timer period */</span>
<span class="p_add">+	/* Enable next timer period: */</span>
 	mod_timer(timer, jiffies + SCIR_CPU_HB_INTERVAL);
 }
 
<span class="p_chunk">@@ -935,7 +963,7 @@</span> <span class="p_context"> static int uv_heartbeat_enable(unsigned int cpu)</span>
 		add_timer_on(timer, cpu);
 		uv_cpu_scir_info(cpu)-&gt;enabled = 1;
 
<span class="p_del">-		/* also ensure that boot cpu is enabled */</span>
<span class="p_add">+		/* Also ensure that boot CPU is enabled: */</span>
 		cpu = 0;
 	}
 	return 0;
<span class="p_chunk">@@ -968,9 +996,11 @@</span> <span class="p_context"> static __init int uv_init_heartbeat(void)</span>
 {
 	int cpu;
 
<span class="p_del">-	if (is_uv_system())</span>
<span class="p_add">+	if (is_uv_system()) {</span>
 		for_each_online_cpu(cpu)
 			uv_heartbeat_enable(cpu);
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -979,14 +1009,10 @@</span> <span class="p_context"> late_initcall(uv_init_heartbeat);</span>
 #endif /* !CONFIG_HOTPLUG_CPU */
 
 /* Direct Legacy VGA I/O traffic to designated IOH */
<span class="p_del">-int uv_set_vga_state(struct pci_dev *pdev, bool decode,</span>
<span class="p_del">-		      unsigned int command_bits, u32 flags)</span>
<span class="p_add">+int uv_set_vga_state(struct pci_dev *pdev, bool decode, unsigned int command_bits, u32 flags)</span>
 {
 	int domain, bus, rc;
 
<span class="p_del">-	PR_DEVEL(&quot;devfn %x decode %d cmd %x flags %d\n&quot;,</span>
<span class="p_del">-			pdev-&gt;devfn, decode, command_bits, flags);</span>
<span class="p_del">-</span>
 	if (!(flags &amp; PCI_VGA_STATE_CHANGE_BRIDGE))
 		return 0;
 
<span class="p_chunk">@@ -997,13 +1023,12 @@</span> <span class="p_context"> int uv_set_vga_state(struct pci_dev *pdev, bool decode,</span>
 	bus = pdev-&gt;bus-&gt;number;
 
 	rc = uv_bios_set_legacy_vga_target(decode, domain, bus);
<span class="p_del">-	PR_DEVEL(&quot;vga decode %d %x:%x, rc: %d\n&quot;, decode, domain, bus, rc);</span>
 
 	return rc;
 }
 
 /*
<span class="p_del">- * Called on each cpu to initialize the per_cpu UV data area.</span>
<span class="p_add">+ * Called on each CPU to initialize the per_cpu UV data area.</span>
  * FIXME: hotplug not supported yet
  */
 void uv_cpu_init(void)
<span class="p_chunk">@@ -1030,90 +1055,79 @@</span> <span class="p_context"> static void get_mn(struct mn *mnp)</span>
 	union uvh_rh_gam_config_mmr_u m_n_config;
 	union uv3h_gr0_gam_gr_config_u m_gr_config;
 
<span class="p_del">-	m_n_config.v = uv_read_local_mmr(UVH_RH_GAM_CONFIG_MMR);</span>
<span class="p_del">-	mnp-&gt;n_val = m_n_config.s.n_skt;</span>
<span class="p_add">+	/* Make sure the whole structure is well initialized: */</span>
<span class="p_add">+	memset(mnp, 0, sizeof(*mnp));</span>
<span class="p_add">+</span>
<span class="p_add">+	m_n_config.v	= uv_read_local_mmr(UVH_RH_GAM_CONFIG_MMR);</span>
<span class="p_add">+	mnp-&gt;n_val	= m_n_config.s.n_skt;</span>
<span class="p_add">+</span>
 	if (is_uv4_hub()) {
<span class="p_del">-		mnp-&gt;m_val = 0;</span>
<span class="p_del">-		mnp-&gt;n_lshift = 0;</span>
<span class="p_add">+		mnp-&gt;m_val	= 0;</span>
<span class="p_add">+		mnp-&gt;n_lshift	= 0;</span>
 	} else if (is_uv3_hub()) {
<span class="p_del">-		mnp-&gt;m_val = m_n_config.s3.m_skt;</span>
<span class="p_del">-		m_gr_config.v = uv_read_local_mmr(UV3H_GR0_GAM_GR_CONFIG);</span>
<span class="p_del">-		mnp-&gt;n_lshift = m_gr_config.s3.m_skt;</span>
<span class="p_add">+		mnp-&gt;m_val	= m_n_config.s3.m_skt;</span>
<span class="p_add">+		m_gr_config.v	= uv_read_local_mmr(UV3H_GR0_GAM_GR_CONFIG);</span>
<span class="p_add">+		mnp-&gt;n_lshift	= m_gr_config.s3.m_skt;</span>
 	} else if (is_uv2_hub()) {
<span class="p_del">-		mnp-&gt;m_val = m_n_config.s2.m_skt;</span>
<span class="p_del">-		mnp-&gt;n_lshift = mnp-&gt;m_val == 40 ? 40 : 39;</span>
<span class="p_add">+		mnp-&gt;m_val	= m_n_config.s2.m_skt;</span>
<span class="p_add">+		mnp-&gt;n_lshift	= mnp-&gt;m_val == 40 ? 40 : 39;</span>
 	} else if (is_uv1_hub()) {
<span class="p_del">-		mnp-&gt;m_val = m_n_config.s1.m_skt;</span>
<span class="p_del">-		mnp-&gt;n_lshift = mnp-&gt;m_val;</span>
<span class="p_add">+		mnp-&gt;m_val	= m_n_config.s1.m_skt;</span>
<span class="p_add">+		mnp-&gt;n_lshift	= mnp-&gt;m_val;</span>
 	}
 	mnp-&gt;m_shift = mnp-&gt;m_val ? 64 - mnp-&gt;m_val : 0;
 }
 
<span class="p_del">-void __init uv_init_hub_info(struct uv_hub_info_s *hub_info)</span>
<span class="p_add">+void __init uv_init_hub_info(struct uv_hub_info_s *hi)</span>
 {
<span class="p_del">-	struct mn mn = {0};	/* avoid unitialized warnings */</span>
 	union uvh_node_id_u node_id;
<span class="p_add">+	struct mn mn;</span>
 
 	get_mn(&amp;mn);
<span class="p_del">-	hub_info-&gt;m_val = mn.m_val;</span>
<span class="p_del">-	hub_info-&gt;n_val = mn.n_val;</span>
<span class="p_del">-	hub_info-&gt;m_shift = mn.m_shift;</span>
<span class="p_del">-	hub_info-&gt;n_lshift = mn.n_lshift ? mn.n_lshift : 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	hub_info-&gt;hub_revision = uv_hub_info-&gt;hub_revision;</span>
<span class="p_del">-	hub_info-&gt;pnode_mask = uv_cpuid.pnode_mask;</span>
<span class="p_del">-	hub_info-&gt;min_pnode = _min_pnode;</span>
<span class="p_del">-	hub_info-&gt;min_socket = _min_socket;</span>
<span class="p_del">-	hub_info-&gt;pnode_to_socket = _pnode_to_socket;</span>
<span class="p_del">-	hub_info-&gt;socket_to_node = _socket_to_node;</span>
<span class="p_del">-	hub_info-&gt;socket_to_pnode = _socket_to_pnode;</span>
<span class="p_del">-	hub_info-&gt;gr_table_len = _gr_table_len;</span>
<span class="p_del">-	hub_info-&gt;gr_table = _gr_table;</span>
<span class="p_del">-	hub_info-&gt;gpa_mask = mn.m_val ?</span>
<span class="p_add">+	hi-&gt;gpa_mask = mn.m_val ?</span>
 		(1UL &lt;&lt; (mn.m_val + mn.n_val)) - 1 :
 		(1UL &lt;&lt; uv_cpuid.gpa_shift) - 1;
 
<span class="p_del">-	node_id.v = uv_read_local_mmr(UVH_NODE_ID);</span>
<span class="p_del">-	hub_info-&gt;gnode_extra =</span>
<span class="p_del">-		(node_id.s.node_id &amp; ~((1 &lt;&lt; mn.n_val) - 1)) &gt;&gt; 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	hub_info-&gt;gnode_upper =</span>
<span class="p_del">-		((unsigned long)hub_info-&gt;gnode_extra &lt;&lt; mn.m_val);</span>
<span class="p_add">+	hi-&gt;m_val		= mn.m_val;</span>
<span class="p_add">+	hi-&gt;n_val		= mn.n_val;</span>
<span class="p_add">+	hi-&gt;m_shift		= mn.m_shift;</span>
<span class="p_add">+	hi-&gt;n_lshift		= mn.n_lshift ? mn.n_lshift : 0;</span>
<span class="p_add">+	hi-&gt;hub_revision	= uv_hub_info-&gt;hub_revision;</span>
<span class="p_add">+	hi-&gt;pnode_mask		= uv_cpuid.pnode_mask;</span>
<span class="p_add">+	hi-&gt;min_pnode		= _min_pnode;</span>
<span class="p_add">+	hi-&gt;min_socket		= _min_socket;</span>
<span class="p_add">+	hi-&gt;pnode_to_socket	= _pnode_to_socket;</span>
<span class="p_add">+	hi-&gt;socket_to_node	= _socket_to_node;</span>
<span class="p_add">+	hi-&gt;socket_to_pnode	= _socket_to_pnode;</span>
<span class="p_add">+	hi-&gt;gr_table_len	= _gr_table_len;</span>
<span class="p_add">+	hi-&gt;gr_table		= _gr_table;</span>
<span class="p_add">+</span>
<span class="p_add">+	node_id.v		= uv_read_local_mmr(UVH_NODE_ID);</span>
<span class="p_add">+	uv_cpuid.gnode_shift	= max_t(unsigned int, uv_cpuid.gnode_shift, mn.n_val);</span>
<span class="p_add">+	hi-&gt;gnode_extra		= (node_id.s.node_id &amp; ~((1 &lt;&lt; uv_cpuid.gnode_shift) - 1)) &gt;&gt; 1;</span>
<span class="p_add">+	hi-&gt;gnode_upper		= (unsigned long)hi-&gt;gnode_extra &lt;&lt; mn.m_val;</span>
 
 	if (uv_gp_table) {
<span class="p_del">-		hub_info-&gt;global_mmr_base = uv_gp_table-&gt;mmr_base;</span>
<span class="p_del">-		hub_info-&gt;global_mmr_shift = uv_gp_table-&gt;mmr_shift;</span>
<span class="p_del">-		hub_info-&gt;global_gru_base = uv_gp_table-&gt;gru_base;</span>
<span class="p_del">-		hub_info-&gt;global_gru_shift = uv_gp_table-&gt;gru_shift;</span>
<span class="p_del">-		hub_info-&gt;gpa_shift = uv_gp_table-&gt;gpa_shift;</span>
<span class="p_del">-		hub_info-&gt;gpa_mask = (1UL &lt;&lt; hub_info-&gt;gpa_shift) - 1;</span>
<span class="p_add">+		hi-&gt;global_mmr_base	= uv_gp_table-&gt;mmr_base;</span>
<span class="p_add">+		hi-&gt;global_mmr_shift	= uv_gp_table-&gt;mmr_shift;</span>
<span class="p_add">+		hi-&gt;global_gru_base	= uv_gp_table-&gt;gru_base;</span>
<span class="p_add">+		hi-&gt;global_gru_shift	= uv_gp_table-&gt;gru_shift;</span>
<span class="p_add">+		hi-&gt;gpa_shift		= uv_gp_table-&gt;gpa_shift;</span>
<span class="p_add">+		hi-&gt;gpa_mask		= (1UL &lt;&lt; hi-&gt;gpa_shift) - 1;</span>
 	} else {
<span class="p_del">-		hub_info-&gt;global_mmr_base =</span>
<span class="p_del">-			uv_read_local_mmr(UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR) &amp;</span>
<span class="p_del">-					~UV_MMR_ENABLE;</span>
<span class="p_del">-		hub_info-&gt;global_mmr_shift = _UV_GLOBAL_MMR64_PNODE_SHIFT;</span>
<span class="p_add">+		hi-&gt;global_mmr_base	= uv_read_local_mmr(UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR) &amp; ~UV_MMR_ENABLE;</span>
<span class="p_add">+		hi-&gt;global_mmr_shift	= _UV_GLOBAL_MMR64_PNODE_SHIFT;</span>
 	}
 
<span class="p_del">-	get_lowmem_redirect(</span>
<span class="p_del">-		&amp;hub_info-&gt;lowmem_remap_base, &amp;hub_info-&gt;lowmem_remap_top);</span>
<span class="p_del">-</span>
<span class="p_del">-	hub_info-&gt;apic_pnode_shift = uv_cpuid.socketid_shift;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* show system specific info */</span>
<span class="p_del">-	pr_info(&quot;UV: N:%d M:%d m_shift:%d n_lshift:%d\n&quot;,</span>
<span class="p_del">-		hub_info-&gt;n_val, hub_info-&gt;m_val,</span>
<span class="p_del">-		hub_info-&gt;m_shift, hub_info-&gt;n_lshift);</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_info(&quot;UV: gpa_mask/shift:0x%lx/%d pnode_mask:0x%x apic_pns:%d\n&quot;,</span>
<span class="p_del">-		hub_info-&gt;gpa_mask, hub_info-&gt;gpa_shift,</span>
<span class="p_del">-		hub_info-&gt;pnode_mask, hub_info-&gt;apic_pnode_shift);</span>
<span class="p_add">+	get_lowmem_redirect(&amp;hi-&gt;lowmem_remap_base, &amp;hi-&gt;lowmem_remap_top);</span>
 
<span class="p_del">-	pr_info(&quot;UV: mmr_base/shift:0x%lx/%ld gru_base/shift:0x%lx/%ld\n&quot;,</span>
<span class="p_del">-		hub_info-&gt;global_mmr_base, hub_info-&gt;global_mmr_shift,</span>
<span class="p_del">-		hub_info-&gt;global_gru_base, hub_info-&gt;global_gru_shift);</span>
<span class="p_add">+	hi-&gt;apic_pnode_shift = uv_cpuid.socketid_shift;</span>
 
<span class="p_del">-	pr_info(&quot;UV: gnode_upper:0x%lx gnode_extra:0x%x\n&quot;,</span>
<span class="p_del">-		hub_info-&gt;gnode_upper, hub_info-&gt;gnode_extra);</span>
<span class="p_add">+	/* Show system specific info: */</span>
<span class="p_add">+	pr_info(&quot;UV: N:%d M:%d m_shift:%d n_lshift:%d\n&quot;, hi-&gt;n_val, hi-&gt;m_val, hi-&gt;m_shift, hi-&gt;n_lshift);</span>
<span class="p_add">+	pr_info(&quot;UV: gpa_mask/shift:0x%lx/%d pnode_mask:0x%x apic_pns:%d\n&quot;, hi-&gt;gpa_mask, hi-&gt;gpa_shift, hi-&gt;pnode_mask, hi-&gt;apic_pnode_shift);</span>
<span class="p_add">+	pr_info(&quot;UV: mmr_base/shift:0x%lx/%ld gru_base/shift:0x%lx/%ld\n&quot;, hi-&gt;global_mmr_base, hi-&gt;global_mmr_shift, hi-&gt;global_gru_base, hi-&gt;global_gru_shift);</span>
<span class="p_add">+	pr_info(&quot;UV: gnode_upper:0x%lx gnode_extra:0x%x\n&quot;, hi-&gt;gnode_upper, hi-&gt;gnode_extra);</span>
 }
 
 static void __init decode_gam_params(unsigned long ptr)
<span class="p_chunk">@@ -1139,12 +1153,9 @@</span> <span class="p_context"> static void __init decode_gam_rng_tbl(unsigned long ptr)</span>
 	for (; gre-&gt;type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
 		if (!index) {
 			pr_info(&quot;UV: GAM Range Table...\n&quot;);
<span class="p_del">-			pr_info(&quot;UV:  # %20s %14s %5s %4s %5s %3s %2s\n&quot;,</span>
<span class="p_del">-				&quot;Range&quot;, &quot;&quot;, &quot;Size&quot;, &quot;Type&quot;, &quot;NASID&quot;,</span>
<span class="p_del">-				&quot;SID&quot;, &quot;PN&quot;);</span>
<span class="p_add">+			pr_info(&quot;UV:  # %20s %14s %5s %4s %5s %3s %2s\n&quot;, &quot;Range&quot;, &quot;&quot;, &quot;Size&quot;, &quot;Type&quot;, &quot;NASID&quot;, &quot;SID&quot;, &quot;PN&quot;);</span>
 		}
<span class="p_del">-		pr_info(</span>
<span class="p_del">-		&quot;UV: %2d: 0x%014lx-0x%014lx %5luG %3d   %04x  %02x %02x\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;UV: %2d: 0x%014lx-0x%014lx %5luG %3d   %04x  %02x %02x\n&quot;,</span>
 			index++,
 			(unsigned long)lgre &lt;&lt; UV_GAM_RANGE_SHFT,
 			(unsigned long)gre-&gt;limit &lt;&lt; UV_GAM_RANGE_SHFT,
<span class="p_chunk">@@ -1162,29 +1173,32 @@</span> <span class="p_context"> static void __init decode_gam_rng_tbl(unsigned long ptr)</span>
 		if (pnode_max &lt; gre-&gt;pnode)
 			pnode_max = gre-&gt;pnode;
 	}
<span class="p_del">-	_min_socket = sock_min;</span>
<span class="p_del">-	_max_socket = sock_max;</span>
<span class="p_del">-	_min_pnode = pnode_min;</span>
<span class="p_del">-	_max_pnode = pnode_max;</span>
<span class="p_del">-	_gr_table_len = index;</span>
<span class="p_del">-	pr_info(</span>
<span class="p_del">-	&quot;UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n&quot;,</span>
<span class="p_del">-		index, _min_socket, _max_socket, _min_pnode, _max_pnode);</span>
<span class="p_add">+	_min_socket	= sock_min;</span>
<span class="p_add">+	_max_socket	= sock_max;</span>
<span class="p_add">+	_min_pnode	= pnode_min;</span>
<span class="p_add">+	_max_pnode	= pnode_max;</span>
<span class="p_add">+	_gr_table_len	= index;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;UV: GRT: %d entries, sockets(min:%x,max:%x) pnodes(min:%x,max:%x)\n&quot;, index, _min_socket, _max_socket, _min_pnode, _max_pnode);</span>
 }
 
<span class="p_del">-static void __init decode_uv_systab(void)</span>
<span class="p_add">+static int __init decode_uv_systab(void)</span>
 {
 	struct uv_systab *st;
 	int i;
 
<span class="p_add">+	if (uv_hub_info-&gt;hub_revision &lt; UV4_HUB_REVISION_BASE)</span>
<span class="p_add">+		return 0;	/* No extended UVsystab required */</span>
<span class="p_add">+</span>
 	st = uv_systab;
<span class="p_del">-	if ((!st || st-&gt;revision &lt; UV_SYSTAB_VERSION_UV4) &amp;&amp; !is_uv4_hub())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	if (st-&gt;revision != UV_SYSTAB_VERSION_UV4_LATEST) {</span>
<span class="p_del">-		pr_crit(</span>
<span class="p_del">-		&quot;UV: BIOS UVsystab version(%x) mismatch, expecting(%x)\n&quot;,</span>
<span class="p_del">-			st-&gt;revision, UV_SYSTAB_VERSION_UV4_LATEST);</span>
<span class="p_del">-		BUG();</span>
<span class="p_add">+	if ((!st) || (st-&gt;revision &lt; UV_SYSTAB_VERSION_UV4_LATEST)) {</span>
<span class="p_add">+		int rev = st ? st-&gt;revision : 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_err(&quot;UV: BIOS UVsystab version(%x) mismatch, expecting(%x)\n&quot;, rev, UV_SYSTAB_VERSION_UV4_LATEST);</span>
<span class="p_add">+		pr_err(&quot;UV: Cannot support UV operations, switching to generic PC\n&quot;);</span>
<span class="p_add">+		uv_system_type = UV_NONE;</span>
<span class="p_add">+</span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
 	for (i = 0; st-&gt;entry[i].type != UV_SYSTAB_TYPE_UNUSED; i++) {
<span class="p_chunk">@@ -1205,10 +1219,11 @@</span> <span class="p_context"> static void __init decode_uv_systab(void)</span>
 			break;
 		}
 	}
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_del">- * Setup physical blade translations from UVH_NODE_PRESENT_TABLE</span>
<span class="p_add">+ * Set up physical blade translations from UVH_NODE_PRESENT_TABLE</span>
  * .. NB: UVH_NODE_PRESENT_TABLE is going away,
  * .. being replaced by GAM Range Table
  */
<span class="p_chunk">@@ -1244,14 +1259,13 @@</span> <span class="p_context"> static void __init build_socket_tables(void)</span>
 	if (!gre) {
 		if (is_uv1_hub() || is_uv2_hub() || is_uv3_hub()) {
 			pr_info(&quot;UV: No UVsystab socket table, ignoring\n&quot;);
<span class="p_del">-			return;		/* not required */</span>
<span class="p_add">+			return;</span>
 		}
<span class="p_del">-		pr_crit(</span>
<span class="p_del">-		&quot;UV: Error: UVsystab address translations not available!\n&quot;);</span>
<span class="p_add">+		pr_crit(&quot;UV: Error: UVsystab address translations not available!\n&quot;);</span>
 		BUG();
 	}
 
<span class="p_del">-	/* build socket id -&gt; node id, pnode */</span>
<span class="p_add">+	/* Build socket id -&gt; node id, pnode */</span>
 	num = maxsock - minsock + 1;
 	bytes = num * sizeof(_socket_to_node[0]);
 	_socket_to_node = kmalloc(bytes, GFP_KERNEL);
<span class="p_chunk">@@ -1268,27 +1282,27 @@</span> <span class="p_context"> static void __init build_socket_tables(void)</span>
 	for (i = 0; i &lt; nump; i++)
 		_pnode_to_socket[i] = SOCK_EMPTY;
 
<span class="p_del">-	/* fill in pnode/node/addr conversion list values */</span>
<span class="p_add">+	/* Fill in pnode/node/addr conversion list values: */</span>
 	pr_info(&quot;UV: GAM Building socket/pnode conversion tables\n&quot;);
 	for (; gre-&gt;type != UV_GAM_RANGE_TYPE_UNUSED; gre++) {
 		if (gre-&gt;type == UV_GAM_RANGE_TYPE_HOLE)
 			continue;
 		i = gre-&gt;sockid - minsock;
<span class="p_add">+		/* Duplicate: */</span>
 		if (_socket_to_pnode[i] != SOCK_EMPTY)
<span class="p_del">-			continue;	/* duplicate */</span>
<span class="p_add">+			continue;</span>
 		_socket_to_pnode[i] = gre-&gt;pnode;
 
 		i = gre-&gt;pnode - minpnode;
 		_pnode_to_socket[i] = gre-&gt;sockid;
 
<span class="p_del">-		pr_info(</span>
<span class="p_del">-		&quot;UV: sid:%02x type:%d nasid:%04x pn:%02x pn2s:%2x\n&quot;,</span>
<span class="p_add">+		pr_info(&quot;UV: sid:%02x type:%d nasid:%04x pn:%02x pn2s:%2x\n&quot;,</span>
 			gre-&gt;sockid, gre-&gt;type, gre-&gt;nasid,
 			_socket_to_pnode[gre-&gt;sockid - minsock],
 			_pnode_to_socket[gre-&gt;pnode - minpnode]);
 	}
 
<span class="p_del">-	/* Set socket -&gt; node values */</span>
<span class="p_add">+	/* Set socket -&gt; node values: */</span>
 	lnid = -1;
 	for_each_present_cpu(cpu) {
 		int nid = cpu_to_node(cpu);
<span class="p_chunk">@@ -1304,7 +1318,7 @@</span> <span class="p_context"> static void __init build_socket_tables(void)</span>
 			sockid, apicid, nid);
 	}
 
<span class="p_del">-	/* Setup physical blade to pnode translation from GAM Range Table */</span>
<span class="p_add">+	/* Set up physical blade to pnode translation from GAM Range Table: */</span>
 	bytes = num_possible_nodes() * sizeof(_node_to_pnode[0]);
 	_node_to_pnode = kmalloc(bytes, GFP_KERNEL);
 	BUG_ON(!_node_to_pnode);
<span class="p_chunk">@@ -1314,8 +1328,7 @@</span> <span class="p_context"> static void __init build_socket_tables(void)</span>
 
 		for (sockid = minsock; sockid &lt;= maxsock; sockid++) {
 			if (lnid == _socket_to_node[sockid - minsock]) {
<span class="p_del">-				_node_to_pnode[lnid] =</span>
<span class="p_del">-					_socket_to_pnode[sockid - minsock];</span>
<span class="p_add">+				_node_to_pnode[lnid] = _socket_to_pnode[sockid - minsock];</span>
 				break;
 			}
 		}
<span class="p_chunk">@@ -1332,8 +1345,7 @@</span> <span class="p_context"> static void __init build_socket_tables(void)</span>
 	pr_info(&quot;UV: Checking socket-&gt;node/pnode for identity maps\n&quot;);
 	if (minsock == 0) {
 		for (i = 0; i &lt; num; i++)
<span class="p_del">-			if (_socket_to_node[i] == SOCK_EMPTY ||</span>
<span class="p_del">-				i != _socket_to_node[i])</span>
<span class="p_add">+			if (_socket_to_node[i] == SOCK_EMPTY || i != _socket_to_node[i])</span>
 				break;
 		if (i &gt;= num) {
 			kfree(_socket_to_node);
<span class="p_chunk">@@ -1354,7 +1366,7 @@</span> <span class="p_context"> static void __init build_socket_tables(void)</span>
 	}
 }
 
<span class="p_del">-void __init uv_system_init(void)</span>
<span class="p_add">+static void __init uv_system_init_hub(void)</span>
 {
 	struct uv_hub_info_s hub_info = {0};
 	int bytes, cpu, nodeid;
<span class="p_chunk">@@ -1372,8 +1384,13 @@</span> <span class="p_context"> void __init uv_system_init(void)</span>
 
 	map_low_mmrs();
 
<span class="p_del">-	uv_bios_init();			/* get uv_systab for decoding */</span>
<span class="p_del">-	decode_uv_systab();</span>
<span class="p_add">+	/* Get uv_systab for decoding: */</span>
<span class="p_add">+	uv_bios_init();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If there&#39;s an UVsystab problem then abort UV init: */</span>
<span class="p_add">+	if (decode_uv_systab() &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	build_socket_tables();
 	build_uv_gr_table();
 	uv_init_hub_info(&amp;hub_info);
<span class="p_chunk">@@ -1381,14 +1398,10 @@</span> <span class="p_context"> void __init uv_system_init(void)</span>
 	if (!_node_to_pnode)
 		boot_init_possible_blades(&amp;hub_info);
 
<span class="p_del">-	/* uv_num_possible_blades() is really the hub count */</span>
<span class="p_del">-	pr_info(&quot;UV: Found %d hubs, %d nodes, %d cpus\n&quot;,</span>
<span class="p_del">-			uv_num_possible_blades(),</span>
<span class="p_del">-			num_possible_nodes(),</span>
<span class="p_del">-			num_possible_cpus());</span>
<span class="p_add">+	/* uv_num_possible_blades() is really the hub count: */</span>
<span class="p_add">+	pr_info(&quot;UV: Found %d hubs, %d nodes, %d CPUs\n&quot;, uv_num_possible_blades(), num_possible_nodes(), num_possible_cpus());</span>
 
<span class="p_del">-	uv_bios_get_sn_info(0, &amp;uv_type, &amp;sn_partition_id, &amp;sn_coherency_id,</span>
<span class="p_del">-			    &amp;sn_region_size, &amp;system_serial_number);</span>
<span class="p_add">+	uv_bios_get_sn_info(0, &amp;uv_type, &amp;sn_partition_id, &amp;sn_coherency_id, &amp;sn_region_size, &amp;system_serial_number);</span>
 	hub_info.coherency_domain_number = sn_coherency_id;
 	uv_rtc_init();
 
<span class="p_chunk">@@ -1401,33 +1414,31 @@</span> <span class="p_context"> void __init uv_system_init(void)</span>
 		struct uv_hub_info_s *new_hub;
 
 		if (__uv_hub_info_list[nodeid]) {
<span class="p_del">-			pr_err(&quot;UV: Node %d UV HUB already initialized!?\n&quot;,</span>
<span class="p_del">-				nodeid);</span>
<span class="p_add">+			pr_err(&quot;UV: Node %d UV HUB already initialized!?\n&quot;, nodeid);</span>
 			BUG();
 		}
 
 		/* Allocate new per hub info list */
<span class="p_del">-		new_hub = (nodeid == 0) ?</span>
<span class="p_del">-			&amp;uv_hub_info_node0 :</span>
<span class="p_del">-			kzalloc_node(bytes, GFP_KERNEL, nodeid);</span>
<span class="p_add">+		new_hub = (nodeid == 0) ?  &amp;uv_hub_info_node0 : kzalloc_node(bytes, GFP_KERNEL, nodeid);</span>
 		BUG_ON(!new_hub);
 		__uv_hub_info_list[nodeid] = new_hub;
 		new_hub = uv_hub_info_list(nodeid);
 		BUG_ON(!new_hub);
 		*new_hub = hub_info;
 
<span class="p_del">-		/* Use information from GAM table if available */</span>
<span class="p_add">+		/* Use information from GAM table if available: */</span>
 		if (_node_to_pnode)
 			new_hub-&gt;pnode = _node_to_pnode[nodeid];
<span class="p_del">-		else	/* Fill in during cpu loop */</span>
<span class="p_add">+		else /* Or fill in during CPU loop: */</span>
 			new_hub-&gt;pnode = 0xffff;
<span class="p_add">+</span>
 		new_hub-&gt;numa_blade_id = uv_node_to_blade_id(nodeid);
 		new_hub-&gt;memory_nid = -1;
 		new_hub-&gt;nr_possible_cpus = 0;
 		new_hub-&gt;nr_online_cpus = 0;
 	}
 
<span class="p_del">-	/* Initialize per cpu info */</span>
<span class="p_add">+	/* Initialize per CPU info: */</span>
 	for_each_possible_cpu(cpu) {
 		int apicid = per_cpu(x86_cpu_to_apicid, cpu);
 		int numa_node_id;
<span class="p_chunk">@@ -1438,22 +1449,24 @@</span> <span class="p_context"> void __init uv_system_init(void)</span>
 		pnode = uv_apicid_to_pnode(apicid);
 
 		uv_cpu_info_per(cpu)-&gt;p_uv_hub_info = uv_hub_info_list(nodeid);
<span class="p_del">-		uv_cpu_info_per(cpu)-&gt;blade_cpu_id =</span>
<span class="p_del">-			uv_cpu_hub_info(cpu)-&gt;nr_possible_cpus++;</span>
<span class="p_add">+		uv_cpu_info_per(cpu)-&gt;blade_cpu_id = uv_cpu_hub_info(cpu)-&gt;nr_possible_cpus++;</span>
 		if (uv_cpu_hub_info(cpu)-&gt;memory_nid == -1)
 			uv_cpu_hub_info(cpu)-&gt;memory_nid = cpu_to_node(cpu);
<span class="p_del">-		if (nodeid != numa_node_id &amp;&amp;	/* init memoryless node */</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Init memoryless node: */</span>
<span class="p_add">+		if (nodeid != numa_node_id &amp;&amp;</span>
 		    uv_hub_info_list(numa_node_id)-&gt;pnode == 0xffff)
 			uv_hub_info_list(numa_node_id)-&gt;pnode = pnode;
 		else if (uv_cpu_hub_info(cpu)-&gt;pnode == 0xffff)
 			uv_cpu_hub_info(cpu)-&gt;pnode = pnode;
<span class="p_add">+</span>
 		uv_cpu_scir_info(cpu)-&gt;offset = uv_scir_offset(apicid);
 	}
 
 	for_each_node(nodeid) {
 		unsigned short pnode = uv_hub_info_list(nodeid)-&gt;pnode;
 
<span class="p_del">-		/* Add pnode info for pre-GAM list nodes without cpus */</span>
<span class="p_add">+		/* Add pnode info for pre-GAM list nodes without CPUs: */</span>
 		if (pnode == 0xffff) {
 			unsigned long paddr;
 
<span class="p_chunk">@@ -1479,15 +1492,30 @@</span> <span class="p_context"> void __init uv_system_init(void)</span>
 	uv_scir_register_cpu_notifier();
 	proc_mkdir(&quot;sgi_uv&quot;, NULL);
 
<span class="p_del">-	/* register Legacy VGA I/O redirection handler */</span>
<span class="p_add">+	/* Register Legacy VGA I/O redirection handler: */</span>
 	pci_register_set_vga_state(uv_set_vga_state);
 
 	/*
 	 * For a kdump kernel the reset must be BOOT_ACPI, not BOOT_EFI, as
<span class="p_del">-	 * EFI is not enabled in the kdump kernel.</span>
<span class="p_add">+	 * EFI is not enabled in the kdump kernel:</span>
 	 */
 	if (is_kdump_kernel())
 		reboot_type = BOOT_ACPI;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * There is a small amount of UV specific code needed to initialize a</span>
<span class="p_add">+ * UV system that does not have a &quot;UV HUB&quot; (referred to as &quot;hubless&quot;).</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init uv_system_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(!is_uv_system() &amp;&amp; !is_uv_hubless()))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_uv_system())</span>
<span class="p_add">+		uv_system_init_hub();</span>
<span class="p_add">+	else</span>
<span class="p_add">+		uv_nmi_setup_hubless();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 apic_driver(apic_x2apic_uv_x);
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 46732dc3b73c..386c7f713c2a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -1341,8 +1341,7 @@</span> <span class="p_context"> void __init native_smp_prepare_cpus(unsigned int max_cpus)</span>
 	pr_info(&quot;CPU0: &quot;);
 	print_cpu_info(&amp;cpu_data(0));
 
<span class="p_del">-	if (is_uv_system())</span>
<span class="p_del">-		uv_system_init();</span>
<span class="p_add">+	uv_system_init();</span>
 
 	set_mtrr_aps_delayed_init();
 
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">index 90e4f2a6625b..a7dbec4dce27 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_chunk">@@ -5,14 +5,12 @@</span> <span class="p_context"> obj-$(subst m,y,$(CONFIG_MMC_SDHCI_PCI)) += platform_mrfld_sd.o</span>
 # WiFi
 obj-$(subst m,y,$(CONFIG_BRCMFMAC_SDIO)) += platform_bcm43xx.o
 # IPC Devices
<span class="p_del">-obj-y += platform_ipc.o</span>
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic.o
 obj-$(subst m,y,$(CONFIG_SND_MFLD_MACHINE)) += platform_msic_audio.o
 obj-$(subst m,y,$(CONFIG_GPIO_MSIC)) += platform_msic_gpio.o
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic_ocd.o
 obj-$(subst m,y,$(CONFIG_MFD_INTEL_MSIC)) += platform_msic_battery.o
 obj-$(subst m,y,$(CONFIG_INTEL_MID_POWER_BUTTON)) += platform_msic_power_btn.o
<span class="p_del">-obj-$(subst m,y,$(CONFIG_GPIO_INTEL_PMIC)) += platform_pmic_gpio.o</span>
 obj-$(subst m,y,$(CONFIG_INTEL_MFLD_THERMAL)) += platform_msic_thermal.o
 # SPI Devices
 obj-$(subst m,y,$(CONFIG_SPI_SPIDEV)) += platform_mrfld_spidev.o
<span class="p_chunk">@@ -28,4 +26,5 @@</span> <span class="p_context"> obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_pcal9555a.o</span>
 obj-$(subst m,y,$(CONFIG_GPIO_PCA953X)) += platform_tca6416.o
 # MISC Devices
 obj-$(subst m,y,$(CONFIG_KEYBOARD_GPIO)) += platform_gpio_keys.o
<span class="p_add">+obj-$(subst m,y,$(CONFIG_RTC_DRV_CMOS)) += platform_mrfld_rtc.o</span>
 obj-$(subst m,y,$(CONFIG_INTEL_MID_WATCHDOG)) += platform_mrfld_wdt.o
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c b/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c</span>
<span class="p_header">index 52534ec29765..74283875c7e8 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_gpio_keys.c</span>
<span class="p_chunk">@@ -32,6 +32,9 @@</span> <span class="p_context"> static struct gpio_keys_button gpio_button[] = {</span>
 	{SW_LID,		-1, 1, &quot;lid_switch&quot;,	EV_SW,  0, 20},
 	{KEY_VOLUMEUP,		-1, 1, &quot;vol_up&quot;,	EV_KEY, 0, 20},
 	{KEY_VOLUMEDOWN,	-1, 1, &quot;vol_down&quot;,	EV_KEY, 0, 20},
<span class="p_add">+	{KEY_MUTE,		-1, 1, &quot;mute_enable&quot;,	EV_KEY, 0, 20},</span>
<span class="p_add">+	{KEY_VOLUMEUP,		-1, 1, &quot;volume_up&quot;,	EV_KEY, 0, 20},</span>
<span class="p_add">+	{KEY_VOLUMEDOWN,	-1, 1, &quot;volume_down&quot;,	EV_KEY, 0, 20},</span>
 	{KEY_CAMERA,		-1, 1, &quot;camera_full&quot;,	EV_KEY, 0, 20},
 	{KEY_CAMERA_FOCUS,	-1, 1, &quot;camera_half&quot;,	EV_KEY, 0, 20},
 	{SW_KEYPAD_SLIDE,	-1, 1, &quot;MagSw1&quot;,	EV_SW,  0, 20},
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_ipc.c b/arch/x86/platform/intel-mid/device_libs/platform_ipc.c</span>
deleted file mode 100644
<span class="p_header">index a84b73d6c4a0..000000000000</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_ipc.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,68 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * platform_ipc.c: IPC platform library file</span>
<span class="p_del">- *</span>
<span class="p_del">- * (C) Copyright 2013 Intel Corporation</span>
<span class="p_del">- * Author: Sathyanarayanan Kuppuswamy &lt;sathyanarayanan.kuppuswamy@intel.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or</span>
<span class="p_del">- * modify it under the terms of the GNU General Public License</span>
<span class="p_del">- * as published by the Free Software Foundation; version 2</span>
<span class="p_del">- * of the License.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/init.h&gt;</span>
<span class="p_del">-#include &lt;linux/kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/sfi.h&gt;</span>
<span class="p_del">-#include &lt;linux/gpio.h&gt;</span>
<span class="p_del">-#include &lt;asm/intel-mid.h&gt;</span>
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-void __init ipc_device_handler(struct sfi_device_table_entry *pentry,</span>
<span class="p_del">-				struct devs_id *dev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct platform_device *pdev;</span>
<span class="p_del">-	void *pdata = NULL;</span>
<span class="p_del">-	static struct resource res __initdata = {</span>
<span class="p_del">-		.name = &quot;IRQ&quot;,</span>
<span class="p_del">-		.flags = IORESOURCE_IRQ,</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_debug(&quot;IPC bus, name = %16.16s, irq = 0x%2x\n&quot;,</span>
<span class="p_del">-		pentry-&gt;name, pentry-&gt;irq);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to call platform init of IPC devices to fill misc_pdata</span>
<span class="p_del">-	 * structure. It will be used in msic_init for initialization.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (dev != NULL)</span>
<span class="p_del">-		pdata = dev-&gt;get_platform_data(pentry);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * On Medfield the platform device creation is handled by the MSIC</span>
<span class="p_del">-	 * MFD driver so we don&#39;t need to do it here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (intel_mid_has_msic())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	pdev = platform_device_alloc(pentry-&gt;name, 0);</span>
<span class="p_del">-	if (pdev == NULL) {</span>
<span class="p_del">-		pr_err(&quot;out of memory for SFI platform device &#39;%s&#39;.\n&quot;,</span>
<span class="p_del">-			pentry-&gt;name);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	res.start = pentry-&gt;irq;</span>
<span class="p_del">-	platform_device_add_resources(pdev, &amp;res, 1);</span>
<span class="p_del">-</span>
<span class="p_del">-	pdev-&gt;dev.platform_data = pdata;</span>
<span class="p_del">-	intel_scu_device_register(pdev);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct devs_id pmic_audio_dev_id __initconst = {</span>
<span class="p_del">-	.name = &quot;pmic_audio&quot;,</span>
<span class="p_del">-	.type = SFI_DEV_TYPE_IPC,</span>
<span class="p_del">-	.delay = 1,</span>
<span class="p_del">-	.device_handler = &amp;ipc_device_handler,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-sfi_device(pmic_audio_dev_id);</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_ipc.h b/arch/x86/platform/intel-mid/device_libs/platform_ipc.h</span>
deleted file mode 100644
<span class="p_header">index 79bb09d4f718..000000000000</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_ipc.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,18 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * platform_ipc.h: IPC platform library header file</span>
<span class="p_del">- *</span>
<span class="p_del">- * (C) Copyright 2013 Intel Corporation</span>
<span class="p_del">- * Author: Sathyanarayanan Kuppuswamy &lt;sathyanarayanan.kuppuswamy@intel.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or</span>
<span class="p_del">- * modify it under the terms of the GNU General Public License</span>
<span class="p_del">- * as published by the Free Software Foundation; version 2</span>
<span class="p_del">- * of the License.</span>
<span class="p_del">- */</span>
<span class="p_del">-#ifndef _PLATFORM_IPC_H_</span>
<span class="p_del">-#define _PLATFORM_IPC_H_</span>
<span class="p_del">-</span>
<span class="p_del">-void __init</span>
<span class="p_del">-ipc_device_handler(struct sfi_device_table_entry *pentry, struct devs_id *dev);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_rtc.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_rtc.c</span>
new file mode 100644
<span class="p_header">index 000000000000..3135416df037</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_rtc.c</span>
<span class="p_chunk">@@ -0,0 +1,48 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Intel Merrifield legacy RTC initialization file</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (C) Copyright 2017 Intel Corporation</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Andy Shevchenko &lt;andriy.shevchenko@linux.intel.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ * as published by the Free Software Foundation; version 2</span>
<span class="p_add">+ * of the License.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/hw_irq.h&gt;</span>
<span class="p_add">+#include &lt;asm/intel-mid.h&gt;</span>
<span class="p_add">+#include &lt;asm/io_apic.h&gt;</span>
<span class="p_add">+#include &lt;asm/time.h&gt;</span>
<span class="p_add">+#include &lt;asm/x86_init.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mrfld_legacy_rtc_alloc_irq(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct irq_alloc_info info;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!x86_platform.legacy.rtc)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ioapic_set_alloc_attr(&amp;info, NUMA_NO_NODE, 1, 0);</span>
<span class="p_add">+	ret = mp_map_gsi_to_irq(RTC_IRQ, IOAPIC_MAP_ALLOC, &amp;info);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		pr_info(&quot;Failed to allocate RTC interrupt. Disabling RTC\n&quot;);</span>
<span class="p_add">+		x86_platform.legacy.rtc = 0;</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mrfld_legacy_rtc_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_TANGIER)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mrfld_legacy_rtc_alloc_irq();</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(mrfld_legacy_rtc_init);</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c</span>
<span class="p_header">index 3f1f1c77d090..86edd1e941eb 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_wdt.c</span>
<span class="p_chunk">@@ -28,9 +28,9 @@</span> <span class="p_context"> static struct platform_device wdt_dev = {</span>
 
 static int tangier_probe(struct platform_device *pdev)
 {
<span class="p_del">-	int gsi;</span>
 	struct irq_alloc_info info;
 	struct intel_mid_wdt_pdata *pdata = pdev-&gt;dev.platform_data;
<span class="p_add">+	int gsi, irq;</span>
 
 	if (!pdata)
 		return -EINVAL;
<span class="p_chunk">@@ -38,10 +38,10 @@</span> <span class="p_context"> static int tangier_probe(struct platform_device *pdev)</span>
 	/* IOAPIC builds identity mapping between GSI and IRQ on MID */
 	gsi = pdata-&gt;irq;
 	ioapic_set_alloc_attr(&amp;info, cpu_to_node(0), 1, 0);
<span class="p_del">-	if (mp_map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC, &amp;info) &lt;= 0) {</span>
<span class="p_del">-		dev_warn(&amp;pdev-&gt;dev, &quot;cannot find interrupt %d in ioapic\n&quot;,</span>
<span class="p_del">-			 gsi);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	irq = mp_map_gsi_to_irq(gsi, IOAPIC_MAP_ALLOC, &amp;info);</span>
<span class="p_add">+	if (irq &lt; 0) {</span>
<span class="p_add">+		dev_warn(&amp;pdev-&gt;dev, &quot;cannot find interrupt %d in ioapic\n&quot;, gsi);</span>
<span class="p_add">+		return irq;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -82,4 +82,4 @@</span> <span class="p_context"> static int __init register_mid_wdt(void)</span>
 
 	return 0;
 }
<span class="p_del">-rootfs_initcall(register_mid_wdt);</span>
<span class="p_add">+arch_initcall(register_mid_wdt);</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_audio.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_audio.c</span>
<span class="p_header">index cb3490ecb341..d4dc744dd5a5 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_audio.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_audio.c</span>
<span class="p_chunk">@@ -20,7 +20,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/intel-mid.h&gt;
 
 #include &quot;platform_msic.h&quot;
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
 
 static void *msic_audio_platform_data(void *info)
 {
<span class="p_chunk">@@ -40,8 +39,8 @@</span> <span class="p_context"> static const struct devs_id msic_audio_dev_id __initconst = {</span>
 	.name = &quot;msic_audio&quot;,
 	.type = SFI_DEV_TYPE_IPC,
 	.delay = 1,
<span class="p_add">+	.msic = 1,</span>
 	.get_platform_data = &amp;msic_audio_platform_data,
<span class="p_del">-	.device_handler = &amp;ipc_device_handler,</span>
 };
 
 sfi_device(msic_audio_dev_id);
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_battery.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_battery.c</span>
<span class="p_header">index 4f72193939a6..5c3e9919633f 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_battery.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_battery.c</span>
<span class="p_chunk">@@ -19,7 +19,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/intel-mid.h&gt;
 
 #include &quot;platform_msic.h&quot;
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
 
 static void __init *msic_battery_platform_data(void *info)
 {
<span class="p_chunk">@@ -30,8 +29,8 @@</span> <span class="p_context"> static const struct devs_id msic_battery_dev_id __initconst = {</span>
 	.name = &quot;msic_battery&quot;,
 	.type = SFI_DEV_TYPE_IPC,
 	.delay = 1,
<span class="p_add">+	.msic = 1,</span>
 	.get_platform_data = &amp;msic_battery_platform_data,
<span class="p_del">-	.device_handler = &amp;ipc_device_handler,</span>
 };
 
 sfi_device(msic_battery_dev_id);
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c</span>
<span class="p_header">index 70de5b531ba0..9fdb88d460d7 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_gpio.c</span>
<span class="p_chunk">@@ -20,7 +20,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/intel-mid.h&gt;
 
 #include &quot;platform_msic.h&quot;
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
 
 static void __init *msic_gpio_platform_data(void *info)
 {
<span class="p_chunk">@@ -41,8 +40,8 @@</span> <span class="p_context"> static const struct devs_id msic_gpio_dev_id __initconst = {</span>
 	.name = &quot;msic_gpio&quot;,
 	.type = SFI_DEV_TYPE_IPC,
 	.delay = 1,
<span class="p_add">+	.msic = 1,</span>
 	.get_platform_data = &amp;msic_gpio_platform_data,
<span class="p_del">-	.device_handler = &amp;ipc_device_handler,</span>
 };
 
 sfi_device(msic_gpio_dev_id);
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.c</span>
<span class="p_header">index 3d7c2011b6cf..7ae37cdbf256 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_ocd.c</span>
<span class="p_chunk">@@ -20,7 +20,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/intel-mid.h&gt;
 
 #include &quot;platform_msic.h&quot;
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
 
 static void __init *msic_ocd_platform_data(void *info)
 {
<span class="p_chunk">@@ -42,8 +41,8 @@</span> <span class="p_context"> static const struct devs_id msic_ocd_dev_id __initconst = {</span>
 	.name = &quot;msic_ocd&quot;,
 	.type = SFI_DEV_TYPE_IPC,
 	.delay = 1,
<span class="p_add">+	.msic = 1,</span>
 	.get_platform_data = &amp;msic_ocd_platform_data,
<span class="p_del">-	.device_handler = &amp;ipc_device_handler,</span>
 };
 
 sfi_device(msic_ocd_dev_id);
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c</span>
<span class="p_header">index 038f618fbc52..96809b98cf69 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_power_btn.c</span>
<span class="p_chunk">@@ -18,7 +18,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/intel-mid.h&gt;
 
 #include &quot;platform_msic.h&quot;
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
 
 static void __init *msic_power_btn_platform_data(void *info)
 {
<span class="p_chunk">@@ -29,8 +28,8 @@</span> <span class="p_context"> static const struct devs_id msic_power_btn_dev_id __initconst = {</span>
 	.name = &quot;msic_power_btn&quot;,
 	.type = SFI_DEV_TYPE_IPC,
 	.delay = 1,
<span class="p_add">+	.msic = 1,</span>
 	.get_platform_data = &amp;msic_power_btn_platform_data,
<span class="p_del">-	.device_handler = &amp;ipc_device_handler,</span>
 };
 
 sfi_device(msic_power_btn_dev_id);
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c</span>
<span class="p_header">index 114a5755b1e4..3e4167d246cd 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_msic_thermal.c</span>
<span class="p_chunk">@@ -19,7 +19,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/intel-mid.h&gt;
 
 #include &quot;platform_msic.h&quot;
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
 
 static void __init *msic_thermal_platform_data(void *info)
 {
<span class="p_chunk">@@ -30,8 +29,8 @@</span> <span class="p_context"> static const struct devs_id msic_thermal_dev_id __initconst = {</span>
 	.name = &quot;msic_thermal&quot;,
 	.type = SFI_DEV_TYPE_IPC,
 	.delay = 1,
<span class="p_add">+	.msic = 1,</span>
 	.get_platform_data = &amp;msic_thermal_platform_data,
<span class="p_del">-	.device_handler = &amp;ipc_device_handler,</span>
 };
 
 sfi_device(msic_thermal_dev_id);
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c b/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c</span>
deleted file mode 100644
<span class="p_header">index e30cb62e3300..000000000000</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_pmic_gpio.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,54 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * platform_pmic_gpio.c: PMIC GPIO platform data initialization file</span>
<span class="p_del">- *</span>
<span class="p_del">- * (C) Copyright 2013 Intel Corporation</span>
<span class="p_del">- * Author: Sathyanarayanan Kuppuswamy &lt;sathyanarayanan.kuppuswamy@intel.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or</span>
<span class="p_del">- * modify it under the terms of the GNU General Public License</span>
<span class="p_del">- * as published by the Free Software Foundation; version 2</span>
<span class="p_del">- * of the License.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/scatterlist.h&gt;</span>
<span class="p_del">-#include &lt;linux/gpio.h&gt;</span>
<span class="p_del">-#include &lt;linux/init.h&gt;</span>
<span class="p_del">-#include &lt;linux/sfi.h&gt;</span>
<span class="p_del">-#include &lt;linux/intel_pmic_gpio.h&gt;</span>
<span class="p_del">-#include &lt;asm/intel-mid.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &quot;platform_ipc.h&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init *pmic_gpio_platform_data(void *info)</span>
<span class="p_del">-{</span>
<span class="p_del">-	static struct intel_pmic_gpio_platform_data pmic_gpio_pdata;</span>
<span class="p_del">-	int gpio_base = get_gpio_by_name(&quot;pmic_gpio_base&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (gpio_base &lt; 0)</span>
<span class="p_del">-		gpio_base = 64;</span>
<span class="p_del">-	pmic_gpio_pdata.gpio_base = gpio_base;</span>
<span class="p_del">-	pmic_gpio_pdata.irq_base = gpio_base + INTEL_MID_IRQ_OFFSET;</span>
<span class="p_del">-	pmic_gpio_pdata.gpiointr = 0xffffeff8;</span>
<span class="p_del">-</span>
<span class="p_del">-	return &amp;pmic_gpio_pdata;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct devs_id pmic_gpio_spi_dev_id __initconst = {</span>
<span class="p_del">-	.name = &quot;pmic_gpio&quot;,</span>
<span class="p_del">-	.type = SFI_DEV_TYPE_SPI,</span>
<span class="p_del">-	.delay = 1,</span>
<span class="p_del">-	.get_platform_data = &amp;pmic_gpio_platform_data,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct devs_id pmic_gpio_ipc_dev_id __initconst = {</span>
<span class="p_del">-	.name = &quot;pmic_gpio&quot;,</span>
<span class="p_del">-	.type = SFI_DEV_TYPE_IPC,</span>
<span class="p_del">-	.delay = 1,</span>
<span class="p_del">-	.get_platform_data = &amp;pmic_gpio_platform_data,</span>
<span class="p_del">-	.device_handler = &amp;ipc_device_handler</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-sfi_device(pmic_gpio_spi_dev_id);</span>
<span class="p_del">-sfi_device(pmic_gpio_ipc_dev_id);</span>
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/mrfld.c b/arch/x86/platform/intel-mid/mrfld.c</span>
<span class="p_header">index e0607c77a1bd..ae7bdeb0e507 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/mrfld.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/mrfld.c</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> static unsigned long __init tangier_calibrate_tsc(void)</span>
 static void __init tangier_arch_setup(void)
 {
 	x86_platform.calibrate_tsc = tangier_calibrate_tsc;
<span class="p_add">+	x86_platform.legacy.rtc = 1;</span>
 }
 
 /* tangier arch ops */
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/sfi.c b/arch/x86/platform/intel-mid/sfi.c</span>
<span class="p_header">index 051d264fce2e..19b43e3a9f0f 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/sfi.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/sfi.c</span>
<span class="p_chunk">@@ -15,7 +15,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/scatterlist.h&gt;
 #include &lt;linux/sfi.h&gt;
<span class="p_del">-#include &lt;linux/intel_pmic_gpio.h&gt;</span>
 #include &lt;linux/spi/spi.h&gt;
 #include &lt;linux/i2c.h&gt;
 #include &lt;linux/skbuff.h&gt;
<span class="p_chunk">@@ -226,7 +225,7 @@</span> <span class="p_context"> int get_gpio_by_name(const char *name)</span>
 	return -EINVAL;
 }
 
<span class="p_del">-void __init intel_scu_device_register(struct platform_device *pdev)</span>
<span class="p_add">+static void __init intel_scu_ipc_device_register(struct platform_device *pdev)</span>
 {
 	if (ipc_next_dev == MAX_IPCDEVS)
 		pr_err(&quot;too many SCU IPC devices&quot;);
<span class="p_chunk">@@ -335,10 +334,22 @@</span> <span class="p_context"> static void __init sfi_handle_ipc_dev(struct sfi_device_table_entry *pentry,</span>
 
 	pr_debug(&quot;IPC bus, name = %16.16s, irq = 0x%2x\n&quot;,
 		pentry-&gt;name, pentry-&gt;irq);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to call platform init of IPC devices to fill misc_pdata</span>
<span class="p_add">+	 * structure. It will be used in msic_init for initialization.</span>
<span class="p_add">+	 */</span>
 	pdata = intel_mid_sfi_get_pdata(dev, pentry);
 	if (IS_ERR(pdata))
 		return;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On Medfield the platform device creation is handled by the MSIC</span>
<span class="p_add">+	 * MFD driver so we don&#39;t need to do it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dev-&gt;msic &amp;&amp; intel_mid_has_msic())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	pdev = platform_device_alloc(pentry-&gt;name, 0);
 	if (pdev == NULL) {
 		pr_err(&quot;out of memory for SFI platform device &#39;%s&#39;.\n&quot;,
<span class="p_chunk">@@ -348,7 +359,10 @@</span> <span class="p_context"> static void __init sfi_handle_ipc_dev(struct sfi_device_table_entry *pentry,</span>
 	install_irq_resource(pdev, pentry-&gt;irq);
 
 	pdev-&gt;dev.platform_data = pdata;
<span class="p_del">-	platform_device_add(pdev);</span>
<span class="p_add">+	if (dev-&gt;delay)</span>
<span class="p_add">+		intel_scu_ipc_device_register(pdev);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		platform_device_add(pdev);</span>
 }
 
 static void __init sfi_handle_spi_dev(struct sfi_device_table_entry *pentry,
<span class="p_chunk">@@ -503,27 +517,23 @@</span> <span class="p_context"> static int __init sfi_parse_devs(struct sfi_table_header *table)</span>
 		if (!dev)
 			continue;
 
<span class="p_del">-		if (dev-&gt;device_handler) {</span>
<span class="p_del">-			dev-&gt;device_handler(pentry, dev);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			switch (pentry-&gt;type) {</span>
<span class="p_del">-			case SFI_DEV_TYPE_IPC:</span>
<span class="p_del">-				sfi_handle_ipc_dev(pentry, dev);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case SFI_DEV_TYPE_SPI:</span>
<span class="p_del">-				sfi_handle_spi_dev(pentry, dev);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case SFI_DEV_TYPE_I2C:</span>
<span class="p_del">-				sfi_handle_i2c_dev(pentry, dev);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case SFI_DEV_TYPE_SD:</span>
<span class="p_del">-				sfi_handle_sd_dev(pentry, dev);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case SFI_DEV_TYPE_UART:</span>
<span class="p_del">-			case SFI_DEV_TYPE_HSI:</span>
<span class="p_del">-			default:</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		switch (pentry-&gt;type) {</span>
<span class="p_add">+		case SFI_DEV_TYPE_IPC:</span>
<span class="p_add">+			sfi_handle_ipc_dev(pentry, dev);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SFI_DEV_TYPE_SPI:</span>
<span class="p_add">+			sfi_handle_spi_dev(pentry, dev);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SFI_DEV_TYPE_I2C:</span>
<span class="p_add">+			sfi_handle_i2c_dev(pentry, dev);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SFI_DEV_TYPE_SD:</span>
<span class="p_add">+			sfi_handle_sd_dev(pentry, dev);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case SFI_DEV_TYPE_UART:</span>
<span class="p_add">+		case SFI_DEV_TYPE_HSI:</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			break;</span>
 		}
 	}
 	return 0;
<span class="p_header">diff --git a/arch/x86/platform/uv/uv_nmi.c b/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_header">index 8410e7d0a5b5..9743d0ccfec6 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/uv_nmi.c</span>
<span class="p_chunk">@@ -45,8 +45,8 @@</span> <span class="p_context"></span>
  *
  * Handle system-wide NMI events generated by the global &#39;power nmi&#39; command.
  *
<span class="p_del">- * Basic operation is to field the NMI interrupt on each cpu and wait</span>
<span class="p_del">- * until all cpus have arrived into the nmi handler.  If some cpus do not</span>
<span class="p_add">+ * Basic operation is to field the NMI interrupt on each CPU and wait</span>
<span class="p_add">+ * until all CPU&#39;s have arrived into the nmi handler.  If some CPU&#39;s do not</span>
  * make it into the handler, try and force them in with the IPI(NMI) signal.
  *
  * We also have to lessen UV Hub MMR accesses as much as possible as this
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"></span>
  * To do this we register our primary NMI notifier on the NMI_UNKNOWN
  * chain.  This reduces the number of false NMI calls when the perf
  * tools are running which generate an enormous number of NMIs per
<span class="p_del">- * second (~4M/s for 1024 cpu threads).  Our secondary NMI handler is</span>
<span class="p_add">+ * second (~4M/s for 1024 CPU threads).  Our secondary NMI handler is</span>
  * very short as it only checks that if it has been &quot;pinged&quot; with the
  * IPI(NMI) signal as mentioned above, and does not read the UV Hub&#39;s MMR.
  *
<span class="p_chunk">@@ -65,8 +65,20 @@</span> <span class="p_context"></span>
 static struct uv_hub_nmi_s **uv_hub_nmi_list;
 
 DEFINE_PER_CPU(struct uv_cpu_nmi_s, uv_cpu_nmi);
<span class="p_del">-EXPORT_PER_CPU_SYMBOL_GPL(uv_cpu_nmi);</span>
 
<span class="p_add">+/* UV hubless values */</span>
<span class="p_add">+#define NMI_CONTROL_PORT	0x70</span>
<span class="p_add">+#define NMI_DUMMY_PORT		0x71</span>
<span class="p_add">+#define PAD_OWN_GPP_D_0		0x2c</span>
<span class="p_add">+#define GPI_NMI_STS_GPP_D_0	0x164</span>
<span class="p_add">+#define GPI_NMI_ENA_GPP_D_0	0x174</span>
<span class="p_add">+#define STS_GPP_D_0_MASK	0x1</span>
<span class="p_add">+#define PAD_CFG_DW0_GPP_D_0	0x4c0</span>
<span class="p_add">+#define GPIROUTNMI		(1ul &lt;&lt; 17)</span>
<span class="p_add">+#define PCH_PCR_GPIO_1_BASE	0xfdae0000ul</span>
<span class="p_add">+#define PCH_PCR_GPIO_ADDRESS(offset) (int *)((u64)(pch_base) | (u64)(offset))</span>
<span class="p_add">+</span>
<span class="p_add">+static u64 *pch_base;</span>
 static unsigned long nmi_mmr;
 static unsigned long nmi_mmr_clear;
 static unsigned long nmi_mmr_pending;
<span class="p_chunk">@@ -100,7 +112,7 @@</span> <span class="p_context"> static int param_get_local64(char *buffer, const struct kernel_param *kp)</span>
 
 static int param_set_local64(const char *val, const struct kernel_param *kp)
 {
<span class="p_del">-	/* clear on any write */</span>
<span class="p_add">+	/* Clear on any write */</span>
 	local64_set((local64_t *)kp-&gt;arg, 0);
 	return 0;
 }
<span class="p_chunk">@@ -144,16 +156,80 @@</span> <span class="p_context"> module_param_named(wait_count, uv_nmi_wait_count, int, 0644);</span>
 static int uv_nmi_retry_count = 500;
 module_param_named(retry_count, uv_nmi_retry_count, int, 0644);
 
<span class="p_del">-/*</span>
<span class="p_del">- * Valid NMI Actions:</span>
<span class="p_del">- *  &quot;dump&quot;	- dump process stack for each cpu</span>
<span class="p_del">- *  &quot;ips&quot;	- dump IP info for each cpu</span>
<span class="p_del">- *  &quot;kdump&quot;	- do crash dump</span>
<span class="p_del">- *  &quot;kdb&quot;	- enter KDB (default)</span>
<span class="p_del">- *  &quot;kgdb&quot;	- enter KGDB</span>
<span class="p_del">- */</span>
<span class="p_del">-static char uv_nmi_action[8] = &quot;kdb&quot;;</span>
<span class="p_del">-module_param_string(action, uv_nmi_action, sizeof(uv_nmi_action), 0644);</span>
<span class="p_add">+static bool uv_pch_intr_enable = true;</span>
<span class="p_add">+static bool uv_pch_intr_now_enabled;</span>
<span class="p_add">+module_param_named(pch_intr_enable, uv_pch_intr_enable, bool, 0644);</span>
<span class="p_add">+</span>
<span class="p_add">+static bool uv_pch_init_enable = true;</span>
<span class="p_add">+module_param_named(pch_init_enable, uv_pch_init_enable, bool, 0644);</span>
<span class="p_add">+</span>
<span class="p_add">+static int uv_nmi_debug;</span>
<span class="p_add">+module_param_named(debug, uv_nmi_debug, int, 0644);</span>
<span class="p_add">+</span>
<span class="p_add">+#define nmi_debug(fmt, ...)				\</span>
<span class="p_add">+	do {						\</span>
<span class="p_add">+		if (uv_nmi_debug)			\</span>
<span class="p_add">+			pr_info(fmt, ##__VA_ARGS__);	\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+/* Valid NMI Actions */</span>
<span class="p_add">+#define	ACTION_LEN	16</span>
<span class="p_add">+static struct nmi_action {</span>
<span class="p_add">+	char	*action;</span>
<span class="p_add">+	char	*desc;</span>
<span class="p_add">+} valid_acts[] = {</span>
<span class="p_add">+	{	&quot;kdump&quot;,	&quot;do kernel crash dump&quot;			},</span>
<span class="p_add">+	{	&quot;dump&quot;,		&quot;dump process stack for each cpu&quot;	},</span>
<span class="p_add">+	{	&quot;ips&quot;,		&quot;dump Inst Ptr info for each cpu&quot;	},</span>
<span class="p_add">+	{	&quot;kdb&quot;,		&quot;enter KDB (needs kgdboc= assignment)&quot;	},</span>
<span class="p_add">+	{	&quot;kgdb&quot;,		&quot;enter KGDB (needs gdb target remote)&quot;	},</span>
<span class="p_add">+	{	&quot;health&quot;,	&quot;check if CPUs respond to NMI&quot;		},</span>
<span class="p_add">+};</span>
<span class="p_add">+typedef char action_t[ACTION_LEN];</span>
<span class="p_add">+static action_t uv_nmi_action = { &quot;dump&quot; };</span>
<span class="p_add">+</span>
<span class="p_add">+static int param_get_action(char *buffer, const struct kernel_param *kp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sprintf(buffer, &quot;%s\n&quot;, uv_nmi_action);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int param_set_action(const char *val, const struct kernel_param *kp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int n = ARRAY_SIZE(valid_acts);</span>
<span class="p_add">+	char arg[ACTION_LEN], *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* (remove possible &#39;\n&#39;) */</span>
<span class="p_add">+	strncpy(arg, val, ACTION_LEN - 1);</span>
<span class="p_add">+	arg[ACTION_LEN - 1] = &#39;\0&#39;;</span>
<span class="p_add">+	p = strchr(arg, &#39;\n&#39;);</span>
<span class="p_add">+	if (p)</span>
<span class="p_add">+		*p = &#39;\0&#39;;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; n; i++)</span>
<span class="p_add">+		if (!strcmp(arg, valid_acts[i].action))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (i &lt; n) {</span>
<span class="p_add">+		strcpy(uv_nmi_action, arg);</span>
<span class="p_add">+		pr_info(&quot;UV: New NMI action:%s\n&quot;, uv_nmi_action);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_err(&quot;UV: Invalid NMI action:%s, valid actions are:\n&quot;, arg);</span>
<span class="p_add">+	for (i = 0; i &lt; n; i++)</span>
<span class="p_add">+		pr_err(&quot;UV: %-8s - %s\n&quot;,</span>
<span class="p_add">+			valid_acts[i].action, valid_acts[i].desc);</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct kernel_param_ops param_ops_action = {</span>
<span class="p_add">+	.get = param_get_action,</span>
<span class="p_add">+	.set = param_set_action,</span>
<span class="p_add">+};</span>
<span class="p_add">+#define param_check_action(name, p) __param_check(name, p, action_t)</span>
<span class="p_add">+</span>
<span class="p_add">+module_param_named(action, uv_nmi_action, action, 0644);</span>
 
 static inline bool uv_nmi_action_is(const char *action)
 {
<span class="p_chunk">@@ -192,8 +268,200 @@</span> <span class="p_context"> static inline void uv_local_mmr_clear_nmi(void)</span>
 }
 
 /*
<span class="p_del">- * If first cpu in on this hub, set hub_nmi &quot;in_nmi&quot; and &quot;owner&quot; values and</span>
<span class="p_del">- * return true.  If first cpu in on the system, set global &quot;in_nmi&quot; flag.</span>
<span class="p_add">+ * UV hubless NMI handler functions</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void uv_reassert_nmi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* (from arch/x86/include/asm/mach_traps.h) */</span>
<span class="p_add">+	outb(0x8f, NMI_CONTROL_PORT);</span>
<span class="p_add">+	inb(NMI_DUMMY_PORT);		/* dummy read */</span>
<span class="p_add">+	outb(0x0f, NMI_CONTROL_PORT);</span>
<span class="p_add">+	inb(NMI_DUMMY_PORT);		/* dummy read */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void uv_init_hubless_pch_io(int offset, int mask, int data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int *addr = PCH_PCR_GPIO_ADDRESS(offset);</span>
<span class="p_add">+	int readd = readl(addr);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mask) {			/* OR in new data */</span>
<span class="p_add">+		int writed = (readd &amp; ~mask) | data;</span>
<span class="p_add">+</span>
<span class="p_add">+		nmi_debug(&quot;UV:PCH: %p = %x &amp; %x | %x (%x)\n&quot;,</span>
<span class="p_add">+			addr, readd, ~mask, data, writed);</span>
<span class="p_add">+		writel(writed, addr);</span>
<span class="p_add">+	} else if (readd &amp; data) {	/* clear status bit */</span>
<span class="p_add">+		nmi_debug(&quot;UV:PCH: %p = %x\n&quot;, addr, data);</span>
<span class="p_add">+		writel(data, addr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	(void)readl(addr);		/* flush write data */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void uv_nmi_setup_hubless_intr(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uv_pch_intr_now_enabled = uv_pch_intr_enable;</span>
<span class="p_add">+</span>
<span class="p_add">+	uv_init_hubless_pch_io(</span>
<span class="p_add">+		PAD_CFG_DW0_GPP_D_0, GPIROUTNMI,</span>
<span class="p_add">+		uv_pch_intr_now_enabled ? GPIROUTNMI : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	nmi_debug(&quot;UV:NMI: GPP_D_0 interrupt %s\n&quot;,</span>
<span class="p_add">+		uv_pch_intr_now_enabled ? &quot;enabled&quot; : &quot;disabled&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct init_nmi {</span>
<span class="p_add">+	unsigned int	offset;</span>
<span class="p_add">+	unsigned int	mask;</span>
<span class="p_add">+	unsigned int	data;</span>
<span class="p_add">+} init_nmi[] = {</span>
<span class="p_add">+	{	/* HOSTSW_OWN_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x84,</span>
<span class="p_add">+	.mask = 0x1,</span>
<span class="p_add">+	.data = 0x0,	/* ACPI Mode */</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
<span class="p_add">+/* Clear status: */</span>
<span class="p_add">+	{	/* GPI_INT_STS_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x104,</span>
<span class="p_add">+	.mask = 0x0,</span>
<span class="p_add">+	.data = 0x1,	/* Clear Status */</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* GPI_GPE_STS_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x124,</span>
<span class="p_add">+	.mask = 0x0,</span>
<span class="p_add">+	.data = 0x1,	/* Clear Status */</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* GPI_SMI_STS_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x144,</span>
<span class="p_add">+	.mask = 0x0,</span>
<span class="p_add">+	.data = 0x1,	/* Clear Status */</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* GPI_NMI_STS_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x164,</span>
<span class="p_add">+	.mask = 0x0,</span>
<span class="p_add">+	.data = 0x1,	/* Clear Status */</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
<span class="p_add">+/* Disable interrupts: */</span>
<span class="p_add">+	{	/* GPI_INT_EN_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x114,</span>
<span class="p_add">+	.mask = 0x1,</span>
<span class="p_add">+	.data = 0x0,	/* Disable interrupt generation */</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* GPI_GPE_EN_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x134,</span>
<span class="p_add">+	.mask = 0x1,</span>
<span class="p_add">+	.data = 0x0,	/* Disable interrupt generation */</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* GPI_SMI_EN_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x154,</span>
<span class="p_add">+	.mask = 0x1,</span>
<span class="p_add">+	.data = 0x0,	/* Disable interrupt generation */</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{	/* GPI_NMI_EN_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x174,</span>
<span class="p_add">+	.mask = 0x1,</span>
<span class="p_add">+	.data = 0x0,	/* Disable interrupt generation */</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
<span class="p_add">+/* Setup GPP_D_0 Pad Config: */</span>
<span class="p_add">+	{	/* PAD_CFG_DW0_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x4c0,</span>
<span class="p_add">+	.mask = 0xffffffff,</span>
<span class="p_add">+	.data = 0x82020100,</span>
<span class="p_add">+/*</span>
<span class="p_add">+ *  31:30 Pad Reset Config (PADRSTCFG): = 2h  # PLTRST# (default)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  29    RX Pad State Select (RXPADSTSEL): = 0 # Raw RX pad state directly</span>
<span class="p_add">+ *                                                from RX buffer (default)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  28    RX Raw Override to &#39;1&#39; (RXRAW1): = 0 # No Override</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  26:25 RX Level/Edge Configuration (RXEVCFG):</span>
<span class="p_add">+ *      = 0h # Level</span>
<span class="p_add">+ *      = 1h # Edge</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  23    RX Invert (RXINV): = 0 # No Inversion (signal active high)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  20    GPIO Input Route IOxAPIC (GPIROUTIOXAPIC):</span>
<span class="p_add">+ * = 0 # Routing does not cause peripheral IRQ...</span>
<span class="p_add">+ *     # (we want an NMI not an IRQ)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  19    GPIO Input Route SCI (GPIROUTSCI): = 0 # Routing does not cause SCI.</span>
<span class="p_add">+ *  18    GPIO Input Route SMI (GPIROUTSMI): = 0 # Routing does not cause SMI.</span>
<span class="p_add">+ *  17    GPIO Input Route NMI (GPIROUTNMI): = 1 # Routing can cause NMI.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  11:10 Pad Mode (PMODE1/0): = 0h = GPIO control the Pad.</span>
<span class="p_add">+ *   9    GPIO RX Disable (GPIORXDIS):</span>
<span class="p_add">+ * = 0 # Enable the input buffer (active low enable)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   8    GPIO TX Disable (GPIOTXDIS):</span>
<span class="p_add">+ * = 1 # Disable the output buffer; i.e. Hi-Z</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   1 GPIO RX State (GPIORXSTATE): This is the current internal RX pad state..</span>
<span class="p_add">+ *   0 GPIO TX State (GPIOTXSTATE):</span>
<span class="p_add">+ * = 0 # (Leave at default)</span>
<span class="p_add">+ */</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
<span class="p_add">+/* Pad Config DW1 */</span>
<span class="p_add">+	{	/* PAD_CFG_DW1_GPP_D_0 */</span>
<span class="p_add">+	.offset = 0x4c4,</span>
<span class="p_add">+	.mask = 0x3c00,</span>
<span class="p_add">+	.data = 0,	/* Termination = none (default) */</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void uv_init_hubless_pch_d0(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i, read;</span>
<span class="p_add">+</span>
<span class="p_add">+	read = *PCH_PCR_GPIO_ADDRESS(PAD_OWN_GPP_D_0);</span>
<span class="p_add">+	if (read != 0) {</span>
<span class="p_add">+		pr_info(&quot;UV: Hubless NMI already configured\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	nmi_debug(&quot;UV: Initializing UV Hubless NMI on PCH\n&quot;);</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(init_nmi); i++) {</span>
<span class="p_add">+		uv_init_hubless_pch_io(init_nmi[i].offset,</span>
<span class="p_add">+					init_nmi[i].mask,</span>
<span class="p_add">+					init_nmi[i].data);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int uv_nmi_test_hubless(struct uv_hub_nmi_s *hub_nmi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int *pstat = PCH_PCR_GPIO_ADDRESS(GPI_NMI_STS_GPP_D_0);</span>
<span class="p_add">+	int status = *pstat;</span>
<span class="p_add">+</span>
<span class="p_add">+	hub_nmi-&gt;nmi_value = status;</span>
<span class="p_add">+	atomic_inc(&amp;hub_nmi-&gt;read_mmr_count);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(status &amp; STS_GPP_D_0_MASK))	/* Not a UV external NMI */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	*pstat = STS_GPP_D_0_MASK;	/* Is a UV NMI: clear GPP_D_0 status */</span>
<span class="p_add">+	(void)*pstat;			/* Flush write */</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int uv_test_nmi(struct uv_hub_nmi_s *hub_nmi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (hub_nmi-&gt;hub_present)</span>
<span class="p_add">+		return uv_nmi_test_mmr(hub_nmi);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hub_nmi-&gt;pch_owner)		/* Only PCH owner can check status */</span>
<span class="p_add">+		return uv_nmi_test_hubless(hub_nmi);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * If first CPU in on this hub, set hub_nmi &quot;in_nmi&quot; and &quot;owner&quot; values and</span>
<span class="p_add">+ * return true.  If first CPU in on the system, set global &quot;in_nmi&quot; flag.</span>
  */
 static int uv_set_in_nmi(int cpu, struct uv_hub_nmi_s *hub_nmi)
 {
<span class="p_chunk">@@ -214,6 +482,7 @@</span> <span class="p_context"> static int uv_check_nmi(struct uv_hub_nmi_s *hub_nmi)</span>
 {
 	int cpu = smp_processor_id();
 	int nmi = 0;
<span class="p_add">+	int nmi_detected = 0;</span>
 
 	local64_inc(&amp;uv_nmi_count);
 	this_cpu_inc(uv_cpu_nmi.queries);
<span class="p_chunk">@@ -224,35 +493,48 @@</span> <span class="p_context"> static int uv_check_nmi(struct uv_hub_nmi_s *hub_nmi)</span>
 			break;
 
 		if (raw_spin_trylock(&amp;hub_nmi-&gt;nmi_lock)) {
<span class="p_add">+			nmi_detected = uv_test_nmi(hub_nmi);</span>
 
<span class="p_del">-			/* check hub MMR NMI flag */</span>
<span class="p_del">-			if (uv_nmi_test_mmr(hub_nmi)) {</span>
<span class="p_add">+			/* Check flag for UV external NMI */</span>
<span class="p_add">+			if (nmi_detected &gt; 0) {</span>
 				uv_set_in_nmi(cpu, hub_nmi);
 				nmi = 1;
 				break;
 			}
 
<span class="p_del">-			/* MMR NMI flag is clear */</span>
<span class="p_add">+			/* A non-PCH node in a hubless system waits for NMI */</span>
<span class="p_add">+			else if (nmi_detected &lt; 0)</span>
<span class="p_add">+				goto slave_wait;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* MMR/PCH NMI flag is clear */</span>
 			raw_spin_unlock(&amp;hub_nmi-&gt;nmi_lock);
 
 		} else {
<span class="p_del">-			/* wait a moment for the hub nmi locker to set flag */</span>
<span class="p_del">-			cpu_relax();</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Wait a moment for the HUB NMI locker to set flag */</span>
<span class="p_add">+slave_wait:		cpu_relax();</span>
 			udelay(uv_nmi_slave_delay);
 
<span class="p_del">-			/* re-check hub in_nmi flag */</span>
<span class="p_add">+			/* Re-check hub in_nmi flag */</span>
 			nmi = atomic_read(&amp;hub_nmi-&gt;in_nmi);
 			if (nmi)
 				break;
 		}
 
<span class="p_del">-		/* check if this BMC missed setting the MMR NMI flag */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check if this BMC missed setting the MMR NMI flag (or)</span>
<span class="p_add">+		 * UV hubless system where only PCH owner can check flag</span>
<span class="p_add">+		 */</span>
 		if (!nmi) {
 			nmi = atomic_read(&amp;uv_in_nmi);
 			if (nmi)
 				uv_set_in_nmi(cpu, hub_nmi);
 		}
 
<span class="p_add">+		/* If we&#39;re holding the hub lock, release it now */</span>
<span class="p_add">+		if (nmi_detected &lt; 0)</span>
<span class="p_add">+			raw_spin_unlock(&amp;hub_nmi-&gt;nmi_lock);</span>
<span class="p_add">+</span>
 	} while (0);
 
 	if (!nmi)
<span class="p_chunk">@@ -269,12 +551,15 @@</span> <span class="p_context"> static inline void uv_clear_nmi(int cpu)</span>
 	if (cpu == atomic_read(&amp;hub_nmi-&gt;cpu_owner)) {
 		atomic_set(&amp;hub_nmi-&gt;cpu_owner, -1);
 		atomic_set(&amp;hub_nmi-&gt;in_nmi, 0);
<span class="p_del">-		uv_local_mmr_clear_nmi();</span>
<span class="p_add">+		if (hub_nmi-&gt;hub_present)</span>
<span class="p_add">+			uv_local_mmr_clear_nmi();</span>
<span class="p_add">+		else</span>
<span class="p_add">+			uv_reassert_nmi();</span>
 		raw_spin_unlock(&amp;hub_nmi-&gt;nmi_lock);
 	}
 }
 
<span class="p_del">-/* Ping non-responding cpus attemping to force them into the NMI handler */</span>
<span class="p_add">+/* Ping non-responding CPU&#39;s attemping to force them into the NMI handler */</span>
 static void uv_nmi_nr_cpus_ping(void)
 {
 	int cpu;
<span class="p_chunk">@@ -285,7 +570,7 @@</span> <span class="p_context"> static void uv_nmi_nr_cpus_ping(void)</span>
 	apic-&gt;send_IPI_mask(uv_nmi_cpu_mask, APIC_DM_NMI);
 }
 
<span class="p_del">-/* Clean up flags for cpus that ignored both NMI and ping */</span>
<span class="p_add">+/* Clean up flags for CPU&#39;s that ignored both NMI and ping */</span>
 static void uv_nmi_cleanup_mask(void)
 {
 	int cpu;
<span class="p_chunk">@@ -297,11 +582,12 @@</span> <span class="p_context"> static void uv_nmi_cleanup_mask(void)</span>
 	}
 }
 
<span class="p_del">-/* Loop waiting as cpus enter nmi handler */</span>
<span class="p_add">+/* Loop waiting as CPU&#39;s enter NMI handler */</span>
 static int uv_nmi_wait_cpus(int first)
 {
 	int i, j, k, n = num_online_cpus();
 	int last_k = 0, waiting = 0;
<span class="p_add">+	int cpu = smp_processor_id();</span>
 
 	if (first) {
 		cpumask_copy(uv_nmi_cpu_mask, cpu_online_mask);
<span class="p_chunk">@@ -310,6 +596,12 @@</span> <span class="p_context"> static int uv_nmi_wait_cpus(int first)</span>
 		k = n - cpumask_weight(uv_nmi_cpu_mask);
 	}
 
<span class="p_add">+	/* PCH NMI causes only one CPU to respond */</span>
<span class="p_add">+	if (first &amp;&amp; uv_pch_intr_now_enabled) {</span>
<span class="p_add">+		cpumask_clear_cpu(cpu, uv_nmi_cpu_mask);</span>
<span class="p_add">+		return n - k - 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	udelay(uv_nmi_initial_delay);
 	for (i = 0; i &lt; uv_nmi_retry_count; i++) {
 		int loop_delay = uv_nmi_loop_delay;
<span class="p_chunk">@@ -325,13 +617,13 @@</span> <span class="p_context"> static int uv_nmi_wait_cpus(int first)</span>
 			k = n;
 			break;
 		}
<span class="p_del">-		if (last_k != k) {	/* abort if no new cpus coming in */</span>
<span class="p_add">+		if (last_k != k) {	/* abort if no new CPU&#39;s coming in */</span>
 			last_k = k;
 			waiting = 0;
 		} else if (++waiting &gt; uv_nmi_wait_count)
 			break;
 
<span class="p_del">-		/* extend delay if waiting only for cpu 0 */</span>
<span class="p_add">+		/* Extend delay if waiting only for CPU 0: */</span>
 		if (waiting &amp;&amp; (n - k) == 1 &amp;&amp;
 		    cpumask_test_cpu(0, uv_nmi_cpu_mask))
 			loop_delay *= 100;
<span class="p_chunk">@@ -342,29 +634,29 @@</span> <span class="p_context"> static int uv_nmi_wait_cpus(int first)</span>
 	return n - k;
 }
 
<span class="p_del">-/* Wait until all slave cpus have entered UV NMI handler */</span>
<span class="p_add">+/* Wait until all slave CPU&#39;s have entered UV NMI handler */</span>
 static void uv_nmi_wait(int master)
 {
<span class="p_del">-	/* indicate this cpu is in */</span>
<span class="p_add">+	/* Indicate this CPU is in: */</span>
 	this_cpu_write(uv_cpu_nmi.state, UV_NMI_STATE_IN);
 
<span class="p_del">-	/* if not the first cpu in (the master), then we are a slave cpu */</span>
<span class="p_add">+	/* If not the first CPU in (the master), then we are a slave CPU */</span>
 	if (!master)
 		return;
 
 	do {
<span class="p_del">-		/* wait for all other cpus to gather here */</span>
<span class="p_add">+		/* Wait for all other CPU&#39;s to gather here */</span>
 		if (!uv_nmi_wait_cpus(1))
 			break;
 
<span class="p_del">-		/* if not all made it in, send IPI NMI to them */</span>
<span class="p_del">-		pr_alert(&quot;UV: Sending NMI IPI to %d non-responding CPUs: %*pbl\n&quot;,</span>
<span class="p_add">+		/* If not all made it in, send IPI NMI to them */</span>
<span class="p_add">+		pr_alert(&quot;UV: Sending NMI IPI to %d CPUs: %*pbl\n&quot;,</span>
 			 cpumask_weight(uv_nmi_cpu_mask),
 			 cpumask_pr_args(uv_nmi_cpu_mask));
 
 		uv_nmi_nr_cpus_ping();
 
<span class="p_del">-		/* if all cpus are in, then done */</span>
<span class="p_add">+		/* If all CPU&#39;s are in, then done */</span>
 		if (!uv_nmi_wait_cpus(0))
 			break;
 
<span class="p_chunk">@@ -416,7 +708,7 @@</span> <span class="p_context"> static void uv_nmi_dump_state_cpu(int cpu, struct pt_regs *regs)</span>
 	this_cpu_write(uv_cpu_nmi.state, UV_NMI_STATE_DUMP_DONE);
 }
 
<span class="p_del">-/* Trigger a slave cpu to dump it&#39;s state */</span>
<span class="p_add">+/* Trigger a slave CPU to dump it&#39;s state */</span>
 static void uv_nmi_trigger_dump(int cpu)
 {
 	int retry = uv_nmi_trigger_delay;
<span class="p_chunk">@@ -437,7 +729,7 @@</span> <span class="p_context"> static void uv_nmi_trigger_dump(int cpu)</span>
 	uv_cpu_nmi_per(cpu).state = UV_NMI_STATE_DUMP_DONE;
 }
 
<span class="p_del">-/* Wait until all cpus ready to exit */</span>
<span class="p_add">+/* Wait until all CPU&#39;s ready to exit */</span>
 static void uv_nmi_sync_exit(int master)
 {
 	atomic_dec(&amp;uv_nmi_cpus_in_nmi);
<span class="p_chunk">@@ -451,7 +743,23 @@</span> <span class="p_context"> static void uv_nmi_sync_exit(int master)</span>
 	}
 }
 
<span class="p_del">-/* Walk through cpu list and dump state of each */</span>
<span class="p_add">+/* Current &quot;health&quot; check is to check which CPU&#39;s are responsive */</span>
<span class="p_add">+static void uv_nmi_action_health(int cpu, struct pt_regs *regs, int master)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (master) {</span>
<span class="p_add">+		int in = atomic_read(&amp;uv_nmi_cpus_in_nmi);</span>
<span class="p_add">+		int out = num_online_cpus() - in;</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_alert(&quot;UV: NMI CPU health check (non-responding:%d)\n&quot;, out);</span>
<span class="p_add">+		atomic_set(&amp;uv_nmi_slave_continue, SLAVE_EXIT);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		while (!atomic_read(&amp;uv_nmi_slave_continue))</span>
<span class="p_add">+			cpu_relax();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	uv_nmi_sync_exit(master);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Walk through CPU list and dump state of each */</span>
 static void uv_nmi_dump_state(int cpu, struct pt_regs *regs, int master)
 {
 	if (master) {
<span class="p_chunk">@@ -538,7 +846,7 @@</span> <span class="p_context"> static inline int uv_nmi_kdb_reason(void)</span>
 #else /* !CONFIG_KGDB_KDB */
 static inline int uv_nmi_kdb_reason(void)
 {
<span class="p_del">-	/* Insure user is expecting to attach gdb remote */</span>
<span class="p_add">+	/* Ensure user is expecting to attach gdb remote */</span>
 	if (uv_nmi_action_is(&quot;kgdb&quot;))
 		return 0;
 
<span class="p_chunk">@@ -563,7 +871,7 @@</span> <span class="p_context"> static void uv_call_kgdb_kdb(int cpu, struct pt_regs *regs, int master)</span>
 		if (reason &lt; 0)
 			return;
 
<span class="p_del">-		/* call KGDB NMI handler as MASTER */</span>
<span class="p_add">+		/* Call KGDB NMI handler as MASTER */</span>
 		ret = kgdb_nmicallin(cpu, X86_TRAP_NMI, regs, reason,
 				&amp;uv_nmi_slave_continue);
 		if (ret) {
<span class="p_chunk">@@ -571,7 +879,7 @@</span> <span class="p_context"> static void uv_call_kgdb_kdb(int cpu, struct pt_regs *regs, int master)</span>
 			atomic_set(&amp;uv_nmi_slave_continue, SLAVE_EXIT);
 		}
 	} else {
<span class="p_del">-		/* wait for KGDB signal that it&#39;s ready for slaves to enter */</span>
<span class="p_add">+		/* Wait for KGDB signal that it&#39;s ready for slaves to enter */</span>
 		int sig;
 
 		do {
<span class="p_chunk">@@ -579,7 +887,7 @@</span> <span class="p_context"> static void uv_call_kgdb_kdb(int cpu, struct pt_regs *regs, int master)</span>
 			sig = atomic_read(&amp;uv_nmi_slave_continue);
 		} while (!sig);
 
<span class="p_del">-		/* call KGDB as slave */</span>
<span class="p_add">+		/* Call KGDB as slave */</span>
 		if (sig == SLAVE_CONTINUE)
 			kgdb_nmicallback(cpu, regs);
 	}
<span class="p_chunk">@@ -623,18 +931,23 @@</span> <span class="p_context"> int uv_handle_nmi(unsigned int reason, struct pt_regs *regs)</span>
 			strncpy(uv_nmi_action, &quot;dump&quot;, strlen(uv_nmi_action));
 	}
 
<span class="p_del">-	/* Pause as all cpus enter the NMI handler */</span>
<span class="p_add">+	/* Pause as all CPU&#39;s enter the NMI handler */</span>
 	uv_nmi_wait(master);
 
<span class="p_del">-	/* Dump state of each cpu */</span>
<span class="p_del">-	if (uv_nmi_action_is(&quot;ips&quot;) || uv_nmi_action_is(&quot;dump&quot;))</span>
<span class="p_add">+	/* Process actions other than &quot;kdump&quot;: */</span>
<span class="p_add">+	if (uv_nmi_action_is(&quot;health&quot;)) {</span>
<span class="p_add">+		uv_nmi_action_health(cpu, regs, master);</span>
<span class="p_add">+	} else if (uv_nmi_action_is(&quot;ips&quot;) || uv_nmi_action_is(&quot;dump&quot;)) {</span>
 		uv_nmi_dump_state(cpu, regs, master);
<span class="p_del">-</span>
<span class="p_del">-	/* Call KGDB/KDB if enabled */</span>
<span class="p_del">-	else if (uv_nmi_action_is(&quot;kdb&quot;) || uv_nmi_action_is(&quot;kgdb&quot;))</span>
<span class="p_add">+	} else if (uv_nmi_action_is(&quot;kdb&quot;) || uv_nmi_action_is(&quot;kgdb&quot;)) {</span>
 		uv_call_kgdb_kdb(cpu, regs, master);
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (master)</span>
<span class="p_add">+			pr_alert(&quot;UV: unknown NMI action: %s\n&quot;, uv_nmi_action);</span>
<span class="p_add">+		uv_nmi_sync_exit(master);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	/* Clear per_cpu &quot;in nmi&quot; flag */</span>
<span class="p_add">+	/* Clear per_cpu &quot;in_nmi&quot; flag */</span>
 	this_cpu_write(uv_cpu_nmi.state, UV_NMI_STATE_OUT);
 
 	/* Clear MMR NMI flag on each hub */
<span class="p_chunk">@@ -648,6 +961,7 @@</span> <span class="p_context"> int uv_handle_nmi(unsigned int reason, struct pt_regs *regs)</span>
 		atomic_set(&amp;uv_nmi_cpu, -1);
 		atomic_set(&amp;uv_in_nmi, 0);
 		atomic_set(&amp;uv_nmi_kexec_failed, 0);
<span class="p_add">+		atomic_set(&amp;uv_nmi_slave_continue, SLAVE_CLEAR);</span>
 	}
 
 	uv_nmi_touch_watchdogs();
<span class="p_chunk">@@ -657,7 +971,7 @@</span> <span class="p_context"> int uv_handle_nmi(unsigned int reason, struct pt_regs *regs)</span>
 }
 
 /*
<span class="p_del">- * NMI handler for pulling in CPUs when perf events are grabbing our NMI</span>
<span class="p_add">+ * NMI handler for pulling in CPU&#39;s when perf events are grabbing our NMI</span>
  */
 static int uv_handle_nmi_ping(unsigned int reason, struct pt_regs *regs)
 {
<span class="p_chunk">@@ -690,35 +1004,62 @@</span> <span class="p_context"> void uv_nmi_init(void)</span>
 	unsigned int value;
 
 	/*
<span class="p_del">-	 * Unmask NMI on all cpus</span>
<span class="p_add">+	 * Unmask NMI on all CPU&#39;s</span>
 	 */
 	value = apic_read(APIC_LVT1) | APIC_DM_NMI;
 	value &amp;= ~APIC_LVT_MASKED;
 	apic_write(APIC_LVT1, value);
 }
 
<span class="p_del">-void uv_nmi_setup(void)</span>
<span class="p_add">+/* Setup HUB NMI info */</span>
<span class="p_add">+void __init uv_nmi_setup_common(bool hubbed)</span>
 {
 	int size = sizeof(void *) * (1 &lt;&lt; NODES_SHIFT);
<span class="p_del">-	int cpu, nid;</span>
<span class="p_add">+	int cpu;</span>
 
<span class="p_del">-	/* Setup hub nmi info */</span>
<span class="p_del">-	uv_nmi_setup_mmrs();</span>
 	uv_hub_nmi_list = kzalloc(size, GFP_KERNEL);
<span class="p_del">-	pr_info(&quot;UV: NMI hub list @ 0x%p (%d)\n&quot;, uv_hub_nmi_list, size);</span>
<span class="p_add">+	nmi_debug(&quot;UV: NMI hub list @ 0x%p (%d)\n&quot;, uv_hub_nmi_list, size);</span>
 	BUG_ON(!uv_hub_nmi_list);
 	size = sizeof(struct uv_hub_nmi_s);
 	for_each_present_cpu(cpu) {
<span class="p_del">-		nid = cpu_to_node(cpu);</span>
<span class="p_add">+		int nid = cpu_to_node(cpu);</span>
 		if (uv_hub_nmi_list[nid] == NULL) {
 			uv_hub_nmi_list[nid] = kzalloc_node(size,
 							    GFP_KERNEL, nid);
 			BUG_ON(!uv_hub_nmi_list[nid]);
 			raw_spin_lock_init(&amp;(uv_hub_nmi_list[nid]-&gt;nmi_lock));
 			atomic_set(&amp;uv_hub_nmi_list[nid]-&gt;cpu_owner, -1);
<span class="p_add">+			uv_hub_nmi_list[nid]-&gt;hub_present = hubbed;</span>
<span class="p_add">+			uv_hub_nmi_list[nid]-&gt;pch_owner = (nid == 0);</span>
 		}
 		uv_hub_nmi_per(cpu) = uv_hub_nmi_list[nid];
 	}
 	BUG_ON(!alloc_cpumask_var(&amp;uv_nmi_cpu_mask, GFP_KERNEL));
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Setup for UV Hub systems */</span>
<span class="p_add">+void __init uv_nmi_setup(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uv_nmi_setup_mmrs();</span>
<span class="p_add">+	uv_nmi_setup_common(true);</span>
<span class="p_add">+	uv_register_nmi_notifier();</span>
<span class="p_add">+	pr_info(&quot;UV: Hub NMI enabled\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Setup for UV Hubless systems */</span>
<span class="p_add">+void __init uv_nmi_setup_hubless(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uv_nmi_setup_common(false);</span>
<span class="p_add">+	pch_base = xlate_dev_mem_ptr(PCH_PCR_GPIO_1_BASE);</span>
<span class="p_add">+	nmi_debug(&quot;UV: PCH base:%p from 0x%lx, GPP_D_0\n&quot;,</span>
<span class="p_add">+		pch_base, PCH_PCR_GPIO_1_BASE);</span>
<span class="p_add">+	if (uv_pch_init_enable)</span>
<span class="p_add">+		uv_init_hubless_pch_d0();</span>
<span class="p_add">+	uv_init_hubless_pch_io(GPI_NMI_ENA_GPP_D_0,</span>
<span class="p_add">+				STS_GPP_D_0_MASK, STS_GPP_D_0_MASK);</span>
<span class="p_add">+	uv_nmi_setup_hubless_intr();</span>
<span class="p_add">+	/* Ensure NMI enabled in Processor Interface Reg: */</span>
<span class="p_add">+	uv_reassert_nmi();</span>
 	uv_register_nmi_notifier();
<span class="p_add">+	pr_info(&quot;UV: Hubless NMI enabled\n&quot;);</span>
 }
<span class="p_header">diff --git a/drivers/platform/x86/Kconfig b/drivers/platform/x86/Kconfig</span>
<span class="p_header">index 59aa8e302bc3..49a594855f98 100644</span>
<span class="p_header">--- a/drivers/platform/x86/Kconfig</span>
<span class="p_header">+++ b/drivers/platform/x86/Kconfig</span>
<span class="p_chunk">@@ -816,13 +816,6 @@</span> <span class="p_context"> config INTEL_SCU_IPC_UTIL</span>
 	  low level access for debug work and updating the firmware. Say
 	  N unless you will be doing this on an Intel MID platform.
 
<span class="p_del">-config GPIO_INTEL_PMIC</span>
<span class="p_del">-	bool &quot;Intel PMIC GPIO support&quot;</span>
<span class="p_del">-	depends on INTEL_SCU_IPC &amp;&amp; GPIOLIB</span>
<span class="p_del">-	---help---</span>
<span class="p_del">-	  Say Y here to support GPIO via the SCU IPC interface</span>
<span class="p_del">-	  on Intel MID platforms.</span>
<span class="p_del">-</span>
 config INTEL_MID_POWER_BUTTON
 	tristate &quot;power button driver for Intel MID platforms&quot;
 	depends on INTEL_SCU_IPC &amp;&amp; INPUT
<span class="p_header">diff --git a/drivers/platform/x86/Makefile b/drivers/platform/x86/Makefile</span>
<span class="p_header">index d4111f0f8a78..b2f52a7690af 100644</span>
<span class="p_header">--- a/drivers/platform/x86/Makefile</span>
<span class="p_header">+++ b/drivers/platform/x86/Makefile</span>
<span class="p_chunk">@@ -50,7 +50,6 @@</span> <span class="p_context"> obj-$(CONFIG_INTEL_SCU_IPC)	+= intel_scu_ipc.o</span>
 obj-$(CONFIG_INTEL_SCU_IPC_UTIL) += intel_scu_ipcutil.o
 obj-$(CONFIG_INTEL_MFLD_THERMAL) += intel_mid_thermal.o
 obj-$(CONFIG_INTEL_IPS)		+= intel_ips.o
<span class="p_del">-obj-$(CONFIG_GPIO_INTEL_PMIC)	+= intel_pmic_gpio.o</span>
 obj-$(CONFIG_XO1_RFKILL)	+= xo1-rfkill.o
 obj-$(CONFIG_XO15_EBOOK)	+= xo15-ebook.o
 obj-$(CONFIG_IBM_RTL)		+= ibm_rtl.o
<span class="p_header">diff --git a/drivers/platform/x86/intel_pmic_gpio.c b/drivers/platform/x86/intel_pmic_gpio.c</span>
deleted file mode 100644
<span class="p_header">index 91ae58510d92..000000000000</span>
<span class="p_header">--- a/drivers/platform/x86/intel_pmic_gpio.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,326 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/* Moorestown PMIC GPIO (access through IPC) driver</span>
<span class="p_del">- * Copyright (c) 2008 - 2009, Intel Corporation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Author: Alek Du &lt;alek.du@intel.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_del">- * published by the Free Software Foundation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program; if not, write to the Free Software</span>
<span class="p_del">- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/* Supports:</span>
<span class="p_del">- * Moorestown platform PMIC chip</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#define pr_fmt(fmt) &quot;%s: &quot; fmt, __func__</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/delay.h&gt;</span>
<span class="p_del">-#include &lt;linux/stddef.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-#include &lt;linux/ioport.h&gt;</span>
<span class="p_del">-#include &lt;linux/init.h&gt;</span>
<span class="p_del">-#include &lt;linux/io.h&gt;</span>
<span class="p_del">-#include &lt;linux/gpio/driver.h&gt;</span>
<span class="p_del">-#include &lt;asm/intel_scu_ipc.h&gt;</span>
<span class="p_del">-#include &lt;linux/device.h&gt;</span>
<span class="p_del">-#include &lt;linux/intel_pmic_gpio.h&gt;</span>
<span class="p_del">-#include &lt;linux/platform_device.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#define DRIVER_NAME &quot;pmic_gpio&quot;</span>
<span class="p_del">-</span>
<span class="p_del">-/* register offset that IPC driver should use</span>
<span class="p_del">- * 8 GPIO + 8 GPOSW (6 controllable) + 8GPO</span>
<span class="p_del">- */</span>
<span class="p_del">-enum pmic_gpio_register {</span>
<span class="p_del">-	GPIO0		= 0xE0,</span>
<span class="p_del">-	GPIO7		= 0xE7,</span>
<span class="p_del">-	GPIOINT		= 0xE8,</span>
<span class="p_del">-	GPOSWCTL0	= 0xEC,</span>
<span class="p_del">-	GPOSWCTL5	= 0xF1,</span>
<span class="p_del">-	GPO		= 0xF4,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* bits definition for GPIO &amp; GPOSW */</span>
<span class="p_del">-#define GPIO_DRV 0x01</span>
<span class="p_del">-#define GPIO_DIR 0x02</span>
<span class="p_del">-#define GPIO_DIN 0x04</span>
<span class="p_del">-#define GPIO_DOU 0x08</span>
<span class="p_del">-#define GPIO_INTCTL 0x30</span>
<span class="p_del">-#define GPIO_DBC 0xc0</span>
<span class="p_del">-</span>
<span class="p_del">-#define GPOSW_DRV 0x01</span>
<span class="p_del">-#define GPOSW_DOU 0x08</span>
<span class="p_del">-#define GPOSW_RDRV 0x30</span>
<span class="p_del">-</span>
<span class="p_del">-#define GPIO_UPDATE_TYPE	0x80000000</span>
<span class="p_del">-</span>
<span class="p_del">-#define NUM_GPIO 24</span>
<span class="p_del">-</span>
<span class="p_del">-struct pmic_gpio {</span>
<span class="p_del">-	struct mutex		buslock;</span>
<span class="p_del">-	struct gpio_chip	chip;</span>
<span class="p_del">-	void			*gpiointr;</span>
<span class="p_del">-	int			irq;</span>
<span class="p_del">-	unsigned		irq_base;</span>
<span class="p_del">-	unsigned int		update_type;</span>
<span class="p_del">-	u32			trigger_type;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void pmic_program_irqtype(int gpio, int type)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (type &amp; IRQ_TYPE_EDGE_RISING)</span>
<span class="p_del">-		intel_scu_ipc_update_register(GPIO0 + gpio, 0x20, 0x20);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		intel_scu_ipc_update_register(GPIO0 + gpio, 0x00, 0x20);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (type &amp; IRQ_TYPE_EDGE_FALLING)</span>
<span class="p_del">-		intel_scu_ipc_update_register(GPIO0 + gpio, 0x10, 0x10);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		intel_scu_ipc_update_register(GPIO0 + gpio, 0x00, 0x10);</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int pmic_gpio_direction_input(struct gpio_chip *chip, unsigned offset)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (offset &gt;= 8) {</span>
<span class="p_del">-		pr_err(&quot;only pin 0-7 support input\n&quot;);</span>
<span class="p_del">-		return -1;/* we only have 8 GPIO can use as input */</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return intel_scu_ipc_update_register(GPIO0 + offset,</span>
<span class="p_del">-							GPIO_DIR, GPIO_DIR);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int pmic_gpio_direction_output(struct gpio_chip *chip,</span>
<span class="p_del">-			unsigned offset, int value)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int rc = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (offset &lt; 8)/* it is GPIO */</span>
<span class="p_del">-		rc = intel_scu_ipc_update_register(GPIO0 + offset,</span>
<span class="p_del">-				GPIO_DRV | (value ? GPIO_DOU : 0),</span>
<span class="p_del">-				GPIO_DRV | GPIO_DOU | GPIO_DIR);</span>
<span class="p_del">-	else if (offset &lt; 16)/* it is GPOSW */</span>
<span class="p_del">-		rc = intel_scu_ipc_update_register(GPOSWCTL0 + offset - 8,</span>
<span class="p_del">-				GPOSW_DRV | (value ? GPOSW_DOU : 0),</span>
<span class="p_del">-				GPOSW_DRV | GPOSW_DOU | GPOSW_RDRV);</span>
<span class="p_del">-	else if (offset &gt; 15 &amp;&amp; offset &lt; 24)/* it is GPO */</span>
<span class="p_del">-		rc = intel_scu_ipc_update_register(GPO,</span>
<span class="p_del">-				value ? 1 &lt;&lt; (offset - 16) : 0,</span>
<span class="p_del">-				1 &lt;&lt; (offset - 16));</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		pr_err(&quot;invalid PMIC GPIO pin %d!\n&quot;, offset);</span>
<span class="p_del">-		WARN_ON(1);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return rc;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int pmic_gpio_get(struct gpio_chip *chip, unsigned offset)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 r;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* we only have 8 GPIO pins we can use as input */</span>
<span class="p_del">-	if (offset &gt;= 8)</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-	ret = intel_scu_ipc_ioread8(GPIO0 + offset, &amp;r);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	return r &amp; GPIO_DIN;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pmic_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (offset &lt; 8)/* it is GPIO */</span>
<span class="p_del">-		intel_scu_ipc_update_register(GPIO0 + offset,</span>
<span class="p_del">-			GPIO_DRV | (value ? GPIO_DOU : 0),</span>
<span class="p_del">-			GPIO_DRV | GPIO_DOU);</span>
<span class="p_del">-	else if (offset &lt; 16)/* it is GPOSW */</span>
<span class="p_del">-		intel_scu_ipc_update_register(GPOSWCTL0 + offset - 8,</span>
<span class="p_del">-			GPOSW_DRV | (value ? GPOSW_DOU : 0),</span>
<span class="p_del">-			GPOSW_DRV | GPOSW_DOU | GPOSW_RDRV);</span>
<span class="p_del">-	else if (offset &gt; 15 &amp;&amp; offset &lt; 24) /* it is GPO */</span>
<span class="p_del">-		intel_scu_ipc_update_register(GPO,</span>
<span class="p_del">-			value ? 1 &lt;&lt; (offset - 16) : 0,</span>
<span class="p_del">-			1 &lt;&lt; (offset - 16));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This is called from genirq with pg-&gt;buslock locked and</span>
<span class="p_del">- * irq_desc-&gt;lock held. We can not access the scu bus here, so we</span>
<span class="p_del">- * store the change and update in the bus_sync_unlock() function below</span>
<span class="p_del">- */</span>
<span class="p_del">-static int pmic_irq_type(struct irq_data *data, unsigned type)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pmic_gpio *pg = irq_data_get_irq_chip_data(data);</span>
<span class="p_del">-	u32 gpio = data-&gt;irq - pg-&gt;irq_base;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (gpio &gt;= pg-&gt;chip.ngpio)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	pg-&gt;trigger_type = type;</span>
<span class="p_del">-	pg-&gt;update_type = gpio | GPIO_UPDATE_TYPE;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int pmic_gpio_to_irq(struct gpio_chip *chip, unsigned offset)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pmic_gpio *pg = gpiochip_get_data(chip);</span>
<span class="p_del">-</span>
<span class="p_del">-	return pg-&gt;irq_base + offset;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pmic_bus_lock(struct irq_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pmic_gpio *pg = irq_data_get_irq_chip_data(data);</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;pg-&gt;buslock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void pmic_bus_sync_unlock(struct irq_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pmic_gpio *pg = irq_data_get_irq_chip_data(data);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pg-&gt;update_type) {</span>
<span class="p_del">-		unsigned int gpio = pg-&gt;update_type &amp; ~GPIO_UPDATE_TYPE;</span>
<span class="p_del">-</span>
<span class="p_del">-		pmic_program_irqtype(gpio, pg-&gt;trigger_type);</span>
<span class="p_del">-		pg-&gt;update_type = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mutex_unlock(&amp;pg-&gt;buslock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* the gpiointr register is read-clear, so just do nothing. */</span>
<span class="p_del">-static void pmic_irq_unmask(struct irq_data *data) { }</span>
<span class="p_del">-</span>
<span class="p_del">-static void pmic_irq_mask(struct irq_data *data) { }</span>
<span class="p_del">-</span>
<span class="p_del">-static struct irq_chip pmic_irqchip = {</span>
<span class="p_del">-	.name			= &quot;PMIC-GPIO&quot;,</span>
<span class="p_del">-	.irq_mask		= pmic_irq_mask,</span>
<span class="p_del">-	.irq_unmask		= pmic_irq_unmask,</span>
<span class="p_del">-	.irq_set_type		= pmic_irq_type,</span>
<span class="p_del">-	.irq_bus_lock		= pmic_bus_lock,</span>
<span class="p_del">-	.irq_bus_sync_unlock	= pmic_bus_sync_unlock,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static irqreturn_t pmic_irq_handler(int irq, void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pmic_gpio *pg = data;</span>
<span class="p_del">-	u8 intsts = *((u8 *)pg-&gt;gpiointr + 4);</span>
<span class="p_del">-	int gpio;</span>
<span class="p_del">-	irqreturn_t ret = IRQ_NONE;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (gpio = 0; gpio &lt; 8; gpio++) {</span>
<span class="p_del">-		if (intsts &amp; (1 &lt;&lt; gpio)) {</span>
<span class="p_del">-			pr_debug(&quot;pmic pin %d triggered\n&quot;, gpio);</span>
<span class="p_del">-			generic_handle_irq(pg-&gt;irq_base + gpio);</span>
<span class="p_del">-			ret = IRQ_HANDLED;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int platform_pmic_gpio_probe(struct platform_device *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct device *dev = &amp;pdev-&gt;dev;</span>
<span class="p_del">-	int irq = platform_get_irq(pdev, 0);</span>
<span class="p_del">-	struct intel_pmic_gpio_platform_data *pdata = dev-&gt;platform_data;</span>
<span class="p_del">-</span>
<span class="p_del">-	struct pmic_gpio *pg;</span>
<span class="p_del">-	int retval;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (irq &lt; 0) {</span>
<span class="p_del">-		dev_dbg(dev, &quot;no IRQ line\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!pdata || !pdata-&gt;gpio_base || !pdata-&gt;irq_base) {</span>
<span class="p_del">-		dev_dbg(dev, &quot;incorrect or missing platform data\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	pg = kzalloc(sizeof(*pg), GFP_KERNEL);</span>
<span class="p_del">-	if (!pg)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev_set_drvdata(dev, pg);</span>
<span class="p_del">-</span>
<span class="p_del">-	pg-&gt;irq = irq;</span>
<span class="p_del">-	/* setting up SRAM mapping for GPIOINT register */</span>
<span class="p_del">-	pg-&gt;gpiointr = ioremap_nocache(pdata-&gt;gpiointr, 8);</span>
<span class="p_del">-	if (!pg-&gt;gpiointr) {</span>
<span class="p_del">-		pr_err(&quot;Can not map GPIOINT\n&quot;);</span>
<span class="p_del">-		retval = -EINVAL;</span>
<span class="p_del">-		goto err2;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	pg-&gt;irq_base = pdata-&gt;irq_base;</span>
<span class="p_del">-	pg-&gt;chip.label = &quot;intel_pmic&quot;;</span>
<span class="p_del">-	pg-&gt;chip.direction_input = pmic_gpio_direction_input;</span>
<span class="p_del">-	pg-&gt;chip.direction_output = pmic_gpio_direction_output;</span>
<span class="p_del">-	pg-&gt;chip.get = pmic_gpio_get;</span>
<span class="p_del">-	pg-&gt;chip.set = pmic_gpio_set;</span>
<span class="p_del">-	pg-&gt;chip.to_irq = pmic_gpio_to_irq;</span>
<span class="p_del">-	pg-&gt;chip.base = pdata-&gt;gpio_base;</span>
<span class="p_del">-	pg-&gt;chip.ngpio = NUM_GPIO;</span>
<span class="p_del">-	pg-&gt;chip.can_sleep = 1;</span>
<span class="p_del">-	pg-&gt;chip.parent = dev;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_init(&amp;pg-&gt;buslock);</span>
<span class="p_del">-</span>
<span class="p_del">-	pg-&gt;chip.parent = dev;</span>
<span class="p_del">-	retval = gpiochip_add_data(&amp;pg-&gt;chip, pg);</span>
<span class="p_del">-	if (retval) {</span>
<span class="p_del">-		pr_err(&quot;Can not add pmic gpio chip\n&quot;);</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	retval = request_irq(pg-&gt;irq, pmic_irq_handler, 0, &quot;pmic&quot;, pg);</span>
<span class="p_del">-	if (retval) {</span>
<span class="p_del">-		pr_warn(&quot;Interrupt request failed\n&quot;);</span>
<span class="p_del">-		goto fail_request_irq;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; 8; i++) {</span>
<span class="p_del">-		irq_set_chip_and_handler_name(i + pg-&gt;irq_base,</span>
<span class="p_del">-					      &amp;pmic_irqchip,</span>
<span class="p_del">-					      handle_simple_irq,</span>
<span class="p_del">-					      &quot;demux&quot;);</span>
<span class="p_del">-		irq_set_chip_data(i + pg-&gt;irq_base, pg);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-fail_request_irq:</span>
<span class="p_del">-	gpiochip_remove(&amp;pg-&gt;chip);</span>
<span class="p_del">-err:</span>
<span class="p_del">-	iounmap(pg-&gt;gpiointr);</span>
<span class="p_del">-err2:</span>
<span class="p_del">-	kfree(pg);</span>
<span class="p_del">-	return retval;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* at the same time, register a platform driver</span>
<span class="p_del">- * this supports the sfi 0.81 fw */</span>
<span class="p_del">-static struct platform_driver platform_pmic_gpio_driver = {</span>
<span class="p_del">-	.driver = {</span>
<span class="p_del">-		.name		= DRIVER_NAME,</span>
<span class="p_del">-	},</span>
<span class="p_del">-	.probe		= platform_pmic_gpio_probe,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int __init platform_pmic_gpio_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return platform_driver_register(&amp;platform_pmic_gpio_driver);</span>
<span class="p_del">-}</span>
<span class="p_del">-subsys_initcall(platform_pmic_gpio_init);</span>
<span class="p_header">diff --git a/include/linux/intel_pmic_gpio.h b/include/linux/intel_pmic_gpio.h</span>
deleted file mode 100644
<span class="p_header">index 920109a29191..000000000000</span>
<span class="p_header">--- a/include/linux/intel_pmic_gpio.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,15 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef LINUX_INTEL_PMIC_H</span>
<span class="p_del">-#define LINUX_INTEL_PMIC_H</span>
<span class="p_del">-</span>
<span class="p_del">-struct intel_pmic_gpio_platform_data {</span>
<span class="p_del">-	/* the first IRQ of the chip */</span>
<span class="p_del">-	unsigned	irq_base;</span>
<span class="p_del">-	/* number assigned to the first GPIO */</span>
<span class="p_del">-	unsigned	gpio_base;</span>
<span class="p_del">-	/* sram address for gpiointr register, the langwell chip will map</span>
<span class="p_del">-	 * the PMIC spi GPIO expander&#39;s GPIOINTR register in sram.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	unsigned	gpiointr;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-#endif</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



