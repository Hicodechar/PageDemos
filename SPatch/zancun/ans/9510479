
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v5,3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v5,3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 11, 2017, 3:34 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1484148852-29783-4-git-send-email-matt.redfearn@imgtec.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9510479/mbox/"
   >mbox</a>
|
   <a href="/patch/9510479/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9510479/">/patch/9510479/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9A3E66075C for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 15:38:53 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 84E06284D9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 15:38:53 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 79936285AF; Wed, 11 Jan 2017 15:38:53 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-1.9 required=2.0 tests=BAYES_00 autolearn=ham
	version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 14B2C284EC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 11 Jan 2017 15:38:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1030363AbdAKPez (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 11 Jan 2017 10:34:55 -0500
Received: from mailapp01.imgtec.com ([195.59.15.196]:10815 &quot;EHLO
	mailapp01.imgtec.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1763278AbdAKPen (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 11 Jan 2017 10:34:43 -0500
Received: from HHMAIL01.hh.imgtec.org (unknown [10.100.10.19])
	by Forcepoint Email with ESMTPS id 07D2FD2612A23;
	Wed, 11 Jan 2017 15:34:37 +0000 (GMT)
Received: from mredfearn-linux.le.imgtec.org (10.150.130.83) by
	HHMAIL01.hh.imgtec.org (10.100.10.21) with Microsoft SMTP Server
	(TLS) id 14.3.294.0; Wed, 11 Jan 2017 15:34:39 +0000
From: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
To: Ralf Baechle &lt;ralf@linux-mips.org&gt;,
	Bjorn Andersson &lt;bjorn.andersson@linaro.org&gt;,
	Ohad Ben-Cohen &lt;ohad@wizery.com&gt;, Thomas Gleixner &lt;tglx@linutronix.de&gt;
CC: &lt;linux-mips@linux-mips.org&gt;, &lt;linux-remoteproc@vger.kernel.org&gt;,
	&lt;lisa.parratt@imgtec.com&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
Subject: [PATCH v5 3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS
Date: Wed, 11 Jan 2017 15:34:11 +0000
Message-ID: &lt;1484148852-29783-4-git-send-email-matt.redfearn@imgtec.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1484148852-29783-1-git-send-email-matt.redfearn@imgtec.com&gt;
References: &lt;1484148852-29783-1-git-send-email-matt.redfearn@imgtec.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [10.150.130.83]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Jan. 11, 2017, 3:34 p.m.</div>
<pre class="content">
This driver allows a MIPS processor offlined from Linux to be used as a
remote processor. Firmware may be loaded via the sysfs interface and
changed at runtime, allowing the processor to handle real-time tasks or
perform coprocessing while remaining processors are available to Linux.

Coprocessor firmware must abide by the remoteproc standard, i.e.
implement the resource table containing memory layouts and virtio device
descriptions, and additionally abide by the MIPS UHI coprocessor boot
protocol in the startup code.
<span class="signed-off-by">
Signed-off-by: Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>

---

Changes in v5:
Depend on !64bit since this driver only works with 32bit kernels
Set mproc-&gt;tsk state to TASK_DEAD before freeing it to avoid warning
Flush icache of each carveout so that icache sees latest data written

Changes in v4:
Have a single mips-rproc device to be parent to each CPU&#39;s rproc device.
Support per-device coherence introduced in v4.9
Add a sysfs interface to control the mask of cpus available to rproc

Changes in v3:
Update MIPS remoteproc driver to use CPU hotplug state machine
Remove sysfs interface from MIPS rproc driver, now provided by the core.
Drop patches that Ralf has already merged to mips-next

Changes in v2: None

 Documentation/ABI/testing/sysfs-devices-mips-rproc |  13 +
 drivers/remoteproc/Kconfig                         |  11 +
 drivers/remoteproc/Makefile                        |   1 +
 drivers/remoteproc/mips_remoteproc.c               | 596 +++++++++++++++++++++
 4 files changed, 621 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-devices-mips-rproc
 create mode 100644 drivers/remoteproc/mips_remoteproc.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Jan. 19, 2017, 3:09 p.m.</div>
<pre class="content">
Hi Bjorn,

Please could you review this driver?

Thanks,

Matt


On 11/01/17 15:34, Matt Redfearn wrote:
<span class="quote">&gt; This driver allows a MIPS processor offlined from Linux to be used as a</span>
<span class="quote">&gt; remote processor. Firmware may be loaded via the sysfs interface and</span>
<span class="quote">&gt; changed at runtime, allowing the processor to handle real-time tasks or</span>
<span class="quote">&gt; perform coprocessing while remaining processors are available to Linux.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Coprocessor firmware must abide by the remoteproc standard, i.e.</span>
<span class="quote">&gt; implement the resource table containing memory layouts and virtio device</span>
<span class="quote">&gt; descriptions, and additionally abide by the MIPS UHI coprocessor boot</span>
<span class="quote">&gt; protocol in the startup code.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Changes in v5:</span>
<span class="quote">&gt; Depend on !64bit since this driver only works with 32bit kernels</span>
<span class="quote">&gt; Set mproc-&gt;tsk state to TASK_DEAD before freeing it to avoid warning</span>
<span class="quote">&gt; Flush icache of each carveout so that icache sees latest data written</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Changes in v4:</span>
<span class="quote">&gt; Have a single mips-rproc device to be parent to each CPU&#39;s rproc device.</span>
<span class="quote">&gt; Support per-device coherence introduced in v4.9</span>
<span class="quote">&gt; Add a sysfs interface to control the mask of cpus available to rproc</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Changes in v3:</span>
<span class="quote">&gt; Update MIPS remoteproc driver to use CPU hotplug state machine</span>
<span class="quote">&gt; Remove sysfs interface from MIPS rproc driver, now provided by the core.</span>
<span class="quote">&gt; Drop patches that Ralf has already merged to mips-next</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Changes in v2: None</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   Documentation/ABI/testing/sysfs-devices-mips-rproc |  13 +</span>
<span class="quote">&gt;   drivers/remoteproc/Kconfig                         |  11 +</span>
<span class="quote">&gt;   drivers/remoteproc/Makefile                        |   1 +</span>
<span class="quote">&gt;   drivers/remoteproc/mips_remoteproc.c               | 596 +++++++++++++++++++++</span>
<span class="quote">&gt;   4 files changed, 621 insertions(+)</span>
<span class="quote">&gt;   create mode 100644 Documentation/ABI/testing/sysfs-devices-mips-rproc</span>
<span class="quote">&gt;   create mode 100644 drivers/remoteproc/mips_remoteproc.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/Documentation/ABI/testing/sysfs-devices-mips-rproc b/Documentation/ABI/testing/sysfs-devices-mips-rproc</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..b06f6671807a</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/Documentation/ABI/testing/sysfs-devices-mips-rproc</span>
<span class="quote">&gt; @@ -0,0 +1,13 @@</span>
<span class="quote">&gt; +What:		/sys/devices/mips-rproc/cpus</span>
<span class="quote">&gt; +Date:		October 2016</span>
<span class="quote">&gt; +Contact:	Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="quote">&gt; +Description:</span>
<span class="quote">&gt; +		CPU topology file describing which CPUs may be used by the</span>
<span class="quote">&gt; +		MIPS remote processor driver when offline from Linux.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		This can be read to observe the current setting, or written to</span>
<span class="quote">&gt; +		change the allowed CPUs.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		The format is compatible with cpulist_parse()</span>
<span class="quote">&gt; +		[see &lt;linux/cpumask.h&gt;], for example to enable the MIPS remote</span>
<span class="quote">&gt; +		processor driver on CPUs 1,2 &amp; 3, write &quot;1-3&quot; into this file.</span>
<span class="quote">&gt; diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig</span>
<span class="quote">&gt; index 8f9cf0bc571c..3be2202f639d 100644</span>
<span class="quote">&gt; --- a/drivers/remoteproc/Kconfig</span>
<span class="quote">&gt; +++ b/drivers/remoteproc/Kconfig</span>
<span class="quote">&gt; @@ -68,6 +68,17 @@ config DA8XX_REMOTEPROC</span>
<span class="quote">&gt;   	  It&#39;s safe to say n here if you&#39;re not interested in multimedia</span>
<span class="quote">&gt;   	  offloading.</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +config MIPS_REMOTEPROC</span>
<span class="quote">&gt; +	tristate &quot;MIPS remoteproc support&quot;</span>
<span class="quote">&gt; +	depends on MIPS_CPS &amp;&amp; HAS_DMA &amp;&amp; !64BIT</span>
<span class="quote">&gt; +	depends on REMOTEPROC</span>
<span class="quote">&gt; +	select CMA</span>
<span class="quote">&gt; +	select MIPS_CPU_STEAL</span>
<span class="quote">&gt; +	help</span>
<span class="quote">&gt; +	  Say y here to support using offline cores/VPEs as remote processors</span>
<span class="quote">&gt; +	  via the remote processor framework.</span>
<span class="quote">&gt; +	  If unsure say N.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   config QCOM_ADSP_PIL</span>
<span class="quote">&gt;   	tristate &quot;Qualcomm ADSP Peripheral Image Loader&quot;</span>
<span class="quote">&gt;   	depends on OF &amp;&amp; ARCH_QCOM</span>
<span class="quote">&gt; diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile</span>
<span class="quote">&gt; index 0938ea3c41ba..580ee8907da9 100644</span>
<span class="quote">&gt; --- a/drivers/remoteproc/Makefile</span>
<span class="quote">&gt; +++ b/drivers/remoteproc/Makefile</span>
<span class="quote">&gt; @@ -11,6 +11,7 @@ remoteproc-y				+= remoteproc_elf_loader.o</span>
<span class="quote">&gt;   obj-$(CONFIG_OMAP_REMOTEPROC)		+= omap_remoteproc.o</span>
<span class="quote">&gt;   obj-$(CONFIG_WKUP_M3_RPROC)		+= wkup_m3_rproc.o</span>
<span class="quote">&gt;   obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o</span>
<span class="quote">&gt; +obj-$(CONFIG_MIPS_REMOTEPROC)		+= mips_remoteproc.o</span>
<span class="quote">&gt;   obj-$(CONFIG_QCOM_ADSP_PIL)		+= qcom_adsp_pil.o</span>
<span class="quote">&gt;   obj-$(CONFIG_QCOM_MDT_LOADER)		+= qcom_mdt_loader.o</span>
<span class="quote">&gt;   obj-$(CONFIG_QCOM_Q6V5_PIL)		+= qcom_q6v5_pil.o</span>
<span class="quote">&gt; diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..9a2a7bbddc0a</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="quote">&gt; @@ -0,0 +1,596 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * MIPS Remote Processor driver</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright (C) 2016 Imagination Technologies</span>
<span class="quote">&gt; + * Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="quote">&gt; + * Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify it</span>
<span class="quote">&gt; + * under the terms of the GNU General Public License as published by the</span>
<span class="quote">&gt; + * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="quote">&gt; + * option) any later version.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/cpu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/dma-mapping.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/remoteproc.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;asm/cacheflush.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/smp-cps.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbmisc.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &quot;remoteproc_internal.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct mips_rproc {</span>
<span class="quote">&gt; +	char			name[16];</span>
<span class="quote">&gt; +	struct rproc		*rproc;</span>
<span class="quote">&gt; +	struct task_struct	*tsk;</span>
<span class="quote">&gt; +	unsigned int		cpu;</span>
<span class="quote">&gt; +	int			ipi_linux;</span>
<span class="quote">&gt; +	int			ipi_remote;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Parent device for MIPS remoteproc */</span>
<span class="quote">&gt; +static struct device mips_rproc_dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Array of allocated MIPS remote processor instances */</span>
<span class="quote">&gt; +static struct mips_rproc *mips_rprocs[NR_CPUS];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Bitmap used to identify which CPUs are available to rproc */</span>
<span class="quote">&gt; +static cpumask_var_t mips_rproc_cpumask;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Dynamic CPU hotplug state associated with this driver */</span>
<span class="quote">&gt; +static int cpuhp_state;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Add wired entry to map a device address to physical memory */</span>
<span class="quote">&gt; +static void mips_map_page(unsigned long da, unsigned long pa, int c,</span>
<span class="quote">&gt; +			  unsigned long pagesize)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long pa2 = pa + (pagesize / 2);</span>
<span class="quote">&gt; +	unsigned long entryhi, entrylo0, entrylo1;</span>
<span class="quote">&gt; +	unsigned long pagemask = pagesize - 0x2000;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pa = (pa &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="quote">&gt; +	pa2 = (pa2 &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="quote">&gt; +	entryhi = da &amp; 0xfffffe000;</span>
<span class="quote">&gt; +	entrylo0 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa;</span>
<span class="quote">&gt; +	entrylo1 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pr_debug(&quot;Create wired entry %d, CCA %d\n&quot;, read_c0_wired(), c);</span>
<span class="quote">&gt; +	pr_debug(&quot; EntryHi: 0x%016lx\n&quot;, entryhi);</span>
<span class="quote">&gt; +	pr_debug(&quot; EntryLo0: 0x%016lx\n&quot;, entrylo0);</span>
<span class="quote">&gt; +	pr_debug(&quot; EntryLo1: 0x%016lx\n&quot;, entrylo1);</span>
<span class="quote">&gt; +	pr_debug(&quot; Pagemask: 0x%016lx\n&quot;, pagemask);</span>
<span class="quote">&gt; +	pr_debug(&quot;\n&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	add_wired_entry(entrylo0, entrylo1, entryhi, pagemask);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Compute the largest page mask a physical address can be mapped with */</span>
<span class="quote">&gt; +static unsigned long mips_rproc_largest_pm(unsigned long pa,</span>
<span class="quote">&gt; +					   unsigned long maxmask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long mask;</span>
<span class="quote">&gt; +	/* Find address bits limiting alignment */</span>
<span class="quote">&gt; +	unsigned long shift = ffs(pa);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Obey MIPS restrictions on page sizes */</span>
<span class="quote">&gt; +	if (pa) {</span>
<span class="quote">&gt; +		if (shift &amp; 1)</span>
<span class="quote">&gt; +			shift -= 2;</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			shift--;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	mask = ULONG_MAX &lt;&lt; shift;</span>
<span class="quote">&gt; +	return maxmask &amp; ~mask;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Compute the page mask one step larger than a given page mask */</span>
<span class="quote">&gt; +static unsigned long mips_rproc_next_pm(unsigned long pm, unsigned long maxmask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +#define PM_SHIFT 13</span>
<span class="quote">&gt; +	return ((pm &lt;&lt; 2) | (0x3 &lt;&lt; PM_SHIFT)) &amp; maxmask;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Add mappings to the TLB such that memory allocated by the kernel for a</span>
<span class="quote">&gt; + * firmware component appears at the right virtual address</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static inline void mips_rproc_map(unsigned long da, unsigned long pa, int c,</span>
<span class="quote">&gt; +				  unsigned long size, unsigned long maxmask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	/* minimum mappable size is 2 * 4k pages */</span>
<span class="quote">&gt; +	const unsigned long min_map_sz = 0x2000;</span>
<span class="quote">&gt; +	unsigned long bigmask, nextmask;</span>
<span class="quote">&gt; +	unsigned long distance, target;</span>
<span class="quote">&gt; +	unsigned long page2_size; /* Size of the 2 buddy pages */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	do {</span>
<span class="quote">&gt; +		/* Compute the current largest page mask */</span>
<span class="quote">&gt; +		bigmask = mips_rproc_largest_pm(pa, maxmask);</span>
<span class="quote">&gt; +		/* Compute the next largest pagesize */</span>
<span class="quote">&gt; +		nextmask = mips_rproc_next_pm(bigmask, maxmask);</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Compute the distance from our current physical address to</span>
<span class="quote">&gt; +		 * the next page boundary.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		distance = (nextmask + min_map_sz) - (pa &amp; nextmask);</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Decide between searching to get to the next highest page</span>
<span class="quote">&gt; +		 * boundary or finishing.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		target = distance &lt; size ? distance : size;</span>
<span class="quote">&gt; +		while (target) {</span>
<span class="quote">&gt; +			/* Find the largest supported page size that will fit */</span>
<span class="quote">&gt; +			for (page2_size = maxmask + min_map_sz;</span>
<span class="quote">&gt; +			    (page2_size &gt; min_map_sz) &amp;&amp; (page2_size &gt; target);</span>
<span class="quote">&gt; +			     page2_size /= 4) {</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +			/* Emit it */</span>
<span class="quote">&gt; +			mips_map_page(da, pa, c, page2_size);</span>
<span class="quote">&gt; +			/* Move to next step */</span>
<span class="quote">&gt; +			size -= page2_size;</span>
<span class="quote">&gt; +			da += page2_size;</span>
<span class="quote">&gt; +			pa += page2_size;</span>
<span class="quote">&gt; +			target -= page2_size;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	} while (size);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mips_rproc_carveouts(struct rproc *rproc, int max_pagemask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct rproc_mem_entry *carveout;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each_entry(carveout, &amp;rproc-&gt;carveouts, node) {</span>
<span class="quote">&gt; +		int c = CONF_CM_CACHABLE_COW;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="quote">&gt; +			&quot;carveout mapping da 0x%x -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="quote">&gt; +			carveout-&gt;da, &amp;carveout-&gt;dma, carveout-&gt;len, c);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		mips_rproc_map(carveout-&gt;da, carveout-&gt;dma, c,</span>
<span class="quote">&gt; +				carveout-&gt;len, max_pagemask);</span>
<span class="quote">&gt; +		flush_icache_range((unsigned long)carveout-&gt;va,</span>
<span class="quote">&gt; +				   (unsigned long)carveout-&gt;va + carveout-&gt;len);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mips_rproc_vdevs(struct rproc *rproc, int max_pagemask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct rproc_vdev *rvdev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each_entry(rvdev, &amp;rproc-&gt;rvdevs, node) {</span>
<span class="quote">&gt; +		int i, size;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		for (i = 0; i &lt; ARRAY_SIZE(rvdev-&gt;vring); i++) {</span>
<span class="quote">&gt; +			struct rproc_vring *vring = &amp;rvdev-&gt;vring[i];</span>
<span class="quote">&gt; +			unsigned long pa = vring-&gt;dma;</span>
<span class="quote">&gt; +			int c;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			if (plat_device_is_coherent(&amp;mips_rproc_dev)) {</span>
<span class="quote">&gt; +				/*</span>
<span class="quote">&gt; +				 * The DMA API will allocate cacheable buffers</span>
<span class="quote">&gt; +				 * for shared resources, so the firmware should</span>
<span class="quote">&gt; +				 * also access those buffers cached</span>
<span class="quote">&gt; +				 */</span>
<span class="quote">&gt; +				c = (_page_cachable_default &gt;&gt; _CACHE_SHIFT);</span>
<span class="quote">&gt; +			} else {</span>
<span class="quote">&gt; +				/*</span>
<span class="quote">&gt; +				 * Otherwise, shared buffers should be accessed</span>
<span class="quote">&gt; +				 * uncached</span>
<span class="quote">&gt; +				 */</span>
<span class="quote">&gt; +				c = CONF_CM_UNCACHED;</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			/* actual size of vring (in bytes) */</span>
<span class="quote">&gt; +			size = PAGE_ALIGN(vring_size(vring-&gt;len, vring-&gt;align));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="quote">&gt; +				&quot;vring mapping da %pad -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="quote">&gt; +				&amp;vring-&gt;dma, &amp;vring-&gt;dma, size, c);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			mips_rproc_map(pa, pa, c, size, max_pagemask);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mips_rproc_cpu_entry(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = mips_rprocs[smp_processor_id()];</span>
<span class="quote">&gt; +	struct rproc *rproc = mproc-&gt;rproc;</span>
<span class="quote">&gt; +	int ipi_to_remote = ipi_get_hwirq(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="quote">&gt; +	int ipi_from_remote = ipi_get_hwirq(mproc-&gt;ipi_linux, 0);</span>
<span class="quote">&gt; +	unsigned long old_pagemask, max_pagemask;</span>
<span class="quote">&gt; +	void (*fw_entry)(int, int ipi_to_remote, int ipi_from_remote, int);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev_info(&amp;rproc-&gt;dev, &quot;%s booting firmware %s\n&quot;,</span>
<span class="quote">&gt; +		 rproc-&gt;name, rproc-&gt;firmware);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Get the maximum pagemask supported on this CPU */</span>
<span class="quote">&gt; +	old_pagemask = read_c0_pagemask();</span>
<span class="quote">&gt; +	write_c0_pagemask(~0);</span>
<span class="quote">&gt; +	back_to_back_c0_hazard();</span>
<span class="quote">&gt; +	max_pagemask = read_c0_pagemask();</span>
<span class="quote">&gt; +	write_c0_pagemask(old_pagemask);</span>
<span class="quote">&gt; +	back_to_back_c0_hazard();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Start with no wired entries */</span>
<span class="quote">&gt; +	write_c0_wired(0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Flush all previous TLB entries */</span>
<span class="quote">&gt; +	local_flush_tlb_all();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set ASID 0 */</span>
<span class="quote">&gt; +	write_c0_entryhi(0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Map firmware resources into virtual memory */</span>
<span class="quote">&gt; +	mips_rproc_carveouts(rproc, max_pagemask);</span>
<span class="quote">&gt; +	mips_rproc_vdevs(rproc, max_pagemask);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI to remote: %d\n&quot;, ipi_to_remote);</span>
<span class="quote">&gt; +	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI from remote: %d\n&quot;, ipi_from_remote);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Hand off the CPU to the firmware */</span>
<span class="quote">&gt; +	dev_dbg(&amp;rproc-&gt;dev, &quot;Jumping to firmware at 0x%x\n&quot;, rproc-&gt;bootaddr);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Jump into the firmware, obeying the firmware protocol. */</span>
<span class="quote">&gt; +	fw_entry = (void *)rproc-&gt;bootaddr;</span>
<span class="quote">&gt; +	fw_entry(-3, ipi_to_remote, ipi_from_remote, 0);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static irqreturn_t mips_rproc_ipi_handler(int irq, void *dev_id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	/* Synthetic interrupts shouldn&#39;t need acking */</span>
<span class="quote">&gt; +	return IRQ_WAKE_THREAD;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static irqreturn_t mips_rproc_vq_int(int irq, void *p)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct rproc *rproc = (struct rproc *)p;</span>
<span class="quote">&gt; +	void *entry;</span>
<span class="quote">&gt; +	int id;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* We don&#39;t have a mailbox, so iterate over all vqs and kick them. */</span>
<span class="quote">&gt; +	idr_for_each_entry(&amp;rproc-&gt;notifyids, entry, id)</span>
<span class="quote">&gt; +		rproc_vq_interrupt(rproc, id);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return IRQ_HANDLED;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Helper function to find the IPI domain */</span>
<span class="quote">&gt; +static struct irq_domain *ipi_domain(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device_node *node = of_irq_find_parent(of_root);</span>
<span class="quote">&gt; +	struct irq_domain *ipidomain;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ipidomain = irq_find_matching_host(node, DOMAIN_BUS_IPI);</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Some platforms have half DT setup. So if we found irq node but</span>
<span class="quote">&gt; +	 * didn&#39;t find an ipidomain, try to search for one that is not in the</span>
<span class="quote">&gt; +	 * DT.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (node &amp;&amp; !ipidomain)</span>
<span class="quote">&gt; +		ipidomain = irq_find_matching_host(NULL, DOMAIN_BUS_IPI);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ipidomain;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="quote">&gt; +	int err;</span>
<span class="quote">&gt; +	int cpu = mproc-&gt;cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="quote">&gt; +	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="quote">&gt; +	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="quote">&gt; +	if (mips_smp_ipi_free(get_cpu_mask(cpu))) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="quote">&gt; +		goto exit_free_tsk;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="quote">&gt; +	 * offlined while the remote CPU is running.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="quote">&gt; +	if (!mproc-&gt;ipi_linux) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="quote">&gt; +		goto exit_restore_ipi;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="quote">&gt; +	if (!mproc-&gt;ipi_remote) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="quote">&gt; +		goto exit_destroy_ipi_linux;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* register incoming ipi */</span>
<span class="quote">&gt; +	err = request_threaded_irq(mproc-&gt;ipi_linux, mips_rproc_ipi_handler,</span>
<span class="quote">&gt; +				   mips_rproc_vq_int, 0,</span>
<span class="quote">&gt; +				   &quot;mips-rproc IPI in&quot;, rproc);</span>
<span class="quote">&gt; +	if (err) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="quote">&gt; +			err);</span>
<span class="quote">&gt; +		goto exit_destroy_ipi_remote;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="quote">&gt; +						mproc-&gt;tsk)) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="quote">&gt; +		goto exit_free_irq;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +exit_free_irq:</span>
<span class="quote">&gt; +	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="quote">&gt; +exit_destroy_ipi_remote:</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="quote">&gt; +exit_destroy_ipi_linux:</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt; +exit_restore_ipi:</span>
<span class="quote">&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt; +	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="quote">&gt; +exit_free_tsk:</span>
<span class="quote">&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return -EINVAL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt; +	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	set_task_state(mproc-&gt;tsk, TASK_DEAD);</span>
<span class="quote">&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void mips_rproc_op_kick(struct rproc *rproc, int vqid)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (rproc-&gt;state == RPROC_RUNNING)</span>
<span class="quote">&gt; +		ipi_send_single(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct rproc_ops mips_rproc_proc_ops = {</span>
<span class="quote">&gt; +	.start	= mips_rproc_op_start,</span>
<span class="quote">&gt; +	.stop	= mips_rproc_op_stop,</span>
<span class="quote">&gt; +	.kick	= mips_rproc_op_kick,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Create an rproc instance in response to CPU down */</span>
<span class="quote">&gt; +static int mips_rproc_device_register(unsigned int cpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	char *template = &quot;mips-cpu%u&quot;;</span>
<span class="quote">&gt; +	struct rproc *rproc;</span>
<span class="quote">&gt; +	struct mips_rproc *mproc;</span>
<span class="quote">&gt; +	int err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!cpumask_test_cpu(cpu, mips_rproc_cpumask))</span>
<span class="quote">&gt; +		/* The CPU is not in the mask, so don&#39;t register rproc on it */</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pr_debug(&quot;Allocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mips_rprocs[cpu]) {</span>
<span class="quote">&gt; +		dev_err(&amp;mips_rproc_dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mproc = kzalloc(sizeof(struct mips_rproc), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!mproc) {</span>
<span class="quote">&gt; +		err = -ENOMEM;</span>
<span class="quote">&gt; +		goto exit;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	snprintf(mproc-&gt;name, sizeof(mproc-&gt;name), template, cpu);</span>
<span class="quote">&gt; +	mproc-&gt;cpu = cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	rproc = rproc_alloc(&amp;mips_rproc_dev, mproc-&gt;name,</span>
<span class="quote">&gt; +			    &amp;mips_rproc_proc_ops, NULL,</span>
<span class="quote">&gt; +			    sizeof(struct mips_rproc *));</span>
<span class="quote">&gt; +	if (!rproc) {</span>
<span class="quote">&gt; +		dev_err(&amp;mips_rproc_dev, &quot;Error allocating rproc\n&quot;);</span>
<span class="quote">&gt; +		err = -ENOMEM;</span>
<span class="quote">&gt; +		goto exit_free_mproc;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mproc-&gt;rproc = rproc;</span>
<span class="quote">&gt; +	rproc-&gt;priv = (void *)mproc;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	err = rproc_add(rproc);</span>
<span class="quote">&gt; +	if (err) {</span>
<span class="quote">&gt; +		dev_err(&amp;mips_rproc_dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="quote">&gt; +		goto exit_free_rproc;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mips_rprocs[cpu] = mproc;</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +exit_free_rproc:</span>
<span class="quote">&gt; +	rproc_free(rproc);</span>
<span class="quote">&gt; +exit_free_mproc:</span>
<span class="quote">&gt; +	kfree(mproc);</span>
<span class="quote">&gt; +exit:</span>
<span class="quote">&gt; +	return err;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Destroy rproc instance in response to CPU up */</span>
<span class="quote">&gt; +static int mips_rproc_device_unregister(unsigned int cpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = mips_rprocs[cpu];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!mproc)</span>
<span class="quote">&gt; +		/* No rproc instance has been created for this CPU */</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pr_debug(&quot;Deallocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	rproc_del(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	rproc_put(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	kfree(mproc);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mips_rprocs[cpu] = NULL;</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Show MIPS CPUs available to rproc */</span>
<span class="quote">&gt; +static ssize_t cpus_show(struct device *dev, struct device_attribute *attr,</span>
<span class="quote">&gt; +			  char *buf)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return cpumap_print_to_pagebuf(true, buf, mips_rproc_cpumask);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Allow MIPS CPUs to be made available to rproc */</span>
<span class="quote">&gt; +static ssize_t cpus_store(struct device *dev,</span>
<span class="quote">&gt; +			      struct device_attribute *attr,</span>
<span class="quote">&gt; +			      const char *buf, size_t count)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	static cpumask_var_t new_mask;</span>
<span class="quote">&gt; +	int err, cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	err = cpulist_parse(buf, new_mask);</span>
<span class="quote">&gt; +	if (err)</span>
<span class="quote">&gt; +		return err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Prevent CPU hotplug on/offlining CPUs while we do this */</span>
<span class="quote">&gt; +	get_online_cpus();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for_each_possible_cpu(cpu) {</span>
<span class="quote">&gt; +		if (cpumask_test_cpu(cpu, mips_rproc_cpumask) &amp;&amp;</span>
<span class="quote">&gt; +		    !cpumask_test_cpu(cpu, new_mask)) {</span>
<span class="quote">&gt; +			/* CPU no longer allowed. Release any instance on it */</span>
<span class="quote">&gt; +			cpumask_clear_cpu(cpu, mips_rproc_cpumask);</span>
<span class="quote">&gt; +			mips_rproc_device_unregister(cpu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		} else if (!cpumask_test_cpu(cpu, mips_rproc_cpumask) &amp;&amp;</span>
<span class="quote">&gt; +			   cpumask_test_cpu(cpu, new_mask)) {</span>
<span class="quote">&gt; +			/* If the CPU isn&#39;t online, start an instance */</span>
<span class="quote">&gt; +			cpumask_set_cpu(cpu, mips_rproc_cpumask);</span>
<span class="quote">&gt; +			if (!cpu_online(cpu))</span>
<span class="quote">&gt; +				mips_rproc_device_register(cpu);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	put_online_cpus();</span>
<span class="quote">&gt; +	return count;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +static DEVICE_ATTR_RW(cpus);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct attribute *mips_rproc_attrs[] = {</span>
<span class="quote">&gt; +	&amp;dev_attr_cpus.attr,</span>
<span class="quote">&gt; +	NULL</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct attribute_group mips_rproc_devgroup = {</span>
<span class="quote">&gt; +	.attrs = mips_rproc_attrs</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct attribute_group *mips_rproc_devgroups[] = {</span>
<span class="quote">&gt; +	&amp;mips_rproc_devgroup,</span>
<span class="quote">&gt; +	NULL</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +static struct device_type mips_rproc_type = {</span>
<span class="quote">&gt; +	.groups = mips_rproc_devgroups,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct platform_driver mips_rproc_driver = {</span>
<span class="quote">&gt; +	.driver = {</span>
<span class="quote">&gt; +		.name = &quot;mips-rproc&quot;,</span>
<span class="quote">&gt; +	},</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init mips_rproc_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if ((!cpu_has_mipsmt) &amp;&amp; (!cpu_has_vp)) {</span>
<span class="quote">&gt; +		pr_debug(&quot;MIPS rproc not supported on this cpu\n&quot;);</span>
<span class="quote">&gt; +		return -EIO;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mips_rproc_dev.driver = &amp;mips_rproc_driver.driver;</span>
<span class="quote">&gt; +	mips_rproc_dev.type = &amp;mips_rproc_type;</span>
<span class="quote">&gt; +	dev_set_name(&amp;mips_rproc_dev, &quot;mips-rproc&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set device to have coherent DMA ops */</span>
<span class="quote">&gt; +	arch_setup_dma_ops(&amp;mips_rproc_dev, 0, 0, NULL, 1);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	err = device_register(&amp;mips_rproc_dev);</span>
<span class="quote">&gt; +	if (err) {</span>
<span class="quote">&gt; +		dev_err(&amp;mips_rproc_dev, &quot;Error adding MIPS rproc: %d\n&quot;, err);</span>
<span class="quote">&gt; +		return err;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Register with the cpu hotplug state machine.</span>
<span class="quote">&gt; +	 * This driver requires opposite sense to &quot;normal&quot; drivers, since the</span>
<span class="quote">&gt; +	 * driver is activated for offline CPUs via the teardown callback and</span>
<span class="quote">&gt; +	 * deactivated via the online callback.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	err = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, &quot;MIPS:REMOTEPROC&quot;,</span>
<span class="quote">&gt; +				mips_rproc_device_unregister,</span>
<span class="quote">&gt; +				mips_rproc_device_register);</span>
<span class="quote">&gt; +	if (err &lt; 0) {</span>
<span class="quote">&gt; +		device_unregister(&amp;mips_rproc_dev);</span>
<span class="quote">&gt; +		return err;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	cpuhp_state = err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void __exit mips_rproc_exit(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (cpuhp_state) {</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Unregister with the cpu hotplug state machine, but don&#39;t call</span>
<span class="quote">&gt; +		 * the teardown callback, since that would try to start the</span>
<span class="quote">&gt; +		 * remote processor device.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		__cpuhp_remove_state(cpuhp_state, false);</span>
<span class="quote">&gt; +		cpuhp_state = 0;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	get_online_cpus();</span>
<span class="quote">&gt; +	/* Unregister devices created for any offline CPUs */</span>
<span class="quote">&gt; +	for_each_possible_cpu(cpu)</span>
<span class="quote">&gt; +		mips_rproc_device_unregister(cpu);</span>
<span class="quote">&gt; +	put_online_cpus();</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +late_initcall(mips_rproc_init);</span>
<span class="quote">&gt; +module_exit(mips_rproc_exit);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +module_platform_driver(mips_rproc_driver);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="quote">&gt; +MODULE_DESCRIPTION(&quot;MIPS Remote Processor control driver&quot;);</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-devices-mips-rproc b/Documentation/ABI/testing/sysfs-devices-mips-rproc</span>
new file mode 100644
<span class="p_header">index 000000000000..b06f6671807a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-devices-mips-rproc</span>
<span class="p_chunk">@@ -0,0 +1,13 @@</span> <span class="p_context"></span>
<span class="p_add">+What:		/sys/devices/mips-rproc/cpus</span>
<span class="p_add">+Date:		October 2016</span>
<span class="p_add">+Contact:	Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="p_add">+Description:</span>
<span class="p_add">+		CPU topology file describing which CPUs may be used by the</span>
<span class="p_add">+		MIPS remote processor driver when offline from Linux.</span>
<span class="p_add">+</span>
<span class="p_add">+		This can be read to observe the current setting, or written to</span>
<span class="p_add">+		change the allowed CPUs.</span>
<span class="p_add">+</span>
<span class="p_add">+		The format is compatible with cpulist_parse()</span>
<span class="p_add">+		[see &lt;linux/cpumask.h&gt;], for example to enable the MIPS remote</span>
<span class="p_add">+		processor driver on CPUs 1,2 &amp; 3, write &quot;1-3&quot; into this file.</span>
<span class="p_header">diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig</span>
<span class="p_header">index 8f9cf0bc571c..3be2202f639d 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Kconfig</span>
<span class="p_header">+++ b/drivers/remoteproc/Kconfig</span>
<span class="p_chunk">@@ -68,6 +68,17 @@</span> <span class="p_context"> config DA8XX_REMOTEPROC</span>
 	  It&#39;s safe to say n here if you&#39;re not interested in multimedia
 	  offloading.
 
<span class="p_add">+config MIPS_REMOTEPROC</span>
<span class="p_add">+	tristate &quot;MIPS remoteproc support&quot;</span>
<span class="p_add">+	depends on MIPS_CPS &amp;&amp; HAS_DMA &amp;&amp; !64BIT</span>
<span class="p_add">+	depends on REMOTEPROC</span>
<span class="p_add">+	select CMA</span>
<span class="p_add">+	select MIPS_CPU_STEAL</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Say y here to support using offline cores/VPEs as remote processors</span>
<span class="p_add">+	  via the remote processor framework.</span>
<span class="p_add">+	  If unsure say N.</span>
<span class="p_add">+</span>
 config QCOM_ADSP_PIL
 	tristate &quot;Qualcomm ADSP Peripheral Image Loader&quot;
 	depends on OF &amp;&amp; ARCH_QCOM
<span class="p_header">diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile</span>
<span class="p_header">index 0938ea3c41ba..580ee8907da9 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Makefile</span>
<span class="p_header">+++ b/drivers/remoteproc/Makefile</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"> remoteproc-y				+= remoteproc_elf_loader.o</span>
 obj-$(CONFIG_OMAP_REMOTEPROC)		+= omap_remoteproc.o
 obj-$(CONFIG_WKUP_M3_RPROC)		+= wkup_m3_rproc.o
 obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o
<span class="p_add">+obj-$(CONFIG_MIPS_REMOTEPROC)		+= mips_remoteproc.o</span>
 obj-$(CONFIG_QCOM_ADSP_PIL)		+= qcom_adsp_pil.o
 obj-$(CONFIG_QCOM_MDT_LOADER)		+= qcom_mdt_loader.o
 obj-$(CONFIG_QCOM_Q6V5_PIL)		+= qcom_q6v5_pil.o
<span class="p_header">diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
new file mode 100644
<span class="p_header">index 000000000000..9a2a7bbddc0a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="p_chunk">@@ -0,0 +1,596 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MIPS Remote Processor driver</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Imagination Technologies</span>
<span class="p_add">+ * Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="p_add">+ * Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify it</span>
<span class="p_add">+ * under the terms of the GNU General Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-mapping.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/remoteproc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp-cps.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbmisc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;remoteproc_internal.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+struct mips_rproc {</span>
<span class="p_add">+	char			name[16];</span>
<span class="p_add">+	struct rproc		*rproc;</span>
<span class="p_add">+	struct task_struct	*tsk;</span>
<span class="p_add">+	unsigned int		cpu;</span>
<span class="p_add">+	int			ipi_linux;</span>
<span class="p_add">+	int			ipi_remote;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Parent device for MIPS remoteproc */</span>
<span class="p_add">+static struct device mips_rproc_dev;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Array of allocated MIPS remote processor instances */</span>
<span class="p_add">+static struct mips_rproc *mips_rprocs[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+/* Bitmap used to identify which CPUs are available to rproc */</span>
<span class="p_add">+static cpumask_var_t mips_rproc_cpumask;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Dynamic CPU hotplug state associated with this driver */</span>
<span class="p_add">+static int cpuhp_state;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Add wired entry to map a device address to physical memory */</span>
<span class="p_add">+static void mips_map_page(unsigned long da, unsigned long pa, int c,</span>
<span class="p_add">+			  unsigned long pagesize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pa2 = pa + (pagesize / 2);</span>
<span class="p_add">+	unsigned long entryhi, entrylo0, entrylo1;</span>
<span class="p_add">+	unsigned long pagemask = pagesize - 0x2000;</span>
<span class="p_add">+</span>
<span class="p_add">+	pa = (pa &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	pa2 = (pa2 &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	entryhi = da &amp; 0xfffffe000;</span>
<span class="p_add">+	entrylo0 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa;</span>
<span class="p_add">+	entrylo1 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa2;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Create wired entry %d, CCA %d\n&quot;, read_c0_wired(), c);</span>
<span class="p_add">+	pr_debug(&quot; EntryHi: 0x%016lx\n&quot;, entryhi);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo0: 0x%016lx\n&quot;, entrylo0);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo1: 0x%016lx\n&quot;, entrylo1);</span>
<span class="p_add">+	pr_debug(&quot; Pagemask: 0x%016lx\n&quot;, pagemask);</span>
<span class="p_add">+	pr_debug(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	add_wired_entry(entrylo0, entrylo1, entryhi, pagemask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the largest page mask a physical address can be mapped with */</span>
<span class="p_add">+static unsigned long mips_rproc_largest_pm(unsigned long pa,</span>
<span class="p_add">+					   unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long mask;</span>
<span class="p_add">+	/* Find address bits limiting alignment */</span>
<span class="p_add">+	unsigned long shift = ffs(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Obey MIPS restrictions on page sizes */</span>
<span class="p_add">+	if (pa) {</span>
<span class="p_add">+		if (shift &amp; 1)</span>
<span class="p_add">+			shift -= 2;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			shift--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mask = ULONG_MAX &lt;&lt; shift;</span>
<span class="p_add">+	return maxmask &amp; ~mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the page mask one step larger than a given page mask */</span>
<span class="p_add">+static unsigned long mips_rproc_next_pm(unsigned long pm, unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+#define PM_SHIFT 13</span>
<span class="p_add">+	return ((pm &lt;&lt; 2) | (0x3 &lt;&lt; PM_SHIFT)) &amp; maxmask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Add mappings to the TLB such that memory allocated by the kernel for a</span>
<span class="p_add">+ * firmware component appears at the right virtual address</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void mips_rproc_map(unsigned long da, unsigned long pa, int c,</span>
<span class="p_add">+				  unsigned long size, unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* minimum mappable size is 2 * 4k pages */</span>
<span class="p_add">+	const unsigned long min_map_sz = 0x2000;</span>
<span class="p_add">+	unsigned long bigmask, nextmask;</span>
<span class="p_add">+	unsigned long distance, target;</span>
<span class="p_add">+	unsigned long page2_size; /* Size of the 2 buddy pages */</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		/* Compute the current largest page mask */</span>
<span class="p_add">+		bigmask = mips_rproc_largest_pm(pa, maxmask);</span>
<span class="p_add">+		/* Compute the next largest pagesize */</span>
<span class="p_add">+		nextmask = mips_rproc_next_pm(bigmask, maxmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Compute the distance from our current physical address to</span>
<span class="p_add">+		 * the next page boundary.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		distance = (nextmask + min_map_sz) - (pa &amp; nextmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Decide between searching to get to the next highest page</span>
<span class="p_add">+		 * boundary or finishing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		target = distance &lt; size ? distance : size;</span>
<span class="p_add">+		while (target) {</span>
<span class="p_add">+			/* Find the largest supported page size that will fit */</span>
<span class="p_add">+			for (page2_size = maxmask + min_map_sz;</span>
<span class="p_add">+			    (page2_size &gt; min_map_sz) &amp;&amp; (page2_size &gt; target);</span>
<span class="p_add">+			     page2_size /= 4) {</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/* Emit it */</span>
<span class="p_add">+			mips_map_page(da, pa, c, page2_size);</span>
<span class="p_add">+			/* Move to next step */</span>
<span class="p_add">+			size -= page2_size;</span>
<span class="p_add">+			da += page2_size;</span>
<span class="p_add">+			pa += page2_size;</span>
<span class="p_add">+			target -= page2_size;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_carveouts(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_mem_entry *carveout;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(carveout, &amp;rproc-&gt;carveouts, node) {</span>
<span class="p_add">+		int c = CONF_CM_CACHABLE_COW;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+			&quot;carveout mapping da 0x%x -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+			carveout-&gt;da, &amp;carveout-&gt;dma, carveout-&gt;len, c);</span>
<span class="p_add">+</span>
<span class="p_add">+		mips_rproc_map(carveout-&gt;da, carveout-&gt;dma, c,</span>
<span class="p_add">+				carveout-&gt;len, max_pagemask);</span>
<span class="p_add">+		flush_icache_range((unsigned long)carveout-&gt;va,</span>
<span class="p_add">+				   (unsigned long)carveout-&gt;va + carveout-&gt;len);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_vdevs(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_vdev *rvdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(rvdev, &amp;rproc-&gt;rvdevs, node) {</span>
<span class="p_add">+		int i, size;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(rvdev-&gt;vring); i++) {</span>
<span class="p_add">+			struct rproc_vring *vring = &amp;rvdev-&gt;vring[i];</span>
<span class="p_add">+			unsigned long pa = vring-&gt;dma;</span>
<span class="p_add">+			int c;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (plat_device_is_coherent(&amp;mips_rproc_dev)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * The DMA API will allocate cacheable buffers</span>
<span class="p_add">+				 * for shared resources, so the firmware should</span>
<span class="p_add">+				 * also access those buffers cached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = (_page_cachable_default &gt;&gt; _CACHE_SHIFT);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Otherwise, shared buffers should be accessed</span>
<span class="p_add">+				 * uncached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = CONF_CM_UNCACHED;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/* actual size of vring (in bytes) */</span>
<span class="p_add">+			size = PAGE_ALIGN(vring_size(vring-&gt;len, vring-&gt;align));</span>
<span class="p_add">+</span>
<span class="p_add">+			dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+				&quot;vring mapping da %pad -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+				&amp;vring-&gt;dma, &amp;vring-&gt;dma, size, c);</span>
<span class="p_add">+</span>
<span class="p_add">+			mips_rproc_map(pa, pa, c, size, max_pagemask);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_rproc_cpu_entry(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = mips_rprocs[smp_processor_id()];</span>
<span class="p_add">+	struct rproc *rproc = mproc-&gt;rproc;</span>
<span class="p_add">+	int ipi_to_remote = ipi_get_hwirq(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+	int ipi_from_remote = ipi_get_hwirq(mproc-&gt;ipi_linux, 0);</span>
<span class="p_add">+	unsigned long old_pagemask, max_pagemask;</span>
<span class="p_add">+	void (*fw_entry)(int, int ipi_to_remote, int ipi_from_remote, int);</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;rproc-&gt;dev, &quot;%s booting firmware %s\n&quot;,</span>
<span class="p_add">+		 rproc-&gt;name, rproc-&gt;firmware);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the maximum pagemask supported on this CPU */</span>
<span class="p_add">+	old_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(~0);</span>
<span class="p_add">+	back_to_back_c0_hazard();</span>
<span class="p_add">+	max_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(old_pagemask);</span>
<span class="p_add">+	back_to_back_c0_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start with no wired entries */</span>
<span class="p_add">+	write_c0_wired(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush all previous TLB entries */</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set ASID 0 */</span>
<span class="p_add">+	write_c0_entryhi(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Map firmware resources into virtual memory */</span>
<span class="p_add">+	mips_rproc_carveouts(rproc, max_pagemask);</span>
<span class="p_add">+	mips_rproc_vdevs(rproc, max_pagemask);</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI to remote: %d\n&quot;, ipi_to_remote);</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI from remote: %d\n&quot;, ipi_from_remote);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Hand off the CPU to the firmware */</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;Jumping to firmware at 0x%x\n&quot;, rproc-&gt;bootaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Jump into the firmware, obeying the firmware protocol. */</span>
<span class="p_add">+	fw_entry = (void *)rproc-&gt;bootaddr;</span>
<span class="p_add">+	fw_entry(-3, ipi_to_remote, ipi_from_remote, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_ipi_handler(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Synthetic interrupts shouldn&#39;t need acking */</span>
<span class="p_add">+	return IRQ_WAKE_THREAD;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_vq_int(int irq, void *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc *rproc = (struct rproc *)p;</span>
<span class="p_add">+	void *entry;</span>
<span class="p_add">+	int id;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We don&#39;t have a mailbox, so iterate over all vqs and kick them. */</span>
<span class="p_add">+	idr_for_each_entry(&amp;rproc-&gt;notifyids, entry, id)</span>
<span class="p_add">+		rproc_vq_interrupt(rproc, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Helper function to find the IPI domain */</span>
<span class="p_add">+static struct irq_domain *ipi_domain(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node = of_irq_find_parent(of_root);</span>
<span class="p_add">+	struct irq_domain *ipidomain;</span>
<span class="p_add">+</span>
<span class="p_add">+	ipidomain = irq_find_matching_host(node, DOMAIN_BUS_IPI);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some platforms have half DT setup. So if we found irq node but</span>
<span class="p_add">+	 * didn&#39;t find an ipidomain, try to search for one that is not in the</span>
<span class="p_add">+	 * DT.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (node &amp;&amp; !ipidomain)</span>
<span class="p_add">+		ipidomain = irq_find_matching_host(NULL, DOMAIN_BUS_IPI);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ipidomain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int cpu = mproc-&gt;cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="p_add">+	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="p_add">+	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="p_add">+	if (mips_smp_ipi_free(get_cpu_mask(cpu))) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="p_add">+		goto exit_free_tsk;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="p_add">+	 * offlined while the remote CPU is running.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_linux) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="p_add">+		goto exit_restore_ipi;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_remote) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="p_add">+		goto exit_destroy_ipi_linux;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* register incoming ipi */</span>
<span class="p_add">+	err = request_threaded_irq(mproc-&gt;ipi_linux, mips_rproc_ipi_handler,</span>
<span class="p_add">+				   mips_rproc_vq_int, 0,</span>
<span class="p_add">+				   &quot;mips-rproc IPI in&quot;, rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="p_add">+			err);</span>
<span class="p_add">+		goto exit_destroy_ipi_remote;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="p_add">+						mproc-&gt;tsk)) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="p_add">+		goto exit_free_irq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+exit_free_irq:</span>
<span class="p_add">+	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="p_add">+exit_destroy_ipi_remote:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="p_add">+exit_destroy_ipi_linux:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+exit_restore_ipi:</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="p_add">+exit_free_tsk:</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	set_task_state(mproc-&gt;tsk, TASK_DEAD);</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void mips_rproc_op_kick(struct rproc *rproc, int vqid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rproc-&gt;state == RPROC_RUNNING)</span>
<span class="p_add">+		ipi_send_single(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct rproc_ops mips_rproc_proc_ops = {</span>
<span class="p_add">+	.start	= mips_rproc_op_start,</span>
<span class="p_add">+	.stop	= mips_rproc_op_stop,</span>
<span class="p_add">+	.kick	= mips_rproc_op_kick,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Create an rproc instance in response to CPU down */</span>
<span class="p_add">+static int mips_rproc_device_register(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char *template = &quot;mips-cpu%u&quot;;</span>
<span class="p_add">+	struct rproc *rproc;</span>
<span class="p_add">+	struct mips_rproc *mproc;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpumask_test_cpu(cpu, mips_rproc_cpumask))</span>
<span class="p_add">+		/* The CPU is not in the mask, so don&#39;t register rproc on it */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Allocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_rprocs[cpu]) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc = kzalloc(sizeof(struct mips_rproc), GFP_KERNEL);</span>
<span class="p_add">+	if (!mproc) {</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	snprintf(mproc-&gt;name, sizeof(mproc-&gt;name), template, cpu);</span>
<span class="p_add">+	mproc-&gt;cpu = cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	rproc = rproc_alloc(&amp;mips_rproc_dev, mproc-&gt;name,</span>
<span class="p_add">+			    &amp;mips_rproc_proc_ops, NULL,</span>
<span class="p_add">+			    sizeof(struct mips_rproc *));</span>
<span class="p_add">+	if (!rproc) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;Error allocating rproc\n&quot;);</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto exit_free_mproc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;rproc = rproc;</span>
<span class="p_add">+	rproc-&gt;priv = (void *)mproc;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = rproc_add(rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="p_add">+		goto exit_free_rproc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rprocs[cpu] = mproc;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+exit_free_rproc:</span>
<span class="p_add">+	rproc_free(rproc);</span>
<span class="p_add">+exit_free_mproc:</span>
<span class="p_add">+	kfree(mproc);</span>
<span class="p_add">+exit:</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Destroy rproc instance in response to CPU up */</span>
<span class="p_add">+static int mips_rproc_device_unregister(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = mips_rprocs[cpu];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mproc)</span>
<span class="p_add">+		/* No rproc instance has been created for this CPU */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Deallocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	rproc_del(mproc-&gt;rproc);</span>
<span class="p_add">+	rproc_put(mproc-&gt;rproc);</span>
<span class="p_add">+	kfree(mproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rprocs[cpu] = NULL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Show MIPS CPUs available to rproc */</span>
<span class="p_add">+static ssize_t cpus_show(struct device *dev, struct device_attribute *attr,</span>
<span class="p_add">+			  char *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return cpumap_print_to_pagebuf(true, buf, mips_rproc_cpumask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Allow MIPS CPUs to be made available to rproc */</span>
<span class="p_add">+static ssize_t cpus_store(struct device *dev,</span>
<span class="p_add">+			      struct device_attribute *attr,</span>
<span class="p_add">+			      const char *buf, size_t count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static cpumask_var_t new_mask;</span>
<span class="p_add">+	int err, cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = cpulist_parse(buf, new_mask);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Prevent CPU hotplug on/offlining CPUs while we do this */</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_possible_cpu(cpu) {</span>
<span class="p_add">+		if (cpumask_test_cpu(cpu, mips_rproc_cpumask) &amp;&amp;</span>
<span class="p_add">+		    !cpumask_test_cpu(cpu, new_mask)) {</span>
<span class="p_add">+			/* CPU no longer allowed. Release any instance on it */</span>
<span class="p_add">+			cpumask_clear_cpu(cpu, mips_rproc_cpumask);</span>
<span class="p_add">+			mips_rproc_device_unregister(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		} else if (!cpumask_test_cpu(cpu, mips_rproc_cpumask) &amp;&amp;</span>
<span class="p_add">+			   cpumask_test_cpu(cpu, new_mask)) {</span>
<span class="p_add">+			/* If the CPU isn&#39;t online, start an instance */</span>
<span class="p_add">+			cpumask_set_cpu(cpu, mips_rproc_cpumask);</span>
<span class="p_add">+			if (!cpu_online(cpu))</span>
<span class="p_add">+				mips_rproc_device_register(cpu);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+	return count;</span>
<span class="p_add">+}</span>
<span class="p_add">+static DEVICE_ATTR_RW(cpus);</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute *mips_rproc_attrs[] = {</span>
<span class="p_add">+	&amp;dev_attr_cpus.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group mips_rproc_devgroup = {</span>
<span class="p_add">+	.attrs = mips_rproc_attrs</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *mips_rproc_devgroups[] = {</span>
<span class="p_add">+	&amp;mips_rproc_devgroup,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+static struct device_type mips_rproc_type = {</span>
<span class="p_add">+	.groups = mips_rproc_devgroups,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mips_rproc_driver = {</span>
<span class="p_add">+	.driver = {</span>
<span class="p_add">+		.name = &quot;mips-rproc&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mips_rproc_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((!cpu_has_mipsmt) &amp;&amp; (!cpu_has_vp)) {</span>
<span class="p_add">+		pr_debug(&quot;MIPS rproc not supported on this cpu\n&quot;);</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rproc_dev.driver = &amp;mips_rproc_driver.driver;</span>
<span class="p_add">+	mips_rproc_dev.type = &amp;mips_rproc_type;</span>
<span class="p_add">+	dev_set_name(&amp;mips_rproc_dev, &quot;mips-rproc&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set device to have coherent DMA ops */</span>
<span class="p_add">+	arch_setup_dma_ops(&amp;mips_rproc_dev, 0, 0, NULL, 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = device_register(&amp;mips_rproc_dev);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mips_rproc_dev, &quot;Error adding MIPS rproc: %d\n&quot;, err);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Register with the cpu hotplug state machine.</span>
<span class="p_add">+	 * This driver requires opposite sense to &quot;normal&quot; drivers, since the</span>
<span class="p_add">+	 * driver is activated for offline CPUs via the teardown callback and</span>
<span class="p_add">+	 * deactivated via the online callback.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, &quot;MIPS:REMOTEPROC&quot;,</span>
<span class="p_add">+				mips_rproc_device_unregister,</span>
<span class="p_add">+				mips_rproc_device_register);</span>
<span class="p_add">+	if (err &lt; 0) {</span>
<span class="p_add">+		device_unregister(&amp;mips_rproc_dev);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	cpuhp_state = err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit mips_rproc_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpuhp_state) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Unregister with the cpu hotplug state machine, but don&#39;t call</span>
<span class="p_add">+		 * the teardown callback, since that would try to start the</span>
<span class="p_add">+		 * remote processor device.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		__cpuhp_remove_state(cpuhp_state, false);</span>
<span class="p_add">+		cpuhp_state = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+	/* Unregister devices created for any offline CPUs */</span>
<span class="p_add">+	for_each_possible_cpu(cpu)</span>
<span class="p_add">+		mips_rproc_device_unregister(cpu);</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+late_initcall(mips_rproc_init);</span>
<span class="p_add">+module_exit(mips_rproc_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+module_platform_driver(mips_rproc_driver);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;MIPS Remote Processor control driver&quot;);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



