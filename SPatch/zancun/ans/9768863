
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[2/2] acpi, gicv3-its, numa: Adding numa node mapping for gic-its units - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [2/2] acpi, gicv3-its, numa: Adding numa node mapping for gic-its units</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=173593">Ganapatrao Kulkarni</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 6, 2017, 12:56 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1496753787-27735-3-git-send-email-ganapatrao.kulkarni@cavium.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9768863/mbox/"
   >mbox</a>
|
   <a href="/patch/9768863/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9768863/">/patch/9768863/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	F192060393 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  6 Jun 2017 12:57:39 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DA9D5201F3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  6 Jun 2017 12:57:39 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id CBF522834A; Tue,  6 Jun 2017 12:57:39 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-4.1 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, RCVD_IN_BL_SPAMCOP_NET, RCVD_IN_DNSWL_HI,
	RCVD_IN_SORBS_WEB autolearn=unavailable version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7966A27F54
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  6 Jun 2017 12:57:38 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751494AbdFFM5c (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 6 Jun 2017 08:57:32 -0400
Received: from mail-bl2nam02on0049.outbound.protection.outlook.com
	([104.47.38.49]:51665
	&quot;EHLO NAM02-BL2-obe.outbound.protection.outlook.com&quot;
	rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org with ESMTP
	id S1751305AbdFFM52 (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 6 Jun 2017 08:57:28 -0400
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=CAVIUMNETWORKS.onmicrosoft.com; s=selector1-cavium-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version;
	bh=DZvBwfybuTzTNjr4fzI2dD26f2d7AF0js/Z6bx1C7fI=;
	b=RpHMrm6niwyeQVq/7G1xYjjSIxB5pRVbazcrZVJQbKKjtJ5JtAIj3sYBiCd5ukUWsAj15//RirtHUoViRwE0+++WVGPXvGgD/1X23V06ckC5gCOoK1g45FSIspWUu6ife9566iefM8p5aZ6kc5EvUAjvdPwqup1D8zEG6bv8yL4=
Authentication-Results: vger.kernel.org; dkim=none (message not signed)
	header.d=none; vger.kernel.org;
	dmarc=none action=none header.from=cavium.com; 
Received: from mypc.cavium.com.com (111.93.218.67) by
	CY1PR07MB2572.namprd07.prod.outlook.com (10.167.16.134) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256_P256) id
	15.1.1143.10; Tue, 6 Jun 2017 12:57:16 +0000
From: Ganapatrao Kulkarni &lt;ganapatrao.kulkarni@cavium.com&gt;
To: linux-acpi@vger.kernel.org, devel@acpica.org,
	linux-kernel@vger.kernel.org, linux-arm-kernel@lists.infradead.org
Cc: lv.zheng@intel.com, robert.moore@intel.com,
	catalin.marinas@arm.com, will.deacon@arm.com, tglx@linutronix.de,
	jason@lakedaemon.net, marc.zyngier@arm.com,
	jnair@caviumnetworks.com, gpkulkarni@gmail.com
Subject: [PATCH 2/2] acpi, gicv3-its,
	numa: Adding numa node mapping for gic-its units
Date: Tue,  6 Jun 2017 18:26:27 +0530
Message-Id: &lt;1496753787-27735-3-git-send-email-ganapatrao.kulkarni@cavium.com&gt;
X-Mailer: git-send-email 1.8.1.4
In-Reply-To: &lt;1496753787-27735-1-git-send-email-ganapatrao.kulkarni@cavium.com&gt;
References: &lt;1496753787-27735-1-git-send-email-ganapatrao.kulkarni@cavium.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [111.93.218.67]
X-ClientProxiedBy: MA1PR01CA0092.INDPRD01.PROD.OUTLOOK.COM (10.174.56.32) To
	CY1PR07MB2572.namprd07.prod.outlook.com (10.167.16.134)
X-MS-PublicTrafficType: Email
X-MS-TrafficTypeDiagnostic: CY1PR07MB2572:
X-MS-Office365-Filtering-Correlation-Id: e92269f0-409d-44f1-b3ed-08d4acdb9121
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(22001)(201703131423075)(201703031133081);
	SRVR:CY1PR07MB2572; 
X-Microsoft-Exchange-Diagnostics: 1; CY1PR07MB2572;
	3:RSuuURTkTFidhL88XkC/AIyykorjmZEd/q3Fmux5Mb+9GNDDHYLIDudrQIAzw/FURy/HVB+a23VQBHZEWTwve3nOFvj/3NP7e/njdevnnSwIsDVw1Eeh58HyiLdOr+4cDvZny4aZOcHkU0LEliJtd2DHcJ+3bQhMzMakv9rU35XKiSPGDM5XHZX2r7xfPxhzCi6JoCM97JRlGDp+sre0pcZ5+4+Tmvxum+uJ/njZUlbfBIj0EwEoEgeS4Ssdumjyl8733NGEL+akDCJ72XbOsJz0zdUOwh8EIJ/Z56PPAhv76ewftMJ9WdwpTikilvYEqYn2VFNF2JihLWTJkzkXMQ==;
	25:1Ep6PPWFFpWppXxUGENcARh+vR4LYSZWz0e+y/C/H2N1fbqYAcZ6v6RoZtkdKuosAoX9+JqkFywHP4dx6w4B+JBxTJfPHR/0h5AGLfZmn5yY84NsmQ7OHrxrTIFVk9+z4yDMjdWVumuMsMLT+ui2pgIOVBX81EGcu3JkOK5IkO//7dEuK9AGk4Ib0PDf13tdFG/ivdWaneTYAlzpk13bUd1eVa1ekMqBFP5NNU/CmkoM8bzeeAYPsTgyNgcCOM0EiUyO1ijgmajNmJXCNhhKbjXycOCNMuEz/oFoiMHsZ2Fa3SvM7u2Ve500z5MaNHDEP8tfhTDDq4p9jIZP4Vy9XyBOeZ5UpT1Bnadta9qJkDys/IGERbv3C91l7AFx/QUTDxeuM/CKKvxWIcUk9hZhgPvMbMBtlJ8BduLRq7j0TtKQK4tJPtlO0mlhLbDDJrS7RJvK43grG05ijR9k7jAcWAg1EiJunSMBw0QuIYiRTbA=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR07MB2572;
	31:rZaYbhSGBLbGI7NU/yT7+tg+ib/r2B9cnQfv0tiFFANAZDhb2BGaJQ7rjf8MY4+cynUJk8lwWVZAI07NNZNiPSDiHg5uF3+XoYUI9N2uTxVePGinwyoxOZuGEumpM/8zh51NZJo2qsXg+bnKIdtU/t6DhpUQwZz86CPSp0NwNsaUhmubo9CtFA0kySEh1cB6RVh0KLEGh1aUgA2WpLW+zCIVzyGopD8br+3Gh70gfxo=;
	20:UrU7UCYkYokTnCOeaEohPaxSa+jPJtPDBcniMB46nofPGg8AlKQ8CLp8MSJWiNkDH3tyJdIixSMFWWn8bckBpxFPbqfy0WC17QH/dxSI/S7g4Nzx5YtncWHgbyEqr+4hTLTUA7Kn6/jrztQVBPrEkToVEy9+KcQYV/lMcG2ewMA5HZ3wlYbXVhSZdqOqf+gBMBMfmbDiQEvXjR75EaHCWmx2bYVHpZIrzexP6FSfdTc/snLCl1WDJ3AnRCTIVi14pQ8KOGcsUraudbn3Pqe0nmxIyFykNLBU2XJzgYryFFN6HqIHf6tMx41wMktUYMtNVE3h69c0o2cgTH5QL8gDnygpjblkJVO+dK13PNbwMFPLyYUXvqpFs2JVN8CmhLX+tQL89aK9V9rTD1QOI1kJGHeTk2h1RLKKZrGq0SRuKvZYrWUY6NwFosZr57pGUv9ev909chGKo1t50xr7lM3KhpK7qjdcBr2bZvPXWXufPsswTezd45XFVX7MI5dof0xu
X-Microsoft-Antispam-PRVS: &lt;CY1PR07MB2572C3E0B07E837CDF98D4AD83CB0@CY1PR07MB2572.namprd07.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:;
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(100000700101)(100105000095)(100000701101)(100105300095)(100000702101)(100105100095)(6040450)(601004)(2401047)(5005006)(8121501046)(10201501046)(3002001)(93006095)(93001095)(100000703101)(100105400095)(6041248)(20161123555025)(20161123560025)(20161123562025)(20161123564025)(201703131423075)(201702281528075)(201703061421075)(201703061406153)(20161123558100)(6072148)(100000704101)(100105200095)(100000705101)(100105500095);
	SRVR:CY1PR07MB2572; BCL:0; PCL:0;
	RULEID:(100000800101)(100110000095)(100000801101)(100110300095)(100000802101)(100110100095)(100000803101)(100110400095)(100000804101)(100110200095)(100000805101)(100110500095);
	SRVR:CY1PR07MB2572; 
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CY1PR07MB2572;
	4:8zLA2ncy439B7aOG0EARICijaTKW6ZcsYTWZp9Dji3?=
	=?us-ascii?Q?Ovv4qxIEHAt4cFKHSMaxAD5sehUIG3+jIAJ5j8x5Dhe81eCIpRrStw1pXjmZ?=
	=?us-ascii?Q?FavJxOKWlxgTxkWjCAQ9rSeUIqtHAPcrFET3WuMmOIgcAn2XUHhciBzsvtXJ?=
	=?us-ascii?Q?ouYGd3EAnsdRC0oTBNbwDoJ2nzekRhtdNSYFao81y4LGs72OiEbNMpQmVyfZ?=
	=?us-ascii?Q?Vo0IL+drk+0DBMdS/WXZP6JdKqYC4qm58/MEYtJlRacB2nNRvDreqwIWZvKZ?=
	=?us-ascii?Q?hQOcRIl4vjgTMer9BQGHYU/ozoyEMBsfFEsQQlHt4MBDOC593lWtmghNJB4d?=
	=?us-ascii?Q?W+VKtEg/q0mPzB3wMhDC6zpITU7786zdfH+/dzVN8km8xvItmP5e6WyHG364?=
	=?us-ascii?Q?MSPzHw3v1k9NWx+IKj7IyZ654b8ghI8T1Dh1FSrAhG8VNGGjdvuGfJcZBCq7?=
	=?us-ascii?Q?6IaYHVOYhqi24lCUFJe1QAcyf2i18NLNoLDN03r7gr0FjW1dKEwIi4SkRMf8?=
	=?us-ascii?Q?5YNEnAVVl0fyDIuZW9G+y+Uqk4neuXXL5v7W7Qcis4CYBcZrMJYOt9uGNqmL?=
	=?us-ascii?Q?f96rrJfonh0gbWql/+hE4CqjyMfd5fTlmKot3eViC9yuzWaLnISALKSPYpUH?=
	=?us-ascii?Q?62dniX5eCMB/sc4WPDQpDWuDpqDTTAQnFNywDk5r4T0YJygzsFjeDIG5Q8Cc?=
	=?us-ascii?Q?gj6UQxYtuzI4hmODCiF69cWbgsOUZaqAgCLVuGY0pyEZvnQwDLC0f1xTpcCD?=
	=?us-ascii?Q?GT2jEPLKPYrVr7EXhcW/WS//ZG7KXrhrNV+TNkHBDPU08att0PIFPxJ+0ezj?=
	=?us-ascii?Q?zOQGR41l41bgaghg91AI9lw6gYzax/tnv6cMtl7gWNQ3VzhStZuR7q4D4/Eq?=
	=?us-ascii?Q?xiBVhIX/XpicWiVqZ28ernnfK6KGiuPW1WT+F49vP2Am/vZTppz7hqkqOy4u?=
	=?us-ascii?Q?/dVlxgPt9elVxwBtpBmbJtwMFgBF0oW/1wtQOE4GPWSAhVfRePnBvR5Q6ZEf?=
	=?us-ascii?Q?yT2tt/yDBR1QHMf3oZvWSNrLuC+HPfMsqecjQ7spuLJYQQclnCkh5f74biVc?=
	=?us-ascii?Q?FLu61YELBm/ng4fXBL8EuEG8vh8deepOMYumw443N8j41UPzdimQoHPrxPNz?=
	=?us-ascii?Q?pDaoAErsrz0ed6EWvqM7EeSvR8k+Vl?=
X-Forefront-PRVS: 033054F29A
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10009020)(4630300001)(6009001)(39410400002)(39850400002)(39400400002)(39840400002)(39450400003)(25786009)(72206003)(5003940100001)(50466002)(48376002)(4720700003)(478600001)(6666003)(53936002)(4326008)(2950100002)(86362001)(575784001)(6506006)(36756003)(6116002)(6486002)(6512007)(5009440100003)(42186005)(3846002)(189998001)(76176999)(50986999)(5660300001)(7416002)(305945005)(2906002)(50226002)(38730400002)(33646002)(110136004)(7736002)(66066001)(47776003)(81166006)(8676002);
	DIR:OUT; SFP:1101; SCL:1; SRVR:CY1PR07MB2572;
	H:mypc.cavium.com.com; FPR:; SPF:None; MLV:sfv; LANG:en; 
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CY1PR07MB2572;
	23:FOOh3vE20VeO/SXHfti80tVhzHanMNXO4mVV5oXiW?=
	=?us-ascii?Q?aMrS9MJ48lJB1z1tEGy45xru3EIHDaOolS1x9kdUDz0Tssf9X3y3p0JhTDdM?=
	=?us-ascii?Q?cGq9SY0zQ+ixjtHRPEwO+/q142lr4HqsDCl9/HpCR8UTQIcxU55E+GEa4RJJ?=
	=?us-ascii?Q?Am6bWzc0nzt3ad+jp+vm69eAly/FSf0UIE+/sKdkrDjcmDooXJmIRLk/2/Q0?=
	=?us-ascii?Q?Ehz3pz6Yu/Fsfreogj9DX364S5vn/5rm4nb+tRXuOudnHJG0OZvxxFienepN?=
	=?us-ascii?Q?ljXqgo8XZsGT7Neyf97XH1L9zyiJJdunAVgtAhGIW/2SC3wOVDKCgm5UBuHR?=
	=?us-ascii?Q?qGaDdlHSTRFcbHxA54KgUJTcq2gmSd+gEWkApB2yPOSXeJFP7JZN55+8uII2?=
	=?us-ascii?Q?1RmeduWlKB3GJzEtb19AaFSuUWiaUmHdbCEKi+yWFz9EQd7xd/cQ8OBH0+R6?=
	=?us-ascii?Q?JyI7I1SHeW52TFiBy/NJWiAdO9hIMPW8Vwe3JCZ18XhY17PHO6gk4rvGVIQe?=
	=?us-ascii?Q?EHZzOAnfw7XP20fa5oOqqiPEI065ciJPK6cvY2jXyBpRllsfT4PLEHImsBH+?=
	=?us-ascii?Q?UdPrDJCtsqAy+w6+9J2QQyyj0E3l8Ve0OyD0s2OsoLDzz1F8ODBpi8UAe1ZQ?=
	=?us-ascii?Q?KbbzmlzUfWVamgBjMDxc+YsHBxNxAhyqOpG6NV2JRbCo4B0Z76p7df4cZFfJ?=
	=?us-ascii?Q?2daCsamNq4zGpONLLQ8wt+IbMwIrZSABcNgDRfwNFxSGgXRojrZKkV/uKdaN?=
	=?us-ascii?Q?RiFapHq2B8a2zCbM0ZgjOM53UGiOo1k/kSNlk6f0Ddom9lfSm5W21iSVET/5?=
	=?us-ascii?Q?5G3E1JztJ2nWa+S4b3k8pKRx9swa0QfU4MmlLwaOoMVI/S9ZWscwoIuJSg+/?=
	=?us-ascii?Q?UF2E2c+FgmQXPsTSxTaE9nl5g02tYhTnhXoZfBJuCZNJYao9r+EWMYz47rIP?=
	=?us-ascii?Q?RIaXvn9I8ntgJgj0vUm4LEzy7LsC7sUVKFyvpUoa6DsE6cpwYbx6wfj1qH/r?=
	=?us-ascii?Q?sxlkoKxz3uXfGaNxvKj4aXWTw6bbitf/m1CPU3KtVxlz9nqFa7+UPTVW9oQ2?=
	=?us-ascii?Q?r2E7PDbUBQ8jzY04/Iafrl9rItQP7txsV6Iryzsh02nfBYcoJg1grFY/dC8m?=
	=?us-ascii?Q?c3AeZ2/mWGN7KOrIX19WHka6mWa3ZRk?=
X-Microsoft-Exchange-Diagnostics: 1; CY1PR07MB2572;
	6:/FEYc/ovd8UWi/okF6UYTT588OP32zwQeqK1S02fLQgav18/D/OUAXBZnQlzo3nG6gd4KgaIUmIao1ZtcqMxul/G4joa/VX09XKPVPNzFqz7L4HyW7f4fMAm3phGsA87nytqs6xQ4aotO3HMGElybvbGBJLaUO1hEF7OtmB81yMPdvKpbLfrZMLjjlbPhINY3ySpZzZVcHupACVPrmqozCRXzHAIw5o8ez1f6IPpf+44w5W1QVpbGF/WKpUnSA3CV8Q3odMWng2GgaD69vRE02fcYYeC2Abx27z7vMSrJvSjS3MU0cEHnAkxKGfOFLHYEkrtWrgEX5kx2hMXcVdnX2LsLGVJH0CsUHdZPhdbm4XLxNV60FScZp+4fPZc72jCDUK16WSY4gQuMHPFxLXTcdvB8V2b/n1OucD8xQzizwzUDxKse4WjLpz08YqbU8DriVyEihrH0hcGs+U2TAm1+EPY2Hyk4FAHtpPFtTuChjhWyxZsuhzW2m8wspcIadEq2voWFLxM/VVuCiFhVdJDqQ==
X-Microsoft-Exchange-Diagnostics: 1; CY1PR07MB2572;
	5:gtcaAfP4qcWf/4RLg4zvdRPnClMr1s+TtXn+1R4AqTXo8SW0e2L5AzzklAzalQdxMfRI5n7u1szZpBz+gd9GkRZTvf8sF5SGYhIdVxImuDTNYV9NUiPPNuigA//tLHsUrOxbRU/ga71PyVhcpBcjPA3q3qhtuSX7PlaBMK+xap9Os1npWeKageV70dA8DXx1M8WAHx3C5ZPU+KnQdRVZF+OPp7DqCFzBu8Qg94GHjqyjhqpJwDD9K6s/7NmhSwkFx1IJv+dx1AR7LN0oS2XjZPO8woP304olWSENsA+YqbKeAWqGa2nY6vbcTlqvygFjKPoYYl19St5AFTOUYaL0AOwuMyAjt3aG1TjLTm0Q9a5jac2y+WSZxXUpk5i19LQvoje922lGJqyTlv0LLC1m6BCwT6AyrgvKcT5yicKcgvrOE1Cgz7ZETbsHVL5/SYMfdMa291o+WnF+rvCd4HQKyZsCje1Uh2V4DeIzicZ1pbqSj8CrUwEQ3ENQLsDrO1iB;
	24:NvbX1pMCS3G5/lvcEUiB5OhwnrfRxi7gwqMVfgY9epb4y077RPAdwrtcg9yPcXspVzad9tY6WHFaBqn2Rb6qNDZRwO8Kinv+NoTtEq9YtxI=
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; CY1PR07MB2572;
	7:g3VTJx7EzCEcB7VxOvyOzPxO8cGeEGrZbCgYMHbOmkYeg+3EAxdlLT2SQjT/zE/5XEPioARvpGrO5KCtb8k/CVfz3EFBPx6UB7IGwjm1OFAjQVktDpTG+yRJ/ZreYa+5JVcxhMQ6KDTM72UbCiVzRrl9eWmnb6AemmsPafhtQxIa/VkRBPwF84azBEASfmzRXsDYKMk4QAGAyGvDo46H6Yl+vopr6HEpmk99NhEyZXifkoc+5LVKn6aECv1D++FV1nfvTwcRTcGMljzPXY0KicYjlWOL/YefLhqnux0OhAiPEAAPZtymtvJ59GWULPSmvWrbZNFNuozn8N+VP0eSpw==
X-OriginatorOrg: cavium.com
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 06 Jun 2017 12:57:16.3646
	(UTC)
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CY1PR07MB2572
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=173593">Ganapatrao Kulkarni</a> - June 6, 2017, 12:56 p.m.</div>
<pre class="content">
Add code to parse SRAT ITS Affinity sub table as defined in ACPI 6.2
Later in driver probe, its devices are mapped to numa node
using its id to proximity domain mapping.
<span class="signed-off-by">
Signed-off-by: Ganapatrao Kulkarni &lt;ganapatrao.kulkarni@cavium.com&gt;</span>
---
 arch/arm64/include/asm/acpi.h    |  2 ++
 arch/arm64/kernel/acpi_numa.c    | 59 ++++++++++++++++++++++++++++++++++++++++
 drivers/acpi/numa.c              | 32 +++++++++++++++++++++-
 drivers/irqchip/irq-gic-v3-its.c |  3 +-
 include/linux/acpi.h             |  3 ++
 5 files changed, 97 insertions(+), 2 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=106031">Ganapatrao Kulkarni</a> - June 7, 2017, 3:39 a.m.</div>
<pre class="content">
Adding  Lorenzo and  Hanzun.

On Tue, Jun 6, 2017 at 6:26 PM, Ganapatrao Kulkarni
&lt;ganapatrao.kulkarni@cavium.com&gt; wrote:
<span class="quote">&gt; Add code to parse SRAT ITS Affinity sub table as defined in ACPI 6.2</span>
<span class="quote">&gt; Later in driver probe, its devices are mapped to numa node</span>
<span class="quote">&gt; using its id to proximity domain mapping.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Ganapatrao Kulkarni &lt;ganapatrao.kulkarni@cavium.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm64/include/asm/acpi.h    |  2 ++</span>
<span class="quote">&gt;  arch/arm64/kernel/acpi_numa.c    | 59 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  drivers/acpi/numa.c              | 32 +++++++++++++++++++++-</span>
<span class="quote">&gt;  drivers/irqchip/irq-gic-v3-its.c |  3 +-</span>
<span class="quote">&gt;  include/linux/acpi.h             |  3 ++</span>
<span class="quote">&gt;  5 files changed, 97 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; index 0e99978..60ea7d1 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; @@ -143,9 +143,11 @@ static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
<span class="quote">&gt;  #ifdef CONFIG_ACPI_NUMA</span>
<span class="quote">&gt;  int arm64_acpi_numa_init(void);</span>
<span class="quote">&gt;  int acpi_numa_get_nid(unsigned int cpu, u64 hwid);</span>
<span class="quote">&gt; +int acpi_numa_get_its_nid(u32 its_id);</span>
<span class="quote">&gt;  #else</span>
<span class="quote">&gt;  static inline int arm64_acpi_numa_init(void) { return -ENOSYS; }</span>
<span class="quote">&gt;  static inline int acpi_numa_get_nid(unsigned int cpu, u64 hwid) { return NUMA_NO_NODE; }</span>
<span class="quote">&gt; +static inline int acpi_numa_get_its_nid(u32 its_id) { return NUMA_NO_NODE; }</span>
<span class="quote">&gt;  #endif /* CONFIG_ACPI_NUMA */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  #define ACPI_TABLE_UPGRADE_MAX_PHYS MEMBLOCK_ALLOC_ACCESSIBLE</span>
<span class="quote">&gt; diff --git a/arch/arm64/kernel/acpi_numa.c b/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt; index f01fab6..f7b2ea6 100644</span>
<span class="quote">&gt; --- a/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt; +++ b/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt; @@ -29,15 +29,24 @@</span>
<span class="quote">&gt;  #include &lt;asm/numa.h&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  static int cpus_in_srat;</span>
<span class="quote">&gt; +static int its_in_srat;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  struct __node_cpu_hwid {</span>
<span class="quote">&gt;         u32 node_id;    /* logical node containing this CPU */</span>
<span class="quote">&gt;         u64 cpu_hwid;   /* MPIDR for this CPU */</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +struct __node_its_id {</span>
<span class="quote">&gt; +       u32 node_id;    /* numa node id */</span>
<span class="quote">&gt; +       u32 its_id ;   /* GIC ITS ID */</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static struct __node_cpu_hwid early_node_cpu_hwid[NR_CPUS] = {</span>
<span class="quote">&gt;  [0 ... NR_CPUS - 1] = {NUMA_NO_NODE, PHYS_CPUID_INVALID} };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static struct __node_its_id early_node_its_id[MAX_NUMNODES] = {</span>
<span class="quote">&gt; +[0 ... MAX_NUMNODES - 1] = {NUMA_NO_NODE, UINT_MAX} };</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  int acpi_numa_get_nid(unsigned int cpu, u64 hwid)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;         int i;</span>
<span class="quote">&gt; @@ -50,6 +59,18 @@ int acpi_numa_get_nid(unsigned int cpu, u64 hwid)</span>
<span class="quote">&gt;         return NUMA_NO_NODE;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +int acpi_numa_get_its_nid(u32 its_id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; its_in_srat; i++) {</span>
<span class="quote">&gt; +               if (its_id == early_node_its_id[i].its_id)</span>
<span class="quote">&gt; +                       return early_node_its_id[i].node_id;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return NUMA_NO_NODE;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /* Callback for Proximity Domain -&gt; ACPI processor UID mapping */</span>
<span class="quote">&gt;  void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -100,6 +121,44 @@ void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)</span>
<span class="quote">&gt;                 pxm, mpidr, node);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +/* Callback for ITS ACPI Proximity Domain mapping */</span>
<span class="quote">&gt; +void __init acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       int pxm, node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (srat_disabled())</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (pa-&gt;header.length &lt; sizeof(struct acpi_srat_its_affinity)) {</span>
<span class="quote">&gt; +               pr_err(&quot;SRAT: Invalid SRAT header length: %d\n&quot;,</span>
<span class="quote">&gt; +                       pa-&gt;header.length);</span>
<span class="quote">&gt; +               bad_srat();</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (its_in_srat &gt;= MAX_NUMNODES) {</span>
<span class="quote">&gt; +               pr_warn_once(&quot;SRAT: its count exceeding max count[%d]\n&quot;,</span>
<span class="quote">&gt; +                            MAX_NUMNODES);</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       pxm = pa-&gt;proximity_domain;</span>
<span class="quote">&gt; +       node = acpi_map_pxm_to_node(pxm);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (node == NUMA_NO_NODE || node &gt;= MAX_NUMNODES) {</span>
<span class="quote">&gt; +               pr_err(&quot;SRAT: Too many proximity domains %d\n&quot;, pxm);</span>
<span class="quote">&gt; +               bad_srat();</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       early_node_its_id[its_in_srat].node_id = node;</span>
<span class="quote">&gt; +       early_node_its_id[its_in_srat].its_id =  its_in_srat;</span>
<span class="quote">&gt; +       node_set(node, numa_nodes_parsed);</span>
<span class="quote">&gt; +       pr_info(&quot;SRAT: PXM %d -&gt; ITS %d -&gt; Node %d\n&quot;,</span>
<span class="quote">&gt; +               pxm, its_in_srat, node);</span>
<span class="quote">&gt; +       its_in_srat++;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  int __init arm64_acpi_numa_init(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;         int ret;</span>
<span class="quote">&gt; diff --git a/drivers/acpi/numa.c b/drivers/acpi/numa.c</span>
<span class="quote">&gt; index edb0c79..9c04dba 100644</span>
<span class="quote">&gt; --- a/drivers/acpi/numa.c</span>
<span class="quote">&gt; +++ b/drivers/acpi/numa.c</span>
<span class="quote">&gt; @@ -182,6 +182,16 @@ int acpi_map_pxm_to_online_node(int pxm)</span>
<span class="quote">&gt;                 }</span>
<span class="quote">&gt;                 break;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +       case ACPI_SRAT_TYPE_GIC_ITS_AFFINITY:</span>
<span class="quote">&gt; +               {</span>
<span class="quote">&gt; +                       struct acpi_srat_its_affinity *p =</span>
<span class="quote">&gt; +                           (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt; +                       pr_debug(&quot;SRAT ITS [0x%04x]) in proximity domain %d\n&quot;,</span>
<span class="quote">&gt; +                                p-&gt;its_id,</span>
<span class="quote">&gt; +                                p-&gt;proximity_domain);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               break;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;         default:</span>
<span class="quote">&gt;                 pr_warn(&quot;Found unsupported SRAT entry (type = 0x%x)\n&quot;,</span>
<span class="quote">&gt;                         header-&gt;type);</span>
<span class="quote">&gt; @@ -390,6 +400,24 @@ static int __init acpi_parse_slit(struct acpi_table_header *table)</span>
<span class="quote">&gt;         return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static int __init</span>
<span class="quote">&gt; +acpi_parse_its_affinity(struct acpi_subtable_header *header,</span>
<span class="quote">&gt; +                        const unsigned long end)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct acpi_srat_its_affinity *its_affinity;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       its_affinity = (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt; +       if (!its_affinity)</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       acpi_table_print_srat_entry(header);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* let architecture-dependent part to do it */</span>
<span class="quote">&gt; +       acpi_numa_its_affinity_init(its_affinity);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static int __initdata parsed_numa_memblks;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  static int __init</span>
<span class="quote">&gt; @@ -445,7 +473,7 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         /* SRAT: Static Resource Affinity Table */</span>
<span class="quote">&gt;         if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {</span>
<span class="quote">&gt; -               struct acpi_subtable_proc srat_proc[3];</span>
<span class="quote">&gt; +               struct acpi_subtable_proc srat_proc[4];</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;                 memset(srat_proc, 0, sizeof(srat_proc));</span>
<span class="quote">&gt;                 srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;</span>
<span class="quote">&gt; @@ -454,6 +482,8 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;                 srat_proc[1].handler = acpi_parse_x2apic_affinity;</span>
<span class="quote">&gt;                 srat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;</span>
<span class="quote">&gt;                 srat_proc[2].handler = acpi_parse_gicc_affinity;</span>
<span class="quote">&gt; +               srat_proc[3].id = ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;</span>
<span class="quote">&gt; +               srat_proc[3].handler = acpi_parse_its_affinity;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;                 acpi_table_parse_entries_array(ACPI_SIG_SRAT,</span>
<span class="quote">&gt;                                         sizeof(struct acpi_table_srat),</span>
<span class="quote">&gt; diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; index 45ea1933..84936da 100644</span>
<span class="quote">&gt; --- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; +++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; @@ -1861,7 +1861,8 @@ static int __init gic_acpi_parse_madt_its(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;                 goto dom_err;</span>
<span class="quote">&gt;         }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -       err = its_probe_one(&amp;res, dom_handle, NUMA_NO_NODE);</span>
<span class="quote">&gt; +       err = its_probe_one(&amp;res, dom_handle,</span>
<span class="quote">&gt; +                       acpi_numa_get_its_nid(its_entry-&gt;translation_id));</span>
<span class="quote">&gt;         if (!err)</span>
<span class="quote">&gt;                 return 0;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="quote">&gt; index 137e4a3..e5e8ae3 100644</span>
<span class="quote">&gt; --- a/include/linux/acpi.h</span>
<span class="quote">&gt; +++ b/include/linux/acpi.h</span>
<span class="quote">&gt; @@ -260,9 +260,12 @@ int acpi_table_parse_madt(enum acpi_madt_type id,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  #ifdef CONFIG_ARM64</span>
<span class="quote">&gt;  void acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa);</span>
<span class="quote">&gt; +void acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa);</span>
<span class="quote">&gt;  #else</span>
<span class="quote">&gt;  static inline void</span>
<span class="quote">&gt;  acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa) { }</span>
<span class="quote">&gt; +static inline void</span>
<span class="quote">&gt; +acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa) { }</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;  int acpi_numa_memory_affinity_init (struct acpi_srat_mem_affinity *ma);</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; 1.8.1.4</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=22691">Lorenzo Pieralisi</a> - June 12, 2017, 10:53 a.m.</div>
<pre class="content">
On Tue, Jun 06, 2017 at 06:26:27PM +0530, Ganapatrao Kulkarni wrote:
<span class="quote">&gt; Add code to parse SRAT ITS Affinity sub table as defined in ACPI 6.2</span>
<span class="quote">&gt; Later in driver probe, its devices are mapped to numa node</span>

Nit: Capitalize &quot;its&quot;.
<span class="quote">
&gt; using its id to proximity domain mapping.</span>

Ditto.
<span class="quote">
&gt; Signed-off-by: Ganapatrao Kulkarni &lt;ganapatrao.kulkarni@cavium.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm64/include/asm/acpi.h    |  2 ++</span>
<span class="quote">&gt;  arch/arm64/kernel/acpi_numa.c    | 59 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  drivers/acpi/numa.c              | 32 +++++++++++++++++++++-</span>
<span class="quote">&gt;  drivers/irqchip/irq-gic-v3-its.c |  3 +-</span>
<span class="quote">&gt;  include/linux/acpi.h             |  3 ++</span>
<span class="quote">&gt;  5 files changed, 97 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; index 0e99978..60ea7d1 100644</span>
<span class="quote">&gt; --- a/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; +++ b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt; @@ -143,9 +143,11 @@ static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
<span class="quote">&gt;  #ifdef CONFIG_ACPI_NUMA</span>
<span class="quote">&gt;  int arm64_acpi_numa_init(void);</span>
<span class="quote">&gt;  int acpi_numa_get_nid(unsigned int cpu, u64 hwid);</span>
<span class="quote">&gt; +int acpi_numa_get_its_nid(u32 its_id);</span>
<span class="quote">&gt;  #else</span>
<span class="quote">&gt;  static inline int arm64_acpi_numa_init(void) { return -ENOSYS; }</span>
<span class="quote">&gt;  static inline int acpi_numa_get_nid(unsigned int cpu, u64 hwid) { return NUMA_NO_NODE; }</span>
<span class="quote">&gt; +static inline int acpi_numa_get_its_nid(u32 its_id) { return NUMA_NO_NODE; }</span>
<span class="quote">&gt;  #endif /* CONFIG_ACPI_NUMA */</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define ACPI_TABLE_UPGRADE_MAX_PHYS MEMBLOCK_ALLOC_ACCESSIBLE</span>
<span class="quote">&gt; diff --git a/arch/arm64/kernel/acpi_numa.c b/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt; index f01fab6..f7b2ea6 100644</span>
<span class="quote">&gt; --- a/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt; +++ b/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt; @@ -29,15 +29,24 @@</span>
<span class="quote">&gt;  #include &lt;asm/numa.h&gt;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static int cpus_in_srat;</span>
<span class="quote">&gt; +static int its_in_srat;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  struct __node_cpu_hwid {</span>
<span class="quote">&gt;  	u32 node_id;    /* logical node containing this CPU */</span>
<span class="quote">&gt;  	u64 cpu_hwid;   /* MPIDR for this CPU */</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +struct __node_its_id {</span>
<span class="quote">&gt; +	u32 node_id;    /* numa node id */</span>
<span class="quote">&gt; +	u32 its_id ;   /* GIC ITS ID */</span>
                  ^
Remove space.
<span class="quote">
&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static struct __node_cpu_hwid early_node_cpu_hwid[NR_CPUS] = {</span>
<span class="quote">&gt;  [0 ... NR_CPUS - 1] = {NUMA_NO_NODE, PHYS_CPUID_INVALID} };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static struct __node_its_id early_node_its_id[MAX_NUMNODES] = {</span>

Mind explaining to us where does MAX_NUMNODES as an array size limit
stem from here ?
<span class="quote">
&gt; +[0 ... MAX_NUMNODES - 1] = {NUMA_NO_NODE, UINT_MAX} };</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  int acpi_numa_get_nid(unsigned int cpu, u64 hwid)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	int i;</span>
<span class="quote">&gt; @@ -50,6 +59,18 @@ int acpi_numa_get_nid(unsigned int cpu, u64 hwid)</span>
<span class="quote">&gt;  	return NUMA_NO_NODE;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +int acpi_numa_get_its_nid(u32 its_id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int i;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (i = 0; i &lt; its_in_srat; i++) {</span>
<span class="quote">&gt; +		if (its_id == early_node_its_id[i].its_id)</span>
<span class="quote">&gt; +			return early_node_its_id[i].node_id;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return NUMA_NO_NODE;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  /* Callback for Proximity Domain -&gt; ACPI processor UID mapping */</span>
<span class="quote">&gt;  void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -100,6 +121,44 @@ void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)</span>
<span class="quote">&gt;  		pxm, mpidr, node);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +/* Callback for ITS ACPI Proximity Domain mapping */</span>
<span class="quote">&gt; +void __init acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int pxm, node;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (srat_disabled())</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (pa-&gt;header.length &lt; sizeof(struct acpi_srat_its_affinity)) {</span>
<span class="quote">&gt; +		pr_err(&quot;SRAT: Invalid SRAT header length: %d\n&quot;,</span>
<span class="quote">&gt; +			pa-&gt;header.length);</span>
<span class="quote">&gt; +		bad_srat();</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (its_in_srat &gt;= MAX_NUMNODES) {</span>

I do not understand why maxcount == MAX_NUMNODES in the first place.
<span class="quote">
&gt; +		pr_warn_once(&quot;SRAT: its count exceeding max count[%d]\n&quot;,</span>
<span class="quote">&gt; +			     MAX_NUMNODES);</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pxm = pa-&gt;proximity_domain;</span>
<span class="quote">&gt; +	node = acpi_map_pxm_to_node(pxm);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (node == NUMA_NO_NODE || node &gt;= MAX_NUMNODES) {</span>
<span class="quote">&gt; +		pr_err(&quot;SRAT: Too many proximity domains %d\n&quot;, pxm);</span>

Wrong error log message or at least inconsistent (yes, GICC code
where you copied this code from needs patching too).
<span class="quote">
&gt; +		bad_srat();</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	early_node_its_id[its_in_srat].node_id = node;</span>
<span class="quote">&gt; +	early_node_its_id[its_in_srat].its_id =  its_in_srat;</span>
                                               ^
One space is enough (again - that&#39;s through for GICC code too).
<span class="quote">
&gt; +	node_set(node, numa_nodes_parsed);</span>
<span class="quote">&gt; +	pr_info(&quot;SRAT: PXM %d -&gt; ITS %d -&gt; Node %d\n&quot;,</span>
<span class="quote">&gt; +		pxm, its_in_srat, node);</span>
<span class="quote">&gt; +	its_in_srat++;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  int __init arm64_acpi_numa_init(void)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	int ret;</span>
<span class="quote">&gt; diff --git a/drivers/acpi/numa.c b/drivers/acpi/numa.c</span>
<span class="quote">&gt; index edb0c79..9c04dba 100644</span>
<span class="quote">&gt; --- a/drivers/acpi/numa.c</span>
<span class="quote">&gt; +++ b/drivers/acpi/numa.c</span>
<span class="quote">&gt; @@ -182,6 +182,16 @@ int acpi_map_pxm_to_online_node(int pxm)</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt;  		break;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	case ACPI_SRAT_TYPE_GIC_ITS_AFFINITY:</span>
<span class="quote">&gt; +		{</span>
<span class="quote">&gt; +			struct acpi_srat_its_affinity *p =</span>
<span class="quote">&gt; +			    (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt; +			pr_debug(&quot;SRAT ITS [0x%04x]) in proximity domain %d\n&quot;,</span>
<span class="quote">&gt; +				 p-&gt;its_id,</span>
<span class="quote">&gt; +				 p-&gt;proximity_domain);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	default:</span>
<span class="quote">&gt;  		pr_warn(&quot;Found unsupported SRAT entry (type = 0x%x)\n&quot;,</span>
<span class="quote">&gt;  			header-&gt;type);</span>
<span class="quote">&gt; @@ -390,6 +400,24 @@ static int __init acpi_parse_slit(struct acpi_table_header *table)</span>
<span class="quote">&gt;  	return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static int __init</span>
<span class="quote">&gt; +acpi_parse_its_affinity(struct acpi_subtable_header *header,</span>
<span class="quote">&gt; +			 const unsigned long end)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct acpi_srat_its_affinity *its_affinity;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	its_affinity = (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt; +	if (!its_affinity)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	acpi_table_print_srat_entry(header);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* let architecture-dependent part to do it */</span>
<span class="quote">&gt; +	acpi_numa_its_affinity_init(its_affinity);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static int __initdata parsed_numa_memblks;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static int __init</span>
<span class="quote">&gt; @@ -445,7 +473,7 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* SRAT: Static Resource Affinity Table */</span>
<span class="quote">&gt;  	if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {</span>
<span class="quote">&gt; -		struct acpi_subtable_proc srat_proc[3];</span>
<span class="quote">&gt; +		struct acpi_subtable_proc srat_proc[4];</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  		memset(srat_proc, 0, sizeof(srat_proc));</span>
<span class="quote">&gt;  		srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;</span>
<span class="quote">&gt; @@ -454,6 +482,8 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;  		srat_proc[1].handler = acpi_parse_x2apic_affinity;</span>
<span class="quote">&gt;  		srat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;</span>
<span class="quote">&gt;  		srat_proc[2].handler = acpi_parse_gicc_affinity;</span>
<span class="quote">&gt; +		srat_proc[3].id = ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;</span>
<span class="quote">&gt; +		srat_proc[3].handler = acpi_parse_its_affinity;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  		acpi_table_parse_entries_array(ACPI_SIG_SRAT,</span>
<span class="quote">&gt;  					sizeof(struct acpi_table_srat),</span>
<span class="quote">&gt; diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; index 45ea1933..84936da 100644</span>
<span class="quote">&gt; --- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; +++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; @@ -1861,7 +1861,8 @@ static int __init gic_acpi_parse_madt_its(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;  		goto dom_err;</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	err = its_probe_one(&amp;res, dom_handle, NUMA_NO_NODE);</span>
<span class="quote">&gt; +	err = its_probe_one(&amp;res, dom_handle,</span>
<span class="quote">&gt; +			acpi_numa_get_its_nid(its_entry-&gt;translation_id));</span>

If that&#39;s the only usage I wonder whether we really need all arm64
arch code/data, instead of parsing the SRAT in ITS code driver straight
away at probe, retrieve its node and be done with this.

I understand you replicated what x86/GICC does with APIC code, I would
like to understand though if we see a reason why (or better, why we keep
the relevant stashed data in arch/arm64 instead of the ITS driver).

Thanks,
Lorenzo
<span class="quote">
&gt;  	if (!err)</span>
<span class="quote">&gt;  		return 0;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="quote">&gt; index 137e4a3..e5e8ae3 100644</span>
<span class="quote">&gt; --- a/include/linux/acpi.h</span>
<span class="quote">&gt; +++ b/include/linux/acpi.h</span>
<span class="quote">&gt; @@ -260,9 +260,12 @@ int acpi_table_parse_madt(enum acpi_madt_type id,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_ARM64</span>
<span class="quote">&gt;  void acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa);</span>
<span class="quote">&gt; +void acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa);</span>
<span class="quote">&gt;  #else</span>
<span class="quote">&gt;  static inline void</span>
<span class="quote">&gt;  acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa) { }</span>
<span class="quote">&gt; +static inline void</span>
<span class="quote">&gt; +acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa) { }</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  int acpi_numa_memory_affinity_init (struct acpi_srat_mem_affinity *ma);</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 1.8.1.4</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-acpi&quot; in</span>
<span class="quote">&gt; the body of a message to majordomo@vger.kernel.org</span>
<span class="quote">&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=106031">Ganapatrao Kulkarni</a> - June 14, 2017, 9:53 a.m.</div>
<pre class="content">
Hi Lorenzo,

On Mon, Jun 12, 2017 at 4:23 PM, Lorenzo Pieralisi
&lt;lorenzo.pieralisi@arm.com&gt; wrote:
<span class="quote">&gt; On Tue, Jun 06, 2017 at 06:26:27PM +0530, Ganapatrao Kulkarni wrote:</span>
<span class="quote">&gt;&gt; Add code to parse SRAT ITS Affinity sub table as defined in ACPI 6.2</span>
<span class="quote">&gt;&gt; Later in driver probe, its devices are mapped to numa node</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Nit: Capitalize &quot;its&quot;.</span>

ok.
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; using its id to proximity domain mapping.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ditto.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Ganapatrao Kulkarni &lt;ganapatrao.kulkarni@cavium.com&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/arm64/include/asm/acpi.h    |  2 ++</span>
<span class="quote">&gt;&gt;  arch/arm64/kernel/acpi_numa.c    | 59 ++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  drivers/acpi/numa.c              | 32 +++++++++++++++++++++-</span>
<span class="quote">&gt;&gt;  drivers/irqchip/irq-gic-v3-its.c |  3 +-</span>
<span class="quote">&gt;&gt;  include/linux/acpi.h             |  3 ++</span>
<span class="quote">&gt;&gt;  5 files changed, 97 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt;&gt; index 0e99978..60ea7d1 100644</span>
<span class="quote">&gt;&gt; --- a/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt;&gt; +++ b/arch/arm64/include/asm/acpi.h</span>
<span class="quote">&gt;&gt; @@ -143,9 +143,11 @@ static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
<span class="quote">&gt;&gt;  #ifdef CONFIG_ACPI_NUMA</span>
<span class="quote">&gt;&gt;  int arm64_acpi_numa_init(void);</span>
<span class="quote">&gt;&gt;  int acpi_numa_get_nid(unsigned int cpu, u64 hwid);</span>
<span class="quote">&gt;&gt; +int acpi_numa_get_its_nid(u32 its_id);</span>
<span class="quote">&gt;&gt;  #else</span>
<span class="quote">&gt;&gt;  static inline int arm64_acpi_numa_init(void) { return -ENOSYS; }</span>
<span class="quote">&gt;&gt;  static inline int acpi_numa_get_nid(unsigned int cpu, u64 hwid) { return NUMA_NO_NODE; }</span>
<span class="quote">&gt;&gt; +static inline int acpi_numa_get_its_nid(u32 its_id) { return NUMA_NO_NODE; }</span>
<span class="quote">&gt;&gt;  #endif /* CONFIG_ACPI_NUMA */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  #define ACPI_TABLE_UPGRADE_MAX_PHYS MEMBLOCK_ALLOC_ACCESSIBLE</span>
<span class="quote">&gt;&gt; diff --git a/arch/arm64/kernel/acpi_numa.c b/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt;&gt; index f01fab6..f7b2ea6 100644</span>
<span class="quote">&gt;&gt; --- a/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt;&gt; +++ b/arch/arm64/kernel/acpi_numa.c</span>
<span class="quote">&gt;&gt; @@ -29,15 +29,24 @@</span>
<span class="quote">&gt;&gt;  #include &lt;asm/numa.h&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  static int cpus_in_srat;</span>
<span class="quote">&gt;&gt; +static int its_in_srat;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  struct __node_cpu_hwid {</span>
<span class="quote">&gt;&gt;       u32 node_id;    /* logical node containing this CPU */</span>
<span class="quote">&gt;&gt;       u64 cpu_hwid;   /* MPIDR for this CPU */</span>
<span class="quote">&gt;&gt;  };</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +struct __node_its_id {</span>
<span class="quote">&gt;&gt; +     u32 node_id;    /* numa node id */</span>
<span class="quote">&gt;&gt; +     u32 its_id ;   /* GIC ITS ID */</span>
<span class="quote">&gt;                   ^</span>
<span class="quote">&gt; Remove space.</span>

ok, thanks.
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +};</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  static struct __node_cpu_hwid early_node_cpu_hwid[NR_CPUS] = {</span>
<span class="quote">&gt;&gt;  [0 ... NR_CPUS - 1] = {NUMA_NO_NODE, PHYS_CPUID_INVALID} };</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +static struct __node_its_id early_node_its_id[MAX_NUMNODES] = {</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Mind explaining to us where does MAX_NUMNODES as an array size limit</span>
<span class="quote">&gt; stem from here ?</span>

this is heuristic!
AFAIK, there is no limit on ITS devices per socket, however almost all
SoC designs has one ITS device per socket,
IMHO, assuming max ITS count to MAX_NUMNODES to init static array
should be reasonable i guess?
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +[0 ... MAX_NUMNODES - 1] = {NUMA_NO_NODE, UINT_MAX} };</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  int acpi_numa_get_nid(unsigned int cpu, u64 hwid)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt;       int i;</span>
<span class="quote">&gt;&gt; @@ -50,6 +59,18 @@ int acpi_numa_get_nid(unsigned int cpu, u64 hwid)</span>
<span class="quote">&gt;&gt;       return NUMA_NO_NODE;</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +int acpi_numa_get_its_nid(u32 its_id)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +     int i;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     for (i = 0; i &lt; its_in_srat; i++) {</span>
<span class="quote">&gt;&gt; +             if (its_id == early_node_its_id[i].its_id)</span>
<span class="quote">&gt;&gt; +                     return early_node_its_id[i].node_id;</span>
<span class="quote">&gt;&gt; +     }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     return NUMA_NO_NODE;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  /* Callback for Proximity Domain -&gt; ACPI processor UID mapping */</span>
<span class="quote">&gt;&gt;  void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt; @@ -100,6 +121,44 @@ void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)</span>
<span class="quote">&gt;&gt;               pxm, mpidr, node);</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +/* Callback for ITS ACPI Proximity Domain mapping */</span>
<span class="quote">&gt;&gt; +void __init acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +     int pxm, node;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     if (srat_disabled())</span>
<span class="quote">&gt;&gt; +             return;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     if (pa-&gt;header.length &lt; sizeof(struct acpi_srat_its_affinity)) {</span>
<span class="quote">&gt;&gt; +             pr_err(&quot;SRAT: Invalid SRAT header length: %d\n&quot;,</span>
<span class="quote">&gt;&gt; +                     pa-&gt;header.length);</span>
<span class="quote">&gt;&gt; +             bad_srat();</span>
<span class="quote">&gt;&gt; +             return;</span>
<span class="quote">&gt;&gt; +     }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     if (its_in_srat &gt;= MAX_NUMNODES) {</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I do not understand why maxcount == MAX_NUMNODES in the first place.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +             pr_warn_once(&quot;SRAT: its count exceeding max count[%d]\n&quot;,</span>
<span class="quote">&gt;&gt; +                          MAX_NUMNODES);</span>
<span class="quote">&gt;&gt; +             return;</span>
<span class="quote">&gt;&gt; +     }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     pxm = pa-&gt;proximity_domain;</span>
<span class="quote">&gt;&gt; +     node = acpi_map_pxm_to_node(pxm);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     if (node == NUMA_NO_NODE || node &gt;= MAX_NUMNODES) {</span>
<span class="quote">&gt;&gt; +             pr_err(&quot;SRAT: Too many proximity domains %d\n&quot;, pxm);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Wrong error log message or at least inconsistent (yes, GICC code</span>
<span class="quote">&gt; where you copied this code from needs patching too).</span>
<span class="quote">&gt;</span>

ok, i will update.
<span class="quote">&gt;&gt; +             bad_srat();</span>
<span class="quote">&gt;&gt; +             return;</span>
<span class="quote">&gt;&gt; +     }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     early_node_its_id[its_in_srat].node_id = node;</span>
<span class="quote">&gt;&gt; +     early_node_its_id[its_in_srat].its_id =  its_in_srat;</span>
<span class="quote">&gt;                                                ^</span>
<span class="quote">&gt; One space is enough (again - that&#39;s through for GICC code too).</span>

ok, thanks
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +     node_set(node, numa_nodes_parsed);</span>
<span class="quote">&gt;&gt; +     pr_info(&quot;SRAT: PXM %d -&gt; ITS %d -&gt; Node %d\n&quot;,</span>
<span class="quote">&gt;&gt; +             pxm, its_in_srat, node);</span>
<span class="quote">&gt;&gt; +     its_in_srat++;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  int __init arm64_acpi_numa_init(void)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt;       int ret;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/acpi/numa.c b/drivers/acpi/numa.c</span>
<span class="quote">&gt;&gt; index edb0c79..9c04dba 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/acpi/numa.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/acpi/numa.c</span>
<span class="quote">&gt;&gt; @@ -182,6 +182,16 @@ int acpi_map_pxm_to_online_node(int pxm)</span>
<span class="quote">&gt;&gt;               }</span>
<span class="quote">&gt;&gt;               break;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +     case ACPI_SRAT_TYPE_GIC_ITS_AFFINITY:</span>
<span class="quote">&gt;&gt; +             {</span>
<span class="quote">&gt;&gt; +                     struct acpi_srat_its_affinity *p =</span>
<span class="quote">&gt;&gt; +                         (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt;&gt; +                     pr_debug(&quot;SRAT ITS [0x%04x]) in proximity domain %d\n&quot;,</span>
<span class="quote">&gt;&gt; +                              p-&gt;its_id,</span>
<span class="quote">&gt;&gt; +                              p-&gt;proximity_domain);</span>
<span class="quote">&gt;&gt; +             }</span>
<span class="quote">&gt;&gt; +             break;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;       default:</span>
<span class="quote">&gt;&gt;               pr_warn(&quot;Found unsupported SRAT entry (type = 0x%x)\n&quot;,</span>
<span class="quote">&gt;&gt;                       header-&gt;type);</span>
<span class="quote">&gt;&gt; @@ -390,6 +400,24 @@ static int __init acpi_parse_slit(struct acpi_table_header *table)</span>
<span class="quote">&gt;&gt;       return 0;</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +static int __init</span>
<span class="quote">&gt;&gt; +acpi_parse_its_affinity(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;&gt; +                      const unsigned long end)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +     struct acpi_srat_its_affinity *its_affinity;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     its_affinity = (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt;&gt; +     if (!its_affinity)</span>
<span class="quote">&gt;&gt; +             return -EINVAL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     acpi_table_print_srat_entry(header);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     /* let architecture-dependent part to do it */</span>
<span class="quote">&gt;&gt; +     acpi_numa_its_affinity_init(its_affinity);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     return 0;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  static int __initdata parsed_numa_memblks;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  static int __init</span>
<span class="quote">&gt;&gt; @@ -445,7 +473,7 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;       /* SRAT: Static Resource Affinity Table */</span>
<span class="quote">&gt;&gt;       if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {</span>
<span class="quote">&gt;&gt; -             struct acpi_subtable_proc srat_proc[3];</span>
<span class="quote">&gt;&gt; +             struct acpi_subtable_proc srat_proc[4];</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;               memset(srat_proc, 0, sizeof(srat_proc));</span>
<span class="quote">&gt;&gt;               srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;</span>
<span class="quote">&gt;&gt; @@ -454,6 +482,8 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;&gt;               srat_proc[1].handler = acpi_parse_x2apic_affinity;</span>
<span class="quote">&gt;&gt;               srat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;</span>
<span class="quote">&gt;&gt;               srat_proc[2].handler = acpi_parse_gicc_affinity;</span>
<span class="quote">&gt;&gt; +             srat_proc[3].id = ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;</span>
<span class="quote">&gt;&gt; +             srat_proc[3].handler = acpi_parse_its_affinity;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;               acpi_table_parse_entries_array(ACPI_SIG_SRAT,</span>
<span class="quote">&gt;&gt;                                       sizeof(struct acpi_table_srat),</span>
<span class="quote">&gt;&gt; diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt; index 45ea1933..84936da 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt; @@ -1861,7 +1861,8 @@ static int __init gic_acpi_parse_madt_its(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;&gt;               goto dom_err;</span>
<span class="quote">&gt;&gt;       }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; -     err = its_probe_one(&amp;res, dom_handle, NUMA_NO_NODE);</span>
<span class="quote">&gt;&gt; +     err = its_probe_one(&amp;res, dom_handle,</span>
<span class="quote">&gt;&gt; +                     acpi_numa_get_its_nid(its_entry-&gt;translation_id));</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If that&#39;s the only usage I wonder whether we really need all arm64</span>
<span class="quote">&gt; arch code/data, instead of parsing the SRAT in ITS code driver straight</span>
<span class="quote">&gt; away at probe, retrieve its node and be done with this.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I understand you replicated what x86/GICC does with APIC code, I would</span>
<span class="quote">&gt; like to understand though if we see a reason why (or better, why we keep</span>
<span class="quote">&gt; the relevant stashed data in arch/arm64 instead of the ITS driver).</span>

it is been thought to do ITS sub table parse along with other SRAT tables.
and use the mapping later when ITS devices are initialised/probed.
IMO, it is more appropriate to keep all SRAT sub table parsing to same
function/place
rather than moving to driver.
<span class="quote">
&gt;</span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt; Lorenzo</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;       if (!err)</span>
<span class="quote">&gt;&gt;               return 0;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="quote">&gt;&gt; index 137e4a3..e5e8ae3 100644</span>
<span class="quote">&gt;&gt; --- a/include/linux/acpi.h</span>
<span class="quote">&gt;&gt; +++ b/include/linux/acpi.h</span>
<span class="quote">&gt;&gt; @@ -260,9 +260,12 @@ int acpi_table_parse_madt(enum acpi_madt_type id,</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  #ifdef CONFIG_ARM64</span>
<span class="quote">&gt;&gt;  void acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa);</span>
<span class="quote">&gt;&gt; +void acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa);</span>
<span class="quote">&gt;&gt;  #else</span>
<span class="quote">&gt;&gt;  static inline void</span>
<span class="quote">&gt;&gt;  acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa) { }</span>
<span class="quote">&gt;&gt; +static inline void</span>
<span class="quote">&gt;&gt; +acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa) { }</span>
<span class="quote">&gt;&gt;  #endif</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;  int acpi_numa_memory_affinity_init (struct acpi_srat_mem_affinity *ma);</span>
<span class="quote">&gt;&gt; --</span>
<span class="quote">&gt;&gt; 1.8.1.4</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; --</span>
<span class="quote">&gt;&gt; To unsubscribe from this list: send the line &quot;unsubscribe linux-acpi&quot; in</span>
<span class="quote">&gt;&gt; the body of a message to majordomo@vger.kernel.org</span>
<span class="quote">&gt;&gt; More majordomo info at  http://vger.kernel.org/majordomo-info.html</span>

thanks
Ganapat
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=22691">Lorenzo Pieralisi</a> - June 15, 2017, 10:35 a.m.</div>
<pre class="content">
On Wed, Jun 14, 2017 at 03:23:17PM +0530, Ganapatrao Kulkarni wrote:

[...]
<span class="quote">
&gt; &gt;&gt; +static int __init</span>
<span class="quote">&gt; &gt;&gt; +acpi_parse_its_affinity(struct acpi_subtable_header *header,</span>
<span class="quote">&gt; &gt;&gt; +                      const unsigned long end)</span>
<span class="quote">&gt; &gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; +     struct acpi_srat_its_affinity *its_affinity;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +     its_affinity = (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt; &gt;&gt; +     if (!its_affinity)</span>
<span class="quote">&gt; &gt;&gt; +             return -EINVAL;</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +     acpi_table_print_srat_entry(header);</span>

You can leave this info printing but see below.
<span class="quote">
&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +     /* let architecture-dependent part to do it */</span>
<span class="quote">&gt; &gt;&gt; +     acpi_numa_its_affinity_init(its_affinity);</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; +     return 0;</span>
<span class="quote">&gt; &gt;&gt; +}</span>
<span class="quote">&gt; &gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;  static int __initdata parsed_numa_memblks;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;  static int __init</span>
<span class="quote">&gt; &gt;&gt; @@ -445,7 +473,7 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;       /* SRAT: Static Resource Affinity Table */</span>
<span class="quote">&gt; &gt;&gt;       if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {</span>
<span class="quote">&gt; &gt;&gt; -             struct acpi_subtable_proc srat_proc[3];</span>
<span class="quote">&gt; &gt;&gt; +             struct acpi_subtable_proc srat_proc[4];</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;               memset(srat_proc, 0, sizeof(srat_proc));</span>
<span class="quote">&gt; &gt;&gt;               srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;</span>
<span class="quote">&gt; &gt;&gt; @@ -454,6 +482,8 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt; &gt;&gt;               srat_proc[1].handler = acpi_parse_x2apic_affinity;</span>
<span class="quote">&gt; &gt;&gt;               srat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;</span>
<span class="quote">&gt; &gt;&gt;               srat_proc[2].handler = acpi_parse_gicc_affinity;</span>
<span class="quote">&gt; &gt;&gt; +             srat_proc[3].id = ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;</span>
<span class="quote">&gt; &gt;&gt; +             srat_proc[3].handler = acpi_parse_its_affinity;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;               acpi_table_parse_entries_array(ACPI_SIG_SRAT,</span>
<span class="quote">&gt; &gt;&gt;                                       sizeof(struct acpi_table_srat),</span>
<span class="quote">&gt; &gt;&gt; diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; &gt;&gt; index 45ea1933..84936da 100644</span>
<span class="quote">&gt; &gt;&gt; --- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; &gt;&gt; +++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt; &gt;&gt; @@ -1861,7 +1861,8 @@ static int __init gic_acpi_parse_madt_its(struct acpi_subtable_header *header,</span>
<span class="quote">&gt; &gt;&gt;               goto dom_err;</span>
<span class="quote">&gt; &gt;&gt;       }</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; -     err = its_probe_one(&amp;res, dom_handle, NUMA_NO_NODE);</span>
<span class="quote">&gt; &gt;&gt; +     err = its_probe_one(&amp;res, dom_handle,</span>
<span class="quote">&gt; &gt;&gt; +                     acpi_numa_get_its_nid(its_entry-&gt;translation_id));</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; If that&#39;s the only usage I wonder whether we really need all arm64</span>
<span class="quote">&gt; &gt; arch code/data, instead of parsing the SRAT in ITS code driver straight</span>
<span class="quote">&gt; &gt; away at probe, retrieve its node and be done with this.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; I understand you replicated what x86/GICC does with APIC code, I would</span>
<span class="quote">&gt; &gt; like to understand though if we see a reason why (or better, why we keep</span>
<span class="quote">&gt; &gt; the relevant stashed data in arch/arm64 instead of the ITS driver).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; it is been thought to do ITS sub table parse along with other SRAT</span>
<span class="quote">&gt; tables.  and use the mapping later when ITS devices are</span>
<span class="quote">&gt; initialised/probed.  IMO, it is more appropriate to keep all SRAT sub</span>
<span class="quote">&gt; table parsing to same function/place rather than moving to driver.</span>

I do not follow. If it is just used in ITS driver code to set the ITS
affinity node what&#39;s the point of stashing data and adding callbacks
when you can simply parse the SRAT and be done with it ?

Or you have something on top of these patches that require ITS node
information and the calls you added ? If so post the code please.

Regardless, it&#39;s ITS specific information, ITS is managed through an
irqchip driver on ARM64 so even if you decided to stash the SRAT ITS
information it does not belong in arch/arm64 IMO, you can implement
acpi_numa_its_affinity_init() in the ITS driver but AFAICS for the time
being it would be just useless that&#39;s the point I am making.

Thanks,
Lorenzo
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=28962">Marc Zyngier</a> - June 15, 2017, 10:43 a.m.</div>
<pre class="content">
On 15/06/17 11:35, Lorenzo Pieralisi wrote:
<span class="quote">&gt; On Wed, Jun 14, 2017 at 03:23:17PM +0530, Ganapatrao Kulkarni wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; [...]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; +static int __init</span>
<span class="quote">&gt;&gt;&gt;&gt; +acpi_parse_its_affinity(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;&gt;&gt;&gt; +                      const unsigned long end)</span>
<span class="quote">&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt; +     struct acpi_srat_its_affinity *its_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +     its_affinity = (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt;&gt;&gt;&gt; +     if (!its_affinity)</span>
<span class="quote">&gt;&gt;&gt;&gt; +             return -EINVAL;</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +     acpi_table_print_srat_entry(header);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You can leave this info printing but see below.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +     /* let architecture-dependent part to do it */</span>
<span class="quote">&gt;&gt;&gt;&gt; +     acpi_numa_its_affinity_init(its_affinity);</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +     return 0;</span>
<span class="quote">&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;  static int __initdata parsed_numa_memblks;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  static int __init</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -445,7 +473,7 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;       /* SRAT: Static Resource Affinity Table */</span>
<span class="quote">&gt;&gt;&gt;&gt;       if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {</span>
<span class="quote">&gt;&gt;&gt;&gt; -             struct acpi_subtable_proc srat_proc[3];</span>
<span class="quote">&gt;&gt;&gt;&gt; +             struct acpi_subtable_proc srat_proc[4];</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;               memset(srat_proc, 0, sizeof(srat_proc));</span>
<span class="quote">&gt;&gt;&gt;&gt;               srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -454,6 +482,8 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;&gt;&gt;&gt;               srat_proc[1].handler = acpi_parse_x2apic_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt;               srat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;</span>
<span class="quote">&gt;&gt;&gt;&gt;               srat_proc[2].handler = acpi_parse_gicc_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt; +             srat_proc[3].id = ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;</span>
<span class="quote">&gt;&gt;&gt;&gt; +             srat_proc[3].handler = acpi_parse_its_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;               acpi_table_parse_entries_array(ACPI_SIG_SRAT,</span>
<span class="quote">&gt;&gt;&gt;&gt;                                       sizeof(struct acpi_table_srat),</span>
<span class="quote">&gt;&gt;&gt;&gt; diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt;&gt;&gt; index 45ea1933..84936da 100644</span>
<span class="quote">&gt;&gt;&gt;&gt; --- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt;&gt;&gt; +++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt;&gt;&gt; @@ -1861,7 +1861,8 @@ static int __init gic_acpi_parse_madt_its(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;&gt;&gt;&gt;               goto dom_err;</span>
<span class="quote">&gt;&gt;&gt;&gt;       }</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; -     err = its_probe_one(&amp;res, dom_handle, NUMA_NO_NODE);</span>
<span class="quote">&gt;&gt;&gt;&gt; +     err = its_probe_one(&amp;res, dom_handle,</span>
<span class="quote">&gt;&gt;&gt;&gt; +                     acpi_numa_get_its_nid(its_entry-&gt;translation_id));</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; If that&#39;s the only usage I wonder whether we really need all arm64</span>
<span class="quote">&gt;&gt;&gt; arch code/data, instead of parsing the SRAT in ITS code driver straight</span>
<span class="quote">&gt;&gt;&gt; away at probe, retrieve its node and be done with this.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; I understand you replicated what x86/GICC does with APIC code, I would</span>
<span class="quote">&gt;&gt;&gt; like to understand though if we see a reason why (or better, why we keep</span>
<span class="quote">&gt;&gt;&gt; the relevant stashed data in arch/arm64 instead of the ITS driver).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; it is been thought to do ITS sub table parse along with other SRAT</span>
<span class="quote">&gt;&gt; tables.  and use the mapping later when ITS devices are</span>
<span class="quote">&gt;&gt; initialised/probed.  IMO, it is more appropriate to keep all SRAT sub</span>
<span class="quote">&gt;&gt; table parsing to same function/place rather than moving to driver.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I do not follow. If it is just used in ITS driver code to set the ITS</span>
<span class="quote">&gt; affinity node what&#39;s the point of stashing data and adding callbacks</span>
<span class="quote">&gt; when you can simply parse the SRAT and be done with it ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Or you have something on top of these patches that require ITS node</span>
<span class="quote">&gt; information and the calls you added ? If so post the code please.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Regardless, it&#39;s ITS specific information, ITS is managed through an</span>
<span class="quote">&gt; irqchip driver on ARM64 so even if you decided to stash the SRAT ITS</span>
<span class="quote">&gt; information it does not belong in arch/arm64 IMO, you can implement</span>
<span class="quote">&gt; acpi_numa_its_affinity_init() in the ITS driver but AFAICS for the time</span>
<span class="quote">&gt; being it would be just useless that&#39;s the point I am making.</span>

Agreed. As long as there is only the ITS as a consumer of that
information, there is no need to pollute the rest of the kernel with it.
Once we have another consumer, we can look at making that code common.
In the meantime, keeping it in the ITS code is the right thing to do.

Thanks,

	M.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=106031">Ganapatrao Kulkarni</a> - June 15, 2017, 10:55 a.m.</div>
<pre class="content">
On Thu, Jun 15, 2017 at 4:13 PM, Marc Zyngier &lt;marc.zyngier@arm.com&gt; wrote:
<span class="quote">&gt; On 15/06/17 11:35, Lorenzo Pieralisi wrote:</span>
<span class="quote">&gt;&gt; On Wed, Jun 14, 2017 at 03:23:17PM +0530, Ganapatrao Kulkarni wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; [...]</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +static int __init</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +acpi_parse_its_affinity(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +                      const unsigned long end)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     struct acpi_srat_its_affinity *its_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     its_affinity = (struct acpi_srat_its_affinity *)header;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     if (!its_affinity)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             return -EINVAL;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     acpi_table_print_srat_entry(header);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; You can leave this info printing but see below.</span>

ok.
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     /* let architecture-dependent part to do it */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     acpi_numa_its_affinity_init(its_affinity);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     return 0;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;  static int __initdata parsed_numa_memblks;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;  static int __init</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; @@ -445,7 +473,7 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;       /* SRAT: Static Resource Affinity Table */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;       if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; -             struct acpi_subtable_proc srat_proc[3];</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             struct acpi_subtable_proc srat_proc[4];</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;               memset(srat_proc, 0, sizeof(srat_proc));</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;               srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; @@ -454,6 +482,8 @@ int __init acpi_numa_init(void)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;               srat_proc[1].handler = acpi_parse_x2apic_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;               srat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;               srat_proc[2].handler = acpi_parse_gicc_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             srat_proc[3].id = ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +             srat_proc[3].handler = acpi_parse_its_affinity;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;               acpi_table_parse_entries_array(ACPI_SIG_SRAT,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;                                       sizeof(struct acpi_table_srat),</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; index 45ea1933..84936da 100644</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; --- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; @@ -1861,7 +1861,8 @@ static int __init gic_acpi_parse_madt_its(struct acpi_subtable_header *header,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;               goto dom_err;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;       }</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; -     err = its_probe_one(&amp;res, dom_handle, NUMA_NO_NODE);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +     err = its_probe_one(&amp;res, dom_handle,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +                     acpi_numa_get_its_nid(its_entry-&gt;translation_id));</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; If that&#39;s the only usage I wonder whether we really need all arm64</span>
<span class="quote">&gt;&gt;&gt;&gt; arch code/data, instead of parsing the SRAT in ITS code driver straight</span>
<span class="quote">&gt;&gt;&gt;&gt; away at probe, retrieve its node and be done with this.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I understand you replicated what x86/GICC does with APIC code, I would</span>
<span class="quote">&gt;&gt;&gt;&gt; like to understand though if we see a reason why (or better, why we keep</span>
<span class="quote">&gt;&gt;&gt;&gt; the relevant stashed data in arch/arm64 instead of the ITS driver).</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; it is been thought to do ITS sub table parse along with other SRAT</span>
<span class="quote">&gt;&gt;&gt; tables.  and use the mapping later when ITS devices are</span>
<span class="quote">&gt;&gt;&gt; initialised/probed.  IMO, it is more appropriate to keep all SRAT sub</span>
<span class="quote">&gt;&gt;&gt; table parsing to same function/place rather than moving to driver.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I do not follow. If it is just used in ITS driver code to set the ITS</span>
<span class="quote">&gt;&gt; affinity node what&#39;s the point of stashing data and adding callbacks</span>
<span class="quote">&gt;&gt; when you can simply parse the SRAT and be done with it ?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Or you have something on top of these patches that require ITS node</span>
<span class="quote">&gt;&gt; information and the calls you added ? If so post the code please.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Regardless, it&#39;s ITS specific information, ITS is managed through an</span>
<span class="quote">&gt;&gt; irqchip driver on ARM64 so even if you decided to stash the SRAT ITS</span>
<span class="quote">&gt;&gt; information it does not belong in arch/arm64 IMO, you can implement</span>
<span class="quote">&gt;&gt; acpi_numa_its_affinity_init() in the ITS driver but AFAICS for the time</span>
<span class="quote">&gt;&gt; being it would be just useless that&#39;s the point I am making.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Agreed. As long as there is only the ITS as a consumer of that</span>
<span class="quote">&gt; information, there is no need to pollute the rest of the kernel with it.</span>
<span class="quote">&gt; Once we have another consumer, we can look at making that code common.</span>
<span class="quote">&gt; In the meantime, keeping it in the ITS code is the right thing to do.</span>

agreed, i will change it in next version.
<span class="quote">
&gt;</span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         M.</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; Jazz is not dead. It just smells funny...</span>

thanks
Ganapat
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm64/include/asm/acpi.h b/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">index 0e99978..60ea7d1 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/acpi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/acpi.h</span>
<span class="p_chunk">@@ -143,9 +143,11 @@</span> <span class="p_context"> static inline void arch_apei_flush_tlb_one(unsigned long addr)</span>
 #ifdef CONFIG_ACPI_NUMA
 int arm64_acpi_numa_init(void);
 int acpi_numa_get_nid(unsigned int cpu, u64 hwid);
<span class="p_add">+int acpi_numa_get_its_nid(u32 its_id);</span>
 #else
 static inline int arm64_acpi_numa_init(void) { return -ENOSYS; }
 static inline int acpi_numa_get_nid(unsigned int cpu, u64 hwid) { return NUMA_NO_NODE; }
<span class="p_add">+static inline int acpi_numa_get_its_nid(u32 its_id) { return NUMA_NO_NODE; }</span>
 #endif /* CONFIG_ACPI_NUMA */
 
 #define ACPI_TABLE_UPGRADE_MAX_PHYS MEMBLOCK_ALLOC_ACCESSIBLE
<span class="p_header">diff --git a/arch/arm64/kernel/acpi_numa.c b/arch/arm64/kernel/acpi_numa.c</span>
<span class="p_header">index f01fab6..f7b2ea6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/acpi_numa.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/acpi_numa.c</span>
<span class="p_chunk">@@ -29,15 +29,24 @@</span> <span class="p_context"></span>
 #include &lt;asm/numa.h&gt;
 
 static int cpus_in_srat;
<span class="p_add">+static int its_in_srat;</span>
 
 struct __node_cpu_hwid {
 	u32 node_id;    /* logical node containing this CPU */
 	u64 cpu_hwid;   /* MPIDR for this CPU */
 };
 
<span class="p_add">+struct __node_its_id {</span>
<span class="p_add">+	u32 node_id;    /* numa node id */</span>
<span class="p_add">+	u32 its_id ;   /* GIC ITS ID */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static struct __node_cpu_hwid early_node_cpu_hwid[NR_CPUS] = {
 [0 ... NR_CPUS - 1] = {NUMA_NO_NODE, PHYS_CPUID_INVALID} };
 
<span class="p_add">+static struct __node_its_id early_node_its_id[MAX_NUMNODES] = {</span>
<span class="p_add">+[0 ... MAX_NUMNODES - 1] = {NUMA_NO_NODE, UINT_MAX} };</span>
<span class="p_add">+</span>
 int acpi_numa_get_nid(unsigned int cpu, u64 hwid)
 {
 	int i;
<span class="p_chunk">@@ -50,6 +59,18 @@</span> <span class="p_context"> int acpi_numa_get_nid(unsigned int cpu, u64 hwid)</span>
 	return NUMA_NO_NODE;
 }
 
<span class="p_add">+int acpi_numa_get_its_nid(u32 its_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; its_in_srat; i++) {</span>
<span class="p_add">+		if (its_id == early_node_its_id[i].its_id)</span>
<span class="p_add">+			return early_node_its_id[i].node_id;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Callback for Proximity Domain -&gt; ACPI processor UID mapping */
 void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)
 {
<span class="p_chunk">@@ -100,6 +121,44 @@</span> <span class="p_context"> void __init acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa)</span>
 		pxm, mpidr, node);
 }
 
<span class="p_add">+/* Callback for ITS ACPI Proximity Domain mapping */</span>
<span class="p_add">+void __init acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int pxm, node;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (srat_disabled())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pa-&gt;header.length &lt; sizeof(struct acpi_srat_its_affinity)) {</span>
<span class="p_add">+		pr_err(&quot;SRAT: Invalid SRAT header length: %d\n&quot;,</span>
<span class="p_add">+			pa-&gt;header.length);</span>
<span class="p_add">+		bad_srat();</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (its_in_srat &gt;= MAX_NUMNODES) {</span>
<span class="p_add">+		pr_warn_once(&quot;SRAT: its count exceeding max count[%d]\n&quot;,</span>
<span class="p_add">+			     MAX_NUMNODES);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pxm = pa-&gt;proximity_domain;</span>
<span class="p_add">+	node = acpi_map_pxm_to_node(pxm);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (node == NUMA_NO_NODE || node &gt;= MAX_NUMNODES) {</span>
<span class="p_add">+		pr_err(&quot;SRAT: Too many proximity domains %d\n&quot;, pxm);</span>
<span class="p_add">+		bad_srat();</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	early_node_its_id[its_in_srat].node_id = node;</span>
<span class="p_add">+	early_node_its_id[its_in_srat].its_id =  its_in_srat;</span>
<span class="p_add">+	node_set(node, numa_nodes_parsed);</span>
<span class="p_add">+	pr_info(&quot;SRAT: PXM %d -&gt; ITS %d -&gt; Node %d\n&quot;,</span>
<span class="p_add">+		pxm, its_in_srat, node);</span>
<span class="p_add">+	its_in_srat++;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int __init arm64_acpi_numa_init(void)
 {
 	int ret;
<span class="p_header">diff --git a/drivers/acpi/numa.c b/drivers/acpi/numa.c</span>
<span class="p_header">index edb0c79..9c04dba 100644</span>
<span class="p_header">--- a/drivers/acpi/numa.c</span>
<span class="p_header">+++ b/drivers/acpi/numa.c</span>
<span class="p_chunk">@@ -182,6 +182,16 @@</span> <span class="p_context"> int acpi_map_pxm_to_online_node(int pxm)</span>
 		}
 		break;
 
<span class="p_add">+	case ACPI_SRAT_TYPE_GIC_ITS_AFFINITY:</span>
<span class="p_add">+		{</span>
<span class="p_add">+			struct acpi_srat_its_affinity *p =</span>
<span class="p_add">+			    (struct acpi_srat_its_affinity *)header;</span>
<span class="p_add">+			pr_debug(&quot;SRAT ITS [0x%04x]) in proximity domain %d\n&quot;,</span>
<span class="p_add">+				 p-&gt;its_id,</span>
<span class="p_add">+				 p-&gt;proximity_domain);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	default:
 		pr_warn(&quot;Found unsupported SRAT entry (type = 0x%x)\n&quot;,
 			header-&gt;type);
<span class="p_chunk">@@ -390,6 +400,24 @@</span> <span class="p_context"> static int __init acpi_parse_slit(struct acpi_table_header *table)</span>
 	return 0;
 }
 
<span class="p_add">+static int __init</span>
<span class="p_add">+acpi_parse_its_affinity(struct acpi_subtable_header *header,</span>
<span class="p_add">+			 const unsigned long end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct acpi_srat_its_affinity *its_affinity;</span>
<span class="p_add">+</span>
<span class="p_add">+	its_affinity = (struct acpi_srat_its_affinity *)header;</span>
<span class="p_add">+	if (!its_affinity)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	acpi_table_print_srat_entry(header);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let architecture-dependent part to do it */</span>
<span class="p_add">+	acpi_numa_its_affinity_init(its_affinity);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __initdata parsed_numa_memblks;
 
 static int __init
<span class="p_chunk">@@ -445,7 +473,7 @@</span> <span class="p_context"> int __init acpi_numa_init(void)</span>
 
 	/* SRAT: Static Resource Affinity Table */
 	if (!acpi_table_parse(ACPI_SIG_SRAT, acpi_parse_srat)) {
<span class="p_del">-		struct acpi_subtable_proc srat_proc[3];</span>
<span class="p_add">+		struct acpi_subtable_proc srat_proc[4];</span>
 
 		memset(srat_proc, 0, sizeof(srat_proc));
 		srat_proc[0].id = ACPI_SRAT_TYPE_CPU_AFFINITY;
<span class="p_chunk">@@ -454,6 +482,8 @@</span> <span class="p_context"> int __init acpi_numa_init(void)</span>
 		srat_proc[1].handler = acpi_parse_x2apic_affinity;
 		srat_proc[2].id = ACPI_SRAT_TYPE_GICC_AFFINITY;
 		srat_proc[2].handler = acpi_parse_gicc_affinity;
<span class="p_add">+		srat_proc[3].id = ACPI_SRAT_TYPE_GIC_ITS_AFFINITY;</span>
<span class="p_add">+		srat_proc[3].handler = acpi_parse_its_affinity;</span>
 
 		acpi_table_parse_entries_array(ACPI_SIG_SRAT,
 					sizeof(struct acpi_table_srat),
<span class="p_header">diff --git a/drivers/irqchip/irq-gic-v3-its.c b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_header">index 45ea1933..84936da 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-gic-v3-its.c</span>
<span class="p_chunk">@@ -1861,7 +1861,8 @@</span> <span class="p_context"> static int __init gic_acpi_parse_madt_its(struct acpi_subtable_header *header,</span>
 		goto dom_err;
 	}
 
<span class="p_del">-	err = its_probe_one(&amp;res, dom_handle, NUMA_NO_NODE);</span>
<span class="p_add">+	err = its_probe_one(&amp;res, dom_handle,</span>
<span class="p_add">+			acpi_numa_get_its_nid(its_entry-&gt;translation_id));</span>
 	if (!err)
 		return 0;
 
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index 137e4a3..e5e8ae3 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -260,9 +260,12 @@</span> <span class="p_context"> int acpi_table_parse_madt(enum acpi_madt_type id,</span>
 
 #ifdef CONFIG_ARM64
 void acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa);
<span class="p_add">+void acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa);</span>
 #else
 static inline void
 acpi_numa_gicc_affinity_init(struct acpi_srat_gicc_affinity *pa) { }
<span class="p_add">+static inline void</span>
<span class="p_add">+acpi_numa_its_affinity_init(struct acpi_srat_its_affinity *pa) { }</span>
 #endif
 
 int acpi_numa_memory_affinity_init (struct acpi_srat_mem_affinity *ma);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



