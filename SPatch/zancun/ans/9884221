
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.12.5 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.12.5</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 7, 2017, 1:48 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170807014830.GB7155@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9884221/mbox/"
   >mbox</a>
|
   <a href="/patch/9884221/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9884221/">/patch/9884221/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E391560360 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Aug 2017 01:48:43 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CF6A02856A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Aug 2017 01:48:43 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C413A2857B; Mon,  7 Aug 2017 01:48:43 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id BEAC928578
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  7 Aug 2017 01:48:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752048AbdHGBsf (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 6 Aug 2017 21:48:35 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:60570 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751396AbdHGBsb (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 6 Aug 2017 21:48:31 -0400
Received: from localhost (c-73-158-54-216.hsd1.ca.comcast.net
	[73.158.54.216])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id CB580258;
	Mon,  7 Aug 2017 01:48:30 +0000 (UTC)
Date: Sun, 6 Aug 2017 18:48:30 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.12.5
Message-ID: &lt;20170807014830.GB7155@kroah.com&gt;
References: &lt;20170807014818.GA7155@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170807014818.GA7155@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 7, 2017, 1:48 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index bfdc92c2e47a..382e967b0792 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 12
<span class="p_del">-SUBLEVEL = 4</span>
<span class="p_add">+SUBLEVEL = 5</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index c32a09095216..85a92db70afc 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -453,8 +453,8 @@</span> <span class="p_context"> void copy_user_page(void *vto, void *vfrom, unsigned long vaddr,</span>
 	  before it can be accessed through the kernel mapping. */
 	preempt_disable();
 	flush_dcache_page_asm(__pa(vfrom), vaddr);
<span class="p_del">-	preempt_enable();</span>
 	copy_page_asm(vto, vfrom);
<span class="p_add">+	preempt_enable();</span>
 }
 EXPORT_SYMBOL(copy_user_page);
 
<span class="p_chunk">@@ -539,6 +539,10 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 	struct vm_area_struct *vma;
 	pgd_t *pgd;
 
<span class="p_add">+	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_add">+	if (parisc_requires_coherency())</span>
<span class="p_add">+		flush_tlb_all();</span>
<span class="p_add">+</span>
 	/* Flushing the whole cache on each cpu takes forever on
 	   rp3440, etc.  So, avoid it if the mm isn&#39;t too big.  */
 	if (mm_total_size(mm) &gt;= parisc_cache_flush_threshold) {
<span class="p_chunk">@@ -577,33 +581,22 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 void flush_cache_range(struct vm_area_struct *vma,
 		unsigned long start, unsigned long end)
 {
<span class="p_del">-	unsigned long addr;</span>
<span class="p_del">-	pgd_t *pgd;</span>
<span class="p_del">-</span>
 	BUG_ON(!vma-&gt;vm_mm-&gt;context);
 
<span class="p_add">+	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_add">+	if (parisc_requires_coherency())</span>
<span class="p_add">+		flush_tlb_range(vma, start, end);</span>
<span class="p_add">+</span>
 	if ((end - start) &gt;= parisc_cache_flush_threshold) {
 		flush_cache_all();
 		return;
 	}
 
<span class="p_del">-	if (vma-&gt;vm_mm-&gt;context == mfsp(3)) {</span>
<span class="p_del">-		flush_user_dcache_range_asm(start, end);</span>
<span class="p_del">-		if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_del">-			flush_user_icache_range_asm(start, end);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	BUG_ON(vma-&gt;vm_mm-&gt;context != mfsp(3));</span>
 
<span class="p_del">-	pgd = vma-&gt;vm_mm-&gt;pgd;</span>
<span class="p_del">-	for (addr = start &amp; PAGE_MASK; addr &lt; end; addr += PAGE_SIZE) {</span>
<span class="p_del">-		unsigned long pfn;</span>
<span class="p_del">-		pte_t *ptep = get_ptep(pgd, addr);</span>
<span class="p_del">-		if (!ptep)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		pfn = pte_pfn(*ptep);</span>
<span class="p_del">-		if (pfn_valid(pfn))</span>
<span class="p_del">-			__flush_cache_page(vma, addr, PFN_PHYS(pfn));</span>
<span class="p_del">-	}</span>
<span class="p_add">+	flush_user_dcache_range_asm(start, end);</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_add">+		flush_user_icache_range_asm(start, end);</span>
 }
 
 void
<span class="p_chunk">@@ -612,7 +605,8 @@</span> <span class="p_context"> flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long</span>
 	BUG_ON(!vma-&gt;vm_mm-&gt;context);
 
 	if (pfn_valid(pfn)) {
<span class="p_del">-		flush_tlb_page(vma, vmaddr);</span>
<span class="p_add">+		if (parisc_requires_coherency())</span>
<span class="p_add">+			flush_tlb_page(vma, vmaddr);</span>
 		__flush_cache_page(vma, vmaddr, PFN_PHYS(pfn));
 	}
 }
<span class="p_header">diff --git a/arch/parisc/kernel/process.c b/arch/parisc/kernel/process.c</span>
<span class="p_header">index b64d7d21646e..a45a67d526f8 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/process.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/process.c</span>
<span class="p_chunk">@@ -53,6 +53,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/random.h&gt;
<span class="p_add">+#include &lt;linux/nmi.h&gt;</span>
 
 #include &lt;asm/io.h&gt;
 #include &lt;asm/asm-offsets.h&gt;
<span class="p_chunk">@@ -145,6 +146,7 @@</span> <span class="p_context"> void machine_power_off(void)</span>
 
 	/* prevent soft lockup/stalled CPU messages for endless loop. */
 	rcu_sysrq_start();
<span class="p_add">+	lockup_detector_suspend();</span>
 	for (;;);
 }
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_64_mmu_hv.c b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">index 710e491206ed..1c10e26cebbb 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_64_mmu_hv.c</span>
<span class="p_chunk">@@ -164,8 +164,10 @@</span> <span class="p_context"> long kvmppc_alloc_reset_hpt(struct kvm *kvm, int order)</span>
 		goto out;
 	}
 
<span class="p_del">-	if (kvm-&gt;arch.hpt.virt)</span>
<span class="p_add">+	if (kvm-&gt;arch.hpt.virt) {</span>
 		kvmppc_free_hpt(&amp;kvm-&gt;arch.hpt);
<span class="p_add">+		kvmppc_rmap_reset(kvm);</span>
<span class="p_add">+	}</span>
 
 	err = kvmppc_allocate_hpt(&amp;info, order);
 	if (err &lt; 0)
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 8d1a365b8edc..1d3602f7ec22 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -2938,6 +2938,8 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 			run-&gt;fail_entry.hardware_entry_failure_reason = 0;
 			return -EINVAL;
 		}
<span class="p_add">+		/* Enable TM so we can read the TM SPRs */</span>
<span class="p_add">+		mtmsr(mfmsr() | MSR_TM);</span>
 		current-&gt;thread.tm_tfhar = mfspr(SPRN_TFHAR);
 		current-&gt;thread.tm_tfiar = mfspr(SPRN_TFIAR);
 		current-&gt;thread.tm_texasr = mfspr(SPRN_TEXASR);
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/reconfig.c b/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_header">index e5bf1e84047f..011ef2180fe6 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/reconfig.c</span>
<span class="p_chunk">@@ -82,7 +82,6 @@</span> <span class="p_context"> static int pSeries_reconfig_remove_node(struct device_node *np)</span>
 
 	of_detach_node(np);
 	of_node_put(parent);
<span class="p_del">-	of_node_put(np); /* Must decrement the refcount */</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/crypto/authencesn.c b/crypto/authencesn.c</span>
<span class="p_header">index 6f8f6b86bfe2..0cf5fefdb859 100644</span>
<span class="p_header">--- a/crypto/authencesn.c</span>
<span class="p_header">+++ b/crypto/authencesn.c</span>
<span class="p_chunk">@@ -248,6 +248,9 @@</span> <span class="p_context"> static int crypto_authenc_esn_decrypt_tail(struct aead_request *req,</span>
 	u8 *ihash = ohash + crypto_ahash_digestsize(auth);
 	u32 tmp[2];
 
<span class="p_add">+	if (!authsize)</span>
<span class="p_add">+		goto decrypt;</span>
<span class="p_add">+</span>
 	/* Move high-order bits of sequence number back. */
 	scatterwalk_map_and_copy(tmp, dst, 4, 4, 0);
 	scatterwalk_map_and_copy(tmp + 1, dst, assoclen + cryptlen, 4, 0);
<span class="p_chunk">@@ -256,6 +259,8 @@</span> <span class="p_context"> static int crypto_authenc_esn_decrypt_tail(struct aead_request *req,</span>
 	if (crypto_memneq(ihash, ohash, authsize))
 		return -EBADMSG;
 
<span class="p_add">+decrypt:</span>
<span class="p_add">+</span>
 	sg_init_table(areq_ctx-&gt;dst, 2);
 	dst = scatterwalk_ffwd(areq_ctx-&gt;dst, dst, assoclen);
 
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_watchdog.c b/drivers/char/ipmi/ipmi_watchdog.c</span>
<span class="p_header">index d165af8abe36..4161d9961a24 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_watchdog.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_watchdog.c</span>
<span class="p_chunk">@@ -1163,10 +1163,11 @@</span> <span class="p_context"> static int wdog_reboot_handler(struct notifier_block *this,</span>
 			ipmi_watchdog_state = WDOG_TIMEOUT_NONE;
 			ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
 		} else if (ipmi_watchdog_state != WDOG_TIMEOUT_NONE) {
<span class="p_del">-			/* Set a long timer to let the reboot happens, but</span>
<span class="p_del">-			   reboot if it hangs, but only if the watchdog</span>
<span class="p_add">+			/* Set a long timer to let the reboot happen or</span>
<span class="p_add">+			   reset if it hangs, but only if the watchdog</span>
 			   timer was already running. */
<span class="p_del">-			timeout = 120;</span>
<span class="p_add">+			if (timeout &lt; 120)</span>
<span class="p_add">+				timeout = 120;</span>
 			pretimeout = 0;
 			ipmi_watchdog_state = WDOG_TIMEOUT_RESET;
 			ipmi_set_timeout(IPMI_SET_TIMEOUT_NO_HB);
<span class="p_header">diff --git a/drivers/crypto/Kconfig b/drivers/crypto/Kconfig</span>
<span class="p_header">index fb1e60f5002e..778fc1bcccee 100644</span>
<span class="p_header">--- a/drivers/crypto/Kconfig</span>
<span class="p_header">+++ b/drivers/crypto/Kconfig</span>
<span class="p_chunk">@@ -629,7 +629,7 @@</span> <span class="p_context"> source &quot;drivers/crypto/virtio/Kconfig&quot;</span>
 config CRYPTO_DEV_BCM_SPU
 	tristate &quot;Broadcom symmetric crypto/hash acceleration support&quot;
 	depends on ARCH_BCM_IPROC
<span class="p_del">-	depends on BCM_PDC_MBOX</span>
<span class="p_add">+	depends on MAILBOX</span>
 	default m
 	select CRYPTO_DES
 	select CRYPTO_MD5
<span class="p_header">diff --git a/drivers/crypto/bcm/spu2.c b/drivers/crypto/bcm/spu2.c</span>
<span class="p_header">index ef04c9748317..bf7ac621c591 100644</span>
<span class="p_header">--- a/drivers/crypto/bcm/spu2.c</span>
<span class="p_header">+++ b/drivers/crypto/bcm/spu2.c</span>
<span class="p_chunk">@@ -302,6 +302,7 @@</span> <span class="p_context"> spu2_hash_xlate(enum hash_alg hash_alg, enum hash_mode hash_mode,</span>
 		break;
 	case HASH_ALG_SHA3_512:
 		*spu2_type = SPU2_HASH_TYPE_SHA3_512;
<span class="p_add">+		break;</span>
 	case HASH_ALG_LAST:
 	default:
 		err = -EINVAL;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 9106ea32b048..881df8843e66 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -9085,6 +9085,13 @@</span> <span class="p_context"> static bool haswell_get_pipe_config(struct intel_crtc *crtc,</span>
 	u64 power_domain_mask;
 	bool active;
 
<span class="p_add">+	if (INTEL_GEN(dev_priv) &gt;= 9) {</span>
<span class="p_add">+		intel_crtc_init_scalers(crtc, pipe_config);</span>
<span class="p_add">+</span>
<span class="p_add">+		pipe_config-&gt;scaler_state.scaler_id = -1;</span>
<span class="p_add">+		pipe_config-&gt;scaler_state.scaler_users &amp;= ~(1 &lt;&lt; SKL_CRTC_INDEX);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	power_domain = POWER_DOMAIN_PIPE(crtc-&gt;pipe);
 	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))
 		return false;
<span class="p_chunk">@@ -9113,13 +9120,6 @@</span> <span class="p_context"> static bool haswell_get_pipe_config(struct intel_crtc *crtc,</span>
 	pipe_config-&gt;gamma_mode =
 		I915_READ(GAMMA_MODE(crtc-&gt;pipe)) &amp; GAMMA_MODE_MODE_MASK;
 
<span class="p_del">-	if (INTEL_GEN(dev_priv) &gt;= 9) {</span>
<span class="p_del">-		intel_crtc_init_scalers(crtc, pipe_config);</span>
<span class="p_del">-</span>
<span class="p_del">-		pipe_config-&gt;scaler_state.scaler_id = -1;</span>
<span class="p_del">-		pipe_config-&gt;scaler_state.scaler_users &amp;= ~(1 &lt;&lt; SKL_CRTC_INDEX);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	power_domain = POWER_DOMAIN_PIPE_PANEL_FITTER(crtc-&gt;pipe);
 	if (intel_display_power_get_if_enabled(dev_priv, power_domain)) {
 		power_domain_mask |= BIT_ULL(power_domain);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h</span>
<span class="p_header">index 1e1de6bfe85a..5893be9788d3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/disp/nv50.h</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> struct nv50_disp {</span>
 		u8 type[3];
 	} pior;
 
<span class="p_del">-	struct nv50_disp_chan *chan[17];</span>
<span class="p_add">+	struct nv50_disp_chan *chan[21];</span>
 };
 
 int nv50_disp_root_scanoutpos(NV50_DISP_MTHD_V0);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c</span>
<span class="p_header">index c794b2c2d21e..6d8f21290aa2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/subdev/bar/gf100.c</span>
<span class="p_chunk">@@ -129,7 +129,7 @@</span> <span class="p_context"> gf100_bar_init(struct nvkm_bar *base)</span>
 
 	if (bar-&gt;bar[0].mem) {
 		addr = nvkm_memory_addr(bar-&gt;bar[0].mem) &gt;&gt; 12;
<span class="p_del">-		nvkm_wr32(device, 0x001714, 0xc0000000 | addr);</span>
<span class="p_add">+		nvkm_wr32(device, 0x001714, 0x80000000 | addr);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index c7b53d987f06..fefb9d995d2c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -519,7 +519,7 @@</span> <span class="p_context"> static int vmw_cmd_invalid(struct vmw_private *dev_priv,</span>
 			   struct vmw_sw_context *sw_context,
 			   SVGA3dCmdHeader *header)
 {
<span class="p_del">-	return capable(CAP_SYS_ADMIN) ? : -EINVAL;</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int vmw_cmd_ok(struct vmw_private *dev_priv,
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c</span>
<span class="p_header">index 50be1f034f9e..5284e8d2f7ba 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_stdu.c</span>
<span class="p_chunk">@@ -1640,8 +1640,8 @@</span> <span class="p_context"> int vmw_kms_stdu_init_display(struct vmw_private *dev_priv)</span>
 		 * something arbitrarily large and we will reject any layout
 		 * that doesn&#39;t fit prim_bb_mem later
 		 */
<span class="p_del">-		dev-&gt;mode_config.max_width = 16384;</span>
<span class="p_del">-		dev-&gt;mode_config.max_height = 16384;</span>
<span class="p_add">+		dev-&gt;mode_config.max_width = 8192;</span>
<span class="p_add">+		dev-&gt;mode_config.max_height = 8192;</span>
 	}
 
 	vmw_kms_create_implicit_placement_property(dev_priv, false);
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_common.c b/drivers/isdn/i4l/isdn_common.c</span>
<span class="p_header">index 9b856e1890d1..e4c43a17b333 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_common.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_common.c</span>
<span class="p_chunk">@@ -1379,6 +1379,7 @@</span> <span class="p_context"> isdn_ioctl(struct file *file, uint cmd, ulong arg)</span>
 			if (arg) {
 				if (copy_from_user(bname, argp, sizeof(bname) - 1))
 					return -EFAULT;
<span class="p_add">+				bname[sizeof(bname)-1] = 0;</span>
 			} else
 				return -EINVAL;
 			ret = mutex_lock_interruptible(&amp;dev-&gt;mtx);
<span class="p_header">diff --git a/drivers/isdn/i4l/isdn_net.c b/drivers/isdn/i4l/isdn_net.c</span>
<span class="p_header">index c151c6daa67e..f63a110b7bcb 100644</span>
<span class="p_header">--- a/drivers/isdn/i4l/isdn_net.c</span>
<span class="p_header">+++ b/drivers/isdn/i4l/isdn_net.c</span>
<span class="p_chunk">@@ -2611,10 +2611,9 @@</span> <span class="p_context"> isdn_net_newslave(char *parm)</span>
 	char newname[10];
 
 	if (p) {
<span class="p_del">-		/* Slave-Name MUST not be empty */</span>
<span class="p_del">-		if (!strlen(p + 1))</span>
<span class="p_add">+		/* Slave-Name MUST not be empty or overflow &#39;newname&#39; */</span>
<span class="p_add">+		if (strscpy(newname, p + 1, sizeof(newname)) &lt;= 0)</span>
 			return NULL;
<span class="p_del">-		strcpy(newname, p + 1);</span>
 		*p = 0;
 		/* Master must already exist */
 		if (!(n = isdn_net_findif(parm)))
<span class="p_header">diff --git a/drivers/md/dm-integrity.c b/drivers/md/dm-integrity.c</span>
<span class="p_header">index 93b181088168..b68e21c25a17 100644</span>
<span class="p_header">--- a/drivers/md/dm-integrity.c</span>
<span class="p_header">+++ b/drivers/md/dm-integrity.c</span>
<span class="p_chunk">@@ -1587,16 +1587,18 @@</span> <span class="p_context"> static void dm_integrity_map_continue(struct dm_integrity_io *dio, bool from_map</span>
 	if (likely(ic-&gt;mode == &#39;J&#39;)) {
 		if (dio-&gt;write) {
 			unsigned next_entry, i, pos;
<span class="p_del">-			unsigned ws, we;</span>
<span class="p_add">+			unsigned ws, we, range_sectors;</span>
 
<span class="p_del">-			dio-&gt;range.n_sectors = min(dio-&gt;range.n_sectors, ic-&gt;free_sectors);</span>
<span class="p_add">+			dio-&gt;range.n_sectors = min(dio-&gt;range.n_sectors,</span>
<span class="p_add">+						   ic-&gt;free_sectors &lt;&lt; ic-&gt;sb-&gt;log2_sectors_per_block);</span>
 			if (unlikely(!dio-&gt;range.n_sectors))
 				goto sleep;
<span class="p_del">-			ic-&gt;free_sectors -= dio-&gt;range.n_sectors;</span>
<span class="p_add">+			range_sectors = dio-&gt;range.n_sectors &gt;&gt; ic-&gt;sb-&gt;log2_sectors_per_block;</span>
<span class="p_add">+			ic-&gt;free_sectors -= range_sectors;</span>
 			journal_section = ic-&gt;free_section;
 			journal_entry = ic-&gt;free_section_entry;
 
<span class="p_del">-			next_entry = ic-&gt;free_section_entry + dio-&gt;range.n_sectors;</span>
<span class="p_add">+			next_entry = ic-&gt;free_section_entry + range_sectors;</span>
 			ic-&gt;free_section_entry = next_entry % ic-&gt;journal_section_entries;
 			ic-&gt;free_section += next_entry / ic-&gt;journal_section_entries;
 			ic-&gt;n_uncommitted_sections += next_entry / ic-&gt;journal_section_entries;
<span class="p_chunk">@@ -3019,6 +3021,11 @@</span> <span class="p_context"> static int dm_integrity_ctr(struct dm_target *ti, unsigned argc, char **argv)</span>
 		ti-&gt;error = &quot;Block size doesn&#39;t match the information in superblock&quot;;
 		goto bad;
 	}
<span class="p_add">+	if (!le32_to_cpu(ic-&gt;sb-&gt;journal_sections)) {</span>
<span class="p_add">+		r = -EINVAL;</span>
<span class="p_add">+		ti-&gt;error = &quot;Corrupted superblock, journal_sections is 0&quot;;</span>
<span class="p_add">+		goto bad;</span>
<span class="p_add">+	}</span>
 	/* make sure that ti-&gt;max_io_len doesn&#39;t overflow */
 	if (ic-&gt;sb-&gt;log2_interleave_sectors &lt; MIN_LOG2_INTERLEAVE_SECTORS ||
 	    ic-&gt;sb-&gt;log2_interleave_sectors &gt; MAX_LOG2_INTERLEAVE_SECTORS) {
<span class="p_header">diff --git a/drivers/md/md.h b/drivers/md/md.h</span>
<span class="p_header">index 63d342d560b8..33611a91b1d9 100644</span>
<span class="p_header">--- a/drivers/md/md.h</span>
<span class="p_header">+++ b/drivers/md/md.h</span>
<span class="p_chunk">@@ -733,7 +733,6 @@</span> <span class="p_context"> static inline void mddev_check_write_zeroes(struct mddev *mddev, struct bio *bio</span>
 
 /* for managing resync I/O pages */
 struct resync_pages {
<span class="p_del">-	unsigned	idx;	/* for get/put page from the pool */</span>
 	void		*raid_bio;
 	struct page	*pages[RESYNC_PAGES];
 };
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 7866563338fa..5de4b3d04eb5 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -170,7 +170,6 @@</span> <span class="p_context"> static void * r1buf_pool_alloc(gfp_t gfp_flags, void *data)</span>
 			resync_get_all_pages(rp);
 		}
 
<span class="p_del">-		rp-&gt;idx = 0;</span>
 		rp-&gt;raid_bio = r1_bio;
 		bio-&gt;bi_private = rp;
 	}
<span class="p_chunk">@@ -492,10 +491,6 @@</span> <span class="p_context"> static void raid1_end_write_request(struct bio *bio)</span>
 	}
 
 	if (behind) {
<span class="p_del">-		/* we release behind master bio when all write are done */</span>
<span class="p_del">-		if (r1_bio-&gt;behind_master_bio == bio)</span>
<span class="p_del">-			to_put = NULL;</span>
<span class="p_del">-</span>
 		if (test_bit(WriteMostly, &amp;rdev-&gt;flags))
 			atomic_dec(&amp;r1_bio-&gt;behind_remaining);
 
<span class="p_chunk">@@ -1088,7 +1083,7 @@</span> <span class="p_context"> static void unfreeze_array(struct r1conf *conf)</span>
 	wake_up(&amp;conf-&gt;wait_barrier);
 }
 
<span class="p_del">-static struct bio *alloc_behind_master_bio(struct r1bio *r1_bio,</span>
<span class="p_add">+static void alloc_behind_master_bio(struct r1bio *r1_bio,</span>
 					   struct bio *bio)
 {
 	int size = bio-&gt;bi_iter.bi_size;
<span class="p_chunk">@@ -1098,11 +1093,13 @@</span> <span class="p_context"> static struct bio *alloc_behind_master_bio(struct r1bio *r1_bio,</span>
 
 	behind_bio = bio_alloc_mddev(GFP_NOIO, vcnt, r1_bio-&gt;mddev);
 	if (!behind_bio)
<span class="p_del">-		goto fail;</span>
<span class="p_add">+		return;</span>
 
 	/* discard op, we don&#39;t support writezero/writesame yet */
<span class="p_del">-	if (!bio_has_data(bio))</span>
<span class="p_add">+	if (!bio_has_data(bio)) {</span>
<span class="p_add">+		behind_bio-&gt;bi_iter.bi_size = size;</span>
 		goto skip_copy;
<span class="p_add">+	}</span>
 
 	while (i &lt; vcnt &amp;&amp; size) {
 		struct page *page;
<span class="p_chunk">@@ -1123,14 +1120,13 @@</span> <span class="p_context"> static struct bio *alloc_behind_master_bio(struct r1bio *r1_bio,</span>
 	r1_bio-&gt;behind_master_bio = behind_bio;;
 	set_bit(R1BIO_BehindIO, &amp;r1_bio-&gt;state);
 
<span class="p_del">-	return behind_bio;</span>
<span class="p_add">+	return;</span>
 
 free_pages:
 	pr_debug(&quot;%dB behind alloc failed, doing sync I/O\n&quot;,
 		 bio-&gt;bi_iter.bi_size);
 	bio_free_pages(behind_bio);
<span class="p_del">-fail:</span>
<span class="p_del">-	return behind_bio;</span>
<span class="p_add">+	bio_put(behind_bio);</span>
 }
 
 struct raid1_plug_cb {
<span class="p_chunk">@@ -1483,7 +1479,7 @@</span> <span class="p_context"> static void raid1_write_request(struct mddev *mddev, struct bio *bio,</span>
 			    (atomic_read(&amp;bitmap-&gt;behind_writes)
 			     &lt; mddev-&gt;bitmap_info.max_write_behind) &amp;&amp;
 			    !waitqueue_active(&amp;bitmap-&gt;behind_wait)) {
<span class="p_del">-				mbio = alloc_behind_master_bio(r1_bio, bio);</span>
<span class="p_add">+				alloc_behind_master_bio(r1_bio, bio);</span>
 			}
 
 			bitmap_startwrite(bitmap, r1_bio-&gt;sector,
<span class="p_chunk">@@ -1493,14 +1489,11 @@</span> <span class="p_context"> static void raid1_write_request(struct mddev *mddev, struct bio *bio,</span>
 			first_clone = 0;
 		}
 
<span class="p_del">-		if (!mbio) {</span>
<span class="p_del">-			if (r1_bio-&gt;behind_master_bio)</span>
<span class="p_del">-				mbio = bio_clone_fast(r1_bio-&gt;behind_master_bio,</span>
<span class="p_del">-						      GFP_NOIO,</span>
<span class="p_del">-						      mddev-&gt;bio_set);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				mbio = bio_clone_fast(bio, GFP_NOIO, mddev-&gt;bio_set);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (r1_bio-&gt;behind_master_bio)</span>
<span class="p_add">+			mbio = bio_clone_fast(r1_bio-&gt;behind_master_bio,</span>
<span class="p_add">+					      GFP_NOIO, mddev-&gt;bio_set);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			mbio = bio_clone_fast(bio, GFP_NOIO, mddev-&gt;bio_set);</span>
 
 		if (r1_bio-&gt;behind_master_bio) {
 			if (test_bit(WriteMostly, &amp;conf-&gt;mirrors[i].rdev-&gt;flags))
<span class="p_chunk">@@ -2368,8 +2361,6 @@</span> <span class="p_context"> static int narrow_write_error(struct r1bio *r1_bio, int i)</span>
 			wbio = bio_clone_fast(r1_bio-&gt;behind_master_bio,
 					      GFP_NOIO,
 					      mddev-&gt;bio_set);
<span class="p_del">-			/* We really need a _all clone */</span>
<span class="p_del">-			wbio-&gt;bi_iter = (struct bvec_iter){ 0 };</span>
 		} else {
 			wbio = bio_clone_fast(r1_bio-&gt;master_bio, GFP_NOIO,
 					      mddev-&gt;bio_set);
<span class="p_chunk">@@ -2621,6 +2612,7 @@</span> <span class="p_context"> static sector_t raid1_sync_request(struct mddev *mddev, sector_t sector_nr,</span>
 	int good_sectors = RESYNC_SECTORS;
 	int min_bad = 0; /* number of sectors that are bad in all devices */
 	int idx = sector_to_idx(sector_nr);
<span class="p_add">+	int page_idx = 0;</span>
 
 	if (!conf-&gt;r1buf_pool)
 		if (init_resync(conf))
<span class="p_chunk">@@ -2848,7 +2840,7 @@</span> <span class="p_context"> static sector_t raid1_sync_request(struct mddev *mddev, sector_t sector_nr,</span>
 			bio = r1_bio-&gt;bios[i];
 			rp = get_resync_pages(bio);
 			if (bio-&gt;bi_end_io) {
<span class="p_del">-				page = resync_fetch_page(rp, rp-&gt;idx++);</span>
<span class="p_add">+				page = resync_fetch_page(rp, page_idx);</span>
 
 				/*
 				 * won&#39;t fail because the vec table is big
<span class="p_chunk">@@ -2860,7 +2852,7 @@</span> <span class="p_context"> static sector_t raid1_sync_request(struct mddev *mddev, sector_t sector_nr,</span>
 		nr_sectors += len&gt;&gt;9;
 		sector_nr += len&gt;&gt;9;
 		sync_blocks -= (len&gt;&gt;9);
<span class="p_del">-	} while (get_resync_pages(r1_bio-&gt;bios[disk]-&gt;bi_private)-&gt;idx &lt; RESYNC_PAGES);</span>
<span class="p_add">+	} while (++page_idx &lt; RESYNC_PAGES);</span>
 
 	r1_bio-&gt;sectors = nr_sectors;
 
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 52acffa7a06a..bfc6db236348 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -221,7 +221,6 @@</span> <span class="p_context"> static void * r10buf_pool_alloc(gfp_t gfp_flags, void *data)</span>
 			resync_get_all_pages(rp);
 		}
 
<span class="p_del">-		rp-&gt;idx = 0;</span>
 		rp-&gt;raid_bio = r10_bio;
 		bio-&gt;bi_private = rp;
 		if (rbio) {
<span class="p_chunk">@@ -2853,6 +2852,7 @@</span> <span class="p_context"> static sector_t raid10_sync_request(struct mddev *mddev, sector_t sector_nr,</span>
 	sector_t sectors_skipped = 0;
 	int chunks_skipped = 0;
 	sector_t chunk_mask = conf-&gt;geo.chunk_mask;
<span class="p_add">+	int page_idx = 0;</span>
 
 	if (!conf-&gt;r10buf_pool)
 		if (init_resync(conf))
<span class="p_chunk">@@ -3355,7 +3355,7 @@</span> <span class="p_context"> static sector_t raid10_sync_request(struct mddev *mddev, sector_t sector_nr,</span>
 			break;
 		for (bio= biolist ; bio ; bio=bio-&gt;bi_next) {
 			struct resync_pages *rp = get_resync_pages(bio);
<span class="p_del">-			page = resync_fetch_page(rp, rp-&gt;idx++);</span>
<span class="p_add">+			page = resync_fetch_page(rp, page_idx);</span>
 			/*
 			 * won&#39;t fail because the vec table is big enough
 			 * to hold all these pages
<span class="p_chunk">@@ -3364,7 +3364,7 @@</span> <span class="p_context"> static sector_t raid10_sync_request(struct mddev *mddev, sector_t sector_nr,</span>
 		}
 		nr_sectors += len&gt;&gt;9;
 		sector_nr += len&gt;&gt;9;
<span class="p_del">-	} while (get_resync_pages(biolist)-&gt;idx &lt; RESYNC_PAGES);</span>
<span class="p_add">+	} while (++page_idx &lt; RESYNC_PAGES);</span>
 	r10_bio-&gt;sectors = nr_sectors;
 
 	while (biolist) {
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index d524daddc630..e92dd2dc4b5a 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -6237,6 +6237,8 @@</span> <span class="p_context"> static void raid5_do_work(struct work_struct *work)</span>
 	pr_debug(&quot;%d stripes handled\n&quot;, handled);
 
 	spin_unlock_irq(&amp;conf-&gt;device_lock);
<span class="p_add">+</span>
<span class="p_add">+	async_tx_issue_pending_all();</span>
 	blk_finish_plug(&amp;plug);
 
 	pr_debug(&quot;--- raid5worker inactive\n&quot;);
<span class="p_header">diff --git a/drivers/mmc/host/sunxi-mmc.c b/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_header">index d6fa2214aaae..0fb4e4c119e1 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sunxi-mmc.c</span>
<span class="p_chunk">@@ -793,8 +793,12 @@</span> <span class="p_context"> static int sunxi_mmc_clk_set_rate(struct sunxi_mmc_host *host,</span>
 	}
 	mmc_writel(host, REG_CLKCR, rval);
 
<span class="p_del">-	if (host-&gt;cfg-&gt;needs_new_timings)</span>
<span class="p_del">-		mmc_writel(host, REG_SD_NTSR, SDXC_2X_TIMING_MODE);</span>
<span class="p_add">+	if (host-&gt;cfg-&gt;needs_new_timings) {</span>
<span class="p_add">+		/* Don&#39;t touch the delay bits */</span>
<span class="p_add">+		rval = mmc_readl(host, REG_SD_NTSR);</span>
<span class="p_add">+		rval |= SDXC_2X_TIMING_MODE;</span>
<span class="p_add">+		mmc_writel(host, REG_SD_NTSR, rval);</span>
<span class="p_add">+	}</span>
 
 	ret = sunxi_mmc_clk_set_phase(host, ios, rate);
 	if (ret)
<span class="p_header">diff --git a/drivers/mmc/host/tmio_mmc_pio.c b/drivers/mmc/host/tmio_mmc_pio.c</span>
<span class="p_header">index a2d92f10501b..a3d20e39e5b5 100644</span>
<span class="p_header">--- a/drivers/mmc/host/tmio_mmc_pio.c</span>
<span class="p_header">+++ b/drivers/mmc/host/tmio_mmc_pio.c</span>
<span class="p_chunk">@@ -404,30 +404,29 @@</span> <span class="p_context"> static void tmio_mmc_transfer_data(struct tmio_mmc_host *host,</span>
 	 * Transfer the data
 	 */
 	if (host-&gt;pdata-&gt;flags &amp; TMIO_MMC_32BIT_DATA_PORT) {
<span class="p_del">-		u8 data[4] = { };</span>
<span class="p_add">+		u32 data = 0;</span>
<span class="p_add">+		u32 *buf32 = (u32 *)buf;</span>
 
 		if (is_read)
<span class="p_del">-			sd_ctrl_read32_rep(host, CTL_SD_DATA_PORT, (u32 *)buf,</span>
<span class="p_add">+			sd_ctrl_read32_rep(host, CTL_SD_DATA_PORT, buf32,</span>
 					   count &gt;&gt; 2);
 		else
<span class="p_del">-			sd_ctrl_write32_rep(host, CTL_SD_DATA_PORT, (u32 *)buf,</span>
<span class="p_add">+			sd_ctrl_write32_rep(host, CTL_SD_DATA_PORT, buf32,</span>
 					    count &gt;&gt; 2);
 
 		/* if count was multiple of 4 */
 		if (!(count &amp; 0x3))
 			return;
 
<span class="p_del">-		buf8 = (u8 *)(buf + (count &gt;&gt; 2));</span>
<span class="p_add">+		buf32 += count &gt;&gt; 2;</span>
 		count %= 4;
 
 		if (is_read) {
<span class="p_del">-			sd_ctrl_read32_rep(host, CTL_SD_DATA_PORT,</span>
<span class="p_del">-					   (u32 *)data, 1);</span>
<span class="p_del">-			memcpy(buf8, data, count);</span>
<span class="p_add">+			sd_ctrl_read32_rep(host, CTL_SD_DATA_PORT, &amp;data, 1);</span>
<span class="p_add">+			memcpy(buf32, &amp;data, count);</span>
 		} else {
<span class="p_del">-			memcpy(data, buf8, count);</span>
<span class="p_del">-			sd_ctrl_write32_rep(host, CTL_SD_DATA_PORT,</span>
<span class="p_del">-					    (u32 *)data, 1);</span>
<span class="p_add">+			memcpy(&amp;data, buf32, count);</span>
<span class="p_add">+			sd_ctrl_write32_rep(host, CTL_SD_DATA_PORT, &amp;data, 1);</span>
 		}
 
 		return;
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 1161390f4935..736754c5ab63 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -277,6 +277,33 @@</span> <span class="p_context"> static inline int dname_external(const struct dentry *dentry)</span>
 	return dentry-&gt;d_name.name != dentry-&gt;d_iname;
 }
 
<span class="p_add">+void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spin_lock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+	if (unlikely(dname_external(dentry))) {</span>
<span class="p_add">+		struct external_name *p = external_name(dentry);</span>
<span class="p_add">+		atomic_inc(&amp;p-&gt;u.count);</span>
<span class="p_add">+		spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+		name-&gt;name = p-&gt;name;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		memcpy(name-&gt;inline_name, dentry-&gt;d_iname, DNAME_INLINE_LEN);</span>
<span class="p_add">+		spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+		name-&gt;name = name-&gt;inline_name;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(take_dentry_name_snapshot);</span>
<span class="p_add">+</span>
<span class="p_add">+void release_dentry_name_snapshot(struct name_snapshot *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(name-&gt;name != name-&gt;inline_name)) {</span>
<span class="p_add">+		struct external_name *p;</span>
<span class="p_add">+		p = container_of(name-&gt;name, struct external_name, name[0]);</span>
<span class="p_add">+		if (unlikely(atomic_dec_and_test(&amp;p-&gt;u.count)))</span>
<span class="p_add">+			kfree_rcu(p, u.head);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(release_dentry_name_snapshot);</span>
<span class="p_add">+</span>
 static inline void __d_set_inode_and_type(struct dentry *dentry,
 					  struct inode *inode,
 					  unsigned type_flags)
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index e892ae7d89f8..acd3be2cc691 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -766,7 +766,7 @@</span> <span class="p_context"> struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,</span>
 {
 	int error;
 	struct dentry *dentry = NULL, *trap;
<span class="p_del">-	const char *old_name;</span>
<span class="p_add">+	struct name_snapshot old_name;</span>
 
 	trap = lock_rename(new_dir, old_dir);
 	/* Source or destination directories don&#39;t exist? */
<span class="p_chunk">@@ -781,19 +781,19 @@</span> <span class="p_context"> struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,</span>
 	if (IS_ERR(dentry) || dentry == trap || d_really_is_positive(dentry))
 		goto exit;
 
<span class="p_del">-	old_name = fsnotify_oldname_init(old_dentry-&gt;d_name.name);</span>
<span class="p_add">+	take_dentry_name_snapshot(&amp;old_name, old_dentry);</span>
 
 	error = simple_rename(d_inode(old_dir), old_dentry, d_inode(new_dir),
 			      dentry, 0);
 	if (error) {
<span class="p_del">-		fsnotify_oldname_free(old_name);</span>
<span class="p_add">+		release_dentry_name_snapshot(&amp;old_name);</span>
 		goto exit;
 	}
 	d_move(old_dentry, dentry);
<span class="p_del">-	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name,</span>
<span class="p_add">+	fsnotify_move(d_inode(old_dir), d_inode(new_dir), old_name.name,</span>
 		d_is_dir(old_dentry),
 		NULL, old_dentry);
<span class="p_del">-	fsnotify_oldname_free(old_name);</span>
<span class="p_add">+	release_dentry_name_snapshot(&amp;old_name);</span>
 	unlock_rename(new_dir, old_dir);
 	dput(dentry);
 	return old_dentry;
<span class="p_header">diff --git a/fs/jfs/acl.c b/fs/jfs/acl.c</span>
<span class="p_header">index 7bc186f4ed4d..1be45c8d460d 100644</span>
<span class="p_header">--- a/fs/jfs/acl.c</span>
<span class="p_header">+++ b/fs/jfs/acl.c</span>
<span class="p_chunk">@@ -77,13 +77,6 @@</span> <span class="p_context"> static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,</span>
 	switch (type) {
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
<span class="p_del">-		if (acl) {</span>
<span class="p_del">-			rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_del">-			if (rc)</span>
<span class="p_del">-				return rc;</span>
<span class="p_del">-			inode-&gt;i_ctime = current_time(inode);</span>
<span class="p_del">-			mark_inode_dirty(inode);</span>
<span class="p_del">-		}</span>
 		break;
 	case ACL_TYPE_DEFAULT:
 		ea_name = XATTR_NAME_POSIX_ACL_DEFAULT;
<span class="p_chunk">@@ -118,9 +111,17 @@</span> <span class="p_context"> int jfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 
 	tid = txBegin(inode-&gt;i_sb, 0);
 	mutex_lock(&amp;JFS_IP(inode)-&gt;commit_mutex);
<span class="p_add">+	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {</span>
<span class="p_add">+		rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (rc)</span>
<span class="p_add">+			goto end_tx;</span>
<span class="p_add">+		inode-&gt;i_ctime = current_time(inode);</span>
<span class="p_add">+		mark_inode_dirty(inode);</span>
<span class="p_add">+	}</span>
 	rc = __jfs_set_acl(tid, inode, type, acl);
 	if (!rc)
 		rc = txCommit(tid, 1, &amp;inode, 0);
<span class="p_add">+end_tx:</span>
 	txEnd(tid);
 	mutex_unlock(&amp;JFS_IP(inode)-&gt;commit_mutex);
 	return rc;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 6571a5f5112e..281c1f7fa983 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -4362,11 +4362,11 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 {
 	int error;
 	bool is_dir = d_is_dir(old_dentry);
<span class="p_del">-	const unsigned char *old_name;</span>
 	struct inode *source = old_dentry-&gt;d_inode;
 	struct inode *target = new_dentry-&gt;d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir-&gt;i_sb-&gt;s_max_links;
<span class="p_add">+	struct name_snapshot old_name;</span>
 
 	if (source == target)
 		return 0;
<span class="p_chunk">@@ -4413,7 +4413,7 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 	if (error)
 		return error;
 
<span class="p_del">-	old_name = fsnotify_oldname_init(old_dentry-&gt;d_name.name);</span>
<span class="p_add">+	take_dentry_name_snapshot(&amp;old_name, old_dentry);</span>
 	dget(new_dentry);
 	if (!is_dir || (flags &amp; RENAME_EXCHANGE))
 		lock_two_nondirectories(source, target);
<span class="p_chunk">@@ -4468,14 +4468,14 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		inode_unlock(target);
 	dput(new_dentry);
 	if (!error) {
<span class="p_del">-		fsnotify_move(old_dir, new_dir, old_name, is_dir,</span>
<span class="p_add">+		fsnotify_move(old_dir, new_dir, old_name.name, is_dir,</span>
 			      !(flags &amp; RENAME_EXCHANGE) ? target : NULL, old_dentry);
 		if (flags &amp; RENAME_EXCHANGE) {
 			fsnotify_move(new_dir, old_dir, old_dentry-&gt;d_name.name,
 				      new_is_dir, NULL, new_dentry);
 		}
 	}
<span class="p_del">-	fsnotify_oldname_free(old_name);</span>
<span class="p_add">+	release_dentry_name_snapshot(&amp;old_name);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/fs/nfs/file.c b/fs/nfs/file.c</span>
<span class="p_header">index 5713eb32a45e..d264363559db 100644</span>
<span class="p_header">--- a/fs/nfs/file.c</span>
<span class="p_header">+++ b/fs/nfs/file.c</span>
<span class="p_chunk">@@ -750,7 +750,7 @@</span> <span class="p_context"> do_setlk(struct file *filp, int cmd, struct file_lock *fl, int is_local)</span>
 	 */
 	nfs_sync_mapping(filp-&gt;f_mapping);
 	if (!NFS_PROTO(inode)-&gt;have_delegation(inode, FMODE_READ))
<span class="p_del">-		nfs_zap_mapping(inode, filp-&gt;f_mapping);</span>
<span class="p_add">+		nfs_zap_caches(inode);</span>
 out:
 	return status;
 }
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index dbfa18900e25..f5a7faac39a7 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -6441,7 +6441,7 @@</span> <span class="p_context"> nfs4_retry_setlk(struct nfs4_state *state, int cmd, struct file_lock *request)</span>
 		set_current_state(TASK_INTERRUPTIBLE);
 		spin_unlock_irqrestore(&amp;q-&gt;lock, flags);
 
<span class="p_del">-		freezable_schedule_timeout_interruptible(NFS4_LOCK_MAXTIMEOUT);</span>
<span class="p_add">+		freezable_schedule_timeout(NFS4_LOCK_MAXTIMEOUT);</span>
 	}
 
 	finish_wait(q, &amp;wait);
<span class="p_header">diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.c</span>
<span class="p_header">index 01a9f0f007d4..0c4583b61717 100644</span>
<span class="p_header">--- a/fs/notify/fsnotify.c</span>
<span class="p_header">+++ b/fs/notify/fsnotify.c</span>
<span class="p_chunk">@@ -161,16 +161,20 @@</span> <span class="p_context"> int __fsnotify_parent(const struct path *path, struct dentry *dentry, __u32 mask</span>
 	if (unlikely(!fsnotify_inode_watches_children(p_inode)))
 		__fsnotify_update_child_dentry_flags(p_inode);
 	else if (p_inode-&gt;i_fsnotify_mask &amp; mask) {
<span class="p_add">+		struct name_snapshot name;</span>
<span class="p_add">+</span>
 		/* we are notifying a parent so come up with the new mask which
 		 * specifies these are events which came from a child. */
 		mask |= FS_EVENT_ON_CHILD;
 
<span class="p_add">+		take_dentry_name_snapshot(&amp;name, dentry);</span>
 		if (path)
 			ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,
<span class="p_del">-				       dentry-&gt;d_name.name, 0);</span>
<span class="p_add">+				       name.name, 0);</span>
 		else
 			ret = fsnotify(p_inode, mask, dentry-&gt;d_inode, FSNOTIFY_EVENT_INODE,
<span class="p_del">-				       dentry-&gt;d_name.name, 0);</span>
<span class="p_add">+				       name.name, 0);</span>
<span class="p_add">+		release_dentry_name_snapshot(&amp;name);</span>
 	}
 
 	dput(parent);
<span class="p_header">diff --git a/include/linux/dcache.h b/include/linux/dcache.h</span>
<span class="p_header">index d2e38dc6172c..025727bf6797 100644</span>
<span class="p_header">--- a/include/linux/dcache.h</span>
<span class="p_header">+++ b/include/linux/dcache.h</span>
<span class="p_chunk">@@ -591,5 +591,11 @@</span> <span class="p_context"> static inline struct inode *d_real_inode(const struct dentry *dentry)</span>
 	return d_backing_inode(d_real((struct dentry *) dentry, NULL, 0));
 }
 
<span class="p_add">+struct name_snapshot {</span>
<span class="p_add">+	const char *name;</span>
<span class="p_add">+	char inline_name[DNAME_INLINE_LEN];</span>
<span class="p_add">+};</span>
<span class="p_add">+void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);</span>
<span class="p_add">+void release_dentry_name_snapshot(struct name_snapshot *);</span>
 
 #endif	/* __LINUX_DCACHE_H */
<span class="p_header">diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h</span>
<span class="p_header">index b43d3f5bd9ea..b78aa7ac77ce 100644</span>
<span class="p_header">--- a/include/linux/fsnotify.h</span>
<span class="p_header">+++ b/include/linux/fsnotify.h</span>
<span class="p_chunk">@@ -293,35 +293,4 @@</span> <span class="p_context"> static inline void fsnotify_change(struct dentry *dentry, unsigned int ia_valid)</span>
 	}
 }
 
<span class="p_del">-#if defined(CONFIG_FSNOTIFY)	/* notify helpers */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * fsnotify_oldname_init - save off the old filename before we change it</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return kstrdup(name, GFP_KERNEL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * fsnotify_oldname_free - free the name we got from fsnotify_oldname_init</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void fsnotify_oldname_free(const unsigned char *old_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	kfree(old_name);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#else	/* CONFIG_FSNOTIFY */</span>
<span class="p_del">-</span>
<span class="p_del">-static inline const char *fsnotify_oldname_init(const unsigned char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void fsnotify_oldname_free(const unsigned char *old_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#endif	/*  CONFIG_FSNOTIFY */</span>
<span class="p_del">-</span>
 #endif	/* _LINUX_FS_NOTIFY_H */
<span class="p_header">diff --git a/scripts/dtc/dtx_diff b/scripts/dtc/dtx_diff</span>
<span class="p_header">index ec47f95991a3..586cccea46ce 100755</span>
<span class="p_header">--- a/scripts/dtc/dtx_diff</span>
<span class="p_header">+++ b/scripts/dtc/dtx_diff</span>
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> fi</span>
 cpp_flags=&quot;\
 	-nostdinc                                  \
 	-I${srctree}/arch/${ARCH}/boot/dts         \
<span class="p_del">-	-I${srctree}/arch/${ARCH}/boot/dts/include \</span>
<span class="p_add">+	-I${srctree}/scripts/dtc/include-prefixes  \</span>
 	-I${srctree}/drivers/of/testcase-data      \
 	-undef -D__DTS__&quot;
 
<span class="p_header">diff --git a/sound/pci/fm801.c b/sound/pci/fm801.c</span>
<span class="p_header">index c47287d79306..a178e0d03088 100644</span>
<span class="p_header">--- a/sound/pci/fm801.c</span>
<span class="p_header">+++ b/sound/pci/fm801.c</span>
<span class="p_chunk">@@ -1235,8 +1235,6 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 		}
 	}
 
<span class="p_del">-	snd_fm801_chip_init(chip);</span>
<span class="p_del">-</span>
 	if ((chip-&gt;tea575x_tuner &amp; TUNER_ONLY) == 0) {
 		if (devm_request_irq(&amp;pci-&gt;dev, pci-&gt;irq, snd_fm801_interrupt,
 				IRQF_SHARED, KBUILD_MODNAME, chip)) {
<span class="p_chunk">@@ -1248,6 +1246,8 @@</span> <span class="p_context"> static int snd_fm801_create(struct snd_card *card,</span>
 		pci_set_master(pci);
 	}
 
<span class="p_add">+	snd_fm801_chip_init(chip);</span>
<span class="p_add">+</span>
 	if ((err = snd_device_new(card, SNDRV_DEV_LOWLEVEL, chip, &amp;ops)) &lt; 0) {
 		snd_fm801_free(chip);
 		return err;
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index 63bc894ddf5e..8c1289963c80 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -933,6 +933,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x103c, 0x8174, &quot;HP Spectre x360&quot;, CXT_FIXUP_HP_SPECTRE),
 	SND_PCI_QUIRK(0x103c, 0x8115, &quot;HP Z1 Gen3&quot;, CXT_FIXUP_HP_GATE_MIC),
 	SND_PCI_QUIRK(0x103c, 0x814f, &quot;HP ZBook 15u G3&quot;, CXT_FIXUP_MUTE_LED_GPIO),
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x822e, &quot;HP ProBook 440 G4&quot;, CXT_FIXUP_MUTE_LED_GPIO),</span>
 	SND_PCI_QUIRK(0x1043, 0x138d, &quot;Asus&quot;, CXT_FIXUP_HEADPHONE_MIC_PIN),
 	SND_PCI_QUIRK(0x152d, 0x0833, &quot;OLPC XO-1.5&quot;, CXT_FIXUP_OLPC_XO),
 	SND_PCI_QUIRK(0x17aa, 0x20f2, &quot;Lenovo T400&quot;, CXT_PINCFG_LENOVO_TP410),
<span class="p_header">diff --git a/sound/pci/hda/patch_hdmi.c b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">index 90e4ff87445e..c87ff8e5d1d5 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_hdmi.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_hdmi.c</span>
<span class="p_chunk">@@ -3757,11 +3757,15 @@</span> <span class="p_context"> HDA_CODEC_ENTRY(0x1002aa01, &quot;R6xx HDMI&quot;,	patch_atihdmi),</span>
 HDA_CODEC_ENTRY(0x10951390, &quot;SiI1390 HDMI&quot;,	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x10951392, &quot;SiI1392 HDMI&quot;,	patch_generic_hdmi),
 HDA_CODEC_ENTRY(0x17e80047, &quot;Chrontel HDMI&quot;,	patch_generic_hdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0001, &quot;MCP73 HDMI&quot;,	patch_nvhdmi_2ch),</span>
 HDA_CODEC_ENTRY(0x10de0002, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
 HDA_CODEC_ENTRY(0x10de0003, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0004, &quot;GPU 04 HDMI&quot;,	patch_nvhdmi_8ch_7x),</span>
 HDA_CODEC_ENTRY(0x10de0005, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
 HDA_CODEC_ENTRY(0x10de0006, &quot;MCP77/78 HDMI&quot;,	patch_nvhdmi_8ch_7x),
 HDA_CODEC_ENTRY(0x10de0007, &quot;MCP79/7A HDMI&quot;,	patch_nvhdmi_8ch_7x),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0008, &quot;GPU 08 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0009, &quot;GPU 09 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de000a, &quot;GPU 0a HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de000b, &quot;GPU 0b HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de000c, &quot;MCP89 HDMI&quot;,	patch_nvhdmi),
<span class="p_chunk">@@ -3788,17 +3792,40 @@</span> <span class="p_context"> HDA_CODEC_ENTRY(0x10de0041, &quot;GPU 41 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0042, &quot;GPU 42 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0043, &quot;GPU 43 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0044, &quot;GPU 44 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0045, &quot;GPU 45 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0050, &quot;GPU 50 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0051, &quot;GPU 51 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0052, &quot;GPU 52 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0060, &quot;GPU 60 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0061, &quot;GPU 61 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0062, &quot;GPU 62 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0067, &quot;MCP67 HDMI&quot;,	patch_nvhdmi_2ch),
 HDA_CODEC_ENTRY(0x10de0070, &quot;GPU 70 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0071, &quot;GPU 71 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0072, &quot;GPU 72 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0073, &quot;GPU 73 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0074, &quot;GPU 74 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0076, &quot;GPU 76 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de007b, &quot;GPU 7b HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de007c, &quot;GPU 7c HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de007d, &quot;GPU 7d HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de007e, &quot;GPU 7e HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0080, &quot;GPU 80 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0081, &quot;GPU 81 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de0082, &quot;GPU 82 HDMI/DP&quot;,	patch_nvhdmi),
 HDA_CODEC_ENTRY(0x10de0083, &quot;GPU 83 HDMI/DP&quot;,	patch_nvhdmi),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0084, &quot;GPU 84 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0090, &quot;GPU 90 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0091, &quot;GPU 91 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0092, &quot;GPU 92 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0093, &quot;GPU 93 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0094, &quot;GPU 94 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0095, &quot;GPU 95 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0097, &quot;GPU 97 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0098, &quot;GPU 98 HDMI/DP&quot;,	patch_nvhdmi),</span>
<span class="p_add">+HDA_CODEC_ENTRY(0x10de0099, &quot;GPU 99 HDMI/DP&quot;,	patch_nvhdmi),</span>
 HDA_CODEC_ENTRY(0x10de8001, &quot;MCP73 HDMI&quot;,	patch_nvhdmi_2ch),
<span class="p_add">+HDA_CODEC_ENTRY(0x10de8067, &quot;MCP67/68 HDMI&quot;,	patch_nvhdmi_2ch),</span>
 HDA_CODEC_ENTRY(0x11069f80, &quot;VX900 HDMI/DP&quot;,	patch_via_hdmi),
 HDA_CODEC_ENTRY(0x11069f81, &quot;VX900 HDMI/DP&quot;,	patch_via_hdmi),
 HDA_CODEC_ENTRY(0x11069f84, &quot;VX11 HDMI/DP&quot;,	patch_generic_hdmi),

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



