
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.19.y-ckt,stable] Linux 3.19.8-ckt1 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.19.y-ckt,stable] Linux 3.19.8-ckt1</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 29, 2015, 5:36 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1432920997-24848-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6509951/mbox/"
   >mbox</a>
|
   <a href="/patch/6509951/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6509951/">/patch/6509951/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id A0E3E9F3D1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 29 May 2015 17:37:39 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 5DB8A20835
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 29 May 2015 17:37:33 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 8B7C42082B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 29 May 2015 17:37:26 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756722AbbE2RhQ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 29 May 2015 13:37:16 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:34096 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1756603AbbE2Rgn (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 29 May 2015 13:36:43 -0400
Received: from [10.172.68.52] (helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1YyOD2-0000Ks-Fb; Fri, 29 May 2015 17:36:41 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1YyOD0-0006TO-8K; Fri, 29 May 2015 10:36:38 -0700
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.19.y-ckt stable] Linux 3.19.8-ckt1
Date: Fri, 29 May 2015 10:36:37 -0700
Message-Id: &lt;1432920997-24848-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1432920997-24848-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1432920997-24848-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 3.19
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - May 29, 2015, 5:36 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_header">index a4873e5..e30e184 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/dma/fsl-mxs-dma.txt</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> dma_apbx: dma-apbx@80024000 {</span>
 		      80 81 68 69
 		      70 71 72 73
 		      74 75 76 77&gt;;
<span class="p_del">-	interrupt-names = &quot;auart4-rx&quot;, &quot;aurat4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
<span class="p_add">+	interrupt-names = &quot;auart4-rx&quot;, &quot;auart4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
 			  &quot;saif0&quot;, &quot;saif1&quot;, &quot;i2c0&quot;, &quot;i2c1&quot;,
 			  &quot;auart0-rx&quot;, &quot;auart0-tx&quot;, &quot;auart1-rx&quot;, &quot;auart1-tx&quot;,
 			  &quot;auart2-rx&quot;, &quot;auart2-tx&quot;, &quot;auart3-rx&quot;, &quot;auart3-tx&quot;;
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 176d4fe..c7e8f40 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3717,6 +3717,8 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 					READ_CAPACITY_16 command);
 				f = NO_REPORT_OPCODES (don&#39;t use report opcodes
 					command, uas only);
<span class="p_add">+				g = MAX_SECTORS_240 (don&#39;t transfer more than</span>
<span class="p_add">+					240 sectors at a time, uas only);</span>
 				h = CAPACITY_HEURISTICS (decrease the
 					reported device capacity by one
 					sector if the number is odd);
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 110782b..8723390b6 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,8 +1,8 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 19
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_del">-NAME = Diseased Newt</span>
<span class="p_add">+EXTRAVERSION = -ckt1</span>
<span class="p_add">+NAME = Sedated Swine</span>
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute &quot;make help&quot;
<span class="p_header">diff --git a/arch/arm/boot/dts/am57xx-beagle-x15.dts b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">index 49edbda..bcc2f95 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_chunk">@@ -336,7 +336,7 @@</span> <span class="p_context"></span>
 		compatible = &quot;microchip,mcp7941x&quot;;
 		reg = &lt;0x6f&gt;;
 		interrupt-parent = &lt;&amp;gic&gt;;
<span class="p_del">-		interrupts = &lt;GIC_SPI 2 IRQ_TYPE_LEVEL_LOW&gt;;  /* IRQ_SYS_1N */</span>
<span class="p_add">+		interrupts = &lt;GIC_SPI 2 IRQ_TYPE_EDGE_RISING&gt;;  /* IRQ_SYS_1N */</span>
 
 		pinctrl-names = &quot;default&quot;;
 		pinctrl-0 = &lt;&amp;mcp79410_pins_default&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_header">index 6f6b091..101c1ec 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-openblocks-ax3-4.dts</span>
<span class="p_chunk">@@ -71,6 +71,10 @@</span> <span class="p_context"></span>
 		};
 
 		internal-regs {
<span class="p_add">+			rtc@10300 {</span>
<span class="p_add">+				/* No crystal connected to the internal RTC */</span>
<span class="p_add">+				status = &quot;disabled&quot;;</span>
<span class="p_add">+			};</span>
 			serial@12000 {
 				status = &quot;okay&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/boot/dts/imx23-olinuxino.dts b/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_header">index 7e6eef2..8204539 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx23-olinuxino.dts</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
  */
 
 /dts-v1/;
<span class="p_add">+#include &lt;dt-bindings/gpio/gpio.h&gt;</span>
 #include &quot;imx23.dtsi&quot;
 
 / {
<span class="p_chunk">@@ -93,6 +94,7 @@</span> <span class="p_context"></span>
 
 	ahb@80080000 {
 		usb0: usb@80080000 {
<span class="p_add">+			dr_mode = &quot;host&quot;;</span>
 			vbus-supply = &lt;&amp;reg_usb0_vbus&gt;;
 			status = &quot;okay&quot;;
 		};
<span class="p_chunk">@@ -122,7 +124,7 @@</span> <span class="p_context"></span>
 
 		user {
 			label = &quot;green&quot;;
<span class="p_del">-			gpios = &lt;&amp;gpio2 1 1&gt;;</span>
<span class="p_add">+			gpios = &lt;&amp;gpio2 1 GPIO_ACTIVE_HIGH&gt;;</span>
 		};
 	};
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/imx25.dtsi b/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_header">index e4d3aec..677f81d 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx25.dtsi</span>
<span class="p_chunk">@@ -428,6 +428,7 @@</span> <span class="p_context"></span>
 
 			pwm4: pwm@53fc8000 {
 				compatible = &quot;fsl,imx25-pwm&quot;, &quot;fsl,imx27-pwm&quot;;
<span class="p_add">+				#pwm-cells = &lt;2&gt;;</span>
 				reg = &lt;0x53fc8000 0x4000&gt;;
 				clocks = &lt;&amp;clks 108&gt;, &lt;&amp;clks 52&gt;;
 				clock-names = &quot;ipg&quot;, &quot;per&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx28.dtsi b/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_header">index 47f68ac..5ed245a 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx28.dtsi</span>
<span class="p_chunk">@@ -900,7 +900,7 @@</span> <span class="p_context"></span>
 					      80 81 68 69
 					      70 71 72 73
 					      74 75 76 77&gt;;
<span class="p_del">-				interrupt-names = &quot;auart4-rx&quot;, &quot;aurat4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
<span class="p_add">+				interrupt-names = &quot;auart4-rx&quot;, &quot;auart4-tx&quot;, &quot;spdif-tx&quot;, &quot;empty&quot;,</span>
 						  &quot;saif0&quot;, &quot;saif1&quot;, &quot;i2c0&quot;, &quot;i2c1&quot;,
 						  &quot;auart0-rx&quot;, &quot;auart0-tx&quot;, &quot;auart1-rx&quot;, &quot;auart1-tx&quot;,
 						  &quot;auart2-rx&quot;, &quot;auart2-tx&quot;, &quot;auart3-rx&quot;, &quot;auart3-tx&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_header">index 19cc269..1ce6133 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx6qdl-phytec-pfla02.dtsi</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 			regulator-min-microvolt = &lt;5000000&gt;;
 			regulator-max-microvolt = &lt;5000000&gt;;
 			gpio = &lt;&amp;gpio4 15 0&gt;;
<span class="p_add">+			enable-active-high;</span>
 		};
 
 		reg_usb_h1_vbus: regulator@1 {
<span class="p_chunk">@@ -40,6 +41,7 @@</span> <span class="p_context"></span>
 			regulator-min-microvolt = &lt;5000000&gt;;
 			regulator-max-microvolt = &lt;5000000&gt;;
 			gpio = &lt;&amp;gpio1 0 0&gt;;
<span class="p_add">+			enable-active-high;</span>
 		};
 	};
 
<span class="p_header">diff --git a/arch/arm/boot/dts/omap3-n900.dts b/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_header">index b550c41..f7858f5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap3-n900.dts</span>
<span class="p_chunk">@@ -478,6 +478,8 @@</span> <span class="p_context"></span>
 		DRVDD-supply = &lt;&amp;vmmc2&gt;;
 		IOVDD-supply = &lt;&amp;vio&gt;;
 		DVDD-supply = &lt;&amp;vio&gt;;
<span class="p_add">+</span>
<span class="p_add">+		ai3x-micbias-vg = &lt;1&gt;;</span>
 	};
 
 	tlv320aic3x_aux: tlv320aic3x@19 {
<span class="p_chunk">@@ -489,6 +491,8 @@</span> <span class="p_context"></span>
 		DRVDD-supply = &lt;&amp;vmmc2&gt;;
 		IOVDD-supply = &lt;&amp;vio&gt;;
 		DVDD-supply = &lt;&amp;vio&gt;;
<span class="p_add">+</span>
<span class="p_add">+		ai3x-micbias-vg = &lt;2&gt;;</span>
 	};
 
 	tsl2563: tsl2563@29 {
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-dbx5x0.dtsi b/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_header">index bfd3f1c..2201cd5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-dbx5x0.dtsi</span>
<span class="p_chunk">@@ -1017,23 +1017,6 @@</span> <span class="p_context"></span>
 			status = &quot;disabled&quot;;
 		};
 
<span class="p_del">-		vmmci: regulator-gpio {</span>
<span class="p_del">-			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_del">-			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_del">-			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_del">-			regulator-type = &quot;voltage&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-			startup-delay-us = &lt;100&gt;;</span>
<span class="p_del">-			enable-active-high;</span>
<span class="p_del">-</span>
<span class="p_del">-			states = &lt;1800000 0x1</span>
<span class="p_del">-				  2900000 0x0&gt;;</span>
<span class="p_del">-</span>
<span class="p_del">-			status = &quot;disabled&quot;;</span>
<span class="p_del">-		};</span>
<span class="p_del">-</span>
 		mcde@a0350000 {
 			compatible = &quot;stericsson,mcde&quot;;
 			reg = &lt;0xa0350000 0x1000&gt;, /* MCDE */
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-href.dtsi b/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_header">index bf8f0ed..744c1e3 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-href.dtsi</span>
<span class="p_chunk">@@ -111,6 +111,21 @@</span> <span class="p_context"></span>
 			pinctrl-1 = &lt;&amp;i2c3_sleep_mode&gt;;
 		};
 
<span class="p_add">+		vmmci: regulator-gpio {</span>
<span class="p_add">+			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_add">+			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_add">+			regulator-type = &quot;voltage&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			startup-delay-us = &lt;100&gt;;</span>
<span class="p_add">+			enable-active-high;</span>
<span class="p_add">+</span>
<span class="p_add">+			states = &lt;1800000 0x1</span>
<span class="p_add">+				  2900000 0x0&gt;;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		// External Micro SD slot
 		sdi0_per1@80126000 {
 			arm,primecell-periphid = &lt;0x10480180&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-snowball.dts b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">index 206826a..1bc84eb 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_chunk">@@ -146,8 +146,21 @@</span> <span class="p_context"></span>
 		};
 
 		vmmci: regulator-gpio {
<span class="p_add">+			compatible = &quot;regulator-gpio&quot;;</span>
<span class="p_add">+</span>
 			gpios = &lt;&amp;gpio7 4 0x4&gt;;
 			enable-gpio = &lt;&amp;gpio6 25 0x4&gt;;
<span class="p_add">+</span>
<span class="p_add">+			regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+			regulator-max-microvolt = &lt;2900000&gt;;</span>
<span class="p_add">+			regulator-name = &quot;mmci-reg&quot;;</span>
<span class="p_add">+			regulator-type = &quot;voltage&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+			startup-delay-us = &lt;100&gt;;</span>
<span class="p_add">+			enable-active-high;</span>
<span class="p_add">+</span>
<span class="p_add">+			states = &lt;1800000 0x1</span>
<span class="p_add">+				  2900000 0x0&gt;;</span>
 		};
 
 		// External Micro SD slot
<span class="p_header">diff --git a/arch/arm/mach-omap2/prm-regbits-34xx.h b/arch/arm/mach-omap2/prm-regbits-34xx.h</span>
<span class="p_header">index cbefbd7..661d753 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/prm-regbits-34xx.h</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/prm-regbits-34xx.h</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"></span>
 #define OMAP3430_VC_CMD_ONLP_SHIFT			16
 #define OMAP3430_VC_CMD_RET_SHIFT			8
 #define OMAP3430_VC_CMD_OFF_SHIFT			0
<span class="p_add">+#define OMAP3430_SREN_MASK				(1 &lt;&lt; 4)</span>
 #define OMAP3430_HSEN_MASK				(1 &lt;&lt; 3)
 #define OMAP3430_MCODE_MASK				(0x7 &lt;&lt; 0)
 #define OMAP3430_VALID_MASK				(1 &lt;&lt; 24)
<span class="p_header">diff --git a/arch/arm/mach-omap2/prm-regbits-44xx.h b/arch/arm/mach-omap2/prm-regbits-44xx.h</span>
<span class="p_header">index b1c7a33..e794828 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/prm-regbits-44xx.h</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/prm-regbits-44xx.h</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #define OMAP4430_GLOBAL_WARM_SW_RST_SHIFT				1
 #define OMAP4430_GLOBAL_WUEN_MASK					(1 &lt;&lt; 16)
 #define OMAP4430_HSMCODE_MASK						(0x7 &lt;&lt; 0)
<span class="p_add">+#define OMAP4430_SRMODEEN_MASK						(1 &lt;&lt; 4)</span>
 #define OMAP4430_HSMODEEN_MASK						(1 &lt;&lt; 3)
 #define OMAP4430_HSSCLL_SHIFT						24
 #define OMAP4430_ICEPICK_RST_SHIFT					9
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">index be9ef83..076fd20 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc.c</span>
<span class="p_chunk">@@ -316,7 +316,8 @@</span> <span class="p_context"> static void __init omap3_vc_init_pmic_signaling(struct voltagedomain *voltdm)</span>
 	 * idle. And we can also scale voltages to zero for off-idle.
 	 * Note that no actual voltage scaling during off-idle will
 	 * happen unless the board specific twl4030 PMIC scripts are
<span class="p_del">-	 * loaded.</span>
<span class="p_add">+	 * loaded. See also omap_vc_i2c_init for comments regarding</span>
<span class="p_add">+	 * erratum i531.</span>
 	 */
 	val = voltdm-&gt;read(OMAP3_PRM_VOLTCTRL_OFFSET);
 	if (!(val &amp; OMAP3430_PRM_VOLTCTRL_SEL_OFF)) {
<span class="p_chunk">@@ -704,9 +705,16 @@</span> <span class="p_context"> static void __init omap_vc_i2c_init(struct voltagedomain *voltdm)</span>
 		return;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note that for omap3 OMAP3430_SREN_MASK clears SREN to work around</span>
<span class="p_add">+	 * erratum i531 &quot;Extra Power Consumed When Repeated Start Operation</span>
<span class="p_add">+	 * Mode Is Enabled on I2C Interface Dedicated for Smart Reflex (I2C4)&quot;.</span>
<span class="p_add">+	 * Otherwise I2C4 eventually leads into about 23mW extra power being</span>
<span class="p_add">+	 * consumed even during off idle using VMODE.</span>
<span class="p_add">+	 */</span>
 	i2c_high_speed = voltdm-&gt;pmic-&gt;i2c_high_speed;
 	if (i2c_high_speed)
<span class="p_del">-		voltdm-&gt;rmw(vc-&gt;common-&gt;i2c_cfg_hsen_mask,</span>
<span class="p_add">+		voltdm-&gt;rmw(vc-&gt;common-&gt;i2c_cfg_clear_mask,</span>
 			    vc-&gt;common-&gt;i2c_cfg_hsen_mask,
 			    vc-&gt;common-&gt;i2c_cfg_reg);
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc.h b/arch/arm/mach-omap2/vc.h</span>
<span class="p_header">index cdbdd78..89b83b7 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc.h</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc.h</span>
<span class="p_chunk">@@ -34,6 +34,7 @@</span> <span class="p_context"> struct voltagedomain;</span>
  * @cmd_ret_shift: RET field shift in PRM_VC_CMD_VAL_* register
  * @cmd_off_shift: OFF field shift in PRM_VC_CMD_VAL_* register
  * @i2c_cfg_reg: I2C configuration register offset
<span class="p_add">+ * @i2c_cfg_clear_mask: high-speed mode bit clear mask in I2C config register</span>
  * @i2c_cfg_hsen_mask: high-speed mode bit field mask in I2C config register
  * @i2c_mcode_mask: MCODE field mask for I2C config register
  *
<span class="p_chunk">@@ -52,6 +53,7 @@</span> <span class="p_context"> struct omap_vc_common {</span>
 	u8 cmd_ret_shift;
 	u8 cmd_off_shift;
 	u8 i2c_cfg_reg;
<span class="p_add">+	u8 i2c_cfg_clear_mask;</span>
 	u8 i2c_cfg_hsen_mask;
 	u8 i2c_mcode_mask;
 };
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc3xxx_data.c b/arch/arm/mach-omap2/vc3xxx_data.c</span>
<span class="p_header">index 75bc4aa..71d74c9 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc3xxx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc3xxx_data.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"> static struct omap_vc_common omap3_vc_common = {</span>
 	.cmd_onlp_shift	 = OMAP3430_VC_CMD_ONLP_SHIFT,
 	.cmd_ret_shift	 = OMAP3430_VC_CMD_RET_SHIFT,
 	.cmd_off_shift	 = OMAP3430_VC_CMD_OFF_SHIFT,
<span class="p_add">+	.i2c_cfg_clear_mask = OMAP3430_SREN_MASK | OMAP3430_HSEN_MASK,</span>
 	.i2c_cfg_hsen_mask = OMAP3430_HSEN_MASK,
 	.i2c_cfg_reg	 = OMAP3_PRM_VC_I2C_CFG_OFFSET,
 	.i2c_mcode_mask	 = OMAP3430_MCODE_MASK,
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc44xx_data.c b/arch/arm/mach-omap2/vc44xx_data.c</span>
<span class="p_header">index 085e5d6..2abd5fa 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc44xx_data.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc44xx_data.c</span>
<span class="p_chunk">@@ -42,6 +42,7 @@</span> <span class="p_context"> static const struct omap_vc_common omap4_vc_common = {</span>
 	.cmd_ret_shift = OMAP4430_RET_SHIFT,
 	.cmd_off_shift = OMAP4430_OFF_SHIFT,
 	.i2c_cfg_reg = OMAP4_PRM_VC_CFG_I2C_MODE_OFFSET,
<span class="p_add">+	.i2c_cfg_clear_mask = OMAP4430_SRMODEEN_MASK | OMAP4430_HSMODEEN_MASK,</span>
 	.i2c_cfg_hsen_mask = OMAP4430_HSMODEEN_MASK,
 	.i2c_mcode_mask	 = OMAP4430_HSMCODE_MASK,
 };
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index df34a70..7980c2a 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -67,8 +67,7 @@</span> <span class="p_context"> static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)</span>
 
 		*ret_page = phys_to_page(phys);
 		ptr = (void *)val;
<span class="p_del">-		if (flags &amp; __GFP_ZERO)</span>
<span class="p_del">-			memset(ptr, 0, size);</span>
<span class="p_add">+		memset(ptr, 0, size);</span>
 	}
 
 	return ptr;
<span class="p_chunk">@@ -113,8 +112,7 @@</span> <span class="p_context"> static void *__dma_alloc_coherent(struct device *dev, size_t size,</span>
 
 		*dma_handle = phys_to_dma(dev, page_to_phys(page));
 		addr = page_address(page);
<span class="p_del">-		if (flags &amp; __GFP_ZERO)</span>
<span class="p_del">-			memset(addr, 0, size);</span>
<span class="p_add">+		memset(addr, 0, size);</span>
 		return addr;
 	} else {
 		return swiotlb_alloc_coherent(dev, size, dma_handle, flags);
<span class="p_chunk">@@ -135,7 +133,7 @@</span> <span class="p_context"> static void __dma_free_coherent(struct device *dev, size_t size,</span>
 
 	freed = dma_release_from_contiguous(dev,
 					phys_to_page(paddr),
<span class="p_del">-					size &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+					PAGE_ALIGN(size) &gt;&gt; PAGE_SHIFT);</span>
 	if (!freed)
 		swiotlb_free_coherent(dev, size, vaddr, dma_handle);
 }
<span class="p_chunk">@@ -191,6 +189,8 @@</span> <span class="p_context"> static void __dma_free_noncoherent(struct device *dev, size_t size,</span>
 {
 	void *swiotlb_addr = phys_to_virt(dma_to_phys(dev, dma_handle));
 
<span class="p_add">+	size = PAGE_ALIGN(size);</span>
<span class="p_add">+</span>
 	if (__free_from_pool(vaddr, size))
 		return;
 	vunmap(vaddr);
<span class="p_header">diff --git a/arch/powerpc/kernel/idle_power7.S b/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_header">index 05adc8b..401d8d0 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_chunk">@@ -500,9 +500,11 @@</span> <span class="p_context"> BEGIN_FTR_SECTION</span>
 	CHECK_HMI_INTERRUPT
 END_FTR_SECTION_IFSET(CPU_FTR_HVMODE)
 	ld	r1,PACAR1(r13)
<span class="p_add">+	ld	r6,_CCR(r1)</span>
 	ld	r4,_MSR(r1)
 	ld	r5,_NIP(r1)
 	addi	r1,r1,INT_FRAME_SIZE
<span class="p_add">+	mtcr	r6</span>
 	mtspr	SPRN_SRR1,r4
 	mtspr	SPRN_SRR0,r5
 	rfid
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index c22bb1b..0991578 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -410,6 +410,10 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 	if (rc)
 		return -EINVAL;
 
<span class="p_add">+	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	parent = of_find_node_by_path(&quot;/cpus&quot;);
 	if (!parent)
 		return -ENODEV;
<span class="p_chunk">@@ -420,12 +424,6 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 
 	of_node_put(parent);
 
<span class="p_del">-	rc = dlpar_acquire_drc(drc_index);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		dlpar_free_cc_nodes(dn);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index 92b9a5f..5999980 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -1110,6 +1110,8 @@</span> <span class="p_context"> struct boot_params *make_boot_params(struct efi_config *c)</span>
 	if (!cmdline_ptr)
 		goto fail;
 	hdr-&gt;cmd_line_ptr = (unsigned long)cmdline_ptr;
<span class="p_add">+	/* Fill in upper bits of command line address, NOP on 32 bit  */</span>
<span class="p_add">+	boot_params-&gt;ext_cmd_line_ptr = (u64)(unsigned long)cmdline_ptr &gt;&gt; 32;</span>
 
 	hdr-&gt;ramdisk_image = 0;
 	hdr-&gt;ramdisk_size = 0;
<span class="p_header">diff --git a/arch/x86/include/asm/spinlock.h b/arch/x86/include/asm/spinlock.h</span>
<span class="p_header">index cf87de3..64b6117 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> static inline int arch_spin_is_contended(arch_spinlock_t *lock)</span>
 	struct __raw_tickets tmp = READ_ONCE(lock-&gt;tickets);
 
 	tmp.head &amp;= ~TICKET_SLOWPATH_FLAG;
<span class="p_del">-	return (tmp.tail - tmp.head) &gt; TICKET_LOCK_INC;</span>
<span class="p_add">+	return (__ticket_t)(tmp.tail - tmp.head) &gt; TICKET_LOCK_INC;</span>
 }
 #define arch_spin_is_contended	arch_spin_is_contended
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel_early.c b/arch/x86/kernel/cpu/microcode/intel_early.c</span>
<span class="p_header">index ec9df6f..5e109a3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel_early.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel_early.c</span>
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> get_matching_model_microcode(int cpu, unsigned long start,</span>
 	unsigned int mc_saved_count = mc_saved_data-&gt;mc_saved_count;
 	int i;
 
<span class="p_del">-	while (leftover) {</span>
<span class="p_add">+	while (leftover &amp;&amp; mc_saved_count &lt; ARRAY_SIZE(mc_saved_tmp)) {</span>
 		mc_header = (struct microcode_header_intel *)ucode_ptr;
 
 		mc_size = get_totalsize(mc_header);
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 447f533..c99b3e1 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -673,8 +673,11 @@</span> <span class="p_context"> static void blk_mq_rq_timer(unsigned long priv)</span>
 		data.next = blk_rq_timeout(round_jiffies_up(data.next));
 		mod_timer(&amp;q-&gt;timeout, data.next);
 	} else {
<span class="p_del">-		queue_for_each_hw_ctx(q, hctx, i)</span>
<span class="p_del">-			blk_mq_tag_idle(hctx);</span>
<span class="p_add">+		queue_for_each_hw_ctx(q, hctx, i) {</span>
<span class="p_add">+			/* the hctx may be unmapped, so check it here */</span>
<span class="p_add">+			if (blk_mq_hw_queue_mapped(hctx))</span>
<span class="p_add">+				blk_mq_tag_idle(hctx);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -1571,22 +1574,6 @@</span> <span class="p_context"> static int blk_mq_hctx_cpu_offline(struct blk_mq_hw_ctx *hctx, int cpu)</span>
 	return NOTIFY_OK;
 }
 
<span class="p_del">-static int blk_mq_hctx_cpu_online(struct blk_mq_hw_ctx *hctx, int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct request_queue *q = hctx-&gt;queue;</span>
<span class="p_del">-	struct blk_mq_tag_set *set = q-&gt;tag_set;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (set-&gt;tags[hctx-&gt;queue_num])</span>
<span class="p_del">-		return NOTIFY_OK;</span>
<span class="p_del">-</span>
<span class="p_del">-	set-&gt;tags[hctx-&gt;queue_num] = blk_mq_init_rq_map(set, hctx-&gt;queue_num);</span>
<span class="p_del">-	if (!set-&gt;tags[hctx-&gt;queue_num])</span>
<span class="p_del">-		return NOTIFY_STOP;</span>
<span class="p_del">-</span>
<span class="p_del">-	hctx-&gt;tags = set-&gt;tags[hctx-&gt;queue_num];</span>
<span class="p_del">-	return NOTIFY_OK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int blk_mq_hctx_notify(void *data, unsigned long action,
 			      unsigned int cpu)
 {
<span class="p_chunk">@@ -1594,8 +1581,11 @@</span> <span class="p_context"> static int blk_mq_hctx_notify(void *data, unsigned long action,</span>
 
 	if (action == CPU_DEAD || action == CPU_DEAD_FROZEN)
 		return blk_mq_hctx_cpu_offline(hctx, cpu);
<span class="p_del">-	else if (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)</span>
<span class="p_del">-		return blk_mq_hctx_cpu_online(hctx, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case of CPU online, tags may be reallocated</span>
<span class="p_add">+	 * in blk_mq_map_swqueue() after mapping is updated.</span>
<span class="p_add">+	 */</span>
 
 	return NOTIFY_OK;
 }
<span class="p_chunk">@@ -1777,6 +1767,7 @@</span> <span class="p_context"> static void blk_mq_map_swqueue(struct request_queue *q)</span>
 	unsigned int i;
 	struct blk_mq_hw_ctx *hctx;
 	struct blk_mq_ctx *ctx;
<span class="p_add">+	struct blk_mq_tag_set *set = q-&gt;tag_set;</span>
 
 	queue_for_each_hw_ctx(q, hctx, i) {
 		cpumask_clear(hctx-&gt;cpumask);
<span class="p_chunk">@@ -1803,16 +1794,20 @@</span> <span class="p_context"> static void blk_mq_map_swqueue(struct request_queue *q)</span>
 		 * disable it and free the request entries.
 		 */
 		if (!hctx-&gt;nr_ctx) {
<span class="p_del">-			struct blk_mq_tag_set *set = q-&gt;tag_set;</span>
<span class="p_del">-</span>
 			if (set-&gt;tags[i]) {
 				blk_mq_free_rq_map(set, set-&gt;tags[i], i);
 				set-&gt;tags[i] = NULL;
<span class="p_del">-				hctx-&gt;tags = NULL;</span>
 			}
<span class="p_add">+			hctx-&gt;tags = NULL;</span>
 			continue;
 		}
 
<span class="p_add">+		/* unmapped hw queue can be remapped after CPU topo changed */</span>
<span class="p_add">+		if (!set-&gt;tags[i])</span>
<span class="p_add">+			set-&gt;tags[i] = blk_mq_init_rq_map(set, i);</span>
<span class="p_add">+		hctx-&gt;tags = set-&gt;tags[i];</span>
<span class="p_add">+		WARN_ON(!hctx-&gt;tags);</span>
<span class="p_add">+</span>
 		/*
 		 * Initialize batch roundrobin counts
 		 */
<span class="p_chunk">@@ -2076,9 +2071,16 @@</span> <span class="p_context"> static int blk_mq_queue_reinit_notify(struct notifier_block *nb,</span>
 	 */
 	list_for_each_entry(q, &amp;all_q_list, all_q_node)
 		blk_mq_freeze_queue_start(q);
<span class="p_del">-	list_for_each_entry(q, &amp;all_q_list, all_q_node)</span>
<span class="p_add">+	list_for_each_entry(q, &amp;all_q_list, all_q_node) {</span>
 		blk_mq_freeze_queue_wait(q);
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * timeout handler can&#39;t touch hw queue during the</span>
<span class="p_add">+		 * reinitialization</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		del_timer_sync(&amp;q-&gt;timeout);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_for_each_entry(q, &amp;all_q_list, all_q_node)
 		blk_mq_queue_reinit(q);
 
<span class="p_header">diff --git a/drivers/acpi/acpi_pnp.c b/drivers/acpi/acpi_pnp.c</span>
<span class="p_header">index b193f84..ff6d8ad 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_pnp.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_pnp.c</span>
<span class="p_chunk">@@ -304,6 +304,8 @@</span> <span class="p_context"> static const struct acpi_device_id acpi_pnp_device_ids[] = {</span>
 	{&quot;PNPb006&quot;},
 	/* cs423x-pnpbios */
 	{&quot;CSC0100&quot;},
<span class="p_add">+	{&quot;CSC0103&quot;},</span>
<span class="p_add">+	{&quot;CSC0110&quot;},</span>
 	{&quot;CSC0000&quot;},
 	{&quot;GIM0100&quot;},		/* Guillemot Turtlebeach something appears to be cs4232 compatible */
 	/* es18xx-pnpbios */
<span class="p_header">diff --git a/drivers/acpi/sbs.c b/drivers/acpi/sbs.c</span>
<span class="p_header">index a7a3edd..f23179e 100644</span>
<span class="p_header">--- a/drivers/acpi/sbs.c</span>
<span class="p_header">+++ b/drivers/acpi/sbs.c</span>
<span class="p_chunk">@@ -670,7 +670,7 @@</span> <span class="p_context"> static int acpi_sbs_add(struct acpi_device *device)</span>
 	if (!sbs_manager_broken) {
 		result = acpi_manager_get_info(sbs);
 		if (!result) {
<span class="p_del">-			sbs-&gt;manager_present = 0;</span>
<span class="p_add">+			sbs-&gt;manager_present = 1;</span>
 			for (id = 0; id &lt; MAX_SBS_BAT; ++id)
 				if ((sbs-&gt;batteries_supported &amp; (1 &lt;&lt; id)))
 					acpi_battery_add(sbs, id);
<span class="p_header">diff --git a/drivers/acpi/sbshc.c b/drivers/acpi/sbshc.c</span>
<span class="p_header">index 26e5b50..bf034f8 100644</span>
<span class="p_header">--- a/drivers/acpi/sbshc.c</span>
<span class="p_header">+++ b/drivers/acpi/sbshc.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/interrupt.h&gt;
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
 #include &quot;sbshc.h&quot;
 
 #define PREFIX &quot;ACPI: &quot;
<span class="p_chunk">@@ -87,6 +88,8 @@</span> <span class="p_context"> enum acpi_smb_offset {</span>
 	ACPI_SMB_ALARM_DATA = 0x26,	/* 2 bytes alarm data */
 };
 
<span class="p_add">+static bool macbook;</span>
<span class="p_add">+</span>
 static inline int smb_hc_read(struct acpi_smb_hc *hc, u8 address, u8 *data)
 {
 	return ec_read(hc-&gt;offset + address, data);
<span class="p_chunk">@@ -132,6 +135,8 @@</span> <span class="p_context"> static int acpi_smbus_transaction(struct acpi_smb_hc *hc, u8 protocol,</span>
 	}
 
 	mutex_lock(&amp;hc-&gt;lock);
<span class="p_add">+	if (macbook)</span>
<span class="p_add">+		udelay(5);</span>
 	if (smb_hc_read(hc, ACPI_SMB_PROTOCOL, &amp;temp))
 		goto end;
 	if (temp) {
<span class="p_chunk">@@ -257,12 +262,29 @@</span> <span class="p_context"> extern int acpi_ec_add_query_handler(struct acpi_ec *ec, u8 query_bit,</span>
 			      acpi_handle handle, acpi_ec_query_func func,
 			      void *data);
 
<span class="p_add">+static int macbook_dmi_match(const struct dmi_system_id *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_debug(&quot;Detected MacBook, enabling workaround\n&quot;);</span>
<span class="p_add">+	macbook = true;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct dmi_system_id acpi_smbus_dmi_table[] = {</span>
<span class="p_add">+	{ macbook_dmi_match, &quot;Apple MacBook&quot;, {</span>
<span class="p_add">+	  DMI_MATCH(DMI_BOARD_VENDOR, &quot;Apple&quot;),</span>
<span class="p_add">+	  DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBook&quot;) },</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{ },</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int acpi_smbus_hc_add(struct acpi_device *device)
 {
 	int status;
 	unsigned long long val;
 	struct acpi_smb_hc *hc;
 
<span class="p_add">+	dmi_check_system(acpi_smbus_dmi_table);</span>
<span class="p_add">+</span>
 	if (!device)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 8a86b62..733e621 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -2261,6 +2261,11 @@</span> <span class="p_context"> static bool rbd_img_obj_end_request(struct rbd_obj_request *obj_request)</span>
 			result, xferred);
 		if (!img_request-&gt;result)
 			img_request-&gt;result = result;
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Need to end I/O on the entire obj_request worth of</span>
<span class="p_add">+		 * bytes in case of error.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		xferred = obj_request-&gt;length;</span>
 	}
 
 	/* Image object requests don&#39;t own their page array */
<span class="p_header">diff --git a/drivers/firmware/efi/runtime-map.c b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">index 87b8e3b..5c55227 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/runtime-map.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/runtime-map.c</span>
<span class="p_chunk">@@ -120,7 +120,8 @@</span> <span class="p_context"> add_sysfs_runtime_map_entry(struct kobject *kobj, int nr)</span>
 	entry = kzalloc(sizeof(*entry), GFP_KERNEL);
 	if (!entry) {
 		kset_unregister(map_kset);
<span class="p_del">-		return entry;</span>
<span class="p_add">+		map_kset = NULL;</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
 	}
 
 	memcpy(&amp;entry-&gt;md, efi_runtime_map + nr * efi_memdesc_size,
<span class="p_chunk">@@ -132,6 +133,7 @@</span> <span class="p_context"> add_sysfs_runtime_map_entry(struct kobject *kobj, int nr)</span>
 	if (ret) {
 		kobject_put(&amp;entry-&gt;kobj);
 		kset_unregister(map_kset);
<span class="p_add">+		map_kset = NULL;</span>
 		return ERR_PTR(ret);
 	}
 
<span class="p_chunk">@@ -195,8 +197,6 @@</span> <span class="p_context"> out_add_entry:</span>
 		entry = *(map_entries + j);
 		kobject_put(&amp;entry-&gt;kobj);
 	}
<span class="p_del">-	if (map_kset)</span>
<span class="p_del">-		kset_unregister(map_kset);</span>
 out:
 	return ret;
 }
<span class="p_header">diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c</span>
<span class="p_header">index 7722ed5..af3bc7a 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib-sysfs.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib-sysfs.c</span>
<span class="p_chunk">@@ -551,6 +551,7 @@</span> <span class="p_context"> static struct class gpio_class = {</span>
  */
 int gpiod_export(struct gpio_desc *desc, bool direction_may_change)
 {
<span class="p_add">+	struct gpio_chip	*chip;</span>
 	unsigned long		flags;
 	int			status;
 	const char		*ioname = NULL;
<span class="p_chunk">@@ -568,8 +569,16 @@</span> <span class="p_context"> int gpiod_export(struct gpio_desc *desc, bool direction_may_change)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	chip = desc-&gt;chip;</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;sysfs_lock);
 
<span class="p_add">+	/* check if chip is being removed */</span>
<span class="p_add">+	if (!chip || !chip-&gt;exported) {</span>
<span class="p_add">+		status = -ENODEV;</span>
<span class="p_add">+		goto fail_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;gpio_lock, flags);
 	if (!test_bit(FLAG_REQUESTED, &amp;desc-&gt;flags) ||
 	     test_bit(FLAG_EXPORT, &amp;desc-&gt;flags)) {
<span class="p_chunk">@@ -783,12 +792,15 @@</span> <span class="p_context"> void gpiochip_unexport(struct gpio_chip *chip)</span>
 {
 	int			status;
 	struct device		*dev;
<span class="p_add">+	struct gpio_desc *desc;</span>
<span class="p_add">+	unsigned int i;</span>
 
 	mutex_lock(&amp;sysfs_lock);
 	dev = class_find_device(&amp;gpio_class, NULL, chip, match_export);
 	if (dev) {
 		put_device(dev);
 		device_unregister(dev);
<span class="p_add">+		/* prevent further gpiod exports */</span>
 		chip-&gt;exported = false;
 		status = 0;
 	} else
<span class="p_chunk">@@ -797,6 +809,13 @@</span> <span class="p_context"> void gpiochip_unexport(struct gpio_chip *chip)</span>
 
 	if (status)
 		chip_dbg(chip, &quot;%s: status %d\n&quot;, __func__, status);
<span class="p_add">+</span>
<span class="p_add">+	/* unregister gpiod class devices owned by sysfs */</span>
<span class="p_add">+	for (i = 0; i &lt; chip-&gt;ngpio; i++) {</span>
<span class="p_add">+		desc = &amp;chip-&gt;desc[i];</span>
<span class="p_add">+		if (test_and_clear_bit(FLAG_SYSFS, &amp;desc-&gt;flags))</span>
<span class="p_add">+			gpiod_free(desc);</span>
<span class="p_add">+	}</span>
 }
 
 static int __init gpiolib_sysfs_init(void)
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c b/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c</span>
<span class="p_header">index c80a8a3..c9d2f3a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c</span>
<span class="p_chunk">@@ -445,9 +445,10 @@</span> <span class="p_context"> static int unregister_process_nocpsch(struct device_queue_manager *dqm,</span>
 
 	BUG_ON(!dqm || !qpd);
 
<span class="p_del">-	BUG_ON(!list_empty(&amp;qpd-&gt;queues_list));</span>
<span class="p_add">+	pr_debug(&quot;In func %s\n&quot;, __func__);</span>
 
<span class="p_del">-	pr_debug(&quot;kfd: In func %s\n&quot;, __func__);</span>
<span class="p_add">+	pr_debug(&quot;qpd-&gt;queues_list is %s\n&quot;,</span>
<span class="p_add">+			list_empty(&amp;qpd-&gt;queues_list) ? &quot;empty&quot; : &quot;not empty&quot;);</span>
 
 	retval = 0;
 	mutex_lock(&amp;dqm-&gt;lock);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_irq.c b/drivers/gpu/drm/drm_irq.c</span>
<span class="p_header">index 4d79dad..68193a6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_irq.c</span>
<span class="p_chunk">@@ -131,12 +131,11 @@</span> <span class="p_context"> static void drm_update_vblank_count(struct drm_device *dev, int crtc)</span>
 
 	/* Reinitialize corresponding vblank timestamp if high-precision query
 	 * available. Skip this step if query unsupported or failed. Will
<span class="p_del">-	 * reinitialize delayed at next vblank interrupt in that case.</span>
<span class="p_add">+	 * reinitialize delayed at next vblank interrupt in that case and</span>
<span class="p_add">+	 * assign 0 for now, to mark the vblanktimestamp as invalid.</span>
 	 */
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		tslot = atomic_read(&amp;vblank-&gt;count) + diff;</span>
<span class="p_del">-		vblanktimestamp(dev, crtc, tslot) = t_vblank;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	tslot = atomic_read(&amp;vblank-&gt;count) + diff;</span>
<span class="p_add">+	vblanktimestamp(dev, crtc, tslot) = rc ? t_vblank : (struct timeval) {0, 0};</span>
 
 	smp_mb__before_atomic();
 	atomic_add(diff, &amp;vblank-&gt;count);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 9f6c897..00c8ee9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -1175,7 +1175,7 @@</span> <span class="p_context"> intel_dp_compute_config(struct intel_encoder *encoder,</span>
 
 	pipe_config-&gt;has_dp_encoder = true;
 	pipe_config-&gt;has_drrs = false;
<span class="p_del">-	pipe_config-&gt;has_audio = intel_dp-&gt;has_audio;</span>
<span class="p_add">+	pipe_config-&gt;has_audio = intel_dp-&gt;has_audio &amp;&amp; port != PORT_A;</span>
 
 	if (is_edp(intel_dp) &amp;&amp; intel_connector-&gt;panel.fixed_mode) {
 		intel_fixed_panel_mode(intel_connector-&gt;panel.fixed_mode,
<span class="p_chunk">@@ -2024,8 +2024,8 @@</span> <span class="p_context"> static void intel_dp_get_config(struct intel_encoder *encoder,</span>
 	int dotclock;
 
 	tmp = I915_READ(intel_dp-&gt;output_reg);
<span class="p_del">-	if (tmp &amp; DP_AUDIO_OUTPUT_ENABLE)</span>
<span class="p_del">-		pipe_config-&gt;has_audio = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	pipe_config-&gt;has_audio = tmp &amp; DP_AUDIO_OUTPUT_ENABLE &amp;&amp; port != PORT_A;</span>
 
 	if ((port == PORT_A) || !HAS_PCH_CPT(dev)) {
 		if (tmp &amp; DP_SYNC_HS_HIGH)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lvds.c b/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_header">index 14654d6..2dcda09 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lvds.c</span>
<span class="p_chunk">@@ -809,12 +809,28 @@</span> <span class="p_context"> static int intel_dual_link_lvds_callback(const struct dmi_system_id *id)</span>
 static const struct dmi_system_id intel_dual_link_lvds[] = {
 	{
 		.callback = intel_dual_link_lvds_callback,
<span class="p_del">-		.ident = &quot;Apple MacBook Pro (Core i5/i7 Series)&quot;,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2010)&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro6,2&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = intel_dual_link_lvds_callback,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2011)&quot;,</span>
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro8,2&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = intel_dual_link_lvds_callback,</span>
<span class="p_add">+		.ident = &quot;Apple MacBook Pro 15\&quot; (2012)&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Apple Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;MacBookPro9,1&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }	/* terminating entry */
 };
 
<span class="p_chunk">@@ -844,6 +860,11 @@</span> <span class="p_context"> static bool compute_is_dual_link_lvds(struct intel_lvds_encoder *lvds_encoder)</span>
 	if (i915.lvds_channel_mode &gt; 0)
 		return i915.lvds_channel_mode == 2;
 
<span class="p_add">+	/* single channel LVDS is limited to 112 MHz */</span>
<span class="p_add">+	if (lvds_encoder-&gt;attached_connector-&gt;base.panel.fixed_mode-&gt;clock</span>
<span class="p_add">+	    &gt; 112999)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
 	if (dmi_check_system(intel_dual_link_lvds))
 		return true;
 
<span class="p_chunk">@@ -1101,6 +1122,8 @@</span> <span class="p_context"> void intel_lvds_init(struct drm_device *dev)</span>
 out:
 	mutex_unlock(&amp;dev-&gt;mode_config.mutex);
 
<span class="p_add">+	intel_panel_init(&amp;intel_connector-&gt;panel, fixed_mode, downclock_mode);</span>
<span class="p_add">+</span>
 	lvds_encoder-&gt;is_dual_link = compute_is_dual_link_lvds(lvds_encoder);
 	DRM_DEBUG_KMS(&quot;detected %s-link lvds configuration\n&quot;,
 		      lvds_encoder-&gt;is_dual_link ? &quot;dual&quot; : &quot;single&quot;);
<span class="p_chunk">@@ -1115,7 +1138,6 @@</span> <span class="p_context"> out:</span>
 	}
 	drm_connector_register(connector);
 
<span class="p_del">-	intel_panel_init(&amp;intel_connector-&gt;panel, fixed_mode, downclock_mode);</span>
 	intel_panel_setup_backlight(connector, INVALID_PIPE);
 
 	return;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 9bd5611..1afc0b4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -580,6 +580,9 @@</span> <span class="p_context"> static u32 atombios_adjust_pll(struct drm_crtc *crtc,</span>
 		else
 			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_LOW_REF_DIV;
 
<span class="p_add">+		/* if there is no audio, set MINM_OVER_MAXP  */</span>
<span class="p_add">+		if (!drm_detect_monitor_audio(radeon_connector_edid(connector)))</span>
<span class="p_add">+			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;</span>
 		if (rdev-&gt;family &lt; CHIP_RV770)
 			radeon_crtc-&gt;pll_flags |= RADEON_PLL_PREFER_MINM_OVER_MAXP;
 		/* use frac fb div on APUs */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_asic.c b/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_header">index ed0e10e..c34ceb8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_asic.c</span>
<span class="p_chunk">@@ -1190,7 +1190,7 @@</span> <span class="p_context"> static struct radeon_asic rs780_asic = {</span>
 static struct radeon_asic_ring rv770_uvd_ring = {
 	.ib_execute = &amp;uvd_v1_0_ib_execute,
 	.emit_fence = &amp;uvd_v2_2_fence_emit,
<span class="p_del">-	.emit_semaphore = &amp;uvd_v1_0_semaphore_emit,</span>
<span class="p_add">+	.emit_semaphore = &amp;uvd_v2_2_semaphore_emit,</span>
 	.cs_parse = &amp;radeon_uvd_cs_parse,
 	.ring_test = &amp;uvd_v1_0_ring_test,
 	.ib_test = &amp;uvd_v1_0_ib_test,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_asic.h b/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_header">index 8d787d1..b427a36 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_asic.h</span>
<span class="p_chunk">@@ -914,6 +914,10 @@</span> <span class="p_context"> void uvd_v1_0_ib_execute(struct radeon_device *rdev, struct radeon_ib *ib);</span>
 int uvd_v2_2_resume(struct radeon_device *rdev);
 void uvd_v2_2_fence_emit(struct radeon_device *rdev,
 			 struct radeon_fence *fence);
<span class="p_add">+bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring,</span>
<span class="p_add">+			     struct radeon_semaphore *semaphore,</span>
<span class="p_add">+			     bool emit_wait);</span>
 
 /* uvd v3.1 */
 bool uvd_v3_1_semaphore_emit(struct radeon_device *rdev,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cs.c b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">index 26e7d28..204a64a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cs.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> static int radeon_cs_parser_relocs(struct radeon_cs_parser *p)</span>
 	p-&gt;dma_reloc_idx = 0;
 	/* FIXME: we assume that each relocs use 4 dwords */
 	p-&gt;nrelocs = chunk-&gt;length_dw / 4;
<span class="p_del">-	p-&gt;relocs = kcalloc(p-&gt;nrelocs, sizeof(struct radeon_bo_list), GFP_KERNEL);</span>
<span class="p_add">+	p-&gt;relocs = drm_calloc_large(p-&gt;nrelocs, sizeof(struct radeon_bo_list));</span>
 	if (p-&gt;relocs == NULL) {
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -428,7 +428,7 @@</span> <span class="p_context"> static void radeon_cs_parser_fini(struct radeon_cs_parser *parser, int error, bo</span>
 		}
 	}
 	kfree(parser-&gt;track);
<span class="p_del">-	kfree(parser-&gt;relocs);</span>
<span class="p_add">+	drm_free_large(parser-&gt;relocs);</span>
 	drm_free_large(parser-&gt;vm_bos);
 	for (i = 0; i &lt; parser-&gt;nchunks; i++)
 		drm_free_large(parser-&gt;chunks[i].kdata);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_ttm.c b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">index b292aca..edafd3c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_ttm.c</span>
<span class="p_chunk">@@ -591,8 +591,7 @@</span> <span class="p_context"> static void radeon_ttm_tt_unpin_userptr(struct ttm_tt *ttm)</span>
 {
 	struct radeon_device *rdev = radeon_get_rdev(ttm-&gt;bdev);
 	struct radeon_ttm_tt *gtt = (void *)ttm;
<span class="p_del">-	struct scatterlist *sg;</span>
<span class="p_del">-	int i;</span>
<span class="p_add">+	struct sg_page_iter sg_iter;</span>
 
 	int write = !(gtt-&gt;userflags &amp; RADEON_GEM_USERPTR_READONLY);
 	enum dma_data_direction direction = write ?
<span class="p_chunk">@@ -605,9 +604,8 @@</span> <span class="p_context"> static void radeon_ttm_tt_unpin_userptr(struct ttm_tt *ttm)</span>
 	/* free the sg table and pages again */
 	dma_unmap_sg(rdev-&gt;dev, ttm-&gt;sg-&gt;sgl, ttm-&gt;sg-&gt;nents, direction);
 
<span class="p_del">-	for_each_sg(ttm-&gt;sg-&gt;sgl, sg, ttm-&gt;sg-&gt;nents, i) {</span>
<span class="p_del">-		struct page *page = sg_page(sg);</span>
<span class="p_del">-</span>
<span class="p_add">+	for_each_sg_page(ttm-&gt;sg-&gt;sgl, &amp;sg_iter, ttm-&gt;sg-&gt;nents, 0) {</span>
<span class="p_add">+		struct page *page = sg_page_iter_page(&amp;sg_iter);</span>
 		if (!(gtt-&gt;userflags &amp; RADEON_GEM_USERPTR_READONLY))
 			set_page_dirty(page);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_uvd.c b/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_header">index c10b2ae..cd63028 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_uvd.c</span>
<span class="p_chunk">@@ -396,6 +396,29 @@</span> <span class="p_context"> static int radeon_uvd_cs_msg_decode(uint32_t *msg, unsigned buf_sizes[])</span>
 	return 0;
 }
 
<span class="p_add">+static int radeon_uvd_validate_codec(struct radeon_cs_parser *p,</span>
<span class="p_add">+				     unsigned stream_type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (stream_type) {</span>
<span class="p_add">+	case 0: /* H264 */</span>
<span class="p_add">+	case 1: /* VC1 */</span>
<span class="p_add">+		/* always supported */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 3: /* MPEG2 */</span>
<span class="p_add">+	case 4: /* MPEG4 */</span>
<span class="p_add">+		/* only since UVD 3 */</span>
<span class="p_add">+		if (p-&gt;rdev-&gt;family &gt;= CHIP_PALM)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* fall through */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		DRM_ERROR(&quot;UVD codec not supported by hardware %d!\n&quot;,</span>
<span class="p_add">+			  stream_type);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,
 			     unsigned offset, unsigned buf_sizes[])
 {
<span class="p_chunk">@@ -436,50 +459,70 @@</span> <span class="p_context"> static int radeon_uvd_cs_msg(struct radeon_cs_parser *p, struct radeon_bo *bo,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	if (msg_type == 1) {</span>
<span class="p_del">-		/* it&#39;s a decode msg, calc buffer sizes */</span>
<span class="p_del">-		r = radeon_uvd_cs_msg_decode(msg, buf_sizes);</span>
<span class="p_del">-		/* calc image size (width * height) */</span>
<span class="p_del">-		img_size = msg[6] * msg[7];</span>
<span class="p_add">+	switch (msg_type) {</span>
<span class="p_add">+	case 0:</span>
<span class="p_add">+		/* it&#39;s a create msg, calc image size (width * height) */</span>
<span class="p_add">+		img_size = msg[7] * msg[8];</span>
<span class="p_add">+</span>
<span class="p_add">+		r = radeon_uvd_validate_codec(p, msg[4]);</span>
<span class="p_add">+		radeon_bo_kunmap(bo);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			return r;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* try to alloc a new handle */</span>
<span class="p_add">+		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_add">+			if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle) {</span>
<span class="p_add">+				DRM_ERROR(&quot;Handle 0x%x already in use!\n&quot;, handle);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], 0, handle)) {</span>
<span class="p_add">+				p-&gt;rdev-&gt;uvd.filp[i] = p-&gt;filp;</span>
<span class="p_add">+				p-&gt;rdev-&gt;uvd.img_size[i] = img_size;</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_ERROR(&quot;No more free UVD handles!\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		/* it&#39;s a decode msg, validate codec and calc buffer sizes */</span>
<span class="p_add">+		r = radeon_uvd_validate_codec(p, msg[4]);</span>
<span class="p_add">+		if (!r)</span>
<span class="p_add">+			r = radeon_uvd_cs_msg_decode(msg, buf_sizes);</span>
 		radeon_bo_kunmap(bo);
 		if (r)
 			return r;
 
<span class="p_del">-	} else if (msg_type == 2) {</span>
<span class="p_add">+		/* validate the handle */</span>
<span class="p_add">+		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_add">+			if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle) {</span>
<span class="p_add">+				if (p-&gt;rdev-&gt;uvd.filp[i] != p-&gt;filp) {</span>
<span class="p_add">+					DRM_ERROR(&quot;UVD handle collision detected!\n&quot;);</span>
<span class="p_add">+					return -EINVAL;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_ERROR(&quot;Invalid UVD handle 0x%x!\n&quot;, handle);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 2:</span>
 		/* it&#39;s a destroy msg, free the handle */
 		for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i)
 			atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], handle, 0);
 		radeon_bo_kunmap(bo);
 		return 0;
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* it&#39;s a create msg, calc image size (width * height) */</span>
<span class="p_del">-		img_size = msg[7] * msg[8];</span>
<span class="p_del">-		radeon_bo_kunmap(bo);</span>
 
<span class="p_del">-		if (msg_type != 0) {</span>
<span class="p_del">-			DRM_ERROR(&quot;Illegal UVD message type (%d)!\n&quot;, msg_type);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* it&#39;s a create msg, no special handling needed */</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* create or decode, validate the handle */</span>
<span class="p_del">-	for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_del">-		if (atomic_read(&amp;p-&gt;rdev-&gt;uvd.handles[i]) == handle)</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	default:</span>
 
<span class="p_del">-	/* handle not found try to alloc a new one */</span>
<span class="p_del">-	for (i = 0; i &lt; RADEON_MAX_UVD_HANDLES; ++i) {</span>
<span class="p_del">-		if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;uvd.handles[i], 0, handle)) {</span>
<span class="p_del">-			p-&gt;rdev-&gt;uvd.filp[i] = p-&gt;filp;</span>
<span class="p_del">-			p-&gt;rdev-&gt;uvd.img_size[i] = img_size;</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		DRM_ERROR(&quot;Illegal UVD message type (%d)!\n&quot;, msg_type);</span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
<span class="p_del">-	DRM_ERROR(&quot;No more free UVD handles!\n&quot;);</span>
<span class="p_add">+	BUG();</span>
 	return -EINVAL;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vce.c b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">index 976fe43..7ed5612 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vce.c</span>
<span class="p_chunk">@@ -493,18 +493,27 @@</span> <span class="p_context"> int radeon_vce_cs_reloc(struct radeon_cs_parser *p, int lo, int hi,</span>
  *
  * @p: parser context
  * @handle: handle to validate
<span class="p_add">+ * @allocated: allocated a new handle?</span>
  *
  * Validates the handle and return the found session index or -EINVAL
  * we we don&#39;t have another free session index.
  */
<span class="p_del">-int radeon_vce_validate_handle(struct radeon_cs_parser *p, uint32_t handle)</span>
<span class="p_add">+static int radeon_vce_validate_handle(struct radeon_cs_parser *p,</span>
<span class="p_add">+				      uint32_t handle, bool *allocated)</span>
 {
 	unsigned i;
 
<span class="p_add">+	*allocated = false;</span>
<span class="p_add">+</span>
 	/* validate the handle */
 	for (i = 0; i &lt; RADEON_MAX_VCE_HANDLES; ++i) {
<span class="p_del">-		if (atomic_read(&amp;p-&gt;rdev-&gt;vce.handles[i]) == handle)</span>
<span class="p_add">+		if (atomic_read(&amp;p-&gt;rdev-&gt;vce.handles[i]) == handle) {</span>
<span class="p_add">+			if (p-&gt;rdev-&gt;vce.filp[i] != p-&gt;filp) {</span>
<span class="p_add">+				DRM_ERROR(&quot;VCE handle collision detected!\n&quot;);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
 			return i;
<span class="p_add">+		}</span>
 	}
 
 	/* handle not found try to alloc a new one */
<span class="p_chunk">@@ -512,6 +521,7 @@</span> <span class="p_context"> int radeon_vce_validate_handle(struct radeon_cs_parser *p, uint32_t handle)</span>
 		if (!atomic_cmpxchg(&amp;p-&gt;rdev-&gt;vce.handles[i], 0, handle)) {
 			p-&gt;rdev-&gt;vce.filp[i] = p-&gt;filp;
 			p-&gt;rdev-&gt;vce.img_size[i] = 0;
<span class="p_add">+			*allocated = true;</span>
 			return i;
 		}
 	}
<span class="p_chunk">@@ -529,10 +539,10 @@</span> <span class="p_context"> int radeon_vce_validate_handle(struct radeon_cs_parser *p, uint32_t handle)</span>
 int radeon_vce_cs_parse(struct radeon_cs_parser *p)
 {
 	int session_idx = -1;
<span class="p_del">-	bool destroyed = false;</span>
<span class="p_add">+	bool destroyed = false, created = false, allocated = false;</span>
 	uint32_t tmp, handle = 0;
 	uint32_t *size = &amp;tmp;
<span class="p_del">-	int i, r;</span>
<span class="p_add">+	int i, r = 0;</span>
 
 	while (p-&gt;idx &lt; p-&gt;chunk_ib-&gt;length_dw) {
 		uint32_t len = radeon_get_ib_value(p, p-&gt;idx);
<span class="p_chunk">@@ -540,18 +550,21 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 
 		if ((len &lt; 8) || (len &amp; 3)) {
 			DRM_ERROR(&quot;invalid VCE command length (%d)!\n&quot;, len);
<span class="p_del">-                	return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		if (destroyed) {
 			DRM_ERROR(&quot;No other command allowed after destroy!\n&quot;);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		switch (cmd) {
 		case 0x00000001: // session
 			handle = radeon_get_ib_value(p, p-&gt;idx + 2);
<span class="p_del">-			session_idx = radeon_vce_validate_handle(p, handle);</span>
<span class="p_add">+			session_idx = radeon_vce_validate_handle(p, handle,</span>
<span class="p_add">+								 &amp;allocated);</span>
 			if (session_idx &lt; 0)
 				return session_idx;
 			size = &amp;p-&gt;rdev-&gt;vce.img_size[session_idx];
<span class="p_chunk">@@ -561,6 +574,13 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			break;
 
 		case 0x01000001: // create
<span class="p_add">+			created = true;</span>
<span class="p_add">+			if (!allocated) {</span>
<span class="p_add">+				DRM_ERROR(&quot;Handle already in use!\n&quot;);</span>
<span class="p_add">+				r = -EINVAL;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			*size = radeon_get_ib_value(p, p-&gt;idx + 8) *
 				radeon_get_ib_value(p, p-&gt;idx + 10) *
 				8 * 3 / 2;
<span class="p_chunk">@@ -577,12 +597,12 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 10, p-&gt;idx + 9,
 						*size);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 12, p-&gt;idx + 11,
 						*size / 3);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		case 0x02000001: // destroy
<span class="p_chunk">@@ -593,7 +613,7 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 3, p-&gt;idx + 2,
 						*size * 2);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		case 0x05000004: // video bitstream buffer
<span class="p_chunk">@@ -601,36 +621,47 @@</span> <span class="p_context"> int radeon_vce_cs_parse(struct radeon_cs_parser *p)</span>
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 3, p-&gt;idx + 2,
 						tmp);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		case 0x05000005: // feedback buffer
 			r = radeon_vce_cs_reloc(p, p-&gt;idx + 3, p-&gt;idx + 2,
 						4096);
 			if (r)
<span class="p_del">-				return r;</span>
<span class="p_add">+				goto out;</span>
 			break;
 
 		default:
 			DRM_ERROR(&quot;invalid VCE command (0x%x)!\n&quot;, cmd);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		if (session_idx == -1) {
 			DRM_ERROR(&quot;no session command at start of IB\n&quot;);
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			r = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
 
 		p-&gt;idx += len / 4;
 	}
 
<span class="p_del">-	if (destroyed) {</span>
<span class="p_del">-		/* IB contains a destroy msg, free the handle */</span>
<span class="p_add">+	if (allocated &amp;&amp; !created) {</span>
<span class="p_add">+		DRM_ERROR(&quot;New session without create command!\n&quot;);</span>
<span class="p_add">+		r = -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	if ((!r &amp;&amp; destroyed) || (r &amp;&amp; allocated)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * IB contains a destroy msg or we have allocated an</span>
<span class="p_add">+		 * handle and got an error, anyway free the handle</span>
<span class="p_add">+		 */</span>
 		for (i = 0; i &lt; RADEON_MAX_VCE_HANDLES; ++i)
 			atomic_cmpxchg(&amp;p-&gt;rdev-&gt;vce.handles[i], handle, 0);
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return r;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_vm.c b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">index 2a5a4a9..de42fc4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_vm.c</span>
<span class="p_chunk">@@ -473,6 +473,23 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 	}
 
 	mutex_lock(&amp;vm-&gt;mutex);
<span class="p_add">+	soffset /= RADEON_GPU_PAGE_SIZE;</span>
<span class="p_add">+	eoffset /= RADEON_GPU_PAGE_SIZE;</span>
<span class="p_add">+	if (soffset || eoffset) {</span>
<span class="p_add">+		struct interval_tree_node *it;</span>
<span class="p_add">+		it = interval_tree_iter_first(&amp;vm-&gt;va, soffset, eoffset - 1);</span>
<span class="p_add">+		if (it &amp;&amp; it != &amp;bo_va-&gt;it) {</span>
<span class="p_add">+			struct radeon_bo_va *tmp;</span>
<span class="p_add">+			tmp = container_of(it, struct radeon_bo_va, it);</span>
<span class="p_add">+			/* bo and tmp overlap, invalid offset */</span>
<span class="p_add">+			dev_err(rdev-&gt;dev, &quot;bo %p va 0x%010Lx conflict with &quot;</span>
<span class="p_add">+				&quot;(bo %p 0x%010lx 0x%010lx)\n&quot;, bo_va-&gt;bo,</span>
<span class="p_add">+				soffset, tmp-&gt;bo, tmp-&gt;it.start, tmp-&gt;it.last);</span>
<span class="p_add">+			mutex_unlock(&amp;vm-&gt;mutex);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (bo_va-&gt;it.start || bo_va-&gt;it.last) {
 		if (bo_va-&gt;addr) {
 			/* add a clone of the bo_va to clear the old address */
<span class="p_chunk">@@ -490,6 +507,8 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 			spin_lock(&amp;vm-&gt;status_lock);
 			list_add(&amp;tmp-&gt;vm_status, &amp;vm-&gt;freed);
 			spin_unlock(&amp;vm-&gt;status_lock);
<span class="p_add">+</span>
<span class="p_add">+			bo_va-&gt;addr = 0;</span>
 		}
 
 		interval_tree_remove(&amp;bo_va-&gt;it, &amp;vm-&gt;va);
<span class="p_chunk">@@ -497,21 +516,7 @@</span> <span class="p_context"> int radeon_vm_bo_set_addr(struct radeon_device *rdev,</span>
 		bo_va-&gt;it.last = 0;
 	}
 
<span class="p_del">-	soffset /= RADEON_GPU_PAGE_SIZE;</span>
<span class="p_del">-	eoffset /= RADEON_GPU_PAGE_SIZE;</span>
 	if (soffset || eoffset) {
<span class="p_del">-		struct interval_tree_node *it;</span>
<span class="p_del">-		it = interval_tree_iter_first(&amp;vm-&gt;va, soffset, eoffset - 1);</span>
<span class="p_del">-		if (it) {</span>
<span class="p_del">-			struct radeon_bo_va *tmp;</span>
<span class="p_del">-			tmp = container_of(it, struct radeon_bo_va, it);</span>
<span class="p_del">-			/* bo and tmp overlap, invalid offset */</span>
<span class="p_del">-			dev_err(rdev-&gt;dev, &quot;bo %p va 0x%010Lx conflict with &quot;</span>
<span class="p_del">-				&quot;(bo %p 0x%010lx 0x%010lx)\n&quot;, bo_va-&gt;bo,</span>
<span class="p_del">-				soffset, tmp-&gt;bo, tmp-&gt;it.start, tmp-&gt;it.last);</span>
<span class="p_del">-			mutex_unlock(&amp;vm-&gt;mutex);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-		}</span>
 		bo_va-&gt;it.start = soffset;
 		bo_va-&gt;it.last = eoffset - 1;
 		interval_tree_insert(&amp;bo_va-&gt;it, &amp;vm-&gt;va);
<span class="p_chunk">@@ -1107,7 +1112,8 @@</span> <span class="p_context"> void radeon_vm_bo_rmv(struct radeon_device *rdev,</span>
 	list_del(&amp;bo_va-&gt;bo_list);
 
 	mutex_lock(&amp;vm-&gt;mutex);
<span class="p_del">-	interval_tree_remove(&amp;bo_va-&gt;it, &amp;vm-&gt;va);</span>
<span class="p_add">+	if (bo_va-&gt;it.start || bo_va-&gt;it.last)</span>
<span class="p_add">+		interval_tree_remove(&amp;bo_va-&gt;it, &amp;vm-&gt;va);</span>
 	spin_lock(&amp;vm-&gt;status_lock);
 	list_del(&amp;bo_va-&gt;vm_status);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/rv770d.h b/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_header">index 3cf1e29..9ef2064 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/rv770d.h</span>
<span class="p_chunk">@@ -989,6 +989,9 @@</span> <span class="p_context"></span>
 			 ((n) &amp; 0x3FFF) &lt;&lt; 16)
 
 /* UVD */
<span class="p_add">+#define UVD_SEMA_ADDR_LOW				0xef00</span>
<span class="p_add">+#define UVD_SEMA_ADDR_HIGH				0xef04</span>
<span class="p_add">+#define UVD_SEMA_CMD					0xef08</span>
 #define UVD_GPCOM_VCPU_CMD				0xef0c
 #define UVD_GPCOM_VCPU_DATA0				0xef10
 #define UVD_GPCOM_VCPU_DATA1				0xef14
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index eff8a64..50313d7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2921,6 +2921,7 @@</span> <span class="p_context"> struct si_dpm_quirk {</span>
 static struct si_dpm_quirk si_dpm_quirk_list[] = {
 	/* PITCAIRN - https://bugs.freedesktop.org/show_bug.cgi?id=76490 */
 	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1462, 0x3036, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0xe271, 0, 120000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/uvd_v1_0.c b/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_header">index e72b3cb..c6b1cbc 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/uvd_v1_0.c</span>
<span class="p_chunk">@@ -466,18 +466,8 @@</span> <span class="p_context"> bool uvd_v1_0_semaphore_emit(struct radeon_device *rdev,</span>
 			     struct radeon_semaphore *semaphore,
 			     bool emit_wait)
 {
<span class="p_del">-	uint64_t addr = semaphore-&gt;gpu_addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_LOW, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_HIGH, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_del">-</span>
<span class="p_del">-	radeon_ring_write(ring, PACKET0(UVD_SEMA_CMD, 0));</span>
<span class="p_del">-	radeon_ring_write(ring, emit_wait ? 1 : 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	return true;</span>
<span class="p_add">+	/* disable semaphores for UVD V1 hardware */</span>
<span class="p_add">+	return false;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/uvd_v2_2.c b/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_header">index 8919351..7ed778c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/uvd_v2_2.c</span>
<span class="p_chunk">@@ -60,6 +60,35 @@</span> <span class="p_context"> void uvd_v2_2_fence_emit(struct radeon_device *rdev,</span>
 }
 
 /**
<span class="p_add">+ * uvd_v2_2_semaphore_emit - emit semaphore command</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @rdev: radeon_device pointer</span>
<span class="p_add">+ * @ring: radeon_ring pointer</span>
<span class="p_add">+ * @semaphore: semaphore to emit commands for</span>
<span class="p_add">+ * @emit_wait: true if we should emit a wait command</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Emit a semaphore command (either wait or signal) to the UVD ring.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool uvd_v2_2_semaphore_emit(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring,</span>
<span class="p_add">+			     struct radeon_semaphore *semaphore,</span>
<span class="p_add">+			     bool emit_wait)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint64_t addr = semaphore-&gt;gpu_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_LOW, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, (addr &gt;&gt; 3) &amp; 0x000FFFFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_ADDR_HIGH, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, (addr &gt;&gt; 23) &amp; 0x000FFFFF);</span>
<span class="p_add">+</span>
<span class="p_add">+	radeon_ring_write(ring, PACKET0(UVD_SEMA_CMD, 0));</span>
<span class="p_add">+	radeon_ring_write(ring, emit_wait ? 1 : 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * uvd_v2_2_resume - memory controller programming
  *
  * @rdev: radeon_device pointer
<span class="p_header">diff --git a/drivers/infiniband/core/cma.c b/drivers/infiniband/core/cma.c</span>
<span class="p_header">index d570030..06441a4 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cma.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cma.c</span>
<span class="p_chunk">@@ -859,19 +859,27 @@</span> <span class="p_context"> static void cma_save_ib_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id</span>
 	memcpy(&amp;ib-&gt;sib_addr, &amp;path-&gt;dgid, 16);
 }
 
<span class="p_add">+static __be16 ss_get_port(const struct sockaddr_storage *ss)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ss-&gt;ss_family == AF_INET)</span>
<span class="p_add">+		return ((struct sockaddr_in *)ss)-&gt;sin_port;</span>
<span class="p_add">+	else if (ss-&gt;ss_family == AF_INET6)</span>
<span class="p_add">+		return ((struct sockaddr_in6 *)ss)-&gt;sin6_port;</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cma_save_ip4_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id,
 			      struct cma_hdr *hdr)
 {
<span class="p_del">-	struct sockaddr_in *listen4, *ip4;</span>
<span class="p_add">+	struct sockaddr_in *ip4;</span>
 
<span class="p_del">-	listen4 = (struct sockaddr_in *) &amp;listen_id-&gt;route.addr.src_addr;</span>
 	ip4 = (struct sockaddr_in *) &amp;id-&gt;route.addr.src_addr;
<span class="p_del">-	ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+	ip4-&gt;sin_family = AF_INET;</span>
 	ip4-&gt;sin_addr.s_addr = hdr-&gt;dst_addr.ip4.addr;
<span class="p_del">-	ip4-&gt;sin_port = listen4-&gt;sin_port;</span>
<span class="p_add">+	ip4-&gt;sin_port = ss_get_port(&amp;listen_id-&gt;route.addr.src_addr);</span>
 
 	ip4 = (struct sockaddr_in *) &amp;id-&gt;route.addr.dst_addr;
<span class="p_del">-	ip4-&gt;sin_family = listen4-&gt;sin_family;</span>
<span class="p_add">+	ip4-&gt;sin_family = AF_INET;</span>
 	ip4-&gt;sin_addr.s_addr = hdr-&gt;src_addr.ip4.addr;
 	ip4-&gt;sin_port = hdr-&gt;port;
 }
<span class="p_chunk">@@ -879,16 +887,15 @@</span> <span class="p_context"> static void cma_save_ip4_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_i</span>
 static void cma_save_ip6_info(struct rdma_cm_id *id, struct rdma_cm_id *listen_id,
 			      struct cma_hdr *hdr)
 {
<span class="p_del">-	struct sockaddr_in6 *listen6, *ip6;</span>
<span class="p_add">+	struct sockaddr_in6 *ip6;</span>
 
<span class="p_del">-	listen6 = (struct sockaddr_in6 *) &amp;listen_id-&gt;route.addr.src_addr;</span>
 	ip6 = (struct sockaddr_in6 *) &amp;id-&gt;route.addr.src_addr;
<span class="p_del">-	ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+	ip6-&gt;sin6_family = AF_INET6;</span>
 	ip6-&gt;sin6_addr = hdr-&gt;dst_addr.ip6;
<span class="p_del">-	ip6-&gt;sin6_port = listen6-&gt;sin6_port;</span>
<span class="p_add">+	ip6-&gt;sin6_port = ss_get_port(&amp;listen_id-&gt;route.addr.src_addr);</span>
 
 	ip6 = (struct sockaddr_in6 *) &amp;id-&gt;route.addr.dst_addr;
<span class="p_del">-	ip6-&gt;sin6_family = listen6-&gt;sin6_family;</span>
<span class="p_add">+	ip6-&gt;sin6_family = AF_INET6;</span>
 	ip6-&gt;sin6_addr = hdr-&gt;src_addr.ip6;
 	ip6-&gt;sin6_port = hdr-&gt;port;
 }
<span class="p_header">diff --git a/drivers/md/dm-crypt.c b/drivers/md/dm-crypt.c</span>
<span class="p_header">index a9f2266..08981be 100644</span>
<span class="p_header">--- a/drivers/md/dm-crypt.c</span>
<span class="p_header">+++ b/drivers/md/dm-crypt.c</span>
<span class="p_chunk">@@ -920,10 +920,11 @@</span> <span class="p_context"> static int crypt_convert(struct crypt_config *cc,</span>
 
 		switch (r) {
 		/* async */
<span class="p_del">-		case -EINPROGRESS:</span>
 		case -EBUSY:
 			wait_for_completion(&amp;ctx-&gt;restart);
 			reinit_completion(&amp;ctx-&gt;restart);
<span class="p_add">+			/* fall through*/</span>
<span class="p_add">+		case -EINPROGRESS:</span>
 			ctx-&gt;req = NULL;
 			ctx-&gt;cc_sector++;
 			continue;
<span class="p_chunk">@@ -1314,8 +1315,10 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	struct dm_crypt_io *io = container_of(ctx, struct dm_crypt_io, ctx);
 	struct crypt_config *cc = io-&gt;cc;
 
<span class="p_del">-	if (error == -EINPROGRESS)</span>
<span class="p_add">+	if (error == -EINPROGRESS) {</span>
<span class="p_add">+		complete(&amp;ctx-&gt;restart);</span>
 		return;
<span class="p_add">+	}</span>
 
 	if (!error &amp;&amp; cc-&gt;iv_gen_ops &amp;&amp; cc-&gt;iv_gen_ops-&gt;post)
 		error = cc-&gt;iv_gen_ops-&gt;post(cc, iv_of_dmreq(cc, dmreq), dmreq);
<span class="p_chunk">@@ -1326,15 +1329,12 @@</span> <span class="p_context"> static void kcryptd_async_done(struct crypto_async_request *async_req,</span>
 	crypt_free_req(cc, req_of_dmreq(cc, dmreq), io-&gt;base_bio);
 
 	if (!atomic_dec_and_test(&amp;ctx-&gt;cc_pending))
<span class="p_del">-		goto done;</span>
<span class="p_add">+		return;</span>
 
 	if (bio_data_dir(io-&gt;base_bio) == READ)
 		kcryptd_crypt_read_done(io);
 	else
 		kcryptd_crypt_write_io_submit(io, 1);
<span class="p_del">-done:</span>
<span class="p_del">-	if (!completion_done(&amp;ctx-&gt;restart))</span>
<span class="p_del">-		complete(&amp;ctx-&gt;restart);</span>
 }
 
 static void kcryptd_crypt(struct work_struct *work)
<span class="p_header">diff --git a/drivers/md/raid0.c b/drivers/md/raid0.c</span>
<span class="p_header">index d5c12e5..b974ff2 100644</span>
<span class="p_header">--- a/drivers/md/raid0.c</span>
<span class="p_header">+++ b/drivers/md/raid0.c</span>
<span class="p_chunk">@@ -530,6 +530,9 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			 ? (sector &amp; (chunk_sects-1))
 			 : sector_div(sector, chunk_sects));
 
<span class="p_add">+		/* Restore due to sector_div */</span>
<span class="p_add">+		sector = bio-&gt;bi_iter.bi_sector;</span>
<span class="p_add">+</span>
 		if (sectors &lt; bio_sectors(bio)) {
 			split = bio_split(bio, sectors, GFP_NOIO, fs_bio_set);
 			bio_chain(split, bio);
<span class="p_chunk">@@ -537,7 +540,6 @@</span> <span class="p_context"> static void raid0_make_request(struct mddev *mddev, struct bio *bio)</span>
 			split = bio;
 		}
 
<span class="p_del">-		sector = bio-&gt;bi_iter.bi_sector;</span>
 		zone = find_zone(mddev-&gt;private, &amp;sector);
 		tmp_dev = map_sector(mddev, zone, sector, &amp;sector);
 		split-&gt;bi_bdev = tmp_dev-&gt;bdev;
<span class="p_header">diff --git a/drivers/media/platform/marvell-ccic/mcam-core.c b/drivers/media/platform/marvell-ccic/mcam-core.c</span>
<span class="p_header">index 193373f..6e439ef 100644</span>
<span class="p_header">--- a/drivers/media/platform/marvell-ccic/mcam-core.c</span>
<span class="p_header">+++ b/drivers/media/platform/marvell-ccic/mcam-core.c</span>
<span class="p_chunk">@@ -116,8 +116,8 @@</span> <span class="p_context"> static struct mcam_format_struct {</span>
 		.planar		= false,
 	},
 	{
<span class="p_del">-		.desc		= &quot;UYVY 4:2:2&quot;,</span>
<span class="p_del">-		.pixelformat	= V4L2_PIX_FMT_UYVY,</span>
<span class="p_add">+		.desc		= &quot;YVYU 4:2:2&quot;,</span>
<span class="p_add">+		.pixelformat	= V4L2_PIX_FMT_YVYU,</span>
 		.mbus_code	= MEDIA_BUS_FMT_YUYV8_2X8,
 		.bpp		= 2,
 		.planar		= false,
<span class="p_chunk">@@ -748,7 +748,7 @@</span> <span class="p_context"> static void mcam_ctlr_image(struct mcam_camera *cam)</span>
 
 	switch (fmt-&gt;pixelformat) {
 	case V4L2_PIX_FMT_YUYV:
<span class="p_del">-	case V4L2_PIX_FMT_UYVY:</span>
<span class="p_add">+	case V4L2_PIX_FMT_YVYU:</span>
 		widthy = fmt-&gt;width * 2;
 		widthuv = 0;
 		break;
<span class="p_chunk">@@ -784,15 +784,15 @@</span> <span class="p_context"> static void mcam_ctlr_image(struct mcam_camera *cam)</span>
 	case V4L2_PIX_FMT_YUV420:
 	case V4L2_PIX_FMT_YVU420:
 		mcam_reg_write_mask(cam, REG_CTRL0,
<span class="p_del">-			C0_DF_YUV | C0_YUV_420PL | C0_YUVE_YVYU, C0_DF_MASK);</span>
<span class="p_add">+			C0_DF_YUV | C0_YUV_420PL | C0_YUVE_VYUY, C0_DF_MASK);</span>
 		break;
 	case V4L2_PIX_FMT_YUYV:
 		mcam_reg_write_mask(cam, REG_CTRL0,
<span class="p_del">-			C0_DF_YUV | C0_YUV_PACKED | C0_YUVE_UYVY, C0_DF_MASK);</span>
<span class="p_add">+			C0_DF_YUV | C0_YUV_PACKED | C0_YUVE_NOSWAP, C0_DF_MASK);</span>
 		break;
<span class="p_del">-	case V4L2_PIX_FMT_UYVY:</span>
<span class="p_add">+	case V4L2_PIX_FMT_YVYU:</span>
 		mcam_reg_write_mask(cam, REG_CTRL0,
<span class="p_del">-			C0_DF_YUV | C0_YUV_PACKED | C0_YUVE_YUYV, C0_DF_MASK);</span>
<span class="p_add">+			C0_DF_YUV | C0_YUV_PACKED | C0_YUVE_SWAP24, C0_DF_MASK);</span>
 		break;
 	case V4L2_PIX_FMT_JPEG:
 		mcam_reg_write_mask(cam, REG_CTRL0,
<span class="p_header">diff --git a/drivers/media/platform/marvell-ccic/mcam-core.h b/drivers/media/platform/marvell-ccic/mcam-core.h</span>
<span class="p_header">index aa0c6ea..7ffdf4d 100644</span>
<span class="p_header">--- a/drivers/media/platform/marvell-ccic/mcam-core.h</span>
<span class="p_header">+++ b/drivers/media/platform/marvell-ccic/mcam-core.h</span>
<span class="p_chunk">@@ -330,10 +330,10 @@</span> <span class="p_context"> int mccic_resume(struct mcam_camera *cam);</span>
 #define	  C0_YUVE_YVYU	  0x00010000	/* Y1CrY0Cb		*/
 #define	  C0_YUVE_VYUY	  0x00020000	/* CrY1CbY0		*/
 #define	  C0_YUVE_UYVY	  0x00030000	/* CbY1CrY0		*/
<span class="p_del">-#define	  C0_YUVE_XYUV	  0x00000000	/* 420: .YUV		*/</span>
<span class="p_del">-#define	  C0_YUVE_XYVU	  0x00010000	/* 420: .YVU		*/</span>
<span class="p_del">-#define	  C0_YUVE_XUVY	  0x00020000	/* 420: .UVY		*/</span>
<span class="p_del">-#define	  C0_YUVE_XVUY	  0x00030000	/* 420: .VUY		*/</span>
<span class="p_add">+#define	  C0_YUVE_NOSWAP  0x00000000	/* no bytes swapping	*/</span>
<span class="p_add">+#define	  C0_YUVE_SWAP13  0x00010000	/* swap byte 1 and 3	*/</span>
<span class="p_add">+#define	  C0_YUVE_SWAP24  0x00020000	/* swap byte 2 and 4	*/</span>
<span class="p_add">+#define	  C0_YUVE_SWAP1324 0x00030000	/* swap bytes 1&amp;3 and 2&amp;4 */</span>
 /* Bayer bits 18,19 if needed */
 #define	  C0_EOF_VSYNC	  0x00400000	/* Generate EOF by VSYNC */
 #define	  C0_VEDGE_CTRL   0x00800000	/* Detect falling edge of VSYNC */
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 4409d79..4e5d36a 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1029,6 +1029,18 @@</span> <span class="p_context"> static inline void mmc_blk_reset_success(struct mmc_blk_data *md, int type)</span>
 	md-&gt;reset_done &amp;= ~type;
 }
 
<span class="p_add">+int mmc_access_rpmb(struct mmc_queue *mq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mmc_blk_data *md = mq-&gt;data;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If this is a RPMB partition access, return ture</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (md &amp;&amp; md-&gt;part_type == EXT_CSD_PART_CONFIG_ACC_RPMB)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mmc_blk_issue_discard_rq(struct mmc_queue *mq, struct request *req)
 {
 	struct mmc_blk_data *md = mq-&gt;data;
<span class="p_header">diff --git a/drivers/mmc/card/queue.c b/drivers/mmc/card/queue.c</span>
<span class="p_header">index 236d194..8efa368 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.c</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.c</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static int mmc_prep_request(struct request_queue *q, struct request *req)</span>
 		return BLKPREP_KILL;
 	}
 
<span class="p_del">-	if (mq &amp;&amp; mmc_card_removed(mq-&gt;card))</span>
<span class="p_add">+	if (mq &amp;&amp; (mmc_card_removed(mq-&gt;card) || mmc_access_rpmb(mq)))</span>
 		return BLKPREP_KILL;
 
 	req-&gt;cmd_flags |= REQ_DONTPREP;
<span class="p_header">diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h</span>
<span class="p_header">index 5752d50..99e6521 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.h</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.h</span>
<span class="p_chunk">@@ -73,4 +73,6 @@</span> <span class="p_context"> extern void mmc_queue_bounce_post(struct mmc_queue_req *);</span>
 extern int mmc_packed_init(struct mmc_queue *, struct mmc_card *);
 extern void mmc_packed_clean(struct mmc_queue *);
 
<span class="p_add">+extern int mmc_access_rpmb(struct mmc_queue *);</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 9584bff..113aaec 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -2620,6 +2620,7 @@</span> <span class="p_context"> int mmc_pm_notify(struct notifier_block *notify_block,</span>
 	switch (mode) {
 	case PM_HIBERNATION_PREPARE:
 	case PM_SUSPEND_PREPARE:
<span class="p_add">+	case PM_RESTORE_PREPARE:</span>
 		spin_lock_irqsave(&amp;host-&gt;lock, flags);
 		host-&gt;rescan_disable = 1;
 		spin_unlock_irqrestore(&amp;host-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/mmc/host/sh_mmcif.c b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">index 7d9d6a3..5165ae7 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sh_mmcif.c</span>
<span class="p_chunk">@@ -1402,7 +1402,7 @@</span> <span class="p_context"> static int sh_mmcif_probe(struct platform_device *pdev)</span>
 	host		= mmc_priv(mmc);
 	host-&gt;mmc	= mmc;
 	host-&gt;addr	= reg;
<span class="p_del">-	host-&gt;timeout	= msecs_to_jiffies(1000);</span>
<span class="p_add">+	host-&gt;timeout	= msecs_to_jiffies(10000);</span>
 	host-&gt;ccs_enable = !pd || !pd-&gt;ccs_unsupported;
 	host-&gt;clk_ctrl2_enable = pd &amp;&amp; pd-&gt;clk_ctrl2_present;
 
<span class="p_header">diff --git a/drivers/pinctrl/core.c b/drivers/pinctrl/core.c</span>
<span class="p_header">index 89dca77..18ee208 100644</span>
<span class="p_header">--- a/drivers/pinctrl/core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/core.c</span>
<span class="p_chunk">@@ -1110,7 +1110,7 @@</span> <span class="p_context"> void devm_pinctrl_put(struct pinctrl *p)</span>
 EXPORT_SYMBOL_GPL(devm_pinctrl_put);
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
<span class="p_del">-			 bool dup, bool locked)</span>
<span class="p_add">+			 bool dup)</span>
 {
 	int i, ret;
 	struct pinctrl_maps *maps_node;
<span class="p_chunk">@@ -1178,11 +1178,9 @@</span> <span class="p_context"> int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,</span>
 		maps_node-&gt;maps = maps;
 	}
 
<span class="p_del">-	if (!locked)</span>
<span class="p_del">-		mutex_lock(&amp;pinctrl_maps_mutex);</span>
<span class="p_add">+	mutex_lock(&amp;pinctrl_maps_mutex);</span>
 	list_add_tail(&amp;maps_node-&gt;node, &amp;pinctrl_maps);
<span class="p_del">-	if (!locked)</span>
<span class="p_del">-		mutex_unlock(&amp;pinctrl_maps_mutex);</span>
<span class="p_add">+	mutex_unlock(&amp;pinctrl_maps_mutex);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1197,7 +1195,7 @@</span> <span class="p_context"> int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,</span>
 int pinctrl_register_mappings(struct pinctrl_map const *maps,
 			      unsigned num_maps)
 {
<span class="p_del">-	return pinctrl_register_map(maps, num_maps, true, false);</span>
<span class="p_add">+	return pinctrl_register_map(maps, num_maps, true);</span>
 }
 
 void pinctrl_unregister_map(struct pinctrl_map const *map)
<span class="p_header">diff --git a/drivers/pinctrl/core.h b/drivers/pinctrl/core.h</span>
<span class="p_header">index 75476b3..b24ea84 100644</span>
<span class="p_header">--- a/drivers/pinctrl/core.h</span>
<span class="p_header">+++ b/drivers/pinctrl/core.h</span>
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> static inline struct pin_desc *pin_desc_get(struct pinctrl_dev *pctldev,</span>
 }
 
 int pinctrl_register_map(struct pinctrl_map const *maps, unsigned num_maps,
<span class="p_del">-			 bool dup, bool locked);</span>
<span class="p_add">+			 bool dup);</span>
 void pinctrl_unregister_map(struct pinctrl_map const *map);
 
 extern int pinctrl_force_sleep(struct pinctrl_dev *pctldev);
<span class="p_header">diff --git a/drivers/pinctrl/devicetree.c b/drivers/pinctrl/devicetree.c</span>
<span class="p_header">index eda13de..0bbf7d7 100644</span>
<span class="p_header">--- a/drivers/pinctrl/devicetree.c</span>
<span class="p_header">+++ b/drivers/pinctrl/devicetree.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static int dt_remember_or_free_map(struct pinctrl *p, const char *statename,</span>
 	dt_map-&gt;num_maps = num_maps;
 	list_add_tail(&amp;dt_map-&gt;node, &amp;p-&gt;dt_maps);
 
<span class="p_del">-	return pinctrl_register_map(map, num_maps, false, true);</span>
<span class="p_add">+	return pinctrl_register_map(map, num_maps, false);</span>
 }
 
 struct pinctrl_dev *of_pinctrl_get(struct device_node *np)
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.c b/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">index cd4129f..1f9e8d2 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.c</span>
<span class="p_chunk">@@ -149,7 +149,6 @@</span> <span class="p_context"> static int twa_reset_sequence(TW_Device_Extension *tw_dev, int soft_reset);</span>
 static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry *sglistarg);
 static void twa_scsiop_execute_scsi_complete(TW_Device_Extension *tw_dev, int request_id);
 static char *twa_string_lookup(twa_message_type *table, unsigned int aen_code);
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id);</span>
 
 /* Functions */
 
<span class="p_chunk">@@ -1339,11 +1338,11 @@</span> <span class="p_context"> static irqreturn_t twa_interrupt(int irq, void *dev_instance)</span>
 				}
 
 				/* Now complete the io */
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 				tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 				twa_free_request_id(tw_dev, request_id);
 				tw_dev-&gt;posted_request_count--;
<span class="p_del">-				tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, request_id);</span>
 			}
 
 			/* Check for valid status after each drain */
<span class="p_chunk">@@ -1401,26 +1400,6 @@</span> <span class="p_context"> static void twa_load_sgl(TW_Device_Extension *tw_dev, TW_Command_Full *full_comm</span>
 	}
 } /* End twa_load_sgl() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twa_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1c, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twa_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function will poll for a response interrupt of a request */
 static int twa_poll_response(TW_Device_Extension *tw_dev, int request_id, int seconds)
 {
<span class="p_chunk">@@ -1599,9 +1578,11 @@</span> <span class="p_context"> static int twa_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
 			if (tw_dev-&gt;srb[i]) {
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twa_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+				struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1780,21 +1761,18 @@</span> <span class="p_context"> static int twa_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twa_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	switch (retval) {
 	case SCSI_MLQUEUE_HOST_BUSY:
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		twa_free_request_id(tw_dev, request_id);
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		break;
 	case 1:
<span class="p_del">-		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_del">-		twa_free_request_id(tw_dev, request_id);</span>
<span class="p_del">-		twa_unmap_scsi_data(tw_dev, request_id);</span>
 		SCpnt-&gt;result = (DID_ERROR &lt;&lt; 16);
<span class="p_add">+		scsi_dma_unmap(SCpnt);</span>
 		done(SCpnt);
<span class="p_add">+		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;</span>
<span class="p_add">+		twa_free_request_id(tw_dev, request_id);</span>
 		retval = 0;
 	}
 out:
<span class="p_chunk">@@ -1862,8 +1840,8 @@</span> <span class="p_context"> static int twa_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 				command_packet-&gt;sg_list[0].address = TW_CPU_TO_SGL(tw_dev-&gt;generic_buffer_phys[request_id]);
 				command_packet-&gt;sg_list[0].length = cpu_to_le32(TW_MIN_SGL_LENGTH);
 			} else {
<span class="p_del">-				sg_count = twa_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-				if (sg_count == 0)</span>
<span class="p_add">+				sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+				if (sg_count &lt; 0)</span>
 					goto out;
 
 				scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1978,15 +1956,6 @@</span> <span class="p_context"> static char *twa_string_lookup(twa_message_type *table, unsigned int code)</span>
 	return(table[index].text);
 } /* End twa_string_lookup() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twa_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twa_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function gets called when a disk is coming on-line */
 static int twa_slave_configure(struct scsi_device *sdev)
 {
<span class="p_header">diff --git a/drivers/scsi/3w-9xxx.h b/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">index 040f721..0fdc83c 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-9xxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-9xxx.h</span>
<span class="p_chunk">@@ -324,11 +324,6 @@</span> <span class="p_context"> static twa_message_type twa_error_table[] = {</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE  1</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_9550SX_DRAIN_COMPLETED	      0xFFFF
 #define TW_SECTOR_SIZE                        512
<span class="p_header">diff --git a/drivers/scsi/3w-sas.c b/drivers/scsi/3w-sas.c</span>
<span class="p_header">index 2361772..f837485 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.c</span>
<span class="p_chunk">@@ -290,26 +290,6 @@</span> <span class="p_context"> static int twl_post_command_packet(TW_Device_Extension *tw_dev, int request_id)</span>
 	return 0;
 } /* End twl_post_command_packet() */
 
<span class="p_del">-/* This function will perform a pci-dma mapping for a scatter gather list */</span>
<span class="p_del">-static int twl_map_scsi_sg_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	else if (use_sg &lt; 0) {</span>
<span class="p_del">-		TW_PRINTK(tw_dev-&gt;host, TW_DRIVER, 0x1, &quot;Failed to map scatter gather list&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End twl_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
 /* This function hands scsi cdb&#39;s to the firmware */
 static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id, char *cdb, int use_sg, TW_SG_Entry_ISO *sglistarg)
 {
<span class="p_chunk">@@ -357,8 +337,8 @@</span> <span class="p_context"> static int twl_scsiop_execute_scsi(TW_Device_Extension *tw_dev, int request_id,</span>
 	if (!sglistarg) {
 		/* Map sglist from scsi layer to cmd packet */
 		if (scsi_sg_count(srb)) {
<span class="p_del">-			sg_count = twl_map_scsi_sg_data(tw_dev, request_id);</span>
<span class="p_del">-			if (sg_count == 0)</span>
<span class="p_add">+			sg_count = scsi_dma_map(srb);</span>
<span class="p_add">+			if (sg_count &lt;= 0)</span>
 				goto out;
 
 			scsi_for_each_sg(srb, sg, sg_count, i) {
<span class="p_chunk">@@ -1102,15 +1082,6 @@</span> <span class="p_context"> out:</span>
 	return retval;
 } /* End twl_initialize_device_extension() */
 
<span class="p_del">-/* This function will perform a pci-dma unmap */</span>
<span class="p_del">-static void twl_unmap_scsi_data(TW_Device_Extension *tw_dev, int request_id)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_cmnd *cmd = tw_dev-&gt;srb[request_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End twl_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will handle attention interrupts */
 static int twl_handle_attention_interrupt(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1251,11 +1222,11 @@</span> <span class="p_context"> static irqreturn_t twl_interrupt(int irq, void *dev_instance)</span>
 			}
 
 			/* Now complete the io */
<span class="p_add">+			scsi_dma_unmap(cmd);</span>
<span class="p_add">+			cmd-&gt;scsi_done(cmd);</span>
 			tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 			twl_free_request_id(tw_dev, request_id);
 			tw_dev-&gt;posted_request_count--;
<span class="p_del">-			tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-			twl_unmap_scsi_data(tw_dev, request_id);</span>
 		}
 
 		/* Check for another response interrupt */
<span class="p_chunk">@@ -1400,10 +1371,12 @@</span> <span class="p_context"> static int twl_reset_device_extension(TW_Device_Extension *tw_dev, int ioctl_res</span>
 		if ((tw_dev-&gt;state[i] != TW_S_FINISHED) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_INITIAL) &amp;&amp;
 		    (tw_dev-&gt;state[i] != TW_S_COMPLETED)) {
<span class="p_del">-			if (tw_dev-&gt;srb[i]) {</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				twl_unmap_scsi_data(tw_dev, i);</span>
<span class="p_add">+			struct scsi_cmnd *cmd = tw_dev-&gt;srb[i];</span>
<span class="p_add">+</span>
<span class="p_add">+			if (cmd) {</span>
<span class="p_add">+				cmd-&gt;result = (DID_RESET &lt;&lt; 16);</span>
<span class="p_add">+				scsi_dma_unmap(cmd);</span>
<span class="p_add">+				cmd-&gt;scsi_done(cmd);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1507,9 +1480,6 @@</span> <span class="p_context"> static int twl_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	retval = twl_scsiop_execute_scsi(tw_dev, request_id, NULL, 0, NULL);
 	if (retval) {
 		tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
<span class="p_header">diff --git a/drivers/scsi/3w-sas.h b/drivers/scsi/3w-sas.h</span>
<span class="p_header">index d474892..fec6449 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-sas.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-sas.h</span>
<span class="p_chunk">@@ -103,10 +103,6 @@</span> <span class="p_context"> static char *twl_aen_severity_table[] =</span>
 #define TW_CURRENT_DRIVER_BUILD 0
 #define TW_CURRENT_DRIVER_BRANCH 0
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SGLIST  2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_SECTOR_SIZE                        512
 #define TW_MAX_UNITS			      32
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.c b/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">index c75f204..2940bd7 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.c</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.c</span>
<span class="p_chunk">@@ -1271,32 +1271,6 @@</span> <span class="p_context"> static int tw_initialize_device_extension(TW_Device_Extension *tw_dev)</span>
 	return 0;
 } /* End tw_initialize_device_extension() */
 
<span class="p_del">-static int tw_map_scsi_sg_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	use_sg = scsi_dma_map(cmd);</span>
<span class="p_del">-	if (use_sg &lt; 0) {</span>
<span class="p_del">-		printk(KERN_WARNING &quot;3w-xxxx: tw_map_scsi_sg_data(): pci_map_sg() failed.\n&quot;);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	cmd-&gt;SCp.phase = TW_PHASE_SGLIST;</span>
<span class="p_del">-	cmd-&gt;SCp.have_data_in = use_sg;</span>
<span class="p_del">-</span>
<span class="p_del">-	return use_sg;</span>
<span class="p_del">-} /* End tw_map_scsi_sg_data() */</span>
<span class="p_del">-</span>
<span class="p_del">-static void tw_unmap_scsi_data(struct pci_dev *pdev, struct scsi_cmnd *cmd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	dprintk(KERN_WARNING &quot;3w-xxxx: tw_unmap_scsi_data()\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmd-&gt;SCp.phase == TW_PHASE_SGLIST)</span>
<span class="p_del">-		scsi_dma_unmap(cmd);</span>
<span class="p_del">-} /* End tw_unmap_scsi_data() */</span>
<span class="p_del">-</span>
 /* This function will reset a device extension */
 static int tw_reset_device_extension(TW_Device_Extension *tw_dev)
 {
<span class="p_chunk">@@ -1319,8 +1293,8 @@</span> <span class="p_context"> static int tw_reset_device_extension(TW_Device_Extension *tw_dev)</span>
 			srb = tw_dev-&gt;srb[i];
 			if (srb != NULL) {
 				srb-&gt;result = (DID_RESET &lt;&lt; 16);
<span class="p_del">-				tw_dev-&gt;srb[i]-&gt;scsi_done(tw_dev-&gt;srb[i]);</span>
<span class="p_del">-				tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[i]);</span>
<span class="p_add">+				scsi_dma_unmap(srb);</span>
<span class="p_add">+				srb-&gt;scsi_done(srb);</span>
 			}
 		}
 	}
<span class="p_chunk">@@ -1767,8 +1741,8 @@</span> <span class="p_context"> static int tw_scsiop_read_write(TW_Device_Extension *tw_dev, int request_id)</span>
 	command_packet-&gt;byte8.io.lba = lba;
 	command_packet-&gt;byte6.block_count = num_sectors;
 
<span class="p_del">-	use_sg = tw_map_scsi_sg_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-	if (!use_sg)</span>
<span class="p_add">+	use_sg = scsi_dma_map(srb);</span>
<span class="p_add">+	if (use_sg &lt;= 0)</span>
 		return 1;
 
 	scsi_for_each_sg(tw_dev-&gt;srb[request_id], sg, use_sg, i) {
<span class="p_chunk">@@ -1955,9 +1929,6 @@</span> <span class="p_context"> static int tw_scsi_queue_lck(struct scsi_cmnd *SCpnt, void (*done)(struct scsi_c</span>
 	/* Save the scsi command for use by the ISR */
 	tw_dev-&gt;srb[request_id] = SCpnt;
 
<span class="p_del">-	/* Initialize phase to zero */</span>
<span class="p_del">-	SCpnt-&gt;SCp.phase = TW_PHASE_INITIAL;</span>
<span class="p_del">-</span>
 	switch (*command) {
 		case READ_10:
 		case READ_6:
<span class="p_chunk">@@ -2185,12 +2156,11 @@</span> <span class="p_context"> static irqreturn_t tw_interrupt(int irq, void *dev_instance)</span>
 
 				/* Now complete the io */
 				if ((error != TW_ISR_DONT_COMPLETE)) {
<span class="p_add">+					scsi_dma_unmap(tw_dev-&gt;srb[request_id]);</span>
<span class="p_add">+					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
 					tw_dev-&gt;state[request_id] = TW_S_COMPLETED;
 					tw_state_request_finish(tw_dev, request_id);
 					tw_dev-&gt;posted_request_count--;
<span class="p_del">-					tw_dev-&gt;srb[request_id]-&gt;scsi_done(tw_dev-&gt;srb[request_id]);</span>
<span class="p_del">-					</span>
<span class="p_del">-					tw_unmap_scsi_data(tw_dev-&gt;tw_pci_dev, tw_dev-&gt;srb[request_id]);</span>
 				}
 			}
 				
<span class="p_header">diff --git a/drivers/scsi/3w-xxxx.h b/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">index 29b0b84e..6f65e66 100644</span>
<span class="p_header">--- a/drivers/scsi/3w-xxxx.h</span>
<span class="p_header">+++ b/drivers/scsi/3w-xxxx.h</span>
<span class="p_chunk">@@ -195,11 +195,6 @@</span> <span class="p_context"> static unsigned char tw_sense_table[][4] =</span>
 #define TW_AEN_SMART_FAIL        0x000F
 #define TW_AEN_SBUF_FAIL         0x0024
 
<span class="p_del">-/* Phase defines */</span>
<span class="p_del">-#define TW_PHASE_INITIAL 0</span>
<span class="p_del">-#define TW_PHASE_SINGLE 1</span>
<span class="p_del">-#define TW_PHASE_SGLIST 2</span>
<span class="p_del">-</span>
 /* Misc defines */
 #define TW_ALIGNMENT_6000		      64 /* 64 bytes */
 #define TW_ALIGNMENT_7000                     4  /* 4 bytes */
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index 262ab83..9f77d23 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -226,6 +226,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;PIONEER&quot;, &quot;CD-ROM DRM-624X&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;Promise&quot;, &quot;VTrak E610f&quot;, NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
<span class="p_add">+	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},</span>
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
 	{&quot;REGAL&quot;, &quot;CDC-4X&quot;, NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},
 	{&quot;SanDisk&quot;, &quot;ImageMate CF-SD1&quot;, NULL, BLIST_FORCELUN},
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 983aed1..cc662c9 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -909,6 +909,12 @@</span> <span class="p_context"> static int scsi_add_lun(struct scsi_device *sdev, unsigned char *inq_result,</span>
 	 */
 	if (*bflags &amp; BLIST_MAX_512)
 		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 512);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Max 1024 sector transfer length for targets that report incorrect</span>
<span class="p_add">+	 * max/optimal lengths and relied on the old block layer safe default</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	else if (*bflags &amp; BLIST_MAX_1024)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 1024);</span>
 
 	/*
 	 * Some devices may not want to have a start command automatically
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index f1e5742..5bab1c6 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -299,11 +299,27 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 	return 0;
 }
 
<span class="p_add">+static void xen_console_update_evtchn(struct xencons_info *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (xen_hvm_domain()) {</span>
<span class="p_add">+		uint64_t v;</span>
<span class="p_add">+		int err;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = hvm_get_parameter(HVM_PARAM_CONSOLE_EVTCHN, &amp;v);</span>
<span class="p_add">+		if (!err &amp;&amp; v)</span>
<span class="p_add">+			info-&gt;evtchn = v;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		info-&gt;evtchn = xen_start_info-&gt;console.domU.evtchn;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void xen_console_resume(void)
 {
 	struct xencons_info *info = vtermno_to_xencons(HVC_COOKIE);
<span class="p_del">-	if (info != NULL &amp;&amp; info-&gt;irq)</span>
<span class="p_add">+	if (info != NULL &amp;&amp; info-&gt;irq) {</span>
<span class="p_add">+		if (!xen_initial_domain())</span>
<span class="p_add">+			xen_console_update_evtchn(info);</span>
 		rebind_evtchn_irq(info-&gt;evtchn, info-&gt;irq);
<span class="p_add">+	}</span>
 }
 
 static void xencons_disconnect_backend(struct xencons_info *info)
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 92a8b26..95f8f64 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -856,6 +856,7 @@</span> <span class="p_context"> static int atmel_prepare_tx_dma(struct uart_port *port)</span>
 	config.direction = DMA_MEM_TO_DEV;
 	config.dst_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 	config.dst_addr = port-&gt;mapbase + ATMEL_US_THR;
<span class="p_add">+	config.dst_maxburst = 1;</span>
 
 	ret = dmaengine_slave_config(atmel_port-&gt;chan_tx,
 				     &amp;config);
<span class="p_chunk">@@ -1035,6 +1036,7 @@</span> <span class="p_context"> static int atmel_prepare_rx_dma(struct uart_port *port)</span>
 	config.direction = DMA_DEV_TO_MEM;
 	config.src_addr_width = DMA_SLAVE_BUSWIDTH_1_BYTE;
 	config.src_addr = port-&gt;mapbase + ATMEL_US_RHR;
<span class="p_add">+	config.src_maxburst = 1;</span>
 
 	ret = dmaengine_slave_config(atmel_port-&gt;chan_rx,
 				     &amp;config);
<span class="p_header">diff --git a/drivers/tty/serial/of_serial.c b/drivers/tty/serial/of_serial.c</span>
<span class="p_header">index 64f1bab..e79d884 100644</span>
<span class="p_header">--- a/drivers/tty/serial/of_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/of_serial.c</span>
<span class="p_chunk">@@ -335,7 +335,6 @@</span> <span class="p_context"> static struct of_device_id of_platform_serial_table[] = {</span>
 	{ .compatible = &quot;ibm,qpace-nwp-serial&quot;,
 		.data = (void *)PORT_NWPSERIAL, },
 #endif
<span class="p_del">-	{ .type = &quot;serial&quot;,         .data = (void *)PORT_UNKNOWN, },</span>
 	{ /* end of list */ },
 };
 
<span class="p_header">diff --git a/drivers/tty/serial/uartlite.c b/drivers/tty/serial/uartlite.c</span>
<span class="p_header">index 189f52e..a0099a7 100644</span>
<span class="p_header">--- a/drivers/tty/serial/uartlite.c</span>
<span class="p_header">+++ b/drivers/tty/serial/uartlite.c</span>
<span class="p_chunk">@@ -632,7 +632,8 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(of, ulite_of_match);</span>
 
 static int ulite_probe(struct platform_device *pdev)
 {
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
<span class="p_add">+	int irq;</span>
 	int id = pdev-&gt;id;
 #ifdef CONFIG_OF
 	const __be32 *prop;
<span class="p_chunk">@@ -646,11 +647,11 @@</span> <span class="p_context"> static int ulite_probe(struct platform_device *pdev)</span>
 	if (!res)
 		return -ENODEV;
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0)</span>
<span class="p_add">+		return -ENXIO;</span>
 
<span class="p_del">-	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, res2-&gt;start);</span>
<span class="p_add">+	return ulite_assign(&amp;pdev-&gt;dev, id, res-&gt;start, irq);</span>
 }
 
 static int ulite_remove(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/tty/serial/xilinx_uartps.c b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">index 542bab3..4716721 100644</span>
<span class="p_header">--- a/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_header">+++ b/drivers/tty/serial/xilinx_uartps.c</span>
<span class="p_chunk">@@ -1323,9 +1323,9 @@</span> <span class="p_context"> static SIMPLE_DEV_PM_OPS(cdns_uart_dev_pm_ops, cdns_uart_suspend,</span>
  */
 static int cdns_uart_probe(struct platform_device *pdev)
 {
<span class="p_del">-	int rc, id;</span>
<span class="p_add">+	int rc, id, irq;</span>
 	struct uart_port *port;
<span class="p_del">-	struct resource *res, *res2;</span>
<span class="p_add">+	struct resource *res;</span>
 	struct cdns_uart *cdns_uart_data;
 
 	cdns_uart_data = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(*cdns_uart_data),
<span class="p_chunk">@@ -1372,9 +1372,9 @@</span> <span class="p_context"> static int cdns_uart_probe(struct platform_device *pdev)</span>
 		goto err_out_clk_disable;
 	}
 
<span class="p_del">-	res2 = platform_get_resource(pdev, IORESOURCE_IRQ, 0);</span>
<span class="p_del">-	if (!res2) {</span>
<span class="p_del">-		rc = -ENODEV;</span>
<span class="p_add">+	irq = platform_get_irq(pdev, 0);</span>
<span class="p_add">+	if (irq &lt;= 0) {</span>
<span class="p_add">+		rc = -ENXIO;</span>
 		goto err_out_clk_disable;
 	}
 
<span class="p_chunk">@@ -1403,7 +1403,7 @@</span> <span class="p_context"> static int cdns_uart_probe(struct platform_device *pdev)</span>
 		 * and triggers invocation of the config_port() entry point.
 		 */
 		port-&gt;mapbase = res-&gt;start;
<span class="p_del">-		port-&gt;irq = res2-&gt;start;</span>
<span class="p_add">+		port-&gt;irq = irq;</span>
 		port-&gt;dev = &amp;pdev-&gt;dev;
 		port-&gt;uartclk = clk_get_rate(cdns_uart_data-&gt;uartclk);
 		port-&gt;private_data = cdns_uart_data;
<span class="p_header">diff --git a/drivers/usb/chipidea/otg_fsm.c b/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_header">index 562e581..3770330 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/otg_fsm.c</span>
<span class="p_chunk">@@ -537,7 +537,6 @@</span> <span class="p_context"> static int ci_otg_start_host(struct otg_fsm *fsm, int on)</span>
 {
 	struct ci_hdrc	*ci = container_of(fsm, struct ci_hdrc, fsm);
 
<span class="p_del">-	mutex_unlock(&amp;fsm-&gt;lock);</span>
 	if (on) {
 		ci_role_stop(ci);
 		ci_role_start(ci, CI_ROLE_HOST);
<span class="p_chunk">@@ -546,7 +545,6 @@</span> <span class="p_context"> static int ci_otg_start_host(struct otg_fsm *fsm, int on)</span>
 		hw_device_reset(ci);
 		ci_role_start(ci, CI_ROLE_GADGET);
 	}
<span class="p_del">-	mutex_lock(&amp;fsm-&gt;lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -554,12 +552,10 @@</span> <span class="p_context"> static int ci_otg_start_gadget(struct otg_fsm *fsm, int on)</span>
 {
 	struct ci_hdrc	*ci = container_of(fsm, struct ci_hdrc, fsm);
 
<span class="p_del">-	mutex_unlock(&amp;fsm-&gt;lock);</span>
 	if (on)
 		usb_gadget_vbus_connect(&amp;ci-&gt;gadget);
 	else
 		usb_gadget_vbus_disconnect(&amp;ci-&gt;gadget);
<span class="p_del">-	mutex_lock(&amp;fsm-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index a417b73..054fc28 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1133,11 +1133,16 @@</span> <span class="p_context"> static int acm_probe(struct usb_interface *intf,</span>
 	}
 
 	while (buflen &gt; 0) {
<span class="p_add">+		elength = buffer[0];</span>
<span class="p_add">+		if (!elength) {</span>
<span class="p_add">+			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage byte\n&quot;);</span>
<span class="p_add">+			elength = 1;</span>
<span class="p_add">+			goto next_desc;</span>
<span class="p_add">+		}</span>
 		if (buffer[1] != USB_DT_CS_INTERFACE) {
 			dev_err(&amp;intf-&gt;dev, &quot;skipping garbage\n&quot;);
 			goto next_desc;
 		}
<span class="p_del">-		elength = buffer[0];</span>
 
 		switch (buffer[2]) {
 		case USB_CDC_UNION_TYPE: /* we&#39;ve found it */
<span class="p_header">diff --git a/drivers/usb/storage/uas-detect.h b/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">index 9893d69..f58caa9 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas-detect.h</span>
<span class="p_header">+++ b/drivers/usb/storage/uas-detect.h</span>
<span class="p_chunk">@@ -51,7 +51,8 @@</span> <span class="p_context"> static int uas_find_endpoints(struct usb_host_interface *alt,</span>
 }
 
 static int uas_use_uas_driver(struct usb_interface *intf,
<span class="p_del">-			      const struct usb_device_id *id)</span>
<span class="p_add">+			      const struct usb_device_id *id,</span>
<span class="p_add">+			      unsigned long *flags_ret)</span>
 {
 	struct usb_host_endpoint *eps[4] = { };
 	struct usb_device *udev = interface_to_usbdev(intf);
<span class="p_chunk">@@ -73,7 +74,7 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 	 * this writing the following versions exist:
 	 * ASM1051 - no uas support version
 	 * ASM1051 - with broken (*) uas support
<span class="p_del">-	 * ASM1053 - with working uas support</span>
<span class="p_add">+	 * ASM1053 - with working uas support, but problems with large xfers</span>
 	 * ASM1153 - with working uas support
 	 *
 	 * Devices with these chips re-use a number of device-ids over the
<span class="p_chunk">@@ -103,6 +104,9 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		} else if (usb_ss_max_streams(&amp;eps[1]-&gt;ss_ep_comp) == 32) {
 			/* Possibly an ASM1051, disable uas */
 			flags |= US_FL_IGNORE_UAS;
<span class="p_add">+		} else {</span>
<span class="p_add">+			/* ASM1053, these have issues with large transfers */</span>
<span class="p_add">+			flags |= US_FL_MAX_SECTORS_240;</span>
 		}
 	}
 
<span class="p_chunk">@@ -132,5 +136,8 @@</span> <span class="p_context"> static int uas_use_uas_driver(struct usb_interface *intf,</span>
 		return 0;
 	}
 
<span class="p_add">+	if (flags_ret)</span>
<span class="p_add">+		*flags_ret = flags;</span>
<span class="p_add">+</span>
 	return 1;
 }
<span class="p_header">diff --git a/drivers/usb/storage/uas.c b/drivers/usb/storage/uas.c</span>
<span class="p_header">index 6cdabdc..6d3122a 100644</span>
<span class="p_header">--- a/drivers/usb/storage/uas.c</span>
<span class="p_header">+++ b/drivers/usb/storage/uas.c</span>
<span class="p_chunk">@@ -759,7 +759,10 @@</span> <span class="p_context"> static int uas_eh_bus_reset_handler(struct scsi_cmnd *cmnd)</span>
 
 static int uas_slave_alloc(struct scsi_device *sdev)
 {
<span class="p_del">-	sdev-&gt;hostdata = (void *)sdev-&gt;host-&gt;hostdata;</span>
<span class="p_add">+	struct uas_dev_info *devinfo =</span>
<span class="p_add">+		(struct uas_dev_info *)sdev-&gt;host-&gt;hostdata;</span>
<span class="p_add">+</span>
<span class="p_add">+	sdev-&gt;hostdata = devinfo;</span>
 
 	/* USB has unusual DMA-alignment requirements: Although the
 	 * starting address of each scatter-gather element doesn&#39;t matter,
<span class="p_chunk">@@ -778,6 +781,11 @@</span> <span class="p_context"> static int uas_slave_alloc(struct scsi_device *sdev)</span>
 	 */
 	blk_queue_update_dma_alignment(sdev-&gt;request_queue, (512 - 1));
 
<span class="p_add">+	if (devinfo-&gt;flags &amp; US_FL_MAX_SECTORS_64)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 64);</span>
<span class="p_add">+	else if (devinfo-&gt;flags &amp; US_FL_MAX_SECTORS_240)</span>
<span class="p_add">+		blk_queue_max_hw_sectors(sdev-&gt;request_queue, 240);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -887,8 +895,9 @@</span> <span class="p_context"> static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	struct Scsi_Host *shost = NULL;
 	struct uas_dev_info *devinfo;
 	struct usb_device *udev = interface_to_usbdev(intf);
<span class="p_add">+	unsigned long dev_flags;</span>
 
<span class="p_del">-	if (!uas_use_uas_driver(intf, id))</span>
<span class="p_add">+	if (!uas_use_uas_driver(intf, id, &amp;dev_flags))</span>
 		return -ENODEV;
 
 	if (uas_switch_interface(udev, intf))
<span class="p_chunk">@@ -910,8 +919,7 @@</span> <span class="p_context"> static int uas_probe(struct usb_interface *intf, const struct usb_device_id *id)</span>
 	devinfo-&gt;udev = udev;
 	devinfo-&gt;resetting = 0;
 	devinfo-&gt;shutdown = 0;
<span class="p_del">-	devinfo-&gt;flags = id-&gt;driver_info;</span>
<span class="p_del">-	usb_stor_adjust_quirks(udev, &amp;devinfo-&gt;flags);</span>
<span class="p_add">+	devinfo-&gt;flags = dev_flags;</span>
 	init_usb_anchor(&amp;devinfo-&gt;cmd_urbs);
 	init_usb_anchor(&amp;devinfo-&gt;sense_urbs);
 	init_usb_anchor(&amp;devinfo-&gt;data_urbs);
<span class="p_header">diff --git a/drivers/usb/storage/usb.c b/drivers/usb/storage/usb.c</span>
<span class="p_header">index d468d02..9c5eb04 100644</span>
<span class="p_header">--- a/drivers/usb/storage/usb.c</span>
<span class="p_header">+++ b/drivers/usb/storage/usb.c</span>
<span class="p_chunk">@@ -479,7 +479,8 @@</span> <span class="p_context"> void usb_stor_adjust_quirks(struct usb_device *udev, unsigned long *fflags)</span>
 			US_FL_SINGLE_LUN | US_FL_NO_WP_DETECT |
 			US_FL_NO_READ_DISC_INFO | US_FL_NO_READ_CAPACITY_16 |
 			US_FL_INITIAL_READ10 | US_FL_WRITE_CACHE |
<span class="p_del">-			US_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES);</span>
<span class="p_add">+			US_FL_NO_ATA_1X | US_FL_NO_REPORT_OPCODES |</span>
<span class="p_add">+			US_FL_MAX_SECTORS_240);</span>
 
 	p = quirks;
 	while (*p) {
<span class="p_chunk">@@ -520,6 +521,9 @@</span> <span class="p_context"> void usb_stor_adjust_quirks(struct usb_device *udev, unsigned long *fflags)</span>
 		case &#39;f&#39;:
 			f |= US_FL_NO_REPORT_OPCODES;
 			break;
<span class="p_add">+		case &#39;g&#39;:</span>
<span class="p_add">+			f |= US_FL_MAX_SECTORS_240;</span>
<span class="p_add">+			break;</span>
 		case &#39;h&#39;:
 			f |= US_FL_CAPACITY_HEURISTICS;
 			break;
<span class="p_chunk">@@ -1074,7 +1078,7 @@</span> <span class="p_context"> static int storage_probe(struct usb_interface *intf,</span>
 
 	/* If uas is enabled and this device can do uas then ignore it. */
 #if IS_ENABLED(CONFIG_USB_UAS)
<span class="p_del">-	if (uas_use_uas_driver(intf, id))</span>
<span class="p_add">+	if (uas_use_uas_driver(intf, id, NULL))</span>
 		return -ENXIO;
 #endif
 
<span class="p_header">diff --git a/drivers/vhost/scsi.c b/drivers/vhost/scsi.c</span>
<span class="p_header">index d695b16..be0517f 100644</span>
<span class="p_header">--- a/drivers/vhost/scsi.c</span>
<span class="p_header">+++ b/drivers/vhost/scsi.c</span>
<span class="p_chunk">@@ -1253,7 +1253,7 @@</span> <span class="p_context"> tcm_vhost_send_evt(struct vhost_scsi *vs,</span>
 		 * lun[4-7] need to be zero according to virtio-scsi spec.
 		 */
 		evt-&gt;event.lun[0] = 0x01;
<span class="p_del">-		evt-&gt;event.lun[1] = tpg-&gt;tport_tpgt &amp; 0xFF;</span>
<span class="p_add">+		evt-&gt;event.lun[1] = tpg-&gt;tport_tpgt;</span>
 		if (lun-&gt;unpacked_lun &gt;= 256)
 			evt-&gt;event.lun[2] = lun-&gt;unpacked_lun &gt;&gt; 8 | 0x40 ;
 		evt-&gt;event.lun[3] = lun-&gt;unpacked_lun &amp; 0xFF;
<span class="p_chunk">@@ -2124,12 +2124,12 @@</span> <span class="p_context"> tcm_vhost_make_tpg(struct se_wwn *wwn,</span>
 			struct tcm_vhost_tport, tport_wwn);
 
 	struct tcm_vhost_tpg *tpg;
<span class="p_del">-	unsigned long tpgt;</span>
<span class="p_add">+	u16 tpgt;</span>
 	int ret;
 
 	if (strstr(name, &quot;tpgt_&quot;) != name)
 		return ERR_PTR(-EINVAL);
<span class="p_del">-	if (kstrtoul(name + 5, 10, &amp;tpgt) || tpgt &gt; UINT_MAX)</span>
<span class="p_add">+	if (kstrtou16(name + 5, 10, &amp;tpgt) || tpgt &gt;= VHOST_SCSI_MAX_TARGET)</span>
 		return ERR_PTR(-EINVAL);
 
 	tpg = kzalloc(sizeof(struct tcm_vhost_tpg), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/xen/events/events_2l.c b/drivers/xen/events/events_2l.c</span>
<span class="p_header">index 5db43fc..7dd4631 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_2l.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_2l.c</span>
<span class="p_chunk">@@ -345,6 +345,15 @@</span> <span class="p_context"> irqreturn_t xen_debug_interrupt(int irq, void *dev_id)</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_add">+static void evtchn_2l_resume(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_online_cpu(i)</span>
<span class="p_add">+		memset(per_cpu(cpu_evtchn_mask, i), 0, sizeof(xen_ulong_t) *</span>
<span class="p_add">+				EVTCHN_2L_NR_CHANNELS/BITS_PER_EVTCHN_WORD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct evtchn_ops evtchn_ops_2l = {
 	.max_channels      = evtchn_2l_max_channels,
 	.nr_channels       = evtchn_2l_max_channels,
<span class="p_chunk">@@ -356,6 +365,7 @@</span> <span class="p_context"> static const struct evtchn_ops evtchn_ops_2l = {</span>
 	.mask              = evtchn_2l_mask,
 	.unmask            = evtchn_2l_unmask,
 	.handle_events     = evtchn_2l_handle_events,
<span class="p_add">+	.resume	           = evtchn_2l_resume,</span>
 };
 
 void __init xen_evtchn_2l_init(void)
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index 70fba97..2b8553b 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -529,8 +529,8 @@</span> <span class="p_context"> static unsigned int __startup_pirq(unsigned int irq)</span>
 	if (rc)
 		goto err;
 
<span class="p_del">-	bind_evtchn_to_cpu(evtchn, 0);</span>
 	info-&gt;evtchn = evtchn;
<span class="p_add">+	bind_evtchn_to_cpu(evtchn, 0);</span>
 
 	rc = xen_evtchn_port_setup(info);
 	if (rc)
<span class="p_chunk">@@ -1279,8 +1279,9 @@</span> <span class="p_context"> void rebind_evtchn_irq(int evtchn, int irq)</span>
 
 	mutex_unlock(&amp;irq_mapping_update_lock);
 
<span class="p_del">-	/* new event channels are always bound to cpu 0 */</span>
<span class="p_del">-	irq_set_affinity(irq, cpumask_of(0));</span>
<span class="p_add">+        bind_evtchn_to_cpu(evtchn, info-&gt;cpu);</span>
<span class="p_add">+	/* This will be deferred until interrupt is processed */</span>
<span class="p_add">+	irq_set_affinity(irq, cpumask_of(info-&gt;cpu));</span>
 
 	/* Unmask the event channel. */
 	enable_irq(irq);
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.c b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">index 75fe3d4..9c23420 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.c</span>
<span class="p_chunk">@@ -16,8 +16,8 @@</span> <span class="p_context"></span>
 #include &quot;conf_space.h&quot;
 #include &quot;conf_space_quirks.h&quot;
 
<span class="p_del">-bool permissive;</span>
<span class="p_del">-module_param(permissive, bool, 0644);</span>
<span class="p_add">+bool xen_pcibk_permissive;</span>
<span class="p_add">+module_param_named(permissive, xen_pcibk_permissive, bool, 0644);</span>
 
 /* This is where xen_pcibk_read_config_byte, xen_pcibk_read_config_word,
  * xen_pcibk_write_config_word, and xen_pcibk_write_config_byte are created. */
<span class="p_chunk">@@ -262,7 +262,7 @@</span> <span class="p_context"> int xen_pcibk_config_write(struct pci_dev *dev, int offset, int size, u32 value)</span>
 		 * This means that some fields may still be read-only because
 		 * they have entries in the config_field list that intercept
 		 * the write and do nothing. */
<span class="p_del">-		if (dev_data-&gt;permissive || permissive) {</span>
<span class="p_add">+		if (dev_data-&gt;permissive || xen_pcibk_permissive) {</span>
 			switch (size) {
 			case 1:
 				err = pci_write_config_byte(dev, offset,
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space.h b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">index 2e1d73d..62461a8 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space.h</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> struct config_field_entry {</span>
 	void *data;
 };
 
<span class="p_del">-extern bool permissive;</span>
<span class="p_add">+extern bool xen_pcibk_permissive;</span>
 
 #define OFFSET(cfg_entry) ((cfg_entry)-&gt;base_offset+(cfg_entry)-&gt;field-&gt;offset)
 
<span class="p_header">diff --git a/drivers/xen/xen-pciback/conf_space_header.c b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">index 2d73693..f8baf46 100644</span>
<span class="p_header">--- a/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_header">+++ b/drivers/xen/xen-pciback/conf_space_header.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int command_write(struct pci_dev *dev, int offset, u16 value, void *data)</span>
 
 	cmd-&gt;val = value;
 
<span class="p_del">-	if (!permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
<span class="p_add">+	if (!xen_pcibk_permissive &amp;&amp; (!dev_data || !dev_data-&gt;permissive))</span>
 		return 0;
 
 	/* Only allow the guest to control certain bits. */
<span class="p_header">diff --git a/drivers/xen/xenbus/xenbus_probe.c b/drivers/xen/xenbus/xenbus_probe.c</span>
<span class="p_header">index 564b315..5390a67 100644</span>
<span class="p_header">--- a/drivers/xen/xenbus/xenbus_probe.c</span>
<span class="p_header">+++ b/drivers/xen/xenbus/xenbus_probe.c</span>
<span class="p_chunk">@@ -57,6 +57,7 @@</span> <span class="p_context"></span>
 #include &lt;xen/xen.h&gt;
 #include &lt;xen/xenbus.h&gt;
 #include &lt;xen/events.h&gt;
<span class="p_add">+#include &lt;xen/xen-ops.h&gt;</span>
 #include &lt;xen/page.h&gt;
 
 #include &lt;xen/hvm.h&gt;
<span class="p_chunk">@@ -735,6 +736,30 @@</span> <span class="p_context"> static int __init xenstored_local_init(void)</span>
 	return err;
 }
 
<span class="p_add">+static int xenbus_resume_cb(struct notifier_block *nb,</span>
<span class="p_add">+			    unsigned long action, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xen_hvm_domain()) {</span>
<span class="p_add">+		uint64_t v;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = hvm_get_parameter(HVM_PARAM_STORE_EVTCHN, &amp;v);</span>
<span class="p_add">+		if (!err &amp;&amp; v)</span>
<span class="p_add">+			xen_store_evtchn = v;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pr_warn(&quot;Cannot update xenstore event channel: %d\n&quot;,</span>
<span class="p_add">+				err);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		xen_store_evtchn = xen_start_info-&gt;store_evtchn;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block xenbus_resume_nb = {</span>
<span class="p_add">+	.notifier_call = xenbus_resume_cb,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int __init xenbus_init(void)
 {
 	int err = 0;
<span class="p_chunk">@@ -793,6 +818,10 @@</span> <span class="p_context"> static int __init xenbus_init(void)</span>
 		goto out_error;
 	}
 
<span class="p_add">+	if ((xen_store_domain_type != XS_LOCAL) &amp;&amp;</span>
<span class="p_add">+	    (xen_store_domain_type != XS_UNKNOWN))</span>
<span class="p_add">+		xen_resume_notifier_register(&amp;xenbus_resume_nb);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_XEN_COMPAT_XENFS
 	/*
 	 * Create xenfs mountpoint in /proc for compatibility with
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 09a566a..334b0a9 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2403,7 +2403,7 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 			&quot;Attempt to delete subvolume %llu during send&quot;,
 			dest-&gt;root_key.objectid);
 		err = -EPERM;
<span class="p_del">-		goto out_dput;</span>
<span class="p_add">+		goto out_unlock_inode;</span>
 	}
 
 	d_invalidate(dentry);
<span class="p_chunk">@@ -2498,6 +2498,7 @@</span> <span class="p_context"> out_up_write:</span>
 				root_flags &amp; ~BTRFS_ROOT_SUBVOL_DEAD);
 		spin_unlock(&amp;dest-&gt;root_item_lock);
 	}
<span class="p_add">+out_unlock_inode:</span>
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 	if (!err) {
 		shrink_dcache_sb(root-&gt;fs_info-&gt;sb);
<span class="p_header">diff --git a/fs/efivarfs/super.c b/fs/efivarfs/super.c</span>
<span class="p_header">index 6dad117..7b9efb9 100644</span>
<span class="p_header">--- a/fs/efivarfs/super.c</span>
<span class="p_header">+++ b/fs/efivarfs/super.c</span>
<span class="p_chunk">@@ -121,7 +121,7 @@</span> <span class="p_context"> static int efivarfs_callback(efi_char16_t *name16, efi_guid_t vendor,</span>
 	int len, i;
 	int err = -ENOMEM;
 
<span class="p_del">-	entry = kmalloc(sizeof(*entry), GFP_KERNEL);</span>
<span class="p_add">+	entry = kzalloc(sizeof(*entry), GFP_KERNEL);</span>
 	if (!entry)
 		return err;
 
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index bed4308..30dee3c 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -4803,12 +4803,6 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 	else
 		max_blocks -= lblk;
 
<span class="p_del">-	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT |</span>
<span class="p_del">-		EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |</span>
<span class="p_del">-		EXT4_EX_NOCACHE;</span>
<span class="p_del">-	if (mode &amp; FALLOC_FL_KEEP_SIZE)</span>
<span class="p_del">-		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
 	/*
<span class="p_chunk">@@ -4825,15 +4819,28 @@</span> <span class="p_context"> static long ext4_zero_range(struct file *file, loff_t offset,</span>
 		ret = inode_newsize_ok(inode, new_size);
 		if (ret)
 			goto out_mutex;
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If we have a partial block after EOF we have to allocate</span>
<span class="p_del">-		 * the entire block.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (partial_end)</span>
<span class="p_del">-			max_blocks += 1;</span>
 	}
 
<span class="p_add">+	flags = EXT4_GET_BLOCKS_CREATE_UNWRIT_EXT;</span>
<span class="p_add">+	if (mode &amp; FALLOC_FL_KEEP_SIZE)</span>
<span class="p_add">+		flags |= EXT4_GET_BLOCKS_KEEP_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Preallocate the range including the unaligned edges */</span>
<span class="p_add">+	if (partial_begin || partial_end) {</span>
<span class="p_add">+		ret = ext4_alloc_file_blocks(file,</span>
<span class="p_add">+				round_down(offset, 1 &lt;&lt; blkbits) &gt;&gt; blkbits,</span>
<span class="p_add">+				(round_up((offset + len), 1 &lt;&lt; blkbits) -</span>
<span class="p_add">+				 round_down(offset, 1 &lt;&lt; blkbits)) &gt;&gt; blkbits,</span>
<span class="p_add">+				new_size, flags, mode);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_mutex;</span>
<span class="p_add">+</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zero range excluding the unaligned edges */</span>
 	if (max_blocks &gt; 0) {
<span class="p_add">+		flags |= (EXT4_GET_BLOCKS_CONVERT_UNWRITTEN |</span>
<span class="p_add">+			  EXT4_EX_NOCACHE);</span>
 
 		/* Now release the pages and zero block aligned part of pages*/
 		truncate_pagecache_range(inode, start, end - 1);
<span class="p_chunk">@@ -4934,13 +4941,6 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * currently supporting (pre)allocate mode for extent-based</span>
<span class="p_del">-	 * files _only_</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))</span>
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_del">-</span>
 	if (mode &amp; FALLOC_FL_COLLAPSE_RANGE)
 		return ext4_collapse_range(inode, offset, len);
 
<span class="p_chunk">@@ -4962,6 +4962,14 @@</span> <span class="p_context"> long ext4_fallocate(struct file *file, int mode, loff_t offset, loff_t len)</span>
 
 	mutex_lock(&amp;inode-&gt;i_mutex);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only support preallocation for extent-based files only</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {</span>
<span class="p_add">+		ret = -EOPNOTSUPP;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(mode &amp; FALLOC_FL_KEEP_SIZE) &amp;&amp;
 	     offset + len &gt; i_size_read(inode)) {
 		new_size = offset + len;
<span class="p_header">diff --git a/fs/ext4/extents_status.c b/fs/ext4/extents_status.c</span>
<span class="p_header">index e04d457..9a01213 100644</span>
<span class="p_header">--- a/fs/ext4/extents_status.c</span>
<span class="p_header">+++ b/fs/ext4/extents_status.c</span>
<span class="p_chunk">@@ -705,6 +705,14 @@</span> <span class="p_context"> int ext4_es_insert_extent(struct inode *inode, ext4_lblk_t lblk,</span>
 
 	BUG_ON(end &lt; lblk);
 
<span class="p_add">+	if ((status &amp; EXTENT_STATUS_DELAYED) &amp;&amp;</span>
<span class="p_add">+	    (status &amp; EXTENT_STATUS_WRITTEN)) {</span>
<span class="p_add">+		ext4_warning(inode-&gt;i_sb, &quot;Inserting extent [%u/%u] as &quot;</span>
<span class="p_add">+				&quot; delayed and written which can potentially &quot;</span>
<span class="p_add">+				&quot; cause data loss.\n&quot;, lblk, len);</span>
<span class="p_add">+		WARN_ON(1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	newes.es_lblk = lblk;
 	newes.es_len = len;
 	ext4_es_store_pblock_status(&amp;newes, pblk, status);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 5653fa4..9743a38 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -534,6 +534,7 @@</span> <span class="p_context"> int ext4_map_blocks(handle_t *handle, struct inode *inode,</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_chunk">@@ -638,6 +639,7 @@</span> <span class="p_context"> found:</span>
 		status = map-&gt;m_flags &amp; EXT4_MAP_UNWRITTEN ?
 				EXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;
 		if (!(flags &amp; EXT4_GET_BLOCKS_DELALLOC_RESERVE) &amp;&amp;
<span class="p_add">+		    !(status &amp; EXTENT_STATUS_WRITTEN) &amp;&amp;</span>
 		    ext4_find_delalloc_range(inode, map-&gt;m_lblk,
 					     map-&gt;m_lblk + map-&gt;m_len - 1))
 			status |= EXTENT_STATUS_DELAYED;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 3abfbda..b4d2182 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -3209,7 +3209,7 @@</span> <span class="p_context"> static struct file *path_openat(int dfd, struct filename *pathname,</span>
 
 	if (unlikely(file-&gt;f_flags &amp; __O_TMPFILE)) {
 		error = do_tmpfile(dfd, pathname, nd, flags, op, file, &amp;opened);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out2;</span>
 	}
 
 	error = path_init(dfd, pathname-&gt;name, flags, nd);
<span class="p_chunk">@@ -3239,6 +3239,7 @@</span> <span class="p_context"> static struct file *path_openat(int dfd, struct filename *pathname,</span>
 	}
 out:
 	path_cleanup(nd);
<span class="p_add">+out2:</span>
 	if (!(opened &amp; FILE_OPENED)) {
 		BUG_ON(!error);
 		put_filp(file);
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 07d0562..8129c51 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -3140,6 +3140,12 @@</span> <span class="p_context"> bool fs_fully_visible(struct file_system_type *type)</span>
 		if (mnt-&gt;mnt.mnt_sb-&gt;s_type != type)
 			continue;
 
<span class="p_add">+		/* This mount is not fully visible if it&#39;s root directory</span>
<span class="p_add">+		 * is not the root directory of the filesystem.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		/* This mount is not fully visible if there are any child mounts
 		 * that cover anything except for empty directories.
 		 */
<span class="p_header">diff --git a/fs/nilfs2/btree.c b/fs/nilfs2/btree.c</span>
<span class="p_header">index ecdbae1..090d8ce 100644</span>
<span class="p_header">--- a/fs/nilfs2/btree.c</span>
<span class="p_header">+++ b/fs/nilfs2/btree.c</span>
<span class="p_chunk">@@ -388,7 +388,7 @@</span> <span class="p_context"> static int nilfs_btree_root_broken(const struct nilfs_btree_node *node,</span>
 	nchildren = nilfs_btree_node_get_nchildren(node);
 
 	if (unlikely(level &lt; NILFS_BTREE_LEVEL_NODE_MIN ||
<span class="p_del">-		     level &gt; NILFS_BTREE_LEVEL_MAX ||</span>
<span class="p_add">+		     level &gt;= NILFS_BTREE_LEVEL_MAX ||</span>
 		     nchildren &lt; 0 ||
 		     nchildren &gt; NILFS_BTREE_ROOT_NCHILDREN_MAX)) {
 		pr_crit(&quot;NILFS: bad btree root (inode number=%lu): level = %d, flags = 0x%x, nchildren = %d\n&quot;,
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index a6944b2..fdf4b41 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -757,6 +757,19 @@</span> <span class="p_context"> lookup:</span>
 	if (tmpres) {
 		spin_unlock(&amp;dlm-&gt;spinlock);
 		spin_lock(&amp;tmpres-&gt;spinlock);
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Right after dlm spinlock was released, dlm_thread could have</span>
<span class="p_add">+		 * purged the lockres. Check if lockres got unhashed. If so</span>
<span class="p_add">+		 * start over.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (hlist_unhashed(&amp;tmpres-&gt;hash_node)) {</span>
<span class="p_add">+			spin_unlock(&amp;tmpres-&gt;spinlock);</span>
<span class="p_add">+			dlm_lockres_put(tmpres);</span>
<span class="p_add">+			tmpres = NULL;</span>
<span class="p_add">+			goto lookup;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* Wait on the thread that is mastering the resource */
 		if (tmpres-&gt;owner == DLM_LOCK_RES_OWNER_UNKNOWN) {
 			__dlm_wait_on_lockres(tmpres);
<span class="p_header">diff --git a/include/linux/nilfs2_fs.h b/include/linux/nilfs2_fs.h</span>
<span class="p_header">index ff3fea3..9abb763 100644</span>
<span class="p_header">--- a/include/linux/nilfs2_fs.h</span>
<span class="p_header">+++ b/include/linux/nilfs2_fs.h</span>
<span class="p_chunk">@@ -460,7 +460,7 @@</span> <span class="p_context"> struct nilfs_btree_node {</span>
 /* level */
 #define NILFS_BTREE_LEVEL_DATA          0
 #define NILFS_BTREE_LEVEL_NODE_MIN      (NILFS_BTREE_LEVEL_DATA + 1)
<span class="p_del">-#define NILFS_BTREE_LEVEL_MAX           14</span>
<span class="p_add">+#define NILFS_BTREE_LEVEL_MAX           14	/* Max level (exclusive) */</span>
 
 /**
  * struct nilfs_palloc_group_desc - block group descriptor
<span class="p_header">diff --git a/include/linux/usb_usual.h b/include/linux/usb_usual.h</span>
<span class="p_header">index a7f2604..7f5f78b 100644</span>
<span class="p_header">--- a/include/linux/usb_usual.h</span>
<span class="p_header">+++ b/include/linux/usb_usual.h</span>
<span class="p_chunk">@@ -77,6 +77,8 @@</span> <span class="p_context"></span>
 		/* Cannot handle ATA_12 or ATA_16 CDBs */	\
 	US_FLAG(NO_REPORT_OPCODES,	0x04000000)		\
 		/* Cannot handle MI_REPORT_SUPPORTED_OPERATION_CODES */	\
<span class="p_add">+	US_FLAG(MAX_SECTORS_240,	0x08000000)		\</span>
<span class="p_add">+		/* Sets max_sectors to 240 */			\</span>
 
 #define US_FLAG(name, value)	US_FL_##name = value ,
 enum { US_DO_ALL_FLAGS };
<span class="p_header">diff --git a/include/scsi/scsi_devinfo.h b/include/scsi/scsi_devinfo.h</span>
<span class="p_header">index 183eaab..96e3f56 100644</span>
<span class="p_header">--- a/include/scsi/scsi_devinfo.h</span>
<span class="p_header">+++ b/include/scsi/scsi_devinfo.h</span>
<span class="p_chunk">@@ -36,5 +36,6 @@</span> <span class="p_context"></span>
 					     for sequential scan */
 #define BLIST_TRY_VPD_PAGES	0x10000000 /* Attempt to read VPD pages */
 #define BLIST_NO_RSOC		0x20000000 /* don&#39;t try to issue RSOC */
<span class="p_add">+#define BLIST_MAX_1024		0x40000000 /* maximum 1024 sector cdb length */</span>
 
 #endif
<span class="p_header">diff --git a/include/sound/emu10k1.h b/include/sound/emu10k1.h</span>
<span class="p_header">index c46908c..8af2fff 100644</span>
<span class="p_header">--- a/include/sound/emu10k1.h</span>
<span class="p_header">+++ b/include/sound/emu10k1.h</span>
<span class="p_chunk">@@ -41,7 +41,8 @@</span> <span class="p_context"></span>
 
 #define EMUPAGESIZE     4096
 #define MAXREQVOICES    8
<span class="p_del">-#define MAXPAGES        8192</span>
<span class="p_add">+#define MAXPAGES0       4096	/* 32 bit mode */</span>
<span class="p_add">+#define MAXPAGES1       8192	/* 31 bit mode */</span>
 #define RESERVED        0
 #define NUM_MIDI        16
 #define NUM_G           64              /* use all channels */
<span class="p_chunk">@@ -50,8 +51,7 @@</span> <span class="p_context"></span>
 
 /* FIXME? - according to the OSS driver the EMU10K1 needs a 29 bit DMA mask */
 #define EMU10K1_DMA_MASK	0x7fffffffUL	/* 31bit */
<span class="p_del">-#define AUDIGY_DMA_MASK		0x7fffffffUL	/* 31bit FIXME - 32 should work? */</span>
<span class="p_del">-						/* See ALSA bug #1276 - rlrevell */</span>
<span class="p_add">+#define AUDIGY_DMA_MASK		0xffffffffUL	/* 32bit mode */</span>
 
 #define TMEMSIZE        256*1024
 #define TMEMSIZEREG     4
<span class="p_chunk">@@ -466,8 +466,11 @@</span> <span class="p_context"></span>
 
 #define MAPB			0x0d		/* Cache map B						*/
 
<span class="p_del">-#define MAP_PTE_MASK		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_del">-#define MAP_PTI_MASK		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
<span class="p_add">+#define MAP_PTE_MASK0		0xfffff000	/* The 20 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK0		0x00000fff	/* The 12 bit index to one of the 4096 PTE dwords      	*/</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAP_PTE_MASK1		0xffffe000	/* The 19 MSBs of the PTE indexed by the PTI		*/</span>
<span class="p_add">+#define MAP_PTI_MASK1		0x00001fff	/* The 13 bit index to one of the 8192 PTE dwords      	*/</span>
 
 /* 0x0e, 0x0f: Not used */
 
<span class="p_chunk">@@ -1704,6 +1707,7 @@</span> <span class="p_context"> struct snd_emu10k1 {</span>
 	unsigned short model;			/* subsystem id */
 	unsigned int card_type;			/* EMU10K1_CARD_* */
 	unsigned int ecard_ctrl;		/* ecard control bits */
<span class="p_add">+	unsigned int address_mode;		/* address mode */</span>
 	unsigned long dma_mask;			/* PCI DMA mask */
 	unsigned int delay_pcm_irq;		/* in samples */
 	int max_cache_pages;			/* max memory size / PAGE_SIZE */
<span class="p_header">diff --git a/include/sound/soc-dapm.h b/include/sound/soc-dapm.h</span>
<span class="p_header">index 89823cf..0ea7a44e 100644</span>
<span class="p_header">--- a/include/sound/soc-dapm.h</span>
<span class="p_header">+++ b/include/sound/soc-dapm.h</span>
<span class="p_chunk">@@ -287,7 +287,7 @@</span> <span class="p_context"> struct device;</span>
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | SNDRV_CTL_ELEM_ACCESS_READWRITE,\
 	.tlv.p = (tlv_array), \
 	.get = snd_soc_dapm_get_volsw, .put = snd_soc_dapm_put_volsw, \
<span class="p_del">-	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 0) }</span>
<span class="p_add">+	.private_value = SOC_SINGLE_VALUE(reg, shift, max, invert, 1) }</span>
 #define SOC_DAPM_SINGLE_TLV_VIRT(xname, max, tlv_array) \
 	SOC_DAPM_SINGLE(xname, SND_SOC_NOPM, 0, max, 0, tlv_array)
 #define SOC_DAPM_ENUM(xname, xenum) \
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 20c29dd..dc29bec 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1148,10 +1148,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * The check (unnecessarily) ignores LRU pages being isolated and
 	 * walked by the page reclaim code, however that&#39;s not a big loss.
 	 */
<span class="p_del">-	if (!PageHuge(p) &amp;&amp; !PageTransTail(p)) {</span>
<span class="p_del">-		if (!PageLRU(p))</span>
<span class="p_del">-			shake_page(p, 0);</span>
<span class="p_del">-		if (!PageLRU(p)) {</span>
<span class="p_add">+	if (!PageHuge(p)) {</span>
<span class="p_add">+		if (!PageLRU(hpage))</span>
<span class="p_add">+			shake_page(hpage, 0);</span>
<span class="p_add">+		if (!PageLRU(hpage)) {</span>
 			/*
 			 * shake_page could have turned it free.
 			 */
<span class="p_chunk">@@ -1728,12 +1728,12 @@</span> <span class="p_context"> int soft_offline_page(struct page *page, int flags)</span>
 	} else if (ret == 0) { /* for free pages */
 		if (PageHuge(page)) {
 			set_page_hwpoison_huge_page(hpage);
<span class="p_del">-			dequeue_hwpoisoned_huge_page(hpage);</span>
<span class="p_del">-			atomic_long_add(1 &lt;&lt; compound_order(hpage),</span>
<span class="p_add">+			if (!dequeue_hwpoisoned_huge_page(hpage))</span>
<span class="p_add">+				atomic_long_add(1 &lt;&lt; compound_order(hpage),</span>
 					&amp;num_poisoned_pages);
 		} else {
<span class="p_del">-			SetPageHWPoison(page);</span>
<span class="p_del">-			atomic_long_inc(&amp;num_poisoned_pages);</span>
<span class="p_add">+			if (!TestSetPageHWPoison(page))</span>
<span class="p_add">+				atomic_long_inc(&amp;num_poisoned_pages);</span>
 		}
 	}
 	unset_migratetype_isolate(page, MIGRATE_MOVABLE);
<span class="p_header">diff --git a/mm/page-writeback.c b/mm/page-writeback.c</span>
<span class="p_header">index f24d4c9..7bc9aee 100644</span>
<span class="p_header">--- a/mm/page-writeback.c</span>
<span class="p_header">+++ b/mm/page-writeback.c</span>
<span class="p_chunk">@@ -580,7 +580,7 @@</span> <span class="p_context"> static long long pos_ratio_polynom(unsigned long setpoint,</span>
 	long x;
 
 	x = div64_s64(((s64)setpoint - (s64)dirty) &lt;&lt; RATELIMIT_CALC_SHIFT,
<span class="p_del">-		    limit - setpoint + 1);</span>
<span class="p_add">+		      (limit - setpoint) | 1);</span>
 	pos_ratio = x;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
 	pos_ratio = pos_ratio * x &gt;&gt; RATELIMIT_CALC_SHIFT;
<span class="p_chunk">@@ -807,7 +807,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 	 * scale global setpoint to bdi&#39;s:
 	 *	bdi_setpoint = setpoint * bdi_thresh / thresh
 	 */
<span class="p_del">-	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh + 1);</span>
<span class="p_add">+	x = div_u64((u64)bdi_thresh &lt;&lt; 16, thresh | 1);</span>
 	bdi_setpoint = setpoint * (u64)x &gt;&gt; 16;
 	/*
 	 * Use span=(8*write_bw) in single bdi case as indicated by
<span class="p_chunk">@@ -822,7 +822,7 @@</span> <span class="p_context"> static unsigned long bdi_position_ratio(struct backing_dev_info *bdi,</span>
 
 	if (bdi_dirty &lt; x_intercept - span / 4) {
 		pos_ratio = div64_u64(pos_ratio * (x_intercept - bdi_dirty),
<span class="p_del">-				    x_intercept - bdi_setpoint + 1);</span>
<span class="p_add">+				      (x_intercept - bdi_setpoint) | 1);</span>
 	} else
 		pos_ratio /= 4;
 
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1.c b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">index 4c17163..a432b4c 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1.c</span>
<span class="p_chunk">@@ -183,8 +183,10 @@</span> <span class="p_context"> static int snd_card_emu10k1_probe(struct pci_dev *pci,</span>
 	}
 #endif
  
<span class="p_del">-	strcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver);</span>
<span class="p_del">-	strcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name);</span>
<span class="p_add">+	strlcpy(card-&gt;driver, emu-&gt;card_capabilities-&gt;driver,</span>
<span class="p_add">+		sizeof(card-&gt;driver));</span>
<span class="p_add">+	strlcpy(card-&gt;shortname, emu-&gt;card_capabilities-&gt;name,</span>
<span class="p_add">+		sizeof(card-&gt;shortname));</span>
 	snprintf(card-&gt;longname, sizeof(card-&gt;longname),
 		 &quot;%s (rev.%d, serial:0x%x) at 0x%lx, irq %i&quot;,
 		 card-&gt;shortname, emu-&gt;revision, emu-&gt;serial, emu-&gt;port, emu-&gt;irq);
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_callback.c b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">index 874cd76..d2c7ea3 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_callback.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 	snd_emu10k1_ptr_write(hw, Z2, ch, 0);
 
 	/* invalidate maps */
<span class="p_del">-	temp = (hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	temp = (hw-&gt;silent_page.addr &lt;&lt; hw-&gt;address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 	snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 #if 0
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> start_voice(struct snd_emux_voice *vp)</span>
 		snd_emu10k1_ptr_write(hw, CDF, ch, sample);
 
 		/* invalidate maps */
<span class="p_del">-		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+		temp = ((unsigned int)hw-&gt;silent_page.addr &lt;&lt; hw_address_mode) | (hw-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 		snd_emu10k1_ptr_write(hw, MAPA, ch, temp);
 		snd_emu10k1_ptr_write(hw, MAPB, ch, temp);
 		
<span class="p_header">diff --git a/sound/pci/emu10k1/emu10k1_main.c b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">index b4458a6..df9f5c7 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emu10k1_main.c</span>
<span class="p_chunk">@@ -282,7 +282,7 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 	snd_emu10k1_ptr_write(emu, TCB, 0, 0);	/* taken from original driver */
 	snd_emu10k1_ptr_write(emu, TCBS, 0, 4);	/* taken from original driver */
 
<span class="p_del">-	silent_page = (emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = (emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	for (ch = 0; ch &lt; NUM_G; ch++) {
 		snd_emu10k1_ptr_write(emu, MAPA, ch, silent_page);
 		snd_emu10k1_ptr_write(emu, MAPB, ch, silent_page);
<span class="p_chunk">@@ -348,6 +348,11 @@</span> <span class="p_context"> static int snd_emu10k1_init(struct snd_emu10k1 *emu, int enable_ir, int resume)</span>
 		outl(reg | A_IOCFG_GPOUT0, emu-&gt;port + A_IOCFG);
 	}
 
<span class="p_add">+	if (emu-&gt;address_mode == 0) {</span>
<span class="p_add">+		/* use 16M in 4G */</span>
<span class="p_add">+		outl(inl(emu-&gt;port + HCFG) | HCFG_EXPANDED_MEM, emu-&gt;port + HCFG);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1421,7 +1426,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 *
 	 */
 	{.vendor = 0x1102, .device = 0x0008, .subsystem = 0x20011102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 ZS Notebook [SB0530]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 ZS Notebook [SB0530]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0108_chip = 1,
<span class="p_chunk">@@ -1571,7 +1576,7 @@</span> <span class="p_context"> static struct snd_emu_chip_details emu_chip_details[] = {</span>
 	 .adc_1361t = 1,  /* 24 bit capture instead of 16bit */
 	 .ac97_chip = 1} ,
 	{.vendor = 0x1102, .device = 0x0004, .subsystem = 0x10051102,
<span class="p_del">-	 .driver = &quot;Audigy2&quot;, .name = &quot;SB Audigy 2 Platinum EX [SB0280]&quot;,</span>
<span class="p_add">+	 .driver = &quot;Audigy2&quot;, .name = &quot;Audigy 2 Platinum EX [SB0280]&quot;,</span>
 	 .id = &quot;Audigy2&quot;,
 	 .emu10k2_chip = 1,
 	 .ca0102_chip = 1,
<span class="p_chunk">@@ -1877,8 +1882,10 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	is_audigy = emu-&gt;audigy = c-&gt;emu10k2_chip;
 
<span class="p_add">+	/* set addressing mode */</span>
<span class="p_add">+	emu-&gt;address_mode = is_audigy ? 0 : 1;</span>
 	/* set the DMA transfer mask */
<span class="p_del">-	emu-&gt;dma_mask = is_audigy ? AUDIGY_DMA_MASK : EMU10K1_DMA_MASK;</span>
<span class="p_add">+	emu-&gt;dma_mask = emu-&gt;address_mode ? EMU10K1_DMA_MASK : AUDIGY_DMA_MASK;</span>
 	if (pci_set_dma_mask(pci, emu-&gt;dma_mask) &lt; 0 ||
 	    pci_set_consistent_dma_mask(pci, emu-&gt;dma_mask) &lt; 0) {
 		dev_err(card-&gt;dev,
<span class="p_chunk">@@ -1903,7 +1910,7 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	emu-&gt;max_cache_pages = max_cache_bytes &gt;&gt; PAGE_SHIFT;
 	if (snd_dma_alloc_pages(SNDRV_DMA_TYPE_DEV, snd_dma_pci_data(pci),
<span class="p_del">-				32 * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
<span class="p_add">+				(emu-&gt;address_mode ? 32 : 16) * 1024, &amp;emu-&gt;ptb_pages) &lt; 0) {</span>
 		err = -ENOMEM;
 		goto error;
 	}
<span class="p_chunk">@@ -2002,8 +2009,8 @@</span> <span class="p_context"> int snd_emu10k1_create(struct snd_card *card,</span>
 
 	/* Clear silent pages and set up pointers */
 	memset(emu-&gt;silent_page.area, 0, PAGE_SIZE);
<span class="p_del">-	silent_page = emu-&gt;silent_page.addr &lt;&lt; 1;</span>
<span class="p_del">-	for (idx = 0; idx &lt; MAXPAGES; idx++)</span>
<span class="p_add">+	silent_page = emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode;</span>
<span class="p_add">+	for (idx = 0; idx &lt; (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0); idx++)</span>
 		((u32 *)emu-&gt;ptb_pages.area)[idx] = cpu_to_le32(silent_page | idx);
 
 	/* set up voice indices */
<span class="p_header">diff --git a/sound/pci/emu10k1/emupcm.c b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">index f82481b..36f0b86 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emupcm.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emupcm.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static void snd_emu10k1_pcm_init_voice(struct snd_emu10k1 *emu,</span>
 	snd_emu10k1_ptr_write(emu, Z1, voice, 0);
 	snd_emu10k1_ptr_write(emu, Z2, voice, 0);
 	/* invalidate maps */
<span class="p_del">-	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; 1) | MAP_PTI_MASK;</span>
<span class="p_add">+	silent_page = ((unsigned int)emu-&gt;silent_page.addr &lt;&lt; emu-&gt;address_mode) | (emu-&gt;address_mode ? MAP_PTI_MASK1 : MAP_PTI_MASK0);</span>
 	snd_emu10k1_ptr_write(emu, MAPA, voice, silent_page);
 	snd_emu10k1_ptr_write(emu, MAPB, voice, silent_page);
 	/* modulation envelope */
<span class="p_header">diff --git a/sound/pci/emu10k1/memory.c b/sound/pci/emu10k1/memory.c</span>
<span class="p_header">index c68e6dd..4f1f69b 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/memory.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/memory.c</span>
<span class="p_chunk">@@ -34,10 +34,11 @@</span> <span class="p_context"></span>
  * aligned pages in others
  */
 #define __set_ptb_entry(emu,page,addr) \
<span class="p_del">-	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; 1) | (page)))</span>
<span class="p_add">+	(((u32 *)(emu)-&gt;ptb_pages.area)[page] = cpu_to_le32(((addr) &lt;&lt; (emu-&gt;address_mode)) | (page)))</span>
 
 #define UNIT_PAGES		(PAGE_SIZE / EMUPAGESIZE)
<span class="p_del">-#define MAX_ALIGN_PAGES		(MAXPAGES / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES0		(MAXPAGES0 / UNIT_PAGES)</span>
<span class="p_add">+#define MAX_ALIGN_PAGES1		(MAXPAGES1 / UNIT_PAGES)</span>
 /* get aligned page from offset address */
 #define get_aligned_page(offset)	((offset) &gt;&gt; PAGE_SHIFT)
 /* get offset address from aligned page */
<span class="p_chunk">@@ -124,7 +125,7 @@</span> <span class="p_context"> static int search_empty_map_area(struct snd_emu10k1 *emu, int npages, struct lis</span>
 		}
 		page = blk-&gt;mapped_page + blk-&gt;pages;
 	}
<span class="p_del">-	size = MAX_ALIGN_PAGES - page;</span>
<span class="p_add">+	size = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0) - page;</span>
 	if (size &gt;= max_size) {
 		*nextp = pos;
 		return page;
<span class="p_chunk">@@ -181,7 +182,7 @@</span> <span class="p_context"> static int unmap_memblk(struct snd_emu10k1 *emu, struct snd_emu10k1_memblk *blk)</span>
 		q = get_emu10k1_memblk(p, mapped_link);
 		end_page = q-&gt;mapped_page;
 	} else
<span class="p_del">-		end_page = MAX_ALIGN_PAGES;</span>
<span class="p_add">+		end_page = (emu-&gt;address_mode ? MAX_ALIGN_PAGES1 : MAX_ALIGN_PAGES0);</span>
 
 	/* remove links */
 	list_del(&amp;blk-&gt;mapped_link);
<span class="p_chunk">@@ -307,7 +308,7 @@</span> <span class="p_context"> snd_emu10k1_alloc_pages(struct snd_emu10k1 *emu, struct snd_pcm_substream *subst</span>
 	if (snd_BUG_ON(!emu))
 		return NULL;
 	if (snd_BUG_ON(runtime-&gt;dma_bytes &lt;= 0 ||
<span class="p_del">-		       runtime-&gt;dma_bytes &gt;= MAXPAGES * EMUPAGESIZE))</span>
<span class="p_add">+		       runtime-&gt;dma_bytes &gt;= (emu-&gt;address_mode ? MAXPAGES1 : MAXPAGES0) * EMUPAGESIZE))</span>
 		return NULL;
 	hdr = emu-&gt;memhdr;
 	if (snd_BUG_ON(!hdr))
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index 2fe86d2..a63a863 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -3027,6 +3027,16 @@</span> <span class="p_context"> static struct snd_kcontrol_new vmaster_mute_mode = {</span>
 	.put = vmaster_mute_mode_put,
 };
 
<span class="p_add">+/* meta hook to call each driver&#39;s vmaster hook */</span>
<span class="p_add">+static void vmaster_hook(void *private_data, int enabled)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct hda_vmaster_mute_hook *hook = private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hook-&gt;mute_mode != HDA_VMUTE_FOLLOW_MASTER)</span>
<span class="p_add">+		enabled = hook-&gt;mute_mode;</span>
<span class="p_add">+	hook-&gt;hook(hook-&gt;codec, enabled);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * snd_hda_add_vmaster_hook - Add a vmaster hook for mute-LED
  * @codec: the HDA codec
<span class="p_chunk">@@ -3045,9 +3055,9 @@</span> <span class="p_context"> int snd_hda_add_vmaster_hook(struct hda_codec *codec,</span>
 
 	if (!hook-&gt;hook || !hook-&gt;sw_kctl)
 		return 0;
<span class="p_del">-	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, hook-&gt;hook, codec);</span>
 	hook-&gt;codec = codec;
 	hook-&gt;mute_mode = HDA_VMUTE_FOLLOW_MASTER;
<span class="p_add">+	snd_ctl_add_vmaster_hook(hook-&gt;sw_kctl, vmaster_hook, hook);</span>
 	if (!expose_enum_ctl)
 		return 0;
 	kctl = snd_ctl_new1(&amp;vmaster_mute_mode, hook);
<span class="p_chunk">@@ -3073,14 +3083,7 @@</span> <span class="p_context"> void snd_hda_sync_vmaster_hook(struct hda_vmaster_mute_hook *hook)</span>
 	 */
 	if (hook-&gt;codec-&gt;bus-&gt;shutdown)
 		return;
<span class="p_del">-	switch (hook-&gt;mute_mode) {</span>
<span class="p_del">-	case HDA_VMUTE_FOLLOW_MASTER:</span>
<span class="p_del">-		snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		hook-&gt;hook(hook-&gt;codec, hook-&gt;mute_mode);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	snd_ctl_sync_vmaster_hook(hook-&gt;sw_kctl);</span>
 }
 EXPORT_SYMBOL_GPL(snd_hda_sync_vmaster_hook);
 
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index 6ba0b55..2341fc3 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -72,6 +72,7 @@</span> <span class="p_context"> static void hda_fixup_thinkpad_acpi(struct hda_codec *codec,</span>
 		if (led_set_func(TPACPI_LED_MUTE, false) &gt;= 0) {
 			old_vmaster_hook = spec-&gt;vmaster_mute.hook;
 			spec-&gt;vmaster_mute.hook = update_tpacpi_mute_led;
<span class="p_add">+			spec-&gt;vmaster_mute_enum = 1;</span>
 			removefunc = false;
 		}
 		if (led_set_func(TPACPI_LED_MICMUTE, false) &gt;= 0) {
<span class="p_header">diff --git a/sound/soc/codecs/rt5677.c b/sound/soc/codecs/rt5677.c</span>
<span class="p_header">index cc90988..1038d2d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5677.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5677.c</span>
<span class="p_chunk">@@ -62,6 +62,9 @@</span> <span class="p_context"> static const struct reg_default init_list[] = {</span>
 	{RT5677_PR_BASE + 0x1e,	0x0000},
 	{RT5677_PR_BASE + 0x12,	0x0eaa},
 	{RT5677_PR_BASE + 0x14,	0x018a},
<span class="p_add">+	{RT5677_PR_BASE + 0x15,	0x0490},</span>
<span class="p_add">+	{RT5677_PR_BASE + 0x38,	0x0f71},</span>
<span class="p_add">+	{RT5677_PR_BASE + 0x39,	0x0f71},</span>
 };
 #define RT5677_INIT_REG_LEN ARRAY_SIZE(init_list)
 
<span class="p_chunk">@@ -901,7 +904,7 @@</span> <span class="p_context"> static int set_dmic_clk(struct snd_soc_dapm_widget *w,</span>
 {
 	struct snd_soc_codec *codec = w-&gt;codec;
 	struct rt5677_priv *rt5677 = snd_soc_codec_get_drvdata(codec);
<span class="p_del">-	int idx = rl6231_calc_dmic_clk(rt5677-&gt;sysclk);</span>
<span class="p_add">+	int idx = rl6231_calc_dmic_clk(rt5677-&gt;lrck[RT5677_AIF1] &lt;&lt; 8);</span>
 
 	if (idx &lt; 0)
 		dev_err(codec-&gt;dev, &quot;Failed to set DMIC clock\n&quot;);
<span class="p_header">diff --git a/sound/soc/codecs/tfa9879.c b/sound/soc/codecs/tfa9879.c</span>
<span class="p_header">index 16f1b71..aab0af6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/tfa9879.c</span>
<span class="p_header">+++ b/sound/soc/codecs/tfa9879.c</span>
<span class="p_chunk">@@ -280,8 +280,8 @@</span> <span class="p_context"> static int tfa9879_i2c_probe(struct i2c_client *i2c,</span>
 	int i;
 
 	tfa9879 = devm_kzalloc(&amp;i2c-&gt;dev, sizeof(*tfa9879), GFP_KERNEL);
<span class="p_del">-	if (IS_ERR(tfa9879))</span>
<span class="p_del">-		return PTR_ERR(tfa9879);</span>
<span class="p_add">+	if (!tfa9879)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	i2c_set_clientdata(i2c, tfa9879);
 
<span class="p_header">diff --git a/sound/soc/samsung/s3c24xx-i2s.c b/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_header">index 326d3c3..5bf7236 100644</span>
<span class="p_header">--- a/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_header">+++ b/sound/soc/samsung/s3c24xx-i2s.c</span>
<span class="p_chunk">@@ -461,8 +461,8 @@</span> <span class="p_context"> static int s3c24xx_iis_dev_probe(struct platform_device *pdev)</span>
 		return -ENOENT;
 	}
 	s3c24xx_i2s.regs = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
<span class="p_del">-	if (s3c24xx_i2s.regs == NULL)</span>
<span class="p_del">-		return -ENXIO;</span>
<span class="p_add">+	if (IS_ERR(s3c24xx_i2s.regs))</span>
<span class="p_add">+		return PTR_ERR(s3c24xx_i2s.regs);</span>
 
 	s3c24xx_i2s_pcm_stereo_out.dma_addr = res-&gt;start + S3C2410_IISFIFO;
 	s3c24xx_i2s_pcm_stereo_in.dma_addr = res-&gt;start + S3C2410_IISFIFO;
<span class="p_header">diff --git a/sound/synth/emux/emux_oss.c b/sound/synth/emux/emux_oss.c</span>
<span class="p_header">index 319754c..daf61ab 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_oss.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_oss.c</span>
<span class="p_chunk">@@ -118,12 +118,8 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (snd_BUG_ON(!arg || !emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!snd_emux_inc_count(emu)) {</span>
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	if (!snd_emux_inc_count(emu))</span>
 		return -EFAULT;
<span class="p_del">-	}</span>
 
 	memset(&amp;callback, 0, sizeof(callback));
 	callback.owner = THIS_MODULE;
<span class="p_chunk">@@ -135,7 +131,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	if (p == NULL) {
 		snd_printk(KERN_ERR &quot;can&#39;t create port\n&quot;);
 		snd_emux_dec_count(emu);
<span class="p_del">-		mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 		return -ENOMEM;
 	}
 
<span class="p_chunk">@@ -148,8 +143,6 @@</span> <span class="p_context"> snd_emux_open_seq_oss(struct snd_seq_oss_arg *arg, void *closure)</span>
 	reset_port_mode(p, arg-&gt;seq_mode);
 
 	snd_emux_reset_port(p);
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -195,13 +188,11 @@</span> <span class="p_context"> snd_emux_close_seq_oss(struct snd_seq_oss_arg *arg)</span>
 	if (snd_BUG_ON(!emu))
 		return -ENXIO;
 
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	snd_emux_sounds_off_all(p);
 	snd_soundfont_close_check(emu-&gt;sflist, SF_CLIENT_NO(p-&gt;chset.port));
 	snd_seq_event_port_detach(p-&gt;chset.client, p-&gt;chset.port);
 	snd_emux_dec_count(emu);
 
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/synth/emux/emux_seq.c b/sound/synth/emux/emux_seq.c</span>
<span class="p_header">index 7778b8e..a020920 100644</span>
<span class="p_header">--- a/sound/synth/emux/emux_seq.c</span>
<span class="p_header">+++ b/sound/synth/emux/emux_seq.c</span>
<span class="p_chunk">@@ -124,12 +124,10 @@</span> <span class="p_context"> snd_emux_detach_seq(struct snd_emux *emu)</span>
 	if (emu-&gt;voices)
 		snd_emux_terminate_all(emu);
 		
<span class="p_del">-	mutex_lock(&amp;emu-&gt;register_mutex);</span>
 	if (emu-&gt;client &gt;= 0) {
 		snd_seq_delete_kernel_client(emu-&gt;client);
 		emu-&gt;client = -1;
 	}
<span class="p_del">-	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
 }
 
 
<span class="p_chunk">@@ -269,8 +267,8 @@</span> <span class="p_context"> snd_emux_event_input(struct snd_seq_event *ev, int direct, void *private_data,</span>
 /*
  * increment usage count
  */
<span class="p_del">-int</span>
<span class="p_del">-snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+static int</span>
<span class="p_add">+__snd_emux_inc_count(struct snd_emux *emu)</span>
 {
 	emu-&gt;used++;
 	if (!try_module_get(emu-&gt;ops.owner))
<span class="p_chunk">@@ -284,12 +282,21 @@</span> <span class="p_context"> snd_emux_inc_count(struct snd_emux *emu)</span>
 	return 1;
 }
 
<span class="p_add">+int snd_emux_inc_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	ret = __snd_emux_inc_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
 /*
  * decrease usage count
  */
<span class="p_del">-void</span>
<span class="p_del">-snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+static void</span>
<span class="p_add">+__snd_emux_dec_count(struct snd_emux *emu)</span>
 {
 	module_put(emu-&gt;card-&gt;module);
 	emu-&gt;used--;
<span class="p_chunk">@@ -298,6 +305,12 @@</span> <span class="p_context"> snd_emux_dec_count(struct snd_emux *emu)</span>
 	module_put(emu-&gt;ops.owner);
 }
 
<span class="p_add">+void snd_emux_dec_count(struct snd_emux *emu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
<span class="p_add">+	mutex_unlock(&amp;emu-&gt;register_mutex);</span>
<span class="p_add">+}</span>
 
 /*
  * Routine that is called upon a first use of a particular port
<span class="p_chunk">@@ -317,7 +330,7 @@</span> <span class="p_context"> snd_emux_use(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_init_port(p);
<span class="p_del">-	snd_emux_inc_count(emu);</span>
<span class="p_add">+	__snd_emux_inc_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }
<span class="p_chunk">@@ -340,7 +353,7 @@</span> <span class="p_context"> snd_emux_unuse(void *private_data, struct snd_seq_port_subscribe *info)</span>
 
 	mutex_lock(&amp;emu-&gt;register_mutex);
 	snd_emux_sounds_off_all(p);
<span class="p_del">-	snd_emux_dec_count(emu);</span>
<span class="p_add">+	__snd_emux_dec_count(emu);</span>
 	mutex_unlock(&amp;emu-&gt;register_mutex);
 	return 0;
 }

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



