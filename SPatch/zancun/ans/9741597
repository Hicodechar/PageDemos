
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[6/7] RISC-V: arch/riscv/kernel - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [6/7] RISC-V: arch/riscv/kernel</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 23, 2017, 12:41 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170523004107.536-7-palmer@dabbelt.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9741597/mbox/"
   >mbox</a>
|
   <a href="/patch/9741597/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9741597/">/patch/9741597/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9FAF260388 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 May 2017 00:44:49 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 888432876F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 May 2017 00:44:49 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7B0CC2877A; Tue, 23 May 2017 00:44:49 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-4.7 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	URIBL_BLACK autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E501A2876F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 May 2017 00:44:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1758242AbdEWAoj (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 22 May 2017 20:44:39 -0400
Received: from mail-pf0-f196.google.com ([209.85.192.196]:36134 &quot;EHLO
	mail-pf0-f196.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S935109AbdEWAnT (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 22 May 2017 20:43:19 -0400
Received: by mail-pf0-f196.google.com with SMTP id n23so23430571pfb.3
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Mon, 22 May 2017 17:43:19 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=dabbelt-com.20150623.gappssmtp.com; s=20150623;
	h=from:to:to:to:cc:cc:subject:date:message-id:in-reply-to:references; 
	bh=g/+9jopqWWzbI/90fw6sevb2wYbvZhCA52UlMrEDB90=;
	b=Qv1p+Ph0iH1NvupPV6hq6+zMpyEKD/Bk6kBLm9nb7UpKcpsMTOBw7XOehCy7RWsfrl
	QtxeuFRVTM5qbAvfLeVnBnOvVSnAR99eU6+eXCLz+aleMs+VwIHWZKbCl7BwrgFsxjHu
	rGiThpZMLz6vG8NmpptX/DCNPMsQ0U53o1LCOQie4noQyl46vADD5/QMrWHeMnjIsB1q
	egisKvzH+4RTaMfH80IBenQwXeDZ9baFCWVDeY7XbgEJA1kYb1ZFX0FW0qzqTDLd7X3E
	ZA+xk7HPuGZB0Y8O9oyX+ZELH4RmSmJk3mwUDq+24VzPNgqkr0t2GY9/dFuePCx/qIGx
	yEMg==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:to:to:cc:cc:subject:date:message-id
	:in-reply-to:references;
	bh=g/+9jopqWWzbI/90fw6sevb2wYbvZhCA52UlMrEDB90=;
	b=jBqljMB+7QyHSCx+bMzmzpEGgG3Zv7YncSGoq0Ewu9Vj1eb+L1mzh7NyXQUeCf+Mp8
	GU741PuIpuSEfs3lBMrn70EZVsJEDBshxshrCTHanidvYOYAJ4kjF8Z5AuNifbcLY1BL
	dAkJO2zAL58Mj+lfltFqvK7J1qym7Y8cDJp7fA9DNoLMJckxLX0g5/eL3frQ1ATyFDv6
	X9xZVhrPyDWWOPzlG3pvN42aD7HL5+DJiv8vQGFpJapYJ1Etc18NNZhrATQPvp0FclLH
	9F3TH4vNbIYj3uxa7ouxn1RuPEas6KpvbBX2TNJj4iuQlZgd+JI73mpyj0FGol1FdxIE
	bdRw==
X-Gm-Message-State: AODbwcDBOk9RunyTujaOLchw7bXjWFTOxv5cedXUhZvSnYbdFCwTLIyo
	pJjdDy0U9oOcAWpU
X-Received: by 10.84.231.139 with SMTP id g11mr17833113plk.71.1495500191914; 
	Mon, 22 May 2017 17:43:11 -0700 (PDT)
Received: from localhost (c-24-5-193-41.hsd1.ca.comcast.net. [24.5.193.41])
	by smtp.gmail.com with ESMTPSA id
	h84sm9850012pfh.45.2017.05.22.17.43.10
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Mon, 22 May 2017 17:43:11 -0700 (PDT)
From: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
To: linux-kernel@vger.kernel.org
To: Arnd Bergmann &lt;arnd@arndb.de&gt;
To: olof@lixom.net
Cc: albert@sifive.com
Cc: Palmer Dabbelt &lt;palmer@dabbelt.com&gt;
Subject: [PATCH 6/7] RISC-V: arch/riscv/kernel
Date: Mon, 22 May 2017 17:41:06 -0700
Message-Id: &lt;20170523004107.536-7-palmer@dabbelt.com&gt;
X-Mailer: git-send-email 2.13.0
In-Reply-To: &lt;20170523004107.536-1-palmer@dabbelt.com&gt;
References: &lt;20170523004107.536-1-palmer@dabbelt.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - May 23, 2017, 12:41 a.m.</div>
<pre class="content">
---
 arch/riscv/kernel/Makefile         |  19 ++
 arch/riscv/kernel/asm-offsets.c    | 113 ++++++++++
 arch/riscv/kernel/cacheinfo.c      |  82 ++++++++
 arch/riscv/kernel/cpu.c            |  81 ++++++++
 arch/riscv/kernel/entry.S          | 414 +++++++++++++++++++++++++++++++++++++
 arch/riscv/kernel/head.S           | 139 +++++++++++++
 arch/riscv/kernel/irq.c            | 205 ++++++++++++++++++
 arch/riscv/kernel/module.c         | 185 +++++++++++++++++
 arch/riscv/kernel/pci.c            |  36 ++++
 arch/riscv/kernel/plic.c           | 208 +++++++++++++++++++
 arch/riscv/kernel/process.c        | 130 ++++++++++++
 arch/riscv/kernel/ptrace.c         | 148 +++++++++++++
 arch/riscv/kernel/reset.c          |  33 +++
 arch/riscv/kernel/riscv_ksyms.c    |  16 ++
 arch/riscv/kernel/sbi-con.c        | 214 +++++++++++++++++++
 arch/riscv/kernel/setup.c          | 234 +++++++++++++++++++++
 arch/riscv/kernel/signal.c         | 258 +++++++++++++++++++++++
 arch/riscv/kernel/smp.c            | 107 ++++++++++
 arch/riscv/kernel/smpboot.c        | 105 ++++++++++
 arch/riscv/kernel/stacktrace.c     | 183 ++++++++++++++++
 arch/riscv/kernel/sys_riscv.c      |  85 ++++++++
 arch/riscv/kernel/syscall_table.c  |  26 +++
 arch/riscv/kernel/time.c           | 116 +++++++++++
 arch/riscv/kernel/traps.c          | 167 +++++++++++++++
 arch/riscv/kernel/vdso.c           | 125 +++++++++++
 arch/riscv/kernel/vdso/.gitignore  |   1 +
 arch/riscv/kernel/vdso/Makefile    |  61 ++++++
 arch/riscv/kernel/vdso/sigreturn.S |  25 +++
 arch/riscv/kernel/vdso/vdso.S      |  28 +++
 arch/riscv/kernel/vdso/vdso.lds.S  |  77 +++++++
 arch/riscv/kernel/vmlinux.lds.S    |  93 +++++++++
 31 files changed, 3714 insertions(+)
 create mode 100644 arch/riscv/kernel/Makefile
 create mode 100644 arch/riscv/kernel/asm-offsets.c
 create mode 100644 arch/riscv/kernel/cacheinfo.c
 create mode 100644 arch/riscv/kernel/cpu.c
 create mode 100644 arch/riscv/kernel/entry.S
 create mode 100644 arch/riscv/kernel/head.S
 create mode 100644 arch/riscv/kernel/irq.c
 create mode 100644 arch/riscv/kernel/module.c
 create mode 100644 arch/riscv/kernel/pci.c
 create mode 100644 arch/riscv/kernel/plic.c
 create mode 100644 arch/riscv/kernel/process.c
 create mode 100644 arch/riscv/kernel/ptrace.c
 create mode 100644 arch/riscv/kernel/reset.c
 create mode 100644 arch/riscv/kernel/riscv_ksyms.c
 create mode 100644 arch/riscv/kernel/sbi-con.c
 create mode 100644 arch/riscv/kernel/setup.c
 create mode 100644 arch/riscv/kernel/signal.c
 create mode 100644 arch/riscv/kernel/smp.c
 create mode 100644 arch/riscv/kernel/smpboot.c
 create mode 100644 arch/riscv/kernel/stacktrace.c
 create mode 100644 arch/riscv/kernel/sys_riscv.c
 create mode 100644 arch/riscv/kernel/syscall_table.c
 create mode 100644 arch/riscv/kernel/time.c
 create mode 100644 arch/riscv/kernel/traps.c
 create mode 100644 arch/riscv/kernel/vdso.c
 create mode 100644 arch/riscv/kernel/vdso/.gitignore
 create mode 100644 arch/riscv/kernel/vdso/Makefile
 create mode 100644 arch/riscv/kernel/vdso/sigreturn.S
 create mode 100644 arch/riscv/kernel/vdso/vdso.S
 create mode 100644 arch/riscv/kernel/vdso/vdso.lds.S
 create mode 100644 arch/riscv/kernel/vmlinux.lds.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=565">Olof Johansson</a> - May 23, 2017, 2:11 a.m.</div>
<pre class="content">
On Mon, May 22, 2017 at 5:41 PM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/riscv/kernel/Makefile         |  19 ++</span>
<span class="quote">&gt;  arch/riscv/kernel/asm-offsets.c    | 113 ++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/cacheinfo.c      |  82 ++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/cpu.c            |  81 ++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/entry.S          | 414 +++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/head.S           | 139 +++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/irq.c            | 205 ++++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/module.c         | 185 +++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/pci.c            |  36 ++++</span>
<span class="quote">&gt;  arch/riscv/kernel/plic.c           | 208 +++++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/process.c        | 130 ++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/ptrace.c         | 148 +++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/reset.c          |  33 +++</span>
<span class="quote">&gt;  arch/riscv/kernel/riscv_ksyms.c    |  16 ++</span>
<span class="quote">&gt;  arch/riscv/kernel/sbi-con.c        | 214 +++++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/setup.c          | 234 +++++++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/signal.c         | 258 +++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/smp.c            | 107 ++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/smpboot.c        | 105 ++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/stacktrace.c     | 183 ++++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/sys_riscv.c      |  85 ++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/syscall_table.c  |  26 +++</span>
<span class="quote">&gt;  arch/riscv/kernel/time.c           | 116 +++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/traps.c          | 167 +++++++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/vdso.c           | 125 +++++++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/vdso/.gitignore  |   1 +</span>
<span class="quote">&gt;  arch/riscv/kernel/vdso/Makefile    |  61 ++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/vdso/sigreturn.S |  25 +++</span>
<span class="quote">&gt;  arch/riscv/kernel/vdso/vdso.S      |  28 +++</span>
<span class="quote">&gt;  arch/riscv/kernel/vdso/vdso.lds.S  |  77 +++++++</span>
<span class="quote">&gt;  arch/riscv/kernel/vmlinux.lds.S    |  93 +++++++++</span>
<span class="quote">&gt;  31 files changed, 3714 insertions(+)</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/Makefile</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/asm-offsets.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/cacheinfo.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/cpu.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/entry.S</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/head.S</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/irq.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/module.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/pci.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/plic.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/process.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/ptrace.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/reset.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/riscv_ksyms.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/sbi-con.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/setup.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/signal.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/smp.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/smpboot.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/stacktrace.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/sys_riscv.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/syscall_table.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/time.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/traps.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/vdso.c</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/vdso/.gitignore</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/vdso/Makefile</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/vdso/sigreturn.S</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/vdso/vdso.S</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/vdso/vdso.lds.S</span>
<span class="quote">&gt;  create mode 100644 arch/riscv/kernel/vmlinux.lds.S</span>

What&#39;s missing from this patchset (ideally) is a good writeup under
DOcumentation/ on expectations of system state (and/or configuration)
upon entry of the kernel. For comparison, see the arm64 documentation
where they were quite specific in this.


This patch is also pushing size limits, and is getting unwieldy to
comment on. I&#39;ll point out a few things below with plenty of snipped
out lines.
<span class="quote">
&gt;</span>
<span class="quote">&gt; diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..94ac2931c56a</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/Makefile</span>
<span class="quote">&gt; @@ -0,0 +1,19 @@</span>
<span class="quote">&gt; +#</span>
<span class="quote">&gt; +# Makefile for the RISC-V Linux kernel</span>
<span class="quote">&gt; +#</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extra-y := head.o vmlinux.lds</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +obj-y  := cpu.o entry.o irq.o process.o ptrace.o reset.o setup.o \</span>
<span class="quote">&gt; +          signal.o syscall_table.o sys_riscv.o time.o traps.o \</span>
<span class="quote">&gt; +          riscv_ksyms.o stacktrace.o vdso.o cacheinfo.o vdso/</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +CFLAGS_setup.o := -mcmodel=medany</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +obj-$(CONFIG_SMP)              += smpboot.o smp.o</span>
<span class="quote">&gt; +obj-$(CONFIG_SBI_CONSOLE)      += sbi-con.o</span>
<span class="quote">&gt; +obj-$(CONFIG_PCI)              += pci.o</span>
<span class="quote">&gt; +obj-$(CONFIG_MODULES)          += module.o</span>
<span class="quote">&gt; +obj-$(CONFIG_PLIC)             += plic.o</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +clean:</span>
<span class="quote">&gt; diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..ac2e0cfaf8a3</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/asm-offsets.c</span>
<span class="quote">&gt; @@ -0,0 +1,113 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>

Hmm, I haven&#39;t seen these terms used often, but they seem to exist
around the tree in a few places. arch/tile is littered with them.

I am not a lawyer, but I can&#39;t seem any reference to &quot;good title&quot; in
the GPLv2 text.

Rather than having to go through the process of figuring out if this
license header is acceptable or not, you might find it easier to just
go with something more established.
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/cacheinfo.c b/arch/riscv/kernel/cacheinfo.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..a22ea8abbf3c</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/cacheinfo.c</span>
<span class="quote">&gt; @@ -0,0 +1,82 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2017 SiFive</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/cacheinfo.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/cpu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_device.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="quote">&gt; +                         struct device_node *node,</span>
<span class="quote">&gt; +                         enum cache_type type, unsigned int level)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +        this_leaf-&gt;of_node = node;</span>
<span class="quote">&gt; +        this_leaf-&gt;level = level;</span>
<span class="quote">&gt; +        this_leaf-&gt;type = type;</span>
<span class="quote">&gt; +        this_leaf-&gt;physical_line_partition = 1; // not a sector cache</span>
<span class="quote">&gt; +        this_leaf-&gt;attributes = CACHE_WRITE_BACK | CACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE; // TODO: add to DTS</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init_cache_level(unsigned int cpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="quote">&gt; +       struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="quote">&gt; +       int levels = 0, leaves = 0, level;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (of_property_read_bool(np, &quot;cache-size&quot;)) ++leaves;</span>
<span class="quote">&gt; +       if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ++leaves;</span>
<span class="quote">&gt; +       if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ++leaves;</span>
<span class="quote">&gt; +       if (leaves &gt; 0) levels = 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       while ((np = of_find_next_cache_node(np))) {</span>
<span class="quote">&gt; +               if (!of_device_is_compatible(np, &quot;cache&quot;)) break;</span>
<span class="quote">&gt; +               if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level)) break;</span>
<span class="quote">&gt; +               if (level &lt;= levels) break;</span>
<span class="quote">&gt; +               if (of_property_read_bool(np, &quot;cache-size&quot;)) ++leaves;</span>
<span class="quote">&gt; +               if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ++leaves;</span>
<span class="quote">&gt; +               if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ++leaves;</span>
<span class="quote">&gt; +               levels = level;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       this_cpu_ci-&gt;num_levels = levels;</span>
<span class="quote">&gt; +       this_cpu_ci-&gt;num_leaves = leaves;</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __populate_cache_leaves(unsigned int cpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="quote">&gt; +       struct cacheinfo *this_leaf = this_cpu_ci-&gt;info_list;</span>
<span class="quote">&gt; +       struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="quote">&gt; +       int levels = 1, level = 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (of_property_read_bool(np, &quot;cache-size&quot;))   ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="quote">&gt; +       if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="quote">&gt; +       if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>

Please run checkpatch, kernel coding style doesn&#39;t use one-line ifs
(here nor elsewhere).
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +       while ((np = of_find_next_cache_node(np))) {</span>
<span class="quote">&gt; +               if (!of_device_is_compatible(np, &quot;cache&quot;)) break;</span>
<span class="quote">&gt; +               if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level)) break;</span>
<span class="quote">&gt; +               if (level &lt;= levels) break;</span>
<span class="quote">&gt; +               if (of_property_read_bool(np, &quot;cache-size&quot;))   ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="quote">&gt; +               if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="quote">&gt; +               if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="quote">&gt; +               levels = level;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)</span>
<span class="quote">&gt; +DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)</span>
<span class="quote">&gt; diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..9cbf53eb58be</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/cpu.c</span>
<span class="quote">&gt; @@ -0,0 +1,81 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/init.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/seq_file.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Return -1 if not a valid hart */</span>
<span class="quote">&gt; +int riscv_of_processor_hart(struct device_node *node)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       const char *isa, *status;</span>
<span class="quote">&gt; +       u32 hart;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!of_device_is_compatible(node, &quot;riscv&quot;)) return -1;</span>
<span class="quote">&gt; +       if (of_property_read_u32(node, &quot;reg&quot;, &amp;hart) || hart &gt;= NR_CPUS) return -1;</span>
<span class="quote">&gt; +       if (of_property_read_string(node, &quot;status&quot;, &amp;status) || strcmp(status, &quot;okay&quot;)) return -1;</span>
<span class="quote">&gt; +       if (of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa) || isa[0] != &#39;r&#39; || isa[1] != &#39;v&#39;) return -1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return hart;</span>
<span class="quote">&gt; +}</span>

We usually prefer to see real -E&lt;foo&gt; returns instead of -1 in the kernel.

[...]
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..52d574206d76</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/head.S</span>
<span class="quote">&gt; @@ -0,0 +1,139 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;asm/thread_info.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/asm-offsets.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/asm.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/init.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/linkage.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/thread_info.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/page.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/csr.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +__INIT</span>
<span class="quote">&gt; +ENTRY(_start)</span>
<span class="quote">&gt; +       /* Mask all interrupts */</span>
<span class="quote">&gt; +       csrw sie, zero</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Disable FPU to detect illegal usage of</span>
<span class="quote">&gt; +          floating point in kernel space */</span>
<span class="quote">&gt; +       li t0, SR_FS</span>
<span class="quote">&gt; +       csrc sstatus, t0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifndef CONFIG_RV_PUM</span>
<span class="quote">&gt; +       /* Allow access to user memory */</span>
<span class="quote">&gt; +       li t0, SR_SUM</span>
<span class="quote">&gt; +       csrs sstatus, t0</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Pick one hart to run the main boot sequence */</span>
<span class="quote">&gt; +       la a3, hart_lottery</span>
<span class="quote">&gt; +       li a2, 1</span>
<span class="quote">&gt; +       amoadd.w a3, a2, (a3)</span>
<span class="quote">&gt; +       bnez a3, .Lsecondary_start</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Save hart ID and DTB physical address */</span>
<span class="quote">&gt; +       mv s0, a0</span>
<span class="quote">&gt; +       mv s1, a1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Initialize page tables and relocate to virtual addresses */</span>
<span class="quote">&gt; +       la sp, init_thread_union + THREAD_SIZE</span>
<span class="quote">&gt; +       call setup_vm</span>
<span class="quote">&gt; +       call relocate</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Restore C environment */</span>
<span class="quote">&gt; +       la tp, init_thread_union</span>
<span class="quote">&gt; +       li sp, THREAD_SIZE</span>
<span class="quote">&gt; +       add sp, sp, tp</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Start the kernel */</span>
<span class="quote">&gt; +       mv a0, s0</span>
<span class="quote">&gt; +       mv a1, s1</span>
<span class="quote">&gt; +       call sbi_save</span>
<span class="quote">&gt; +       tail start_kernel</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +relocate:</span>
<span class="quote">&gt; +       /* Relocate return address */</span>
<span class="quote">&gt; +       li a1, PAGE_OFFSET</span>
<span class="quote">&gt; +       la a0, _start</span>
<span class="quote">&gt; +       sub a1, a1, a0</span>
<span class="quote">&gt; +       add ra, ra, a1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Point stvec to virtual address of intruction after sptbr write */</span>
<span class="quote">&gt; +       la a0, 1f</span>
<span class="quote">&gt; +       add a0, a0, a1</span>
<span class="quote">&gt; +       csrw stvec, a0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Compute sptbr for kernel page tables, but don&#39;t load it yet */</span>
<span class="quote">&gt; +       la a2, swapper_pg_dir</span>
<span class="quote">&gt; +       srl a2, a2, PAGE_SHIFT</span>
<span class="quote">&gt; +       li a1, SPTBR_MODE</span>
<span class="quote">&gt; +       or a2, a2, a1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Load trampoline page directory, which will cause us to trap to</span>
<span class="quote">&gt; +          stvec if VA != PA, or simply fall through if VA == PA */</span>
<span class="quote">&gt; +       la a0, trampoline_pg_dir</span>
<span class="quote">&gt; +       srl a0, a0, PAGE_SHIFT</span>
<span class="quote">&gt; +       or a0, a0, a1</span>
<span class="quote">&gt; +       sfence.vma</span>
<span class="quote">&gt; +       csrw sptbr, a0</span>
<span class="quote">&gt; +1:</span>
<span class="quote">&gt; +       /* Set trap vector to spin forever to help debug */</span>
<span class="quote">&gt; +       la a0, .Lsecondary_park</span>
<span class="quote">&gt; +       csrw stvec, a0</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Load the global pointer */</span>
<span class="quote">&gt; +       la gp, __global_pointer$</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Switch to kernel page tables */</span>
<span class="quote">&gt; +       csrw sptbr, a2</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +.Lsecondary_start:</span>
<span class="quote">&gt; +#ifdef CONFIG_SMP</span>
<span class="quote">&gt; +       li a1, CONFIG_NR_CPUS</span>
<span class="quote">&gt; +       bgeu a0, a1, .Lsecondary_park</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       la a1, __cpu_up_stack_pointer</span>
<span class="quote">&gt; +       slli a0, a0, LGREG</span>
<span class="quote">&gt; +       add a0, a0, a1</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +.Lwait_for_cpu_up:</span>
<span class="quote">&gt; +       REG_L sp, (a0)</span>
<span class="quote">&gt; +       beqz sp, .Lwait_for_cpu_up</span>
<span class="quote">&gt; +       fence</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Enable virtual memory and relocate to virtual address */</span>
<span class="quote">&gt; +       call relocate</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* Initialize task_struct pointer */</span>
<span class="quote">&gt; +       li tp, -THREAD_SIZE</span>
<span class="quote">&gt; +       add tp, tp, sp</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       tail smp_callin</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +.Lsecondary_park:</span>
<span class="quote">&gt; +       /* We lack SMP support or have too many harts, so park this hart */</span>
<span class="quote">&gt; +       wfi</span>
<span class="quote">&gt; +       j .Lsecondary_park</span>
<span class="quote">&gt; +END(_start)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +__PAGE_ALIGNED_BSS</span>
<span class="quote">&gt; +       /* Empty zero page */</span>
<span class="quote">&gt; +       .balign PAGE_SIZE</span>
<span class="quote">&gt; +ENTRY(empty_zero_page)</span>
<span class="quote">&gt; +       .fill (empty_zero_page + PAGE_SIZE) - ., 1, 0x00</span>
<span class="quote">&gt; +END(empty_zero_page)</span>
<span class="quote">&gt; diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..b772bb9539cf</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/irq.c</span>
<span class="quote">&gt; @@ -0,0 +1,205 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt; + * Copyright (C) 2017 SiFive</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irqchip.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irqdomain.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/ftrace.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/seq_file.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;asm/ptrace.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/sbi.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/smp.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct riscv_irq_data {</span>
<span class="quote">&gt; +       struct irq_chip         chip;</span>
<span class="quote">&gt; +       struct irq_domain       *domain;</span>
<span class="quote">&gt; +       int                     hart;</span>
<span class="quote">&gt; +       char                    name[20];</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +DEFINE_PER_CPU(struct riscv_irq_data, riscv_irq_data);</span>
<span class="quote">&gt; +DEFINE_PER_CPU(atomic_long_t, riscv_early_sie);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_software_interrupt(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +#ifdef CONFIG_SMP</span>
<span class="quote">&gt; +       irqreturn_t ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       ret = handle_ipi();</span>
<span class="quote">&gt; +       if (ret != IRQ_NONE)</span>
<span class="quote">&gt; +               return;</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       BUG();</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +asmlinkage void __irq_entry do_IRQ(unsigned int cause, struct pt_regs *regs)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct pt_regs *old_regs = set_irq_regs(regs);</span>
<span class="quote">&gt; +       irq_enter();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* There are three classes of interrupt: timer, software, and</span>
<span class="quote">&gt; +          external devices.  We dispatch between them here.  External</span>
<span class="quote">&gt; +          device interrupts use the generic IRQ mechanisms. */</span>
<span class="quote">&gt; +       switch (cause) {</span>
<span class="quote">&gt; +               case INTERRUPT_CAUSE_TIMER:</span>
<span class="quote">&gt; +                       riscv_timer_interrupt();</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               case INTERRUPT_CAUSE_SOFTWARE:</span>
<span class="quote">&gt; +                       riscv_software_interrupt();</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               default: {</span>
<span class="quote">&gt; +                       struct irq_domain *domain = per_cpu(riscv_irq_data, smp_processor_id()).domain;</span>

Move this up to top of function and remove the { } wrap, please.
<span class="quote">
&gt; +                       generic_handle_irq(irq_find_mapping(domain, cause));</span>
<span class="quote">&gt; +                       break;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       irq_exit();</span>
<span class="quote">&gt; +       set_irq_regs(old_regs);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int riscv_irqdomain_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hwirq)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct riscv_irq_data *data = d-&gt;host_data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        irq_set_chip_and_handler(irq, &amp;data-&gt;chip, handle_simple_irq);</span>
<span class="quote">&gt; +        irq_set_chip_data(irq, data);</span>
<span class="quote">&gt; +        irq_set_noprobe(irq);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct irq_domain_ops riscv_irqdomain_ops = {</span>
<span class="quote">&gt; +       .map    = riscv_irqdomain_map,</span>
<span class="quote">&gt; +       .xlate  = irq_domain_xlate_onecell,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_mask(struct irq_data *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt; +       BUG_ON(smp_processor_id() != data-&gt;hart);</span>
<span class="quote">&gt; +       csr_clear(sie, 1 &lt;&lt; (long)d-&gt;hwirq);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_unmask(struct irq_data *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt; +       BUG_ON(smp_processor_id() != data-&gt;hart);</span>
<span class="quote">&gt; +       csr_set(sie, 1 &lt;&lt; (long)d-&gt;hwirq);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_enable_helper(void *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       riscv_irq_unmask(d);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_enable(struct irq_data *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt; +       atomic_long_or((1 &lt;&lt; (long)d-&gt;hwirq), &amp;per_cpu(riscv_early_sie, data-&gt;hart));</span>

This is a bit dense to get into without a few words of how it&#39;s
expected to work.
<span class="quote">
&gt; +       if (data-&gt;hart == smp_processor_id()) {</span>
<span class="quote">&gt; +               riscv_irq_unmask(d);</span>
<span class="quote">&gt; +       } else if (cpu_online(data-&gt;hart)) {</span>
<span class="quote">&gt; +               smp_call_function_single(data-&gt;hart, riscv_irq_enable_helper, d, true);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_disable_helper(void *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       riscv_irq_mask(d);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_disable(struct irq_data *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt; +       atomic_long_and(~(1 &lt;&lt; (long)d-&gt;hwirq), &amp;per_cpu(riscv_early_sie, data-&gt;hart));</span>
<span class="quote">&gt; +       if (data-&gt;hart == smp_processor_id()) {</span>
<span class="quote">&gt; +               riscv_irq_mask(d);</span>
<span class="quote">&gt; +       } else if (cpu_online(data-&gt;hart)) {</span>
<span class="quote">&gt; +               smp_call_function_single(data-&gt;hart, riscv_irq_disable_helper, d, true);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_mask_noop(struct irq_data *d) { }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_unmask_noop(struct irq_data *d) { }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void riscv_irq_enable_noop(struct irq_data *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct device_node *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt; +       u32 hart;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (!of_property_read_u32(data, &quot;reg&quot;, &amp;hart)) {</span>
<span class="quote">&gt; +               printk(&quot;WARNING: enabled interrupt %d for missing hart %d (this interrupt has no handler)\n&quot;, (int)d-&gt;hwirq, hart);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct irq_chip riscv_noop_chip = {</span>
<span class="quote">&gt; +       .name = &quot;riscv,cpu-intc,noop&quot;,</span>
<span class="quote">&gt; +       .irq_mask = riscv_irq_mask_noop,</span>
<span class="quote">&gt; +       .irq_unmask = riscv_irq_unmask_noop,</span>
<span class="quote">&gt; +       .irq_enable = riscv_irq_enable_noop,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int riscv_irqdomain_map_noop(struct irq_domain *d, unsigned int irq, irq_hw_number_t hwirq)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct device_node *data = d-&gt;host_data;</span>
<span class="quote">&gt; +       irq_set_chip_and_handler(irq, &amp;riscv_noop_chip, handle_simple_irq);</span>
<span class="quote">&gt; +       irq_set_chip_data(irq, data);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct irq_domain_ops riscv_irqdomain_ops_noop = {</span>
<span class="quote">&gt; +       .map    = riscv_irqdomain_map_noop,</span>
<span class="quote">&gt; +       .xlate  = irq_domain_xlate_onecell,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int riscv_intc_init(struct device_node *node, struct device_node *parent)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       int hart;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if (parent) return 0; // should have no interrupt parent</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       if ((hart = riscv_of_processor_hart(node-&gt;parent)) &gt;= 0) {</span>

Common pattern in kernel is to detect error instead:
    hart = riscv_of_processor_hart(node-&gt;parent);
    if (hart &lt; 0) {
        &lt;from your else side here&gt;
        return 0;
    }
    &lt;body if your if statement here&gt;

    return 0;
<span class="quote">
&gt; +               struct riscv_irq_data *data = &amp;per_cpu(riscv_irq_data, hart);</span>
<span class="quote">&gt; +               snprintf(data-&gt;name, sizeof(data-&gt;name), &quot;riscv,cpu_intc,%d&quot;, hart);</span>
<span class="quote">&gt; +               data-&gt;hart = hart;</span>
<span class="quote">&gt; +               data-&gt;chip.name = data-&gt;name;</span>
<span class="quote">&gt; +               data-&gt;chip.irq_mask = riscv_irq_mask;</span>
<span class="quote">&gt; +               data-&gt;chip.irq_unmask = riscv_irq_unmask;</span>
<span class="quote">&gt; +               data-&gt;chip.irq_enable = riscv_irq_enable;</span>
<span class="quote">&gt; +               data-&gt;chip.irq_disable = riscv_irq_disable;</span>
<span class="quote">&gt; +               data-&gt;domain = irq_domain_add_linear(node, 8*sizeof(uintptr_t), &amp;riscv_irqdomain_ops, data);</span>
<span class="quote">&gt; +               WARN_ON(!data-&gt;domain);</span>
<span class="quote">&gt; +               printk(&quot;%s: %d local interrupts mapped\n&quot;, data-&gt;name, 8*(int)sizeof(uintptr_t));</span>
<span class="quote">&gt; +       } else {</span>
<span class="quote">&gt; +               /* If a hart is disabled, create a no-op irq domain.</span>
<span class="quote">&gt; +                * Devices may still have interrupts connected to those harts.</span>
<span class="quote">&gt; +                * This is not wrong... unless they actually load a driver that needs it!</span>
<span class="quote">&gt; +                */</span>
<span class="quote">&gt; +               irq_domain_add_linear(node, 8*sizeof(uintptr_t), &amp;riscv_irqdomain_ops_noop, node-&gt;parent);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +IRQCHIP_DECLARE(riscv, &quot;riscv,cpu-intc&quot;, riscv_intc_init);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __init init_IRQ(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       irqchip_init();</span>
<span class="quote">&gt; +}</span>
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/pci.c b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..4191a5ffdd67</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt; @@ -0,0 +1,36 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Code borrowed from arch/arm64/kernel/pci.c</span>

So, you should add recursive reference from there (i.e. powerpc).

But in the end, there&#39;s essentially no code in this file. :)
<span class="quote">

&gt; + *</span>
<span class="quote">&gt; + * Copyright (C) 2003 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM</span>
<span class="quote">&gt; + * Copyright (C) 2014 ARM Ltd.</span>
<span class="quote">&gt; + * Copyright (C) 2017 SiFive</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + * modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + * version 2 as published by the Free Software Foundation.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/init.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/pci.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Called after each bus is probed, but before its children are examined</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +void pcibios_fixup_bus(struct pci_bus *bus)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       /* nothing to do, expected to be removed in the future */</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * We don&#39;t have to worry about legacy ISA devices, so nothing to do here</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +resource_size_t pcibios_align_resource(void *data, const struct resource *res,</span>
<span class="quote">&gt; +                               resource_size_t size, resource_size_t align)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       return res-&gt;start;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; diff --git a/arch/riscv/kernel/plic.c b/arch/riscv/kernel/plic.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..5b3d4241f4e2</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/plic.c</span>
<span class="quote">&gt; @@ -0,0 +1,208 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2017 SiFive</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irqchip.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irqchip/chained_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irqdomain.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_address.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define MAX_DEVICES    1024 // 0 is reserved</span>

Seems like an odd comment to have here (and should probably not go at
the end of the line)
<span class="quote">
&gt; +#define MAX_CONTEXTS   15872</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PRIORITY_BASE  0</span>
<span class="quote">&gt; +#define ENABLE_BASE    0x2000</span>
<span class="quote">&gt; +#define ENABLE_SIZE    0x80</span>
<span class="quote">&gt; +#define HART_BASE      0x200000</span>
<span class="quote">&gt; +#define HART_SIZE      0x1000</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PLIC_HART_CONTEXT(data, i)     (struct plic_hart_context *)((char*)data-&gt;reg + HART_BASE + HART_SIZE*i)</span>
<span class="quote">&gt; +#define PLIC_ENABLE_CONTEXT(data, i)   (struct plic_enable_context *)((char*)data-&gt;reg + ENABLE_BASE + ENABLE_SIZE*i)</span>
<span class="quote">&gt; +#define PLIC_PRIORITY(data)            (struct plic_priority *)((char *)data-&gt;reg + PRIORITY_BASE)</span>

Since you have typecasting and stuff here, small static inlines with
appropriate return types seems slightly tidier.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +struct plic_hart_context {</span>
<span class="quote">&gt; +       volatile u32 threshold;</span>
<span class="quote">&gt; +       volatile u32 claim;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct plic_enable_context {</span>
<span class="quote">&gt; +       atomic_t mask[32]; // 32-bit * 32-entry</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct plic_priority {</span>
<span class="quote">&gt; +       volatile u32 prio[MAX_DEVICES];</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct plic_data {</span>
<span class="quote">&gt; +       struct irq_chip         chip;</span>
<span class="quote">&gt; +       struct irq_domain       *domain;</span>
<span class="quote">&gt; +       u32                     ndev;</span>
<span class="quote">&gt; +       void __iomem            *reg;</span>
<span class="quote">&gt; +       int                     handlers;</span>
<span class="quote">&gt; +       struct plic_handler     *handler;</span>
<span class="quote">&gt; +       char                    name[30];</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct plic_handler {</span>
<span class="quote">&gt; +       struct plic_hart_context        *context;</span>
<span class="quote">&gt; +       struct plic_data                *data;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void plic_disable(struct plic_data *data, int i, int hwirq)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct plic_enable_context *enable = PLIC_ENABLE_CONTEXT(data, i);</span>
<span class="quote">&gt; +       atomic_and(~(1 &lt;&lt; (hwirq % 32)), &amp;enable-&gt;mask[hwirq / 32]);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void plic_enable(struct plic_data *data, int i, int hwirq)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct plic_enable_context *enable = PLIC_ENABLE_CONTEXT(data, i);</span>
<span class="quote">&gt; +       atomic_or((1 &lt;&lt; (hwirq % 32)), &amp;enable-&gt;mask[hwirq / 32]);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +// There is no need to mask/unmask PLIC interrupts</span>
<span class="quote">&gt; +// They are &quot;masked&quot; by reading claim and &quot;unmasked&quot; when writing it back.</span>
<span class="quote">&gt; +static void plic_irq_mask(struct irq_data *d) { }</span>
<span class="quote">&gt; +static void plic_irq_unmask(struct irq_data *d) { }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void plic_irq_enable(struct irq_data *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct plic_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt; +       struct plic_priority *priority = PLIC_PRIORITY(data);</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +       iowrite32(1, &amp;priority-&gt;prio[d-&gt;hwirq]);</span>
<span class="quote">&gt; +       for (i = 0; i &lt; data-&gt;handlers; ++i)</span>
<span class="quote">&gt; +               if (data-&gt;handler[i].context)</span>
<span class="quote">&gt; +                       plic_enable(data, i, d-&gt;hwirq);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void plic_irq_disable(struct irq_data *d)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct plic_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt; +       struct plic_priority *priority = PLIC_PRIORITY(data);</span>
<span class="quote">&gt; +       int i;</span>
<span class="quote">&gt; +       iowrite32(0, &amp;priority-&gt;prio[d-&gt;hwirq]);</span>
<span class="quote">&gt; +       for (i = 0; i &lt; data-&gt;handlers; ++i)</span>
<span class="quote">&gt; +               if (data-&gt;handler[i].context)</span>
<span class="quote">&gt; +                       plic_disable(data, i, d-&gt;hwirq);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int plic_irqdomain_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hwirq)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct plic_data *data = d-&gt;host_data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        irq_set_chip_and_handler(irq, &amp;data-&gt;chip, handle_simple_irq);</span>
<span class="quote">&gt; +        irq_set_chip_data(irq, data);</span>
<span class="quote">&gt; +        irq_set_noprobe(irq);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +        return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct irq_domain_ops plic_irqdomain_ops = {</span>
<span class="quote">&gt; +       .map    = plic_irqdomain_map,</span>
<span class="quote">&gt; +       .xlate  = irq_domain_xlate_onecell,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void plic_chained_handle_irq(struct irq_desc *desc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +        struct plic_handler *handler = irq_desc_get_handler_data(desc);</span>
<span class="quote">&gt; +       struct irq_chip *chip = irq_desc_get_chip(desc);</span>

Whitespace.
<span class="quote">
&gt; +       struct irq_domain *domain = handler-&gt;data-&gt;domain;</span>
<span class="quote">&gt; +       u32 what;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       chained_irq_enter(chip, desc);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       while ((what = ioread32(&amp;handler-&gt;context-&gt;claim))) {</span>
<span class="quote">&gt; +               int irq = irq_find_mapping(domain, what);</span>
<span class="quote">&gt; +               if (irq &gt; 0) {</span>
<span class="quote">&gt; +                       generic_handle_irq(irq);</span>
<span class="quote">&gt; +               } else {</span>
<span class="quote">&gt; +                       handle_bad_irq(desc);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +               iowrite32(what, &amp;handler-&gt;context-&gt;claim);</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       chained_irq_exit(chip, desc);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +// TODO: add a /sys interface to set priority + per-hart enables for steering</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int plic_init(struct device_node *node, struct device_node *parent)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct plic_data *data;</span>
<span class="quote">&gt; +       struct resource resource;</span>
<span class="quote">&gt; +       int i, ok = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (WARN_ON(!data)) return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;reg = of_iomap(node, 0);</span>
<span class="quote">&gt; +       if (WARN_ON(!data-&gt;reg)) return -EIO;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       of_property_read_u32(node, &quot;riscv,ndev&quot;, &amp;data-&gt;ndev);</span>
<span class="quote">&gt; +       if (WARN_ON(!data-&gt;ndev)) return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;handlers = of_irq_count(node);</span>
<span class="quote">&gt; +       if (WARN_ON(!data-&gt;handlers)) return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;handler = kzalloc(sizeof(*data-&gt;handler)*data-&gt;handlers, GFP_KERNEL);</span>
<span class="quote">&gt; +       if (WARN_ON(!data-&gt;handler)) return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       data-&gt;domain = irq_domain_add_linear(node, data-&gt;ndev+1, &amp;plic_irqdomain_ops, data);</span>
<span class="quote">&gt; +       if (WARN_ON(!data-&gt;domain)) return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       of_address_to_resource(node, 0, &amp;resource);</span>
<span class="quote">&gt; +       snprintf(data-&gt;name, sizeof(data-&gt;name), &quot;riscv,plic0,%llx&quot;, resource.start);</span>
<span class="quote">&gt; +       data-&gt;chip.name = data-&gt;name;</span>
<span class="quote">&gt; +       data-&gt;chip.irq_mask = plic_irq_mask;</span>
<span class="quote">&gt; +       data-&gt;chip.irq_unmask = plic_irq_unmask;</span>
<span class="quote">&gt; +       data-&gt;chip.irq_enable = plic_irq_enable;</span>
<span class="quote">&gt; +       data-&gt;chip.irq_disable = plic_irq_disable;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (i = 0; i &lt; data-&gt;handlers; ++i) {</span>
<span class="quote">&gt; +               struct plic_handler *handler = &amp;data-&gt;handler[i];</span>
<span class="quote">&gt; +               struct of_phandle_args parent;</span>
<span class="quote">&gt; +               int parent_irq, hwirq;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (of_irq_parse_one(node, i, &amp;parent)) continue;</span>
<span class="quote">&gt; +               if (parent.args[0] == -1) continue; // skip context holes</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               // skip any contexts that lead to inactive harts</span>
<span class="quote">&gt; +               if (of_device_is_compatible(parent.np, &quot;riscv,cpu-intc&quot;) &amp;&amp;</span>
<span class="quote">&gt; +                   parent.np-&gt;parent &amp;&amp;</span>
<span class="quote">&gt; +                   riscv_of_processor_hart(parent.np-&gt;parent) &lt; 0) continue;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               parent_irq = irq_create_of_mapping(&amp;parent);</span>
<span class="quote">&gt; +               if (!parent_irq) continue;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               handler-&gt;context = PLIC_HART_CONTEXT(data, i);</span>
<span class="quote">&gt; +               handler-&gt;data = data;</span>
<span class="quote">&gt; +               iowrite32(0, &amp;handler-&gt;context-&gt;threshold); // hwirq prio must be &gt; this to trigger an interrupt</span>
<span class="quote">&gt; +               for (hwirq = 1; hwirq &lt;= data-&gt;ndev; ++hwirq) plic_disable(data, i, hwirq);</span>
<span class="quote">&gt; +               irq_set_chained_handler_and_data(parent_irq, plic_chained_handle_irq, handler);</span>
<span class="quote">&gt; +               ++ok;</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       printk(&quot;%s: mapped %d interrupts to %d/%d handlers\n&quot;, data-&gt;name, data-&gt;ndev, ok, data-&gt;handlers);</span>
<span class="quote">&gt; +       WARN_ON(!ok);</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +IRQCHIP_DECLARE(plic0, &quot;riscv,plic0&quot;, plic_init);</span>


[wrapping up review of this patch at this point to keep size down]


-Olof
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - May 23, 2017, 1:35 p.m.</div>
<pre class="content">
<span class="quote">&gt; +IRQCHIP_DECLARE(riscv, &quot;riscv,cpu-intc&quot;, riscv_intc_init);</span>

Please move the majority of this file into drivers/irqchip as a
standalone driver.
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/pci.c b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..4191a5ffdd67</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt; @@ -0,0 +1,36 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Code borrowed from arch/arm64/kernel/pci.c</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright (C) 2003 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM</span>
<span class="quote">&gt; + * Copyright (C) 2014 ARM Ltd.</span>
<span class="quote">&gt; + * Copyright (C) 2017 SiFive</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + * modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + * version 2 as published by the Free Software Foundation.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/init.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/pci.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Called after each bus is probed, but before its children are examined</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +void pcibios_fixup_bus(struct pci_bus *bus)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       /* nothing to do, expected to be removed in the future */</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * We don&#39;t have to worry about legacy ISA devices, so nothing to do here</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +resource_size_t pcibios_align_resource(void *data, const struct resource *res,</span>
<span class="quote">&gt; +                               resource_size_t size, resource_size_t align)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       return res-&gt;start;</span>
<span class="quote">&gt; +}</span>

Can you add a patch to remove the need for this, and send that to the
PCI maintainers?

In the long run, I think we want both of these to be pci host bridge
driver specific callbacks rather than per-architecture definitions, but
for the moment, moving the empty version as a __weak copy
into drivers/pci/ should be sufficient.

[note: don&#39;t ever use __weak elsewhere, the use in PCI is
 only done for historic reasons and we want to get rid of that
 too, but for now it&#39;s more important to avoid adding yet another
 pointless copy]

If you don&#39;t care about LPC/ISA devices, then your PCI_MIN_IO
should also be zero instead of 0x1000
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/plic.c b/arch/riscv/kernel/plic.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..5b3d4241f4e2</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/plic.c</span>

drivers/irqchip/riscv-plic.c

The file needs some work for following coding style, once that
is done, please submit to the irqchip maintainers.
<span class="quote">
&gt; +#define PLIC_HART_CONTEXT(data, i)     (struct plic_hart_context *)((char*)data-&gt;reg + HART_BASE + HART_SIZE*i)</span>
<span class="quote">&gt; +#define PLIC_ENABLE_CONTEXT(data, i)   (struct plic_enable_context *)((char*)data-&gt;reg + ENABLE_BASE + ENABLE_SIZE*i)</span>
<span class="quote">&gt; +#define PLIC_PRIORITY(data)            (struct plic_priority *)((char *)data-&gt;reg + PRIORITY_BASE)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct plic_hart_context {</span>
<span class="quote">&gt; +       volatile u32 threshold;</span>
<span class="quote">&gt; +       volatile u32 claim;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct plic_enable_context {</span>
<span class="quote">&gt; +       atomic_t mask[32]; // 32-bit * 32-entry</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct plic_priority {</span>
<span class="quote">&gt; +       volatile u32 prio[MAX_DEVICES];</span>
<span class="quote">&gt; +};</span>

The &#39;volatile&#39; seems misplaced here. What is it for?
<span class="quote">
&gt; +// TODO: add a /sys interface to set priority + per-hart enables for steering</span>

No driver-private sysfs interfaces please for irqchips please.
See http://elixir.free-electrons.com/linux/latest/source/Documentation/IRQ-affinity.txt
for setting the affinity.
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/reset.c b/arch/riscv/kernel/reset.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..58bad9598e21</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/reset.c</span>
<span class="quote">&gt; @@ -0,0 +1,33 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/reboot.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/export.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/sbi.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void (*pm_power_off)(void) = machine_power_off;</span>
<span class="quote">&gt; +EXPORT_SYMBOL(pm_power_off);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void machine_restart(char *cmd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +}</span>

Call do_kernel_restart(cmd) here.
<span class="quote">
&gt; +void machine_halt(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +}</span>

This should not return. Either make it call sbi_shutdown as well,
or use the ARM implementation:

void machine_halt(void)
{
        local_irq_disable();
        smp_send_stop();
        while (1);
}
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/sbi-con.c b/arch/riscv/kernel/sbi-con.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..86baeb5ef0cd</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/sbi-con.c</span>

As Olof said, move it to drivers/tty/hvc/ and use those helpers.
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/sys_riscv.c b/arch/riscv/kernel/sys_riscv.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..3e07308e24f5</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/sys_riscv.c</span>
<span class="quote">&gt; @@ -0,0 +1,85 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt; + * Copyright (C) 2014 Darius Rad &lt;darius@bluespec.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt; + *   more details.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/syscalls.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/unistd.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,</span>
<span class="quote">&gt; +       unsigned long, prot, unsigned long, flags,</span>
<span class="quote">&gt; +       unsigned long, fd, off_t, offset)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       if (unlikely(offset &amp; (~PAGE_MASK)))</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       return sys_mmap_pgoff(addr, len, prot, flags, fd, offset &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#ifndef CONFIG_64BIT</span>
<span class="quote">&gt; +SYSCALL_DEFINE6(mmap2, unsigned long, addr, unsigned long, len,</span>
<span class="quote">&gt; +       unsigned long, prot, unsigned long, flags,</span>
<span class="quote">&gt; +       unsigned long, fd, off_t, offset)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       /* Note that the shift for mmap2 is constant (12),</span>
<span class="quote">&gt; +          regardless of PAGE_SIZE */</span>
<span class="quote">&gt; +       if (unlikely(offset &amp; (~PAGE_MASK &gt;&gt; 12)))</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +       return sys_mmap_pgoff(addr, len, prot, flags, fd,</span>
<span class="quote">&gt; +               offset &gt;&gt; (PAGE_SHIFT - 12));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +#endif /* !CONFIG_64BIT */</span>

The first one should be CONFIG_64BIT only.
<span class="quote">
&gt; +#ifdef CONFIG_RV_SYSRISCV_ATOMIC</span>
<span class="quote">&gt; +SYSCALL_DEFINE4(sysriscv, unsigned long, cmd, unsigned long, arg1,</span>
<span class="quote">&gt; +       unsigned long, arg2, unsigned long, arg3)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       unsigned long flags;</span>
<span class="quote">&gt; +       unsigned long prev;</span>
<span class="quote">&gt; +       unsigned int *ptr;</span>
<span class="quote">&gt; +       unsigned int err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       switch (cmd) {</span>
<span class="quote">&gt; +       case RISCV_ATOMIC_CMPXCHG:</span>
<span class="quote">&gt; +               ptr = (unsigned int *)arg1;</span>
<span class="quote">&gt; +               if (!access_ok(VERIFY_WRITE, ptr, sizeof(unsigned int)))</span>
<span class="quote">&gt; +                       return -EFAULT;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               preempt_disable();</span>
<span class="quote">&gt; +               raw_local_irq_save(flags);</span>
<span class="quote">&gt; +               err = __get_user(prev, ptr);</span>
<span class="quote">&gt; +               if (likely(!err &amp;&amp; prev == arg2))</span>
<span class="quote">&gt; +                       err = __put_user(arg3, ptr);</span>
<span class="quote">&gt; +               raw_local_irq_restore(flags);</span>
<span class="quote">&gt; +               preempt_enable();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               return unlikely(err) ? err : prev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       case RISCV_ATOMIC_CMPXCHG64:</span>

Make these two separate syscalls and get rid of the wrapper
(I already mentioned it in the header file comments, but it
fits better here).

It may be good to have an optimized version in the vdso
that does an atomic operation directly if the CPU supports
it.
<span class="quote">
&gt; diff --git a/arch/riscv/kernel/time.c b/arch/riscv/kernel/time.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..ce8c459fadaa</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/riscv/kernel/time.c</span>

drivers/clocksource/riscv-timer.c, and submit it to the
respective maintainers.

      Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - May 25, 2017, 1:59 a.m.</div>
<pre class="content">
On Mon, 22 May 2017 19:11:35 PDT (-0700), olof@lixom.net wrote:
<span class="quote">&gt; On Mon, May 22, 2017 at 5:41 PM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:</span>
<span class="quote">&gt; What&#39;s missing from this patchset (ideally) is a good writeup under</span>
<span class="quote">&gt; DOcumentation/ on expectations of system state (and/or configuration)</span>
<span class="quote">&gt; upon entry of the kernel. For comparison, see the arm64 documentation</span>
<span class="quote">&gt; where they were quite specific in this.</span>

We don&#39;t have a spec written for this yet, but one is being written.  Is it OK
if I wait until there&#39;s a spec?
<span class="quote">
&gt; This patch is also pushing size limits, and is getting unwieldy to</span>
<span class="quote">&gt; comment on. I&#39;ll point out a few things below with plenty of snipped</span>
<span class="quote">&gt; out lines.</span>

I&#39;m also going to start dropping diffs, as this is very big.
<span class="quote">
&gt;&gt; +++ b/arch/riscv/kernel/asm-offsets.c</span>
<span class="quote">&gt;&gt; @@ -0,0 +1,113 @@</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt;&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt;&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt;&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt;&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt;&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt;&gt; + *   more details.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Hmm, I haven&#39;t seen these terms used often, but they seem to exist</span>
<span class="quote">&gt; around the tree in a few places. arch/tile is littered with them.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I am not a lawyer, but I can&#39;t seem any reference to &quot;good title&quot; in</span>
<span class="quote">&gt; the GPLv2 text.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Rather than having to go through the process of figuring out if this</span>
<span class="quote">&gt; license header is acceptable or not, you might find it easier to just</span>
<span class="quote">&gt; go with something more established.</span>

This almost certainly came from Tilera: I stole our ptrace from there becuase
that was the ISA I understood best, and that header must have proliferated
everywhere else.

I&#39;ve changed it to a header I copied from ARM

  https://github.com/riscv/riscv-linux/commit/ccc4f51b40b28adf01b14ed6578bf26dc02f1425
<span class="quote">
&gt;&gt; +static int __populate_cache_leaves(unsigned int cpu)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="quote">&gt;&gt; +       struct cacheinfo *this_leaf = this_cpu_ci-&gt;info_list;</span>
<span class="quote">&gt;&gt; +       struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="quote">&gt;&gt; +       int levels = 1, level = 1;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (of_property_read_bool(np, &quot;cache-size&quot;))   ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="quote">&gt;&gt; +       if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="quote">&gt;&gt; +       if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Please run checkpatch, kernel coding style doesn&#39;t use one-line ifs</span>
<span class="quote">&gt; (here nor elsewhere).</span>

I went through and fixed many of the checkpatch messages.  The ones that are
left fall into the following categories:

 * Lots of uses of BUG/BUG_ON instead of WARN_ON.  Lots of these are in boot
   code, but some of them can probably be fixed.

 * Parens around single-statement __asm__ macros.  For these I also get a
   message when they&#39;re wrapped in &quot;do {} while (0)&quot;, so I&#39;m not sure what else
   to do.

 * Parens around macros like &quot;#define RISCV_PTR .dword&quot;.  These can&#39;t have
   parens because they go directly to the assembler, so I&#39;m considering this a
   false-positive.

 * Warnings about volatile in function declarations in bitops.h.  These are
   copied from other architectures.  There were a handful of other volatiles
   that I fixed,, but I think these should stay.

 * Definitions like ARCH_HAS_SETUP_ADDITIONAL_PAGES, these are also present in
   other architectures.

 * We added new typedefs, I can remove these if that&#39;s a problem.  They&#39;re
   there to match our other code (bootloader and simulator).

 * A handful of lines over 80 characters that I think are onerous to break any
   more.

 * Some warnings about printk() not having a KERN_ prefix.  I fixed a handful
   of these, but the remaining ones I don&#39;t know how to fix (in show_regs, for
   example, where arm64 also has them).

 * Extern declarations in C files, all of which link to symbols in assembly or
   linker scripts.  These were copied from other architectures.

There&#39;s also a bunch of false positives:

 * The spelling of SEPC, which is correct (Supervisor Exception Program
   Counter).

 * Fall-through warnings, probably getting confused by the break looking like
   &quot;break; \&quot; (they&#39;re in macros).

I&#39;ll make another pass on these before a v2 patch set.
<span class="quote">
&gt;&gt; +/* Return -1 if not a valid hart */</span>
<span class="quote">&gt;&gt; +int riscv_of_processor_hart(struct device_node *node)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       const char *isa, *status;</span>
<span class="quote">&gt;&gt; +       u32 hart;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (!of_device_is_compatible(node, &quot;riscv&quot;)) return -1;</span>
<span class="quote">&gt;&gt; +       if (of_property_read_u32(node, &quot;reg&quot;, &amp;hart) || hart &gt;= NR_CPUS) return -1;</span>
<span class="quote">&gt;&gt; +       if (of_property_read_string(node, &quot;status&quot;, &amp;status) || strcmp(status, &quot;okay&quot;)) return -1;</span>
<span class="quote">&gt;&gt; +       if (of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa) || isa[0] != &#39;r&#39; || isa[1] != &#39;v&#39;) return -1;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       return hart;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; We usually prefer to see real -E&lt;foo&gt; returns instead of -1 in the kernel.</span>

Makes sense.  https://github.com/riscv/riscv-linux/commit/10ef72b2aa16b2b69f9f349cffc06d12e183a56e
<span class="quote">
&gt;&gt; +asmlinkage void __irq_entry do_IRQ(unsigned int cause, struct pt_regs *regs)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       struct pt_regs *old_regs = set_irq_regs(regs);</span>
<span class="quote">&gt;&gt; +       irq_enter();</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       /* There are three classes of interrupt: timer, software, and</span>
<span class="quote">&gt;&gt; +          external devices.  We dispatch between them here.  External</span>
<span class="quote">&gt;&gt; +          device interrupts use the generic IRQ mechanisms. */</span>
<span class="quote">&gt;&gt; +       switch (cause) {</span>
<span class="quote">&gt;&gt; +               case INTERRUPT_CAUSE_TIMER:</span>
<span class="quote">&gt;&gt; +                       riscv_timer_interrupt();</span>
<span class="quote">&gt;&gt; +                       break;</span>
<span class="quote">&gt;&gt; +               case INTERRUPT_CAUSE_SOFTWARE:</span>
<span class="quote">&gt;&gt; +                       riscv_software_interrupt();</span>
<span class="quote">&gt;&gt; +                       break;</span>
<span class="quote">&gt;&gt; +               default: {</span>
<span class="quote">&gt;&gt; +                       struct irq_domain *domain = per_cpu(riscv_irq_data, smp_processor_id()).domain;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Move this up to top of function and remove the { } wrap, please.</span>

https://github.com/riscv/riscv-linux/commit/17879136caa05ed9f686736b3343f4b2063920ab
<span class="quote">
&gt;&gt; +static void riscv_irq_enable(struct irq_data *d)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="quote">&gt;&gt; +       atomic_long_or((1 &lt;&lt; (long)d-&gt;hwirq), &amp;per_cpu(riscv_early_sie, data-&gt;hart));</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This is a bit dense to get into without a few words of how it&#39;s</span>
<span class="quote">&gt; expected to work.</span>

OK, how does this look? https://github.com/riscv/riscv-linux/commit/112fd2d882c2363508a660061da558d772a4ff0b
<span class="quote">
&gt;&gt; +static int riscv_intc_init(struct device_node *node, struct device_node *parent)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       int hart;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (parent) return 0; // should have no interrupt parent</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if ((hart = riscv_of_processor_hart(node-&gt;parent)) &gt;= 0) {</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Common pattern in kernel is to detect error instead:</span>
<span class="quote">&gt;     hart = riscv_of_processor_hart(node-&gt;parent);</span>
<span class="quote">&gt;     if (hart &lt; 0) {</span>
<span class="quote">&gt;         &lt;from your else side here&gt;</span>
<span class="quote">&gt;         return 0;</span>
<span class="quote">&gt;     }</span>
<span class="quote">&gt;     &lt;body if your if statement here&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;     return 0;</span>

OK.  I&#39;ve fixed this one here

  https://github.com/riscv/riscv-linux/commit/5f48d9ba0d3cd19dc0bf95f66370de4cfcd84cca

I&#39;ll try to remember to fix any others that I come across.
<span class="quote">
&gt;&gt; diff --git a/arch/riscv/kernel/pci.c b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 000000000000..4191a5ffdd67</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt;&gt; @@ -0,0 +1,36 @@</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Code borrowed from arch/arm64/kernel/pci.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So, you should add recursive reference from there (i.e. powerpc).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; But in the end, there&#39;s essentially no code in this file. :)</span>

Well, now there&#39;s more copyright notices than lines of code... :)

  https://github.com/riscv/riscv-linux/commit/5ad312f755935319fdbb6739377b400ea81cd2ec
<span class="quote">
&gt;&gt; +#define MAX_DEVICES    1024 // 0 is reserved</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Seems like an odd comment to have here (and should probably not go at</span>
<span class="quote">&gt; the end of the line)</span>

Device 0 in the PLIC is reserved to mean &quot;no device&quot;, which means &quot;MAX_DEVICES&quot;
is a bit of an odd name (there can only be MAX_DEVICES-1 devices).  I&#39;ve added
a larger comment to describe this better.

  https://github.com/riscv/riscv-linux/commit/9d16413051dd86db0fb8a792f3d5f05ce788d145
<span class="quote">
&gt;&gt; +#define PLIC_HART_CONTEXT(data, i)     (struct plic_hart_context *)((char*)data-&gt;reg + HART_BASE + HART_SIZE*i)</span>
<span class="quote">&gt;&gt; +#define PLIC_ENABLE_CONTEXT(data, i)   (struct plic_enable_context *)((char*)data-&gt;reg + ENABLE_BASE + ENABLE_SIZE*i)</span>
<span class="quote">&gt;&gt; +#define PLIC_PRIORITY(data)            (struct plic_priority *)((char *)data-&gt;reg + PRIORITY_BASE)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Since you have typecasting and stuff here, small static inlines with</span>
<span class="quote">&gt; appropriate return types seems slightly tidier.</span>

OK.  https://github.com/riscv/riscv-linux/commit/c416649b203276d944be595d87caf042c998727f
<span class="quote">
&gt;&gt; +static void plic_chained_handle_irq(struct irq_desc *desc)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +        struct plic_handler *handler = irq_desc_get_handler_data(desc);</span>
<span class="quote">&gt;&gt; +       struct irq_chip *chip = irq_desc_get_chip(desc);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Whitespace.</span>

These were fixed along with the other checkpatch messages.
<span class="quote">

&gt; [wrapping up review of this patch at this point to keep size down]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; -Olof</span>

Thanks for the comments!  I&#39;ll batch these up into a v2 when I&#39;m done with
everyone&#39;s comments from this round.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1167">Pavel Machek</a> - May 25, 2017, 5:05 p.m.</div>
<pre class="content">
Hi!
<span class="quote">
&gt; +static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="quote">&gt; +                         struct device_node *node,</span>
<span class="quote">&gt; +                         enum cache_type type, unsigned int level)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +        this_leaf-&gt;of_node = node;</span>
<span class="quote">&gt; +        this_leaf-&gt;level = level;</span>
<span class="quote">&gt; +        this_leaf-&gt;type = type;</span>
<span class="quote">&gt; +        this_leaf-&gt;physical_line_partition = 1; // not a sector cache</span>
<span class="quote">&gt; +        this_leaf-&gt;attributes = CACHE_WRITE_BACK | CACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE; // TODO: add to DTS</span>
<span class="quote">&gt; +}</span>

You may want to run the patches through checkpatch. (Comment style,
long lines).
<span class="quote">
&gt; +static int __populate_cache_leaves(unsigned int cpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="quote">&gt; +	struct cacheinfo *this_leaf = this_cpu_ci-&gt;info_list;</span>
<span class="quote">&gt; +	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="quote">&gt; +	int levels = 1, level = 1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (of_property_read_bool(np, &quot;cache-size&quot;))   ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="quote">&gt; +	if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="quote">&gt; +	if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - May 25, 2017, 7:51 p.m.</div>
<pre class="content">
On Thu, May 25, 2017 at 3:59 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:
<span class="quote">&gt; On Mon, 22 May 2017 19:11:35 PDT (-0700), olof@lixom.net wrote:</span>
<span class="quote">
&gt;  * Parens around single-statement __asm__ macros.  For these I also get a</span>
<span class="quote">&gt;    message when they&#39;re wrapped in &quot;do {} while (0)&quot;, so I&#39;m not sure what else</span>
<span class="quote">&gt;    to do.</span>

I would generally recommend using inline functions for those, and only do
macros when you need them.
<span class="quote">
&gt;  * Parens around macros like &quot;#define RISCV_PTR .dword&quot;.  These can&#39;t have</span>
<span class="quote">&gt;    parens because they go directly to the assembler, so I&#39;m considering this a</span>
<span class="quote">&gt;    false-positive.</span>

agreed
<span class="quote">
&gt;  * Warnings about volatile in function declarations in bitops.h.  These are</span>
<span class="quote">&gt;    copied from other architectures.  There were a handful of other volatiles</span>
<span class="quote">&gt;    that I fixed,, but I think these should stay.</span>

Agreed, bitops.h is one of the few headers that should use &#39;volatile&#39;.
<span class="quote">
&gt;  * Definitions like ARCH_HAS_SETUP_ADDITIONAL_PAGES, these are also present in</span>
<span class="quote">&gt;    other architectures.</span>

What is the warning here? I would assume that you should leave this
unchanged as well.
<span class="quote">
&gt;  * We added new typedefs, I can remove these if that&#39;s a problem.  They&#39;re</span>
<span class="quote">&gt;    there to match our other code (bootloader and simulator).</span>

It depends. What typedefs are those? Removing the typedefs in both
the kernel and the other code that uses the same types is likely the
best option here.
<span class="quote">
&gt;  * A handful of lines over 80 characters that I think are onerous to break any</span>
<span class="quote">&gt;    more.</span>

Right, don&#39;t worry about it too much, and use common sense for this
warning.
<span class="quote">
&gt;  * Some warnings about printk() not having a KERN_ prefix.  I fixed a handful</span>
<span class="quote">&gt;    of these, but the remaining ones I don&#39;t know how to fix (in show_regs, for</span>
<span class="quote">&gt;    example, where arm64 also has them).</span>

KERN_CONT
<span class="quote">
&gt;  * Extern declarations in C files, all of which link to symbols in assembly or</span>
<span class="quote">&gt;    linker scripts.  These were copied from other architectures.</span>

I would try to fix those by using a header even if there is only one user.
I&#39;d actually like to get a compile-time warning for those in the long run,
maybe with &#39;make W=1&#39;, so better don&#39;t introduce new ones.

     Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - June 2, 2017, 11:56 p.m.</div>
<pre class="content">
On Tue, 23 May 2017 06:35:23 PDT (-0700), Arnd Bergmann wrote:
<span class="quote">&gt;&gt; +IRQCHIP_DECLARE(riscv, &quot;riscv,cpu-intc&quot;, riscv_intc_init);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Please move the majority of this file into drivers/irqchip as a</span>
<span class="quote">&gt; standalone driver.</span>

OK.

  https://github.com/riscv/riscv-linux/commit/549c7f5ef63d7be04c9cac7e332ef81ec6ffe103
<span class="quote">
&gt;&gt; diff --git a/arch/riscv/kernel/pci.c b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 000000000000..4191a5ffdd67</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/riscv/kernel/pci.c</span>
<span class="quote">&gt;&gt; @@ -0,0 +1,36 @@</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Code borrowed from arch/arm64/kernel/pci.c</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2003 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2014 ARM Ltd.</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2017 SiFive</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + * This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt;&gt; + * modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt;&gt; + * version 2 as published by the Free Software Foundation.</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#include &lt;linux/init.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/slab.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/pci.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Called after each bus is probed, but before its children are examined</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +void pcibios_fixup_bus(struct pci_bus *bus)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       /* nothing to do, expected to be removed in the future */</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * We don&#39;t have to worry about legacy ISA devices, so nothing to do here</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +resource_size_t pcibios_align_resource(void *data, const struct resource *res,</span>
<span class="quote">&gt;&gt; +                               resource_size_t size, resource_size_t align)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       return res-&gt;start;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can you add a patch to remove the need for this, and send that to the</span>
<span class="quote">&gt; PCI maintainers?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; In the long run, I think we want both of these to be pci host bridge</span>
<span class="quote">&gt; driver specific callbacks rather than per-architecture definitions, but</span>
<span class="quote">&gt; for the moment, moving the empty version as a __weak copy</span>
<span class="quote">&gt; into drivers/pci/ should be sufficient.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; [note: don&#39;t ever use __weak elsewhere, the use in PCI is</span>
<span class="quote">&gt;  only done for historic reasons and we want to get rid of that</span>
<span class="quote">&gt;  too, but for now it&#39;s more important to avoid adding yet another</span>
<span class="quote">&gt;  pointless copy]</span>

Sounds good

  https://github.com/riscv/riscv-linux/commit/4aa540bf849b2a190e288e7d25d262dee21306b3
  https://github.com/riscv/riscv-linux/commit/bb3b4c6ca4841538d101f2b9c437f5dccda0b3a7
<span class="quote">
&gt; If you don&#39;t care about LPC/ISA devices, then your PCI_MIN_IO</span>
<span class="quote">&gt; should also be zero instead of 0x1000</span>

Sorry, but the only Google results for PCI_MIN_IO is this email.  There don&#39;t
appear to be any relevant references to PCI_MIN in the kernel

  $ git grep PCI_MIN_
  arch/mips/include/asm/mach-loongson64/cs5536/cs5536_pci.h:      ((PCI_MAX_LATENCY &lt;&lt; 24) | (PCI_MIN_GRANT &lt;&lt; 16) | \
  arch/mips/include/asm/mach-loongson64/cs5536/cs5536_pci.h:#define PCI_MIN_GRANT                 0x00
  drivers/ata/pata_hpt366.c:      pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);
  drivers/ata/pata_hpt37x.c:      pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);
  drivers/ata/pata_hpt3x2n.c:     pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);
  drivers/ide/hpt366.c:   pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);
  drivers/net/fddi/skfp/h/skfbi.h:#define PCI_MIN_GNT     0x3e    /*  8 bit       Min_Gnt */
  drivers/net/fddi/skfp/h/skfbi.h:/*      PCI_MIN_GNT     8 bit   Min_Gnt */
  include/uapi/linux/pci_regs.h:#define PCI_MIN_GNT               0x3e    /* 8 bits */

I&#39;m afraid that I&#39;m not sure what to do here.
<span class="quote">
&gt;&gt; diff --git a/arch/riscv/kernel/plic.c b/arch/riscv/kernel/plic.c</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 000000000000..5b3d4241f4e2</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/riscv/kernel/plic.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; drivers/irqchip/riscv-plic.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The file needs some work for following coding style, once that</span>
<span class="quote">&gt; is done, please submit to the irqchip maintainers.</span>

I&#39;ve addressed most of this thanks to some other code reviews, so I&#39;m going to
drop the comments that are about things I&#39;ve already fixed.
<span class="quote">
&gt;&gt; +// TODO: add a /sys interface to set priority + per-hart enables for steering</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; No driver-private sysfs interfaces please for irqchips please.</span>
<span class="quote">&gt; See http://elixir.free-electrons.com/linux/latest/source/Documentation/IRQ-affinity.txt</span>
<span class="quote">&gt; for setting the affinity.</span>

We&#39;ll do it the right way when we add IRQ affinity control.  Thanks for the
heads up!
<span class="quote">
&gt;&gt; diff --git a/arch/riscv/kernel/reset.c b/arch/riscv/kernel/reset.c</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 000000000000..58bad9598e21</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/riscv/kernel/reset.c</span>
<span class="quote">&gt;&gt; @@ -0,0 +1,33 @@</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt;&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt;&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt;&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt;&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt;&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt;&gt; + *   more details.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#include &lt;linux/reboot.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;linux/export.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/sbi.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +void (*pm_power_off)(void) = machine_power_off;</span>
<span class="quote">&gt;&gt; +EXPORT_SYMBOL(pm_power_off);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +void machine_restart(char *cmd)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Call do_kernel_restart(cmd) here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +void machine_halt(void)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This should not return. Either make it call sbi_shutdown as well,</span>
<span class="quote">&gt; or use the ARM implementation:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; void machine_halt(void)</span>
<span class="quote">&gt; {</span>
<span class="quote">&gt;         local_irq_disable();</span>
<span class="quote">&gt;         smp_send_stop();</span>
<span class="quote">&gt;         while (1);</span>
<span class="quote">&gt; }</span>

OK.

  https://github.com/riscv/riscv-linux/commit/5f486cb73e3a0a5a218d26781e9eae651e59203f
<span class="quote">
&gt;&gt; diff --git a/arch/riscv/kernel/sbi-con.c b/arch/riscv/kernel/sbi-con.c</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 000000000000..86baeb5ef0cd</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/riscv/kernel/sbi-con.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; As Olof said, move it to drivers/tty/hvc/ and use those helpers.</span>

Ah, that&#39;s great: now there&#39;s almost no code left :)

  https://github.com/riscv/riscv-linux/commit/8adad12c5525a70b8837196b8f2d4ac003a7647c
<span class="quote">
&gt;&gt; diff --git a/arch/riscv/kernel/sys_riscv.c b/arch/riscv/kernel/sys_riscv.c</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 000000000000..3e07308e24f5</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/riscv/kernel/sys_riscv.c</span>
<span class="quote">&gt;&gt; @@ -0,0 +1,85 @@</span>
<span class="quote">&gt;&gt; +/*</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2012 Regents of the University of California</span>
<span class="quote">&gt;&gt; + * Copyright (C) 2014 Darius Rad &lt;darius@bluespec.com&gt;</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *   This program is free software; you can redistribute it and/or</span>
<span class="quote">&gt;&gt; + *   modify it under the terms of the GNU General Public License</span>
<span class="quote">&gt;&gt; + *   as published by the Free Software Foundation, version 2.</span>
<span class="quote">&gt;&gt; + *</span>
<span class="quote">&gt;&gt; + *   This program is distributed in the hope that it will be useful, but</span>
<span class="quote">&gt;&gt; + *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="quote">&gt;&gt; + *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="quote">&gt;&gt; + *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="quote">&gt;&gt; + *   more details.</span>
<span class="quote">&gt;&gt; + */</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#include &lt;linux/syscalls.h&gt;</span>
<span class="quote">&gt;&gt; +#include &lt;asm/unistd.h&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,</span>
<span class="quote">&gt;&gt; +       unsigned long, prot, unsigned long, flags,</span>
<span class="quote">&gt;&gt; +       unsigned long, fd, off_t, offset)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       if (unlikely(offset &amp; (~PAGE_MASK)))</span>
<span class="quote">&gt;&gt; +               return -EINVAL;</span>
<span class="quote">&gt;&gt; +       return sys_mmap_pgoff(addr, len, prot, flags, fd, offset &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +#ifndef CONFIG_64BIT</span>
<span class="quote">&gt;&gt; +SYSCALL_DEFINE6(mmap2, unsigned long, addr, unsigned long, len,</span>
<span class="quote">&gt;&gt; +       unsigned long, prot, unsigned long, flags,</span>
<span class="quote">&gt;&gt; +       unsigned long, fd, off_t, offset)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       /* Note that the shift for mmap2 is constant (12),</span>
<span class="quote">&gt;&gt; +          regardless of PAGE_SIZE */</span>
<span class="quote">&gt;&gt; +       if (unlikely(offset &amp; (~PAGE_MASK &gt;&gt; 12)))</span>
<span class="quote">&gt;&gt; +               return -EINVAL;</span>
<span class="quote">&gt;&gt; +       return sys_mmap_pgoff(addr, len, prot, flags, fd,</span>
<span class="quote">&gt;&gt; +               offset &gt;&gt; (PAGE_SHIFT - 12));</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +#endif /* !CONFIG_64BIT */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The first one should be CONFIG_64BIT only.</span>

OK. https://github.com/riscv/riscv-linux/commit/ed7545c6765ba7d705e1bc6ce7b67bb7e8cb0926
<span class="quote">
&gt;&gt; +#ifdef CONFIG_RV_SYSRISCV_ATOMIC</span>
<span class="quote">&gt;&gt; +SYSCALL_DEFINE4(sysriscv, unsigned long, cmd, unsigned long, arg1,</span>
<span class="quote">&gt;&gt; +       unsigned long, arg2, unsigned long, arg3)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       unsigned long flags;</span>
<span class="quote">&gt;&gt; +       unsigned long prev;</span>
<span class="quote">&gt;&gt; +       unsigned int *ptr;</span>
<span class="quote">&gt;&gt; +       unsigned int err;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       switch (cmd) {</span>
<span class="quote">&gt;&gt; +       case RISCV_ATOMIC_CMPXCHG:</span>
<span class="quote">&gt;&gt; +               ptr = (unsigned int *)arg1;</span>
<span class="quote">&gt;&gt; +               if (!access_ok(VERIFY_WRITE, ptr, sizeof(unsigned int)))</span>
<span class="quote">&gt;&gt; +                       return -EFAULT;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +               preempt_disable();</span>
<span class="quote">&gt;&gt; +               raw_local_irq_save(flags);</span>
<span class="quote">&gt;&gt; +               err = __get_user(prev, ptr);</span>
<span class="quote">&gt;&gt; +               if (likely(!err &amp;&amp; prev == arg2))</span>
<span class="quote">&gt;&gt; +                       err = __put_user(arg3, ptr);</span>
<span class="quote">&gt;&gt; +               raw_local_irq_restore(flags);</span>
<span class="quote">&gt;&gt; +               preempt_enable();</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +               return unlikely(err) ? err : prev;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       case RISCV_ATOMIC_CMPXCHG64:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Make these two separate syscalls and get rid of the wrapper</span>
<span class="quote">&gt; (I already mentioned it in the header file comments, but it</span>
<span class="quote">&gt; fits better here).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; It may be good to have an optimized version in the vdso</span>
<span class="quote">&gt; that does an atomic operation directly if the CPU supports</span>
<span class="quote">&gt; it.</span>

Yep.  It&#39;s on the list.
<span class="quote">
&gt;&gt; diff --git a/arch/riscv/kernel/time.c b/arch/riscv/kernel/time.c</span>
<span class="quote">&gt;&gt; new file mode 100644</span>
<span class="quote">&gt;&gt; index 000000000000..ce8c459fadaa</span>
<span class="quote">&gt;&gt; --- /dev/null</span>
<span class="quote">&gt;&gt; +++ b/arch/riscv/kernel/time.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; drivers/clocksource/riscv-timer.c, and submit it to the</span>
<span class="quote">&gt; respective maintainers.</span>

Sounds good.

  https://github.com/riscv/riscv-linux/commit/d9fcab4603c158755e19663dec0040b28ea1aad1
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - June 3, 2017, 3:32 a.m.</div>
<pre class="content">
On Thu, 25 May 2017 10:05:05 PDT (-0700), pavel@ucw.cz wrote:
<span class="quote">&gt;&gt; +static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="quote">&gt;&gt; +                         struct device_node *node,</span>
<span class="quote">&gt;&gt; +                         enum cache_type type, unsigned int level)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +        this_leaf-&gt;of_node = node;</span>
<span class="quote">&gt;&gt; +        this_leaf-&gt;level = level;</span>
<span class="quote">&gt;&gt; +        this_leaf-&gt;type = type;</span>
<span class="quote">&gt;&gt; +        this_leaf-&gt;physical_line_partition = 1; // not a sector cache</span>
<span class="quote">&gt;&gt; +        this_leaf-&gt;attributes = CACHE_WRITE_BACK | CACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE; // TODO: add to DTS</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You may want to run the patches through checkpatch. (Comment style,</span>
<span class="quote">&gt; long lines).</span>

Thanks.  Someone else suggested this and I&#39;ve fixed most of the errors.  I&#39;ll
submit a v2 with everyone&#39;s feedback once I get through my mail.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - June 6, 2017, 4:56 a.m.</div>
<pre class="content">
On Thu, 25 May 2017 12:51:54 PDT (-0700), Arnd Bergmann wrote:
<span class="quote">&gt; On Thu, May 25, 2017 at 3:59 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On Mon, 22 May 2017 19:11:35 PDT (-0700), olof@lixom.net wrote:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;  * Parens around single-statement __asm__ macros.  For these I also get a</span>
<span class="quote">&gt;&gt;    message when they&#39;re wrapped in &quot;do {} while (0)&quot;, so I&#39;m not sure what else</span>
<span class="quote">&gt;&gt;    to do.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I would generally recommend using inline functions for those, and only do</span>
<span class="quote">&gt; macros when you need them.</span>

We&#39;ve tried to avoid new macros, so these are mostly from places where other
architectures use macros (like mb) or where we need to use CPP token pasting
(like __op_bit).  Should I change things like mb?
<span class="quote">
&gt;&gt;  * Parens around macros like &quot;#define RISCV_PTR .dword&quot;.  These can&#39;t have</span>
<span class="quote">&gt;&gt;    parens because they go directly to the assembler, so I&#39;m considering this a</span>
<span class="quote">&gt;&gt;    false-positive.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; agreed</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;  * Warnings about volatile in function declarations in bitops.h.  These are</span>
<span class="quote">&gt;&gt;    copied from other architectures.  There were a handful of other volatiles</span>
<span class="quote">&gt;&gt;    that I fixed,, but I think these should stay.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Agreed, bitops.h is one of the few headers that should use &#39;volatile&#39;.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;  * Definitions like ARCH_HAS_SETUP_ADDITIONAL_PAGES, these are also present in</span>
<span class="quote">&gt;&gt;    other architectures.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What is the warning here? I would assume that you should leave this</span>
<span class="quote">&gt; unchanged as well.</span>

ERROR: #define of &#39;ARCH_HAS_SETUP_ADDITIONAL_PAGES&#39; is wrong - use Kconfig variables or standard guards instead
#2533: FILE: arch/riscv/include/asm/elf.h:79:
+#define ARCH_HAS_SETUP_ADDITIONAL_PAGES
<span class="quote">
&gt;&gt;  * We added new typedefs, I can remove these if that&#39;s a problem.  They&#39;re</span>
<span class="quote">&gt;&gt;    there to match our other code (bootloader and simulator).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; It depends. What typedefs are those? Removing the typedefs in both</span>
<span class="quote">&gt; the kernel and the other code that uses the same types is likely the</span>
<span class="quote">&gt; best option here.</span>

OK, I&#39;ll add it to my TODO list.
<span class="quote">
&gt;&gt;  * A handful of lines over 80 characters that I think are onerous to break any</span>
<span class="quote">&gt;&gt;    more.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Right, don&#39;t worry about it too much, and use common sense for this</span>
<span class="quote">&gt; warning.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;  * Some warnings about printk() not having a KERN_ prefix.  I fixed a handful</span>
<span class="quote">&gt;&gt;    of these, but the remaining ones I don&#39;t know how to fix (in show_regs, for</span>
<span class="quote">&gt;&gt;    example, where arm64 also has them).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; KERN_CONT</span>

https://github.com/riscv/riscv-linux/commit/98e8fe9cb19d495180a9be03a0aa48c0183dd5be
<span class="quote">
&gt;&gt;  * Extern declarations in C files, all of which link to symbols in assembly or</span>
<span class="quote">&gt;&gt;    linker scripts.  These were copied from other architectures.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I would try to fix those by using a header even if there is only one user.</span>
<span class="quote">&gt; I&#39;d actually like to get a compile-time warning for those in the long run,</span>
<span class="quote">&gt; maybe with &#39;make W=1&#39;, so better don&#39;t introduce new ones.</span>

OK, I&#39;ll fix them.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - June 6, 2017, 9:01 a.m.</div>
<pre class="content">
On Sat, Jun 3, 2017 at 1:56 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:
<span class="quote">&gt; On Tue, 23 May 2017 06:35:23 PDT (-0700), Arnd Bergmann wrote:</span>
<span class="quote">&gt;&gt;&gt; +IRQCHIP_DECLARE(riscv, &quot;riscv,cpu-intc&quot;, riscv_intc_init);</span>
<span class="quote">&gt;&gt; If you don&#39;t care about LPC/ISA devices, then your PCI_MIN_IO</span>
<span class="quote">&gt;&gt; should also be zero instead of 0x1000</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Sorry, but the only Google results for PCI_MIN_IO is this email.  There don&#39;t</span>
<span class="quote">&gt; appear to be any relevant references to PCI_MIN in the kernel</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   $ git grep PCI_MIN_</span>
<span class="quote">&gt;   arch/mips/include/asm/mach-loongson64/cs5536/cs5536_pci.h:      ((PCI_MAX_LATENCY &lt;&lt; 24) | (PCI_MIN_GRANT &lt;&lt; 16) | \</span>
<span class="quote">&gt;   arch/mips/include/asm/mach-loongson64/cs5536/cs5536_pci.h:#define PCI_MIN_GRANT                 0x00</span>
<span class="quote">&gt;   drivers/ata/pata_hpt366.c:      pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;   drivers/ata/pata_hpt37x.c:      pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;   drivers/ata/pata_hpt3x2n.c:     pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;   drivers/ide/hpt366.c:   pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;   drivers/net/fddi/skfp/h/skfbi.h:#define PCI_MIN_GNT     0x3e    /*  8 bit       Min_Gnt */</span>
<span class="quote">&gt;   drivers/net/fddi/skfp/h/skfbi.h:/*      PCI_MIN_GNT     8 bit   Min_Gnt */</span>
<span class="quote">&gt;   include/uapi/linux/pci_regs.h:#define PCI_MIN_GNT               0x3e    /* 8 bits */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;m afraid that I&#39;m not sure what to do here.</span>

Sorry, I meant PCIBIOS_MIN_IO

       Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - June 6, 2017, 9:03 a.m.</div>
<pre class="content">
On Tue, Jun 6, 2017 at 6:56 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:
<span class="quote">&gt; On Thu, 25 May 2017 12:51:54 PDT (-0700), Arnd Bergmann wrote:</span>
<span class="quote">&gt;&gt; On Thu, May 25, 2017 at 3:59 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt; On Mon, 22 May 2017 19:11:35 PDT (-0700), olof@lixom.net wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;  * Definitions like ARCH_HAS_SETUP_ADDITIONAL_PAGES, these are also present in</span>
<span class="quote">&gt;&gt;&gt;    other architectures.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; What is the warning here? I would assume that you should leave this</span>
<span class="quote">&gt;&gt; unchanged as well.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ERROR: #define of &#39;ARCH_HAS_SETUP_ADDITIONAL_PAGES&#39; is wrong - use Kconfig variables or standard guards instead</span>
<span class="quote">&gt; #2533: FILE: arch/riscv/include/asm/elf.h:79:</span>
<span class="quote">&gt; +#define ARCH_HAS_SETUP_ADDITIONAL_PAGES</span>

Ok, you can definitely ignore this one. The warning is meant to prevent adding
new macros like that, but the macro already exists in the other architectures,
and I see no point in converting them all into a CONFIG_ symbol.

       Arnd
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - June 6, 2017, 8:37 p.m.</div>
<pre class="content">
On Tue, 06 Jun 2017 02:01:23 PDT (-0700), Arnd Bergmann wrote:
<span class="quote">&gt; On Sat, Jun 3, 2017 at 1:56 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On Tue, 23 May 2017 06:35:23 PDT (-0700), Arnd Bergmann wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; +IRQCHIP_DECLARE(riscv, &quot;riscv,cpu-intc&quot;, riscv_intc_init);</span>
<span class="quote">&gt;&gt;&gt; If you don&#39;t care about LPC/ISA devices, then your PCI_MIN_IO</span>
<span class="quote">&gt;&gt;&gt; should also be zero instead of 0x1000</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Sorry, but the only Google results for PCI_MIN_IO is this email.  There don&#39;t</span>
<span class="quote">&gt;&gt; appear to be any relevant references to PCI_MIN in the kernel</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;   $ git grep PCI_MIN_</span>
<span class="quote">&gt;&gt;   arch/mips/include/asm/mach-loongson64/cs5536/cs5536_pci.h:      ((PCI_MAX_LATENCY &lt;&lt; 24) | (PCI_MIN_GRANT &lt;&lt; 16) | \</span>
<span class="quote">&gt;&gt;   arch/mips/include/asm/mach-loongson64/cs5536/cs5536_pci.h:#define PCI_MIN_GRANT                 0x00</span>
<span class="quote">&gt;&gt;   drivers/ata/pata_hpt366.c:      pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;&gt;   drivers/ata/pata_hpt37x.c:      pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;&gt;   drivers/ata/pata_hpt3x2n.c:     pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;&gt;   drivers/ide/hpt366.c:   pci_write_config_byte(dev, PCI_MIN_GNT, 0x08);</span>
<span class="quote">&gt;&gt;   drivers/net/fddi/skfp/h/skfbi.h:#define PCI_MIN_GNT     0x3e    /*  8 bit       Min_Gnt */</span>
<span class="quote">&gt;&gt;   drivers/net/fddi/skfp/h/skfbi.h:/*      PCI_MIN_GNT     8 bit   Min_Gnt */</span>
<span class="quote">&gt;&gt;   include/uapi/linux/pci_regs.h:#define PCI_MIN_GNT               0x3e    /* 8 bits */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I&#39;m afraid that I&#39;m not sure what to do here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Sorry, I meant PCIBIOS_MIN_IO</span>

OK, fixed.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=90941">Palmer Dabbelt</a> - June 6, 2017, 8:38 p.m.</div>
<pre class="content">
On Tue, 06 Jun 2017 02:03:51 PDT (-0700), Arnd Bergmann wrote:
<span class="quote">&gt; On Tue, Jun 6, 2017 at 6:56 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:</span>
<span class="quote">&gt;&gt; On Thu, 25 May 2017 12:51:54 PDT (-0700), Arnd Bergmann wrote:</span>
<span class="quote">&gt;&gt;&gt; On Thu, May 25, 2017 at 3:59 AM, Palmer Dabbelt &lt;palmer@dabbelt.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Mon, 22 May 2017 19:11:35 PDT (-0700), olof@lixom.net wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;  * Definitions like ARCH_HAS_SETUP_ADDITIONAL_PAGES, these are also present in</span>
<span class="quote">&gt;&gt;&gt;&gt;    other architectures.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; What is the warning here? I would assume that you should leave this</span>
<span class="quote">&gt;&gt;&gt; unchanged as well.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; ERROR: #define of &#39;ARCH_HAS_SETUP_ADDITIONAL_PAGES&#39; is wrong - use Kconfig variables or standard guards instead</span>
<span class="quote">&gt;&gt; #2533: FILE: arch/riscv/include/asm/elf.h:79:</span>
<span class="quote">&gt;&gt; +#define ARCH_HAS_SETUP_ADDITIONAL_PAGES</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Ok, you can definitely ignore this one. The warning is meant to prevent adding</span>
<span class="quote">&gt; new macros like that, but the macro already exists in the other architectures,</span>
<span class="quote">&gt; and I see no point in converting them all into a CONFIG_ symbol.</span>

Sounds good.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/riscv/kernel/Makefile b/arch/riscv/kernel/Makefile</span>
new file mode 100644
<span class="p_header">index 000000000000..94ac2931c56a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/Makefile</span>
<span class="p_chunk">@@ -0,0 +1,19 @@</span> <span class="p_context"></span>
<span class="p_add">+#</span>
<span class="p_add">+# Makefile for the RISC-V Linux kernel</span>
<span class="p_add">+#</span>
<span class="p_add">+</span>
<span class="p_add">+extra-y := head.o vmlinux.lds</span>
<span class="p_add">+</span>
<span class="p_add">+obj-y	:= cpu.o entry.o irq.o process.o ptrace.o reset.o setup.o \</span>
<span class="p_add">+	   signal.o syscall_table.o sys_riscv.o time.o traps.o \</span>
<span class="p_add">+	   riscv_ksyms.o stacktrace.o vdso.o cacheinfo.o vdso/</span>
<span class="p_add">+</span>
<span class="p_add">+CFLAGS_setup.o := -mcmodel=medany</span>
<span class="p_add">+</span>
<span class="p_add">+obj-$(CONFIG_SMP)		+= smpboot.o smp.o</span>
<span class="p_add">+obj-$(CONFIG_SBI_CONSOLE)	+= sbi-con.o</span>
<span class="p_add">+obj-$(CONFIG_PCI)		+= pci.o</span>
<span class="p_add">+obj-$(CONFIG_MODULES)		+= module.o</span>
<span class="p_add">+obj-$(CONFIG_PLIC)		+= plic.o</span>
<span class="p_add">+</span>
<span class="p_add">+clean:</span>
<span class="p_header">diff --git a/arch/riscv/kernel/asm-offsets.c b/arch/riscv/kernel/asm-offsets.c</span>
new file mode 100644
<span class="p_header">index 000000000000..ac2e0cfaf8a3</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -0,0 +1,113 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kbuild.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void asm_offsets(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	OFFSET(TASK_THREAD_INFO, task_struct, stack);</span>
<span class="p_add">+	OFFSET(THREAD_RA, task_struct, thread.ra);</span>
<span class="p_add">+	OFFSET(THREAD_SP, task_struct, thread.sp);</span>
<span class="p_add">+	OFFSET(THREAD_S0, task_struct, thread.s[0]);</span>
<span class="p_add">+	OFFSET(THREAD_S1, task_struct, thread.s[1]);</span>
<span class="p_add">+	OFFSET(THREAD_S2, task_struct, thread.s[2]);</span>
<span class="p_add">+	OFFSET(THREAD_S3, task_struct, thread.s[3]);</span>
<span class="p_add">+	OFFSET(THREAD_S4, task_struct, thread.s[4]);</span>
<span class="p_add">+	OFFSET(THREAD_S5, task_struct, thread.s[5]);</span>
<span class="p_add">+	OFFSET(THREAD_S6, task_struct, thread.s[6]);</span>
<span class="p_add">+	OFFSET(THREAD_S7, task_struct, thread.s[7]);</span>
<span class="p_add">+	OFFSET(THREAD_S8, task_struct, thread.s[8]);</span>
<span class="p_add">+	OFFSET(THREAD_S9, task_struct, thread.s[9]);</span>
<span class="p_add">+	OFFSET(THREAD_S10, task_struct, thread.s[10]);</span>
<span class="p_add">+	OFFSET(THREAD_S11, task_struct, thread.s[11]);</span>
<span class="p_add">+	OFFSET(THREAD_SP, task_struct, thread.sp);</span>
<span class="p_add">+	OFFSET(TI_TASK, thread_info, task);</span>
<span class="p_add">+	OFFSET(TI_FLAGS, thread_info, flags);</span>
<span class="p_add">+	OFFSET(TI_CPU, thread_info, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	OFFSET(THREAD_F0,  task_struct, thread.fstate.f[0]);</span>
<span class="p_add">+	OFFSET(THREAD_F1,  task_struct, thread.fstate.f[1]);</span>
<span class="p_add">+	OFFSET(THREAD_F2,  task_struct, thread.fstate.f[2]);</span>
<span class="p_add">+	OFFSET(THREAD_F3,  task_struct, thread.fstate.f[3]);</span>
<span class="p_add">+	OFFSET(THREAD_F4,  task_struct, thread.fstate.f[4]);</span>
<span class="p_add">+	OFFSET(THREAD_F5,  task_struct, thread.fstate.f[5]);</span>
<span class="p_add">+	OFFSET(THREAD_F6,  task_struct, thread.fstate.f[6]);</span>
<span class="p_add">+	OFFSET(THREAD_F7,  task_struct, thread.fstate.f[7]);</span>
<span class="p_add">+	OFFSET(THREAD_F8,  task_struct, thread.fstate.f[8]);</span>
<span class="p_add">+	OFFSET(THREAD_F9,  task_struct, thread.fstate.f[9]);</span>
<span class="p_add">+	OFFSET(THREAD_F10, task_struct, thread.fstate.f[10]);</span>
<span class="p_add">+	OFFSET(THREAD_F11, task_struct, thread.fstate.f[11]);</span>
<span class="p_add">+	OFFSET(THREAD_F12, task_struct, thread.fstate.f[12]);</span>
<span class="p_add">+	OFFSET(THREAD_F13, task_struct, thread.fstate.f[13]);</span>
<span class="p_add">+	OFFSET(THREAD_F14, task_struct, thread.fstate.f[14]);</span>
<span class="p_add">+	OFFSET(THREAD_F15, task_struct, thread.fstate.f[15]);</span>
<span class="p_add">+	OFFSET(THREAD_F16, task_struct, thread.fstate.f[16]);</span>
<span class="p_add">+	OFFSET(THREAD_F17, task_struct, thread.fstate.f[17]);</span>
<span class="p_add">+	OFFSET(THREAD_F18, task_struct, thread.fstate.f[18]);</span>
<span class="p_add">+	OFFSET(THREAD_F19, task_struct, thread.fstate.f[19]);</span>
<span class="p_add">+	OFFSET(THREAD_F20, task_struct, thread.fstate.f[20]);</span>
<span class="p_add">+	OFFSET(THREAD_F21, task_struct, thread.fstate.f[21]);</span>
<span class="p_add">+	OFFSET(THREAD_F22, task_struct, thread.fstate.f[22]);</span>
<span class="p_add">+	OFFSET(THREAD_F23, task_struct, thread.fstate.f[23]);</span>
<span class="p_add">+	OFFSET(THREAD_F24, task_struct, thread.fstate.f[24]);</span>
<span class="p_add">+	OFFSET(THREAD_F25, task_struct, thread.fstate.f[25]);</span>
<span class="p_add">+	OFFSET(THREAD_F26, task_struct, thread.fstate.f[26]);</span>
<span class="p_add">+	OFFSET(THREAD_F27, task_struct, thread.fstate.f[27]);</span>
<span class="p_add">+	OFFSET(THREAD_F28, task_struct, thread.fstate.f[28]);</span>
<span class="p_add">+	OFFSET(THREAD_F29, task_struct, thread.fstate.f[29]);</span>
<span class="p_add">+	OFFSET(THREAD_F30, task_struct, thread.fstate.f[30]);</span>
<span class="p_add">+	OFFSET(THREAD_F31, task_struct, thread.fstate.f[31]);</span>
<span class="p_add">+	OFFSET(THREAD_FCSR, task_struct, thread.fstate.fcsr);</span>
<span class="p_add">+</span>
<span class="p_add">+	DEFINE(PT_SIZE, sizeof(struct pt_regs));</span>
<span class="p_add">+	OFFSET(PT_SEPC, pt_regs, sepc);</span>
<span class="p_add">+	OFFSET(PT_RA, pt_regs, ra);</span>
<span class="p_add">+	OFFSET(PT_FP, pt_regs, s0);</span>
<span class="p_add">+	OFFSET(PT_S0, pt_regs, s0);</span>
<span class="p_add">+	OFFSET(PT_S1, pt_regs, s1);</span>
<span class="p_add">+	OFFSET(PT_S2, pt_regs, s2);</span>
<span class="p_add">+	OFFSET(PT_S3, pt_regs, s3);</span>
<span class="p_add">+	OFFSET(PT_S4, pt_regs, s4);</span>
<span class="p_add">+	OFFSET(PT_S5, pt_regs, s5);</span>
<span class="p_add">+	OFFSET(PT_S6, pt_regs, s6);</span>
<span class="p_add">+	OFFSET(PT_S7, pt_regs, s7);</span>
<span class="p_add">+	OFFSET(PT_S8, pt_regs, s8);</span>
<span class="p_add">+	OFFSET(PT_S9, pt_regs, s9);</span>
<span class="p_add">+	OFFSET(PT_S10, pt_regs, s10);</span>
<span class="p_add">+	OFFSET(PT_S11, pt_regs, s11);</span>
<span class="p_add">+	OFFSET(PT_SP, pt_regs, sp);</span>
<span class="p_add">+	OFFSET(PT_TP, pt_regs, tp);</span>
<span class="p_add">+	OFFSET(PT_A0, pt_regs, a0);</span>
<span class="p_add">+	OFFSET(PT_A1, pt_regs, a1);</span>
<span class="p_add">+	OFFSET(PT_A2, pt_regs, a2);</span>
<span class="p_add">+	OFFSET(PT_A3, pt_regs, a3);</span>
<span class="p_add">+	OFFSET(PT_A4, pt_regs, a4);</span>
<span class="p_add">+	OFFSET(PT_A5, pt_regs, a5);</span>
<span class="p_add">+	OFFSET(PT_A6, pt_regs, a6);</span>
<span class="p_add">+	OFFSET(PT_A7, pt_regs, a7);</span>
<span class="p_add">+	OFFSET(PT_T0, pt_regs, t0);</span>
<span class="p_add">+	OFFSET(PT_T1, pt_regs, t1);</span>
<span class="p_add">+	OFFSET(PT_T2, pt_regs, t2);</span>
<span class="p_add">+	OFFSET(PT_T3, pt_regs, t3);</span>
<span class="p_add">+	OFFSET(PT_T4, pt_regs, t4);</span>
<span class="p_add">+	OFFSET(PT_T5, pt_regs, t5);</span>
<span class="p_add">+	OFFSET(PT_T6, pt_regs, t6);</span>
<span class="p_add">+	OFFSET(PT_GP, pt_regs, gp);</span>
<span class="p_add">+	OFFSET(PT_SSTATUS, pt_regs, sstatus);</span>
<span class="p_add">+	OFFSET(PT_SBADADDR, pt_regs, sbadaddr);</span>
<span class="p_add">+	OFFSET(PT_SCAUSE, pt_regs, scause);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cacheinfo.c b/arch/riscv/kernel/cacheinfo.c</span>
new file mode 100644
<span class="p_header">index 000000000000..a22ea8abbf3c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cacheinfo.c</span>
<span class="p_chunk">@@ -0,0 +1,82 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cacheinfo.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_device.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void ci_leaf_init(struct cacheinfo *this_leaf,</span>
<span class="p_add">+                         struct device_node *node,</span>
<span class="p_add">+                         enum cache_type type, unsigned int level)</span>
<span class="p_add">+{</span>
<span class="p_add">+        this_leaf-&gt;of_node = node;</span>
<span class="p_add">+        this_leaf-&gt;level = level;</span>
<span class="p_add">+        this_leaf-&gt;type = type;</span>
<span class="p_add">+        this_leaf-&gt;physical_line_partition = 1; // not a sector cache</span>
<span class="p_add">+        this_leaf-&gt;attributes = CACHE_WRITE_BACK | CACHE_READ_ALLOCATE | CACHE_WRITE_ALLOCATE; // TODO: add to DTS</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init_cache_level(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 0, leaves = 0, level;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;)) ++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ++leaves;</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ++leaves;</span>
<span class="p_add">+	if (leaves &gt; 0) levels = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;)) break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level)) break;</span>
<span class="p_add">+		if (level &lt;= levels) break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;)) ++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ++leaves;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ++leaves;</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	this_cpu_ci-&gt;num_levels = levels;</span>
<span class="p_add">+	this_cpu_ci-&gt;num_leaves = leaves;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __populate_cache_leaves(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpu_cacheinfo *this_cpu_ci = get_cpu_cacheinfo(cpu);</span>
<span class="p_add">+	struct cacheinfo *this_leaf = this_cpu_ci-&gt;info_list;</span>
<span class="p_add">+	struct device_node *np = of_cpu_device_node_get(cpu);</span>
<span class="p_add">+	int levels = 1, level = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;cache-size&quot;))   ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+	if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((np = of_find_next_cache_node(np))) {</span>
<span class="p_add">+		if (!of_device_is_compatible(np, &quot;cache&quot;)) break;</span>
<span class="p_add">+		if (of_property_read_u32(np, &quot;cache-level&quot;, &amp;level)) break;</span>
<span class="p_add">+		if (level &lt;= levels) break;</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;cache-size&quot;))   ci_leaf_init(this_leaf++, np, CACHE_TYPE_UNIFIED, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;i-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_INST, level);</span>
<span class="p_add">+		if (of_property_read_bool(np, &quot;d-cache-size&quot;)) ci_leaf_init(this_leaf++, np, CACHE_TYPE_DATA, level);</span>
<span class="p_add">+		levels = level;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(init_cache_level)</span>
<span class="p_add">+DEFINE_SMP_CALL_CACHE_FUNCTION(populate_cache_leaves)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/cpu.c b/arch/riscv/kernel/cpu.c</span>
new file mode 100644
<span class="p_header">index 000000000000..9cbf53eb58be</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/cpu.c</span>
<span class="p_chunk">@@ -0,0 +1,81 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Return -1 if not a valid hart */</span>
<span class="p_add">+int riscv_of_processor_hart(struct device_node *node)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const char *isa, *status;</span>
<span class="p_add">+	u32 hart;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!of_device_is_compatible(node, &quot;riscv&quot;)) return -1;</span>
<span class="p_add">+	if (of_property_read_u32(node, &quot;reg&quot;, &amp;hart) || hart &gt;= NR_CPUS) return -1;</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;status&quot;, &amp;status) || strcmp(status, &quot;okay&quot;)) return -1;</span>
<span class="p_add">+	if (of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa) || isa[0] != &#39;r&#39; || isa[1] != &#39;v&#39;) return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hart;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_FS</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_start(struct seq_file *m, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*pos = cpumask_next(*pos - 1, cpu_online_mask);</span>
<span class="p_add">+	if ((*pos) &lt; nr_cpu_ids)</span>
<span class="p_add">+		return (void *)(uintptr_t)(1 + *pos);</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void *c_next(struct seq_file *m, void *v, loff_t *pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	(*pos)++;</span>
<span class="p_add">+	return c_start(m, pos);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void c_stop(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int c_show(struct seq_file *m, void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long hart_id = (unsigned long)v - 1;</span>
<span class="p_add">+	struct device_node *node = of_get_cpu_node(hart_id, NULL);</span>
<span class="p_add">+	const char *compat, *isa, *mmu;</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(m, &quot;hart\t: %lu\n&quot;, hart_id);</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;riscv,isa&quot;, &amp;isa) &amp;&amp; isa[0] == &#39;r&#39; &amp;&amp; isa[1] == &#39;v&#39;) {</span>
<span class="p_add">+		seq_printf(m, &quot;isa\t: %s\n&quot;, isa);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;mmu-type&quot;, &amp;mmu) &amp;&amp; !strncmp(mmu, &quot;riscv,&quot;, 6)) {</span>
<span class="p_add">+		seq_printf(m, &quot;mmu\t: %s\n&quot;, mmu+6);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!of_property_read_string(node, &quot;compatible&quot;, &amp;compat) &amp;&amp; strcmp(compat, &quot;riscv&quot;)) {</span>
<span class="p_add">+		seq_printf(m, &quot;uarch\t: %s\n&quot;, compat);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	seq_printf(m, &quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const struct seq_operations cpuinfo_op = {</span>
<span class="p_add">+	.start	= c_start,</span>
<span class="p_add">+	.next	= c_next,</span>
<span class="p_add">+	.stop	= c_stop,</span>
<span class="p_add">+	.show	= c_show</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_PROC_FS */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/entry.S b/arch/riscv/kernel/entry.S</span>
new file mode 100644
<span class="p_header">index 000000000000..d70a1be1e3a6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/entry.S</span>
<span class="p_chunk">@@ -0,0 +1,414 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+	.altmacro</span>
<span class="p_add">+	.macro SAVE_ALL</span>
<span class="p_add">+	LOCAL _restore_kernel_sp</span>
<span class="p_add">+	LOCAL _save_context</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If coming from userspace, preserve the user stack pointer and load</span>
<span class="p_add">+	   the kernel stack pointer.  If we came from the kernel, sscratch</span>
<span class="p_add">+	   will contain 0, and we should continue on the current stack. */</span>
<span class="p_add">+	csrrw sp, sscratch, sp</span>
<span class="p_add">+	bnez sp, _save_context</span>
<span class="p_add">+</span>
<span class="p_add">+_restore_kernel_sp:</span>
<span class="p_add">+	csrr sp, sscratch</span>
<span class="p_add">+_save_context:</span>
<span class="p_add">+	addi sp, sp, -(PT_SIZE)</span>
<span class="p_add">+	REG_S x1,  PT_RA(sp)</span>
<span class="p_add">+	REG_S x3,  PT_GP(sp)</span>
<span class="p_add">+	REG_S x4,  PT_TP(sp)</span>
<span class="p_add">+	REG_S x5,  PT_T0(sp)</span>
<span class="p_add">+	REG_S x6,  PT_T1(sp)</span>
<span class="p_add">+	REG_S x7,  PT_T2(sp)</span>
<span class="p_add">+	REG_S x8,  PT_S0(sp)</span>
<span class="p_add">+	REG_S x9,  PT_S1(sp)</span>
<span class="p_add">+	REG_S x10, PT_A0(sp)</span>
<span class="p_add">+	REG_S x11, PT_A1(sp)</span>
<span class="p_add">+	REG_S x12, PT_A2(sp)</span>
<span class="p_add">+	REG_S x13, PT_A3(sp)</span>
<span class="p_add">+	REG_S x14, PT_A4(sp)</span>
<span class="p_add">+	REG_S x15, PT_A5(sp)</span>
<span class="p_add">+	REG_S x16, PT_A6(sp)</span>
<span class="p_add">+	REG_S x17, PT_A7(sp)</span>
<span class="p_add">+	REG_S x18, PT_S2(sp)</span>
<span class="p_add">+	REG_S x19, PT_S3(sp)</span>
<span class="p_add">+	REG_S x20, PT_S4(sp)</span>
<span class="p_add">+	REG_S x21, PT_S5(sp)</span>
<span class="p_add">+	REG_S x22, PT_S6(sp)</span>
<span class="p_add">+	REG_S x23, PT_S7(sp)</span>
<span class="p_add">+	REG_S x24, PT_S8(sp)</span>
<span class="p_add">+	REG_S x25, PT_S9(sp)</span>
<span class="p_add">+	REG_S x26, PT_S10(sp)</span>
<span class="p_add">+	REG_S x27, PT_S11(sp)</span>
<span class="p_add">+	REG_S x28, PT_T3(sp)</span>
<span class="p_add">+	REG_S x29, PT_T4(sp)</span>
<span class="p_add">+	REG_S x30, PT_T5(sp)</span>
<span class="p_add">+	REG_S x31, PT_T6(sp)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable FPU to detect illegal usage of</span>
<span class="p_add">+	   floating point in kernel space */</span>
<span class="p_add">+	li t0, SR_FS</span>
<span class="p_add">+</span>
<span class="p_add">+	csrr s0, sscratch</span>
<span class="p_add">+	csrrc s1, sstatus, t0</span>
<span class="p_add">+	csrr s2, sepc</span>
<span class="p_add">+	csrr s3, sbadaddr</span>
<span class="p_add">+	csrr s4, scause</span>
<span class="p_add">+	REG_S s0, PT_SP(sp)</span>
<span class="p_add">+	REG_S s1, PT_SSTATUS(sp)</span>
<span class="p_add">+	REG_S s2, PT_SEPC(sp)</span>
<span class="p_add">+	REG_S s3, PT_SBADADDR(sp)</span>
<span class="p_add">+	REG_S s4, PT_SCAUSE(sp)</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro RESTORE_ALL</span>
<span class="p_add">+	REG_L a0, PT_SSTATUS(sp)</span>
<span class="p_add">+	REG_L a2, PT_SEPC(sp)</span>
<span class="p_add">+	csrw sstatus, a0</span>
<span class="p_add">+	csrw sepc, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	REG_L x1,  PT_RA(sp)</span>
<span class="p_add">+	REG_L x3,  PT_GP(sp)</span>
<span class="p_add">+	REG_L x4,  PT_TP(sp)</span>
<span class="p_add">+	REG_L x5,  PT_T0(sp)</span>
<span class="p_add">+	REG_L x6,  PT_T1(sp)</span>
<span class="p_add">+	REG_L x7,  PT_T2(sp)</span>
<span class="p_add">+	REG_L x8,  PT_S0(sp)</span>
<span class="p_add">+	REG_L x9,  PT_S1(sp)</span>
<span class="p_add">+	REG_L x10, PT_A0(sp)</span>
<span class="p_add">+	REG_L x11, PT_A1(sp)</span>
<span class="p_add">+	REG_L x12, PT_A2(sp)</span>
<span class="p_add">+	REG_L x13, PT_A3(sp)</span>
<span class="p_add">+	REG_L x14, PT_A4(sp)</span>
<span class="p_add">+	REG_L x15, PT_A5(sp)</span>
<span class="p_add">+	REG_L x16, PT_A6(sp)</span>
<span class="p_add">+	REG_L x17, PT_A7(sp)</span>
<span class="p_add">+	REG_L x18, PT_S2(sp)</span>
<span class="p_add">+	REG_L x19, PT_S3(sp)</span>
<span class="p_add">+	REG_L x20, PT_S4(sp)</span>
<span class="p_add">+	REG_L x21, PT_S5(sp)</span>
<span class="p_add">+	REG_L x22, PT_S6(sp)</span>
<span class="p_add">+	REG_L x23, PT_S7(sp)</span>
<span class="p_add">+	REG_L x24, PT_S8(sp)</span>
<span class="p_add">+	REG_L x25, PT_S9(sp)</span>
<span class="p_add">+	REG_L x26, PT_S10(sp)</span>
<span class="p_add">+	REG_L x27, PT_S11(sp)</span>
<span class="p_add">+	REG_L x28, PT_T3(sp)</span>
<span class="p_add">+	REG_L x29, PT_T4(sp)</span>
<span class="p_add">+	REG_L x30, PT_T5(sp)</span>
<span class="p_add">+	REG_L x31, PT_T6(sp)</span>
<span class="p_add">+</span>
<span class="p_add">+	REG_L x2,  PT_SP(sp)</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(handle_exception)</span>
<span class="p_add">+	SAVE_ALL</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set sscratch register to 0, so that if a recursive exception</span>
<span class="p_add">+	   occurs, the exception vector knows it came from the kernel */</span>
<span class="p_add">+	csrw sscratch, x0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute address of current thread_info */</span>
<span class="p_add">+	li tp, ~(THREAD_SIZE-1)</span>
<span class="p_add">+	and tp, tp, sp</span>
<span class="p_add">+</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	/* MSB of cause differentiates between</span>
<span class="p_add">+	   interrupts and exceptions */</span>
<span class="p_add">+	bge s4, zero, 1f</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Handle interrupts */</span>
<span class="p_add">+	slli a0, s4, 1</span>
<span class="p_add">+	srli a0, a0, 1</span>
<span class="p_add">+	move a1, sp /* pt_regs */</span>
<span class="p_add">+	tail do_IRQ</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* Handle syscalls */</span>
<span class="p_add">+	li t0, EXC_SYSCALL</span>
<span class="p_add">+	beq s4, t0, handle_syscall</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Handle other exceptions */</span>
<span class="p_add">+	slli t0, s4, LGPTR</span>
<span class="p_add">+	la t1, excp_vect_table</span>
<span class="p_add">+	la t2, excp_vect_table_end</span>
<span class="p_add">+	move a0, sp /* pt_regs */</span>
<span class="p_add">+	add t0, t1, t0</span>
<span class="p_add">+	/* Check if exception code lies within bounds */</span>
<span class="p_add">+	bgeu t0, t2, 1f</span>
<span class="p_add">+	REG_L t0, 0(t0)</span>
<span class="p_add">+	jr t0</span>
<span class="p_add">+1:</span>
<span class="p_add">+	tail do_trap_unknown</span>
<span class="p_add">+</span>
<span class="p_add">+handle_syscall:</span>
<span class="p_add">+	/* Advance SEPC to avoid executing the original</span>
<span class="p_add">+	   scall instruction on sret */</span>
<span class="p_add">+	addi s2, s2, 0x4</span>
<span class="p_add">+	REG_S s2, PT_SEPC(sp)</span>
<span class="p_add">+	/* System calls run with interrupts enabled */</span>
<span class="p_add">+	csrs sstatus, SR_IE</span>
<span class="p_add">+	/* Trace syscalls, but only if requested by the user. */</span>
<span class="p_add">+	REG_L t0, TI_FLAGS(tp)</span>
<span class="p_add">+	andi t0, t0, _TIF_SYSCALL_TRACE</span>
<span class="p_add">+	bnez t0, handle_syscall_trace_enter</span>
<span class="p_add">+check_syscall_nr:</span>
<span class="p_add">+	/* Check to make sure we don&#39;t jump to a bogus syscall number. */</span>
<span class="p_add">+	li t0, __NR_syscalls</span>
<span class="p_add">+	la s0, sys_ni_syscall</span>
<span class="p_add">+	/* Syscall number held in a7 */</span>
<span class="p_add">+	bgeu a7, t0, 1f</span>
<span class="p_add">+	la s0, sys_call_table</span>
<span class="p_add">+	slli t0, a7, LGPTR</span>
<span class="p_add">+	add s0, s0, t0</span>
<span class="p_add">+	REG_L s0, 0(s0)</span>
<span class="p_add">+1:</span>
<span class="p_add">+	jalr s0</span>
<span class="p_add">+</span>
<span class="p_add">+ret_from_syscall:</span>
<span class="p_add">+	/* Set user a0 to kernel a0 */</span>
<span class="p_add">+	REG_S a0, PT_A0(sp)</span>
<span class="p_add">+	/* Trace syscalls, but only if requested by the user. */</span>
<span class="p_add">+	REG_L t0, TI_FLAGS(tp)</span>
<span class="p_add">+	andi t0, t0, _TIF_SYSCALL_TRACE</span>
<span class="p_add">+	bnez t0, handle_syscall_trace_exit</span>
<span class="p_add">+</span>
<span class="p_add">+ret_from_exception:</span>
<span class="p_add">+	REG_L s0, PT_SSTATUS(sp)</span>
<span class="p_add">+	csrc sstatus, SR_IE</span>
<span class="p_add">+	andi s0, s0, SR_PS</span>
<span class="p_add">+	bnez s0, restore_all</span>
<span class="p_add">+</span>
<span class="p_add">+resume_userspace:</span>
<span class="p_add">+	/* Interrupts must be disabled here so flags are checked atomically */</span>
<span class="p_add">+	REG_L s0, TI_FLAGS(tp) /* current_thread_info-&gt;flags */</span>
<span class="p_add">+	andi s1, s0, _TIF_WORK_MASK</span>
<span class="p_add">+	bnez s1, work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save unwound kernel stack pointer in sscratch */</span>
<span class="p_add">+	addi s0, sp, PT_SIZE</span>
<span class="p_add">+	csrw sscratch, s0</span>
<span class="p_add">+restore_all:</span>
<span class="p_add">+	RESTORE_ALL</span>
<span class="p_add">+	sret</span>
<span class="p_add">+</span>
<span class="p_add">+work_pending:</span>
<span class="p_add">+	/* Enter slow path for supplementary processing */</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	andi s1, s0, _TIF_NEED_RESCHED</span>
<span class="p_add">+	bnez s1, work_resched</span>
<span class="p_add">+work_notifysig:</span>
<span class="p_add">+	/* Handle pending signals and notify-resume requests */</span>
<span class="p_add">+	csrs sstatus, SR_IE /* Enable interrupts for do_notify_resume() */</span>
<span class="p_add">+	move a0, sp /* pt_regs */</span>
<span class="p_add">+	move a1, s0 /* current_thread_info-&gt;flags */</span>
<span class="p_add">+	tail do_notify_resume</span>
<span class="p_add">+work_resched:</span>
<span class="p_add">+	tail schedule</span>
<span class="p_add">+</span>
<span class="p_add">+/* Slow paths for ptrace. */</span>
<span class="p_add">+handle_syscall_trace_enter:</span>
<span class="p_add">+	move a0, sp</span>
<span class="p_add">+	call do_syscall_trace_enter</span>
<span class="p_add">+	REG_L a0, PT_A0(sp)</span>
<span class="p_add">+	REG_L a1, PT_A1(sp)</span>
<span class="p_add">+	REG_L a2, PT_A2(sp)</span>
<span class="p_add">+	REG_L a3, PT_A3(sp)</span>
<span class="p_add">+	REG_L a4, PT_A4(sp)</span>
<span class="p_add">+	REG_L a5, PT_A5(sp)</span>
<span class="p_add">+	REG_L a6, PT_A6(sp)</span>
<span class="p_add">+	REG_L a7, PT_A7(sp)</span>
<span class="p_add">+	j check_syscall_nr</span>
<span class="p_add">+handle_syscall_trace_exit:</span>
<span class="p_add">+	move a0, sp</span>
<span class="p_add">+	call do_syscall_trace_exit</span>
<span class="p_add">+	j ret_from_exception</span>
<span class="p_add">+</span>
<span class="p_add">+END(handle_exception)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ret_from_fork)</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	tail schedule_tail</span>
<span class="p_add">+ENDPROC(ret_from_fork)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ret_from_kernel_thread)</span>
<span class="p_add">+	call schedule_tail</span>
<span class="p_add">+	/* Call fn(arg) */</span>
<span class="p_add">+	la ra, ret_from_exception</span>
<span class="p_add">+	move a0, s1</span>
<span class="p_add">+	jr s0</span>
<span class="p_add">+ENDPROC(ret_from_kernel_thread)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Integer register context switch</span>
<span class="p_add">+ * The callee-saved registers must be saved and restored.</span>
<span class="p_add">+ * </span>
<span class="p_add">+ *   a0: previous task_struct (must be preserved across the switch)</span>
<span class="p_add">+ *   a1: next task_struct</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(__switch_to)</span>
<span class="p_add">+	/* Save context into prev-&gt;thread */</span>
<span class="p_add">+	REG_S ra,  THREAD_RA(a0)</span>
<span class="p_add">+	REG_S sp,  THREAD_SP(a0)</span>
<span class="p_add">+	REG_S s0,  THREAD_S0(a0)</span>
<span class="p_add">+	REG_S s1,  THREAD_S1(a0)</span>
<span class="p_add">+	REG_S s2,  THREAD_S2(a0)</span>
<span class="p_add">+	REG_S s3,  THREAD_S3(a0)</span>
<span class="p_add">+	REG_S s4,  THREAD_S4(a0)</span>
<span class="p_add">+	REG_S s5,  THREAD_S5(a0)</span>
<span class="p_add">+	REG_S s6,  THREAD_S6(a0)</span>
<span class="p_add">+	REG_S s7,  THREAD_S7(a0)</span>
<span class="p_add">+	REG_S s8,  THREAD_S8(a0)</span>
<span class="p_add">+	REG_S s9,  THREAD_S9(a0)</span>
<span class="p_add">+	REG_S s10, THREAD_S10(a0)</span>
<span class="p_add">+	REG_S s11, THREAD_S11(a0)</span>
<span class="p_add">+	/* Restore context from next-&gt;thread */</span>
<span class="p_add">+	REG_L ra,  THREAD_RA(a1)</span>
<span class="p_add">+	REG_L sp,  THREAD_SP(a1)</span>
<span class="p_add">+	REG_L s0,  THREAD_S0(a1)</span>
<span class="p_add">+	REG_L s1,  THREAD_S1(a1)</span>
<span class="p_add">+	REG_L s2,  THREAD_S2(a1)</span>
<span class="p_add">+	REG_L s3,  THREAD_S3(a1)</span>
<span class="p_add">+	REG_L s4,  THREAD_S4(a1)</span>
<span class="p_add">+	REG_L s5,  THREAD_S5(a1)</span>
<span class="p_add">+	REG_L s6,  THREAD_S6(a1)</span>
<span class="p_add">+	REG_L s7,  THREAD_S7(a1)</span>
<span class="p_add">+	REG_L s8,  THREAD_S8(a1)</span>
<span class="p_add">+	REG_L s9,  THREAD_S9(a1)</span>
<span class="p_add">+	REG_L s10, THREAD_S10(a1)</span>
<span class="p_add">+	REG_L s11, THREAD_S11(a1)</span>
<span class="p_add">+	REG_L tp, TASK_THREAD_INFO(a1)</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__switch_to)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__fstate_save)</span>
<span class="p_add">+	li t1, SR_FS</span>
<span class="p_add">+	csrs sstatus, t1</span>
<span class="p_add">+	frcsr t0</span>
<span class="p_add">+	fsd f0,  THREAD_F0(a0)</span>
<span class="p_add">+	fsd f1,  THREAD_F1(a0)</span>
<span class="p_add">+	fsd f2,  THREAD_F2(a0)</span>
<span class="p_add">+	fsd f3,  THREAD_F3(a0)</span>
<span class="p_add">+	fsd f4,  THREAD_F4(a0)</span>
<span class="p_add">+	fsd f5,  THREAD_F5(a0)</span>
<span class="p_add">+	fsd f6,  THREAD_F6(a0)</span>
<span class="p_add">+	fsd f7,  THREAD_F7(a0)</span>
<span class="p_add">+	fsd f8,  THREAD_F8(a0)</span>
<span class="p_add">+	fsd f9,  THREAD_F9(a0)</span>
<span class="p_add">+	fsd f10, THREAD_F10(a0)</span>
<span class="p_add">+	fsd f11, THREAD_F11(a0)</span>
<span class="p_add">+	fsd f12, THREAD_F12(a0)</span>
<span class="p_add">+	fsd f13, THREAD_F13(a0)</span>
<span class="p_add">+	fsd f14, THREAD_F14(a0)</span>
<span class="p_add">+	fsd f15, THREAD_F15(a0)</span>
<span class="p_add">+	fsd f16, THREAD_F16(a0)</span>
<span class="p_add">+	fsd f17, THREAD_F17(a0)</span>
<span class="p_add">+	fsd f18, THREAD_F18(a0)</span>
<span class="p_add">+	fsd f19, THREAD_F19(a0)</span>
<span class="p_add">+	fsd f20, THREAD_F20(a0)</span>
<span class="p_add">+	fsd f21, THREAD_F21(a0)</span>
<span class="p_add">+	fsd f22, THREAD_F22(a0)</span>
<span class="p_add">+	fsd f23, THREAD_F23(a0)</span>
<span class="p_add">+	fsd f24, THREAD_F24(a0)</span>
<span class="p_add">+	fsd f25, THREAD_F25(a0)</span>
<span class="p_add">+	fsd f26, THREAD_F26(a0)</span>
<span class="p_add">+	fsd f27, THREAD_F27(a0)</span>
<span class="p_add">+	fsd f28, THREAD_F28(a0)</span>
<span class="p_add">+	fsd f29, THREAD_F29(a0)</span>
<span class="p_add">+	fsd f30, THREAD_F30(a0)</span>
<span class="p_add">+	fsd f31, THREAD_F31(a0)</span>
<span class="p_add">+	sw t0, THREAD_FCSR(a0)</span>
<span class="p_add">+	csrc sstatus, t1</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__fstate_save)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__fstate_restore)</span>
<span class="p_add">+	li t1, SR_FS</span>
<span class="p_add">+	lw t0, THREAD_FCSR(a0)</span>
<span class="p_add">+	csrs sstatus, t1</span>
<span class="p_add">+	fld f0,  THREAD_F0(a0)</span>
<span class="p_add">+	fld f1,  THREAD_F1(a0)</span>
<span class="p_add">+	fld f2,  THREAD_F2(a0)</span>
<span class="p_add">+	fld f3,  THREAD_F3(a0)</span>
<span class="p_add">+	fld f4,  THREAD_F4(a0)</span>
<span class="p_add">+	fld f5,  THREAD_F5(a0)</span>
<span class="p_add">+	fld f6,  THREAD_F6(a0)</span>
<span class="p_add">+	fld f7,  THREAD_F7(a0)</span>
<span class="p_add">+	fld f8,  THREAD_F8(a0)</span>
<span class="p_add">+	fld f9,  THREAD_F9(a0)</span>
<span class="p_add">+	fld f10, THREAD_F10(a0)</span>
<span class="p_add">+	fld f11, THREAD_F11(a0)</span>
<span class="p_add">+	fld f12, THREAD_F12(a0)</span>
<span class="p_add">+	fld f13, THREAD_F13(a0)</span>
<span class="p_add">+	fld f14, THREAD_F14(a0)</span>
<span class="p_add">+	fld f15, THREAD_F15(a0)</span>
<span class="p_add">+	fld f16, THREAD_F16(a0)</span>
<span class="p_add">+	fld f17, THREAD_F17(a0)</span>
<span class="p_add">+	fld f18, THREAD_F18(a0)</span>
<span class="p_add">+	fld f19, THREAD_F19(a0)</span>
<span class="p_add">+	fld f20, THREAD_F20(a0)</span>
<span class="p_add">+	fld f21, THREAD_F21(a0)</span>
<span class="p_add">+	fld f22, THREAD_F22(a0)</span>
<span class="p_add">+	fld f23, THREAD_F23(a0)</span>
<span class="p_add">+	fld f24, THREAD_F24(a0)</span>
<span class="p_add">+	fld f25, THREAD_F25(a0)</span>
<span class="p_add">+	fld f26, THREAD_F26(a0)</span>
<span class="p_add">+	fld f27, THREAD_F27(a0)</span>
<span class="p_add">+	fld f28, THREAD_F28(a0)</span>
<span class="p_add">+	fld f29, THREAD_F29(a0)</span>
<span class="p_add">+	fld f30, THREAD_F30(a0)</span>
<span class="p_add">+	fld f31, THREAD_F31(a0)</span>
<span class="p_add">+	fscsr t0</span>
<span class="p_add">+	csrc sstatus, t1</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__fstate_restore)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	.section &quot;.rodata&quot;</span>
<span class="p_add">+	/* Exception vector table */</span>
<span class="p_add">+ENTRY(excp_vect_table)</span>
<span class="p_add">+	PTR do_trap_insn_misaligned</span>
<span class="p_add">+	PTR do_trap_unknown /* instruction access exception */</span>
<span class="p_add">+	PTR do_trap_insn_illegal</span>
<span class="p_add">+	PTR do_trap_break</span>
<span class="p_add">+	PTR do_trap_unknown</span>
<span class="p_add">+	PTR do_trap_unknown /* load access exception */</span>
<span class="p_add">+	PTR do_trap_amo_misaligned</span>
<span class="p_add">+	PTR do_trap_unknown /* store access exception */</span>
<span class="p_add">+	PTR do_trap_unknown /* handle_syscall */</span>
<span class="p_add">+	PTR do_trap_unknown</span>
<span class="p_add">+	PTR do_trap_unknown</span>
<span class="p_add">+	PTR do_trap_unknown</span>
<span class="p_add">+	PTR do_page_fault   /* instruction page fault */</span>
<span class="p_add">+	PTR do_page_fault   /* load page fault */</span>
<span class="p_add">+	PTR do_trap_unknown</span>
<span class="p_add">+	PTR do_page_fault   /* store page fault */</span>
<span class="p_add">+excp_vect_table_end:</span>
<span class="p_add">+END(excp_vect_table)</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/riscv/kernel/head.S b/arch/riscv/kernel/head.S</span>
new file mode 100644
<span class="p_header">index 000000000000..52d574206d76</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/head.S</span>
<span class="p_chunk">@@ -0,0 +1,139 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+__INIT</span>
<span class="p_add">+ENTRY(_start)</span>
<span class="p_add">+	/* Mask all interrupts */</span>
<span class="p_add">+	csrw sie, zero</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable FPU to detect illegal usage of</span>
<span class="p_add">+	   floating point in kernel space */</span>
<span class="p_add">+	li t0, SR_FS</span>
<span class="p_add">+	csrc sstatus, t0</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef CONFIG_RV_PUM</span>
<span class="p_add">+	/* Allow access to user memory */</span>
<span class="p_add">+	li t0, SR_SUM</span>
<span class="p_add">+	csrs sstatus, t0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Pick one hart to run the main boot sequence */</span>
<span class="p_add">+	la a3, hart_lottery</span>
<span class="p_add">+	li a2, 1</span>
<span class="p_add">+	amoadd.w a3, a2, (a3)</span>
<span class="p_add">+	bnez a3, .Lsecondary_start</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save hart ID and DTB physical address */</span>
<span class="p_add">+	mv s0, a0</span>
<span class="p_add">+	mv s1, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize page tables and relocate to virtual addresses */</span>
<span class="p_add">+	la sp, init_thread_union + THREAD_SIZE</span>
<span class="p_add">+	call setup_vm</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore C environment */</span>
<span class="p_add">+	la tp, init_thread_union</span>
<span class="p_add">+	li sp, THREAD_SIZE</span>
<span class="p_add">+	add sp, sp, tp</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start the kernel */</span>
<span class="p_add">+	mv a0, s0</span>
<span class="p_add">+	mv a1, s1</span>
<span class="p_add">+	call sbi_save</span>
<span class="p_add">+	tail start_kernel</span>
<span class="p_add">+</span>
<span class="p_add">+relocate:</span>
<span class="p_add">+	/* Relocate return address */</span>
<span class="p_add">+	li a1, PAGE_OFFSET</span>
<span class="p_add">+	la a0, _start</span>
<span class="p_add">+	sub a1, a1, a0</span>
<span class="p_add">+	add ra, ra, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Point stvec to virtual address of intruction after sptbr write */</span>
<span class="p_add">+	la a0, 1f</span>
<span class="p_add">+	add a0, a0, a1</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute sptbr for kernel page tables, but don&#39;t load it yet */</span>
<span class="p_add">+	la a2, swapper_pg_dir</span>
<span class="p_add">+	srl a2, a2, PAGE_SHIFT</span>
<span class="p_add">+	li a1, SPTBR_MODE</span>
<span class="p_add">+	or a2, a2, a1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load trampoline page directory, which will cause us to trap to</span>
<span class="p_add">+	   stvec if VA != PA, or simply fall through if VA == PA */</span>
<span class="p_add">+	la a0, trampoline_pg_dir</span>
<span class="p_add">+	srl a0, a0, PAGE_SHIFT</span>
<span class="p_add">+	or a0, a0, a1</span>
<span class="p_add">+	sfence.vma</span>
<span class="p_add">+	csrw sptbr, a0</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* Set trap vector to spin forever to help debug */</span>
<span class="p_add">+	la a0, .Lsecondary_park</span>
<span class="p_add">+	csrw stvec, a0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load the global pointer */</span>
<span class="p_add">+	la gp, __global_pointer$</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Switch to kernel page tables */</span>
<span class="p_add">+	csrw sptbr, a2</span>
<span class="p_add">+</span>
<span class="p_add">+	ret</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_start:</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	li a1, CONFIG_NR_CPUS</span>
<span class="p_add">+	bgeu a0, a1, .Lsecondary_park</span>
<span class="p_add">+</span>
<span class="p_add">+	la a1, __cpu_up_stack_pointer</span>
<span class="p_add">+	slli a0, a0, LGREG</span>
<span class="p_add">+	add a0, a0, a1</span>
<span class="p_add">+</span>
<span class="p_add">+.Lwait_for_cpu_up:</span>
<span class="p_add">+	REG_L sp, (a0)</span>
<span class="p_add">+	beqz sp, .Lwait_for_cpu_up</span>
<span class="p_add">+	fence</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable virtual memory and relocate to virtual address */</span>
<span class="p_add">+	call relocate</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize task_struct pointer */</span>
<span class="p_add">+	li tp, -THREAD_SIZE</span>
<span class="p_add">+	add tp, tp, sp</span>
<span class="p_add">+</span>
<span class="p_add">+	tail smp_callin</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+.Lsecondary_park:</span>
<span class="p_add">+	/* We lack SMP support or have too many harts, so park this hart */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	j .Lsecondary_park</span>
<span class="p_add">+END(_start)</span>
<span class="p_add">+</span>
<span class="p_add">+__PAGE_ALIGNED_BSS</span>
<span class="p_add">+	/* Empty zero page */</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+ENTRY(empty_zero_page)</span>
<span class="p_add">+	.fill (empty_zero_page + PAGE_SIZE) - ., 1, 0x00</span>
<span class="p_add">+END(empty_zero_page)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/irq.c b/arch/riscv/kernel/irq.c</span>
new file mode 100644
<span class="p_header">index 000000000000..b772bb9539cf</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/irq.c</span>
<span class="p_chunk">@@ -0,0 +1,205 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqchip.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqdomain.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/ftrace.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/seq_file.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+struct riscv_irq_data {</span>
<span class="p_add">+	struct irq_chip		chip;</span>
<span class="p_add">+	struct irq_domain	*domain;</span>
<span class="p_add">+	int			hart;</span>
<span class="p_add">+	char			name[20];</span>
<span class="p_add">+};</span>
<span class="p_add">+DEFINE_PER_CPU(struct riscv_irq_data, riscv_irq_data);</span>
<span class="p_add">+DEFINE_PER_CPU(atomic_long_t, riscv_early_sie);</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_software_interrupt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	irqreturn_t ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = handle_ipi();</span>
<span class="p_add">+	if (ret != IRQ_NONE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void __irq_entry do_IRQ(unsigned int cause, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *old_regs = set_irq_regs(regs);</span>
<span class="p_add">+	irq_enter();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* There are three classes of interrupt: timer, software, and</span>
<span class="p_add">+	   external devices.  We dispatch between them here.  External</span>
<span class="p_add">+	   device interrupts use the generic IRQ mechanisms. */</span>
<span class="p_add">+	switch (cause) {</span>
<span class="p_add">+		case INTERRUPT_CAUSE_TIMER:</span>
<span class="p_add">+			riscv_timer_interrupt();</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case INTERRUPT_CAUSE_SOFTWARE:</span>
<span class="p_add">+			riscv_software_interrupt();</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default: {</span>
<span class="p_add">+			struct irq_domain *domain = per_cpu(riscv_irq_data, smp_processor_id()).domain;</span>
<span class="p_add">+			generic_handle_irq(irq_find_mapping(domain, cause));</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_exit();</span>
<span class="p_add">+	set_irq_regs(old_regs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_irqdomain_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hwirq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct riscv_irq_data *data = d-&gt;host_data;</span>
<span class="p_add">+</span>
<span class="p_add">+        irq_set_chip_and_handler(irq, &amp;data-&gt;chip, handle_simple_irq);</span>
<span class="p_add">+        irq_set_chip_data(irq, data);</span>
<span class="p_add">+        irq_set_noprobe(irq);</span>
<span class="p_add">+</span>
<span class="p_add">+        return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct irq_domain_ops riscv_irqdomain_ops = {</span>
<span class="p_add">+	.map	= riscv_irqdomain_map,</span>
<span class="p_add">+	.xlate	= irq_domain_xlate_onecell,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_mask(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	BUG_ON(smp_processor_id() != data-&gt;hart);</span>
<span class="p_add">+	csr_clear(sie, 1 &lt;&lt; (long)d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_unmask(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	BUG_ON(smp_processor_id() != data-&gt;hart);</span>
<span class="p_add">+	csr_set(sie, 1 &lt;&lt; (long)d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_enable_helper(void *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	riscv_irq_unmask(d);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_enable(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	atomic_long_or((1 &lt;&lt; (long)d-&gt;hwirq), &amp;per_cpu(riscv_early_sie, data-&gt;hart));</span>
<span class="p_add">+	if (data-&gt;hart == smp_processor_id()) {</span>
<span class="p_add">+		riscv_irq_unmask(d);</span>
<span class="p_add">+	} else if (cpu_online(data-&gt;hart)) {</span>
<span class="p_add">+		smp_call_function_single(data-&gt;hart, riscv_irq_enable_helper, d, true);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_disable_helper(void *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	riscv_irq_mask(d);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_disable(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct riscv_irq_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	atomic_long_and(~(1 &lt;&lt; (long)d-&gt;hwirq), &amp;per_cpu(riscv_early_sie, data-&gt;hart));</span>
<span class="p_add">+	if (data-&gt;hart == smp_processor_id()) {</span>
<span class="p_add">+		riscv_irq_mask(d);</span>
<span class="p_add">+	} else if (cpu_online(data-&gt;hart)) {</span>
<span class="p_add">+		smp_call_function_single(data-&gt;hart, riscv_irq_disable_helper, d, true);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_mask_noop(struct irq_data *d) { }</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_unmask_noop(struct irq_data *d) { }</span>
<span class="p_add">+</span>
<span class="p_add">+static void riscv_irq_enable_noop(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *data = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	u32 hart;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!of_property_read_u32(data, &quot;reg&quot;, &amp;hart)) {</span>
<span class="p_add">+		printk(&quot;WARNING: enabled interrupt %d for missing hart %d (this interrupt has no handler)\n&quot;, (int)d-&gt;hwirq, hart);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct irq_chip riscv_noop_chip = {</span>
<span class="p_add">+	.name = &quot;riscv,cpu-intc,noop&quot;,</span>
<span class="p_add">+	.irq_mask = riscv_irq_mask_noop,</span>
<span class="p_add">+	.irq_unmask = riscv_irq_unmask_noop,</span>
<span class="p_add">+	.irq_enable = riscv_irq_enable_noop,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_irqdomain_map_noop(struct irq_domain *d, unsigned int irq, irq_hw_number_t hwirq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *data = d-&gt;host_data;</span>
<span class="p_add">+	irq_set_chip_and_handler(irq, &amp;riscv_noop_chip, handle_simple_irq);</span>
<span class="p_add">+	irq_set_chip_data(irq, data);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct irq_domain_ops riscv_irqdomain_ops_noop = {</span>
<span class="p_add">+	.map    = riscv_irqdomain_map_noop,</span>
<span class="p_add">+	.xlate  = irq_domain_xlate_onecell,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_intc_init(struct device_node *node, struct device_node *parent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int hart;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (parent) return 0; // should have no interrupt parent</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((hart = riscv_of_processor_hart(node-&gt;parent)) &gt;= 0) {</span>
<span class="p_add">+		struct riscv_irq_data *data = &amp;per_cpu(riscv_irq_data, hart);</span>
<span class="p_add">+		snprintf(data-&gt;name, sizeof(data-&gt;name), &quot;riscv,cpu_intc,%d&quot;, hart);</span>
<span class="p_add">+		data-&gt;hart = hart;</span>
<span class="p_add">+		data-&gt;chip.name = data-&gt;name;</span>
<span class="p_add">+		data-&gt;chip.irq_mask = riscv_irq_mask;</span>
<span class="p_add">+		data-&gt;chip.irq_unmask = riscv_irq_unmask;</span>
<span class="p_add">+		data-&gt;chip.irq_enable = riscv_irq_enable;</span>
<span class="p_add">+		data-&gt;chip.irq_disable = riscv_irq_disable;</span>
<span class="p_add">+		data-&gt;domain = irq_domain_add_linear(node, 8*sizeof(uintptr_t), &amp;riscv_irqdomain_ops, data);</span>
<span class="p_add">+		WARN_ON(!data-&gt;domain);</span>
<span class="p_add">+		printk(&quot;%s: %d local interrupts mapped\n&quot;, data-&gt;name, 8*(int)sizeof(uintptr_t));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* If a hart is disabled, create a no-op irq domain.</span>
<span class="p_add">+		 * Devices may still have interrupts connected to those harts.</span>
<span class="p_add">+		 * This is not wrong... unless they actually load a driver that needs it!</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		irq_domain_add_linear(node, 8*sizeof(uintptr_t), &amp;riscv_irqdomain_ops_noop, node-&gt;parent);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+IRQCHIP_DECLARE(riscv, &quot;riscv,cpu-intc&quot;, riscv_intc_init);</span>
<span class="p_add">+</span>
<span class="p_add">+void __init init_IRQ(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	irqchip_init();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/module.c b/arch/riscv/kernel/module.c</span>
new file mode 100644
<span class="p_header">index 000000000000..c58d3847c05a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/module.c</span>
<span class="p_chunk">@@ -0,0 +1,185 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ *  This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ *  it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ *  the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ *  (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ *  GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ *  along with this program; if not, write to the Free Software</span>
<span class="p_add">+ *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Copyright (C) 2017 Zihao Yu</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/elf.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/errno.h&gt;</span>
<span class="p_add">+#include &lt;linux/moduleloader.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_64_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	*(u64 *)location = v;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_branch_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	s64 offset = (void*)v - (void *)location;</span>
<span class="p_add">+	u32 imm12 = (offset &amp; 0x1000) &lt;&lt; (31 - 12);</span>
<span class="p_add">+	u32 imm11 = (offset &amp; 0x800) &gt;&gt; (11 - 7);</span>
<span class="p_add">+	u32 imm10_5 = (offset &amp; 0x7e0) &lt;&lt; (30 - 10);</span>
<span class="p_add">+	u32 imm4_1 = (offset &amp; 0x1e) &lt;&lt; (11 - 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	*location = (*location &amp; 0x1fff07f) | imm12 | imm11 | imm10_5 | imm4_1;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_jal_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	s64 offset = (void*)v - (void *)location;</span>
<span class="p_add">+	u32 imm20 = (offset &amp; 0x100000) &lt;&lt; (31 - 20);</span>
<span class="p_add">+	u32 imm19_12 = (offset &amp; 0xff000);</span>
<span class="p_add">+	u32 imm11 = (offset &amp; 0x800) &lt;&lt; (20 - 11);</span>
<span class="p_add">+	u32 imm10_1 = (offset &amp; 0x7fe) &lt;&lt; (30 - 10);</span>
<span class="p_add">+</span>
<span class="p_add">+	*location = (*location &amp; 0xfff) | imm20 | imm19_12 | imm11 | imm10_1;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_pcrel_hi20_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	s64 offset = (void*)v - (void *)location;</span>
<span class="p_add">+	s32 hi20;</span>
<span class="p_add">+</span>
<span class="p_add">+	if(offset != (s32)offset) {</span>
<span class="p_add">+		pr_err(&quot;%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n&quot;, me-&gt;name, v, location);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hi20 = (offset + 0x800) &amp; 0xfffff000;</span>
<span class="p_add">+	*location = (*location &amp; 0xfff) | hi20;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_pcrel_lo12_i_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	/* v is the lo12 value to fill. It is calculated before calling this handler. */</span>
<span class="p_add">+	*location = (*location &amp; 0xfffff) | ((v &amp; 0xfff) &lt;&lt; 20);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_pcrel_lo12_s_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	/* v is the lo12 value to fill. It is calculated before calling this handler. */</span>
<span class="p_add">+	u32 imm11_5 = (v &amp; 0xfe0) &lt;&lt; (31 - 11);</span>
<span class="p_add">+	u32 imm4_0 = (v &amp; 0x1f) &lt;&lt; (11 - 4);</span>
<span class="p_add">+</span>
<span class="p_add">+	*location = (*location &amp; 0x1fff07f) | imm11_5 | imm4_0;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_call_plt_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	s64 offset = (void*)v - (void *)location;</span>
<span class="p_add">+	s32 fill_v = offset;</span>
<span class="p_add">+	u32 hi20, lo12;</span>
<span class="p_add">+	if(offset != fill_v) {</span>
<span class="p_add">+		pr_err(&quot;%s: target %016llx can not be addressed by the 32-bit offset from PC = %p\n&quot;, me-&gt;name, v, location);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hi20 = (offset + 0x800) &amp; 0xfffff000;</span>
<span class="p_add">+	lo12 = (offset - hi20) &amp; 0xfff;</span>
<span class="p_add">+	*location = (*location &amp; 0xfff) | hi20;</span>
<span class="p_add">+	*(location + 1) = (*(location + 1) &amp; 0xfffff) | (lo12 &lt;&lt; 20);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_r_riscv_relax_rela(struct module *me, u32 *location, Elf_Addr v) {</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int (*reloc_handlers_rela[]) (struct module *me, u32 *location,</span>
<span class="p_add">+				Elf_Addr v) = {</span>
<span class="p_add">+	[R_RISCV_64]			= apply_r_riscv_64_rela,</span>
<span class="p_add">+	[R_RISCV_BRANCH]		= apply_r_riscv_branch_rela,</span>
<span class="p_add">+	[R_RISCV_JAL]			= apply_r_riscv_jal_rela,</span>
<span class="p_add">+	[R_RISCV_PCREL_HI20]		= apply_r_riscv_pcrel_hi20_rela,</span>
<span class="p_add">+	[R_RISCV_PCREL_LO12_I]		= apply_r_riscv_pcrel_lo12_i_rela,</span>
<span class="p_add">+	[R_RISCV_PCREL_LO12_S]		= apply_r_riscv_pcrel_lo12_s_rela,</span>
<span class="p_add">+	[R_RISCV_CALL_PLT]		= apply_r_riscv_call_plt_rela,</span>
<span class="p_add">+	[R_RISCV_RELAX]			= apply_r_riscv_relax_rela,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+int apply_relocate_add(Elf_Shdr *sechdrs, const char *strtab,</span>
<span class="p_add">+		       unsigned int symindex, unsigned int relsec,</span>
<span class="p_add">+		       struct module *me) {</span>
<span class="p_add">+	Elf_Rela *rel = (void *) sechdrs[relsec].sh_addr;</span>
<span class="p_add">+	int (*handler)(struct module *me, u32 *location, Elf_Addr v);</span>
<span class="p_add">+	Elf_Sym *sym;</span>
<span class="p_add">+	u32 *location;</span>
<span class="p_add">+	unsigned int i, type;</span>
<span class="p_add">+	Elf_Addr v;</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Applying relocate section %u to %u\n&quot;, relsec,</span>
<span class="p_add">+	       sechdrs[relsec].sh_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; sechdrs[relsec].sh_size / sizeof(*rel); i++) {</span>
<span class="p_add">+		/* This is where to make the change */</span>
<span class="p_add">+		location = (void *)sechdrs[sechdrs[relsec].sh_info].sh_addr</span>
<span class="p_add">+			+ rel[i].r_offset;</span>
<span class="p_add">+		/* This is the symbol it is referring to */</span>
<span class="p_add">+		sym = (Elf_Sym *)sechdrs[symindex].sh_addr</span>
<span class="p_add">+			+ ELF_RISCV_R_SYM(rel[i].r_info);</span>
<span class="p_add">+		if (IS_ERR_VALUE(sym-&gt;st_value)) {</span>
<span class="p_add">+			/* Ignore unresolved weak symbol */</span>
<span class="p_add">+			if (ELF_ST_BIND(sym-&gt;st_info) == STB_WEAK)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			printk(KERN_WARNING &quot;%s: Unknown symbol %s\n&quot;,</span>
<span class="p_add">+			       me-&gt;name, strtab + sym-&gt;st_name);</span>
<span class="p_add">+			return -ENOENT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		type = ELF_RISCV_R_TYPE(rel[i].r_info);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (type &lt; ARRAY_SIZE(reloc_handlers_rela))</span>
<span class="p_add">+			handler = reloc_handlers_rela[type];</span>
<span class="p_add">+		else</span>
<span class="p_add">+			handler = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!handler) {</span>
<span class="p_add">+			pr_err(&quot;%s: Unknown relocation type %u\n&quot;,</span>
<span class="p_add">+			       me-&gt;name, type);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		v = sym-&gt;st_value + rel[i].r_addend;</span>
<span class="p_add">+</span>
<span class="p_add">+		if(type == R_RISCV_PCREL_LO12_I || type == R_RISCV_PCREL_LO12_S) {</span>
<span class="p_add">+			unsigned j;</span>
<span class="p_add">+			for (j = 0; j &lt; sechdrs[relsec].sh_size / sizeof(*rel); j++) {</span>
<span class="p_add">+				u64 hi20_loc = sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[j].r_offset;</span>
<span class="p_add">+				/* Find the corresponding HI20 PC-relative relocation entry */</span>
<span class="p_add">+				if(hi20_loc == sym-&gt;st_value) {</span>
<span class="p_add">+					Elf_Sym *hi20_sym = (Elf_Sym *)sechdrs[symindex].sh_addr + ELF_RISCV_R_SYM(rel[j].r_info);</span>
<span class="p_add">+					u64 hi20_sym_val = hi20_sym-&gt;st_value + rel[j].r_addend;</span>
<span class="p_add">+					/* Calculate lo12 */</span>
<span class="p_add">+					s64 offset = hi20_sym_val - hi20_loc;</span>
<span class="p_add">+					s32 hi20 = (offset + 0x800) &amp; 0xfffff000;</span>
<span class="p_add">+					s32 lo12 = offset - hi20;</span>
<span class="p_add">+					v = lo12;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if(j == sechdrs[relsec].sh_size / sizeof(*rel)) {</span>
<span class="p_add">+				pr_err(&quot;%s: Can not find HI20 PC-relative relocation information\n&quot;, me-&gt;name);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		res = handler(me, location, v);</span>
<span class="p_add">+		if (res)</span>
<span class="p_add">+			return res;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/pci.c b/arch/riscv/kernel/pci.c</span>
new file mode 100644
<span class="p_header">index 000000000000..4191a5ffdd67</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/pci.c</span>
<span class="p_chunk">@@ -0,0 +1,36 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Code borrowed from arch/arm64/kernel/pci.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2003 Anton Blanchard &lt;anton@au.ibm.com&gt;, IBM</span>
<span class="p_add">+ * Copyright (C) 2014 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ * version 2 as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/pci.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Called after each bus is probed, but before its children are examined</span>
<span class="p_add">+ */</span>
<span class="p_add">+void pcibios_fixup_bus(struct pci_bus *bus)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* nothing to do, expected to be removed in the future */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We don&#39;t have to worry about legacy ISA devices, so nothing to do here</span>
<span class="p_add">+ */</span>
<span class="p_add">+resource_size_t pcibios_align_resource(void *data, const struct resource *res,</span>
<span class="p_add">+				resource_size_t size, resource_size_t align)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return res-&gt;start;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/plic.c b/arch/riscv/kernel/plic.c</span>
new file mode 100644
<span class="p_header">index 000000000000..5b3d4241f4e2</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/plic.c</span>
<span class="p_chunk">@@ -0,0 +1,208 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqchip.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqchip/chained_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/irqdomain.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAX_DEVICES	1024 // 0 is reserved</span>
<span class="p_add">+#define MAX_CONTEXTS	15872</span>
<span class="p_add">+</span>
<span class="p_add">+#define PRIORITY_BASE	0</span>
<span class="p_add">+#define ENABLE_BASE	0x2000</span>
<span class="p_add">+#define ENABLE_SIZE	0x80</span>
<span class="p_add">+#define HART_BASE	0x200000</span>
<span class="p_add">+#define HART_SIZE	0x1000</span>
<span class="p_add">+</span>
<span class="p_add">+#define PLIC_HART_CONTEXT(data, i)	(struct plic_hart_context *)((char*)data-&gt;reg + HART_BASE + HART_SIZE*i)</span>
<span class="p_add">+#define PLIC_ENABLE_CONTEXT(data, i)	(struct plic_enable_context *)((char*)data-&gt;reg + ENABLE_BASE + ENABLE_SIZE*i)</span>
<span class="p_add">+#define PLIC_PRIORITY(data)		(struct plic_priority *)((char *)data-&gt;reg + PRIORITY_BASE)</span>
<span class="p_add">+</span>
<span class="p_add">+struct plic_hart_context {</span>
<span class="p_add">+	volatile u32 threshold;</span>
<span class="p_add">+	volatile u32 claim;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct plic_enable_context {</span>
<span class="p_add">+	atomic_t mask[32]; // 32-bit * 32-entry</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct plic_priority {</span>
<span class="p_add">+	volatile u32 prio[MAX_DEVICES];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct plic_data {</span>
<span class="p_add">+	struct irq_chip		chip;</span>
<span class="p_add">+	struct irq_domain	*domain;</span>
<span class="p_add">+	u32			ndev;</span>
<span class="p_add">+	void __iomem		*reg;</span>
<span class="p_add">+	int			handlers;</span>
<span class="p_add">+	struct plic_handler	*handler;</span>
<span class="p_add">+	char			name[30];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct plic_handler {</span>
<span class="p_add">+	struct plic_hart_context	*context;</span>
<span class="p_add">+	struct plic_data		*data;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void plic_disable(struct plic_data *data, int i, int hwirq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct plic_enable_context *enable = PLIC_ENABLE_CONTEXT(data, i);</span>
<span class="p_add">+	atomic_and(~(1 &lt;&lt; (hwirq % 32)), &amp;enable-&gt;mask[hwirq / 32]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void plic_enable(struct plic_data *data, int i, int hwirq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct plic_enable_context *enable = PLIC_ENABLE_CONTEXT(data, i);</span>
<span class="p_add">+	atomic_or((1 &lt;&lt; (hwirq % 32)), &amp;enable-&gt;mask[hwirq / 32]);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+// There is no need to mask/unmask PLIC interrupts</span>
<span class="p_add">+// They are &quot;masked&quot; by reading claim and &quot;unmasked&quot; when writing it back.</span>
<span class="p_add">+static void plic_irq_mask(struct irq_data *d) { }</span>
<span class="p_add">+static void plic_irq_unmask(struct irq_data *d) { }</span>
<span class="p_add">+</span>
<span class="p_add">+static void plic_irq_enable(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct plic_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	struct plic_priority *priority = PLIC_PRIORITY(data);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	iowrite32(1, &amp;priority-&gt;prio[d-&gt;hwirq]);</span>
<span class="p_add">+	for (i = 0; i &lt; data-&gt;handlers; ++i)</span>
<span class="p_add">+		if (data-&gt;handler[i].context)</span>
<span class="p_add">+			plic_enable(data, i, d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void plic_irq_disable(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct plic_data *data = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+	struct plic_priority *priority = PLIC_PRIORITY(data);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	iowrite32(0, &amp;priority-&gt;prio[d-&gt;hwirq]);</span>
<span class="p_add">+	for (i = 0; i &lt; data-&gt;handlers; ++i)</span>
<span class="p_add">+		if (data-&gt;handler[i].context)</span>
<span class="p_add">+			plic_disable(data, i, d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int plic_irqdomain_map(struct irq_domain *d, unsigned int irq, irq_hw_number_t hwirq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct plic_data *data = d-&gt;host_data;</span>
<span class="p_add">+</span>
<span class="p_add">+        irq_set_chip_and_handler(irq, &amp;data-&gt;chip, handle_simple_irq);</span>
<span class="p_add">+        irq_set_chip_data(irq, data);</span>
<span class="p_add">+        irq_set_noprobe(irq);</span>
<span class="p_add">+</span>
<span class="p_add">+        return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct irq_domain_ops plic_irqdomain_ops = {</span>
<span class="p_add">+	.map	= plic_irqdomain_map,</span>
<span class="p_add">+	.xlate	= irq_domain_xlate_onecell,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void plic_chained_handle_irq(struct irq_desc *desc)</span>
<span class="p_add">+{</span>
<span class="p_add">+        struct plic_handler *handler = irq_desc_get_handler_data(desc);</span>
<span class="p_add">+	struct irq_chip *chip = irq_desc_get_chip(desc);</span>
<span class="p_add">+	struct irq_domain *domain = handler-&gt;data-&gt;domain;</span>
<span class="p_add">+	u32 what;</span>
<span class="p_add">+</span>
<span class="p_add">+	chained_irq_enter(chip, desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((what = ioread32(&amp;handler-&gt;context-&gt;claim))) {</span>
<span class="p_add">+		int irq = irq_find_mapping(domain, what);</span>
<span class="p_add">+		if (irq &gt; 0) {</span>
<span class="p_add">+			generic_handle_irq(irq);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			handle_bad_irq(desc);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		iowrite32(what, &amp;handler-&gt;context-&gt;claim);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	chained_irq_exit(chip, desc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+// TODO: add a /sys interface to set priority + per-hart enables for steering</span>
<span class="p_add">+</span>
<span class="p_add">+static int plic_init(struct device_node *node, struct device_node *parent)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct plic_data *data;</span>
<span class="p_add">+	struct resource resource;</span>
<span class="p_add">+	int i, ok = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = kzalloc(sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (WARN_ON(!data)) return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;reg = of_iomap(node, 0);</span>
<span class="p_add">+	if (WARN_ON(!data-&gt;reg)) return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	of_property_read_u32(node, &quot;riscv,ndev&quot;, &amp;data-&gt;ndev);</span>
<span class="p_add">+	if (WARN_ON(!data-&gt;ndev)) return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;handlers = of_irq_count(node);</span>
<span class="p_add">+	if (WARN_ON(!data-&gt;handlers)) return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;handler = kzalloc(sizeof(*data-&gt;handler)*data-&gt;handlers, GFP_KERNEL);</span>
<span class="p_add">+	if (WARN_ON(!data-&gt;handler)) return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	data-&gt;domain = irq_domain_add_linear(node, data-&gt;ndev+1, &amp;plic_irqdomain_ops, data);</span>
<span class="p_add">+	if (WARN_ON(!data-&gt;domain)) return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	of_address_to_resource(node, 0, &amp;resource);</span>
<span class="p_add">+	snprintf(data-&gt;name, sizeof(data-&gt;name), &quot;riscv,plic0,%llx&quot;, resource.start);</span>
<span class="p_add">+	data-&gt;chip.name = data-&gt;name;</span>
<span class="p_add">+	data-&gt;chip.irq_mask = plic_irq_mask;</span>
<span class="p_add">+	data-&gt;chip.irq_unmask = plic_irq_unmask;</span>
<span class="p_add">+	data-&gt;chip.irq_enable = plic_irq_enable;</span>
<span class="p_add">+	data-&gt;chip.irq_disable = plic_irq_disable;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; data-&gt;handlers; ++i) {</span>
<span class="p_add">+		struct plic_handler *handler = &amp;data-&gt;handler[i];</span>
<span class="p_add">+		struct of_phandle_args parent;</span>
<span class="p_add">+		int parent_irq, hwirq;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (of_irq_parse_one(node, i, &amp;parent)) continue;</span>
<span class="p_add">+		if (parent.args[0] == -1) continue; // skip context holes</span>
<span class="p_add">+</span>
<span class="p_add">+		// skip any contexts that lead to inactive harts</span>
<span class="p_add">+		if (of_device_is_compatible(parent.np, &quot;riscv,cpu-intc&quot;) &amp;&amp;</span>
<span class="p_add">+		    parent.np-&gt;parent &amp;&amp;</span>
<span class="p_add">+		    riscv_of_processor_hart(parent.np-&gt;parent) &lt; 0) continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		parent_irq = irq_create_of_mapping(&amp;parent);</span>
<span class="p_add">+		if (!parent_irq) continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		handler-&gt;context = PLIC_HART_CONTEXT(data, i);</span>
<span class="p_add">+		handler-&gt;data = data;</span>
<span class="p_add">+		iowrite32(0, &amp;handler-&gt;context-&gt;threshold); // hwirq prio must be &gt; this to trigger an interrupt</span>
<span class="p_add">+		for (hwirq = 1; hwirq &lt;= data-&gt;ndev; ++hwirq) plic_disable(data, i, hwirq);</span>
<span class="p_add">+		irq_set_chained_handler_and_data(parent_irq, plic_chained_handle_irq, handler);</span>
<span class="p_add">+		++ok;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(&quot;%s: mapped %d interrupts to %d/%d handlers\n&quot;, data-&gt;name, data-&gt;ndev, ok, data-&gt;handlers);</span>
<span class="p_add">+	WARN_ON(!ok);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+IRQCHIP_DECLARE(plic0, &quot;riscv,plic0&quot;, plic_init);</span>
<span class="p_header">diff --git a/arch/riscv/kernel/process.c b/arch/riscv/kernel/process.c</span>
new file mode 100644
<span class="p_header">index 000000000000..0552017c49ce</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/process.c</span>
<span class="p_chunk">@@ -0,0 +1,130 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/tick.h&gt;</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+#include &lt;asm/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+#include &lt;asm/string.h&gt;</span>
<span class="p_add">+#include &lt;asm/switch_to.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern asmlinkage void ret_from_fork(void);</span>
<span class="p_add">+extern asmlinkage void ret_from_kernel_thread(void);</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_cpu_idle(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	wait_for_interrupt();</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void show_regs(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	show_regs_print_info(KERN_DEFAULT);</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(&quot;sepc: &quot; REG_FMT &quot; ra : &quot; REG_FMT &quot; sp : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;sepc, regs-&gt;ra, regs-&gt;sp);</span>
<span class="p_add">+	printk(&quot; gp : &quot; REG_FMT &quot; tp : &quot; REG_FMT &quot; t0 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;gp, regs-&gt;tp, regs-&gt;t0);</span>
<span class="p_add">+	printk(&quot; t1 : &quot; REG_FMT &quot; t2 : &quot; REG_FMT &quot; s0 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;t1, regs-&gt;t2, regs-&gt;s0);</span>
<span class="p_add">+	printk(&quot; s1 : &quot; REG_FMT &quot; a0 : &quot; REG_FMT &quot; a1 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s1, regs-&gt;a0, regs-&gt;a1);</span>
<span class="p_add">+	printk(&quot; a2 : &quot; REG_FMT &quot; a3 : &quot; REG_FMT &quot; a4 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;a2, regs-&gt;a3, regs-&gt;a4);</span>
<span class="p_add">+	printk(&quot; a5 : &quot; REG_FMT &quot; a6 : &quot; REG_FMT &quot; a7 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;a5, regs-&gt;a6, regs-&gt;a7);</span>
<span class="p_add">+	printk(&quot; s2 : &quot; REG_FMT &quot; s3 : &quot; REG_FMT &quot; s4 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s2, regs-&gt;s3, regs-&gt;s4);</span>
<span class="p_add">+	printk(&quot; s5 : &quot; REG_FMT &quot; s6 : &quot; REG_FMT &quot; s7 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s5, regs-&gt;s6, regs-&gt;s7);</span>
<span class="p_add">+	printk(&quot; s8 : &quot; REG_FMT &quot; s9 : &quot; REG_FMT &quot; s10: &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s8, regs-&gt;s9, regs-&gt;s10);</span>
<span class="p_add">+	printk(&quot; s11: &quot; REG_FMT &quot; t3 : &quot; REG_FMT &quot; t4 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;s11, regs-&gt;t3, regs-&gt;t4);</span>
<span class="p_add">+	printk(&quot; t5 : &quot; REG_FMT &quot; t6 : &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;t5, regs-&gt;t6);</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(&quot;sstatus: &quot; REG_FMT &quot; sbadaddr: &quot; REG_FMT &quot; scause: &quot; REG_FMT &quot;\n&quot;,</span>
<span class="p_add">+		regs-&gt;sstatus, regs-&gt;sbadaddr, regs-&gt;scause);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void start_thread(struct pt_regs *regs, unsigned long pc, </span>
<span class="p_add">+	unsigned long sp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	regs-&gt;sstatus = SR_PIE /* User mode, irqs on */ | SR_FS_INITIAL;</span>
<span class="p_add">+	regs-&gt;sepc = pc;</span>
<span class="p_add">+	regs-&gt;sp = sp;</span>
<span class="p_add">+	set_fs(USER_DS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void flush_thread(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Reset FPU context</span>
<span class="p_add">+	 *	frm: round to nearest, ties to even (IEEE default)</span>
<span class="p_add">+	 *	fflags: accrued exceptions cleared</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memset(&amp;current-&gt;thread.fstate, 0,</span>
<span class="p_add">+		sizeof(struct user_fpregs_struct));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	fstate_save(src, task_pt_regs(src));</span>
<span class="p_add">+	*dst = *src;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int copy_thread(unsigned long clone_flags, unsigned long usp,</span>
<span class="p_add">+	unsigned long arg, struct task_struct *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *childregs = task_pt_regs(p);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* p-&gt;thread holds context to be restored by __switch_to() */</span>
<span class="p_add">+	if (unlikely(p-&gt;flags &amp; PF_KTHREAD)) {</span>
<span class="p_add">+		/* Kernel thread */</span>
<span class="p_add">+		const register unsigned long gp __asm__ (&quot;gp&quot;);</span>
<span class="p_add">+		memset(childregs, 0, sizeof(struct pt_regs));</span>
<span class="p_add">+		childregs-&gt;gp = gp;</span>
<span class="p_add">+		childregs-&gt;sstatus = SR_PS | SR_PIE; /* Supervisor, irqs on */</span>
<span class="p_add">+</span>
<span class="p_add">+		p-&gt;thread.ra = (unsigned long)ret_from_kernel_thread;</span>
<span class="p_add">+		p-&gt;thread.s[0] = usp; /* fn */</span>
<span class="p_add">+		p-&gt;thread.s[1] = arg;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		*childregs = *(current_pt_regs());</span>
<span class="p_add">+		if (usp) /* User fork */</span>
<span class="p_add">+			childregs-&gt;sp = usp;</span>
<span class="p_add">+		if (clone_flags &amp; CLONE_SETTLS)</span>
<span class="p_add">+			childregs-&gt;tp = childregs-&gt;a5;</span>
<span class="p_add">+		childregs-&gt;a0 = 0; /* Return value of fork() */</span>
<span class="p_add">+		p-&gt;thread.ra = (unsigned long)ret_from_fork;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	p-&gt;thread.sp = (unsigned long)childregs; /* kernel sp */</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/ptrace.c b/arch/riscv/kernel/ptrace.c</span>
new file mode 100644
<span class="p_header">index 000000000000..35d3d85817e6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/ptrace.c</span>
<span class="p_chunk">@@ -0,0 +1,148 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright 2010 Tilera Corporation. All Rights Reserved.</span>
<span class="p_add">+ * Copyright 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copied from arch/tile/kernel/ptrace.c</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/syscall.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;linux/elf.h&gt;</span>
<span class="p_add">+#include &lt;linux/regset.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/tracehook.h&gt;</span>
<span class="p_add">+#include &lt;trace/events/syscalls.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+enum riscv_regset {</span>
<span class="p_add">+	REGSET_X,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Get registers from task and ready the result for userspace.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static char *getregs(struct task_struct *child, struct pt_regs *uregs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*uregs = *task_pt_regs(child);</span>
<span class="p_add">+	return (char *)uregs;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Put registers back to task. */</span>
<span class="p_add">+static void putregs(struct task_struct *child, struct pt_regs *uregs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *regs = task_pt_regs(child);</span>
<span class="p_add">+	*regs = *uregs;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_gpr_get(struct task_struct *target,</span>
<span class="p_add">+                         const struct user_regset *regset,</span>
<span class="p_add">+                         unsigned int pos, unsigned int count,</span>
<span class="p_add">+                         void *kbuf, void __user *ubuf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs regs;</span>
<span class="p_add">+</span>
<span class="p_add">+	getregs(target, &amp;regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	return user_regset_copyout(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;regs, 0,</span>
<span class="p_add">+				   sizeof(regs));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_gpr_set(struct task_struct *target,</span>
<span class="p_add">+                         const struct user_regset *regset,</span>
<span class="p_add">+                         unsigned int pos, unsigned int count,</span>
<span class="p_add">+                         const void *kbuf, const void __user *ubuf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	struct pt_regs regs;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = user_regset_copyin(&amp;pos, &amp;count, &amp;kbuf, &amp;ubuf, &amp;regs, 0,</span>
<span class="p_add">+				 sizeof(regs));</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	putregs(target, &amp;regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct user_regset riscv_user_regset[] = {</span>
<span class="p_add">+	[REGSET_X] = {</span>
<span class="p_add">+		.core_note_type = NT_PRSTATUS,</span>
<span class="p_add">+		.n = ELF_NGREG,</span>
<span class="p_add">+		.size = sizeof(elf_greg_t),</span>
<span class="p_add">+		.align = sizeof(elf_greg_t),</span>
<span class="p_add">+		.get = &amp;riscv_gpr_get,</span>
<span class="p_add">+		.set = &amp;riscv_gpr_set,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct user_regset_view riscv_user_native_view = {</span>
<span class="p_add">+	.name = &quot;riscv&quot;,</span>
<span class="p_add">+	.e_machine = EM_RISCV,</span>
<span class="p_add">+	.regsets = riscv_user_regset,</span>
<span class="p_add">+	.n = ARRAY_SIZE(riscv_user_regset),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+const struct user_regset_view *task_user_regset_view(struct task_struct *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;riscv_user_native_view;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void ptrace_disable(struct task_struct *child)</span>
<span class="p_add">+{</span>
<span class="p_add">+        clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+long arch_ptrace(struct task_struct *child, long request,</span>
<span class="p_add">+                 unsigned long addr, unsigned long data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long ret = -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (request) {</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		ret = ptrace_request(child, request, addr, data);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Allows PTRACE_SYSCALL to work.  These are called from entry.S in</span>
<span class="p_add">+ * {handle,ret_from}_syscall. */</span>
<span class="p_add">+void do_syscall_trace_enter(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACE)) {</span>
<span class="p_add">+		if (tracehook_report_syscall_entry(regs))</span>
<span class="p_add">+			syscall_set_nr(current, regs, -1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))</span>
<span class="p_add">+		trace_sys_enter(regs, syscall_get_nr(current, regs));</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_syscall_trace_exit(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACE))</span>
<span class="p_add">+		tracehook_report_syscall_exit(regs, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HAVE_SYSCALL_TRACEPOINTS</span>
<span class="p_add">+	if (test_thread_flag(TIF_SYSCALL_TRACEPOINT))</span>
<span class="p_add">+		trace_sys_exit(regs, regs-&gt;regs[0]);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/reset.c b/arch/riscv/kernel/reset.c</span>
new file mode 100644
<span class="p_header">index 000000000000..58bad9598e21</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/reset.c</span>
<span class="p_chunk">@@ -0,0 +1,33 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/reboot.h&gt;</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void (*pm_power_off)(void) = machine_power_off;</span>
<span class="p_add">+EXPORT_SYMBOL(pm_power_off);</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_restart(char *cmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_halt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void machine_power_off(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+  sbi_shutdown();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/riscv_ksyms.c b/arch/riscv/kernel/riscv_ksyms.c</span>
new file mode 100644
<span class="p_header">index 000000000000..ab0db6d48101</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/riscv_ksyms.c</span>
<span class="p_chunk">@@ -0,0 +1,16 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2017 Zihao Yu</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Assembly functions that may be used (directly or indirectly) by modules</span>
<span class="p_add">+ */</span>
<span class="p_add">+EXPORT_SYMBOL(__copy_user);</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/riscv/kernel/sbi-con.c b/arch/riscv/kernel/sbi-con.c</span>
new file mode 100644
<span class="p_header">index 000000000000..86baeb5ef0cd</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/sbi-con.c</span>
<span class="p_chunk">@@ -0,0 +1,214 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
<span class="p_add">+#include &lt;linux/timer.h&gt;</span>
<span class="p_add">+#include &lt;linux/tty.h&gt;</span>
<span class="p_add">+#include &lt;linux/tty_flip.h&gt;</span>
<span class="p_add">+#include &lt;linux/tty_driver.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define SBI_POLL_PERIOD 1</span>
<span class="p_add">+#define SBI_MAX_GETCHARS 10</span>
<span class="p_add">+</span>
<span class="p_add">+static struct tty_driver *sbi_tty_driver;</span>
<span class="p_add">+</span>
<span class="p_add">+struct sbi_console_private {</span>
<span class="p_add">+	struct tty_port port;</span>
<span class="p_add">+	struct timer_list timer;</span>
<span class="p_add">+</span>
<span class="p_add">+} sbi_console_singleton;</span>
<span class="p_add">+</span>
<span class="p_add">+static void sbi_console_getchars(uintptr_t data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sbi_console_private *priv = (struct sbi_console_private *)data;</span>
<span class="p_add">+	struct tty_port *port = &amp;priv-&gt;port;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	int ch;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((ch = sbi_console_getchar()) &gt;= 0) {</span>
<span class="p_add">+		tty_insert_flip_char(port, ch, TTY_NORMAL);</span>
<span class="p_add">+		tty_flip_buffer_push(port);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mod_timer(&amp;priv-&gt;timer, jiffies + SBI_POLL_PERIOD);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int sbi_tty_write(struct tty_struct *tty,</span>
<span class="p_add">+	const unsigned char *buf, int count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const unsigned char *end;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (end = buf + count; buf &lt; end; buf++) {</span>
<span class="p_add">+		sbi_console_putchar(*buf);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return count;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int sbi_tty_write_room(struct tty_struct *tty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 1024; /* arbitrary */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int sbi_tty_open(struct tty_struct *tty, struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sbi_console_private *priv = &amp;sbi_console_singleton;</span>
<span class="p_add">+	struct tty_port *port = &amp;priv-&gt;port;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!port-&gt;tty) {</span>
<span class="p_add">+		tty-&gt;driver_data = priv;</span>
<span class="p_add">+		tty-&gt;port = port;</span>
<span class="p_add">+		port-&gt;tty = tty;</span>
<span class="p_add">+		mod_timer(&amp;priv-&gt;timer, jiffies);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void sbi_tty_close(struct tty_struct *tty, struct file *filp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sbi_console_private *priv = tty-&gt;driver_data;</span>
<span class="p_add">+	struct tty_port *port = &amp;priv-&gt;port;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tty-&gt;count == 1) {</span>
<span class="p_add">+		port-&gt;tty = NULL;</span>
<span class="p_add">+		del_timer(&amp;priv-&gt;timer);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct tty_operations sbi_tty_ops = {</span>
<span class="p_add">+	.open		= sbi_tty_open,</span>
<span class="p_add">+	.close		= sbi_tty_close,</span>
<span class="p_add">+	.write		= sbi_tty_write,</span>
<span class="p_add">+	.write_room	= sbi_tty_write_room,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static void sbi_console_write(struct console *co, const char *buf, unsigned n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	for ( ; n &gt; 0; n--, buf++) {</span>
<span class="p_add">+		if (*buf == &#39;\n&#39;)</span>
<span class="p_add">+			sbi_console_putchar(&#39;\r&#39;);</span>
<span class="p_add">+		sbi_console_putchar(*buf);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct tty_driver *sbi_console_device(struct console *co, int *index)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*index = co-&gt;index;</span>
<span class="p_add">+	return sbi_tty_driver;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int sbi_console_setup(struct console *co, char *options)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return co-&gt;index != 0 ? -ENODEV : 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct console sbi_console = {</span>
<span class="p_add">+	.name	= &quot;sbi_console&quot;,</span>
<span class="p_add">+	.write	= sbi_console_write,</span>
<span class="p_add">+	.device	= sbi_console_device,</span>
<span class="p_add">+	.setup	= sbi_console_setup,</span>
<span class="p_add">+	.flags	= CON_PRINTBUFFER,</span>
<span class="p_add">+	.index	= -1</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init sbi_console_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	static struct tty_driver *drv;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_timer(&amp;sbi_console_singleton.timer, sbi_console_getchars,</span>
<span class="p_add">+		    (uintptr_t)&amp;sbi_console_singleton);</span>
<span class="p_add">+	register_console(&amp;sbi_console);</span>
<span class="p_add">+</span>
<span class="p_add">+	drv = tty_alloc_driver(1, TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV);</span>
<span class="p_add">+	if (unlikely(IS_ERR(drv)))</span>
<span class="p_add">+		return PTR_ERR(drv);</span>
<span class="p_add">+</span>
<span class="p_add">+	drv-&gt;driver_name = &quot;sbi&quot;;</span>
<span class="p_add">+	drv-&gt;name = &quot;ttySBI&quot;;</span>
<span class="p_add">+	drv-&gt;major = TTY_MAJOR;</span>
<span class="p_add">+	drv-&gt;minor_start = 0;</span>
<span class="p_add">+	drv-&gt;type = TTY_DRIVER_TYPE_SERIAL;</span>
<span class="p_add">+	drv-&gt;subtype = SERIAL_TYPE_NORMAL;</span>
<span class="p_add">+	drv-&gt;init_termios = tty_std_termios;</span>
<span class="p_add">+	tty_set_operations(drv, &amp;sbi_tty_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	tty_port_init(&amp;sbi_console_singleton.port);</span>
<span class="p_add">+	tty_port_link_device(&amp;sbi_console_singleton.port, drv, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = tty_register_driver(drv);</span>
<span class="p_add">+	if (unlikely(ret))</span>
<span class="p_add">+		goto out_tty_put;</span>
<span class="p_add">+</span>
<span class="p_add">+	sbi_tty_driver = drv;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out_tty_put:</span>
<span class="p_add">+	put_tty_driver(drv);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit sbi_console_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	tty_unregister_driver(sbi_tty_driver);</span>
<span class="p_add">+	put_tty_driver(sbi_tty_driver);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+module_init(sbi_console_init);</span>
<span class="p_add">+module_exit(sbi_console_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;RISC-V SBI console driver&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_EARLY_PRINTK</span>
<span class="p_add">+</span>
<span class="p_add">+static struct console early_console_dev __initdata = {</span>
<span class="p_add">+	.name	= &quot;early&quot;,</span>
<span class="p_add">+	.write	= sbi_console_write,</span>
<span class="p_add">+	.flags	= CON_PRINTBUFFER | CON_BOOT,</span>
<span class="p_add">+	.index	= -1</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init setup_early_printk(char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (early_console == NULL) {</span>
<span class="p_add">+		early_console = &amp;early_console_dev;</span>
<span class="p_add">+		register_console(early_console);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+early_param(&quot;earlyprintk&quot;, setup_early_printk);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/riscv/kernel/setup.c b/arch/riscv/kernel/setup.c</span>
new file mode 100644
<span class="p_header">index 000000000000..5100eab75c14</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/setup.c</span>
<span class="p_chunk">@@ -0,0 +1,234 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
<span class="p_add">+#include &lt;linux/console.h&gt;</span>
<span class="p_add">+#include &lt;linux/screen_info.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_fdt.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/pgtable.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+struct screen_info screen_info = {</span>
<span class="p_add">+	.orig_video_lines	= 30,</span>
<span class="p_add">+	.orig_video_cols	= 80,</span>
<span class="p_add">+	.orig_video_mode	= 0,</span>
<span class="p_add">+	.orig_video_ega_bx	= 0,</span>
<span class="p_add">+	.orig_video_isVGA	= 1,</span>
<span class="p_add">+	.orig_video_points	= 8</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+static char __initdata builtin_cmdline[COMMAND_LINE_SIZE] = CONFIG_CMDLINE;</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long va_pa_offset;</span>
<span class="p_add">+unsigned long pfn_base;</span>
<span class="p_add">+</span>
<span class="p_add">+/* The lucky hart to first increment this variable will boot the other cores */</span>
<span class="p_add">+atomic_t hart_lottery;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+static void __init setup_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char __initramfs_start[];</span>
<span class="p_add">+	extern unsigned long __initramfs_size;</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__initramfs_size &gt; 0) {</span>
<span class="p_add">+		initrd_start = (unsigned long)(&amp;__initramfs_start);</span>
<span class="p_add">+		initrd_end = initrd_start + __initramfs_size;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (initrd_start &gt;= initrd_end) {</span>
<span class="p_add">+		printk(KERN_INFO &quot;initrd not found or empty&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (__pa(initrd_end) &gt; PFN_PHYS(max_low_pfn)) {</span>
<span class="p_add">+		printk(KERN_ERR &quot;initrd extends beyond end of memory&quot;);</span>
<span class="p_add">+		goto disable;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	size =  initrd_end - initrd_start;</span>
<span class="p_add">+	memblock_reserve(__pa(initrd_start), size);</span>
<span class="p_add">+	initrd_below_start_ok = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(KERN_INFO &quot;Initial ramdisk at: 0x%p (%lu bytes)\n&quot;,</span>
<span class="p_add">+		(void *)(initrd_start), size);</span>
<span class="p_add">+	return;</span>
<span class="p_add">+disable:</span>
<span class="p_add">+	printk(KERN_CONT &quot; - disabling initrd\n&quot;);</span>
<span class="p_add">+	initrd_start = 0;</span>
<span class="p_add">+	initrd_end = 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+pgd_t swapper_pg_dir[PTRS_PER_PGD] __page_aligned_bss;</span>
<span class="p_add">+pgd_t trampoline_pg_dir[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+#define NUM_SWAPPER_PMDS ((uintptr_t)-PAGE_OFFSET &gt;&gt; PGDIR_SHIFT)</span>
<span class="p_add">+pmd_t swapper_pmd[PTRS_PER_PMD*((-PAGE_OFFSET)/PGDIR_SIZE)] __page_aligned_bss;</span>
<span class="p_add">+pmd_t trampoline_pmd[PTRS_PER_PGD] __initdata __aligned(PAGE_SIZE);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void __init setup_vm(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char _start;</span>
<span class="p_add">+	uintptr_t i;</span>
<span class="p_add">+	uintptr_t pa = (uintptr_t) &amp;_start;</span>
<span class="p_add">+	pgprot_t prot = __pgprot(pgprot_val(PAGE_KERNEL) | _PAGE_EXEC);</span>
<span class="p_add">+</span>
<span class="p_add">+	va_pa_offset = PAGE_OFFSET - pa;</span>
<span class="p_add">+	pfn_base = PFN_DOWN(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Sanity check alignment and size */</span>
<span class="p_add">+	BUG_ON((PAGE_OFFSET % PGDIR_SIZE) != 0);</span>
<span class="p_add">+	BUG_ON((pa % (PAGE_SIZE * PTRS_PER_PTE)) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __PAGETABLE_PMD_FOLDED</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN((uintptr_t)trampoline_pmd),</span>
<span class="p_add">+			__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	trampoline_pmd[0] = pfn_pmd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i)</span>
<span class="p_add">+		swapper_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN((uintptr_t)swapper_pmd) + i,</span>
<span class="p_add">+				__pgprot(_PAGE_TABLE));</span>
<span class="p_add">+	for (i = 0; i &lt; sizeof(swapper_pmd)/sizeof(swapper_pmd[0]); i++)</span>
<span class="p_add">+		swapper_pmd[i] = pfn_pmd(PFN_DOWN(pa + i * PMD_SIZE), prot);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	trampoline_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD] =</span>
<span class="p_add">+		pfn_pgd(PFN_DOWN(pa), prot);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; (-PAGE_OFFSET)/PGDIR_SIZE; ++i)</span>
<span class="p_add">+		swapper_pg_dir[(PAGE_OFFSET &gt;&gt; PGDIR_SHIFT) % PTRS_PER_PGD + i] =</span>
<span class="p_add">+			pfn_pgd(PFN_DOWN(pa + i * PGDIR_SIZE), prot);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init sbi_save(unsigned hartid, void *dtb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	init_thread_info.cpu = hartid;</span>
<span class="p_add">+	early_init_dt_scan(__va(dtb));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Allow the user to manually add a memory region (in case DTS is broken); &quot;mem_end=nn[KkMmGg]&quot; */</span>
<span class="p_add">+static int __init mem_end_override(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	resource_size_t base, end;</span>
<span class="p_add">+	if (!p)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	base = (uintptr_t) __pa(PAGE_OFFSET);</span>
<span class="p_add">+	end = memparse(p, &amp;p) &amp; PMD_MASK;</span>
<span class="p_add">+	if (end == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	memblock_add(base, end - base);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+early_param(&quot;mem_end&quot;, mem_end_override);</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init setup_bootmem(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct memblock_region *reg;</span>
<span class="p_add">+	phys_addr_t mem_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the memory region containing the kernel */</span>
<span class="p_add">+	for_each_memblock(memory, reg) {</span>
<span class="p_add">+		phys_addr_t vmlinux_end = __pa(_end);</span>
<span class="p_add">+		phys_addr_t end = reg-&gt;base + reg-&gt;size;</span>
<span class="p_add">+		if (reg-&gt;base &lt;= vmlinux_end &amp;&amp; vmlinux_end &lt;= end) {</span>
<span class="p_add">+			/* Reserve from the start of the region to the end of the kernel */</span>
<span class="p_add">+			memblock_reserve(reg-&gt;base, vmlinux_end - reg-&gt;base);</span>
<span class="p_add">+			mem_size = min(reg-&gt;size, (phys_addr_t)-PAGE_OFFSET);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	BUG_ON(mem_size == 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_max_mapnr(PFN_DOWN(mem_size));</span>
<span class="p_add">+	max_low_pfn = pfn_base + PFN_DOWN(mem_size);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_BLK_DEV_INITRD</span>
<span class="p_add">+	setup_initrd();</span>
<span class="p_add">+#endif /* CONFIG_BLK_DEV_INITRD */</span>
<span class="p_add">+</span>
<span class="p_add">+	early_init_fdt_reserve_self();</span>
<span class="p_add">+	early_init_fdt_scan_reserved_mem();</span>
<span class="p_add">+	memblock_allow_resize();</span>
<span class="p_add">+	memblock_dump_all();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_arch(char **cmdline_p)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_BOOL</span>
<span class="p_add">+#ifdef CONFIG_CMDLINE_OVERRIDE</span>
<span class="p_add">+	strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	if (builtin_cmdline[0] != &#39;\0&#39;) {</span>
<span class="p_add">+		/* Append bootloader command line to built-in */</span>
<span class="p_add">+		strlcat(builtin_cmdline, &quot; &quot;, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcat(builtin_cmdline, boot_command_line, COMMAND_LINE_SIZE);</span>
<span class="p_add">+		strlcpy(boot_command_line, builtin_cmdline, COMMAND_LINE_SIZE);</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_OVERRIDE */</span>
<span class="p_add">+#endif /* CONFIG_CMDLINE_BOOL */</span>
<span class="p_add">+	*cmdline_p = boot_command_line;</span>
<span class="p_add">+</span>
<span class="p_add">+	parse_early_param();</span>
<span class="p_add">+</span>
<span class="p_add">+	init_mm.start_code = (unsigned long) _stext;</span>
<span class="p_add">+	init_mm.end_code   = (unsigned long) _etext;</span>
<span class="p_add">+	init_mm.end_data   = (unsigned long) _edata;</span>
<span class="p_add">+	init_mm.brk        = (unsigned long) _end;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_bootmem();</span>
<span class="p_add">+	paging_init();</span>
<span class="p_add">+	unflatten_device_tree();</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	setup_smp();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_DUMMY_CONSOLE</span>
<span class="p_add">+	conswitchp = &amp;dummy_con;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init riscv_device_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+subsys_initcall_sync(riscv_device_init);</span>
<span class="p_header">diff --git a/arch/riscv/kernel/signal.c b/arch/riscv/kernel/signal.c</span>
new file mode 100644
<span class="p_header">index 000000000000..d71bb3377583</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/signal.c</span>
<span class="p_chunk">@@ -0,0 +1,258 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Sunplus Core Technology Co., Ltd.</span>
<span class="p_add">+ *  Chen Liqin &lt;liqin.chen@sunplusct.com&gt;</span>
<span class="p_add">+ *  Lennox Wu &lt;lennox.wu@sunplusct.com&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License as published by</span>
<span class="p_add">+ * the Free Software Foundation; either version 2 of the License, or</span>
<span class="p_add">+ * (at your option) any later version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, see the file COPYING, or write</span>
<span class="p_add">+ * to the Free Software Foundation, Inc.,</span>
<span class="p_add">+ * 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
<span class="p_add">+#include &lt;linux/tracehook.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/ucontext.h&gt;</span>
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
<span class="p_add">+#include &lt;asm/switch_to.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DEBUG_SIG 0</span>
<span class="p_add">+</span>
<span class="p_add">+struct rt_sigframe {</span>
<span class="p_add">+	struct siginfo info;</span>
<span class="p_add">+	struct ucontext uc;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static long restore_sigcontext(struct pt_regs *regs,</span>
<span class="p_add">+	struct sigcontext __user *sc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_struct *task = current;</span>
<span class="p_add">+	long err;</span>
<span class="p_add">+	/* sc_regs is structured the same as the start of pt_regs */</span>
<span class="p_add">+	err = __copy_from_user(regs, &amp;sc-&gt;sc_regs, sizeof(sc-&gt;sc_regs));</span>
<span class="p_add">+	err |= __copy_from_user(&amp;task-&gt;thread.fstate, &amp;sc-&gt;sc_fpregs,</span>
<span class="p_add">+		sizeof(sc-&gt;sc_fpregs));</span>
<span class="p_add">+	if (likely(!err))</span>
<span class="p_add">+		fstate_restore(task, regs);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+SYSCALL_DEFINE0(rt_sigreturn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *regs = current_pt_regs();</span>
<span class="p_add">+	struct rt_sigframe __user *frame;</span>
<span class="p_add">+	struct task_struct *task;</span>
<span class="p_add">+	sigset_t set;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Always make any pending restarted system calls return -EINTR */</span>
<span class="p_add">+	current-&gt;restart_block.fn = do_no_restart_syscall;</span>
<span class="p_add">+</span>
<span class="p_add">+	frame = (struct rt_sigframe __user *)regs-&gt;sp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__copy_from_user(&amp;set, &amp;frame-&gt;uc.uc_sigmask, sizeof(set)))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_current_blocked(&amp;set);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (restore_sigcontext(regs, &amp;frame-&gt;uc.uc_mcontext))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (restore_altstack(&amp;frame-&gt;uc.uc_stack))</span>
<span class="p_add">+		goto badframe;</span>
<span class="p_add">+</span>
<span class="p_add">+	return regs-&gt;a0;</span>
<span class="p_add">+</span>
<span class="p_add">+badframe:</span>
<span class="p_add">+	task = current;</span>
<span class="p_add">+	if (show_unhandled_signals) {</span>
<span class="p_add">+		pr_info_ratelimited(&quot;%s[%d]: bad frame in %s: &quot;</span>
<span class="p_add">+			&quot;frame=%p pc=%p sp=%p\n&quot;,</span>
<span class="p_add">+			task-&gt;comm, task_pid_nr(task), __func__,</span>
<span class="p_add">+			frame, (void *)regs-&gt;sepc, (void *)regs-&gt;sp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	force_sig(SIGSEGV, task);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static long setup_sigcontext(struct sigcontext __user *sc,</span>
<span class="p_add">+	struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_struct *task = current;</span>
<span class="p_add">+	long err;</span>
<span class="p_add">+	/* sc_regs is structured the same as the start of pt_regs */</span>
<span class="p_add">+	err = __copy_to_user(&amp;sc-&gt;sc_regs, regs, sizeof(sc-&gt;sc_regs));</span>
<span class="p_add">+	fstate_save(task, regs);</span>
<span class="p_add">+	err |= __copy_to_user(&amp;sc-&gt;sc_fpregs, &amp;task-&gt;thread.fstate,</span>
<span class="p_add">+		sizeof(sc-&gt;sc_fpregs));</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void __user *get_sigframe(struct ksignal *ksig,</span>
<span class="p_add">+	struct pt_regs *regs, size_t framesize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long sp;</span>
<span class="p_add">+	/* Default to using normal stack */</span>
<span class="p_add">+	sp = regs-&gt;sp;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we are on the alternate signal stack and would overflow it, don&#39;t.</span>
<span class="p_add">+	 * Return an always-bogus address instead so we will die with SIGSEGV.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (on_sig_stack(sp) &amp;&amp; !likely(on_sig_stack(sp - framesize)))</span>
<span class="p_add">+		return (void __user __force *)(-1UL);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* This is the X/Open sanctioned signal stack switching. */</span>
<span class="p_add">+	sp = sigsp(sp, ksig) - framesize;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Align the stack frame. */</span>
<span class="p_add">+	sp &amp;= ~0xfUL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (void __user *)sp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int setup_rt_frame(struct ksignal *ksig, sigset_t *set,</span>
<span class="p_add">+	struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rt_sigframe __user *frame;</span>
<span class="p_add">+	long err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	frame = get_sigframe(ksig, regs, sizeof(*frame));</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, frame, sizeof(*frame)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	err |= copy_siginfo_to_user(&amp;frame-&gt;info, &amp;ksig-&gt;info);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create the ucontext. */</span>
<span class="p_add">+	err |= __put_user(0, &amp;frame-&gt;uc.uc_flags);</span>
<span class="p_add">+	err |= __put_user(NULL, &amp;frame-&gt;uc.uc_link);</span>
<span class="p_add">+	err |= __save_altstack(&amp;frame-&gt;uc.uc_stack, regs-&gt;sp);</span>
<span class="p_add">+	err |= setup_sigcontext(&amp;frame-&gt;uc.uc_mcontext, regs);</span>
<span class="p_add">+	err |= __copy_to_user(&amp;frame-&gt;uc.uc_sigmask, set, sizeof(*set));</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up to return from userspace. */</span>
<span class="p_add">+	regs-&gt;ra = (unsigned long)VDSO_SYMBOL(</span>
<span class="p_add">+		current-&gt;mm-&gt;context.vdso, rt_sigreturn);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Set up registers for signal handler.</span>
<span class="p_add">+	 * Registers that we don&#39;t modify keep the value they had from</span>
<span class="p_add">+	 * user-space at the time we took the signal.</span>
<span class="p_add">+	 * We always pass siginfo and mcontext, regardless of SA_SIGINFO,</span>
<span class="p_add">+	 * since some things rely on this (e.g. glibc&#39;s debug/segfault.c).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	regs-&gt;sepc = (unsigned long)ksig-&gt;ka.sa.sa_handler;</span>
<span class="p_add">+	regs-&gt;sp = (unsigned long)frame;</span>
<span class="p_add">+	regs-&gt;a0 = ksig-&gt;sig;                     /* a0: signal number */</span>
<span class="p_add">+	regs-&gt;a1 = (unsigned long)(&amp;frame-&gt;info); /* a1: siginfo pointer */</span>
<span class="p_add">+	regs-&gt;a2 = (unsigned long)(&amp;frame-&gt;uc);   /* a2: ucontext pointer */</span>
<span class="p_add">+</span>
<span class="p_add">+#if DEBUG_SIG</span>
<span class="p_add">+	pr_info(&quot;SIG deliver (%s:%d): sig=%d pc=%p ra=%p sp=%p\n&quot;,</span>
<span class="p_add">+		current-&gt;comm, task_pid_nr(current), ksig-&gt;sig,</span>
<span class="p_add">+		(void *)regs-&gt;sepc, (void *)regs-&gt;ra, frame);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void handle_signal(struct ksignal *ksig, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sigset_t *oldset = sigmask_to_save();</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Are we from a system call? */</span>
<span class="p_add">+	if (regs-&gt;scause == EXC_SYSCALL) {</span>
<span class="p_add">+		/* If so, check system call restarting.. */</span>
<span class="p_add">+		switch (regs-&gt;a0) {</span>
<span class="p_add">+		case -ERESTART_RESTARTBLOCK:</span>
<span class="p_add">+		case -ERESTARTNOHAND:</span>
<span class="p_add">+			regs-&gt;a0 = -EINTR;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		case -ERESTARTSYS:</span>
<span class="p_add">+			if (!(ksig-&gt;ka.sa.sa_flags &amp; SA_RESTART)) {</span>
<span class="p_add">+				regs-&gt;a0 = -EINTR;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/* fallthrough */</span>
<span class="p_add">+		case -ERESTARTNOINTR:</span>
<span class="p_add">+			regs-&gt;sepc -= 0x4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up the stack frame */</span>
<span class="p_add">+	ret = setup_rt_frame(ksig, oldset, regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	signal_setup_done(ret, ksig, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void do_signal(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ksignal ksig;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_signal(&amp;ksig)) {</span>
<span class="p_add">+		/* Actually deliver the signal */</span>
<span class="p_add">+		handle_signal(&amp;ksig, regs);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Did we come from a system call? */</span>
<span class="p_add">+	if (regs-&gt;scause == EXC_SYSCALL) {</span>
<span class="p_add">+		/* Restart the system call - no handlers present */</span>
<span class="p_add">+		switch (regs-&gt;a0) {</span>
<span class="p_add">+		case -ERESTARTNOHAND:</span>
<span class="p_add">+		case -ERESTARTSYS:</span>
<span class="p_add">+		case -ERESTARTNOINTR:</span>
<span class="p_add">+			regs-&gt;sepc -= 0x4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case -ERESTART_RESTARTBLOCK:</span>
<span class="p_add">+			regs-&gt;a7 = __NR_restart_syscall;</span>
<span class="p_add">+			regs-&gt;sepc -= 0x4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If there is no signal to deliver, we just put the saved</span>
<span class="p_add">+	   sigmask back. */</span>
<span class="p_add">+	restore_saved_sigmask();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * notification of userspace execution resumption</span>
<span class="p_add">+ * - triggered by the _TIF_WORK_MASK flags</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void do_notify_resume(struct pt_regs *regs,</span>
<span class="p_add">+	unsigned long thread_info_flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Handle pending signal delivery */</span>
<span class="p_add">+	if (thread_info_flags &amp; _TIF_SIGPENDING) {</span>
<span class="p_add">+		do_signal(regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (thread_info_flags &amp; _TIF_NOTIFY_RESUME) {</span>
<span class="p_add">+		clear_thread_flag(TIF_NOTIFY_RESUME);</span>
<span class="p_add">+		tracehook_notify_resume(regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smp.c b/arch/riscv/kernel/smp.c</span>
new file mode 100644
<span class="p_header">index 000000000000..afa262c5bd40</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smp.c</span>
<span class="p_chunk">@@ -0,0 +1,107 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* A collection of single bit ipi messages.  */</span>
<span class="p_add">+static struct {</span>
<span class="p_add">+	unsigned long bits ____cacheline_aligned;</span>
<span class="p_add">+} ipi_data[NR_CPUS] __cacheline_aligned;</span>
<span class="p_add">+</span>
<span class="p_add">+enum ipi_message_type {</span>
<span class="p_add">+	IPI_RESCHEDULE,</span>
<span class="p_add">+	IPI_CALL_FUNC,</span>
<span class="p_add">+	IPI_MAX</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+irqreturn_t handle_ipi(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *pending_ipis = &amp;ipi_data[smp_processor_id()].bits;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear pending IPI */</span>
<span class="p_add">+	csr_clear(sip, SIE_SSIE);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (true) {</span>
<span class="p_add">+		unsigned long ops;</span>
<span class="p_add">+</span>
<span class="p_add">+		mb();	/* Order bit clearing and data access. */</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((ops = xchg(pending_ipis, 0)) == 0)</span>
<span class="p_add">+			return IRQ_HANDLED;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_RESCHEDULE))</span>
<span class="p_add">+			scheduler_ipi();</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ops &amp; (1 &lt;&lt; IPI_CALL_FUNC))</span>
<span class="p_add">+			generic_smp_call_function_interrupt();</span>
<span class="p_add">+</span>
<span class="p_add">+		BUG_ON((ops &gt;&gt; IPI_MAX) != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		mb();	/* Order data access and bit testing. */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void</span>
<span class="p_add">+send_ipi_message(const struct cpumask *to_whom, enum ipi_message_type operation)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	for_each_cpu(i, to_whom)</span>
<span class="p_add">+		set_bit(operation, &amp;ipi_data[i].bits);</span>
<span class="p_add">+</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	sbi_send_ipi(cpumask_bits(to_whom));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_ipi_mask(struct cpumask *mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(mask, IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void arch_send_call_function_single_ipi(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_CALL_FUNC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void ipi_stop(void *unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (1)</span>
<span class="p_add">+		wait_for_interrupt();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	on_each_cpu(ipi_stop, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void smp_send_reschedule(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	send_ipi_message(cpumask_of(cpu), IPI_RESCHEDULE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/smpboot.c b/arch/riscv/kernel/smpboot.c</span>
new file mode 100644
<span class="p_header">index 000000000000..1ef2da22fb23</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/smpboot.c</span>
<span class="p_chunk">@@ -0,0 +1,105 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * SMP initialisation and IPI support</span>
<span class="p_add">+ * Based on arch/arm64/kernel/smp.c</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Ltd.</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel_stat.h&gt;</span>
<span class="p_add">+#include &lt;linux/notifier.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/percpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void *__cpu_up_stack_pointer[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_boot_cpu(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_prepare_cpus(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init setup_smp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dn = NULL;</span>
<span class="p_add">+	int hart, im_okay_therefore_i_am = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while ((dn = of_find_node_by_type(dn, &quot;cpu&quot;))) {</span>
<span class="p_add">+		if ((hart = riscv_of_processor_hart(dn)) &gt;= 0) {</span>
<span class="p_add">+			set_cpu_possible(hart, true);</span>
<span class="p_add">+			set_cpu_present(hart, true);</span>
<span class="p_add">+			if (hart == smp_processor_id()) {</span>
<span class="p_add">+				BUG_ON(im_okay_therefore_i_am);</span>
<span class="p_add">+				im_okay_therefore_i_am = 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(!im_okay_therefore_i_am);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __cpu_up(unsigned int cpu, struct task_struct *tidle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Signal cpu to start */</span>
<span class="p_add">+	mb();</span>
<span class="p_add">+	__cpu_up_stack_pointer[cpu] = task_stack_page(tidle) + THREAD_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!cpu_online(cpu))</span>
<span class="p_add">+		cpu_relax();</span>
<span class="p_add">+	</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init smp_cpus_done(unsigned int max_cpus)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * C entry point for a secondary processor.</span>
<span class="p_add">+ */</span>
<span class="p_add">+asmlinkage void __init smp_callin(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = &amp;init_mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All kernel threads share the same mm context.  */</span>
<span class="p_add">+	atomic_inc(&amp;mm-&gt;mm_count);</span>
<span class="p_add">+	current-&gt;active_mm = mm;</span>
<span class="p_add">+</span>
<span class="p_add">+	trap_init();</span>
<span class="p_add">+	init_clockevent();</span>
<span class="p_add">+	notify_cpu_starting(smp_processor_id());</span>
<span class="p_add">+	set_cpu_online(smp_processor_id(), 1);</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+	preempt_disable();</span>
<span class="p_add">+	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/stacktrace.c b/arch/riscv/kernel/stacktrace.c</span>
new file mode 100644
<span class="p_header">index 000000000000..3633ce052a8b</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -0,0 +1,183 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2008 ARM Limited</span>
<span class="p_add">+ * Copyright (C) 2014 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/export.h&gt;</span>
<span class="p_add">+#include &lt;linux/kallsyms.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/stacktrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_FRAME_POINTER</span>
<span class="p_add">+</span>
<span class="p_add">+struct stackframe {</span>
<span class="p_add">+	unsigned long fp;</span>
<span class="p_add">+	unsigned long ra;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void notrace walk_stackframe(struct task_struct *task,</span>
<span class="p_add">+	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long fp, sp, pc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs) {</span>
<span class="p_add">+		fp = GET_FP(regs);</span>
<span class="p_add">+		sp = GET_USP(regs);</span>
<span class="p_add">+		pc = GET_IP(regs);</span>
<span class="p_add">+	} else if (task == NULL || task == current) {</span>
<span class="p_add">+		const register unsigned long current_sp __asm__ (&quot;sp&quot;);</span>
<span class="p_add">+		fp = (unsigned long)__builtin_frame_address(0);</span>
<span class="p_add">+		sp = current_sp;</span>
<span class="p_add">+		pc = (unsigned long)walk_stackframe;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* task blocked in __switch_to */</span>
<span class="p_add">+		fp = task-&gt;thread.s[0];</span>
<span class="p_add">+		sp = task-&gt;thread.sp;</span>
<span class="p_add">+		pc = task-&gt;thread.ra;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		unsigned long low, high;</span>
<span class="p_add">+		struct stackframe *frame;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (unlikely(!__kernel_text_address(pc) || fn(pc, arg)))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Validate frame pointer */</span>
<span class="p_add">+		low = sp + sizeof(struct stackframe);</span>
<span class="p_add">+		high = ALIGN(sp, THREAD_SIZE);</span>
<span class="p_add">+		if (unlikely(fp &lt; low || fp &gt; high || fp &amp; 0x7))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/* Unwind stack frame */</span>
<span class="p_add">+		frame = (struct stackframe *)fp - 1;</span>
<span class="p_add">+		sp = fp;</span>
<span class="p_add">+		fp = frame-&gt;fp;</span>
<span class="p_add">+		pc = frame-&gt;ra - 0x4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* !CONFIG_FRAME_POINTER */</span>
<span class="p_add">+</span>
<span class="p_add">+static void notrace walk_stackframe(struct task_struct *task,</span>
<span class="p_add">+	struct pt_regs *regs, bool (*fn)(unsigned long, void *), void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long sp, pc;</span>
<span class="p_add">+	unsigned long *ksp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regs) {</span>
<span class="p_add">+		sp = GET_USP(regs);</span>
<span class="p_add">+		pc = GET_IP(regs);</span>
<span class="p_add">+	} else if (task == NULL || task == current) {</span>
<span class="p_add">+		const register unsigned long current_sp __asm__ (&quot;sp&quot;);</span>
<span class="p_add">+		sp = current_sp;</span>
<span class="p_add">+		pc = (unsigned long)walk_stackframe;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* task blocked in __switch_to */</span>
<span class="p_add">+		sp = task-&gt;thread.sp;</span>
<span class="p_add">+		pc = task-&gt;thread.ra;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(sp &amp; 0x7))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ksp = (unsigned long *)sp;</span>
<span class="p_add">+	while (!kstack_end(ksp)) {</span>
<span class="p_add">+		if (__kernel_text_address(pc) &amp;&amp; unlikely(fn(pc, arg))) {</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pc = (*ksp++) - 0x4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_FRAME_POINTER */</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static bool print_trace_address(unsigned long pc, void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	print_ip_sym(pc);</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void show_stack(struct task_struct *task, unsigned long *sp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	printk(&quot;Call Trace:\n&quot;);</span>
<span class="p_add">+	walk_stackframe(task, NULL, print_trace_address, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static bool save_wchan(unsigned long pc, void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!in_sched_functions(pc)) {</span>
<span class="p_add">+		unsigned long *p = arg;</span>
<span class="p_add">+		*p = pc;</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long get_wchan(struct task_struct *task)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pc;</span>
<span class="p_add">+	pc = 0;</span>
<span class="p_add">+	if (likely(task &amp;&amp; task != current &amp;&amp; task-&gt;state != TASK_RUNNING)) {</span>
<span class="p_add">+		walk_stackframe(task, NULL, save_wchan, &amp;pc);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return pc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_STACKTRACE</span>
<span class="p_add">+</span>
<span class="p_add">+static bool __save_trace(unsigned long pc, void *arg, bool nosched)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct stack_trace *trace = arg;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(nosched &amp;&amp; in_sched_functions(pc)))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (unlikely(trace-&gt;skip &gt; 0)) {</span>
<span class="p_add">+		trace-&gt;skip--;</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	trace-&gt;entries[trace-&gt;nr_entries++] = pc;</span>
<span class="p_add">+	return (trace-&gt;nr_entries &gt;= trace-&gt;max_entries);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool save_trace(unsigned long pc, void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __save_trace(pc, arg, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save stack-backtrace addresses into a stack_trace buffer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	walk_stackframe(tsk, NULL, save_trace, trace);</span>
<span class="p_add">+	if (trace-&gt;nr_entries &lt; trace-&gt;max_entries)</span>
<span class="p_add">+		trace-&gt;entries[trace-&gt;nr_entries++] = ULONG_MAX;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(save_stack_trace_tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+void save_stack_trace(struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	save_stack_trace_tsk(NULL, trace);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(save_stack_trace);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_STACKTRACE */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/sys_riscv.c b/arch/riscv/kernel/sys_riscv.c</span>
new file mode 100644
<span class="p_header">index 000000000000..3e07308e24f5</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/sys_riscv.c</span>
<span class="p_chunk">@@ -0,0 +1,85 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2014 Darius Rad &lt;darius@bluespec.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+SYSCALL_DEFINE6(mmap, unsigned long, addr, unsigned long, len,</span>
<span class="p_add">+	unsigned long, prot, unsigned long, flags,</span>
<span class="p_add">+	unsigned long, fd, off_t, offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(offset &amp; (~PAGE_MASK)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	return sys_mmap_pgoff(addr, len, prot, flags, fd, offset &gt;&gt; PAGE_SHIFT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef CONFIG_64BIT</span>
<span class="p_add">+SYSCALL_DEFINE6(mmap2, unsigned long, addr, unsigned long, len,</span>
<span class="p_add">+	unsigned long, prot, unsigned long, flags,</span>
<span class="p_add">+	unsigned long, fd, off_t, offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Note that the shift for mmap2 is constant (12),</span>
<span class="p_add">+	   regardless of PAGE_SIZE */</span>
<span class="p_add">+	if (unlikely(offset &amp; (~PAGE_MASK &gt;&gt; 12)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	return sys_mmap_pgoff(addr, len, prot, flags, fd,</span>
<span class="p_add">+		offset &gt;&gt; (PAGE_SHIFT - 12));</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* !CONFIG_64BIT */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_RV_SYSRISCV_ATOMIC</span>
<span class="p_add">+SYSCALL_DEFINE4(sysriscv, unsigned long, cmd, unsigned long, arg1,</span>
<span class="p_add">+	unsigned long, arg2, unsigned long, arg3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	unsigned long prev;</span>
<span class="p_add">+	unsigned int *ptr;</span>
<span class="p_add">+	unsigned int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (cmd) {</span>
<span class="p_add">+	case RISCV_ATOMIC_CMPXCHG:</span>
<span class="p_add">+		ptr = (unsigned int *)arg1;</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, ptr, sizeof(unsigned int)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+		preempt_disable();</span>
<span class="p_add">+		raw_local_irq_save(flags);</span>
<span class="p_add">+		err = __get_user(prev, ptr);</span>
<span class="p_add">+		if (likely(!err &amp;&amp; prev == arg2))</span>
<span class="p_add">+			err = __put_user(arg3, ptr);</span>
<span class="p_add">+		raw_local_irq_restore(flags);</span>
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+		return unlikely(err) ? err : prev;</span>
<span class="p_add">+</span>
<span class="p_add">+	case RISCV_ATOMIC_CMPXCHG64:</span>
<span class="p_add">+		ptr = (unsigned int *)arg1;</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, ptr, sizeof(unsigned long)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+		preempt_disable();</span>
<span class="p_add">+		raw_local_irq_save(flags);</span>
<span class="p_add">+		err = __get_user(prev, ptr);</span>
<span class="p_add">+		if (likely(!err &amp;&amp; prev == arg2))</span>
<span class="p_add">+			err = __put_user(arg3, ptr);</span>
<span class="p_add">+		raw_local_irq_restore(flags);</span>
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+</span>
<span class="p_add">+		return unlikely(err) ? err : prev;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_RV_SYSRISCV_ATOMIC */</span>
<span class="p_header">diff --git a/arch/riscv/kernel/syscall_table.c b/arch/riscv/kernel/syscall_table.c</span>
new file mode 100644
<span class="p_header">index 000000000000..6b5505b1dbb5</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/syscall_table.c</span>
<span class="p_chunk">@@ -0,0 +1,26 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2009 Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/syscalls.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/syscalls.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#undef __SYSCALL</span>
<span class="p_add">+#define __SYSCALL(nr, call) [nr] = (call),</span>
<span class="p_add">+</span>
<span class="p_add">+void *sys_call_table[__NR_syscalls] = {</span>
<span class="p_add">+	[0 ... __NR_syscalls - 1] = sys_ni_syscall,</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/arch/riscv/kernel/time.c b/arch/riscv/kernel/time.c</span>
new file mode 100644
<span class="p_header">index 000000000000..ce8c459fadaa</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/time.c</span>
<span class="p_chunk">@@ -0,0 +1,116 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/clocksource.h&gt;</span>
<span class="p_add">+#include &lt;linux/clockchips.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/irq.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+#include &lt;asm/sbi.h&gt;</span>
<span class="p_add">+#include &lt;asm/delay.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long timebase;</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_PER_CPU(struct clock_event_device, clock_event);</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_timer_set_next_event(unsigned long delta,</span>
<span class="p_add">+	struct clock_event_device *evdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sbi_set_timer(get_cycles() + delta);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_timer_set_oneshot(struct clock_event_device *evt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* no-op; only one mode */</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int riscv_timer_set_shutdown(struct clock_event_device *evt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* can&#39;t stop the clock! */</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u64 riscv_rdtime(struct clocksource *cs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return get_cycles();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct clocksource riscv_clocksource = {</span>
<span class="p_add">+	.name = &quot;riscv_clocksource&quot;,</span>
<span class="p_add">+	.rating = 300,</span>
<span class="p_add">+	.read = riscv_rdtime,</span>
<span class="p_add">+#ifdef CONFIG_64BITS</span>
<span class="p_add">+	.mask = CLOCKSOURCE_MASK(64),</span>
<span class="p_add">+#else</span>
<span class="p_add">+	.mask = CLOCKSOURCE_MASK(32),</span>
<span class="p_add">+#endif /* CONFIG_64BITS */</span>
<span class="p_add">+	.flags = CLOCK_SOURCE_IS_CONTINUOUS,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void riscv_timer_interrupt(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
<span class="p_add">+	struct clock_event_device *evdev = &amp;per_cpu(clock_event, cpu);</span>
<span class="p_add">+	evdev-&gt;event_handler(evdev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init init_clockevent(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
<span class="p_add">+	struct clock_event_device *ce = &amp;per_cpu(clock_event, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	*ce = (struct clock_event_device){</span>
<span class="p_add">+		.name = &quot;riscv_timer_clockevent&quot;,</span>
<span class="p_add">+		.features = CLOCK_EVT_FEAT_ONESHOT,</span>
<span class="p_add">+		.rating = 300,</span>
<span class="p_add">+		.cpumask = cpumask_of(cpu),</span>
<span class="p_add">+		.set_next_event = riscv_timer_set_next_event,</span>
<span class="p_add">+		.set_state_oneshot  = riscv_timer_set_oneshot,</span>
<span class="p_add">+		.set_state_shutdown = riscv_timer_set_shutdown,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable timer interrupts */</span>
<span class="p_add">+	csr_set(sie, SIE_STIE);</span>
<span class="p_add">+</span>
<span class="p_add">+	clockevents_config_and_register(ce, timebase, 100, 0x7fffffff);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long __init of_timebase(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *cpu;</span>
<span class="p_add">+	const __be32 *prop;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((cpu = of_find_node_by_path(&quot;/cpus&quot;)) &amp;&amp;</span>
<span class="p_add">+	    (prop = of_get_property(cpu, &quot;timebase-frequency&quot;, NULL))) {</span>
<span class="p_add">+		return be32_to_cpu(*prop);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return 10000000;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init time_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	timebase = of_timebase();</span>
<span class="p_add">+	lpj_fine = timebase / HZ;</span>
<span class="p_add">+</span>
<span class="p_add">+	clocksource_register_hz(&amp;riscv_clocksource, timebase);</span>
<span class="p_add">+	init_clockevent();</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/traps.c b/arch/riscv/kernel/traps.c</span>
new file mode 100644
<span class="p_header">index 000000000000..cbdabfbbc09f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/traps.c</span>
<span class="p_chunk">@@ -0,0 +1,167 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/signal.h&gt;</span>
<span class="p_add">+#include &lt;linux/kdebug.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/csr.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+int show_unhandled_signals = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+extern asmlinkage void handle_exception(void);</span>
<span class="p_add">+</span>
<span class="p_add">+static DEFINE_SPINLOCK(die_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+void die(struct pt_regs *regs, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int die_counter;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	oops_enter();</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;die_lock);</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+	bust_spinlocks(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;%s [#%d]\n&quot;, str, ++die_counter);</span>
<span class="p_add">+	print_modules();</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = notify_die(DIE_OOPS, str, regs, 0, regs-&gt;scause, SIGSEGV);</span>
<span class="p_add">+</span>
<span class="p_add">+	bust_spinlocks(0);</span>
<span class="p_add">+	add_taint(TAINT_DIE, LOCKDEP_NOW_UNRELIABLE);</span>
<span class="p_add">+	spin_unlock_irq(&amp;die_lock);</span>
<span class="p_add">+	oops_exit();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (in_interrupt())</span>
<span class="p_add">+		panic(&quot;Fatal exception in interrupt&quot;);</span>
<span class="p_add">+	if (panic_on_oops)</span>
<span class="p_add">+		panic(&quot;Fatal exception&quot;);</span>
<span class="p_add">+	if (ret != NOTIFY_STOP)</span>
<span class="p_add">+		do_exit(SIGSEGV);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void do_trap_siginfo(int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	info.si_signo = signo;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = code;</span>
<span class="p_add">+	info.si_addr = (void __user *)addr;</span>
<span class="p_add">+	force_sig_info(signo, &amp;info, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_trap(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (show_unhandled_signals &amp;&amp; unhandled_signal(tsk, signo)</span>
<span class="p_add">+	    &amp;&amp; printk_ratelimit()) {</span>
<span class="p_add">+		pr_info(&quot;%s[%d]: unhandled signal %d code 0x%x at 0x&quot; REG_FMT,</span>
<span class="p_add">+			tsk-&gt;comm, task_pid_nr(tsk), signo, code, addr);</span>
<span class="p_add">+		print_vma_addr(KERN_CONT &quot; in &quot;, GET_IP(regs));</span>
<span class="p_add">+		pr_cont(&quot;\n&quot;);</span>
<span class="p_add">+		show_regs(regs);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(signo, code, addr, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void do_trap_error(struct pt_regs *regs, int signo, int code,</span>
<span class="p_add">+	unsigned long addr, const char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		do_trap(regs, signo, code, addr, current);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!fixup_exception(regs))</span>
<span class="p_add">+			die(regs, str);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define DO_ERROR_INFO(name, signo, code, str)				\</span>
<span class="p_add">+asmlinkage void name(struct pt_regs *regs)				\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	do_trap_error(regs, signo, code, regs-&gt;sepc, &quot;Oops - &quot; str);	\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_unknown,</span>
<span class="p_add">+	SIGILL, ILL_ILLTRP, &quot;unknown exception&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_amo_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;AMO address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_misaligned,</span>
<span class="p_add">+	SIGBUS, BUS_ADRALN, &quot;instruction address misaligned&quot;);</span>
<span class="p_add">+DO_ERROR_INFO(do_trap_insn_illegal,</span>
<span class="p_add">+	SIGILL, ILL_ILLOPC, &quot;illegal instruction&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void do_trap_break(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+	if (!user_mode(regs)) {</span>
<span class="p_add">+		enum bug_trap_type type;</span>
<span class="p_add">+</span>
<span class="p_add">+		type = report_bug(regs-&gt;sepc, regs);</span>
<span class="p_add">+		switch (type) {</span>
<span class="p_add">+		case BUG_TRAP_TYPE_NONE:</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_WARN:</span>
<span class="p_add">+			regs-&gt;sepc += sizeof(bug_insn_t);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		case BUG_TRAP_TYPE_BUG:</span>
<span class="p_add">+			die(regs, &quot;Kernel BUG&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+	do_trap_siginfo(SIGTRAP, TRAP_BRKPT, regs-&gt;sepc, current);</span>
<span class="p_add">+	regs-&gt;sepc += 0x4;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_GENERIC_BUG</span>
<span class="p_add">+int is_valid_bugaddr(unsigned long pc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bug_insn_t insn;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pc &lt; PAGE_OFFSET)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	if (probe_kernel_address((bug_insn_t __user *)pc, insn))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	return (insn == __BUG_INSN);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_GENERIC_BUG */</span>
<span class="p_add">+</span>
<span class="p_add">+void __init trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int hart = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set sup0 scratch register to 0, indicating to exception vector</span>
<span class="p_add">+	   that we are presently executing in the kernel */</span>
<span class="p_add">+	csr_write(sscratch, 0);</span>
<span class="p_add">+	/* Set the exception vector address */</span>
<span class="p_add">+	csr_write(stvec, &amp;handle_exception);</span>
<span class="p_add">+	/* Enable software interrupts and setup initial mask */</span>
<span class="p_add">+	csr_write(sie, SIE_SSIE | atomic_long_read(&amp;per_cpu(riscv_early_sie, hart)));</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso.c b/arch/riscv/kernel/vdso.c</span>
new file mode 100644
<span class="p_header">index 000000000000..a4007ec0cb53</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso.c</span>
<span class="p_chunk">@@ -0,0 +1,125 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2004 Benjamin Herrenschmidt, IBM Corp.</span>
<span class="p_add">+ *                    &lt;benh@kernel.crashing.org&gt;</span>
<span class="p_add">+ * Copyright (C) 2012 ARM Limited</span>
<span class="p_add">+ * Copyright (C) 2015 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/binfmts.h&gt;</span>
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/vdso.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern char vdso_start[], vdso_end[];</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned int vdso_pages;</span>
<span class="p_add">+static struct page **vdso_pagelist;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The vDSO data page.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static union {</span>
<span class="p_add">+	struct vdso_data	data;</span>
<span class="p_add">+	u8			page[PAGE_SIZE];</span>
<span class="p_add">+} vdso_data_store __page_aligned_data;</span>
<span class="p_add">+struct vdso_data *vdso_data = &amp;vdso_data_store.data;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init vdso_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_pages = (vdso_end - vdso_start) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	vdso_pagelist = kzalloc(sizeof(struct page *) * (vdso_pages + 1), GFP_KERNEL);</span>
<span class="p_add">+	if (unlikely(vdso_pagelist == NULL)) {</span>
<span class="p_add">+		pr_err(&quot;vdso: pagelist allocation failed\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; vdso_pages; i++) {</span>
<span class="p_add">+		struct page *pg;</span>
<span class="p_add">+		pg = virt_to_page(vdso_start + (i &lt;&lt; PAGE_SHIFT));</span>
<span class="p_add">+		ClearPageReserved(pg);</span>
<span class="p_add">+		vdso_pagelist[i] = pg;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	vdso_pagelist[i] = virt_to_page(vdso_data);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+arch_initcall(vdso_init);</span>
<span class="p_add">+</span>
<span class="p_add">+int arch_setup_additional_pages(struct linux_binprm *bprm,</span>
<span class="p_add">+	int uses_interp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mm_struct *mm = current-&gt;mm;</span>
<span class="p_add">+	unsigned long vdso_base, vdso_len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	vdso_len = (vdso_pages + 1) &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	vdso_base = get_unmapped_area(NULL, 0, vdso_len, 0, 0);</span>
<span class="p_add">+	if (unlikely(IS_ERR_VALUE(vdso_base))) {</span>
<span class="p_add">+		ret = vdso_base;</span>
<span class="p_add">+		goto end;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Put vDSO base into mm struct. We need to do this before calling</span>
<span class="p_add">+	 * install_special_mapping or the perf counter mmap tracking code</span>
<span class="p_add">+	 * will fail to recognise it as a vDSO (since arch_vma_name fails).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mm-&gt;context.vdso = (void *)vdso_base;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = install_special_mapping(mm, vdso_base, vdso_len,</span>
<span class="p_add">+		(VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC),</span>
<span class="p_add">+		vdso_pagelist);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(ret)) {</span>
<span class="p_add">+		mm-&gt;context.vdso = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+end:</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+const char *arch_vma_name(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (vma-&gt;vm_mm &amp;&amp; (vma-&gt;vm_start == (long)vma-&gt;vm_mm-&gt;context.vdso)) {</span>
<span class="p_add">+		return &quot;[vdso]&quot;;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Function stubs to prevent linker errors when AT_SYSINFO_EHDR is defined</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area_no_mm(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int in_gate_area(struct mm_struct *mm, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct vm_area_struct *get_gate_vma(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/.gitignore b/arch/riscv/kernel/vdso/.gitignore</span>
new file mode 100644
<span class="p_header">index 000000000000..f8b69d84238e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/.gitignore</span>
<span class="p_chunk">@@ -0,0 +1 @@</span> <span class="p_context"></span>
<span class="p_add">+vdso.lds</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/Makefile b/arch/riscv/kernel/vdso/Makefile</span>
new file mode 100644
<span class="p_header">index 000000000000..04f3ec75b217</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -0,0 +1,61 @@</span> <span class="p_context"></span>
<span class="p_add">+# Derived from arch/{arm64,tile}/kernel/vdso/Makefile</span>
<span class="p_add">+</span>
<span class="p_add">+obj-vdso := sigreturn.o</span>
<span class="p_add">+</span>
<span class="p_add">+# Build rules</span>
<span class="p_add">+targets := $(obj-vdso) vdso.so vdso.so.dbg</span>
<span class="p_add">+obj-vdso := $(addprefix $(obj)/, $(obj-vdso))</span>
<span class="p_add">+</span>
<span class="p_add">+#ccflags-y := -shared -fno-common -fno-builtin</span>
<span class="p_add">+#ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \</span>
<span class="p_add">+		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)</span>
<span class="p_add">+</span>
<span class="p_add">+CFLAGS_vdso.so = $(c_flags)</span>
<span class="p_add">+CFLAGS_vdso.so.dbg = -shared -s -Wl,-soname=linux-vdso.so.1 \</span>
<span class="p_add">+	$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)</span>
<span class="p_add">+CFLAGS_vdso_syms.o = -r</span>
<span class="p_add">+</span>
<span class="p_add">+obj-y += vdso.o</span>
<span class="p_add">+</span>
<span class="p_add">+# We also create a special relocatable object that should mirror the symbol</span>
<span class="p_add">+# table and layout of the linked DSO.  With ld -R we can then refer to</span>
<span class="p_add">+# these symbols in the kernel code rather than hand-coded addresses.</span>
<span class="p_add">+extra-y += vdso.lds vdso-syms.o</span>
<span class="p_add">+$(obj)/built-in.o: $(obj)/vdso-syms.o</span>
<span class="p_add">+$(obj)/built-in.o: ld_flags += -R $(obj)/vdso-syms.o</span>
<span class="p_add">+</span>
<span class="p_add">+CPPFLAGS_vdso.lds += -P -C -U$(ARCH)</span>
<span class="p_add">+</span>
<span class="p_add">+# Force dependency</span>
<span class="p_add">+$(obj)/vdso.o : $(obj)/vdso.so</span>
<span class="p_add">+</span>
<span class="p_add">+# Link rule for the *.so file; *.lds must be first</span>
<span class="p_add">+$(obj)/vdso.so.dbg: $(src)/vdso.lds $(obj-vdso)</span>
<span class="p_add">+	$(call if_changed,vdsold)</span>
<span class="p_add">+$(obj)/vdso-syms.o: $(src)/vdso.lds $(obj-vdso)</span>
<span class="p_add">+	$(call if_changed,vdsold)</span>
<span class="p_add">+</span>
<span class="p_add">+# Strip rule for the *.so file</span>
<span class="p_add">+$(obj)/%.so: OBJCOPYFLAGS := -S</span>
<span class="p_add">+$(obj)/%.so: $(obj)/%.so.dbg FORCE</span>
<span class="p_add">+	$(call if_changed,objcopy)</span>
<span class="p_add">+</span>
<span class="p_add">+# Assembly rules for the *.S files</span>
<span class="p_add">+$(obj-vdso): %.o: %.S</span>
<span class="p_add">+	$(call if_changed_dep,vdsoas)</span>
<span class="p_add">+</span>
<span class="p_add">+# Actual build commands</span>
<span class="p_add">+quiet_cmd_vdsold = VDSOLD  $@</span>
<span class="p_add">+      cmd_vdsold = $(CC) $(c_flags) -nostdlib $(CFLAGS_$(@F)) -Wl,-n -Wl,-T $^ -o $@</span>
<span class="p_add">+quiet_cmd_vdsoas = VDSOAS  $@</span>
<span class="p_add">+      cmd_vdsoas = $(CC) $(a_flags) -c -o $@ $&lt;</span>
<span class="p_add">+</span>
<span class="p_add">+# Install commands for the unstripped file</span>
<span class="p_add">+quiet_cmd_vdso_install = INSTALL $@</span>
<span class="p_add">+      cmd_vdso_install = cp $(obj)/$@.dbg $(MODLIB)/vdso/$@</span>
<span class="p_add">+</span>
<span class="p_add">+vdso.so: $(obj)/vdso.so.dbg</span>
<span class="p_add">+	@mkdir -p $(MODLIB)/vdso</span>
<span class="p_add">+	$(call cmd,vdso_install)</span>
<span class="p_add">+</span>
<span class="p_add">+vdso_install: vdso.so</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/sigreturn.S b/arch/riscv/kernel/vdso/sigreturn.S</span>
new file mode 100644
<span class="p_header">index 000000000000..d5d33dbb5976</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/sigreturn.S</span>
<span class="p_chunk">@@ -0,0 +1,25 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+ENTRY(__vdso_rt_sigreturn)</span>
<span class="p_add">+	.cfi_startproc</span>
<span class="p_add">+	.cfi_signal_frame</span>
<span class="p_add">+	li a7, __NR_rt_sigreturn</span>
<span class="p_add">+	scall</span>
<span class="p_add">+	.cfi_endproc</span>
<span class="p_add">+ENDPROC(__vdso_rt_sigreturn)</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/vdso.S b/arch/riscv/kernel/vdso/vdso.S</span>
new file mode 100644
<span class="p_header">index 000000000000..e2edb3529286</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/vdso.S</span>
<span class="p_chunk">@@ -0,0 +1,28 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2014 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+	__PAGE_ALIGNED_DATA</span>
<span class="p_add">+</span>
<span class="p_add">+	.globl vdso_start, vdso_end</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+vdso_start:</span>
<span class="p_add">+	.incbin &quot;arch/riscv/kernel/vdso/vdso.so&quot;</span>
<span class="p_add">+	.balign PAGE_SIZE</span>
<span class="p_add">+vdso_end:</span>
<span class="p_add">+</span>
<span class="p_add">+	.previous</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vdso/vdso.lds.S b/arch/riscv/kernel/vdso/vdso.lds.S</span>
new file mode 100644
<span class="p_header">index 000000000000..4c3d72306ad8</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vdso/vdso.lds.S</span>
<span class="p_chunk">@@ -0,0 +1,77 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+OUTPUT_ARCH(riscv)</span>
<span class="p_add">+</span>
<span class="p_add">+SECTIONS</span>
<span class="p_add">+{</span>
<span class="p_add">+	. = SIZEOF_HEADERS;</span>
<span class="p_add">+</span>
<span class="p_add">+	.hash		: { *(.hash) }			:text</span>
<span class="p_add">+	.gnu.hash	: { *(.gnu.hash) }</span>
<span class="p_add">+	.dynsym		: { *(.dynsym) }</span>
<span class="p_add">+	.dynstr		: { *(.dynstr) }</span>
<span class="p_add">+	.gnu.version	: { *(.gnu.version) }</span>
<span class="p_add">+	.gnu.version_d	: { *(.gnu.version_d) }</span>
<span class="p_add">+	.gnu.version_r	: { *(.gnu.version_r) }</span>
<span class="p_add">+</span>
<span class="p_add">+	.note		: { *(.note.*) }		:text	:note</span>
<span class="p_add">+	.dynamic	: { *(.dynamic) }		:text	:dynamic</span>
<span class="p_add">+</span>
<span class="p_add">+	.eh_frame_hdr	: { *(.eh_frame_hdr) }		:text	:eh_frame_hdr</span>
<span class="p_add">+	.eh_frame	: { KEEP (*(.eh_frame)) }	:text</span>
<span class="p_add">+</span>
<span class="p_add">+	.rodata		: { *(.rodata .rodata.* .gnu.linkonce.r.*) }</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This linker script is used both with -r and with -shared.</span>
<span class="p_add">+	 * For the layouts to match, we need to skip more than enough</span>
<span class="p_add">+	 * space for the dynamic symbol table, etc. If this amount is</span>
<span class="p_add">+	 * insufficient, ld -shared will error; simply increase it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	. = 0x800;</span>
<span class="p_add">+	.text		: { *(.text .text.*) }		:text</span>
<span class="p_add">+</span>
<span class="p_add">+	.data		: {</span>
<span class="p_add">+		*(.got.plt) *(.got)</span>
<span class="p_add">+		*(.data .data.* .gnu.linkonce.d.*)</span>
<span class="p_add">+		*(.dynbss)</span>
<span class="p_add">+		*(.bss .bss.* .gnu.linkonce.b.*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We must supply the ELF program headers explicitly to get just one</span>
<span class="p_add">+ * PT_LOAD segment, and set the flags explicitly to make segments read-only.</span>
<span class="p_add">+ */</span>
<span class="p_add">+PHDRS</span>
<span class="p_add">+{</span>
<span class="p_add">+	text		PT_LOAD		FLAGS(5) FILEHDR PHDRS; /* PF_R|PF_X */</span>
<span class="p_add">+	dynamic		PT_DYNAMIC	FLAGS(4);		/* PF_R */</span>
<span class="p_add">+	note		PT_NOTE		FLAGS(4);		/* PF_R */</span>
<span class="p_add">+	eh_frame_hdr	PT_GNU_EH_FRAME;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This controls what symbols we export from the DSO.</span>
<span class="p_add">+ */</span>
<span class="p_add">+VERSION</span>
<span class="p_add">+{</span>
<span class="p_add">+	LINUX_2.6 {</span>
<span class="p_add">+	global:</span>
<span class="p_add">+		__vdso_rt_sigreturn;</span>
<span class="p_add">+	local: *;</span>
<span class="p_add">+	};</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/riscv/kernel/vmlinux.lds.S b/arch/riscv/kernel/vmlinux.lds.S</span>
new file mode 100644
<span class="p_header">index 000000000000..5e13c9103024</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/riscv/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -0,0 +1,93 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012 Regents of the University of California</span>
<span class="p_add">+ * Copyright (C) 2017 SiFive</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ *   modify it under the terms of the GNU General Public License</span>
<span class="p_add">+ *   as published by the Free Software Foundation, version 2.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   This program is distributed in the hope that it will be useful, but</span>
<span class="p_add">+ *   WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ *   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or</span>
<span class="p_add">+ *   NON INFRINGEMENT.  See the GNU General Public License for</span>
<span class="p_add">+ *   more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define LOAD_OFFSET PAGE_OFFSET</span>
<span class="p_add">+#include &lt;asm/vmlinux.lds.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+#include &lt;asm/cache.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+OUTPUT_ARCH(riscv)</span>
<span class="p_add">+ENTRY(_start)</span>
<span class="p_add">+</span>
<span class="p_add">+jiffies = jiffies_64;</span>
<span class="p_add">+</span>
<span class="p_add">+SECTIONS</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Beginning of code and text segment */</span>
<span class="p_add">+	. = LOAD_OFFSET;</span>
<span class="p_add">+	_start = .;</span>
<span class="p_add">+	__init_begin = .;</span>
<span class="p_add">+	HEAD_TEXT_SECTION</span>
<span class="p_add">+	INIT_TEXT_SECTION(PAGE_SIZE)</span>
<span class="p_add">+	INIT_DATA_SECTION(16)</span>
<span class="p_add">+	/* we have to discard exit text and such at runtime, not link time */</span>
<span class="p_add">+	.exit.text :</span>
<span class="p_add">+	{</span>
<span class="p_add">+		EXIT_TEXT</span>
<span class="p_add">+	}</span>
<span class="p_add">+	.exit.data :</span>
<span class="p_add">+	{</span>
<span class="p_add">+		EXIT_DATA</span>
<span class="p_add">+	}</span>
<span class="p_add">+	PERCPU_SECTION(L1_CACHE_BYTES)</span>
<span class="p_add">+	__init_end = .;</span>
<span class="p_add">+</span>
<span class="p_add">+	.text : {</span>
<span class="p_add">+		_text = .;</span>
<span class="p_add">+		_stext = .;</span>
<span class="p_add">+		TEXT_TEXT</span>
<span class="p_add">+		SCHED_TEXT</span>
<span class="p_add">+		CPUIDLE_TEXT</span>
<span class="p_add">+		LOCK_TEXT</span>
<span class="p_add">+		KPROBES_TEXT</span>
<span class="p_add">+		ENTRY_TEXT</span>
<span class="p_add">+		IRQENTRY_TEXT</span>
<span class="p_add">+		*(.fixup)</span>
<span class="p_add">+		_etext = .;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start of data section */</span>
<span class="p_add">+	_sdata = .;</span>
<span class="p_add">+	RO_DATA_SECTION(L1_CACHE_BYTES)</span>
<span class="p_add">+	.srodata : {</span>
<span class="p_add">+		*(.srodata*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	RW_DATA_SECTION(L1_CACHE_BYTES, PAGE_SIZE, THREAD_SIZE)</span>
<span class="p_add">+	.sdata : {</span>
<span class="p_add">+		__global_pointer$ = . + 0x800;</span>
<span class="p_add">+		*(.sdata*)</span>
<span class="p_add">+		/* End of data section */</span>
<span class="p_add">+		_edata = .;</span>
<span class="p_add">+		*(.sbss*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	BSS_SECTION(0, 0, 0)</span>
<span class="p_add">+</span>
<span class="p_add">+	EXCEPTION_TABLE(0x10)</span>
<span class="p_add">+	NOTES</span>
<span class="p_add">+</span>
<span class="p_add">+	.rel.dyn : {</span>
<span class="p_add">+		*(.rel.dyn*)</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	_end = .;</span>
<span class="p_add">+</span>
<span class="p_add">+	STABS_DEBUG</span>
<span class="p_add">+	DWARF_DEBUG</span>
<span class="p_add">+</span>
<span class="p_add">+	DISCARDS</span>
<span class="p_add">+}</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



