
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2,5/6] remoteproc/MIPS: Add a remoteproc driver for MIPS - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2,5/6] remoteproc/MIPS: Add a remoteproc driver for MIPS</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 20, 2016, 8:47 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1474361249-31064-6-git-send-email-matt.redfearn@imgtec.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9341251/mbox/"
   >mbox</a>
|
   <a href="/patch/9341251/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9341251/">/patch/9341251/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	97F906077A for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Sep 2016 08:48:19 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8829A29D4B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Sep 2016 08:48:19 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7BF4C29D50; Tue, 20 Sep 2016 08:48:19 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 132E529D4B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 20 Sep 2016 08:48:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753042AbcITIsB (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 20 Sep 2016 04:48:01 -0400
Received: from mailapp01.imgtec.com ([195.59.15.196]:55149 &quot;EHLO
	mailapp01.imgtec.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753805AbcITIrx (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 20 Sep 2016 04:47:53 -0400
Received: from HHMAIL01.hh.imgtec.org (unknown [10.100.10.19])
	by Forcepoint Email with ESMTPS id 9A48831388F8;
	Tue, 20 Sep 2016 09:47:37 +0100 (IST)
Received: from mredfearn-linux.le.imgtec.org (10.150.130.83) by
	HHMAIL01.hh.imgtec.org (10.100.10.21) with Microsoft SMTP Server
	(TLS) id 14.3.294.0; Tue, 20 Sep 2016 09:47:39 +0100
From: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
To: Ralf Baechle &lt;ralf@linux-mips.org&gt;,
	Bjorn Andersson &lt;bjorn.andersson@linaro.org&gt;,
	Ohad Ben-Cohen &lt;ohad@wizery.com&gt;, Thomas Gleixner &lt;tglx@linutronix.de&gt;
CC: &lt;linux-mips@linux-mips.org&gt;, &lt;linux-remoteproc@vger.kernel.org&gt;,
	&lt;lisa.parratt@imgtec.com&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
Subject: [PATCH v2 5/6] remoteproc/MIPS: Add a remoteproc driver for MIPS
Date: Tue, 20 Sep 2016 09:47:28 +0100
Message-ID: &lt;1474361249-31064-6-git-send-email-matt.redfearn@imgtec.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1474361249-31064-1-git-send-email-matt.redfearn@imgtec.com&gt;
References: &lt;1474361249-31064-1-git-send-email-matt.redfearn@imgtec.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [10.150.130.83]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Sept. 20, 2016, 8:47 a.m.</div>
<pre class="content">
Add a remoteproc driver to steal, load the firmware, and boot an offline
MIPS core, turning it into a coprocessor.

This driver provides a sysfs to allow arbitrary firmware to be loaded
onto a core, which may expose virtio devices. Coprocessor firmware must
abide by the UHI coprocessor boot protocol.
<span class="signed-off-by">
Signed-off-by: Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>

---

Changes in v2: None

 Documentation/ABI/testing/sysfs-class-mips-rproc |  24 +
 drivers/remoteproc/Kconfig                       |  11 +
 drivers/remoteproc/Makefile                      |   1 +
 drivers/remoteproc/mips_remoteproc.c             | 651 +++++++++++++++++++++++
 4 files changed, 687 insertions(+)
 create mode 100644 Documentation/ABI/testing/sysfs-class-mips-rproc
 create mode 100644 drivers/remoteproc/mips_remoteproc.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Sept. 20, 2016, 9:47 a.m.</div>
<pre class="content">
On Tue, 20 Sep 2016, Matt Redfearn wrote:
<span class="quote">&gt; +/* Intercept CPU hotplug events for syfs purposes */</span>
<span class="quote">&gt; +static int mips_rproc_callback(struct notifier_block *nfb, unsigned long action,</span>
<span class="quote">&gt; +			       void *hcpu)</span>
<span class="quote">&gt; +{</span>

Please convert to cpu hotplug state machine.
<span class="quote">
&gt; +	unsigned int cpu = (unsigned long)hcpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	switch (action) {</span>
<span class="quote">&gt; +	case CPU_UP_PREPARE:</span>
<span class="quote">&gt; +	case CPU_DOWN_FAILED:</span>
<span class="quote">&gt; +		mips_rproc_device_unregister(cpu);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case CPU_DOWN_PREPARE:</span>
<span class="quote">&gt; +		mips_rproc_device_register(cpu);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	}</span>

There is no reason why you need to setup the rproc device on
DOWN_PREPARE. It&#39;s sufficient to do that when the CPU is dead, so you can
use a symetric callback prep/dead.
<span class="quote">
&gt; +	/* Dynamically create mips-rproc class devices based on hotplug data */</span>
<span class="quote">&gt; +	get_online_cpus();</span>
<span class="quote">&gt; +	for_each_possible_cpu(cpu)</span>
<span class="quote">&gt; +		if (!cpu_online(cpu))</span>
<span class="quote">&gt; +			mips_rproc_device_register(cpu);</span>
<span class="quote">&gt; +	register_hotcpu_notifier(&amp;mips_rproc_notifier);</span>
<span class="quote">&gt; +	put_online_cpus();</span>

Perhaps we should add support for &quot;reverse&quot; functionality to the state
machine core. I&#39;ll have a look later how hard that&#39;d be.

Thanks,

	tglx
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Sept. 20, 2016, 3:31 p.m.</div>
<pre class="content">
Hi Thomas,


On 20/09/16 10:47, Thomas Gleixner wrote:
<span class="quote">&gt; On Tue, 20 Sep 2016, Matt Redfearn wrote:</span>
<span class="quote">&gt;&gt; +/* Intercept CPU hotplug events for syfs purposes */</span>
<span class="quote">&gt;&gt; +static int mips_rproc_callback(struct notifier_block *nfb, unsigned long action,</span>
<span class="quote">&gt;&gt; +			       void *hcpu)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt; Please convert to cpu hotplug state machine.</span>

OK, I&#39;ve done that for this and the MIPS GIC patch, using the dynamic 
CPUHP_AP_ONLINE_DYN state - I hope that is ok.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	unsigned int cpu = (unsigned long)hcpu;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	switch (action) {</span>
<span class="quote">&gt;&gt; +	case CPU_UP_PREPARE:</span>
<span class="quote">&gt;&gt; +	case CPU_DOWN_FAILED:</span>
<span class="quote">&gt;&gt; +		mips_rproc_device_unregister(cpu);</span>
<span class="quote">&gt;&gt; +		break;</span>
<span class="quote">&gt;&gt; +	case CPU_DOWN_PREPARE:</span>
<span class="quote">&gt;&gt; +		mips_rproc_device_register(cpu);</span>
<span class="quote">&gt;&gt; +		break;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt; There is no reason why you need to setup the rproc device on</span>
<span class="quote">&gt; DOWN_PREPARE. It&#39;s sufficient to do that when the CPU is dead, so you can</span>
<span class="quote">&gt; use a symetric callback prep/dead.</span>

Sure, the new state machine makes this much nicer registering the 
on/offline callbacks on one state.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	/* Dynamically create mips-rproc class devices based on hotplug data */</span>
<span class="quote">&gt;&gt; +	get_online_cpus();</span>
<span class="quote">&gt;&gt; +	for_each_possible_cpu(cpu)</span>
<span class="quote">&gt;&gt; +		if (!cpu_online(cpu))</span>
<span class="quote">&gt;&gt; +			mips_rproc_device_register(cpu);</span>
<span class="quote">&gt;&gt; +	register_hotcpu_notifier(&amp;mips_rproc_notifier);</span>
<span class="quote">&gt;&gt; +	put_online_cpus();</span>
<span class="quote">&gt; Perhaps we should add support for &quot;reverse&quot; functionality to the state</span>
<span class="quote">&gt; machine core. I&#39;ll have a look later how hard that&#39;d be.</span>

Yeah - I&#39;ve had to work around the framework a little here since we 
require the opposite sense to the callbacks - activate the driver when 
the cpu is offlined and vice versa. In practice the only issue this gave 
me was that by default the framework invokes the teardown callback when 
the state is removed, so I used __cpuhp_remove_state() to avoid creating 
a remote processor device as the driver is being removed.

Thanks,
Matt
<span class="quote">
&gt;</span>
<span class="quote">&gt; Thanks,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	tglx</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Oct. 3, 2016, 8:35 a.m.</div>
<pre class="content">
Hi Bjorn / Ohad,

Please could you give some feedback on this patch?

Thanks,

Matt


On 20/09/16 09:47, Matt Redfearn wrote:
<span class="quote">&gt; Add a remoteproc driver to steal, load the firmware, and boot an offline</span>
<span class="quote">&gt; MIPS core, turning it into a coprocessor.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This driver provides a sysfs to allow arbitrary firmware to be loaded</span>
<span class="quote">&gt; onto a core, which may expose virtio devices. Coprocessor firmware must</span>
<span class="quote">&gt; abide by the UHI coprocessor boot protocol.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Changes in v2: None</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;   Documentation/ABI/testing/sysfs-class-mips-rproc |  24 +</span>
<span class="quote">&gt;   drivers/remoteproc/Kconfig                       |  11 +</span>
<span class="quote">&gt;   drivers/remoteproc/Makefile                      |   1 +</span>
<span class="quote">&gt;   drivers/remoteproc/mips_remoteproc.c             | 651 +++++++++++++++++++++++</span>
<span class="quote">&gt;   4 files changed, 687 insertions(+)</span>
<span class="quote">&gt;   create mode 100644 Documentation/ABI/testing/sysfs-class-mips-rproc</span>
<span class="quote">&gt;   create mode 100644 drivers/remoteproc/mips_remoteproc.c</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/Documentation/ABI/testing/sysfs-class-mips-rproc b/Documentation/ABI/testing/sysfs-class-mips-rproc</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..c09d02a755e4</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/Documentation/ABI/testing/sysfs-class-mips-rproc</span>
<span class="quote">&gt; @@ -0,0 +1,24 @@</span>
<span class="quote">&gt; +What:		/sys/class/mips-rproc/rproc#/firmware</span>
<span class="quote">&gt; +Date:		August 2015</span>
<span class="quote">&gt; +Contact:	Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="quote">&gt; +Description:	MIPS VPE remoteproc start</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	This node only exists when a VPE is considered offline by Linux. Writes</span>
<span class="quote">&gt; +	to this file will start firmware running on a VPE.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	If the VPE is idle, specifying a name will cause a remoteproc instance</span>
<span class="quote">&gt; +	to be allocated, which will cause the core to be stolen, the firmware</span>
<span class="quote">&gt; +	image to be loaded, and the remoteproc instance to be started.</span>
<span class="quote">&gt; +	Otherwise, the operation will fail.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +What:		/sys/class/mips-rproc/rproc#/stop</span>
<span class="quote">&gt; +Date:		August 2015</span>
<span class="quote">&gt; +Contact:	Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="quote">&gt; +Description:	MIPS VPE remoteproc stop</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	This node only exists when a VPE is considered offline by Linux. Writes</span>
<span class="quote">&gt; +	to this file will stop firmware running on a VPE.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	If the VPE is running a remote proc instance, the instance will be</span>
<span class="quote">&gt; +	stopped, the core returned, and the instance freed.</span>
<span class="quote">&gt; +	Otherwise, the operation will fail.</span>
<span class="quote">&gt; diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig</span>
<span class="quote">&gt; index 1a8bf76a925f..05db52e0e668 100644</span>
<span class="quote">&gt; --- a/drivers/remoteproc/Kconfig</span>
<span class="quote">&gt; +++ b/drivers/remoteproc/Kconfig</span>
<span class="quote">&gt; @@ -100,4 +100,15 @@ config ST_REMOTEPROC</span>
<span class="quote">&gt;   	  processor framework.</span>
<span class="quote">&gt;   	  This can be either built-in or a loadable module.</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +config MIPS_REMOTEPROC</span>
<span class="quote">&gt; +	tristate &quot;MIPS remoteproc support&quot;</span>
<span class="quote">&gt; +	depends on MIPS_CPS &amp;&amp; HAS_DMA</span>
<span class="quote">&gt; +	select CMA</span>
<span class="quote">&gt; +	select REMOTEPROC</span>
<span class="quote">&gt; +	select MIPS_STEAL</span>
<span class="quote">&gt; +	help</span>
<span class="quote">&gt; +	  Say y here to support using offline cores/VPEs as remote processors</span>
<span class="quote">&gt; +	  via the remote processor framework.</span>
<span class="quote">&gt; +	  If unsure say N.</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   endmenu</span>
<span class="quote">&gt; diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile</span>
<span class="quote">&gt; index 92d3758bd15c..de19cd320f3a 100644</span>
<span class="quote">&gt; --- a/drivers/remoteproc/Makefile</span>
<span class="quote">&gt; +++ b/drivers/remoteproc/Makefile</span>
<span class="quote">&gt; @@ -14,3 +14,4 @@ obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o</span>
<span class="quote">&gt;   obj-$(CONFIG_QCOM_MDT_LOADER)		+= qcom_mdt_loader.o</span>
<span class="quote">&gt;   obj-$(CONFIG_QCOM_Q6V5_PIL)		+= qcom_q6v5_pil.o</span>
<span class="quote">&gt;   obj-$(CONFIG_ST_REMOTEPROC)		+= st_remoteproc.o</span>
<span class="quote">&gt; +obj-$(CONFIG_MIPS_REMOTEPROC)		+= mips_remoteproc.o</span>
<span class="quote">&gt; diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..944ad66280b4</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="quote">&gt; @@ -0,0 +1,651 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * MIPS Remote Processor driver</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright (C) 2016 Imagination Technologies</span>
<span class="quote">&gt; + * Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="quote">&gt; + * Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify it</span>
<span class="quote">&gt; + * under the terms of the GNU General Public License as published by the</span>
<span class="quote">&gt; + * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="quote">&gt; + * option) any later version.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/cpu.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/interrupt.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/io.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/module.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/of_irq.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/platform_device.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/remoteproc.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;asm/dma-coherence.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/smp-cps.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbflush.h&gt;</span>
<span class="quote">&gt; +#include &lt;asm/tlbmisc.h&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &quot;remoteproc_internal.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct mips_rproc {</span>
<span class="quote">&gt; +	struct rproc		*rproc;</span>
<span class="quote">&gt; +	char			*firmware;</span>
<span class="quote">&gt; +	struct task_struct	*tsk;</span>
<span class="quote">&gt; +	struct device		dev;</span>
<span class="quote">&gt; +	unsigned int		cpu;</span>
<span class="quote">&gt; +	int			ipi_linux;</span>
<span class="quote">&gt; +	int			ipi_remote;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct rproc *mips_rprocs[NR_CPUS];</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define to_mips_rproc(d) container_of(d, struct mips_rproc, dev)</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Compute the largest page mask a physical address can be mapped with */</span>
<span class="quote">&gt; +static unsigned long mips_rproc_largest_pm(unsigned long pa,</span>
<span class="quote">&gt; +					   unsigned long maxmask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long mask;</span>
<span class="quote">&gt; +	/* Find address bits limiting alignment */</span>
<span class="quote">&gt; +	unsigned long shift = ffs(pa);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Obey MIPS restrictions on page sizes */</span>
<span class="quote">&gt; +	if (pa) {</span>
<span class="quote">&gt; +		if (shift &amp; 1)</span>
<span class="quote">&gt; +			shift -= 2;</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			shift--;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	mask = ULONG_MAX &lt;&lt; shift;</span>
<span class="quote">&gt; +	return maxmask &amp; ~mask;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Compute the next largest page mask for a given page mask */</span>
<span class="quote">&gt; +static unsigned long mips_rproc_next_pm(unsigned long pm, unsigned long maxmask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (pm != PM_4K)</span>
<span class="quote">&gt; +		return ((pm &lt;&lt; 2) | pm) &amp; maxmask;</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		return PM_16K;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mips_map_page(unsigned long da, unsigned long pa, int c,</span>
<span class="quote">&gt; +			  unsigned long pagemask, unsigned long pagesize)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long pa2 = pa + (pagesize / 2);</span>
<span class="quote">&gt; +	unsigned long entryhi, entrylo0, entrylo1;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Compute the mapping */</span>
<span class="quote">&gt; +	pa = (pa &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="quote">&gt; +	pa2 = (pa2 &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="quote">&gt; +	entryhi = da &amp; 0xfffffe000;</span>
<span class="quote">&gt; +	entrylo0 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa;</span>
<span class="quote">&gt; +	entrylo1 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa2;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pr_debug(&quot;Create wired entry %d, CCA %d\n&quot;, read_c0_wired(), c);</span>
<span class="quote">&gt; +	pr_debug(&quot; EntryHi: 0x%016lx\n&quot;, entryhi);</span>
<span class="quote">&gt; +	pr_debug(&quot; EntryLo0: 0x%016lx\n&quot;, entrylo0);</span>
<span class="quote">&gt; +	pr_debug(&quot; EntryLo1: 0x%016lx\n&quot;, entrylo1);</span>
<span class="quote">&gt; +	pr_debug(&quot; Pagemask: 0x%016lx\n&quot;, pagemask);</span>
<span class="quote">&gt; +	pr_debug(&quot;\n&quot;);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	add_wired_entry(entrylo0, entrylo1, entryhi, pagemask);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * Compute the page required to fulfill a mapping. Escapes alignment derived</span>
<span class="quote">&gt; + * page size limitations before using biggest fit to map the remainder.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +static inline void mips_rproc_fit_page(unsigned long da, unsigned long pa,</span>
<span class="quote">&gt; +					int c, unsigned long size,</span>
<span class="quote">&gt; +					unsigned long maxmask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned long bigmask, nextmask;</span>
<span class="quote">&gt; +	unsigned long pagemask, pagesize;</span>
<span class="quote">&gt; +	unsigned long distance, target;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	do {</span>
<span class="quote">&gt; +		/* Compute the current largest page mask */</span>
<span class="quote">&gt; +		bigmask = mips_rproc_largest_pm(pa, maxmask);</span>
<span class="quote">&gt; +		/* Compute the next largest pagesize */</span>
<span class="quote">&gt; +		nextmask = mips_rproc_next_pm(bigmask, maxmask);</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Compute the distance from our current physical address to</span>
<span class="quote">&gt; +		 * the next page boundary.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		distance = (nextmask + 0x2000) - (pa &amp; nextmask);</span>
<span class="quote">&gt; +		/*</span>
<span class="quote">&gt; +		 * Decide between searching to get to the next highest page</span>
<span class="quote">&gt; +		 * boundary or finishing.</span>
<span class="quote">&gt; +		 */</span>
<span class="quote">&gt; +		target = distance &lt; size ? distance : size;</span>
<span class="quote">&gt; +		/* Fit */</span>
<span class="quote">&gt; +		while (target) {</span>
<span class="quote">&gt; +			/* Find the largest supported page size that will fit */</span>
<span class="quote">&gt; +			for (pagesize = maxmask + 0x2000;</span>
<span class="quote">&gt; +			     (pagesize &gt; 0x2000) &amp;&amp; (pagesize &gt; target);</span>
<span class="quote">&gt; +			     pagesize /= 4) {</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +			/* Convert it to a page mask */</span>
<span class="quote">&gt; +			pagemask = pagesize - 0x2000;</span>
<span class="quote">&gt; +			/* Emit it */</span>
<span class="quote">&gt; +			mips_map_page(da, pa, c, pagemask, pagesize);</span>
<span class="quote">&gt; +			/* Move to next step */</span>
<span class="quote">&gt; +			size -= pagesize;</span>
<span class="quote">&gt; +			da += pagesize;</span>
<span class="quote">&gt; +			pa += pagesize;</span>
<span class="quote">&gt; +			target -= pagesize;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	} while (size);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mips_rproc_carveouts(struct rproc *rproc, int max_pagemask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct rproc_mem_entry *carveout;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each_entry(carveout, &amp;rproc-&gt;carveouts, node) {</span>
<span class="quote">&gt; +		int c = CONF_CM_CACHABLE_COW;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="quote">&gt; +			&quot;carveout mapping da 0x%x -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="quote">&gt; +			carveout-&gt;da, &amp;carveout-&gt;dma, carveout-&gt;len, c);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		mips_rproc_fit_page(carveout-&gt;da, carveout-&gt;dma, c,</span>
<span class="quote">&gt; +				    carveout-&gt;len, max_pagemask);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mips_rproc_vdevs(struct rproc *rproc, int max_pagemask)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct rproc_vdev *rvdev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	list_for_each_entry(rvdev, &amp;rproc-&gt;rvdevs, node) {</span>
<span class="quote">&gt; +		int i, size;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		for (i = 0; i &lt; ARRAY_SIZE(rvdev-&gt;vring); i++) {</span>
<span class="quote">&gt; +			struct rproc_vring *vring = &amp;rvdev-&gt;vring[i];</span>
<span class="quote">&gt; +			unsigned long pa = vring-&gt;dma;</span>
<span class="quote">&gt; +			int c;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			if (hw_coherentio) {</span>
<span class="quote">&gt; +				/*</span>
<span class="quote">&gt; +				 * The DMA API will allocate cacheable buffers</span>
<span class="quote">&gt; +				 * for shared resources, so the firmware should</span>
<span class="quote">&gt; +				 * also access those buffers cached</span>
<span class="quote">&gt; +				 */</span>
<span class="quote">&gt; +				c = (_page_cachable_default &gt;&gt; _CACHE_SHIFT);</span>
<span class="quote">&gt; +			} else {</span>
<span class="quote">&gt; +				/*</span>
<span class="quote">&gt; +				 * Otherwise, shared buffers should be accessed</span>
<span class="quote">&gt; +				 * uncached</span>
<span class="quote">&gt; +				 */</span>
<span class="quote">&gt; +				c = CONF_CM_UNCACHED;</span>
<span class="quote">&gt; +			}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			/* actual size of vring (in bytes) */</span>
<span class="quote">&gt; +			size = PAGE_ALIGN(vring_size(vring-&gt;len, vring-&gt;align));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="quote">&gt; +				&quot;vring mapping da %pad -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="quote">&gt; +				&amp;vring-&gt;dma, &amp;vring-&gt;dma, size, c);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			mips_rproc_fit_page(pa, pa, c, size, max_pagemask);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mips_rproc_cpu_entry(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct rproc *rproc = mips_rprocs[smp_processor_id()];</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt; +	int ipi_to_remote = ipi_get_hwirq(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="quote">&gt; +	int ipi_from_remote = ipi_get_hwirq(mproc-&gt;ipi_linux, 0);</span>
<span class="quote">&gt; +	unsigned long old_pagemask, max_pagemask;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!rproc)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev_info(&amp;rproc-&gt;dev, &quot;Starting %s on MIPS CPU%d\n&quot;,</span>
<span class="quote">&gt; +		 mproc-&gt;firmware, mproc-&gt;cpu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Get the maximum pagemask supported on this CPU */</span>
<span class="quote">&gt; +	old_pagemask = read_c0_pagemask();</span>
<span class="quote">&gt; +	write_c0_pagemask(PM_HUGE_MASK);</span>
<span class="quote">&gt; +	mtc0_tlbw_hazard();</span>
<span class="quote">&gt; +	max_pagemask = read_c0_pagemask();</span>
<span class="quote">&gt; +	write_c0_pagemask(old_pagemask);</span>
<span class="quote">&gt; +	mtc0_tlbw_hazard();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Start with no wired entries */</span>
<span class="quote">&gt; +	write_c0_wired(0);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Flush all previous TLB entries */</span>
<span class="quote">&gt; +	local_flush_tlb_all();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Map firmware resources into virtual memory */</span>
<span class="quote">&gt; +	mips_rproc_carveouts(rproc, max_pagemask);</span>
<span class="quote">&gt; +	mips_rproc_vdevs(rproc, max_pagemask);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI to remote: %d\n&quot;, ipi_to_remote);</span>
<span class="quote">&gt; +	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI from remote: %d\n&quot;, ipi_from_remote);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Hand off the CPU to the firmware */</span>
<span class="quote">&gt; +	dev_dbg(&amp;rproc-&gt;dev, &quot;Jumping to firmware at 0x%x\n&quot;, rproc-&gt;bootaddr);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	write_c0_entryhi(0); /* Set ASID 0 */</span>
<span class="quote">&gt; +	tlbw_use_hazard();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Firmware protocol */</span>
<span class="quote">&gt; +	__asm__(&quot;addiu $a0, $zero, -3&quot;);</span>
<span class="quote">&gt; +	__asm__(&quot;move $a1, %0&quot; :: &quot;r&quot; (ipi_to_remote));</span>
<span class="quote">&gt; +	__asm__(&quot;move $a2, %0&quot; :: &quot;r&quot; (ipi_from_remote));</span>
<span class="quote">&gt; +	__asm__(&quot;move $a3, $zero&quot;);</span>
<span class="quote">&gt; +	__asm__(&quot;jr %0&quot; :: &quot;r&quot; (rproc-&gt;bootaddr));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static irqreturn_t mips_rproc_ipi_handler(int irq, void *dev_id)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	/* Synthetic interrupts shouldn&#39;t need acking */</span>
<span class="quote">&gt; +	return IRQ_WAKE_THREAD;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static irqreturn_t mips_rproc_vq_int(int irq, void *p)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct rproc *rproc = (struct rproc *)p;</span>
<span class="quote">&gt; +	void *entry;</span>
<span class="quote">&gt; +	int id;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* We don&#39;t have a mailbox, so iterate over all vqs and kick them. */</span>
<span class="quote">&gt; +	idr_for_each_entry(&amp;rproc-&gt;notifyids, entry, id)</span>
<span class="quote">&gt; +		rproc_vq_interrupt(rproc, id);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return IRQ_HANDLED;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Helper function to find the IPI domain */</span>
<span class="quote">&gt; +static struct irq_domain *ipi_domain(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device_node *node = of_irq_find_parent(of_root);</span>
<span class="quote">&gt; +	struct irq_domain *ipidomain;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ipidomain = irq_find_matching_host(node, DOMAIN_BUS_IPI);</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Some platforms have half DT setup. So if we found irq node but</span>
<span class="quote">&gt; +	 * didn&#39;t find an ipidomain, try to search for one that is not in the</span>
<span class="quote">&gt; +	 * DT.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (node &amp;&amp; !ipidomain)</span>
<span class="quote">&gt; +		ipidomain = irq_find_matching_host(NULL, DOMAIN_BUS_IPI);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ipidomain;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt; +	int err;</span>
<span class="quote">&gt; +	int cpu = mproc-&gt;cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mips_rprocs[cpu]) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="quote">&gt; +		return -EBUSY;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	mips_rprocs[cpu] = rproc;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="quote">&gt; +	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="quote">&gt; +	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="quote">&gt; +	if (mips_smp_ipi_free(get_cpu_mask(cpu)))</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="quote">&gt; +	 * offlined while the remote CPU is running.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="quote">&gt; +	if (!mproc-&gt;ipi_linux) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="quote">&gt; +		goto exit_rproc_nofrom;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="quote">&gt; +	if (!mproc-&gt;ipi_remote) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="quote">&gt; +		goto exit_rproc_noto;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* register incoming ipi */</span>
<span class="quote">&gt; +	err = devm_request_threaded_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux,</span>
<span class="quote">&gt; +					mips_rproc_ipi_handler,</span>
<span class="quote">&gt; +					mips_rproc_vq_int, 0,</span>
<span class="quote">&gt; +					&quot;mips-rproc IPI in&quot;, mproc-&gt;rproc);</span>
<span class="quote">&gt; +	if (err) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="quote">&gt; +			err);</span>
<span class="quote">&gt; +		goto exit_rproc_noint;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="quote">&gt; +						mproc-&gt;tsk))</span>
<span class="quote">&gt; +		return 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev_err(&amp;mproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="quote">&gt; +	devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="quote">&gt; +exit_rproc_noint:</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="quote">&gt; +exit_rproc_noto:</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt; +exit_rproc_nofrom:</span>
<span class="quote">&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt; +	mips_rprocs[cpu] = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt; +	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="quote">&gt; +	return -EINVAL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mproc-&gt;ipi_linux)</span>
<span class="quote">&gt; +		devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt; +	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mips_rprocs[mproc-&gt;cpu] = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void mips_rproc_op_kick(struct rproc *rproc, int vqid)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ipi_send_single(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +struct rproc_ops mips_rproc_proc_ops = {</span>
<span class="quote">&gt; +	.start	= mips_rproc_op_start,</span>
<span class="quote">&gt; +	.stop	= mips_rproc_op_stop,</span>
<span class="quote">&gt; +	.kick	= mips_rproc_op_kick,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mips_rproc_probe(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mips_rproc_remove(struct platform_device *pdev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct platform_driver mips_rproc_driver = {</span>
<span class="quote">&gt; +	.probe = mips_rproc_probe,</span>
<span class="quote">&gt; +	.remove = mips_rproc_remove,</span>
<span class="quote">&gt; +	.driver = {</span>
<span class="quote">&gt; +		.name = &quot;mips-rproc&quot;</span>
<span class="quote">&gt; +	},</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Steal a core and run some firmware on it */</span>
<span class="quote">&gt; +int mips_rproc_start(struct mips_rproc *mproc, const char *firmware, size_t len)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int err = -EINVAL;</span>
<span class="quote">&gt; +	struct mips_rproc **priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Duplicate the filename, dropping whitespace from the end via len */</span>
<span class="quote">&gt; +	mproc-&gt;firmware = kstrndup(firmware, len, GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!mproc-&gt;firmware)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mproc-&gt;rproc = rproc_alloc(&amp;mproc-&gt;dev, &quot;mips&quot;, &amp;mips_rproc_proc_ops,</span>
<span class="quote">&gt; +				   mproc-&gt;firmware,</span>
<span class="quote">&gt; +				   sizeof(struct mips_rproc *));</span>
<span class="quote">&gt; +	if (!mproc-&gt;rproc)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv = mproc-&gt;rproc-&gt;priv;</span>
<span class="quote">&gt; +	*priv = mproc;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* go live! */</span>
<span class="quote">&gt; +	err = rproc_add(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	if (err) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="quote">&gt; +		rproc_put(mproc-&gt;rproc);</span>
<span class="quote">&gt; +		kfree(mproc-&gt;firmware);</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Stop a core, and return it to being offline */</span>
<span class="quote">&gt; +int mips_rproc_stop(struct mips_rproc *mproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	rproc_shutdown(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	rproc_del(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	rproc_put(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	mproc-&gt;rproc = NULL;</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* sysfs interface to mips_rproc_start */</span>
<span class="quote">&gt; +static ssize_t firmware_store(struct device *dev,</span>
<span class="quote">&gt; +			      struct device_attribute *attr,</span>
<span class="quote">&gt; +			      const char *buf, size_t count)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="quote">&gt; +	size_t len = count;</span>
<span class="quote">&gt; +	int err = -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (buf[count - 1] == &#39;\n&#39;)</span>
<span class="quote">&gt; +		len--;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!mproc-&gt;rproc &amp;&amp; len)</span>
<span class="quote">&gt; +		err = mips_rproc_start(mproc, buf, len);</span>
<span class="quote">&gt; +	else if (len)</span>
<span class="quote">&gt; +		err = -EBUSY;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return err ? err : count;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +static DEVICE_ATTR_WO(firmware);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* sysfs interface to mips_rproc_stop */</span>
<span class="quote">&gt; +static ssize_t stop_store(struct device *dev,</span>
<span class="quote">&gt; +			      struct device_attribute *attr,</span>
<span class="quote">&gt; +			      const char *buf, size_t count)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="quote">&gt; +	int err = -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mproc-&gt;rproc)</span>
<span class="quote">&gt; +		err = mips_rproc_stop(mproc);</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		err = -EBUSY;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return err ? err : count;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +static DEVICE_ATTR_WO(stop);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Boiler plate for devclarng mips-rproc sysfs devices */</span>
<span class="quote">&gt; +static struct attribute *mips_rproc_attrs[] = {</span>
<span class="quote">&gt; +	&amp;dev_attr_firmware.attr,</span>
<span class="quote">&gt; +	&amp;dev_attr_stop.attr,</span>
<span class="quote">&gt; +	NULL</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct attribute_group mips_rproc_devgroup = {</span>
<span class="quote">&gt; +	.attrs = mips_rproc_attrs</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static const struct attribute_group *mips_rproc_devgroups[] = {</span>
<span class="quote">&gt; +	&amp;mips_rproc_devgroup,</span>
<span class="quote">&gt; +	NULL</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static char *mips_rproc_devnode(struct device *dev, umode_t *mode)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	return kasprintf(GFP_KERNEL, &quot;mips-rproc/%s&quot;, dev_name(dev));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct class mips_rproc_class = {</span>
<span class="quote">&gt; +	.name		= &quot;mips-rproc&quot;,</span>
<span class="quote">&gt; +	.devnode	= mips_rproc_devnode,</span>
<span class="quote">&gt; +	.dev_groups	= mips_rproc_devgroups,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void mips_rproc_release(struct device *dev)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int mips_rproc_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!mproc)</span>
<span class="quote">&gt; +		return -ENODEV;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct device_type mips_rproc_type = {</span>
<span class="quote">&gt; +	.release	= mips_rproc_release,</span>
<span class="quote">&gt; +	.uevent		= mips_rproc_uevent</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Helper function for locating the device for a CPU */</span>
<span class="quote">&gt; +int mips_rproc_device_rproc_match(struct device *dev, const void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="quote">&gt; +	unsigned int cpu = *(unsigned int *)data;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return mproc-&gt;cpu == cpu;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Create a sysfs device in response to CPU down */</span>
<span class="quote">&gt; +int mips_rproc_device_register(unsigned int cpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *dev;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!dev)</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	dev-&gt;dev.driver = &amp;mips_rproc_driver.driver;</span>
<span class="quote">&gt; +	dev-&gt;dev.type = &amp;mips_rproc_type;</span>
<span class="quote">&gt; +	dev-&gt;dev.class = &amp;mips_rproc_class;</span>
<span class="quote">&gt; +	dev-&gt;dev.id = cpu;</span>
<span class="quote">&gt; +	dev_set_name(&amp;dev-&gt;dev, &quot;rproc%u&quot;, cpu);</span>
<span class="quote">&gt; +	dev-&gt;cpu = cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return device_register(&amp;dev-&gt;dev);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Destroy a sysfs device in response to CPU up */</span>
<span class="quote">&gt; +int mips_rproc_device_unregister(unsigned int cpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct device *dev = class_find_device(&amp;mips_rproc_class, NULL, &amp;cpu,</span>
<span class="quote">&gt; +					       mips_rproc_device_rproc_match);</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mips_rprocs[cpu])</span>
<span class="quote">&gt; +		mips_rproc_stop(mproc);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	put_device(dev);</span>
<span class="quote">&gt; +	device_unregister(dev);</span>
<span class="quote">&gt; +	kfree(mproc);</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Intercept CPU hotplug events for syfs purposes */</span>
<span class="quote">&gt; +static int mips_rproc_callback(struct notifier_block *nfb, unsigned long action,</span>
<span class="quote">&gt; +			       void *hcpu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	unsigned int cpu = (unsigned long)hcpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	switch (action) {</span>
<span class="quote">&gt; +	case CPU_UP_PREPARE:</span>
<span class="quote">&gt; +	case CPU_DOWN_FAILED:</span>
<span class="quote">&gt; +		mips_rproc_device_unregister(cpu);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	case CPU_DOWN_PREPARE:</span>
<span class="quote">&gt; +		mips_rproc_device_register(cpu);</span>
<span class="quote">&gt; +		break;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return NOTIFY_OK;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static struct notifier_block mips_rproc_notifier __refdata = {</span>
<span class="quote">&gt; +	.notifier_call = mips_rproc_callback</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int __init mips_rproc_init(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int cpu;</span>
<span class="quote">&gt; +	/* create mips-rproc device class for sysfs */</span>
<span class="quote">&gt; +	int err = class_register(&amp;mips_rproc_class);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (err) {</span>
<span class="quote">&gt; +		pr_err(&quot;mips-proc: unable to register mips-rproc class\n&quot;);</span>
<span class="quote">&gt; +		return err;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Dynamically create mips-rproc class devices based on hotplug data */</span>
<span class="quote">&gt; +	get_online_cpus();</span>
<span class="quote">&gt; +	for_each_possible_cpu(cpu)</span>
<span class="quote">&gt; +		if (!cpu_online(cpu))</span>
<span class="quote">&gt; +			mips_rproc_device_register(cpu);</span>
<span class="quote">&gt; +	register_hotcpu_notifier(&amp;mips_rproc_notifier);</span>
<span class="quote">&gt; +	put_online_cpus();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static void __exit mips_rproc_exit(void)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int cpu;</span>
<span class="quote">&gt; +	/* Destroy mips-rproc class devices */</span>
<span class="quote">&gt; +	get_online_cpus();</span>
<span class="quote">&gt; +	unregister_hotcpu_notifier(&amp;mips_rproc_notifier);</span>
<span class="quote">&gt; +	for_each_possible_cpu(cpu)</span>
<span class="quote">&gt; +		if (!cpu_online(cpu))</span>
<span class="quote">&gt; +			mips_rproc_device_unregister(cpu);</span>
<span class="quote">&gt; +	put_online_cpus();</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	class_unregister(&amp;mips_rproc_class);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +subsys_initcall(mips_rproc_init);</span>
<span class="quote">&gt; +module_exit(mips_rproc_exit);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +module_platform_driver(mips_rproc_driver);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="quote">&gt; +MODULE_DESCRIPTION(&quot;MIPS Remote Processor control driver&quot;);</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=155101">Bjorn Andersson</a> - Oct. 3, 2016, 10:16 p.m.</div>
<pre class="content">
On Tue 20 Sep 01:47 PDT 2016, Matt Redfearn wrote:
<span class="quote">
&gt; Add a remoteproc driver to steal, load the firmware, and boot an offline</span>
<span class="quote">&gt; MIPS core, turning it into a coprocessor.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This driver provides a sysfs to allow arbitrary firmware to be loaded</span>
<span class="quote">&gt; onto a core, which may expose virtio devices. Coprocessor firmware must</span>
<span class="quote">&gt; abide by the UHI coprocessor boot protocol.</span>

Hi Matt,

Sorry for my very slow response, I kept getting side tracked on the
sysfs part every time I attempted to review this. After discussing with
others it&#39;s obvious that being able to boot a remoteproc with a specific
firmware image for some amount of time is a very common request.

Rather than adding a MIPS specific interface for controlling this rproc
I would like for us to bring this to the core.


I would also appreciate if Ralf had some input on the MIPS specifics.


Also regarding the 32-bit requirement, have you investigated what is
needed to support 64-bit ELFs?

[..]
<span class="quote">&gt; diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
[..]
<span class="quote">&gt; +int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt; +	int err;</span>
<span class="quote">&gt; +	int cpu = mproc-&gt;cpu;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mips_rprocs[cpu]) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="quote">&gt; +		return -EBUSY;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	mips_rprocs[cpu] = rproc;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="quote">&gt; +	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="quote">&gt; +	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="quote">&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="quote">&gt; +	if (mips_smp_ipi_free(get_cpu_mask(cpu)))</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="quote">&gt; +	 * offlined while the remote CPU is running.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="quote">&gt; +	if (!mproc-&gt;ipi_linux) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="quote">&gt; +		goto exit_rproc_nofrom;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="quote">&gt; +	if (!mproc-&gt;ipi_remote) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="quote">&gt; +		goto exit_rproc_noto;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* register incoming ipi */</span>
<span class="quote">&gt; +	err = devm_request_threaded_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux,</span>
<span class="quote">&gt; +					mips_rproc_ipi_handler,</span>
<span class="quote">&gt; +					mips_rproc_vq_int, 0,</span>
<span class="quote">&gt; +					&quot;mips-rproc IPI in&quot;, mproc-&gt;rproc);</span>

Based on how you&#39;ve designed this I think it makes sense to just depend
on the fact that stop() will always be called and hence you do not
benefit from the devm_ version of this api.
<span class="quote">
&gt; +	if (err) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="quote">&gt; +			err);</span>
<span class="quote">&gt; +		goto exit_rproc_noint;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="quote">&gt; +						mproc-&gt;tsk))</span>
<span class="quote">&gt; +		return 0;</span>

Please flip this around, to follow the pattern of the others, like:

	if (mips_cps_steal_cpu_and_execute()) {
		dev_err()
		goto exit_free_irq;
	}

	return 0;

exit_free_irq:
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	dev_err(&amp;mproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="quote">&gt; +	devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="quote">&gt; +exit_rproc_noint:</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="quote">&gt; +exit_rproc_noto:</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt; +exit_rproc_nofrom:</span>
<span class="quote">&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt; +	mips_rprocs[cpu] = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt; +	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="quote">&gt; +	return -EINVAL;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mproc-&gt;ipi_linux)</span>

stop() should not be called unless start() succeeded, so ipi_linux
should not be able to be 0.
<span class="quote">
&gt; +		devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt; +	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mips_rprocs[mproc-&gt;cpu] = NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
[..]
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Steal a core and run some firmware on it */</span>
<span class="quote">&gt; +int mips_rproc_start(struct mips_rproc *mproc, const char *firmware, size_t len)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	int err = -EINVAL;</span>
<span class="quote">&gt; +	struct mips_rproc **priv;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* Duplicate the filename, dropping whitespace from the end via len */</span>
<span class="quote">&gt; +	mproc-&gt;firmware = kstrndup(firmware, len, GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!mproc-&gt;firmware)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	mproc-&gt;rproc = rproc_alloc(&amp;mproc-&gt;dev, &quot;mips&quot;, &amp;mips_rproc_proc_ops,</span>
<span class="quote">&gt; +				   mproc-&gt;firmware,</span>
<span class="quote">&gt; +				   sizeof(struct mips_rproc *));</span>
<span class="quote">&gt; +	if (!mproc-&gt;rproc)</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	priv = mproc-&gt;rproc-&gt;priv;</span>
<span class="quote">&gt; +	*priv = mproc;</span>

If we move the class into the core, everyone will share the same
interface for setting firmware, booting and shutting down remoteproc.

I think you should set rproc-&gt;auto_boot to false and move this code into
the probe function above. It would make there be an remoteproc instance
whenever the cpu is offlined, do you see any problems with this?
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +	/* go live! */</span>
<span class="quote">&gt; +	err = rproc_add(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	if (err) {</span>
<span class="quote">&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="quote">&gt; +		rproc_put(mproc-&gt;rproc);</span>
<span class="quote">&gt; +		kfree(mproc-&gt;firmware);</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* Stop a core, and return it to being offline */</span>
<span class="quote">&gt; +int mips_rproc_stop(struct mips_rproc *mproc)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	rproc_shutdown(mproc-&gt;rproc);</span>

I presume this shutdown is related to the implicit boot happening in
rproc_add() if you have virtio devices; I&#39;ve changed this for v4.9 so
that rproc_del() shuts down the core if rproc_add() booted it.

There needs to be some more work done in this area though, because there
are plenty of corner cases that we don&#39;t handle properly today...
<span class="quote">
&gt; +	rproc_del(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	rproc_put(mproc-&gt;rproc);</span>
<span class="quote">&gt; +	mproc-&gt;rproc = NULL;</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
[..]
<span class="quote">&gt; +</span>
<span class="quote">&gt; +/* sysfs interface to mips_rproc_stop */</span>
<span class="quote">&gt; +static ssize_t stop_store(struct device *dev,</span>
<span class="quote">&gt; +			      struct device_attribute *attr,</span>
<span class="quote">&gt; +			      const char *buf, size_t count)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="quote">&gt; +	int err = -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (mproc-&gt;rproc)</span>
<span class="quote">&gt; +		err = mips_rproc_stop(mproc);</span>
<span class="quote">&gt; +	else</span>
<span class="quote">&gt; +		err = -EBUSY;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return err ? err : count;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +static DEVICE_ATTR_WO(stop);</span>

Please move this control into the core, preferably as &quot;state&quot; which can
be passed &quot;boot&quot; or &quot;shutdown&quot; - i.e. what we today have in debugfs.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +/* Boiler plate for devclarng mips-rproc sysfs devices */</span>
<span class="quote">&gt; +static struct attribute *mips_rproc_attrs[] = {</span>
<span class="quote">&gt; +	&amp;dev_attr_firmware.attr,</span>
<span class="quote">&gt; +	&amp;dev_attr_stop.attr,</span>
<span class="quote">&gt; +	NULL</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>

Regards,
Bjorn
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Oct. 5, 2016, 4:22 p.m.</div>
<pre class="content">
Hi Bjorn,

Thanks for the review and comments, much appreciated :-)


On 03/10/16 23:16, Bjorn Andersson wrote:
<span class="quote">&gt; On Tue 20 Sep 01:47 PDT 2016, Matt Redfearn wrote:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; Add a remoteproc driver to steal, load the firmware, and boot an offline</span>
<span class="quote">&gt;&gt; MIPS core, turning it into a coprocessor.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This driver provides a sysfs to allow arbitrary firmware to be loaded</span>
<span class="quote">&gt;&gt; onto a core, which may expose virtio devices. Coprocessor firmware must</span>
<span class="quote">&gt;&gt; abide by the UHI coprocessor boot protocol.</span>
<span class="quote">&gt; Hi Matt,</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Sorry for my very slow response, I kept getting side tracked on the</span>
<span class="quote">&gt; sysfs part every time I attempted to review this. After discussing with</span>
<span class="quote">&gt; others it&#39;s obvious that being able to boot a remoteproc with a specific</span>
<span class="quote">&gt; firmware image for some amount of time is a very common request.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Rather than adding a MIPS specific interface for controlling this rproc</span>
<span class="quote">&gt; I would like for us to bring this to the core.</span>

Yes, makes perfect sense. I had a bit of fun allowing for the firmware 
name / information to be changed in an allocated struct rproc, but I 
have a proof of concept working now and will post it soon. The main 
issue remaining is that when the virtio devices are removed in the 
context of the sysfs write, a warning from dma-mapping.h is triggered 
because interrupts are disabled:

[   28.413958] WARNING: CPU: 0 PID: 121 at 
./include/linux/dma-mapping.h:433 free_buf+0x1a8/0x288
[   28.423542] Modules linked in:
[   28.426951] CPU: 0 PID: 121 Comm: sh Tainted: G        W 4.8.0+ #729
[   28.434600] Stack : 00000000 00000000 00000000 00000000 80d26cea 
0000003e 80c50000 00000000
       00000000 80c50000 80c50000 00040800 80c50000 8f658bc8 80b992dc 
00000079
       00000000 80d23824 00000000 0067544c 0067542c 8048af58 80c50000 
00000001
       80c50000 00000000 80b9fcd0 8f7c7b74 80d23824 8051d8bc 00000000 
0067544c
       00000007 80c50000 8f7c7b74 00040800 00000000 00000000 00000000 
00000000
       ...
[   28.474274] Call Trace:
[   28.477005] [&lt;8040c538&gt;] show_stack+0x74/0xc0
[   28.481860] [&lt;80757240&gt;] dump_stack+0xd0/0x110
[   28.486813] [&lt;80430d98&gt;] __warn+0xfc/0x130
[   28.491379] [&lt;80430ee0&gt;] warn_slowpath_null+0x2c/0x3c
[   28.497007] [&lt;807e7c6c&gt;] free_buf+0x1a8/0x288
[   28.501862] [&lt;807ea590&gt;] remove_port_data+0x50/0xac
[   28.507298] [&lt;807ea6a0&gt;] unplug_port+0xb4/0x1bc
[   28.512346] [&lt;807ea858&gt;] virtcons_remove+0xb0/0xfc
[   28.517689] [&lt;807b6734&gt;] virtio_dev_remove+0x58/0xc0
[   28.523223] [&lt;807f918c&gt;] __device_release_driver+0xac/0x134
[   28.529433] [&lt;807f924c&gt;] device_release_driver+0x38/0x50
[   28.535352] [&lt;807f7edc&gt;] bus_remove_device+0xfc/0x130
[   28.540980] [&lt;807f4b74&gt;] device_del+0x17c/0x21c
[   28.546027] [&lt;807f4c38&gt;] device_unregister+0x24/0x38
[   28.551562] [&lt;807b6b50&gt;] unregister_virtio_device+0x28/0x44
[   28.557777] [&lt;80948ab0&gt;] rproc_change_firmware+0xb4/0x114
[   28.563795] [&lt;80949464&gt;] firmware_store+0x2c/0x40
[   28.569039] [&lt;8060186c&gt;] kernfs_fop_write+0x154/0x1dc
[   28.574669] [&lt;805823f0&gt;] __vfs_write+0x5c/0x17c
[   28.579719] [&lt;805834ac&gt;] vfs_write+0xe0/0x190
[   28.584574] [&lt;80584520&gt;] SyS_write+0x80/0xf4
[   28.589336] [&lt;80415908&gt;] syscall_common+0x34/0x58
[   28.594570]
[   28.596228] ---[ end trace 3f6cae675f2fcee9 ]---


I&#39;m still investigating how to decouple removal of the virtio devices 
from interrupts being disabled.
<span class="quote">

&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I would also appreciate if Ralf had some input on the MIPS specifics.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Also regarding the 32-bit requirement, have you investigated what is</span>
<span class="quote">&gt; needed to support 64-bit ELFs?</span>

Not yet - I wanted to get the 32bit version accepted first, then we can 
look at the required changes to support 64bit since no doubt that will 
necessitate quite a few changes to the core code.
<span class="quote">
&gt;</span>
<span class="quote">&gt; [..]</span>
<span class="quote">&gt;&gt; diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="quote">&gt; [..]</span>
<span class="quote">&gt;&gt; +int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt;&gt; +	int err;</span>
<span class="quote">&gt;&gt; +	int cpu = mproc-&gt;cpu;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (mips_rprocs[cpu]) {</span>
<span class="quote">&gt;&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="quote">&gt;&gt; +		return -EBUSY;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +	mips_rprocs[cpu] = rproc;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="quote">&gt;&gt; +	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="quote">&gt;&gt; +	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="quote">&gt;&gt; +		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="quote">&gt;&gt; +		return -ENOMEM;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="quote">&gt;&gt; +	if (mips_smp_ipi_free(get_cpu_mask(cpu)))</span>
<span class="quote">&gt;&gt; +		return -EINVAL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/*</span>
<span class="quote">&gt;&gt; +	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="quote">&gt;&gt; +	 * offlined while the remote CPU is running.</span>
<span class="quote">&gt;&gt; +	 */</span>
<span class="quote">&gt;&gt; +	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="quote">&gt;&gt; +	if (!mproc-&gt;ipi_linux) {</span>
<span class="quote">&gt;&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="quote">&gt;&gt; +		goto exit_rproc_nofrom;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="quote">&gt;&gt; +	if (!mproc-&gt;ipi_remote) {</span>
<span class="quote">&gt;&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="quote">&gt;&gt; +		goto exit_rproc_noto;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* register incoming ipi */</span>
<span class="quote">&gt;&gt; +	err = devm_request_threaded_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux,</span>
<span class="quote">&gt;&gt; +					mips_rproc_ipi_handler,</span>
<span class="quote">&gt;&gt; +					mips_rproc_vq_int, 0,</span>
<span class="quote">&gt;&gt; +					&quot;mips-rproc IPI in&quot;, mproc-&gt;rproc);</span>
<span class="quote">&gt; Based on how you&#39;ve designed this I think it makes sense to just depend</span>
<span class="quote">&gt; on the fact that stop() will always be called and hence you do not</span>
<span class="quote">&gt; benefit from the devm_ version of this api.</span>

Yeah, makes sense.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	if (err) {</span>
<span class="quote">&gt;&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="quote">&gt;&gt; +			err);</span>
<span class="quote">&gt;&gt; +		goto exit_rproc_noint;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (!mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="quote">&gt;&gt; +						mproc-&gt;tsk))</span>
<span class="quote">&gt;&gt; +		return 0;</span>
<span class="quote">&gt; Please flip this around, to follow the pattern of the others, like:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	if (mips_cps_steal_cpu_and_execute()) {</span>
<span class="quote">&gt; 		dev_err()</span>
<span class="quote">&gt; 		goto exit_free_irq;</span>
<span class="quote">&gt; 	}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; 	return 0;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; exit_free_irq:</span>

OK.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	dev_err(&amp;mproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="quote">&gt;&gt; +	devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="quote">&gt;&gt; +exit_rproc_noint:</span>
<span class="quote">&gt;&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="quote">&gt;&gt; +exit_rproc_noto:</span>
<span class="quote">&gt;&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt;&gt; +exit_rproc_nofrom:</span>
<span class="quote">&gt;&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt;&gt; +	mips_rprocs[cpu] = NULL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt;&gt; +	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="quote">&gt;&gt; +	return -EINVAL;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (mproc-&gt;ipi_linux)</span>
<span class="quote">&gt; stop() should not be called unless start() succeeded, so ipi_linux</span>
<span class="quote">&gt; should not be able to be 0.</span>

True.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +		devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="quote">&gt;&gt; +	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Set up the Linux IPIs again */</span>
<span class="quote">&gt;&gt; +	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	free_task(mproc-&gt;tsk);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	mips_rprocs[mproc-&gt;cpu] = NULL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt; [..]</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/* Steal a core and run some firmware on it */</span>
<span class="quote">&gt;&gt; +int mips_rproc_start(struct mips_rproc *mproc, const char *firmware, size_t len)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	int err = -EINVAL;</span>
<span class="quote">&gt;&gt; +	struct mips_rproc **priv;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* Duplicate the filename, dropping whitespace from the end via len */</span>
<span class="quote">&gt;&gt; +	mproc-&gt;firmware = kstrndup(firmware, len, GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +	if (!mproc-&gt;firmware)</span>
<span class="quote">&gt;&gt; +		return -ENOMEM;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	mproc-&gt;rproc = rproc_alloc(&amp;mproc-&gt;dev, &quot;mips&quot;, &amp;mips_rproc_proc_ops,</span>
<span class="quote">&gt;&gt; +				   mproc-&gt;firmware,</span>
<span class="quote">&gt;&gt; +				   sizeof(struct mips_rproc *));</span>
<span class="quote">&gt;&gt; +	if (!mproc-&gt;rproc)</span>
<span class="quote">&gt;&gt; +		return -ENOMEM;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	priv = mproc-&gt;rproc-&gt;priv;</span>
<span class="quote">&gt;&gt; +	*priv = mproc;</span>
<span class="quote">&gt; If we move the class into the core, everyone will share the same</span>
<span class="quote">&gt; interface for setting firmware, booting and shutting down remoteproc.</span>

Yes, that sounds like the best way forward.
<span class="quote">
&gt;</span>
<span class="quote">&gt; I think you should set rproc-&gt;auto_boot to false and move this code into</span>
<span class="quote">&gt; the probe function above. It would make there be an remoteproc instance</span>
<span class="quote">&gt; whenever the cpu is offlined, do you see any problems with this?</span>

No problem with it being available any time the CPU is offline.
<span class="quote">

&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* go live! */</span>
<span class="quote">&gt;&gt; +	err = rproc_add(mproc-&gt;rproc);</span>
<span class="quote">&gt;&gt; +	if (err) {</span>
<span class="quote">&gt;&gt; +		dev_err(&amp;mproc-&gt;dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="quote">&gt;&gt; +		rproc_put(mproc-&gt;rproc);</span>
<span class="quote">&gt;&gt; +		kfree(mproc-&gt;firmware);</span>
<span class="quote">&gt;&gt; +		return -EINVAL;</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/* Stop a core, and return it to being offline */</span>
<span class="quote">&gt;&gt; +int mips_rproc_stop(struct mips_rproc *mproc)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	rproc_shutdown(mproc-&gt;rproc);</span>
<span class="quote">&gt; I presume this shutdown is related to the implicit boot happening in</span>
<span class="quote">&gt; rproc_add() if you have virtio devices; I&#39;ve changed this for v4.9 so</span>
<span class="quote">&gt; that rproc_del() shuts down the core if rproc_add() booted it.</span>

Yeah it is, ok great.
<span class="quote">
&gt;</span>
<span class="quote">&gt; There needs to be some more work done in this area though, because there</span>
<span class="quote">&gt; are plenty of corner cases that we don&#39;t handle properly today...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +	rproc_del(mproc-&gt;rproc);</span>
<span class="quote">&gt;&gt; +	rproc_put(mproc-&gt;rproc);</span>
<span class="quote">&gt;&gt; +	mproc-&gt;rproc = NULL;</span>
<span class="quote">&gt;&gt; +	return 0;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt; [..]</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/* sysfs interface to mips_rproc_stop */</span>
<span class="quote">&gt;&gt; +static ssize_t stop_store(struct device *dev,</span>
<span class="quote">&gt;&gt; +			      struct device_attribute *attr,</span>
<span class="quote">&gt;&gt; +			      const char *buf, size_t count)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="quote">&gt;&gt; +	int err = -EINVAL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	if (mproc-&gt;rproc)</span>
<span class="quote">&gt;&gt; +		err = mips_rproc_stop(mproc);</span>
<span class="quote">&gt;&gt; +	else</span>
<span class="quote">&gt;&gt; +		err = -EBUSY;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	return err ? err : count;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +static DEVICE_ATTR_WO(stop);</span>
<span class="quote">&gt; Please move this control into the core, preferably as &quot;state&quot; which can</span>
<span class="quote">&gt; be passed &quot;boot&quot; or &quot;shutdown&quot; - i.e. what we today have in debugfs.</span>

OK, though I&#39;ve stuck with &quot;start&quot; and &quot;stop&quot; as are in the debugfs version.

Thanks,
Matt
<span class="quote">

&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +/* Boiler plate for devclarng mips-rproc sysfs devices */</span>
<span class="quote">&gt;&gt; +static struct attribute *mips_rproc_attrs[] = {</span>
<span class="quote">&gt;&gt; +	&amp;dev_attr_firmware.attr,</span>
<span class="quote">&gt;&gt; +	&amp;dev_attr_stop.attr,</span>
<span class="quote">&gt;&gt; +	NULL</span>
<span class="quote">&gt;&gt; +};</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt; Regards,</span>
<span class="quote">&gt; Bjorn</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-class-mips-rproc b/Documentation/ABI/testing/sysfs-class-mips-rproc</span>
new file mode 100644
<span class="p_header">index 000000000000..c09d02a755e4</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-class-mips-rproc</span>
<span class="p_chunk">@@ -0,0 +1,24 @@</span> <span class="p_context"></span>
<span class="p_add">+What:		/sys/class/mips-rproc/rproc#/firmware</span>
<span class="p_add">+Date:		August 2015</span>
<span class="p_add">+Contact:	Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="p_add">+Description:	MIPS VPE remoteproc start</span>
<span class="p_add">+</span>
<span class="p_add">+	This node only exists when a VPE is considered offline by Linux. Writes</span>
<span class="p_add">+	to this file will start firmware running on a VPE.</span>
<span class="p_add">+</span>
<span class="p_add">+	If the VPE is idle, specifying a name will cause a remoteproc instance</span>
<span class="p_add">+	to be allocated, which will cause the core to be stolen, the firmware</span>
<span class="p_add">+	image to be loaded, and the remoteproc instance to be started.</span>
<span class="p_add">+	Otherwise, the operation will fail.</span>
<span class="p_add">+</span>
<span class="p_add">+What:		/sys/class/mips-rproc/rproc#/stop</span>
<span class="p_add">+Date:		August 2015</span>
<span class="p_add">+Contact:	Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="p_add">+Description:	MIPS VPE remoteproc stop</span>
<span class="p_add">+</span>
<span class="p_add">+	This node only exists when a VPE is considered offline by Linux. Writes</span>
<span class="p_add">+	to this file will stop firmware running on a VPE.</span>
<span class="p_add">+</span>
<span class="p_add">+	If the VPE is running a remote proc instance, the instance will be</span>
<span class="p_add">+	stopped, the core returned, and the instance freed.</span>
<span class="p_add">+	Otherwise, the operation will fail.</span>
<span class="p_header">diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig</span>
<span class="p_header">index 1a8bf76a925f..05db52e0e668 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Kconfig</span>
<span class="p_header">+++ b/drivers/remoteproc/Kconfig</span>
<span class="p_chunk">@@ -100,4 +100,15 @@</span> <span class="p_context"> config ST_REMOTEPROC</span>
 	  processor framework.
 	  This can be either built-in or a loadable module.
 
<span class="p_add">+config MIPS_REMOTEPROC</span>
<span class="p_add">+	tristate &quot;MIPS remoteproc support&quot;</span>
<span class="p_add">+	depends on MIPS_CPS &amp;&amp; HAS_DMA</span>
<span class="p_add">+	select CMA</span>
<span class="p_add">+	select REMOTEPROC</span>
<span class="p_add">+	select MIPS_STEAL</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Say y here to support using offline cores/VPEs as remote processors</span>
<span class="p_add">+	  via the remote processor framework.</span>
<span class="p_add">+	  If unsure say N.</span>
<span class="p_add">+</span>
 endmenu
<span class="p_header">diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile</span>
<span class="p_header">index 92d3758bd15c..de19cd320f3a 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Makefile</span>
<span class="p_header">+++ b/drivers/remoteproc/Makefile</span>
<span class="p_chunk">@@ -14,3 +14,4 @@</span> <span class="p_context"> obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o</span>
 obj-$(CONFIG_QCOM_MDT_LOADER)		+= qcom_mdt_loader.o
 obj-$(CONFIG_QCOM_Q6V5_PIL)		+= qcom_q6v5_pil.o
 obj-$(CONFIG_ST_REMOTEPROC)		+= st_remoteproc.o
<span class="p_add">+obj-$(CONFIG_MIPS_REMOTEPROC)		+= mips_remoteproc.o</span>
<span class="p_header">diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
new file mode 100644
<span class="p_header">index 000000000000..944ad66280b4</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="p_chunk">@@ -0,0 +1,651 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MIPS Remote Processor driver</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Imagination Technologies</span>
<span class="p_add">+ * Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="p_add">+ * Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify it</span>
<span class="p_add">+ * under the terms of the GNU General Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/remoteproc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/dma-coherence.h&gt;</span>
<span class="p_add">+#include &lt;asm/smp-cps.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbmisc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;remoteproc_internal.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+struct mips_rproc {</span>
<span class="p_add">+	struct rproc		*rproc;</span>
<span class="p_add">+	char			*firmware;</span>
<span class="p_add">+	struct task_struct	*tsk;</span>
<span class="p_add">+	struct device		dev;</span>
<span class="p_add">+	unsigned int		cpu;</span>
<span class="p_add">+	int			ipi_linux;</span>
<span class="p_add">+	int			ipi_remote;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct rproc *mips_rprocs[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+#define to_mips_rproc(d) container_of(d, struct mips_rproc, dev)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the largest page mask a physical address can be mapped with */</span>
<span class="p_add">+static unsigned long mips_rproc_largest_pm(unsigned long pa,</span>
<span class="p_add">+					   unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long mask;</span>
<span class="p_add">+	/* Find address bits limiting alignment */</span>
<span class="p_add">+	unsigned long shift = ffs(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Obey MIPS restrictions on page sizes */</span>
<span class="p_add">+	if (pa) {</span>
<span class="p_add">+		if (shift &amp; 1)</span>
<span class="p_add">+			shift -= 2;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			shift--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mask = ULONG_MAX &lt;&lt; shift;</span>
<span class="p_add">+	return maxmask &amp; ~mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the next largest page mask for a given page mask */</span>
<span class="p_add">+static unsigned long mips_rproc_next_pm(unsigned long pm, unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pm != PM_4K)</span>
<span class="p_add">+		return ((pm &lt;&lt; 2) | pm) &amp; maxmask;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return PM_16K;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_map_page(unsigned long da, unsigned long pa, int c,</span>
<span class="p_add">+			  unsigned long pagemask, unsigned long pagesize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pa2 = pa + (pagesize / 2);</span>
<span class="p_add">+	unsigned long entryhi, entrylo0, entrylo1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute the mapping */</span>
<span class="p_add">+	pa = (pa &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	pa2 = (pa2 &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	entryhi = da &amp; 0xfffffe000;</span>
<span class="p_add">+	entrylo0 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa;</span>
<span class="p_add">+	entrylo1 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa2;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Create wired entry %d, CCA %d\n&quot;, read_c0_wired(), c);</span>
<span class="p_add">+	pr_debug(&quot; EntryHi: 0x%016lx\n&quot;, entryhi);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo0: 0x%016lx\n&quot;, entrylo0);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo1: 0x%016lx\n&quot;, entrylo1);</span>
<span class="p_add">+	pr_debug(&quot; Pagemask: 0x%016lx\n&quot;, pagemask);</span>
<span class="p_add">+	pr_debug(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	add_wired_entry(entrylo0, entrylo1, entryhi, pagemask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Compute the page required to fulfill a mapping. Escapes alignment derived</span>
<span class="p_add">+ * page size limitations before using biggest fit to map the remainder.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void mips_rproc_fit_page(unsigned long da, unsigned long pa,</span>
<span class="p_add">+					int c, unsigned long size,</span>
<span class="p_add">+					unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long bigmask, nextmask;</span>
<span class="p_add">+	unsigned long pagemask, pagesize;</span>
<span class="p_add">+	unsigned long distance, target;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		/* Compute the current largest page mask */</span>
<span class="p_add">+		bigmask = mips_rproc_largest_pm(pa, maxmask);</span>
<span class="p_add">+		/* Compute the next largest pagesize */</span>
<span class="p_add">+		nextmask = mips_rproc_next_pm(bigmask, maxmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Compute the distance from our current physical address to</span>
<span class="p_add">+		 * the next page boundary.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		distance = (nextmask + 0x2000) - (pa &amp; nextmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Decide between searching to get to the next highest page</span>
<span class="p_add">+		 * boundary or finishing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		target = distance &lt; size ? distance : size;</span>
<span class="p_add">+		/* Fit */</span>
<span class="p_add">+		while (target) {</span>
<span class="p_add">+			/* Find the largest supported page size that will fit */</span>
<span class="p_add">+			for (pagesize = maxmask + 0x2000;</span>
<span class="p_add">+			     (pagesize &gt; 0x2000) &amp;&amp; (pagesize &gt; target);</span>
<span class="p_add">+			     pagesize /= 4) {</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/* Convert it to a page mask */</span>
<span class="p_add">+			pagemask = pagesize - 0x2000;</span>
<span class="p_add">+			/* Emit it */</span>
<span class="p_add">+			mips_map_page(da, pa, c, pagemask, pagesize);</span>
<span class="p_add">+			/* Move to next step */</span>
<span class="p_add">+			size -= pagesize;</span>
<span class="p_add">+			da += pagesize;</span>
<span class="p_add">+			pa += pagesize;</span>
<span class="p_add">+			target -= pagesize;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_carveouts(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_mem_entry *carveout;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(carveout, &amp;rproc-&gt;carveouts, node) {</span>
<span class="p_add">+		int c = CONF_CM_CACHABLE_COW;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+			&quot;carveout mapping da 0x%x -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+			carveout-&gt;da, &amp;carveout-&gt;dma, carveout-&gt;len, c);</span>
<span class="p_add">+</span>
<span class="p_add">+		mips_rproc_fit_page(carveout-&gt;da, carveout-&gt;dma, c,</span>
<span class="p_add">+				    carveout-&gt;len, max_pagemask);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_vdevs(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_vdev *rvdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(rvdev, &amp;rproc-&gt;rvdevs, node) {</span>
<span class="p_add">+		int i, size;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(rvdev-&gt;vring); i++) {</span>
<span class="p_add">+			struct rproc_vring *vring = &amp;rvdev-&gt;vring[i];</span>
<span class="p_add">+			unsigned long pa = vring-&gt;dma;</span>
<span class="p_add">+			int c;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (hw_coherentio) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * The DMA API will allocate cacheable buffers</span>
<span class="p_add">+				 * for shared resources, so the firmware should</span>
<span class="p_add">+				 * also access those buffers cached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = (_page_cachable_default &gt;&gt; _CACHE_SHIFT);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Otherwise, shared buffers should be accessed</span>
<span class="p_add">+				 * uncached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = CONF_CM_UNCACHED;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/* actual size of vring (in bytes) */</span>
<span class="p_add">+			size = PAGE_ALIGN(vring_size(vring-&gt;len, vring-&gt;align));</span>
<span class="p_add">+</span>
<span class="p_add">+			dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+				&quot;vring mapping da %pad -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+				&amp;vring-&gt;dma, &amp;vring-&gt;dma, size, c);</span>
<span class="p_add">+</span>
<span class="p_add">+			mips_rproc_fit_page(pa, pa, c, size, max_pagemask);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_rproc_cpu_entry(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc *rproc = mips_rprocs[smp_processor_id()];</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+	int ipi_to_remote = ipi_get_hwirq(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+	int ipi_from_remote = ipi_get_hwirq(mproc-&gt;ipi_linux, 0);</span>
<span class="p_add">+	unsigned long old_pagemask, max_pagemask;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rproc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;rproc-&gt;dev, &quot;Starting %s on MIPS CPU%d\n&quot;,</span>
<span class="p_add">+		 mproc-&gt;firmware, mproc-&gt;cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the maximum pagemask supported on this CPU */</span>
<span class="p_add">+	old_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(PM_HUGE_MASK);</span>
<span class="p_add">+	mtc0_tlbw_hazard();</span>
<span class="p_add">+	max_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(old_pagemask);</span>
<span class="p_add">+	mtc0_tlbw_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start with no wired entries */</span>
<span class="p_add">+	write_c0_wired(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush all previous TLB entries */</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Map firmware resources into virtual memory */</span>
<span class="p_add">+	mips_rproc_carveouts(rproc, max_pagemask);</span>
<span class="p_add">+	mips_rproc_vdevs(rproc, max_pagemask);</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI to remote: %d\n&quot;, ipi_to_remote);</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI from remote: %d\n&quot;, ipi_from_remote);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Hand off the CPU to the firmware */</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;Jumping to firmware at 0x%x\n&quot;, rproc-&gt;bootaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	write_c0_entryhi(0); /* Set ASID 0 */</span>
<span class="p_add">+	tlbw_use_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Firmware protocol */</span>
<span class="p_add">+	__asm__(&quot;addiu $a0, $zero, -3&quot;);</span>
<span class="p_add">+	__asm__(&quot;move $a1, %0&quot; :: &quot;r&quot; (ipi_to_remote));</span>
<span class="p_add">+	__asm__(&quot;move $a2, %0&quot; :: &quot;r&quot; (ipi_from_remote));</span>
<span class="p_add">+	__asm__(&quot;move $a3, $zero&quot;);</span>
<span class="p_add">+	__asm__(&quot;jr %0&quot; :: &quot;r&quot; (rproc-&gt;bootaddr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_ipi_handler(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Synthetic interrupts shouldn&#39;t need acking */</span>
<span class="p_add">+	return IRQ_WAKE_THREAD;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_vq_int(int irq, void *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc *rproc = (struct rproc *)p;</span>
<span class="p_add">+	void *entry;</span>
<span class="p_add">+	int id;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We don&#39;t have a mailbox, so iterate over all vqs and kick them. */</span>
<span class="p_add">+	idr_for_each_entry(&amp;rproc-&gt;notifyids, entry, id)</span>
<span class="p_add">+		rproc_vq_interrupt(rproc, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/* Helper function to find the IPI domain */</span>
<span class="p_add">+static struct irq_domain *ipi_domain(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node = of_irq_find_parent(of_root);</span>
<span class="p_add">+	struct irq_domain *ipidomain;</span>
<span class="p_add">+</span>
<span class="p_add">+	ipidomain = irq_find_matching_host(node, DOMAIN_BUS_IPI);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some platforms have half DT setup. So if we found irq node but</span>
<span class="p_add">+	 * didn&#39;t find an ipidomain, try to search for one that is not in the</span>
<span class="p_add">+	 * DT.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (node &amp;&amp; !ipidomain)</span>
<span class="p_add">+		ipidomain = irq_find_matching_host(NULL, DOMAIN_BUS_IPI);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ipidomain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int cpu = mproc-&gt;cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_rprocs[cpu]) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mips_rprocs[cpu] = rproc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="p_add">+	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="p_add">+	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="p_add">+	if (mips_smp_ipi_free(get_cpu_mask(cpu)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="p_add">+	 * offlined while the remote CPU is running.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_linux) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="p_add">+		goto exit_rproc_nofrom;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_remote) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="p_add">+		goto exit_rproc_noto;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* register incoming ipi */</span>
<span class="p_add">+	err = devm_request_threaded_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux,</span>
<span class="p_add">+					mips_rproc_ipi_handler,</span>
<span class="p_add">+					mips_rproc_vq_int, 0,</span>
<span class="p_add">+					&quot;mips-rproc IPI in&quot;, mproc-&gt;rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="p_add">+			err);</span>
<span class="p_add">+		goto exit_rproc_noint;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="p_add">+						mproc-&gt;tsk))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_err(&amp;mproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="p_add">+	devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="p_add">+exit_rproc_noint:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="p_add">+exit_rproc_noto:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+exit_rproc_nofrom:</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+	mips_rprocs[cpu] = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mproc-&gt;ipi_linux)</span>
<span class="p_add">+		devm_free_irq(&amp;mproc-&gt;dev, mproc-&gt;ipi_linux, mproc-&gt;rproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rprocs[mproc-&gt;cpu] = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void mips_rproc_op_kick(struct rproc *rproc, int vqid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	ipi_send_single(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct rproc_ops mips_rproc_proc_ops = {</span>
<span class="p_add">+	.start	= mips_rproc_op_start,</span>
<span class="p_add">+	.stop	= mips_rproc_op_stop,</span>
<span class="p_add">+	.kick	= mips_rproc_op_kick,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mips_rproc_driver = {</span>
<span class="p_add">+	.probe = mips_rproc_probe,</span>
<span class="p_add">+	.remove = mips_rproc_remove,</span>
<span class="p_add">+	.driver = {</span>
<span class="p_add">+		.name = &quot;mips-rproc&quot;</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/* Steal a core and run some firmware on it */</span>
<span class="p_add">+int mips_rproc_start(struct mips_rproc *mproc, const char *firmware, size_t len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = -EINVAL;</span>
<span class="p_add">+	struct mips_rproc **priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Duplicate the filename, dropping whitespace from the end via len */</span>
<span class="p_add">+	mproc-&gt;firmware = kstrndup(firmware, len, GFP_KERNEL);</span>
<span class="p_add">+	if (!mproc-&gt;firmware)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;rproc = rproc_alloc(&amp;mproc-&gt;dev, &quot;mips&quot;, &amp;mips_rproc_proc_ops,</span>
<span class="p_add">+				   mproc-&gt;firmware,</span>
<span class="p_add">+				   sizeof(struct mips_rproc *));</span>
<span class="p_add">+	if (!mproc-&gt;rproc)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv = mproc-&gt;rproc-&gt;priv;</span>
<span class="p_add">+	*priv = mproc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* go live! */</span>
<span class="p_add">+	err = rproc_add(mproc-&gt;rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="p_add">+		rproc_put(mproc-&gt;rproc);</span>
<span class="p_add">+		kfree(mproc-&gt;firmware);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Stop a core, and return it to being offline */</span>
<span class="p_add">+int mips_rproc_stop(struct mips_rproc *mproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	rproc_shutdown(mproc-&gt;rproc);</span>
<span class="p_add">+	rproc_del(mproc-&gt;rproc);</span>
<span class="p_add">+	rproc_put(mproc-&gt;rproc);</span>
<span class="p_add">+	mproc-&gt;rproc = NULL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* sysfs interface to mips_rproc_start */</span>
<span class="p_add">+static ssize_t firmware_store(struct device *dev,</span>
<span class="p_add">+			      struct device_attribute *attr,</span>
<span class="p_add">+			      const char *buf, size_t count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="p_add">+	size_t len = count;</span>
<span class="p_add">+	int err = -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (buf[count - 1] == &#39;\n&#39;)</span>
<span class="p_add">+		len--;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mproc-&gt;rproc &amp;&amp; len)</span>
<span class="p_add">+		err = mips_rproc_start(mproc, buf, len);</span>
<span class="p_add">+	else if (len)</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err ? err : count;</span>
<span class="p_add">+}</span>
<span class="p_add">+static DEVICE_ATTR_WO(firmware);</span>
<span class="p_add">+</span>
<span class="p_add">+/* sysfs interface to mips_rproc_stop */</span>
<span class="p_add">+static ssize_t stop_store(struct device *dev,</span>
<span class="p_add">+			      struct device_attribute *attr,</span>
<span class="p_add">+			      const char *buf, size_t count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="p_add">+	int err = -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mproc-&gt;rproc)</span>
<span class="p_add">+		err = mips_rproc_stop(mproc);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return err ? err : count;</span>
<span class="p_add">+}</span>
<span class="p_add">+static DEVICE_ATTR_WO(stop);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Boiler plate for devclarng mips-rproc sysfs devices */</span>
<span class="p_add">+static struct attribute *mips_rproc_attrs[] = {</span>
<span class="p_add">+	&amp;dev_attr_firmware.attr,</span>
<span class="p_add">+	&amp;dev_attr_stop.attr,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct attribute_group mips_rproc_devgroup = {</span>
<span class="p_add">+	.attrs = mips_rproc_attrs</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct attribute_group *mips_rproc_devgroups[] = {</span>
<span class="p_add">+	&amp;mips_rproc_devgroup,</span>
<span class="p_add">+	NULL</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static char *mips_rproc_devnode(struct device *dev, umode_t *mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kasprintf(GFP_KERNEL, &quot;mips-rproc/%s&quot;, dev_name(dev));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct class mips_rproc_class = {</span>
<span class="p_add">+	.name		= &quot;mips-rproc&quot;,</span>
<span class="p_add">+	.devnode	= mips_rproc_devnode,</span>
<span class="p_add">+	.dev_groups	= mips_rproc_devgroups,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_rproc_release(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mproc)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct device_type mips_rproc_type = {</span>
<span class="p_add">+	.release	= mips_rproc_release,</span>
<span class="p_add">+	.uevent		= mips_rproc_uevent</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Helper function for locating the device for a CPU */</span>
<span class="p_add">+int mips_rproc_device_rproc_match(struct device *dev, const void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="p_add">+	unsigned int cpu = *(unsigned int *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+	return mproc-&gt;cpu == cpu;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Create a sysfs device in response to CPU down */</span>
<span class="p_add">+int mips_rproc_device_register(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);</span>
<span class="p_add">+	if (!dev)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev-&gt;dev.driver = &amp;mips_rproc_driver.driver;</span>
<span class="p_add">+	dev-&gt;dev.type = &amp;mips_rproc_type;</span>
<span class="p_add">+	dev-&gt;dev.class = &amp;mips_rproc_class;</span>
<span class="p_add">+	dev-&gt;dev.id = cpu;</span>
<span class="p_add">+	dev_set_name(&amp;dev-&gt;dev, &quot;rproc%u&quot;, cpu);</span>
<span class="p_add">+	dev-&gt;cpu = cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	return device_register(&amp;dev-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Destroy a sysfs device in response to CPU up */</span>
<span class="p_add">+int mips_rproc_device_unregister(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *dev = class_find_device(&amp;mips_rproc_class, NULL, &amp;cpu,</span>
<span class="p_add">+					       mips_rproc_device_rproc_match);</span>
<span class="p_add">+	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_rprocs[cpu])</span>
<span class="p_add">+		mips_rproc_stop(mproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	put_device(dev);</span>
<span class="p_add">+	device_unregister(dev);</span>
<span class="p_add">+	kfree(mproc);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Intercept CPU hotplug events for syfs purposes */</span>
<span class="p_add">+static int mips_rproc_callback(struct notifier_block *nfb, unsigned long action,</span>
<span class="p_add">+			       void *hcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = (unsigned long)hcpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (action) {</span>
<span class="p_add">+	case CPU_UP_PREPARE:</span>
<span class="p_add">+	case CPU_DOWN_FAILED:</span>
<span class="p_add">+		mips_rproc_device_unregister(cpu);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case CPU_DOWN_PREPARE:</span>
<span class="p_add">+		mips_rproc_device_register(cpu);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_OK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block mips_rproc_notifier __refdata = {</span>
<span class="p_add">+	.notifier_call = mips_rproc_callback</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mips_rproc_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+	/* create mips-rproc device class for sysfs */</span>
<span class="p_add">+	int err = class_register(&amp;mips_rproc_class);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		pr_err(&quot;mips-proc: unable to register mips-rproc class\n&quot;);</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Dynamically create mips-rproc class devices based on hotplug data */</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+	for_each_possible_cpu(cpu)</span>
<span class="p_add">+		if (!cpu_online(cpu))</span>
<span class="p_add">+			mips_rproc_device_register(cpu);</span>
<span class="p_add">+	register_hotcpu_notifier(&amp;mips_rproc_notifier);</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit mips_rproc_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+	/* Destroy mips-rproc class devices */</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+	unregister_hotcpu_notifier(&amp;mips_rproc_notifier);</span>
<span class="p_add">+	for_each_possible_cpu(cpu)</span>
<span class="p_add">+		if (!cpu_online(cpu))</span>
<span class="p_add">+			mips_rproc_device_unregister(cpu);</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+</span>
<span class="p_add">+	class_unregister(&amp;mips_rproc_class);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(mips_rproc_init);</span>
<span class="p_add">+module_exit(mips_rproc_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+module_platform_driver(mips_rproc_driver);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;MIPS Remote Processor control driver&quot;);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



