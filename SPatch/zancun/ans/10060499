
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v2] mm: show total hugetlb memory consumption in /proc/meminfo - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v2] mm: show total hugetlb memory consumption in /proc/meminfo</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=174271">Roman Gushchin</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 15, 2017, 11:14 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171115231409.12131-1-guro@fb.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10060499/mbox/"
   >mbox</a>
|
   <a href="/patch/10060499/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10060499/">/patch/10060499/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	A225660231 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 15 Nov 2017 23:15:21 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 818F628978
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 15 Nov 2017 23:15:21 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 75DEF2A376; Wed, 15 Nov 2017 23:15:21 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID,RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7FCDC28978
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 15 Nov 2017 23:15:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932796AbdKOXPN (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 15 Nov 2017 18:15:13 -0500
Received: from mx0a-00082601.pphosted.com ([67.231.145.42]:39652 &quot;EHLO
	mx0a-00082601.pphosted.com&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1753451AbdKOXPG (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 15 Nov 2017 18:15:06 -0500
Received: from pps.filterd (m0044012.ppops.net [127.0.0.1])
	by mx0a-00082601.pphosted.com (8.16.0.21/8.16.0.21) with SMTP id
	vAFNEfPx030355; Wed, 15 Nov 2017 15:14:43 -0800
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=fb.com;
	h=from : to : cc : subject
	: date : message-id : mime-version : content-type; s=facebook;
	bh=uwHHpKy5crQIz/9ghMUVzaaGE/514padR/0CIvODPU8=;
	b=b9hM8L/+SaHkoySMKOCfchEN8CxGPXXW1bNY1FZ6uLrBNyJJ52TRWTrHnWiQfGkTiMq5
	vGu0MBm4rrvPjlMYloxkER8e6pTRQhAFJC62GwVAVG9smfCcpcbjSlxTtIY9gQG5r0HN
	zMbLwwdCq701jgHG0AreAa3j5iSF++6YqFo= 
Received: from mail.thefacebook.com ([199.201.64.23])
	by mx0a-00082601.pphosted.com with ESMTP id 2e8v6j0jav-2
	(version=TLSv1 cipher=ECDHE-RSA-AES256-SHA bits=256 verify=NOT);
	Wed, 15 Nov 2017 15:14:43 -0800
Received: from NAM01-BN3-obe.outbound.protection.outlook.com (192.168.54.28)
	by o365-in.thefacebook.com (192.168.16.21) with Microsoft SMTP
	Server (TLS) id 14.3.319.2; Wed, 15 Nov 2017 15:14:40 -0800
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=fb.onmicrosoft.com; 
	s=selector1-fb-com;
	h=From:Date:Subject:Message-ID:Content-Type:MIME-Version; 
	bh=uwHHpKy5crQIz/9ghMUVzaaGE/514padR/0CIvODPU8=;
	b=Wwo3GoootFkXjen4+48OvsFnRD+KPawZAcwy5qfi1qI70zeLiRFf8AtMZgVJ4xjbxrZTkr2ZvtMMMbh/fLon/CGQSU6Jfq6mq3mYm2oVpsRvaeHl5TsrZsA+Hdk3ewnWZvqFyOtCGwURDdKW+BVa65DQ+wWPqCn4sWRMv+qFypQ=
Received: from castle.thefacebook.com (2620:10d:c092:180::1:5328) by
	CO1PR15MB1079.namprd15.prod.outlook.com (2a01:111:e400:7b66::9) with
	Microsoft SMTP Server (version=TLS1_2,
	cipher=TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384_P256) id 15.20.218.12;
	Wed, 15 Nov 2017 23:14:33 +0000
From: Roman Gushchin &lt;guro@fb.com&gt;
To: &lt;linux-mm@kvack.org&gt;
CC: Roman Gushchin &lt;guro@fb.com&gt;, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Michal Hocko &lt;mhocko@suse.com&gt;, Johannes Weiner &lt;hannes@cmpxchg.org&gt;,
	Mike Kravetz &lt;mike.kravetz@oracle.com&gt;,
	&quot;Aneesh Kumar K.V&quot; &lt;aneesh.kumar@linux.vnet.ibm.com&gt;,
	Andrea Arcangeli &lt;aarcange@redhat.com&gt;,
	Dave Hansen &lt;dave.hansen@intel.com&gt;,
	David Rientjes &lt;rientjes@google.com&gt;, &lt;kernel-team@fb.com&gt;,
	&lt;linux-kernel@vger.kernel.org&gt;
Subject: [PATCH v2] mm: show total hugetlb memory consumption in
	/proc/meminfo
Date: Wed, 15 Nov 2017 23:14:09 +0000
Message-ID: &lt;20171115231409.12131-1-guro@fb.com&gt;
X-Mailer: git-send-email 2.13.6
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [2620:10d:c092:180::1:5328]
X-ClientProxiedBy: HE1PR09CA0043.eurprd09.prod.outlook.com
	(2603:10a6:7:3c::11) To CO1PR15MB1079.namprd15.prod.outlook.com
	(2a01:111:e400:7b66::9)
X-MS-PublicTrafficType: Email
X-MS-Office365-Filtering-Correlation-Id: 90877b80-d4a5-48b8-691d-08d52c7ea482
X-Microsoft-Antispam: UriScan:; BCL:0; PCL:0;
	RULEID:(22001)(4534020)(4602075)(4627115)(201703031133081)(201702281549075)(2017052603199);
	SRVR:CO1PR15MB1079; 
X-Microsoft-Exchange-Diagnostics: 1; CO1PR15MB1079;
	3:xBHNluBoZLWVdy7RqVJTBTesLEuKcmpkz4xaKm0CkyhXTK7WkYIl7rc+P23zr0aQijMidACg7oYtMMrsZOR5OIFuopj5ytxb+FyHTSr7ceuT5qq8bPXLBfbxjOJzk2Yo7BPxtiUvt3gvAVXIGVMz1i+xXv0OkfFY7haPVPLeQfUJJdEWrZefmDUFnTYOdayTOItbW/KcURYPcfjv+fAk5qAnxJLFPFKntvGPA+vBgzRTEqbnz20PS4rPTEAQ+3lg;
	25:opbQZs8kYcYoJXe3foBoGsGXABZd6KaxYbK6qcnrvSKaczvVh7mgCKABiE6ZW0JDyJP4rkaxOES2ooQEQ4ttD546IZX4gsIh7/Ycwv1Jm/BWlIuvr8CLWp71mrGkzmqFmvFCv8A0GpLdm1SfSKZzksq227bmAeQPdh+OonA4M5N3DtRe9qOAuEqeFPk3W0kC/4SlGDp7NV8uiWyEgwti88ghpr7wZjeZTBqLLFl4tZ5mhP2Zfq++yuW+JtqElJCK9cekHbkSuwmMnIWHTj0I5x64cYeAojkf6zQiFOCBNo/cOxwFjW4StZwTZmgEGcO5d7YLnuhD+LlI0QowZYjCXRZXLHaaVplESo1xXaJ1qhc=;
	31:PqenG1l/m6v7RXIAFMMJX9sNOvYMrjkxgyrbFypp6VkZrMsz3J19aK2iGOE+s4pL/m00w5Cpl4wvO9CqUHJV/L0ZfxZPwYPJC6YrCAY++nEe9hzhykPHnKCU6gz76bpt4ZVYvmOdU3/insa7+Mp9wV2jI6diZtU3W/uRllILdgiaXKWGz6LIlxqd2yYcNVksxEVrlJR4bzBAwCB9XTozMSOVmWYVOMExMY4ixZxUkvA=
X-MS-TrafficTypeDiagnostic: CO1PR15MB1079:
X-Microsoft-Exchange-Diagnostics: 1; CO1PR15MB1079;
	20:6dzaul7K/SYWI182MZAeK5MngAiG/acL6qtL3Mv36XKlqbzbbvmsBNn91xbHUQSGyxW4YlybOo0CMMwqT4t20XR4MTmmtb0uhVHp9nvKAJ1RLkGe3miWNhh2V5McBnmB3vVl2ZsR/KJ5+IjoGKq7SNyEbegcSultTNjTsYi60Fb7t/Ix1t7650M8AZjtrzXr+V6VAM4aXbeq+oENpDfZzA56bY2TszuIyojwqYIrns+rd1Bkr/vLII7B6h8u3wBUnYFUUvDqd+enwEdeLzFtC/Ox2x9NkgcsdQ4k48UTDB26vIz4EbzwfTNpCrUUQRa7l692TDa117AV3hQPGRYp0QFx/2oWYMFv86oUky86lZsi4F8nr7KEaiLo2AWt86XHPzUBs9YbHJ6FI8ylh/06ZzX4RDTkAZvmPBHyuwqZqoKGI9BRmiH0QDGPTwA2ODEhc1XqIbn0wWA3hE4c5O6HsYWMjPRrSDn0oBiPnMH0/MN3lNne+f5mD4t//KFREfrA
X-Microsoft-Antispam-PRVS: &lt;CO1PR15MB1079957E8EC021D33C6CD230BE290@CO1PR15MB1079.namprd15.prod.outlook.com&gt;
X-Exchange-Antispam-Report-Test: UriScan:(9452136761055)(67672495146484)(211936372134217)(153496737603132)(104084551191319)(146099531331640)(228905959029699);
X-Exchange-Antispam-Report-CFA-Test: BCL:0; PCL:0;
	RULEID:(100000700101)(100105000095)(100000701101)(100105300095)(100000702101)(100105100095)(11241501159)(6040450)(2401047)(5005006)(8121501046)(93006095)(93001095)(100000703101)(100105400095)(3002001)(10201501046)(3231022)(920507027)(6041248)(20161123560025)(20161123558100)(201703131423075)(201702281528075)(201703061421075)(201703061406153)(20161123562025)(20161123555025)(20161123564025)(6072148)(201708071742011)(100000704101)(100105200095)(100000705101)(100105500095);
	SRVR:CO1PR15MB1079; BCL:0; PCL:0;
	RULEID:(100000800101)(100110000095)(100000801101)(100110300095)(100000802101)(100110100095)(100000803101)(100110400095)(100000804101)(100110200095)(100000805101)(100110500095);
	SRVR:CO1PR15MB1079; 
X-Microsoft-Exchange-Diagnostics: 1; CO1PR15MB1079;
	4:hWIhEpettEndw+wJvjppNcRgSjexQBQO4+9vKfaZG5QhqxWKlabc45h029ptwWbR6o45IpfB/Gg9uIJfeEYUSDv6KqrM2n/7cOqkVBbISQltNQJRCZ30nAmXGOzGI2qfe6nF2gnAnNWxSBAT2JotPxawxH/Ird6MppK1KV0s4GmmdSWsgF5ODeHAJwbco2MkQbrZq/57pDYqa9UcydNwhUcWTDkeA84U7c1CNL2yaQzyY6Sto5uKA1WeGXtT52304mQGGh4j8lRRq5jdcVz3IA5lUJ/1IHYxs7qrKUQ4ZboCCWITz9l+iNBhfkET57pwmcDAIy27uy1wZdAnxGJQbbuuw/4KeIhVbH265CElah9rlGGttm3gVYc+ICT5gp2NGqWR3sGRBTkRSzNjTWymqfbJQsK3T/aAHYAw1MnI5iKVjbtMs4CI20XwhDaErarhQlZQqphv6oc+HKjai7VaKd8V3a/sE1BJ4aiTgKiQJK88MchpHMmsgvG0OnRUQ+YTQEsKK2aXYxzT/tZE1KvdfA==
X-Forefront-PRVS: 0492FD61DD
X-Forefront-Antispam-Report: SFV:NSPM;
	SFS:(10019020)(6009001)(346002)(376002)(199003)(189002)(54906003)(189998001)(50986999)(4326008)(478600001)(33646002)(25786009)(6486002)(305945005)(1076002)(6116002)(86362001)(106356001)(2351001)(2361001)(105586002)(5003940100001)(50226002)(34040400001)(101416001)(7736002)(316002)(53416004)(8676002)(69596002)(81166006)(81156014)(68736007)(6506006)(36756003)(48376002)(97736004)(6916009)(8936002)(16586007)(53936002)(50466002)(6666003)(6512007)(7416002)(47776003)(2906002)(5660300001)(21314002)(42262002);
	DIR:OUT; SFP:1102; SCL:1; SRVR:CO1PR15MB1079;
	H:castle.thefacebook.com; FPR:; SPF:None; PTR:InfoNoRecords;
	A:1; MX:1; LANG:en; 
Received-SPF: None (protection.outlook.com: fb.com does not designate
	permitted sender hosts)
X-Microsoft-Exchange-Diagnostics: =?us-ascii?Q?1; CO1PR15MB1079;
	23:P9Ph3CxwLLOLd9iDZphx0Xi/haSEcrLoHUN9VZJQH?=
	=?us-ascii?Q?xsQmrbubZJeq5Pe5JrUHnlXsGwvCRX/bg2S1Xt7lwJQJONFrtKJFMcpoRf4Q?=
	=?us-ascii?Q?/KFXYMMkpJD2KMOxeqp6ztf6utm4CPOv09EXUwXjOQ8jjsWBn6tsryeDRry4?=
	=?us-ascii?Q?27fS+FrrluKYEin5ylkGhDbvTogXFqb5BWJ9qg6J2mEn+NrIrWzfXk7JvpJG?=
	=?us-ascii?Q?Hkut+Cu+cJuWAVhLaoxJa6PK7O/7IoG5zQIvWW6HlBq7HArT5qXBhyLJQJRo?=
	=?us-ascii?Q?2TErSq8YVYvkfWKB+WorfIiR7+5uUimYM+qDX/p5xGe9ypBRSn7I2u2jxuWA?=
	=?us-ascii?Q?DW3TxbDdpTWFTyZI5brGhsDq+fJIPjtuKxxFAWr+Te7/nMGNa0Im1PaptVAI?=
	=?us-ascii?Q?FVgeapkZBj6Kg4pWvdMegGpumZEtEGM8//Uw46ZSqIhEbKYfzKf8QVc8OAOk?=
	=?us-ascii?Q?Jk3wkSdyQZfTcYXbzTvvH47xOQsAY8YQzc5BAfRX76vvijw6MMjAD6ddLlG+?=
	=?us-ascii?Q?ZY0Gy7giey95/xEOYzC/RGtiXVKVlAXKHgLymDZImYaZZIbCOBHRKF3cCxmB?=
	=?us-ascii?Q?h0d+hLoPjFN8SRZPldpSoSNasvHnsi8GYv6t6IQB7jSI+ajxYuSl408Dtr+e?=
	=?us-ascii?Q?C1SWccy3BKYYsCS/MFoS/2/IWntef0X4shC9seranEQySky+pcoQGMCyz2B5?=
	=?us-ascii?Q?5zZZVy3czPpSSXQnLDtvWVH3xBjdopZl/hYuuDDN5tEmEmH1w9/yXe3cdL6N?=
	=?us-ascii?Q?809vN734slcQi47bl4h5I4VpfH1Hf0yfbFjUxsOhh6Z5yGLJeLehKp7deVii?=
	=?us-ascii?Q?uieiJYcx82ahlL7bOBTcEC9NYWzmIU5h1fWtba2X8xur4rLkIyTWpSdz8dtc?=
	=?us-ascii?Q?tJQULEjXzxwEc0g1FNeS42makGQtKrClwAevI89tDwdj5KMlRPozvMg9KlAg?=
	=?us-ascii?Q?0Vs0BTjD+GpCrJIi44eF/7vO9otJhz48RDpyFawHs/fTAdzmAuDzXQbAVOFx?=
	=?us-ascii?Q?g34aTYdMGfVSI2yrbAAfdvEKcahi4eDG/RgcLnBOgsf5J9y0lGO2YvQTmPAB?=
	=?us-ascii?Q?AkZcU7njsIeqmGSjLB/N/qRkyO1HFRwSSHOoV+AbiYZkc3CJ8+gjeFcxVooi?=
	=?us-ascii?Q?xjjCwpJrGKyaA5DmrR3isH4fvhHNxyldiNnNI8J0U7dfSzYYn3Hlg=3D=3D?=
X-Microsoft-Exchange-Diagnostics: 1; CO1PR15MB1079;
	6:16OOvroEMeq05UVWqsOWqPsZOJDxMIwhk1fni3KsmNPKzIh5CQWkjUd9MivdZZF4+FgRetfdlLbo121xP5Ru6PlqAnyGGxYRkl3M0N8jyppn+RCvqmAISMjFKY1yB9/zHC9fLA6Dp05uiFC93mxY5bikfUVdFhLk2UezJG/C68euVO0elPp1xdmg/RoUTjfVGqQweWs+zs0oQNv4WrcYudVmT1q6uESWeZsc3P8aWDM7SHVt328jPN/0fJ1sBVazTeWSnlS1f6g7Uz6EwOqLuIqJEaGrHwb6ryO0qAy4ZNKUN7/YIG5wTU1MFQbvfvjctbx7/EZjyWfLz+U3gWLgkABldeG31XGcLDHsKKmH8TE=;
	5:SYHQ81Uo1sV2pqmioGHxuRo00BNNvS1RlZADgSxupXiuclPhaEvKJh+y36Ei9B6LN2ktAiCd7NSWVvMKky0StbPu5jF0y1f6SckpIgc0PJEHqKxzclX1F6gizPSAwTOqXA6RNb16nh+/X2qjevFBY1x5PivCrGYqW4yGOzlzpSA=;
	24:Cb3/ct8ru7tv1h4NgT1j1NveUrBe+LcJmab8HN0G7U5+tXllN5WVdEEYGJXGQuFTIFEtPmPqqOF3ER7bg+WcHSwlUJ4MKaIRJLg0J0KdMUs=;
	7:fuH+piENATWikY5xCqKMvpy1jUoHyn9+kgfjlRokk6WOz45uc1s1NC3FCfsDE3rlFB19w+R7V4QqQloTDTsDa198dOsjoO6nofwu53S0+kH6IP1G7F3rfzxsn/vlxPeMVYpWXdt93DkRmn1is5E5CbWZeQ0CUqKGCr0aDQ4CIFNJrcjSTnJYSan/TM/9o2u24lBEOKiBpGEzFAxkoFJNkPCblw3PDLRmha4CdmgumGd0swymLOLM2ERFO21LCWw3
SpamDiagnosticOutput: 1:99
SpamDiagnosticMetadata: NSPM
X-Microsoft-Exchange-Diagnostics: 1; CO1PR15MB1079;
	20:XkZ9HrqPsUXsvlDhTkRQVfMNV119KvtizcmJiH8PAy060LXkCDJwAeNr/E7AL2o3w3x7/Y2z0SLOMiFaZl1rrLV9i6dGiOhhFNr6YVzl3KdlbQTwptf0ZK4voA5GmhFvdRy9xo8gb2I/VH/8nmba2a8knzK6tnmSc/T5/rzJf5g=
X-MS-Exchange-CrossTenant-OriginalArrivalTime: 15 Nov 2017 23:14:33.6709
	(UTC)
X-MS-Exchange-CrossTenant-Network-Message-Id: 90877b80-d4a5-48b8-691d-08d52c7ea482
X-MS-Exchange-CrossTenant-FromEntityHeader: Hosted
X-MS-Exchange-CrossTenant-Id: 8ae927fe-1255-47a7-a2af-5f3a069daaa2
X-MS-Exchange-Transport-CrossTenantHeadersStamped: CO1PR15MB1079
X-OriginatorOrg: fb.com
X-Proofpoint-Virus-Version: vendor=fsecure engine=2.50.10432:, ,
	definitions=2017-11-15_11:, , signatures=0
X-Proofpoint-Spam-Reason: safe
X-FB-Internal: Safe
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=174271">Roman Gushchin</a> - Nov. 15, 2017, 11:14 p.m.</div>
<pre class="content">
Currently we display some hugepage statistics (total, free, etc)
in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).

If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),
/proc/meminfo output can be confusing, as non-default sized hugepages
are not reflected at all, and there are no signs that they are
existing and consuming system memory.

To solve this problem, let&#39;s display the total amount of memory,
consumed by hugetlb pages of all sized (both free and used).
Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic
/proc/meminfo style.

For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):
  $ cat /proc/meminfo
  MemTotal:        8168984 kB
  MemFree:         3789276 kB
  &lt;...&gt;
  CmaFree:               0 kB
  HugePages_Total:    1024
  HugePages_Free:     1024
  HugePages_Rsvd:        0
  HugePages_Surp:        0
  Hugepagesize:       2048 kB
  Hugetlb:         4194304 kB
  DirectMap4k:       32632 kB
  DirectMap2M:     4161536 kB
  DirectMap1G:     6291456 kB

Also, this patch updates corresponding docs to reflect
Hugetlb entry meaning and difference between Hugetlb and
HugePages_Total * Hugepagesize.
<span class="signed-off-by">
Signed-off-by: Roman Gushchin &lt;guro@fb.com&gt;</span>
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;
Cc: Michal Hocko &lt;mhocko@suse.com&gt;
Cc: Johannes Weiner &lt;hannes@cmpxchg.org&gt;
Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;
Cc: &quot;Aneesh Kumar K.V&quot; &lt;aneesh.kumar@linux.vnet.ibm.com&gt;
Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;
Cc: Dave Hansen &lt;dave.hansen@intel.com&gt;
Cc: David Rientjes &lt;rientjes@google.com&gt;
Cc: kernel-team@fb.com
Cc: linux-mm@kvack.org
Cc: linux-kernel@vger.kernel.org
---
 Documentation/vm/hugetlbpage.txt | 27 ++++++++++++++++++---------
 mm/hugetlb.c                     | 36 ++++++++++++++++++++++++------------
 2 files changed, 42 insertions(+), 21 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Nov. 16, 2017, 9:11 a.m.</div>
<pre class="content">
On Wed 15-11-17 23:14:09, Roman Gushchin wrote:
<span class="quote">&gt; Currently we display some hugepage statistics (total, free, etc)</span>
<span class="quote">&gt; in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),</span>
<span class="quote">&gt; /proc/meminfo output can be confusing, as non-default sized hugepages</span>
<span class="quote">&gt; are not reflected at all, and there are no signs that they are</span>
<span class="quote">&gt; existing and consuming system memory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; To solve this problem, let&#39;s display the total amount of memory,</span>
<span class="quote">&gt; consumed by hugetlb pages of all sized (both free and used).</span>
<span class="quote">&gt; Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic</span>
<span class="quote">&gt; /proc/meminfo style.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):</span>
<span class="quote">&gt;   $ cat /proc/meminfo</span>
<span class="quote">&gt;   MemTotal:        8168984 kB</span>
<span class="quote">&gt;   MemFree:         3789276 kB</span>
<span class="quote">&gt;   &lt;...&gt;</span>
<span class="quote">&gt;   CmaFree:               0 kB</span>
<span class="quote">&gt;   HugePages_Total:    1024</span>
<span class="quote">&gt;   HugePages_Free:     1024</span>
<span class="quote">&gt;   HugePages_Rsvd:        0</span>
<span class="quote">&gt;   HugePages_Surp:        0</span>
<span class="quote">&gt;   Hugepagesize:       2048 kB</span>
<span class="quote">&gt;   Hugetlb:         4194304 kB</span>
<span class="quote">&gt;   DirectMap4k:       32632 kB</span>
<span class="quote">&gt;   DirectMap2M:     4161536 kB</span>
<span class="quote">&gt;   DirectMap1G:     6291456 kB</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also, this patch updates corresponding docs to reflect</span>
<span class="quote">&gt; Hugetlb entry meaning and difference between Hugetlb and</span>
<span class="quote">&gt; HugePages_Total * Hugepagesize.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Roman Gushchin &lt;guro@fb.com&gt;</span>
<span class="quote">&gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; Cc: Johannes Weiner &lt;hannes@cmpxchg.org&gt;</span>
<span class="quote">&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt; Cc: &quot;Aneesh Kumar K.V&quot; &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen &lt;dave.hansen@intel.com&gt;</span>
<span class="quote">&gt; Cc: David Rientjes &lt;rientjes@google.com&gt;</span>
<span class="quote">&gt; Cc: kernel-team@fb.com</span>
<span class="quote">&gt; Cc: linux-mm@kvack.org</span>
<span class="quote">&gt; Cc: linux-kernel@vger.kernel.org</span>
<span class="acked-by">
Acked-by: Michal Hocko &lt;mhocko@suse.com&gt;</span>

Thanks!
<span class="quote">
&gt; ---</span>
<span class="quote">&gt;  Documentation/vm/hugetlbpage.txt | 27 ++++++++++++++++++---------</span>
<span class="quote">&gt;  mm/hugetlb.c                     | 36 ++++++++++++++++++++++++------------</span>
<span class="quote">&gt;  2 files changed, 42 insertions(+), 21 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/Documentation/vm/hugetlbpage.txt b/Documentation/vm/hugetlbpage.txt</span>
<span class="quote">&gt; index 59cbc803aad6..faf077d50d42 100644</span>
<span class="quote">&gt; --- a/Documentation/vm/hugetlbpage.txt</span>
<span class="quote">&gt; +++ b/Documentation/vm/hugetlbpage.txt</span>
<span class="quote">&gt; @@ -20,19 +20,20 @@ options.</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  The /proc/meminfo file provides information about the total number of</span>
<span class="quote">&gt;  persistent hugetlb pages in the kernel&#39;s huge page pool.  It also displays</span>
<span class="quote">&gt; -information about the number of free, reserved and surplus huge pages and the</span>
<span class="quote">&gt; -default huge page size.  The huge page size is needed for generating the</span>
<span class="quote">&gt; -proper alignment and size of the arguments to system calls that map huge page</span>
<span class="quote">&gt; -regions.</span>
<span class="quote">&gt; +default huge page size and information about the number of free, reserved</span>
<span class="quote">&gt; +and surplus huge pages in the pool of huge pages of default size.</span>
<span class="quote">&gt; +The huge page size is needed for generating the proper alignment and</span>
<span class="quote">&gt; +size of the arguments to system calls that map huge page regions.</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  The output of &quot;cat /proc/meminfo&quot; will include lines like:</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  .....</span>
<span class="quote">&gt; -HugePages_Total: vvv</span>
<span class="quote">&gt; -HugePages_Free:  www</span>
<span class="quote">&gt; -HugePages_Rsvd:  xxx</span>
<span class="quote">&gt; -HugePages_Surp:  yyy</span>
<span class="quote">&gt; -Hugepagesize:    zzz kB</span>
<span class="quote">&gt; +HugePages_Total: uuu</span>
<span class="quote">&gt; +HugePages_Free:  vvv</span>
<span class="quote">&gt; +HugePages_Rsvd:  www</span>
<span class="quote">&gt; +HugePages_Surp:  xxx</span>
<span class="quote">&gt; +Hugepagesize:    yyy kB</span>
<span class="quote">&gt; +Hugetlb:         zzz kB</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  where:</span>
<span class="quote">&gt;  HugePages_Total is the size of the pool of huge pages.</span>
<span class="quote">&gt; @@ -47,6 +48,14 @@ HugePages_Surp  is short for &quot;surplus,&quot; and is the number of huge pages in</span>
<span class="quote">&gt;                  the pool above the value in /proc/sys/vm/nr_hugepages. The</span>
<span class="quote">&gt;                  maximum number of surplus huge pages is controlled by</span>
<span class="quote">&gt;                  /proc/sys/vm/nr_overcommit_hugepages.</span>
<span class="quote">&gt; +Hugepagesize    is the default hugepage size (in Kb).</span>
<span class="quote">&gt; +Hugetlb         is the total amount of memory (in kB), consumed by huge</span>
<span class="quote">&gt; +                pages of all sizes.</span>
<span class="quote">&gt; +                If huge pages of different sizes are in use, this number</span>
<span class="quote">&gt; +                will exceed HugePages_Total * Hugepagesize. To get more</span>
<span class="quote">&gt; +                detailed information, please, refer to</span>
<span class="quote">&gt; +                /sys/kernel/mm/hugepages (described below).</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  /proc/filesystems should also show a filesystem of type &quot;hugetlbfs&quot; configured</span>
<span class="quote">&gt;  in the kernel.</span>
<span class="quote">&gt; diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="quote">&gt; index 4b3bbd2980bb..672377e6de9f 100644</span>
<span class="quote">&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -2973,20 +2973,32 @@ int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  void hugetlb_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	struct hstate *h = &amp;default_hstate;</span>
<span class="quote">&gt; +	struct hstate *h;</span>
<span class="quote">&gt; +	unsigned long total = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	if (!hugepages_supported())</span>
<span class="quote">&gt;  		return;</span>
<span class="quote">&gt; -	seq_printf(m,</span>
<span class="quote">&gt; -			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; -			h-&gt;nr_huge_pages,</span>
<span class="quote">&gt; -			h-&gt;free_huge_pages,</span>
<span class="quote">&gt; -			h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; -			h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; -			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for_each_hstate(h) {</span>
<span class="quote">&gt; +		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; +			seq_printf(m,</span>
<span class="quote">&gt; +				   &quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; +				   count,</span>
<span class="quote">&gt; +				   h-&gt;free_huge_pages,</span>
<span class="quote">&gt; +				   h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; +				   h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; +				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  int hugetlb_report_node_meminfo(int nid, char *buf)</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.13.6</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45">Johannes Weiner</a> - Nov. 16, 2017, 2:22 p.m.</div>
<pre class="content">
On Wed, Nov 15, 2017 at 11:14:09PM +0000, Roman Gushchin wrote:
<span class="quote">&gt; Currently we display some hugepage statistics (total, free, etc)</span>
<span class="quote">&gt; in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),</span>
<span class="quote">&gt; /proc/meminfo output can be confusing, as non-default sized hugepages</span>
<span class="quote">&gt; are not reflected at all, and there are no signs that they are</span>
<span class="quote">&gt; existing and consuming system memory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; To solve this problem, let&#39;s display the total amount of memory,</span>
<span class="quote">&gt; consumed by hugetlb pages of all sized (both free and used).</span>
<span class="quote">&gt; Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic</span>
<span class="quote">&gt; /proc/meminfo style.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):</span>
<span class="quote">&gt;   $ cat /proc/meminfo</span>
<span class="quote">&gt;   MemTotal:        8168984 kB</span>
<span class="quote">&gt;   MemFree:         3789276 kB</span>
<span class="quote">&gt;   &lt;...&gt;</span>
<span class="quote">&gt;   CmaFree:               0 kB</span>
<span class="quote">&gt;   HugePages_Total:    1024</span>
<span class="quote">&gt;   HugePages_Free:     1024</span>
<span class="quote">&gt;   HugePages_Rsvd:        0</span>
<span class="quote">&gt;   HugePages_Surp:        0</span>
<span class="quote">&gt;   Hugepagesize:       2048 kB</span>
<span class="quote">&gt;   Hugetlb:         4194304 kB</span>
<span class="quote">&gt;   DirectMap4k:       32632 kB</span>
<span class="quote">&gt;   DirectMap2M:     4161536 kB</span>
<span class="quote">&gt;   DirectMap1G:     6291456 kB</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also, this patch updates corresponding docs to reflect</span>
<span class="quote">&gt; Hugetlb entry meaning and difference between Hugetlb and</span>
<span class="quote">&gt; HugePages_Total * Hugepagesize.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Roman Gushchin &lt;guro@fb.com&gt;</span>
<span class="quote">&gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; Cc: Johannes Weiner &lt;hannes@cmpxchg.org&gt;</span>
<span class="quote">&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt; Cc: &quot;Aneesh Kumar K.V&quot; &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen &lt;dave.hansen@intel.com&gt;</span>
<span class="quote">&gt; Cc: David Rientjes &lt;rientjes@google.com&gt;</span>
<span class="quote">&gt; Cc: kernel-team@fb.com</span>
<span class="quote">&gt; Cc: linux-mm@kvack.org</span>
<span class="quote">&gt; Cc: linux-kernel@vger.kernel.org</span>
<span class="acked-by">
Acked-by: Johannes Weiner &lt;hannes@cmpxchg.org&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=579">David Rientjes</a> - Nov. 17, 2017, 9:41 a.m.</div>
<pre class="content">
On Wed, 15 Nov 2017, Roman Gushchin wrote:
<span class="quote">
&gt; Currently we display some hugepage statistics (total, free, etc)</span>
<span class="quote">&gt; in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),</span>
<span class="quote">&gt; /proc/meminfo output can be confusing, as non-default sized hugepages</span>
<span class="quote">&gt; are not reflected at all, and there are no signs that they are</span>
<span class="quote">&gt; existing and consuming system memory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; To solve this problem, let&#39;s display the total amount of memory,</span>
<span class="quote">&gt; consumed by hugetlb pages of all sized (both free and used).</span>
<span class="quote">&gt; Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic</span>
<span class="quote">&gt; /proc/meminfo style.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):</span>
<span class="quote">&gt;   $ cat /proc/meminfo</span>
<span class="quote">&gt;   MemTotal:        8168984 kB</span>
<span class="quote">&gt;   MemFree:         3789276 kB</span>
<span class="quote">&gt;   &lt;...&gt;</span>
<span class="quote">&gt;   CmaFree:               0 kB</span>
<span class="quote">&gt;   HugePages_Total:    1024</span>
<span class="quote">&gt;   HugePages_Free:     1024</span>
<span class="quote">&gt;   HugePages_Rsvd:        0</span>
<span class="quote">&gt;   HugePages_Surp:        0</span>
<span class="quote">&gt;   Hugepagesize:       2048 kB</span>
<span class="quote">&gt;   Hugetlb:         4194304 kB</span>
<span class="quote">&gt;   DirectMap4k:       32632 kB</span>
<span class="quote">&gt;   DirectMap2M:     4161536 kB</span>
<span class="quote">&gt;   DirectMap1G:     6291456 kB</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also, this patch updates corresponding docs to reflect</span>
<span class="quote">&gt; Hugetlb entry meaning and difference between Hugetlb and</span>
<span class="quote">&gt; HugePages_Total * Hugepagesize.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Roman Gushchin &lt;guro@fb.com&gt;</span>
<span class="quote">&gt; Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;</span>
<span class="quote">&gt; Cc: Michal Hocko &lt;mhocko@suse.com&gt;</span>
<span class="quote">&gt; Cc: Johannes Weiner &lt;hannes@cmpxchg.org&gt;</span>
<span class="quote">&gt; Cc: Mike Kravetz &lt;mike.kravetz@oracle.com&gt;</span>
<span class="quote">&gt; Cc: &quot;Aneesh Kumar K.V&quot; &lt;aneesh.kumar@linux.vnet.ibm.com&gt;</span>
<span class="quote">&gt; Cc: Andrea Arcangeli &lt;aarcange@redhat.com&gt;</span>
<span class="quote">&gt; Cc: Dave Hansen &lt;dave.hansen@intel.com&gt;</span>
<span class="quote">&gt; Cc: David Rientjes &lt;rientjes@google.com&gt;</span>
<span class="quote">&gt; Cc: kernel-team@fb.com</span>
<span class="quote">&gt; Cc: linux-mm@kvack.org</span>
<span class="quote">&gt; Cc: linux-kernel@vger.kernel.org</span>
<span class="acked-by">
Acked-by: David Rientjes &lt;rientjes@google.com&gt;</span>

Nice!
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41">Andrew Morton</a> - Nov. 21, 2017, 12:51 a.m.</div>
<pre class="content">
On Wed, 15 Nov 2017 23:14:09 +0000 Roman Gushchin &lt;guro@fb.com&gt; wrote:
<span class="quote">
&gt; Currently we display some hugepage statistics (total, free, etc)</span>
<span class="quote">&gt; in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),</span>
<span class="quote">&gt; /proc/meminfo output can be confusing, as non-default sized hugepages</span>
<span class="quote">&gt; are not reflected at all, and there are no signs that they are</span>
<span class="quote">&gt; existing and consuming system memory.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; To solve this problem, let&#39;s display the total amount of memory,</span>
<span class="quote">&gt; consumed by hugetlb pages of all sized (both free and used).</span>
<span class="quote">&gt; Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic</span>
<span class="quote">&gt; /proc/meminfo style.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):</span>
<span class="quote">&gt;   $ cat /proc/meminfo</span>
<span class="quote">&gt;   MemTotal:        8168984 kB</span>
<span class="quote">&gt;   MemFree:         3789276 kB</span>
<span class="quote">&gt;   &lt;...&gt;</span>
<span class="quote">&gt;   CmaFree:               0 kB</span>
<span class="quote">&gt;   HugePages_Total:    1024</span>
<span class="quote">&gt;   HugePages_Free:     1024</span>
<span class="quote">&gt;   HugePages_Rsvd:        0</span>
<span class="quote">&gt;   HugePages_Surp:        0</span>
<span class="quote">&gt;   Hugepagesize:       2048 kB</span>
<span class="quote">&gt;   Hugetlb:         4194304 kB</span>
<span class="quote">&gt;   DirectMap4k:       32632 kB</span>
<span class="quote">&gt;   DirectMap2M:     4161536 kB</span>
<span class="quote">&gt;   DirectMap1G:     6291456 kB</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Also, this patch updates corresponding docs to reflect</span>
<span class="quote">&gt; Hugetlb entry meaning and difference between Hugetlb and</span>
<span class="quote">&gt; HugePages_Total * Hugepagesize.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -2973,20 +2973,32 @@ int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  void hugetlb_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; -	struct hstate *h = &amp;default_hstate;</span>
<span class="quote">&gt; +	struct hstate *h;</span>
<span class="quote">&gt; +	unsigned long total = 0;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  	if (!hugepages_supported())</span>
<span class="quote">&gt;  		return;</span>
<span class="quote">&gt; -	seq_printf(m,</span>
<span class="quote">&gt; -			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; -			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; -			h-&gt;nr_huge_pages,</span>
<span class="quote">&gt; -			h-&gt;free_huge_pages,</span>
<span class="quote">&gt; -			h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; -			h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; -			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for_each_hstate(h) {</span>
<span class="quote">&gt; +		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (h == &amp;default_hstate)</span>

I&#39;m not understanding this test.  Are we assuming that default_hstate
always refers to the highest-index hstate?  If so why, and is that
valid?
<span class="quote">
&gt; +			seq_printf(m,</span>
<span class="quote">&gt; +				   &quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; +				   &quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; +				   count,</span>
<span class="quote">&gt; +				   h-&gt;free_huge_pages,</span>
<span class="quote">&gt; +				   h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; +				   h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; +				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt;  }</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=124511">Mike Kravetz</a> - Nov. 21, 2017, 1:09 a.m.</div>
<pre class="content">
On 11/20/2017 04:51 PM, Andrew Morton wrote:
<span class="quote">&gt; On Wed, 15 Nov 2017 23:14:09 +0000 Roman Gushchin &lt;guro@fb.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;&gt; Currently we display some hugepage statistics (total, free, etc)</span>
<span class="quote">&gt;&gt; in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),</span>
<span class="quote">&gt;&gt; /proc/meminfo output can be confusing, as non-default sized hugepages</span>
<span class="quote">&gt;&gt; are not reflected at all, and there are no signs that they are</span>
<span class="quote">&gt;&gt; existing and consuming system memory.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; To solve this problem, let&#39;s display the total amount of memory,</span>
<span class="quote">&gt;&gt; consumed by hugetlb pages of all sized (both free and used).</span>
<span class="quote">&gt;&gt; Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic</span>
<span class="quote">&gt;&gt; /proc/meminfo style.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):</span>
<span class="quote">&gt;&gt;   $ cat /proc/meminfo</span>
<span class="quote">&gt;&gt;   MemTotal:        8168984 kB</span>
<span class="quote">&gt;&gt;   MemFree:         3789276 kB</span>
<span class="quote">&gt;&gt;   &lt;...&gt;</span>
<span class="quote">&gt;&gt;   CmaFree:               0 kB</span>
<span class="quote">&gt;&gt;   HugePages_Total:    1024</span>
<span class="quote">&gt;&gt;   HugePages_Free:     1024</span>
<span class="quote">&gt;&gt;   HugePages_Rsvd:        0</span>
<span class="quote">&gt;&gt;   HugePages_Surp:        0</span>
<span class="quote">&gt;&gt;   Hugepagesize:       2048 kB</span>
<span class="quote">&gt;&gt;   Hugetlb:         4194304 kB</span>
<span class="quote">&gt;&gt;   DirectMap4k:       32632 kB</span>
<span class="quote">&gt;&gt;   DirectMap2M:     4161536 kB</span>
<span class="quote">&gt;&gt;   DirectMap1G:     6291456 kB</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Also, this patch updates corresponding docs to reflect</span>
<span class="quote">&gt;&gt; Hugetlb entry meaning and difference between Hugetlb and</span>
<span class="quote">&gt;&gt; HugePages_Total * Hugepagesize.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; ...</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt;&gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt;&gt; @@ -2973,20 +2973,32 @@ int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
<span class="quote">&gt;&gt;  </span>
<span class="quote">&gt;&gt;  void hugetlb_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt;&gt;  {</span>
<span class="quote">&gt;&gt; -	struct hstate *h = &amp;default_hstate;</span>
<span class="quote">&gt;&gt; +	struct hstate *h;</span>
<span class="quote">&gt;&gt; +	unsigned long total = 0;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;  	if (!hugepages_supported())</span>
<span class="quote">&gt;&gt;  		return;</span>
<span class="quote">&gt;&gt; -	seq_printf(m,</span>
<span class="quote">&gt;&gt; -			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt;&gt; -			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt;&gt; -			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt;&gt; -			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt;&gt; -			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt; -			h-&gt;nr_huge_pages,</span>
<span class="quote">&gt;&gt; -			h-&gt;free_huge_pages,</span>
<span class="quote">&gt;&gt; -			h-&gt;resv_huge_pages,</span>
<span class="quote">&gt;&gt; -			h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt;&gt; -			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	for_each_hstate(h) {</span>
<span class="quote">&gt;&gt; +		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m not understanding this test.  Are we assuming that default_hstate</span>
<span class="quote">&gt; always refers to the highest-index hstate?  If so why, and is that</span>
<span class="quote">&gt; valid?</span>

Actually default_hstate is defined as:

#define default_hstate (hstates[default_hstate_idx])

default_hstate_idx is set during hugetlb_init based upon default_hstate_size
which defaults to HPAGE_SIZE.  However, it can be overridden by the kernel
command line argument &quot;default_hugepagesz=&lt;size&gt;&quot;.

By definition and history /proc/meminfo lists information on the default
huge page size.  This code is looping through all hstates to get the total
memory consumed by hugetlb pages for the new &quot;Hugetlb&quot; field.  When it gets
to the default huge page size, it prints the historic fields.

Hope that helps,
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Nov. 21, 2017, 7:01 a.m.</div>
<pre class="content">
On Mon 20-11-17 16:51:10, Andrew Morton wrote:
<span class="quote">&gt; On Wed, 15 Nov 2017 23:14:09 +0000 Roman Gushchin &lt;guro@fb.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Currently we display some hugepage statistics (total, free, etc)</span>
<span class="quote">&gt; &gt; in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),</span>
<span class="quote">&gt; &gt; /proc/meminfo output can be confusing, as non-default sized hugepages</span>
<span class="quote">&gt; &gt; are not reflected at all, and there are no signs that they are</span>
<span class="quote">&gt; &gt; existing and consuming system memory.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; To solve this problem, let&#39;s display the total amount of memory,</span>
<span class="quote">&gt; &gt; consumed by hugetlb pages of all sized (both free and used).</span>
<span class="quote">&gt; &gt; Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic</span>
<span class="quote">&gt; &gt; /proc/meminfo style.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):</span>
<span class="quote">&gt; &gt;   $ cat /proc/meminfo</span>
<span class="quote">&gt; &gt;   MemTotal:        8168984 kB</span>
<span class="quote">&gt; &gt;   MemFree:         3789276 kB</span>
<span class="quote">&gt; &gt;   &lt;...&gt;</span>
<span class="quote">&gt; &gt;   CmaFree:               0 kB</span>
<span class="quote">&gt; &gt;   HugePages_Total:    1024</span>
<span class="quote">&gt; &gt;   HugePages_Free:     1024</span>
<span class="quote">&gt; &gt;   HugePages_Rsvd:        0</span>
<span class="quote">&gt; &gt;   HugePages_Surp:        0</span>
<span class="quote">&gt; &gt;   Hugepagesize:       2048 kB</span>
<span class="quote">&gt; &gt;   Hugetlb:         4194304 kB</span>
<span class="quote">&gt; &gt;   DirectMap4k:       32632 kB</span>
<span class="quote">&gt; &gt;   DirectMap2M:     4161536 kB</span>
<span class="quote">&gt; &gt;   DirectMap1G:     6291456 kB</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Also, this patch updates corresponding docs to reflect</span>
<span class="quote">&gt; &gt; Hugetlb entry meaning and difference between Hugetlb and</span>
<span class="quote">&gt; &gt; HugePages_Total * Hugepagesize.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; ...</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; &gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; &gt; @@ -2973,20 +2973,32 @@ int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  void hugetlb_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; -	struct hstate *h = &amp;default_hstate;</span>
<span class="quote">&gt; &gt; +	struct hstate *h;</span>
<span class="quote">&gt; &gt; +	unsigned long total = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  	if (!hugepages_supported())</span>
<span class="quote">&gt; &gt;  		return;</span>
<span class="quote">&gt; &gt; -	seq_printf(m,</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt; -			h-&gt;nr_huge_pages,</span>
<span class="quote">&gt; &gt; -			h-&gt;free_huge_pages,</span>
<span class="quote">&gt; &gt; -			h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; &gt; -			h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; &gt; -			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	for_each_hstate(h) {</span>
<span class="quote">&gt; &gt; +		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m not understanding this test.  Are we assuming that default_hstate</span>
<span class="quote">&gt; always refers to the highest-index hstate?  If so why, and is that</span>
<span class="quote">&gt; valid?</span>

The whole point of this checks is to provide hugetlb detailed stats _only_
for the default hstate because that is what we have been doing
traditionally. The loop is there only to gather total amount and display
it separately.
<span class="quote">
&gt; &gt; +			seq_printf(m,</span>
<span class="quote">&gt; &gt; +				   &quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; &gt; +				   &quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; +				   &quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; +				   &quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; +				   &quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt; +				   count,</span>
<span class="quote">&gt; &gt; +				   h-&gt;free_huge_pages,</span>
<span class="quote">&gt; &gt; +				   h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; &gt; +				   h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; &gt; +				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);</span>
<span class="quote">&gt; &gt; +	}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=174271">Roman Gushchin</a> - Nov. 21, 2017, 3:15 p.m.</div>
<pre class="content">
On Mon, Nov 20, 2017 at 04:51:10PM -0800, Andrew Morton wrote:
<span class="quote">&gt; On Wed, 15 Nov 2017 23:14:09 +0000 Roman Gushchin &lt;guro@fb.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; Currently we display some hugepage statistics (total, free, etc)</span>
<span class="quote">&gt; &gt; in /proc/meminfo, but only for default hugepage size (e.g. 2Mb).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; If hugepages of different sizes are used (like 2Mb and 1Gb on x86-64),</span>
<span class="quote">&gt; &gt; /proc/meminfo output can be confusing, as non-default sized hugepages</span>
<span class="quote">&gt; &gt; are not reflected at all, and there are no signs that they are</span>
<span class="quote">&gt; &gt; existing and consuming system memory.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; To solve this problem, let&#39;s display the total amount of memory,</span>
<span class="quote">&gt; &gt; consumed by hugetlb pages of all sized (both free and used).</span>
<span class="quote">&gt; &gt; Let&#39;s call it &quot;Hugetlb&quot;, and display size in kB to match generic</span>
<span class="quote">&gt; &gt; /proc/meminfo style.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; For example, (1024 2Mb pages and 2 1Gb pages are pre-allocated):</span>
<span class="quote">&gt; &gt;   $ cat /proc/meminfo</span>
<span class="quote">&gt; &gt;   MemTotal:        8168984 kB</span>
<span class="quote">&gt; &gt;   MemFree:         3789276 kB</span>
<span class="quote">&gt; &gt;   &lt;...&gt;</span>
<span class="quote">&gt; &gt;   CmaFree:               0 kB</span>
<span class="quote">&gt; &gt;   HugePages_Total:    1024</span>
<span class="quote">&gt; &gt;   HugePages_Free:     1024</span>
<span class="quote">&gt; &gt;   HugePages_Rsvd:        0</span>
<span class="quote">&gt; &gt;   HugePages_Surp:        0</span>
<span class="quote">&gt; &gt;   Hugepagesize:       2048 kB</span>
<span class="quote">&gt; &gt;   Hugetlb:         4194304 kB</span>
<span class="quote">&gt; &gt;   DirectMap4k:       32632 kB</span>
<span class="quote">&gt; &gt;   DirectMap2M:     4161536 kB</span>
<span class="quote">&gt; &gt;   DirectMap1G:     6291456 kB</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Also, this patch updates corresponding docs to reflect</span>
<span class="quote">&gt; &gt; Hugetlb entry meaning and difference between Hugetlb and</span>
<span class="quote">&gt; &gt; HugePages_Total * Hugepagesize.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; ...</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; --- a/mm/hugetlb.c</span>
<span class="quote">&gt; &gt; +++ b/mm/hugetlb.c</span>
<span class="quote">&gt; &gt; @@ -2973,20 +2973,32 @@ int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  void hugetlb_report_meminfo(struct seq_file *m)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt; -	struct hstate *h = &amp;default_hstate;</span>
<span class="quote">&gt; &gt; +	struct hstate *h;</span>
<span class="quote">&gt; &gt; +	unsigned long total = 0;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  	if (!hugepages_supported())</span>
<span class="quote">&gt; &gt;  		return;</span>
<span class="quote">&gt; &gt; -	seq_printf(m,</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; -			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt; -			h-&gt;nr_huge_pages,</span>
<span class="quote">&gt; &gt; -			h-&gt;free_huge_pages,</span>
<span class="quote">&gt; &gt; -			h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; &gt; -			h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; &gt; -			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +	for_each_hstate(h) {</span>
<span class="quote">&gt; &gt; +		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;m not understanding this test.  Are we assuming that default_hstate</span>
<span class="quote">&gt; always refers to the highest-index hstate?  If so why, and is that</span>
<span class="quote">&gt; valid?</span>

As Mike and Michal pointed, default_hstate is defined as
  #define default_hstate (hstates[default_hstate_idx]),
where default_hstate_idx can be altered by a boot argument.

We&#39;re iterating over all states to calculate total and also
print some additional info for the default size. Having a single
loop guarantees consistency of these numbers.

Thanks!
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41">Andrew Morton</a> - Nov. 21, 2017, 7:19 p.m.</div>
<pre class="content">
On Tue, 21 Nov 2017 15:15:55 +0000 Roman Gushchin &lt;guro@fb.com&gt; wrote:
<span class="quote">
&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +	for_each_hstate(h) {</span>
<span class="quote">&gt; &gt; &gt; +		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; +		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I&#39;m not understanding this test.  Are we assuming that default_hstate</span>
<span class="quote">&gt; &gt; always refers to the highest-index hstate?  If so why, and is that</span>
<span class="quote">&gt; &gt; valid?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; As Mike and Michal pointed, default_hstate is defined as</span>
<span class="quote">&gt;   #define default_hstate (hstates[default_hstate_idx]),</span>
<span class="quote">&gt; where default_hstate_idx can be altered by a boot argument.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We&#39;re iterating over all states to calculate total and also</span>
<span class="quote">&gt; print some additional info for the default size. Having a single</span>
<span class="quote">&gt; loop guarantees consistency of these numbers.</span>
<span class="quote">&gt; </span>

OK, I misread the handling of `count&#39; -&gt; HugePages_Total.

It seems unnecessarily obscure?

	for_each_hstate(h) {
		unsigned long count = h-&gt;nr_huge_pages;

		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;

		if (h == &amp;default_hstate)
			seq_printf(m,
				   &quot;HugePages_Total:   %5lu\n&quot;
				   &quot;HugePages_Free:    %5lu\n&quot;
				   &quot;HugePages_Rsvd:    %5lu\n&quot;
				   &quot;HugePages_Surp:    %5lu\n&quot;
				   &quot;Hugepagesize:   %8lu kB\n&quot;,
				   count,
				   h-&gt;free_huge_pages,
				   h-&gt;resv_huge_pages,
				   h-&gt;surplus_huge_pages,
				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);
	}

	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);


Why not

	seq_printf(m,
			&quot;HugePages_Total:   %5lu\n&quot;
			&quot;HugePages_Free:    %5lu\n&quot;
			&quot;HugePages_Rsvd:    %5lu\n&quot;
			&quot;HugePages_Surp:    %5lu\n&quot;
			&quot;Hugepagesize:   %8lu kB\n&quot;,
			h-&gt;nr_huge_pages,
			h-&gt;free_huge_pages,
			h-&gt;resv_huge_pages,
			h-&gt;surplus_huge_pages,
			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));

	for_each_hstate(h)
		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * h-&gt;nr_huge_pages;
	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);
	
?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=174271">Roman Gushchin</a> - Nov. 21, 2017, 7:59 p.m.</div>
<pre class="content">
On Tue, Nov 21, 2017 at 11:19:07AM -0800, Andrew Morton wrote:
<span class="quote">&gt; On Tue, 21 Nov 2017 15:15:55 +0000 Roman Gushchin &lt;guro@fb.com&gt; wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; +	for_each_hstate(h) {</span>
<span class="quote">&gt; &gt; &gt; &gt; +		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; +		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; +		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I&#39;m not understanding this test.  Are we assuming that default_hstate</span>
<span class="quote">&gt; &gt; &gt; always refers to the highest-index hstate?  If so why, and is that</span>
<span class="quote">&gt; &gt; &gt; valid?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; As Mike and Michal pointed, default_hstate is defined as</span>
<span class="quote">&gt; &gt;   #define default_hstate (hstates[default_hstate_idx]),</span>
<span class="quote">&gt; &gt; where default_hstate_idx can be altered by a boot argument.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; We&#39;re iterating over all states to calculate total and also</span>
<span class="quote">&gt; &gt; print some additional info for the default size. Having a single</span>
<span class="quote">&gt; &gt; loop guarantees consistency of these numbers.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; OK, I misread the handling of `count&#39; -&gt; HugePages_Total.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It seems unnecessarily obscure?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	for_each_hstate(h) {</span>
<span class="quote">&gt; 		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; 			seq_printf(m,</span>
<span class="quote">&gt; 				   &quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; 				   count,</span>
<span class="quote">&gt; 				   h-&gt;free_huge_pages,</span>
<span class="quote">&gt; 				   h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; 				   h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; 				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);</span>
<span class="quote">&gt; 	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Why not</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	seq_printf(m,</span>
<span class="quote">&gt; 			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; 			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; 			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; 			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; 			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; 			h-&gt;nr_huge_pages,</span>
<span class="quote">&gt; 			h-&gt;free_huge_pages,</span>
<span class="quote">&gt; 			h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; 			h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; 			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	for_each_hstate(h)</span>
<span class="quote">&gt; 		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; 	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt; 	</span>
<span class="quote">&gt; ?</span>

The idea was that the local variable guarantees the consistency
between Hugetlb and HugePages_Total numbers. Otherwise we have
to take hugetlb_lock.

What we can do, is to rename &quot;count&quot; into &quot;nr_huge_pages&quot;, like:

	for_each_hstate(h) {
		unsigned long nr_huge_pages = h-&gt;nr_huge_pages;

		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * nr_huge_pages;

		if (h == &amp;default_hstate)
			seq_printf(m,
				   &quot;HugePages_Total:   %5lu\n&quot;
				   &quot;HugePages_Free:    %5lu\n&quot;
				   &quot;HugePages_Rsvd:    %5lu\n&quot;
				   &quot;HugePages_Surp:    %5lu\n&quot;
				   &quot;Hugepagesize:   %8lu kB\n&quot;,
				   nr_huge_pages,
				   h-&gt;free_huge_pages,
				   h-&gt;resv_huge_pages,
				   h-&gt;surplus_huge_pages,
				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);
	}

	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);

But maybe taking a lock is not a bad idea, because it will also
guarantee consistency between other numbers (like HugePages_Free) as well,
which is not true right now.

Thanks!
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=124511">Mike Kravetz</a> - Nov. 22, 2017, 12:27 a.m.</div>
<pre class="content">
On 11/21/2017 11:59 AM, Roman Gushchin wrote:
<span class="quote">&gt; On Tue, Nov 21, 2017 at 11:19:07AM -0800, Andrew Morton wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Why not</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 	seq_printf(m,</span>
<span class="quote">&gt;&gt; 			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt;&gt; 			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt;&gt; 			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt;&gt; 			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt;&gt; 			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt;&gt; 			h-&gt;nr_huge_pages,</span>
<span class="quote">&gt;&gt; 			h-&gt;free_huge_pages,</span>
<span class="quote">&gt;&gt; 			h-&gt;resv_huge_pages,</span>
<span class="quote">&gt;&gt; 			h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt;&gt; 			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; 	for_each_hstate(h)</span>
<span class="quote">&gt;&gt; 		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * h-&gt;nr_huge_pages;</span>
<span class="quote">&gt;&gt; 	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt;&gt; 	</span>
<span class="quote">&gt;&gt; ?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The idea was that the local variable guarantees the consistency</span>
<span class="quote">&gt; between Hugetlb and HugePages_Total numbers. Otherwise we have</span>
<span class="quote">&gt; to take hugetlb_lock.</span>

Most important it prevents HugePages_Total from being larger than 
Hugetlb.
<span class="quote">
&gt; What we can do, is to rename &quot;count&quot; into &quot;nr_huge_pages&quot;, like:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	for_each_hstate(h) {</span>
<span class="quote">&gt; 		unsigned long nr_huge_pages = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * nr_huge_pages;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; 			seq_printf(m,</span>
<span class="quote">&gt; 				   &quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; 				   &quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; 				   nr_huge_pages,</span>
<span class="quote">&gt; 				   h-&gt;free_huge_pages,</span>
<span class="quote">&gt; 				   h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; 				   h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; 				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);</span>
<span class="quote">&gt; 	}</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; But maybe taking a lock is not a bad idea, because it will also</span>
<span class="quote">&gt; guarantee consistency between other numbers (like HugePages_Free) as well,</span>
<span class="quote">&gt; which is not true right now.</span>

You are correct in that there is no consistency guarantee for the numbers
with the default huge page size today.  However, I am not really a fan of
taking the lock for that guarantee.  IMO, the above code is fine.

This discussion reminds me that ideally there should be a per-hstate lock.
My guess is that the global lock is a carry over from the days when only
a single huge page size was supported.  In practice, I don&#39;t think this is
much of an issue as people typically only use a single huge page size.  But,
if anyone thinks is/may be an issue I am happy to make the changes.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - Nov. 22, 2017, 9:10 a.m.</div>
<pre class="content">
On Tue 21-11-17 16:27:38, Mike Kravetz wrote:
<span class="quote">&gt; On 11/21/2017 11:59 AM, Roman Gushchin wrote:</span>
[...]
<span class="quote">&gt; &gt; What we can do, is to rename &quot;count&quot; into &quot;nr_huge_pages&quot;, like:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 	for_each_hstate(h) {</span>
<span class="quote">&gt; &gt; 		unsigned long nr_huge_pages = h-&gt;nr_huge_pages;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * nr_huge_pages;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 		if (h == &amp;default_hstate)</span>
<span class="quote">&gt; &gt; 			seq_printf(m,</span>
<span class="quote">&gt; &gt; 				   &quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="quote">&gt; &gt; 				   &quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; 				   &quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; 				   &quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="quote">&gt; &gt; 				   &quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt; 				   nr_huge_pages,</span>
<span class="quote">&gt; &gt; 				   h-&gt;free_huge_pages,</span>
<span class="quote">&gt; &gt; 				   h-&gt;resv_huge_pages,</span>
<span class="quote">&gt; &gt; 				   h-&gt;surplus_huge_pages,</span>
<span class="quote">&gt; &gt; 				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);</span>
<span class="quote">&gt; &gt; 	}</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; But maybe taking a lock is not a bad idea, because it will also</span>
<span class="quote">&gt; &gt; guarantee consistency between other numbers (like HugePages_Free) as well,</span>
<span class="quote">&gt; &gt; which is not true right now.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You are correct in that there is no consistency guarantee for the numbers</span>
<span class="quote">&gt; with the default huge page size today.  However, I am not really a fan of</span>
<span class="quote">&gt; taking the lock for that guarantee.  IMO, the above code is fine.</span>

I agree
<span class="quote">
&gt; This discussion reminds me that ideally there should be a per-hstate lock.</span>
<span class="quote">&gt; My guess is that the global lock is a carry over from the days when only</span>
<span class="quote">&gt; a single huge page size was supported.  In practice, I don&#39;t think this is</span>
<span class="quote">&gt; much of an issue as people typically only use a single huge page size.  But,</span>
<span class="quote">&gt; if anyone thinks is/may be an issue I am happy to make the changes.</span>

Well, it kind of makes sense but I am not sure it is worth bothering.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/vm/hugetlbpage.txt b/Documentation/vm/hugetlbpage.txt</span>
<span class="p_header">index 59cbc803aad6..faf077d50d42 100644</span>
<span class="p_header">--- a/Documentation/vm/hugetlbpage.txt</span>
<span class="p_header">+++ b/Documentation/vm/hugetlbpage.txt</span>
<span class="p_chunk">@@ -20,19 +20,20 @@</span> <span class="p_context"> options.</span>
 
 The /proc/meminfo file provides information about the total number of
 persistent hugetlb pages in the kernel&#39;s huge page pool.  It also displays
<span class="p_del">-information about the number of free, reserved and surplus huge pages and the</span>
<span class="p_del">-default huge page size.  The huge page size is needed for generating the</span>
<span class="p_del">-proper alignment and size of the arguments to system calls that map huge page</span>
<span class="p_del">-regions.</span>
<span class="p_add">+default huge page size and information about the number of free, reserved</span>
<span class="p_add">+and surplus huge pages in the pool of huge pages of default size.</span>
<span class="p_add">+The huge page size is needed for generating the proper alignment and</span>
<span class="p_add">+size of the arguments to system calls that map huge page regions.</span>
 
 The output of &quot;cat /proc/meminfo&quot; will include lines like:
 
 .....
<span class="p_del">-HugePages_Total: vvv</span>
<span class="p_del">-HugePages_Free:  www</span>
<span class="p_del">-HugePages_Rsvd:  xxx</span>
<span class="p_del">-HugePages_Surp:  yyy</span>
<span class="p_del">-Hugepagesize:    zzz kB</span>
<span class="p_add">+HugePages_Total: uuu</span>
<span class="p_add">+HugePages_Free:  vvv</span>
<span class="p_add">+HugePages_Rsvd:  www</span>
<span class="p_add">+HugePages_Surp:  xxx</span>
<span class="p_add">+Hugepagesize:    yyy kB</span>
<span class="p_add">+Hugetlb:         zzz kB</span>
 
 where:
 HugePages_Total is the size of the pool of huge pages.
<span class="p_chunk">@@ -47,6 +48,14 @@</span> <span class="p_context"> HugePages_Surp  is short for &quot;surplus,&quot; and is the number of huge pages in</span>
                 the pool above the value in /proc/sys/vm/nr_hugepages. The
                 maximum number of surplus huge pages is controlled by
                 /proc/sys/vm/nr_overcommit_hugepages.
<span class="p_add">+Hugepagesize    is the default hugepage size (in Kb).</span>
<span class="p_add">+Hugetlb         is the total amount of memory (in kB), consumed by huge</span>
<span class="p_add">+                pages of all sizes.</span>
<span class="p_add">+                If huge pages of different sizes are in use, this number</span>
<span class="p_add">+                will exceed HugePages_Total * Hugepagesize. To get more</span>
<span class="p_add">+                detailed information, please, refer to</span>
<span class="p_add">+                /sys/kernel/mm/hugepages (described below).</span>
<span class="p_add">+</span>
 
 /proc/filesystems should also show a filesystem of type &quot;hugetlbfs&quot; configured
 in the kernel.
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 4b3bbd2980bb..672377e6de9f 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -2973,20 +2973,32 @@</span> <span class="p_context"> int hugetlb_overcommit_handler(struct ctl_table *table, int write,</span>
 
 void hugetlb_report_meminfo(struct seq_file *m)
 {
<span class="p_del">-	struct hstate *h = &amp;default_hstate;</span>
<span class="p_add">+	struct hstate *h;</span>
<span class="p_add">+	unsigned long total = 0;</span>
<span class="p_add">+</span>
 	if (!hugepages_supported())
 		return;
<span class="p_del">-	seq_printf(m,</span>
<span class="p_del">-			&quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="p_del">-			&quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="p_del">-			&quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="p_del">-			&quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="p_del">-			&quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="p_del">-			h-&gt;nr_huge_pages,</span>
<span class="p_del">-			h-&gt;free_huge_pages,</span>
<span class="p_del">-			h-&gt;resv_huge_pages,</span>
<span class="p_del">-			h-&gt;surplus_huge_pages,</span>
<span class="p_del">-			1UL &lt;&lt; (huge_page_order(h) + PAGE_SHIFT - 10));</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_hstate(h) {</span>
<span class="p_add">+		unsigned long count = h-&gt;nr_huge_pages;</span>
<span class="p_add">+</span>
<span class="p_add">+		total += (PAGE_SIZE &lt;&lt; huge_page_order(h)) * count;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (h == &amp;default_hstate)</span>
<span class="p_add">+			seq_printf(m,</span>
<span class="p_add">+				   &quot;HugePages_Total:   %5lu\n&quot;</span>
<span class="p_add">+				   &quot;HugePages_Free:    %5lu\n&quot;</span>
<span class="p_add">+				   &quot;HugePages_Rsvd:    %5lu\n&quot;</span>
<span class="p_add">+				   &quot;HugePages_Surp:    %5lu\n&quot;</span>
<span class="p_add">+				   &quot;Hugepagesize:   %8lu kB\n&quot;,</span>
<span class="p_add">+				   count,</span>
<span class="p_add">+				   h-&gt;free_huge_pages,</span>
<span class="p_add">+				   h-&gt;resv_huge_pages,</span>
<span class="p_add">+				   h-&gt;surplus_huge_pages,</span>
<span class="p_add">+				   (PAGE_SIZE &lt;&lt; huge_page_order(h)) / 1024);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	seq_printf(m, &quot;Hugetlb:        %8lu kB\n&quot;, total / 1024);</span>
 }
 
 int hugetlb_report_node_meminfo(int nid, char *buf)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



