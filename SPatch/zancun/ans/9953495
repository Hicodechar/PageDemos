
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.50 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.50</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 14, 2017, 4:04 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170914160427.GB3505@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9953495/mbox/"
   >mbox</a>
|
   <a href="/patch/9953495/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9953495/">/patch/9953495/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	65C55602C9 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:04:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 699B41FE8D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:04:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 5E44B27F17; Thu, 14 Sep 2017 16:04:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B32371FE8D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 14 Sep 2017 16:04:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752089AbdINQEb (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 14 Sep 2017 12:04:31 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:44762 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751420AbdINQE2 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 14 Sep 2017 12:04:28 -0400
Received: from localhost (unknown [12.145.98.253])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 2458898A;
	Thu, 14 Sep 2017 16:04:28 +0000 (UTC)
Date: Thu, 14 Sep 2017 09:04:27 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.50
Message-ID: &lt;20170914160427.GB3505@kroah.com&gt;
References: &lt;20170914160423.GA3505@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170914160423.GA3505@kroah.com&gt;
User-Agent: Mutt/1.9.0 (2017-09-02)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 14, 2017, 4:04 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 1ebc553f5464..038d126a15fc 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 49</span>
<span class="p_add">+SUBLEVEL = 50</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c</span>
<span class="p_header">index 0122ad1a6027..f7861dc83182 100644</span>
<span class="p_header">--- a/arch/arm/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm/mm/fault.c</span>
<span class="p_chunk">@@ -314,8 +314,11 @@</span> <span class="p_context"> do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)</span>
 	 * signal first. We do not need to release the mmap_sem because
 	 * it would already be released in __lock_page_or_retry in
 	 * mm/filemap.c. */
<span class="p_del">-	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current))</span>
<span class="p_add">+	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current)) {</span>
<span class="p_add">+		if (!user_mode(regs))</span>
<span class="p_add">+			goto no_context;</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/*
 	 * Major/minor page fault accounting is only done on the
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_header">index 49a5d8ccae27..68e6f88bdcfe 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-37xx.dtsi</span>
<span class="p_chunk">@@ -170,6 +170,7 @@</span> <span class="p_context"></span>
 				interrupt-controller;
 				reg = &lt;0x1d00000 0x10000&gt;, /* GICD */
 				      &lt;0x1d40000 0x40000&gt;; /* GICR */
<span class="p_add">+				interrupts = &lt;GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH&gt;;</span>
 			};
 		};
 
<span class="p_header">diff --git a/drivers/mtd/nand/mxc_nand.c b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">index d7f724b24fd7..0c84ee80e5b6 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/mxc_nand.c</span>
<span class="p_chunk">@@ -877,6 +877,8 @@</span> <span class="p_context"> static void mxc_do_addr_cycle(struct mtd_info *mtd, int column, int page_addr)</span>
 	}
 }
 
<span class="p_add">+#define MXC_V1_ECCBYTES		5</span>
<span class="p_add">+</span>
 static int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,
 				struct mtd_oob_region *oobregion)
 {
<span class="p_chunk">@@ -886,7 +888,7 @@</span> <span class="p_context"> static int mxc_v1_ooblayout_ecc(struct mtd_info *mtd, int section,</span>
 		return -ERANGE;
 
 	oobregion-&gt;offset = (section * 16) + 6;
<span class="p_del">-	oobregion-&gt;length = nand_chip-&gt;ecc.bytes;</span>
<span class="p_add">+	oobregion-&gt;length = MXC_V1_ECCBYTES;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -908,8 +910,7 @@</span> <span class="p_context"> static int mxc_v1_ooblayout_free(struct mtd_info *mtd, int section,</span>
 			oobregion-&gt;length = 4;
 		}
 	} else {
<span class="p_del">-		oobregion-&gt;offset = ((section - 1) * 16) +</span>
<span class="p_del">-				    nand_chip-&gt;ecc.bytes + 6;</span>
<span class="p_add">+		oobregion-&gt;offset = ((section - 1) * 16) + MXC_V1_ECCBYTES + 6;</span>
 		if (section &lt; nand_chip-&gt;ecc.steps)
 			oobregion-&gt;length = (section * 16) + 6 -
 					    oobregion-&gt;offset;
<span class="p_header">diff --git a/drivers/mtd/nand/qcom_nandc.c b/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_header">index 57d483ac5765..6f0fd1512ad2 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/qcom_nandc.c</span>
<span class="p_chunk">@@ -109,7 +109,11 @@</span> <span class="p_context"></span>
 #define	READ_ADDR			0
 
 /* NAND_DEV_CMD_VLD bits */
<span class="p_del">-#define	READ_START_VLD			0</span>
<span class="p_add">+#define	READ_START_VLD			BIT(0)</span>
<span class="p_add">+#define	READ_STOP_VLD			BIT(1)</span>
<span class="p_add">+#define	WRITE_START_VLD			BIT(2)</span>
<span class="p_add">+#define	ERASE_START_VLD			BIT(3)</span>
<span class="p_add">+#define	SEQ_READ_START_VLD		BIT(4)</span>
 
 /* NAND_EBI2_ECC_BUF_CFG bits */
 #define	NUM_STEPS			0
<span class="p_chunk">@@ -148,6 +152,10 @@</span> <span class="p_context"></span>
 #define	FETCH_ID			0xb
 #define	RESET_DEVICE			0xd
 
<span class="p_add">+/* Default Value for NAND_DEV_CMD_VLD */</span>
<span class="p_add">+#define NAND_DEV_CMD_VLD_VAL		(READ_START_VLD | WRITE_START_VLD | \</span>
<span class="p_add">+					 ERASE_START_VLD | SEQ_READ_START_VLD)</span>
<span class="p_add">+</span>
 /*
  * the NAND controller performs reads/writes with ECC in 516 byte chunks.
  * the driver calls the chunks &#39;step&#39; or &#39;codeword&#39; interchangeably
<span class="p_chunk">@@ -672,8 +680,7 @@</span> <span class="p_context"> static int nandc_param(struct qcom_nand_host *host)</span>
 
 	/* configure CMD1 and VLD for ONFI param probing */
 	nandc_set_reg(nandc, NAND_DEV_CMD_VLD,
<span class="p_del">-		      (nandc-&gt;vld &amp; ~(1 &lt;&lt; READ_START_VLD))</span>
<span class="p_del">-		      | 0 &lt;&lt; READ_START_VLD);</span>
<span class="p_add">+		      (nandc-&gt;vld &amp; ~READ_START_VLD));</span>
 	nandc_set_reg(nandc, NAND_DEV_CMD1,
 		      (nandc-&gt;cmd1 &amp; ~(0xFF &lt;&lt; READ_ADDR))
 		      | NAND_CMD_PARAM &lt;&lt; READ_ADDR);
<span class="p_chunk">@@ -1893,7 +1900,7 @@</span> <span class="p_context"> static int qcom_nand_host_setup(struct qcom_nand_host *host)</span>
 				| wide_bus &lt;&lt; WIDE_FLASH
 				| 1 &lt;&lt; DEV0_CFG1_ECC_DISABLE;
 
<span class="p_del">-	host-&gt;ecc_bch_cfg = host-&gt;bch_enabled &lt;&lt; ECC_CFG_ECC_DISABLE</span>
<span class="p_add">+	host-&gt;ecc_bch_cfg = !host-&gt;bch_enabled &lt;&lt; ECC_CFG_ECC_DISABLE</span>
 				| 0 &lt;&lt; ECC_SW_RESET
 				| host-&gt;cw_data &lt;&lt; ECC_NUM_DATA_BYTES
 				| 1 &lt;&lt; ECC_FORCE_CLK_OPEN
<span class="p_chunk">@@ -1972,13 +1979,14 @@</span> <span class="p_context"> static int qcom_nandc_setup(struct qcom_nand_controller *nandc)</span>
 {
 	/* kill onenand */
 	nandc_write(nandc, SFLASHC_BURST_CFG, 0);
<span class="p_add">+	nandc_write(nandc, NAND_DEV_CMD_VLD, NAND_DEV_CMD_VLD_VAL);</span>
 
 	/* enable ADM DMA */
 	nandc_write(nandc, NAND_FLASH_CHIP_SELECT, DM_EN);
 
 	/* save the original values of these registers */
 	nandc-&gt;cmd1 = nandc_read(nandc, NAND_DEV_CMD1);
<span class="p_del">-	nandc-&gt;vld = nandc_read(nandc, NAND_DEV_CMD_VLD);</span>
<span class="p_add">+	nandc-&gt;vld = NAND_DEV_CMD_VLD_VAL;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/nvme/host/fabrics.c b/drivers/nvme/host/fabrics.c</span>
<span class="p_header">index 5a3f008d3480..eef1a68e5d95 100644</span>
<span class="p_header">--- a/drivers/nvme/host/fabrics.c</span>
<span class="p_header">+++ b/drivers/nvme/host/fabrics.c</span>
<span class="p_chunk">@@ -77,7 +77,7 @@</span> <span class="p_context"> static struct nvmf_host *nvmf_host_default(void)</span>
 	kref_init(&amp;host-&gt;ref);
 	uuid_be_gen(&amp;host-&gt;id);
 	snprintf(host-&gt;nqn, NVMF_NQN_SIZE,
<span class="p_del">-		&quot;nqn.2014-08.org.nvmexpress:NVMf:uuid:%pUb&quot;, &amp;host-&gt;id);</span>
<span class="p_add">+		&quot;nqn.2014-08.org.nvmexpress:uuid:%pUb&quot;, &amp;host-&gt;id);</span>
 
 	mutex_lock(&amp;nvmf_hosts_mutex);
 	list_add_tail(&amp;host-&gt;list, &amp;nvmf_hosts);
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 74ed5aae6cea..f6e111984ce2 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -1834,6 +1834,8 @@</span> <span class="p_context"> static int btrfs_remount(struct super_block *sb, int *flags, char *data)</span>
 			goto restore;
 		}
 
<span class="p_add">+		btrfs_qgroup_rescan_resume(fs_info);</span>
<span class="p_add">+</span>
 		if (!fs_info-&gt;uuid_root) {
 			btrfs_info(fs_info, &quot;creating UUID tree&quot;);
 			ret = btrfs_create_uuid_tree(fs_info);
<span class="p_header">diff --git a/fs/nfs/file.c b/fs/nfs/file.c</span>
<span class="p_header">index 84c1cb9237d0..1eec947c562d 100644</span>
<span class="p_header">--- a/fs/nfs/file.c</span>
<span class="p_header">+++ b/fs/nfs/file.c</span>
<span class="p_chunk">@@ -636,11 +636,11 @@</span> <span class="p_context"> ssize_t nfs_file_write(struct kiocb *iocb, struct iov_iter *from)</span>
 	if (result &lt;= 0)
 		goto out;
 
<span class="p_del">-	result = generic_write_sync(iocb, result);</span>
<span class="p_del">-	if (result &lt; 0)</span>
<span class="p_del">-		goto out;</span>
 	written = result;
 	iocb-&gt;ki_pos += written;
<span class="p_add">+	result = generic_write_sync(iocb, written);</span>
<span class="p_add">+	if (result &lt; 0)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Return error values */
 	if (nfs_need_check_write(file, inode)) {
<span class="p_header">diff --git a/fs/nfs/internal.h b/fs/nfs/internal.h</span>
<span class="p_header">index 80bcc0befb07..52ea41bce038 100644</span>
<span class="p_header">--- a/fs/nfs/internal.h</span>
<span class="p_header">+++ b/fs/nfs/internal.h</span>
<span class="p_chunk">@@ -248,7 +248,6 @@</span> <span class="p_context"> int nfs_iocounter_wait(struct nfs_lock_context *l_ctx);</span>
 extern const struct nfs_pageio_ops nfs_pgio_rw_ops;
 struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *);
 void nfs_pgio_header_free(struct nfs_pgio_header *);
<span class="p_del">-void nfs_pgio_data_destroy(struct nfs_pgio_header *);</span>
 int nfs_generic_pgio(struct nfs_pageio_descriptor *, struct nfs_pgio_header *);
 int nfs_initiate_pgio(struct rpc_clnt *clnt, struct nfs_pgio_header *hdr,
 		      struct rpc_cred *cred, const struct nfs_rpc_ops *rpc_ops,
<span class="p_header">diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c</span>
<span class="p_header">index 142a74f3c59b..3d17fc82b9fe 100644</span>
<span class="p_header">--- a/fs/nfs/pagelist.c</span>
<span class="p_header">+++ b/fs/nfs/pagelist.c</span>
<span class="p_chunk">@@ -497,16 +497,6 @@</span> <span class="p_context"> struct nfs_pgio_header *nfs_pgio_header_alloc(const struct nfs_rw_ops *ops)</span>
 }
 EXPORT_SYMBOL_GPL(nfs_pgio_header_alloc);
 
<span class="p_del">-/*</span>
<span class="p_del">- * nfs_pgio_header_free - Free a read or write header</span>
<span class="p_del">- * @hdr: The header to free</span>
<span class="p_del">- */</span>
<span class="p_del">-void nfs_pgio_header_free(struct nfs_pgio_header *hdr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	hdr-&gt;rw_ops-&gt;rw_free_header(hdr);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
<span class="p_del">-</span>
 /**
  * nfs_pgio_data_destroy - make @hdr suitable for reuse
  *
<span class="p_chunk">@@ -515,14 +505,24 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
  *
  * @hdr: A header that has had nfs_generic_pgio called
  */
<span class="p_del">-void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)</span>
<span class="p_add">+static void nfs_pgio_data_destroy(struct nfs_pgio_header *hdr)</span>
 {
 	if (hdr-&gt;args.context)
 		put_nfs_open_context(hdr-&gt;args.context);
 	if (hdr-&gt;page_array.pagevec != hdr-&gt;page_array.page_array)
 		kfree(hdr-&gt;page_array.pagevec);
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(nfs_pgio_data_destroy);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * nfs_pgio_header_free - Free a read or write header</span>
<span class="p_add">+ * @hdr: The header to free</span>
<span class="p_add">+ */</span>
<span class="p_add">+void nfs_pgio_header_free(struct nfs_pgio_header *hdr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	nfs_pgio_data_destroy(hdr);</span>
<span class="p_add">+	hdr-&gt;rw_ops-&gt;rw_free_header(hdr);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(nfs_pgio_header_free);</span>
 
 /**
  * nfs_pgio_rpcsetup - Set up arguments for a pageio call
<span class="p_chunk">@@ -636,7 +636,6 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nfs_initiate_pgio);</span>
 static void nfs_pgio_error(struct nfs_pgio_header *hdr)
 {
 	set_bit(NFS_IOHDR_REDO, &amp;hdr-&gt;flags);
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;completion_ops-&gt;completion(hdr);
 }
 
<span class="p_chunk">@@ -647,7 +646,6 @@</span> <span class="p_context"> static void nfs_pgio_error(struct nfs_pgio_header *hdr)</span>
 static void nfs_pgio_release(void *calldata)
 {
 	struct nfs_pgio_header *hdr = calldata;
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;completion_ops-&gt;completion(hdr);
 }
 
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 415d7e69bc5e..b7a07ba8783a 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -2145,7 +2145,6 @@</span> <span class="p_context"> pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_write_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;release(hdr);
 }
 
<span class="p_chunk">@@ -2257,7 +2256,6 @@</span> <span class="p_context"> pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_read_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	nfs_pgio_data_destroy(hdr);</span>
 	hdr-&gt;release(hdr);
 }
 
<span class="p_header">diff --git a/fs/xfs/xfs_linux.h b/fs/xfs/xfs_linux.h</span>
<span class="p_header">index 1455b25205a8..3ebed168e508 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_linux.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_linux.h</span>
<span class="p_chunk">@@ -363,7 +363,14 @@</span> <span class="p_context"> static inline __uint64_t howmany_64(__uint64_t x, __uint32_t y)</span>
 #endif /* DEBUG */
 
 #ifdef CONFIG_XFS_RT
<span class="p_del">-#define XFS_IS_REALTIME_INODE(ip) ((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * make sure we ignore the inode flag if the filesystem doesn&#39;t have a</span>
<span class="p_add">+ * configured realtime device.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define XFS_IS_REALTIME_INODE(ip)			\</span>
<span class="p_add">+	(((ip)-&gt;i_d.di_flags &amp; XFS_DIFLAG_REALTIME) &amp;&amp;	\</span>
<span class="p_add">+	 (ip)-&gt;i_mount-&gt;m_rtdev_targp)</span>
 #else
 #define XFS_IS_REALTIME_INODE(ip) (0)
 #endif
<span class="p_header">diff --git a/kernel/locking/locktorture.c b/kernel/locking/locktorture.c</span>
<span class="p_header">index f8c5af52a131..d3de04b12f8c 100644</span>
<span class="p_header">--- a/kernel/locking/locktorture.c</span>
<span class="p_header">+++ b/kernel/locking/locktorture.c</span>
<span class="p_chunk">@@ -780,6 +780,10 @@</span> <span class="p_context"> static void lock_torture_cleanup(void)</span>
 	else
 		lock_torture_print_module_parms(cxt.cur_ops,
 						&quot;End of test: SUCCESS&quot;);
<span class="p_add">+</span>
<span class="p_add">+	kfree(cxt.lwsa);</span>
<span class="p_add">+	kfree(cxt.lrsa);</span>
<span class="p_add">+</span>
 end:
 	torture_cleanup_end();
 }
<span class="p_chunk">@@ -924,6 +928,8 @@</span> <span class="p_context"> static int __init lock_torture_init(void)</span>
 				       GFP_KERNEL);
 		if (reader_tasks == NULL) {
 			VERBOSE_TOROUT_ERRSTRING(&quot;reader_tasks: Out of memory&quot;);
<span class="p_add">+			kfree(writer_tasks);</span>
<span class="p_add">+			writer_tasks = NULL;</span>
 			firsterr = -ENOMEM;
 			goto unwind;
 		}
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index d064caff9d7d..1aa63e7dd790 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -3596,6 +3596,11 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 	/* do counter updates before entering really critical section. */
 	check_sync_rss_stat(current);
 
<span class="p_add">+	if (!arch_vma_access_permitted(vma, flags &amp; FAULT_FLAG_WRITE,</span>
<span class="p_add">+					    flags &amp; FAULT_FLAG_INSTRUCTION,</span>
<span class="p_add">+					    flags &amp; FAULT_FLAG_REMOTE))</span>
<span class="p_add">+		return VM_FAULT_SIGSEGV;</span>
<span class="p_add">+</span>
 	/*
 	 * Enable the memcg OOM handling for faults triggered in user
 	 * space.  Kernel faults are handled more gracefully.
<span class="p_chunk">@@ -3603,11 +3608,6 @@</span> <span class="p_context"> int handle_mm_fault(struct vm_area_struct *vma, unsigned long address,</span>
 	if (flags &amp; FAULT_FLAG_USER)
 		mem_cgroup_oom_enable();
 
<span class="p_del">-	if (!arch_vma_access_permitted(vma, flags &amp; FAULT_FLAG_WRITE,</span>
<span class="p_del">-					    flags &amp; FAULT_FLAG_INSTRUCTION,</span>
<span class="p_del">-					    flags &amp; FAULT_FLAG_REMOTE))</span>
<span class="p_del">-		return VM_FAULT_SIGSEGV;</span>
<span class="p_del">-</span>
 	if (unlikely(is_vm_hugetlb_page(vma)))
 		ret = hugetlb_fault(vma-&gt;vm_mm, vma, address, flags);
 	else
<span class="p_header">diff --git a/net/bluetooth/l2cap_core.c b/net/bluetooth/l2cap_core.c</span>
<span class="p_header">index 577f1c01454a..ffd09c1675d4 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_core.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_core.c</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> static struct sk_buff *l2cap_build_cmd(struct l2cap_conn *conn,</span>
 				       u8 code, u8 ident, u16 dlen, void *data);
 static void l2cap_send_cmd(struct l2cap_conn *conn, u8 ident, u8 code, u16 len,
 			   void *data);
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data);</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size);</span>
 static void l2cap_send_disconn_req(struct l2cap_chan *chan, int err);
 
 static void l2cap_tx(struct l2cap_chan *chan, struct l2cap_ctrl *control,
<span class="p_chunk">@@ -1473,7 +1473,7 @@</span> <span class="p_context"> static void l2cap_conn_start(struct l2cap_conn *conn)</span>
 
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 
<span class="p_chunk">@@ -2977,12 +2977,15 @@</span> <span class="p_context"> static inline int l2cap_get_conf_opt(void **ptr, int *type, int *olen,</span>
 	return len;
 }
 
<span class="p_del">-static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
<span class="p_add">+static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val, size_t size)</span>
 {
 	struct l2cap_conf_opt *opt = *ptr;
 
 	BT_DBG(&quot;type 0x%2.2x len %u val 0x%lx&quot;, type, len, val);
 
<span class="p_add">+	if (size &lt; L2CAP_CONF_OPT_SIZE + len)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	opt-&gt;type = type;
 	opt-&gt;len  = len;
 
<span class="p_chunk">@@ -3007,7 +3010,7 @@</span> <span class="p_context"> static void l2cap_add_conf_opt(void **ptr, u8 type, u8 len, unsigned long val)</span>
 	*ptr += L2CAP_CONF_OPT_SIZE + len;
 }
 
<span class="p_del">-static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
<span class="p_add">+static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan, size_t size)</span>
 {
 	struct l2cap_conf_efs efs;
 
<span class="p_chunk">@@ -3035,7 +3038,7 @@</span> <span class="p_context"> static void l2cap_add_opt_efs(void **ptr, struct l2cap_chan *chan)</span>
 	}
 
 	l2cap_add_conf_opt(ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-			   (unsigned long) &amp;efs);</span>
<span class="p_add">+			   (unsigned long) &amp;efs, size);</span>
 }
 
 static void l2cap_ack_timeout(struct work_struct *work)
<span class="p_chunk">@@ -3181,11 +3184,12 @@</span> <span class="p_context"> static inline void l2cap_txwin_setup(struct l2cap_chan *chan)</span>
 	chan-&gt;ack_win = chan-&gt;tx_win;
 }
 
<span class="p_del">-static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_req *req = data;
 	struct l2cap_conf_rfc rfc = { .mode = chan-&gt;mode };
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	u16 size;
 
 	BT_DBG(&quot;chan %p&quot;, chan);
<span class="p_chunk">@@ -3210,7 +3214,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 done:
 	if (chan-&gt;imtu != L2CAP_DEFAULT_MTU)
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 
 	switch (chan-&gt;mode) {
 	case L2CAP_MODE_BASIC:
<span class="p_chunk">@@ -3229,7 +3233,7 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size    = 0;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 		break;
 
 	case L2CAP_MODE_ERTM:
<span class="p_chunk">@@ -3249,21 +3253,21 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 				       L2CAP_DEFAULT_TX_WINDOW);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EXT_CTRL, &amp;chan-&gt;flags))
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 
<span class="p_chunk">@@ -3281,17 +3285,17 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 		rfc.max_pdu_size = cpu_to_le16(size);
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 		if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags))
<span class="p_del">-			l2cap_add_opt_efs(&amp;ptr, chan);</span>
<span class="p_add">+			l2cap_add_opt_efs(&amp;ptr, chan, endptr - ptr);</span>
 
 		if (chan-&gt;conn-&gt;feat_mask &amp; L2CAP_FEAT_FCS)
 			if (chan-&gt;fcs == L2CAP_FCS_NONE ||
 			    test_bit(CONF_RECV_NO_FCS, &amp;chan-&gt;conf_state)) {
 				chan-&gt;fcs = L2CAP_FCS_NONE;
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FCS, 1,
<span class="p_del">-						   chan-&gt;fcs);</span>
<span class="p_add">+						   chan-&gt;fcs, endptr - ptr);</span>
 			}
 		break;
 	}
<span class="p_chunk">@@ -3302,10 +3306,11 @@</span> <span class="p_context"> static int l2cap_build_conf_req(struct l2cap_chan *chan, void *data)</span>
 	return ptr - data;
 }
 
<span class="p_del">-static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
<span class="p_add">+static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data, size_t data_size)</span>
 {
 	struct l2cap_conf_rsp *rsp = data;
 	void *ptr = rsp-&gt;data;
<span class="p_add">+	void *endptr = data + data_size;</span>
 	void *req = chan-&gt;conf_req;
 	int len = chan-&gt;conf_len;
 	int type, hint, olen;
<span class="p_chunk">@@ -3407,7 +3412,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			return -ECONNREFUSED;
 
 		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-				   (unsigned long) &amp;rfc);</span>
<span class="p_add">+				   (unsigned long) &amp;rfc, endptr - ptr);</span>
 	}
 
 	if (result == L2CAP_CONF_SUCCESS) {
<span class="p_chunk">@@ -3420,7 +3425,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			chan-&gt;omtu = mtu;
 			set_bit(CONF_MTU_DONE, &amp;chan-&gt;conf_state);
 		}
<span class="p_del">-		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu);</span>
<span class="p_add">+		l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;omtu, endptr - ptr);</span>
 
 		if (remote_efs) {
 			if (chan-&gt;local_stype != L2CAP_SERV_NOTRAFIC &amp;&amp;
<span class="p_chunk">@@ -3434,7 +3439,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			} else {
 				/* Send PENDING Conf Rsp */
 				result = L2CAP_CONF_PENDING;
<span class="p_chunk">@@ -3467,7 +3472,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			if (test_bit(FLAG_EFS_ENABLE, &amp;chan-&gt;flags)) {
 				chan-&gt;remote_id = efs.id;
<span class="p_chunk">@@ -3481,7 +3486,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 					le32_to_cpu(efs.sdu_itime);
 				l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS,
 						   sizeof(efs),
<span class="p_del">-						   (unsigned long) &amp;efs);</span>
<span class="p_add">+						   (unsigned long) &amp;efs, endptr - ptr);</span>
 			}
 			break;
 
<span class="p_chunk">@@ -3495,7 +3500,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 			set_bit(CONF_MODE_DONE, &amp;chan-&gt;conf_state);
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC, sizeof(rfc),
<span class="p_del">-					   (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   (unsigned long) &amp;rfc, endptr - ptr);</span>
 
 			break;
 
<span class="p_chunk">@@ -3517,10 +3522,11 @@</span> <span class="p_context"> static int l2cap_parse_conf_req(struct l2cap_chan *chan, void *data)</span>
 }
 
 static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,
<span class="p_del">-				void *data, u16 *result)</span>
<span class="p_add">+				void *data, size_t size, u16 *result)</span>
 {
 	struct l2cap_conf_req *req = data;
 	void *ptr = req-&gt;data;
<span class="p_add">+	void *endptr = data + size;</span>
 	int type, olen;
 	unsigned long val;
 	struct l2cap_conf_rfc rfc = { .mode = L2CAP_MODE_BASIC };
<span class="p_chunk">@@ -3538,13 +3544,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				chan-&gt;imtu = L2CAP_DEFAULT_MIN_MTU;
 			} else
 				chan-&gt;imtu = val;
<span class="p_del">-			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu);</span>
<span class="p_add">+			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_MTU, 2, chan-&gt;imtu, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FLUSH_TO:
 			chan-&gt;flush_to = val;
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_FLUSH_TO,
<span class="p_del">-					   2, chan-&gt;flush_to);</span>
<span class="p_add">+					   2, chan-&gt;flush_to, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_RFC:
<span class="p_chunk">@@ -3558,13 +3564,13 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 			chan-&gt;fcs = 0;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_RFC,
<span class="p_del">-					   sizeof(rfc), (unsigned long) &amp;rfc);</span>
<span class="p_add">+					   sizeof(rfc), (unsigned long) &amp;rfc, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EWS:
 			chan-&gt;ack_win = min_t(u16, val, chan-&gt;ack_win);
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EWS, 2,
<span class="p_del">-					   chan-&gt;tx_win);</span>
<span class="p_add">+					   chan-&gt;tx_win, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_EFS:
<span class="p_chunk">@@ -3577,7 +3583,7 @@</span> <span class="p_context"> static int l2cap_parse_conf_rsp(struct l2cap_chan *chan, void *rsp, int len,</span>
 				return -ECONNREFUSED;
 
 			l2cap_add_conf_opt(&amp;ptr, L2CAP_CONF_EFS, sizeof(efs),
<span class="p_del">-					   (unsigned long) &amp;efs);</span>
<span class="p_add">+					   (unsigned long) &amp;efs, endptr - ptr);</span>
 			break;
 
 		case L2CAP_CONF_FCS:
<span class="p_chunk">@@ -3682,7 +3688,7 @@</span> <span class="p_context"> void __l2cap_connect_rsp_defer(struct l2cap_chan *chan)</span>
 		return;
 
 	l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-		       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+		       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 	chan-&gt;num_conf_req++;
 }
 
<span class="p_chunk">@@ -3890,7 +3896,7 @@</span> <span class="p_context"> static struct l2cap_chan *l2cap_connect(struct l2cap_conn *conn,</span>
 		u8 buf[128];
 		set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -3968,7 +3974,7 @@</span> <span class="p_context"> static int l2cap_connect_create_rsp(struct l2cap_conn *conn,</span>
 			break;
 
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, req), req);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, req, sizeof(req)), req);</span>
 		chan-&gt;num_conf_req++;
 		break;
 
<span class="p_chunk">@@ -4080,7 +4086,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	}
 
 	/* Complete config. */
<span class="p_del">-	len = l2cap_parse_conf_req(chan, rsp);</span>
<span class="p_add">+	len = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));</span>
 	if (len &lt; 0) {
 		l2cap_send_disconn_req(chan, ECONNRESET);
 		goto unlock;
<span class="p_chunk">@@ -4114,7 +4120,7 @@</span> <span class="p_context"> static inline int l2cap_config_req(struct l2cap_conn *conn,</span>
 	if (!test_and_set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state)) {
 		u8 buf[64];
 		l2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,
<span class="p_del">-			       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+			       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 		chan-&gt;num_conf_req++;
 	}
 
<span class="p_chunk">@@ -4174,7 +4180,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			char buf[64];
 
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   buf, &amp;result);</span>
<span class="p_add">+						   buf, sizeof(buf), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4204,7 +4210,7 @@</span> <span class="p_context"> static inline int l2cap_config_rsp(struct l2cap_conn *conn,</span>
 			/* throw out any old stored conf requests */
 			result = L2CAP_CONF_SUCCESS;
 			len = l2cap_parse_conf_rsp(chan, rsp-&gt;data, len,
<span class="p_del">-						   req, &amp;result);</span>
<span class="p_add">+						   req, sizeof(req), &amp;result);</span>
 			if (len &lt; 0) {
 				l2cap_send_disconn_req(chan, ECONNRESET);
 				goto done;
<span class="p_chunk">@@ -4781,7 +4787,7 @@</span> <span class="p_context"> static void l2cap_do_create(struct l2cap_chan *chan, int result,</span>
 			set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 			l2cap_send_cmd(chan-&gt;conn, l2cap_get_ident(chan-&gt;conn),
 				       L2CAP_CONF_REQ,
<span class="p_del">-				       l2cap_build_conf_req(chan, buf), buf);</span>
<span class="p_add">+				       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);</span>
 			chan-&gt;num_conf_req++;
 		}
 	}
<span class="p_chunk">@@ -7457,7 +7463,7 @@</span> <span class="p_context"> static void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)</span>
 				set_bit(CONF_REQ_SENT, &amp;chan-&gt;conf_state);
 				l2cap_send_cmd(conn, l2cap_get_ident(conn),
 					       L2CAP_CONF_REQ,
<span class="p_del">-					       l2cap_build_conf_req(chan, buf),</span>
<span class="p_add">+					       l2cap_build_conf_req(chan, buf, sizeof(buf)),</span>
 					       buf);
 				chan-&gt;num_conf_req++;
 			}
<span class="p_header">diff --git a/sound/isa/msnd/msnd_midi.c b/sound/isa/msnd/msnd_midi.c</span>
<span class="p_header">index ffc67fd80c23..58e59cd3c95c 100644</span>
<span class="p_header">--- a/sound/isa/msnd/msnd_midi.c</span>
<span class="p_header">+++ b/sound/isa/msnd/msnd_midi.c</span>
<span class="p_chunk">@@ -120,24 +120,24 @@</span> <span class="p_context"> void snd_msndmidi_input_read(void *mpuv)</span>
 	unsigned long flags;
 	struct snd_msndmidi *mpu = mpuv;
 	void *pwMIDQData = mpu-&gt;dev-&gt;mappedbase + MIDQ_DATA_BUFF;
<span class="p_add">+	u16 head, tail, size;</span>
 
 	spin_lock_irqsave(&amp;mpu-&gt;input_lock, flags);
<span class="p_del">-	while (readw(mpu-&gt;dev-&gt;MIDQ + JQS_wTail) !=</span>
<span class="p_del">-	       readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead)) {</span>
<span class="p_del">-		u16 wTmp, val;</span>
<span class="p_del">-		val = readw(pwMIDQData + 2 * readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead));</span>
<span class="p_del">-</span>
<span class="p_del">-			if (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER,</span>
<span class="p_del">-				     &amp;mpu-&gt;mode))</span>
<span class="p_del">-				snd_rawmidi_receive(mpu-&gt;substream_input,</span>
<span class="p_del">-						    (unsigned char *)&amp;val, 1);</span>
<span class="p_del">-</span>
<span class="p_del">-		wTmp = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead) + 1;</span>
<span class="p_del">-		if (wTmp &gt; readw(mpu-&gt;dev-&gt;MIDQ + JQS_wSize))</span>
<span class="p_del">-			writew(0,  mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			writew(wTmp,  mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
<span class="p_add">+	head = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
<span class="p_add">+	tail = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wTail);</span>
<span class="p_add">+	size = readw(mpu-&gt;dev-&gt;MIDQ + JQS_wSize);</span>
<span class="p_add">+	if (head &gt; size || tail &gt; size)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	while (head != tail) {</span>
<span class="p_add">+		unsigned char val = readw(pwMIDQData + 2 * head);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (test_bit(MSNDMIDI_MODE_BIT_INPUT_TRIGGER, &amp;mpu-&gt;mode))</span>
<span class="p_add">+			snd_rawmidi_receive(mpu-&gt;substream_input, &amp;val, 1);</span>
<span class="p_add">+		if (++head &gt; size)</span>
<span class="p_add">+			head = 0;</span>
<span class="p_add">+		writew(head, mpu-&gt;dev-&gt;MIDQ + JQS_wHead);</span>
 	}
<span class="p_add">+ out:</span>
 	spin_unlock_irqrestore(&amp;mpu-&gt;input_lock, flags);
 }
 EXPORT_SYMBOL(snd_msndmidi_input_read);
<span class="p_header">diff --git a/sound/isa/msnd/msnd_pinnacle.c b/sound/isa/msnd/msnd_pinnacle.c</span>
<span class="p_header">index 4c072666115d..a31ea6c22d19 100644</span>
<span class="p_header">--- a/sound/isa/msnd/msnd_pinnacle.c</span>
<span class="p_header">+++ b/sound/isa/msnd/msnd_pinnacle.c</span>
<span class="p_chunk">@@ -170,23 +170,24 @@</span> <span class="p_context"> static irqreturn_t snd_msnd_interrupt(int irq, void *dev_id)</span>
 {
 	struct snd_msnd *chip = dev_id;
 	void *pwDSPQData = chip-&gt;mappedbase + DSPQ_DATA_BUFF;
<span class="p_add">+	u16 head, tail, size;</span>
 
 	/* Send ack to DSP */
 	/* inb(chip-&gt;io + HP_RXL); */
 
 	/* Evaluate queued DSP messages */
<span class="p_del">-	while (readw(chip-&gt;DSPQ + JQS_wTail) != readw(chip-&gt;DSPQ + JQS_wHead)) {</span>
<span class="p_del">-		u16 wTmp;</span>
<span class="p_del">-</span>
<span class="p_del">-		snd_msnd_eval_dsp_msg(chip,</span>
<span class="p_del">-			readw(pwDSPQData + 2 * readw(chip-&gt;DSPQ + JQS_wHead)));</span>
<span class="p_del">-</span>
<span class="p_del">-		wTmp = readw(chip-&gt;DSPQ + JQS_wHead) + 1;</span>
<span class="p_del">-		if (wTmp &gt; readw(chip-&gt;DSPQ + JQS_wSize))</span>
<span class="p_del">-			writew(0, chip-&gt;DSPQ + JQS_wHead);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			writew(wTmp, chip-&gt;DSPQ + JQS_wHead);</span>
<span class="p_add">+	head = readw(chip-&gt;DSPQ + JQS_wHead);</span>
<span class="p_add">+	tail = readw(chip-&gt;DSPQ + JQS_wTail);</span>
<span class="p_add">+	size = readw(chip-&gt;DSPQ + JQS_wSize);</span>
<span class="p_add">+	if (head &gt; size || tail &gt; size)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	while (head != tail) {</span>
<span class="p_add">+		snd_msnd_eval_dsp_msg(chip, readw(pwDSPQData + 2 * head));</span>
<span class="p_add">+		if (++head &gt; size)</span>
<span class="p_add">+			head = 0;</span>
<span class="p_add">+		writew(head, chip-&gt;DSPQ + JQS_wHead);</span>
 	}
<span class="p_add">+ out:</span>
 	/* Send ack to DSP */
 	inb(chip-&gt;io + HP_RXL);
 	return IRQ_HANDLED;
<span class="p_header">diff --git a/tools/testing/selftests/x86/fsgsbase.c b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">index 5b2b4b3c634c..9b4610c6d3fb 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/fsgsbase.c</span>
<span class="p_chunk">@@ -285,9 +285,12 @@</span> <span class="p_context"> static void *threadproc(void *ctx)</span>
 	}
 }
 
<span class="p_del">-static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
<span class="p_add">+static void set_gs_and_switch_to(unsigned long local,</span>
<span class="p_add">+				 unsigned short force_sel,</span>
<span class="p_add">+				 unsigned long remote)</span>
 {
 	unsigned long base;
<span class="p_add">+	unsigned short sel_pre_sched, sel_post_sched;</span>
 
 	bool hard_zero = false;
 	if (local == HARD_ZERO) {
<span class="p_chunk">@@ -297,6 +300,8 @@</span> <span class="p_context"> static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
 
 	printf(&quot;[RUN]\tARCH_SET_GS(0x%lx)%s, then schedule to 0x%lx\n&quot;,
 	       local, hard_zero ? &quot; and clear gs&quot; : &quot;&quot;, remote);
<span class="p_add">+	if (force_sel)</span>
<span class="p_add">+		printf(&quot;\tBefore schedule, set selector to 0x%hx\n&quot;, force_sel);</span>
 	if (syscall(SYS_arch_prctl, ARCH_SET_GS, local) != 0)
 		err(1, &quot;ARCH_SET_GS&quot;);
 	if (hard_zero)
<span class="p_chunk">@@ -307,18 +312,35 @@</span> <span class="p_context"> static void set_gs_and_switch_to(unsigned long local, unsigned long remote)</span>
 		printf(&quot;[FAIL]\tGSBASE wasn&#39;t set as expected\n&quot;);
 	}
 
<span class="p_add">+	if (force_sel) {</span>
<span class="p_add">+		asm volatile (&quot;mov %0, %%gs&quot; : : &quot;rm&quot; (force_sel));</span>
<span class="p_add">+		sel_pre_sched = force_sel;</span>
<span class="p_add">+		local = read_base(GS);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Signal delivery seems to mess up weird selectors.  Put it</span>
<span class="p_add">+		 * back.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		asm volatile (&quot;mov %0, %%gs&quot; : : &quot;rm&quot; (force_sel));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		asm volatile (&quot;mov %%gs, %0&quot; : &quot;=rm&quot; (sel_pre_sched));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	remote_base = remote;
 	ftx = 1;
 	syscall(SYS_futex, &amp;ftx, FUTEX_WAKE, 0, NULL, NULL, 0);
 	while (ftx != 0)
 		syscall(SYS_futex, &amp;ftx, FUTEX_WAIT, 1, NULL, NULL, 0);
 
<span class="p_add">+	asm volatile (&quot;mov %%gs, %0&quot; : &quot;=rm&quot; (sel_post_sched));</span>
 	base = read_base(GS);
<span class="p_del">-	if (base == local) {</span>
<span class="p_del">-		printf(&quot;[OK]\tGSBASE remained 0x%lx\n&quot;, local);</span>
<span class="p_add">+	if (base == local &amp;&amp; sel_pre_sched == sel_post_sched) {</span>
<span class="p_add">+		printf(&quot;[OK]\tGS/BASE remained 0x%hx/0x%lx\n&quot;,</span>
<span class="p_add">+		       sel_pre_sched, local);</span>
 	} else {
 		nerrs++;
<span class="p_del">-		printf(&quot;[FAIL]\tGSBASE changed to 0x%lx\n&quot;, base);</span>
<span class="p_add">+		printf(&quot;[FAIL]\tGS/BASE changed from 0x%hx/0x%lx to 0x%hx/0x%lx\n&quot;,</span>
<span class="p_add">+		       sel_pre_sched, local, sel_post_sched, base);</span>
 	}
 }
 
<span class="p_chunk">@@ -381,8 +403,15 @@</span> <span class="p_context"> int main()</span>
 
 	for (int local = 0; local &lt; 4; local++) {
 		for (int remote = 0; remote &lt; 4; remote++) {
<span class="p_del">-			set_gs_and_switch_to(bases_with_hard_zero[local],</span>
<span class="p_del">-					     bases_with_hard_zero[remote]);</span>
<span class="p_add">+			for (unsigned short s = 0; s &lt; 5; s++) {</span>
<span class="p_add">+				unsigned short sel = s;</span>
<span class="p_add">+				if (s == 4)</span>
<span class="p_add">+					asm (&quot;mov %%ss, %0&quot; : &quot;=rm&quot; (sel));</span>
<span class="p_add">+				set_gs_and_switch_to(</span>
<span class="p_add">+					bases_with_hard_zero[local],</span>
<span class="p_add">+					sel,</span>
<span class="p_add">+					bases_with_hard_zero[remote]);</span>
<span class="p_add">+			}</span>
 		}
 	}
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



