
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.8.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.8.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 31, 2016, 12:47 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161031124716.GB31799@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9405447/mbox/"
   >mbox</a>
|
   <a href="/patch/9405447/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9405447/">/patch/9405447/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2ABF560234 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 31 Oct 2016 12:48:57 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1271E2918C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 31 Oct 2016 12:48:57 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 0418F29193; Mon, 31 Oct 2016 12:48:57 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2EF2F2918C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 31 Oct 2016 12:48:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S941978AbcJaMsg (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 31 Oct 2016 08:48:36 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:36806 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S941795AbcJaMsH (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 31 Oct 2016 08:48:07 -0400
Received: from localhost (unknown [207.224.144.10])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id BEED9415;
	Mon, 31 Oct 2016 12:48:05 +0000 (UTC)
Date: Mon, 31 Oct 2016 06:47:16 -0600
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.8.6
Message-ID: &lt;20161031124716.GB31799@kroah.com&gt;
References: &lt;20161031124710.GA31799@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161031124710.GA31799@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 31, 2016, 12:47 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index daa3a01d2525..b249529204cd 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 8
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arm/boot/dts/arm-realview-eb.dtsi b/arch/arm/boot/dts/arm-realview-eb.dtsi</span>
<span class="p_header">index 1c6a040218e3..e2e9599596e2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/arm-realview-eb.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/arm-realview-eb.dtsi</span>
<span class="p_chunk">@@ -51,14 +51,6 @@</span> <span class="p_context"></span>
 		regulator-boot-on;
         };
 
<span class="p_del">-	veth: fixedregulator@0 {</span>
<span class="p_del">-		compatible = &quot;regulator-fixed&quot;;</span>
<span class="p_del">-		regulator-name = &quot;veth&quot;;</span>
<span class="p_del">-		regulator-min-microvolt = &lt;3300000&gt;;</span>
<span class="p_del">-		regulator-max-microvolt = &lt;3300000&gt;;</span>
<span class="p_del">-		regulator-boot-on;</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
 	xtal24mhz: xtal24mhz@24M {
 		#clock-cells = &lt;0&gt;;
 		compatible = &quot;fixed-clock&quot;;
<span class="p_chunk">@@ -134,16 +126,15 @@</span> <span class="p_context"></span>
 		bank-width = &lt;4&gt;;
 	};
 
<span class="p_del">-	/* SMSC 9118 ethernet with PHY and EEPROM */</span>
<span class="p_add">+	/* SMSC LAN91C111 ethernet with PHY and EEPROM */</span>
 	ethernet: ethernet@4e000000 {
<span class="p_del">-		compatible = &quot;smsc,lan9118&quot;, &quot;smsc,lan9115&quot;;</span>
<span class="p_add">+		compatible = &quot;smsc,lan91c111&quot;;</span>
 		reg = &lt;0x4e000000 0x10000&gt;;
<span class="p_del">-		phy-mode = &quot;mii&quot;;</span>
<span class="p_del">-		reg-io-width = &lt;4&gt;;</span>
<span class="p_del">-		smsc,irq-active-high;</span>
<span class="p_del">-		smsc,irq-push-pull;</span>
<span class="p_del">-		vdd33a-supply = &lt;&amp;veth&gt;;</span>
<span class="p_del">-		vddvario-supply = &lt;&amp;veth&gt;;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This means the adapter can be accessed with 8, 16 or</span>
<span class="p_add">+		 * 32 bit reads/writes.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		reg-io-width = &lt;7&gt;;</span>
 	};
 
 	usb: usb@4f000000 {
<span class="p_header">diff --git a/arch/arm/boot/dts/bcm958625hr.dts b/arch/arm/boot/dts/bcm958625hr.dts</span>
<span class="p_header">index 03b8bbeb694f..652418aa2700 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/bcm958625hr.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/bcm958625hr.dts</span>
<span class="p_chunk">@@ -47,7 +47,8 @@</span> <span class="p_context"></span>
 	};
 
 	memory {
<span class="p_del">-		reg = &lt;0x60000000 0x20000000&gt;;</span>
<span class="p_add">+		device_type = &quot;memory&quot;;</span>
<span class="p_add">+		reg = &lt;0x60000000 0x80000000&gt;;</span>
 	};
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi b/arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi</span>
<span class="p_header">index ca86da68220c..854117dc0b77 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap3-overo-common-lcd35.dtsi</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"></span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;mcspi1_pins&gt;;
 
<span class="p_del">-	lcd0: display {</span>
<span class="p_add">+	lcd0: display@1 {</span>
 		compatible = &quot;lgphilips,lb035q02&quot;;
 		label = &quot;lcd35&quot;;
 
<span class="p_header">diff --git a/arch/arm/boot/dts/sun9i-a80.dtsi b/arch/arm/boot/dts/sun9i-a80.dtsi</span>
<span class="p_header">index f68b3242b33a..3f528a379288 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun9i-a80.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun9i-a80.dtsi</span>
<span class="p_chunk">@@ -899,8 +899,7 @@</span> <span class="p_context"></span>
 			resets = &lt;&amp;apbs_rst 0&gt;;
 			gpio-controller;
 			interrupt-controller;
<span class="p_del">-			#address-cells = &lt;1&gt;;</span>
<span class="p_del">-			#size-cells = &lt;0&gt;;</span>
<span class="p_add">+			#interrupt-cells = &lt;3&gt;;</span>
 			#gpio-cells = &lt;3&gt;;
 
 			r_ir_pins: r_ir {
<span class="p_header">diff --git a/arch/arm/crypto/ghash-ce-glue.c b/arch/arm/crypto/ghash-ce-glue.c</span>
<span class="p_header">index 1568cb5cd870..b88364aa149a 100644</span>
<span class="p_header">--- a/arch/arm/crypto/ghash-ce-glue.c</span>
<span class="p_header">+++ b/arch/arm/crypto/ghash-ce-glue.c</span>
<span class="p_chunk">@@ -220,6 +220,27 @@</span> <span class="p_context"> static int ghash_async_digest(struct ahash_request *req)</span>
 	}
 }
 
<span class="p_add">+static int ghash_async_import(struct ahash_request *req, const void *in)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ahash_request *cryptd_req = ahash_request_ctx(req);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);</span>
<span class="p_add">+	struct ghash_async_ctx *ctx = crypto_ahash_ctx(tfm);</span>
<span class="p_add">+	struct shash_desc *desc = cryptd_shash_desc(cryptd_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	desc-&gt;tfm = cryptd_ahash_child(ctx-&gt;cryptd_tfm);</span>
<span class="p_add">+	desc-&gt;flags = req-&gt;base.flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_shash_import(desc, in);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int ghash_async_export(struct ahash_request *req, void *out)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ahash_request *cryptd_req = ahash_request_ctx(req);</span>
<span class="p_add">+	struct shash_desc *desc = cryptd_shash_desc(cryptd_req);</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_shash_export(desc, out);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int ghash_async_setkey(struct crypto_ahash *tfm, const u8 *key,
 			      unsigned int keylen)
 {
<span class="p_chunk">@@ -268,7 +289,10 @@</span> <span class="p_context"> static struct ahash_alg ghash_async_alg = {</span>
 	.final			= ghash_async_final,
 	.setkey			= ghash_async_setkey,
 	.digest			= ghash_async_digest,
<span class="p_add">+	.import			= ghash_async_import,</span>
<span class="p_add">+	.export			= ghash_async_export,</span>
 	.halg.digestsize	= GHASH_DIGEST_SIZE,
<span class="p_add">+	.halg.statesize		= sizeof(struct ghash_desc_ctx),</span>
 	.halg.base		= {
 		.cra_name	= &quot;ghash&quot;,
 		.cra_driver_name = &quot;ghash-ce&quot;,
<span class="p_header">diff --git a/arch/arm/mach-pxa/corgi_pm.c b/arch/arm/mach-pxa/corgi_pm.c</span>
<span class="p_header">index d9206811be9b..c71c483f410e 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/corgi_pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/corgi_pm.c</span>
<span class="p_chunk">@@ -131,16 +131,11 @@</span> <span class="p_context"> static int corgi_should_wakeup(unsigned int resume_on_alarm)</span>
 	return is_resume;
 }
 
<span class="p_del">-static unsigned long corgi_charger_wakeup(void)</span>
<span class="p_add">+static bool corgi_charger_wakeup(void)</span>
 {
<span class="p_del">-	unsigned long ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = (!gpio_get_value(CORGI_GPIO_AC_IN) &lt;&lt; GPIO_bit(CORGI_GPIO_AC_IN))</span>
<span class="p_del">-		| (!gpio_get_value(CORGI_GPIO_KEY_INT)</span>
<span class="p_del">-		&lt;&lt; GPIO_bit(CORGI_GPIO_KEY_INT))</span>
<span class="p_del">-		| (!gpio_get_value(CORGI_GPIO_WAKEUP)</span>
<span class="p_del">-		&lt;&lt; GPIO_bit(CORGI_GPIO_WAKEUP));</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return !gpio_get_value(CORGI_GPIO_AC_IN) ||</span>
<span class="p_add">+		!gpio_get_value(CORGI_GPIO_KEY_INT) ||</span>
<span class="p_add">+		!gpio_get_value(CORGI_GPIO_WAKEUP);</span>
 }
 
 unsigned long corgipm_read_devdata(int type)
<span class="p_header">diff --git a/arch/arm/mach-pxa/pxa_cplds_irqs.c b/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
<span class="p_header">index 2385052b0ce1..e362f865fcd2 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/pxa_cplds_irqs.c</span>
<span class="p_chunk">@@ -41,30 +41,35 @@</span> <span class="p_context"> static irqreturn_t cplds_irq_handler(int in_irq, void *d)</span>
 	unsigned long pending;
 	unsigned int bit;
 
<span class="p_del">-	pending = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR) &amp; fpga-&gt;irq_mask;</span>
<span class="p_del">-	for_each_set_bit(bit, &amp;pending, CPLDS_NB_IRQ)</span>
<span class="p_del">-		generic_handle_irq(irq_find_mapping(fpga-&gt;irqdomain, bit));</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		pending = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR) &amp; fpga-&gt;irq_mask;</span>
<span class="p_add">+		for_each_set_bit(bit, &amp;pending, CPLDS_NB_IRQ) {</span>
<span class="p_add">+			generic_handle_irq(irq_find_mapping(fpga-&gt;irqdomain,</span>
<span class="p_add">+							    bit));</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (pending);</span>
 
 	return IRQ_HANDLED;
 }
 
<span class="p_del">-static void cplds_irq_mask_ack(struct irq_data *d)</span>
<span class="p_add">+static void cplds_irq_mask(struct irq_data *d)</span>
 {
 	struct cplds *fpga = irq_data_get_irq_chip_data(d);
 	unsigned int cplds_irq = irqd_to_hwirq(d);
<span class="p_del">-	unsigned int set, bit = BIT(cplds_irq);</span>
<span class="p_add">+	unsigned int bit = BIT(cplds_irq);</span>
 
 	fpga-&gt;irq_mask &amp;= ~bit;
 	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);
<span class="p_del">-	set = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
<span class="p_del">-	writel(set &amp; ~bit, fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
 }
 
 static void cplds_irq_unmask(struct irq_data *d)
 {
 	struct cplds *fpga = irq_data_get_irq_chip_data(d);
 	unsigned int cplds_irq = irqd_to_hwirq(d);
<span class="p_del">-	unsigned int bit = BIT(cplds_irq);</span>
<span class="p_add">+	unsigned int set, bit = BIT(cplds_irq);</span>
<span class="p_add">+</span>
<span class="p_add">+	set = readl(fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
<span class="p_add">+	writel(set &amp; ~bit, fpga-&gt;base + FPGA_IRQ_SET_CLR);</span>
 
 	fpga-&gt;irq_mask |= bit;
 	writel(fpga-&gt;irq_mask, fpga-&gt;base + FPGA_IRQ_MASK_EN);
<span class="p_chunk">@@ -72,7 +77,8 @@</span> <span class="p_context"> static void cplds_irq_unmask(struct irq_data *d)</span>
 
 static struct irq_chip cplds_irq_chip = {
 	.name		= &quot;pxa_cplds&quot;,
<span class="p_del">-	.irq_mask_ack	= cplds_irq_mask_ack,</span>
<span class="p_add">+	.irq_ack	= cplds_irq_mask,</span>
<span class="p_add">+	.irq_mask	= cplds_irq_mask,</span>
 	.irq_unmask	= cplds_irq_unmask,
 	.flags		= IRQCHIP_MASK_ON_SUSPEND | IRQCHIP_SKIP_SET_WAKE,
 };
<span class="p_header">diff --git a/arch/arm/mach-pxa/sharpsl_pm.c b/arch/arm/mach-pxa/sharpsl_pm.c</span>
<span class="p_header">index b80eab9993c5..249b7bd5fbc4 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/sharpsl_pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/sharpsl_pm.c</span>
<span class="p_chunk">@@ -744,7 +744,7 @@</span> <span class="p_context"> static int sharpsl_off_charge_battery(void)</span>
 		time = RCNR;
 		while (1) {
 			/* Check if any wakeup event had occurred */
<span class="p_del">-			if (sharpsl_pm.machinfo-&gt;charger_wakeup() != 0)</span>
<span class="p_add">+			if (sharpsl_pm.machinfo-&gt;charger_wakeup())</span>
 				return 0;
 			/* Check for timeout */
 			if ((RCNR - time) &gt; SHARPSL_WAIT_CO_TIME)
<span class="p_header">diff --git a/arch/arm/mach-pxa/sharpsl_pm.h b/arch/arm/mach-pxa/sharpsl_pm.h</span>
<span class="p_header">index 905be6755f04..fa75b6df8134 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/sharpsl_pm.h</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/sharpsl_pm.h</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"> struct sharpsl_charger_machinfo {</span>
 #define SHARPSL_STATUS_LOCK     5
 #define SHARPSL_STATUS_CHRGFULL 6
 #define SHARPSL_STATUS_FATAL    7
<span class="p_del">-	unsigned long (*charger_wakeup)(void);</span>
<span class="p_add">+	bool (*charger_wakeup)(void);</span>
 	int (*should_wakeup)(unsigned int resume_on_alarm);
 	void (*backlight_limit)(int);
 	int (*backlight_get_status) (void);
<span class="p_header">diff --git a/arch/arm/mach-pxa/spitz_pm.c b/arch/arm/mach-pxa/spitz_pm.c</span>
<span class="p_header">index ea9f9034cb54..4e64a140252e 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/spitz_pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/spitz_pm.c</span>
<span class="p_chunk">@@ -165,13 +165,10 @@</span> <span class="p_context"> static int spitz_should_wakeup(unsigned int resume_on_alarm)</span>
 	return is_resume;
 }
 
<span class="p_del">-static unsigned long spitz_charger_wakeup(void)</span>
<span class="p_add">+static bool spitz_charger_wakeup(void)</span>
 {
<span class="p_del">-	unsigned long ret;</span>
<span class="p_del">-	ret = ((!gpio_get_value(SPITZ_GPIO_KEY_INT)</span>
<span class="p_del">-		&lt;&lt; GPIO_bit(SPITZ_GPIO_KEY_INT))</span>
<span class="p_del">-		| gpio_get_value(SPITZ_GPIO_SYNC));</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return !gpio_get_value(SPITZ_GPIO_KEY_INT) ||</span>
<span class="p_add">+		gpio_get_value(SPITZ_GPIO_SYNC);</span>
 }
 
 unsigned long spitzpm_read_devdata(int type)
<span class="p_header">diff --git a/arch/powerpc/include/asm/book3s/64/pgtable.h b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_header">index 263bf39ced40..9bd84ba06ec4 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/book3s/64/pgtable.h</span>
<span class="p_chunk">@@ -6,6 +6,8 @@</span> <span class="p_context"></span>
  */
 #define _PAGE_BIT_SWAP_TYPE	0
 
<span class="p_add">+#define _PAGE_RO		0</span>
<span class="p_add">+</span>
 #define _PAGE_EXEC		0x00001 /* execute permission */
 #define _PAGE_WRITE		0x00002 /* write access allowed */
 #define _PAGE_READ		0x00004	/* read access allowed */
<span class="p_header">diff --git a/arch/powerpc/kernel/nvram_64.c b/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_header">index 64174bf95611..05a0a913ec38 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_chunk">@@ -956,7 +956,7 @@</span> <span class="p_context"> int __init nvram_remove_partition(const char *name, int sig,</span>
 
 		/* Make partition a free partition */
 		part-&gt;header.signature = NVRAM_SIG_FREE;
<span class="p_del">-		strncpy(part-&gt;header.name, &quot;wwwwwwwwwwww&quot;, 12);</span>
<span class="p_add">+		memset(part-&gt;header.name, &#39;w&#39;, 12);</span>
 		part-&gt;header.checksum = nvram_checksum(&amp;part-&gt;header);
 		rc = nvram_write_header(part);
 		if (rc &lt;= 0) {
<span class="p_chunk">@@ -974,8 +974,8 @@</span> <span class="p_context"> int __init nvram_remove_partition(const char *name, int sig,</span>
 		}
 		if (prev) {
 			prev-&gt;header.length += part-&gt;header.length;
<span class="p_del">-			prev-&gt;header.checksum = nvram_checksum(&amp;part-&gt;header);</span>
<span class="p_del">-			rc = nvram_write_header(part);</span>
<span class="p_add">+			prev-&gt;header.checksum = nvram_checksum(&amp;prev-&gt;header);</span>
<span class="p_add">+			rc = nvram_write_header(prev);</span>
 			if (rc &lt;= 0) {
 				printk(KERN_ERR &quot;nvram_remove_partition: nvram_write failed (%d)\n&quot;, rc);
 				return rc;
<span class="p_header">diff --git a/arch/powerpc/kernel/process.c b/arch/powerpc/kernel/process.c</span>
<span class="p_header">index 9ee2623e0f67..ad37aa175f59 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/process.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/process.c</span>
<span class="p_chunk">@@ -88,7 +88,13 @@</span> <span class="p_context"> static void check_if_tm_restore_required(struct task_struct *tsk)</span>
 		set_thread_flag(TIF_RESTORE_TM);
 	}
 }
<span class="p_add">+</span>
<span class="p_add">+static inline bool msr_tm_active(unsigned long msr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return MSR_TM_ACTIVE(msr);</span>
<span class="p_add">+}</span>
 #else
<span class="p_add">+static inline bool msr_tm_active(unsigned long msr) { return false; }</span>
 static inline void check_if_tm_restore_required(struct task_struct *tsk) { }
 #endif /* CONFIG_PPC_TRANSACTIONAL_MEM */
 
<span class="p_chunk">@@ -208,7 +214,7 @@</span> <span class="p_context"> void enable_kernel_fp(void)</span>
 EXPORT_SYMBOL(enable_kernel_fp);
 
 static int restore_fp(struct task_struct *tsk) {
<span class="p_del">-	if (tsk-&gt;thread.load_fp) {</span>
<span class="p_add">+	if (tsk-&gt;thread.load_fp || msr_tm_active(tsk-&gt;thread.regs-&gt;msr)) {</span>
 		load_fp_state(&amp;current-&gt;thread.fp_state);
 		current-&gt;thread.load_fp++;
 		return 1;
<span class="p_chunk">@@ -278,7 +284,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(flush_altivec_to_thread);</span>
 
 static int restore_altivec(struct task_struct *tsk)
 {
<span class="p_del">-	if (cpu_has_feature(CPU_FTR_ALTIVEC) &amp;&amp; tsk-&gt;thread.load_vec) {</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ALTIVEC) &amp;&amp;</span>
<span class="p_add">+		(tsk-&gt;thread.load_vec || msr_tm_active(tsk-&gt;thread.regs-&gt;msr))) {</span>
 		load_vr_state(&amp;tsk-&gt;thread.vr_state);
 		tsk-&gt;thread.used_vr = 1;
 		tsk-&gt;thread.load_vec++;
<span class="p_chunk">@@ -438,6 +445,7 @@</span> <span class="p_context"> void giveup_all(struct task_struct *tsk)</span>
 		return;
 
 	msr_check_and_set(msr_all_available);
<span class="p_add">+	check_if_tm_restore_required(tsk);</span>
 
 #ifdef CONFIG_PPC_FPU
 	if (usermsr &amp; MSR_FP)
<span class="p_chunk">@@ -464,7 +472,8 @@</span> <span class="p_context"> void restore_math(struct pt_regs *regs)</span>
 {
 	unsigned long msr;
 
<span class="p_del">-	if (!current-&gt;thread.load_fp &amp;&amp; !loadvec(current-&gt;thread))</span>
<span class="p_add">+	if (!msr_tm_active(regs-&gt;msr) &amp;&amp;</span>
<span class="p_add">+		!current-&gt;thread.load_fp &amp;&amp; !loadvec(current-&gt;thread))</span>
 		return;
 
 	msr = regs-&gt;msr;
<span class="p_chunk">@@ -983,6 +992,13 @@</span> <span class="p_context"> void restore_tm_state(struct pt_regs *regs)</span>
 	msr_diff = current-&gt;thread.ckpt_regs.msr &amp; ~regs-&gt;msr;
 	msr_diff &amp;= MSR_FP | MSR_VEC | MSR_VSX;
 
<span class="p_add">+	/* Ensure that restore_math() will restore */</span>
<span class="p_add">+	if (msr_diff &amp; MSR_FP)</span>
<span class="p_add">+		current-&gt;thread.load_fp = 1;</span>
<span class="p_add">+#ifdef CONFIG_ALIVEC</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ALTIVEC) &amp;&amp; msr_diff &amp; MSR_VEC)</span>
<span class="p_add">+		current-&gt;thread.load_vec = 1;</span>
<span class="p_add">+#endif</span>
 	restore_math(regs);
 
 	regs-&gt;msr |= msr_diff;
<span class="p_header">diff --git a/arch/powerpc/mm/hugetlbpage.c b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_header">index 7372ee13eb1e..a5d3ecdabc44 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -1019,8 +1019,15 @@</span> <span class="p_context"> int gup_hugepte(pte_t *ptep, unsigned long sz, unsigned long addr,</span>
 
 	pte = READ_ONCE(*ptep);
 	mask = _PAGE_PRESENT | _PAGE_READ;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On some CPUs like the 8xx, _PAGE_RW hence _PAGE_WRITE is defined</span>
<span class="p_add">+	 * as 0 and _PAGE_RO has to be set when a page is not writable</span>
<span class="p_add">+	 */</span>
 	if (write)
 		mask |= _PAGE_WRITE;
<span class="p_add">+	else</span>
<span class="p_add">+		mask |= _PAGE_RO;</span>
 
 	if ((pte_val(pte) &amp; mask) != mask)
 		return 0;
<span class="p_header">diff --git a/arch/x86/kernel/early-quirks.c b/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">index de7501edb21c..8b8852bc2f4a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/early-quirks.c</span>
<span class="p_header">+++ b/arch/x86/kernel/early-quirks.c</span>
<span class="p_chunk">@@ -317,16 +317,11 @@</span> <span class="p_context"> static phys_addr_t __init i85x_stolen_base(int num, int slot, int func,</span>
 static phys_addr_t __init i865_stolen_base(int num, int slot, int func,
 					   size_t stolen_size)
 {
<span class="p_del">-	u16 toud;</span>
<span class="p_add">+	u16 toud = 0;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * FIXME is the graphics stolen memory region</span>
<span class="p_del">-	 * always at TOUD? Ie. is it always the last</span>
<span class="p_del">-	 * one to be allocated by the BIOS?</span>
<span class="p_del">-	 */</span>
 	toud = read_pci_config_16(0, 0, 0, I865_TOUD);
 
<span class="p_del">-	return (phys_addr_t)toud &lt;&lt; 16;</span>
<span class="p_add">+	return (phys_addr_t)(toud &lt;&lt; 16) + i845_tseg_size();</span>
 }
 
 static phys_addr_t __init gen3_stolen_base(int num, int slot, int func,
<span class="p_header">diff --git a/crypto/gcm.c b/crypto/gcm.c</span>
<span class="p_header">index 70a892e87ccb..f624ac98c94e 100644</span>
<span class="p_header">--- a/crypto/gcm.c</span>
<span class="p_header">+++ b/crypto/gcm.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static int crypto_gcm_setkey(struct crypto_aead *aead, const u8 *key,</span>
 	struct crypto_skcipher *ctr = ctx-&gt;ctr;
 	struct {
 		be128 hash;
<span class="p_del">-		u8 iv[8];</span>
<span class="p_add">+		u8 iv[16];</span>
 
 		struct crypto_gcm_setkey_result result;
 
<span class="p_header">diff --git a/drivers/char/hw_random/omap-rng.c b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">index 01d4be2c354b..f5c26a5f6875 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/omap-rng.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/omap-rng.c</span>
<span class="p_chunk">@@ -385,7 +385,7 @@</span> <span class="p_context"> static int omap_rng_probe(struct platform_device *pdev)</span>
 
 	pm_runtime_enable(&amp;pdev-&gt;dev);
 	ret = pm_runtime_get_sync(&amp;pdev-&gt;dev);
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);
 		pm_runtime_put_noidle(&amp;pdev-&gt;dev);
 		goto err_ioremap;
<span class="p_chunk">@@ -443,7 +443,7 @@</span> <span class="p_context"> static int __maybe_unused omap_rng_resume(struct device *dev)</span>
 	int ret;
 
 	ret = pm_runtime_get_sync(dev);
<span class="p_del">-	if (ret) {</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
 		dev_err(dev, &quot;Failed to runtime_get device: %d\n&quot;, ret);
 		pm_runtime_put_noidle(dev);
 		return ret;
<span class="p_header">diff --git a/drivers/clk/bcm/clk-bcm2835.c b/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_header">index 7a7970865c2d..0fc71cbaa440 100644</span>
<span class="p_header">--- a/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_header">+++ b/drivers/clk/bcm/clk-bcm2835.c</span>
<span class="p_chunk">@@ -1006,16 +1006,28 @@</span> <span class="p_context"> static int bcm2835_clock_set_rate(struct clk_hw *hw,</span>
 	return 0;
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+bcm2835_clk_is_pllc(struct clk_hw *hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!hw)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return strncmp(clk_hw_get_name(hw), &quot;pllc&quot;, 4) == 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bcm2835_clock_determine_rate(struct clk_hw *hw,
 					struct clk_rate_request *req)
 {
 	struct bcm2835_clock *clock = bcm2835_clock_from_hw(hw);
 	struct clk_hw *parent, *best_parent = NULL;
<span class="p_add">+	bool current_parent_is_pllc;</span>
 	unsigned long rate, best_rate = 0;
 	unsigned long prate, best_prate = 0;
 	size_t i;
 	u32 div;
 
<span class="p_add">+	current_parent_is_pllc = bcm2835_clk_is_pllc(clk_hw_get_parent(hw));</span>
<span class="p_add">+</span>
 	/*
 	 * Select parent clock that results in the closest but lower rate
 	 */
<span class="p_chunk">@@ -1023,6 +1035,17 @@</span> <span class="p_context"> static int bcm2835_clock_determine_rate(struct clk_hw *hw,</span>
 		parent = clk_hw_get_parent_by_index(hw, i);
 		if (!parent)
 			continue;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Don&#39;t choose a PLLC-derived clock as our parent</span>
<span class="p_add">+		 * unless it had been manually set that way.  PLLC&#39;s</span>
<span class="p_add">+		 * frequency gets adjusted by the firmware due to</span>
<span class="p_add">+		 * over-temp or under-voltage conditions, without</span>
<span class="p_add">+		 * prior notification to our clock consumer.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (bcm2835_clk_is_pllc(parent) &amp;&amp; !current_parent_is_pllc)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		prate = clk_hw_get_rate(parent);
 		div = bcm2835_clock_choose_div(hw, req-&gt;rate, prate, true);
 		rate = bcm2835_clock_rate_from_divisor(clock, prate, div);
<span class="p_header">diff --git a/drivers/clk/clk-divider.c b/drivers/clk/clk-divider.c</span>
<span class="p_header">index a0f55bc1ad3d..96386ffc8483 100644</span>
<span class="p_header">--- a/drivers/clk/clk-divider.c</span>
<span class="p_header">+++ b/drivers/clk/clk-divider.c</span>
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> static long clk_divider_round_rate(struct clk_hw *hw, unsigned long rate,</span>
 
 	/* if read only, just return current value */
 	if (divider-&gt;flags &amp; CLK_DIVIDER_READ_ONLY) {
<span class="p_del">-		bestdiv = readl(divider-&gt;reg) &gt;&gt; divider-&gt;shift;</span>
<span class="p_add">+		bestdiv = clk_readl(divider-&gt;reg) &gt;&gt; divider-&gt;shift;</span>
 		bestdiv &amp;= div_mask(divider-&gt;width);
 		bestdiv = _get_div(divider-&gt;table, bestdiv, divider-&gt;flags,
 			divider-&gt;width);
<span class="p_header">diff --git a/drivers/clk/clk-qoriq.c b/drivers/clk/clk-qoriq.c</span>
<span class="p_header">index 58566a17944a..20b105584f82 100644</span>
<span class="p_header">--- a/drivers/clk/clk-qoriq.c</span>
<span class="p_header">+++ b/drivers/clk/clk-qoriq.c</span>
<span class="p_chunk">@@ -766,7 +766,11 @@</span> <span class="p_context"> static struct clk * __init create_one_cmux(struct clockgen *cg, int idx)</span>
 	if (!hwc)
 		return NULL;
 
<span class="p_del">-	hwc-&gt;reg = cg-&gt;regs + 0x20 * idx;</span>
<span class="p_add">+	if (cg-&gt;info.flags &amp; CG_VER3)</span>
<span class="p_add">+		hwc-&gt;reg = cg-&gt;regs + 0x70000 + 0x20 * idx;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		hwc-&gt;reg = cg-&gt;regs + 0x20 * idx;</span>
<span class="p_add">+</span>
 	hwc-&gt;info = cg-&gt;info.cmux_groups[cg-&gt;info.cmux_to_group[idx]];
 
 	/*
<span class="p_header">diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c</span>
<span class="p_header">index 820a939fb6bb..2877a4ddeda2 100644</span>
<span class="p_header">--- a/drivers/clk/clk.c</span>
<span class="p_header">+++ b/drivers/clk/clk.c</span>
<span class="p_chunk">@@ -1908,10 +1908,6 @@</span> <span class="p_context"> int clk_set_phase(struct clk *clk, int degrees)</span>
 
 	clk_prepare_lock();
 
<span class="p_del">-	/* bail early if nothing to do */</span>
<span class="p_del">-	if (degrees == clk-&gt;core-&gt;phase)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	trace_clk_set_phase(clk-&gt;core, degrees);
 
 	if (clk-&gt;core-&gt;ops-&gt;set_phase)
<span class="p_chunk">@@ -1922,7 +1918,6 @@</span> <span class="p_context"> int clk_set_phase(struct clk *clk, int degrees)</span>
 	if (!ret)
 		clk-&gt;core-&gt;phase = degrees;
 
<span class="p_del">-out:</span>
 	clk_prepare_unlock();
 
 	return ret;
<span class="p_chunk">@@ -3186,7 +3181,7 @@</span> <span class="p_context"> struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,</span>
 {
 	struct of_clk_provider *provider;
 	struct clk *clk = ERR_PTR(-EPROBE_DEFER);
<span class="p_del">-	struct clk_hw *hw = ERR_PTR(-EPROBE_DEFER);</span>
<span class="p_add">+	struct clk_hw *hw;</span>
 
 	if (!clkspec)
 		return ERR_PTR(-EINVAL);
<span class="p_chunk">@@ -3194,12 +3189,13 @@</span> <span class="p_context"> struct clk *__of_clk_get_from_provider(struct of_phandle_args *clkspec,</span>
 	/* Check if we have such a provider in our array */
 	mutex_lock(&amp;of_clk_mutex);
 	list_for_each_entry(provider, &amp;of_clk_providers, link) {
<span class="p_del">-		if (provider-&gt;node == clkspec-&gt;np)</span>
<span class="p_add">+		if (provider-&gt;node == clkspec-&gt;np) {</span>
 			hw = __of_clk_get_hw_from_provider(provider, clkspec);
<span class="p_del">-		if (!IS_ERR(hw)) {</span>
 			clk = __clk_create_clk(hw, dev_id, con_id);
<span class="p_add">+		}</span>
 
<span class="p_del">-			if (!IS_ERR(clk) &amp;&amp; !__clk_get(clk)) {</span>
<span class="p_add">+		if (!IS_ERR(clk)) {</span>
<span class="p_add">+			if (!__clk_get(clk)) {</span>
 				__clk_free_clk(clk);
 				clk = ERR_PTR(-ENOENT);
 			}
<span class="p_header">diff --git a/drivers/clk/imx/clk-imx35.c b/drivers/clk/imx/clk-imx35.c</span>
<span class="p_header">index b0978d3b83e2..d302ed3b8225 100644</span>
<span class="p_header">--- a/drivers/clk/imx/clk-imx35.c</span>
<span class="p_header">+++ b/drivers/clk/imx/clk-imx35.c</span>
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> static void __init _mx35_clocks_init(void)</span>
 	}
 
 	clk[ckih] = imx_clk_fixed(&quot;ckih&quot;, 24000000);
<span class="p_del">-	clk[ckil] = imx_clk_fixed(&quot;ckih&quot;, 32768);</span>
<span class="p_add">+	clk[ckil] = imx_clk_fixed(&quot;ckil&quot;, 32768);</span>
 	clk[mpll] = imx_clk_pllv1(IMX_PLLV1_IMX35, &quot;mpll&quot;, &quot;ckih&quot;, base + MX35_CCM_MPCTL);
 	clk[ppll] = imx_clk_pllv1(IMX_PLLV1_IMX35, &quot;ppll&quot;, &quot;ckih&quot;, base + MX35_CCM_PPCTL);
 
<span class="p_header">diff --git a/drivers/clk/qcom/Kconfig b/drivers/clk/qcom/Kconfig</span>
<span class="p_header">index 95e3b3e0fa1c..98909b184d44 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/Kconfig</span>
<span class="p_header">+++ b/drivers/clk/qcom/Kconfig</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> config MSM_MMCC_8974</span>
 
 config MSM_GCC_8996
 	tristate &quot;MSM8996 Global Clock Controller&quot;
<span class="p_add">+	select QCOM_GDSC</span>
 	depends on COMMON_CLK_QCOM
 	help
 	  Support for the global clock controller on msm8996 devices.
<span class="p_chunk">@@ -126,6 +127,7 @@</span> <span class="p_context"> config MSM_GCC_8996</span>
 config MSM_MMCC_8996
 	tristate &quot;MSM8996 Multimedia Clock Controller&quot;
 	select MSM_GCC_8996
<span class="p_add">+	select QCOM_GDSC</span>
 	depends on COMMON_CLK_QCOM
 	help
 	  Support for the multimedia clock controller on msm8996 devices.
<span class="p_header">diff --git a/drivers/clk/qcom/gcc-msm8996.c b/drivers/clk/qcom/gcc-msm8996.c</span>
<span class="p_header">index bbf732bbc3fd..9f643cca85d0 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/gcc-msm8996.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/gcc-msm8996.c</span>
<span class="p_chunk">@@ -2592,9 +2592,9 @@</span> <span class="p_context"> static struct clk_branch gcc_pcie_2_aux_clk = {</span>
 };
 
 static struct clk_branch gcc_pcie_2_pipe_clk = {
<span class="p_del">-	.halt_reg = 0x6e108,</span>
<span class="p_add">+	.halt_reg = 0x6e018,</span>
 	.clkr = {
<span class="p_del">-		.enable_reg = 0x6e108,</span>
<span class="p_add">+		.enable_reg = 0x6e018,</span>
 		.enable_mask = BIT(0),
 		.hw.init = &amp;(struct clk_init_data){
 			.name = &quot;gcc_pcie_2_pipe_clk&quot;,
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-dmaengine.c b/drivers/crypto/ccp/ccp-dmaengine.c</span>
<span class="p_header">index 94f77b0f9ae7..32f645ea77b8 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-dmaengine.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-dmaengine.c</span>
<span class="p_chunk">@@ -650,7 +650,7 @@</span> <span class="p_context"> int ccp_dmaengine_register(struct ccp_device *ccp)</span>
 	dma_desc_cache_name = devm_kasprintf(ccp-&gt;dev, GFP_KERNEL,
 					     &quot;%s-dmaengine-desc-cache&quot;,
 					     ccp-&gt;name);
<span class="p_del">-	if (!dma_cmd_cache_name)</span>
<span class="p_add">+	if (!dma_desc_cache_name)</span>
 		return -ENOMEM;
 	ccp-&gt;dma_desc_cache = kmem_cache_create(dma_desc_cache_name,
 						sizeof(struct ccp_dma_desc),
<span class="p_header">diff --git a/drivers/crypto/marvell/cesa.c b/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">index d64af8625d7e..37dadb2a4feb 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/cesa.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/cesa.c</span>
<span class="p_chunk">@@ -166,6 +166,7 @@</span> <span class="p_context"> static irqreturn_t mv_cesa_int(int irq, void *priv)</span>
 			if (!req)
 				break;
 
<span class="p_add">+			ctx = crypto_tfm_ctx(req-&gt;tfm);</span>
 			mv_cesa_complete_req(ctx, req, 0);
 		}
 	}
<span class="p_header">diff --git a/drivers/crypto/marvell/hash.c b/drivers/crypto/marvell/hash.c</span>
<span class="p_header">index 82e0f4e6eb1c..b111e14bac1e 100644</span>
<span class="p_header">--- a/drivers/crypto/marvell/hash.c</span>
<span class="p_header">+++ b/drivers/crypto/marvell/hash.c</span>
<span class="p_chunk">@@ -805,13 +805,14 @@</span> <span class="p_context"> static int mv_cesa_md5_init(struct ahash_request *req)</span>
 	struct mv_cesa_op_ctx tmpl = { };
 
 	mv_cesa_set_op_cfg(&amp;tmpl, CESA_SA_DESC_CFG_MACM_MD5);
<span class="p_add">+</span>
<span class="p_add">+	mv_cesa_ahash_init(req, &amp;tmpl, true);</span>
<span class="p_add">+</span>
 	creq-&gt;state[0] = MD5_H0;
 	creq-&gt;state[1] = MD5_H1;
 	creq-&gt;state[2] = MD5_H2;
 	creq-&gt;state[3] = MD5_H3;
 
<span class="p_del">-	mv_cesa_ahash_init(req, &amp;tmpl, true);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -873,14 +874,15 @@</span> <span class="p_context"> static int mv_cesa_sha1_init(struct ahash_request *req)</span>
 	struct mv_cesa_op_ctx tmpl = { };
 
 	mv_cesa_set_op_cfg(&amp;tmpl, CESA_SA_DESC_CFG_MACM_SHA1);
<span class="p_add">+</span>
<span class="p_add">+	mv_cesa_ahash_init(req, &amp;tmpl, false);</span>
<span class="p_add">+</span>
 	creq-&gt;state[0] = SHA1_H0;
 	creq-&gt;state[1] = SHA1_H1;
 	creq-&gt;state[2] = SHA1_H2;
 	creq-&gt;state[3] = SHA1_H3;
 	creq-&gt;state[4] = SHA1_H4;
 
<span class="p_del">-	mv_cesa_ahash_init(req, &amp;tmpl, false);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -942,6 +944,9 @@</span> <span class="p_context"> static int mv_cesa_sha256_init(struct ahash_request *req)</span>
 	struct mv_cesa_op_ctx tmpl = { };
 
 	mv_cesa_set_op_cfg(&amp;tmpl, CESA_SA_DESC_CFG_MACM_SHA256);
<span class="p_add">+</span>
<span class="p_add">+	mv_cesa_ahash_init(req, &amp;tmpl, false);</span>
<span class="p_add">+</span>
 	creq-&gt;state[0] = SHA256_H0;
 	creq-&gt;state[1] = SHA256_H1;
 	creq-&gt;state[2] = SHA256_H2;
<span class="p_chunk">@@ -951,8 +956,6 @@</span> <span class="p_context"> static int mv_cesa_sha256_init(struct ahash_request *req)</span>
 	creq-&gt;state[6] = SHA256_H6;
 	creq-&gt;state[7] = SHA256_H7;
 
<span class="p_del">-	mv_cesa_ahash_init(req, &amp;tmpl, false);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/dma/ipu/ipu_irq.c b/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_header">index 2bf37e68ad0f..dd184b50e5b4 100644</span>
<span class="p_header">--- a/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_header">+++ b/drivers/dma/ipu/ipu_irq.c</span>
<span class="p_chunk">@@ -286,22 +286,21 @@</span> <span class="p_context"> static void ipu_irq_handler(struct irq_desc *desc)</span>
 		raw_spin_unlock(&amp;bank_lock);
 		while ((line = ffs(status))) {
 			struct ipu_irq_map *map;
<span class="p_del">-			unsigned int irq = NO_IRQ;</span>
<span class="p_add">+			unsigned int irq;</span>
 
 			line--;
 			status &amp;= ~(1UL &lt;&lt; line);
 
 			raw_spin_lock(&amp;bank_lock);
 			map = src2map(32 * i + line);
<span class="p_del">-			if (map)</span>
<span class="p_del">-				irq = map-&gt;irq;</span>
<span class="p_del">-			raw_spin_unlock(&amp;bank_lock);</span>
<span class="p_del">-</span>
 			if (!map) {
<span class="p_add">+				raw_spin_unlock(&amp;bank_lock);</span>
 				pr_err(&quot;IPU: Interrupt on unmapped source %u bank %d\n&quot;,
 				       line, i);
 				continue;
 			}
<span class="p_add">+			irq = map-&gt;irq;</span>
<span class="p_add">+			raw_spin_unlock(&amp;bank_lock);</span>
 			generic_handle_irq(irq);
 		}
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c</span>
<span class="p_header">index 17e13621fae9..4e71a680e91b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ctx.c</span>
<span class="p_chunk">@@ -43,6 +43,9 @@</span> <span class="p_context"> static int amdgpu_ctx_init(struct amdgpu_device *adev, struct amdgpu_ctx *ctx)</span>
 		ctx-&gt;rings[i].sequence = 1;
 		ctx-&gt;rings[i].fences = &amp;ctx-&gt;fences[amdgpu_sched_jobs * i];
 	}
<span class="p_add">+</span>
<span class="p_add">+	ctx-&gt;reset_counter = atomic_read(&amp;adev-&gt;gpu_reset_counter);</span>
<span class="p_add">+</span>
 	/* create context entity for each ring */
 	for (i = 0; i &lt; adev-&gt;num_rings; i++) {
 		struct amdgpu_ring *ring = adev-&gt;rings[i];
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_header">index fe36caf1b7d7..14f57d9915e3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_dpm.c</span>
<span class="p_chunk">@@ -113,24 +113,26 @@</span> <span class="p_context"> void amdgpu_dpm_print_ps_status(struct amdgpu_device *adev,</span>
 	printk(&quot;\n&quot;);
 }
 
<span class="p_add">+</span>
 u32 amdgpu_dpm_get_vblank_time(struct amdgpu_device *adev)
 {
 	struct drm_device *dev = adev-&gt;ddev;
 	struct drm_crtc *crtc;
 	struct amdgpu_crtc *amdgpu_crtc;
<span class="p_del">-	u32 line_time_us, vblank_lines;</span>
<span class="p_add">+	u32 vblank_in_pixels;</span>
 	u32 vblank_time_us = 0xffffffff; /* if the displays are off, vblank time is max */
 
 	if (adev-&gt;mode_info.num_crtc &amp;&amp; adev-&gt;mode_info.mode_config_initialized) {
 		list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
 			amdgpu_crtc = to_amdgpu_crtc(crtc);
 			if (crtc-&gt;enabled &amp;&amp; amdgpu_crtc-&gt;enabled &amp;&amp; amdgpu_crtc-&gt;hw_mode.clock) {
<span class="p_del">-				line_time_us = (amdgpu_crtc-&gt;hw_mode.crtc_htotal * 1000) /</span>
<span class="p_del">-					amdgpu_crtc-&gt;hw_mode.clock;</span>
<span class="p_del">-				vblank_lines = amdgpu_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_add">+				vblank_in_pixels =</span>
<span class="p_add">+					amdgpu_crtc-&gt;hw_mode.crtc_htotal *</span>
<span class="p_add">+					(amdgpu_crtc-&gt;hw_mode.crtc_vblank_end -</span>
 					amdgpu_crtc-&gt;hw_mode.crtc_vdisplay +
<span class="p_del">-					(amdgpu_crtc-&gt;v_border * 2);</span>
<span class="p_del">-				vblank_time_us = vblank_lines * line_time_us;</span>
<span class="p_add">+					(amdgpu_crtc-&gt;v_border * 2));</span>
<span class="p_add">+</span>
<span class="p_add">+				vblank_time_us = vblank_in_pixels * 1000 / amdgpu_crtc-&gt;hw_mode.clock;</span>
 				break;
 			}
 		}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">index d942654a1de0..e24a8af72d90 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_kms.c</span>
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> static int amdgpu_info_ioctl(struct drm_device *dev, void *data, struct drm_file</span>
 			type = AMD_IP_BLOCK_TYPE_UVD;
 			ring_mask = adev-&gt;uvd.ring.ready ? 1 : 0;
 			ib_start_alignment = AMDGPU_GPU_PAGE_SIZE;
<span class="p_del">-			ib_size_alignment = 8;</span>
<span class="p_add">+			ib_size_alignment = 16;</span>
 			break;
 		case AMDGPU_HW_IP_VCE:
 			type = AMD_IP_BLOCK_TYPE_VCE;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">index c1b04e9aab57..172bed946287 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_chunk">@@ -425,16 +425,6 @@</span> <span class="p_context"> static void dce_v10_0_hpd_init(struct amdgpu_device *adev)</span>
 	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {
 		struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
 
<span class="p_del">-		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_del">-		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_del">-			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_del">-			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_del">-			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_del">-			 * also avoid interrupt storms during dpms.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		switch (amdgpu_connector-&gt;hpd.hpd) {
 		case AMDGPU_HPD_1:
 			idx = 0;
<span class="p_chunk">@@ -458,6 +448,19 @@</span> <span class="p_context"> static void dce_v10_0_hpd_init(struct amdgpu_device *adev)</span>
 			continue;
 		}
 
<span class="p_add">+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_add">+		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_add">+			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_add">+			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_add">+			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_add">+			 * also avoid interrupt storms during dpms.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tmp = RREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx]);</span>
<span class="p_add">+			tmp = REG_SET_FIELD(tmp, DC_HPD_INT_CONTROL, DC_HPD_INT_EN, 0);</span>
<span class="p_add">+			WREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx], tmp);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		tmp = RREG32(mmDC_HPD_CONTROL + hpd_offsets[idx]);
 		tmp = REG_SET_FIELD(tmp, DC_HPD_CONTROL, DC_HPD_EN, 1);
 		WREG32(mmDC_HPD_CONTROL + hpd_offsets[idx], tmp);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">index d4bf133908b1..67c7c05a751c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_chunk">@@ -443,16 +443,6 @@</span> <span class="p_context"> static void dce_v11_0_hpd_init(struct amdgpu_device *adev)</span>
 	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {
 		struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
 
<span class="p_del">-		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_del">-		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_del">-			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_del">-			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_del">-			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_del">-			 * also avoid interrupt storms during dpms.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		switch (amdgpu_connector-&gt;hpd.hpd) {
 		case AMDGPU_HPD_1:
 			idx = 0;
<span class="p_chunk">@@ -476,6 +466,19 @@</span> <span class="p_context"> static void dce_v11_0_hpd_init(struct amdgpu_device *adev)</span>
 			continue;
 		}
 
<span class="p_add">+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_add">+		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_add">+			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_add">+			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_add">+			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_add">+			 * also avoid interrupt storms during dpms.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tmp = RREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx]);</span>
<span class="p_add">+			tmp = REG_SET_FIELD(tmp, DC_HPD_INT_CONTROL, DC_HPD_INT_EN, 0);</span>
<span class="p_add">+			WREG32(mmDC_HPD_INT_CONTROL + hpd_offsets[idx], tmp);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		tmp = RREG32(mmDC_HPD_CONTROL + hpd_offsets[idx]);
 		tmp = REG_SET_FIELD(tmp, DC_HPD_CONTROL, DC_HPD_EN, 1);
 		WREG32(mmDC_HPD_CONTROL + hpd_offsets[idx], tmp);
<span class="p_chunk">@@ -3109,6 +3112,7 @@</span> <span class="p_context"> static int dce_v11_0_sw_fini(void *handle)</span>
 
 	dce_v11_0_afmt_fini(adev);
 
<span class="p_add">+	drm_mode_config_cleanup(adev-&gt;ddev);</span>
 	adev-&gt;mode_info.mode_config_initialized = false;
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">index 4fdfab1e9200..ea07c50369b4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_chunk">@@ -395,15 +395,6 @@</span> <span class="p_context"> static void dce_v8_0_hpd_init(struct amdgpu_device *adev)</span>
 	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {
 		struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
 
<span class="p_del">-		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_del">-		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_del">-			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_del">-			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_del">-			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_del">-			 * also avoid interrupt storms during dpms.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
 		switch (amdgpu_connector-&gt;hpd.hpd) {
 		case AMDGPU_HPD_1:
 			WREG32(mmDC_HPD1_CONTROL, tmp);
<span class="p_chunk">@@ -426,6 +417,45 @@</span> <span class="p_context"> static void dce_v8_0_hpd_init(struct amdgpu_device *adev)</span>
 		default:
 			break;
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_eDP ||</span>
<span class="p_add">+		    connector-&gt;connector_type == DRM_MODE_CONNECTOR_LVDS) {</span>
<span class="p_add">+			/* don&#39;t try to enable hpd on eDP or LVDS avoid breaking the</span>
<span class="p_add">+			 * aux dp channel on imac and help (but not completely fix)</span>
<span class="p_add">+			 * https://bugzilla.redhat.com/show_bug.cgi?id=726143</span>
<span class="p_add">+			 * also avoid interrupt storms during dpms.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			u32 dc_hpd_int_cntl_reg, dc_hpd_int_cntl;</span>
<span class="p_add">+</span>
<span class="p_add">+			switch (amdgpu_connector-&gt;hpd.hpd) {</span>
<span class="p_add">+			case AMDGPU_HPD_1:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD1_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_2:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD2_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_3:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD3_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_4:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD4_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_5:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD5_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case AMDGPU_HPD_6:</span>
<span class="p_add">+				dc_hpd_int_cntl_reg = mmDC_HPD6_INT_CONTROL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			default:</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			dc_hpd_int_cntl = RREG32(dc_hpd_int_cntl_reg);</span>
<span class="p_add">+			dc_hpd_int_cntl &amp;= ~DC_HPD1_INT_CONTROL__DC_HPD1_INT_EN_MASK;</span>
<span class="p_add">+			WREG32(dc_hpd_int_cntl_reg, dc_hpd_int_cntl);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		dce_v8_0_hpd_set_polarity(adev, amdgpu_connector-&gt;hpd.hpd);
 		amdgpu_irq_get(adev, &amp;adev-&gt;hpd_irq, amdgpu_connector-&gt;hpd.hpd);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/eventmgr/eventactionchains.c b/drivers/gpu/drm/amd/powerplay/eventmgr/eventactionchains.c</span>
<span class="p_header">index 635fc4b48184..92b117843875 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/eventmgr/eventactionchains.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/eventmgr/eventactionchains.c</span>
<span class="p_chunk">@@ -262,6 +262,8 @@</span> <span class="p_context"> static const pem_event_action * const display_config_change_event[] = {</span>
 	unblock_adjust_power_state_tasks,
 	set_cpu_power_state,
 	notify_hw_power_source_tasks,
<span class="p_add">+	get_2d_performance_state_tasks,</span>
<span class="p_add">+	set_performance_state_tasks,</span>
 	/* updateDALConfigurationTasks,
 	variBrightDisplayConfigurationChangeTasks, */
 	adjust_power_state_tasks,
<span class="p_header">diff --git a/drivers/gpu/drm/amd/powerplay/eventmgr/psm.c b/drivers/gpu/drm/amd/powerplay/eventmgr/psm.c</span>
<span class="p_header">index a46225c0fc01..d6bee727497c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/powerplay/eventmgr/psm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/powerplay/eventmgr/psm.c</span>
<span class="p_chunk">@@ -100,11 +100,12 @@</span> <span class="p_context"> int psm_adjust_power_state_dynamic(struct pp_eventmgr *eventmgr, bool skip)</span>
 	if (requested == NULL)
 		return 0;
 
<span class="p_add">+	phm_apply_state_adjust_rules(hwmgr, requested, pcurrent);</span>
<span class="p_add">+</span>
 	if (pcurrent == NULL || (0 != phm_check_states_equal(hwmgr, &amp;pcurrent-&gt;hardware, &amp;requested-&gt;hardware, &amp;equal)))
 		equal = false;
 
 	if (!equal || phm_check_smc_update_required_for_display_configuration(hwmgr)) {
<span class="p_del">-		phm_apply_state_adjust_rules(hwmgr, requested, pcurrent);</span>
 		phm_set_power_state(hwmgr, &amp;pcurrent-&gt;hardware, &amp;requested-&gt;hardware);
 		hwmgr-&gt;current_ps = requested;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/drm_prime.c b/drivers/gpu/drm/drm_prime.c</span>
<span class="p_header">index 780589b420a4..9c4387d79d11 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_prime.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_prime.c</span>
<span class="p_chunk">@@ -335,14 +335,17 @@</span> <span class="p_context"> static const struct dma_buf_ops drm_gem_prime_dmabuf_ops =  {</span>
  * using the PRIME helpers.
  */
 struct dma_buf *drm_gem_prime_export(struct drm_device *dev,
<span class="p_del">-				     struct drm_gem_object *obj, int flags)</span>
<span class="p_add">+				     struct drm_gem_object *obj,</span>
<span class="p_add">+				     int flags)</span>
 {
<span class="p_del">-	DEFINE_DMA_BUF_EXPORT_INFO(exp_info);</span>
<span class="p_del">-</span>
<span class="p_del">-	exp_info.ops = &amp;drm_gem_prime_dmabuf_ops;</span>
<span class="p_del">-	exp_info.size = obj-&gt;size;</span>
<span class="p_del">-	exp_info.flags = flags;</span>
<span class="p_del">-	exp_info.priv = obj;</span>
<span class="p_add">+	struct dma_buf_export_info exp_info = {</span>
<span class="p_add">+		.exp_name = KBUILD_MODNAME, /* white lie for debug */</span>
<span class="p_add">+		.owner = dev-&gt;driver-&gt;fops-&gt;owner,</span>
<span class="p_add">+		.ops = &amp;drm_gem_prime_dmabuf_ops,</span>
<span class="p_add">+		.size = obj-&gt;size,</span>
<span class="p_add">+		.flags = flags,</span>
<span class="p_add">+		.priv = obj,</span>
<span class="p_add">+	};</span>
 
 	if (dev-&gt;driver-&gt;gem_prime_res_obj)
 		exp_info.resv = dev-&gt;driver-&gt;gem_prime_res_obj(obj);
<span class="p_header">diff --git a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c</span>
<span class="p_header">index 7882387f9bff..5fc8ebdf40b2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/fsl-dcu/fsl_dcu_drm_drv.c</span>
<span class="p_chunk">@@ -330,6 +330,7 @@</span> <span class="p_context"> static int fsl_dcu_drm_probe(struct platform_device *pdev)</span>
 	const char *pix_clk_in_name;
 	const struct of_device_id *id;
 	int ret;
<span class="p_add">+	u8 div_ratio_shift = 0;</span>
 
 	fsl_dev = devm_kzalloc(dev, sizeof(*fsl_dev), GFP_KERNEL);
 	if (!fsl_dev)
<span class="p_chunk">@@ -382,11 +383,14 @@</span> <span class="p_context"> static int fsl_dcu_drm_probe(struct platform_device *pdev)</span>
 		pix_clk_in = fsl_dev-&gt;clk;
 	}
 
<span class="p_add">+	if (of_property_read_bool(dev-&gt;of_node, &quot;big-endian&quot;))</span>
<span class="p_add">+		div_ratio_shift = 24;</span>
<span class="p_add">+</span>
 	pix_clk_in_name = __clk_get_name(pix_clk_in);
 	snprintf(pix_clk_name, sizeof(pix_clk_name), &quot;%s_pix&quot;, pix_clk_in_name);
 	fsl_dev-&gt;pix_clk = clk_register_divider(dev, pix_clk_name,
 			pix_clk_in_name, 0, base + DCU_DIV_RATIO,
<span class="p_del">-			0, 8, CLK_DIVIDER_ROUND_CLOSEST, NULL);</span>
<span class="p_add">+			div_ratio_shift, 8, CLK_DIVIDER_ROUND_CLOSEST, NULL);</span>
 	if (IS_ERR(fsl_dev-&gt;pix_clk)) {
 		dev_err(dev, &quot;failed to register pix clk\n&quot;);
 		ret = PTR_ERR(fsl_dev-&gt;pix_clk);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index f68c78918d63..84a00105871d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -631,6 +631,8 @@</span> <span class="p_context"> struct drm_i915_display_funcs {</span>
 				  struct intel_crtc_state *crtc_state);
 	void (*crtc_enable)(struct drm_crtc *crtc);
 	void (*crtc_disable)(struct drm_crtc *crtc);
<span class="p_add">+	void (*update_crtcs)(struct drm_atomic_state *state,</span>
<span class="p_add">+			     unsigned int *crtc_vblank_mask);</span>
 	void (*audio_codec_enable)(struct drm_connector *connector,
 				   struct intel_encoder *encoder,
 				   const struct drm_display_mode *adjusted_mode);
<span class="p_chunk">@@ -1965,11 +1967,11 @@</span> <span class="p_context"> struct drm_i915_private {</span>
 	struct vlv_s0ix_state vlv_s0ix_state;
 
 	enum {
<span class="p_del">-		I915_SKL_SAGV_UNKNOWN = 0,</span>
<span class="p_del">-		I915_SKL_SAGV_DISABLED,</span>
<span class="p_del">-		I915_SKL_SAGV_ENABLED,</span>
<span class="p_del">-		I915_SKL_SAGV_NOT_CONTROLLED</span>
<span class="p_del">-	} skl_sagv_status;</span>
<span class="p_add">+		I915_SAGV_UNKNOWN = 0,</span>
<span class="p_add">+		I915_SAGV_DISABLED,</span>
<span class="p_add">+		I915_SAGV_ENABLED,</span>
<span class="p_add">+		I915_SAGV_NOT_CONTROLLED</span>
<span class="p_add">+	} sagv_status;</span>
 
 	struct {
 		/*
<span class="p_chunk">@@ -2280,21 +2282,19 @@</span> <span class="p_context"> struct drm_i915_gem_object {</span>
 	/** Record of address bit 17 of each page at last unbind. */
 	unsigned long *bit_17;
 
<span class="p_del">-	union {</span>
<span class="p_del">-		/** for phy allocated objects */</span>
<span class="p_del">-		struct drm_dma_handle *phys_handle;</span>
<span class="p_del">-</span>
<span class="p_del">-		struct i915_gem_userptr {</span>
<span class="p_del">-			uintptr_t ptr;</span>
<span class="p_del">-			unsigned read_only :1;</span>
<span class="p_del">-			unsigned workers :4;</span>
<span class="p_add">+	struct i915_gem_userptr {</span>
<span class="p_add">+		uintptr_t ptr;</span>
<span class="p_add">+		unsigned read_only :1;</span>
<span class="p_add">+		unsigned workers :4;</span>
 #define I915_GEM_USERPTR_MAX_WORKERS 15
 
<span class="p_del">-			struct i915_mm_struct *mm;</span>
<span class="p_del">-			struct i915_mmu_object *mmu_object;</span>
<span class="p_del">-			struct work_struct *work;</span>
<span class="p_del">-		} userptr;</span>
<span class="p_del">-	};</span>
<span class="p_add">+		struct i915_mm_struct *mm;</span>
<span class="p_add">+		struct i915_mmu_object *mmu_object;</span>
<span class="p_add">+		struct work_struct *work;</span>
<span class="p_add">+	} userptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	/** for phys allocated objects */</span>
<span class="p_add">+	struct drm_dma_handle *phys_handle;</span>
 };
 #define to_intel_bo(x) container_of(x, struct drm_i915_gem_object, base)
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_stolen.c b/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_header">index 66be299a1486..2bb69f3c5b84 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_stolen.c</span>
<span class="p_chunk">@@ -115,17 +115,28 @@</span> <span class="p_context"> static unsigned long i915_stolen_to_physical(struct drm_device *dev)</span>
 
 		base = bsm &amp; INTEL_BSM_MASK;
 	} else if (IS_I865G(dev)) {
<span class="p_add">+		u32 tseg_size = 0;</span>
 		u16 toud = 0;
<span class="p_add">+		u8 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_bus_read_config_byte(dev-&gt;pdev-&gt;bus, PCI_DEVFN(0, 0),</span>
<span class="p_add">+					 I845_ESMRAMC, &amp;tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (tmp &amp; TSEG_ENABLE) {</span>
<span class="p_add">+			switch (tmp &amp; I845_TSEG_SIZE_MASK) {</span>
<span class="p_add">+			case I845_TSEG_SIZE_512K:</span>
<span class="p_add">+				tseg_size = KB(512);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case I845_TSEG_SIZE_1M:</span>
<span class="p_add">+				tseg_size = MB(1);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * FIXME is the graphics stolen memory region</span>
<span class="p_del">-		 * always at TOUD? Ie. is it always the last</span>
<span class="p_del">-		 * one to be allocated by the BIOS?</span>
<span class="p_del">-		 */</span>
 		pci_bus_read_config_word(dev-&gt;pdev-&gt;bus, PCI_DEVFN(0, 0),
 					 I865_TOUD, &amp;toud);
 
<span class="p_del">-		base = toud &lt;&lt; 16;</span>
<span class="p_add">+		base = (toud &lt;&lt; 16) + tseg_size;</span>
 	} else if (IS_I85X(dev)) {
 		u32 tseg_size = 0;
 		u32 tom;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 175595fc3e45..e9a64fba6333 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -2980,6 +2980,7 @@</span> <span class="p_context"> static void skylake_update_primary_plane(struct drm_plane *plane,</span>
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc_state-&gt;base.crtc);
 	struct drm_framebuffer *fb = plane_state-&gt;base.fb;
 	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
<span class="p_add">+	const struct skl_wm_values *wm = &amp;dev_priv-&gt;wm.skl_results;</span>
 	int pipe = intel_crtc-&gt;pipe;
 	u32 plane_ctl, stride_div, stride;
 	u32 tile_height, plane_offset, plane_size;
<span class="p_chunk">@@ -3031,6 +3032,9 @@</span> <span class="p_context"> static void skylake_update_primary_plane(struct drm_plane *plane,</span>
 	intel_crtc-&gt;adjusted_x = x_offset;
 	intel_crtc-&gt;adjusted_y = y_offset;
 
<span class="p_add">+	if (wm-&gt;dirty_pipes &amp; drm_crtc_mask(&amp;intel_crtc-&gt;base))</span>
<span class="p_add">+		skl_write_plane_wm(intel_crtc, wm, 0);</span>
<span class="p_add">+</span>
 	I915_WRITE(PLANE_CTL(pipe, 0), plane_ctl);
 	I915_WRITE(PLANE_OFFSET(pipe, 0), plane_offset);
 	I915_WRITE(PLANE_SIZE(pipe, 0), plane_size);
<span class="p_chunk">@@ -3061,7 +3065,15 @@</span> <span class="p_context"> static void skylake_disable_primary_plane(struct drm_plane *primary,</span>
 {
 	struct drm_device *dev = crtc-&gt;dev;
 	struct drm_i915_private *dev_priv = to_i915(dev);
<span class="p_del">-	int pipe = to_intel_crtc(crtc)-&gt;pipe;</span>
<span class="p_add">+	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);</span>
<span class="p_add">+	int pipe = intel_crtc-&gt;pipe;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only populate skl_results on watermark updates, and if the</span>
<span class="p_add">+	 * plane&#39;s visiblity isn&#39;t actually changing neither is its watermarks.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!to_intel_plane_state(crtc-&gt;primary-&gt;state)-&gt;visible)</span>
<span class="p_add">+		skl_write_plane_wm(intel_crtc, &amp;dev_priv-&gt;wm.skl_results, 0);</span>
 
 	I915_WRITE(PLANE_CTL(pipe, 0), 0);
 	I915_WRITE(PLANE_SURF(pipe, 0), 0);
<span class="p_chunk">@@ -8995,6 +9007,24 @@</span> <span class="p_context"> static void ironlake_compute_dpll(struct intel_crtc *intel_crtc,</span>
 	if (intel_crtc_has_dp_encoder(crtc_state))
 		dpll |= DPLL_SDVO_HIGH_SPEED;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The high speed IO clock is only really required for</span>
<span class="p_add">+	 * SDVO/HDMI/DP, but we also enable it for CRT to make it</span>
<span class="p_add">+	 * possible to share the DPLL between CRT and HDMI. Enabling</span>
<span class="p_add">+	 * the clock needlessly does no real harm, except use up a</span>
<span class="p_add">+	 * bit of power potentially.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We&#39;ll limit this to IVB with 3 pipes, since it has only two</span>
<span class="p_add">+	 * DPLLs and so DPLL sharing is the only way to get three pipes</span>
<span class="p_add">+	 * driving PCH ports at the same time. On SNB we could do this,</span>
<span class="p_add">+	 * and potentially avoid enabling the second DPLL, but it&#39;s not</span>
<span class="p_add">+	 * clear if it&#39;&#39;s a win or loss power wise. No point in doing</span>
<span class="p_add">+	 * this on ILK at all since it has a fixed DPLL&lt;-&gt;pipe mapping.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (INTEL_INFO(dev_priv)-&gt;num_pipes == 3 &amp;&amp;</span>
<span class="p_add">+	    intel_crtc_has_type(crtc_state, INTEL_OUTPUT_ANALOG))</span>
<span class="p_add">+		dpll |= DPLL_SDVO_HIGH_SPEED;</span>
<span class="p_add">+</span>
 	/* compute bitmask from p1 value */
 	dpll |= (1 &lt;&lt; (crtc_state-&gt;dpll.p1 - 1)) &lt;&lt; DPLL_FPA01_P1_POST_DIV_SHIFT;
 	/* also FPA1 */
<span class="p_chunk">@@ -10306,9 +10336,13 @@</span> <span class="p_context"> static void i9xx_update_cursor(struct drm_crtc *crtc, u32 base,</span>
 	struct drm_device *dev = crtc-&gt;dev;
 	struct drm_i915_private *dev_priv = to_i915(dev);
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
<span class="p_add">+	const struct skl_wm_values *wm = &amp;dev_priv-&gt;wm.skl_results;</span>
 	int pipe = intel_crtc-&gt;pipe;
 	uint32_t cntl = 0;
 
<span class="p_add">+	if (INTEL_GEN(dev_priv) &gt;= 9 &amp;&amp; wm-&gt;dirty_pipes &amp; drm_crtc_mask(crtc))</span>
<span class="p_add">+		skl_write_cursor_wm(intel_crtc, wm);</span>
<span class="p_add">+</span>
 	if (plane_state &amp;&amp; plane_state-&gt;visible) {
 		cntl = MCURSOR_GAMMA_ENABLE;
 		switch (plane_state-&gt;base.crtc_w) {
<span class="p_chunk">@@ -12956,16 +12990,23 @@</span> <span class="p_context"> static void verify_wm_state(struct drm_crtc *crtc,</span>
 			  hw_entry-&gt;start, hw_entry-&gt;end);
 	}
 
<span class="p_del">-	/* cursor */</span>
<span class="p_del">-	hw_entry = &amp;hw_ddb.plane[pipe][PLANE_CURSOR];</span>
<span class="p_del">-	sw_entry = &amp;sw_ddb-&gt;plane[pipe][PLANE_CURSOR];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!skl_ddb_entry_equal(hw_entry, sw_entry)) {</span>
<span class="p_del">-		DRM_ERROR(&quot;mismatch in DDB state pipe %c cursor &quot;</span>
<span class="p_del">-			  &quot;(expected (%u,%u), found (%u,%u))\n&quot;,</span>
<span class="p_del">-			  pipe_name(pipe),</span>
<span class="p_del">-			  sw_entry-&gt;start, sw_entry-&gt;end,</span>
<span class="p_del">-			  hw_entry-&gt;start, hw_entry-&gt;end);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * cursor</span>
<span class="p_add">+	 * If the cursor plane isn&#39;t active, we may not have updated it&#39;s ddb</span>
<span class="p_add">+	 * allocation. In that case since the ddb allocation will be updated</span>
<span class="p_add">+	 * once the plane becomes visible, we can skip this check</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (intel_crtc-&gt;cursor_addr) {</span>
<span class="p_add">+		hw_entry = &amp;hw_ddb.plane[pipe][PLANE_CURSOR];</span>
<span class="p_add">+		sw_entry = &amp;sw_ddb-&gt;plane[pipe][PLANE_CURSOR];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!skl_ddb_entry_equal(hw_entry, sw_entry)) {</span>
<span class="p_add">+			DRM_ERROR(&quot;mismatch in DDB state pipe %c cursor &quot;</span>
<span class="p_add">+				  &quot;(expected (%u,%u), found (%u,%u))\n&quot;,</span>
<span class="p_add">+				  pipe_name(pipe),</span>
<span class="p_add">+				  sw_entry-&gt;start, sw_entry-&gt;end,</span>
<span class="p_add">+				  hw_entry-&gt;start, hw_entry-&gt;end);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -13671,6 +13712,111 @@</span> <span class="p_context"> static bool needs_vblank_wait(struct intel_crtc_state *crtc_state)</span>
 	return false;
 }
 
<span class="p_add">+static void intel_update_crtc(struct drm_crtc *crtc,</span>
<span class="p_add">+			      struct drm_atomic_state *state,</span>
<span class="p_add">+			      struct drm_crtc_state *old_crtc_state,</span>
<span class="p_add">+			      unsigned int *crtc_vblank_mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_device *dev = crtc-&gt;dev;</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(dev);</span>
<span class="p_add">+	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);</span>
<span class="p_add">+	struct intel_crtc_state *pipe_config = to_intel_crtc_state(crtc-&gt;state);</span>
<span class="p_add">+	bool modeset = needs_modeset(crtc-&gt;state);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (modeset) {</span>
<span class="p_add">+		update_scanline_offset(intel_crtc);</span>
<span class="p_add">+		dev_priv-&gt;display.crtc_enable(crtc);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		intel_pre_plane_update(to_intel_crtc_state(old_crtc_state));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (drm_atomic_get_existing_plane_state(state, crtc-&gt;primary)) {</span>
<span class="p_add">+		intel_fbc_enable(</span>
<span class="p_add">+		    intel_crtc, pipe_config,</span>
<span class="p_add">+		    to_intel_plane_state(crtc-&gt;primary-&gt;state));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	drm_atomic_helper_commit_planes_on_crtc(old_crtc_state);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (needs_vblank_wait(pipe_config))</span>
<span class="p_add">+		*crtc_vblank_mask |= drm_crtc_mask(crtc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void intel_update_crtcs(struct drm_atomic_state *state,</span>
<span class="p_add">+			       unsigned int *crtc_vblank_mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_crtc *crtc;</span>
<span class="p_add">+	struct drm_crtc_state *old_crtc_state;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_crtc_in_state(state, crtc, old_crtc_state, i) {</span>
<span class="p_add">+		if (!crtc-&gt;state-&gt;active)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		intel_update_crtc(crtc, state, old_crtc_state,</span>
<span class="p_add">+				  crtc_vblank_mask);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void skl_update_crtcs(struct drm_atomic_state *state,</span>
<span class="p_add">+			     unsigned int *crtc_vblank_mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_device *dev = state-&gt;dev;</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(dev);</span>
<span class="p_add">+	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);</span>
<span class="p_add">+	struct drm_crtc *crtc;</span>
<span class="p_add">+	struct drm_crtc_state *old_crtc_state;</span>
<span class="p_add">+	struct skl_ddb_allocation *new_ddb = &amp;intel_state-&gt;wm_results.ddb;</span>
<span class="p_add">+	struct skl_ddb_allocation *cur_ddb = &amp;dev_priv-&gt;wm.skl_hw.ddb;</span>
<span class="p_add">+	unsigned int updated = 0;</span>
<span class="p_add">+	bool progress;</span>
<span class="p_add">+	enum pipe pipe;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Whenever the number of active pipes changes, we need to make sure we</span>
<span class="p_add">+	 * update the pipes in the right order so that their ddb allocations</span>
<span class="p_add">+	 * never overlap with eachother inbetween CRTC updates. Otherwise we&#39;ll</span>
<span class="p_add">+	 * cause pipe underruns and other bad stuff.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+		progress = false;</span>
<span class="p_add">+</span>
<span class="p_add">+		for_each_crtc_in_state(state, crtc, old_crtc_state, i) {</span>
<span class="p_add">+			bool vbl_wait = false;</span>
<span class="p_add">+			unsigned int cmask = drm_crtc_mask(crtc);</span>
<span class="p_add">+			pipe = to_intel_crtc(crtc)-&gt;pipe;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (updated &amp; cmask || !crtc-&gt;state-&gt;active)</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			if (skl_ddb_allocation_overlaps(state, cur_ddb, new_ddb,</span>
<span class="p_add">+							pipe))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			updated |= cmask;</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If this is an already active pipe, it&#39;s DDB changed,</span>
<span class="p_add">+			 * and this isn&#39;t the last pipe that needs updating</span>
<span class="p_add">+			 * then we need to wait for a vblank to pass for the</span>
<span class="p_add">+			 * new ddb allocation to take effect.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (!skl_ddb_allocation_equals(cur_ddb, new_ddb, pipe) &amp;&amp;</span>
<span class="p_add">+			    !crtc-&gt;state-&gt;active_changed &amp;&amp;</span>
<span class="p_add">+			    intel_state-&gt;wm_results.dirty_pipes != updated)</span>
<span class="p_add">+				vbl_wait = true;</span>
<span class="p_add">+</span>
<span class="p_add">+			intel_update_crtc(crtc, state, old_crtc_state,</span>
<span class="p_add">+					  crtc_vblank_mask);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (vbl_wait)</span>
<span class="p_add">+				intel_wait_for_vblank(dev, pipe);</span>
<span class="p_add">+</span>
<span class="p_add">+			progress = true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (progress);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void intel_atomic_commit_tail(struct drm_atomic_state *state)
 {
 	struct drm_device *dev = state-&gt;dev;
<span class="p_chunk">@@ -13763,23 +13909,15 @@</span> <span class="p_context"> static void intel_atomic_commit_tail(struct drm_atomic_state *state)</span>
 		 * SKL workaround: bspec recommends we disable the SAGV when we
 		 * have more then one pipe enabled
 		 */
<span class="p_del">-		if (IS_SKYLAKE(dev_priv) &amp;&amp; !skl_can_enable_sagv(state))</span>
<span class="p_del">-			skl_disable_sagv(dev_priv);</span>
<span class="p_add">+		if (!intel_can_enable_sagv(state))</span>
<span class="p_add">+			intel_disable_sagv(dev_priv);</span>
 
 		intel_modeset_verify_disabled(dev);
 	}
 
<span class="p_del">-	/* Now enable the clocks, plane, pipe, and connectors that we set up. */</span>
<span class="p_add">+	/* Complete the events for pipes that have now been disabled */</span>
 	for_each_crtc_in_state(state, crtc, old_crtc_state, i) {
<span class="p_del">-		struct intel_crtc *intel_crtc = to_intel_crtc(crtc);</span>
 		bool modeset = needs_modeset(crtc-&gt;state);
<span class="p_del">-		struct intel_crtc_state *pipe_config =</span>
<span class="p_del">-			to_intel_crtc_state(crtc-&gt;state);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (modeset &amp;&amp; crtc-&gt;state-&gt;active) {</span>
<span class="p_del">-			update_scanline_offset(to_intel_crtc(crtc));</span>
<span class="p_del">-			dev_priv-&gt;display.crtc_enable(crtc);</span>
<span class="p_del">-		}</span>
 
 		/* Complete events for now disable pipes here. */
 		if (modeset &amp;&amp; !crtc-&gt;state-&gt;active &amp;&amp; crtc-&gt;state-&gt;event) {
<span class="p_chunk">@@ -13789,21 +13927,11 @@</span> <span class="p_context"> static void intel_atomic_commit_tail(struct drm_atomic_state *state)</span>
 
 			crtc-&gt;state-&gt;event = NULL;
 		}
<span class="p_del">-</span>
<span class="p_del">-		if (!modeset)</span>
<span class="p_del">-			intel_pre_plane_update(to_intel_crtc_state(old_crtc_state));</span>
<span class="p_del">-</span>
<span class="p_del">-		if (crtc-&gt;state-&gt;active &amp;&amp;</span>
<span class="p_del">-		    drm_atomic_get_existing_plane_state(state, crtc-&gt;primary))</span>
<span class="p_del">-			intel_fbc_enable(intel_crtc, pipe_config, to_intel_plane_state(crtc-&gt;primary-&gt;state));</span>
<span class="p_del">-</span>
<span class="p_del">-		if (crtc-&gt;state-&gt;active)</span>
<span class="p_del">-			drm_atomic_helper_commit_planes_on_crtc(old_crtc_state);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (pipe_config-&gt;base.active &amp;&amp; needs_vblank_wait(pipe_config))</span>
<span class="p_del">-			crtc_vblank_mask |= 1 &lt;&lt; i;</span>
 	}
 
<span class="p_add">+	/* Now enable the clocks, plane, pipe, and connectors that we set up. */</span>
<span class="p_add">+	dev_priv-&gt;display.update_crtcs(state, &amp;crtc_vblank_mask);</span>
<span class="p_add">+</span>
 	/* FIXME: We should call drm_atomic_helper_commit_hw_done() here
 	 * already, but still need the state for the delayed optimization. To
 	 * fix this:
<span class="p_chunk">@@ -13839,9 +13967,8 @@</span> <span class="p_context"> static void intel_atomic_commit_tail(struct drm_atomic_state *state)</span>
 		intel_modeset_verify_crtc(crtc, old_crtc_state, crtc-&gt;state);
 	}
 
<span class="p_del">-	if (IS_SKYLAKE(dev_priv) &amp;&amp; intel_state-&gt;modeset &amp;&amp;</span>
<span class="p_del">-	    skl_can_enable_sagv(state))</span>
<span class="p_del">-		skl_enable_sagv(dev_priv);</span>
<span class="p_add">+	if (intel_state-&gt;modeset &amp;&amp; intel_can_enable_sagv(state))</span>
<span class="p_add">+		intel_enable_sagv(dev_priv);</span>
 
 	drm_atomic_helper_commit_hw_done(state);
 
<span class="p_chunk">@@ -14221,10 +14348,12 @@</span> <span class="p_context"> static void intel_begin_crtc_commit(struct drm_crtc *crtc,</span>
 				    struct drm_crtc_state *old_crtc_state)
 {
 	struct drm_device *dev = crtc-&gt;dev;
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(dev);</span>
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 	struct intel_crtc_state *old_intel_state =
 		to_intel_crtc_state(old_crtc_state);
 	bool modeset = needs_modeset(crtc-&gt;state);
<span class="p_add">+	enum pipe pipe = intel_crtc-&gt;pipe;</span>
 
 	/* Perform vblank evasion around commit operation */
 	intel_pipe_update_start(intel_crtc);
<span class="p_chunk">@@ -14239,8 +14368,12 @@</span> <span class="p_context"> static void intel_begin_crtc_commit(struct drm_crtc *crtc,</span>
 
 	if (to_intel_crtc_state(crtc-&gt;state)-&gt;update_pipe)
 		intel_update_pipe_config(intel_crtc, old_intel_state);
<span class="p_del">-	else if (INTEL_INFO(dev)-&gt;gen &gt;= 9)</span>
<span class="p_add">+	else if (INTEL_GEN(dev_priv) &gt;= 9) {</span>
 		skl_detach_scalers(intel_crtc);
<span class="p_add">+</span>
<span class="p_add">+		I915_WRITE(PIPE_WM_LINETIME(pipe),</span>
<span class="p_add">+			   dev_priv-&gt;wm.skl_hw.wm_linetime[pipe]);</span>
<span class="p_add">+	}</span>
 }
 
 static void intel_finish_crtc_commit(struct drm_crtc *crtc,
<span class="p_chunk">@@ -15347,6 +15480,11 @@</span> <span class="p_context"> void intel_init_display_hooks(struct drm_i915_private *dev_priv)</span>
 			skl_modeset_calc_cdclk;
 	}
 
<span class="p_add">+	if (dev_priv-&gt;info.gen &gt;= 9)</span>
<span class="p_add">+		dev_priv-&gt;display.update_crtcs = skl_update_crtcs;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		dev_priv-&gt;display.update_crtcs = intel_update_crtcs;</span>
<span class="p_add">+</span>
 	switch (INTEL_INFO(dev_priv)-&gt;gen) {
 	case 2:
 		dev_priv-&gt;display.queue_flip = intel_gen2_queue_flip;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 21b04c3eda41..1ca155f4d368 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -4148,7 +4148,7 @@</span> <span class="p_context"> static bool bxt_digital_port_connected(struct drm_i915_private *dev_priv,</span>
  *
  * Return %true if @port is connected, %false otherwise.
  */
<span class="p_del">-bool intel_digital_port_connected(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+static bool intel_digital_port_connected(struct drm_i915_private *dev_priv,</span>
 					 struct intel_digital_port *port)
 {
 	if (HAS_PCH_IBX(dev_priv))
<span class="p_chunk">@@ -4207,7 +4207,7 @@</span> <span class="p_context"> intel_dp_unset_edid(struct intel_dp *intel_dp)</span>
 	intel_dp-&gt;has_audio = false;
 }
 
<span class="p_del">-static void</span>
<span class="p_add">+static enum drm_connector_status</span>
 intel_dp_long_pulse(struct intel_connector *intel_connector)
 {
 	struct drm_connector *connector = &amp;intel_connector-&gt;base;
<span class="p_chunk">@@ -4232,7 +4232,7 @@</span> <span class="p_context"> intel_dp_long_pulse(struct intel_connector *intel_connector)</span>
 	else
 		status = connector_status_disconnected;
 
<span class="p_del">-	if (status != connector_status_connected) {</span>
<span class="p_add">+	if (status == connector_status_disconnected) {</span>
 		intel_dp-&gt;compliance_test_active = 0;
 		intel_dp-&gt;compliance_test_type = 0;
 		intel_dp-&gt;compliance_test_data = 0;
<span class="p_chunk">@@ -4284,8 +4284,8 @@</span> <span class="p_context"> intel_dp_long_pulse(struct intel_connector *intel_connector)</span>
 	intel_dp-&gt;aux.i2c_defer_count = 0;
 
 	intel_dp_set_edid(intel_dp);
<span class="p_del">-</span>
<span class="p_del">-	status = connector_status_connected;</span>
<span class="p_add">+	if (is_edp(intel_dp) || intel_connector-&gt;detect_edid)</span>
<span class="p_add">+		status = connector_status_connected;</span>
 	intel_dp-&gt;detect_done = true;
 
 	/* Try to read the source of the interrupt */
<span class="p_chunk">@@ -4303,12 +4303,11 @@</span> <span class="p_context"> intel_dp_long_pulse(struct intel_connector *intel_connector)</span>
 	}
 
 out:
<span class="p_del">-	if ((status != connector_status_connected) &amp;&amp;</span>
<span class="p_del">-	    (intel_dp-&gt;is_mst == false))</span>
<span class="p_add">+	if (status != connector_status_connected &amp;&amp; !intel_dp-&gt;is_mst)</span>
 		intel_dp_unset_edid(intel_dp);
 
 	intel_display_power_put(to_i915(dev), power_domain);
<span class="p_del">-	return;</span>
<span class="p_add">+	return status;</span>
 }
 
 static enum drm_connector_status
<span class="p_chunk">@@ -4317,7 +4316,7 @@</span> <span class="p_context"> intel_dp_detect(struct drm_connector *connector, bool force)</span>
 	struct intel_dp *intel_dp = intel_attached_dp(connector);
 	struct intel_digital_port *intel_dig_port = dp_to_dig_port(intel_dp);
 	struct intel_encoder *intel_encoder = &amp;intel_dig_port-&gt;base;
<span class="p_del">-	struct intel_connector *intel_connector = to_intel_connector(connector);</span>
<span class="p_add">+	enum drm_connector_status status = connector-&gt;status;</span>
 
 	DRM_DEBUG_KMS(&quot;[CONNECTOR:%d:%s]\n&quot;,
 		      connector-&gt;base.id, connector-&gt;name);
<span class="p_chunk">@@ -4332,14 +4331,11 @@</span> <span class="p_context"> intel_dp_detect(struct drm_connector *connector, bool force)</span>
 
 	/* If full detect is not performed yet, do a full detect */
 	if (!intel_dp-&gt;detect_done)
<span class="p_del">-		intel_dp_long_pulse(intel_dp-&gt;attached_connector);</span>
<span class="p_add">+		status = intel_dp_long_pulse(intel_dp-&gt;attached_connector);</span>
 
 	intel_dp-&gt;detect_done = false;
 
<span class="p_del">-	if (is_edp(intel_dp) || intel_connector-&gt;detect_edid)</span>
<span class="p_del">-		return connector_status_connected;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return connector_status_disconnected;</span>
<span class="p_add">+	return status;</span>
 }
 
 static void
<span class="p_chunk">@@ -4696,36 +4692,34 @@</span> <span class="p_context"> intel_dp_hpd_pulse(struct intel_digital_port *intel_dig_port, bool long_hpd)</span>
 		      port_name(intel_dig_port-&gt;port),
 		      long_hpd ? &quot;long&quot; : &quot;short&quot;);
 
<span class="p_add">+	if (long_hpd) {</span>
<span class="p_add">+		intel_dp-&gt;detect_done = false;</span>
<span class="p_add">+		return IRQ_NONE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	power_domain = intel_display_port_aux_power_domain(intel_encoder);
 	intel_display_power_get(dev_priv, power_domain);
 
<span class="p_del">-	if (long_hpd) {</span>
<span class="p_del">-		intel_dp_long_pulse(intel_dp-&gt;attached_connector);</span>
<span class="p_del">-		if (intel_dp-&gt;is_mst)</span>
<span class="p_del">-			ret = IRQ_HANDLED;</span>
<span class="p_del">-		goto put_power;</span>
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (intel_dp-&gt;is_mst) {</span>
<span class="p_del">-			if (intel_dp_check_mst_status(intel_dp) == -EINVAL) {</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * If we were in MST mode, and device is not</span>
<span class="p_del">-				 * there, get out of MST mode</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				DRM_DEBUG_KMS(&quot;MST device may have disappeared %d vs %d\n&quot;,</span>
<span class="p_del">-					      intel_dp-&gt;is_mst, intel_dp-&gt;mst_mgr.mst_state);</span>
<span class="p_del">-				intel_dp-&gt;is_mst = false;</span>
<span class="p_del">-				drm_dp_mst_topology_mgr_set_mst(&amp;intel_dp-&gt;mst_mgr,</span>
<span class="p_del">-								intel_dp-&gt;is_mst);</span>
<span class="p_del">-				goto put_power;</span>
<span class="p_del">-			}</span>
<span class="p_add">+	if (intel_dp-&gt;is_mst) {</span>
<span class="p_add">+		if (intel_dp_check_mst_status(intel_dp) == -EINVAL) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If we were in MST mode, and device is not</span>
<span class="p_add">+			 * there, get out of MST mode</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;MST device may have disappeared %d vs %d\n&quot;,</span>
<span class="p_add">+				      intel_dp-&gt;is_mst, intel_dp-&gt;mst_mgr.mst_state);</span>
<span class="p_add">+			intel_dp-&gt;is_mst = false;</span>
<span class="p_add">+			drm_dp_mst_topology_mgr_set_mst(&amp;intel_dp-&gt;mst_mgr,</span>
<span class="p_add">+							intel_dp-&gt;is_mst);</span>
<span class="p_add">+			intel_dp-&gt;detect_done = false;</span>
<span class="p_add">+			goto put_power;</span>
 		}
<span class="p_add">+	}</span>
 
<span class="p_del">-		if (!intel_dp-&gt;is_mst) {</span>
<span class="p_del">-			if (!intel_dp_short_pulse(intel_dp)) {</span>
<span class="p_del">-				intel_dp_long_pulse(intel_dp-&gt;attached_connector);</span>
<span class="p_del">-				goto put_power;</span>
<span class="p_del">-			}</span>
<span class="p_add">+	if (!intel_dp-&gt;is_mst) {</span>
<span class="p_add">+		if (!intel_dp_short_pulse(intel_dp)) {</span>
<span class="p_add">+			intel_dp-&gt;detect_done = false;</span>
<span class="p_add">+			goto put_power;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index ff399b9a5c1f..9a58800cba3b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -236,6 +236,7 @@</span> <span class="p_context"> struct intel_panel {</span>
 		bool enabled;
 		bool combination_mode;	/* gen 2/4 only */
 		bool active_low_pwm;
<span class="p_add">+		bool alternate_pwm_increment;	/* lpt+ */</span>
 
 		/* PWM chip */
 		bool util_pin_active_low;	/* bxt+ */
<span class="p_chunk">@@ -1387,8 +1388,6 @@</span> <span class="p_context"> void intel_edp_drrs_disable(struct intel_dp *intel_dp);</span>
 void intel_edp_drrs_invalidate(struct drm_device *dev,
 		unsigned frontbuffer_bits);
 void intel_edp_drrs_flush(struct drm_device *dev, unsigned frontbuffer_bits);
<span class="p_del">-bool intel_digital_port_connected(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-					 struct intel_digital_port *port);</span>
 
 void
 intel_dp_program_link_training_pattern(struct intel_dp *intel_dp,
<span class="p_chunk">@@ -1716,9 +1715,21 @@</span> <span class="p_context"> void ilk_wm_get_hw_state(struct drm_device *dev);</span>
 void skl_wm_get_hw_state(struct drm_device *dev);
 void skl_ddb_get_hw_state(struct drm_i915_private *dev_priv,
 			  struct skl_ddb_allocation *ddb /* out */);
<span class="p_del">-bool skl_can_enable_sagv(struct drm_atomic_state *state);</span>
<span class="p_del">-int skl_enable_sagv(struct drm_i915_private *dev_priv);</span>
<span class="p_del">-int skl_disable_sagv(struct drm_i915_private *dev_priv);</span>
<span class="p_add">+bool intel_can_enable_sagv(struct drm_atomic_state *state);</span>
<span class="p_add">+int intel_enable_sagv(struct drm_i915_private *dev_priv);</span>
<span class="p_add">+int intel_disable_sagv(struct drm_i915_private *dev_priv);</span>
<span class="p_add">+bool skl_ddb_allocation_equals(const struct skl_ddb_allocation *old,</span>
<span class="p_add">+			       const struct skl_ddb_allocation *new,</span>
<span class="p_add">+			       enum pipe pipe);</span>
<span class="p_add">+bool skl_ddb_allocation_overlaps(struct drm_atomic_state *state,</span>
<span class="p_add">+				 const struct skl_ddb_allocation *old,</span>
<span class="p_add">+				 const struct skl_ddb_allocation *new,</span>
<span class="p_add">+				 enum pipe pipe);</span>
<span class="p_add">+void skl_write_cursor_wm(struct intel_crtc *intel_crtc,</span>
<span class="p_add">+			 const struct skl_wm_values *wm);</span>
<span class="p_add">+void skl_write_plane_wm(struct intel_crtc *intel_crtc,</span>
<span class="p_add">+			const struct skl_wm_values *wm,</span>
<span class="p_add">+			int plane);</span>
 uint32_t ilk_pipe_pixel_rate(const struct intel_crtc_state *pipe_config);
 bool ilk_disable_lp_wm(struct drm_device *dev);
 int sanitize_rc6_option(struct drm_i915_private *dev_priv, int enable_rc6);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_hdmi.c b/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_header">index 4df9f384910c..c3aa9e670d15 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_hdmi.c</span>
<span class="p_chunk">@@ -1422,24 +1422,22 @@</span> <span class="p_context"> intel_hdmi_dp_dual_mode_detect(struct drm_connector *connector, bool has_edid)</span>
 }
 
 static bool
<span class="p_del">-intel_hdmi_set_edid(struct drm_connector *connector, bool force)</span>
<span class="p_add">+intel_hdmi_set_edid(struct drm_connector *connector)</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(connector-&gt;dev);
 	struct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);
<span class="p_del">-	struct edid *edid = NULL;</span>
<span class="p_add">+	struct edid *edid;</span>
 	bool connected = false;
 
<span class="p_del">-	if (force) {</span>
<span class="p_del">-		intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);</span>
<span class="p_add">+	intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);</span>
 
<span class="p_del">-		edid = drm_get_edid(connector,</span>
<span class="p_del">-				    intel_gmbus_get_adapter(dev_priv,</span>
<span class="p_del">-				    intel_hdmi-&gt;ddc_bus));</span>
<span class="p_add">+	edid = drm_get_edid(connector,</span>
<span class="p_add">+			    intel_gmbus_get_adapter(dev_priv,</span>
<span class="p_add">+			    intel_hdmi-&gt;ddc_bus));</span>
 
<span class="p_del">-		intel_hdmi_dp_dual_mode_detect(connector, edid != NULL);</span>
<span class="p_add">+	intel_hdmi_dp_dual_mode_detect(connector, edid != NULL);</span>
 
<span class="p_del">-		intel_display_power_put(dev_priv, POWER_DOMAIN_GMBUS);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	intel_display_power_put(dev_priv, POWER_DOMAIN_GMBUS);</span>
 
 	to_intel_connector(connector)-&gt;detect_edid = edid;
 	if (edid &amp;&amp; edid-&gt;input &amp; DRM_EDID_INPUT_DIGITAL) {
<span class="p_chunk">@@ -1465,37 +1463,16 @@</span> <span class="p_context"> static enum drm_connector_status</span>
 intel_hdmi_detect(struct drm_connector *connector, bool force)
 {
 	enum drm_connector_status status;
<span class="p_del">-	struct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);</span>
 	struct drm_i915_private *dev_priv = to_i915(connector-&gt;dev);
<span class="p_del">-	bool live_status = false;</span>
<span class="p_del">-	unsigned int try;</span>
 
 	DRM_DEBUG_KMS(&quot;[CONNECTOR:%d:%s]\n&quot;,
 		      connector-&gt;base.id, connector-&gt;name);
 
 	intel_display_power_get(dev_priv, POWER_DOMAIN_GMBUS);
 
<span class="p_del">-	for (try = 0; !live_status &amp;&amp; try &lt; 9; try++) {</span>
<span class="p_del">-		if (try)</span>
<span class="p_del">-			msleep(10);</span>
<span class="p_del">-		live_status = intel_digital_port_connected(dev_priv,</span>
<span class="p_del">-				hdmi_to_dig_port(intel_hdmi));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!live_status) {</span>
<span class="p_del">-		DRM_DEBUG_KMS(&quot;HDMI live status down\n&quot;);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Live status register is not reliable on all intel platforms.</span>
<span class="p_del">-		 * So consider live_status only for certain platforms, for</span>
<span class="p_del">-		 * others, read EDID to determine presence of sink.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (INTEL_INFO(dev_priv)-&gt;gen &lt; 7 || IS_IVYBRIDGE(dev_priv))</span>
<span class="p_del">-			live_status = true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	intel_hdmi_unset_edid(connector);
 
<span class="p_del">-	if (intel_hdmi_set_edid(connector, live_status)) {</span>
<span class="p_add">+	if (intel_hdmi_set_edid(connector)) {</span>
 		struct intel_hdmi *intel_hdmi = intel_attached_hdmi(connector);
 
 		hdmi_to_dig_port(intel_hdmi)-&gt;base.type = INTEL_OUTPUT_HDMI;
<span class="p_chunk">@@ -1521,7 +1498,7 @@</span> <span class="p_context"> intel_hdmi_force(struct drm_connector *connector)</span>
 	if (connector-&gt;status != connector_status_connected)
 		return;
 
<span class="p_del">-	intel_hdmi_set_edid(connector, true);</span>
<span class="p_add">+	intel_hdmi_set_edid(connector);</span>
 	hdmi_to_dig_port(intel_hdmi)-&gt;base.type = INTEL_OUTPUT_HDMI;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_panel.c b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">index 96c65d77e886..9a2393a6b277 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_chunk">@@ -841,7 +841,7 @@</span> <span class="p_context"> static void lpt_enable_backlight(struct intel_connector *connector)</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(connector-&gt;base.dev);
 	struct intel_panel *panel = &amp;connector-&gt;panel;
<span class="p_del">-	u32 pch_ctl1, pch_ctl2;</span>
<span class="p_add">+	u32 pch_ctl1, pch_ctl2, schicken;</span>
 
 	pch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);
 	if (pch_ctl1 &amp; BLM_PCH_PWM_ENABLE) {
<span class="p_chunk">@@ -850,6 +850,22 @@</span> <span class="p_context"> static void lpt_enable_backlight(struct intel_connector *connector)</span>
 		I915_WRITE(BLC_PWM_PCH_CTL1, pch_ctl1);
 	}
 
<span class="p_add">+	if (HAS_PCH_LPT(dev_priv)) {</span>
<span class="p_add">+		schicken = I915_READ(SOUTH_CHICKEN2);</span>
<span class="p_add">+		if (panel-&gt;backlight.alternate_pwm_increment)</span>
<span class="p_add">+			schicken |= LPT_PWM_GRANULARITY;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			schicken &amp;= ~LPT_PWM_GRANULARITY;</span>
<span class="p_add">+		I915_WRITE(SOUTH_CHICKEN2, schicken);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		schicken = I915_READ(SOUTH_CHICKEN1);</span>
<span class="p_add">+		if (panel-&gt;backlight.alternate_pwm_increment)</span>
<span class="p_add">+			schicken |= SPT_PWM_GRANULARITY;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			schicken &amp;= ~SPT_PWM_GRANULARITY;</span>
<span class="p_add">+		I915_WRITE(SOUTH_CHICKEN1, schicken);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pch_ctl2 = panel-&gt;backlight.max &lt;&lt; 16;
 	I915_WRITE(BLC_PWM_PCH_CTL2, pch_ctl2);
 
<span class="p_chunk">@@ -1242,10 +1258,10 @@</span> <span class="p_context"> static u32 bxt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)</span>
  */
 static u32 spt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
 {
<span class="p_del">-	struct drm_i915_private *dev_priv = to_i915(connector-&gt;base.dev);</span>
<span class="p_add">+	struct intel_panel *panel = &amp;connector-&gt;panel;</span>
 	u32 mul;
 
<span class="p_del">-	if (I915_READ(SOUTH_CHICKEN1) &amp; SPT_PWM_GRANULARITY)</span>
<span class="p_add">+	if (panel-&gt;backlight.alternate_pwm_increment)</span>
 		mul = 128;
 	else
 		mul = 16;
<span class="p_chunk">@@ -1261,9 +1277,10 @@</span> <span class="p_context"> static u32 spt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)</span>
 static u32 lpt_hz_to_pwm(struct intel_connector *connector, u32 pwm_freq_hz)
 {
 	struct drm_i915_private *dev_priv = to_i915(connector-&gt;base.dev);
<span class="p_add">+	struct intel_panel *panel = &amp;connector-&gt;panel;</span>
 	u32 mul, clock;
 
<span class="p_del">-	if (I915_READ(SOUTH_CHICKEN2) &amp; LPT_PWM_GRANULARITY)</span>
<span class="p_add">+	if (panel-&gt;backlight.alternate_pwm_increment)</span>
 		mul = 16;
 	else
 		mul = 128;
<span class="p_chunk">@@ -1414,6 +1431,13 @@</span> <span class="p_context"> static int lpt_setup_backlight(struct intel_connector *connector, enum pipe unus</span>
 	struct drm_i915_private *dev_priv = to_i915(connector-&gt;base.dev);
 	struct intel_panel *panel = &amp;connector-&gt;panel;
 	u32 pch_ctl1, pch_ctl2, val;
<span class="p_add">+	bool alt;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (HAS_PCH_LPT(dev_priv))</span>
<span class="p_add">+		alt = I915_READ(SOUTH_CHICKEN2) &amp; LPT_PWM_GRANULARITY;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		alt = I915_READ(SOUTH_CHICKEN1) &amp; SPT_PWM_GRANULARITY;</span>
<span class="p_add">+	panel-&gt;backlight.alternate_pwm_increment = alt;</span>
 
 	pch_ctl1 = I915_READ(BLC_PWM_PCH_CTL1);
 	panel-&gt;backlight.active_low_pwm = pch_ctl1 &amp; BLM_PCH_POLARITY;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 2d2481392824..e59a28cb3158 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -2119,32 +2119,34 @@</span> <span class="p_context"> static void intel_read_wm_latency(struct drm_device *dev, uint16_t wm[8])</span>
 				GEN9_MEM_LATENCY_LEVEL_MASK;
 
 		/*
<span class="p_add">+		 * If a level n (n &gt; 1) has a 0us latency, all levels m (m &gt;= n)</span>
<span class="p_add">+		 * need to be disabled. We make sure to sanitize the values out</span>
<span class="p_add">+		 * of the punit to satisfy this requirement.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		for (level = 1; level &lt;= max_level; level++) {</span>
<span class="p_add">+			if (wm[level] == 0) {</span>
<span class="p_add">+				for (i = level + 1; i &lt;= max_level; i++)</span>
<span class="p_add">+					wm[i] = 0;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
 		 * WaWmMemoryReadLatency:skl
 		 *
 		 * punit doesn&#39;t take into account the read latency so we need
<span class="p_del">-		 * to add 2us to the various latency levels we retrieve from</span>
<span class="p_del">-		 * the punit.</span>
<span class="p_del">-		 *   - W0 is a bit special in that it&#39;s the only level that</span>
<span class="p_del">-		 *   can&#39;t be disabled if we want to have display working, so</span>
<span class="p_del">-		 *   we always add 2us there.</span>
<span class="p_del">-		 *   - For levels &gt;=1, punit returns 0us latency when they are</span>
<span class="p_del">-		 *   disabled, so we respect that and don&#39;t add 2us then</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Additionally, if a level n (n &gt; 1) has a 0us latency, all</span>
<span class="p_del">-		 * levels m (m &gt;= n) need to be disabled. We make sure to</span>
<span class="p_del">-		 * sanitize the values out of the punit to satisfy this</span>
<span class="p_del">-		 * requirement.</span>
<span class="p_add">+		 * to add 2us to the various latency levels we retrieve from the</span>
<span class="p_add">+		 * punit when level 0 response data us 0us.</span>
 		 */
<span class="p_del">-		wm[0] += 2;</span>
<span class="p_del">-		for (level = 1; level &lt;= max_level; level++)</span>
<span class="p_del">-			if (wm[level] != 0)</span>
<span class="p_add">+		if (wm[0] == 0) {</span>
<span class="p_add">+			wm[0] += 2;</span>
<span class="p_add">+			for (level = 1; level &lt;= max_level; level++) {</span>
<span class="p_add">+				if (wm[level] == 0)</span>
<span class="p_add">+					break;</span>
 				wm[level] += 2;
<span class="p_del">-			else {</span>
<span class="p_del">-				for (i = level + 1; i &lt;= max_level; i++)</span>
<span class="p_del">-					wm[i] = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-				break;</span>
 			}
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 	} else if (IS_HASWELL(dev) || IS_BROADWELL(dev)) {
 		uint64_t sskpd = I915_READ64(MCH_SSKPD);
 
<span class="p_chunk">@@ -2876,6 +2878,19 @@</span> <span class="p_context"> skl_wm_plane_id(const struct intel_plane *plane)</span>
 	}
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+intel_has_sagv(struct drm_i915_private *dev_priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (IS_KABYLAKE(dev_priv))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKYLAKE(dev_priv) &amp;&amp;</span>
<span class="p_add">+	    dev_priv-&gt;sagv_status != I915_SAGV_NOT_CONTROLLED)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * SAGV dynamically adjusts the system agent voltage and clock frequencies
  * depending on power and performance requirements. The display engine access
<span class="p_chunk">@@ -2888,12 +2903,14 @@</span> <span class="p_context"> skl_wm_plane_id(const struct intel_plane *plane)</span>
  *  - We&#39;re not using an interlaced display configuration
  */
 int
<span class="p_del">-skl_enable_sagv(struct drm_i915_private *dev_priv)</span>
<span class="p_add">+intel_enable_sagv(struct drm_i915_private *dev_priv)</span>
 {
 	int ret;
 
<span class="p_del">-	if (dev_priv-&gt;skl_sagv_status == I915_SKL_SAGV_NOT_CONTROLLED ||</span>
<span class="p_del">-	    dev_priv-&gt;skl_sagv_status == I915_SKL_SAGV_ENABLED)</span>
<span class="p_add">+	if (!intel_has_sagv(dev_priv))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev_priv-&gt;sagv_status == I915_SAGV_ENABLED)</span>
 		return 0;
 
 	DRM_DEBUG_KMS(&quot;Enabling the SAGV\n&quot;);
<span class="p_chunk">@@ -2909,21 +2926,21 @@</span> <span class="p_context"> skl_enable_sagv(struct drm_i915_private *dev_priv)</span>
 	 * Some skl systems, pre-release machines in particular,
 	 * don&#39;t actually have an SAGV.
 	 */
<span class="p_del">-	if (ret == -ENXIO) {</span>
<span class="p_add">+	if (IS_SKYLAKE(dev_priv) &amp;&amp; ret == -ENXIO) {</span>
 		DRM_DEBUG_DRIVER(&quot;No SAGV found on system, ignoring\n&quot;);
<span class="p_del">-		dev_priv-&gt;skl_sagv_status = I915_SKL_SAGV_NOT_CONTROLLED;</span>
<span class="p_add">+		dev_priv-&gt;sagv_status = I915_SAGV_NOT_CONTROLLED;</span>
 		return 0;
 	} else if (ret &lt; 0) {
 		DRM_ERROR(&quot;Failed to enable the SAGV\n&quot;);
 		return ret;
 	}
 
<span class="p_del">-	dev_priv-&gt;skl_sagv_status = I915_SKL_SAGV_ENABLED;</span>
<span class="p_add">+	dev_priv-&gt;sagv_status = I915_SAGV_ENABLED;</span>
 	return 0;
 }
 
 static int
<span class="p_del">-skl_do_sagv_disable(struct drm_i915_private *dev_priv)</span>
<span class="p_add">+intel_do_sagv_disable(struct drm_i915_private *dev_priv)</span>
 {
 	int ret;
 	uint32_t temp = GEN9_SAGV_DISABLE;
<span class="p_chunk">@@ -2937,19 +2954,21 @@</span> <span class="p_context"> skl_do_sagv_disable(struct drm_i915_private *dev_priv)</span>
 }
 
 int
<span class="p_del">-skl_disable_sagv(struct drm_i915_private *dev_priv)</span>
<span class="p_add">+intel_disable_sagv(struct drm_i915_private *dev_priv)</span>
 {
 	int ret, result;
 
<span class="p_del">-	if (dev_priv-&gt;skl_sagv_status == I915_SKL_SAGV_NOT_CONTROLLED ||</span>
<span class="p_del">-	    dev_priv-&gt;skl_sagv_status == I915_SKL_SAGV_DISABLED)</span>
<span class="p_add">+	if (!intel_has_sagv(dev_priv))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev_priv-&gt;sagv_status == I915_SAGV_DISABLED)</span>
 		return 0;
 
 	DRM_DEBUG_KMS(&quot;Disabling the SAGV\n&quot;);
 	mutex_lock(&amp;dev_priv-&gt;rps.hw_lock);
 
 	/* bspec says to keep retrying for at least 1 ms */
<span class="p_del">-	ret = wait_for(result = skl_do_sagv_disable(dev_priv), 1);</span>
<span class="p_add">+	ret = wait_for(result = intel_do_sagv_disable(dev_priv), 1);</span>
 	mutex_unlock(&amp;dev_priv-&gt;rps.hw_lock);
 
 	if (ret == -ETIMEDOUT) {
<span class="p_chunk">@@ -2961,20 +2980,20 @@</span> <span class="p_context"> skl_disable_sagv(struct drm_i915_private *dev_priv)</span>
 	 * Some skl systems, pre-release machines in particular,
 	 * don&#39;t actually have an SAGV.
 	 */
<span class="p_del">-	if (result == -ENXIO) {</span>
<span class="p_add">+	if (IS_SKYLAKE(dev_priv) &amp;&amp; result == -ENXIO) {</span>
 		DRM_DEBUG_DRIVER(&quot;No SAGV found on system, ignoring\n&quot;);
<span class="p_del">-		dev_priv-&gt;skl_sagv_status = I915_SKL_SAGV_NOT_CONTROLLED;</span>
<span class="p_add">+		dev_priv-&gt;sagv_status = I915_SAGV_NOT_CONTROLLED;</span>
 		return 0;
 	} else if (result &lt; 0) {
 		DRM_ERROR(&quot;Failed to disable the SAGV\n&quot;);
 		return result;
 	}
 
<span class="p_del">-	dev_priv-&gt;skl_sagv_status = I915_SKL_SAGV_DISABLED;</span>
<span class="p_add">+	dev_priv-&gt;sagv_status = I915_SAGV_DISABLED;</span>
 	return 0;
 }
 
<span class="p_del">-bool skl_can_enable_sagv(struct drm_atomic_state *state)</span>
<span class="p_add">+bool intel_can_enable_sagv(struct drm_atomic_state *state)</span>
 {
 	struct drm_device *dev = state-&gt;dev;
 	struct drm_i915_private *dev_priv = to_i915(dev);
<span class="p_chunk">@@ -2983,6 +3002,9 @@</span> <span class="p_context"> bool skl_can_enable_sagv(struct drm_atomic_state *state)</span>
 	enum pipe pipe;
 	int level, plane;
 
<span class="p_add">+	if (!intel_has_sagv(dev_priv))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	/*
 	 * SKL workaround: bspec recommends we disable the SAGV when we have
 	 * more then one pipe enabled
<span class="p_chunk">@@ -3473,29 +3495,14 @@</span> <span class="p_context"> static uint32_t skl_wm_method1(uint32_t pixel_rate, uint8_t cpp, uint32_t latenc</span>
 }
 
 static uint32_t skl_wm_method2(uint32_t pixel_rate, uint32_t pipe_htotal,
<span class="p_del">-			       uint32_t horiz_pixels, uint8_t cpp,</span>
<span class="p_del">-			       uint64_t tiling, uint32_t latency)</span>
<span class="p_add">+			       uint32_t latency, uint32_t plane_blocks_per_line)</span>
 {
 	uint32_t ret;
<span class="p_del">-	uint32_t plane_bytes_per_line, plane_blocks_per_line;</span>
 	uint32_t wm_intermediate_val;
 
 	if (latency == 0)
 		return UINT_MAX;
 
<span class="p_del">-	plane_bytes_per_line = horiz_pixels * cpp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tiling == I915_FORMAT_MOD_Y_TILED ||</span>
<span class="p_del">-	    tiling == I915_FORMAT_MOD_Yf_TILED) {</span>
<span class="p_del">-		plane_bytes_per_line *= 4;</span>
<span class="p_del">-		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);</span>
<span class="p_del">-		plane_blocks_per_line /= 4;</span>
<span class="p_del">-	} else if (tiling == DRM_FORMAT_MOD_NONE) {</span>
<span class="p_del">-		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512) + 1;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	wm_intermediate_val = latency * pixel_rate;
 	ret = DIV_ROUND_UP(wm_intermediate_val, pipe_htotal * 1000) *
 				plane_blocks_per_line;
<span class="p_chunk">@@ -3546,6 +3553,7 @@</span> <span class="p_context"> static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,</span>
 	uint8_t cpp;
 	uint32_t width = 0, height = 0;
 	uint32_t plane_pixel_rate;
<span class="p_add">+	uint32_t y_tile_minimum, y_min_scanlines;</span>
 
 	if (latency == 0 || !cstate-&gt;base.active || !intel_pstate-&gt;visible) {
 		*enabled = false;
<span class="p_chunk">@@ -3561,38 +3569,51 @@</span> <span class="p_context"> static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,</span>
 	cpp = drm_format_plane_cpp(fb-&gt;pixel_format, 0);
 	plane_pixel_rate = skl_adjusted_plane_pixel_rate(cstate, intel_pstate);
 
<span class="p_add">+	if (intel_rotation_90_or_270(pstate-&gt;rotation)) {</span>
<span class="p_add">+		int cpp = (fb-&gt;pixel_format == DRM_FORMAT_NV12) ?</span>
<span class="p_add">+			drm_format_plane_cpp(fb-&gt;pixel_format, 1) :</span>
<span class="p_add">+			drm_format_plane_cpp(fb-&gt;pixel_format, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		switch (cpp) {</span>
<span class="p_add">+		case 1:</span>
<span class="p_add">+			y_min_scanlines = 16;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 2:</span>
<span class="p_add">+			y_min_scanlines = 8;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			WARN(1, &quot;Unsupported pixel depth for rotation&quot;);</span>
<span class="p_add">+		case 4:</span>
<span class="p_add">+			y_min_scanlines = 4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		y_min_scanlines = 4;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	plane_bytes_per_line = width * cpp;</span>
<span class="p_add">+	if (fb-&gt;modifier[0] == I915_FORMAT_MOD_Y_TILED ||</span>
<span class="p_add">+	    fb-&gt;modifier[0] == I915_FORMAT_MOD_Yf_TILED) {</span>
<span class="p_add">+		plane_blocks_per_line =</span>
<span class="p_add">+		      DIV_ROUND_UP(plane_bytes_per_line * y_min_scanlines, 512);</span>
<span class="p_add">+		plane_blocks_per_line /= y_min_scanlines;</span>
<span class="p_add">+	} else if (fb-&gt;modifier[0] == DRM_FORMAT_MOD_NONE) {</span>
<span class="p_add">+		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512)</span>
<span class="p_add">+					+ 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	method1 = skl_wm_method1(plane_pixel_rate, cpp, latency);
 	method2 = skl_wm_method2(plane_pixel_rate,
 				 cstate-&gt;base.adjusted_mode.crtc_htotal,
<span class="p_del">-				 width,</span>
<span class="p_del">-				 cpp,</span>
<span class="p_del">-				 fb-&gt;modifier[0],</span>
<span class="p_del">-				 latency);</span>
<span class="p_add">+				 latency,</span>
<span class="p_add">+				 plane_blocks_per_line);</span>
 
<span class="p_del">-	plane_bytes_per_line = width * cpp;</span>
<span class="p_del">-	plane_blocks_per_line = DIV_ROUND_UP(plane_bytes_per_line, 512);</span>
<span class="p_add">+	y_tile_minimum = plane_blocks_per_line * y_min_scanlines;</span>
 
 	if (fb-&gt;modifier[0] == I915_FORMAT_MOD_Y_TILED ||
 	    fb-&gt;modifier[0] == I915_FORMAT_MOD_Yf_TILED) {
<span class="p_del">-		uint32_t min_scanlines = 4;</span>
<span class="p_del">-		uint32_t y_tile_minimum;</span>
<span class="p_del">-		if (intel_rotation_90_or_270(pstate-&gt;rotation)) {</span>
<span class="p_del">-			int cpp = (fb-&gt;pixel_format == DRM_FORMAT_NV12) ?</span>
<span class="p_del">-				drm_format_plane_cpp(fb-&gt;pixel_format, 1) :</span>
<span class="p_del">-				drm_format_plane_cpp(fb-&gt;pixel_format, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-			switch (cpp) {</span>
<span class="p_del">-			case 1:</span>
<span class="p_del">-				min_scanlines = 16;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 2:</span>
<span class="p_del">-				min_scanlines = 8;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			case 8:</span>
<span class="p_del">-				WARN(1, &quot;Unsupported pixel depth for rotation&quot;);</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-		y_tile_minimum = plane_blocks_per_line * min_scanlines;</span>
 		selected_result = max(method2, y_tile_minimum);
 	} else {
 		if ((ddb_allocation / plane_blocks_per_line) &gt;= 1)
<span class="p_chunk">@@ -3606,10 +3627,12 @@</span> <span class="p_context"> static int skl_compute_plane_wm(const struct drm_i915_private *dev_priv,</span>
 
 	if (level &gt;= 1 &amp;&amp; level &lt;= 7) {
 		if (fb-&gt;modifier[0] == I915_FORMAT_MOD_Y_TILED ||
<span class="p_del">-		    fb-&gt;modifier[0] == I915_FORMAT_MOD_Yf_TILED)</span>
<span class="p_del">-			res_lines += 4;</span>
<span class="p_del">-		else</span>
<span class="p_add">+		    fb-&gt;modifier[0] == I915_FORMAT_MOD_Yf_TILED) {</span>
<span class="p_add">+			res_blocks += y_tile_minimum;</span>
<span class="p_add">+			res_lines += y_min_scanlines;</span>
<span class="p_add">+		} else {</span>
 			res_blocks++;
<span class="p_add">+		}</span>
 	}
 
 	if (res_blocks &gt;= ddb_allocation || res_lines &gt; 31) {
<span class="p_chunk">@@ -3828,183 +3851,82 @@</span> <span class="p_context"> static void skl_ddb_entry_write(struct drm_i915_private *dev_priv,</span>
 		I915_WRITE(reg, 0);
 }
 
<span class="p_del">-static void skl_write_wm_values(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-				const struct skl_wm_values *new)</span>
<span class="p_add">+void skl_write_plane_wm(struct intel_crtc *intel_crtc,</span>
<span class="p_add">+			const struct skl_wm_values *wm,</span>
<span class="p_add">+			int plane)</span>
 {
<span class="p_del">-	struct drm_device *dev = &amp;dev_priv-&gt;drm;</span>
<span class="p_del">-	struct intel_crtc *crtc;</span>
<span class="p_del">-</span>
<span class="p_del">-	for_each_intel_crtc(dev, crtc) {</span>
<span class="p_del">-		int i, level, max_level = ilk_wm_max_level(dev);</span>
<span class="p_del">-		enum pipe pipe = crtc-&gt;pipe;</span>
<span class="p_del">-</span>
<span class="p_del">-		if ((new-&gt;dirty_pipes &amp; drm_crtc_mask(&amp;crtc-&gt;base)) == 0)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (!crtc-&gt;active)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		I915_WRITE(PIPE_WM_LINETIME(pipe), new-&gt;wm_linetime[pipe]);</span>
<span class="p_del">-</span>
<span class="p_del">-		for (level = 0; level &lt;= max_level; level++) {</span>
<span class="p_del">-			for (i = 0; i &lt; intel_num_planes(crtc); i++)</span>
<span class="p_del">-				I915_WRITE(PLANE_WM(pipe, i, level),</span>
<span class="p_del">-					   new-&gt;plane[pipe][i][level]);</span>
<span class="p_del">-			I915_WRITE(CUR_WM(pipe, level),</span>
<span class="p_del">-				   new-&gt;plane[pipe][PLANE_CURSOR][level]);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		for (i = 0; i &lt; intel_num_planes(crtc); i++)</span>
<span class="p_del">-			I915_WRITE(PLANE_WM_TRANS(pipe, i),</span>
<span class="p_del">-				   new-&gt;plane_trans[pipe][i]);</span>
<span class="p_del">-		I915_WRITE(CUR_WM_TRANS(pipe),</span>
<span class="p_del">-			   new-&gt;plane_trans[pipe][PLANE_CURSOR]);</span>
<span class="p_del">-</span>
<span class="p_del">-		for (i = 0; i &lt; intel_num_planes(crtc); i++) {</span>
<span class="p_del">-			skl_ddb_entry_write(dev_priv,</span>
<span class="p_del">-					    PLANE_BUF_CFG(pipe, i),</span>
<span class="p_del">-					    &amp;new-&gt;ddb.plane[pipe][i]);</span>
<span class="p_del">-			skl_ddb_entry_write(dev_priv,</span>
<span class="p_del">-					    PLANE_NV12_BUF_CFG(pipe, i),</span>
<span class="p_del">-					    &amp;new-&gt;ddb.y_plane[pipe][i]);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	struct drm_crtc *crtc = &amp;intel_crtc-&gt;base;</span>
<span class="p_add">+	struct drm_device *dev = crtc-&gt;dev;</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(dev);</span>
<span class="p_add">+	int level, max_level = ilk_wm_max_level(dev);</span>
<span class="p_add">+	enum pipe pipe = intel_crtc-&gt;pipe;</span>
 
<span class="p_del">-		skl_ddb_entry_write(dev_priv, CUR_BUF_CFG(pipe),</span>
<span class="p_del">-				    &amp;new-&gt;ddb.plane[pipe][PLANE_CURSOR]);</span>
<span class="p_add">+	for (level = 0; level &lt;= max_level; level++) {</span>
<span class="p_add">+		I915_WRITE(PLANE_WM(pipe, plane, level),</span>
<span class="p_add">+			   wm-&gt;plane[pipe][plane][level]);</span>
 	}
<span class="p_del">-}</span>
<span class="p_add">+	I915_WRITE(PLANE_WM_TRANS(pipe, plane), wm-&gt;plane_trans[pipe][plane]);</span>
 
<span class="p_del">-/*</span>
<span class="p_del">- * When setting up a new DDB allocation arrangement, we need to correctly</span>
<span class="p_del">- * sequence the times at which the new allocations for the pipes are taken into</span>
<span class="p_del">- * account or we&#39;ll have pipes fetching from space previously allocated to</span>
<span class="p_del">- * another pipe.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Roughly the sequence looks like:</span>
<span class="p_del">- *  1. re-allocate the pipe(s) with the allocation being reduced and not</span>
<span class="p_del">- *     overlapping with a previous light-up pipe (another way to put it is:</span>
<span class="p_del">- *     pipes with their new allocation strickly included into their old ones).</span>
<span class="p_del">- *  2. re-allocate the other pipes that get their allocation reduced</span>
<span class="p_del">- *  3. allocate the pipes having their allocation increased</span>
<span class="p_del">- *</span>
<span class="p_del">- * Steps 1. and 2. are here to take care of the following case:</span>
<span class="p_del">- * - Initially DDB looks like this:</span>
<span class="p_del">- *     |   B    |   C    |</span>
<span class="p_del">- * - enable pipe A.</span>
<span class="p_del">- * - pipe B has a reduced DDB allocation that overlaps with the old pipe C</span>
<span class="p_del">- *   allocation</span>
<span class="p_del">- *     |  A  |  B  |  C  |</span>
<span class="p_del">- *</span>
<span class="p_del">- * We need to sequence the re-allocation: C, B, A (and not B, C, A).</span>
<span class="p_del">- */</span>
<span class="p_add">+	skl_ddb_entry_write(dev_priv, PLANE_BUF_CFG(pipe, plane),</span>
<span class="p_add">+			    &amp;wm-&gt;ddb.plane[pipe][plane]);</span>
<span class="p_add">+	skl_ddb_entry_write(dev_priv, PLANE_NV12_BUF_CFG(pipe, plane),</span>
<span class="p_add">+			    &amp;wm-&gt;ddb.y_plane[pipe][plane]);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-static void</span>
<span class="p_del">-skl_wm_flush_pipe(struct drm_i915_private *dev_priv, enum pipe pipe, int pass)</span>
<span class="p_add">+void skl_write_cursor_wm(struct intel_crtc *intel_crtc,</span>
<span class="p_add">+			 const struct skl_wm_values *wm)</span>
 {
<span class="p_del">-	int plane;</span>
<span class="p_del">-</span>
<span class="p_del">-	DRM_DEBUG_KMS(&quot;flush pipe %c (pass %d)\n&quot;, pipe_name(pipe), pass);</span>
<span class="p_add">+	struct drm_crtc *crtc = &amp;intel_crtc-&gt;base;</span>
<span class="p_add">+	struct drm_device *dev = crtc-&gt;dev;</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(dev);</span>
<span class="p_add">+	int level, max_level = ilk_wm_max_level(dev);</span>
<span class="p_add">+	enum pipe pipe = intel_crtc-&gt;pipe;</span>
 
<span class="p_del">-	for_each_plane(dev_priv, pipe, plane) {</span>
<span class="p_del">-		I915_WRITE(PLANE_SURF(pipe, plane),</span>
<span class="p_del">-			   I915_READ(PLANE_SURF(pipe, plane)));</span>
<span class="p_add">+	for (level = 0; level &lt;= max_level; level++) {</span>
<span class="p_add">+		I915_WRITE(CUR_WM(pipe, level),</span>
<span class="p_add">+			   wm-&gt;plane[pipe][PLANE_CURSOR][level]);</span>
 	}
<span class="p_del">-	I915_WRITE(CURBASE(pipe), I915_READ(CURBASE(pipe)));</span>
<span class="p_add">+	I915_WRITE(CUR_WM_TRANS(pipe), wm-&gt;plane_trans[pipe][PLANE_CURSOR]);</span>
<span class="p_add">+</span>
<span class="p_add">+	skl_ddb_entry_write(dev_priv, CUR_BUF_CFG(pipe),</span>
<span class="p_add">+			    &amp;wm-&gt;ddb.plane[pipe][PLANE_CURSOR]);</span>
 }
 
<span class="p_del">-static bool</span>
<span class="p_del">-skl_ddb_allocation_included(const struct skl_ddb_allocation *old,</span>
<span class="p_del">-			    const struct skl_ddb_allocation *new,</span>
<span class="p_del">-			    enum pipe pipe)</span>
<span class="p_add">+bool skl_ddb_allocation_equals(const struct skl_ddb_allocation *old,</span>
<span class="p_add">+			       const struct skl_ddb_allocation *new,</span>
<span class="p_add">+			       enum pipe pipe)</span>
 {
<span class="p_del">-	uint16_t old_size, new_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	old_size = skl_ddb_entry_size(&amp;old-&gt;pipe[pipe]);</span>
<span class="p_del">-	new_size = skl_ddb_entry_size(&amp;new-&gt;pipe[pipe]);</span>
<span class="p_del">-</span>
<span class="p_del">-	return old_size != new_size &amp;&amp;</span>
<span class="p_del">-	       new-&gt;pipe[pipe].start &gt;= old-&gt;pipe[pipe].start &amp;&amp;</span>
<span class="p_del">-	       new-&gt;pipe[pipe].end &lt;= old-&gt;pipe[pipe].end;</span>
<span class="p_add">+	return new-&gt;pipe[pipe].start == old-&gt;pipe[pipe].start &amp;&amp;</span>
<span class="p_add">+	       new-&gt;pipe[pipe].end == old-&gt;pipe[pipe].end;</span>
 }
 
<span class="p_del">-static void skl_flush_wm_values(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-				struct skl_wm_values *new_values)</span>
<span class="p_add">+static inline bool skl_ddb_entries_overlap(const struct skl_ddb_entry *a,</span>
<span class="p_add">+					   const struct skl_ddb_entry *b)</span>
 {
<span class="p_del">-	struct drm_device *dev = &amp;dev_priv-&gt;drm;</span>
<span class="p_del">-	struct skl_ddb_allocation *cur_ddb, *new_ddb;</span>
<span class="p_del">-	bool reallocated[I915_MAX_PIPES] = {};</span>
<span class="p_del">-	struct intel_crtc *crtc;</span>
<span class="p_del">-	enum pipe pipe;</span>
<span class="p_del">-</span>
<span class="p_del">-	new_ddb = &amp;new_values-&gt;ddb;</span>
<span class="p_del">-	cur_ddb = &amp;dev_priv-&gt;wm.skl_hw.ddb;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * First pass: flush the pipes with the new allocation contained into</span>
<span class="p_del">-	 * the old space.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We&#39;ll wait for the vblank on those pipes to ensure we can safely</span>
<span class="p_del">-	 * re-allocate the freed space without this pipe fetching from it.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for_each_intel_crtc(dev, crtc) {</span>
<span class="p_del">-		if (!crtc-&gt;active)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		pipe = crtc-&gt;pipe;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!skl_ddb_allocation_included(cur_ddb, new_ddb, pipe))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		skl_wm_flush_pipe(dev_priv, pipe, 1);</span>
<span class="p_del">-		intel_wait_for_vblank(dev, pipe);</span>
<span class="p_del">-</span>
<span class="p_del">-		reallocated[pipe] = true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_add">+	return a-&gt;start &lt; b-&gt;end &amp;&amp; b-&gt;start &lt; a-&gt;end;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Second pass: flush the pipes that are having their allocation</span>
<span class="p_del">-	 * reduced, but overlapping with a previous allocation.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Here as well we need to wait for the vblank to make sure the freed</span>
<span class="p_del">-	 * space is not used anymore.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for_each_intel_crtc(dev, crtc) {</span>
<span class="p_del">-		if (!crtc-&gt;active)</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+bool skl_ddb_allocation_overlaps(struct drm_atomic_state *state,</span>
<span class="p_add">+				 const struct skl_ddb_allocation *old,</span>
<span class="p_add">+				 const struct skl_ddb_allocation *new,</span>
<span class="p_add">+				 enum pipe pipe)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_device *dev = state-&gt;dev;</span>
<span class="p_add">+	struct intel_crtc *intel_crtc;</span>
<span class="p_add">+	enum pipe otherp;</span>
 
<span class="p_del">-		pipe = crtc-&gt;pipe;</span>
<span class="p_add">+	for_each_intel_crtc(dev, intel_crtc) {</span>
<span class="p_add">+		otherp = intel_crtc-&gt;pipe;</span>
 
<span class="p_del">-		if (reallocated[pipe])</span>
<span class="p_add">+		if (otherp == pipe)</span>
 			continue;
 
<span class="p_del">-		if (skl_ddb_entry_size(&amp;new_ddb-&gt;pipe[pipe]) &lt;</span>
<span class="p_del">-		    skl_ddb_entry_size(&amp;cur_ddb-&gt;pipe[pipe])) {</span>
<span class="p_del">-			skl_wm_flush_pipe(dev_priv, pipe, 2);</span>
<span class="p_del">-			intel_wait_for_vblank(dev, pipe);</span>
<span class="p_del">-			reallocated[pipe] = true;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (skl_ddb_entries_overlap(&amp;new-&gt;pipe[pipe],</span>
<span class="p_add">+					    &amp;old-&gt;pipe[otherp]))</span>
<span class="p_add">+			return true;</span>
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Third pass: flush the pipes that got more space allocated.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We don&#39;t need to actively wait for the update here, next vblank</span>
<span class="p_del">-	 * will just get more DDB space with the correct WM values.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for_each_intel_crtc(dev, crtc) {</span>
<span class="p_del">-		if (!crtc-&gt;active)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		pipe = crtc-&gt;pipe;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * At this point, only the pipes more space than before are</span>
<span class="p_del">-		 * left to re-allocate.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (reallocated[pipe])</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		skl_wm_flush_pipe(dev_priv, pipe, 3);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	return false;</span>
 }
 
 static int skl_update_pipe_wm(struct drm_crtc_state *cstate,
<span class="p_chunk">@@ -4041,6 +3963,41 @@</span> <span class="p_context"> pipes_modified(struct drm_atomic_state *state)</span>
 	return ret;
 }
 
<span class="p_add">+int</span>
<span class="p_add">+skl_ddb_add_affected_planes(struct intel_crtc_state *cstate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_atomic_state *state = cstate-&gt;base.state;</span>
<span class="p_add">+	struct drm_device *dev = state-&gt;dev;</span>
<span class="p_add">+	struct drm_crtc *crtc = cstate-&gt;base.crtc;</span>
<span class="p_add">+	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(dev);</span>
<span class="p_add">+	struct intel_atomic_state *intel_state = to_intel_atomic_state(state);</span>
<span class="p_add">+	struct skl_ddb_allocation *new_ddb = &amp;intel_state-&gt;wm_results.ddb;</span>
<span class="p_add">+	struct skl_ddb_allocation *cur_ddb = &amp;dev_priv-&gt;wm.skl_hw.ddb;</span>
<span class="p_add">+	struct drm_plane_state *plane_state;</span>
<span class="p_add">+	struct drm_plane *plane;</span>
<span class="p_add">+	enum pipe pipe = intel_crtc-&gt;pipe;</span>
<span class="p_add">+	int id;</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(!drm_atomic_get_existing_crtc_state(state, crtc));</span>
<span class="p_add">+</span>
<span class="p_add">+	drm_for_each_plane_mask(plane, dev, crtc-&gt;state-&gt;plane_mask) {</span>
<span class="p_add">+		id = skl_wm_plane_id(to_intel_plane(plane));</span>
<span class="p_add">+</span>
<span class="p_add">+		if (skl_ddb_entry_equal(&amp;cur_ddb-&gt;plane[pipe][id],</span>
<span class="p_add">+					&amp;new_ddb-&gt;plane[pipe][id]) &amp;&amp;</span>
<span class="p_add">+		    skl_ddb_entry_equal(&amp;cur_ddb-&gt;y_plane[pipe][id],</span>
<span class="p_add">+					&amp;new_ddb-&gt;y_plane[pipe][id]))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		plane_state = drm_atomic_get_plane_state(state, plane);</span>
<span class="p_add">+		if (IS_ERR(plane_state))</span>
<span class="p_add">+			return PTR_ERR(plane_state);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 skl_compute_ddb(struct drm_atomic_state *state)
 {
<span class="p_chunk">@@ -4105,6 +4062,10 @@</span> <span class="p_context"> skl_compute_ddb(struct drm_atomic_state *state)</span>
 		if (ret)
 			return ret;
 
<span class="p_add">+		ret = skl_ddb_add_affected_planes(cstate);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
 		ret = drm_atomic_add_affected_planes(state, &amp;intel_crtc-&gt;base);
 		if (ret)
 			return ret;
<span class="p_chunk">@@ -4206,7 +4167,7 @@</span> <span class="p_context"> static void skl_update_wm(struct drm_crtc *crtc)</span>
 	struct skl_wm_values *hw_vals = &amp;dev_priv-&gt;wm.skl_hw;
 	struct intel_crtc_state *cstate = to_intel_crtc_state(crtc-&gt;state);
 	struct skl_pipe_wm *pipe_wm = &amp;cstate-&gt;wm.skl.optimal;
<span class="p_del">-	int pipe;</span>
<span class="p_add">+	enum pipe pipe = intel_crtc-&gt;pipe;</span>
 
 	if ((results-&gt;dirty_pipes &amp; drm_crtc_mask(crtc)) == 0)
 		return;
<span class="p_chunk">@@ -4215,15 +4176,22 @@</span> <span class="p_context"> static void skl_update_wm(struct drm_crtc *crtc)</span>
 
 	mutex_lock(&amp;dev_priv-&gt;wm.wm_mutex);
 
<span class="p_del">-	skl_write_wm_values(dev_priv, results);</span>
<span class="p_del">-	skl_flush_wm_values(dev_priv, results);</span>
<span class="p_del">-</span>
 	/*
<span class="p_del">-	 * Store the new configuration (but only for the pipes that have</span>
<span class="p_del">-	 * changed; the other values weren&#39;t recomputed).</span>
<span class="p_add">+	 * If this pipe isn&#39;t active already, we&#39;re going to be enabling it</span>
<span class="p_add">+	 * very soon. Since it&#39;s safe to update a pipe&#39;s ddb allocation while</span>
<span class="p_add">+	 * the pipe&#39;s shut off, just do so here. Already active pipes will have</span>
<span class="p_add">+	 * their watermarks updated once we update their planes.</span>
 	 */
<span class="p_del">-	for_each_pipe_masked(dev_priv, pipe, results-&gt;dirty_pipes)</span>
<span class="p_del">-		skl_copy_wm_for_pipe(hw_vals, results, pipe);</span>
<span class="p_add">+	if (crtc-&gt;state-&gt;active_changed) {</span>
<span class="p_add">+		int plane;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (plane = 0; plane &lt; intel_num_planes(intel_crtc); plane++)</span>
<span class="p_add">+			skl_write_plane_wm(intel_crtc, results, plane);</span>
<span class="p_add">+</span>
<span class="p_add">+		skl_write_cursor_wm(intel_crtc, results);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	skl_copy_wm_for_pipe(hw_vals, results, pipe);</span>
 
 	mutex_unlock(&amp;dev_priv-&gt;wm.wm_mutex);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_sprite.c b/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_header">index 7c08e4f29032..4178849631ad 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_chunk">@@ -203,6 +203,9 @@</span> <span class="p_context"> skl_update_plane(struct drm_plane *drm_plane,</span>
 	struct intel_plane *intel_plane = to_intel_plane(drm_plane);
 	struct drm_framebuffer *fb = plane_state-&gt;base.fb;
 	struct drm_i915_gem_object *obj = intel_fb_obj(fb);
<span class="p_add">+	const struct skl_wm_values *wm = &amp;dev_priv-&gt;wm.skl_results;</span>
<span class="p_add">+	struct drm_crtc *crtc = crtc_state-&gt;base.crtc;</span>
<span class="p_add">+	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);</span>
 	const int pipe = intel_plane-&gt;pipe;
 	const int plane = intel_plane-&gt;plane + 1;
 	u32 plane_ctl, stride_div, stride;
<span class="p_chunk">@@ -238,6 +241,9 @@</span> <span class="p_context"> skl_update_plane(struct drm_plane *drm_plane,</span>
 	crtc_w--;
 	crtc_h--;
 
<span class="p_add">+	if (wm-&gt;dirty_pipes &amp; drm_crtc_mask(crtc))</span>
<span class="p_add">+		skl_write_plane_wm(intel_crtc, wm, plane);</span>
<span class="p_add">+</span>
 	if (key-&gt;flags) {
 		I915_WRITE(PLANE_KEYVAL(pipe, plane), key-&gt;min_value);
 		I915_WRITE(PLANE_KEYMAX(pipe, plane), key-&gt;max_value);
<span class="p_chunk">@@ -308,6 +314,14 @@</span> <span class="p_context"> skl_disable_plane(struct drm_plane *dplane, struct drm_crtc *crtc)</span>
 	const int pipe = intel_plane-&gt;pipe;
 	const int plane = intel_plane-&gt;plane + 1;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only populate skl_results on watermark updates, and if the</span>
<span class="p_add">+	 * plane&#39;s visiblity isn&#39;t actually changing neither is its watermarks.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!to_intel_plane_state(dplane-&gt;state)-&gt;visible)</span>
<span class="p_add">+		skl_write_plane_wm(to_intel_crtc(crtc),</span>
<span class="p_add">+				   &amp;dev_priv-&gt;wm.skl_results, plane);</span>
<span class="p_add">+</span>
 	I915_WRITE(PLANE_CTL(pipe, plane), 0);
 
 	I915_WRITE(PLANE_SURF(pipe, plane), 0);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">index ff80a81b1a84..ec28b15f2724 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_chunk">@@ -796,10 +796,9 @@</span> <span class="p_context"> __unclaimed_reg_debug(struct drm_i915_private *dev_priv,</span>
 		      const bool read,
 		      const bool before)
 {
<span class="p_del">-	if (WARN(check_for_unclaimed_mmio(dev_priv),</span>
<span class="p_del">-		 &quot;Unclaimed register detected %s %s register 0x%x\n&quot;,</span>
<span class="p_del">-		 before ? &quot;before&quot; : &quot;after&quot;,</span>
<span class="p_del">-		 read ? &quot;reading&quot; : &quot;writing to&quot;,</span>
<span class="p_add">+	if (WARN(check_for_unclaimed_mmio(dev_priv) &amp;&amp; !before,</span>
<span class="p_add">+		 &quot;Unclaimed %s register 0x%x\n&quot;,</span>
<span class="p_add">+		 read ? &quot;read from&quot; : &quot;write to&quot;,</span>
 		 i915_mmio_reg_offset(reg)))
 		i915.mmio_debug--; /* Only report the first N failures */
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600_dpm.c b/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_header">index 6a4b020dd0b4..5a26eb4545aa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_chunk">@@ -156,19 +156,20 @@</span> <span class="p_context"> u32 r600_dpm_get_vblank_time(struct radeon_device *rdev)</span>
 	struct drm_device *dev = rdev-&gt;ddev;
 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
<span class="p_del">-	u32 line_time_us, vblank_lines;</span>
<span class="p_add">+	u32 vblank_in_pixels;</span>
 	u32 vblank_time_us = 0xffffffff; /* if the displays are off, vblank time is max */
 
 	if (rdev-&gt;num_crtc &amp;&amp; rdev-&gt;mode_info.mode_config_initialized) {
 		list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
 			radeon_crtc = to_radeon_crtc(crtc);
 			if (crtc-&gt;enabled &amp;&amp; radeon_crtc-&gt;enabled &amp;&amp; radeon_crtc-&gt;hw_mode.clock) {
<span class="p_del">-				line_time_us = (radeon_crtc-&gt;hw_mode.crtc_htotal * 1000) /</span>
<span class="p_del">-					radeon_crtc-&gt;hw_mode.clock;</span>
<span class="p_del">-				vblank_lines = radeon_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_del">-					radeon_crtc-&gt;hw_mode.crtc_vdisplay +</span>
<span class="p_del">-					(radeon_crtc-&gt;v_border * 2);</span>
<span class="p_del">-				vblank_time_us = vblank_lines * line_time_us;</span>
<span class="p_add">+				vblank_in_pixels =</span>
<span class="p_add">+					radeon_crtc-&gt;hw_mode.crtc_htotal *</span>
<span class="p_add">+					(radeon_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_add">+					 radeon_crtc-&gt;hw_mode.crtc_vdisplay +</span>
<span class="p_add">+					 (radeon_crtc-&gt;v_border * 2));</span>
<span class="p_add">+</span>
<span class="p_add">+				vblank_time_us = vblank_in_pixels * 1000 / radeon_crtc-&gt;hw_mode.clock;</span>
 				break;
 			}
 		}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index a00dd2f74527..554ca7115f98 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -661,8 +661,9 @@</span> <span class="p_context"> bool radeon_card_posted(struct radeon_device *rdev)</span>
 {
 	uint32_t reg;
 
<span class="p_del">-	/* for pass through, always force asic_init */</span>
<span class="p_del">-	if (radeon_device_is_virtual())</span>
<span class="p_add">+	/* for pass through, always force asic_init for CI */</span>
<span class="p_add">+	if (rdev-&gt;family &gt;= CHIP_BONAIRE &amp;&amp;</span>
<span class="p_add">+	    radeon_device_is_virtual())</span>
 		return false;
 
 	/* required for EFI mode on macbook2,1 which uses an r5xx asic */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 1f78ec2548ec..89bdf20344ae 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -4112,7 +4112,7 @@</span> <span class="p_context"> static int si_populate_smc_voltage_tables(struct radeon_device *rdev,</span>
 							      &amp;rdev-&gt;pm.dpm.dyn_state.phase_shedding_limits_table)) {
 				si_populate_smc_voltage_table(rdev, &amp;si_pi-&gt;vddc_phase_shed_table, table);
 
<span class="p_del">-				table-&gt;phaseMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC] =</span>
<span class="p_add">+				table-&gt;phaseMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC_PHASE_SHEDDING] =</span>
 					cpu_to_be32(si_pi-&gt;vddc_phase_shed_table.mask_low);
 
 				si_write_smc_soft_register(rdev, SI_SMC_SOFT_REGISTER_phase_shedding_delay,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/sislands_smc.h b/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_header">index 3c779838d9ab..966e3a556011 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_chunk">@@ -194,6 +194,7 @@</span> <span class="p_context"> typedef struct SISLANDS_SMC_SWSTATE SISLANDS_SMC_SWSTATE;</span>
 #define SISLANDS_SMC_VOLTAGEMASK_VDDC  0
 #define SISLANDS_SMC_VOLTAGEMASK_MVDD  1
 #define SISLANDS_SMC_VOLTAGEMASK_VDDCI 2
<span class="p_add">+#define SISLANDS_SMC_VOLTAGEMASK_VDDC_PHASE_SHEDDING 3</span>
 #define SISLANDS_SMC_VOLTAGEMASK_MAX   4
 
 struct SISLANDS_SMC_VOLTAGEMASKTABLE
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_drv.h b/drivers/gpu/drm/vc4/vc4_drv.h</span>
<span class="p_header">index 428e24919ef1..f696b752886b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_drv.h</span>
<span class="p_chunk">@@ -122,9 +122,16 @@</span> <span class="p_context"> to_vc4_dev(struct drm_device *dev)</span>
 struct vc4_bo {
 	struct drm_gem_cma_object base;
 
<span class="p_del">-	/* seqno of the last job to render to this BO. */</span>
<span class="p_add">+	/* seqno of the last job to render using this BO. */</span>
 	uint64_t seqno;
 
<span class="p_add">+	/* seqno of the last job to use the RCL to write to this BO.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that this doesn&#39;t include binner overflow memory</span>
<span class="p_add">+	 * writes.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	uint64_t write_seqno;</span>
<span class="p_add">+</span>
 	/* List entry for the BO&#39;s position in either
 	 * vc4_exec_info-&gt;unref_list or vc4_dev-&gt;bo_cache.time_list
 	 */
<span class="p_chunk">@@ -216,6 +223,9 @@</span> <span class="p_context"> struct vc4_exec_info {</span>
 	/* Sequence number for this bin/render job. */
 	uint64_t seqno;
 
<span class="p_add">+	/* Latest write_seqno of any BO that binning depends on. */</span>
<span class="p_add">+	uint64_t bin_dep_seqno;</span>
<span class="p_add">+</span>
 	/* Last current addresses the hardware was processing when the
 	 * hangcheck timer checked on us.
 	 */
<span class="p_chunk">@@ -230,6 +240,13 @@</span> <span class="p_context"> struct vc4_exec_info {</span>
 	struct drm_gem_cma_object **bo;
 	uint32_t bo_count;
 
<span class="p_add">+	/* List of BOs that are being written by the RCL.  Other than</span>
<span class="p_add">+	 * the binner temporary storage, this is all the BOs written</span>
<span class="p_add">+	 * by the job.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct drm_gem_cma_object *rcl_write_bo[4];</span>
<span class="p_add">+	uint32_t rcl_write_bo_count;</span>
<span class="p_add">+</span>
 	/* Pointers for our position in vc4-&gt;job_list */
 	struct list_head head;
 
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_gem.c b/drivers/gpu/drm/vc4/vc4_gem.c</span>
<span class="p_header">index b262c5c26f10..ae1609e739ef 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_gem.c</span>
<span class="p_chunk">@@ -471,6 +471,11 @@</span> <span class="p_context"> vc4_update_bo_seqnos(struct vc4_exec_info *exec, uint64_t seqno)</span>
 	list_for_each_entry(bo, &amp;exec-&gt;unref_list, unref_head) {
 		bo-&gt;seqno = seqno;
 	}
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; exec-&gt;rcl_write_bo_count; i++) {</span>
<span class="p_add">+		bo = to_vc4_bo(&amp;exec-&gt;rcl_write_bo[i]-&gt;base);</span>
<span class="p_add">+		bo-&gt;write_seqno = seqno;</span>
<span class="p_add">+	}</span>
 }
 
 /* Queues a struct vc4_exec_info for execution.  If no job is
<span class="p_chunk">@@ -673,6 +678,14 @@</span> <span class="p_context"> vc4_get_bcl(struct drm_device *dev, struct vc4_exec_info *exec)</span>
 		goto fail;
 
 	ret = vc4_validate_shader_recs(dev, exec);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Block waiting on any previous rendering into the CS&#39;s VBO,</span>
<span class="p_add">+	 * IB, or textures, so that pixels are actually written by the</span>
<span class="p_add">+	 * time we try to read them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = vc4_wait_for_seqno(dev, exec-&gt;bin_dep_seqno, ~0ull, true);</span>
 
 fail:
 	drm_free_large(temp);
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_render_cl.c b/drivers/gpu/drm/vc4/vc4_render_cl.c</span>
<span class="p_header">index 0f12418725e5..08886a309757 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_render_cl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_render_cl.c</span>
<span class="p_chunk">@@ -45,6 +45,8 @@</span> <span class="p_context"> struct vc4_rcl_setup {</span>
 
 	struct drm_gem_cma_object *rcl;
 	u32 next_offset;
<span class="p_add">+</span>
<span class="p_add">+	u32 next_write_bo_index;</span>
 };
 
 static inline void rcl_u8(struct vc4_rcl_setup *setup, u8 val)
<span class="p_chunk">@@ -407,6 +409,8 @@</span> <span class="p_context"> static int vc4_rcl_msaa_surface_setup(struct vc4_exec_info *exec,</span>
 	if (!*obj)
 		return -EINVAL;
 
<span class="p_add">+	exec-&gt;rcl_write_bo[exec-&gt;rcl_write_bo_count++] = *obj;</span>
<span class="p_add">+</span>
 	if (surf-&gt;offset &amp; 0xf) {
 		DRM_ERROR(&quot;MSAA write must be 16b aligned.\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -417,7 +421,8 @@</span> <span class="p_context"> static int vc4_rcl_msaa_surface_setup(struct vc4_exec_info *exec,</span>
 
 static int vc4_rcl_surface_setup(struct vc4_exec_info *exec,
 				 struct drm_gem_cma_object **obj,
<span class="p_del">-				 struct drm_vc4_submit_rcl_surface *surf)</span>
<span class="p_add">+				 struct drm_vc4_submit_rcl_surface *surf,</span>
<span class="p_add">+				 bool is_write)</span>
 {
 	uint8_t tiling = VC4_GET_FIELD(surf-&gt;bits,
 				       VC4_LOADSTORE_TILE_BUFFER_TILING);
<span class="p_chunk">@@ -440,6 +445,9 @@</span> <span class="p_context"> static int vc4_rcl_surface_setup(struct vc4_exec_info *exec,</span>
 	if (!*obj)
 		return -EINVAL;
 
<span class="p_add">+	if (is_write)</span>
<span class="p_add">+		exec-&gt;rcl_write_bo[exec-&gt;rcl_write_bo_count++] = *obj;</span>
<span class="p_add">+</span>
 	if (surf-&gt;flags &amp; VC4_SUBMIT_RCL_SURFACE_READ_IS_FULL_RES) {
 		if (surf == &amp;exec-&gt;args-&gt;zs_write) {
 			DRM_ERROR(&quot;general zs write may not be a full-res.\n&quot;);
<span class="p_chunk">@@ -542,6 +550,8 @@</span> <span class="p_context"> vc4_rcl_render_config_surface_setup(struct vc4_exec_info *exec,</span>
 	if (!*obj)
 		return -EINVAL;
 
<span class="p_add">+	exec-&gt;rcl_write_bo[exec-&gt;rcl_write_bo_count++] = *obj;</span>
<span class="p_add">+</span>
 	if (tiling &gt; VC4_TILING_FORMAT_LT) {
 		DRM_ERROR(&quot;Bad tiling format\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -599,15 +609,18 @@</span> <span class="p_context"> int vc4_get_rcl(struct drm_device *dev, struct vc4_exec_info *exec)</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = vc4_rcl_surface_setup(exec, &amp;setup.color_read, &amp;args-&gt;color_read);</span>
<span class="p_add">+	ret = vc4_rcl_surface_setup(exec, &amp;setup.color_read, &amp;args-&gt;color_read,</span>
<span class="p_add">+				    false);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = vc4_rcl_surface_setup(exec, &amp;setup.zs_read, &amp;args-&gt;zs_read);</span>
<span class="p_add">+	ret = vc4_rcl_surface_setup(exec, &amp;setup.zs_read, &amp;args-&gt;zs_read,</span>
<span class="p_add">+				    false);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	ret = vc4_rcl_surface_setup(exec, &amp;setup.zs_write, &amp;args-&gt;zs_write);</span>
<span class="p_add">+	ret = vc4_rcl_surface_setup(exec, &amp;setup.zs_write, &amp;args-&gt;zs_write,</span>
<span class="p_add">+				    true);</span>
 	if (ret)
 		return ret;
 
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_validate.c b/drivers/gpu/drm/vc4/vc4_validate.c</span>
<span class="p_header">index 9ce1d0adf882..26503e307438 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_validate.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_validate.c</span>
<span class="p_chunk">@@ -267,6 +267,9 @@</span> <span class="p_context"> validate_indexed_prim_list(VALIDATE_ARGS)</span>
 	if (!ib)
 		return -EINVAL;
 
<span class="p_add">+	exec-&gt;bin_dep_seqno = max(exec-&gt;bin_dep_seqno,</span>
<span class="p_add">+				  to_vc4_bo(&amp;ib-&gt;base)-&gt;write_seqno);</span>
<span class="p_add">+</span>
 	if (offset &gt; ib-&gt;base.size ||
 	    (ib-&gt;base.size - offset) / index_size &lt; length) {
 		DRM_ERROR(&quot;IB access overflow (%d + %d*%d &gt; %zd)\n&quot;,
<span class="p_chunk">@@ -555,8 +558,7 @@</span> <span class="p_context"> static bool</span>
 reloc_tex(struct vc4_exec_info *exec,
 	  void *uniform_data_u,
 	  struct vc4_texture_sample_info *sample,
<span class="p_del">-	  uint32_t texture_handle_index)</span>
<span class="p_del">-</span>
<span class="p_add">+	  uint32_t texture_handle_index, bool is_cs)</span>
 {
 	struct drm_gem_cma_object *tex;
 	uint32_t p0 = *(uint32_t *)(uniform_data_u + sample-&gt;p_offset[0]);
<span class="p_chunk">@@ -714,6 +716,11 @@</span> <span class="p_context"> reloc_tex(struct vc4_exec_info *exec,</span>
 
 	*validated_p0 = tex-&gt;paddr + p0;
 
<span class="p_add">+	if (is_cs) {</span>
<span class="p_add">+		exec-&gt;bin_dep_seqno = max(exec-&gt;bin_dep_seqno,</span>
<span class="p_add">+					  to_vc4_bo(&amp;tex-&gt;base)-&gt;write_seqno);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return true;
  fail:
 	DRM_INFO(&quot;Texture p0 at %d: 0x%08x\n&quot;, sample-&gt;p_offset[0], p0);
<span class="p_chunk">@@ -835,7 +842,8 @@</span> <span class="p_context"> validate_gl_shader_rec(struct drm_device *dev,</span>
 			if (!reloc_tex(exec,
 				       uniform_data_u,
 				       &amp;validated_shader-&gt;texture_samples[tex],
<span class="p_del">-				       texture_handles_u[tex])) {</span>
<span class="p_add">+				       texture_handles_u[tex],</span>
<span class="p_add">+				       i == 2)) {</span>
 				return -EINVAL;
 			}
 		}
<span class="p_chunk">@@ -867,6 +875,9 @@</span> <span class="p_context"> validate_gl_shader_rec(struct drm_device *dev,</span>
 		uint32_t stride = *(uint8_t *)(pkt_u + o + 5);
 		uint32_t max_index;
 
<span class="p_add">+		exec-&gt;bin_dep_seqno = max(exec-&gt;bin_dep_seqno,</span>
<span class="p_add">+					  to_vc4_bo(&amp;vbo-&gt;base)-&gt;write_seqno);</span>
<span class="p_add">+</span>
 		if (state-&gt;addr &amp; 0x8)
 			stride |= (*(uint32_t *)(pkt_u + 100 + i * 4)) &amp; ~0xff;
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index dc5beff2b4aa..8a15c4aa84c1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -34,6 +34,24 @@</span> <span class="p_context"></span>
 
 #define VMW_RES_HT_ORDER 12
 
<span class="p_add">+ /**</span>
<span class="p_add">+ * enum vmw_resource_relocation_type - Relocation type for resources</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @vmw_res_rel_normal: Traditional relocation. The resource id in the</span>
<span class="p_add">+ * command stream is replaced with the actual id after validation.</span>
<span class="p_add">+ * @vmw_res_rel_nop: NOP relocation. The command is unconditionally replaced</span>
<span class="p_add">+ * with a NOP.</span>
<span class="p_add">+ * @vmw_res_rel_cond_nop: Conditional NOP relocation. If the resource id</span>
<span class="p_add">+ * after validation is -1, the command is replaced with a NOP. Otherwise no</span>
<span class="p_add">+ * action.</span>
<span class="p_add">+ */</span>
<span class="p_add">+enum vmw_resource_relocation_type {</span>
<span class="p_add">+	vmw_res_rel_normal,</span>
<span class="p_add">+	vmw_res_rel_nop,</span>
<span class="p_add">+	vmw_res_rel_cond_nop,</span>
<span class="p_add">+	vmw_res_rel_max</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /**
  * struct vmw_resource_relocation - Relocation info for resources
  *
<span class="p_chunk">@@ -41,11 +59,13 @@</span> <span class="p_context"></span>
  * @res: Non-ref-counted pointer to the resource.
  * @offset: Offset of 4 byte entries into the command buffer where the
  * id that needs fixup is located.
<span class="p_add">+ * @rel_type: Type of relocation.</span>
  */
 struct vmw_resource_relocation {
 	struct list_head head;
 	const struct vmw_resource *res;
<span class="p_del">-	unsigned long offset;</span>
<span class="p_add">+	u32 offset:29;</span>
<span class="p_add">+	enum vmw_resource_relocation_type rel_type:3;</span>
 };
 
 /**
<span class="p_chunk">@@ -410,10 +430,13 @@</span> <span class="p_context"> static int vmw_resource_context_res_add(struct vmw_private *dev_priv,</span>
  * @res: The resource.
  * @offset: Offset into the command buffer currently being parsed where the
  * id that needs fixup is located. Granularity is 4 bytes.
<span class="p_add">+ * @rel_type: Relocation type.</span>
  */
 static int vmw_resource_relocation_add(struct list_head *list,
 				       const struct vmw_resource *res,
<span class="p_del">-				       unsigned long offset)</span>
<span class="p_add">+				       unsigned long offset,</span>
<span class="p_add">+				       enum vmw_resource_relocation_type</span>
<span class="p_add">+				       rel_type)</span>
 {
 	struct vmw_resource_relocation *rel;
 
<span class="p_chunk">@@ -425,6 +448,7 @@</span> <span class="p_context"> static int vmw_resource_relocation_add(struct list_head *list,</span>
 
 	rel-&gt;res = res;
 	rel-&gt;offset = offset;
<span class="p_add">+	rel-&gt;rel_type = rel_type;</span>
 	list_add_tail(&amp;rel-&gt;head, list);
 
 	return 0;
<span class="p_chunk">@@ -459,11 +483,23 @@</span> <span class="p_context"> static void vmw_resource_relocations_apply(uint32_t *cb,</span>
 {
 	struct vmw_resource_relocation *rel;
 
<span class="p_add">+	/* Validate the struct vmw_resource_relocation member size */</span>
<span class="p_add">+	BUILD_BUG_ON(SVGA_CB_MAX_SIZE &gt;= (1 &lt;&lt; 29));</span>
<span class="p_add">+	BUILD_BUG_ON(vmw_res_rel_max &gt;= (1 &lt;&lt; 3));</span>
<span class="p_add">+</span>
 	list_for_each_entry(rel, list, head) {
<span class="p_del">-		if (likely(rel-&gt;res != NULL))</span>
<span class="p_add">+		switch (rel-&gt;rel_type) {</span>
<span class="p_add">+		case vmw_res_rel_normal:</span>
 			cb[rel-&gt;offset] = rel-&gt;res-&gt;id;
<span class="p_del">-		else</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case vmw_res_rel_nop:</span>
 			cb[rel-&gt;offset] = SVGA_3D_CMD_NOP;
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			if (rel-&gt;res-&gt;id == -1)</span>
<span class="p_add">+				cb[rel-&gt;offset] = SVGA_3D_CMD_NOP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -655,7 +691,8 @@</span> <span class="p_context"> static int vmw_cmd_res_reloc_add(struct vmw_private *dev_priv,</span>
 	*p_val = NULL;
 	ret = vmw_resource_relocation_add(&amp;sw_context-&gt;res_relocations,
 					  res,
<span class="p_del">-					  id_loc - sw_context-&gt;buf_start);</span>
<span class="p_add">+					  id_loc - sw_context-&gt;buf_start,</span>
<span class="p_add">+					  vmw_res_rel_normal);</span>
 	if (unlikely(ret != 0))
 		return ret;
 
<span class="p_chunk">@@ -721,7 +758,8 @@</span> <span class="p_context"> vmw_cmd_res_check(struct vmw_private *dev_priv,</span>
 
 		return vmw_resource_relocation_add
 			(&amp;sw_context-&gt;res_relocations, res,
<span class="p_del">-			 id_loc - sw_context-&gt;buf_start);</span>
<span class="p_add">+			 id_loc - sw_context-&gt;buf_start,</span>
<span class="p_add">+			 vmw_res_rel_normal);</span>
 	}
 
 	ret = vmw_user_resource_lookup_handle(dev_priv,
<span class="p_chunk">@@ -2144,7 +2182,8 @@</span> <span class="p_context"> static int vmw_cmd_shader_define(struct vmw_private *dev_priv,</span>
 
 	return vmw_resource_relocation_add(&amp;sw_context-&gt;res_relocations,
 					   NULL, &amp;cmd-&gt;header.id -
<span class="p_del">-					   sw_context-&gt;buf_start);</span>
<span class="p_add">+					   sw_context-&gt;buf_start,</span>
<span class="p_add">+					   vmw_res_rel_nop);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -2189,7 +2228,8 @@</span> <span class="p_context"> static int vmw_cmd_shader_destroy(struct vmw_private *dev_priv,</span>
 
 	return vmw_resource_relocation_add(&amp;sw_context-&gt;res_relocations,
 					   NULL, &amp;cmd-&gt;header.id -
<span class="p_del">-					   sw_context-&gt;buf_start);</span>
<span class="p_add">+					   sw_context-&gt;buf_start,</span>
<span class="p_add">+					   vmw_res_rel_nop);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -2848,8 +2888,7 @@</span> <span class="p_context"> static int vmw_cmd_dx_cid_check(struct vmw_private *dev_priv,</span>
  * @header: Pointer to the command header in the command stream.
  *
  * Check that the view exists, and if it was not created using this
<span class="p_del">- * command batch, make sure it&#39;s validated (present in the device) so that</span>
<span class="p_del">- * the remove command will not confuse the device.</span>
<span class="p_add">+ * command batch, conditionally make this command a NOP.</span>
  */
 static int vmw_cmd_dx_view_remove(struct vmw_private *dev_priv,
 				  struct vmw_sw_context *sw_context,
<span class="p_chunk">@@ -2877,10 +2916,15 @@</span> <span class="p_context"> static int vmw_cmd_dx_view_remove(struct vmw_private *dev_priv,</span>
 		return ret;
 
 	/*
<span class="p_del">-	 * Add view to the validate list iff it was not created using this</span>
<span class="p_del">-	 * command batch.</span>
<span class="p_add">+	 * If the view wasn&#39;t created during this command batch, it might</span>
<span class="p_add">+	 * have been removed due to a context swapout, so add a</span>
<span class="p_add">+	 * relocation to conditionally make this command a NOP to avoid</span>
<span class="p_add">+	 * device errors.</span>
 	 */
<span class="p_del">-	return vmw_view_res_val_add(sw_context, view);</span>
<span class="p_add">+	return vmw_resource_relocation_add(&amp;sw_context-&gt;res_relocations,</span>
<span class="p_add">+					   view,</span>
<span class="p_add">+					   &amp;cmd-&gt;header.id - sw_context-&gt;buf_start,</span>
<span class="p_add">+					   vmw_res_rel_cond_nop);</span>
 }
 
 /**
<span class="p_chunk">@@ -3848,14 +3892,14 @@</span> <span class="p_context"> static void *vmw_execbuf_cmdbuf(struct vmw_private *dev_priv,</span>
 	int ret;
 
 	*header = NULL;
<span class="p_del">-	if (!dev_priv-&gt;cman || kernel_commands)</span>
<span class="p_del">-		return kernel_commands;</span>
<span class="p_del">-</span>
 	if (command_size &gt; SVGA_CB_MAX_SIZE) {
 		DRM_ERROR(&quot;Command buffer is too large.\n&quot;);
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_add">+	if (!dev_priv-&gt;cman || kernel_commands)</span>
<span class="p_add">+		return kernel_commands;</span>
<span class="p_add">+</span>
 	/* If possible, add a little space for fencing. */
 	cmdbuf_size = command_size + 512;
 	cmdbuf_size = min_t(size_t, cmdbuf_size, SVGA_CB_MAX_SIZE);
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 4ed9a4fdfea7..e92b09d32605 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -64,6 +64,9 @@</span> <span class="p_context"></span>
 #define USB_VENDOR_ID_AKAI		0x2011
 #define USB_DEVICE_ID_AKAI_MPKMINI2	0x0715
 
<span class="p_add">+#define USB_VENDOR_ID_AKAI_09E8		0x09E8</span>
<span class="p_add">+#define USB_DEVICE_ID_AKAI_09E8_MIDIMIX	0x0031</span>
<span class="p_add">+</span>
 #define USB_VENDOR_ID_ALCOR		0x058f
 #define USB_DEVICE_ID_ALCOR_USBRS232	0x9720
 
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index b4b8c6abb03e..bb400081efe4 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -56,6 +56,7 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 
 	{ USB_VENDOR_ID_AIREN, USB_DEVICE_ID_AIREN_SLIMPLUS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_AKAI, USB_DEVICE_ID_AKAI_MPKMINI2, HID_QUIRK_NO_INIT_REPORTS },
<span class="p_add">+	{ USB_VENDOR_ID_AKAI_09E8, USB_DEVICE_ID_AKAI_09E8_MIDIMIX, HID_QUIRK_NO_INIT_REPORTS },</span>
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_UC100KM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS124U, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_2PORTKVM, HID_QUIRK_NOGET },
<span class="p_header">diff --git a/drivers/hwtracing/coresight/coresight-tmc.c b/drivers/hwtracing/coresight/coresight-tmc.c</span>
<span class="p_header">index 9e02ac963cd0..3978cbb6b038 100644</span>
<span class="p_header">--- a/drivers/hwtracing/coresight/coresight-tmc.c</span>
<span class="p_header">+++ b/drivers/hwtracing/coresight/coresight-tmc.c</span>
<span class="p_chunk">@@ -388,9 +388,6 @@</span> <span class="p_context"> static int tmc_probe(struct amba_device *adev, const struct amba_id *id)</span>
 err_misc_register:
 	coresight_unregister(drvdata-&gt;csdev);
 err_devm_kzalloc:
<span class="p_del">-	if (drvdata-&gt;config_type == TMC_CONFIG_TYPE_ETR)</span>
<span class="p_del">-		dma_free_coherent(dev, drvdata-&gt;size,</span>
<span class="p_del">-				drvdata-&gt;vaddr, drvdata-&gt;paddr);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/iio/dac/ad5755.c b/drivers/iio/dac/ad5755.c</span>
<span class="p_header">index 0fde593ec0d9..5f7968232564 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad5755.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad5755.c</span>
<span class="p_chunk">@@ -655,7 +655,7 @@</span> <span class="p_context"> static struct ad5755_platform_data *ad5755_parse_dt(struct device *dev)</span>
 
 	devnr = 0;
 	for_each_child_of_node(np, pp) {
<span class="p_del">-		if (devnr &gt; AD5755_NUM_CHANNELS) {</span>
<span class="p_add">+		if (devnr &gt;= AD5755_NUM_CHANNELS) {</span>
 			dev_err(dev,
 				&quot;There is to many channels defined in DT\n&quot;);
 			goto error_out;
<span class="p_header">diff --git a/drivers/iio/light/us5182d.c b/drivers/iio/light/us5182d.c</span>
<span class="p_header">index 20c40f780964..18cf2e29e4d5 100644</span>
<span class="p_header">--- a/drivers/iio/light/us5182d.c</span>
<span class="p_header">+++ b/drivers/iio/light/us5182d.c</span>
<span class="p_chunk">@@ -894,7 +894,7 @@</span> <span class="p_context"> static int us5182d_probe(struct i2c_client *client,</span>
 		goto out_err;
 
 	if (data-&gt;default_continuous) {
<span class="p_del">-		pm_runtime_set_active(&amp;client-&gt;dev);</span>
<span class="p_add">+		ret = pm_runtime_set_active(&amp;client-&gt;dev);</span>
 		if (ret &lt; 0)
 			goto out_err;
 	}
<span class="p_header">diff --git a/drivers/infiniband/hw/hfi1/qp.c b/drivers/infiniband/hw/hfi1/qp.c</span>
<span class="p_header">index 4e4d8317c281..c17c9dd7cde1 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/hfi1/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/hfi1/qp.c</span>
<span class="p_chunk">@@ -808,6 +808,13 @@</span> <span class="p_context"> void *qp_priv_alloc(struct rvt_dev_info *rdi, struct rvt_qp *qp,</span>
 		kfree(priv);
 		return ERR_PTR(-ENOMEM);
 	}
<span class="p_add">+	iowait_init(</span>
<span class="p_add">+		&amp;priv-&gt;s_iowait,</span>
<span class="p_add">+		1,</span>
<span class="p_add">+		_hfi1_do_send,</span>
<span class="p_add">+		iowait_sleep,</span>
<span class="p_add">+		iowait_wakeup,</span>
<span class="p_add">+		iowait_sdma_drained);</span>
 	setup_timer(&amp;priv-&gt;s_rnr_timer, hfi1_rc_rnr_retry, (unsigned long)qp);
 	qp-&gt;s_timer.function = hfi1_rc_timeout;
 	return priv;
<span class="p_chunk">@@ -873,13 +880,6 @@</span> <span class="p_context"> void notify_qp_reset(struct rvt_qp *qp)</span>
 {
 	struct hfi1_qp_priv *priv = qp-&gt;priv;
 
<span class="p_del">-	iowait_init(</span>
<span class="p_del">-		&amp;priv-&gt;s_iowait,</span>
<span class="p_del">-		1,</span>
<span class="p_del">-		_hfi1_do_send,</span>
<span class="p_del">-		iowait_sleep,</span>
<span class="p_del">-		iowait_wakeup,</span>
<span class="p_del">-		iowait_sdma_drained);</span>
 	priv-&gt;r_adefered = 0;
 	clear_ahg(qp);
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index e19537cf44ab..bff8707a2f1f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -1843,6 +1843,7 @@</span> <span class="p_context"> static struct mlx5_ib_flow_handler *create_leftovers_rule(struct mlx5_ib_dev *de</span>
 						 &amp;leftovers_specs[LEFTOVERS_UC].flow_attr,
 						 dst);
 		if (IS_ERR(handler_ucast)) {
<span class="p_add">+			mlx5_del_flow_rule(handler-&gt;rule);</span>
 			kfree(handler);
 			handler = handler_ucast;
 		} else {
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">index bbf0a163aeab..54bb655f5332 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_chunk">@@ -1131,7 +1131,6 @@</span> <span class="p_context"> extern spinlock_t qib_devs_lock;</span>
 extern struct qib_devdata *qib_lookup(int unit);
 extern u32 qib_cpulist_count;
 extern unsigned long *qib_cpulist;
<span class="p_del">-extern u16 qpt_mask;</span>
 extern unsigned qib_cc_table_size;
 
 int qib_init(struct qib_devdata *, int);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_qp.c b/drivers/infiniband/hw/qib/qib_qp.c</span>
<span class="p_header">index f9b8cd2354d1..99d31efe4c2f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_qp.c</span>
<span class="p_chunk">@@ -41,14 +41,6 @@</span> <span class="p_context"></span>
 
 #include &quot;qib.h&quot;
 
<span class="p_del">-/*</span>
<span class="p_del">- * mask field which was present in now deleted qib_qpn_table</span>
<span class="p_del">- * is not present in rvt_qpn_table. Defining the same field</span>
<span class="p_del">- * as qpt_mask here instead of adding the mask field to</span>
<span class="p_del">- * rvt_qpn_table.</span>
<span class="p_del">- */</span>
<span class="p_del">-u16 qpt_mask;</span>
<span class="p_del">-</span>
 static inline unsigned mk_qpn(struct rvt_qpn_table *qpt,
 			      struct rvt_qpn_map *map, unsigned off)
 {
<span class="p_chunk">@@ -57,7 +49,7 @@</span> <span class="p_context"> static inline unsigned mk_qpn(struct rvt_qpn_table *qpt,</span>
 
 static inline unsigned find_next_offset(struct rvt_qpn_table *qpt,
 					struct rvt_qpn_map *map, unsigned off,
<span class="p_del">-					unsigned n)</span>
<span class="p_add">+					unsigned n, u16 qpt_mask)</span>
 {
 	if (qpt_mask) {
 		off++;
<span class="p_chunk">@@ -179,6 +171,7 @@</span> <span class="p_context"> int qib_alloc_qpn(struct rvt_dev_info *rdi, struct rvt_qpn_table *qpt,</span>
 	struct qib_ibdev *verbs_dev = container_of(rdi, struct qib_ibdev, rdi);
 	struct qib_devdata *dd = container_of(verbs_dev, struct qib_devdata,
 					      verbs_dev);
<span class="p_add">+	u16 qpt_mask = dd-&gt;qpn_mask;</span>
 
 	if (type == IB_QPT_SMI || type == IB_QPT_GSI) {
 		unsigned n;
<span class="p_chunk">@@ -215,7 +208,7 @@</span> <span class="p_context"> int qib_alloc_qpn(struct rvt_dev_info *rdi, struct rvt_qpn_table *qpt,</span>
 				goto bail;
 			}
 			offset = find_next_offset(qpt, map, offset,
<span class="p_del">-				dd-&gt;n_krcv_queues);</span>
<span class="p_add">+				dd-&gt;n_krcv_queues, qpt_mask);</span>
 			qpn = mk_qpn(qpt, map, offset);
 			/*
 			 * This test differs from alloc_pidmap().
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_header">index fd1dfbce5539..b2b845f9f7df 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_chunk">@@ -1606,8 +1606,6 @@</span> <span class="p_context"> int qib_register_ib_device(struct qib_devdata *dd)</span>
 	/* Only need to initialize non-zero fields. */
 	setup_timer(&amp;dev-&gt;mem_timer, mem_timer, (unsigned long)dev);
 
<span class="p_del">-	qpt_mask = dd-&gt;qpn_mask;</span>
<span class="p_del">-</span>
 	INIT_LIST_HEAD(&amp;dev-&gt;piowait);
 	INIT_LIST_HEAD(&amp;dev-&gt;dmawait);
 	INIT_LIST_HEAD(&amp;dev-&gt;txwait);
<span class="p_header">diff --git a/drivers/infiniband/sw/rdmavt/qp.c b/drivers/infiniband/sw/rdmavt/qp.c</span>
<span class="p_header">index 870b4f212fbc..5911c534cc18 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rdmavt/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rdmavt/qp.c</span>
<span class="p_chunk">@@ -501,12 +501,9 @@</span> <span class="p_context"> static void rvt_remove_qp(struct rvt_dev_info *rdi, struct rvt_qp *qp)</span>
  */
 static void rvt_reset_qp(struct rvt_dev_info *rdi, struct rvt_qp *qp,
 		  enum ib_qp_type type)
<span class="p_del">-	__releases(&amp;qp-&gt;s_lock)</span>
<span class="p_del">-	__releases(&amp;qp-&gt;s_hlock)</span>
<span class="p_del">-	__releases(&amp;qp-&gt;r_lock)</span>
<span class="p_del">-	__acquires(&amp;qp-&gt;r_lock)</span>
<span class="p_del">-	__acquires(&amp;qp-&gt;s_hlock)</span>
<span class="p_del">-	__acquires(&amp;qp-&gt;s_lock)</span>
<span class="p_add">+	__must_hold(&amp;qp-&gt;r_lock)</span>
<span class="p_add">+	__must_hold(&amp;qp-&gt;s_hlock)</span>
<span class="p_add">+	__must_hold(&amp;qp-&gt;s_lock)</span>
 {
 	if (qp-&gt;state != IB_QPS_RESET) {
 		qp-&gt;state = IB_QPS_RESET;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_client.c b/drivers/net/ethernet/intel/i40e/i40e_client.c</span>
<span class="p_header">index 618f18436618..c65e17fae24e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_client.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_client.c</span>
<span class="p_chunk">@@ -1009,7 +1009,6 @@</span> <span class="p_context"> int i40e_unregister_client(struct i40e_client *client)</span>
 	if (!i40e_client_is_registered(client)) {
 		pr_info(&quot;i40e: Client %s has not been registered\n&quot;,
 			client-&gt;name);
<span class="p_del">-		mutex_unlock(&amp;i40e_client_mutex);</span>
 		ret = -ENODEV;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index dad15b6c66dd..c74d16409941 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -7990,45 +7990,34 @@</span> <span class="p_context"> static int i40e_setup_misc_vector(struct i40e_pf *pf)</span>
 static int i40e_config_rss_aq(struct i40e_vsi *vsi, const u8 *seed,
 			      u8 *lut, u16 lut_size)
 {
<span class="p_del">-	struct i40e_aqc_get_set_rss_key_data rss_key;</span>
 	struct i40e_pf *pf = vsi-&gt;back;
 	struct i40e_hw *hw = &amp;pf-&gt;hw;
<span class="p_del">-	bool pf_lut = false;</span>
<span class="p_del">-	u8 *rss_lut;</span>
<span class="p_del">-	int ret, i;</span>
<span class="p_del">-</span>
<span class="p_del">-	memcpy(&amp;rss_key, seed, sizeof(rss_key));</span>
<span class="p_del">-</span>
<span class="p_del">-	rss_lut = kzalloc(pf-&gt;rss_table_size, GFP_KERNEL);</span>
<span class="p_del">-	if (!rss_lut)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Populate the LUT with max no. of queues in round robin fashion */</span>
<span class="p_del">-	for (i = 0; i &lt; vsi-&gt;rss_table_size; i++)</span>
<span class="p_del">-		rss_lut[i] = i % vsi-&gt;rss_size;</span>
<span class="p_add">+	int ret = 0;</span>
 
<span class="p_del">-	ret = i40e_aq_set_rss_key(hw, vsi-&gt;id, &amp;rss_key);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		dev_info(&amp;pf-&gt;pdev-&gt;dev,</span>
<span class="p_del">-			 &quot;Cannot set RSS key, err %s aq_err %s\n&quot;,</span>
<span class="p_del">-			 i40e_stat_str(&amp;pf-&gt;hw, ret),</span>
<span class="p_del">-			 i40e_aq_str(&amp;pf-&gt;hw, pf-&gt;hw.aq.asq_last_status));</span>
<span class="p_del">-		goto config_rss_aq_out;</span>
<span class="p_add">+	if (seed) {</span>
<span class="p_add">+		struct i40e_aqc_get_set_rss_key_data *seed_dw =</span>
<span class="p_add">+			(struct i40e_aqc_get_set_rss_key_data *)seed;</span>
<span class="p_add">+		ret = i40e_aq_set_rss_key(hw, vsi-&gt;id, seed_dw);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_info(&amp;pf-&gt;pdev-&gt;dev,</span>
<span class="p_add">+				 &quot;Cannot set RSS key, err %s aq_err %s\n&quot;,</span>
<span class="p_add">+				 i40e_stat_str(hw, ret),</span>
<span class="p_add">+				 i40e_aq_str(hw, hw-&gt;aq.asq_last_status));</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_add">+	if (lut) {</span>
<span class="p_add">+		bool pf_lut = vsi-&gt;type == I40E_VSI_MAIN ? true : false;</span>
 
<span class="p_del">-	if (vsi-&gt;type == I40E_VSI_MAIN)</span>
<span class="p_del">-		pf_lut = true;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = i40e_aq_set_rss_lut(hw, vsi-&gt;id, pf_lut, rss_lut,</span>
<span class="p_del">-				  vsi-&gt;rss_table_size);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		dev_info(&amp;pf-&gt;pdev-&gt;dev,</span>
<span class="p_del">-			 &quot;Cannot set RSS lut, err %s aq_err %s\n&quot;,</span>
<span class="p_del">-			 i40e_stat_str(&amp;pf-&gt;hw, ret),</span>
<span class="p_del">-			 i40e_aq_str(&amp;pf-&gt;hw, pf-&gt;hw.aq.asq_last_status));</span>
<span class="p_del">-</span>
<span class="p_del">-config_rss_aq_out:</span>
<span class="p_del">-	kfree(rss_lut);</span>
<span class="p_add">+		ret = i40e_aq_set_rss_lut(hw, vsi-&gt;id, pf_lut, lut, lut_size);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			dev_info(&amp;pf-&gt;pdev-&gt;dev,</span>
<span class="p_add">+				 &quot;Cannot set RSS lut, err %s aq_err %s\n&quot;,</span>
<span class="p_add">+				 i40e_stat_str(hw, ret),</span>
<span class="p_add">+				 i40e_aq_str(hw, hw-&gt;aq.asq_last_status));</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/htt_rx.c b/drivers/net/wireless/ath/ath10k/htt_rx.c</span>
<span class="p_header">index 24c8d65bcf34..09ca63466504 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/htt_rx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c</span>
<span class="p_chunk">@@ -2394,6 +2394,8 @@</span> <span class="p_context"> static void ath10k_htt_txrx_compl_task(unsigned long ptr)</span>
 	skb_queue_splice_init(&amp;htt-&gt;rx_in_ord_compl_q, &amp;rx_ind_q);
 	spin_unlock_irqrestore(&amp;htt-&gt;rx_in_ord_compl_q.lock, flags);
 
<span class="p_add">+	ath10k_mac_tx_push_pending(ar);</span>
<span class="p_add">+</span>
 	spin_lock_irqsave(&amp;htt-&gt;tx_fetch_ind_q.lock, flags);
 	skb_queue_splice_init(&amp;htt-&gt;tx_fetch_ind_q, &amp;tx_ind_q);
 	spin_unlock_irqrestore(&amp;htt-&gt;tx_fetch_ind_q.lock, flags);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/mac.c b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">index 0bbd0a00edcc..146365b93ff5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/mac.c</span>
<span class="p_chunk">@@ -3777,7 +3777,9 @@</span> <span class="p_context"> int ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,</span>
 	enum ath10k_hw_txrx_mode txmode;
 	enum ath10k_mac_tx_path txpath;
 	struct sk_buff *skb;
<span class="p_add">+	struct ieee80211_hdr *hdr;</span>
 	size_t skb_len;
<span class="p_add">+	bool is_mgmt, is_presp;</span>
 	int ret;
 
 	spin_lock_bh(&amp;ar-&gt;htt.tx_lock);
<span class="p_chunk">@@ -3801,6 +3803,22 @@</span> <span class="p_context"> int ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,</span>
 	skb_len = skb-&gt;len;
 	txmode = ath10k_mac_tx_h_get_txmode(ar, vif, sta, skb);
 	txpath = ath10k_mac_tx_h_get_txpath(ar, skb, txmode);
<span class="p_add">+	is_mgmt = (txpath == ATH10K_MAC_TX_HTT_MGMT);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_mgmt) {</span>
<span class="p_add">+		hdr = (struct ieee80211_hdr *)skb-&gt;data;</span>
<span class="p_add">+		is_presp = ieee80211_is_probe_resp(hdr-&gt;frame_control);</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_bh(&amp;ar-&gt;htt.tx_lock);</span>
<span class="p_add">+		ret = ath10k_htt_tx_mgmt_inc_pending(htt, is_mgmt, is_presp);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			ath10k_htt_tx_dec_pending(htt);</span>
<span class="p_add">+			spin_unlock_bh(&amp;ar-&gt;htt.tx_lock);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_unlock_bh(&amp;ar-&gt;htt.tx_lock);</span>
<span class="p_add">+	}</span>
 
 	ret = ath10k_mac_tx(ar, vif, sta, txmode, txpath, skb);
 	if (unlikely(ret)) {
<span class="p_chunk">@@ -3808,6 +3826,8 @@</span> <span class="p_context"> int ath10k_mac_tx_push_txq(struct ieee80211_hw *hw,</span>
 
 		spin_lock_bh(&amp;ar-&gt;htt.tx_lock);
 		ath10k_htt_tx_dec_pending(htt);
<span class="p_add">+		if (is_mgmt)</span>
<span class="p_add">+			ath10k_htt_tx_mgmt_dec_pending(htt);</span>
 		spin_unlock_bh(&amp;ar-&gt;htt.tx_lock);
 
 		return ret;
<span class="p_chunk">@@ -6538,7 +6558,7 @@</span> <span class="p_context"> static int ath10k_get_survey(struct ieee80211_hw *hw, int idx,</span>
 		goto exit;
 	}
 
<span class="p_del">-	ath10k_mac_update_bss_chan_survey(ar, survey-&gt;channel);</span>
<span class="p_add">+	ath10k_mac_update_bss_chan_survey(ar, &amp;sband-&gt;channels[idx]);</span>
 
 	spin_lock_bh(&amp;ar-&gt;data_lock);
 	memcpy(survey, ar_survey, sizeof(*survey));
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/txrx.c b/drivers/net/wireless/ath/ath10k/txrx.c</span>
<span class="p_header">index b29a86a26c13..28ff5cb4ec28 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/txrx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/txrx.c</span>
<span class="p_chunk">@@ -119,8 +119,6 @@</span> <span class="p_context"> int ath10k_txrx_tx_unref(struct ath10k_htt *htt,</span>
 	ieee80211_tx_status(htt-&gt;ar-&gt;hw, msdu);
 	/* we do not own the msdu anymore */
 
<span class="p_del">-	ath10k_mac_tx_push_pending(ar);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/wmi.h b/drivers/net/wireless/ath/ath10k/wmi.h</span>
<span class="p_header">index 3ef468893b3f..f67cc198bc0e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/wmi.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/wmi.h</span>
<span class="p_chunk">@@ -180,6 +180,7 @@</span> <span class="p_context"> enum wmi_service {</span>
 	WMI_SERVICE_MESH_NON_11S,
 	WMI_SERVICE_PEER_STATS,
 	WMI_SERVICE_RESTRT_CHNL_SUPPORT,
<span class="p_add">+	WMI_SERVICE_PERIODIC_CHAN_STAT_SUPPORT,</span>
 	WMI_SERVICE_TX_MODE_PUSH_ONLY,
 	WMI_SERVICE_TX_MODE_PUSH_PULL,
 	WMI_SERVICE_TX_MODE_DYNAMIC,
<span class="p_chunk">@@ -305,6 +306,7 @@</span> <span class="p_context"> enum wmi_10_4_service {</span>
 	WMI_10_4_SERVICE_RESTRT_CHNL_SUPPORT,
 	WMI_10_4_SERVICE_PEER_STATS,
 	WMI_10_4_SERVICE_MESH_11S,
<span class="p_add">+	WMI_10_4_SERVICE_PERIODIC_CHAN_STAT_SUPPORT,</span>
 	WMI_10_4_SERVICE_TX_MODE_PUSH_ONLY,
 	WMI_10_4_SERVICE_TX_MODE_PUSH_PULL,
 	WMI_10_4_SERVICE_TX_MODE_DYNAMIC,
<span class="p_chunk">@@ -402,6 +404,7 @@</span> <span class="p_context"> static inline char *wmi_service_name(int service_id)</span>
 	SVCSTR(WMI_SERVICE_MESH_NON_11S);
 	SVCSTR(WMI_SERVICE_PEER_STATS);
 	SVCSTR(WMI_SERVICE_RESTRT_CHNL_SUPPORT);
<span class="p_add">+	SVCSTR(WMI_SERVICE_PERIODIC_CHAN_STAT_SUPPORT);</span>
 	SVCSTR(WMI_SERVICE_TX_MODE_PUSH_ONLY);
 	SVCSTR(WMI_SERVICE_TX_MODE_PUSH_PULL);
 	SVCSTR(WMI_SERVICE_TX_MODE_DYNAMIC);
<span class="p_chunk">@@ -652,6 +655,8 @@</span> <span class="p_context"> static inline void wmi_10_4_svc_map(const __le32 *in, unsigned long *out,</span>
 	       WMI_SERVICE_PEER_STATS, len);
 	SVCMAP(WMI_10_4_SERVICE_MESH_11S,
 	       WMI_SERVICE_MESH_11S, len);
<span class="p_add">+	SVCMAP(WMI_10_4_SERVICE_PERIODIC_CHAN_STAT_SUPPORT,</span>
<span class="p_add">+	       WMI_SERVICE_PERIODIC_CHAN_STAT_SUPPORT, len);</span>
 	SVCMAP(WMI_10_4_SERVICE_TX_MODE_PUSH_ONLY,
 	       WMI_SERVICE_TX_MODE_PUSH_ONLY, len);
 	SVCMAP(WMI_10_4_SERVICE_TX_MODE_PUSH_PULL,
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_header">index 43f8f7d45ddb..adba3b003f55 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/iwl-nvm-parse.c</span>
<span class="p_chunk">@@ -564,11 +564,16 @@</span> <span class="p_context"> static void iwl_set_hw_address_from_csr(struct iwl_trans *trans,</span>
 	__le32 mac_addr0 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR0_STRAP));
 	__le32 mac_addr1 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR1_STRAP));
 
<span class="p_del">-	/* If OEM did not fuse address - get it from OTP */</span>
<span class="p_del">-	if (!mac_addr0 &amp;&amp; !mac_addr1) {</span>
<span class="p_del">-		mac_addr0 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR0_OTP));</span>
<span class="p_del">-		mac_addr1 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR1_OTP));</span>
<span class="p_del">-	}</span>
<span class="p_add">+	iwl_flip_hw_address(mac_addr0, mac_addr1, data-&gt;hw_addr);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If the OEM fused a valid address, use it instead of the one in the</span>
<span class="p_add">+	 * OTP</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (is_valid_ether_addr(data-&gt;hw_addr))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	mac_addr0 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR0_OTP));</span>
<span class="p_add">+	mac_addr1 = cpu_to_le32(iwl_read32(trans, CSR_MAC_ADDR1_OTP));</span>
 
 	iwl_flip_hw_address(mac_addr0, mac_addr1, data-&gt;hw_addr);
 }
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c</span>
<span class="p_header">index 7e0cdbf8bf74..794c57486e02 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/fw.c</span>
<span class="p_chunk">@@ -1214,9 +1214,12 @@</span> <span class="p_context"> int iwl_mvm_up(struct iwl_mvm *mvm)</span>
 	}
 
 	/* TODO: read the budget from BIOS / Platform NVM */
<span class="p_del">-	if (iwl_mvm_is_ctdp_supported(mvm) &amp;&amp; mvm-&gt;cooling_dev.cur_state &gt; 0)</span>
<span class="p_add">+	if (iwl_mvm_is_ctdp_supported(mvm) &amp;&amp; mvm-&gt;cooling_dev.cur_state &gt; 0) {</span>
 		ret = iwl_mvm_ctdp_command(mvm, CTDP_CMD_OPERATION_START,
 					   mvm-&gt;cooling_dev.cur_state);
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto error;</span>
<span class="p_add">+	}</span>
 #else
 	/* Initialize tx backoffs to the minimal possible */
 	iwl_mvm_tt_tx_backoff(mvm, 0);
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c b/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c</span>
<span class="p_header">index 69c42ce45b8a..d742d27d8de0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/mac-ctxt.c</span>
<span class="p_chunk">@@ -539,6 +539,11 @@</span> <span class="p_context"> void iwl_mvm_mac_ctxt_release(struct iwl_mvm *mvm, struct ieee80211_vif *vif)</span>
 			iwl_mvm_disable_txq(mvm, IWL_MVM_OFFCHANNEL_QUEUE,
 					    IWL_MVM_OFFCHANNEL_QUEUE,
 					    IWL_MAX_TID_COUNT, 0);
<span class="p_add">+		else</span>
<span class="p_add">+			iwl_mvm_disable_txq(mvm,</span>
<span class="p_add">+					    IWL_MVM_DQA_P2P_DEVICE_QUEUE,</span>
<span class="p_add">+					    vif-&gt;hw_queue[0], IWL_MAX_TID_COUNT,</span>
<span class="p_add">+					    0);</span>
 
 		break;
 	case NL80211_IFTYPE_AP:
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c b/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c</span>
<span class="p_header">index df6c32caa5f0..afb7eb60e454 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/rxmq.c</span>
<span class="p_chunk">@@ -598,9 +598,10 @@</span> <span class="p_context"> static bool iwl_mvm_reorder(struct iwl_mvm *mvm,</span>
 
 	mvm_sta = iwl_mvm_sta_from_mac80211(sta);
 
<span class="p_del">-	/* not a data packet */</span>
<span class="p_del">-	if (!ieee80211_is_data_qos(hdr-&gt;frame_control) ||</span>
<span class="p_del">-	    is_multicast_ether_addr(hdr-&gt;addr1))</span>
<span class="p_add">+	/* not a data packet or a bar */</span>
<span class="p_add">+	if (!ieee80211_is_back_req(hdr-&gt;frame_control) &amp;&amp;</span>
<span class="p_add">+	    (!ieee80211_is_data_qos(hdr-&gt;frame_control) ||</span>
<span class="p_add">+	     is_multicast_ether_addr(hdr-&gt;addr1)))</span>
 		return false;
 
 	if (unlikely(!ieee80211_is_data_present(hdr-&gt;frame_control)))
<span class="p_chunk">@@ -624,6 +625,11 @@</span> <span class="p_context"> static bool iwl_mvm_reorder(struct iwl_mvm *mvm,</span>
 
 	spin_lock_bh(&amp;buffer-&gt;lock);
 
<span class="p_add">+	if (ieee80211_is_back_req(hdr-&gt;frame_control)) {</span>
<span class="p_add">+		iwl_mvm_release_frames(mvm, sta, napi, buffer, nssn);</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * If there was a significant jump in the nssn - adjust.
 	 * If the SN is smaller than the NSSN it might need to first go into
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_header">index 3130b9c68a74..e933c12d80aa 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/sta.c</span>
<span class="p_chunk">@@ -576,9 +576,7 @@</span> <span class="p_context"> static int iwl_mvm_scd_queue_redirect(struct iwl_mvm *mvm, int queue, int tid,</span>
 			ret);
 
 	/* Make sure the SCD wrptr is correctly set before reconfiguring */
<span class="p_del">-	iwl_trans_txq_enable(mvm-&gt;trans, queue, iwl_mvm_ac_to_tx_fifo[ac],</span>
<span class="p_del">-			     cmd.sta_id, tid, LINK_QUAL_AGG_FRAME_LIMIT_DEF,</span>
<span class="p_del">-			     ssn, wdg_timeout);</span>
<span class="p_add">+	iwl_trans_txq_enable_cfg(mvm-&gt;trans, queue, ssn, NULL, wdg_timeout);</span>
 
 	/* TODO: Work-around SCD bug when moving back by multiples of 0x40 */
 
<span class="p_chunk">@@ -1270,9 +1268,31 @@</span> <span class="p_context"> int iwl_mvm_rm_sta(struct iwl_mvm *mvm,</span>
 		ret = iwl_mvm_drain_sta(mvm, mvm_sta, false);
 
 		/* If DQA is supported - the queues can be disabled now */
<span class="p_del">-		if (iwl_mvm_is_dqa_supported(mvm))</span>
<span class="p_add">+		if (iwl_mvm_is_dqa_supported(mvm)) {</span>
<span class="p_add">+			u8 reserved_txq = mvm_sta-&gt;reserved_queue;</span>
<span class="p_add">+			enum iwl_mvm_queue_status *status;</span>
<span class="p_add">+</span>
 			iwl_mvm_disable_sta_queues(mvm, vif, mvm_sta);
 
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If no traffic has gone through the reserved TXQ - it</span>
<span class="p_add">+			 * is still marked as IWL_MVM_QUEUE_RESERVED, and</span>
<span class="p_add">+			 * should be manually marked as free again</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			spin_lock_bh(&amp;mvm-&gt;queue_info_lock);</span>
<span class="p_add">+			status = &amp;mvm-&gt;queue_info[reserved_txq].status;</span>
<span class="p_add">+			if (WARN((*status != IWL_MVM_QUEUE_RESERVED) &amp;&amp;</span>
<span class="p_add">+				 (*status != IWL_MVM_QUEUE_FREE),</span>
<span class="p_add">+				 &quot;sta_id %d reserved txq %d status %d&quot;,</span>
<span class="p_add">+				 mvm_sta-&gt;sta_id, reserved_txq, *status)) {</span>
<span class="p_add">+				spin_unlock_bh(&amp;mvm-&gt;queue_info_lock);</span>
<span class="p_add">+				return -EINVAL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			*status = IWL_MVM_QUEUE_FREE;</span>
<span class="p_add">+			spin_unlock_bh(&amp;mvm-&gt;queue_info_lock);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (vif-&gt;type == NL80211_IFTYPE_STATION &amp;&amp;
 		    mvmvif-&gt;ap_sta_id == mvm_sta-&gt;sta_id) {
 			/* if associated - we can&#39;t remove the AP STA now */
<span class="p_header">diff --git a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">index b3a87a31de30..a0c1e3d07db5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_header">+++ b/drivers/net/wireless/intel/iwlwifi/mvm/tx.c</span>
<span class="p_chunk">@@ -903,9 +903,13 @@</span> <span class="p_context"> static int iwl_mvm_tx_mpdu(struct iwl_mvm *mvm, struct sk_buff *skb,</span>
 		tid = IWL_MAX_TID_COUNT;
 	}
 
<span class="p_del">-	if (iwl_mvm_is_dqa_supported(mvm))</span>
<span class="p_add">+	if (iwl_mvm_is_dqa_supported(mvm)) {</span>
 		txq_id = mvmsta-&gt;tid_data[tid].txq_id;
 
<span class="p_add">+		if (ieee80211_is_mgmt(fc))</span>
<span class="p_add">+			tx_cmd-&gt;tid_tspec = IWL_TID_NON_QOS;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Copy MAC header from skb into command buffer */
 	memcpy(tx_cmd-&gt;hdr, hdr, hdrlen);
 
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/join.c b/drivers/net/wireless/marvell/mwifiex/join.c</span>
<span class="p_header">index 1c7b00630b90..b89596c18b41 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/join.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/join.c</span>
<span class="p_chunk">@@ -669,9 +669,8 @@</span> <span class="p_context"> int mwifiex_ret_802_11_associate(struct mwifiex_private *priv,</span>
 	priv-&gt;assoc_rsp_size = min(le16_to_cpu(resp-&gt;size) - S_DS_GEN,
 				   sizeof(priv-&gt;assoc_rsp_buf));
 
<span class="p_del">-	memcpy(priv-&gt;assoc_rsp_buf, &amp;resp-&gt;params, priv-&gt;assoc_rsp_size);</span>
<span class="p_del">-</span>
 	assoc_rsp-&gt;a_id = cpu_to_le16(aid);
<span class="p_add">+	memcpy(priv-&gt;assoc_rsp_buf, &amp;resp-&gt;params, priv-&gt;assoc_rsp_size);</span>
 
 	if (status_code) {
 		priv-&gt;adapter-&gt;dbg.num_cmd_assoc_failure++;
<span class="p_header">diff --git a/drivers/net/wireless/marvell/mwifiex/sta_event.c b/drivers/net/wireless/marvell/mwifiex/sta_event.c</span>
<span class="p_header">index a422f3306d4d..7e394d485f54 100644</span>
<span class="p_header">--- a/drivers/net/wireless/marvell/mwifiex/sta_event.c</span>
<span class="p_header">+++ b/drivers/net/wireless/marvell/mwifiex/sta_event.c</span>
<span class="p_chunk">@@ -708,7 +708,11 @@</span> <span class="p_context"> int mwifiex_process_sta_event(struct mwifiex_private *priv)</span>
 
 	case EVENT_EXT_SCAN_REPORT:
 		mwifiex_dbg(adapter, EVENT, &quot;event: EXT_SCAN Report\n&quot;);
<span class="p_del">-		if (adapter-&gt;ext_scan &amp;&amp; !priv-&gt;scan_aborting)</span>
<span class="p_add">+		/* We intend to skip this event during suspend, but handle</span>
<span class="p_add">+		 * it in interface disabled case</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (adapter-&gt;ext_scan &amp;&amp; (!priv-&gt;scan_aborting ||</span>
<span class="p_add">+					  !netif_running(priv-&gt;netdev)))</span>
 			ret = mwifiex_handle_event_ext_scan_report(priv,
 						adapter-&gt;event_skb-&gt;data);
 
<span class="p_header">diff --git a/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c b/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c</span>
<span class="p_header">index 7cf26c6124d1..6005e14213ca 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ralink/rt2x00/rt2x00usb.c</span>
<span class="p_chunk">@@ -831,8 +831,10 @@</span> <span class="p_context"> int rt2x00usb_probe(struct usb_interface *usb_intf,</span>
 	rt2x00dev-&gt;anchor = devm_kmalloc(&amp;usb_dev-&gt;dev,
 					sizeof(struct usb_anchor),
 					GFP_KERNEL);
<span class="p_del">-	if (!rt2x00dev-&gt;anchor)</span>
<span class="p_add">+	if (!rt2x00dev-&gt;anchor) {</span>
<span class="p_add">+		retval = -ENOMEM;</span>
 		goto exit_free_reg;
<span class="p_add">+	}</span>
 
 	init_usb_anchor(rt2x00dev-&gt;anchor);
 	return 0;
<span class="p_header">diff --git a/drivers/nvdimm/bus.c b/drivers/nvdimm/bus.c</span>
<span class="p_header">index 935866fe5ec2..a8b6949a8778 100644</span>
<span class="p_header">--- a/drivers/nvdimm/bus.c</span>
<span class="p_header">+++ b/drivers/nvdimm/bus.c</span>
<span class="p_chunk">@@ -217,6 +217,8 @@</span> <span class="p_context"> long nvdimm_clear_poison(struct device *dev, phys_addr_t phys,</span>
 		return rc;
 	if (cmd_rc &lt; 0)
 		return cmd_rc;
<span class="p_add">+</span>
<span class="p_add">+	nvdimm_clear_from_poison_list(nvdimm_bus, phys, len);</span>
 	return clear_err.cleared;
 }
 EXPORT_SYMBOL_GPL(nvdimm_clear_poison);
<span class="p_header">diff --git a/drivers/nvdimm/core.c b/drivers/nvdimm/core.c</span>
<span class="p_header">index 4d7bbd2df5c0..7ceba08774b6 100644</span>
<span class="p_header">--- a/drivers/nvdimm/core.c</span>
<span class="p_header">+++ b/drivers/nvdimm/core.c</span>
<span class="p_chunk">@@ -547,11 +547,12 @@</span> <span class="p_context"> void nvdimm_badblocks_populate(struct nd_region *nd_region,</span>
 }
 EXPORT_SYMBOL_GPL(nvdimm_badblocks_populate);
 
<span class="p_del">-static int add_poison(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length)</span>
<span class="p_add">+static int add_poison(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length,</span>
<span class="p_add">+			gfp_t flags)</span>
 {
 	struct nd_poison *pl;
 
<span class="p_del">-	pl = kzalloc(sizeof(*pl), GFP_KERNEL);</span>
<span class="p_add">+	pl = kzalloc(sizeof(*pl), flags);</span>
 	if (!pl)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -567,7 +568,7 @@</span> <span class="p_context"> static int bus_add_poison(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length)</span>
 	struct nd_poison *pl;
 
 	if (list_empty(&amp;nvdimm_bus-&gt;poison_list))
<span class="p_del">-		return add_poison(nvdimm_bus, addr, length);</span>
<span class="p_add">+		return add_poison(nvdimm_bus, addr, length, GFP_KERNEL);</span>
 
 	/*
 	 * There is a chance this is a duplicate, check for those first.
<span class="p_chunk">@@ -587,7 +588,7 @@</span> <span class="p_context"> static int bus_add_poison(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length)</span>
 	 * as any overlapping ranges will get resolved when the list is consumed
 	 * and converted to badblocks
 	 */
<span class="p_del">-	return add_poison(nvdimm_bus, addr, length);</span>
<span class="p_add">+	return add_poison(nvdimm_bus, addr, length, GFP_KERNEL);</span>
 }
 
 int nvdimm_bus_add_poison(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length)
<span class="p_chunk">@@ -602,6 +603,70 @@</span> <span class="p_context"> int nvdimm_bus_add_poison(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length)</span>
 }
 EXPORT_SYMBOL_GPL(nvdimm_bus_add_poison);
 
<span class="p_add">+void nvdimm_clear_from_poison_list(struct nvdimm_bus *nvdimm_bus,</span>
<span class="p_add">+		phys_addr_t start, unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct list_head *poison_list = &amp;nvdimm_bus-&gt;poison_list;</span>
<span class="p_add">+	u64 clr_end = start + len - 1;</span>
<span class="p_add">+	struct nd_poison *pl, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	nvdimm_bus_lock(&amp;nvdimm_bus-&gt;dev);</span>
<span class="p_add">+	WARN_ON_ONCE(list_empty(poison_list));</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * [start, clr_end] is the poison interval being cleared.</span>
<span class="p_add">+	 * [pl-&gt;start, pl_end] is the poison_list entry we&#39;re comparing</span>
<span class="p_add">+	 * the above interval against. The poison list entry may need</span>
<span class="p_add">+	 * to be modified (update either start or length), deleted, or</span>
<span class="p_add">+	 * split into two based on the overlap characteristics</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(pl, next, poison_list, list) {</span>
<span class="p_add">+		u64 pl_end = pl-&gt;start + pl-&gt;length - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Skip intervals with no intersection */</span>
<span class="p_add">+		if (pl_end &lt; start)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if (pl-&gt;start &gt;  clr_end)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		/* Delete completely overlapped poison entries */</span>
<span class="p_add">+		if ((pl-&gt;start &gt;= start) &amp;&amp; (pl_end &lt;= clr_end)) {</span>
<span class="p_add">+			list_del(&amp;pl-&gt;list);</span>
<span class="p_add">+			kfree(pl);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* Adjust start point of partially cleared entries */</span>
<span class="p_add">+		if ((start &lt;= pl-&gt;start) &amp;&amp; (clr_end &gt; pl-&gt;start)) {</span>
<span class="p_add">+			pl-&gt;length -= clr_end - pl-&gt;start + 1;</span>
<span class="p_add">+			pl-&gt;start = clr_end + 1;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* Adjust pl-&gt;length for partial clearing at the tail end */</span>
<span class="p_add">+		if ((pl-&gt;start &lt; start) &amp;&amp; (pl_end &lt;= clr_end)) {</span>
<span class="p_add">+			/* pl-&gt;start remains the same */</span>
<span class="p_add">+			pl-&gt;length = start - pl-&gt;start;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If clearing in the middle of an entry, we split it into</span>
<span class="p_add">+		 * two by modifying the current entry to represent one half of</span>
<span class="p_add">+		 * the split, and adding a new entry for the second half.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((pl-&gt;start &lt; start) &amp;&amp; (pl_end &gt; clr_end)) {</span>
<span class="p_add">+			u64 new_start = clr_end + 1;</span>
<span class="p_add">+			u64 new_len = pl_end - new_start + 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Add new entry covering the right half */</span>
<span class="p_add">+			add_poison(nvdimm_bus, new_start, new_len, GFP_NOIO);</span>
<span class="p_add">+			/* Adjust this entry to cover the left half */</span>
<span class="p_add">+			pl-&gt;length = start - pl-&gt;start;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	nvdimm_bus_unlock(&amp;nvdimm_bus-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(nvdimm_clear_from_poison_list);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_BLK_DEV_INTEGRITY
 int nd_integrity_init(struct gendisk *disk, unsigned long meta_size)
 {
<span class="p_header">diff --git a/drivers/pci/host/pci-aardvark.c b/drivers/pci/host/pci-aardvark.c</span>
<span class="p_header">index ef9893fa3176..4f5e567fd7e0 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-aardvark.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-aardvark.c</span>
<span class="p_chunk">@@ -848,7 +848,7 @@</span> <span class="p_context"> static int advk_pcie_parse_request_of_pci_ranges(struct advk_pcie *pcie)</span>
 	int err, res_valid = 0;
 	struct device *dev = &amp;pcie-&gt;pdev-&gt;dev;
 	struct device_node *np = dev-&gt;of_node;
<span class="p_del">-	struct resource_entry *win;</span>
<span class="p_add">+	struct resource_entry *win, *tmp;</span>
 	resource_size_t iobase;
 
 	INIT_LIST_HEAD(&amp;pcie-&gt;resources);
<span class="p_chunk">@@ -862,7 +862,7 @@</span> <span class="p_context"> static int advk_pcie_parse_request_of_pci_ranges(struct advk_pcie *pcie)</span>
 	if (err)
 		goto out_release_res;
 
<span class="p_del">-	resource_list_for_each_entry(win, &amp;pcie-&gt;resources) {</span>
<span class="p_add">+	resource_list_for_each_entry_safe(win, tmp, &amp;pcie-&gt;resources) {</span>
 		struct resource *res = win-&gt;res;
 
 		switch (resource_type(res)) {
<span class="p_chunk">@@ -874,9 +874,11 @@</span> <span class="p_context"> static int advk_pcie_parse_request_of_pci_ranges(struct advk_pcie *pcie)</span>
 					     lower_32_bits(res-&gt;start),
 					     OB_PCIE_IO);
 			err = pci_remap_iospace(res, iobase);
<span class="p_del">-			if (err)</span>
<span class="p_add">+			if (err) {</span>
 				dev_warn(dev, &quot;error %d: failed to map resource %pR\n&quot;,
 					 err, res);
<span class="p_add">+				resource_list_destroy_entry(win);</span>
<span class="p_add">+			}</span>
 			break;
 		case IORESOURCE_MEM:
 			advk_pcie_set_ob_win(pcie, 0,
<span class="p_header">diff --git a/drivers/pci/host/pci-host-common.c b/drivers/pci/host/pci-host-common.c</span>
<span class="p_header">index 9d9d34e959b6..61eb4d46eb50 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-host-common.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-host-common.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"> static int gen_pci_parse_request_of_pci_ranges(struct device *dev,</span>
 	int err, res_valid = 0;
 	struct device_node *np = dev-&gt;of_node;
 	resource_size_t iobase;
<span class="p_del">-	struct resource_entry *win;</span>
<span class="p_add">+	struct resource_entry *win, *tmp;</span>
 
 	err = of_pci_get_host_bridge_resources(np, 0, 0xff, resources, &amp;iobase);
 	if (err)
<span class="p_chunk">@@ -39,15 +39,17 @@</span> <span class="p_context"> static int gen_pci_parse_request_of_pci_ranges(struct device *dev,</span>
 	if (err)
 		return err;
 
<span class="p_del">-	resource_list_for_each_entry(win, resources) {</span>
<span class="p_add">+	resource_list_for_each_entry_safe(win, tmp, resources) {</span>
 		struct resource *res = win-&gt;res;
 
 		switch (resource_type(res)) {
 		case IORESOURCE_IO:
 			err = pci_remap_iospace(res, iobase);
<span class="p_del">-			if (err)</span>
<span class="p_add">+			if (err) {</span>
 				dev_warn(dev, &quot;error %d: failed to map resource %pR\n&quot;,
 					 err, res);
<span class="p_add">+				resource_list_destroy_entry(win);</span>
<span class="p_add">+			}</span>
 			break;
 		case IORESOURCE_MEM:
 			res_valid |= !(res-&gt;flags &amp; IORESOURCE_PREFETCH);
<span class="p_header">diff --git a/drivers/pci/host/pci-tegra.c b/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">index 84d650d892e7..7ec1e800096a 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-tegra.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-tegra.c</span>
<span class="p_chunk">@@ -621,7 +621,11 @@</span> <span class="p_context"> static int tegra_pcie_setup(int nr, struct pci_sys_data *sys)</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	pci_add_resource_offset(&amp;sys-&gt;resources, &amp;pcie-&gt;pio, sys-&gt;io_offset);</span>
<span class="p_add">+	err = pci_remap_iospace(&amp;pcie-&gt;pio, pcie-&gt;io.start);</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		pci_add_resource_offset(&amp;sys-&gt;resources, &amp;pcie-&gt;pio,</span>
<span class="p_add">+					sys-&gt;io_offset);</span>
<span class="p_add">+</span>
 	pci_add_resource_offset(&amp;sys-&gt;resources, &amp;pcie-&gt;mem, sys-&gt;mem_offset);
 	pci_add_resource_offset(&amp;sys-&gt;resources, &amp;pcie-&gt;prefetch,
 				sys-&gt;mem_offset);
<span class="p_chunk">@@ -631,7 +635,6 @@</span> <span class="p_context"> static int tegra_pcie_setup(int nr, struct pci_sys_data *sys)</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	pci_remap_iospace(&amp;pcie-&gt;pio, pcie-&gt;io.start);</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/drivers/pci/host/pci-versatile.c b/drivers/pci/host/pci-versatile.c</span>
<span class="p_header">index f234405770ab..b7dc07002f13 100644</span>
<span class="p_header">--- a/drivers/pci/host/pci-versatile.c</span>
<span class="p_header">+++ b/drivers/pci/host/pci-versatile.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> static int versatile_pci_parse_request_of_pci_ranges(struct device *dev,</span>
 	int err, mem = 1, res_valid = 0;
 	struct device_node *np = dev-&gt;of_node;
 	resource_size_t iobase;
<span class="p_del">-	struct resource_entry *win;</span>
<span class="p_add">+	struct resource_entry *win, *tmp;</span>
 
 	err = of_pci_get_host_bridge_resources(np, 0, 0xff, res, &amp;iobase);
 	if (err)
<span class="p_chunk">@@ -84,15 +84,17 @@</span> <span class="p_context"> static int versatile_pci_parse_request_of_pci_ranges(struct device *dev,</span>
 	if (err)
 		goto out_release_res;
 
<span class="p_del">-	resource_list_for_each_entry(win, res) {</span>
<span class="p_add">+	resource_list_for_each_entry_safe(win, tmp, res) {</span>
 		struct resource *res = win-&gt;res;
 
 		switch (resource_type(res)) {
 		case IORESOURCE_IO:
 			err = pci_remap_iospace(res, iobase);
<span class="p_del">-			if (err)</span>
<span class="p_add">+			if (err) {</span>
 				dev_warn(dev, &quot;error %d: failed to map resource %pR\n&quot;,
 					 err, res);
<span class="p_add">+				resource_list_destroy_entry(win);</span>
<span class="p_add">+			}</span>
 			break;
 		case IORESOURCE_MEM:
 			res_valid |= !(res-&gt;flags &amp; IORESOURCE_PREFETCH);
<span class="p_header">diff --git a/drivers/pci/host/pcie-designware.c b/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">index 12afce19890b..2a500f270c01 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-designware.c</span>
<span class="p_chunk">@@ -436,7 +436,7 @@</span> <span class="p_context"> int dw_pcie_host_init(struct pcie_port *pp)</span>
 	struct resource *cfg_res;
 	int i, ret;
 	LIST_HEAD(res);
<span class="p_del">-	struct resource_entry *win;</span>
<span class="p_add">+	struct resource_entry *win, *tmp;</span>
 
 	cfg_res = platform_get_resource_byname(pdev, IORESOURCE_MEM, &quot;config&quot;);
 	if (cfg_res) {
<span class="p_chunk">@@ -457,17 +457,20 @@</span> <span class="p_context"> int dw_pcie_host_init(struct pcie_port *pp)</span>
 		goto error;
 
 	/* Get the I/O and memory ranges from DT */
<span class="p_del">-	resource_list_for_each_entry(win, &amp;res) {</span>
<span class="p_add">+	resource_list_for_each_entry_safe(win, tmp, &amp;res) {</span>
 		switch (resource_type(win-&gt;res)) {
 		case IORESOURCE_IO:
<span class="p_del">-			pp-&gt;io = win-&gt;res;</span>
<span class="p_del">-			pp-&gt;io-&gt;name = &quot;I/O&quot;;</span>
<span class="p_del">-			pp-&gt;io_size = resource_size(pp-&gt;io);</span>
<span class="p_del">-			pp-&gt;io_bus_addr = pp-&gt;io-&gt;start - win-&gt;offset;</span>
<span class="p_del">-			ret = pci_remap_iospace(pp-&gt;io, pp-&gt;io_base);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_add">+			ret = pci_remap_iospace(win-&gt;res, pp-&gt;io_base);</span>
<span class="p_add">+			if (ret) {</span>
 				dev_warn(pp-&gt;dev, &quot;error %d: failed to map resource %pR\n&quot;,
<span class="p_del">-					 ret, pp-&gt;io);</span>
<span class="p_add">+					 ret, win-&gt;res);</span>
<span class="p_add">+				resource_list_destroy_entry(win);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				pp-&gt;io = win-&gt;res;</span>
<span class="p_add">+				pp-&gt;io-&gt;name = &quot;I/O&quot;;</span>
<span class="p_add">+				pp-&gt;io_size = resource_size(pp-&gt;io);</span>
<span class="p_add">+				pp-&gt;io_bus_addr = pp-&gt;io-&gt;start - win-&gt;offset;</span>
<span class="p_add">+			}</span>
 			break;
 		case IORESOURCE_MEM:
 			pp-&gt;mem = win-&gt;res;
<span class="p_header">diff --git a/drivers/pci/host/pcie-rcar.c b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">index 65db7a221509..5f7fcc971cae 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-rcar.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-rcar.c</span>
<span class="p_chunk">@@ -945,7 +945,7 @@</span> <span class="p_context"> static int rcar_pcie_parse_request_of_pci_ranges(struct rcar_pcie *pci)</span>
 	struct device *dev = pci-&gt;dev;
 	struct device_node *np = dev-&gt;of_node;
 	resource_size_t iobase;
<span class="p_del">-	struct resource_entry *win;</span>
<span class="p_add">+	struct resource_entry *win, *tmp;</span>
 
 	err = of_pci_get_host_bridge_resources(np, 0, 0xff, &amp;pci-&gt;resources, &amp;iobase);
 	if (err)
<span class="p_chunk">@@ -955,14 +955,17 @@</span> <span class="p_context"> static int rcar_pcie_parse_request_of_pci_ranges(struct rcar_pcie *pci)</span>
 	if (err)
 		goto out_release_res;
 
<span class="p_del">-	resource_list_for_each_entry(win, &amp;pci-&gt;resources) {</span>
<span class="p_add">+	resource_list_for_each_entry_safe(win, tmp, &amp;pci-&gt;resources) {</span>
 		struct resource *res = win-&gt;res;
 
 		if (resource_type(res) == IORESOURCE_IO) {
 			err = pci_remap_iospace(res, iobase);
<span class="p_del">-			if (err)</span>
<span class="p_add">+			if (err) {</span>
 				dev_warn(dev, &quot;error %d: failed to map resource %pR\n&quot;,
 					 err, res);
<span class="p_add">+</span>
<span class="p_add">+				resource_list_destroy_entry(win);</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/pinctrl/qcom/pinctrl-msm.c b/drivers/pinctrl/qcom/pinctrl-msm.c</span>
<span class="p_header">index 51c42d746883..775c88303017 100644</span>
<span class="p_header">--- a/drivers/pinctrl/qcom/pinctrl-msm.c</span>
<span class="p_header">+++ b/drivers/pinctrl/qcom/pinctrl-msm.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> static int msm_pinmux_set_mux(struct pinctrl_dev *pctldev,</span>
 	spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);
 
 	val = readl(pctrl-&gt;regs + g-&gt;ctl_reg);
<span class="p_del">-	val &amp;= mask;</span>
<span class="p_add">+	val &amp;= ~mask;</span>
 	val |= i &lt;&lt; g-&gt;mux_bit;
 	writel(val, pctrl-&gt;regs + g-&gt;ctl_reg);
 
<span class="p_header">diff --git a/drivers/power/bq24257_charger.c b/drivers/power/bq24257_charger.c</span>
<span class="p_header">index 1fea2c7ef97f..6fc31bdc639b 100644</span>
<span class="p_header">--- a/drivers/power/bq24257_charger.c</span>
<span class="p_header">+++ b/drivers/power/bq24257_charger.c</span>
<span class="p_chunk">@@ -1068,6 +1068,12 @@</span> <span class="p_context"> static int bq24257_probe(struct i2c_client *client,</span>
 		return ret;
 	}
 
<span class="p_add">+	ret = bq24257_power_supply_init(bq);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to register power supply\n&quot;);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = devm_request_threaded_irq(dev, client-&gt;irq, NULL,
 					bq24257_irq_handler_thread,
 					IRQF_TRIGGER_FALLING |
<span class="p_chunk">@@ -1078,12 +1084,6 @@</span> <span class="p_context"> static int bq24257_probe(struct i2c_client *client,</span>
 		return ret;
 	}
 
<span class="p_del">-	ret = bq24257_power_supply_init(bq);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(dev, &quot;Failed to register power supply\n&quot;);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = sysfs_create_group(&amp;bq-&gt;charger-&gt;dev.kobj, &amp;bq24257_attr_group);
 	if (ret &lt; 0) {
 		dev_err(dev, &quot;Can&#39;t create sysfs entries\n&quot;);
<span class="p_header">diff --git a/drivers/s390/char/con3270.c b/drivers/s390/char/con3270.c</span>
<span class="p_header">index 6b1577c73fe7..285b4006f44b 100644</span>
<span class="p_header">--- a/drivers/s390/char/con3270.c</span>
<span class="p_header">+++ b/drivers/s390/char/con3270.c</span>
<span class="p_chunk">@@ -124,7 +124,12 @@</span> <span class="p_context"> con3270_create_status(struct con3270 *cp)</span>
 static void
 con3270_update_string(struct con3270 *cp, struct string *s, int nr)
 {
<span class="p_del">-	if (s-&gt;len &gt;= cp-&gt;view.cols - 5)</span>
<span class="p_add">+	if (s-&gt;len &lt; 4) {</span>
<span class="p_add">+		/* This indicates a bug, but printing a warning would</span>
<span class="p_add">+		 * cause a deadlock. */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (s-&gt;string[s-&gt;len - 4] != TO_RA)</span>
 		return;
 	raw3270_buffer_address(cp-&gt;view.dev, s-&gt;string + s-&gt;len - 3,
 			       cp-&gt;view.cols * (nr + 1));
<span class="p_chunk">@@ -460,11 +465,11 @@</span> <span class="p_context"> con3270_cline_end(struct con3270 *cp)</span>
 		cp-&gt;cline-&gt;len + 4 : cp-&gt;view.cols;
 	s = con3270_alloc_string(cp, size);
 	memcpy(s-&gt;string, cp-&gt;cline-&gt;string, cp-&gt;cline-&gt;len);
<span class="p_del">-	if (s-&gt;len &lt; cp-&gt;view.cols - 5) {</span>
<span class="p_add">+	if (cp-&gt;cline-&gt;len &lt; cp-&gt;view.cols - 5) {</span>
 		s-&gt;string[s-&gt;len - 4] = TO_RA;
 		s-&gt;string[s-&gt;len - 1] = 0;
 	} else {
<span class="p_del">-		while (--size &gt; cp-&gt;cline-&gt;len)</span>
<span class="p_add">+		while (--size &gt;= cp-&gt;cline-&gt;len)</span>
 			s-&gt;string[size] = cp-&gt;view.ascebc[&#39; &#39;];
 	}
 	/* Replace cline with allocated line s and reset cline. */
<span class="p_header">diff --git a/drivers/s390/cio/chsc.c b/drivers/s390/cio/chsc.c</span>
<span class="p_header">index 940e725bde1e..11674698b36d 100644</span>
<span class="p_header">--- a/drivers/s390/cio/chsc.c</span>
<span class="p_header">+++ b/drivers/s390/cio/chsc.c</span>
<span class="p_chunk">@@ -95,12 +95,13 @@</span> <span class="p_context"> struct chsc_ssd_area {</span>
 int chsc_get_ssd_info(struct subchannel_id schid, struct chsc_ssd_info *ssd)
 {
 	struct chsc_ssd_area *ssd_area;
<span class="p_add">+	unsigned long flags;</span>
 	int ccode;
 	int ret;
 	int i;
 	int mask;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	ssd_area = chsc_page;
 	ssd_area-&gt;request.length = 0x0010;
<span class="p_chunk">@@ -144,7 +145,7 @@</span> <span class="p_context"> int chsc_get_ssd_info(struct subchannel_id schid, struct chsc_ssd_info *ssd)</span>
 			ssd-&gt;fla[i] = ssd_area-&gt;fla[i];
 	}
 out:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -832,9 +833,10 @@</span> <span class="p_context"> int __chsc_do_secm(struct channel_subsystem *css, int enable)</span>
 		u32 fmt : 4;
 		u32 : 16;
 	} __attribute__ ((packed)) *secm_area;
<span class="p_add">+	unsigned long flags;</span>
 	int ret, ccode;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	secm_area = chsc_page;
 	secm_area-&gt;request.length = 0x0050;
<span class="p_chunk">@@ -864,7 +866,7 @@</span> <span class="p_context"> int __chsc_do_secm(struct channel_subsystem *css, int enable)</span>
 		CIO_CRW_EVENT(2, &quot;chsc: secm failed (rc=%04x)\n&quot;,
 			      secm_area-&gt;response.code);
 out:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -992,6 +994,7 @@</span> <span class="p_context"> chsc_initialize_cmg_chars(struct channel_path *chp, u8 cmcv,</span>
 
 int chsc_get_channel_measurement_chars(struct channel_path *chp)
 {
<span class="p_add">+	unsigned long flags;</span>
 	int ccode, ret;
 
 	struct {
<span class="p_chunk">@@ -1021,7 +1024,7 @@</span> <span class="p_context"> int chsc_get_channel_measurement_chars(struct channel_path *chp)</span>
 	if (!css_chsc_characteristics.scmc || !css_chsc_characteristics.secm)
 		return -EINVAL;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	scmc_area = chsc_page;
 	scmc_area-&gt;request.length = 0x0010;
<span class="p_chunk">@@ -1053,7 +1056,7 @@</span> <span class="p_context"> int chsc_get_channel_measurement_chars(struct channel_path *chp)</span>
 	chsc_initialize_cmg_chars(chp, scmc_area-&gt;cmcv,
 				  (struct cmg_chars *) &amp;scmc_area-&gt;data);
 out:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1134,6 +1137,7 @@</span> <span class="p_context"> struct css_chsc_char css_chsc_characteristics;</span>
 int __init
 chsc_determine_css_characteristics(void)
 {
<span class="p_add">+	unsigned long flags;</span>
 	int result;
 	struct {
 		struct chsc_header request;
<span class="p_chunk">@@ -1146,7 +1150,7 @@</span> <span class="p_context"> chsc_determine_css_characteristics(void)</span>
 		u32 chsc_char[508];
 	} __attribute__ ((packed)) *scsc_area;
 
<span class="p_del">-	spin_lock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;chsc_page_lock, flags);</span>
 	memset(chsc_page, 0, PAGE_SIZE);
 	scsc_area = chsc_page;
 	scsc_area-&gt;request.length = 0x0010;
<span class="p_chunk">@@ -1168,7 +1172,7 @@</span> <span class="p_context"> chsc_determine_css_characteristics(void)</span>
 		CIO_CRW_EVENT(2, &quot;chsc: scsc failed (rc=%04x)\n&quot;,
 			      scsc_area-&gt;response.code);
 exit:
<span class="p_del">-	spin_unlock_irq(&amp;chsc_page_lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;chsc_page_lock, flags);</span>
 	return result;
 }
 
<span class="p_header">diff --git a/drivers/scsi/cxlflash/main.c b/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">index 661bb94e2548..228b99ee0483 100644</span>
<span class="p_header">--- a/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">+++ b/drivers/scsi/cxlflash/main.c</span>
<span class="p_chunk">@@ -823,17 +823,6 @@</span> <span class="p_context"> static void notify_shutdown(struct cxlflash_cfg *cfg, bool wait)</span>
 }
 
 /**
<span class="p_del">- * cxlflash_shutdown() - shutdown handler</span>
<span class="p_del">- * @pdev:	PCI device associated with the host.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void cxlflash_shutdown(struct pci_dev *pdev)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cxlflash_cfg *cfg = pci_get_drvdata(pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	notify_shutdown(cfg, false);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * cxlflash_remove() - PCI entry point to tear down host
  * @pdev:	PCI device associated with the host.
  *
<span class="p_chunk">@@ -844,6 +833,11 @@</span> <span class="p_context"> static void cxlflash_remove(struct pci_dev *pdev)</span>
 	struct cxlflash_cfg *cfg = pci_get_drvdata(pdev);
 	ulong lock_flags;
 
<span class="p_add">+	if (!pci_is_enabled(pdev)) {</span>
<span class="p_add">+		pr_debug(&quot;%s: Device is disabled\n&quot;, __func__);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* If a Task Management Function is active, wait for it to complete
 	 * before continuing with remove.
 	 */
<span class="p_chunk">@@ -2685,7 +2679,7 @@</span> <span class="p_context"> static struct pci_driver cxlflash_driver = {</span>
 	.id_table = cxlflash_pci_table,
 	.probe = cxlflash_probe,
 	.remove = cxlflash_remove,
<span class="p_del">-	.shutdown = cxlflash_shutdown,</span>
<span class="p_add">+	.shutdown = cxlflash_remove,</span>
 	.err_handler = &amp;cxlflash_err_handler,
 };
 
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index cd91a684c945..4cb79902e7a8 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -4701,7 +4701,7 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 			    le16_to_cpu(mpi_reply-&gt;DevHandle));
 		mpt3sas_trigger_scsi(ioc, data.skey, data.asc, data.ascq);
 
<span class="p_del">-		if (!(ioc-&gt;logging_level &amp; MPT_DEBUG_REPLY) &amp;&amp;</span>
<span class="p_add">+		if ((ioc-&gt;logging_level &amp; MPT_DEBUG_REPLY) &amp;&amp;</span>
 		     ((scmd-&gt;sense_buffer[2] == UNIT_ATTENTION) ||
 		     (scmd-&gt;sense_buffer[2] == MEDIUM_ERROR) ||
 		     (scmd-&gt;sense_buffer[2] == HARDWARE_ERROR)))
<span class="p_header">diff --git a/drivers/spi/spi-fsl-dspi.c b/drivers/spi/spi-fsl-dspi.c</span>
<span class="p_header">index 9e9dadb52b3d..eec5e3f6e06b 100644</span>
<span class="p_header">--- a/drivers/spi/spi-fsl-dspi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-fsl-dspi.c</span>
<span class="p_chunk">@@ -760,7 +760,6 @@</span> <span class="p_context"> static int dspi_remove(struct platform_device *pdev)</span>
 	/* Disconnect from the SPI framework */
 	clk_disable_unprepare(dspi-&gt;clk);
 	spi_unregister_master(dspi-&gt;master);
<span class="p_del">-	spi_master_put(dspi-&gt;master);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/staging/android/ion/Kconfig b/drivers/staging/android/ion/Kconfig</span>
<span class="p_header">index 19c1572f1525..800245eac390 100644</span>
<span class="p_header">--- a/drivers/staging/android/ion/Kconfig</span>
<span class="p_header">+++ b/drivers/staging/android/ion/Kconfig</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"> config ION_TEGRA</span>
 config ION_HISI
 	tristate &quot;Ion for Hisilicon&quot;
 	depends on ARCH_HISI &amp;&amp; ION
<span class="p_add">+	select ION_OF</span>
 	help
 	  Choose this option if you wish to use ion on Hisilicon Platform.
 
<span class="p_header">diff --git a/drivers/staging/ks7010/ks_hostif.c b/drivers/staging/ks7010/ks_hostif.c</span>
<span class="p_header">index a8822fe2bd60..f4cee811cabd 100644</span>
<span class="p_header">--- a/drivers/staging/ks7010/ks_hostif.c</span>
<span class="p_header">+++ b/drivers/staging/ks7010/ks_hostif.c</span>
<span class="p_chunk">@@ -69,16 +69,20 @@</span> <span class="p_context"> inline u32 get_DWORD(struct ks_wlan_private *priv)</span>
 	return data;
 }
 
<span class="p_del">-void ks_wlan_hw_wakeup_task(struct work_struct *work)</span>
<span class="p_add">+static void ks_wlan_hw_wakeup_task(struct work_struct *work)</span>
 {
 	struct ks_wlan_private *priv =
 	    container_of(work, struct ks_wlan_private, ks_wlan_wakeup_task);
 	int ps_status = atomic_read(&amp;priv-&gt;psstatus.status);
<span class="p_add">+	long time_left;</span>
 
 	if (ps_status == PS_SNOOZE) {
 		ks_wlan_hw_wakeup_request(priv);
<span class="p_del">-		if (!wait_for_completion_interruptible_timeout(&amp;priv-&gt;psstatus.wakeup_wait, HZ / 50)) {	/* 20ms timeout */</span>
<span class="p_del">-			DPRINTK(1, &quot;wake up timeout !!!\n&quot;);</span>
<span class="p_add">+		time_left = wait_for_completion_interruptible_timeout(</span>
<span class="p_add">+				&amp;priv-&gt;psstatus.wakeup_wait,</span>
<span class="p_add">+				msecs_to_jiffies(20));</span>
<span class="p_add">+		if (time_left &lt;= 0) {</span>
<span class="p_add">+			DPRINTK(1, &quot;wake up timeout or interrupted !!!\n&quot;);</span>
 			schedule_work(&amp;priv-&gt;ks_wlan_wakeup_task);
 			return;
 		}
<span class="p_chunk">@@ -1505,7 +1509,7 @@</span> <span class="p_context"> void hostif_infrastructure_set_request(struct ks_wlan_private *priv)</span>
 	ks_wlan_hw_tx(priv, pp, hif_align_size(sizeof(*pp)), NULL, NULL, NULL);
 }
 
<span class="p_del">-void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)</span>
<span class="p_add">+static void hostif_infrastructure_set2_request(struct ks_wlan_private *priv)</span>
 {
 	struct hostif_infrastructure_set2_request_t *pp;
 	uint16_t capability;
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_cmd.c b/drivers/staging/rtl8188eu/core/rtw_cmd.c</span>
<span class="p_header">index 77485235c615..32d3a9c07aa3 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_cmd.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_cmd.c</span>
<span class="p_chunk">@@ -670,13 +670,13 @@</span> <span class="p_context"> u8 rtw_addbareq_cmd(struct adapter *padapter, u8 tid, u8 *addr)</span>
 	u8	res = _SUCCESS;
 
 
<span class="p_del">-	ph2c = kzalloc(sizeof(struct cmd_obj), GFP_KERNEL);</span>
<span class="p_add">+	ph2c = kzalloc(sizeof(struct cmd_obj), GFP_ATOMIC);</span>
 	if (!ph2c) {
 		res = _FAIL;
 		goto exit;
 	}
 
<span class="p_del">-	paddbareq_parm = kzalloc(sizeof(struct addBaReq_parm), GFP_KERNEL);</span>
<span class="p_add">+	paddbareq_parm = kzalloc(sizeof(struct addBaReq_parm), GFP_ATOMIC);</span>
 	if (!paddbareq_parm) {
 		kfree(ph2c);
 		res = _FAIL;
<span class="p_header">diff --git a/drivers/staging/sm750fb/ddk750_mode.c b/drivers/staging/sm750fb/ddk750_mode.c</span>
<span class="p_header">index ccb4e067661a..e29d4bd5dcec 100644</span>
<span class="p_header">--- a/drivers/staging/sm750fb/ddk750_mode.c</span>
<span class="p_header">+++ b/drivers/staging/sm750fb/ddk750_mode.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static unsigned long displayControlAdjust_SM750LE(mode_parameter_t *pModeParam,</span>
 	dispControl |= (CRT_DISPLAY_CTRL_CRTSELECT | CRT_DISPLAY_CTRL_RGBBIT);
 
 	/* Set bit 14 of display controller */
<span class="p_del">-	dispControl = DISPLAY_CTRL_CLOCK_PHASE;</span>
<span class="p_add">+	dispControl |= DISPLAY_CTRL_CLOCK_PHASE;</span>
 
 	POKE32(CRT_DISPLAY_CTRL, dispControl);
 
<span class="p_header">diff --git a/drivers/uio/uio_dmem_genirq.c b/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_header">index 915facbf552e..e1134a4d97f3 100644</span>
<span class="p_header">--- a/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_header">+++ b/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static int uio_dmem_genirq_probe(struct platform_device *pdev)</span>
 		++uiomem;
 	}
 
<span class="p_del">-	priv-&gt;dmem_region_start = i;</span>
<span class="p_add">+	priv-&gt;dmem_region_start = uiomem - &amp;uioinfo-&gt;mem[0];</span>
 	priv-&gt;num_dmem_regions = pdata-&gt;num_dynamic_regions;
 
 	for (i = 0; i &lt; pdata-&gt;num_dynamic_regions; ++i) {
<span class="p_header">diff --git a/fs/9p/acl.c b/fs/9p/acl.c</span>
<span class="p_header">index 5b6a1743ea17..b3c2cc79c20d 100644</span>
<span class="p_header">--- a/fs/9p/acl.c</span>
<span class="p_header">+++ b/fs/9p/acl.c</span>
<span class="p_chunk">@@ -276,32 +276,26 @@</span> <span class="p_context"> static int v9fs_xattr_set_acl(const struct xattr_handler *handler,</span>
 	switch (handler-&gt;flags) {
 	case ACL_TYPE_ACCESS:
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			retval = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (retval &lt; 0)</span>
<span class="p_add">+			struct iattr iattr;</span>
<span class="p_add">+</span>
<span class="p_add">+			retval = posix_acl_update_mode(inode, &amp;iattr.ia_mode, &amp;acl);</span>
<span class="p_add">+			if (retval)</span>
 				goto err_out;
<span class="p_del">-			else {</span>
<span class="p_del">-				struct iattr iattr;</span>
<span class="p_del">-				if (retval == 0) {</span>
<span class="p_del">-					/*</span>
<span class="p_del">-					 * ACL can be represented</span>
<span class="p_del">-					 * by the mode bits. So don&#39;t</span>
<span class="p_del">-					 * update ACL.</span>
<span class="p_del">-					 */</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-					value = NULL;</span>
<span class="p_del">-					size = 0;</span>
<span class="p_del">-				}</span>
<span class="p_del">-				/* Updte the mode bits */</span>
<span class="p_del">-				iattr.ia_mode = ((mode &amp; S_IALLUGO) |</span>
<span class="p_del">-						 (inode-&gt;i_mode &amp; ~S_IALLUGO));</span>
<span class="p_del">-				iattr.ia_valid = ATTR_MODE;</span>
<span class="p_del">-				/* FIXME should we update ctime ?</span>
<span class="p_del">-				 * What is the following setxattr update the</span>
<span class="p_del">-				 * mode ?</span>
<span class="p_add">+			if (!acl) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * ACL can be represented</span>
<span class="p_add">+				 * by the mode bits. So don&#39;t</span>
<span class="p_add">+				 * update ACL.</span>
 				 */
<span class="p_del">-				v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
<span class="p_add">+				value = NULL;</span>
<span class="p_add">+				size = 0;</span>
 			}
<span class="p_add">+			iattr.ia_valid = ATTR_MODE;</span>
<span class="p_add">+			/* FIXME should we update ctime ?</span>
<span class="p_add">+			 * What is the following setxattr update the</span>
<span class="p_add">+			 * mode ?</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			v9fs_vfs_setattr_dotl(dentry, &amp;iattr);</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c</span>
<span class="p_header">index 53bb7af4e5f0..247b8dfaf6e5 100644</span>
<span class="p_header">--- a/fs/btrfs/acl.c</span>
<span class="p_header">+++ b/fs/btrfs/acl.c</span>
<span class="p_chunk">@@ -79,11 +79,9 @@</span> <span class="p_context"> static int __btrfs_set_acl(struct btrfs_trans_handle *trans,</span>
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				return ret;
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		ret = 0;
 		break;
<span class="p_header">diff --git a/fs/ceph/acl.c b/fs/ceph/acl.c</span>
<span class="p_header">index 4f67227f69a5..d0b6b342dff9 100644</span>
<span class="p_header">--- a/fs/ceph/acl.c</span>
<span class="p_header">+++ b/fs/ceph/acl.c</span>
<span class="p_chunk">@@ -95,11 +95,9 @@</span> <span class="p_context"> int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;new_mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;new_mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
 				goto out;
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/ext2/acl.c b/fs/ext2/acl.c</span>
<span class="p_header">index 42f1d1814083..e725aa0890e0 100644</span>
<span class="p_header">--- a/fs/ext2/acl.c</span>
<span class="p_header">+++ b/fs/ext2/acl.c</span>
<span class="p_chunk">@@ -190,15 +190,11 @@</span> <span class="p_context"> ext2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 		case ACL_TYPE_ACCESS:
 			name_index = EXT2_XATTR_INDEX_POSIX_ACL_ACCESS;
 			if (acl) {
<span class="p_del">-				error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-				if (error &lt; 0)</span>
<span class="p_add">+				error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+				if (error)</span>
 					return error;
<span class="p_del">-				else {</span>
<span class="p_del">-					inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_del">-					mark_inode_dirty(inode);</span>
<span class="p_del">-					if (error == 0)</span>
<span class="p_del">-						acl = NULL;</span>
<span class="p_del">-				}</span>
<span class="p_add">+				inode-&gt;i_ctime = CURRENT_TIME_SEC;</span>
<span class="p_add">+				mark_inode_dirty(inode);</span>
 			}
 			break;
 
<span class="p_header">diff --git a/fs/ext4/acl.c b/fs/ext4/acl.c</span>
<span class="p_header">index c6601a476c02..dfa519979038 100644</span>
<span class="p_header">--- a/fs/ext4/acl.c</span>
<span class="p_header">+++ b/fs/ext4/acl.c</span>
<span class="p_chunk">@@ -193,15 +193,11 @@</span> <span class="p_context"> __ext4_set_acl(handle_t *handle, struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = EXT4_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_del">-				ext4_mark_inode_dirty(handle, inode);</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
<span class="p_add">+			inode-&gt;i_ctime = ext4_current_time(inode);</span>
<span class="p_add">+			ext4_mark_inode_dirty(handle, inode);</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/f2fs/acl.c b/fs/f2fs/acl.c</span>
<span class="p_header">index 4dcc9e28dc5c..31344247ce89 100644</span>
<span class="p_header">--- a/fs/f2fs/acl.c</span>
<span class="p_header">+++ b/fs/f2fs/acl.c</span>
<span class="p_chunk">@@ -210,12 +210,10 @@</span> <span class="p_context"> static int __f2fs_set_acl(struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = F2FS_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
 			set_acl_inode(inode, inode-&gt;i_mode);
<span class="p_del">-			if (error == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 
<span class="p_header">diff --git a/fs/gfs2/acl.c b/fs/gfs2/acl.c</span>
<span class="p_header">index 363ba9e9d8d0..2524807ee070 100644</span>
<span class="p_header">--- a/fs/gfs2/acl.c</span>
<span class="p_header">+++ b/fs/gfs2/acl.c</span>
<span class="p_chunk">@@ -92,17 +92,11 @@</span> <span class="p_context"> int __gfs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	if (type == ACL_TYPE_ACCESS) {
 		umode_t mode = inode-&gt;i_mode;
 
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
 			return error;
<span class="p_del">-</span>
<span class="p_del">-		if (error == 0)</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mode != inode-&gt;i_mode) {</span>
<span class="p_del">-			inode-&gt;i_mode = mode;</span>
<span class="p_add">+		if (mode != inode-&gt;i_mode)</span>
 			mark_inode_dirty(inode);
<span class="p_del">-		}</span>
 	}
 
 	if (acl) {
<span class="p_header">diff --git a/fs/hfsplus/posix_acl.c b/fs/hfsplus/posix_acl.c</span>
<span class="p_header">index ab7ea2506b4d..9b92058a1240 100644</span>
<span class="p_header">--- a/fs/hfsplus/posix_acl.c</span>
<span class="p_header">+++ b/fs/hfsplus/posix_acl.c</span>
<span class="p_chunk">@@ -65,8 +65,8 @@</span> <span class="p_context"> int hfsplus_set_posix_acl(struct inode *inode, struct posix_acl *acl,</span>
 	case ACL_TYPE_ACCESS:
 		xattr_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			err = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (err &lt; 0)</span>
<span class="p_add">+			err = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (err)</span>
 				return err;
 		}
 		err = 0;
<span class="p_header">diff --git a/fs/jffs2/acl.c b/fs/jffs2/acl.c</span>
<span class="p_header">index bc2693d56298..2a0f2a1044c1 100644</span>
<span class="p_header">--- a/fs/jffs2/acl.c</span>
<span class="p_header">+++ b/fs/jffs2/acl.c</span>
<span class="p_chunk">@@ -233,9 +233,10 @@</span> <span class="p_context"> int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	case ACL_TYPE_ACCESS:
 		xprefix = JFFS2_XPREFIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (rc &lt; 0)</span>
<span class="p_add">+			umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (rc)</span>
 				return rc;
 			if (inode-&gt;i_mode != mode) {
 				struct iattr attr;
<span class="p_chunk">@@ -247,8 +248,6 @@</span> <span class="p_context"> int jffs2_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 				if (rc &lt; 0)
 					return rc;
 			}
<span class="p_del">-			if (rc == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/jfs/acl.c b/fs/jfs/acl.c</span>
<span class="p_header">index 21fa92ba2c19..3a1e1554a4e3 100644</span>
<span class="p_header">--- a/fs/jfs/acl.c</span>
<span class="p_header">+++ b/fs/jfs/acl.c</span>
<span class="p_chunk">@@ -78,13 +78,11 @@</span> <span class="p_context"> static int __jfs_set_acl(tid_t tid, struct inode *inode, int type,</span>
 	case ACL_TYPE_ACCESS:
 		ea_name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			rc = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (rc &lt; 0)</span>
<span class="p_add">+			rc = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (rc)</span>
 				return rc;
 			inode-&gt;i_ctime = CURRENT_TIME;
 			mark_inode_dirty(inode);
<span class="p_del">-			if (rc == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/ocfs2/acl.c b/fs/ocfs2/acl.c</span>
<span class="p_header">index 2162434728c0..164307b99405 100644</span>
<span class="p_header">--- a/fs/ocfs2/acl.c</span>
<span class="p_header">+++ b/fs/ocfs2/acl.c</span>
<span class="p_chunk">@@ -241,13 +241,11 @@</span> <span class="p_context"> int ocfs2_set_acl(handle_t *handle,</span>
 	case ACL_TYPE_ACCESS:
 		name_index = OCFS2_XATTR_INDEX_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			ret = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_del">-				return ret;</span>
<span class="p_add">+			umode_t mode;</span>
 
<span class="p_del">-			if (ret == 0)</span>
<span class="p_del">-				acl = NULL;</span>
<span class="p_add">+			ret = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 
 			ret = ocfs2_acl_set_mode(inode, di_bh,
 						 handle, mode);
<span class="p_header">diff --git a/fs/orangefs/acl.c b/fs/orangefs/acl.c</span>
<span class="p_header">index 28f2195cd798..7a3754488312 100644</span>
<span class="p_header">--- a/fs/orangefs/acl.c</span>
<span class="p_header">+++ b/fs/orangefs/acl.c</span>
<span class="p_chunk">@@ -73,14 +73,11 @@</span> <span class="p_context"> int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * can we represent this with the traditional file</span>
<span class="p_del">-			 * mode permission bits?</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-			if (error &lt; 0) {</span>
<span class="p_del">-				gossip_err(&quot;%s: posix_acl_equiv_mode err: %d\n&quot;,</span>
<span class="p_add">+			umode_t mode;</span>
<span class="p_add">+</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+			if (error) {</span>
<span class="p_add">+				gossip_err(&quot;%s: posix_acl_update_mode err: %d\n&quot;,</span>
 					   __func__,
 					   error);
 				return error;
<span class="p_chunk">@@ -90,8 +87,6 @@</span> <span class="p_context"> int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 				SetModeFlag(orangefs_inode);
 			inode-&gt;i_mode = mode;
 			mark_inode_dirty_sync(inode);
<span class="p_del">-			if (error == 0)</span>
<span class="p_del">-				acl = NULL;</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/posix_acl.c b/fs/posix_acl.c</span>
<span class="p_header">index 59d47ab0791a..bfc3ec388322 100644</span>
<span class="p_header">--- a/fs/posix_acl.c</span>
<span class="p_header">+++ b/fs/posix_acl.c</span>
<span class="p_chunk">@@ -626,6 +626,37 @@</span> <span class="p_context"> no_mem:</span>
 }
 EXPORT_SYMBOL_GPL(posix_acl_create);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * posix_acl_update_mode  -  update mode in set_acl</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Update the file mode when setting an ACL: compute the new file permission</span>
<span class="p_add">+ * bits based on the ACL.  In addition, if the ACL is equivalent to the new</span>
<span class="p_add">+ * file mode, set *acl to NULL to indicate that no ACL should be set.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * As with chmod, clear the setgit bit if the caller is not in the owning group</span>
<span class="p_add">+ * or capable of CAP_FSETID (see inode_change_ok).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called from set_acl inode operations.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int posix_acl_update_mode(struct inode *inode, umode_t *mode_p,</span>
<span class="p_add">+			  struct posix_acl **acl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	umode_t mode = inode-&gt;i_mode;</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = posix_acl_equiv_mode(*acl, &amp;mode);</span>
<span class="p_add">+	if (error &lt; 0)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	if (error == 0)</span>
<span class="p_add">+		*acl = NULL;</span>
<span class="p_add">+	if (!in_group_p(inode-&gt;i_gid) &amp;&amp;</span>
<span class="p_add">+	    !capable_wrt_inode_uidgid(inode, CAP_FSETID))</span>
<span class="p_add">+		mode &amp;= ~S_ISGID;</span>
<span class="p_add">+	*mode_p = mode;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(posix_acl_update_mode);</span>
<span class="p_add">+</span>
 /*
  * Fix up the uids and gids in posix acl extended attributes in place.
  */
<span class="p_header">diff --git a/fs/reiserfs/xattr_acl.c b/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">index dbed42f755e0..27376681c640 100644</span>
<span class="p_header">--- a/fs/reiserfs/xattr_acl.c</span>
<span class="p_header">+++ b/fs/reiserfs/xattr_acl.c</span>
<span class="p_chunk">@@ -242,13 +242,9 @@</span> <span class="p_context"> __reiserfs_set_acl(struct reiserfs_transaction_handle *th, struct inode *inode,</span>
 	case ACL_TYPE_ACCESS:
 		name = XATTR_NAME_POSIX_ACL_ACCESS;
 		if (acl) {
<span class="p_del">-			error = posix_acl_equiv_mode(acl, &amp;inode-&gt;i_mode);</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_add">+			error = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);</span>
<span class="p_add">+			if (error)</span>
 				return error;
<span class="p_del">-			else {</span>
<span class="p_del">-				if (error == 0)</span>
<span class="p_del">-					acl = NULL;</span>
<span class="p_del">-			}</span>
 		}
 		break;
 	case ACL_TYPE_DEFAULT:
<span class="p_header">diff --git a/fs/xfs/xfs_acl.c b/fs/xfs/xfs_acl.c</span>
<span class="p_header">index b6e527b8eccb..8a0dec89ca56 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_acl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_acl.c</span>
<span class="p_chunk">@@ -257,16 +257,11 @@</span> <span class="p_context"> xfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)</span>
 		return error;
 
 	if (type == ACL_TYPE_ACCESS) {
<span class="p_del">-		umode_t mode = inode-&gt;i_mode;</span>
<span class="p_del">-		error = posix_acl_equiv_mode(acl, &amp;mode);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (error &lt;= 0) {</span>
<span class="p_del">-			acl = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-			if (error &lt; 0)</span>
<span class="p_del">-				return error;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		umode_t mode;</span>
 
<span class="p_add">+		error = posix_acl_update_mode(inode, &amp;mode, &amp;acl);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
 		error = xfs_set_mode(inode, mode);
 		if (error)
 			return error;
<span class="p_header">diff --git a/include/drm/drmP.h b/include/drm/drmP.h</span>
<span class="p_header">index d3778652e462..988903a59007 100644</span>
<span class="p_header">--- a/include/drm/drmP.h</span>
<span class="p_header">+++ b/include/drm/drmP.h</span>
<span class="p_chunk">@@ -938,7 +938,8 @@</span> <span class="p_context"> static inline int drm_debugfs_remove_files(const struct drm_info_list *files,</span>
 #endif
 
 extern struct dma_buf *drm_gem_prime_export(struct drm_device *dev,
<span class="p_del">-		struct drm_gem_object *obj, int flags);</span>
<span class="p_add">+					    struct drm_gem_object *obj,</span>
<span class="p_add">+					    int flags);</span>
 extern int drm_gem_prime_handle_to_fd(struct drm_device *dev,
 		struct drm_file *file_priv, uint32_t handle, uint32_t flags,
 		int *prime_fd);
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index c26d4638f665..fe99e6f956e2 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -450,8 +450,8 @@</span> <span class="p_context"> static inline pgoff_t basepage_index(struct page *page)</span>
 	return __basepage_index(page);
 }
 
<span class="p_del">-extern void dissolve_free_huge_pages(unsigned long start_pfn,</span>
<span class="p_del">-				     unsigned long end_pfn);</span>
<span class="p_add">+extern int dissolve_free_huge_pages(unsigned long start_pfn,</span>
<span class="p_add">+				    unsigned long end_pfn);</span>
 static inline bool hugepage_migration_supported(struct hstate *h)
 {
 #ifdef CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION
<span class="p_chunk">@@ -518,7 +518,7 @@</span> <span class="p_context"> static inline pgoff_t basepage_index(struct page *page)</span>
 {
 	return page-&gt;index;
 }
<span class="p_del">-#define dissolve_free_huge_pages(s, e)	do {} while (0)</span>
<span class="p_add">+#define dissolve_free_huge_pages(s, e)	0</span>
 #define hugepage_migration_supported(h)	false
 
 static inline spinlock_t *huge_pte_lockptr(struct hstate *h,
<span class="p_header">diff --git a/include/linux/libnvdimm.h b/include/linux/libnvdimm.h</span>
<span class="p_header">index b519e137b9b7..bbfce62a0bd7 100644</span>
<span class="p_header">--- a/include/linux/libnvdimm.h</span>
<span class="p_header">+++ b/include/linux/libnvdimm.h</span>
<span class="p_chunk">@@ -129,6 +129,8 @@</span> <span class="p_context"> static inline struct nd_blk_region_desc *to_blk_region_desc(</span>
 }
 
 int nvdimm_bus_add_poison(struct nvdimm_bus *nvdimm_bus, u64 addr, u64 length);
<span class="p_add">+void nvdimm_clear_from_poison_list(struct nvdimm_bus *nvdimm_bus,</span>
<span class="p_add">+		phys_addr_t start, unsigned int len);</span>
 struct nvdimm_bus *nvdimm_bus_register(struct device *parent,
 		struct nvdimm_bus_descriptor *nfit_desc);
 void nvdimm_bus_unregister(struct nvdimm_bus *nvdimm_bus);
<span class="p_header">diff --git a/include/linux/posix_acl.h b/include/linux/posix_acl.h</span>
<span class="p_header">index d5d3d741f028..bf1046d0397b 100644</span>
<span class="p_header">--- a/include/linux/posix_acl.h</span>
<span class="p_header">+++ b/include/linux/posix_acl.h</span>
<span class="p_chunk">@@ -93,6 +93,7 @@</span> <span class="p_context"> extern int set_posix_acl(struct inode *, int, struct posix_acl *);</span>
 extern int posix_acl_chmod(struct inode *, umode_t);
 extern int posix_acl_create(struct inode *, umode_t *, struct posix_acl **,
 		struct posix_acl **);
<span class="p_add">+extern int posix_acl_update_mode(struct inode *, umode_t *, struct posix_acl **);</span>
 
 extern int simple_set_acl(struct inode *, struct posix_acl *, int);
 extern int simple_acl_create(struct inode *, struct inode *);
<span class="p_header">diff --git a/kernel/irq/generic-chip.c b/kernel/irq/generic-chip.c</span>
<span class="p_header">index abd286afbd27..a4775f3451b9 100644</span>
<span class="p_header">--- a/kernel/irq/generic-chip.c</span>
<span class="p_header">+++ b/kernel/irq/generic-chip.c</span>
<span class="p_chunk">@@ -411,8 +411,29 @@</span> <span class="p_context"> int irq_map_generic_chip(struct irq_domain *d, unsigned int virq,</span>
 }
 EXPORT_SYMBOL_GPL(irq_map_generic_chip);
 
<span class="p_add">+static void irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct irq_data *data = irq_domain_get_irq_data(d, virq);</span>
<span class="p_add">+	struct irq_domain_chip_generic *dgc = d-&gt;gc;</span>
<span class="p_add">+	unsigned int hw_irq = data-&gt;hwirq;</span>
<span class="p_add">+	struct irq_chip_generic *gc;</span>
<span class="p_add">+	int irq_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	gc = irq_get_domain_generic_chip(d, hw_irq);</span>
<span class="p_add">+	if (!gc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_idx = hw_irq % dgc-&gt;irqs_per_chip;</span>
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(irq_idx, &amp;gc-&gt;installed);</span>
<span class="p_add">+	irq_domain_set_info(d, virq, hw_irq, &amp;no_irq_chip, NULL, NULL, NULL,</span>
<span class="p_add">+			    NULL);</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct irq_domain_ops irq_generic_chip_ops = {
 	.map	= irq_map_generic_chip,
<span class="p_add">+	.unmap  = irq_unmap_generic_chip,</span>
 	.xlate	= irq_domain_xlate_onetwocell,
 };
 EXPORT_SYMBOL_GPL(irq_generic_chip_ops);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 603bdd01ec2c..770d83eb3f48 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1437,22 +1437,32 @@</span> <span class="p_context"> static int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,</span>
 
 /*
  * Dissolve a given free hugepage into free buddy pages. This function does
<span class="p_del">- * nothing for in-use (including surplus) hugepages.</span>
<span class="p_add">+ * nothing for in-use (including surplus) hugepages. Returns -EBUSY if the</span>
<span class="p_add">+ * number of free hugepages would be reduced below the number of reserved</span>
<span class="p_add">+ * hugepages.</span>
  */
<span class="p_del">-static void dissolve_free_huge_page(struct page *page)</span>
<span class="p_add">+static int dissolve_free_huge_page(struct page *page)</span>
 {
<span class="p_add">+	int rc = 0;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;hugetlb_lock);
 	if (PageHuge(page) &amp;&amp; !page_count(page)) {
 		struct page *head = compound_head(page);
 		struct hstate *h = page_hstate(head);
 		int nid = page_to_nid(head);
<span class="p_add">+		if (h-&gt;free_huge_pages - h-&gt;resv_huge_pages == 0) {</span>
<span class="p_add">+			rc = -EBUSY;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		list_del(&amp;head-&gt;lru);
 		h-&gt;free_huge_pages--;
 		h-&gt;free_huge_pages_node[nid]--;
 		h-&gt;max_huge_pages--;
 		update_and_free_page(h, head);
 	}
<span class="p_add">+out:</span>
 	spin_unlock(&amp;hugetlb_lock);
<span class="p_add">+	return rc;</span>
 }
 
 /*
<span class="p_chunk">@@ -1460,16 +1470,28 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
  * make specified memory blocks removable from the system.
  * Note that this will dissolve a free gigantic hugepage completely, if any
  * part of it lies within the given range.
<span class="p_add">+ * Also note that if dissolve_free_huge_page() returns with an error, all</span>
<span class="p_add">+ * free hugepages that were dissolved before that error are lost.</span>
  */
<span class="p_del">-void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)</span>
<span class="p_add">+int dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)</span>
 {
 	unsigned long pfn;
<span class="p_add">+	struct page *page;</span>
<span class="p_add">+	int rc = 0;</span>
 
 	if (!hugepages_supported())
<span class="p_del">-		return;</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order) {</span>
<span class="p_add">+		page = pfn_to_page(pfn);</span>
<span class="p_add">+		if (PageHuge(page) &amp;&amp; !page_count(page)) {</span>
<span class="p_add">+			rc = dissolve_free_huge_page(page);</span>
<span class="p_add">+			if (rc)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)</span>
<span class="p_del">-		dissolve_free_huge_page(pfn_to_page(pfn));</span>
<span class="p_add">+	return rc;</span>
 }
 
 /*
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 9d29ba0f7192..962927309b6e 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -1945,7 +1945,9 @@</span> <span class="p_context"> repeat:</span>
 	 * dissolve free hugepages in the memory block before doing offlining
 	 * actually in order to make hugetlbfs&#39;s object counting consistent.
 	 */
<span class="p_del">-	dissolve_free_huge_pages(start_pfn, end_pfn);</span>
<span class="p_add">+	ret = dissolve_free_huge_pages(start_pfn, end_pfn);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto failed_removal;</span>
 	/* check again */
 	offlined_pages = check_pages_isolated(start_pfn, end_pfn);
 	if (offlined_pages &lt; 0) {
<span class="p_header">diff --git a/sound/soc/intel/boards/bxt_da7219_max98357a.c b/sound/soc/intel/boards/bxt_da7219_max98357a.c</span>
<span class="p_header">index 3774b117d365..49b65d481949 100644</span>
<span class="p_header">--- a/sound/soc/intel/boards/bxt_da7219_max98357a.c</span>
<span class="p_header">+++ b/sound/soc/intel/boards/bxt_da7219_max98357a.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> static struct snd_soc_ops broxton_da7219_ops = {</span>
 /* broxton digital audio interface glue - connects codec &lt;--&gt; CPU */
 static struct snd_soc_dai_link broxton_dais[] = {
 	/* Front End DAI links */
<span class="p_del">-	[BXT_DPCM_AUDIO_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_PB] =</span>
 	{
 		.name = &quot;Bxt Audio Port&quot;,
 		.stream_name = &quot;Audio&quot;,
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_dais[] = {</span>
 		.dpcm_playback = 1,
 		.ops = &amp;broxton_da7219_fe_ops,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_CP]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_CP] =</span>
 	{
 		.name = &quot;Bxt Audio Capture Port&quot;,
 		.stream_name = &quot;Audio Record&quot;,
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_dais[] = {</span>
 		.dpcm_capture = 1,
 		.ops = &amp;broxton_da7219_fe_ops,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_REF_CP]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_REF_CP] =</span>
 	{
 		.name = &quot;Bxt Audio Reference cap&quot;,
 		.stream_name = &quot;Refcap&quot;,
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_dais[] = {</span>
 		.nonatomic = 1,
 		.dynamic = 1,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_HDMI1_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_HDMI1_PB] =</span>
 	{
 		.name = &quot;Bxt HDMI Port1&quot;,
 		.stream_name = &quot;Hdmi1&quot;,
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_dais[] = {</span>
 		.nonatomic = 1,
 		.dynamic = 1,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_HDMI2_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_HDMI2_PB] =</span>
 	{
 		.name = &quot;Bxt HDMI Port2&quot;,
 		.stream_name = &quot;Hdmi2&quot;,
<span class="p_chunk">@@ -326,7 +326,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_dais[] = {</span>
 		.nonatomic = 1,
 		.dynamic = 1,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_HDMI3_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_HDMI3_PB] =</span>
 	{
 		.name = &quot;Bxt HDMI Port3&quot;,
 		.stream_name = &quot;Hdmi3&quot;,
<span class="p_header">diff --git a/sound/soc/intel/boards/bxt_rt298.c b/sound/soc/intel/boards/bxt_rt298.c</span>
<span class="p_header">index 253d7bfbf511..d610bdca1608 100644</span>
<span class="p_header">--- a/sound/soc/intel/boards/bxt_rt298.c</span>
<span class="p_header">+++ b/sound/soc/intel/boards/bxt_rt298.c</span>
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static const struct snd_soc_ops broxton_rt286_fe_ops = {</span>
 /* broxton digital audio interface glue - connects codec &lt;--&gt; CPU */
 static struct snd_soc_dai_link broxton_rt298_dais[] = {
 	/* Front End DAI links */
<span class="p_del">-	[BXT_DPCM_AUDIO_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_PB] =</span>
 	{
 		.name = &quot;Bxt Audio Port&quot;,
 		.stream_name = &quot;Audio&quot;,
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_rt298_dais[] = {</span>
 		.dpcm_playback = 1,
 		.ops = &amp;broxton_rt286_fe_ops,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_CP]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_CP] =</span>
 	{
 		.name = &quot;Bxt Audio Capture Port&quot;,
 		.stream_name = &quot;Audio Record&quot;,
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_rt298_dais[] = {</span>
 		.dpcm_capture = 1,
 		.ops = &amp;broxton_rt286_fe_ops,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_REF_CP]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_REF_CP] =</span>
 	{
 		.name = &quot;Bxt Audio Reference cap&quot;,
 		.stream_name = &quot;refcap&quot;,
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_rt298_dais[] = {</span>
 		.nonatomic = 1,
 		.dynamic = 1,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_DMIC_CP]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_DMIC_CP] =</span>
 	{
 		.name = &quot;Bxt Audio DMIC cap&quot;,
 		.stream_name = &quot;dmiccap&quot;,
<span class="p_chunk">@@ -327,7 +327,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_rt298_dais[] = {</span>
 		.dynamic = 1,
 		.ops = &amp;broxton_dmic_ops,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_HDMI1_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_HDMI1_PB] =</span>
 	{
 		.name = &quot;Bxt HDMI Port1&quot;,
 		.stream_name = &quot;Hdmi1&quot;,
<span class="p_chunk">@@ -340,7 +340,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_rt298_dais[] = {</span>
 		.nonatomic = 1,
 		.dynamic = 1,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_HDMI2_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_HDMI2_PB] =</span>
 	{
 		.name = &quot;Bxt HDMI Port2&quot;,
 		.stream_name = &quot;Hdmi2&quot;,
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> static struct snd_soc_dai_link broxton_rt298_dais[] = {</span>
 		.nonatomic = 1,
 		.dynamic = 1,
 	},
<span class="p_del">-	[BXT_DPCM_AUDIO_HDMI3_PB]</span>
<span class="p_add">+	[BXT_DPCM_AUDIO_HDMI3_PB] =</span>
 	{
 		.name = &quot;Bxt HDMI Port3&quot;,
 		.stream_name = &quot;Hdmi3&quot;,
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index d908ff8f9755..801082fdc3e0 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -823,6 +823,7 @@</span> <span class="p_context"> static int dapm_create_or_share_kcontrol(struct snd_soc_dapm_widget *w,</span>
 			case snd_soc_dapm_switch:
 			case snd_soc_dapm_mixer:
 			case snd_soc_dapm_pga:
<span class="p_add">+			case snd_soc_dapm_out_drv:</span>
 				wname_in_long_name = true;
 				kcname_in_long_name = true;
 				break;
<span class="p_chunk">@@ -3049,6 +3050,9 @@</span> <span class="p_context"> int snd_soc_dapm_get_volsw(struct snd_kcontrol *kcontrol,</span>
 	}
 	mutex_unlock(&amp;card-&gt;dapm_mutex);
 
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	if (invert)
 		ucontrol-&gt;value.integer.value[0] = max - val;
 	else
<span class="p_chunk">@@ -3200,7 +3204,7 @@</span> <span class="p_context"> int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,</span>
 	if (e-&gt;shift_l != e-&gt;shift_r) {
 		if (item[1] &gt; e-&gt;items)
 			return -EINVAL;
<span class="p_del">-		val |= snd_soc_enum_item_to_val(e, item[1]) &lt;&lt; e-&gt;shift_l;</span>
<span class="p_add">+		val |= snd_soc_enum_item_to_val(e, item[1]) &lt;&lt; e-&gt;shift_r;</span>
 		mask |= e-&gt;mask &lt;&lt; e-&gt;shift_r;
 	}
 
<span class="p_header">diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c</span>
<span class="p_header">index ee7f15aa46fc..34069076bf8e 100644</span>
<span class="p_header">--- a/sound/soc/soc-topology.c</span>
<span class="p_header">+++ b/sound/soc/soc-topology.c</span>
<span class="p_chunk">@@ -1475,6 +1475,7 @@</span> <span class="p_context"> widget:</span>
 	if (widget == NULL) {
 		dev_err(tplg-&gt;dev, &quot;ASoC: failed to create widget %s controls\n&quot;,
 			w-&gt;name);
<span class="p_add">+		ret = -ENOMEM;</span>
 		goto hdr_err;
 	}
 
<span class="p_header">diff --git a/tools/perf/perf-sys.h b/tools/perf/perf-sys.h</span>
<span class="p_header">index 7ed72a475c57..e4b717e9eb6c 100644</span>
<span class="p_header">--- a/tools/perf/perf-sys.h</span>
<span class="p_header">+++ b/tools/perf/perf-sys.h</span>
<span class="p_chunk">@@ -20,7 +20,6 @@</span> <span class="p_context"></span>
 #endif
 
 #ifdef __powerpc__
<span class="p_del">-#include &quot;../../arch/powerpc/include/uapi/asm/unistd.h&quot;</span>
 #define CPUINFO_PROC	{&quot;cpu&quot;}
 #endif
 
<span class="p_header">diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">index 13d414384739..7aee954b307f 100644</span>
<span class="p_header">--- a/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/browsers/hists.c</span>
<span class="p_chunk">@@ -1091,7 +1091,6 @@</span> <span class="p_context"> static int __hpp__slsmg_color_printf(struct perf_hpp *hpp, const char *fmt, ...)</span>
 	ret = scnprintf(hpp-&gt;buf, hpp-&gt;size, fmt, len, percent);
 	ui_browser__printf(arg-&gt;b, &quot;%s&quot;, hpp-&gt;buf);
 
<span class="p_del">-	advance_hpp(hpp, ret);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -2046,6 +2045,7 @@</span> <span class="p_context"> void hist_browser__init(struct hist_browser *browser,</span>
 			struct hists *hists)
 {
 	struct perf_hpp_fmt *fmt;
<span class="p_add">+	struct perf_hpp_list_node *node;</span>
 
 	browser-&gt;hists			= hists;
 	browser-&gt;b.refresh		= hist_browser__refresh;
<span class="p_chunk">@@ -2058,6 +2058,11 @@</span> <span class="p_context"> void hist_browser__init(struct hist_browser *browser,</span>
 		perf_hpp__reset_width(fmt, hists);
 		++browser-&gt;b.columns;
 	}
<span class="p_add">+	/* hierarchy entries have their own hpp list */</span>
<span class="p_add">+	list_for_each_entry(node, &amp;hists-&gt;hpp_formats, list) {</span>
<span class="p_add">+		perf_hpp_list__for_each_format(&amp;node-&gt;hpp, fmt)</span>
<span class="p_add">+			perf_hpp__reset_width(fmt, hists);</span>
<span class="p_add">+	}</span>
 }
 
 struct hist_browser *hist_browser__new(struct hists *hists)
<span class="p_header">diff --git a/tools/perf/ui/stdio/hist.c b/tools/perf/ui/stdio/hist.c</span>
<span class="p_header">index f04a63112079..d0cae75408ff 100644</span>
<span class="p_header">--- a/tools/perf/ui/stdio/hist.c</span>
<span class="p_header">+++ b/tools/perf/ui/stdio/hist.c</span>
<span class="p_chunk">@@ -628,14 +628,6 @@</span> <span class="p_context"> hists__fprintf_hierarchy_headers(struct hists *hists,</span>
 				 struct perf_hpp *hpp,
 				 FILE *fp)
 {
<span class="p_del">-	struct perf_hpp_list_node *fmt_node;</span>
<span class="p_del">-	struct perf_hpp_fmt *fmt;</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(fmt_node, &amp;hists-&gt;hpp_formats, list) {</span>
<span class="p_del">-		perf_hpp_list__for_each_format(&amp;fmt_node-&gt;hpp, fmt)</span>
<span class="p_del">-			perf_hpp__reset_width(fmt, hists);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return print_hierarchy_header(hists, hpp, symbol_conf.field_sep, fp);
 }
 
<span class="p_chunk">@@ -714,6 +706,7 @@</span> <span class="p_context"> size_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,</span>
 		      bool use_callchain)
 {
 	struct perf_hpp_fmt *fmt;
<span class="p_add">+	struct perf_hpp_list_node *node;</span>
 	struct rb_node *nd;
 	size_t ret = 0;
 	const char *sep = symbol_conf.field_sep;
<span class="p_chunk">@@ -726,6 +719,11 @@</span> <span class="p_context"> size_t hists__fprintf(struct hists *hists, bool show_header, int max_rows,</span>
 
 	hists__for_each_format(hists, fmt)
 		perf_hpp__reset_width(fmt, hists);
<span class="p_add">+	/* hierarchy entries have their own hpp list */</span>
<span class="p_add">+	list_for_each_entry(node, &amp;hists-&gt;hpp_formats, list) {</span>
<span class="p_add">+		perf_hpp_list__for_each_format(&amp;node-&gt;hpp, fmt)</span>
<span class="p_add">+			perf_hpp__reset_width(fmt, hists);</span>
<span class="p_add">+	}</span>
 
 	if (symbol_conf.col_width_list_str)
 		perf_hpp__set_user_width(symbol_conf.col_width_list_str);
<span class="p_header">diff --git a/tools/perf/util/data-convert-bt.c b/tools/perf/util/data-convert-bt.c</span>
<span class="p_header">index 4f979bb27b6c..7123f4de32cc 100644</span>
<span class="p_header">--- a/tools/perf/util/data-convert-bt.c</span>
<span class="p_header">+++ b/tools/perf/util/data-convert-bt.c</span>
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> add_bpf_output_values(struct bt_ctf_event_class *event_class,</span>
 	int ret;
 
 	if (nr_elements * sizeof(u32) != raw_size)
<span class="p_del">-		pr_warning(&quot;Incorrect raw_size (%u) in bpf output event, skip %lu bytes\n&quot;,</span>
<span class="p_add">+		pr_warning(&quot;Incorrect raw_size (%u) in bpf output event, skip %zu bytes\n&quot;,</span>
 			   raw_size, nr_elements * sizeof(u32) - raw_size);
 
 	len_type = bt_ctf_event_class_get_field_by_name(event_class, &quot;raw_len&quot;);
<span class="p_header">diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c</span>
<span class="p_header">index a811c13a74d6..f77b3167585c 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol-elf.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol-elf.c</span>
<span class="p_chunk">@@ -1113,9 +1113,8 @@</span> <span class="p_context"> new_symbol:</span>
 	 * For misannotated, zeroed, ASM function sizes.
 	 */
 	if (nr &gt; 0) {
<span class="p_del">-		if (!symbol_conf.allow_aliases)</span>
<span class="p_del">-			symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 		symbols__fixup_end(&amp;dso-&gt;symbols[map-&gt;type]);
<span class="p_add">+		symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 		if (kmap) {
 			/*
 			 * We need to fixup this here too because we create new
<span class="p_header">diff --git a/tools/perf/util/symbol.c b/tools/perf/util/symbol.c</span>
<span class="p_header">index 37e8d20ae03e..f29f336ed17b 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol.c</span>
<span class="p_chunk">@@ -152,6 +152,9 @@</span> <span class="p_context"> void symbols__fixup_duplicate(struct rb_root *symbols)</span>
 	struct rb_node *nd;
 	struct symbol *curr, *next;
 
<span class="p_add">+	if (symbol_conf.allow_aliases)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	nd = rb_first(symbols);
 
 	while (nd) {
<span class="p_chunk">@@ -1234,8 +1237,8 @@</span> <span class="p_context"> int __dso__load_kallsyms(struct dso *dso, const char *filename,</span>
 	if (kallsyms__delta(map, filename, &amp;delta))
 		return -1;
 
<span class="p_del">-	symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 	symbols__fixup_end(&amp;dso-&gt;symbols[map-&gt;type]);
<span class="p_add">+	symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 
 	if (dso-&gt;kernel == DSO_TYPE_GUEST_KERNEL)
 		dso-&gt;symtab_type = DSO_BINARY_TYPE__GUEST_KALLSYMS;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



