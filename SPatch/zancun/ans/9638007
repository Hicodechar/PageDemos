
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v1] mm, hugetlb: use pte_present() instead of pmd_present() in follow_huge_pmd() - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v1] mm, hugetlb: use pte_present() instead of pmd_present() in follow_huge_pmd()</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=4407">Naoya Horiguchi</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 22, 2017, 2:31 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1490149898-20231-1-git-send-email-n-horiguchi@ah.jp.nec.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9638007/mbox/"
   >mbox</a>
|
   <a href="/patch/9638007/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9638007/">/patch/9638007/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E8143602CC for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 22 Mar 2017 02:32:18 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D844E2041F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 22 Mar 2017 02:32:18 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C9B2825D99; Wed, 22 Mar 2017 02:32:18 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.3 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0F5BB2041F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed, 22 Mar 2017 02:32:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1758603AbdCVCcF (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 21 Mar 2017 22:32:05 -0400
Received: from mail-pg0-f67.google.com ([74.125.83.67]:36445 &quot;EHLO
	mail-pg0-f67.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1758025AbdCVCcD (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 21 Mar 2017 22:32:03 -0400
Received: by mail-pg0-f67.google.com with SMTP id 81so19987833pgh.3
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Tue, 21 Mar 2017 19:31:43 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=sender:from:to:cc:subject:date:message-id;
	bh=kY+e5WvTc9QKnA+uVtdsjgyXuhFQkVIrfH2KFzJPTJI=;
	b=XaCX5zNB1HOgWhdVzWj/RB22fCCDSWdQ9BRWn6kXR4Ap6pW1toOylB7u4CGYDa+o0b
	hK7dWo98rOuBFCnvPcgTNjhgl9j4VQEmcKjcLVd5hdvchosG2GfV3qqTMaBk0b/XI1CA
	l7eEYoYMYFBMBN+oh/IGCHXUMdF/Ki2GUsD490Br9/xJ2nxCcj7wSzTL+gvA1nDftyg+
	bDqJEh5HOI6rvSx/IiX4jqpwhguaweU+r5FE1cPM5zsndiW9774lvRQlZlukL+fstIv+
	Rc5VGJitgjxApnTNBQHl3KCfUy1br/WUtdgGSmJ6EYc/aISVt6pTFJv6cospqCLRDfNK
	3ang==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:sender:from:to:cc:subject:date:message-id;
	bh=kY+e5WvTc9QKnA+uVtdsjgyXuhFQkVIrfH2KFzJPTJI=;
	b=tqPFfLu5cf19u6H5Bh9ExmY3rV+j/MKrPYncoAvVZ2hbdeetqFyVuogg3aob/wUHrP
	VoGIpGVFc9yBYG/HFezA8lB7gbP7nLwJGt7XvbKerSbkWIoAUs6p5vww8R7aYI2cN3St
	ElMuQtvR/e7EqZVmmWbAAyjHXtt8tpKSuy73afnhyfF+qrt7fargWVmG8b4IamdC3//V
	rdymcb+3hElAsH+yi4CM3jlNdLZpRvexKg/VCr8yfjsOiaII/caskdmg5Bgd3Dcvtmat
	V/ymFHomvoDwQw26Ufdww2potOYrUW3xDmv5DiHhOT7FbBOyRj2ujd5aTbgSPZeM8JWT
	K3Pw==
X-Gm-Message-State: AFeK/H2m+8QOejnwKzyRv+Q513h6S7sroOMxwAtHwhc1fu9R8c66j6B0kdK88VRuvjncvA==
X-Received: by 10.84.177.164 with SMTP id x33mr51468046plb.75.1490149903102; 
	Tue, 21 Mar 2017 19:31:43 -0700 (PDT)
Received: from www9186uo.sakura.ne.jp (www9186uo.sakura.ne.jp.
	[153.121.56.200]) by smtp.gmail.com with ESMTPSA id
	194sm41911299pfx.134.2017.03.21.19.31.40
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Tue, 21 Mar 2017 19:31:42 -0700 (PDT)
From: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;
To: linux-mm@kvack.org
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Hugh Dickins &lt;hughd@google.com&gt;, Michal Hocko &lt;mhocko@kernel.org&gt;,
	&quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;,
	Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;, linux-kernel@vger.kernel.org,
	Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;,
	Naoya Horiguchi &lt;nao.horiguchi@gmail.com&gt;
Subject: [PATCH v1] mm,
	hugetlb: use pte_present() instead of pmd_present() in
	follow_huge_pmd()
Date: Wed, 22 Mar 2017 11:31:38 +0900
Message-Id: &lt;1490149898-20231-1-git-send-email-n-horiguchi@ah.jp.nec.com&gt;
X-Mailer: git-send-email 2.7.0
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=4407">Naoya Horiguchi</a> - March 22, 2017, 2:31 a.m.</div>
<pre class="content">
I found the race condition which triggers the following bug when
move_pages() and soft offline are called on a single hugetlb page
concurrently.

    [61163.578957] Soft offlining page 0x119400 at 0x700000000000
    [61163.580062] BUG: unable to handle kernel paging request at ffffea0011943820
    [61163.580791] IP: follow_huge_pmd+0x143/0x190
    [61163.581203] PGD 7ffd2067
    [61163.581204] PUD 7ffd1067
    [61163.581471] PMD 0
    [61163.581723]
    [61163.582052] Oops: 0000 [#1] SMP
    [61163.582349] Modules linked in: binfmt_misc ppdev virtio_balloon parport_pc pcspkr i2c_piix4 parport i2c_core acpi_cpufreq ip_tables xfs libcrc32c ata_generic pata_acpi virtio_blk 8139too crc32c_intel ata_piix serio_raw libata virtio_pci 8139cp virtio_ring virtio mii floppy dm_mirror dm_region_hash dm_log dm_mod [last unloaded: cap_check]
    [61163.585130] CPU: 0 PID: 22573 Comm: iterate_numa_mo Tainted: P           OE   4.11.0-rc2-mm1+ #2
    [61163.586055] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011
    [61163.586627] task: ffff88007c951680 task.stack: ffffc90004bd8000
    [61163.587181] RIP: 0010:follow_huge_pmd+0x143/0x190
    [61163.587622] RSP: 0018:ffffc90004bdbcd0 EFLAGS: 00010202
    [61163.588096] RAX: 0000000465003e80 RBX: ffffea0004e34d30 RCX: 00003ffffffff000
    [61163.588818] RDX: 0000000011943800 RSI: 0000000000080001 RDI: 0000000465003e80
    [61163.589486] RBP: ffffc90004bdbd18 R08: 0000000000000000 R09: ffff880138d34000
    [61163.590097] R10: ffffea0004650000 R11: 0000000000c363b0 R12: ffffea0011943800
    [61163.590751] R13: ffff8801b8d34000 R14: ffffea0000000000 R15: 000077ff80000000
    [61163.591375] FS:  00007fc977710740(0000) GS:ffff88007dc00000(0000) knlGS:0000000000000000
    [61163.592068] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
    [61163.592627] CR2: ffffea0011943820 CR3: 000000007a746000 CR4: 00000000001406f0
    [61163.593330] Call Trace:
    [61163.593556]  follow_page_mask+0x270/0x550
    [61163.593908]  SYSC_move_pages+0x4ea/0x8f0
    [61163.594253]  ? lru_cache_add_active_or_unevictable+0x4b/0xd0
    [61163.594798]  SyS_move_pages+0xe/0x10
    [61163.595113]  do_syscall_64+0x67/0x180
    [61163.595434]  entry_SYSCALL64_slow_path+0x25/0x25
    [61163.595837] RIP: 0033:0x7fc976e03949
    [61163.596148] RSP: 002b:00007ffe72221d88 EFLAGS: 00000246 ORIG_RAX: 0000000000000117
    [61163.596940] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fc976e03949
    [61163.597567] RDX: 0000000000c22390 RSI: 0000000000001400 RDI: 0000000000005827
    [61163.598177] RBP: 00007ffe72221e00 R08: 0000000000c2c3a0 R09: 0000000000000004
    [61163.598842] R10: 0000000000c363b0 R11: 0000000000000246 R12: 0000000000400650
    [61163.599456] R13: 00007ffe72221ee0 R14: 0000000000000000 R15: 0000000000000000
    [61163.600067] Code: 81 e4 ff ff 1f 00 48 21 c2 49 c1 ec 0c 48 c1 ea 0c 4c 01 e2 49 bc 00 00 00 00 00 ea ff ff 48 c1 e2 06 49 01 d4 f6 45 bc 04 74 90 &lt;49&gt; 8b 7c 24 20 40 f6 c7 01 75 2b 4c 89 e7 8b 47 1c 85 c0 7e 2a
    [61163.601845] RIP: follow_huge_pmd+0x143/0x190 RSP: ffffc90004bdbcd0
    [61163.602376] CR2: ffffea0011943820
    [61163.602767] ---[ end trace e4f81353a2d23232 ]---
    [61163.603236] Kernel panic - not syncing: Fatal exception
    [61163.603706] Kernel Offset: disabled

This bug is triggered when pmd_present() returns true for non-present
hugetlb, so fixing the present check in follow_huge_pmd() prevents it.
Using pmd_present() to determine present/non-present for hugetlb is
not correct, because pmd_present() checks multiple bits (not only
_PAGE_PRESENT) for historical reason and it can misjudge hugetlb state.

Fixes: e66f17ff7177 (&quot;mm/hugetlb: take page table lock in follow_huge_pmd()&quot;)
<span class="signed-off-by">Signed-off-by: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
Cc: &lt;stable@vger.kernel.org&gt;        [4.0+]
---
 mm/hugetlb.c | 6 ++++--
 1 file changed, 4 insertions(+), 2 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=113021">Hillf Danton</a> - March 22, 2017, 3:29 a.m.</div>
<pre class="content">
On March 22, 2017 10:32 AM Naoya Horiguchi wrote: 
<span class="quote">&gt; </span>
<span class="quote">&gt; I found the race condition which triggers the following bug when</span>
<span class="quote">&gt; move_pages() and soft offline are called on a single hugetlb page</span>
<span class="quote">&gt; concurrently.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     [61163.578957] Soft offlining page 0x119400 at 0x700000000000</span>
<span class="quote">&gt;     [61163.580062] BUG: unable to handle kernel paging request at ffffea0011943820</span>
<span class="quote">&gt;     [61163.580791] IP: follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;     [61163.581203] PGD 7ffd2067</span>
<span class="quote">&gt;     [61163.581204] PUD 7ffd1067</span>
<span class="quote">&gt;     [61163.581471] PMD 0</span>
<span class="quote">&gt;     [61163.581723]</span>
<span class="quote">&gt;     [61163.582052] Oops: 0000 [#1] SMP</span>
<span class="quote">&gt;     [61163.582349] Modules linked in: binfmt_misc ppdev virtio_balloon parport_pc pcspkr i2c_piix4 parport i2c_core acpi_cpufreq</span>
<span class="quote">&gt; ip_tables xfs libcrc32c ata_generic pata_acpi virtio_blk 8139too crc32c_intel ata_piix serio_raw libata virtio_pci 8139cp</span>
virtio_ring virtio
<span class="quote">&gt; mii floppy dm_mirror dm_region_hash dm_log dm_mod [last unloaded: cap_check]</span>
<span class="quote">&gt;     [61163.585130] CPU: 0 PID: 22573 Comm: iterate_numa_mo Tainted: P           OE   4.11.0-rc2-mm1+ #2</span>
<span class="quote">&gt;     [61163.586055] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011</span>
<span class="quote">&gt;     [61163.586627] task: ffff88007c951680 task.stack: ffffc90004bd8000</span>
<span class="quote">&gt;     [61163.587181] RIP: 0010:follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;     [61163.587622] RSP: 0018:ffffc90004bdbcd0 EFLAGS: 00010202</span>
<span class="quote">&gt;     [61163.588096] RAX: 0000000465003e80 RBX: ffffea0004e34d30 RCX: 00003ffffffff000</span>
<span class="quote">&gt;     [61163.588818] RDX: 0000000011943800 RSI: 0000000000080001 RDI: 0000000465003e80</span>
<span class="quote">&gt;     [61163.589486] RBP: ffffc90004bdbd18 R08: 0000000000000000 R09: ffff880138d34000</span>
<span class="quote">&gt;     [61163.590097] R10: ffffea0004650000 R11: 0000000000c363b0 R12: ffffea0011943800</span>
<span class="quote">&gt;     [61163.590751] R13: ffff8801b8d34000 R14: ffffea0000000000 R15: 000077ff80000000</span>
<span class="quote">&gt;     [61163.591375] FS:  00007fc977710740(0000) GS:ffff88007dc00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt;     [61163.592068] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt;     [61163.592627] CR2: ffffea0011943820 CR3: 000000007a746000 CR4: 00000000001406f0</span>
<span class="quote">&gt;     [61163.593330] Call Trace:</span>
<span class="quote">&gt;     [61163.593556]  follow_page_mask+0x270/0x550</span>
<span class="quote">&gt;     [61163.593908]  SYSC_move_pages+0x4ea/0x8f0</span>
<span class="quote">&gt;     [61163.594253]  ? lru_cache_add_active_or_unevictable+0x4b/0xd0</span>
<span class="quote">&gt;     [61163.594798]  SyS_move_pages+0xe/0x10</span>
<span class="quote">&gt;     [61163.595113]  do_syscall_64+0x67/0x180</span>
<span class="quote">&gt;     [61163.595434]  entry_SYSCALL64_slow_path+0x25/0x25</span>
<span class="quote">&gt;     [61163.595837] RIP: 0033:0x7fc976e03949</span>
<span class="quote">&gt;     [61163.596148] RSP: 002b:00007ffe72221d88 EFLAGS: 00000246 ORIG_RAX: 0000000000000117</span>
<span class="quote">&gt;     [61163.596940] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fc976e03949</span>
<span class="quote">&gt;     [61163.597567] RDX: 0000000000c22390 RSI: 0000000000001400 RDI: 0000000000005827</span>
<span class="quote">&gt;     [61163.598177] RBP: 00007ffe72221e00 R08: 0000000000c2c3a0 R09: 0000000000000004</span>
<span class="quote">&gt;     [61163.598842] R10: 0000000000c363b0 R11: 0000000000000246 R12: 0000000000400650</span>
<span class="quote">&gt;     [61163.599456] R13: 00007ffe72221ee0 R14: 0000000000000000 R15: 0000000000000000</span>
<span class="quote">&gt;     [61163.600067] Code: 81 e4 ff ff 1f 00 48 21 c2 49 c1 ec 0c 48 c1 ea 0c 4c 01 e2 49 bc 00 00 00 00 00 ea ff ff 48 c1 e2 06 49</span>
01 d4 f6 45 bc
<span class="quote">&gt; 04 74 90 &lt;49&gt; 8b 7c 24 20 40 f6 c7 01 75 2b 4c 89 e7 8b 47 1c 85 c0 7e 2a</span>
<span class="quote">&gt;     [61163.601845] RIP: follow_huge_pmd+0x143/0x190 RSP: ffffc90004bdbcd0</span>
<span class="quote">&gt;     [61163.602376] CR2: ffffea0011943820</span>
<span class="quote">&gt;     [61163.602767] ---[ end trace e4f81353a2d23232 ]---</span>
<span class="quote">&gt;     [61163.603236] Kernel panic - not syncing: Fatal exception</span>
<span class="quote">&gt;     [61163.603706] Kernel Offset: disabled</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This bug is triggered when pmd_present() returns true for non-present</span>
<span class="quote">&gt; hugetlb, so fixing the present check in follow_huge_pmd() prevents it.</span>
<span class="quote">&gt; Using pmd_present() to determine present/non-present for hugetlb is</span>
<span class="quote">&gt; not correct, because pmd_present() checks multiple bits (not only</span>
<span class="quote">&gt; _PAGE_PRESENT) for historical reason and it can misjudge hugetlb state.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fixes: e66f17ff7177 (&quot;mm/hugetlb: take page table lock in follow_huge_pmd()&quot;)</span>
<span class="quote">&gt; Signed-off-by: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt; Cc: &lt;stable@vger.kernel.org&gt;        [4.0+]</span>
<span class="quote">&gt; ---</span>
<span class="acked-by">
Acked-by: Hillf Danton &lt;hillf.zj@alibaba-inc.com&gt;</span>
<span class="quote">
&gt;  mm/hugetlb.c | 6 ++++--</span>
<span class="quote">&gt;  1 file changed, 4 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="quote">&gt; index 3d0aab9..f501f14 100644</span>
<span class="quote">&gt; --- v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c</span>
<span class="quote">&gt; +++ v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -4651,6 +4651,7 @@ follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct page *page = NULL;</span>
<span class="quote">&gt;  	spinlock_t *ptl;</span>
<span class="quote">&gt; +	pte_t pte;</span>
<span class="quote">&gt;  retry:</span>
<span class="quote">&gt;  	ptl = pmd_lockptr(mm, pmd);</span>
<span class="quote">&gt;  	spin_lock(ptl);</span>
<span class="quote">&gt; @@ -4660,12 +4661,13 @@ follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt;  	if (!pmd_huge(*pmd))</span>
<span class="quote">&gt;  		goto out;</span>
<span class="quote">&gt; -	if (pmd_present(*pmd)) {</span>
<span class="quote">&gt; +	pte = huge_ptep_get((pte_t *)pmd);</span>
<span class="quote">&gt; +	if (pte_present(pte)) {</span>
<span class="quote">&gt;  		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt;  		if (flags &amp; FOLL_GET)</span>
<span class="quote">&gt;  			get_page(page);</span>
<span class="quote">&gt;  	} else {</span>
<span class="quote">&gt; -		if (is_hugetlb_entry_migration(huge_ptep_get((pte_t *)pmd))) {</span>
<span class="quote">&gt; +		if (is_hugetlb_entry_migration(pte)) {</span>
<span class="quote">&gt;  			spin_unlock(ptl);</span>
<span class="quote">&gt;  			__migration_entry_wait(mm, (pte_t *)pmd, ptl);</span>
<span class="quote">&gt;  			goto retry;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; 2.7.0</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - March 22, 2017, 12:29 p.m.</div>
<pre class="content">
[CC Mike]

On Wed 22-03-17 11:31:38, Naoya Horiguchi wrote:
<span class="quote">&gt; I found the race condition which triggers the following bug when</span>
<span class="quote">&gt; move_pages() and soft offline are called on a single hugetlb page</span>
<span class="quote">&gt; concurrently.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     [61163.578957] Soft offlining page 0x119400 at 0x700000000000</span>
<span class="quote">&gt;     [61163.580062] BUG: unable to handle kernel paging request at ffffea0011943820</span>
<span class="quote">&gt;     [61163.580791] IP: follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;     [61163.581203] PGD 7ffd2067</span>
<span class="quote">&gt;     [61163.581204] PUD 7ffd1067</span>
<span class="quote">&gt;     [61163.581471] PMD 0</span>
<span class="quote">&gt;     [61163.581723]</span>
<span class="quote">&gt;     [61163.582052] Oops: 0000 [#1] SMP</span>
<span class="quote">&gt;     [61163.582349] Modules linked in: binfmt_misc ppdev virtio_balloon parport_pc pcspkr i2c_piix4 parport i2c_core acpi_cpufreq ip_tables xfs libcrc32c ata_generic pata_acpi virtio_blk 8139too crc32c_intel ata_piix serio_raw libata virtio_pci 8139cp virtio_ring virtio mii floppy dm_mirror dm_region_hash dm_log dm_mod [last unloaded: cap_check]</span>
<span class="quote">&gt;     [61163.585130] CPU: 0 PID: 22573 Comm: iterate_numa_mo Tainted: P           OE   4.11.0-rc2-mm1+ #2</span>
<span class="quote">&gt;     [61163.586055] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011</span>
<span class="quote">&gt;     [61163.586627] task: ffff88007c951680 task.stack: ffffc90004bd8000</span>
<span class="quote">&gt;     [61163.587181] RIP: 0010:follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;     [61163.587622] RSP: 0018:ffffc90004bdbcd0 EFLAGS: 00010202</span>
<span class="quote">&gt;     [61163.588096] RAX: 0000000465003e80 RBX: ffffea0004e34d30 RCX: 00003ffffffff000</span>
<span class="quote">&gt;     [61163.588818] RDX: 0000000011943800 RSI: 0000000000080001 RDI: 0000000465003e80</span>
<span class="quote">&gt;     [61163.589486] RBP: ffffc90004bdbd18 R08: 0000000000000000 R09: ffff880138d34000</span>
<span class="quote">&gt;     [61163.590097] R10: ffffea0004650000 R11: 0000000000c363b0 R12: ffffea0011943800</span>
<span class="quote">&gt;     [61163.590751] R13: ffff8801b8d34000 R14: ffffea0000000000 R15: 000077ff80000000</span>
<span class="quote">&gt;     [61163.591375] FS:  00007fc977710740(0000) GS:ffff88007dc00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt;     [61163.592068] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt;     [61163.592627] CR2: ffffea0011943820 CR3: 000000007a746000 CR4: 00000000001406f0</span>
<span class="quote">&gt;     [61163.593330] Call Trace:</span>
<span class="quote">&gt;     [61163.593556]  follow_page_mask+0x270/0x550</span>
<span class="quote">&gt;     [61163.593908]  SYSC_move_pages+0x4ea/0x8f0</span>
<span class="quote">&gt;     [61163.594253]  ? lru_cache_add_active_or_unevictable+0x4b/0xd0</span>
<span class="quote">&gt;     [61163.594798]  SyS_move_pages+0xe/0x10</span>
<span class="quote">&gt;     [61163.595113]  do_syscall_64+0x67/0x180</span>
<span class="quote">&gt;     [61163.595434]  entry_SYSCALL64_slow_path+0x25/0x25</span>
<span class="quote">&gt;     [61163.595837] RIP: 0033:0x7fc976e03949</span>
<span class="quote">&gt;     [61163.596148] RSP: 002b:00007ffe72221d88 EFLAGS: 00000246 ORIG_RAX: 0000000000000117</span>
<span class="quote">&gt;     [61163.596940] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fc976e03949</span>
<span class="quote">&gt;     [61163.597567] RDX: 0000000000c22390 RSI: 0000000000001400 RDI: 0000000000005827</span>
<span class="quote">&gt;     [61163.598177] RBP: 00007ffe72221e00 R08: 0000000000c2c3a0 R09: 0000000000000004</span>
<span class="quote">&gt;     [61163.598842] R10: 0000000000c363b0 R11: 0000000000000246 R12: 0000000000400650</span>
<span class="quote">&gt;     [61163.599456] R13: 00007ffe72221ee0 R14: 0000000000000000 R15: 0000000000000000</span>
<span class="quote">&gt;     [61163.600067] Code: 81 e4 ff ff 1f 00 48 21 c2 49 c1 ec 0c 48 c1 ea 0c 4c 01 e2 49 bc 00 00 00 00 00 ea ff ff 48 c1 e2 06 49 01 d4 f6 45 bc 04 74 90 &lt;49&gt; 8b 7c 24 20 40 f6 c7 01 75 2b 4c 89 e7 8b 47 1c 85 c0 7e 2a</span>
<span class="quote">&gt;     [61163.601845] RIP: follow_huge_pmd+0x143/0x190 RSP: ffffc90004bdbcd0</span>
<span class="quote">&gt;     [61163.602376] CR2: ffffea0011943820</span>
<span class="quote">&gt;     [61163.602767] ---[ end trace e4f81353a2d23232 ]---</span>
<span class="quote">&gt;     [61163.603236] Kernel panic - not syncing: Fatal exception</span>
<span class="quote">&gt;     [61163.603706] Kernel Offset: disabled</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This bug is triggered when pmd_present() returns true for non-present</span>
<span class="quote">&gt; hugetlb, so fixing the present check in follow_huge_pmd() prevents it.</span>
<span class="quote">&gt; Using pmd_present() to determine present/non-present for hugetlb is</span>
<span class="quote">&gt; not correct, because pmd_present() checks multiple bits (not only</span>
<span class="quote">&gt; _PAGE_PRESENT) for historical reason and it can misjudge hugetlb state.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fixes: e66f17ff7177 (&quot;mm/hugetlb: take page table lock in follow_huge_pmd()&quot;)</span>
<span class="quote">&gt; Signed-off-by: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt; Cc: &lt;stable@vger.kernel.org&gt;        [4.0+]</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  mm/hugetlb.c | 6 ++++--</span>
<span class="quote">&gt;  1 file changed, 4 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="quote">&gt; index 3d0aab9..f501f14 100644</span>
<span class="quote">&gt; --- v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c</span>
<span class="quote">&gt; +++ v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -4651,6 +4651,7 @@ follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct page *page = NULL;</span>
<span class="quote">&gt;  	spinlock_t *ptl;</span>
<span class="quote">&gt; +	pte_t pte;</span>
<span class="quote">&gt;  retry:</span>
<span class="quote">&gt;  	ptl = pmd_lockptr(mm, pmd);</span>
<span class="quote">&gt;  	spin_lock(ptl);</span>
<span class="quote">&gt; @@ -4660,12 +4661,13 @@ follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt;  	if (!pmd_huge(*pmd))</span>
<span class="quote">&gt;  		goto out;</span>
<span class="quote">&gt; -	if (pmd_present(*pmd)) {</span>
<span class="quote">&gt; +	pte = huge_ptep_get((pte_t *)pmd);</span>
<span class="quote">&gt; +	if (pte_present(pte)) {</span>
<span class="quote">&gt;  		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt;  		if (flags &amp; FOLL_GET)</span>
<span class="quote">&gt;  			get_page(page);</span>
<span class="quote">&gt;  	} else {</span>
<span class="quote">&gt; -		if (is_hugetlb_entry_migration(huge_ptep_get((pte_t *)pmd))) {</span>
<span class="quote">&gt; +		if (is_hugetlb_entry_migration(pte)) {</span>
<span class="quote">&gt;  			spin_unlock(ptl);</span>
<span class="quote">&gt;  			__migration_entry_wait(mm, (pte_t *)pmd, ptl);</span>
<span class="quote">&gt;  			goto retry;</span>
<span class="quote">&gt; -- </span>
<span class="quote">&gt; 2.7.0</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=447">Christian Borntraeger</a> - March 22, 2017, 12:53 p.m.</div>
<pre class="content">
On 03/22/2017 03:31 AM, Naoya Horiguchi wrote:
<span class="quote">&gt; I found the race condition which triggers the following bug when</span>
<span class="quote">&gt; move_pages() and soft offline are called on a single hugetlb page</span>
<span class="quote">&gt; concurrently.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     [61163.578957] Soft offlining page 0x119400 at 0x700000000000</span>
<span class="quote">&gt;     [61163.580062] BUG: unable to handle kernel paging request at ffffea0011943820</span>
<span class="quote">&gt;     [61163.580791] IP: follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;     [61163.581203] PGD 7ffd2067</span>
<span class="quote">&gt;     [61163.581204] PUD 7ffd1067</span>
<span class="quote">&gt;     [61163.581471] PMD 0</span>
<span class="quote">&gt;     [61163.581723]</span>
<span class="quote">&gt;     [61163.582052] Oops: 0000 [#1] SMP</span>
<span class="quote">&gt;     [61163.582349] Modules linked in: binfmt_misc ppdev virtio_balloon parport_pc pcspkr i2c_piix4 parport i2c_core acpi_cpufreq ip_tables xfs libcrc32c ata_generic pata_acpi virtio_blk 8139too crc32c_intel ata_piix serio_raw libata virtio_pci 8139cp virtio_ring virtio mii floppy dm_mirror dm_region_hash dm_log dm_mod [last unloaded: cap_check]</span>
<span class="quote">&gt;     [61163.585130] CPU: 0 PID: 22573 Comm: iterate_numa_mo Tainted: P           OE   4.11.0-rc2-mm1+ #2</span>
<span class="quote">&gt;     [61163.586055] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011</span>
<span class="quote">&gt;     [61163.586627] task: ffff88007c951680 task.stack: ffffc90004bd8000</span>
<span class="quote">&gt;     [61163.587181] RIP: 0010:follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;     [61163.587622] RSP: 0018:ffffc90004bdbcd0 EFLAGS: 00010202</span>
<span class="quote">&gt;     [61163.588096] RAX: 0000000465003e80 RBX: ffffea0004e34d30 RCX: 00003ffffffff000</span>
<span class="quote">&gt;     [61163.588818] RDX: 0000000011943800 RSI: 0000000000080001 RDI: 0000000465003e80</span>
<span class="quote">&gt;     [61163.589486] RBP: ffffc90004bdbd18 R08: 0000000000000000 R09: ffff880138d34000</span>
<span class="quote">&gt;     [61163.590097] R10: ffffea0004650000 R11: 0000000000c363b0 R12: ffffea0011943800</span>
<span class="quote">&gt;     [61163.590751] R13: ffff8801b8d34000 R14: ffffea0000000000 R15: 000077ff80000000</span>
<span class="quote">&gt;     [61163.591375] FS:  00007fc977710740(0000) GS:ffff88007dc00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt;     [61163.592068] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt;     [61163.592627] CR2: ffffea0011943820 CR3: 000000007a746000 CR4: 00000000001406f0</span>
<span class="quote">&gt;     [61163.593330] Call Trace:</span>
<span class="quote">&gt;     [61163.593556]  follow_page_mask+0x270/0x550</span>
<span class="quote">&gt;     [61163.593908]  SYSC_move_pages+0x4ea/0x8f0</span>
<span class="quote">&gt;     [61163.594253]  ? lru_cache_add_active_or_unevictable+0x4b/0xd0</span>
<span class="quote">&gt;     [61163.594798]  SyS_move_pages+0xe/0x10</span>
<span class="quote">&gt;     [61163.595113]  do_syscall_64+0x67/0x180</span>
<span class="quote">&gt;     [61163.595434]  entry_SYSCALL64_slow_path+0x25/0x25</span>
<span class="quote">&gt;     [61163.595837] RIP: 0033:0x7fc976e03949</span>
<span class="quote">&gt;     [61163.596148] RSP: 002b:00007ffe72221d88 EFLAGS: 00000246 ORIG_RAX: 0000000000000117</span>
<span class="quote">&gt;     [61163.596940] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fc976e03949</span>
<span class="quote">&gt;     [61163.597567] RDX: 0000000000c22390 RSI: 0000000000001400 RDI: 0000000000005827</span>
<span class="quote">&gt;     [61163.598177] RBP: 00007ffe72221e00 R08: 0000000000c2c3a0 R09: 0000000000000004</span>
<span class="quote">&gt;     [61163.598842] R10: 0000000000c363b0 R11: 0000000000000246 R12: 0000000000400650</span>
<span class="quote">&gt;     [61163.599456] R13: 00007ffe72221ee0 R14: 0000000000000000 R15: 0000000000000000</span>
<span class="quote">&gt;     [61163.600067] Code: 81 e4 ff ff 1f 00 48 21 c2 49 c1 ec 0c 48 c1 ea 0c 4c 01 e2 49 bc 00 00 00 00 00 ea ff ff 48 c1 e2 06 49 01 d4 f6 45 bc 04 74 90 &lt;49&gt; 8b 7c 24 20 40 f6 c7 01 75 2b 4c 89 e7 8b 47 1c 85 c0 7e 2a</span>
<span class="quote">&gt;     [61163.601845] RIP: follow_huge_pmd+0x143/0x190 RSP: ffffc90004bdbcd0</span>
<span class="quote">&gt;     [61163.602376] CR2: ffffea0011943820</span>
<span class="quote">&gt;     [61163.602767] ---[ end trace e4f81353a2d23232 ]---</span>
<span class="quote">&gt;     [61163.603236] Kernel panic - not syncing: Fatal exception</span>
<span class="quote">&gt;     [61163.603706] Kernel Offset: disabled</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This bug is triggered when pmd_present() returns true for non-present</span>
<span class="quote">&gt; hugetlb, so fixing the present check in follow_huge_pmd() prevents it.</span>
<span class="quote">&gt; Using pmd_present() to determine present/non-present for hugetlb is</span>
<span class="quote">&gt; not correct, because pmd_present() checks multiple bits (not only</span>
<span class="quote">&gt; _PAGE_PRESENT) for historical reason and it can misjudge hugetlb state.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Fixes: e66f17ff7177 (&quot;mm/hugetlb: take page table lock in follow_huge_pmd()&quot;)</span>
<span class="quote">&gt; Signed-off-by: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt; Cc: &lt;stable@vger.kernel.org&gt;        [4.0+]</span>

I think this is broken for s390. The page table entries look different from
the segment table entries (pmds) on s390, e.g. they have the invalid bit at
different places. Using pte functions on pmd does not work here.
Gerald can you confirm.
<span class="quote">




&gt; ---</span>
<span class="quote">&gt;  mm/hugetlb.c | 6 ++++--</span>
<span class="quote">&gt;  1 file changed, 4 insertions(+), 2 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="quote">&gt; index 3d0aab9..f501f14 100644</span>
<span class="quote">&gt; --- v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c</span>
<span class="quote">&gt; +++ v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="quote">&gt; @@ -4651,6 +4651,7 @@ follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	struct page *page = NULL;</span>
<span class="quote">&gt;  	spinlock_t *ptl;</span>
<span class="quote">&gt; +	pte_t pte;</span>
<span class="quote">&gt;  retry:</span>
<span class="quote">&gt;  	ptl = pmd_lockptr(mm, pmd);</span>
<span class="quote">&gt;  	spin_lock(ptl);</span>
<span class="quote">&gt; @@ -4660,12 +4661,13 @@ follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
<span class="quote">&gt;  	 */</span>
<span class="quote">&gt;  	if (!pmd_huge(*pmd))</span>
<span class="quote">&gt;  		goto out;</span>
<span class="quote">&gt; -	if (pmd_present(*pmd)) {</span>
<span class="quote">&gt; +	pte = huge_ptep_get((pte_t *)pmd);</span>
<span class="quote">&gt; +	if (pte_present(pte)) {</span>
<span class="quote">&gt;  		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt;  		if (flags &amp; FOLL_GET)</span>
<span class="quote">&gt;  			get_page(page);</span>
<span class="quote">&gt;  	} else {</span>
<span class="quote">&gt; -		if (is_hugetlb_entry_migration(huge_ptep_get((pte_t *)pmd))) {</span>
<span class="quote">&gt; +		if (is_hugetlb_entry_migration(pte)) {</span>
<span class="quote">&gt;  			spin_unlock(ptl);</span>
<span class="quote">&gt;  			__migration_entry_wait(mm, (pte_t *)pmd, ptl);</span>
<span class="quote">&gt;  			goto retry;</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=447">Christian Borntraeger</a> - March 22, 2017, 2:39 p.m.</div>
<pre class="content">
On 03/22/2017 01:53 PM, Christian Borntraeger wrote:
<span class="quote">&gt; On 03/22/2017 03:31 AM, Naoya Horiguchi wrote:</span>
<span class="quote">&gt;&gt; I found the race condition which triggers the following bug when</span>
<span class="quote">&gt;&gt; move_pages() and soft offline are called on a single hugetlb page</span>
<span class="quote">&gt;&gt; concurrently.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;     [61163.578957] Soft offlining page 0x119400 at 0x700000000000</span>
<span class="quote">&gt;&gt;     [61163.580062] BUG: unable to handle kernel paging request at ffffea0011943820</span>
<span class="quote">&gt;&gt;     [61163.580791] IP: follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;&gt;     [61163.581203] PGD 7ffd2067</span>
<span class="quote">&gt;&gt;     [61163.581204] PUD 7ffd1067</span>
<span class="quote">&gt;&gt;     [61163.581471] PMD 0</span>
<span class="quote">&gt;&gt;     [61163.581723]</span>
<span class="quote">&gt;&gt;     [61163.582052] Oops: 0000 [#1] SMP</span>
<span class="quote">&gt;&gt;     [61163.582349] Modules linked in: binfmt_misc ppdev virtio_balloon parport_pc pcspkr i2c_piix4 parport i2c_core acpi_cpufreq ip_tables xfs libcrc32c ata_generic pata_acpi virtio_blk 8139too crc32c_intel ata_piix serio_raw libata virtio_pci 8139cp virtio_ring virtio mii floppy dm_mirror dm_region_hash dm_log dm_mod [last unloaded: cap_check]</span>
<span class="quote">&gt;&gt;     [61163.585130] CPU: 0 PID: 22573 Comm: iterate_numa_mo Tainted: P           OE   4.11.0-rc2-mm1+ #2</span>
<span class="quote">&gt;&gt;     [61163.586055] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011</span>
<span class="quote">&gt;&gt;     [61163.586627] task: ffff88007c951680 task.stack: ffffc90004bd8000</span>
<span class="quote">&gt;&gt;     [61163.587181] RIP: 0010:follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt;&gt;     [61163.587622] RSP: 0018:ffffc90004bdbcd0 EFLAGS: 00010202</span>
<span class="quote">&gt;&gt;     [61163.588096] RAX: 0000000465003e80 RBX: ffffea0004e34d30 RCX: 00003ffffffff000</span>
<span class="quote">&gt;&gt;     [61163.588818] RDX: 0000000011943800 RSI: 0000000000080001 RDI: 0000000465003e80</span>
<span class="quote">&gt;&gt;     [61163.589486] RBP: ffffc90004bdbd18 R08: 0000000000000000 R09: ffff880138d34000</span>
<span class="quote">&gt;&gt;     [61163.590097] R10: ffffea0004650000 R11: 0000000000c363b0 R12: ffffea0011943800</span>
<span class="quote">&gt;&gt;     [61163.590751] R13: ffff8801b8d34000 R14: ffffea0000000000 R15: 000077ff80000000</span>
<span class="quote">&gt;&gt;     [61163.591375] FS:  00007fc977710740(0000) GS:ffff88007dc00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt;&gt;     [61163.592068] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt;&gt;     [61163.592627] CR2: ffffea0011943820 CR3: 000000007a746000 CR4: 00000000001406f0</span>
<span class="quote">&gt;&gt;     [61163.593330] Call Trace:</span>
<span class="quote">&gt;&gt;     [61163.593556]  follow_page_mask+0x270/0x550</span>
<span class="quote">&gt;&gt;     [61163.593908]  SYSC_move_pages+0x4ea/0x8f0</span>
<span class="quote">&gt;&gt;     [61163.594253]  ? lru_cache_add_active_or_unevictable+0x4b/0xd0</span>
<span class="quote">&gt;&gt;     [61163.594798]  SyS_move_pages+0xe/0x10</span>
<span class="quote">&gt;&gt;     [61163.595113]  do_syscall_64+0x67/0x180</span>
<span class="quote">&gt;&gt;     [61163.595434]  entry_SYSCALL64_slow_path+0x25/0x25</span>
<span class="quote">&gt;&gt;     [61163.595837] RIP: 0033:0x7fc976e03949</span>
<span class="quote">&gt;&gt;     [61163.596148] RSP: 002b:00007ffe72221d88 EFLAGS: 00000246 ORIG_RAX: 0000000000000117</span>
<span class="quote">&gt;&gt;     [61163.596940] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fc976e03949</span>
<span class="quote">&gt;&gt;     [61163.597567] RDX: 0000000000c22390 RSI: 0000000000001400 RDI: 0000000000005827</span>
<span class="quote">&gt;&gt;     [61163.598177] RBP: 00007ffe72221e00 R08: 0000000000c2c3a0 R09: 0000000000000004</span>
<span class="quote">&gt;&gt;     [61163.598842] R10: 0000000000c363b0 R11: 0000000000000246 R12: 0000000000400650</span>
<span class="quote">&gt;&gt;     [61163.599456] R13: 00007ffe72221ee0 R14: 0000000000000000 R15: 0000000000000000</span>
<span class="quote">&gt;&gt;     [61163.600067] Code: 81 e4 ff ff 1f 00 48 21 c2 49 c1 ec 0c 48 c1 ea 0c 4c 01 e2 49 bc 00 00 00 00 00 ea ff ff 48 c1 e2 06 49 01 d4 f6 45 bc 04 74 90 &lt;49&gt; 8b 7c 24 20 40 f6 c7 01 75 2b 4c 89 e7 8b 47 1c 85 c0 7e 2a</span>
<span class="quote">&gt;&gt;     [61163.601845] RIP: follow_huge_pmd+0x143/0x190 RSP: ffffc90004bdbcd0</span>
<span class="quote">&gt;&gt;     [61163.602376] CR2: ffffea0011943820</span>
<span class="quote">&gt;&gt;     [61163.602767] ---[ end trace e4f81353a2d23232 ]---</span>
<span class="quote">&gt;&gt;     [61163.603236] Kernel panic - not syncing: Fatal exception</span>
<span class="quote">&gt;&gt;     [61163.603706] Kernel Offset: disabled</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This bug is triggered when pmd_present() returns true for non-present</span>
<span class="quote">&gt;&gt; hugetlb, so fixing the present check in follow_huge_pmd() prevents it.</span>
<span class="quote">&gt;&gt; Using pmd_present() to determine present/non-present for hugetlb is</span>
<span class="quote">&gt;&gt; not correct, because pmd_present() checks multiple bits (not only</span>
<span class="quote">&gt;&gt; _PAGE_PRESENT) for historical reason and it can misjudge hugetlb state.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Fixes: e66f17ff7177 (&quot;mm/hugetlb: take page table lock in follow_huge_pmd()&quot;)</span>
<span class="quote">&gt;&gt; Signed-off-by: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt;&gt; Cc: &lt;stable@vger.kernel.org&gt;        [4.0+]</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think this is broken for s390. The page table entries look different from</span>
<span class="quote">&gt; the segment table entries (pmds) on s390, e.g. they have the invalid bit at</span>
<span class="quote">&gt; different places. Using pte functions on pmd does not work here.</span>
<span class="quote">&gt; Gerald can you confirm.</span>
<span class="quote">&gt; </span>


Hmmm, it looks like that the s390 variant of huge_ptep_get already
does the translation. So its probably fine.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=4407">Naoya Horiguchi</a> - March 22, 2017, 10:53 p.m.</div>
<pre class="content">
On Wed, Mar 22, 2017 at 03:39:00PM +0100, Christian Borntraeger wrote:
<span class="quote">&gt; On 03/22/2017 01:53 PM, Christian Borntraeger wrote:</span>
<span class="quote">&gt; &gt; On 03/22/2017 03:31 AM, Naoya Horiguchi wrote:</span>
<span class="quote">&gt; &gt;&gt; I found the race condition which triggers the following bug when</span>
<span class="quote">&gt; &gt;&gt; move_pages() and soft offline are called on a single hugetlb page</span>
<span class="quote">&gt; &gt;&gt; concurrently.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;     [61163.578957] Soft offlining page 0x119400 at 0x700000000000</span>
<span class="quote">&gt; &gt;&gt;     [61163.580062] BUG: unable to handle kernel paging request at ffffea0011943820</span>
<span class="quote">&gt; &gt;&gt;     [61163.580791] IP: follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt; &gt;&gt;     [61163.581203] PGD 7ffd2067</span>
<span class="quote">&gt; &gt;&gt;     [61163.581204] PUD 7ffd1067</span>
<span class="quote">&gt; &gt;&gt;     [61163.581471] PMD 0</span>
<span class="quote">&gt; &gt;&gt;     [61163.581723]</span>
<span class="quote">&gt; &gt;&gt;     [61163.582052] Oops: 0000 [#1] SMP</span>
<span class="quote">&gt; &gt;&gt;     [61163.582349] Modules linked in: binfmt_misc ppdev virtio_balloon parport_pc pcspkr i2c_piix4 parport i2c_core acpi_cpufreq ip_tables xfs libcrc32c ata_generic pata_acpi virtio_blk 8139too crc32c_intel ata_piix serio_raw libata virtio_pci 8139cp virtio_ring virtio mii floppy dm_mirror dm_region_hash dm_log dm_mod [last unloaded: cap_check]</span>
<span class="quote">&gt; &gt;&gt;     [61163.585130] CPU: 0 PID: 22573 Comm: iterate_numa_mo Tainted: P           OE   4.11.0-rc2-mm1+ #2</span>
<span class="quote">&gt; &gt;&gt;     [61163.586055] Hardware name: Red Hat KVM, BIOS 0.5.1 01/01/2011</span>
<span class="quote">&gt; &gt;&gt;     [61163.586627] task: ffff88007c951680 task.stack: ffffc90004bd8000</span>
<span class="quote">&gt; &gt;&gt;     [61163.587181] RIP: 0010:follow_huge_pmd+0x143/0x190</span>
<span class="quote">&gt; &gt;&gt;     [61163.587622] RSP: 0018:ffffc90004bdbcd0 EFLAGS: 00010202</span>
<span class="quote">&gt; &gt;&gt;     [61163.588096] RAX: 0000000465003e80 RBX: ffffea0004e34d30 RCX: 00003ffffffff000</span>
<span class="quote">&gt; &gt;&gt;     [61163.588818] RDX: 0000000011943800 RSI: 0000000000080001 RDI: 0000000465003e80</span>
<span class="quote">&gt; &gt;&gt;     [61163.589486] RBP: ffffc90004bdbd18 R08: 0000000000000000 R09: ffff880138d34000</span>
<span class="quote">&gt; &gt;&gt;     [61163.590097] R10: ffffea0004650000 R11: 0000000000c363b0 R12: ffffea0011943800</span>
<span class="quote">&gt; &gt;&gt;     [61163.590751] R13: ffff8801b8d34000 R14: ffffea0000000000 R15: 000077ff80000000</span>
<span class="quote">&gt; &gt;&gt;     [61163.591375] FS:  00007fc977710740(0000) GS:ffff88007dc00000(0000) knlGS:0000000000000000</span>
<span class="quote">&gt; &gt;&gt;     [61163.592068] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033</span>
<span class="quote">&gt; &gt;&gt;     [61163.592627] CR2: ffffea0011943820 CR3: 000000007a746000 CR4: 00000000001406f0</span>
<span class="quote">&gt; &gt;&gt;     [61163.593330] Call Trace:</span>
<span class="quote">&gt; &gt;&gt;     [61163.593556]  follow_page_mask+0x270/0x550</span>
<span class="quote">&gt; &gt;&gt;     [61163.593908]  SYSC_move_pages+0x4ea/0x8f0</span>
<span class="quote">&gt; &gt;&gt;     [61163.594253]  ? lru_cache_add_active_or_unevictable+0x4b/0xd0</span>
<span class="quote">&gt; &gt;&gt;     [61163.594798]  SyS_move_pages+0xe/0x10</span>
<span class="quote">&gt; &gt;&gt;     [61163.595113]  do_syscall_64+0x67/0x180</span>
<span class="quote">&gt; &gt;&gt;     [61163.595434]  entry_SYSCALL64_slow_path+0x25/0x25</span>
<span class="quote">&gt; &gt;&gt;     [61163.595837] RIP: 0033:0x7fc976e03949</span>
<span class="quote">&gt; &gt;&gt;     [61163.596148] RSP: 002b:00007ffe72221d88 EFLAGS: 00000246 ORIG_RAX: 0000000000000117</span>
<span class="quote">&gt; &gt;&gt;     [61163.596940] RAX: ffffffffffffffda RBX: 0000000000000000 RCX: 00007fc976e03949</span>
<span class="quote">&gt; &gt;&gt;     [61163.597567] RDX: 0000000000c22390 RSI: 0000000000001400 RDI: 0000000000005827</span>
<span class="quote">&gt; &gt;&gt;     [61163.598177] RBP: 00007ffe72221e00 R08: 0000000000c2c3a0 R09: 0000000000000004</span>
<span class="quote">&gt; &gt;&gt;     [61163.598842] R10: 0000000000c363b0 R11: 0000000000000246 R12: 0000000000400650</span>
<span class="quote">&gt; &gt;&gt;     [61163.599456] R13: 00007ffe72221ee0 R14: 0000000000000000 R15: 0000000000000000</span>
<span class="quote">&gt; &gt;&gt;     [61163.600067] Code: 81 e4 ff ff 1f 00 48 21 c2 49 c1 ec 0c 48 c1 ea 0c 4c 01 e2 49 bc 00 00 00 00 00 ea ff ff 48 c1 e2 06 49 01 d4 f6 45 bc 04 74 90 &lt;49&gt; 8b 7c 24 20 40 f6 c7 01 75 2b 4c 89 e7 8b 47 1c 85 c0 7e 2a</span>
<span class="quote">&gt; &gt;&gt;     [61163.601845] RIP: follow_huge_pmd+0x143/0x190 RSP: ffffc90004bdbcd0</span>
<span class="quote">&gt; &gt;&gt;     [61163.602376] CR2: ffffea0011943820</span>
<span class="quote">&gt; &gt;&gt;     [61163.602767] ---[ end trace e4f81353a2d23232 ]---</span>
<span class="quote">&gt; &gt;&gt;     [61163.603236] Kernel panic - not syncing: Fatal exception</span>
<span class="quote">&gt; &gt;&gt;     [61163.603706] Kernel Offset: disabled</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; This bug is triggered when pmd_present() returns true for non-present</span>
<span class="quote">&gt; &gt;&gt; hugetlb, so fixing the present check in follow_huge_pmd() prevents it.</span>
<span class="quote">&gt; &gt;&gt; Using pmd_present() to determine present/non-present for hugetlb is</span>
<span class="quote">&gt; &gt;&gt; not correct, because pmd_present() checks multiple bits (not only</span>
<span class="quote">&gt; &gt;&gt; _PAGE_PRESENT) for historical reason and it can misjudge hugetlb state.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Fixes: e66f17ff7177 (&quot;mm/hugetlb: take page table lock in follow_huge_pmd()&quot;)</span>
<span class="quote">&gt; &gt;&gt; Signed-off-by: Naoya Horiguchi &lt;n-horiguchi@ah.jp.nec.com&gt;</span>
<span class="quote">&gt; &gt;&gt; Cc: &lt;stable@vger.kernel.org&gt;        [4.0+]</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I think this is broken for s390. The page table entries look different from</span>
<span class="quote">&gt; &gt; the segment table entries (pmds) on s390, e.g. they have the invalid bit at</span>
<span class="quote">&gt; &gt; different places. Using pte functions on pmd does not work here.</span>
<span class="quote">&gt; &gt; Gerald can you confirm.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmmm, it looks like that the s390 variant of huge_ptep_get already</span>
<span class="quote">&gt; does the translation. So its probably fine.</span>

Thank you for checking. I think so, generic hugetlb code should refer to
leaf level page table entries with &#39;pte&#39; even if it&#39;s actually pmd or pud.
The detail of arch-dependency is contained in huge_ptep_get() as you pointed out.

- Naoya
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="p_header">index 3d0aab9..f501f14 100644</span>
<span class="p_header">--- v4.11-rc2-mmotm-2017-03-17-15-26/mm/hugetlb.c</span>
<span class="p_header">+++ v4.11-rc2-mmotm-2017-03-17-15-26_patched/mm/hugetlb.c</span>
<span class="p_chunk">@@ -4651,6 +4651,7 @@</span> <span class="p_context"> follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
 {
 	struct page *page = NULL;
 	spinlock_t *ptl;
<span class="p_add">+	pte_t pte;</span>
 retry:
 	ptl = pmd_lockptr(mm, pmd);
 	spin_lock(ptl);
<span class="p_chunk">@@ -4660,12 +4661,13 @@</span> <span class="p_context"> follow_huge_pmd(struct mm_struct *mm, unsigned long address,</span>
 	 */
 	if (!pmd_huge(*pmd))
 		goto out;
<span class="p_del">-	if (pmd_present(*pmd)) {</span>
<span class="p_add">+	pte = huge_ptep_get((pte_t *)pmd);</span>
<span class="p_add">+	if (pte_present(pte)) {</span>
 		page = pmd_page(*pmd) + ((address &amp; ~PMD_MASK) &gt;&gt; PAGE_SHIFT);
 		if (flags &amp; FOLL_GET)
 			get_page(page);
 	} else {
<span class="p_del">-		if (is_hugetlb_entry_migration(huge_ptep_get((pte_t *)pmd))) {</span>
<span class="p_add">+		if (is_hugetlb_entry_migration(pte)) {</span>
 			spin_unlock(ptl);
 			__migration_entry_wait(mm, (pte_t *)pmd, ptl);
 			goto retry;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



