
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.34 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.34</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 24, 2017, 5:17 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170624051731.GB28367@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9807599/mbox/"
   >mbox</a>
|
   <a href="/patch/9807599/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9807599/">/patch/9807599/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	27D0460382 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 24 Jun 2017 05:17:48 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 07B6128555
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 24 Jun 2017 05:17:48 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id F02E928583; Sat, 24 Jun 2017 05:17:47 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id EA04528555
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 24 Jun 2017 05:17:43 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751319AbdFXFRm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 24 Jun 2017 01:17:42 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:45394 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751281AbdFXFRj (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 24 Jun 2017 01:17:39 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 9B10C49F;
	Sat, 24 Jun 2017 05:17:37 +0000 (UTC)
Date: Sat, 24 Jun 2017 07:17:31 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.34
Message-ID: &lt;20170624051731.GB28367@kroah.com&gt;
References: &lt;20170624051724.GA28367@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170624051724.GA28367@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 24, 2017, 5:17 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index a6fadef92d6d..86a6746f6833 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -3932,6 +3932,13 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 	spia_pedr=
 	spia_peddr=
 
<span class="p_add">+	stack_guard_gap=	[MM]</span>
<span class="p_add">+			override the default stack gap protection. The value</span>
<span class="p_add">+			is in page units and it defines how many pages prior</span>
<span class="p_add">+			to (for stacks growing down) resp. after (for stacks</span>
<span class="p_add">+			growing up) the main stack are reserved for no other</span>
<span class="p_add">+			mapping. Default value is 256 pages.</span>
<span class="p_add">+</span>
 	stacktrace	[FTRACE]
 			Enabled the stack tracer on boot up.
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 8470d81d5cc2..a40b373eba3a 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 33</span>
<span class="p_add">+SUBLEVEL = 34</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arc/mm/mmap.c b/arch/arc/mm/mmap.c</span>
<span class="p_header">index 2e06d56e987b..cf4ae6958240 100644</span>
<span class="p_header">--- a/arch/arc/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arc/mm/mmap.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/arm/mm/mmap.c b/arch/arm/mm/mmap.c</span>
<span class="p_header">index 66353caa35b9..641334ebf46d 100644</span>
<span class="p_header">--- a/arch/arm/mm/mmap.c</span>
<span class="p_header">+++ b/arch/arm/mm/mmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/frv/mm/elf-fdpic.c b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">index 836f14707a62..efa59f1f8022 100644</span>
<span class="p_header">--- a/arch/frv/mm/elf-fdpic.c</span>
<span class="p_header">+++ b/arch/frv/mm/elf-fdpic.c</span>
<span class="p_chunk">@@ -74,7 +74,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(current-&gt;mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			goto success;
 	}
 
<span class="p_header">diff --git a/arch/mips/boot/Makefile b/arch/mips/boot/Makefile</span>
<span class="p_header">index 2728a9a9c7c5..145b5ce8eb7e 100644</span>
<span class="p_header">--- a/arch/mips/boot/Makefile</span>
<span class="p_header">+++ b/arch/mips/boot/Makefile</span>
<span class="p_chunk">@@ -128,19 +128,19 @@</span> <span class="p_context"> quiet_cmd_cpp_its_S = ITS     $@</span>
 			-DADDR_BITS=$(ADDR_BITS) \
 			-DADDR_CELLS=$(itb_addr_cells)
 
<span class="p_del">-$(obj)/vmlinux.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,none,vmlinux.bin)
 
<span class="p_del">-$(obj)/vmlinux.gz.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.gz.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,gzip,vmlinux.bin.gz)
 
<span class="p_del">-$(obj)/vmlinux.bz2.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.bz2.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX)  FORCE</span>
 	$(call if_changed_dep,cpp_its_S,bzip2,vmlinux.bin.bz2)
 
<span class="p_del">-$(obj)/vmlinux.lzma.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.lzma.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,lzma,vmlinux.bin.lzma)
 
<span class="p_del">-$(obj)/vmlinux.lzo.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S FORCE</span>
<span class="p_add">+$(obj)/vmlinux.lzo.its: $(srctree)/arch/mips/$(PLATFORM)/vmlinux.its.S $(VMLINUX) FORCE</span>
 	$(call if_changed_dep,cpp_its_S,lzo,vmlinux.bin.lzo)
 
 quiet_cmd_itb-image = ITB     $@
<span class="p_header">diff --git a/arch/mips/kernel/branch.c b/arch/mips/kernel/branch.c</span>
<span class="p_header">index 12c718181e5e..c86b66b57fc6 100644</span>
<span class="p_header">--- a/arch/mips/kernel/branch.c</span>
<span class="p_header">+++ b/arch/mips/kernel/branch.c</span>
<span class="p_chunk">@@ -804,8 +804,10 @@</span> <span class="p_context"> int __compute_return_epc_for_insn(struct pt_regs *regs,</span>
 			break;
 		}
 		/* Compact branch: BNEZC || JIALC */
<span class="p_del">-		if (insn.i_format.rs)</span>
<span class="p_add">+		if (!insn.i_format.rs) {</span>
<span class="p_add">+			/* JIALC: set $31/ra */</span>
 			regs-&gt;regs[31] = epc + 4;
<span class="p_add">+		}</span>
 		regs-&gt;cp0_epc += 8;
 		break;
 #endif
<span class="p_header">diff --git a/arch/mips/mm/mmap.c b/arch/mips/mm/mmap.c</span>
<span class="p_header">index d08ea3ff0f53..a44052c05f93 100644</span>
<span class="p_header">--- a/arch/mips/mm/mmap.c</span>
<span class="p_header">+++ b/arch/mips/mm/mmap.c</span>
<span class="p_chunk">@@ -92,7 +92,7 @@</span> <span class="p_context"> static unsigned long arch_get_unmapped_area_common(struct file *filp,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">index 0a393a04e891..1d7691fa8ab2 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	unsigned long task_size = TASK_SIZE;
 	int do_color_align, last_mmap;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -115,9 +115,10 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		else
 			addr = PAGE_ALIGN(addr);
 
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_chunk">@@ -141,7 +142,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	int do_color_align, last_mmap;
<span class="p_chunk">@@ -175,9 +176,11 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			addr = COLOR_ALIGN(addr, last_mmap, pgoff);
 		else
 			addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			goto found_addr;
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/hugetlbpage-radix.c b/arch/powerpc/mm/hugetlbpage-radix.c</span>
<span class="p_header">index 35254a678456..a2b2d97f7eda 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hugetlbpage-radix.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hugetlbpage-radix.c</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> radix__hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	/*
<span class="p_header">diff --git a/arch/powerpc/mm/mmap.c b/arch/powerpc/mm/mmap.c</span>
<span class="p_header">index 2f1e44362198..5bc2845cddf4 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/mmap.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/mmap.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> radix__arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> radix__arch_get_unmapped_area_topdown(struct file *filp,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/powerpc/mm/slice.c b/arch/powerpc/mm/slice.c</span>
<span class="p_header">index 2b27458902ee..c4d5c9c61e0f 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/slice.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/slice.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int slice_area_is_free(struct mm_struct *mm, unsigned long addr,</span>
 	if ((mm-&gt;task_size - len) &lt; addr)
 		return 0;
 	vma = find_vma(mm, addr);
<span class="p_del">-	return (!vma || (addr + len) &lt;= vma-&gt;vm_start);</span>
<span class="p_add">+	return (!vma || (addr + len) &lt;= vm_start_gap(vma));</span>
 }
 
 static int slice_low_has_vma(struct mm_struct *mm, unsigned long slice)
<span class="p_header">diff --git a/arch/s390/mm/mmap.c b/arch/s390/mm/mmap.c</span>
<span class="p_header">index eb9df2822da1..812368f274c9 100644</span>
<span class="p_header">--- a/arch/s390/mm/mmap.c</span>
<span class="p_header">+++ b/arch/s390/mm/mmap.c</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sh/mm/mmap.c b/arch/sh/mm/mmap.c</span>
<span class="p_header">index 6777177807c2..7df7d5944188 100644</span>
<span class="p_header">--- a/arch/sh/mm/mmap.c</span>
<span class="p_header">+++ b/arch/sh/mm/mmap.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/kernel/sys_sparc_64.c b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">index fe8b8ee8e660..02e05e221b94 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sys_sparc_64.c</span>
<span class="p_chunk">@@ -118,7 +118,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr, unsi</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/sparc/mm/hugetlbpage.c b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">index 988acc8b1b80..58cde8d9be8a 100644</span>
<span class="p_header">--- a/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, HPAGE_SIZE);
 		vma = find_vma(mm, addr);
 		if (task_size - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/tile/mm/hugetlbpage.c b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">index 77ceaa343fce..67508b249ede 100644</span>
<span class="p_header">--- a/arch/tile/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/tile/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -232,7 +232,7 @@</span> <span class="p_context"> unsigned long hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (current-&gt;mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/kernel/sys_x86_64.c b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">index a55ed63b9f91..1119414ab419 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_chunk">@@ -140,7 +140,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (end - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -183,7 +183,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 		addr = PAGE_ALIGN(addr);
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/arch/x86/mm/hugetlbpage.c b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">index 2ae8584b44c7..fe342e8ed529 100644</span>
<span class="p_header">--- a/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
<span class="p_header">diff --git a/arch/x86/mm/numa_32.c b/arch/x86/mm/numa_32.c</span>
<span class="p_header">index 6b7ce6279133..aca6295350f3 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa_32.c</span>
<span class="p_chunk">@@ -100,5 +100,6 @@</span> <span class="p_context"> void __init initmem_init(void)</span>
 	printk(KERN_DEBUG &quot;High memory starts at vaddr %08lx\n&quot;,
 			(ulong) pfn_to_kaddr(highstart_pfn));
 
<span class="p_add">+	__vmalloc_start_set = true;</span>
 	setup_bootmem_allocator();
 }
<span class="p_header">diff --git a/arch/xtensa/kernel/syscall.c b/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">index 83cf49685373..3aaaae18417c 100644</span>
<span class="p_header">--- a/arch/xtensa/kernel/syscall.c</span>
<span class="p_header">+++ b/arch/xtensa/kernel/syscall.c</span>
<span class="p_chunk">@@ -87,7 +87,7 @@</span> <span class="p_context"> unsigned long arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		/* At this point:  (!vmm || addr &lt; vmm-&gt;vm_end). */
 		if (TASK_SIZE - len &lt; addr)
 			return -ENOMEM;
<span class="p_del">-		if (!vmm || addr + len &lt;= vmm-&gt;vm_start)</span>
<span class="p_add">+		if (!vmm || addr + len &lt;= vm_start_gap(vmm))</span>
 			return addr;
 		addr = vmm-&gt;vm_end;
 		if (flags &amp; MAP_SHARED)
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 946025a7413b..84eca4f93b82 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -295,6 +295,8 @@</span> <span class="p_context"> static int tpm_ibmvtpm_remove(struct vio_dev *vdev)</span>
 	}
 
 	kfree(ibmvtpm);
<span class="p_add">+	/* For tpm_ibmvtpm_get_desired_dma */</span>
<span class="p_add">+	dev_set_drvdata(&amp;vdev-&gt;dev, NULL);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -309,13 +311,16 @@</span> <span class="p_context"> static int tpm_ibmvtpm_remove(struct vio_dev *vdev)</span>
 static unsigned long tpm_ibmvtpm_get_desired_dma(struct vio_dev *vdev)
 {
 	struct tpm_chip *chip = dev_get_drvdata(&amp;vdev-&gt;dev);
<span class="p_del">-	struct ibmvtpm_dev *ibmvtpm = dev_get_drvdata(&amp;chip-&gt;dev);</span>
<span class="p_add">+	struct ibmvtpm_dev *ibmvtpm;</span>
 
<span class="p_del">-	/* ibmvtpm initializes at probe time, so the data we are</span>
<span class="p_del">-	* asking for may not be set yet. Estimate that 4K required</span>
<span class="p_del">-	* for TCE-mapped buffer in addition to CRQ.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	if (!ibmvtpm)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * ibmvtpm initializes at probe time, so the data we are</span>
<span class="p_add">+	 * asking for may not be set yet. Estimate that 4K required</span>
<span class="p_add">+	 * for TCE-mapped buffer in addition to CRQ.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (chip)</span>
<span class="p_add">+		ibmvtpm = dev_get_drvdata(&amp;chip-&gt;dev);</span>
<span class="p_add">+	else</span>
 		return CRQ_RES_BUF_SIZE + PAGE_SIZE;
 
 	return CRQ_RES_BUF_SIZE + ibmvtpm-&gt;rtce_size;
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq_conservative.c b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">index 13475890d792..00a74351f623 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq_conservative.c</span>
<span class="p_chunk">@@ -169,8 +169,8 @@</span> <span class="p_context"> static ssize_t store_down_threshold(struct gov_attr_set *attr_set,</span>
 	int ret;
 	ret = sscanf(buf, &quot;%u&quot;, &amp;input);
 
<span class="p_del">-	/* cannot be lower than 11 otherwise freq will not fall */</span>
<span class="p_del">-	if (ret != 1 || input &lt; 11 || input &gt; 100 ||</span>
<span class="p_add">+	/* cannot be lower than 1 otherwise freq will not fall */</span>
<span class="p_add">+	if (ret != 1 || input &lt; 1 || input &gt; 100 ||</span>
 			input &gt;= dbs_data-&gt;up_threshold)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">index 42448c7c5ff5..db9b79a8b160 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v10_0.c</span>
<span class="p_chunk">@@ -1290,8 +1290,11 @@</span> <span class="p_context"> static void dce_v10_0_program_watermarks(struct amdgpu_device *adev,</span>
 	u32 tmp, wm_mask, lb_vblank_lead_lines = 0;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 
 		/* watermark for high clocks */
 		if (adev-&gt;pm.dpm_enabled) {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">index 904dabdc3a1e..36d5128a2aad 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v11_0.c</span>
<span class="p_chunk">@@ -1257,8 +1257,11 @@</span> <span class="p_context"> static void dce_v11_0_program_watermarks(struct amdgpu_device *adev,</span>
 	u32 tmp, wm_mask, lb_vblank_lead_lines = 0;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 
 		/* watermark for high clocks */
 		if (adev-&gt;pm.dpm_enabled) {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c</span>
<span class="p_header">index 6d02bdb25d98..75689a2c2de6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v6_0.c</span>
<span class="p_chunk">@@ -1054,8 +1054,11 @@</span> <span class="p_context"> static void dce_v6_0_program_watermarks(struct amdgpu_device *adev,</span>
 	fixed20_12 a, b, c;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 		priority_a_cnt = 0;
 		priority_b_cnt = 0;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">index b1fb60107cfa..ba2321ea800e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c</span>
<span class="p_chunk">@@ -1211,8 +1211,11 @@</span> <span class="p_context"> static void dce_v8_0_program_watermarks(struct amdgpu_device *adev,</span>
 	u32 tmp, wm_mask, lb_vblank_lead_lines = 0;
 
 	if (amdgpu_crtc-&gt;base.enabled &amp;&amp; num_heads &amp;&amp; mode) {
<span class="p_del">-		active_time = 1000000UL * (u32)mode-&gt;crtc_hdisplay / (u32)mode-&gt;clock;</span>
<span class="p_del">-		line_time = min((u32) (1000000UL * (u32)mode-&gt;crtc_htotal / (u32)mode-&gt;clock), (u32)65535);</span>
<span class="p_add">+		active_time = (u32) div_u64((u64)mode-&gt;crtc_hdisplay * 1000000,</span>
<span class="p_add">+					    (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = (u32) div_u64((u64)mode-&gt;crtc_htotal * 1000000,</span>
<span class="p_add">+					  (u32)mode-&gt;clock);</span>
<span class="p_add">+		line_time = min(line_time, (u32)65535);</span>
 
 		/* watermark for high clocks */
 		if (adev-&gt;pm.dpm_enabled) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_pvinfo.h b/drivers/gpu/drm/i915/i915_pvinfo.h</span>
<span class="p_header">index c0cb2974caac..2cfe96d3e5d1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_pvinfo.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_pvinfo.h</span>
<span class="p_chunk">@@ -36,10 +36,6 @@</span> <span class="p_context"></span>
 #define VGT_VERSION_MAJOR 1
 #define VGT_VERSION_MINOR 0
 
<span class="p_del">-#define INTEL_VGT_IF_VERSION_ENCODE(major, minor) ((major) &lt;&lt; 16 | (minor))</span>
<span class="p_del">-#define INTEL_VGT_IF_VERSION \</span>
<span class="p_del">-	INTEL_VGT_IF_VERSION_ENCODE(VGT_VERSION_MAJOR, VGT_VERSION_MINOR)</span>
<span class="p_del">-</span>
 /*
  * notifications from guest to vgpu device model
  */
<span class="p_chunk">@@ -55,8 +51,8 @@</span> <span class="p_context"> enum vgt_g2v_type {</span>
 
 struct vgt_if {
 	u64 magic;		/* VGT_MAGIC */
<span class="p_del">-	uint16_t version_major;</span>
<span class="p_del">-	uint16_t version_minor;</span>
<span class="p_add">+	u16 version_major;</span>
<span class="p_add">+	u16 version_minor;</span>
 	u32 vgt_id;		/* ID of vGT instance */
 	u32 rsv1[12];		/* pad to offset 0x40 */
 	/*
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_vgpu.c b/drivers/gpu/drm/i915/i915_vgpu.c</span>
<span class="p_header">index dae340cfc6c7..125adcc6d6ca 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_vgpu.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_vgpu.c</span>
<span class="p_chunk">@@ -60,8 +60,8 @@</span> <span class="p_context"></span>
  */
 void i915_check_vgpu(struct drm_i915_private *dev_priv)
 {
<span class="p_del">-	uint64_t magic;</span>
<span class="p_del">-	uint32_t version;</span>
<span class="p_add">+	u64 magic;</span>
<span class="p_add">+	u16 version_major;</span>
 
 	BUILD_BUG_ON(sizeof(struct vgt_if) != VGT_PVINFO_SIZE);
 
<span class="p_chunk">@@ -69,10 +69,8 @@</span> <span class="p_context"> void i915_check_vgpu(struct drm_i915_private *dev_priv)</span>
 	if (magic != VGT_MAGIC)
 		return;
 
<span class="p_del">-	version = INTEL_VGT_IF_VERSION_ENCODE(</span>
<span class="p_del">-		__raw_i915_read16(dev_priv, vgtif_reg(version_major)),</span>
<span class="p_del">-		__raw_i915_read16(dev_priv, vgtif_reg(version_minor)));</span>
<span class="p_del">-	if (version != INTEL_VGT_IF_VERSION) {</span>
<span class="p_add">+	version_major = __raw_i915_read16(dev_priv, vgtif_reg(version_major));</span>
<span class="p_add">+	if (version_major &lt; VGT_VERSION_MAJOR) {</span>
 		DRM_INFO(&quot;VGT interface version mismatch!\n&quot;);
 		return;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/mediatek/mtk_hdmi.c b/drivers/gpu/drm/mediatek/mtk_hdmi.c</span>
<span class="p_header">index 0e8c4d9af340..e097780752f6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/mediatek/mtk_hdmi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/mediatek/mtk_hdmi.c</span>
<span class="p_chunk">@@ -1061,7 +1061,7 @@</span> <span class="p_context"> static int mtk_hdmi_setup_vendor_specific_infoframe(struct mtk_hdmi *hdmi,</span>
 	}
 
 	err = hdmi_vendor_infoframe_pack(&amp;frame, buffer, sizeof(buffer));
<span class="p_del">-	if (err) {</span>
<span class="p_add">+	if (err &lt; 0) {</span>
 		dev_err(hdmi-&gt;dev, &quot;Failed to pack vendor infoframe: %zd\n&quot;,
 			err);
 		return err;
<span class="p_header">diff --git a/drivers/gpu/drm/vc4/vc4_bo.c b/drivers/gpu/drm/vc4/vc4_bo.c</span>
<span class="p_header">index 3f6704cf6608..ec9023bd935b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vc4/vc4_bo.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vc4/vc4_bo.c</span>
<span class="p_chunk">@@ -313,6 +313,14 @@</span> <span class="p_context"> void vc4_free_object(struct drm_gem_object *gem_bo)</span>
 		goto out;
 	}
 
<span class="p_add">+	/* If this object was partially constructed but CMA allocation</span>
<span class="p_add">+	 * had failed, just free it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!bo-&gt;base.vaddr) {</span>
<span class="p_add">+		vc4_bo_destroy(bo);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	cache_list = vc4_get_cache_list_for_size(dev, gem_bo-&gt;size);
 	if (!cache_list) {
 		vc4_bo_destroy(bo);
<span class="p_header">diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">index 2de1f52f1b19..62b0dec6d777 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_chunk">@@ -484,7 +484,7 @@</span> <span class="p_context"> static int tiadc_probe(struct platform_device *pdev)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	indio_dev = devm_iio_device_alloc(&amp;pdev-&gt;dev, sizeof(*indio_dev));</span>
<span class="p_add">+	indio_dev = devm_iio_device_alloc(&amp;pdev-&gt;dev, sizeof(*adc_dev));</span>
 	if (indio_dev == NULL) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to allocate iio device\n&quot;);
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">index b9fcbf18aa99..5faea370ab57 100644</span>
<span class="p_header">--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"> static const int accel_scale[] = {598, 1196, 2392, 4785};</span>
 static const struct inv_mpu6050_reg_map reg_set_6500 = {
 	.sample_rate_div	= INV_MPU6050_REG_SAMPLE_RATE_DIV,
 	.lpf                    = INV_MPU6050_REG_CONFIG,
<span class="p_add">+	.accel_lpf              = INV_MPU6500_REG_ACCEL_CONFIG_2,</span>
 	.user_ctrl              = INV_MPU6050_REG_USER_CTRL,
 	.fifo_en                = INV_MPU6050_REG_FIFO_EN,
 	.gyro_config            = INV_MPU6050_REG_GYRO_CONFIG,
<span class="p_chunk">@@ -205,6 +206,37 @@</span> <span class="p_context"> int inv_mpu6050_set_power_itg(struct inv_mpu6050_state *st, bool power_on)</span>
 EXPORT_SYMBOL_GPL(inv_mpu6050_set_power_itg);
 
 /**
<span class="p_add">+ *  inv_mpu6050_set_lpf_regs() - set low pass filter registers, chip dependent</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  MPU60xx/MPU9150 use only 1 register for accelerometer + gyroscope</span>
<span class="p_add">+ *  MPU6500 and above have a dedicated register for accelerometer</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int inv_mpu6050_set_lpf_regs(struct inv_mpu6050_state *st,</span>
<span class="p_add">+				    enum inv_mpu6050_filter_e val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int result;</span>
<span class="p_add">+</span>
<span class="p_add">+	result = regmap_write(st-&gt;map, st-&gt;reg-&gt;lpf, val);</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		return result;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (st-&gt;chip_type) {</span>
<span class="p_add">+	case INV_MPU6050:</span>
<span class="p_add">+	case INV_MPU6000:</span>
<span class="p_add">+	case INV_MPU9150:</span>
<span class="p_add">+		/* old chips, nothing to do */</span>
<span class="p_add">+		result = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		/* set accel lpf */</span>
<span class="p_add">+		result = regmap_write(st-&gt;map, st-&gt;reg-&gt;accel_lpf, val);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  *  inv_mpu6050_init_config() - Initialize hardware, disable FIFO.
  *
  *  Initial configuration:
<span class="p_chunk">@@ -227,8 +259,7 @@</span> <span class="p_context"> static int inv_mpu6050_init_config(struct iio_dev *indio_dev)</span>
 	if (result)
 		return result;
 
<span class="p_del">-	d = INV_MPU6050_FILTER_20HZ;</span>
<span class="p_del">-	result = regmap_write(st-&gt;map, st-&gt;reg-&gt;lpf, d);</span>
<span class="p_add">+	result = inv_mpu6050_set_lpf_regs(st, INV_MPU6050_FILTER_20HZ);</span>
 	if (result)
 		return result;
 
<span class="p_chunk">@@ -531,6 +562,8 @@</span> <span class="p_context"> static int inv_mpu6050_write_raw(struct iio_dev *indio_dev,</span>
  *                  would be alising. This function basically search for the
  *                  correct low pass parameters based on the fifo rate, e.g,
  *                  sampling frequency.
<span class="p_add">+ *</span>
<span class="p_add">+ *  lpf is set automatically when setting sampling rate to avoid any aliases.</span>
  */
 static int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)
 {
<span class="p_chunk">@@ -546,7 +579,7 @@</span> <span class="p_context"> static int inv_mpu6050_set_lpf(struct inv_mpu6050_state *st, int rate)</span>
 	while ((h &lt; hz[i]) &amp;&amp; (i &lt; ARRAY_SIZE(d) - 1))
 		i++;
 	data = d[i];
<span class="p_del">-	result = regmap_write(st-&gt;map, st-&gt;reg-&gt;lpf, data);</span>
<span class="p_add">+	result = inv_mpu6050_set_lpf_regs(st, data);</span>
 	if (result)
 		return result;
 	st-&gt;chip_config.lpf = data;
<span class="p_header">diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h b/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h</span>
<span class="p_header">index f0e8c5dd9fae..d851581bb0b8 100644</span>
<span class="p_header">--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h</span>
<span class="p_header">+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_iio.h</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"></span>
  *  struct inv_mpu6050_reg_map - Notable registers.
  *  @sample_rate_div:	Divider applied to gyro output rate.
  *  @lpf:		Configures internal low pass filter.
<span class="p_add">+ *  @accel_lpf:		Configures accelerometer low pass filter.</span>
  *  @user_ctrl:		Enables/resets the FIFO.
  *  @fifo_en:		Determines which data will appear in FIFO.
  *  @gyro_config:	gyro config register.
<span class="p_chunk">@@ -47,6 +48,7 @@</span> <span class="p_context"></span>
 struct inv_mpu6050_reg_map {
 	u8 sample_rate_div;
 	u8 lpf;
<span class="p_add">+	u8 accel_lpf;</span>
 	u8 user_ctrl;
 	u8 fifo_en;
 	u8 gyro_config;
<span class="p_chunk">@@ -187,6 +189,7 @@</span> <span class="p_context"> struct inv_mpu6050_state {</span>
 #define INV_MPU6050_FIFO_THRESHOLD           500
 
 /* mpu6500 registers */
<span class="p_add">+#define INV_MPU6500_REG_ACCEL_CONFIG_2      0x1D</span>
 #define INV_MPU6500_REG_ACCEL_OFFSET        0x77
 
 /* delay time in milliseconds */
<span class="p_header">diff --git a/drivers/iio/pressure/st_pressure_core.c b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">index 55df9a75eb3a..44e46c159a7e 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_chunk">@@ -227,7 +227,7 @@</span> <span class="p_context"> static const struct iio_chan_spec st_press_1_channels[] = {</span>
 		.address = ST_PRESS_1_OUT_XL_ADDR,
 		.scan_index = 0,
 		.scan_type = {
<span class="p_del">-			.sign = &#39;u&#39;,</span>
<span class="p_add">+			.sign = &#39;s&#39;,</span>
 			.realbits = 24,
 			.storagebits = 32,
 			.endianness = IIO_LE,
<span class="p_chunk">@@ -240,7 +240,7 @@</span> <span class="p_context"> static const struct iio_chan_spec st_press_1_channels[] = {</span>
 		.address = ST_TEMP_1_OUT_L_ADDR,
 		.scan_index = 1,
 		.scan_type = {
<span class="p_del">-			.sign = &#39;u&#39;,</span>
<span class="p_add">+			.sign = &#39;s&#39;,</span>
 			.realbits = 16,
 			.storagebits = 16,
 			.endianness = IIO_LE,
<span class="p_chunk">@@ -259,7 +259,7 @@</span> <span class="p_context"> static const struct iio_chan_spec st_press_lps001wp_channels[] = {</span>
 		.address = ST_PRESS_LPS001WP_OUT_L_ADDR,
 		.scan_index = 0,
 		.scan_type = {
<span class="p_del">-			.sign = &#39;u&#39;,</span>
<span class="p_add">+			.sign = &#39;s&#39;,</span>
 			.realbits = 16,
 			.storagebits = 16,
 			.endianness = IIO_LE,
<span class="p_chunk">@@ -273,7 +273,7 @@</span> <span class="p_context"> static const struct iio_chan_spec st_press_lps001wp_channels[] = {</span>
 		.address = ST_TEMP_LPS001WP_OUT_L_ADDR,
 		.scan_index = 1,
 		.scan_type = {
<span class="p_del">-			.sign = &#39;u&#39;,</span>
<span class="p_add">+			.sign = &#39;s&#39;,</span>
 			.realbits = 16,
 			.storagebits = 16,
 			.endianness = IIO_LE,
<span class="p_chunk">@@ -291,7 +291,7 @@</span> <span class="p_context"> static const struct iio_chan_spec st_press_lps22hb_channels[] = {</span>
 		.address = ST_PRESS_1_OUT_XL_ADDR,
 		.scan_index = 0,
 		.scan_type = {
<span class="p_del">-			.sign = &#39;u&#39;,</span>
<span class="p_add">+			.sign = &#39;s&#39;,</span>
 			.realbits = 24,
 			.storagebits = 32,
 			.endianness = IIO_LE,
<span class="p_header">diff --git a/drivers/iio/proximity/as3935.c b/drivers/iio/proximity/as3935.c</span>
<span class="p_header">index 268210ea4990..24fb54398a3b 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/as3935.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/as3935.c</span>
<span class="p_chunk">@@ -269,8 +269,6 @@</span> <span class="p_context"> static irqreturn_t as3935_interrupt_handler(int irq, void *private)</span>
 
 static void calibrate_as3935(struct as3935_state *st)
 {
<span class="p_del">-	mutex_lock(&amp;st-&gt;lock);</span>
<span class="p_del">-</span>
 	/* mask disturber interrupt bit */
 	as3935_write(st, AS3935_INT, BIT(5));
 
<span class="p_chunk">@@ -280,8 +278,6 @@</span> <span class="p_context"> static void calibrate_as3935(struct as3935_state *st)</span>
 
 	mdelay(2);
 	as3935_write(st, AS3935_TUNE_CAP, (st-&gt;tune_cap / TUNE_CAP_DIV));
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;st-&gt;lock);</span>
 }
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_chunk">@@ -318,6 +314,8 @@</span> <span class="p_context"> static int as3935_resume(struct device *dev)</span>
 	val &amp;= ~AS3935_AFE_PWR_BIT;
 	ret = as3935_write(st, AS3935_AFE_GAIN, val);
 
<span class="p_add">+	calibrate_as3935(st);</span>
<span class="p_add">+</span>
 err_resume:
 	mutex_unlock(&amp;st-&gt;lock);
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index 11bfa27b022c..282c9fb0ba95 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -1105,13 +1105,13 @@</span> <span class="p_context"> static struct ib_ucontext *mlx5_ib_alloc_ucontext(struct ib_device *ibdev,</span>
 	 * pretend we don&#39;t support reading the HCA&#39;s core clock. This is also
 	 * forced by mmap function.
 	 */
<span class="p_del">-	if (PAGE_SIZE &lt;= 4096 &amp;&amp;</span>
<span class="p_del">-	    field_avail(typeof(resp), hca_core_clock_offset, udata-&gt;outlen)) {</span>
<span class="p_del">-		resp.comp_mask |=</span>
<span class="p_del">-			MLX5_IB_ALLOC_UCONTEXT_RESP_MASK_CORE_CLOCK_OFFSET;</span>
<span class="p_del">-		resp.hca_core_clock_offset =</span>
<span class="p_del">-			offsetof(struct mlx5_init_seg, internal_timer_h) %</span>
<span class="p_del">-			PAGE_SIZE;</span>
<span class="p_add">+	if (field_avail(typeof(resp), hca_core_clock_offset, udata-&gt;outlen)) {</span>
<span class="p_add">+		if (PAGE_SIZE &lt;= 4096) {</span>
<span class="p_add">+			resp.comp_mask |=</span>
<span class="p_add">+				MLX5_IB_ALLOC_UCONTEXT_RESP_MASK_CORE_CLOCK_OFFSET;</span>
<span class="p_add">+			resp.hca_core_clock_offset =</span>
<span class="p_add">+				offsetof(struct mlx5_init_seg, internal_timer_h) % PAGE_SIZE;</span>
<span class="p_add">+		}</span>
 		resp.response_length += sizeof(resp.hca_core_clock_offset) +
 					sizeof(resp.reserved2);
 	}
<span class="p_header">diff --git a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">index e1907cd0c3b7..7613d1fee104 100644</span>
<span class="p_header">--- a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">+++ b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_chunk">@@ -123,15 +123,10 @@</span> <span class="p_context"> int pvr2_eeprom_analyze(struct pvr2_hdw *hdw)</span>
 	memset(&amp;tvdata,0,sizeof(tvdata));
 
 	eeprom = pvr2_eeprom_fetch(hdw);
<span class="p_del">-	if (!eeprom) return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	{</span>
<span class="p_del">-		struct i2c_client fake_client;</span>
<span class="p_del">-		/* Newer version expects a useless client interface */</span>
<span class="p_del">-		fake_client.addr = hdw-&gt;eeprom_addr;</span>
<span class="p_del">-		fake_client.adapter = &amp;hdw-&gt;i2c_adap;</span>
<span class="p_del">-		tveeprom_hauppauge_analog(&amp;fake_client,&amp;tvdata,eeprom);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!eeprom)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	tveeprom_hauppauge_analog(NULL, &amp;tvdata, eeprom);</span>
 
 	trace_eeprom(&quot;eeprom assumed v4l tveeprom module&quot;);
 	trace_eeprom(&quot;eeprom direct call results:&quot;);
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 21900202ff83..9ccf7f5e0e2e 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -868,7 +868,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(vb2_core_create_bufs);</span>
 
 void *vb2_plane_vaddr(struct vb2_buffer *vb, unsigned int plane_no)
 {
<span class="p_del">-	if (plane_no &gt; vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
<span class="p_add">+	if (plane_no &gt;= vb-&gt;num_planes || !vb-&gt;planes[plane_no].mem_priv)</span>
 		return NULL;
 
 	return call_ptr_memop(vb, vaddr, vb-&gt;planes[plane_no].mem_priv);
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index 1aa74c4c3ced..9d167c9af2c6 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -377,8 +377,8 @@</span> <span class="p_context"> int omap_tll_init(struct usbhs_omap_platform_data *pdata)</span>
 				 * and use SDR Mode
 				 */
 				reg &amp;= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
<span class="p_del">-					| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF</span>
 					| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
<span class="p_add">+				reg |= OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;</span>
 			} else if (pdata-&gt;port_mode[i] ==
 					OMAP_EHCI_PORT_MODE_HSIC) {
 				/*
<span class="p_header">diff --git a/drivers/misc/c2port/c2port-duramar2150.c b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">index 5484301d57d9..3dc61ea7dc64 100644</span>
<span class="p_header">--- a/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_header">+++ b/drivers/misc/c2port/c2port-duramar2150.c</span>
<span class="p_chunk">@@ -129,8 +129,8 @@</span> <span class="p_context"> static int __init duramar2150_c2port_init(void)</span>
 
 	duramar2150_c2port_dev = c2port_device_register(&quot;uc&quot;,
 					&amp;duramar2150_c2port_ops, NULL);
<span class="p_del">-	if (!duramar2150_c2port_dev) {</span>
<span class="p_del">-		ret = -ENODEV;</span>
<span class="p_add">+	if (IS_ERR(duramar2150_c2port_dev)) {</span>
<span class="p_add">+		ret = PTR_ERR(duramar2150_c2port_dev);</span>
 		goto free_region;
 	}
 
<span class="p_header">diff --git a/drivers/misc/mic/vop/vop_vringh.c b/drivers/misc/mic/vop/vop_vringh.c</span>
<span class="p_header">index 88e45234d527..fed992e2c258 100644</span>
<span class="p_header">--- a/drivers/misc/mic/vop/vop_vringh.c</span>
<span class="p_header">+++ b/drivers/misc/mic/vop/vop_vringh.c</span>
<span class="p_chunk">@@ -292,7 +292,6 @@</span> <span class="p_context"> static int vop_virtio_add_device(struct vop_vdev *vdev,</span>
 	if (ret) {
 		dev_err(vop_dev(vdev), &quot;%s %d err %d\n&quot;,
 			__func__, __LINE__, ret);
<span class="p_del">-		kfree(vdev);</span>
 		return ret;
 	}
 
<span class="p_header">diff --git a/drivers/net/can/usb/gs_usb.c b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">index 7ab24c5262f3..05369dc9dd09 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/gs_usb.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/gs_usb.c</span>
<span class="p_chunk">@@ -265,6 +265,8 @@</span> <span class="p_context"> static int gs_cmd_reset(struct gs_usb *gsusb, struct gs_can *gsdev)</span>
 			     sizeof(*dm),
 			     1000);
 
<span class="p_add">+	kfree(dm);</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/pci.c b/drivers/net/wireless/ath/ath10k/pci.c</span>
<span class="p_header">index 0457e315d336..6063cf439d3d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/pci.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/pci.c</span>
<span class="p_chunk">@@ -1647,6 +1647,8 @@</span> <span class="p_context"> static int ath10k_pci_hif_start(struct ath10k *ar)</span>
 
 	ath10k_dbg(ar, ATH10K_DBG_BOOT, &quot;boot hif start\n&quot;);
 
<span class="p_add">+	napi_enable(&amp;ar-&gt;napi);</span>
<span class="p_add">+</span>
 	ath10k_pci_irq_enable(ar);
 	ath10k_pci_rx_post(ar);
 
<span class="p_chunk">@@ -2531,7 +2533,6 @@</span> <span class="p_context"> static int ath10k_pci_hif_power_up(struct ath10k *ar)</span>
 		ath10k_err(ar, &quot;could not wake up target CPU: %d\n&quot;, ret);
 		goto err_ce;
 	}
<span class="p_del">-	napi_enable(&amp;ar-&gt;napi);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/drivers/staging/iio/light/tsl2x7x_core.c b/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_header">index ea15bc1c300c..197201a70d59 100644</span>
<span class="p_header">--- a/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_chunk">@@ -854,7 +854,7 @@</span> <span class="p_context"> void tsl2x7x_prox_calculate(int *data, int length,</span>
 		tmp = data[i] - statP-&gt;mean;
 		sample_sum += tmp * tmp;
 	}
<span class="p_del">-	statP-&gt;stddev = int_sqrt((long)sample_sum) / length;</span>
<span class="p_add">+	statP-&gt;stddev = int_sqrt((long)sample_sum / length);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_ap.c b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">index 553e8d50352f..6513ace1fce6 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_chunk">@@ -890,7 +890,7 @@</span> <span class="p_context"> int rtw_check_beacon_data(struct adapter *padapter, u8 *pbuf,  int len)</span>
 		return _FAIL;
 
 
<span class="p_del">-	if (len &gt; MAX_IE_SZ)</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; MAX_IE_SZ)</span>
 		return _FAIL;
 
 	pbss_network-&gt;IELength = len;
<span class="p_header">diff --git a/drivers/tty/serial/efm32-uart.c b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">index 195acc868763..5d476916191b 100644</span>
<span class="p_header">--- a/drivers/tty/serial/efm32-uart.c</span>
<span class="p_header">+++ b/drivers/tty/serial/efm32-uart.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #define UARTn_FRAME		0x04
 #define UARTn_FRAME_DATABITS__MASK	0x000f
 #define UARTn_FRAME_DATABITS(n)		((n) - 3)
<span class="p_add">+#define UARTn_FRAME_PARITY__MASK	0x0300</span>
 #define UARTn_FRAME_PARITY_NONE		0x0000
 #define UARTn_FRAME_PARITY_EVEN		0x0200
 #define UARTn_FRAME_PARITY_ODD		0x0300
<span class="p_chunk">@@ -572,12 +573,16 @@</span> <span class="p_context"> static void efm32_uart_console_get_options(struct efm32_uart_port *efm_port,</span>
 			16 * (4 + (clkdiv &gt;&gt; 6)));
 
 	frame = efm32_uart_read32(efm_port, UARTn_FRAME);
<span class="p_del">-	if (frame &amp; UARTn_FRAME_PARITY_ODD)</span>
<span class="p_add">+	switch (frame &amp; UARTn_FRAME_PARITY__MASK) {</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_ODD:</span>
 		*parity = &#39;o&#39;;
<span class="p_del">-	else if (frame &amp; UARTn_FRAME_PARITY_EVEN)</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case UARTn_FRAME_PARITY_EVEN:</span>
 		*parity = &#39;e&#39;;
<span class="p_del">-	else</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
 		*parity = &#39;n&#39;;
<span class="p_add">+	}</span>
 
 	*bits = (frame &amp; UARTn_FRAME_DATABITS__MASK) -
 			UARTn_FRAME_DATABITS(4) + 4;
<span class="p_header">diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">index ee84f89391ca..7e97a1ccab23 100644</span>
<span class="p_header">--- a/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/sh-sci.c</span>
<span class="p_chunk">@@ -2366,6 +2366,10 @@</span> <span class="p_context"> static void sci_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 		 */
 		udelay(DIV_ROUND_UP(10 * 1000000, baud));
 	}
<span class="p_add">+	if (port-&gt;flags &amp; UPF_HARD_FLOW) {</span>
<span class="p_add">+		/* Refresh (Auto) RTS */</span>
<span class="p_add">+		sci_set_mctrl(port, port-&gt;mctrl);</span>
<span class="p_add">+	}</span>
 
 #ifdef CONFIG_SERIAL_SH_SCI_DMA
 	/*
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 3b9735abf2e0..8a7c6bbaed7e 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -2535,6 +2535,7 @@</span> <span class="p_context"> struct usb_hcd *usb_create_shared_hcd(const struct hc_driver *driver,</span>
 		hcd-&gt;bandwidth_mutex = kmalloc(sizeof(*hcd-&gt;bandwidth_mutex),
 				GFP_KERNEL);
 		if (!hcd-&gt;bandwidth_mutex) {
<span class="p_add">+			kfree(hcd-&gt;address0_mutex);</span>
 			kfree(hcd);
 			dev_dbg(dev, &quot;hcd bandwidth mutex alloc failed\n&quot;);
 			return NULL;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 8714b352e57f..f953d6d647f2 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -1334,7 +1334,13 @@</span> <span class="p_context"> static int hub_configure(struct usb_hub *hub,</span>
 	if (ret &lt; 0) {
 		message = &quot;can&#39;t read hub descriptor&quot;;
 		goto fail;
<span class="p_del">-	} else if (hub-&gt;descriptor-&gt;bNbrPorts &gt; USB_MAXCHILDREN) {</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	maxchild = USB_MAXCHILDREN;</span>
<span class="p_add">+	if (hub_is_superspeed(hdev))</span>
<span class="p_add">+		maxchild = min_t(unsigned, maxchild, USB_SS_MAXPORTS);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hub-&gt;descriptor-&gt;bNbrPorts &gt; maxchild) {</span>
 		message = &quot;hub has too many ports!&quot;;
 		ret = -ENODEV;
 		goto fail;
<span class="p_header">diff --git a/drivers/usb/dwc3/dwc3-exynos.c b/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_header">index 2f1fb7e7aa54..9eba51b92f72 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/dwc3-exynos.c</span>
<span class="p_chunk">@@ -148,7 +148,8 @@</span> <span class="p_context"> static int dwc3_exynos_probe(struct platform_device *pdev)</span>
 		exynos-&gt;axius_clk = devm_clk_get(dev, &quot;usbdrd30_axius_clk&quot;);
 		if (IS_ERR(exynos-&gt;axius_clk)) {
 			dev_err(dev, &quot;no AXI UpScaler clk specified\n&quot;);
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto axius_clk_err;</span>
 		}
 		clk_prepare_enable(exynos-&gt;axius_clk);
 	} else {
<span class="p_chunk">@@ -206,6 +207,7 @@</span> <span class="p_context"> static int dwc3_exynos_probe(struct platform_device *pdev)</span>
 	regulator_disable(exynos-&gt;vdd33);
 err2:
 	clk_disable_unprepare(exynos-&gt;axius_clk);
<span class="p_add">+axius_clk_err:</span>
 	clk_disable_unprepare(exynos-&gt;susp_clk);
 	clk_disable_unprepare(exynos-&gt;clk);
 	return ret;
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index c3c5b87b35b3..baa7cdcc0ebc 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -2147,7 +2147,7 @@</span> <span class="p_context"> int composite_os_desc_req_prepare(struct usb_composite_dev *cdev,</span>
 	cdev-&gt;os_desc_req-&gt;buf = kmalloc(4096, GFP_KERNEL);
 	if (!cdev-&gt;os_desc_req-&gt;buf) {
 		ret = -ENOMEM;
<span class="p_del">-		kfree(cdev-&gt;os_desc_req);</span>
<span class="p_add">+		usb_ep_free_request(ep0, cdev-&gt;os_desc_req);</span>
 		goto end;
 	}
 	cdev-&gt;os_desc_req-&gt;context = cdev;
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index 1468d8f085a3..f959c42ecace 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -1183,8 +1183,10 @@</span> <span class="p_context"> dev_release (struct inode *inode, struct file *fd)</span>
 
 	/* closing ep0 === shutdown all */
 
<span class="p_del">-	if (dev-&gt;gadget_registered)</span>
<span class="p_add">+	if (dev-&gt;gadget_registered) {</span>
 		usb_gadget_unregister_driver (&amp;gadgetfs_driver);
<span class="p_add">+		dev-&gt;gadget_registered = false;</span>
<span class="p_add">+	}</span>
 
 	/* at this point &quot;good&quot; hardware has disconnected the
 	 * device from USB; the host won&#39;t see it any more.
<span class="p_chunk">@@ -1677,9 +1679,10 @@</span> <span class="p_context"> static void</span>
 gadgetfs_suspend (struct usb_gadget *gadget)
 {
 	struct dev_data		*dev = get_gadget_data (gadget);
<span class="p_add">+	unsigned long		flags;</span>
 
 	INFO (dev, &quot;suspended from state %d\n&quot;, dev-&gt;state);
<span class="p_del">-	spin_lock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dev-&gt;lock, flags);</span>
 	switch (dev-&gt;state) {
 	case STATE_DEV_SETUP:		// VERY odd... host died??
 	case STATE_DEV_CONNECTED:
<span class="p_chunk">@@ -1690,7 +1693,7 @@</span> <span class="p_context"> gadgetfs_suspend (struct usb_gadget *gadget)</span>
 	default:
 		break;
 	}
<span class="p_del">-	spin_unlock (&amp;dev-&gt;lock);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);</span>
 }
 
 static struct usb_gadget_driver gadgetfs_driver = {
<span class="p_header">diff --git a/drivers/usb/gadget/udc/dummy_hcd.c b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">index 4fa5de2eb501..94c8a9f6cbf1 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/dummy_hcd.c</span>
<span class="p_chunk">@@ -442,23 +442,16 @@</span> <span class="p_context"> static void set_link_state(struct dummy_hcd *dum_hcd)</span>
 		/* Report reset and disconnect events to the driver */
 		if (dum-&gt;driver &amp;&amp; (disconnect || reset)) {
 			stop_activity(dum);
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
 			if (reset)
 				usb_gadget_udc_reset(&amp;dum-&gt;gadget, dum-&gt;driver);
 			else
 				dum-&gt;driver-&gt;disconnect(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
 		}
 	} else if (dum_hcd-&gt;active != dum_hcd-&gt;old_active) {
<span class="p_del">-		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		if (dum_hcd-&gt;old_active &amp;&amp; dum-&gt;driver-&gt;suspend)</span>
 			dum-&gt;driver-&gt;suspend(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		} else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume) {</span>
<span class="p_del">-			spin_unlock(&amp;dum-&gt;lock);</span>
<span class="p_add">+		else if (!dum_hcd-&gt;old_active &amp;&amp;  dum-&gt;driver-&gt;resume)</span>
 			dum-&gt;driver-&gt;resume(&amp;dum-&gt;gadget);
<span class="p_del">-			spin_lock(&amp;dum-&gt;lock);</span>
<span class="p_del">-		}</span>
 	}
 
 	dum_hcd-&gt;old_status = dum_hcd-&gt;port_status;
<span class="p_chunk">@@ -983,7 +976,9 @@</span> <span class="p_context"> static int dummy_udc_stop(struct usb_gadget *g)</span>
 	struct dummy_hcd	*dum_hcd = gadget_to_dummy_hcd(g);
 	struct dummy		*dum = dum_hcd-&gt;dum;
 
<span class="p_add">+	spin_lock_irq(&amp;dum-&gt;lock);</span>
 	dum-&gt;driver = NULL;
<span class="p_add">+	spin_unlock_irq(&amp;dum-&gt;lock);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -2009,7 +2004,7 @@</span> <span class="p_context"> ss_hub_descriptor(struct usb_hub_descriptor *desc)</span>
 			HUB_CHAR_COMMON_OCPM);
 	desc-&gt;bNbrPorts = 1;
 	desc-&gt;u.ss.bHubHdrDecLat = 0x04; /* Worst case: 0.4 micro sec*/
<span class="p_del">-	desc-&gt;u.ss.DeviceRemovable = 0xffff;</span>
<span class="p_add">+	desc-&gt;u.ss.DeviceRemovable = 0;</span>
 }
 
 static inline void hub_descriptor(struct usb_hub_descriptor *desc)
<span class="p_chunk">@@ -2021,8 +2016,8 @@</span> <span class="p_context"> static inline void hub_descriptor(struct usb_hub_descriptor *desc)</span>
 			HUB_CHAR_INDV_PORT_LPSM |
 			HUB_CHAR_COMMON_OCPM);
 	desc-&gt;bNbrPorts = 1;
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[0] = 0xff;</span>
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[0] = 0;</span>
<span class="p_add">+	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;	/* PortPwrCtrlMask */</span>
 }
 
 static int dummy_hub_control(
<span class="p_header">diff --git a/drivers/usb/gadget/udc/net2280.c b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">index 61c938c36d88..33f3987218f7 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/net2280.c</span>
<span class="p_chunk">@@ -2469,11 +2469,8 @@</span> <span class="p_context"> static void stop_activity(struct net2280 *dev, struct usb_gadget_driver *driver)</span>
 		nuke(&amp;dev-&gt;ep[i]);
 
 	/* report disconnect; the driver is already quiesced */
<span class="p_del">-	if (driver) {</span>
<span class="p_del">-		spin_unlock(&amp;dev-&gt;lock);</span>
<span class="p_add">+	if (driver)</span>
 		driver-&gt;disconnect(&amp;dev-&gt;gadget);
<span class="p_del">-		spin_lock(&amp;dev-&gt;lock);</span>
<span class="p_del">-	}</span>
 
 	usb_reinit(dev);
 }
<span class="p_chunk">@@ -3347,8 +3344,6 @@</span> <span class="p_context"> static void handle_stat0_irqs(struct net2280 *dev, u32 stat)</span>
 		BIT(PCI_RETRY_ABORT_INTERRUPT))
 
 static void handle_stat1_irqs(struct net2280 *dev, u32 stat)
<span class="p_del">-__releases(dev-&gt;lock)</span>
<span class="p_del">-__acquires(dev-&gt;lock)</span>
 {
 	struct net2280_ep	*ep;
 	u32			tmp, num, mask, scratch;
<span class="p_chunk">@@ -3389,14 +3384,12 @@</span> <span class="p_context"> __acquires(dev-&gt;lock)</span>
 			if (disconnect || reset) {
 				stop_activity(dev, dev-&gt;driver);
 				ep0_start(dev);
<span class="p_del">-				spin_unlock(&amp;dev-&gt;lock);</span>
 				if (reset)
 					usb_gadget_udc_reset
 						(&amp;dev-&gt;gadget, dev-&gt;driver);
 				else
 					(dev-&gt;driver-&gt;disconnect)
 						(&amp;dev-&gt;gadget);
<span class="p_del">-				spin_lock(&amp;dev-&gt;lock);</span>
 				return;
 			}
 		}
<span class="p_header">diff --git a/drivers/usb/gadget/udc/renesas_usb3.c b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">index fb8fc34827ab..ba78e3f7aea8 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/renesas_usb3.c</span>
<span class="p_chunk">@@ -1401,7 +1401,13 @@</span> <span class="p_context"> static void usb3_request_done_pipen(struct renesas_usb3 *usb3,</span>
 				    struct renesas_usb3_request *usb3_req,
 				    int status)
 {
<span class="p_del">-	usb3_pn_stop(usb3);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;usb3-&gt;lock, flags);</span>
<span class="p_add">+	if (usb3_pn_change(usb3, usb3_ep-&gt;num))</span>
<span class="p_add">+		usb3_pn_stop(usb3);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;usb3-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	usb3_disable_pipe_irq(usb3, usb3_ep-&gt;num);
 	usb3_request_done(usb3_ep, usb3_req, status);
 
<span class="p_chunk">@@ -1430,30 +1436,46 @@</span> <span class="p_context"> static void usb3_irq_epc_pipen_bfrdy(struct renesas_usb3 *usb3, int num)</span>
 {
 	struct renesas_usb3_ep *usb3_ep = usb3_get_ep(usb3, num);
 	struct renesas_usb3_request *usb3_req = usb3_get_request(usb3_ep);
<span class="p_add">+	bool done = false;</span>
 
 	if (!usb3_req)
 		return;
 
<span class="p_add">+	spin_lock(&amp;usb3-&gt;lock);</span>
<span class="p_add">+	if (usb3_pn_change(usb3, num))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (usb3_ep-&gt;dir_in) {
 		/* Do not stop the IN pipe here to detect LSTTR interrupt */
 		if (!usb3_write_pipe(usb3_ep, usb3_req, USB3_PN_WRITE))
 			usb3_clear_bit(usb3, PN_INT_BFRDY, USB3_PN_INT_ENA);
 	} else {
 		if (!usb3_read_pipe(usb3_ep, usb3_req, USB3_PN_READ))
<span class="p_del">-			usb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);</span>
<span class="p_add">+			done = true;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	/* need to unlock because usb3_request_done_pipen() locks it */</span>
<span class="p_add">+	spin_unlock(&amp;usb3-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (done)</span>
<span class="p_add">+		usb3_request_done_pipen(usb3, usb3_ep, usb3_req, 0);</span>
 }
 
 static void usb3_irq_epc_pipen(struct renesas_usb3 *usb3, int num)
 {
 	u32 pn_int_sta;
 
<span class="p_del">-	if (usb3_pn_change(usb3, num) &lt; 0)</span>
<span class="p_add">+	spin_lock(&amp;usb3-&gt;lock);</span>
<span class="p_add">+	if (usb3_pn_change(usb3, num) &lt; 0) {</span>
<span class="p_add">+		spin_unlock(&amp;usb3-&gt;lock);</span>
 		return;
<span class="p_add">+	}</span>
 
 	pn_int_sta = usb3_read(usb3, USB3_PN_INT_STA);
 	pn_int_sta &amp;= usb3_read(usb3, USB3_PN_INT_ENA);
 	usb3_write(usb3, pn_int_sta, USB3_PN_INT_STA);
<span class="p_add">+	spin_unlock(&amp;usb3-&gt;lock);</span>
 	if (pn_int_sta &amp; PN_INT_LSTTR)
 		usb3_irq_epc_pipen_lsttr(usb3, num);
 	if (pn_int_sta &amp; PN_INT_BFRDY)
<span class="p_chunk">@@ -1707,6 +1729,9 @@</span> <span class="p_context"> static int renesas_usb3_start(struct usb_gadget *gadget,</span>
 	/* hook up the driver */
 	usb3-&gt;driver = driver;
 
<span class="p_add">+	pm_runtime_enable(usb3_to_dev(usb3));</span>
<span class="p_add">+	pm_runtime_get_sync(usb3_to_dev(usb3));</span>
<span class="p_add">+</span>
 	renesas_usb3_init_controller(usb3);
 
 	return 0;
<span class="p_chunk">@@ -1715,14 +1740,14 @@</span> <span class="p_context"> static int renesas_usb3_start(struct usb_gadget *gadget,</span>
 static int renesas_usb3_stop(struct usb_gadget *gadget)
 {
 	struct renesas_usb3 *usb3 = gadget_to_renesas_usb3(gadget);
<span class="p_del">-	unsigned long flags;</span>
 
<span class="p_del">-	spin_lock_irqsave(&amp;usb3-&gt;lock, flags);</span>
 	usb3-&gt;softconnect = false;
 	usb3-&gt;gadget.speed = USB_SPEED_UNKNOWN;
 	usb3-&gt;driver = NULL;
 	renesas_usb3_stop_controller(usb3);
<span class="p_del">-	spin_unlock_irqrestore(&amp;usb3-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_put(usb3_to_dev(usb3));</span>
<span class="p_add">+	pm_runtime_disable(usb3_to_dev(usb3));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1761,9 +1786,6 @@</span> <span class="p_context"> static int renesas_usb3_remove(struct platform_device *pdev)</span>
 {
 	struct renesas_usb3 *usb3 = platform_get_drvdata(pdev);
 
<span class="p_del">-	pm_runtime_put(&amp;pdev-&gt;dev);</span>
<span class="p_del">-	pm_runtime_disable(&amp;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	usb_del_gadget_udc(&amp;usb3-&gt;gadget);
 
 	__renesas_usb3_ep_free_request(usb3-&gt;ep0_req);
<span class="p_chunk">@@ -1948,9 +1970,6 @@</span> <span class="p_context"> static int renesas_usb3_probe(struct platform_device *pdev)</span>
 
 	usb3-&gt;workaround_for_vbus = priv-&gt;workaround_for_vbus;
 
<span class="p_del">-	pm_runtime_enable(&amp;pdev-&gt;dev);</span>
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
<span class="p_del">-</span>
 	dev_info(&amp;pdev-&gt;dev, &quot;probed\n&quot;);
 
 	return 0;
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index bfa7fa3d2eea..7bf78be1fd32 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -1269,7 +1269,7 @@</span> <span class="p_context"> static void set_td_timer(struct r8a66597 *r8a66597, struct r8a66597_td *td)</span>
 			time = 30;
 			break;
 		default:
<span class="p_del">-			time = 300;</span>
<span class="p_add">+			time = 50;</span>
 			break;
 		}
 
<span class="p_chunk">@@ -1785,6 +1785,7 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 		pipe = td-&gt;pipe;
 		pipe_stop(r8a66597, pipe);
 
<span class="p_add">+		/* Select a different address or endpoint */</span>
 		new_td = td;
 		do {
 			list_move_tail(&amp;new_td-&gt;queue,
<span class="p_chunk">@@ -1794,7 +1795,8 @@</span> <span class="p_context"> static void r8a66597_td_timer(unsigned long _r8a66597)</span>
 				new_td = td;
 				break;
 			}
<span class="p_del">-		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address);</span>
<span class="p_add">+		} while (td != new_td &amp;&amp; td-&gt;address == new_td-&gt;address &amp;&amp;</span>
<span class="p_add">+			td-&gt;pipe-&gt;info.epnum == new_td-&gt;pipe-&gt;info.epnum);</span>
 
 		start_transfer(r8a66597, new_td);
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 8c6eafe8966c..b7114c3f52aa 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -2123,11 +2123,12 @@</span> <span class="p_context"> static void xhci_add_in_port(struct xhci_hcd *xhci, unsigned int num_ports,</span>
 {
 	u32 temp, port_offset, port_count;
 	int i;
<span class="p_del">-	u8 major_revision;</span>
<span class="p_add">+	u8 major_revision, minor_revision;</span>
 	struct xhci_hub *rhub;
 
 	temp = readl(addr);
 	major_revision = XHCI_EXT_PORT_MAJOR(temp);
<span class="p_add">+	minor_revision = XHCI_EXT_PORT_MINOR(temp);</span>
 
 	if (major_revision == 0x03) {
 		rhub = &amp;xhci-&gt;usb3_rhub;
<span class="p_chunk">@@ -2141,7 +2142,9 @@</span> <span class="p_context"> static void xhci_add_in_port(struct xhci_hcd *xhci, unsigned int num_ports,</span>
 		return;
 	}
 	rhub-&gt;maj_rev = XHCI_EXT_PORT_MAJOR(temp);
<span class="p_del">-	rhub-&gt;min_rev = XHCI_EXT_PORT_MINOR(temp);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rhub-&gt;min_rev &lt; minor_revision)</span>
<span class="p_add">+		rhub-&gt;min_rev = minor_revision;</span>
 
 	/* Port offset and count in the third dword, see section 7.2 */
 	temp = readl(addr + 2);
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index e7d6752eff32..69864ba38698 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -201,6 +201,9 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;
 			pdev-&gt;device == 0x1042)
 		xhci-&gt;quirks |= XHCI_BROKEN_STREAMS;
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_ASMEDIA &amp;&amp;</span>
<span class="p_add">+			pdev-&gt;device == 0x1142)</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_TRUST_TX_LENGTH;</span>
 
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_TI &amp;&amp; pdev-&gt;device == 0x8241)
 		xhci-&gt;quirks |= XHCI_LIMIT_ENDPOINT_INTERVAL_7;
<span class="p_header">diff --git a/drivers/usb/musb/musb_dsps.c b/drivers/usb/musb/musb_dsps.c</span>
<span class="p_header">index 9f125e179acd..39666fb911b0 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_dsps.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_dsps.c</span>
<span class="p_chunk">@@ -213,6 +213,12 @@</span> <span class="p_context"> static int dsps_check_status(struct musb *musb, void *unused)</span>
 				msecs_to_jiffies(wrp-&gt;poll_timeout));
 		break;
 	case OTG_STATE_A_WAIT_BCON:
<span class="p_add">+		/* keep VBUS on for host-only mode */</span>
<span class="p_add">+		if (musb-&gt;port_mode == MUSB_PORT_MODE_HOST) {</span>
<span class="p_add">+			mod_timer(&amp;glue-&gt;timer, jiffies +</span>
<span class="p_add">+					msecs_to_jiffies(wrp-&gt;poll_timeout));</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		musb_writeb(musb-&gt;mregs, MUSB_DEVCTL, 0);
 		skip_session = 1;
 		/* fall */
<span class="p_header">diff --git a/drivers/usb/usbip/vhci_hcd.c b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">index 03eccf29ace0..d6dc165e924b 100644</span>
<span class="p_header">--- a/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_header">+++ b/drivers/usb/usbip/vhci_hcd.c</span>
<span class="p_chunk">@@ -235,14 +235,19 @@</span> <span class="p_context"> static int vhci_hub_status(struct usb_hcd *hcd, char *buf)</span>
 
 static inline void hub_descriptor(struct usb_hub_descriptor *desc)
 {
<span class="p_add">+	int width;</span>
<span class="p_add">+</span>
 	memset(desc, 0, sizeof(*desc));
 	desc-&gt;bDescriptorType = USB_DT_HUB;
<span class="p_del">-	desc-&gt;bDescLength = 9;</span>
 	desc-&gt;wHubCharacteristics = cpu_to_le16(
 		HUB_CHAR_INDV_PORT_LPSM | HUB_CHAR_COMMON_OCPM);
<span class="p_add">+</span>
 	desc-&gt;bNbrPorts = VHCI_HC_PORTS;
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[0] = 0xff;</span>
<span class="p_del">-	desc-&gt;u.hs.DeviceRemovable[1] = 0xff;</span>
<span class="p_add">+	BUILD_BUG_ON(VHCI_HC_PORTS &gt; USB_MAXCHILDREN);</span>
<span class="p_add">+	width = desc-&gt;bNbrPorts / 8 + 1;</span>
<span class="p_add">+	desc-&gt;bDescLength = USB_DT_HUB_NONVAR_SIZE + 2 * width;</span>
<span class="p_add">+	memset(&amp;desc-&gt;u.hs.DeviceRemovable[0], 0, width);</span>
<span class="p_add">+	memset(&amp;desc-&gt;u.hs.DeviceRemovable[width], 0xff, width);</span>
 }
 
 static int vhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,
<span class="p_header">diff --git a/fs/btrfs/hash.c b/fs/btrfs/hash.c</span>
<span class="p_header">index a97fdc156a03..baacc1866861 100644</span>
<span class="p_header">--- a/fs/btrfs/hash.c</span>
<span class="p_header">+++ b/fs/btrfs/hash.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"> u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)</span>
 {
 	SHASH_DESC_ON_STACK(shash, tfm);
 	u32 *ctx = (u32 *)shash_desc_ctx(shash);
<span class="p_add">+	u32 retval;</span>
 	int err;
 
 	shash-&gt;tfm = tfm;
<span class="p_chunk">@@ -47,5 +48,7 @@</span> <span class="p_context"> u32 btrfs_crc32c(u32 crc, const void *address, unsigned int length)</span>
 	err = crypto_shash_update(shash, address, length);
 	BUG_ON(err);
 
<span class="p_del">-	return *ctx;</span>
<span class="p_add">+	retval = *ctx;</span>
<span class="p_add">+	barrier_data(ctx);</span>
<span class="p_add">+	return retval;</span>
 }
<span class="p_header">diff --git a/fs/configfs/symlink.c b/fs/configfs/symlink.c</span>
<span class="p_header">index db6d69289608..314b4edac72b 100644</span>
<span class="p_header">--- a/fs/configfs/symlink.c</span>
<span class="p_header">+++ b/fs/configfs/symlink.c</span>
<span class="p_chunk">@@ -83,14 +83,13 @@</span> <span class="p_context"> static int create_link(struct config_item *parent_item,</span>
 	ret = -ENOMEM;
 	sl = kmalloc(sizeof(struct configfs_symlink), GFP_KERNEL);
 	if (sl) {
<span class="p_del">-		sl-&gt;sl_target = config_item_get(item);</span>
 		spin_lock(&amp;configfs_dirent_lock);
 		if (target_sd-&gt;s_type &amp; CONFIGFS_USET_DROPPING) {
 			spin_unlock(&amp;configfs_dirent_lock);
<span class="p_del">-			config_item_put(item);</span>
 			kfree(sl);
 			return -ENOENT;
 		}
<span class="p_add">+		sl-&gt;sl_target = config_item_get(item);</span>
 		list_add(&amp;sl-&gt;sl_list, &amp;target_sd-&gt;s_links);
 		spin_unlock(&amp;configfs_dirent_lock);
 		ret = configfs_create_link(sl, parent_item-&gt;ci_dentry,
<span class="p_header">diff --git a/fs/f2fs/f2fs.h b/fs/f2fs/f2fs.h</span>
<span class="p_header">index c12f695923b6..88e111ab068b 100644</span>
<span class="p_header">--- a/fs/f2fs/f2fs.h</span>
<span class="p_header">+++ b/fs/f2fs/f2fs.h</span>
<span class="p_chunk">@@ -948,6 +948,7 @@</span> <span class="p_context"> static inline u32 f2fs_crc32(struct f2fs_sb_info *sbi, const void *address,</span>
 {
 	SHASH_DESC_ON_STACK(shash, sbi-&gt;s_chksum_driver);
 	u32 *ctx = (u32 *)shash_desc_ctx(shash);
<span class="p_add">+	u32 retval;</span>
 	int err;
 
 	shash-&gt;tfm = sbi-&gt;s_chksum_driver;
<span class="p_chunk">@@ -957,7 +958,9 @@</span> <span class="p_context"> static inline u32 f2fs_crc32(struct f2fs_sb_info *sbi, const void *address,</span>
 	err = crypto_shash_update(shash, address, length);
 	BUG_ON(err);
 
<span class="p_del">-	return *ctx;</span>
<span class="p_add">+	retval = *ctx;</span>
<span class="p_add">+	barrier_data(ctx);</span>
<span class="p_add">+	return retval;</span>
 }
 
 static inline bool f2fs_crc_valid(struct f2fs_sb_info *sbi, __u32 blk_crc,
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index 4fb7b10f3a05..704fa0b17309 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 		addr = ALIGN(addr, huge_page_size(h));
 		vma = find_vma(mm, addr);
 		if (TASK_SIZE - len &gt;= addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
 			return addr;
 	}
 
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index b1517b6dcbdd..5138e781737a 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -299,11 +299,7 @@</span> <span class="p_context"> show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)</span>
 
 	/* We don&#39;t show the stack guard page in /proc/maps */
 	start = vma-&gt;vm_start;
<span class="p_del">-	if (stack_guard_page_start(vma, start))</span>
<span class="p_del">-		start += PAGE_SIZE;</span>
 	end = vma-&gt;vm_end;
<span class="p_del">-	if (stack_guard_page_end(vma, end))</span>
<span class="p_del">-		end -= PAGE_SIZE;</span>
 
 	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);
 	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,
<span class="p_header">diff --git a/fs/read_write.c b/fs/read_write.c</span>
<span class="p_header">index 190e0d362581..e479e24dcd4c 100644</span>
<span class="p_header">--- a/fs/read_write.c</span>
<span class="p_header">+++ b/fs/read_write.c</span>
<span class="p_chunk">@@ -1232,7 +1232,7 @@</span> <span class="p_context"> static size_t compat_writev(struct file *file,</span>
 	if (!(file-&gt;f_mode &amp; FMODE_CAN_WRITE))
 		goto out;
 
<span class="p_del">-	ret = compat_do_readv_writev(WRITE, file, vec, vlen, pos, 0);</span>
<span class="p_add">+	ret = compat_do_readv_writev(WRITE, file, vec, vlen, pos, flags);</span>
 
 out:
 	if (ret &gt; 0)
<span class="p_header">diff --git a/include/linux/mm.h b/include/linux/mm.h</span>
<span class="p_header">index 0b5b2e4df14e..6c9e1ad12831 100644</span>
<span class="p_header">--- a/include/linux/mm.h</span>
<span class="p_header">+++ b/include/linux/mm.h</span>
<span class="p_chunk">@@ -1356,39 +1356,11 @@</span> <span class="p_context"> int clear_page_dirty_for_io(struct page *page);</span>
 
 int get_cmdline(struct task_struct *task, char *buffer, int buflen);
 
<span class="p_del">-/* Is the vma a continuation of the stack vma above it? */</span>
<span class="p_del">-static inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_end == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSDOWN);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline bool vma_is_anonymous(struct vm_area_struct *vma)
 {
 	return !vma-&gt;vm_ops;
 }
 
<span class="p_del">-static inline int stack_guard_page_start(struct vm_area_struct *vma,</span>
<span class="p_del">-					     unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_start == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsdown(vma-&gt;vm_prev, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Is the vma a continuation of the stack vma below it? */</span>
<span class="p_del">-static inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return vma &amp;&amp; (vma-&gt;vm_start == addr) &amp;&amp; (vma-&gt;vm_flags &amp; VM_GROWSUP);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int stack_guard_page_end(struct vm_area_struct *vma,</span>
<span class="p_del">-					   unsigned long addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp;</span>
<span class="p_del">-		(vma-&gt;vm_end == addr) &amp;&amp;</span>
<span class="p_del">-		!vma_growsup(vma-&gt;vm_next, addr);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int vma_is_stack_for_current(struct vm_area_struct *vma);
 
 extern unsigned long move_page_tables(struct vm_area_struct *vma,
<span class="p_chunk">@@ -2127,6 +2099,7 @@</span> <span class="p_context"> void page_cache_async_readahead(struct address_space *mapping,</span>
 				pgoff_t offset,
 				unsigned long size);
 
<span class="p_add">+extern unsigned long stack_guard_gap;</span>
 /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
 
<span class="p_chunk">@@ -2155,6 +2128,30 @@</span> <span class="p_context"> static inline struct vm_area_struct * find_vma_intersection(struct mm_struct * m</span>
 	return vma;
 }
 
<span class="p_add">+static inline unsigned long vm_start_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_start = vma-&gt;vm_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSDOWN) {</span>
<span class="p_add">+		vm_start -= stack_guard_gap;</span>
<span class="p_add">+		if (vm_start &gt; vma-&gt;vm_start)</span>
<span class="p_add">+			vm_start = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_start;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long vm_end_gap(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_GROWSUP) {</span>
<span class="p_add">+		vm_end += stack_guard_gap;</span>
<span class="p_add">+		if (vm_end &lt; vma-&gt;vm_end)</span>
<span class="p_add">+			vm_end = -PAGE_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return vm_end;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long vma_pages(struct vm_area_struct *vma)
 {
 	return (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT;
<span class="p_header">diff --git a/include/uapi/linux/usb/ch11.h b/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">index 361297e96f58..576c704e3fb8 100644</span>
<span class="p_header">--- a/include/uapi/linux/usb/ch11.h</span>
<span class="p_header">+++ b/include/uapi/linux/usb/ch11.h</span>
<span class="p_chunk">@@ -22,6 +22,9 @@</span> <span class="p_context"></span>
  */
 #define USB_MAXCHILDREN		31
 
<span class="p_add">+/* See USB 3.1 spec Table 10-5 */</span>
<span class="p_add">+#define USB_SS_MAXPORTS		15</span>
<span class="p_add">+</span>
 /*
  * Hub request types
  */
<span class="p_header">diff --git a/kernel/irq/manage.c b/kernel/irq/manage.c</span>
<span class="p_header">index 6b669593e7eb..ea41820ab12e 100644</span>
<span class="p_header">--- a/kernel/irq/manage.c</span>
<span class="p_header">+++ b/kernel/irq/manage.c</span>
<span class="p_chunk">@@ -1308,8 +1308,10 @@</span> <span class="p_context"> __setup_irq(unsigned int irq, struct irq_desc *desc, struct irqaction *new)</span>
 			ret = __irq_set_trigger(desc,
 						new-&gt;flags &amp; IRQF_TRIGGER_MASK);
 
<span class="p_del">-			if (ret)</span>
<span class="p_add">+			if (ret) {</span>
<span class="p_add">+				irq_release_resources(desc);</span>
 				goto out_mask;
<span class="p_add">+			}</span>
 		}
 
 		desc-&gt;istate &amp;= ~(IRQS_AUTODETECT | IRQS_SPURIOUS_DISABLED | \
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 154fd689fe02..692c948ae333 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -5469,7 +5469,7 @@</span> <span class="p_context"> void idle_task_exit(void)</span>
 	BUG_ON(cpu_online(smp_processor_id()));
 
 	if (mm != &amp;init_mm) {
<span class="p_del">-		switch_mm_irqs_off(mm, &amp;init_mm, current);</span>
<span class="p_add">+		switch_mm(mm, &amp;init_mm, current);</span>
 		finish_arch_post_lock_switch();
 	}
 	mmdrop(mm);
<span class="p_header">diff --git a/kernel/time/alarmtimer.c b/kernel/time/alarmtimer.c</span>
<span class="p_header">index 12dd190634ab..9ba04aa740b9 100644</span>
<span class="p_header">--- a/kernel/time/alarmtimer.c</span>
<span class="p_header">+++ b/kernel/time/alarmtimer.c</span>
<span class="p_chunk">@@ -354,7 +354,7 @@</span> <span class="p_context"> void alarm_start_relative(struct alarm *alarm, ktime_t start)</span>
 {
 	struct alarm_base *base = &amp;alarm_bases[alarm-&gt;type];
 
<span class="p_del">-	start = ktime_add(start, base-&gt;gettime());</span>
<span class="p_add">+	start = ktime_add_safe(start, base-&gt;gettime());</span>
 	alarm_start(alarm, start);
 }
 EXPORT_SYMBOL_GPL(alarm_start_relative);
<span class="p_chunk">@@ -440,7 +440,7 @@</span> <span class="p_context"> u64 alarm_forward(struct alarm *alarm, ktime_t now, ktime_t interval)</span>
 		overrun++;
 	}
 
<span class="p_del">-	alarm-&gt;node.expires = ktime_add(alarm-&gt;node.expires, interval);</span>
<span class="p_add">+	alarm-&gt;node.expires = ktime_add_safe(alarm-&gt;node.expires, interval);</span>
 	return overrun;
 }
 EXPORT_SYMBOL_GPL(alarm_forward);
<span class="p_chunk">@@ -624,13 +624,21 @@</span> <span class="p_context"> static int alarm_timer_set(struct k_itimer *timr, int flags,</span>
 
 	/* start the timer */
 	timr-&gt;it.alarm.interval = timespec_to_ktime(new_setting-&gt;it_interval);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Rate limit to the tick as a hot fix to prevent DOS. Will be</span>
<span class="p_add">+	 * mopped up later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ktime_to_ns(timr-&gt;it.alarm.interval) &lt; TICK_NSEC)</span>
<span class="p_add">+		timr-&gt;it.alarm.interval = ktime_set(0, TICK_NSEC);</span>
<span class="p_add">+</span>
 	exp = timespec_to_ktime(new_setting-&gt;it_value);
 	/* Convert (if necessary) to absolute time */
 	if (flags != TIMER_ABSTIME) {
 		ktime_t now;
 
 		now = alarm_bases[timr-&gt;it.alarm.alarmtimer.type].gettime();
<span class="p_del">-		exp = ktime_add(now, exp);</span>
<span class="p_add">+		exp = ktime_add_safe(now, exp);</span>
 	}
 
 	alarm_start(&amp;timr-&gt;it.alarm.alarmtimer, exp);
<span class="p_header">diff --git a/lib/libcrc32c.c b/lib/libcrc32c.c</span>
<span class="p_header">index 74a54b7f2562..9f79547d1b97 100644</span>
<span class="p_header">--- a/lib/libcrc32c.c</span>
<span class="p_header">+++ b/lib/libcrc32c.c</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> static struct crypto_shash *tfm;</span>
 u32 crc32c(u32 crc, const void *address, unsigned int length)
 {
 	SHASH_DESC_ON_STACK(shash, tfm);
<span class="p_del">-	u32 *ctx = (u32 *)shash_desc_ctx(shash);</span>
<span class="p_add">+	u32 ret, *ctx = (u32 *)shash_desc_ctx(shash);</span>
 	int err;
 
 	shash-&gt;tfm = tfm;
<span class="p_chunk">@@ -53,7 +53,9 @@</span> <span class="p_context"> u32 crc32c(u32 crc, const void *address, unsigned int length)</span>
 	err = crypto_shash_update(shash, address, length);
 	BUG_ON(err);
 
<span class="p_del">-	return *ctx;</span>
<span class="p_add">+	ret = *ctx;</span>
<span class="p_add">+	barrier_data(ctx);</span>
<span class="p_add">+	return ret;</span>
 }
 
 EXPORT_SYMBOL(crc32c);
<span class="p_header">diff --git a/mm/gup.c b/mm/gup.c</span>
<span class="p_header">index ec4f82704b6f..c63a0341ae38 100644</span>
<span class="p_header">--- a/mm/gup.c</span>
<span class="p_header">+++ b/mm/gup.c</span>
<span class="p_chunk">@@ -370,11 +370,6 @@</span> <span class="p_context"> static int faultin_page(struct task_struct *tsk, struct vm_area_struct *vma,</span>
 	/* mlock all present pages, but do not fault in new pages */
 	if ((*flags &amp; (FOLL_POPULATE | FOLL_MLOCK)) == FOLL_MLOCK)
 		return -ENOENT;
<span class="p_del">-	/* For mm_populate(), just skip the stack guard page. */</span>
<span class="p_del">-	if ((*flags &amp; FOLL_POPULATE) &amp;&amp;</span>
<span class="p_del">-			(stack_guard_page_start(vma, address) ||</span>
<span class="p_del">-			 stack_guard_page_end(vma, address + PAGE_SIZE)))</span>
<span class="p_del">-		return -ENOENT;</span>
 	if (*flags &amp; FOLL_WRITE)
 		fault_flags |= FAULT_FLAG_WRITE;
 	if (*flags &amp; FOLL_REMOTE)
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 4bd44803e366..ce7d416edab7 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1176,7 +1176,10 @@</span> <span class="p_context"> int memory_failure(unsigned long pfn, int trapno, int flags)</span>
 	 * page_remove_rmap() in try_to_unmap_one(). So to determine page status
 	 * correctly, we save a copy of the page flags at this time.
 	 */
<span class="p_del">-	page_flags = p-&gt;flags;</span>
<span class="p_add">+	if (PageHuge(p))</span>
<span class="p_add">+		page_flags = hpage-&gt;flags;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		page_flags = p-&gt;flags;</span>
 
 	/*
 	 * unpoison always clear PG_hwpoison inside page lock
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index cbb1e5e5f791..e6a5a1f20492 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -2699,40 +2699,6 @@</span> <span class="p_context"> int do_swap_page(struct fault_env *fe, pte_t orig_pte)</span>
 }
 
 /*
<span class="p_del">- * This is like a special single-page &quot;expand_{down|up}wards()&quot;,</span>
<span class="p_del">- * except we must first make sure that &#39;address{-|+}PAGE_SIZE&#39;</span>
<span class="p_del">- * doesn&#39;t hit another vma.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)</span>
<span class="p_del">-{</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSDOWN) &amp;&amp; address == vma-&gt;vm_start) {</span>
<span class="p_del">-		struct vm_area_struct *prev = vma-&gt;vm_prev;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Is there a mapping abutting this one below?</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * That&#39;s only ok if it&#39;s the same stack mapping</span>
<span class="p_del">-		 * that has gotten split..</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (prev &amp;&amp; prev-&gt;vm_end == address)</span>
<span class="p_del">-			return prev-&gt;vm_flags &amp; VM_GROWSDOWN ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_downwards(vma, address - PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if ((vma-&gt;vm_flags &amp; VM_GROWSUP) &amp;&amp; address + PAGE_SIZE == vma-&gt;vm_end) {</span>
<span class="p_del">-		struct vm_area_struct *next = vma-&gt;vm_next;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* As VM_GROWSDOWN but s/below/above/ */</span>
<span class="p_del">-		if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE)</span>
<span class="p_del">-			return next-&gt;vm_flags &amp; VM_GROWSUP ? 0 : -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		return expand_upwards(vma, address + PAGE_SIZE);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
<span class="p_chunk">@@ -2748,10 +2714,6 @@</span> <span class="p_context"> static int do_anonymous_page(struct fault_env *fe)</span>
 	if (vma-&gt;vm_flags &amp; VM_SHARED)
 		return VM_FAULT_SIGBUS;
 
<span class="p_del">-	/* Check if we need to add a guard page to the stack */</span>
<span class="p_del">-	if (check_stack_guard_page(vma, fe-&gt;address) &lt; 0)</span>
<span class="p_del">-		return VM_FAULT_SIGSEGV;</span>
<span class="p_del">-</span>
 	/*
 	 * Use pte_alloc() instead of pte_alloc_map().  We can&#39;t run
 	 * pte_offset_map() on pmds where a huge pmd might be created
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 1af87c14183d..145d3d5253e8 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -183,6 +183,7 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	unsigned long retval;
 	unsigned long newbrk, oldbrk;
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_add">+	struct vm_area_struct *next;</span>
 	unsigned long min_brk;
 	bool populate;
 
<span class="p_chunk">@@ -228,7 +229,8 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 	}
 
 	/* Check against existing mmap mappings. */
<span class="p_del">-	if (find_vma_intersection(mm, oldbrk, newbrk+PAGE_SIZE))</span>
<span class="p_add">+	next = find_vma(mm, oldbrk);</span>
<span class="p_add">+	if (next &amp;&amp; newbrk + PAGE_SIZE &gt; vm_start_gap(next))</span>
 		goto out;
 
 	/* Ok, looks good - let it rip. */
<span class="p_chunk">@@ -251,10 +253,22 @@</span> <span class="p_context"> SYSCALL_DEFINE1(brk, unsigned long, brk)</span>
 
 static long vma_compute_subtree_gap(struct vm_area_struct *vma)
 {
<span class="p_del">-	unsigned long max, subtree_gap;</span>
<span class="p_del">-	max = vma-&gt;vm_start;</span>
<span class="p_del">-	if (vma-&gt;vm_prev)</span>
<span class="p_del">-		max -= vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_add">+	unsigned long max, prev_end, subtree_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note: in the rare case of a VM_GROWSDOWN above a VM_GROWSUP, we</span>
<span class="p_add">+	 * allow two stack_guard_gaps between them here, and when choosing</span>
<span class="p_add">+	 * an unmapped area; whereas when expanding we only require one.</span>
<span class="p_add">+	 * That&#39;s a little inconsistent, but keeps the code here simpler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	max = vm_start_gap(vma);</span>
<span class="p_add">+	if (vma-&gt;vm_prev) {</span>
<span class="p_add">+		prev_end = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+		if (max &gt; prev_end)</span>
<span class="p_add">+			max -= prev_end;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			max = 0;</span>
<span class="p_add">+	}</span>
 	if (vma-&gt;vm_rb.rb_left) {
 		subtree_gap = rb_entry(vma-&gt;vm_rb.rb_left,
 				struct vm_area_struct, vm_rb)-&gt;rb_subtree_gap;
<span class="p_chunk">@@ -350,7 +364,7 @@</span> <span class="p_context"> static void validate_mm(struct mm_struct *mm)</span>
 			anon_vma_unlock_read(anon_vma);
 		}
 
<span class="p_del">-		highest_address = vma-&gt;vm_end;</span>
<span class="p_add">+		highest_address = vm_end_gap(vma);</span>
 		vma = vma-&gt;vm_next;
 		i++;
 	}
<span class="p_chunk">@@ -539,7 +553,7 @@</span> <span class="p_context"> void __vma_link_rb(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 	if (vma-&gt;vm_next)
 		vma_gap_update(vma-&gt;vm_next);
 	else
<span class="p_del">-		mm-&gt;highest_vm_end = vma-&gt;vm_end;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 
 	/*
 	 * vma-&gt;vm_prev wasn&#39;t known when we followed the rbtree to find the
<span class="p_chunk">@@ -854,7 +868,7 @@</span> <span class="p_context"> int __vma_adjust(struct vm_area_struct *vma, unsigned long start,</span>
 			vma_gap_update(vma);
 		if (end_changed) {
 			if (!next)
<span class="p_del">-				mm-&gt;highest_vm_end = end;</span>
<span class="p_add">+				mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 			else if (!adjust_next)
 				vma_gap_update(next);
 		}
<span class="p_chunk">@@ -939,7 +953,7 @@</span> <span class="p_context"> int __vma_adjust(struct vm_area_struct *vma, unsigned long start,</span>
 			 * mm-&gt;highest_vm_end doesn&#39;t need any update
 			 * in remove_next == 1 case.
 			 */
<span class="p_del">-			VM_WARN_ON(mm-&gt;highest_vm_end != end);</span>
<span class="p_add">+			VM_WARN_ON(mm-&gt;highest_vm_end != vm_end_gap(vma));</span>
 		}
 	}
 	if (insert &amp;&amp; file)
<span class="p_chunk">@@ -1783,7 +1797,7 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit left subtree if it looks promising */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &gt;= low_limit &amp;&amp; vma-&gt;vm_rb.rb_left) {
 			struct vm_area_struct *left =
 				rb_entry(vma-&gt;vm_rb.rb_left,
<span class="p_chunk">@@ -1794,12 +1808,13 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 			}
 		}
 
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 check_current:
 		/* Check if current node has a suitable gap */
 		if (gap_start &gt; high_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_end &gt;= low_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_end &gt;= low_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit right subtree if it looks promising */
<span class="p_chunk">@@ -1821,8 +1836,8 @@</span> <span class="p_context"> unsigned long unmapped_area(struct vm_unmapped_area_info *info)</span>
 			vma = rb_entry(rb_parent(prev),
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_left) {
<span class="p_del">-				gap_start = vma-&gt;vm_prev-&gt;vm_end;</span>
<span class="p_del">-				gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+				gap_start = vm_end_gap(vma-&gt;vm_prev);</span>
<span class="p_add">+				gap_end = vm_start_gap(vma);</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1886,7 +1901,7 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 	while (true) {
 		/* Visit right subtree if it looks promising */
<span class="p_del">-		gap_start = vma-&gt;vm_prev ? vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+		gap_start = vma-&gt;vm_prev ? vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 		if (gap_start &lt;= high_limit &amp;&amp; vma-&gt;vm_rb.rb_right) {
 			struct vm_area_struct *right =
 				rb_entry(vma-&gt;vm_rb.rb_right,
<span class="p_chunk">@@ -1899,10 +1914,11 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 
 check_current:
 		/* Check if current node has a suitable gap */
<span class="p_del">-		gap_end = vma-&gt;vm_start;</span>
<span class="p_add">+		gap_end = vm_start_gap(vma);</span>
 		if (gap_end &lt; low_limit)
 			return -ENOMEM;
<span class="p_del">-		if (gap_start &lt;= high_limit &amp;&amp; gap_end - gap_start &gt;= length)</span>
<span class="p_add">+		if (gap_start &lt;= high_limit &amp;&amp;</span>
<span class="p_add">+		    gap_end &gt; gap_start &amp;&amp; gap_end - gap_start &gt;= length)</span>
 			goto found;
 
 		/* Visit left subtree if it looks promising */
<span class="p_chunk">@@ -1925,7 +1941,7 @@</span> <span class="p_context"> unsigned long unmapped_area_topdown(struct vm_unmapped_area_info *info)</span>
 				       struct vm_area_struct, vm_rb);
 			if (prev == vma-&gt;vm_rb.rb_right) {
 				gap_start = vma-&gt;vm_prev ?
<span class="p_del">-					vma-&gt;vm_prev-&gt;vm_end : 0;</span>
<span class="p_add">+					vm_end_gap(vma-&gt;vm_prev) : 0;</span>
 				goto check_current;
 			}
 		}
<span class="p_chunk">@@ -1963,7 +1979,7 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 		unsigned long len, unsigned long pgoff, unsigned long flags)
 {
 	struct mm_struct *mm = current-&gt;mm;
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct vm_unmapped_area_info info;
 
 	if (len &gt; TASK_SIZE - mmap_min_addr)
<span class="p_chunk">@@ -1974,9 +1990,10 @@</span> <span class="p_context"> arch_get_unmapped_area(struct file *filp, unsigned long addr,</span>
 
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-		    (!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+		    (!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+		    (!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -1999,7 +2016,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 			  const unsigned long len, const unsigned long pgoff,
 			  const unsigned long flags)
 {
<span class="p_del">-	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct vm_area_struct *vma, *prev;</span>
 	struct mm_struct *mm = current-&gt;mm;
 	unsigned long addr = addr0;
 	struct vm_unmapped_area_info info;
<span class="p_chunk">@@ -2014,9 +2031,10 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_del">-		vma = find_vma(mm, addr);</span>
<span class="p_add">+		vma = find_vma_prev(mm, addr, &amp;prev);</span>
 		if (TASK_SIZE - len &gt;= addr &amp;&amp; addr &gt;= mmap_min_addr &amp;&amp;
<span class="p_del">-				(!vma || addr + len &lt;= vma-&gt;vm_start))</span>
<span class="p_add">+				(!vma || addr + len &lt;= vm_start_gap(vma)) &amp;&amp;</span>
<span class="p_add">+				(!prev || addr &gt;= vm_end_gap(prev)))</span>
 			return addr;
 	}
 
<span class="p_chunk">@@ -2151,21 +2169,19 @@</span> <span class="p_context"> find_vma_prev(struct mm_struct *mm, unsigned long addr,</span>
  * update accounting. This is shared with both the
  * grow-up and grow-down cases.
  */
<span class="p_del">-static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)</span>
<span class="p_add">+static int acct_stack_growth(struct vm_area_struct *vma,</span>
<span class="p_add">+			     unsigned long size, unsigned long grow)</span>
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
 	struct rlimit *rlim = current-&gt;signal-&gt;rlim;
<span class="p_del">-	unsigned long new_start, actual_size;</span>
<span class="p_add">+	unsigned long new_start;</span>
 
 	/* address space limit tests */
 	if (!may_expand_vm(mm, vma-&gt;vm_flags, grow))
 		return -ENOMEM;
 
 	/* Stack limit test */
<span class="p_del">-	actual_size = size;</span>
<span class="p_del">-	if (size &amp;&amp; (vma-&gt;vm_flags &amp; (VM_GROWSUP | VM_GROWSDOWN)))</span>
<span class="p_del">-		actual_size -= PAGE_SIZE;</span>
<span class="p_del">-	if (actual_size &gt; READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
<span class="p_add">+	if (size &gt; READ_ONCE(rlim[RLIMIT_STACK].rlim_cur))</span>
 		return -ENOMEM;
 
 	/* mlock limit tests */
<span class="p_chunk">@@ -2203,16 +2219,32 @@</span> <span class="p_context"> static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns</span>
 int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
<span class="p_add">+	struct vm_area_struct *next;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error = 0;
 
 	if (!(vma-&gt;vm_flags &amp; VM_GROWSUP))
 		return -EFAULT;
 
<span class="p_del">-	/* Guard against wrapping around to address 0. */</span>
<span class="p_del">-	if (address &lt; PAGE_ALIGN(address+4))</span>
<span class="p_del">-		address = PAGE_ALIGN(address+4);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	/* Guard against exceeding limits of the address space. */</span>
<span class="p_add">+	address &amp;= PAGE_MASK;</span>
<span class="p_add">+	if (address &gt;= TASK_SIZE)</span>
 		return -ENOMEM;
<span class="p_add">+	address += PAGE_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address + stack_guard_gap;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Guard against overflow */</span>
<span class="p_add">+	if (gap_addr &lt; address || gap_addr &gt; TASK_SIZE)</span>
<span class="p_add">+		gap_addr = TASK_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	next = vma-&gt;vm_next;</span>
<span class="p_add">+	if (next &amp;&amp; next-&gt;vm_start &lt; gap_addr) {</span>
<span class="p_add">+		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
 
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
<span class="p_chunk">@@ -2257,7 +2289,7 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 				if (vma-&gt;vm_next)
 					vma_gap_update(vma-&gt;vm_next);
 				else
<span class="p_del">-					mm-&gt;highest_vm_end = address;</span>
<span class="p_add">+					mm-&gt;highest_vm_end = vm_end_gap(vma);</span>
 				spin_unlock(&amp;mm-&gt;page_table_lock);
 
 				perf_event_mmap(vma);
<span class="p_chunk">@@ -2278,6 +2310,8 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 				   unsigned long address)
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
<span class="p_add">+	struct vm_area_struct *prev;</span>
<span class="p_add">+	unsigned long gap_addr;</span>
 	int error;
 
 	address &amp;= PAGE_MASK;
<span class="p_chunk">@@ -2285,6 +2319,17 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	if (error)
 		return error;
 
<span class="p_add">+	/* Enforce stack_guard_gap */</span>
<span class="p_add">+	gap_addr = address - stack_guard_gap;</span>
<span class="p_add">+	if (gap_addr &gt; address)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	prev = vma-&gt;vm_prev;</span>
<span class="p_add">+	if (prev &amp;&amp; prev-&gt;vm_end &gt; gap_addr) {</span>
<span class="p_add">+		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+		/* Check that both stack segments have the same anon_vma? */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* We must make sure the anon_vma is allocated. */
 	if (unlikely(anon_vma_prepare(vma)))
 		return -ENOMEM;
<span class="p_chunk">@@ -2339,28 +2384,25 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	return error;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Note how expand_stack() refuses to expand the stack all the way to</span>
<span class="p_del">- * abut the next virtual mapping, *unless* that mapping itself is also</span>
<span class="p_del">- * a stack mapping. We want to leave room for a guard page, after all</span>
<span class="p_del">- * (the guard page itself is not added here, that is done by the</span>
<span class="p_del">- * actual page faulting logic)</span>
<span class="p_del">- *</span>
<span class="p_del">- * This matches the behavior of the guard page logic (see mm/memory.c:</span>
<span class="p_del">- * check_stack_guard_page()), which only allows the guard page to be</span>
<span class="p_del">- * removed under these circumstances.</span>
<span class="p_del">- */</span>
<span class="p_add">+/* enforced gap between the expanding stack and other mappings. */</span>
<span class="p_add">+unsigned long stack_guard_gap = 256UL&lt;&lt;PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init cmdline_parse_stack_guard_gap(char *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long val;</span>
<span class="p_add">+	char *endptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = simple_strtoul(p, &amp;endptr, 10);</span>
<span class="p_add">+	if (!*endptr)</span>
<span class="p_add">+		stack_guard_gap = val &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;stack_guard_gap=&quot;, cmdline_parse_stack_guard_gap);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_STACK_GROWSUP
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *next;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	next = vma-&gt;vm_next;</span>
<span class="p_del">-	if (next &amp;&amp; next-&gt;vm_start == address + PAGE_SIZE) {</span>
<span class="p_del">-		if (!(next-&gt;vm_flags &amp; VM_GROWSUP))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_upwards(vma, address);
 }
 
<span class="p_chunk">@@ -2382,14 +2424,6 @@</span> <span class="p_context"> find_extend_vma(struct mm_struct *mm, unsigned long addr)</span>
 #else
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
<span class="p_del">-	struct vm_area_struct *prev;</span>
<span class="p_del">-</span>
<span class="p_del">-	address &amp;= PAGE_MASK;</span>
<span class="p_del">-	prev = vma-&gt;vm_prev;</span>
<span class="p_del">-	if (prev &amp;&amp; prev-&gt;vm_end == address) {</span>
<span class="p_del">-		if (!(prev-&gt;vm_flags &amp; VM_GROWSDOWN))</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-	}</span>
 	return expand_downwards(vma, address);
 }
 
<span class="p_chunk">@@ -2487,7 +2521,7 @@</span> <span class="p_context"> detach_vmas_to_be_unmapped(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 		vma-&gt;vm_prev = prev;
 		vma_gap_update(vma);
 	} else
<span class="p_del">-		mm-&gt;highest_vm_end = prev ? prev-&gt;vm_end : 0;</span>
<span class="p_add">+		mm-&gt;highest_vm_end = prev ? vm_end_gap(prev) : 0;</span>
 	tail_vma-&gt;vm_next = NULL;
 
 	/* Kill the cache */
<span class="p_header">diff --git a/mm/swap_cgroup.c b/mm/swap_cgroup.c</span>
<span class="p_header">index 310ac0b8f974..454d6d7509ed 100644</span>
<span class="p_header">--- a/mm/swap_cgroup.c</span>
<span class="p_header">+++ b/mm/swap_cgroup.c</span>
<span class="p_chunk">@@ -48,6 +48,9 @@</span> <span class="p_context"> static int swap_cgroup_prepare(int type)</span>
 		if (!page)
 			goto not_enough_page;
 		ctrl-&gt;map[idx] = page;
<span class="p_add">+</span>
<span class="p_add">+		if (!(idx % SWAP_CLUSTER_MAX))</span>
<span class="p_add">+			cond_resched();</span>
 	}
 	return 0;
 not_enough_page:
<span class="p_header">diff --git a/net/ipv6/ila/ila_xlat.c b/net/ipv6/ila/ila_xlat.c</span>
<span class="p_header">index e604013dd814..7a5b9812af10 100644</span>
<span class="p_header">--- a/net/ipv6/ila/ila_xlat.c</span>
<span class="p_header">+++ b/net/ipv6/ila/ila_xlat.c</span>
<span class="p_chunk">@@ -68,6 +68,7 @@</span> <span class="p_context"> static inline u32 ila_locator_hash(struct ila_locator loc)</span>
 {
 	u32 *v = (u32 *)loc.v32;
 
<span class="p_add">+	__ila_hash_secret_init();</span>
 	return jhash_2words(v[0], v[1], hashrnd);
 }
 
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index fd6541f3ade3..07001b6d36cc 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -865,6 +865,8 @@</span> <span class="p_context"> static int ieee80211_start_ap(struct wiphy *wiphy, struct net_device *dev,</span>
 	default:
 		return -EINVAL;
 	}
<span class="p_add">+	sdata-&gt;u.ap.req_smps = sdata-&gt;smps_mode;</span>
<span class="p_add">+</span>
 	sdata-&gt;needed_rx_chains = sdata-&gt;local-&gt;rx_chains;
 
 	mutex_lock(&amp;local-&gt;mtx);
<span class="p_header">diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c</span>
<span class="p_header">index a31d30713d08..62d13eabe17f 100644</span>
<span class="p_header">--- a/net/mac80211/ibss.c</span>
<span class="p_header">+++ b/net/mac80211/ibss.c</span>
<span class="p_chunk">@@ -66,6 +66,8 @@</span> <span class="p_context"> ieee80211_ibss_build_presp(struct ieee80211_sub_if_data *sdata,</span>
 		    2 + (IEEE80211_MAX_SUPP_RATES - 8) +
 		    2 + sizeof(struct ieee80211_ht_cap) +
 		    2 + sizeof(struct ieee80211_ht_operation) +
<span class="p_add">+		    2 + sizeof(struct ieee80211_vht_cap) +</span>
<span class="p_add">+		    2 + sizeof(struct ieee80211_vht_operation) +</span>
 		    ifibss-&gt;ie_len;
 	presp = kzalloc(sizeof(*presp) + frame_len, GFP_KERNEL);
 	if (!presp)
<span class="p_chunk">@@ -487,14 +489,14 @@</span> <span class="p_context"> int ieee80211_ibss_csa_beacon(struct ieee80211_sub_if_data *sdata,</span>
 	struct beacon_data *presp, *old_presp;
 	struct cfg80211_bss *cbss;
 	const struct cfg80211_bss_ies *ies;
<span class="p_del">-	u16 capability = 0;</span>
<span class="p_add">+	u16 capability = WLAN_CAPABILITY_IBSS;</span>
 	u64 tsf;
 	int ret = 0;
 
 	sdata_assert_lock(sdata);
 
 	if (ifibss-&gt;privacy)
<span class="p_del">-		capability = WLAN_CAPABILITY_PRIVACY;</span>
<span class="p_add">+		capability |= WLAN_CAPABILITY_PRIVACY;</span>
 
 	cbss = cfg80211_get_bss(sdata-&gt;local-&gt;hw.wiphy, ifibss-&gt;chandef.chan,
 				ifibss-&gt;bssid, ifibss-&gt;ssid,
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index acaaf616da71..c45a0fcfb3e7 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -1585,12 +1585,16 @@</span> <span class="p_context"> ieee80211_rx_h_sta_process(struct ieee80211_rx_data *rx)</span>
 	 */
 	if (!ieee80211_hw_check(&amp;sta-&gt;local-&gt;hw, AP_LINK_PS) &amp;&amp;
 	    !ieee80211_has_morefrags(hdr-&gt;frame_control) &amp;&amp;
<span class="p_add">+	    !ieee80211_is_back_req(hdr-&gt;frame_control) &amp;&amp;</span>
 	    !(status-&gt;rx_flags &amp; IEEE80211_RX_DEFERRED_RELEASE) &amp;&amp;
 	    (rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP ||
 	     rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN) &amp;&amp;
<span class="p_del">-	    /* PM bit is only checked in frames where it isn&#39;t reserved,</span>
<span class="p_add">+	    /*</span>
<span class="p_add">+	     * PM bit is only checked in frames where it isn&#39;t reserved,</span>
 	     * in AP mode it&#39;s reserved in non-bufferable management frames
 	     * (cf. IEEE 802.11-2012 8.2.4.1.7 Power Management field)
<span class="p_add">+	     * BAR frames should be ignored as specified in</span>
<span class="p_add">+	     * IEEE 802.11-2012 10.2.1.2.</span>
 	     */
 	    (!ieee80211_is_mgmt(hdr-&gt;frame_control) ||
 	     ieee80211_is_bufferable_mmpdu(hdr-&gt;frame_control))) {
<span class="p_chunk">@@ -2467,7 +2471,8 @@</span> <span class="p_context"> ieee80211_rx_h_mesh_fwding(struct ieee80211_rx_data *rx)</span>
 		if (is_multicast_ether_addr(hdr-&gt;addr1)) {
 			mpp_addr = hdr-&gt;addr3;
 			proxied_addr = mesh_hdr-&gt;eaddr1;
<span class="p_del">-		} else if (mesh_hdr-&gt;flags &amp; MESH_FLAGS_AE_A5_A6) {</span>
<span class="p_add">+		} else if ((mesh_hdr-&gt;flags &amp; MESH_FLAGS_AE) ==</span>
<span class="p_add">+			    MESH_FLAGS_AE_A5_A6) {</span>
 			/* has_a4 already checked in ieee80211_rx_mesh_check */
 			mpp_addr = hdr-&gt;addr4;
 			proxied_addr = mesh_hdr-&gt;eaddr2;
<span class="p_chunk">@@ -3949,6 +3954,7 @@</span> <span class="p_context"> static bool ieee80211_invoke_fast_rx(struct ieee80211_rx_data *rx,</span>
 	stats-&gt;last_rate = sta_stats_encode_rate(status);
 
 	stats-&gt;fragments++;
<span class="p_add">+	stats-&gt;packets++;</span>
 
 	if (!(status-&gt;flag &amp; RX_FLAG_NO_SIGNAL_VAL)) {
 		stats-&gt;last_signal = status-&gt;signal;
<span class="p_header">diff --git a/net/mac80211/sta_info.c b/net/mac80211/sta_info.c</span>
<span class="p_header">index 8e05032689f0..b2c823ffad74 100644</span>
<span class="p_header">--- a/net/mac80211/sta_info.c</span>
<span class="p_header">+++ b/net/mac80211/sta_info.c</span>
<span class="p_chunk">@@ -2148,7 +2148,7 @@</span> <span class="p_context"> void sta_set_sinfo(struct sta_info *sta, struct station_info *sinfo)</span>
 			struct ieee80211_sta_rx_stats *cpurxs;
 
 			cpurxs = per_cpu_ptr(sta-&gt;pcpu_rx_stats, cpu);
<span class="p_del">-			sinfo-&gt;rx_packets += cpurxs-&gt;dropped;</span>
<span class="p_add">+			sinfo-&gt;rx_dropped_misc += cpurxs-&gt;dropped;</span>
 		}
 	}
 
<span class="p_header">diff --git a/net/mac80211/wpa.c b/net/mac80211/wpa.c</span>
<span class="p_header">index 42ce9bd4426f..5c71d60f3a64 100644</span>
<span class="p_header">--- a/net/mac80211/wpa.c</span>
<span class="p_header">+++ b/net/mac80211/wpa.c</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/unaligned.h&gt;
 #include &lt;net/mac80211.h&gt;
 #include &lt;crypto/aes.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 
 #include &quot;ieee80211_i.h&quot;
 #include &quot;michael.h&quot;
<span class="p_chunk">@@ -153,7 +154,7 @@</span> <span class="p_context"> ieee80211_rx_h_michael_mic_verify(struct ieee80211_rx_data *rx)</span>
 	data_len = skb-&gt;len - hdrlen - MICHAEL_MIC_LEN;
 	key = &amp;rx-&gt;key-&gt;conf.key[NL80211_TKIP_DATA_OFFSET_RX_MIC_KEY];
 	michael_mic(key, hdr, data, data_len, mic);
<span class="p_del">-	if (memcmp(mic, data + data_len, MICHAEL_MIC_LEN) != 0)</span>
<span class="p_add">+	if (crypto_memneq(mic, data + data_len, MICHAEL_MIC_LEN))</span>
 		goto mic_fail;
 
 	/* remove Michael MIC from payload */
<span class="p_chunk">@@ -1047,7 +1048,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_cmac_decrypt(struct ieee80211_rx_data *rx)</span>
 		bip_aad(skb, aad);
 		ieee80211_aes_cmac(key-&gt;u.aes_cmac.tfm, aad,
 				   skb-&gt;data + 24, skb-&gt;len - 24, mic);
<span class="p_del">-		if (memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		if (crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_cmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_chunk">@@ -1097,7 +1098,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_cmac_256_decrypt(struct ieee80211_rx_data *rx)</span>
 		bip_aad(skb, aad);
 		ieee80211_aes_cmac_256(key-&gt;u.aes_cmac.tfm, aad,
 				       skb-&gt;data + 24, skb-&gt;len - 24, mic);
<span class="p_del">-		if (memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		if (crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_cmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_chunk">@@ -1201,7 +1202,7 @@</span> <span class="p_context"> ieee80211_crypto_aes_gmac_decrypt(struct ieee80211_rx_data *rx)</span>
 		if (ieee80211_aes_gmac(key-&gt;u.aes_gmac.tfm, aad, nonce,
 				       skb-&gt;data + 24, skb-&gt;len - 24,
 				       mic) &lt; 0 ||
<span class="p_del">-		    memcmp(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic)) != 0) {</span>
<span class="p_add">+		    crypto_memneq(mic, mmie-&gt;mic, sizeof(mmie-&gt;mic))) {</span>
 			key-&gt;u.aes_gmac.icverrors++;
 			return RX_DROP_UNUSABLE;
 		}
<span class="p_header">diff --git a/net/wireless/util.c b/net/wireless/util.c</span>
<span class="p_header">index 659b507b347d..c921c2eed15d 100644</span>
<span class="p_header">--- a/net/wireless/util.c</span>
<span class="p_header">+++ b/net/wireless/util.c</span>
<span class="p_chunk">@@ -454,6 +454,8 @@</span> <span class="p_context"> int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,</span>
 	if (iftype == NL80211_IFTYPE_MESH_POINT)
 		skb_copy_bits(skb, hdrlen, &amp;mesh_flags, 1);
 
<span class="p_add">+	mesh_flags &amp;= MESH_FLAGS_AE;</span>
<span class="p_add">+</span>
 	switch (hdr-&gt;frame_control &amp;
 		cpu_to_le16(IEEE80211_FCTL_TODS | IEEE80211_FCTL_FROMDS)) {
 	case cpu_to_le16(IEEE80211_FCTL_TODS):
<span class="p_chunk">@@ -469,9 +471,9 @@</span> <span class="p_context"> int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,</span>
 			     iftype != NL80211_IFTYPE_STATION))
 			return -1;
 		if (iftype == NL80211_IFTYPE_MESH_POINT) {
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A4)</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A4)</span>
 				return -1;
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A5_A6) {</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A5_A6) {</span>
 				skb_copy_bits(skb, hdrlen +
 					offsetof(struct ieee80211s_hdr, eaddr1),
 					tmp.h_dest, 2 * ETH_ALEN);
<span class="p_chunk">@@ -487,9 +489,9 @@</span> <span class="p_context"> int ieee80211_data_to_8023_exthdr(struct sk_buff *skb, struct ethhdr *ehdr,</span>
 		     ether_addr_equal(tmp.h_source, addr)))
 			return -1;
 		if (iftype == NL80211_IFTYPE_MESH_POINT) {
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A5_A6)</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A5_A6)</span>
 				return -1;
<span class="p_del">-			if (mesh_flags &amp; MESH_FLAGS_AE_A4)</span>
<span class="p_add">+			if (mesh_flags == MESH_FLAGS_AE_A4)</span>
 				skb_copy_bits(skb, hdrlen +
 					offsetof(struct ieee80211s_hdr, eaddr1),
 					tmp.h_source, ETH_ALEN);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



