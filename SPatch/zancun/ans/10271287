
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.15.8 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.15.8</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 9, 2018, 4:54 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180309165415.GB29574@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10271287/mbox/"
   >mbox</a>
|
   <a href="/patch/10271287/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10271287/">/patch/10271287/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	65AFF60594 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Mar 2018 16:54:43 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2CC6929442
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Mar 2018 16:54:43 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 1E1F329C14; Fri,  9 Mar 2018 16:54:43 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id AAC1D29C60
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Mar 2018 16:54:35 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932299AbeCIQyc (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 9 Mar 2018 11:54:32 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:44390 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932230AbeCIQyP (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 9 Mar 2018 11:54:15 -0500
Received: from localhost (unknown [185.236.200.248])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id E6ABFE43;
	Fri,  9 Mar 2018 16:54:13 +0000 (UTC)
Date: Fri, 9 Mar 2018 08:54:15 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.15.8
Message-ID: &lt;20180309165415.GB29574@kroah.com&gt;
References: &lt;20180309165410.GA29574@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180309165410.GA29574@kroah.com&gt;
User-Agent: Mutt/1.9.4 (2018-02-28)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - March 9, 2018, 4:54 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/networking/ip-sysctl.txt b/Documentation/networking/ip-sysctl.txt</span>
<span class="p_header">index 46c7e1085efc..e269541a7d10 100644</span>
<span class="p_header">--- a/Documentation/networking/ip-sysctl.txt</span>
<span class="p_header">+++ b/Documentation/networking/ip-sysctl.txt</span>
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> tcp_rmem - vector of 3 INTEGERs: min, default, max</span>
 	min: Minimal size of receive buffer used by TCP sockets.
 	It is guaranteed to each TCP socket, even under moderate memory
 	pressure.
<span class="p_del">-	Default: 1 page</span>
<span class="p_add">+	Default: 4K</span>
 
 	default: initial size of receive buffer used by TCP sockets.
 	This value overrides net.core.rmem_default used by other protocols.
<span class="p_chunk">@@ -666,7 +666,7 @@</span> <span class="p_context"> tcp_window_scaling - BOOLEAN</span>
 tcp_wmem - vector of 3 INTEGERs: min, default, max
 	min: Amount of memory reserved for send buffers for TCP sockets.
 	Each TCP socket has rights to use it due to fact of its birth.
<span class="p_del">-	Default: 1 page</span>
<span class="p_add">+	Default: 4K</span>
 
 	default: initial size of send buffer used by TCP sockets.  This
 	value overrides net.core.wmem_default used by other protocols.
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 49f524444050..eb18d200a603 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 4
 PATCHLEVEL = 15
<span class="p_del">-SUBLEVEL = 7</span>
<span class="p_add">+SUBLEVEL = 8</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-som-lv.dtsi b/arch/arm/boot/dts/logicpd-som-lv.dtsi</span>
<span class="p_header">index 29cb804d10cc..06cce72508a2 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-som-lv.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-som-lv.dtsi</span>
<span class="p_chunk">@@ -98,6 +98,8 @@</span> <span class="p_context"></span>
 };
 
 &amp;i2c1 {
<span class="p_add">+	pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;i2c1_pins&gt;;</span>
 	clock-frequency = &lt;2600000&gt;;
 
 	twl: twl@48 {
<span class="p_chunk">@@ -216,7 +218,12 @@</span> <span class="p_context"></span>
 		&gt;;
 	};
 
<span class="p_del">-</span>
<span class="p_add">+	i2c1_pins: pinmux_i2c1_pins {</span>
<span class="p_add">+		pinctrl-single,pins = &lt;</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21ba, PIN_INPUT | MUX_MODE0)        /* i2c1_scl.i2c1_scl */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21bc, PIN_INPUT | MUX_MODE0)        /* i2c1_sda.i2c1_sda */</span>
<span class="p_add">+		&gt;;</span>
<span class="p_add">+	};</span>
 };
 
 &amp;omap3_pmx_wkup {
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">index 6d89736c7b44..cf22b35f0a28 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_chunk">@@ -104,6 +104,8 @@</span> <span class="p_context"></span>
 };
 
 &amp;i2c1 {
<span class="p_add">+	pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;i2c1_pins&gt;;</span>
 	clock-frequency = &lt;2600000&gt;;
 
 	twl: twl@48 {
<span class="p_chunk">@@ -211,6 +213,12 @@</span> <span class="p_context"></span>
 			OMAP3_CORE1_IOPAD(0x21b8, PIN_INPUT | MUX_MODE0)	/* hsusb0_data7.hsusb0_data7 */
 		&gt;;
 	};
<span class="p_add">+	i2c1_pins: pinmux_i2c1_pins {</span>
<span class="p_add">+		pinctrl-single,pins = &lt;</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21ba, PIN_INPUT | MUX_MODE0)        /* i2c1_scl.i2c1_scl */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21bc, PIN_INPUT | MUX_MODE0)        /* i2c1_sda.i2c1_sda */</span>
<span class="p_add">+		&gt;;</span>
<span class="p_add">+	};</span>
 };
 
 &amp;uart2 {
<span class="p_header">diff --git a/arch/arm/boot/dts/rk3288-phycore-som.dtsi b/arch/arm/boot/dts/rk3288-phycore-som.dtsi</span>
<span class="p_header">index 99cfae875e12..5eae4776ffde 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/rk3288-phycore-som.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/rk3288-phycore-som.dtsi</span>
<span class="p_chunk">@@ -110,26 +110,6 @@</span> <span class="p_context"></span>
 	};
 };
 
<span class="p_del">-&amp;cpu0 {</span>
<span class="p_del">-	cpu0-supply = &lt;&amp;vdd_cpu&gt;;</span>
<span class="p_del">-	operating-points = &lt;</span>
<span class="p_del">-		/* KHz    uV */</span>
<span class="p_del">-		1800000	1400000</span>
<span class="p_del">-		1608000	1350000</span>
<span class="p_del">-		1512000 1300000</span>
<span class="p_del">-		1416000 1200000</span>
<span class="p_del">-		1200000 1100000</span>
<span class="p_del">-		1008000 1050000</span>
<span class="p_del">-		 816000 1000000</span>
<span class="p_del">-		 696000  950000</span>
<span class="p_del">-		 600000  900000</span>
<span class="p_del">-		 408000  900000</span>
<span class="p_del">-		 312000  900000</span>
<span class="p_del">-		 216000  900000</span>
<span class="p_del">-		 126000  900000</span>
<span class="p_del">-	&gt;;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 &amp;emmc {
 	status = &quot;okay&quot;;
 	bus-width = &lt;8&gt;;
<span class="p_header">diff --git a/arch/arm/kvm/hyp/Makefile b/arch/arm/kvm/hyp/Makefile</span>
<span class="p_header">index 5638ce0c9524..63d6b404d88e 100644</span>
<span class="p_header">--- a/arch/arm/kvm/hyp/Makefile</span>
<span class="p_header">+++ b/arch/arm/kvm/hyp/Makefile</span>
<span class="p_chunk">@@ -7,6 +7,8 @@</span> <span class="p_context"> ccflags-y += -fno-stack-protector -DDISABLE_BRANCH_PROFILING</span>
 
 KVM=../../../../virt/kvm
 
<span class="p_add">+CFLAGS_ARMV7VE		   :=$(call cc-option, -march=armv7ve)</span>
<span class="p_add">+</span>
 obj-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/hyp/vgic-v2-sr.o
 obj-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/hyp/vgic-v3-sr.o
 obj-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/hyp/timer-sr.o
<span class="p_chunk">@@ -15,7 +17,10 @@</span> <span class="p_context"> obj-$(CONFIG_KVM_ARM_HOST) += tlb.o</span>
 obj-$(CONFIG_KVM_ARM_HOST) += cp15-sr.o
 obj-$(CONFIG_KVM_ARM_HOST) += vfp.o
 obj-$(CONFIG_KVM_ARM_HOST) += banked-sr.o
<span class="p_add">+CFLAGS_banked-sr.o	   += $(CFLAGS_ARMV7VE)</span>
<span class="p_add">+</span>
 obj-$(CONFIG_KVM_ARM_HOST) += entry.o
 obj-$(CONFIG_KVM_ARM_HOST) += hyp-entry.o
 obj-$(CONFIG_KVM_ARM_HOST) += switch.o
<span class="p_add">+CFLAGS_switch.o		   += $(CFLAGS_ARMV7VE)</span>
 obj-$(CONFIG_KVM_ARM_HOST) += s2-setup.o
<span class="p_header">diff --git a/arch/arm/kvm/hyp/banked-sr.c b/arch/arm/kvm/hyp/banked-sr.c</span>
<span class="p_header">index 111bda8cdebd..be4b8b0a40ad 100644</span>
<span class="p_header">--- a/arch/arm/kvm/hyp/banked-sr.c</span>
<span class="p_header">+++ b/arch/arm/kvm/hyp/banked-sr.c</span>
<span class="p_chunk">@@ -20,6 +20,10 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/kvm_hyp.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * gcc before 4.9 doesn&#39;t understand -march=armv7ve, so we have to</span>
<span class="p_add">+ * trick the assembler.</span>
<span class="p_add">+ */</span>
 __asm__(&quot;.arch_extension     virt&quot;);
 
 void __hyp_text __banked_save_state(struct kvm_cpu_context *ctxt)
<span class="p_header">diff --git a/arch/arm/mach-mvebu/Kconfig b/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_header">index 9b49867154bf..63fa79f9f121 100644</span>
<span class="p_header">--- a/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> config MACH_ARMADA_375</span>
 	depends on ARCH_MULTI_V7
 	select ARMADA_370_XP_IRQ
 	select ARM_ERRATA_720789
<span class="p_del">-	select ARM_ERRATA_753970</span>
<span class="p_add">+	select PL310_ERRATA_753970</span>
 	select ARM_GIC
 	select ARMADA_375_CLK
 	select HAVE_ARM_SCU
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> config MACH_ARMADA_38X</span>
 	bool &quot;Marvell Armada 380/385 boards&quot;
 	depends on ARCH_MULTI_V7
 	select ARM_ERRATA_720789
<span class="p_del">-	select ARM_ERRATA_753970</span>
<span class="p_add">+	select PL310_ERRATA_753970</span>
 	select ARM_GIC
 	select ARM_GLOBAL_TIMER
 	select CLKSRC_ARM_GLOBAL_TIMER_SCHED_CLOCK
<span class="p_header">diff --git a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c</span>
<span class="p_header">index aff6994950ba..a2399fd66e97 100644</span>
<span class="p_header">--- a/arch/arm/plat-orion/common.c</span>
<span class="p_header">+++ b/arch/arm/plat-orion/common.c</span>
<span class="p_chunk">@@ -472,28 +472,27 @@</span> <span class="p_context"> void __init orion_ge11_init(struct mv643xx_eth_platform_data *eth_data,</span>
 /*****************************************************************************
  * Ethernet switch
  ****************************************************************************/
<span class="p_del">-static __initconst const char *orion_ge00_mvmdio_bus_name = &quot;orion-mii&quot;;</span>
<span class="p_del">-static __initdata struct mdio_board_info</span>
<span class="p_del">-		  orion_ge00_switch_board_info;</span>
<span class="p_add">+static __initdata struct mdio_board_info orion_ge00_switch_board_info = {</span>
<span class="p_add">+	.bus_id   = &quot;orion-mii&quot;,</span>
<span class="p_add">+	.modalias = &quot;mv88e6085&quot;,</span>
<span class="p_add">+};</span>
 
 void __init orion_ge00_switch_init(struct dsa_chip_data *d)
 {
<span class="p_del">-	struct mdio_board_info *bd;</span>
 	unsigned int i;
 
 	if (!IS_BUILTIN(CONFIG_PHYLIB))
 		return;
 
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(d-&gt;port_names); i++)</span>
<span class="p_del">-		if (!strcmp(d-&gt;port_names[i], &quot;cpu&quot;))</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(d-&gt;port_names); i++) {</span>
<span class="p_add">+		if (!strcmp(d-&gt;port_names[i], &quot;cpu&quot;)) {</span>
<span class="p_add">+			d-&gt;netdev[i] = &amp;orion_ge00.dev;</span>
 			break;
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	bd = &amp;orion_ge00_switch_board_info;</span>
<span class="p_del">-	bd-&gt;bus_id = orion_ge00_mvmdio_bus_name;</span>
<span class="p_del">-	bd-&gt;mdio_addr = d-&gt;sw_addr;</span>
<span class="p_del">-	d-&gt;netdev[i] = &amp;orion_ge00.dev;</span>
<span class="p_del">-	strcpy(bd-&gt;modalias, &quot;mv88e6085&quot;);</span>
<span class="p_del">-	bd-&gt;platform_data = d;</span>
<span class="p_add">+	orion_ge00_switch_board_info.mdio_addr = d-&gt;sw_addr;</span>
<span class="p_add">+	orion_ge00_switch_board_info.platform_data = d;</span>
 
 	mdiobus_register_board_info(&amp;orion_ge00_switch_board_info, 1);
 }
<span class="p_header">diff --git a/arch/parisc/include/asm/cacheflush.h b/arch/parisc/include/asm/cacheflush.h</span>
<span class="p_header">index 3742508cc534..bd5ce31936f5 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/cacheflush.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/cacheflush.h</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"> void flush_user_icache_range_asm(unsigned long, unsigned long);</span>
 void flush_kernel_icache_range_asm(unsigned long, unsigned long);
 void flush_user_dcache_range_asm(unsigned long, unsigned long);
 void flush_kernel_dcache_range_asm(unsigned long, unsigned long);
<span class="p_add">+void purge_kernel_dcache_range_asm(unsigned long, unsigned long);</span>
 void flush_kernel_dcache_page_asm(void *);
 void flush_kernel_icache_page(void *);
 
<span class="p_header">diff --git a/arch/parisc/include/asm/processor.h b/arch/parisc/include/asm/processor.h</span>
<span class="p_header">index 0e6ab6e4a4e9..2dbe5580a1a4 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/processor.h</span>
<span class="p_chunk">@@ -316,6 +316,8 @@</span> <span class="p_context"> extern int _parisc_requires_coherency;</span>
 #define parisc_requires_coherency()	(0)
 #endif
 
<span class="p_add">+extern int running_on_qemu;</span>
<span class="p_add">+</span>
 #endif /* __ASSEMBLY__ */
 
 #endif /* __ASM_PARISC_PROCESSOR_H */
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index 19c0c141bc3f..79089778725b 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -465,10 +465,10 @@</span> <span class="p_context"> EXPORT_SYMBOL(copy_user_page);</span>
 int __flush_tlb_range(unsigned long sid, unsigned long start,
 		      unsigned long end)
 {
<span class="p_del">-	unsigned long flags, size;</span>
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_del">-	size = (end - start);</span>
<span class="p_del">-	if (size &gt;= parisc_tlb_flush_threshold) {</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    end - start &gt;= parisc_tlb_flush_threshold) {</span>
 		flush_tlb_all();
 		return 1;
 	}
<span class="p_chunk">@@ -539,13 +539,11 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 	struct vm_area_struct *vma;
 	pgd_t *pgd;
 
<span class="p_del">-	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_del">-	if (parisc_requires_coherency())</span>
<span class="p_del">-		flush_tlb_all();</span>
<span class="p_del">-</span>
 	/* Flushing the whole cache on each cpu takes forever on
 	   rp3440, etc.  So, avoid it if the mm isn&#39;t too big.  */
<span class="p_del">-	if (mm_total_size(mm) &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    mm_total_size(mm) &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+		flush_tlb_all();</span>
 		flush_cache_all();
 		return;
 	}
<span class="p_chunk">@@ -553,9 +551,9 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 	if (mm-&gt;context == mfsp(3)) {
 		for (vma = mm-&gt;mmap; vma; vma = vma-&gt;vm_next) {
 			flush_user_dcache_range_asm(vma-&gt;vm_start, vma-&gt;vm_end);
<span class="p_del">-			if ((vma-&gt;vm_flags &amp; VM_EXEC) == 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			flush_user_icache_range_asm(vma-&gt;vm_start, vma-&gt;vm_end);</span>
<span class="p_add">+			if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_add">+				flush_user_icache_range_asm(vma-&gt;vm_start, vma-&gt;vm_end);</span>
<span class="p_add">+			flush_tlb_range(vma, vma-&gt;vm_start, vma-&gt;vm_end);</span>
 		}
 		return;
 	}
<span class="p_chunk">@@ -581,14 +579,9 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 void flush_cache_range(struct vm_area_struct *vma,
 		unsigned long start, unsigned long end)
 {
<span class="p_del">-	BUG_ON(!vma-&gt;vm_mm-&gt;context);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_del">-	if (parisc_requires_coherency())</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    end - start &gt;= parisc_cache_flush_threshold) {</span>
 		flush_tlb_range(vma, start, end);
<span class="p_del">-</span>
<span class="p_del">-	if ((end - start) &gt;= parisc_cache_flush_threshold</span>
<span class="p_del">-	    || vma-&gt;vm_mm-&gt;context != mfsp(3)) {</span>
 		flush_cache_all();
 		return;
 	}
<span class="p_chunk">@@ -596,6 +589,7 @@</span> <span class="p_context"> void flush_cache_range(struct vm_area_struct *vma,</span>
 	flush_user_dcache_range_asm(start, end);
 	if (vma-&gt;vm_flags &amp; VM_EXEC)
 		flush_user_icache_range_asm(start, end);
<span class="p_add">+	flush_tlb_range(vma, start, end);</span>
 }
 
 void
<span class="p_chunk">@@ -604,8 +598,7 @@</span> <span class="p_context"> flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long</span>
 	BUG_ON(!vma-&gt;vm_mm-&gt;context);
 
 	if (pfn_valid(pfn)) {
<span class="p_del">-		if (parisc_requires_coherency())</span>
<span class="p_del">-			flush_tlb_page(vma, vmaddr);</span>
<span class="p_add">+		flush_tlb_page(vma, vmaddr);</span>
 		__flush_cache_page(vma, vmaddr, PFN_PHYS(pfn));
 	}
 }
<span class="p_chunk">@@ -613,21 +606,33 @@</span> <span class="p_context"> flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long</span>
 void flush_kernel_vmap_range(void *vaddr, int size)
 {
 	unsigned long start = (unsigned long)vaddr;
<span class="p_add">+	unsigned long end = start + size;</span>
 
<span class="p_del">-	if ((unsigned long)size &gt; parisc_cache_flush_threshold)</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    (unsigned long)size &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+		flush_tlb_kernel_range(start, end);</span>
 		flush_data_cache();
<span class="p_del">-	else</span>
<span class="p_del">-		flush_kernel_dcache_range_asm(start, start + size);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	flush_kernel_dcache_range_asm(start, end);</span>
<span class="p_add">+	flush_tlb_kernel_range(start, end);</span>
 }
 EXPORT_SYMBOL(flush_kernel_vmap_range);
 
 void invalidate_kernel_vmap_range(void *vaddr, int size)
 {
 	unsigned long start = (unsigned long)vaddr;
<span class="p_add">+	unsigned long end = start + size;</span>
 
<span class="p_del">-	if ((unsigned long)size &gt; parisc_cache_flush_threshold)</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    (unsigned long)size &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+		flush_tlb_kernel_range(start, end);</span>
 		flush_data_cache();
<span class="p_del">-	else</span>
<span class="p_del">-		flush_kernel_dcache_range_asm(start, start + size);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	purge_kernel_dcache_range_asm(start, end);</span>
<span class="p_add">+	flush_tlb_kernel_range(start, end);</span>
 }
 EXPORT_SYMBOL(invalidate_kernel_vmap_range);
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index 2d40c4ff3f69..67b0f7532e83 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -1110,6 +1110,28 @@</span> <span class="p_context"> ENTRY_CFI(flush_kernel_dcache_range_asm)</span>
 	.procend
 ENDPROC_CFI(flush_kernel_dcache_range_asm)
 
<span class="p_add">+ENTRY_CFI(purge_kernel_dcache_range_asm)</span>
<span class="p_add">+	.proc</span>
<span class="p_add">+	.callinfo NO_CALLS</span>
<span class="p_add">+	.entry</span>
<span class="p_add">+</span>
<span class="p_add">+	ldil		L%dcache_stride, %r1</span>
<span class="p_add">+	ldw		R%dcache_stride(%r1), %r23</span>
<span class="p_add">+	ldo		-1(%r23), %r21</span>
<span class="p_add">+	ANDCM		%r26, %r21, %r26</span>
<span class="p_add">+</span>
<span class="p_add">+1:      cmpb,COND(&lt;&lt;),n	%r26, %r25,1b</span>
<span class="p_add">+	pdc,m		%r23(%r26)</span>
<span class="p_add">+</span>
<span class="p_add">+	sync</span>
<span class="p_add">+	syncdma</span>
<span class="p_add">+	bv		%r0(%r2)</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	.exit</span>
<span class="p_add">+</span>
<span class="p_add">+	.procend</span>
<span class="p_add">+ENDPROC_CFI(purge_kernel_dcache_range_asm)</span>
<span class="p_add">+</span>
 ENTRY_CFI(flush_user_icache_range_asm)
 	.proc
 	.callinfo NO_CALLS
<span class="p_header">diff --git a/arch/parisc/kernel/time.c b/arch/parisc/kernel/time.c</span>
<span class="p_header">index 4b8fd6dc22da..f7e684560186 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/time.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/time.c</span>
<span class="p_chunk">@@ -76,10 +76,10 @@</span> <span class="p_context"> irqreturn_t __irq_entry timer_interrupt(int irq, void *dev_id)</span>
 	next_tick = cpuinfo-&gt;it_value;
 
 	/* Calculate how many ticks have elapsed. */
<span class="p_add">+	now = mfctl(16);</span>
 	do {
 		++ticks_elapsed;
 		next_tick += cpt;
<span class="p_del">-		now = mfctl(16);</span>
 	} while (next_tick - now &gt; cpt);
 
 	/* Store (in CR16 cycles) up to when we are accounting right now. */
<span class="p_chunk">@@ -103,16 +103,17 @@</span> <span class="p_context"> irqreturn_t __irq_entry timer_interrupt(int irq, void *dev_id)</span>
 	 * if one or the other wrapped. If &quot;now&quot; is &quot;bigger&quot; we&#39;ll end up
 	 * with a very large unsigned number.
 	 */
<span class="p_del">-	while (next_tick - mfctl(16) &gt; cpt)</span>
<span class="p_add">+	now = mfctl(16);</span>
<span class="p_add">+	while (next_tick - now &gt; cpt)</span>
 		next_tick += cpt;
 
 	/* Program the IT when to deliver the next interrupt.
 	 * Only bottom 32-bits of next_tick are writable in CR16!
 	 * Timer interrupt will be delivered at least a few hundred cycles
<span class="p_del">-	 * after the IT fires, so if we are too close (&lt;= 500 cycles) to the</span>
<span class="p_add">+	 * after the IT fires, so if we are too close (&lt;= 8000 cycles) to the</span>
 	 * next cycle, simply skip it.
 	 */
<span class="p_del">-	if (next_tick - mfctl(16) &lt;= 500)</span>
<span class="p_add">+	if (next_tick - now &lt;= 8000)</span>
 		next_tick += cpt;
 	mtctl(next_tick, 16);
 
<span class="p_chunk">@@ -248,7 +249,7 @@</span> <span class="p_context"> static int __init init_cr16_clocksource(void)</span>
 	 * different sockets, so mark them unstable and lower rating on
 	 * multi-socket SMP systems.
 	 */
<span class="p_del">-	if (num_online_cpus() &gt; 1) {</span>
<span class="p_add">+	if (num_online_cpus() &gt; 1 &amp;&amp; !running_on_qemu) {</span>
 		int cpu;
 		unsigned long cpu0_loc;
 		cpu0_loc = per_cpu(cpu_data, 0).cpu_loc;
<span class="p_header">diff --git a/arch/parisc/mm/init.c b/arch/parisc/mm/init.c</span>
<span class="p_header">index 48f41399fc0b..cab32ee824d2 100644</span>
<span class="p_header">--- a/arch/parisc/mm/init.c</span>
<span class="p_header">+++ b/arch/parisc/mm/init.c</span>
<span class="p_chunk">@@ -629,7 +629,12 @@</span> <span class="p_context"> void __init mem_init(void)</span>
 #endif
 
 	mem_init_print_info(NULL);
<span class="p_del">-#ifdef CONFIG_DEBUG_KERNEL /* double-sanity-check paranoia */</span>
<span class="p_add">+</span>
<span class="p_add">+#if 0</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Do not expose the virtual kernel memory layout to userspace.</span>
<span class="p_add">+	 * But keep code for debugging purposes.</span>
<span class="p_add">+	 */</span>
 	printk(&quot;virtual kernel memory layout:\n&quot;
 	       &quot;    vmalloc : 0x%px - 0x%px   (%4ld MB)\n&quot;
 	       &quot;    memory  : 0x%px - 0x%px   (%4ld MB)\n&quot;
<span class="p_header">diff --git a/arch/powerpc/mm/pgtable-radix.c b/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_header">index 17ae5c15a9e0..804ba030d859 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/pgtable-radix.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/pgalloc.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 #include &lt;asm/dma.h&gt;
 #include &lt;asm/machdep.h&gt;
 #include &lt;asm/mmu.h&gt;
<span class="p_chunk">@@ -334,6 +335,22 @@</span> <span class="p_context"> static void __init radix_init_pgtable(void)</span>
 		     &quot;r&quot; (TLBIEL_INVAL_SET_LPID), &quot;r&quot; (0));
 	asm volatile(&quot;eieio; tlbsync; ptesync&quot; : : : &quot;memory&quot;);
 	trace_tlbie(0, 0, TLBIEL_INVAL_SET_LPID, 0, 2, 1, 1);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The init_mm context is given the first available (non-zero) PID,</span>
<span class="p_add">+	 * which is the &quot;guard PID&quot; and contains no page table. PIDR should</span>
<span class="p_add">+	 * never be set to zero because that duplicates the kernel address</span>
<span class="p_add">+	 * space at the 0x0... offset (quadrant 0)!</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * An arbitrary PID that may later be allocated by the PID allocator</span>
<span class="p_add">+	 * for userspace processes must not be used either, because that</span>
<span class="p_add">+	 * would cause stale user mappings for that PID on CPUs outside of</span>
<span class="p_add">+	 * the TLB invalidation scheme (because it won&#39;t be in mm_cpumask).</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * So permanently carve out one PID for the purpose of a guard PID.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	init_mm.context.id = mmu_base_pid;</span>
<span class="p_add">+	mmu_base_pid++;</span>
 }
 
 static void __init radix_init_partition_table(void)
<span class="p_chunk">@@ -580,6 +597,8 @@</span> <span class="p_context"> void __init radix__early_init_mmu(void)</span>
 
 	radix_init_iamr();
 	radix_init_pgtable();
<span class="p_add">+	/* Switch to the guard PID before turning on MMU */</span>
<span class="p_add">+	radix__switch_mmu_context(NULL, &amp;init_mm);</span>
 }
 
 void radix__early_init_mmu_secondary(void)
<span class="p_chunk">@@ -601,6 +620,7 @@</span> <span class="p_context"> void radix__early_init_mmu_secondary(void)</span>
 		radix_init_amor();
 	}
 	radix_init_iamr();
<span class="p_add">+	radix__switch_mmu_context(NULL, &amp;init_mm);</span>
 }
 
 void radix__mmu_cleanup_all(void)
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/ras.c b/arch/powerpc/platforms/pseries/ras.c</span>
<span class="p_header">index 81d8614e7379..5e1ef9150182 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/ras.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/ras.c</span>
<span class="p_chunk">@@ -48,6 +48,28 @@</span> <span class="p_context"> static irqreturn_t ras_epow_interrupt(int irq, void *dev_id);</span>
 static irqreturn_t ras_error_interrupt(int irq, void *dev_id);
 
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Enable the hotplug interrupt late because processing them may touch other</span>
<span class="p_add">+ * devices or systems (e.g. hugepages) that have not been initialized at the</span>
<span class="p_add">+ * subsys stage.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __init init_ras_hotplug_IRQ(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *np;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Hotplug Events */</span>
<span class="p_add">+	np = of_find_node_by_path(&quot;/event-sources/hot-plug-events&quot;);</span>
<span class="p_add">+	if (np != NULL) {</span>
<span class="p_add">+		if (dlpar_workqueue_init() == 0)</span>
<span class="p_add">+			request_event_sources_irqs(np, ras_hotplug_interrupt,</span>
<span class="p_add">+						   &quot;RAS_HOTPLUG&quot;);</span>
<span class="p_add">+		of_node_put(np);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+machine_late_initcall(pseries, init_ras_hotplug_IRQ);</span>
<span class="p_add">+</span>
 /*
  * Initialize handlers for the set of interrupts caused by hardware errors
  * and power system events.
<span class="p_chunk">@@ -66,15 +88,6 @@</span> <span class="p_context"> static int __init init_ras_IRQ(void)</span>
 		of_node_put(np);
 	}
 
<span class="p_del">-	/* Hotplug Events */</span>
<span class="p_del">-	np = of_find_node_by_path(&quot;/event-sources/hot-plug-events&quot;);</span>
<span class="p_del">-	if (np != NULL) {</span>
<span class="p_del">-		if (dlpar_workqueue_init() == 0)</span>
<span class="p_del">-			request_event_sources_irqs(np, ras_hotplug_interrupt,</span>
<span class="p_del">-					   &quot;RAS_HOTPLUG&quot;);</span>
<span class="p_del">-		of_node_put(np);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* EPOW Events */
 	np = of_find_node_by_path(&quot;/event-sources/epow-events&quot;);
 	if (np != NULL) {
<span class="p_header">diff --git a/arch/s390/kvm/interrupt.c b/arch/s390/kvm/interrupt.c</span>
<span class="p_header">index 024ad8bcc516..5b8089b0d3ee 100644</span>
<span class="p_header">--- a/arch/s390/kvm/interrupt.c</span>
<span class="p_header">+++ b/arch/s390/kvm/interrupt.c</span>
<span class="p_chunk">@@ -170,8 +170,15 @@</span> <span class="p_context"> static int ckc_interrupts_enabled(struct kvm_vcpu *vcpu)</span>
 
 static int ckc_irq_pending(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	if (vcpu-&gt;arch.sie_block-&gt;ckc &gt;= kvm_s390_get_tod_clock_fast(vcpu-&gt;kvm))</span>
<span class="p_add">+	const u64 now = kvm_s390_get_tod_clock_fast(vcpu-&gt;kvm);</span>
<span class="p_add">+	const u64 ckc = vcpu-&gt;arch.sie_block-&gt;ckc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (vcpu-&gt;arch.sie_block-&gt;gcr[0] &amp; 0x0020000000000000ul) {</span>
<span class="p_add">+		if ((s64)ckc &gt;= (s64)now)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+	} else if (ckc &gt;= now) {</span>
 		return 0;
<span class="p_add">+	}</span>
 	return ckc_interrupts_enabled(vcpu);
 }
 
<span class="p_chunk">@@ -1011,13 +1018,19 @@</span> <span class="p_context"> int kvm_cpu_has_pending_timer(struct kvm_vcpu *vcpu)</span>
 
 static u64 __calculate_sltime(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	u64 now, cputm, sltime = 0;</span>
<span class="p_add">+	const u64 now = kvm_s390_get_tod_clock_fast(vcpu-&gt;kvm);</span>
<span class="p_add">+	const u64 ckc = vcpu-&gt;arch.sie_block-&gt;ckc;</span>
<span class="p_add">+	u64 cputm, sltime = 0;</span>
 
 	if (ckc_interrupts_enabled(vcpu)) {
<span class="p_del">-		now = kvm_s390_get_tod_clock_fast(vcpu-&gt;kvm);</span>
<span class="p_del">-		sltime = tod_to_ns(vcpu-&gt;arch.sie_block-&gt;ckc - now);</span>
<span class="p_del">-		/* already expired or overflow? */</span>
<span class="p_del">-		if (!sltime || vcpu-&gt;arch.sie_block-&gt;ckc &lt;= now)</span>
<span class="p_add">+		if (vcpu-&gt;arch.sie_block-&gt;gcr[0] &amp; 0x0020000000000000ul) {</span>
<span class="p_add">+			if ((s64)now &lt; (s64)ckc)</span>
<span class="p_add">+				sltime = tod_to_ns((s64)ckc - (s64)now);</span>
<span class="p_add">+		} else if (now &lt; ckc) {</span>
<span class="p_add">+			sltime = tod_to_ns(ckc - now);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* already expired */</span>
<span class="p_add">+		if (!sltime)</span>
 			return 0;
 		if (cpu_timer_interrupts_enabled(vcpu)) {
 			cputm = kvm_s390_get_cpu_timer(vcpu);
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.c b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">index 1371dff2b90d..5c03e371b7b8 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.c</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.c</span>
<span class="p_chunk">@@ -166,6 +166,28 @@</span> <span class="p_context"> int kvm_arch_hardware_enable(void)</span>
 static void kvm_gmap_notifier(struct gmap *gmap, unsigned long start,
 			      unsigned long end);
 
<span class="p_add">+static void kvm_clock_sync_scb(struct kvm_s390_sie_block *scb, u64 delta)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 delta_idx = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The TOD jumps by delta, we have to compensate this by adding</span>
<span class="p_add">+	 * -delta to the epoch.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	delta = -delta;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* sign-extension - we&#39;re adding to signed values below */</span>
<span class="p_add">+	if ((s64)delta &lt; 0)</span>
<span class="p_add">+		delta_idx = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	scb-&gt;epoch += delta;</span>
<span class="p_add">+	if (scb-&gt;ecd &amp; ECD_MEF) {</span>
<span class="p_add">+		scb-&gt;epdx += delta_idx;</span>
<span class="p_add">+		if (scb-&gt;epoch &lt; delta)</span>
<span class="p_add">+			scb-&gt;epdx += 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * This callback is executed during stop_machine(). All CPUs are therefore
  * temporarily stopped. In order not to change guest behavior, we have to
<span class="p_chunk">@@ -181,13 +203,17 @@</span> <span class="p_context"> static int kvm_clock_sync(struct notifier_block *notifier, unsigned long val,</span>
 	unsigned long long *delta = v;
 
 	list_for_each_entry(kvm, &amp;vm_list, vm_list) {
<span class="p_del">-		kvm-&gt;arch.epoch -= *delta;</span>
 		kvm_for_each_vcpu(i, vcpu, kvm) {
<span class="p_del">-			vcpu-&gt;arch.sie_block-&gt;epoch -= *delta;</span>
<span class="p_add">+			kvm_clock_sync_scb(vcpu-&gt;arch.sie_block, *delta);</span>
<span class="p_add">+			if (i == 0) {</span>
<span class="p_add">+				kvm-&gt;arch.epoch = vcpu-&gt;arch.sie_block-&gt;epoch;</span>
<span class="p_add">+				kvm-&gt;arch.epdx = vcpu-&gt;arch.sie_block-&gt;epdx;</span>
<span class="p_add">+			}</span>
 			if (vcpu-&gt;arch.cputm_enabled)
 				vcpu-&gt;arch.cputm_start += *delta;
 			if (vcpu-&gt;arch.vsie_block)
<span class="p_del">-				vcpu-&gt;arch.vsie_block-&gt;epoch -= *delta;</span>
<span class="p_add">+				kvm_clock_sync_scb(vcpu-&gt;arch.vsie_block,</span>
<span class="p_add">+						   *delta);</span>
 		}
 	}
 	return NOTIFY_OK;
<span class="p_chunk">@@ -889,12 +915,9 @@</span> <span class="p_context"> static int kvm_s390_set_tod_ext(struct kvm *kvm, struct kvm_device_attr *attr)</span>
 	if (copy_from_user(&amp;gtod, (void __user *)attr-&gt;addr, sizeof(gtod)))
 		return -EFAULT;
 
<span class="p_del">-	if (test_kvm_facility(kvm, 139))</span>
<span class="p_del">-		kvm_s390_set_tod_clock_ext(kvm, &amp;gtod);</span>
<span class="p_del">-	else if (gtod.epoch_idx == 0)</span>
<span class="p_del">-		kvm_s390_set_tod_clock(kvm, gtod.tod);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (!test_kvm_facility(kvm, 139) &amp;&amp; gtod.epoch_idx)</span>
 		return -EINVAL;
<span class="p_add">+	kvm_s390_set_tod_clock(kvm, &amp;gtod);</span>
 
 	VM_EVENT(kvm, 3, &quot;SET: TOD extension: 0x%x, TOD base: 0x%llx&quot;,
 		gtod.epoch_idx, gtod.tod);
<span class="p_chunk">@@ -919,13 +942,14 @@</span> <span class="p_context"> static int kvm_s390_set_tod_high(struct kvm *kvm, struct kvm_device_attr *attr)</span>
 
 static int kvm_s390_set_tod_low(struct kvm *kvm, struct kvm_device_attr *attr)
 {
<span class="p_del">-	u64 gtod;</span>
<span class="p_add">+	struct kvm_s390_vm_tod_clock gtod = { 0 };</span>
 
<span class="p_del">-	if (copy_from_user(&amp;gtod, (void __user *)attr-&gt;addr, sizeof(gtod)))</span>
<span class="p_add">+	if (copy_from_user(&amp;gtod.tod, (void __user *)attr-&gt;addr,</span>
<span class="p_add">+			   sizeof(gtod.tod)))</span>
 		return -EFAULT;
 
<span class="p_del">-	kvm_s390_set_tod_clock(kvm, gtod);</span>
<span class="p_del">-	VM_EVENT(kvm, 3, &quot;SET: TOD base: 0x%llx&quot;, gtod);</span>
<span class="p_add">+	kvm_s390_set_tod_clock(kvm, &amp;gtod);</span>
<span class="p_add">+	VM_EVENT(kvm, 3, &quot;SET: TOD base: 0x%llx&quot;, gtod.tod);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2361,6 +2385,7 @@</span> <span class="p_context"> void kvm_arch_vcpu_postcreate(struct kvm_vcpu *vcpu)</span>
 	mutex_lock(&amp;vcpu-&gt;kvm-&gt;lock);
 	preempt_disable();
 	vcpu-&gt;arch.sie_block-&gt;epoch = vcpu-&gt;kvm-&gt;arch.epoch;
<span class="p_add">+	vcpu-&gt;arch.sie_block-&gt;epdx = vcpu-&gt;kvm-&gt;arch.epdx;</span>
 	preempt_enable();
 	mutex_unlock(&amp;vcpu-&gt;kvm-&gt;lock);
 	if (!kvm_is_ucontrol(vcpu-&gt;kvm)) {
<span class="p_chunk">@@ -2947,8 +2972,8 @@</span> <span class="p_context"> static int kvm_s390_handle_requests(struct kvm_vcpu *vcpu)</span>
 	return 0;
 }
 
<span class="p_del">-void kvm_s390_set_tod_clock_ext(struct kvm *kvm,</span>
<span class="p_del">-				 const struct kvm_s390_vm_tod_clock *gtod)</span>
<span class="p_add">+void kvm_s390_set_tod_clock(struct kvm *kvm,</span>
<span class="p_add">+			    const struct kvm_s390_vm_tod_clock *gtod)</span>
 {
 	struct kvm_vcpu *vcpu;
 	struct kvm_s390_tod_clock_ext htod;
<span class="p_chunk">@@ -2960,10 +2985,12 @@</span> <span class="p_context"> void kvm_s390_set_tod_clock_ext(struct kvm *kvm,</span>
 	get_tod_clock_ext((char *)&amp;htod);
 
 	kvm-&gt;arch.epoch = gtod-&gt;tod - htod.tod;
<span class="p_del">-	kvm-&gt;arch.epdx = gtod-&gt;epoch_idx - htod.epoch_idx;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (kvm-&gt;arch.epoch &gt; gtod-&gt;tod)</span>
<span class="p_del">-		kvm-&gt;arch.epdx -= 1;</span>
<span class="p_add">+	kvm-&gt;arch.epdx = 0;</span>
<span class="p_add">+	if (test_kvm_facility(kvm, 139)) {</span>
<span class="p_add">+		kvm-&gt;arch.epdx = gtod-&gt;epoch_idx - htod.epoch_idx;</span>
<span class="p_add">+		if (kvm-&gt;arch.epoch &gt; gtod-&gt;tod)</span>
<span class="p_add">+			kvm-&gt;arch.epdx -= 1;</span>
<span class="p_add">+	}</span>
 
 	kvm_s390_vcpu_block_all(kvm);
 	kvm_for_each_vcpu(i, vcpu, kvm) {
<span class="p_chunk">@@ -2976,22 +3003,6 @@</span> <span class="p_context"> void kvm_s390_set_tod_clock_ext(struct kvm *kvm,</span>
 	mutex_unlock(&amp;kvm-&gt;lock);
 }
 
<span class="p_del">-void kvm_s390_set_tod_clock(struct kvm *kvm, u64 tod)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct kvm_vcpu *vcpu;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;kvm-&gt;lock);</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-	kvm-&gt;arch.epoch = tod - get_tod_clock();</span>
<span class="p_del">-	kvm_s390_vcpu_block_all(kvm);</span>
<span class="p_del">-	kvm_for_each_vcpu(i, vcpu, kvm)</span>
<span class="p_del">-		vcpu-&gt;arch.sie_block-&gt;epoch = kvm-&gt;arch.epoch;</span>
<span class="p_del">-	kvm_s390_vcpu_unblock_all(kvm);</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-	mutex_unlock(&amp;kvm-&gt;lock);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * kvm_arch_fault_in_page - fault-in guest page if necessary
  * @vcpu: The corresponding virtual cpu
<span class="p_header">diff --git a/arch/s390/kvm/kvm-s390.h b/arch/s390/kvm/kvm-s390.h</span>
<span class="p_header">index 5e46ba429bcb..efa186f065fb 100644</span>
<span class="p_header">--- a/arch/s390/kvm/kvm-s390.h</span>
<span class="p_header">+++ b/arch/s390/kvm/kvm-s390.h</span>
<span class="p_chunk">@@ -268,9 +268,8 @@</span> <span class="p_context"> int kvm_s390_handle_sigp(struct kvm_vcpu *vcpu);</span>
 int kvm_s390_handle_sigp_pei(struct kvm_vcpu *vcpu);
 
 /* implemented in kvm-s390.c */
<span class="p_del">-void kvm_s390_set_tod_clock_ext(struct kvm *kvm,</span>
<span class="p_del">-				 const struct kvm_s390_vm_tod_clock *gtod);</span>
<span class="p_del">-void kvm_s390_set_tod_clock(struct kvm *kvm, u64 tod);</span>
<span class="p_add">+void kvm_s390_set_tod_clock(struct kvm *kvm,</span>
<span class="p_add">+			    const struct kvm_s390_vm_tod_clock *gtod);</span>
 long kvm_arch_fault_in_page(struct kvm_vcpu *vcpu, gpa_t gpa, int writable);
 int kvm_s390_store_status_unloaded(struct kvm_vcpu *vcpu, unsigned long addr);
 int kvm_s390_vcpu_store_status(struct kvm_vcpu *vcpu, unsigned long addr);
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index 0714bfa56da0..23bebdbbf490 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -81,9 +81,10 @@</span> <span class="p_context"> int kvm_s390_handle_e3(struct kvm_vcpu *vcpu)</span>
 /* Handle SCK (SET CLOCK) interception */
 static int handle_set_clock(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	struct kvm_s390_vm_tod_clock gtod = { 0 };</span>
 	int rc;
 	u8 ar;
<span class="p_del">-	u64 op2, val;</span>
<span class="p_add">+	u64 op2;</span>
 
 	if (vcpu-&gt;arch.sie_block-&gt;gpsw.mask &amp; PSW_MASK_PSTATE)
 		return kvm_s390_inject_program_int(vcpu, PGM_PRIVILEGED_OP);
<span class="p_chunk">@@ -91,12 +92,12 @@</span> <span class="p_context"> static int handle_set_clock(struct kvm_vcpu *vcpu)</span>
 	op2 = kvm_s390_get_base_disp_s(vcpu, &amp;ar);
 	if (op2 &amp; 7)	/* Operand must be on a doubleword boundary */
 		return kvm_s390_inject_program_int(vcpu, PGM_SPECIFICATION);
<span class="p_del">-	rc = read_guest(vcpu, op2, ar, &amp;val, sizeof(val));</span>
<span class="p_add">+	rc = read_guest(vcpu, op2, ar, &amp;gtod.tod, sizeof(gtod.tod));</span>
 	if (rc)
 		return kvm_s390_inject_prog_cond(vcpu, rc);
 
<span class="p_del">-	VCPU_EVENT(vcpu, 3, &quot;SCK: setting guest TOD to 0x%llx&quot;, val);</span>
<span class="p_del">-	kvm_s390_set_tod_clock(vcpu-&gt;kvm, val);</span>
<span class="p_add">+	VCPU_EVENT(vcpu, 3, &quot;SCK: setting guest TOD to 0x%llx&quot;, gtod.tod);</span>
<span class="p_add">+	kvm_s390_set_tod_clock(vcpu-&gt;kvm, &amp;gtod);</span>
 
 	kvm_s390_set_psw_cc(vcpu, 0);
 	return 0;
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable.h b/arch/x86/include/asm/pgtable.h</span>
<span class="p_header">index e42b8943cb1a..cd0dba7a2293 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -350,14 +350,14 @@</span> <span class="p_context"> static inline pmd_t pmd_set_flags(pmd_t pmd, pmdval_t set)</span>
 {
 	pmdval_t v = native_pmd_val(pmd);
 
<span class="p_del">-	return __pmd(v | set);</span>
<span class="p_add">+	return native_make_pmd(v | set);</span>
 }
 
 static inline pmd_t pmd_clear_flags(pmd_t pmd, pmdval_t clear)
 {
 	pmdval_t v = native_pmd_val(pmd);
 
<span class="p_del">-	return __pmd(v &amp; ~clear);</span>
<span class="p_add">+	return native_make_pmd(v &amp; ~clear);</span>
 }
 
 static inline pmd_t pmd_mkold(pmd_t pmd)
<span class="p_chunk">@@ -409,14 +409,14 @@</span> <span class="p_context"> static inline pud_t pud_set_flags(pud_t pud, pudval_t set)</span>
 {
 	pudval_t v = native_pud_val(pud);
 
<span class="p_del">-	return __pud(v | set);</span>
<span class="p_add">+	return native_make_pud(v | set);</span>
 }
 
 static inline pud_t pud_clear_flags(pud_t pud, pudval_t clear)
 {
 	pudval_t v = native_pud_val(pud);
 
<span class="p_del">-	return __pud(v &amp; ~clear);</span>
<span class="p_add">+	return native_make_pud(v &amp; ~clear);</span>
 }
 
 static inline pud_t pud_mkold(pud_t pud)
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable_32.h b/arch/x86/include/asm/pgtable_32.h</span>
<span class="p_header">index e55466760ff8..b3ec519e3982 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable_32.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable_32.h</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"> extern pmd_t initial_pg_pmd[];</span>
 static inline void pgtable_cache_init(void) { }
 static inline void check_pgt_cache(void) { }
 void paging_init(void);
<span class="p_add">+void sync_initial_page_table(void);</span>
 
 /*
  * Define this if things work differently on an i386 and an i486:
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable_64.h b/arch/x86/include/asm/pgtable_64.h</span>
<span class="p_header">index 81462e9a34f6..1149d2112b2e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable_64.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable_64.h</span>
<span class="p_chunk">@@ -28,6 +28,7 @@</span> <span class="p_context"> extern pgd_t init_top_pgt[];</span>
 #define swapper_pg_dir init_top_pgt
 
 extern void paging_init(void);
<span class="p_add">+static inline void sync_initial_page_table(void) { }</span>
 
 #define pte_ERROR(e)					\
 	pr_err(&quot;%s:%d: bad pte %p(%016lx)\n&quot;,		\
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h</span>
<span class="p_header">index 3696398a9475..246f15b4e64c 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable_types.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable_types.h</span>
<span class="p_chunk">@@ -323,6 +323,11 @@</span> <span class="p_context"> static inline pudval_t native_pud_val(pud_t pud)</span>
 #else
 #include &lt;asm-generic/pgtable-nopud.h&gt;
 
<span class="p_add">+static inline pud_t native_make_pud(pudval_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (pud_t) { .p4d.pgd = native_make_pgd(val) };</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline pudval_t native_pud_val(pud_t pud)
 {
 	return native_pgd_val(pud.p4d.pgd);
<span class="p_chunk">@@ -344,6 +349,11 @@</span> <span class="p_context"> static inline pmdval_t native_pmd_val(pmd_t pmd)</span>
 #else
 #include &lt;asm-generic/pgtable-nopmd.h&gt;
 
<span class="p_add">+static inline pmd_t native_make_pmd(pmdval_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (pmd_t) { .pud.p4d.pgd = native_make_pgd(val) };</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline pmdval_t native_pmd_val(pmd_t pmd)
 {
 	return native_pgd_val(pmd.pud.p4d.pgd);
<span class="p_header">diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c</span>
<span class="p_header">index 68d7ab81c62f..1fbe6b9fff37 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup.c</span>
<span class="p_chunk">@@ -1205,20 +1205,13 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 
 	kasan_init();
 
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	/* sync back kernel address range */</span>
<span class="p_del">-	clone_pgd_range(initial_page_table + KERNEL_PGD_BOUNDARY,</span>
<span class="p_del">-			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span>
<span class="p_del">-			KERNEL_PGD_PTRS);</span>
<span class="p_del">-</span>
 	/*
<span class="p_del">-	 * sync back low identity map too.  It is used for example</span>
<span class="p_del">-	 * in the 32-bit EFI stub.</span>
<span class="p_add">+	 * Sync back kernel address range.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * FIXME: Can the later sync in setup_cpu_entry_areas() replace</span>
<span class="p_add">+	 * this call?</span>
 	 */
<span class="p_del">-	clone_pgd_range(initial_page_table,</span>
<span class="p_del">-			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span>
<span class="p_del">-			min(KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	sync_initial_page_table();</span>
 
 	tboot_probe();
 
<span class="p_header">diff --git a/arch/x86/kernel/setup_percpu.c b/arch/x86/kernel/setup_percpu.c</span>
<span class="p_header">index 497aa766fab3..ea554f812ee1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup_percpu.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup_percpu.c</span>
<span class="p_chunk">@@ -287,24 +287,15 @@</span> <span class="p_context"> void __init setup_per_cpu_areas(void)</span>
 	/* Setup cpu initialized, callin, callout masks */
 	setup_cpu_local_masks();
 
<span class="p_del">-#ifdef CONFIG_X86_32</span>
 	/*
 	 * Sync back kernel address range again.  We already did this in
 	 * setup_arch(), but percpu data also needs to be available in
 	 * the smpboot asm.  We can&#39;t reliably pick up percpu mappings
 	 * using vmalloc_fault(), because exception dispatch needs
 	 * percpu data.
<span class="p_add">+	 *</span>
<span class="p_add">+	 * FIXME: Can the later sync in setup_cpu_entry_areas() replace</span>
<span class="p_add">+	 * this call?</span>
 	 */
<span class="p_del">-	clone_pgd_range(initial_page_table + KERNEL_PGD_BOUNDARY,</span>
<span class="p_del">-			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span>
<span class="p_del">-			KERNEL_PGD_PTRS);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * sync back low identity map too.  It is used for example</span>
<span class="p_del">-	 * in the 32-bit EFI stub.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	clone_pgd_range(initial_page_table,</span>
<span class="p_del">-			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span>
<span class="p_del">-			min(KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	sync_initial_page_table();</span>
 }
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index e2c1fb8d35ce..dbb8b476b41b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -1993,14 +1993,13 @@</span> <span class="p_context"> void kvm_lapic_set_base(struct kvm_vcpu *vcpu, u64 value)</span>
 
 void kvm_lapic_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
<span class="p_del">-	struct kvm_lapic *apic;</span>
<span class="p_add">+	struct kvm_lapic *apic = vcpu-&gt;arch.apic;</span>
 	int i;
 
<span class="p_del">-	apic_debug(&quot;%s\n&quot;, __func__);</span>
<span class="p_add">+	if (!apic)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	ASSERT(vcpu);</span>
<span class="p_del">-	apic = vcpu-&gt;arch.apic;</span>
<span class="p_del">-	ASSERT(apic != NULL);</span>
<span class="p_add">+	apic_debug(&quot;%s\n&quot;, __func__);</span>
 
 	/* Stop the timer in case it&#39;s a reset to an active apic */
 	hrtimer_cancel(&amp;apic-&gt;lapic_timer.timer);
<span class="p_chunk">@@ -2156,7 +2155,6 @@</span> <span class="p_context"> int kvm_create_lapic(struct kvm_vcpu *vcpu)</span>
 	 */
 	vcpu-&gt;arch.apic_base = MSR_IA32_APICBASE_ENABLE;
 	static_key_slow_inc(&amp;apic_sw_disabled.key); /* sw disabled at reset */
<span class="p_del">-	kvm_lapic_reset(vcpu, false);</span>
 	kvm_iodevice_init(&amp;apic-&gt;dev, &amp;apic_mmio_ops);
 
 	return 0;
<span class="p_chunk">@@ -2560,7 +2558,6 @@</span> <span class="p_context"> void kvm_apic_accept_events(struct kvm_vcpu *vcpu)</span>
 
 	pe = xchg(&amp;apic-&gt;pending_events, 0);
 	if (test_bit(KVM_APIC_INIT, &amp;pe)) {
<span class="p_del">-		kvm_lapic_reset(vcpu, true);</span>
 		kvm_vcpu_reset(vcpu, true);
 		if (kvm_vcpu_is_bsp(apic-&gt;vcpu))
 			vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index cc83bdcb65d1..e080dbe55360 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3017,7 +3017,7 @@</span> <span class="p_context"> static int kvm_handle_bad_page(struct kvm_vcpu *vcpu, gfn_t gfn, kvm_pfn_t pfn)</span>
 		return RET_PF_RETRY;
 	}
 
<span class="p_del">-	return -EFAULT;</span>
<span class="p_add">+	return RET_PF_EMULATE;</span>
 }
 
 static void transparent_hugepage_adjust(struct kvm_vcpu *vcpu,
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 4e3c79530526..3505afabce5d 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/kvm_para.h&gt;
 #include &lt;asm/irq_remapping.h&gt;
<span class="p_add">+#include &lt;asm/microcode.h&gt;</span>
 #include &lt;asm/nospec-branch.h&gt;
 
 #include &lt;asm/virtext.h&gt;
<span class="p_chunk">@@ -5029,7 +5030,7 @@</span> <span class="p_context"> static void svm_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * being speculatively taken.
 	 */
 	if (svm-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, svm-&gt;spec_ctrl);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, svm-&gt;spec_ctrl);</span>
 
 	asm volatile (
 		&quot;push %%&quot; _ASM_BP &quot;; \n\t&quot;
<span class="p_chunk">@@ -5138,11 +5139,11 @@</span> <span class="p_context"> static void svm_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * If the L02 MSR bitmap does not intercept the MSR, then we need to
 	 * save it.
 	 */
<span class="p_del">-	if (!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL))</span>
<span class="p_del">-		rdmsrl(MSR_IA32_SPEC_CTRL, svm-&gt;spec_ctrl);</span>
<span class="p_add">+	if (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))</span>
<span class="p_add">+		svm-&gt;spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);</span>
 
 	if (svm-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
 
 	/* Eliminate branch target predictions from guest mode */
 	vmexit_fill_RSB();
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 561d8937fac5..87b453eeae40 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -51,6 +51,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/irq_remapping.h&gt;
 #include &lt;asm/mmu_context.h&gt;
<span class="p_add">+#include &lt;asm/microcode.h&gt;</span>
 #include &lt;asm/nospec-branch.h&gt;
 
 #include &quot;trace.h&quot;
<span class="p_chunk">@@ -9443,7 +9444,7 @@</span> <span class="p_context"> static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * being speculatively taken.
 	 */
 	if (vmx-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, vmx-&gt;spec_ctrl);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, vmx-&gt;spec_ctrl);</span>
 
 	vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched;
 	asm(
<span class="p_chunk">@@ -9578,11 +9579,11 @@</span> <span class="p_context"> static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * If the L02 MSR bitmap does not intercept the MSR, then we need to
 	 * save it.
 	 */
<span class="p_del">-	if (!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL))</span>
<span class="p_del">-		rdmsrl(MSR_IA32_SPEC_CTRL, vmx-&gt;spec_ctrl);</span>
<span class="p_add">+	if (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))</span>
<span class="p_add">+		vmx-&gt;spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);</span>
 
 	if (vmx-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
 
 	/* Eliminate branch target predictions from guest mode */
 	vmexit_fill_RSB();
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 17f4eca37d22..a10da5052072 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -7835,6 +7835,8 @@</span> <span class="p_context"> void kvm_arch_vcpu_destroy(struct kvm_vcpu *vcpu)</span>
 
 void kvm_vcpu_reset(struct kvm_vcpu *vcpu, bool init_event)
 {
<span class="p_add">+	kvm_lapic_reset(vcpu, init_event);</span>
<span class="p_add">+</span>
 	vcpu-&gt;arch.hflags = 0;
 
 	vcpu-&gt;arch.smi_pending = 0;
<span class="p_chunk">@@ -8279,10 +8281,8 @@</span> <span class="p_context"> int __x86_set_memory_region(struct kvm *kvm, int id, gpa_t gpa, u32 size)</span>
 			return r;
 	}
 
<span class="p_del">-	if (!size) {</span>
<span class="p_del">-		r = vm_munmap(old.userspace_addr, old.npages * PAGE_SIZE);</span>
<span class="p_del">-		WARN_ON(r &lt; 0);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		vm_munmap(old.userspace_addr, old.npages * PAGE_SIZE);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/x86/mm/cpu_entry_area.c b/arch/x86/mm/cpu_entry_area.c</span>
<span class="p_header">index b9283cc27622..476d810639a8 100644</span>
<span class="p_header">--- a/arch/x86/mm/cpu_entry_area.c</span>
<span class="p_header">+++ b/arch/x86/mm/cpu_entry_area.c</span>
<span class="p_chunk">@@ -163,4 +163,10 @@</span> <span class="p_context"> void __init setup_cpu_entry_areas(void)</span>
 
 	for_each_possible_cpu(cpu)
 		setup_cpu_entry_area(cpu);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This is the last essential update to swapper_pgdir which needs</span>
<span class="p_add">+	 * to be synchronized to initial_page_table on 32bit.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sync_initial_page_table();</span>
 }
<span class="p_header">diff --git a/arch/x86/mm/init_32.c b/arch/x86/mm/init_32.c</span>
<span class="p_header">index 135c9a7898c7..3141e67ec24c 100644</span>
<span class="p_header">--- a/arch/x86/mm/init_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/init_32.c</span>
<span class="p_chunk">@@ -453,6 +453,21 @@</span> <span class="p_context"> static inline void permanent_kmaps_init(pgd_t *pgd_base)</span>
 }
 #endif /* CONFIG_HIGHMEM */
 
<span class="p_add">+void __init sync_initial_page_table(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	clone_pgd_range(initial_page_table + KERNEL_PGD_BOUNDARY,</span>
<span class="p_add">+			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span>
<span class="p_add">+			KERNEL_PGD_PTRS);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * sync back low identity map too.  It is used for example</span>
<span class="p_add">+	 * in the 32-bit EFI stub.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	clone_pgd_range(initial_page_table,</span>
<span class="p_add">+			swapper_pg_dir     + KERNEL_PGD_BOUNDARY,</span>
<span class="p_add">+			min(KERNEL_PGD_PTRS, KERNEL_PGD_BOUNDARY));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __init native_pagetable_init(void)
 {
 	unsigned long pfn, va;
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">index 86676cec99a1..09dd7f3cf621 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_chunk">@@ -79,7 +79,7 @@</span> <span class="p_context"> static void intel_mid_power_off(void)</span>
 
 static void intel_mid_reboot(void)
 {
<span class="p_del">-	intel_scu_ipc_simple_command(IPCMSG_COLD_BOOT, 0);</span>
<span class="p_add">+	intel_scu_ipc_simple_command(IPCMSG_COLD_RESET, 0);</span>
 }
 
 static unsigned long __init intel_mid_calibrate_tsc(void)
<span class="p_header">diff --git a/arch/x86/xen/suspend.c b/arch/x86/xen/suspend.c</span>
<span class="p_header">index d9f96cc5d743..1d83152c761b 100644</span>
<span class="p_header">--- a/arch/x86/xen/suspend.c</span>
<span class="p_header">+++ b/arch/x86/xen/suspend.c</span>
<span class="p_chunk">@@ -1,12 +1,15 @@</span> <span class="p_context"></span>
 // SPDX-License-Identifier: GPL-2.0
 #include &lt;linux/types.h&gt;
 #include &lt;linux/tick.h&gt;
<span class="p_add">+#include &lt;linux/percpu-defs.h&gt;</span>
 
 #include &lt;xen/xen.h&gt;
 #include &lt;xen/interface/xen.h&gt;
 #include &lt;xen/grant_table.h&gt;
 #include &lt;xen/events.h&gt;
 
<span class="p_add">+#include &lt;asm/cpufeatures.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr-index.h&gt;</span>
 #include &lt;asm/xen/hypercall.h&gt;
 #include &lt;asm/xen/page.h&gt;
 #include &lt;asm/fixmap.h&gt;
<span class="p_chunk">@@ -15,6 +18,8 @@</span> <span class="p_context"></span>
 #include &quot;mmu.h&quot;
 #include &quot;pmu.h&quot;
 
<span class="p_add">+static DEFINE_PER_CPU(u64, spec_ctrl);</span>
<span class="p_add">+</span>
 void xen_arch_pre_suspend(void)
 {
 	xen_save_time_memory_area();
<span class="p_chunk">@@ -35,6 +40,9 @@</span> <span class="p_context"> void xen_arch_post_suspend(int cancelled)</span>
 
 static void xen_vcpu_notify_restore(void *data)
 {
<span class="p_add">+	if (xen_pv_domain() &amp;&amp; boot_cpu_has(X86_FEATURE_SPEC_CTRL))</span>
<span class="p_add">+		wrmsrl(MSR_IA32_SPEC_CTRL, this_cpu_read(spec_ctrl));</span>
<span class="p_add">+</span>
 	/* Boot processor notified via generic timekeeping_resume() */
 	if (smp_processor_id() == 0)
 		return;
<span class="p_chunk">@@ -44,7 +52,15 @@</span> <span class="p_context"> static void xen_vcpu_notify_restore(void *data)</span>
 
 static void xen_vcpu_notify_suspend(void *data)
 {
<span class="p_add">+	u64 tmp;</span>
<span class="p_add">+</span>
 	tick_suspend_local();
<span class="p_add">+</span>
<span class="p_add">+	if (xen_pv_domain() &amp;&amp; boot_cpu_has(X86_FEATURE_SPEC_CTRL)) {</span>
<span class="p_add">+		rdmsrl(MSR_IA32_SPEC_CTRL, tmp);</span>
<span class="p_add">+		this_cpu_write(spec_ctrl, tmp);</span>
<span class="p_add">+		wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
<span class="p_add">+	}</span>
 }
 
 void xen_arch_resume(void)
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 82b92adf3477..b725d9e340c2 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -2401,7 +2401,7 @@</span> <span class="p_context"> blk_qc_t submit_bio(struct bio *bio)</span>
 		unsigned int count;
 
 		if (unlikely(bio_op(bio) == REQ_OP_WRITE_SAME))
<span class="p_del">-			count = queue_logical_block_size(bio-&gt;bi_disk-&gt;queue);</span>
<span class="p_add">+			count = queue_logical_block_size(bio-&gt;bi_disk-&gt;queue) &gt;&gt; 9;</span>
 		else
 			count = bio_sectors(bio);
 
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index 3d3797327491..5629f18b51bd 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -655,7 +655,6 @@</span> <span class="p_context"> static void __blk_mq_requeue_request(struct request *rq)</span>
 
 	trace_block_rq_requeue(q, rq);
 	wbt_requeue(q-&gt;rq_wb, &amp;rq-&gt;issue_stat);
<span class="p_del">-	blk_mq_sched_requeue_request(rq);</span>
 
 	if (test_and_clear_bit(REQ_ATOM_STARTED, &amp;rq-&gt;atomic_flags)) {
 		if (q-&gt;dma_drain_size &amp;&amp; blk_rq_bytes(rq))
<span class="p_chunk">@@ -667,6 +666,9 @@</span> <span class="p_context"> void blk_mq_requeue_request(struct request *rq, bool kick_requeue_list)</span>
 {
 	__blk_mq_requeue_request(rq);
 
<span class="p_add">+	/* this request will be re-inserted to io scheduler queue */</span>
<span class="p_add">+	blk_mq_sched_requeue_request(rq);</span>
<span class="p_add">+</span>
 	BUG_ON(blk_queued_rq(rq));
 	blk_mq_add_to_requeue_list(rq, true, kick_requeue_list);
 }
<span class="p_header">diff --git a/block/ioctl.c b/block/ioctl.c</span>
<span class="p_header">index 1668506d8ed8..3884d810efd2 100644</span>
<span class="p_header">--- a/block/ioctl.c</span>
<span class="p_header">+++ b/block/ioctl.c</span>
<span class="p_chunk">@@ -225,7 +225,7 @@</span> <span class="p_context"> static int blk_ioctl_discard(struct block_device *bdev, fmode_t mode,</span>
 
 	if (start + len &gt; i_size_read(bdev-&gt;bd_inode))
 		return -EINVAL;
<span class="p_del">-	truncate_inode_pages_range(mapping, start, start + len);</span>
<span class="p_add">+	truncate_inode_pages_range(mapping, start, start + len - 1);</span>
 	return blkdev_issue_discard(bdev, start &gt;&gt; 9, len &gt;&gt; 9,
 				    GFP_KERNEL, flags);
 }
<span class="p_header">diff --git a/block/kyber-iosched.c b/block/kyber-iosched.c</span>
<span class="p_header">index f95c60774ce8..0d6d25e32e1f 100644</span>
<span class="p_header">--- a/block/kyber-iosched.c</span>
<span class="p_header">+++ b/block/kyber-iosched.c</span>
<span class="p_chunk">@@ -833,6 +833,7 @@</span> <span class="p_context"> static struct elevator_type kyber_sched = {</span>
 		.limit_depth = kyber_limit_depth,
 		.prepare_request = kyber_prepare_request,
 		.finish_request = kyber_finish_request,
<span class="p_add">+		.requeue_request = kyber_finish_request,</span>
 		.completed_request = kyber_completed_request,
 		.dispatch_request = kyber_dispatch_request,
 		.has_work = kyber_has_work,
<span class="p_header">diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c</span>
<span class="p_header">index 4d0979e02a28..b6d58cc58f5f 100644</span>
<span class="p_header">--- a/drivers/acpi/bus.c</span>
<span class="p_header">+++ b/drivers/acpi/bus.c</span>
<span class="p_chunk">@@ -66,10 +66,37 @@</span> <span class="p_context"> static int set_copy_dsdt(const struct dmi_system_id *id)</span>
 	return 0;
 }
 #endif
<span class="p_add">+static int set_gbl_term_list(const struct dmi_system_id *id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	acpi_gbl_parse_table_as_term_list = 1;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-static const struct dmi_system_id dsdt_dmi_table[] __initconst = {</span>
<span class="p_add">+static const struct dmi_system_id acpi_quirks_dmi_table[] __initconst = {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Touchpad on Dell XPS 9570/Precision M5530 doesn&#39;t work under I2C</span>
<span class="p_add">+	 * mode.</span>
<span class="p_add">+	 * https://bugzilla.kernel.org/show_bug.cgi?id=198515</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_gbl_term_list,</span>
<span class="p_add">+		.ident = &quot;Dell Precision M5530&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Precision M5530&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_gbl_term_list,</span>
<span class="p_add">+		.ident = &quot;Dell XPS 15 9570&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;XPS 15 9570&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	/*
 	 * Invoke DSDT corruption work-around on all Toshiba Satellite.
<span class="p_add">+	 * DSDT will be copied to memory.</span>
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=14679
 	 */
 	{
<span class="p_chunk">@@ -83,7 +110,7 @@</span> <span class="p_context"> static const struct dmi_system_id dsdt_dmi_table[] __initconst = {</span>
 	{}
 };
 #else
<span class="p_del">-static const struct dmi_system_id dsdt_dmi_table[] __initconst = {</span>
<span class="p_add">+static const struct dmi_system_id acpi_quirks_dmi_table[] __initconst = {</span>
 	{}
 };
 #endif
<span class="p_chunk">@@ -1001,11 +1028,8 @@</span> <span class="p_context"> void __init acpi_early_init(void)</span>
 
 	acpi_permanent_mmap = true;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If the machine falls into the DMI check table,</span>
<span class="p_del">-	 * DSDT will be copied to memory</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	dmi_check_system(dsdt_dmi_table);</span>
<span class="p_add">+	/* Check machine-specific quirks */</span>
<span class="p_add">+	dmi_check_system(acpi_quirks_dmi_table);</span>
 
 	status = acpi_reallocate_root_table();
 	if (ACPI_FAILURE(status)) {
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 76980e78ae56..e71e54c478da 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/usb.h&gt;
 #include &lt;linux/usb/quirks.h&gt;
<span class="p_chunk">@@ -376,6 +377,21 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ }	/* Terminating entry */
 };
 
<span class="p_add">+/* The Bluetooth USB module build into some devices needs to be reset on resume,</span>
<span class="p_add">+ * this is a problem with the platform (likely shutting off all power) not with</span>
<span class="p_add">+ * the module itself. So we use a DMI list to match known broken platforms.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const struct dmi_system_id btusb_needs_reset_resume_table[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Lenovo Yoga 920 (QCA Rome device 0cf3:e300) */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo YOGA 920&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 #define BTUSB_MAX_ISOC_FRAMES	10
 
 #define BTUSB_INTR_RUNNING	0
<span class="p_chunk">@@ -3031,6 +3047,9 @@</span> <span class="p_context"> static int btusb_probe(struct usb_interface *intf,</span>
 	hdev-&gt;send   = btusb_send_frame;
 	hdev-&gt;notify = btusb_notify;
 
<span class="p_add">+	if (dmi_check_system(btusb_needs_reset_resume_table))</span>
<span class="p_add">+		interface_to_usbdev(intf)-&gt;quirks |= USB_QUIRK_RESET_RESUME;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 	err = btusb_config_oob_wake(hdev);
 	if (err)
<span class="p_chunk">@@ -3117,12 +3136,6 @@</span> <span class="p_context"> static int btusb_probe(struct usb_interface *intf,</span>
 	if (id-&gt;driver_info &amp; BTUSB_QCA_ROME) {
 		data-&gt;setup_on_usb = btusb_setup_qca;
 		hdev-&gt;set_bdaddr = btusb_set_bdaddr_ath3012;
<span class="p_del">-</span>
<span class="p_del">-		/* QCA Rome devices lose their updated firmware over suspend,</span>
<span class="p_del">-		 * but the USB hub doesn&#39;t notice any status change.</span>
<span class="p_del">-		 * explicitly request a device reset on resume.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		interface_to_usbdev(intf)-&gt;quirks |= USB_QUIRK_RESET_RESUME;</span>
 	}
 
 #ifdef CONFIG_BT_HCIBTUSB_RTL
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_si_intf.c b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">index 71fad747c0c7..7499b0cd8326 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_si_intf.c</span>
<span class="p_chunk">@@ -2045,6 +2045,7 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 	int rv = 0;
 	int i;
 	char *init_name = NULL;
<span class="p_add">+	bool platform_device_registered = false;</span>
 
 	pr_info(PFX &quot;Trying %s-specified %s state machine at %s address 0x%lx, slave address 0x%x, irq %d\n&quot;,
 		ipmi_addr_src_to_str(new_smi-&gt;io.addr_source),
<span class="p_chunk">@@ -2173,6 +2174,7 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 				rv);
 			goto out_err;
 		}
<span class="p_add">+		platform_device_registered = true;</span>
 	}
 
 	dev_set_drvdata(new_smi-&gt;io.dev, new_smi);
<span class="p_chunk">@@ -2279,10 +2281,11 @@</span> <span class="p_context"> static int try_smi_init(struct smi_info *new_smi)</span>
 	}
 
 	if (new_smi-&gt;pdev) {
<span class="p_del">-		platform_device_unregister(new_smi-&gt;pdev);</span>
<span class="p_add">+		if (platform_device_registered)</span>
<span class="p_add">+			platform_device_unregister(new_smi-&gt;pdev);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			platform_device_put(new_smi-&gt;pdev);</span>
 		new_smi-&gt;pdev = NULL;
<span class="p_del">-	} else if (new_smi-&gt;pdev) {</span>
<span class="p_del">-		platform_device_put(new_smi-&gt;pdev);</span>
 	}
 
 	kfree(init_name);
<span class="p_header">diff --git a/drivers/char/tpm/st33zp24/st33zp24.c b/drivers/char/tpm/st33zp24/st33zp24.c</span>
<span class="p_header">index 4d1dc8b46877..f95b9c75175b 100644</span>
<span class="p_header">--- a/drivers/char/tpm/st33zp24/st33zp24.c</span>
<span class="p_header">+++ b/drivers/char/tpm/st33zp24/st33zp24.c</span>
<span class="p_chunk">@@ -457,7 +457,7 @@</span> <span class="p_context"> static int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,</span>
 			    size_t count)
 {
 	int size = 0;
<span class="p_del">-	int expected;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (!chip)
 		return -EBUSY;
<span class="p_chunk">@@ -474,7 +474,7 @@</span> <span class="p_context"> static int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,</span>
 	}
 
 	expected = be32_to_cpu(*(__be32 *)(buf + 2));
<span class="p_del">-	if (expected &gt; count) {</span>
<span class="p_add">+	if (expected &gt; count || expected &lt; TPM_HEADER_SIZE) {</span>
 		size = -EIO;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/char/tpm/tpm-interface.c b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">index 1d6729be4cd6..3cec403a80b3 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-interface.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-interface.c</span>
<span class="p_chunk">@@ -1228,6 +1228,10 @@</span> <span class="p_context"> int tpm_get_random(u32 chip_num, u8 *out, size_t max)</span>
 			break;
 
 		recd = be32_to_cpu(tpm_cmd.params.getrandom_out.rng_data_len);
<span class="p_add">+		if (recd &gt; num_bytes) {</span>
<span class="p_add">+			total = -EFAULT;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
 		rlength = be32_to_cpu(tpm_cmd.header.out.length);
 		if (rlength &lt; offsetof(struct tpm_getrandom_out, rng_data) +
<span class="p_header">diff --git a/drivers/char/tpm/tpm2-cmd.c b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">index f40d20671a78..f6be08483ae6 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm2-cmd.c</span>
<span class="p_chunk">@@ -683,6 +683,10 @@</span> <span class="p_context"> static int tpm2_unseal_cmd(struct tpm_chip *chip,</span>
 	if (!rc) {
 		data_len = be16_to_cpup(
 			(__be16 *) &amp;buf.data[TPM_HEADER_SIZE + 4]);
<span class="p_add">+		if (data_len &lt; MIN_KEY_SIZE ||  data_len &gt; MAX_KEY_SIZE + 1) {</span>
<span class="p_add">+			rc = -EFAULT;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 
 		rlength = be32_to_cpu(((struct tpm2_cmd *)&amp;buf)
 					-&gt;header.out.length);
<span class="p_header">diff --git a/drivers/char/tpm/tpm_i2c_infineon.c b/drivers/char/tpm/tpm_i2c_infineon.c</span>
<span class="p_header">index 79d6bbb58e39..d5b44cadac56 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_i2c_infineon.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_i2c_infineon.c</span>
<span class="p_chunk">@@ -473,7 +473,8 @@</span> <span class="p_context"> static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 static int tpm_tis_i2c_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 {
 	int size = 0;
<span class="p_del">-	int expected, status;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (count &lt; TPM_HEADER_SIZE) {
 		size = -EIO;
<span class="p_chunk">@@ -488,7 +489,7 @@</span> <span class="p_context"> static int tpm_tis_i2c_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 	}
 
 	expected = be32_to_cpu(*(__be32 *)(buf + 2));
<span class="p_del">-	if ((size_t) expected &gt; count) {</span>
<span class="p_add">+	if (((size_t) expected &gt; count) || (expected &lt; TPM_HEADER_SIZE)) {</span>
 		size = -EIO;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/char/tpm/tpm_i2c_nuvoton.c b/drivers/char/tpm/tpm_i2c_nuvoton.c</span>
<span class="p_header">index c6428771841f..caa86b19c76d 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_i2c_nuvoton.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_i2c_nuvoton.c</span>
<span class="p_chunk">@@ -281,7 +281,11 @@</span> <span class="p_context"> static int i2c_nuvoton_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 	struct device *dev = chip-&gt;dev.parent;
 	struct i2c_client *client = to_i2c_client(dev);
 	s32 rc;
<span class="p_del">-	int expected, status, burst_count, retries, size = 0;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	int burst_count;</span>
<span class="p_add">+	int retries;</span>
<span class="p_add">+	int size = 0;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (count &lt; TPM_HEADER_SIZE) {
 		i2c_nuvoton_ready(chip);    /* return to idle */
<span class="p_chunk">@@ -323,7 +327,7 @@</span> <span class="p_context"> static int i2c_nuvoton_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 		 * to machine native
 		 */
 		expected = be32_to_cpu(*(__be32 *) (buf + 2));
<span class="p_del">-		if (expected &gt; count) {</span>
<span class="p_add">+		if (expected &gt; count || expected &lt; size) {</span>
 			dev_err(dev, &quot;%s() expected &gt; count\n&quot;, __func__);
 			size = -EIO;
 			continue;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_header">index fdde971bc810..7561922bc8f8 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_chunk">@@ -202,7 +202,8 @@</span> <span class="p_context"> static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&amp;chip-&gt;dev);
 	int size = 0;
<span class="p_del">-	int expected, status;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (count &lt; TPM_HEADER_SIZE) {
 		size = -EIO;
<span class="p_chunk">@@ -217,7 +218,7 @@</span> <span class="p_context"> static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 	}
 
 	expected = be32_to_cpu(*(__be32 *) (buf + 2));
<span class="p_del">-	if (expected &gt; count) {</span>
<span class="p_add">+	if (expected &gt; count || expected &lt; TPM_HEADER_SIZE) {</span>
 		size = -EIO;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/cpufreq/s3c24xx-cpufreq.c b/drivers/cpufreq/s3c24xx-cpufreq.c</span>
<span class="p_header">index 7b596fa38ad2..6bebc1f9f55a 100644</span>
<span class="p_header">--- a/drivers/cpufreq/s3c24xx-cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/s3c24xx-cpufreq.c</span>
<span class="p_chunk">@@ -351,7 +351,13 @@</span> <span class="p_context"> struct clk *s3c_cpufreq_clk_get(struct device *dev, const char *name)</span>
 static int s3c_cpufreq_init(struct cpufreq_policy *policy)
 {
 	policy-&gt;clk = clk_arm;
<span class="p_del">-	return cpufreq_generic_init(policy, ftab, cpu_cur.info-&gt;latency);</span>
<span class="p_add">+</span>
<span class="p_add">+	policy-&gt;cpuinfo.transition_latency = cpu_cur.info-&gt;latency;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ftab)</span>
<span class="p_add">+		return cpufreq_table_validate_and_show(policy, ftab);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int __init s3c_cpufreq_initclks(void)
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index f34430f99fd8..872100215ca0 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> static const u32 correrrthrsld[] = {</span>
  * sbridge structs
  */
 
<span class="p_del">-#define NUM_CHANNELS		4	/* Max channels per MC */</span>
<span class="p_add">+#define NUM_CHANNELS		6	/* Max channels per MC */</span>
 #define MAX_DIMMS		3	/* Max DIMMS per channel */
 #define KNL_MAX_CHAS		38	/* KNL max num. of Cache Home Agents */
 #define KNL_MAX_CHANNELS	6	/* KNL max num. of PCI channels */
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 4e4dee0ec2de..926542fbc892 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -8554,6 +8554,10 @@</span> <span class="p_context"> static int remove_and_add_spares(struct mddev *mddev,</span>
 	int removed = 0;
 	bool remove_some = false;
 
<span class="p_add">+	if (this &amp;&amp; test_bit(MD_RECOVERY_RUNNING, &amp;mddev-&gt;recovery))</span>
<span class="p_add">+		/* Mustn&#39;t remove devices when resync thread is running */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	rdev_for_each(rdev, mddev) {
 		if ((this == NULL || rdev == this) &amp;&amp;
 		    rdev-&gt;raid_disk &gt;= 0 &amp;&amp;
<span class="p_header">diff --git a/drivers/media/dvb-frontends/m88ds3103.c b/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_header">index 50bce68ffd66..65d157fe76d1 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_chunk">@@ -1262,11 +1262,12 @@</span> <span class="p_context"> static int m88ds3103_select(struct i2c_mux_core *muxc, u32 chan)</span>
  * New users must use I2C client binding directly!
  */
 struct dvb_frontend *m88ds3103_attach(const struct m88ds3103_config *cfg,
<span class="p_del">-		struct i2c_adapter *i2c, struct i2c_adapter **tuner_i2c_adapter)</span>
<span class="p_add">+				      struct i2c_adapter *i2c,</span>
<span class="p_add">+				      struct i2c_adapter **tuner_i2c_adapter)</span>
 {
 	struct i2c_client *client;
 	struct i2c_board_info board_info;
<span class="p_del">-	struct m88ds3103_platform_data pdata;</span>
<span class="p_add">+	struct m88ds3103_platform_data pdata = {};</span>
 
 	pdata.clk = cfg-&gt;clock;
 	pdata.i2c_wr_max = cfg-&gt;i2c_wr_max;
<span class="p_chunk">@@ -1409,6 +1410,8 @@</span> <span class="p_context"> static int m88ds3103_probe(struct i2c_client *client,</span>
 	case M88DS3103_CHIP_ID:
 		break;
 	default:
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		dev_err(&amp;client-&gt;dev, &quot;Unknown device. Chip_id=%02x\n&quot;, dev-&gt;chip_id);</span>
 		goto err_kfree;
 	}
 
<span class="p_header">diff --git a/drivers/mmc/host/dw_mmc-exynos.c b/drivers/mmc/host/dw_mmc-exynos.c</span>
<span class="p_header">index 35026795be28..fa41d9422d57 100644</span>
<span class="p_header">--- a/drivers/mmc/host/dw_mmc-exynos.c</span>
<span class="p_header">+++ b/drivers/mmc/host/dw_mmc-exynos.c</span>
<span class="p_chunk">@@ -487,6 +487,7 @@</span> <span class="p_context"> static unsigned long exynos_dwmmc_caps[4] = {</span>
 
 static const struct dw_mci_drv_data exynos_drv_data = {
 	.caps			= exynos_dwmmc_caps,
<span class="p_add">+	.num_caps		= ARRAY_SIZE(exynos_dwmmc_caps),</span>
 	.init			= dw_mci_exynos_priv_init,
 	.set_ios		= dw_mci_exynos_set_ios,
 	.parse_dt		= dw_mci_exynos_parse_dt,
<span class="p_header">diff --git a/drivers/mmc/host/dw_mmc-k3.c b/drivers/mmc/host/dw_mmc-k3.c</span>
<span class="p_header">index 73fd75c3c824..89cdb3d533bb 100644</span>
<span class="p_header">--- a/drivers/mmc/host/dw_mmc-k3.c</span>
<span class="p_header">+++ b/drivers/mmc/host/dw_mmc-k3.c</span>
<span class="p_chunk">@@ -135,6 +135,9 @@</span> <span class="p_context"> static int dw_mci_hi6220_parse_dt(struct dw_mci *host)</span>
 	if (priv-&gt;ctrl_id &lt; 0)
 		priv-&gt;ctrl_id = 0;
 
<span class="p_add">+	if (priv-&gt;ctrl_id &gt;= TIMING_MODE)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	host-&gt;priv = priv;
 	return 0;
 }
<span class="p_chunk">@@ -207,6 +210,7 @@</span> <span class="p_context"> static int dw_mci_hi6220_execute_tuning(struct dw_mci_slot *slot, u32 opcode)</span>
 
 static const struct dw_mci_drv_data hi6220_data = {
 	.caps			= dw_mci_hi6220_caps,
<span class="p_add">+	.num_caps		= ARRAY_SIZE(dw_mci_hi6220_caps),</span>
 	.switch_voltage		= dw_mci_hi6220_switch_voltage,
 	.set_ios		= dw_mci_hi6220_set_ios,
 	.parse_dt		= dw_mci_hi6220_parse_dt,
<span class="p_header">diff --git a/drivers/mmc/host/dw_mmc-rockchip.c b/drivers/mmc/host/dw_mmc-rockchip.c</span>
<span class="p_header">index a3f1c2b30145..339295212935 100644</span>
<span class="p_header">--- a/drivers/mmc/host/dw_mmc-rockchip.c</span>
<span class="p_header">+++ b/drivers/mmc/host/dw_mmc-rockchip.c</span>
<span class="p_chunk">@@ -319,6 +319,7 @@</span> <span class="p_context"> static const struct dw_mci_drv_data rk2928_drv_data = {</span>
 
 static const struct dw_mci_drv_data rk3288_drv_data = {
 	.caps			= dw_mci_rk3288_dwmmc_caps,
<span class="p_add">+	.num_caps		= ARRAY_SIZE(dw_mci_rk3288_dwmmc_caps),</span>
 	.set_ios		= dw_mci_rk3288_set_ios,
 	.execute_tuning		= dw_mci_rk3288_execute_tuning,
 	.parse_dt		= dw_mci_rk3288_parse_dt,
<span class="p_header">diff --git a/drivers/mmc/host/dw_mmc-zx.c b/drivers/mmc/host/dw_mmc-zx.c</span>
<span class="p_header">index d38e94ae2b85..c06b5393312f 100644</span>
<span class="p_header">--- a/drivers/mmc/host/dw_mmc-zx.c</span>
<span class="p_header">+++ b/drivers/mmc/host/dw_mmc-zx.c</span>
<span class="p_chunk">@@ -195,6 +195,7 @@</span> <span class="p_context"> static unsigned long zx_dwmmc_caps[3] = {</span>
 
 static const struct dw_mci_drv_data zx_drv_data = {
 	.caps			= zx_dwmmc_caps,
<span class="p_add">+	.num_caps		= ARRAY_SIZE(zx_dwmmc_caps),</span>
 	.execute_tuning		= dw_mci_zx_execute_tuning,
 	.prepare_hs400_tuning	= dw_mci_zx_prepare_hs400_tuning,
 	.parse_dt               = dw_mci_zx_parse_dt,
<span class="p_header">diff --git a/drivers/mmc/host/dw_mmc.c b/drivers/mmc/host/dw_mmc.c</span>
<span class="p_header">index 0aa39975f33b..d9b4acefed31 100644</span>
<span class="p_header">--- a/drivers/mmc/host/dw_mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/dw_mmc.c</span>
<span class="p_chunk">@@ -165,6 +165,8 @@</span> <span class="p_context"> static int dw_mci_regs_show(struct seq_file *s, void *v)</span>
 {
 	struct dw_mci *host = s-&gt;private;
 
<span class="p_add">+	pm_runtime_get_sync(host-&gt;dev);</span>
<span class="p_add">+</span>
 	seq_printf(s, &quot;STATUS:\t0x%08x\n&quot;, mci_readl(host, STATUS));
 	seq_printf(s, &quot;RINTSTS:\t0x%08x\n&quot;, mci_readl(host, RINTSTS));
 	seq_printf(s, &quot;CMD:\t0x%08x\n&quot;, mci_readl(host, CMD));
<span class="p_chunk">@@ -172,6 +174,8 @@</span> <span class="p_context"> static int dw_mci_regs_show(struct seq_file *s, void *v)</span>
 	seq_printf(s, &quot;INTMASK:\t0x%08x\n&quot;, mci_readl(host, INTMASK));
 	seq_printf(s, &quot;CLKENA:\t0x%08x\n&quot;, mci_readl(host, CLKENA));
 
<span class="p_add">+	pm_runtime_put_autosuspend(host-&gt;dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2778,12 +2782,57 @@</span> <span class="p_context"> static irqreturn_t dw_mci_interrupt(int irq, void *dev_id)</span>
 	return IRQ_HANDLED;
 }
 
<span class="p_add">+static int dw_mci_init_slot_caps(struct dw_mci_slot *slot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dw_mci *host = slot-&gt;host;</span>
<span class="p_add">+	const struct dw_mci_drv_data *drv_data = host-&gt;drv_data;</span>
<span class="p_add">+	struct mmc_host *mmc = slot-&gt;mmc;</span>
<span class="p_add">+	int ctrl_id;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (host-&gt;pdata-&gt;caps)</span>
<span class="p_add">+		mmc-&gt;caps = host-&gt;pdata-&gt;caps;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Support MMC_CAP_ERASE by default.</span>
<span class="p_add">+	 * It needs to use trim/discard/erase commands.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mmc-&gt;caps |= MMC_CAP_ERASE;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (host-&gt;pdata-&gt;pm_caps)</span>
<span class="p_add">+		mmc-&gt;pm_caps = host-&gt;pdata-&gt;pm_caps;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (host-&gt;dev-&gt;of_node) {</span>
<span class="p_add">+		ctrl_id = of_alias_get_id(host-&gt;dev-&gt;of_node, &quot;mshc&quot;);</span>
<span class="p_add">+		if (ctrl_id &lt; 0)</span>
<span class="p_add">+			ctrl_id = 0;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ctrl_id = to_platform_device(host-&gt;dev)-&gt;id;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (drv_data &amp;&amp; drv_data-&gt;caps) {</span>
<span class="p_add">+		if (ctrl_id &gt;= drv_data-&gt;num_caps) {</span>
<span class="p_add">+			dev_err(host-&gt;dev, &quot;invalid controller id %d\n&quot;,</span>
<span class="p_add">+				ctrl_id);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mmc-&gt;caps |= drv_data-&gt;caps[ctrl_id];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (host-&gt;pdata-&gt;caps2)</span>
<span class="p_add">+		mmc-&gt;caps2 = host-&gt;pdata-&gt;caps2;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Process SDIO IRQs through the sdio_irq_work. */</span>
<span class="p_add">+	if (mmc-&gt;caps &amp; MMC_CAP_SDIO_IRQ)</span>
<span class="p_add">+		mmc-&gt;caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int dw_mci_init_slot(struct dw_mci *host)
 {
 	struct mmc_host *mmc;
 	struct dw_mci_slot *slot;
<span class="p_del">-	const struct dw_mci_drv_data *drv_data = host-&gt;drv_data;</span>
<span class="p_del">-	int ctrl_id, ret;</span>
<span class="p_add">+	int ret;</span>
 	u32 freq[2];
 
 	mmc = mmc_alloc_host(sizeof(struct dw_mci_slot), host-&gt;dev);
<span class="p_chunk">@@ -2817,38 +2866,13 @@</span> <span class="p_context"> static int dw_mci_init_slot(struct dw_mci *host)</span>
 	if (!mmc-&gt;ocr_avail)
 		mmc-&gt;ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
 
<span class="p_del">-	if (host-&gt;pdata-&gt;caps)</span>
<span class="p_del">-		mmc-&gt;caps = host-&gt;pdata-&gt;caps;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Support MMC_CAP_ERASE by default.</span>
<span class="p_del">-	 * It needs to use trim/discard/erase commands.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mmc-&gt;caps |= MMC_CAP_ERASE;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (host-&gt;pdata-&gt;pm_caps)</span>
<span class="p_del">-		mmc-&gt;pm_caps = host-&gt;pdata-&gt;pm_caps;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (host-&gt;dev-&gt;of_node) {</span>
<span class="p_del">-		ctrl_id = of_alias_get_id(host-&gt;dev-&gt;of_node, &quot;mshc&quot;);</span>
<span class="p_del">-		if (ctrl_id &lt; 0)</span>
<span class="p_del">-			ctrl_id = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		ctrl_id = to_platform_device(host-&gt;dev)-&gt;id;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (drv_data &amp;&amp; drv_data-&gt;caps)</span>
<span class="p_del">-		mmc-&gt;caps |= drv_data-&gt;caps[ctrl_id];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (host-&gt;pdata-&gt;caps2)</span>
<span class="p_del">-		mmc-&gt;caps2 = host-&gt;pdata-&gt;caps2;</span>
<span class="p_del">-</span>
 	ret = mmc_of_parse(mmc);
 	if (ret)
 		goto err_host_allocated;
 
<span class="p_del">-	/* Process SDIO IRQs through the sdio_irq_work. */</span>
<span class="p_del">-	if (mmc-&gt;caps &amp; MMC_CAP_SDIO_IRQ)</span>
<span class="p_del">-		mmc-&gt;caps2 |= MMC_CAP2_SDIO_IRQ_NOTHREAD;</span>
<span class="p_add">+	ret = dw_mci_init_slot_caps(slot);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto err_host_allocated;</span>
 
 	/* Useful defaults if platform data is unset. */
 	if (host-&gt;use_dma == TRANS_MODE_IDMAC) {
<span class="p_header">diff --git a/drivers/mmc/host/dw_mmc.h b/drivers/mmc/host/dw_mmc.h</span>
<span class="p_header">index e3124f06a47e..1424bd490dd1 100644</span>
<span class="p_header">--- a/drivers/mmc/host/dw_mmc.h</span>
<span class="p_header">+++ b/drivers/mmc/host/dw_mmc.h</span>
<span class="p_chunk">@@ -543,6 +543,7 @@</span> <span class="p_context"> struct dw_mci_slot {</span>
 /**
  * dw_mci driver data - dw-mshc implementation specific driver data.
  * @caps: mmc subsystem specified capabilities of the controller(s).
<span class="p_add">+ * @num_caps: number of capabilities specified by @caps.</span>
  * @init: early implementation specific initialization.
  * @set_ios: handle bus specific extensions.
  * @parse_dt: parse implementation specific device tree properties.
<span class="p_chunk">@@ -554,6 +555,7 @@</span> <span class="p_context"> struct dw_mci_slot {</span>
  */
 struct dw_mci_drv_data {
 	unsigned long	*caps;
<span class="p_add">+	u32		num_caps;</span>
 	int		(*init)(struct dw_mci *host);
 	void		(*set_ios)(struct dw_mci *host, struct mmc_ios *ios);
 	int		(*parse_dt)(struct dw_mci *host);
<span class="p_header">diff --git a/drivers/mmc/host/sdhci-pci-core.c b/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_header">index 3e4f04fd5175..bf93e8b0b191 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci-pci-core.c</span>
<span class="p_chunk">@@ -593,9 +593,36 @@</span> <span class="p_context"> static void byt_read_dsm(struct sdhci_pci_slot *slot)</span>
 	slot-&gt;chip-&gt;rpm_retune = intel_host-&gt;d3_retune;
 }
 
<span class="p_del">-static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)</span>
<span class="p_add">+static int intel_execute_tuning(struct mmc_host *mmc, u32 opcode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = sdhci_execute_tuning(mmc, opcode);</span>
<span class="p_add">+	struct sdhci_host *host = mmc_priv(mmc);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Tuning can leave the IP in an active state (Buffer Read Enable bit</span>
<span class="p_add">+	 * set) which prevents the entry to low power states (i.e. S0i3). Data</span>
<span class="p_add">+	 * reset will clear it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sdhci_reset(host, SDHCI_RESET_DATA);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void byt_probe_slot(struct sdhci_pci_slot *slot)</span>
 {
<span class="p_add">+	struct mmc_host_ops *ops = &amp;slot-&gt;host-&gt;mmc_host_ops;</span>
<span class="p_add">+</span>
 	byt_read_dsm(slot);
<span class="p_add">+</span>
<span class="p_add">+	ops-&gt;execute_tuning = intel_execute_tuning;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int byt_emmc_probe_slot(struct sdhci_pci_slot *slot)</span>
<span class="p_add">+{</span>
<span class="p_add">+	byt_probe_slot(slot);</span>
 	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_8_BIT_DATA | MMC_CAP_NONREMOVABLE |
 				 MMC_CAP_HW_RESET | MMC_CAP_1_8V_DDR |
 				 MMC_CAP_CMD_DURING_TFR |
<span class="p_chunk">@@ -650,7 +677,7 @@</span> <span class="p_context"> static int ni_byt_sdio_probe_slot(struct sdhci_pci_slot *slot)</span>
 {
 	int err;
 
<span class="p_del">-	byt_read_dsm(slot);</span>
<span class="p_add">+	byt_probe_slot(slot);</span>
 
 	err = ni_set_max_freq(slot);
 	if (err)
<span class="p_chunk">@@ -663,7 +690,7 @@</span> <span class="p_context"> static int ni_byt_sdio_probe_slot(struct sdhci_pci_slot *slot)</span>
 
 static int byt_sdio_probe_slot(struct sdhci_pci_slot *slot)
 {
<span class="p_del">-	byt_read_dsm(slot);</span>
<span class="p_add">+	byt_probe_slot(slot);</span>
 	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_POWER_OFF_CARD | MMC_CAP_NONREMOVABLE |
 				 MMC_CAP_WAIT_WHILE_BUSY;
 	return 0;
<span class="p_chunk">@@ -671,7 +698,7 @@</span> <span class="p_context"> static int byt_sdio_probe_slot(struct sdhci_pci_slot *slot)</span>
 
 static int byt_sd_probe_slot(struct sdhci_pci_slot *slot)
 {
<span class="p_del">-	byt_read_dsm(slot);</span>
<span class="p_add">+	byt_probe_slot(slot);</span>
 	slot-&gt;host-&gt;mmc-&gt;caps |= MMC_CAP_WAIT_WHILE_BUSY |
 				 MMC_CAP_AGGRESSIVE_PM | MMC_CAP_CD_WAKE;
 	slot-&gt;cd_idx = 0;
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">index a74a8fbad53a..2e6075ce5dca 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-drv.c</span>
<span class="p_chunk">@@ -595,7 +595,7 @@</span> <span class="p_context"> static void xgbe_isr_task(unsigned long data)</span>
 
 		reissue_mask = 1 &lt;&lt; 0;
 		if (!pdata-&gt;per_channel_irq)
<span class="p_del">-			reissue_mask |= 0xffff &lt; 4;</span>
<span class="p_add">+			reissue_mask |= 0xffff &lt;&lt; 4;</span>
 
 		XP_IOWRITE(pdata, XP_INT_REISSUE_EN, reissue_mask);
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/amd/xgbe/xgbe-pci.c b/drivers/net/ethernet/amd/xgbe/xgbe-pci.c</span>
<span class="p_header">index 3e5833cf1fab..eb23f9ba1a9a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/amd/xgbe/xgbe-pci.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/amd/xgbe/xgbe-pci.c</span>
<span class="p_chunk">@@ -426,6 +426,8 @@</span> <span class="p_context"> static int xgbe_pci_resume(struct pci_dev *pdev)</span>
 	struct net_device *netdev = pdata-&gt;netdev;
 	int ret = 0;
 
<span class="p_add">+	XP_IOWRITE(pdata, XP_INT_EN, 0x1fffff);</span>
<span class="p_add">+</span>
 	pdata-&gt;lpm_ctrl &amp;= ~MDIO_CTRL1_LPOWER;
 	XMDIO_WRITE(pdata, MDIO_MMD_PCS, MDIO_CTRL1, pdata-&gt;lpm_ctrl);
 
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c</span>
<span class="p_header">index d699bf88d18f..6044fdcf6056 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/cxgb4/cudbg_lib.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> int cudbg_collect_cim_la(struct cudbg_init *pdbg_init,</span>
 
 	if (is_t6(padap-&gt;params.chip)) {
 		size = padap-&gt;params.cim_la_size / 10 + 1;
<span class="p_del">-		size *= 11 * sizeof(u32);</span>
<span class="p_add">+		size *= 10 * sizeof(u32);</span>
 	} else {
 		size = padap-&gt;params.cim_la_size / 8;
 		size *= 8 * sizeof(u32);
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c</span>
<span class="p_header">index 29cc625e9833..97465101e0b9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_cudbg.c</span>
<span class="p_chunk">@@ -97,7 +97,7 @@</span> <span class="p_context"> static u32 cxgb4_get_entity_length(struct adapter *adap, u32 entity)</span>
 	case CUDBG_CIM_LA:
 		if (is_t6(adap-&gt;params.chip)) {
 			len = adap-&gt;params.cim_la_size / 10 + 1;
<span class="p_del">-			len *= 11 * sizeof(u32);</span>
<span class="p_add">+			len *= 10 * sizeof(u32);</span>
 		} else {
 			len = adap-&gt;params.cim_la_size / 8;
 			len *= 8 * sizeof(u32);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">index 62a18914f00f..a7113e702f58 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_main.c</span>
<span class="p_chunk">@@ -1878,6 +1878,14 @@</span> <span class="p_context"> static void ixgbe_dma_sync_frag(struct ixgbe_ring *rx_ring,</span>
 				     ixgbe_rx_pg_size(rx_ring),
 				     DMA_FROM_DEVICE,
 				     IXGBE_RX_DMA_ATTR);
<span class="p_add">+	} else if (ring_uses_build_skb(rx_ring)) {</span>
<span class="p_add">+		unsigned long offset = (unsigned long)(skb-&gt;data) &amp; ~PAGE_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+		dma_sync_single_range_for_cpu(rx_ring-&gt;dev,</span>
<span class="p_add">+					      IXGBE_CB(skb)-&gt;dma,</span>
<span class="p_add">+					      offset,</span>
<span class="p_add">+					      skb_headlen(skb),</span>
<span class="p_add">+					      DMA_FROM_DEVICE);</span>
 	} else {
 		struct skb_frag_struct *frag = &amp;skb_shinfo(skb)-&gt;frags[0];
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">index d8aefeed124d..0d352d4cf48c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_main.c</span>
<span class="p_chunk">@@ -1911,13 +1911,16 @@</span> <span class="p_context"> static void mlx5e_build_rq_param(struct mlx5e_priv *priv,</span>
 	param-&gt;wq.linear = 1;
 }
 
<span class="p_del">-static void mlx5e_build_drop_rq_param(struct mlx5e_rq_param *param)</span>
<span class="p_add">+static void mlx5e_build_drop_rq_param(struct mlx5_core_dev *mdev,</span>
<span class="p_add">+				      struct mlx5e_rq_param *param)</span>
 {
 	void *rqc = param-&gt;rqc;
 	void *wq = MLX5_ADDR_OF(rqc, rqc, wq);
 
 	MLX5_SET(wq, wq, wq_type, MLX5_WQ_TYPE_LINKED_LIST);
 	MLX5_SET(wq, wq, log_wq_stride,    ilog2(sizeof(struct mlx5e_rx_wqe)));
<span class="p_add">+</span>
<span class="p_add">+	param-&gt;wq.buf_numa_node = dev_to_node(&amp;mdev-&gt;pdev-&gt;dev);</span>
 }
 
 static void mlx5e_build_sq_param_common(struct mlx5e_priv *priv,
<span class="p_chunk">@@ -2774,6 +2777,9 @@</span> <span class="p_context"> static int mlx5e_alloc_drop_cq(struct mlx5_core_dev *mdev,</span>
 			       struct mlx5e_cq *cq,
 			       struct mlx5e_cq_param *param)
 {
<span class="p_add">+	param-&gt;wq.buf_numa_node = dev_to_node(&amp;mdev-&gt;pdev-&gt;dev);</span>
<span class="p_add">+	param-&gt;wq.db_numa_node  = dev_to_node(&amp;mdev-&gt;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	return mlx5e_alloc_cq_common(mdev, param, cq);
 }
 
<span class="p_chunk">@@ -2785,7 +2791,7 @@</span> <span class="p_context"> static int mlx5e_open_drop_rq(struct mlx5_core_dev *mdev,</span>
 	struct mlx5e_cq *cq = &amp;drop_rq-&gt;cq;
 	int err;
 
<span class="p_del">-	mlx5e_build_drop_rq_param(&amp;rq_param);</span>
<span class="p_add">+	mlx5e_build_drop_rq_param(mdev, &amp;rq_param);</span>
 
 	err = mlx5e_alloc_drop_cq(mdev, cq, &amp;cq_param);
 	if (err)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_header">index 5b499c7a698f..36611b64a91c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_rx.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/tcp.h&gt;
 #include &lt;linux/bpf_trace.h&gt;
 #include &lt;net/busy_poll.h&gt;
<span class="p_add">+#include &lt;net/ip6_checksum.h&gt;</span>
 #include &quot;en.h&quot;
 #include &quot;en_tc.h&quot;
 #include &quot;eswitch.h&quot;
<span class="p_chunk">@@ -547,20 +548,33 @@</span> <span class="p_context"> bool mlx5e_post_rx_mpwqes(struct mlx5e_rq *rq)</span>
 	return true;
 }
 
<span class="p_add">+static void mlx5e_lro_update_tcp_hdr(struct mlx5_cqe64 *cqe, struct tcphdr *tcp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 l4_hdr_type = get_cqe_l4_hdr_type(cqe);</span>
<span class="p_add">+	u8 tcp_ack     = (l4_hdr_type == CQE_L4_HDR_TYPE_TCP_ACK_NO_DATA) ||</span>
<span class="p_add">+			 (l4_hdr_type == CQE_L4_HDR_TYPE_TCP_ACK_AND_DATA);</span>
<span class="p_add">+</span>
<span class="p_add">+	tcp-&gt;check                      = 0;</span>
<span class="p_add">+	tcp-&gt;psh                        = get_cqe_lro_tcppsh(cqe);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tcp_ack) {</span>
<span class="p_add">+		tcp-&gt;ack                = 1;</span>
<span class="p_add">+		tcp-&gt;ack_seq            = cqe-&gt;lro_ack_seq_num;</span>
<span class="p_add">+		tcp-&gt;window             = cqe-&gt;lro_tcp_win;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void mlx5e_lro_update_hdr(struct sk_buff *skb, struct mlx5_cqe64 *cqe,
 				 u32 cqe_bcnt)
 {
 	struct ethhdr	*eth = (struct ethhdr *)(skb-&gt;data);
 	struct tcphdr	*tcp;
 	int network_depth = 0;
<span class="p_add">+	__wsum check;</span>
 	__be16 proto;
 	u16 tot_len;
 	void *ip_p;
 
<span class="p_del">-	u8 l4_hdr_type = get_cqe_l4_hdr_type(cqe);</span>
<span class="p_del">-	u8 tcp_ack = (l4_hdr_type == CQE_L4_HDR_TYPE_TCP_ACK_NO_DATA) ||</span>
<span class="p_del">-		(l4_hdr_type == CQE_L4_HDR_TYPE_TCP_ACK_AND_DATA);</span>
<span class="p_del">-</span>
 	proto = __vlan_get_protocol(skb, eth-&gt;h_proto, &amp;network_depth);
 
 	tot_len = cqe_bcnt - network_depth;
<span class="p_chunk">@@ -577,23 +591,30 @@</span> <span class="p_context"> static void mlx5e_lro_update_hdr(struct sk_buff *skb, struct mlx5_cqe64 *cqe,</span>
 		ipv4-&gt;check             = 0;
 		ipv4-&gt;check             = ip_fast_csum((unsigned char *)ipv4,
 						       ipv4-&gt;ihl);
<span class="p_add">+</span>
<span class="p_add">+		mlx5e_lro_update_tcp_hdr(cqe, tcp);</span>
<span class="p_add">+		check = csum_partial(tcp, tcp-&gt;doff * 4,</span>
<span class="p_add">+				     csum_unfold((__force __sum16)cqe-&gt;check_sum));</span>
<span class="p_add">+		/* Almost done, don&#39;t forget the pseudo header */</span>
<span class="p_add">+		tcp-&gt;check = csum_tcpudp_magic(ipv4-&gt;saddr, ipv4-&gt;daddr,</span>
<span class="p_add">+					       tot_len - sizeof(struct iphdr),</span>
<span class="p_add">+					       IPPROTO_TCP, check);</span>
 	} else {
<span class="p_add">+		u16 payload_len = tot_len - sizeof(struct ipv6hdr);</span>
 		struct ipv6hdr *ipv6 = ip_p;
 
 		tcp = ip_p + sizeof(struct ipv6hdr);
 		skb_shinfo(skb)-&gt;gso_type = SKB_GSO_TCPV6;
 
 		ipv6-&gt;hop_limit         = cqe-&gt;lro_min_ttl;
<span class="p_del">-		ipv6-&gt;payload_len       = cpu_to_be16(tot_len -</span>
<span class="p_del">-						      sizeof(struct ipv6hdr));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	tcp-&gt;psh = get_cqe_lro_tcppsh(cqe);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tcp_ack) {</span>
<span class="p_del">-		tcp-&gt;ack                = 1;</span>
<span class="p_del">-		tcp-&gt;ack_seq            = cqe-&gt;lro_ack_seq_num;</span>
<span class="p_del">-		tcp-&gt;window             = cqe-&gt;lro_tcp_win;</span>
<span class="p_add">+		ipv6-&gt;payload_len       = cpu_to_be16(payload_len);</span>
<span class="p_add">+</span>
<span class="p_add">+		mlx5e_lro_update_tcp_hdr(cqe, tcp);</span>
<span class="p_add">+		check = csum_partial(tcp, tcp-&gt;doff * 4,</span>
<span class="p_add">+				     csum_unfold((__force __sum16)cqe-&gt;check_sum));</span>
<span class="p_add">+		/* Almost done, don&#39;t forget the pseudo header */</span>
<span class="p_add">+		tcp-&gt;check = csum_ipv6_magic(&amp;ipv6-&gt;saddr, &amp;ipv6-&gt;daddr, payload_len,</span>
<span class="p_add">+					     IPPROTO_TCP, check);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c</span>
<span class="p_header">index 5a4608281f38..707976482c09 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_selftest.c</span>
<span class="p_chunk">@@ -216,7 +216,8 @@</span> <span class="p_context"> mlx5e_test_loopback_validate(struct sk_buff *skb,</span>
 	if (iph-&gt;protocol != IPPROTO_UDP)
 		goto out;
 
<span class="p_del">-	udph = udp_hdr(skb);</span>
<span class="p_add">+	/* Don&#39;t assume skb_transport_header() was set */</span>
<span class="p_add">+	udph = (struct udphdr *)((u8 *)iph + 4 * iph-&gt;ihl);</span>
 	if (udph-&gt;dest != htons(9))
 		goto out;
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c</span>
<span class="p_header">index 569b42a01026..11b4f1089d1c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/en_tx.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> static inline u16 mlx5e_calc_min_inline(enum mlx5_inline_modes mode,</span>
 	default:
 		hlen = mlx5e_skb_l2_header_offset(skb);
 	}
<span class="p_del">-	return min_t(u16, hlen, skb-&gt;len);</span>
<span class="p_add">+	return min_t(u16, hlen, skb_headlen(skb));</span>
 }
 
 static inline void mlx5e_tx_skb_pull_inline(unsigned char **skb_data,
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c</span>
<span class="p_header">index dfaad9ecb2b8..a681693631aa 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/fs_core.c</span>
<span class="p_chunk">@@ -1755,8 +1755,11 @@</span> <span class="p_context"> _mlx5_add_flow_rules(struct mlx5_flow_table *ft,</span>
 
 	/* Collect all fgs which has a matching match_criteria */
 	err = build_match_list(&amp;match_head, ft, spec);
<span class="p_del">-	if (err)</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		if (take_write)</span>
<span class="p_add">+			up_write_ref_node(&amp;ft-&gt;node);</span>
 		return ERR_PTR(err);
<span class="p_add">+	}</span>
 
 	if (!take_write)
 		up_read_ref_node(&amp;ft-&gt;node);
<span class="p_chunk">@@ -1765,8 +1768,11 @@</span> <span class="p_context"> _mlx5_add_flow_rules(struct mlx5_flow_table *ft,</span>
 				      dest_num, version);
 	free_match_list(&amp;match_head);
 	if (!IS_ERR(rule) ||
<span class="p_del">-	    (PTR_ERR(rule) != -ENOENT &amp;&amp; PTR_ERR(rule) != -EAGAIN))</span>
<span class="p_add">+	    (PTR_ERR(rule) != -ENOENT &amp;&amp; PTR_ERR(rule) != -EAGAIN)) {</span>
<span class="p_add">+		if (take_write)</span>
<span class="p_add">+			up_write_ref_node(&amp;ft-&gt;node);</span>
 		return rule;
<span class="p_add">+	}</span>
 
 	if (!take_write) {
 		nested_down_write_ref_node(&amp;ft-&gt;node, FS_LOCK_GRANDPARENT);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_header">index 7042c855a5d6..7e50dbc8282c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_router.c</span>
<span class="p_chunk">@@ -737,6 +737,9 @@</span> <span class="p_context"> static struct mlxsw_sp_vr *mlxsw_sp_vr_create(struct mlxsw_sp *mlxsw_sp,</span>
 					      u32 tb_id,
 					      struct netlink_ext_ack *extack)
 {
<span class="p_add">+	struct mlxsw_sp_mr_table *mr4_table;</span>
<span class="p_add">+	struct mlxsw_sp_fib *fib4;</span>
<span class="p_add">+	struct mlxsw_sp_fib *fib6;</span>
 	struct mlxsw_sp_vr *vr;
 	int err;
 
<span class="p_chunk">@@ -745,29 +748,30 @@</span> <span class="p_context"> static struct mlxsw_sp_vr *mlxsw_sp_vr_create(struct mlxsw_sp *mlxsw_sp,</span>
 		NL_SET_ERR_MSG(extack, &quot;spectrum: Exceeded number of supported virtual routers&quot;);
 		return ERR_PTR(-EBUSY);
 	}
<span class="p_del">-	vr-&gt;fib4 = mlxsw_sp_fib_create(vr, MLXSW_SP_L3_PROTO_IPV4);</span>
<span class="p_del">-	if (IS_ERR(vr-&gt;fib4))</span>
<span class="p_del">-		return ERR_CAST(vr-&gt;fib4);</span>
<span class="p_del">-	vr-&gt;fib6 = mlxsw_sp_fib_create(vr, MLXSW_SP_L3_PROTO_IPV6);</span>
<span class="p_del">-	if (IS_ERR(vr-&gt;fib6)) {</span>
<span class="p_del">-		err = PTR_ERR(vr-&gt;fib6);</span>
<span class="p_add">+	fib4 = mlxsw_sp_fib_create(vr, MLXSW_SP_L3_PROTO_IPV4);</span>
<span class="p_add">+	if (IS_ERR(fib4))</span>
<span class="p_add">+		return ERR_CAST(fib4);</span>
<span class="p_add">+	fib6 = mlxsw_sp_fib_create(vr, MLXSW_SP_L3_PROTO_IPV6);</span>
<span class="p_add">+	if (IS_ERR(fib6)) {</span>
<span class="p_add">+		err = PTR_ERR(fib6);</span>
 		goto err_fib6_create;
 	}
<span class="p_del">-	vr-&gt;mr4_table = mlxsw_sp_mr_table_create(mlxsw_sp, vr-&gt;id,</span>
<span class="p_del">-						 MLXSW_SP_L3_PROTO_IPV4);</span>
<span class="p_del">-	if (IS_ERR(vr-&gt;mr4_table)) {</span>
<span class="p_del">-		err = PTR_ERR(vr-&gt;mr4_table);</span>
<span class="p_add">+	mr4_table = mlxsw_sp_mr_table_create(mlxsw_sp, vr-&gt;id,</span>
<span class="p_add">+					     MLXSW_SP_L3_PROTO_IPV4);</span>
<span class="p_add">+	if (IS_ERR(mr4_table)) {</span>
<span class="p_add">+		err = PTR_ERR(mr4_table);</span>
 		goto err_mr_table_create;
 	}
<span class="p_add">+	vr-&gt;fib4 = fib4;</span>
<span class="p_add">+	vr-&gt;fib6 = fib6;</span>
<span class="p_add">+	vr-&gt;mr4_table = mr4_table;</span>
 	vr-&gt;tb_id = tb_id;
 	return vr;
 
 err_mr_table_create:
<span class="p_del">-	mlxsw_sp_fib_destroy(vr-&gt;fib6);</span>
<span class="p_del">-	vr-&gt;fib6 = NULL;</span>
<span class="p_add">+	mlxsw_sp_fib_destroy(fib6);</span>
 err_fib6_create:
<span class="p_del">-	mlxsw_sp_fib_destroy(vr-&gt;fib4);</span>
<span class="p_del">-	vr-&gt;fib4 = NULL;</span>
<span class="p_add">+	mlxsw_sp_fib_destroy(fib4);</span>
 	return ERR_PTR(err);
 }
 
<span class="p_chunk">@@ -3761,6 +3765,9 @@</span> <span class="p_context"> mlxsw_sp_fib4_entry_offload_unset(struct mlxsw_sp_fib_entry *fib_entry)</span>
 	struct mlxsw_sp_nexthop_group *nh_grp = fib_entry-&gt;nh_group;
 	int i;
 
<span class="p_add">+	if (!list_is_singular(&amp;nh_grp-&gt;fib_list))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; nh_grp-&gt;count; i++) {
 		struct mlxsw_sp_nexthop *nh = &amp;nh_grp-&gt;nexthops[i];
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c</span>
<span class="p_header">index 593ad31be749..161bcdc012f0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c</span>
<span class="p_chunk">@@ -1203,6 +1203,7 @@</span> <span class="p_context"> static int __mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u8 local_port,</span>
 				     bool dynamic)
 {
 	char *sfd_pl;
<span class="p_add">+	u8 num_rec;</span>
 	int err;
 
 	sfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);
<span class="p_chunk">@@ -1212,9 +1213,16 @@</span> <span class="p_context"> static int __mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u8 local_port,</span>
 	mlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);
 	mlxsw_reg_sfd_uc_pack(sfd_pl, 0, mlxsw_sp_sfd_rec_policy(dynamic),
 			      mac, fid, action, local_port);
<span class="p_add">+	num_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);</span>
 	err = mlxsw_reg_write(mlxsw_sp-&gt;core, MLXSW_REG(sfd), sfd_pl);
<span class="p_del">-	kfree(sfd_pl);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))</span>
<span class="p_add">+		err = -EBUSY;</span>
 
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(sfd_pl);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1239,6 +1247,7 @@</span> <span class="p_context"> static int mlxsw_sp_port_fdb_uc_lag_op(struct mlxsw_sp *mlxsw_sp, u16 lag_id,</span>
 				       bool adding, bool dynamic)
 {
 	char *sfd_pl;
<span class="p_add">+	u8 num_rec;</span>
 	int err;
 
 	sfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);
<span class="p_chunk">@@ -1249,9 +1258,16 @@</span> <span class="p_context"> static int mlxsw_sp_port_fdb_uc_lag_op(struct mlxsw_sp *mlxsw_sp, u16 lag_id,</span>
 	mlxsw_reg_sfd_uc_lag_pack(sfd_pl, 0, mlxsw_sp_sfd_rec_policy(dynamic),
 				  mac, fid, MLXSW_REG_SFD_REC_ACTION_NOP,
 				  lag_vid, lag_id);
<span class="p_add">+	num_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);</span>
 	err = mlxsw_reg_write(mlxsw_sp-&gt;core, MLXSW_REG(sfd), sfd_pl);
<span class="p_del">-	kfree(sfd_pl);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))</span>
<span class="p_add">+		err = -EBUSY;</span>
 
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(sfd_pl);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -1296,6 +1312,7 @@</span> <span class="p_context"> static int mlxsw_sp_port_mdb_op(struct mlxsw_sp *mlxsw_sp, const char *addr,</span>
 				u16 fid, u16 mid_idx, bool adding)
 {
 	char *sfd_pl;
<span class="p_add">+	u8 num_rec;</span>
 	int err;
 
 	sfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);
<span class="p_chunk">@@ -1305,7 +1322,15 @@</span> <span class="p_context"> static int mlxsw_sp_port_mdb_op(struct mlxsw_sp *mlxsw_sp, const char *addr,</span>
 	mlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);
 	mlxsw_reg_sfd_mc_pack(sfd_pl, 0, addr, fid,
 			      MLXSW_REG_SFD_REC_ACTION_NOP, mid_idx);
<span class="p_add">+	num_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);</span>
 	err = mlxsw_reg_write(mlxsw_sp-&gt;core, MLXSW_REG(sfd), sfd_pl);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	kfree(sfd_pl);
 	return err;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_header">index a73600dceb8b..a1ffc3ed77f9 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_chunk">@@ -1618,6 +1618,7 @@</span> <span class="p_context"> static netdev_tx_t cpsw_ndo_start_xmit(struct sk_buff *skb,</span>
 		q_idx = q_idx % cpsw-&gt;tx_ch_num;
 
 	txch = cpsw-&gt;txv[q_idx].ch;
<span class="p_add">+	txq = netdev_get_tx_queue(ndev, q_idx);</span>
 	ret = cpsw_tx_packet_submit(priv, skb, txch);
 	if (unlikely(ret != 0)) {
 		cpsw_err(priv, tx_err, &quot;desc submit failed\n&quot;);
<span class="p_chunk">@@ -1628,15 +1629,26 @@</span> <span class="p_context"> static netdev_tx_t cpsw_ndo_start_xmit(struct sk_buff *skb,</span>
 	 * tell the kernel to stop sending us tx frames.
 	 */
 	if (unlikely(!cpdma_check_free_tx_desc(txch))) {
<span class="p_del">-		txq = netdev_get_tx_queue(ndev, q_idx);</span>
 		netif_tx_stop_queue(txq);
<span class="p_add">+</span>
<span class="p_add">+		/* Barrier, so that stop_queue visible to other cpus */</span>
<span class="p_add">+		smp_mb__after_atomic();</span>
<span class="p_add">+</span>
<span class="p_add">+		if (cpdma_check_free_tx_desc(txch))</span>
<span class="p_add">+			netif_tx_wake_queue(txq);</span>
 	}
 
 	return NETDEV_TX_OK;
 fail:
 	ndev-&gt;stats.tx_dropped++;
<span class="p_del">-	txq = netdev_get_tx_queue(ndev, skb_get_queue_mapping(skb));</span>
 	netif_tx_stop_queue(txq);
<span class="p_add">+</span>
<span class="p_add">+	/* Barrier, so that stop_queue visible to other cpus */</span>
<span class="p_add">+	smp_mb__after_atomic();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpdma_check_free_tx_desc(txch))</span>
<span class="p_add">+		netif_tx_wake_queue(txq);</span>
<span class="p_add">+</span>
 	return NETDEV_TX_BUSY;
 }
 
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index ed10d1fc8f59..39de77a8bb63 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -841,10 +841,10 @@</span> <span class="p_context"> void phy_start(struct phy_device *phydev)</span>
 		break;
 	case PHY_HALTED:
 		/* if phy was suspended, bring the physical link up again */
<span class="p_del">-		phy_resume(phydev);</span>
<span class="p_add">+		__phy_resume(phydev);</span>
 
 		/* make sure interrupts are re-enabled for the PHY */
<span class="p_del">-		if (phydev-&gt;irq != PHY_POLL) {</span>
<span class="p_add">+		if (phy_interrupt_is_valid(phydev)) {</span>
 			err = phy_enable_interrupts(phydev);
 			if (err &lt; 0)
 				break;
<span class="p_header">diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c</span>
<span class="p_header">index b15b31ca2618..d312b314825e 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy_device.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy_device.c</span>
<span class="p_chunk">@@ -135,9 +135,7 @@</span> <span class="p_context"> static int mdio_bus_phy_resume(struct device *dev)</span>
 	if (!mdio_bus_phy_may_suspend(phydev))
 		goto no_resume;
 
<span class="p_del">-	mutex_lock(&amp;phydev-&gt;lock);</span>
 	ret = phy_resume(phydev);
<span class="p_del">-	mutex_unlock(&amp;phydev-&gt;lock);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_chunk">@@ -1028,9 +1026,7 @@</span> <span class="p_context"> int phy_attach_direct(struct net_device *dev, struct phy_device *phydev,</span>
 	if (err)
 		goto error;
 
<span class="p_del">-	mutex_lock(&amp;phydev-&gt;lock);</span>
 	phy_resume(phydev);
<span class="p_del">-	mutex_unlock(&amp;phydev-&gt;lock);</span>
 	phy_led_triggers_register(phydev);
 
 	return err;
<span class="p_chunk">@@ -1156,7 +1152,7 @@</span> <span class="p_context"> int phy_suspend(struct phy_device *phydev)</span>
 }
 EXPORT_SYMBOL(phy_suspend);
 
<span class="p_del">-int phy_resume(struct phy_device *phydev)</span>
<span class="p_add">+int __phy_resume(struct phy_device *phydev)</span>
 {
 	struct phy_driver *phydrv = to_phy_driver(phydev-&gt;mdio.dev.driver);
 	int ret = 0;
<span class="p_chunk">@@ -1173,6 +1169,18 @@</span> <span class="p_context"> int phy_resume(struct phy_device *phydev)</span>
 
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL(__phy_resume);</span>
<span class="p_add">+</span>
<span class="p_add">+int phy_resume(struct phy_device *phydev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;phydev-&gt;lock);</span>
<span class="p_add">+	ret = __phy_resume(phydev);</span>
<span class="p_add">+	mutex_unlock(&amp;phydev-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(phy_resume);
 
 int phy_loopback(struct phy_device *phydev, bool enable)
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index 264d4af0bf69..9f79f9274c50 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -3161,6 +3161,15 @@</span> <span class="p_context"> ppp_connect_channel(struct channel *pch, int unit)</span>
 		goto outl;
 
 	ppp_lock(ppp);
<span class="p_add">+	spin_lock_bh(&amp;pch-&gt;downl);</span>
<span class="p_add">+	if (!pch-&gt;chan) {</span>
<span class="p_add">+		/* Don&#39;t connect unregistered channels */</span>
<span class="p_add">+		spin_unlock_bh(&amp;pch-&gt;downl);</span>
<span class="p_add">+		ppp_unlock(ppp);</span>
<span class="p_add">+		ret = -ENOTCONN;</span>
<span class="p_add">+		goto outl;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;pch-&gt;downl);</span>
 	if (pch-&gt;file.hdrlen &gt; ppp-&gt;file.hdrlen)
 		ppp-&gt;file.hdrlen = pch-&gt;file.hdrlen;
 	hdrlen = pch-&gt;file.hdrlen + 2;	/* for protocol bytes */
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index e29cd5c7d39f..f50cf06c9353 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -1471,6 +1471,7 @@</span> <span class="p_context"> static struct sk_buff *tun_build_skb(struct tun_struct *tun,</span>
 	else
 		*skb_xdp = 0;
 
<span class="p_add">+	preempt_disable();</span>
 	rcu_read_lock();
 	xdp_prog = rcu_dereference(tun-&gt;xdp_prog);
 	if (xdp_prog &amp;&amp; !*skb_xdp) {
<span class="p_chunk">@@ -1490,9 +1491,11 @@</span> <span class="p_context"> static struct sk_buff *tun_build_skb(struct tun_struct *tun,</span>
 			get_page(alloc_frag-&gt;page);
 			alloc_frag-&gt;offset += buflen;
 			err = xdp_do_redirect(tun-&gt;dev, &amp;xdp, xdp_prog);
<span class="p_add">+			xdp_do_flush_map();</span>
 			if (err)
 				goto err_redirect;
 			rcu_read_unlock();
<span class="p_add">+			preempt_enable();</span>
 			return NULL;
 		case XDP_TX:
 			xdp_xmit = true;
<span class="p_chunk">@@ -1514,6 +1517,7 @@</span> <span class="p_context"> static struct sk_buff *tun_build_skb(struct tun_struct *tun,</span>
 	skb = build_skb(buf, buflen);
 	if (!skb) {
 		rcu_read_unlock();
<span class="p_add">+		preempt_enable();</span>
 		return ERR_PTR(-ENOMEM);
 	}
 
<span class="p_chunk">@@ -1526,10 +1530,12 @@</span> <span class="p_context"> static struct sk_buff *tun_build_skb(struct tun_struct *tun,</span>
 		skb-&gt;dev = tun-&gt;dev;
 		generic_xdp_tx(skb, xdp_prog);
 		rcu_read_unlock();
<span class="p_add">+		preempt_enable();</span>
 		return NULL;
 	}
 
 	rcu_read_unlock();
<span class="p_add">+	preempt_enable();</span>
 
 	return skb;
 
<span class="p_chunk">@@ -1537,6 +1543,7 @@</span> <span class="p_context"> static struct sk_buff *tun_build_skb(struct tun_struct *tun,</span>
 	put_page(alloc_frag-&gt;page);
 err_xdp:
 	rcu_read_unlock();
<span class="p_add">+	preempt_enable();</span>
 	this_cpu_inc(tun-&gt;pcpu_stats-&gt;rx_dropped);
 	return NULL;
 }
<span class="p_header">diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c</span>
<span class="p_header">index 559b215c0169..5907a8d0e921 100644</span>
<span class="p_header">--- a/drivers/net/virtio_net.c</span>
<span class="p_header">+++ b/drivers/net/virtio_net.c</span>
<span class="p_chunk">@@ -2040,8 +2040,9 @@</span> <span class="p_context"> static int virtnet_xdp_set(struct net_device *dev, struct bpf_prog *prog,</span>
 	}
 
 	/* Make sure NAPI is not using any XDP TX queues for RX. */
<span class="p_del">-	for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++)</span>
<span class="p_del">-		napi_disable(&amp;vi-&gt;rq[i].napi);</span>
<span class="p_add">+	if (netif_running(dev))</span>
<span class="p_add">+		for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++)</span>
<span class="p_add">+			napi_disable(&amp;vi-&gt;rq[i].napi);</span>
 
 	netif_set_real_num_rx_queues(dev, curr_qp + xdp_qp);
 	err = _virtnet_set_queues(vi, curr_qp + xdp_qp);
<span class="p_chunk">@@ -2060,7 +2061,8 @@</span> <span class="p_context"> static int virtnet_xdp_set(struct net_device *dev, struct bpf_prog *prog,</span>
 		}
 		if (old_prog)
 			bpf_prog_put(old_prog);
<span class="p_del">-		virtnet_napi_enable(vi-&gt;rq[i].vq, &amp;vi-&gt;rq[i].napi);</span>
<span class="p_add">+		if (netif_running(dev))</span>
<span class="p_add">+			virtnet_napi_enable(vi-&gt;rq[i].vq, &amp;vi-&gt;rq[i].napi);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/wan/hdlc_ppp.c b/drivers/net/wan/hdlc_ppp.c</span>
<span class="p_header">index afeca6bcdade..ab8b3cbbb205 100644</span>
<span class="p_header">--- a/drivers/net/wan/hdlc_ppp.c</span>
<span class="p_header">+++ b/drivers/net/wan/hdlc_ppp.c</span>
<span class="p_chunk">@@ -574,7 +574,10 @@</span> <span class="p_context"> static void ppp_timer(struct timer_list *t)</span>
 			ppp_cp_event(proto-&gt;dev, proto-&gt;pid, TO_GOOD, 0, 0,
 				     0, NULL);
 			proto-&gt;restart_counter--;
<span class="p_del">-		} else</span>
<span class="p_add">+		} else if (netif_carrier_ok(proto-&gt;dev))</span>
<span class="p_add">+			ppp_cp_event(proto-&gt;dev, proto-&gt;pid, TO_GOOD, 0, 0,</span>
<span class="p_add">+				     0, NULL);</span>
<span class="p_add">+		else</span>
 			ppp_cp_event(proto-&gt;dev, proto-&gt;pid, TO_BAD, 0, 0,
 				     0, NULL);
 		break;
<span class="p_header">diff --git a/drivers/platform/x86/dell-laptop.c b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">index cd4725e7e0b5..c864430b9fcf 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_chunk">@@ -78,7 +78,6 @@</span> <span class="p_context"> static struct platform_driver platform_driver = {</span>
 	}
 };
 
<span class="p_del">-static struct calling_interface_buffer *buffer;</span>
 static struct platform_device *platform_device;
 static struct backlight_device *dell_backlight_device;
 static struct rfkill *wifi_rfkill;
<span class="p_chunk">@@ -286,7 +285,8 @@</span> <span class="p_context"> static const struct dmi_system_id dell_quirks[] __initconst = {</span>
 	{ }
 };
 
<span class="p_del">-void dell_set_arguments(u32 arg0, u32 arg1, u32 arg2, u32 arg3)</span>
<span class="p_add">+static void dell_fill_request(struct calling_interface_buffer *buffer,</span>
<span class="p_add">+			      u32 arg0, u32 arg1, u32 arg2, u32 arg3)</span>
 {
 	memset(buffer, 0, sizeof(struct calling_interface_buffer));
 	buffer-&gt;input[0] = arg0;
<span class="p_chunk">@@ -295,7 +295,8 @@</span> <span class="p_context"> void dell_set_arguments(u32 arg0, u32 arg1, u32 arg2, u32 arg3)</span>
 	buffer-&gt;input[3] = arg3;
 }
 
<span class="p_del">-int dell_send_request(u16 class, u16 select)</span>
<span class="p_add">+static int dell_send_request(struct calling_interface_buffer *buffer,</span>
<span class="p_add">+			     u16 class, u16 select)</span>
 {
 	int ret;
 
<span class="p_chunk">@@ -432,21 +433,22 @@</span> <span class="p_context"> static int dell_rfkill_set(void *data, bool blocked)</span>
 	int disable = blocked ? 1 : 0;
 	unsigned long radio = (unsigned long)data;
 	int hwswitch_bit = (unsigned long)data - 1;
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	int hwswitch;
 	int status;
 	int ret;
 
<span class="p_del">-	dell_set_arguments(0, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
 	if (ret)
 		return ret;
<span class="p_del">-	status = buffer-&gt;output[1];</span>
<span class="p_add">+	status = buffer.output[1];</span>
 
<span class="p_del">-	dell_set_arguments(0x2, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0x2, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
 	if (ret)
 		return ret;
<span class="p_del">-	hwswitch = buffer-&gt;output[1];</span>
<span class="p_add">+	hwswitch = buffer.output[1];</span>
 
 	/* If the hardware switch controls this radio, and the hardware
 	   switch is disabled, always disable the radio */
<span class="p_chunk">@@ -454,8 +456,8 @@</span> <span class="p_context"> static int dell_rfkill_set(void *data, bool blocked)</span>
 	    (status &amp; BIT(0)) &amp;&amp; !(status &amp; BIT(16)))
 		disable = 1;
 
<span class="p_del">-	dell_set_arguments(1 | (radio&lt;&lt;8) | (disable &lt;&lt; 16), 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 1 | (radio&lt;&lt;8) | (disable &lt;&lt; 16), 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -464,9 +466,11 @@</span> <span class="p_context"> static void dell_rfkill_update_sw_state(struct rfkill *rfkill, int radio,</span>
 {
 	if (status &amp; BIT(0)) {
 		/* Has hw-switch, sync sw_state to BIOS */
<span class="p_add">+		struct calling_interface_buffer buffer;</span>
 		int block = rfkill_blocked(rfkill);
<span class="p_del">-		dell_set_arguments(1 | (radio &lt;&lt; 8) | (block &lt;&lt; 16), 0, 0, 0);</span>
<span class="p_del">-		dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+		dell_fill_request(&amp;buffer,</span>
<span class="p_add">+				   1 | (radio &lt;&lt; 8) | (block &lt;&lt; 16), 0, 0, 0);</span>
<span class="p_add">+		dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
 	} else {
 		/* No hw-switch, sync BIOS state to sw_state */
 		rfkill_set_sw_state(rfkill, !!(status &amp; BIT(radio + 16)));
<span class="p_chunk">@@ -483,21 +487,22 @@</span> <span class="p_context"> static void dell_rfkill_update_hw_state(struct rfkill *rfkill, int radio,</span>
 static void dell_rfkill_query(struct rfkill *rfkill, void *data)
 {
 	int radio = ((unsigned long)data &amp; 0xF);
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	int hwswitch;
 	int status;
 	int ret;
 
<span class="p_del">-	dell_set_arguments(0, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_del">-	status = buffer-&gt;output[1];</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	status = buffer.output[1];</span>
 
 	if (ret != 0 || !(status &amp; BIT(0))) {
 		return;
 	}
 
<span class="p_del">-	dell_set_arguments(0, 0x2, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_del">-	hwswitch = buffer-&gt;output[1];</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0x2, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	hwswitch = buffer.output[1];</span>
 
 	if (ret != 0)
 		return;
<span class="p_chunk">@@ -514,22 +519,23 @@</span> <span class="p_context"> static struct dentry *dell_laptop_dir;</span>
 
 static int dell_debugfs_show(struct seq_file *s, void *data)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	int hwswitch_state;
 	int hwswitch_ret;
 	int status;
 	int ret;
 
<span class="p_del">-	dell_set_arguments(0, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
 	if (ret)
 		return ret;
<span class="p_del">-	status = buffer-&gt;output[1];</span>
<span class="p_add">+	status = buffer.output[1];</span>
 
<span class="p_del">-	dell_set_arguments(0, 0x2, 0, 0);</span>
<span class="p_del">-	hwswitch_ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0x2, 0, 0);</span>
<span class="p_add">+	hwswitch_ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
 	if (hwswitch_ret)
 		return hwswitch_ret;
<span class="p_del">-	hwswitch_state = buffer-&gt;output[1];</span>
<span class="p_add">+	hwswitch_state = buffer.output[1];</span>
 
 	seq_printf(s, &quot;return:\t%d\n&quot;, ret);
 	seq_printf(s, &quot;status:\t0x%X\n&quot;, status);
<span class="p_chunk">@@ -610,22 +616,23 @@</span> <span class="p_context"> static const struct file_operations dell_debugfs_fops = {</span>
 
 static void dell_update_rfkill(struct work_struct *ignored)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	int hwswitch = 0;
 	int status;
 	int ret;
 
<span class="p_del">-	dell_set_arguments(0, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_del">-	status = buffer-&gt;output[1];</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	status = buffer.output[1];</span>
 
 	if (ret != 0)
 		return;
 
<span class="p_del">-	dell_set_arguments(0, 0x2, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0x2, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
 
 	if (ret == 0 &amp;&amp; (status &amp; BIT(0)))
<span class="p_del">-		hwswitch = buffer-&gt;output[1];</span>
<span class="p_add">+		hwswitch = buffer.output[1];</span>
 
 	if (wifi_rfkill) {
 		dell_rfkill_update_hw_state(wifi_rfkill, 1, status, hwswitch);
<span class="p_chunk">@@ -683,6 +690,7 @@</span> <span class="p_context"> static struct notifier_block dell_laptop_rbtn_notifier = {</span>
 
 static int __init dell_setup_rfkill(void)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	int status, ret, whitelisted;
 	const char *product;
 
<span class="p_chunk">@@ -698,9 +706,9 @@</span> <span class="p_context"> static int __init dell_setup_rfkill(void)</span>
 	if (!force_rfkill &amp;&amp; !whitelisted)
 		return 0;
 
<span class="p_del">-	dell_set_arguments(0, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_del">-	status = buffer-&gt;output[1];</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_INFO, SELECT_RFKILL);</span>
<span class="p_add">+	status = buffer.output[1];</span>
 
 	/* dell wireless info smbios call is not supported */
 	if (ret != 0)
<span class="p_chunk">@@ -853,6 +861,7 @@</span> <span class="p_context"> static void dell_cleanup_rfkill(void)</span>
 
 static int dell_send_intensity(struct backlight_device *bd)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	struct calling_interface_token *token;
 	int ret;
 
<span class="p_chunk">@@ -860,17 +869,21 @@</span> <span class="p_context"> static int dell_send_intensity(struct backlight_device *bd)</span>
 	if (!token)
 		return -ENODEV;
 
<span class="p_del">-	dell_set_arguments(token-&gt;location, bd-&gt;props.brightness, 0, 0);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer,</span>
<span class="p_add">+			   token-&gt;location, bd-&gt;props.brightness, 0, 0);</span>
 	if (power_supply_is_system_supplied() &gt; 0)
<span class="p_del">-		ret = dell_send_request(CLASS_TOKEN_WRITE, SELECT_TOKEN_AC);</span>
<span class="p_add">+		ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+					CLASS_TOKEN_WRITE, SELECT_TOKEN_AC);</span>
 	else
<span class="p_del">-		ret = dell_send_request(CLASS_TOKEN_WRITE, SELECT_TOKEN_BAT);</span>
<span class="p_add">+		ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+					CLASS_TOKEN_WRITE, SELECT_TOKEN_BAT);</span>
 
 	return ret;
 }
 
 static int dell_get_intensity(struct backlight_device *bd)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	struct calling_interface_token *token;
 	int ret;
 
<span class="p_chunk">@@ -878,14 +891,17 @@</span> <span class="p_context"> static int dell_get_intensity(struct backlight_device *bd)</span>
 	if (!token)
 		return -ENODEV;
 
<span class="p_del">-	dell_set_arguments(token-&gt;location, 0, 0, 0);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, token-&gt;location, 0, 0, 0);</span>
 	if (power_supply_is_system_supplied() &gt; 0)
<span class="p_del">-		ret = dell_send_request(CLASS_TOKEN_READ, SELECT_TOKEN_AC);</span>
<span class="p_add">+		ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+					CLASS_TOKEN_READ, SELECT_TOKEN_AC);</span>
 	else
<span class="p_del">-		ret = dell_send_request(CLASS_TOKEN_READ, SELECT_TOKEN_BAT);</span>
<span class="p_add">+		ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+					CLASS_TOKEN_READ, SELECT_TOKEN_BAT);</span>
 
 	if (ret == 0)
<span class="p_del">-		ret = buffer-&gt;output[1];</span>
<span class="p_add">+		ret = buffer.output[1];</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1149,31 +1165,33 @@</span> <span class="p_context"> static DEFINE_MUTEX(kbd_led_mutex);</span>
 
 static int kbd_get_info(struct kbd_info *info)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	u8 units;
 	int ret;
 
<span class="p_del">-	dell_set_arguments(0, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+				CLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	info-&gt;modes = buffer-&gt;output[1] &amp; 0xFFFF;</span>
<span class="p_del">-	info-&gt;type = (buffer-&gt;output[1] &gt;&gt; 24) &amp; 0xFF;</span>
<span class="p_del">-	info-&gt;triggers = buffer-&gt;output[2] &amp; 0xFF;</span>
<span class="p_del">-	units = (buffer-&gt;output[2] &gt;&gt; 8) &amp; 0xFF;</span>
<span class="p_del">-	info-&gt;levels = (buffer-&gt;output[2] &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_add">+	info-&gt;modes = buffer.output[1] &amp; 0xFFFF;</span>
<span class="p_add">+	info-&gt;type = (buffer.output[1] &gt;&gt; 24) &amp; 0xFF;</span>
<span class="p_add">+	info-&gt;triggers = buffer.output[2] &amp; 0xFF;</span>
<span class="p_add">+	units = (buffer.output[2] &gt;&gt; 8) &amp; 0xFF;</span>
<span class="p_add">+	info-&gt;levels = (buffer.output[2] &gt;&gt; 16) &amp; 0xFF;</span>
 
 	if (quirks &amp;&amp; quirks-&gt;kbd_led_levels_off_1 &amp;&amp; info-&gt;levels)
 		info-&gt;levels--;
 
 	if (units &amp; BIT(0))
<span class="p_del">-		info-&gt;seconds = (buffer-&gt;output[3] &gt;&gt; 0) &amp; 0xFF;</span>
<span class="p_add">+		info-&gt;seconds = (buffer.output[3] &gt;&gt; 0) &amp; 0xFF;</span>
 	if (units &amp; BIT(1))
<span class="p_del">-		info-&gt;minutes = (buffer-&gt;output[3] &gt;&gt; 8) &amp; 0xFF;</span>
<span class="p_add">+		info-&gt;minutes = (buffer.output[3] &gt;&gt; 8) &amp; 0xFF;</span>
 	if (units &amp; BIT(2))
<span class="p_del">-		info-&gt;hours = (buffer-&gt;output[3] &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_add">+		info-&gt;hours = (buffer.output[3] &gt;&gt; 16) &amp; 0xFF;</span>
 	if (units &amp; BIT(3))
<span class="p_del">-		info-&gt;days = (buffer-&gt;output[3] &gt;&gt; 24) &amp; 0xFF;</span>
<span class="p_add">+		info-&gt;days = (buffer.output[3] &gt;&gt; 24) &amp; 0xFF;</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1233,31 +1251,34 @@</span> <span class="p_context"> static int kbd_set_level(struct kbd_state *state, u8 level)</span>
 
 static int kbd_get_state(struct kbd_state *state)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	int ret;
 
<span class="p_del">-	dell_set_arguments(0x1, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0x1, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+				CLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	state-&gt;mode_bit = ffs(buffer-&gt;output[1] &amp; 0xFFFF);</span>
<span class="p_add">+	state-&gt;mode_bit = ffs(buffer.output[1] &amp; 0xFFFF);</span>
 	if (state-&gt;mode_bit != 0)
 		state-&gt;mode_bit--;
 
<span class="p_del">-	state-&gt;triggers = (buffer-&gt;output[1] &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_del">-	state-&gt;timeout_value = (buffer-&gt;output[1] &gt;&gt; 24) &amp; 0x3F;</span>
<span class="p_del">-	state-&gt;timeout_unit = (buffer-&gt;output[1] &gt;&gt; 30) &amp; 0x3;</span>
<span class="p_del">-	state-&gt;als_setting = buffer-&gt;output[2] &amp; 0xFF;</span>
<span class="p_del">-	state-&gt;als_value = (buffer-&gt;output[2] &gt;&gt; 8) &amp; 0xFF;</span>
<span class="p_del">-	state-&gt;level = (buffer-&gt;output[2] &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_del">-	state-&gt;timeout_value_ac = (buffer-&gt;output[2] &gt;&gt; 24) &amp; 0x3F;</span>
<span class="p_del">-	state-&gt;timeout_unit_ac = (buffer-&gt;output[2] &gt;&gt; 30) &amp; 0x3;</span>
<span class="p_add">+	state-&gt;triggers = (buffer.output[1] &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_add">+	state-&gt;timeout_value = (buffer.output[1] &gt;&gt; 24) &amp; 0x3F;</span>
<span class="p_add">+	state-&gt;timeout_unit = (buffer.output[1] &gt;&gt; 30) &amp; 0x3;</span>
<span class="p_add">+	state-&gt;als_setting = buffer.output[2] &amp; 0xFF;</span>
<span class="p_add">+	state-&gt;als_value = (buffer.output[2] &gt;&gt; 8) &amp; 0xFF;</span>
<span class="p_add">+	state-&gt;level = (buffer.output[2] &gt;&gt; 16) &amp; 0xFF;</span>
<span class="p_add">+	state-&gt;timeout_value_ac = (buffer.output[2] &gt;&gt; 24) &amp; 0x3F;</span>
<span class="p_add">+	state-&gt;timeout_unit_ac = (buffer.output[2] &gt;&gt; 30) &amp; 0x3;</span>
 
 	return ret;
 }
 
 static int kbd_set_state(struct kbd_state *state)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	int ret;
 	u32 input1;
 	u32 input2;
<span class="p_chunk">@@ -1270,8 +1291,9 @@</span> <span class="p_context"> static int kbd_set_state(struct kbd_state *state)</span>
 	input2 |= (state-&gt;level &amp; 0xFF) &lt;&lt; 16;
 	input2 |= (state-&gt;timeout_value_ac &amp; 0x3F) &lt;&lt; 24;
 	input2 |= (state-&gt;timeout_unit_ac &amp; 0x3) &lt;&lt; 30;
<span class="p_del">-	dell_set_arguments(0x2, input1, input2, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, 0x2, input1, input2, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+				CLASS_KBD_BACKLIGHT, SELECT_KBD_BACKLIGHT);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -1298,6 +1320,7 @@</span> <span class="p_context"> static int kbd_set_state_safe(struct kbd_state *state, struct kbd_state *old)</span>
 
 static int kbd_set_token_bit(u8 bit)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	struct calling_interface_token *token;
 	int ret;
 
<span class="p_chunk">@@ -1308,14 +1331,15 @@</span> <span class="p_context"> static int kbd_set_token_bit(u8 bit)</span>
 	if (!token)
 		return -EINVAL;
 
<span class="p_del">-	dell_set_arguments(token-&gt;location, token-&gt;value, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_TOKEN_WRITE, SELECT_TOKEN_STD);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, token-&gt;location, token-&gt;value, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_TOKEN_WRITE, SELECT_TOKEN_STD);</span>
 
 	return ret;
 }
 
 static int kbd_get_token_bit(u8 bit)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	struct calling_interface_token *token;
 	int ret;
 	int val;
<span class="p_chunk">@@ -1327,9 +1351,9 @@</span> <span class="p_context"> static int kbd_get_token_bit(u8 bit)</span>
 	if (!token)
 		return -EINVAL;
 
<span class="p_del">-	dell_set_arguments(token-&gt;location, 0, 0, 0);</span>
<span class="p_del">-	ret = dell_send_request(CLASS_TOKEN_READ, SELECT_TOKEN_STD);</span>
<span class="p_del">-	val = buffer-&gt;output[1];</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, token-&gt;location, 0, 0, 0);</span>
<span class="p_add">+	ret = dell_send_request(&amp;buffer, CLASS_TOKEN_READ, SELECT_TOKEN_STD);</span>
<span class="p_add">+	val = buffer.output[1];</span>
 
 	if (ret)
 		return ret;
<span class="p_chunk">@@ -2046,6 +2070,7 @@</span> <span class="p_context"> static struct notifier_block dell_laptop_notifier = {</span>
 
 int dell_micmute_led_set(int state)
 {
<span class="p_add">+	struct calling_interface_buffer buffer;</span>
 	struct calling_interface_token *token;
 
 	if (state == 0)
<span class="p_chunk">@@ -2058,8 +2083,8 @@</span> <span class="p_context"> int dell_micmute_led_set(int state)</span>
 	if (!token)
 		return -ENODEV;
 
<span class="p_del">-	dell_set_arguments(token-&gt;location, token-&gt;value, 0, 0);</span>
<span class="p_del">-	dell_send_request(CLASS_TOKEN_WRITE, SELECT_TOKEN_STD);</span>
<span class="p_add">+	dell_fill_request(&amp;buffer, token-&gt;location, token-&gt;value, 0, 0);</span>
<span class="p_add">+	dell_send_request(&amp;buffer, CLASS_TOKEN_WRITE, SELECT_TOKEN_STD);</span>
 
 	return state;
 }
<span class="p_chunk">@@ -2090,13 +2115,6 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 	if (ret)
 		goto fail_platform_device2;
 
<span class="p_del">-	buffer = kzalloc(sizeof(struct calling_interface_buffer), GFP_KERNEL);</span>
<span class="p_del">-	if (!buffer) {</span>
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_del">-		goto fail_buffer;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
 	ret = dell_setup_rfkill();
 
 	if (ret) {
<span class="p_chunk">@@ -2121,10 +2139,13 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 
 	token = dell_smbios_find_token(BRIGHTNESS_TOKEN);
 	if (token) {
<span class="p_del">-		dell_set_arguments(token-&gt;location, 0, 0, 0);</span>
<span class="p_del">-		ret = dell_send_request(CLASS_TOKEN_READ, SELECT_TOKEN_AC);</span>
<span class="p_add">+		struct calling_interface_buffer buffer;</span>
<span class="p_add">+</span>
<span class="p_add">+		dell_fill_request(&amp;buffer, token-&gt;location, 0, 0, 0);</span>
<span class="p_add">+		ret = dell_send_request(&amp;buffer,</span>
<span class="p_add">+					CLASS_TOKEN_READ, SELECT_TOKEN_AC);</span>
 		if (ret)
<span class="p_del">-			max_intensity = buffer-&gt;output[3];</span>
<span class="p_add">+			max_intensity = buffer.output[3];</span>
 	}
 
 	if (max_intensity) {
<span class="p_chunk">@@ -2158,8 +2179,6 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 fail_get_brightness:
 	backlight_device_unregister(dell_backlight_device);
 fail_backlight:
<span class="p_del">-	kfree(buffer);</span>
<span class="p_del">-fail_buffer:</span>
 	dell_cleanup_rfkill();
 fail_rfkill:
 	platform_device_del(platform_device);
<span class="p_chunk">@@ -2179,7 +2198,6 @@</span> <span class="p_context"> static void __exit dell_exit(void)</span>
 		touchpad_led_exit();
 	kbd_led_exit();
 	backlight_device_unregister(dell_backlight_device);
<span class="p_del">-	kfree(buffer);</span>
 	dell_cleanup_rfkill();
 	if (platform_device) {
 		platform_device_unregister(platform_device);
<span class="p_header">diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h</span>
<span class="p_header">index badf42acbf95..185b3cd48b88 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core.h</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core.h</span>
<span class="p_chunk">@@ -581,6 +581,11 @@</span> <span class="p_context"> struct qeth_cmd_buffer {</span>
 	void (*callback) (struct qeth_channel *, struct qeth_cmd_buffer *);
 };
 
<span class="p_add">+static inline struct qeth_ipa_cmd *__ipa_cmd(struct qeth_cmd_buffer *iob)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (struct qeth_ipa_cmd *)(iob-&gt;data + IPA_PDU_HEADER_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * definition of a qeth channel, used for read and write
  */
<span class="p_chunk">@@ -836,7 +841,7 @@</span> <span class="p_context"> struct qeth_trap_id {</span>
  */
 static inline int qeth_get_elements_for_range(addr_t start, addr_t end)
 {
<span class="p_del">-	return PFN_UP(end - 1) - PFN_DOWN(start);</span>
<span class="p_add">+	return PFN_UP(end) - PFN_DOWN(start);</span>
 }
 
 static inline int qeth_get_micros(void)
<span class="p_header">diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">index 3614df68830f..61e9d0bca197 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_chunk">@@ -2057,7 +2057,7 @@</span> <span class="p_context"> int qeth_send_control_data(struct qeth_card *card, int len,</span>
 	unsigned long flags;
 	struct qeth_reply *reply = NULL;
 	unsigned long timeout, event_timeout;
<span class="p_del">-	struct qeth_ipa_cmd *cmd;</span>
<span class="p_add">+	struct qeth_ipa_cmd *cmd = NULL;</span>
 
 	QETH_CARD_TEXT(card, 2, &quot;sendctl&quot;);
 
<span class="p_chunk">@@ -2071,22 +2071,26 @@</span> <span class="p_context"> int qeth_send_control_data(struct qeth_card *card, int len,</span>
 	}
 	reply-&gt;callback = reply_cb;
 	reply-&gt;param = reply_param;
<span class="p_del">-	if (card-&gt;state == CARD_STATE_DOWN)</span>
<span class="p_del">-		reply-&gt;seqno = QETH_IDX_COMMAND_SEQNO;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		reply-&gt;seqno = card-&gt;seqno.ipa++;</span>
<span class="p_add">+</span>
 	init_waitqueue_head(&amp;reply-&gt;wait_q);
<span class="p_del">-	spin_lock_irqsave(&amp;card-&gt;lock, flags);</span>
<span class="p_del">-	list_add_tail(&amp;reply-&gt;list, &amp;card-&gt;cmd_waiter_list);</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;card-&gt;lock, flags);</span>
 
 	while (atomic_cmpxchg(&amp;card-&gt;write.irq_pending, 0, 1)) ;
<span class="p_del">-	qeth_prepare_control_data(card, len, iob);</span>
 
<span class="p_del">-	if (IS_IPA(iob-&gt;data))</span>
<span class="p_add">+	if (IS_IPA(iob-&gt;data)) {</span>
<span class="p_add">+		cmd = __ipa_cmd(iob);</span>
<span class="p_add">+		cmd-&gt;hdr.seqno = card-&gt;seqno.ipa++;</span>
<span class="p_add">+		reply-&gt;seqno = cmd-&gt;hdr.seqno;</span>
 		event_timeout = QETH_IPA_TIMEOUT;
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		reply-&gt;seqno = QETH_IDX_COMMAND_SEQNO;</span>
 		event_timeout = QETH_TIMEOUT;
<span class="p_add">+	}</span>
<span class="p_add">+	qeth_prepare_control_data(card, len, iob);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;card-&gt;lock, flags);</span>
<span class="p_add">+	list_add_tail(&amp;reply-&gt;list, &amp;card-&gt;cmd_waiter_list);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;card-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	timeout = jiffies + event_timeout;
 
 	QETH_CARD_TEXT(card, 6, &quot;noirqpnd&quot;);
<span class="p_chunk">@@ -2111,9 +2115,8 @@</span> <span class="p_context"> int qeth_send_control_data(struct qeth_card *card, int len,</span>
 
 	/* we have only one long running ipassist, since we can ensure
 	   process context of this command we can sleep */
<span class="p_del">-	cmd = (struct qeth_ipa_cmd *)(iob-&gt;data+IPA_PDU_HEADER_SIZE);</span>
<span class="p_del">-	if ((cmd-&gt;hdr.command == IPA_CMD_SETIP) &amp;&amp;</span>
<span class="p_del">-	    (cmd-&gt;hdr.prot_version == QETH_PROT_IPV4)) {</span>
<span class="p_add">+	if (cmd &amp;&amp; cmd-&gt;hdr.command == IPA_CMD_SETIP &amp;&amp;</span>
<span class="p_add">+	    cmd-&gt;hdr.prot_version == QETH_PROT_IPV4) {</span>
 		if (!wait_event_timeout(reply-&gt;wait_q,
 		    atomic_read(&amp;reply-&gt;received), event_timeout))
 			goto time_err;
<span class="p_chunk">@@ -2868,7 +2871,7 @@</span> <span class="p_context"> static void qeth_fill_ipacmd_header(struct qeth_card *card,</span>
 	memset(cmd, 0, sizeof(struct qeth_ipa_cmd));
 	cmd-&gt;hdr.command = command;
 	cmd-&gt;hdr.initiator = IPA_CMD_INITIATOR_HOST;
<span class="p_del">-	cmd-&gt;hdr.seqno = card-&gt;seqno.ipa;</span>
<span class="p_add">+	/* cmd-&gt;hdr.seqno is set by qeth_send_control_data() */</span>
 	cmd-&gt;hdr.adapter_type = qeth_get_ipa_adp_type(card-&gt;info.link_type);
 	cmd-&gt;hdr.rel_adapter_no = (__u8) card-&gt;info.portno;
 	if (card-&gt;options.layer2)
<span class="p_chunk">@@ -3833,10 +3836,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(qeth_get_elements_for_frags);</span>
 int qeth_get_elements_no(struct qeth_card *card,
 		     struct sk_buff *skb, int extra_elems, int data_offset)
 {
<span class="p_del">-	int elements = qeth_get_elements_for_range(</span>
<span class="p_del">-				(addr_t)skb-&gt;data + data_offset,</span>
<span class="p_del">-				(addr_t)skb-&gt;data + skb_headlen(skb)) +</span>
<span class="p_del">-			qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+	addr_t end = (addr_t)skb-&gt;data + skb_headlen(skb);</span>
<span class="p_add">+	int elements = qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+	addr_t start = (addr_t)skb-&gt;data + data_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (start != end)</span>
<span class="p_add">+		elements += qeth_get_elements_for_range(start, end);</span>
 
 	if ((elements + extra_elems) &gt; QETH_MAX_BUFFER_ELEMENTS(card)) {
 		QETH_DBF_MESSAGE(2, &quot;Invalid size of IP packet &quot;
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3.h b/drivers/s390/net/qeth_l3.h</span>
<span class="p_header">index e5833837b799..8727b9517de8 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3.h</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3.h</span>
<span class="p_chunk">@@ -40,8 +40,40 @@</span> <span class="p_context"> struct qeth_ipaddr {</span>
 			unsigned int pfxlen;
 		} a6;
 	} u;
<span class="p_del">-</span>
 };
<span class="p_add">+</span>
<span class="p_add">+static inline bool qeth_l3_addr_match_ip(struct qeth_ipaddr *a1,</span>
<span class="p_add">+					 struct qeth_ipaddr *a2)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (a1-&gt;proto != a2-&gt;proto)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (a1-&gt;proto == QETH_PROT_IPV6)</span>
<span class="p_add">+		return ipv6_addr_equal(&amp;a1-&gt;u.a6.addr, &amp;a2-&gt;u.a6.addr);</span>
<span class="p_add">+	return a1-&gt;u.a4.addr == a2-&gt;u.a4.addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool qeth_l3_addr_match_all(struct qeth_ipaddr *a1,</span>
<span class="p_add">+					  struct qeth_ipaddr *a2)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Assumes that the pair was obtained via qeth_l3_addr_find_by_ip(),</span>
<span class="p_add">+	 * so &#39;proto&#39; and &#39;addr&#39; match for sure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For ucast:</span>
<span class="p_add">+	 * -	&#39;mac&#39; is always 0.</span>
<span class="p_add">+	 * -	&#39;mask&#39;/&#39;pfxlen&#39; for RXIP/VIPA is always 0. For NORMAL, matching</span>
<span class="p_add">+	 *	values are required to avoid mixups in takeover eligibility.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For mcast,</span>
<span class="p_add">+	 * -	&#39;mac&#39; is mapped from the IP, and thus always matches.</span>
<span class="p_add">+	 * -	&#39;mask&#39;/&#39;pfxlen&#39; is always 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (a1-&gt;type != a2-&gt;type)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (a1-&gt;proto == QETH_PROT_IPV6)</span>
<span class="p_add">+		return a1-&gt;u.a6.pfxlen == a2-&gt;u.a6.pfxlen;</span>
<span class="p_add">+	return a1-&gt;u.a4.mask == a2-&gt;u.a4.mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline  u64 qeth_l3_ipaddr_hash(struct qeth_ipaddr *addr)
 {
 	u64  ret = 0;
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">index ef0961e18686..33131c594627 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_chunk">@@ -150,6 +150,24 @@</span> <span class="p_context"> int qeth_l3_string_to_ipaddr(const char *buf, enum qeth_prot_versions proto,</span>
 		return -EINVAL;
 }
 
<span class="p_add">+static struct qeth_ipaddr *qeth_l3_find_addr_by_ip(struct qeth_card *card,</span>
<span class="p_add">+						   struct qeth_ipaddr *query)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 key = qeth_l3_ipaddr_hash(query);</span>
<span class="p_add">+	struct qeth_ipaddr *addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (query-&gt;is_multicast) {</span>
<span class="p_add">+		hash_for_each_possible(card-&gt;ip_mc_htable, addr, hnode, key)</span>
<span class="p_add">+			if (qeth_l3_addr_match_ip(addr, query))</span>
<span class="p_add">+				return addr;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hash_for_each_possible(card-&gt;ip_htable,  addr, hnode, key)</span>
<span class="p_add">+			if (qeth_l3_addr_match_ip(addr, query))</span>
<span class="p_add">+				return addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void qeth_l3_convert_addr_to_bits(u8 *addr, u8 *bits, int len)
 {
 	int i, j;
<span class="p_chunk">@@ -203,34 +221,6 @@</span> <span class="p_context"> static bool qeth_l3_is_addr_covered_by_ipato(struct qeth_card *card,</span>
 	return rc;
 }
 
<span class="p_del">-inline int</span>
<span class="p_del">-qeth_l3_ipaddrs_is_equal(struct qeth_ipaddr *addr1, struct qeth_ipaddr *addr2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return addr1-&gt;proto == addr2-&gt;proto &amp;&amp;</span>
<span class="p_del">-		!memcmp(&amp;addr1-&gt;u, &amp;addr2-&gt;u, sizeof(addr1-&gt;u))  &amp;&amp;</span>
<span class="p_del">-		!memcmp(&amp;addr1-&gt;mac, &amp;addr2-&gt;mac, sizeof(addr1-&gt;mac));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct qeth_ipaddr *</span>
<span class="p_del">-qeth_l3_ip_from_hash(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct qeth_ipaddr *addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tmp_addr-&gt;is_multicast) {</span>
<span class="p_del">-		hash_for_each_possible(card-&gt;ip_mc_htable,  addr,</span>
<span class="p_del">-				hnode, qeth_l3_ipaddr_hash(tmp_addr))</span>
<span class="p_del">-			if (qeth_l3_ipaddrs_is_equal(tmp_addr, addr))</span>
<span class="p_del">-				return addr;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		hash_for_each_possible(card-&gt;ip_htable,  addr,</span>
<span class="p_del">-				hnode, qeth_l3_ipaddr_hash(tmp_addr))</span>
<span class="p_del">-			if (qeth_l3_ipaddrs_is_equal(tmp_addr, addr))</span>
<span class="p_del">-				return addr;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int qeth_l3_delete_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)
 {
 	int rc = 0;
<span class="p_chunk">@@ -245,23 +235,18 @@</span> <span class="p_context"> int qeth_l3_delete_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 		QETH_CARD_HEX(card, 4, ((char *)&amp;tmp_addr-&gt;u.a6.addr) + 8, 8);
 	}
 
<span class="p_del">-	addr = qeth_l3_ip_from_hash(card, tmp_addr);</span>
<span class="p_del">-	if (!addr)</span>
<span class="p_add">+	addr = qeth_l3_find_addr_by_ip(card, tmp_addr);</span>
<span class="p_add">+	if (!addr || !qeth_l3_addr_match_all(addr, tmp_addr))</span>
 		return -ENOENT;
 
 	addr-&gt;ref_counter--;
<span class="p_del">-	if (addr-&gt;ref_counter &gt; 0 &amp;&amp; (addr-&gt;type == QETH_IP_TYPE_NORMAL ||</span>
<span class="p_del">-				      addr-&gt;type == QETH_IP_TYPE_RXIP))</span>
<span class="p_add">+	if (addr-&gt;type == QETH_IP_TYPE_NORMAL &amp;&amp; addr-&gt;ref_counter &gt; 0)</span>
 		return rc;
 	if (addr-&gt;in_progress)
 		return -EINPROGRESS;
 
<span class="p_del">-	if (!qeth_card_hw_is_reachable(card)) {</span>
<span class="p_del">-		addr-&gt;disp_flag = QETH_DISP_ADDR_DELETE;</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = qeth_l3_deregister_addr_entry(card, addr);</span>
<span class="p_add">+	if (qeth_card_hw_is_reachable(card))</span>
<span class="p_add">+		rc = qeth_l3_deregister_addr_entry(card, addr);</span>
 
 	hash_del(&amp;addr-&gt;hnode);
 	kfree(addr);
<span class="p_chunk">@@ -273,6 +258,7 @@</span> <span class="p_context"> int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 {
 	int rc = 0;
 	struct qeth_ipaddr *addr;
<span class="p_add">+	char buf[40];</span>
 
 	QETH_CARD_TEXT(card, 4, &quot;addip&quot;);
 
<span class="p_chunk">@@ -283,8 +269,20 @@</span> <span class="p_context"> int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 		QETH_CARD_HEX(card, 4, ((char *)&amp;tmp_addr-&gt;u.a6.addr) + 8, 8);
 	}
 
<span class="p_del">-	addr = qeth_l3_ip_from_hash(card, tmp_addr);</span>
<span class="p_del">-	if (!addr) {</span>
<span class="p_add">+	addr = qeth_l3_find_addr_by_ip(card, tmp_addr);</span>
<span class="p_add">+	if (addr) {</span>
<span class="p_add">+		if (tmp_addr-&gt;type != QETH_IP_TYPE_NORMAL)</span>
<span class="p_add">+			return -EADDRINUSE;</span>
<span class="p_add">+		if (qeth_l3_addr_match_all(addr, tmp_addr)) {</span>
<span class="p_add">+			addr-&gt;ref_counter++;</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		qeth_l3_ipaddr_to_string(tmp_addr-&gt;proto, (u8 *)&amp;tmp_addr-&gt;u,</span>
<span class="p_add">+					 buf);</span>
<span class="p_add">+		dev_warn(&amp;card-&gt;gdev-&gt;dev,</span>
<span class="p_add">+			 &quot;Registering IP address %s failed\n&quot;, buf);</span>
<span class="p_add">+		return -EADDRINUSE;</span>
<span class="p_add">+	} else {</span>
 		addr = qeth_l3_get_addr_buffer(tmp_addr-&gt;proto);
 		if (!addr)
 			return -ENOMEM;
<span class="p_chunk">@@ -324,19 +322,15 @@</span> <span class="p_context"> int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 				(rc == IPA_RC_LAN_OFFLINE)) {
 			addr-&gt;disp_flag = QETH_DISP_ADDR_DO_NOTHING;
 			if (addr-&gt;ref_counter &lt; 1) {
<span class="p_del">-				qeth_l3_delete_ip(card, addr);</span>
<span class="p_add">+				qeth_l3_deregister_addr_entry(card, addr);</span>
<span class="p_add">+				hash_del(&amp;addr-&gt;hnode);</span>
 				kfree(addr);
 			}
 		} else {
 			hash_del(&amp;addr-&gt;hnode);
 			kfree(addr);
 		}
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (addr-&gt;type == QETH_IP_TYPE_NORMAL ||</span>
<span class="p_del">-		    addr-&gt;type == QETH_IP_TYPE_RXIP)</span>
<span class="p_del">-			addr-&gt;ref_counter++;</span>
 	}
<span class="p_del">-</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -404,11 +398,7 @@</span> <span class="p_context"> static void qeth_l3_recover_ip(struct qeth_card *card)</span>
 	spin_lock_bh(&amp;card-&gt;ip_lock);
 
 	hash_for_each_safe(card-&gt;ip_htable, i, tmp, addr, hnode) {
<span class="p_del">-		if (addr-&gt;disp_flag == QETH_DISP_ADDR_DELETE) {</span>
<span class="p_del">-			qeth_l3_deregister_addr_entry(card, addr);</span>
<span class="p_del">-			hash_del(&amp;addr-&gt;hnode);</span>
<span class="p_del">-			kfree(addr);</span>
<span class="p_del">-		} else if (addr-&gt;disp_flag == QETH_DISP_ADDR_ADD) {</span>
<span class="p_add">+		if (addr-&gt;disp_flag == QETH_DISP_ADDR_ADD) {</span>
 			if (addr-&gt;proto == QETH_PROT_IPV4) {
 				addr-&gt;in_progress = 1;
 				spin_unlock_bh(&amp;card-&gt;ip_lock);
<span class="p_chunk">@@ -724,12 +714,7 @@</span> <span class="p_context"> int qeth_l3_add_vipa(struct qeth_card *card, enum qeth_prot_versions proto,</span>
 		return -ENOMEM;
 
 	spin_lock_bh(&amp;card-&gt;ip_lock);
<span class="p_del">-</span>
<span class="p_del">-	if (qeth_l3_ip_from_hash(card, ipaddr))</span>
<span class="p_del">-		rc = -EEXIST;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		qeth_l3_add_ip(card, ipaddr);</span>
<span class="p_del">-</span>
<span class="p_add">+	rc = qeth_l3_add_ip(card, ipaddr);</span>
 	spin_unlock_bh(&amp;card-&gt;ip_lock);
 
 	kfree(ipaddr);
<span class="p_chunk">@@ -792,12 +777,7 @@</span> <span class="p_context"> int qeth_l3_add_rxip(struct qeth_card *card, enum qeth_prot_versions proto,</span>
 		return -ENOMEM;
 
 	spin_lock_bh(&amp;card-&gt;ip_lock);
<span class="p_del">-</span>
<span class="p_del">-	if (qeth_l3_ip_from_hash(card, ipaddr))</span>
<span class="p_del">-		rc = -EEXIST;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		qeth_l3_add_ip(card, ipaddr);</span>
<span class="p_del">-</span>
<span class="p_add">+	rc = qeth_l3_add_ip(card, ipaddr);</span>
 	spin_unlock_bh(&amp;card-&gt;ip_lock);
 
 	kfree(ipaddr);
<span class="p_chunk">@@ -1405,8 +1385,9 @@</span> <span class="p_context"> qeth_l3_add_mc_to_hash(struct qeth_card *card, struct in_device *in4_dev)</span>
 		memcpy(tmp-&gt;mac, buf, sizeof(tmp-&gt;mac));
 		tmp-&gt;is_multicast = 1;
 
<span class="p_del">-		ipm = qeth_l3_ip_from_hash(card, tmp);</span>
<span class="p_add">+		ipm = qeth_l3_find_addr_by_ip(card, tmp);</span>
 		if (ipm) {
<span class="p_add">+			/* for mcast, by-IP match means full match */</span>
 			ipm-&gt;disp_flag = QETH_DISP_ADDR_DO_NOTHING;
 		} else {
 			ipm = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);
<span class="p_chunk">@@ -1489,8 +1470,9 @@</span> <span class="p_context"> qeth_l3_add_mc6_to_hash(struct qeth_card *card, struct inet6_dev *in6_dev)</span>
 		       sizeof(struct in6_addr));
 		tmp-&gt;is_multicast = 1;
 
<span class="p_del">-		ipm = qeth_l3_ip_from_hash(card, tmp);</span>
<span class="p_add">+		ipm = qeth_l3_find_addr_by_ip(card, tmp);</span>
 		if (ipm) {
<span class="p_add">+			/* for mcast, by-IP match means full match */</span>
 			ipm-&gt;disp_flag = QETH_DISP_ADDR_DO_NOTHING;
 			continue;
 		}
<span class="p_chunk">@@ -2629,11 +2611,12 @@</span> <span class="p_context"> static void qeth_tso_fill_header(struct qeth_card *card,</span>
 static int qeth_l3_get_elements_no_tso(struct qeth_card *card,
 			struct sk_buff *skb, int extra_elems)
 {
<span class="p_del">-	addr_t tcpdptr = (addr_t)tcp_hdr(skb) + tcp_hdrlen(skb);</span>
<span class="p_del">-	int elements = qeth_get_elements_for_range(</span>
<span class="p_del">-				tcpdptr,</span>
<span class="p_del">-				(addr_t)skb-&gt;data + skb_headlen(skb)) +</span>
<span class="p_del">-				qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+	addr_t start = (addr_t)tcp_hdr(skb) + tcp_hdrlen(skb);</span>
<span class="p_add">+	addr_t end = (addr_t)skb-&gt;data + skb_headlen(skb);</span>
<span class="p_add">+	int elements = qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (start != end)</span>
<span class="p_add">+		elements += qeth_get_elements_for_range(start, end);</span>
 
 	if ((elements + extra_elems) &gt; QETH_MAX_BUFFER_ELEMENTS(card)) {
 		QETH_DBF_MESSAGE(2,
<span class="p_header">diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class="p_header">index e30e29ae4819..45657e2b1ff7 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class="p_chunk">@@ -338,11 +338,12 @@</span> <span class="p_context"> static int vaddr_get_pfn(struct mm_struct *mm, unsigned long vaddr,</span>
 {
 	struct page *page[1];
 	struct vm_area_struct *vma;
<span class="p_add">+	struct vm_area_struct *vmas[1];</span>
 	int ret;
 
 	if (mm == current-&gt;mm) {
<span class="p_del">-		ret = get_user_pages_fast(vaddr, 1, !!(prot &amp; IOMMU_WRITE),</span>
<span class="p_del">-					  page);</span>
<span class="p_add">+		ret = get_user_pages_longterm(vaddr, 1, !!(prot &amp; IOMMU_WRITE),</span>
<span class="p_add">+					      page, vmas);</span>
 	} else {
 		unsigned int flags = 0;
 
<span class="p_chunk">@@ -351,7 +352,18 @@</span> <span class="p_context"> static int vaddr_get_pfn(struct mm_struct *mm, unsigned long vaddr,</span>
 
 		down_read(&amp;mm-&gt;mmap_sem);
 		ret = get_user_pages_remote(NULL, mm, vaddr, 1, flags, page,
<span class="p_del">-					    NULL, NULL);</span>
<span class="p_add">+					    vmas, NULL);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The lifetime of a vaddr_get_pfn() page pin is</span>
<span class="p_add">+		 * userspace-controlled. In the fs-dax case this could</span>
<span class="p_add">+		 * lead to indefinite stalls in filesystem operations.</span>
<span class="p_add">+		 * Disallow attempts to pin fs-dax pages via this</span>
<span class="p_add">+		 * interface.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ret &gt; 0 &amp;&amp; vma_is_fsdax(vmas[0])) {</span>
<span class="p_add">+			ret = -EOPNOTSUPP;</span>
<span class="p_add">+			put_page(page[0]);</span>
<span class="p_add">+		}</span>
 		up_read(&amp;mm-&gt;mmap_sem);
 	}
 
<span class="p_header">diff --git a/fs/btrfs/sysfs.c b/fs/btrfs/sysfs.c</span>
<span class="p_header">index a28bba801264..27baaff96880 100644</span>
<span class="p_header">--- a/fs/btrfs/sysfs.c</span>
<span class="p_header">+++ b/fs/btrfs/sysfs.c</span>
<span class="p_chunk">@@ -423,7 +423,7 @@</span> <span class="p_context"> static ssize_t btrfs_nodesize_show(struct kobject *kobj,</span>
 {
 	struct btrfs_fs_info *fs_info = to_fs_info(kobj);
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%u\n&quot;, fs_info-&gt;super_copy-&gt;nodesize);</span>
<span class="p_add">+	return snprintf(buf, PAGE_SIZE, &quot;%u\n&quot;, fs_info-&gt;nodesize);</span>
 }
 
 BTRFS_ATTR(, nodesize, btrfs_nodesize_show);
<span class="p_chunk">@@ -433,8 +433,7 @@</span> <span class="p_context"> static ssize_t btrfs_sectorsize_show(struct kobject *kobj,</span>
 {
 	struct btrfs_fs_info *fs_info = to_fs_info(kobj);
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%u\n&quot;,</span>
<span class="p_del">-			fs_info-&gt;super_copy-&gt;sectorsize);</span>
<span class="p_add">+	return snprintf(buf, PAGE_SIZE, &quot;%u\n&quot;, fs_info-&gt;sectorsize);</span>
 }
 
 BTRFS_ATTR(, sectorsize, btrfs_sectorsize_show);
<span class="p_chunk">@@ -444,8 +443,7 @@</span> <span class="p_context"> static ssize_t btrfs_clone_alignment_show(struct kobject *kobj,</span>
 {
 	struct btrfs_fs_info *fs_info = to_fs_info(kobj);
 
<span class="p_del">-	return snprintf(buf, PAGE_SIZE, &quot;%u\n&quot;,</span>
<span class="p_del">-			fs_info-&gt;super_copy-&gt;sectorsize);</span>
<span class="p_add">+	return snprintf(buf, PAGE_SIZE, &quot;%u\n&quot;, fs_info-&gt;sectorsize);</span>
 }
 
 BTRFS_ATTR(, clone_alignment, btrfs_clone_alignment_show);
<span class="p_header">diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c</span>
<span class="p_header">index 5a8c2649af2f..10d12b3de001 100644</span>
<span class="p_header">--- a/fs/btrfs/transaction.c</span>
<span class="p_header">+++ b/fs/btrfs/transaction.c</span>
<span class="p_chunk">@@ -1723,19 +1723,23 @@</span> <span class="p_context"> static void update_super_roots(struct btrfs_fs_info *fs_info)</span>
 
 	super = fs_info-&gt;super_copy;
 
<span class="p_add">+	/* update latest btrfs_super_block::chunk_root refs */</span>
 	root_item = &amp;fs_info-&gt;chunk_root-&gt;root_item;
<span class="p_del">-	super-&gt;chunk_root = root_item-&gt;bytenr;</span>
<span class="p_del">-	super-&gt;chunk_root_generation = root_item-&gt;generation;</span>
<span class="p_del">-	super-&gt;chunk_root_level = root_item-&gt;level;</span>
<span class="p_add">+	btrfs_set_super_chunk_root(super, root_item-&gt;bytenr);</span>
<span class="p_add">+	btrfs_set_super_chunk_root_generation(super, root_item-&gt;generation);</span>
<span class="p_add">+	btrfs_set_super_chunk_root_level(super, root_item-&gt;level);</span>
 
<span class="p_add">+	/* update latest btrfs_super_block::root refs */</span>
 	root_item = &amp;fs_info-&gt;tree_root-&gt;root_item;
<span class="p_del">-	super-&gt;root = root_item-&gt;bytenr;</span>
<span class="p_del">-	super-&gt;generation = root_item-&gt;generation;</span>
<span class="p_del">-	super-&gt;root_level = root_item-&gt;level;</span>
<span class="p_add">+	btrfs_set_super_root(super, root_item-&gt;bytenr);</span>
<span class="p_add">+	btrfs_set_super_generation(super, root_item-&gt;generation);</span>
<span class="p_add">+	btrfs_set_super_root_level(super, root_item-&gt;level);</span>
<span class="p_add">+</span>
 	if (btrfs_test_opt(fs_info, SPACE_CACHE))
<span class="p_del">-		super-&gt;cache_generation = root_item-&gt;generation;</span>
<span class="p_add">+		btrfs_set_super_cache_generation(super, root_item-&gt;generation);</span>
 	if (test_bit(BTRFS_FS_UPDATE_UUID_TREE_GEN, &amp;fs_info-&gt;flags))
<span class="p_del">-		super-&gt;uuid_tree_generation = root_item-&gt;generation;</span>
<span class="p_add">+		btrfs_set_super_uuid_tree_generation(super,</span>
<span class="p_add">+						     root_item-&gt;generation);</span>
 }
 
 int btrfs_transaction_in_commit(struct btrfs_fs_info *info)
<span class="p_header">diff --git a/fs/direct-io.c b/fs/direct-io.c</span>
<span class="p_header">index 3aafb3343a65..b76110e96d62 100644</span>
<span class="p_header">--- a/fs/direct-io.c</span>
<span class="p_header">+++ b/fs/direct-io.c</span>
<span class="p_chunk">@@ -1252,8 +1252,7 @@</span> <span class="p_context"> do_blockdev_direct_IO(struct kiocb *iocb, struct inode *inode,</span>
 	 */
 	if (dio-&gt;is_async &amp;&amp; iov_iter_rw(iter) == WRITE) {
 		retval = 0;
<span class="p_del">-		if ((iocb-&gt;ki_filp-&gt;f_flags &amp; O_DSYNC) ||</span>
<span class="p_del">-		    IS_SYNC(iocb-&gt;ki_filp-&gt;f_mapping-&gt;host))</span>
<span class="p_add">+		if (iocb-&gt;ki_flags &amp; IOCB_DSYNC)</span>
 			retval = dio_set_defer_completion(dio);
 		else if (!dio-&gt;inode-&gt;i_sb-&gt;s_dio_done_wq) {
 			/*
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 511fbaabf624..79421287ff5e 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -3204,7 +3204,7 @@</span> <span class="p_context"> static inline bool vma_is_fsdax(struct vm_area_struct *vma)</span>
 	if (!vma_is_dax(vma))
 		return false;
 	inode = file_inode(vma-&gt;vm_file);
<span class="p_del">-	if (inode-&gt;i_mode == S_IFCHR)</span>
<span class="p_add">+	if (S_ISCHR(inode-&gt;i_mode))</span>
 		return false; /* device-dax */
 	return true;
 }
<span class="p_header">diff --git a/include/linux/nospec.h b/include/linux/nospec.h</span>
<span class="p_header">index fbc98e2c8228..132e3f5a2e0d 100644</span>
<span class="p_header">--- a/include/linux/nospec.h</span>
<span class="p_header">+++ b/include/linux/nospec.h</span>
<span class="p_chunk">@@ -72,7 +72,6 @@</span> <span class="p_context"> static inline unsigned long array_index_mask_nospec(unsigned long index,</span>
 	BUILD_BUG_ON(sizeof(_i) &gt; sizeof(long));			\
 	BUILD_BUG_ON(sizeof(_s) &gt; sizeof(long));			\
 									\
<span class="p_del">-	_i &amp;= _mask;							\</span>
<span class="p_del">-	_i;								\</span>
<span class="p_add">+	(typeof(_i)) (_i &amp; _mask);					\</span>
 })
 #endif /* _LINUX_NOSPEC_H */
<span class="p_header">diff --git a/include/linux/phy.h b/include/linux/phy.h</span>
<span class="p_header">index dc82a07cb4fd..123cd703741d 100644</span>
<span class="p_header">--- a/include/linux/phy.h</span>
<span class="p_header">+++ b/include/linux/phy.h</span>
<span class="p_chunk">@@ -819,6 +819,7 @@</span> <span class="p_context"> void phy_device_remove(struct phy_device *phydev);</span>
 int phy_init_hw(struct phy_device *phydev);
 int phy_suspend(struct phy_device *phydev);
 int phy_resume(struct phy_device *phydev);
<span class="p_add">+int __phy_resume(struct phy_device *phydev);</span>
 int phy_loopback(struct phy_device *phydev, bool enable);
 struct phy_device *phy_attach(struct net_device *dev, const char *bus_id,
 			      phy_interface_t interface);
<span class="p_header">diff --git a/include/net/udplite.h b/include/net/udplite.h</span>
<span class="p_header">index 81bdbf97319b..9185e45b997f 100644</span>
<span class="p_header">--- a/include/net/udplite.h</span>
<span class="p_header">+++ b/include/net/udplite.h</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> static inline int udplite_checksum_init(struct sk_buff *skb, struct udphdr *uh)</span>
 		UDP_SKB_CB(skb)-&gt;cscov = cscov;
 		if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
 			skb-&gt;ip_summed = CHECKSUM_NONE;
<span class="p_add">+		skb-&gt;csum_valid = 0;</span>
         }
 
 	return 0;
<span class="p_header">diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c</span>
<span class="p_header">index aa9d2a2b1210..cf8e4df808cf 100644</span>
<span class="p_header">--- a/kernel/time/hrtimer.c</span>
<span class="p_header">+++ b/kernel/time/hrtimer.c</span>
<span class="p_chunk">@@ -1104,7 +1104,12 @@</span> <span class="p_context"> static void __hrtimer_init(struct hrtimer *timer, clockid_t clock_id,</span>
 
 	cpu_base = raw_cpu_ptr(&amp;hrtimer_bases);
 
<span class="p_del">-	if (clock_id == CLOCK_REALTIME &amp;&amp; mode != HRTIMER_MODE_ABS)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * POSIX magic: Relative CLOCK_REALTIME timers are not affected by</span>
<span class="p_add">+	 * clock modifications, so they needs to become CLOCK_MONOTONIC to</span>
<span class="p_add">+	 * ensure POSIX compliance.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (clock_id == CLOCK_REALTIME &amp;&amp; mode &amp; HRTIMER_MODE_REL)</span>
 		clock_id = CLOCK_MONOTONIC;
 
 	base = hrtimer_clockid_to_base(clock_id);
<span class="p_header">diff --git a/kernel/time/timer.c b/kernel/time/timer.c</span>
<span class="p_header">index 0bcf00e3ce48..e9eb29a0edc5 100644</span>
<span class="p_header">--- a/kernel/time/timer.c</span>
<span class="p_header">+++ b/kernel/time/timer.c</span>
<span class="p_chunk">@@ -1886,6 +1886,12 @@</span> <span class="p_context"> int timers_dead_cpu(unsigned int cpu)</span>
 		raw_spin_lock_irq(&amp;new_base-&gt;lock);
 		raw_spin_lock_nested(&amp;old_base-&gt;lock, SINGLE_DEPTH_NESTING);
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The current CPUs base clock might be stale. Update it</span>
<span class="p_add">+		 * before moving the timers over.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		forward_timer_base(new_base);</span>
<span class="p_add">+</span>
 		BUG_ON(old_base-&gt;running_timer);
 
 		for (i = 0; i &lt; WHEEL_SIZE; i++)
<span class="p_header">diff --git a/lib/vsprintf.c b/lib/vsprintf.c</span>
<span class="p_header">index 01c3957b2de6..062ac753a101 100644</span>
<span class="p_header">--- a/lib/vsprintf.c</span>
<span class="p_header">+++ b/lib/vsprintf.c</span>
<span class="p_chunk">@@ -1849,7 +1849,7 @@</span> <span class="p_context"> char *pointer(const char *fmt, char *buf, char *end, void *ptr,</span>
 {
 	const int default_width = 2 * sizeof(void *);
 
<span class="p_del">-	if (!ptr &amp;&amp; *fmt != &#39;K&#39;) {</span>
<span class="p_add">+	if (!ptr &amp;&amp; *fmt != &#39;K&#39; &amp;&amp; *fmt != &#39;x&#39;) {</span>
 		/*
 		 * Print (null) with the same width as a pointer so it makes
 		 * tabular output look nice.
<span class="p_header">diff --git a/net/bridge/br_sysfs_if.c b/net/bridge/br_sysfs_if.c</span>
<span class="p_header">index 0254c35b2bf0..126a8ea73c96 100644</span>
<span class="p_header">--- a/net/bridge/br_sysfs_if.c</span>
<span class="p_header">+++ b/net/bridge/br_sysfs_if.c</span>
<span class="p_chunk">@@ -255,6 +255,9 @@</span> <span class="p_context"> static ssize_t brport_show(struct kobject *kobj,</span>
 	struct brport_attribute *brport_attr = to_brport_attr(attr);
 	struct net_bridge_port *p = to_brport(kobj);
 
<span class="p_add">+	if (!brport_attr-&gt;show)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	return brport_attr-&gt;show(p, buf);
 }
 
<span class="p_header">diff --git a/net/bridge/br_vlan.c b/net/bridge/br_vlan.c</span>
<span class="p_header">index 51935270c651..9896f4975353 100644</span>
<span class="p_header">--- a/net/bridge/br_vlan.c</span>
<span class="p_header">+++ b/net/bridge/br_vlan.c</span>
<span class="p_chunk">@@ -168,6 +168,8 @@</span> <span class="p_context"> static struct net_bridge_vlan *br_vlan_get_master(struct net_bridge *br, u16 vid</span>
 		masterv = br_vlan_find(vg, vid);
 		if (WARN_ON(!masterv))
 			return NULL;
<span class="p_add">+		refcount_set(&amp;masterv-&gt;refcnt, 1);</span>
<span class="p_add">+		return masterv;</span>
 	}
 	refcount_inc(&amp;masterv-&gt;refcnt);
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index c8c102a3467f..a2a89acd0de8 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2366,8 +2366,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(netdev_set_num_tc);</span>
  */
 int netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq)
 {
<span class="p_add">+	bool disabling;</span>
 	int rc;
 
<span class="p_add">+	disabling = txq &lt; dev-&gt;real_num_tx_queues;</span>
<span class="p_add">+</span>
 	if (txq &lt; 1 || txq &gt; dev-&gt;num_tx_queues)
 		return -EINVAL;
 
<span class="p_chunk">@@ -2383,15 +2386,19 @@</span> <span class="p_context"> int netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq)</span>
 		if (dev-&gt;num_tc)
 			netif_setup_tc(dev, txq);
 
<span class="p_del">-		if (txq &lt; dev-&gt;real_num_tx_queues) {</span>
<span class="p_add">+		dev-&gt;real_num_tx_queues = txq;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (disabling) {</span>
<span class="p_add">+			synchronize_net();</span>
 			qdisc_reset_all_tx_gt(dev, txq);
 #ifdef CONFIG_XPS
 			netif_reset_xps_queues_gt(dev, txq);
 #endif
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		dev-&gt;real_num_tx_queues = txq;</span>
 	}
 
<span class="p_del">-	dev-&gt;real_num_tx_queues = txq;</span>
 	return 0;
 }
 EXPORT_SYMBOL(netif_set_real_num_tx_queues);
<span class="p_header">diff --git a/net/core/gen_estimator.c b/net/core/gen_estimator.c</span>
<span class="p_header">index 0a3f88f08727..98fd12721221 100644</span>
<span class="p_header">--- a/net/core/gen_estimator.c</span>
<span class="p_header">+++ b/net/core/gen_estimator.c</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> struct net_rate_estimator {</span>
 static void est_fetch_counters(struct net_rate_estimator *e,
 			       struct gnet_stats_basic_packed *b)
 {
<span class="p_add">+	memset(b, 0, sizeof(*b));</span>
 	if (e-&gt;stats_lock)
 		spin_lock(e-&gt;stats_lock);
 
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index c586597da20d..7d36a950d961 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -646,6 +646,11 @@</span> <span class="p_context"> int fib_nh_match(struct fib_config *cfg, struct fib_info *fi,</span>
 					    fi-&gt;fib_nh, cfg, extack))
 				return 1;
 		}
<span class="p_add">+#ifdef CONFIG_IP_ROUTE_CLASSID</span>
<span class="p_add">+		if (cfg-&gt;fc_flow &amp;&amp;</span>
<span class="p_add">+		    cfg-&gt;fc_flow != fi-&gt;fib_nh-&gt;nh_tclassid)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+#endif</span>
 		if ((!cfg-&gt;fc_oif || cfg-&gt;fc_oif == fi-&gt;fib_nh-&gt;nh_oif) &amp;&amp;
 		    (!cfg-&gt;fc_gw  || cfg-&gt;fc_gw == fi-&gt;fib_nh-&gt;nh_gw))
 			return 0;
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 4e153b23bcec..f746e49dd585 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -128,10 +128,13 @@</span> <span class="p_context"> static int ip_rt_redirect_silence __read_mostly	= ((HZ / 50) &lt;&lt; (9 + 1));</span>
 static int ip_rt_error_cost __read_mostly	= HZ;
 static int ip_rt_error_burst __read_mostly	= 5 * HZ;
 static int ip_rt_mtu_expires __read_mostly	= 10 * 60 * HZ;
<span class="p_del">-static int ip_rt_min_pmtu __read_mostly		= 512 + 20 + 20;</span>
<span class="p_add">+static u32 ip_rt_min_pmtu __read_mostly		= 512 + 20 + 20;</span>
 static int ip_rt_min_advmss __read_mostly	= 256;
 
 static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
<span class="p_add">+</span>
<span class="p_add">+static int ip_min_valid_pmtu __read_mostly	= IPV4_MIN_MTU;</span>
<span class="p_add">+</span>
 /*
  *	Interface to generic destination cache.
  */
<span class="p_chunk">@@ -1829,6 +1832,8 @@</span> <span class="p_context"> int fib_multipath_hash(const struct fib_info *fi, const struct flowi4 *fl4,</span>
 				return skb_get_hash_raw(skb) &gt;&gt; 1;
 			memset(&amp;hash_keys, 0, sizeof(hash_keys));
 			skb_flow_dissect_flow_keys(skb, &amp;keys, flag);
<span class="p_add">+</span>
<span class="p_add">+			hash_keys.control.addr_type = FLOW_DISSECTOR_KEY_IPV4_ADDRS;</span>
 			hash_keys.addrs.v4addrs.src = keys.addrs.v4addrs.src;
 			hash_keys.addrs.v4addrs.dst = keys.addrs.v4addrs.dst;
 			hash_keys.ports.src = keys.ports.src;
<span class="p_chunk">@@ -2934,7 +2939,8 @@</span> <span class="p_context"> static struct ctl_table ipv4_route_table[] = {</span>
 		.data		= &amp;ip_rt_min_pmtu,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec,</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;ip_min_valid_pmtu,</span>
 	},
 	{
 		.procname	= &quot;min_adv_mss&quot;,
<span class="p_header">diff --git a/net/ipv4/tcp_input.c b/net/ipv4/tcp_input.c</span>
<span class="p_header">index 45f750e85714..0228f494b0a5 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_input.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_input.c</span>
<span class="p_chunk">@@ -1977,11 +1977,6 @@</span> <span class="p_context"> void tcp_enter_loss(struct sock *sk)</span>
 	/* F-RTO RFC5682 sec 3.1 step 1: retransmit SND.UNA if no previous
 	 * loss recovery is underway except recurring timeout(s) on
 	 * the same SND.UNA (sec 3.2). Disable F-RTO on path MTU probing
<span class="p_del">-	 *</span>
<span class="p_del">-	 * In theory F-RTO can be used repeatedly during loss recovery.</span>
<span class="p_del">-	 * In practice this interacts badly with broken middle-boxes that</span>
<span class="p_del">-	 * falsely raise the receive window, which results in repeated</span>
<span class="p_del">-	 * timeouts and stop-and-go behavior.</span>
 	 */
 	tp-&gt;frto = net-&gt;ipv4.sysctl_tcp_frto &amp;&amp;
 		   (new_recovery || icsk-&gt;icsk_retransmits) &amp;&amp;
<span class="p_chunk">@@ -2637,18 +2632,14 @@</span> <span class="p_context"> static void tcp_process_loss(struct sock *sk, int flag, bool is_dupack,</span>
 	    tcp_try_undo_loss(sk, false))
 		return;
 
<span class="p_del">-	/* The ACK (s)acks some never-retransmitted data meaning not all</span>
<span class="p_del">-	 * the data packets before the timeout were lost. Therefore we</span>
<span class="p_del">-	 * undo the congestion window and state. This is essentially</span>
<span class="p_del">-	 * the operation in F-RTO (RFC5682 section 3.1 step 3.b). Since</span>
<span class="p_del">-	 * a retransmitted skb is permantly marked, we can apply such an</span>
<span class="p_del">-	 * operation even if F-RTO was not used.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if ((flag &amp; FLAG_ORIG_SACK_ACKED) &amp;&amp;</span>
<span class="p_del">-	    tcp_try_undo_loss(sk, tp-&gt;undo_marker))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	if (tp-&gt;frto) { /* F-RTO RFC5682 sec 3.1 (sack enhanced version). */
<span class="p_add">+		/* Step 3.b. A timeout is spurious if not all data are</span>
<span class="p_add">+		 * lost, i.e., never-retransmitted data are (s)acked.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((flag &amp; FLAG_ORIG_SACK_ACKED) &amp;&amp;</span>
<span class="p_add">+		    tcp_try_undo_loss(sk, true))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
 		if (after(tp-&gt;snd_nxt, tp-&gt;high_seq)) {
 			if (flag &amp; FLAG_DATA_SACKED || is_dupack)
 				tp-&gt;frto = 0; /* Step 3.a. loss was real */
<span class="p_chunk">@@ -3988,6 +3979,7 @@</span> <span class="p_context"> void tcp_reset(struct sock *sk)</span>
 	/* This barrier is coupled with smp_rmb() in tcp_poll() */
 	smp_wmb();
 
<span class="p_add">+	tcp_write_queue_purge(sk);</span>
 	tcp_done(sk);
 
 	if (!sock_flag(sk, SOCK_DEAD))
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index 94e28350f420..3b051b9b3743 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -705,7 +705,8 @@</span> <span class="p_context"> static void tcp_v4_send_reset(const struct sock *sk, struct sk_buff *skb)</span>
 	 */
 	if (sk) {
 		arg.bound_dev_if = sk-&gt;sk_bound_dev_if;
<span class="p_del">-		trace_tcp_send_reset(sk, skb);</span>
<span class="p_add">+		if (sk_fullsock(sk))</span>
<span class="p_add">+			trace_tcp_send_reset(sk, skb);</span>
 	}
 
 	BUILD_BUG_ON(offsetof(struct sock, sk_bound_dev_if) !=
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index a4d214c7b506..580912de16c2 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -1730,7 +1730,7 @@</span> <span class="p_context"> u32 tcp_tso_autosize(const struct sock *sk, unsigned int mss_now,</span>
 	 */
 	segs = max_t(u32, bytes / mss_now, min_tso_segs);
 
<span class="p_del">-	return min_t(u32, segs, sk-&gt;sk_gso_max_segs);</span>
<span class="p_add">+	return segs;</span>
 }
 EXPORT_SYMBOL(tcp_tso_autosize);
 
<span class="p_chunk">@@ -1742,9 +1742,10 @@</span> <span class="p_context"> static u32 tcp_tso_segs(struct sock *sk, unsigned int mss_now)</span>
 	const struct tcp_congestion_ops *ca_ops = inet_csk(sk)-&gt;icsk_ca_ops;
 	u32 tso_segs = ca_ops-&gt;tso_segs_goal ? ca_ops-&gt;tso_segs_goal(sk) : 0;
 
<span class="p_del">-	return tso_segs ? :</span>
<span class="p_del">-		tcp_tso_autosize(sk, mss_now,</span>
<span class="p_del">-				 sock_net(sk)-&gt;ipv4.sysctl_tcp_min_tso_segs);</span>
<span class="p_add">+	if (!tso_segs)</span>
<span class="p_add">+		tso_segs = tcp_tso_autosize(sk, mss_now,</span>
<span class="p_add">+				sock_net(sk)-&gt;ipv4.sysctl_tcp_min_tso_segs);</span>
<span class="p_add">+	return min_t(u32, tso_segs, sk-&gt;sk_gso_max_segs);</span>
 }
 
 /* Returns the portion of skb which can be sent right away */
<span class="p_chunk">@@ -2026,6 +2027,24 @@</span> <span class="p_context"> static inline void tcp_mtu_check_reprobe(struct sock *sk)</span>
 	}
 }
 
<span class="p_add">+static bool tcp_can_coalesce_send_queue_head(struct sock *sk, int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb = tcp_send_head(sk);</span>
<span class="p_add">+	tcp_for_write_queue_from_safe(skb, next, sk) {</span>
<span class="p_add">+		if (len &lt;= skb-&gt;len)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (unlikely(TCP_SKB_CB(skb)-&gt;eor))</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+</span>
<span class="p_add">+		len -= skb-&gt;len;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Create a new MTU probe if we are ready.
  * MTU probe is regularly attempting to increase the path MTU by
  * deliberately sending larger packets.  This discovers routing
<span class="p_chunk">@@ -2098,6 +2117,9 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 			return 0;
 	}
 
<span class="p_add">+	if (!tcp_can_coalesce_send_queue_head(sk, probe_size))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	/* We&#39;re allowed to probe.  Build it now. */
 	nskb = sk_stream_alloc_skb(sk, probe_size, GFP_ATOMIC, false);
 	if (!nskb)
<span class="p_chunk">@@ -2133,6 +2155,10 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 			/* We&#39;ve eaten all the data from this skb.
 			 * Throw it away. */
 			TCP_SKB_CB(nskb)-&gt;tcp_flags |= TCP_SKB_CB(skb)-&gt;tcp_flags;
<span class="p_add">+			/* If this is the last SKB we copy and eor is set</span>
<span class="p_add">+			 * we need to propagate it to the new skb.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			TCP_SKB_CB(nskb)-&gt;eor = TCP_SKB_CB(skb)-&gt;eor;</span>
 			tcp_unlink_write_queue(skb, sk);
 			sk_wmem_free_skb(sk, skb);
 		} else {
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index e4ff25c947c5..590f9ed90c1f 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -2031,6 +2031,11 @@</span> <span class="p_context"> static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh,</span>
 		err = udplite_checksum_init(skb, uh);
 		if (err)
 			return err;
<span class="p_add">+</span>
<span class="p_add">+		if (UDP_SKB_CB(skb)-&gt;partial_cov) {</span>
<span class="p_add">+			skb-&gt;csum = inet_compute_pseudo(skb, proto);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Note, we are only interested in != 0 or == 0, thus the
<span class="p_header">diff --git a/net/ipv6/ip6_checksum.c b/net/ipv6/ip6_checksum.c</span>
<span class="p_header">index ec43d18b5ff9..547515e8450a 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_checksum.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_checksum.c</span>
<span class="p_chunk">@@ -73,6 +73,11 @@</span> <span class="p_context"> int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh, int proto)</span>
 		err = udplite_checksum_init(skb, uh);
 		if (err)
 			return err;
<span class="p_add">+</span>
<span class="p_add">+		if (UDP_SKB_CB(skb)-&gt;partial_cov) {</span>
<span class="p_add">+			skb-&gt;csum = ip6_compute_pseudo(skb, proto);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* To support RFC 6936 (allow zero checksum in UDP/IPV6 for tunnels)
<span class="p_header">diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c</span>
<span class="p_header">index 3873d3877135..3a1775a62973 100644</span>
<span class="p_header">--- a/net/ipv6/sit.c</span>
<span class="p_header">+++ b/net/ipv6/sit.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static void ipip6_tunnel_clone_6rd(struct net_device *dev, struct sit_net *sitn)</span>
 #ifdef CONFIG_IPV6_SIT_6RD
 	struct ip_tunnel *t = netdev_priv(dev);
 
<span class="p_del">-	if (t-&gt;dev == sitn-&gt;fb_tunnel_dev) {</span>
<span class="p_add">+	if (dev == sitn-&gt;fb_tunnel_dev) {</span>
 		ipv6_addr_set(&amp;t-&gt;ip6rd.prefix, htonl(0x20020000), 0, 0, 0);
 		t-&gt;ip6rd.relay_prefix = 0;
 		t-&gt;ip6rd.prefixlen = 16;
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 7178476b3d2f..6378f6fbc89f 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -943,7 +943,8 @@</span> <span class="p_context"> static void tcp_v6_send_reset(const struct sock *sk, struct sk_buff *skb)</span>
 
 	if (sk) {
 		oif = sk-&gt;sk_bound_dev_if;
<span class="p_del">-		trace_tcp_send_reset(sk, skb);</span>
<span class="p_add">+		if (sk_fullsock(sk))</span>
<span class="p_add">+			trace_tcp_send_reset(sk, skb);</span>
 	}
 
 	tcp_v6_send_response(sk, skb, seq, ack_seq, 0, 0, 0, oif, key, 1, 0, 0);
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 115918ad8eca..861b67c34191 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -136,51 +136,6 @@</span> <span class="p_context"> l2tp_session_id_hash_2(struct l2tp_net *pn, u32 session_id)</span>
 
 }
 
<span class="p_del">-/* Lookup the tunnel socket, possibly involving the fs code if the socket is</span>
<span class="p_del">- * owned by userspace.  A struct sock returned from this function must be</span>
<span class="p_del">- * released using l2tp_tunnel_sock_put once you&#39;re done with it.</span>
<span class="p_del">- */</span>
<span class="p_del">-static struct sock *l2tp_tunnel_sock_lookup(struct l2tp_tunnel *tunnel)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int err = 0;</span>
<span class="p_del">-	struct socket *sock = NULL;</span>
<span class="p_del">-	struct sock *sk = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!tunnel)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tunnel-&gt;fd &gt;= 0) {</span>
<span class="p_del">-		/* Socket is owned by userspace, who might be in the process</span>
<span class="p_del">-		 * of closing it.  Look the socket up using the fd to ensure</span>
<span class="p_del">-		 * consistency.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		sock = sockfd_lookup(tunnel-&gt;fd, &amp;err);</span>
<span class="p_del">-		if (sock)</span>
<span class="p_del">-			sk = sock-&gt;sk;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* Socket is owned by kernelspace */</span>
<span class="p_del">-		sk = tunnel-&gt;sock;</span>
<span class="p_del">-		sock_hold(sk);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return sk;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* Drop a reference to a tunnel socket obtained via. l2tp_tunnel_sock_put */</span>
<span class="p_del">-static void l2tp_tunnel_sock_put(struct sock *sk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);</span>
<span class="p_del">-	if (tunnel) {</span>
<span class="p_del">-		if (tunnel-&gt;fd &gt;= 0) {</span>
<span class="p_del">-			/* Socket is owned by userspace */</span>
<span class="p_del">-			sockfd_put(sk-&gt;sk_socket);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		sock_put(sk);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	sock_put(sk);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Session hash list.
  * The session_id SHOULD be random according to RFC2661, but several
  * L2TP implementations (Cisco and Microsoft) use incrementing
<span class="p_chunk">@@ -193,6 +148,13 @@</span> <span class="p_context"> l2tp_session_id_hash(struct l2tp_tunnel *tunnel, u32 session_id)</span>
 	return &amp;tunnel-&gt;session_hlist[hash_32(session_id, L2TP_HASH_BITS)];
 }
 
<span class="p_add">+void l2tp_tunnel_free(struct l2tp_tunnel *tunnel)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sock_put(tunnel-&gt;sock);</span>
<span class="p_add">+	/* the tunnel is freed in the socket destructor */</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(l2tp_tunnel_free);</span>
<span class="p_add">+</span>
 /* Lookup a tunnel. A new reference is held on the returned tunnel. */
 struct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id)
 {
<span class="p_chunk">@@ -345,13 +307,11 @@</span> <span class="p_context"> int l2tp_session_register(struct l2tp_session *session,</span>
 			}
 
 		l2tp_tunnel_inc_refcount(tunnel);
<span class="p_del">-		sock_hold(tunnel-&gt;sock);</span>
 		hlist_add_head_rcu(&amp;session-&gt;global_hlist, g_head);
 
 		spin_unlock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);
 	} else {
 		l2tp_tunnel_inc_refcount(tunnel);
<span class="p_del">-		sock_hold(tunnel-&gt;sock);</span>
 	}
 
 	hlist_add_head(&amp;session-&gt;hlist, head);
<span class="p_chunk">@@ -975,7 +935,7 @@</span> <span class="p_context"> int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb)</span>
 {
 	struct l2tp_tunnel *tunnel;
 
<span class="p_del">-	tunnel = l2tp_sock_to_tunnel(sk);</span>
<span class="p_add">+	tunnel = l2tp_tunnel(sk);</span>
 	if (tunnel == NULL)
 		goto pass_up;
 
<span class="p_chunk">@@ -983,13 +943,10 @@</span> <span class="p_context"> int l2tp_udp_encap_recv(struct sock *sk, struct sk_buff *skb)</span>
 		 tunnel-&gt;name, skb-&gt;len);
 
 	if (l2tp_udp_recv_core(tunnel, skb, tunnel-&gt;recv_payload_hook))
<span class="p_del">-		goto pass_up_put;</span>
<span class="p_add">+		goto pass_up;</span>
 
<span class="p_del">-	sock_put(sk);</span>
 	return 0;
 
<span class="p_del">-pass_up_put:</span>
<span class="p_del">-	sock_put(sk);</span>
 pass_up:
 	return 1;
 }
<span class="p_chunk">@@ -1216,14 +1173,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_xmit_skb);</span>
 static void l2tp_tunnel_destruct(struct sock *sk)
 {
 	struct l2tp_tunnel *tunnel = l2tp_tunnel(sk);
<span class="p_del">-	struct l2tp_net *pn;</span>
 
 	if (tunnel == NULL)
 		goto end;
 
 	l2tp_info(tunnel, L2TP_MSG_CONTROL, &quot;%s: closing...\n&quot;, tunnel-&gt;name);
 
<span class="p_del">-</span>
 	/* Disable udp encapsulation */
 	switch (tunnel-&gt;encap) {
 	case L2TP_ENCAPTYPE_UDP:
<span class="p_chunk">@@ -1240,18 +1195,11 @@</span> <span class="p_context"> static void l2tp_tunnel_destruct(struct sock *sk)</span>
 	sk-&gt;sk_destruct = tunnel-&gt;old_sk_destruct;
 	sk-&gt;sk_user_data = NULL;
 
<span class="p_del">-	/* Remove the tunnel struct from the tunnel list */</span>
<span class="p_del">-	pn = l2tp_pernet(tunnel-&gt;l2tp_net);</span>
<span class="p_del">-	spin_lock_bh(&amp;pn-&gt;l2tp_tunnel_list_lock);</span>
<span class="p_del">-	list_del_rcu(&amp;tunnel-&gt;list);</span>
<span class="p_del">-	spin_unlock_bh(&amp;pn-&gt;l2tp_tunnel_list_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	tunnel-&gt;sock = NULL;</span>
<span class="p_del">-	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_del">-</span>
 	/* Call the original destructor */
 	if (sk-&gt;sk_destruct)
 		(*sk-&gt;sk_destruct)(sk);
<span class="p_add">+</span>
<span class="p_add">+	kfree_rcu(tunnel, rcu);</span>
 end:
 	return;
 }
<span class="p_chunk">@@ -1312,49 +1260,43 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(l2tp_tunnel_closeall);</span>
 /* Tunnel socket destroy hook for UDP encapsulation */
 static void l2tp_udp_encap_destroy(struct sock *sk)
 {
<span class="p_del">-	struct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);</span>
<span class="p_del">-	if (tunnel) {</span>
<span class="p_del">-		l2tp_tunnel_closeall(tunnel);</span>
<span class="p_del">-		sock_put(sk);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	struct l2tp_tunnel *tunnel = l2tp_tunnel(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tunnel)</span>
<span class="p_add">+		l2tp_tunnel_delete(tunnel);</span>
 }
 
 /* Workqueue tunnel deletion function */
 static void l2tp_tunnel_del_work(struct work_struct *work)
 {
<span class="p_del">-	struct l2tp_tunnel *tunnel = NULL;</span>
<span class="p_del">-	struct socket *sock = NULL;</span>
<span class="p_del">-	struct sock *sk = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	tunnel = container_of(work, struct l2tp_tunnel, del_work);</span>
<span class="p_add">+	struct l2tp_tunnel *tunnel = container_of(work, struct l2tp_tunnel,</span>
<span class="p_add">+						  del_work);</span>
<span class="p_add">+	struct sock *sk = tunnel-&gt;sock;</span>
<span class="p_add">+	struct socket *sock = sk-&gt;sk_socket;</span>
<span class="p_add">+	struct l2tp_net *pn;</span>
 
 	l2tp_tunnel_closeall(tunnel);
 
<span class="p_del">-	sk = l2tp_tunnel_sock_lookup(tunnel);</span>
<span class="p_del">-	if (!sk)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	sock = sk-&gt;sk_socket;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If the tunnel socket was created by userspace, then go through the</span>
<span class="p_del">-	 * inet layer to shut the socket down, and let userspace close it.</span>
<span class="p_del">-	 * Otherwise, if we created the socket directly within the kernel, use</span>
<span class="p_add">+	/* If the tunnel socket was created within the kernel, use</span>
 	 * the sk API to release it here.
<span class="p_del">-	 * In either case the tunnel resources are freed in the socket</span>
<span class="p_del">-	 * destructor when the tunnel socket goes away.</span>
 	 */
<span class="p_del">-	if (tunnel-&gt;fd &gt;= 0) {</span>
<span class="p_del">-		if (sock)</span>
<span class="p_del">-			inet_shutdown(sock, 2);</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	if (tunnel-&gt;fd &lt; 0) {</span>
 		if (sock) {
 			kernel_sock_shutdown(sock, SHUT_RDWR);
 			sock_release(sock);
 		}
 	}
 
<span class="p_del">-	l2tp_tunnel_sock_put(sk);</span>
<span class="p_del">-out:</span>
<span class="p_add">+	/* Remove the tunnel struct from the tunnel list */</span>
<span class="p_add">+	pn = l2tp_pernet(tunnel-&gt;l2tp_net);</span>
<span class="p_add">+	spin_lock_bh(&amp;pn-&gt;l2tp_tunnel_list_lock);</span>
<span class="p_add">+	list_del_rcu(&amp;tunnel-&gt;list);</span>
<span class="p_add">+	spin_unlock_bh(&amp;pn-&gt;l2tp_tunnel_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* drop initial ref */</span>
<span class="p_add">+	l2tp_tunnel_dec_refcount(tunnel);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* drop workqueue ref */</span>
 	l2tp_tunnel_dec_refcount(tunnel);
 }
 
<span class="p_chunk">@@ -1607,13 +1549,22 @@</span> <span class="p_context"> int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32</span>
 		sk-&gt;sk_user_data = tunnel;
 	}
 
<span class="p_add">+	/* Bump the reference count. The tunnel context is deleted</span>
<span class="p_add">+	 * only when this drops to zero. A reference is also held on</span>
<span class="p_add">+	 * the tunnel socket to ensure that it is not released while</span>
<span class="p_add">+	 * the tunnel is extant. Must be done before sk_destruct is</span>
<span class="p_add">+	 * set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	refcount_set(&amp;tunnel-&gt;ref_count, 1);</span>
<span class="p_add">+	sock_hold(sk);</span>
<span class="p_add">+	tunnel-&gt;sock = sk;</span>
<span class="p_add">+	tunnel-&gt;fd = fd;</span>
<span class="p_add">+</span>
 	/* Hook on the tunnel socket destructor so that we can cleanup
 	 * if the tunnel socket goes away.
 	 */
 	tunnel-&gt;old_sk_destruct = sk-&gt;sk_destruct;
 	sk-&gt;sk_destruct = &amp;l2tp_tunnel_destruct;
<span class="p_del">-	tunnel-&gt;sock = sk;</span>
<span class="p_del">-	tunnel-&gt;fd = fd;</span>
 	lockdep_set_class_and_name(&amp;sk-&gt;sk_lock.slock, &amp;l2tp_socket_class, &quot;l2tp_sock&quot;);
 
 	sk-&gt;sk_allocation = GFP_ATOMIC;
<span class="p_chunk">@@ -1623,11 +1574,6 @@</span> <span class="p_context"> int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32</span>
 
 	/* Add tunnel to our list */
 	INIT_LIST_HEAD(&amp;tunnel-&gt;list);
<span class="p_del">-</span>
<span class="p_del">-	/* Bump the reference count. The tunnel context is deleted</span>
<span class="p_del">-	 * only when this drops to zero. Must be done before list insertion</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	refcount_set(&amp;tunnel-&gt;ref_count, 1);</span>
 	spin_lock_bh(&amp;pn-&gt;l2tp_tunnel_list_lock);
 	list_add_rcu(&amp;tunnel-&gt;list, &amp;pn-&gt;l2tp_tunnel_list);
 	spin_unlock_bh(&amp;pn-&gt;l2tp_tunnel_list_lock);
<span class="p_chunk">@@ -1668,8 +1614,6 @@</span> <span class="p_context"> void l2tp_session_free(struct l2tp_session *session)</span>
 
 	if (tunnel) {
 		BUG_ON(tunnel-&gt;magic != L2TP_TUNNEL_MAGIC);
<span class="p_del">-		sock_put(tunnel-&gt;sock);</span>
<span class="p_del">-		session-&gt;tunnel = NULL;</span>
 		l2tp_tunnel_dec_refcount(tunnel);
 	}
 
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index 9534e16965cc..8ecb1d357445 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -219,27 +219,8 @@</span> <span class="p_context"> static inline void *l2tp_session_priv(struct l2tp_session *session)</span>
 	return &amp;session-&gt;priv[0];
 }
 
<span class="p_del">-static inline struct l2tp_tunnel *l2tp_sock_to_tunnel(struct sock *sk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct l2tp_tunnel *tunnel;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (sk == NULL)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	sock_hold(sk);</span>
<span class="p_del">-	tunnel = (struct l2tp_tunnel *)(sk-&gt;sk_user_data);</span>
<span class="p_del">-	if (tunnel == NULL) {</span>
<span class="p_del">-		sock_put(sk);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(tunnel-&gt;magic != L2TP_TUNNEL_MAGIC);</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return tunnel;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 struct l2tp_tunnel *l2tp_tunnel_get(const struct net *net, u32 tunnel_id);
<span class="p_add">+void l2tp_tunnel_free(struct l2tp_tunnel *tunnel);</span>
 
 struct l2tp_session *l2tp_session_get(const struct net *net,
 				      struct l2tp_tunnel *tunnel,
<span class="p_chunk">@@ -288,7 +269,7 @@</span> <span class="p_context"> static inline void l2tp_tunnel_inc_refcount(struct l2tp_tunnel *tunnel)</span>
 static inline void l2tp_tunnel_dec_refcount(struct l2tp_tunnel *tunnel)
 {
 	if (refcount_dec_and_test(&amp;tunnel-&gt;ref_count))
<span class="p_del">-		kfree_rcu(tunnel, rcu);</span>
<span class="p_add">+		l2tp_tunnel_free(tunnel);</span>
 }
 
 /* Session reference counts. Incremented when code obtains a reference
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index ff61124fdf59..3428fba6f2b7 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -234,17 +234,13 @@</span> <span class="p_context"> static void l2tp_ip_close(struct sock *sk, long timeout)</span>
 static void l2tp_ip_destroy_sock(struct sock *sk)
 {
 	struct sk_buff *skb;
<span class="p_del">-	struct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);</span>
<span class="p_add">+	struct l2tp_tunnel *tunnel = sk-&gt;sk_user_data;</span>
 
 	while ((skb = __skb_dequeue_tail(&amp;sk-&gt;sk_write_queue)) != NULL)
 		kfree_skb(skb);
 
<span class="p_del">-	if (tunnel) {</span>
<span class="p_del">-		l2tp_tunnel_closeall(tunnel);</span>
<span class="p_del">-		sock_put(sk);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	sk_refcnt_debug_dec(sk);</span>
<span class="p_add">+	if (tunnel)</span>
<span class="p_add">+		l2tp_tunnel_delete(tunnel);</span>
 }
 
 static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index 192344688c06..6f009eaa5fbe 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -248,16 +248,14 @@</span> <span class="p_context"> static void l2tp_ip6_close(struct sock *sk, long timeout)</span>
 
 static void l2tp_ip6_destroy_sock(struct sock *sk)
 {
<span class="p_del">-	struct l2tp_tunnel *tunnel = l2tp_sock_to_tunnel(sk);</span>
<span class="p_add">+	struct l2tp_tunnel *tunnel = sk-&gt;sk_user_data;</span>
 
 	lock_sock(sk);
 	ip6_flush_pending_frames(sk);
 	release_sock(sk);
 
<span class="p_del">-	if (tunnel) {</span>
<span class="p_del">-		l2tp_tunnel_closeall(tunnel);</span>
<span class="p_del">-		sock_put(sk);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (tunnel)</span>
<span class="p_add">+		l2tp_tunnel_delete(tunnel);</span>
 
 	inet6_destroy_sock(sk);
 }
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index b412fc3351dc..5ea718609fe8 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -416,20 +416,28 @@</span> <span class="p_context"> static int pppol2tp_xmit(struct ppp_channel *chan, struct sk_buff *skb)</span>
  * Session (and tunnel control) socket create/destroy.
  *****************************************************************************/
 
<span class="p_add">+static void pppol2tp_put_sk(struct rcu_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pppol2tp_session *ps;</span>
<span class="p_add">+</span>
<span class="p_add">+	ps = container_of(head, typeof(*ps), rcu);</span>
<span class="p_add">+	sock_put(ps-&gt;__sk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Called by l2tp_core when a session socket is being closed.
  */
 static void pppol2tp_session_close(struct l2tp_session *session)
 {
<span class="p_del">-	struct sock *sk;</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(session-&gt;magic != L2TP_SESSION_MAGIC);</span>
<span class="p_add">+	struct pppol2tp_session *ps;</span>
 
<span class="p_del">-	sk = pppol2tp_session_get_sock(session);</span>
<span class="p_del">-	if (sk) {</span>
<span class="p_del">-		if (sk-&gt;sk_socket)</span>
<span class="p_del">-			inet_shutdown(sk-&gt;sk_socket, SEND_SHUTDOWN);</span>
<span class="p_del">-		sock_put(sk);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	ps = l2tp_session_priv(session);</span>
<span class="p_add">+	mutex_lock(&amp;ps-&gt;sk_lock);</span>
<span class="p_add">+	ps-&gt;__sk = rcu_dereference_protected(ps-&gt;sk,</span>
<span class="p_add">+					     lockdep_is_held(&amp;ps-&gt;sk_lock));</span>
<span class="p_add">+	RCU_INIT_POINTER(ps-&gt;sk, NULL);</span>
<span class="p_add">+	if (ps-&gt;__sk)</span>
<span class="p_add">+		call_rcu(&amp;ps-&gt;rcu, pppol2tp_put_sk);</span>
<span class="p_add">+	mutex_unlock(&amp;ps-&gt;sk_lock);</span>
 }
 
 /* Really kill the session socket. (Called from sock_put() if
<span class="p_chunk">@@ -449,14 +457,6 @@</span> <span class="p_context"> static void pppol2tp_session_destruct(struct sock *sk)</span>
 	}
 }
 
<span class="p_del">-static void pppol2tp_put_sk(struct rcu_head *head)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct pppol2tp_session *ps;</span>
<span class="p_del">-</span>
<span class="p_del">-	ps = container_of(head, typeof(*ps), rcu);</span>
<span class="p_del">-	sock_put(ps-&gt;__sk);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Called when the PPPoX socket (session) is closed.
  */
 static int pppol2tp_release(struct socket *sock)
<span class="p_chunk">@@ -480,26 +480,17 @@</span> <span class="p_context"> static int pppol2tp_release(struct socket *sock)</span>
 	sock_orphan(sk);
 	sock-&gt;sk = NULL;
 
<span class="p_add">+	/* If the socket is associated with a session,</span>
<span class="p_add">+	 * l2tp_session_delete will call pppol2tp_session_close which</span>
<span class="p_add">+	 * will drop the session&#39;s ref on the socket.</span>
<span class="p_add">+	 */</span>
 	session = pppol2tp_sock_to_session(sk);
<span class="p_del">-</span>
<span class="p_del">-	if (session != NULL) {</span>
<span class="p_del">-		struct pppol2tp_session *ps;</span>
<span class="p_del">-</span>
<span class="p_add">+	if (session) {</span>
 		l2tp_session_delete(session);
<span class="p_del">-</span>
<span class="p_del">-		ps = l2tp_session_priv(session);</span>
<span class="p_del">-		mutex_lock(&amp;ps-&gt;sk_lock);</span>
<span class="p_del">-		ps-&gt;__sk = rcu_dereference_protected(ps-&gt;sk,</span>
<span class="p_del">-						     lockdep_is_held(&amp;ps-&gt;sk_lock));</span>
<span class="p_del">-		RCU_INIT_POINTER(ps-&gt;sk, NULL);</span>
<span class="p_del">-		mutex_unlock(&amp;ps-&gt;sk_lock);</span>
<span class="p_del">-		call_rcu(&amp;ps-&gt;rcu, pppol2tp_put_sk);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Rely on the sock_put() call at the end of the function for</span>
<span class="p_del">-		 * dropping the reference held by pppol2tp_sock_to_session().</span>
<span class="p_del">-		 * The last reference will be dropped by pppol2tp_put_sk().</span>
<span class="p_del">-		 */</span>
<span class="p_add">+		/* drop the ref obtained by pppol2tp_sock_to_session */</span>
<span class="p_add">+		sock_put(sk);</span>
 	}
<span class="p_add">+</span>
 	release_sock(sk);
 
 	/* This will delete the session context via
<span class="p_chunk">@@ -796,6 +787,7 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 
 out_no_ppp:
 	/* This is how we get the session context from the socket. */
<span class="p_add">+	sock_hold(sk);</span>
 	sk-&gt;sk_user_data = session;
 	rcu_assign_pointer(ps-&gt;sk, sk);
 	mutex_unlock(&amp;ps-&gt;sk_lock);
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 84a4e4c3be4b..ca9c0544c856 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2275,7 +2275,7 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 	if (cb-&gt;start) {
 		ret = cb-&gt;start(cb);
 		if (ret)
<span class="p_del">-			goto error_unlock;</span>
<span class="p_add">+			goto error_put;</span>
 	}
 
 	nlk-&gt;cb_running = true;
<span class="p_chunk">@@ -2295,6 +2295,8 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 	 */
 	return -EINTR;
 
<span class="p_add">+error_put:</span>
<span class="p_add">+	module_put(control-&gt;module);</span>
 error_unlock:
 	sock_put(sk);
 	mutex_unlock(nlk-&gt;cb_mutex);
<span class="p_header">diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c</span>
<span class="p_header">index d444daf1ac04..6f02499ef007 100644</span>
<span class="p_header">--- a/net/netlink/genetlink.c</span>
<span class="p_header">+++ b/net/netlink/genetlink.c</span>
<span class="p_chunk">@@ -1081,6 +1081,7 @@</span> <span class="p_context"> static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,</span>
 {
 	struct sk_buff *tmp;
 	struct net *net, *prev = NULL;
<span class="p_add">+	bool delivered = false;</span>
 	int err;
 
 	for_each_net_rcu(net) {
<span class="p_chunk">@@ -1092,14 +1093,21 @@</span> <span class="p_context"> static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,</span>
 			}
 			err = nlmsg_multicast(prev-&gt;genl_sock, tmp,
 					      portid, group, flags);
<span class="p_del">-			if (err)</span>
<span class="p_add">+			if (!err)</span>
<span class="p_add">+				delivered = true;</span>
<span class="p_add">+			else if (err != -ESRCH)</span>
 				goto error;
 		}
 
 		prev = net;
 	}
 
<span class="p_del">-	return nlmsg_multicast(prev-&gt;genl_sock, skb, portid, group, flags);</span>
<span class="p_add">+	err = nlmsg_multicast(prev-&gt;genl_sock, skb, portid, group, flags);</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		delivered = true;</span>
<span class="p_add">+	else if (err != -ESRCH)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	return delivered ? 0 : -ESRCH;</span>
  error:
 	kfree_skb(skb);
 	return err;
<span class="p_header">diff --git a/net/rxrpc/output.c b/net/rxrpc/output.c</span>
<span class="p_header">index 42410e910aff..cf73dc006c3b 100644</span>
<span class="p_header">--- a/net/rxrpc/output.c</span>
<span class="p_header">+++ b/net/rxrpc/output.c</span>
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> int rxrpc_send_data_packet(struct rxrpc_call *call, struct sk_buff *skb,</span>
 					(char *)&amp;opt, sizeof(opt));
 		if (ret == 0) {
 			ret = kernel_sendmsg(conn-&gt;params.local-&gt;socket, &amp;msg,
<span class="p_del">-					     iov, 1, iov[0].iov_len);</span>
<span class="p_add">+					     iov, 2, len);</span>
 
 			opt = IPV6_PMTUDISC_DO;
 			kernel_setsockopt(conn-&gt;params.local-&gt;socket,
<span class="p_header">diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c</span>
<span class="p_header">index e6b853f0ee4f..2e437bbd3358 100644</span>
<span class="p_header">--- a/net/sched/cls_api.c</span>
<span class="p_header">+++ b/net/sched/cls_api.c</span>
<span class="p_chunk">@@ -1054,13 +1054,18 @@</span> <span class="p_context"> static int tc_dump_tfilter(struct sk_buff *skb, struct netlink_callback *cb)</span>
 		    nla_get_u32(tca[TCA_CHAIN]) != chain-&gt;index)
 			continue;
 		if (!tcf_chain_dump(chain, q, parent, skb, cb,
<span class="p_del">-				    index_start, &amp;index))</span>
<span class="p_add">+				    index_start, &amp;index)) {</span>
<span class="p_add">+			err = -EMSGSIZE;</span>
 			break;
<span class="p_add">+		}</span>
 	}
 
 	cb-&gt;args[0] = index;
 
 out:
<span class="p_add">+	/* If we did no progress, the error (EMSGSIZE) is real */</span>
<span class="p_add">+	if (skb-&gt;len == 0 &amp;&amp; err)</span>
<span class="p_add">+		return err;</span>
 	return skb-&gt;len;
 }
 
<span class="p_header">diff --git a/net/sched/cls_u32.c b/net/sched/cls_u32.c</span>
<span class="p_header">index 33294b5b2c6a..425cc341fd41 100644</span>
<span class="p_header">--- a/net/sched/cls_u32.c</span>
<span class="p_header">+++ b/net/sched/cls_u32.c</span>
<span class="p_chunk">@@ -397,10 +397,12 @@</span> <span class="p_context"> static int u32_init(struct tcf_proto *tp)</span>
 static int u32_destroy_key(struct tcf_proto *tp, struct tc_u_knode *n,
 			   bool free_pf)
 {
<span class="p_add">+	struct tc_u_hnode *ht = rtnl_dereference(n-&gt;ht_down);</span>
<span class="p_add">+</span>
 	tcf_exts_destroy(&amp;n-&gt;exts);
 	tcf_exts_put_net(&amp;n-&gt;exts);
<span class="p_del">-	if (n-&gt;ht_down)</span>
<span class="p_del">-		n-&gt;ht_down-&gt;refcnt--;</span>
<span class="p_add">+	if (ht &amp;&amp; --ht-&gt;refcnt == 0)</span>
<span class="p_add">+		kfree(ht);</span>
 #ifdef CONFIG_CLS_U32_PERF
 	if (free_pf)
 		free_percpu(n-&gt;pf);
<span class="p_chunk">@@ -653,16 +655,15 @@</span> <span class="p_context"> static void u32_destroy(struct tcf_proto *tp)</span>
 
 		hlist_del(&amp;tp_c-&gt;hnode);
 
<span class="p_del">-		for (ht = rtnl_dereference(tp_c-&gt;hlist);</span>
<span class="p_del">-		     ht;</span>
<span class="p_del">-		     ht = rtnl_dereference(ht-&gt;next)) {</span>
<span class="p_del">-			ht-&gt;refcnt--;</span>
<span class="p_del">-			u32_clear_hnode(tp, ht);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		while ((ht = rtnl_dereference(tp_c-&gt;hlist)) != NULL) {
<span class="p_add">+			u32_clear_hnode(tp, ht);</span>
 			RCU_INIT_POINTER(tp_c-&gt;hlist, ht-&gt;next);
<span class="p_del">-			kfree_rcu(ht, rcu);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* u32_destroy_key() will later free ht for us, if it&#39;s</span>
<span class="p_add">+			 * still referenced by some knode</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (--ht-&gt;refcnt == 0)</span>
<span class="p_add">+				kfree_rcu(ht, rcu);</span>
 		}
 
 		idr_destroy(&amp;tp_c-&gt;handle_idr);
<span class="p_chunk">@@ -928,7 +929,8 @@</span> <span class="p_context"> static int u32_change(struct net *net, struct sk_buff *in_skb,</span>
 		if (TC_U32_KEY(n-&gt;handle) == 0)
 			return -EINVAL;
 
<span class="p_del">-		if (n-&gt;flags != flags)</span>
<span class="p_add">+		if ((n-&gt;flags ^ flags) &amp;</span>
<span class="p_add">+		    ~(TCA_CLS_FLAGS_IN_HW | TCA_CLS_FLAGS_NOT_IN_HW))</span>
 			return -EINVAL;
 
 		new = u32_init_knode(tp, n);
<span class="p_header">diff --git a/net/sctp/input.c b/net/sctp/input.c</span>
<span class="p_header">index 141c9c466ec1..0247cc432e02 100644</span>
<span class="p_header">--- a/net/sctp/input.c</span>
<span class="p_header">+++ b/net/sctp/input.c</span>
<span class="p_chunk">@@ -897,15 +897,12 @@</span> <span class="p_context"> int sctp_hash_transport(struct sctp_transport *t)</span>
 	rhl_for_each_entry_rcu(transport, tmp, list, node)
 		if (transport-&gt;asoc-&gt;ep == t-&gt;asoc-&gt;ep) {
 			rcu_read_unlock();
<span class="p_del">-			err = -EEXIST;</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+			return -EEXIST;</span>
 		}
 	rcu_read_unlock();
 
 	err = rhltable_insert_key(&amp;sctp_transport_hashtable, &amp;arg,
 				  &amp;t-&gt;node, sctp_hash_params);
<span class="p_del">-</span>
<span class="p_del">-out:</span>
 	if (err)
 		pr_err_once(&quot;insert transport fail, errno %d\n&quot;, err);
 
<span class="p_header">diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c</span>
<span class="p_header">index 5d4c15bf66d2..e35d4f73d2df 100644</span>
<span class="p_header">--- a/net/sctp/ipv6.c</span>
<span class="p_header">+++ b/net/sctp/ipv6.c</span>
<span class="p_chunk">@@ -326,8 +326,10 @@</span> <span class="p_context"> static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,</span>
 		final_p = fl6_update_dst(fl6, rcu_dereference(np-&gt;opt), &amp;final);
 		bdst = ip6_dst_lookup_flow(sk, fl6, final_p);
 
<span class="p_del">-		if (!IS_ERR(bdst) &amp;&amp;</span>
<span class="p_del">-		    ipv6_chk_addr(dev_net(bdst-&gt;dev),</span>
<span class="p_add">+		if (IS_ERR(bdst))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ipv6_chk_addr(dev_net(bdst-&gt;dev),</span>
 				  &amp;laddr-&gt;a.v6.sin6_addr, bdst-&gt;dev, 1)) {
 			if (!IS_ERR_OR_NULL(dst))
 				dst_release(dst);
<span class="p_chunk">@@ -336,8 +338,10 @@</span> <span class="p_context"> static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,</span>
 		}
 
 		bmatchlen = sctp_v6_addr_match_len(daddr, &amp;laddr-&gt;a);
<span class="p_del">-		if (matchlen &gt; bmatchlen)</span>
<span class="p_add">+		if (matchlen &gt; bmatchlen) {</span>
<span class="p_add">+			dst_release(bdst);</span>
 			continue;
<span class="p_add">+		}</span>
 
 		if (!IS_ERR_OR_NULL(dst))
 			dst_release(dst);
<span class="p_header">diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c</span>
<span class="p_header">index 6a38c2503649..91813e686c67 100644</span>
<span class="p_header">--- a/net/sctp/protocol.c</span>
<span class="p_header">+++ b/net/sctp/protocol.c</span>
<span class="p_chunk">@@ -514,22 +514,20 @@</span> <span class="p_context"> static void sctp_v4_get_dst(struct sctp_transport *t, union sctp_addr *saddr,</span>
 		if (IS_ERR(rt))
 			continue;
 
<span class="p_del">-		if (!dst)</span>
<span class="p_del">-			dst = &amp;rt-&gt;dst;</span>
<span class="p_del">-</span>
 		/* Ensure the src address belongs to the output
 		 * interface.
 		 */
 		odev = __ip_dev_find(sock_net(sk), laddr-&gt;a.v4.sin_addr.s_addr,
 				     false);
 		if (!odev || odev-&gt;ifindex != fl4-&gt;flowi4_oif) {
<span class="p_del">-			if (&amp;rt-&gt;dst != dst)</span>
<span class="p_add">+			if (!dst)</span>
<span class="p_add">+				dst = &amp;rt-&gt;dst;</span>
<span class="p_add">+			else</span>
 				dst_release(&amp;rt-&gt;dst);
 			continue;
 		}
 
<span class="p_del">-		if (dst != &amp;rt-&gt;dst)</span>
<span class="p_del">-			dst_release(dst);</span>
<span class="p_add">+		dst_release(dst);</span>
 		dst = &amp;rt-&gt;dst;
 		break;
 	}
<span class="p_header">diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c</span>
<span class="p_header">index 9bf575f2e8ed..ea4226e382f9 100644</span>
<span class="p_header">--- a/net/sctp/sm_make_chunk.c</span>
<span class="p_header">+++ b/net/sctp/sm_make_chunk.c</span>
<span class="p_chunk">@@ -1378,9 +1378,14 @@</span> <span class="p_context"> static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,</span>
 	struct sctp_chunk *retval;
 	struct sk_buff *skb;
 	struct sock *sk;
<span class="p_add">+	int chunklen;</span>
<span class="p_add">+</span>
<span class="p_add">+	chunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);</span>
<span class="p_add">+	if (chunklen &gt; SCTP_MAX_CHUNK_LEN)</span>
<span class="p_add">+		goto nodata;</span>
 
 	/* No need to allocate LL here, as this is only a chunk. */
<span class="p_del">-	skb = alloc_skb(SCTP_PAD4(sizeof(*chunk_hdr) + paylen), gfp);</span>
<span class="p_add">+	skb = alloc_skb(chunklen, gfp);</span>
 	if (!skb)
 		goto nodata;
 
<span class="p_header">diff --git a/net/tls/tls_main.c b/net/tls/tls_main.c</span>
<span class="p_header">index 736719c8314e..3a780337c393 100644</span>
<span class="p_header">--- a/net/tls/tls_main.c</span>
<span class="p_header">+++ b/net/tls/tls_main.c</span>
<span class="p_chunk">@@ -45,17 +45,27 @@</span> <span class="p_context"> MODULE_AUTHOR(&quot;Mellanox Technologies&quot;);</span>
 MODULE_DESCRIPTION(&quot;Transport Layer Security Support&quot;);
 MODULE_LICENSE(&quot;Dual BSD/GPL&quot;);
 
<span class="p_add">+enum {</span>
<span class="p_add">+	TLSV4,</span>
<span class="p_add">+	TLSV6,</span>
<span class="p_add">+	TLS_NUM_PROTS,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 enum {
 	TLS_BASE_TX,
 	TLS_SW_TX,
 	TLS_NUM_CONFIG,
 };
 
<span class="p_del">-static struct proto tls_prots[TLS_NUM_CONFIG];</span>
<span class="p_add">+static struct proto *saved_tcpv6_prot;</span>
<span class="p_add">+static DEFINE_MUTEX(tcpv6_prot_mutex);</span>
<span class="p_add">+static struct proto tls_prots[TLS_NUM_PROTS][TLS_NUM_CONFIG];</span>
 
 static inline void update_sk_prot(struct sock *sk, struct tls_context *ctx)
 {
<span class="p_del">-	sk-&gt;sk_prot = &amp;tls_prots[ctx-&gt;tx_conf];</span>
<span class="p_add">+	int ip_ver = sk-&gt;sk_family == AF_INET6 ? TLSV6 : TLSV4;</span>
<span class="p_add">+</span>
<span class="p_add">+	sk-&gt;sk_prot = &amp;tls_prots[ip_ver][ctx-&gt;tx_conf];</span>
 }
 
 int wait_on_pending_writer(struct sock *sk, long *timeo)
<span class="p_chunk">@@ -450,8 +460,21 @@</span> <span class="p_context"> static int tls_setsockopt(struct sock *sk, int level, int optname,</span>
 	return do_tls_setsockopt(sk, optname, optval, optlen);
 }
 
<span class="p_add">+static void build_protos(struct proto *prot, struct proto *base)</span>
<span class="p_add">+{</span>
<span class="p_add">+	prot[TLS_BASE_TX] = *base;</span>
<span class="p_add">+	prot[TLS_BASE_TX].setsockopt	= tls_setsockopt;</span>
<span class="p_add">+	prot[TLS_BASE_TX].getsockopt	= tls_getsockopt;</span>
<span class="p_add">+	prot[TLS_BASE_TX].close		= tls_sk_proto_close;</span>
<span class="p_add">+</span>
<span class="p_add">+	prot[TLS_SW_TX] = prot[TLS_BASE_TX];</span>
<span class="p_add">+	prot[TLS_SW_TX].sendmsg		= tls_sw_sendmsg;</span>
<span class="p_add">+	prot[TLS_SW_TX].sendpage	= tls_sw_sendpage;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int tls_init(struct sock *sk)
 {
<span class="p_add">+	int ip_ver = sk-&gt;sk_family == AF_INET6 ? TLSV6 : TLSV4;</span>
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct tls_context *ctx;
 	int rc = 0;
<span class="p_chunk">@@ -476,6 +499,17 @@</span> <span class="p_context"> static int tls_init(struct sock *sk)</span>
 	ctx-&gt;getsockopt = sk-&gt;sk_prot-&gt;getsockopt;
 	ctx-&gt;sk_proto_close = sk-&gt;sk_prot-&gt;close;
 
<span class="p_add">+	/* Build IPv6 TLS whenever the address of tcpv6_prot changes */</span>
<span class="p_add">+	if (ip_ver == TLSV6 &amp;&amp;</span>
<span class="p_add">+	    unlikely(sk-&gt;sk_prot != smp_load_acquire(&amp;saved_tcpv6_prot))) {</span>
<span class="p_add">+		mutex_lock(&amp;tcpv6_prot_mutex);</span>
<span class="p_add">+		if (likely(sk-&gt;sk_prot != saved_tcpv6_prot)) {</span>
<span class="p_add">+			build_protos(tls_prots[TLSV6], sk-&gt;sk_prot);</span>
<span class="p_add">+			smp_store_release(&amp;saved_tcpv6_prot, sk-&gt;sk_prot);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mutex_unlock(&amp;tcpv6_prot_mutex);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ctx-&gt;tx_conf = TLS_BASE_TX;
 	update_sk_prot(sk, ctx);
 out:
<span class="p_chunk">@@ -488,21 +522,9 @@</span> <span class="p_context"> static struct tcp_ulp_ops tcp_tls_ulp_ops __read_mostly = {</span>
 	.init			= tls_init,
 };
 
<span class="p_del">-static void build_protos(struct proto *prot, struct proto *base)</span>
<span class="p_del">-{</span>
<span class="p_del">-	prot[TLS_BASE_TX] = *base;</span>
<span class="p_del">-	prot[TLS_BASE_TX].setsockopt	= tls_setsockopt;</span>
<span class="p_del">-	prot[TLS_BASE_TX].getsockopt	= tls_getsockopt;</span>
<span class="p_del">-	prot[TLS_BASE_TX].close		= tls_sk_proto_close;</span>
<span class="p_del">-</span>
<span class="p_del">-	prot[TLS_SW_TX] = prot[TLS_BASE_TX];</span>
<span class="p_del">-	prot[TLS_SW_TX].sendmsg		= tls_sw_sendmsg;</span>
<span class="p_del">-	prot[TLS_SW_TX].sendpage	= tls_sw_sendpage;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int __init tls_register(void)
 {
<span class="p_del">-	build_protos(tls_prots, &amp;tcp_prot);</span>
<span class="p_add">+	build_protos(tls_prots[TLSV4], &amp;tcp_prot);</span>
 
 	tcp_register_ulp(&amp;tcp_tls_ulp_ops);
 
<span class="p_header">diff --git a/sound/core/control.c b/sound/core/control.c</span>
<span class="p_header">index 56b3e2d49c82..af7e6165e21e 100644</span>
<span class="p_header">--- a/sound/core/control.c</span>
<span class="p_header">+++ b/sound/core/control.c</span>
<span class="p_chunk">@@ -888,7 +888,7 @@</span> <span class="p_context"> static int snd_ctl_elem_read(struct snd_card *card,</span>
 
 	index_offset = snd_ctl_get_ioff(kctl, &amp;control-&gt;id);
 	vd = &amp;kctl-&gt;vd[index_offset];
<span class="p_del">-	if (!(vd-&gt;access &amp; SNDRV_CTL_ELEM_ACCESS_READ) &amp;&amp; kctl-&gt;get == NULL)</span>
<span class="p_add">+	if (!(vd-&gt;access &amp; SNDRV_CTL_ELEM_ACCESS_READ) || kctl-&gt;get == NULL)</span>
 		return -EPERM;
 
 	snd_ctl_build_ioff(&amp;control-&gt;id, kctl, index_offset);
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index c71dcacea807..96143df19b21 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> static const struct kernel_param_ops param_ops_xint = {</span>
 };
 #define param_check_xint param_check_int
 
<span class="p_del">-static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;</span>
<span class="p_add">+static int power_save = -1;</span>
 module_param(power_save, xint, 0644);
 MODULE_PARM_DESC(power_save, &quot;Automatic power-saving timeout &quot;
 		 &quot;(in second, 0 = disable).&quot;);
<span class="p_chunk">@@ -2186,6 +2186,24 @@</span> <span class="p_context"> static int azx_probe(struct pci_dev *pci,</span>
 	return err;
 }
 
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+/* On some boards setting power_save to a non 0 value leads to clicking /</span>
<span class="p_add">+ * popping sounds when ever we enter/leave powersaving mode. Ideally we would</span>
<span class="p_add">+ * figure out how to avoid these sounds, but that is not always feasible.</span>
<span class="p_add">+ * So we keep a list of devices where we disable powersaving as its known</span>
<span class="p_add">+ * to causes problems on these devices.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct snd_pci_quirk power_save_blacklist[] = {</span>
<span class="p_add">+	/* https://bugzilla.redhat.com/show_bug.cgi?id=1525104 */</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1849, 0x0c0c, &quot;Asrock B85M-ITX&quot;, 0),</span>
<span class="p_add">+	/* https://bugzilla.redhat.com/show_bug.cgi?id=1525104 */</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x8733, &quot;Asus Prime X370-Pro&quot;, 0),</span>
<span class="p_add">+	/* https://bugzilla.kernel.org/show_bug.cgi?id=198611 */</span>
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2227, &quot;Lenovo X1 Carbon 3rd Gen&quot;, 0),</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif /* CONFIG_PM */</span>
<span class="p_add">+</span>
 /* number of codec slots for each chipset: 0 = default slots (i.e. 4) */
 static unsigned int azx_max_codecs[AZX_NUM_DRIVERS] = {
 	[AZX_DRIVER_NVIDIA] = 8,
<span class="p_chunk">@@ -2198,6 +2216,7 @@</span> <span class="p_context"> static int azx_probe_continue(struct azx *chip)</span>
 	struct hdac_bus *bus = azx_bus(chip);
 	struct pci_dev *pci = chip-&gt;pci;
 	int dev = chip-&gt;dev_index;
<span class="p_add">+	int val;</span>
 	int err;
 
 	hda-&gt;probe_continued = 1;
<span class="p_chunk">@@ -2278,7 +2297,22 @@</span> <span class="p_context"> static int azx_probe_continue(struct azx *chip)</span>
 
 	chip-&gt;running = 1;
 	azx_add_card_list(chip);
<span class="p_del">-	snd_hda_set_power_save(&amp;chip-&gt;bus, power_save * 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	val = power_save;</span>
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+	if (val == -1) {</span>
<span class="p_add">+		const struct snd_pci_quirk *q;</span>
<span class="p_add">+</span>
<span class="p_add">+		val = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;</span>
<span class="p_add">+		q = snd_pci_quirk_lookup(chip-&gt;pci, power_save_blacklist);</span>
<span class="p_add">+		if (q &amp;&amp; val) {</span>
<span class="p_add">+			dev_info(chip-&gt;card-&gt;dev, &quot;device %04x:%04x is on the power_save blacklist, forcing power_save to 0\n&quot;,</span>
<span class="p_add">+				 q-&gt;subvendor, q-&gt;subdevice);</span>
<span class="p_add">+			val = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_PM */</span>
<span class="p_add">+	snd_hda_set_power_save(&amp;chip-&gt;bus, val * 1000);</span>
 	if (azx_has_pm_runtime(chip) || hda-&gt;use_vga_switcheroo)
 		pm_runtime_put_autosuspend(&amp;pci-&gt;dev);
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 4ff1f0ca52fc..8fe38c18e29d 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4875,13 +4875,14 @@</span> <span class="p_context"> static void alc_fixup_tpt470_dock(struct hda_codec *codec,</span>
 
 	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
 		spec-&gt;parse_flags = HDA_PINCFG_NO_HP_FIXUP;
<span class="p_add">+		snd_hda_apply_pincfgs(codec, pincfgs);</span>
<span class="p_add">+	} else if (action == HDA_FIXUP_ACT_INIT) {</span>
 		/* Enable DOCK device */
 		snd_hda_codec_write(codec, 0x17, 0,
 			    AC_VERB_SET_CONFIG_DEFAULT_BYTES_3, 0);
 		/* Enable DOCK device */
 		snd_hda_codec_write(codec, 0x19, 0,
 			    AC_VERB_SET_CONFIG_DEFAULT_BYTES_3, 0);
<span class="p_del">-		snd_hda_apply_pincfgs(codec, pincfgs);</span>
 	}
 }
 
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index 8a59d4782a0f..69bf5cf1e91e 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -3277,4 +3277,51 @@</span> <span class="p_context"> AU0828_DEVICE(0x2040, 0x7270, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),</span>
 	}
 },
 
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Bower&#39;s &amp; Wilkins PX headphones only support the 48 kHz sample rate</span>
<span class="p_add">+	 * even though it advertises more. The capture interface doesn&#39;t work</span>
<span class="p_add">+	 * even on windows.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	USB_DEVICE(0x19b5, 0x0021),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp;(const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_MIXER,</span>
<span class="p_add">+			},</span>
<span class="p_add">+			/* Capture */</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_IGNORE_INTERFACE,</span>
<span class="p_add">+			},</span>
<span class="p_add">+			/* Playback */</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct audioformat) {</span>
<span class="p_add">+					.formats = SNDRV_PCM_FMTBIT_S16_LE,</span>
<span class="p_add">+					.channels = 2,</span>
<span class="p_add">+					.iface = 2,</span>
<span class="p_add">+					.altsetting = 1,</span>
<span class="p_add">+					.altset_idx = 1,</span>
<span class="p_add">+					.attributes = UAC_EP_CS_ATTR_FILL_MAX |</span>
<span class="p_add">+						UAC_EP_CS_ATTR_SAMPLE_RATE,</span>
<span class="p_add">+					.endpoint = 0x03,</span>
<span class="p_add">+					.ep_attr = USB_ENDPOINT_XFER_ISOC,</span>
<span class="p_add">+					.rates = SNDRV_PCM_RATE_48000,</span>
<span class="p_add">+					.rate_min = 48000,</span>
<span class="p_add">+					.rate_max = 48000,</span>
<span class="p_add">+					.nr_rates = 1,</span>
<span class="p_add">+					.rate_table = (unsigned int[]) {</span>
<span class="p_add">+						48000</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 #undef USB_DEVICE_VENDOR_SPEC
<span class="p_header">diff --git a/sound/x86/intel_hdmi_audio.c b/sound/x86/intel_hdmi_audio.c</span>
<span class="p_header">index a0951505c7f5..697872d8308e 100644</span>
<span class="p_header">--- a/sound/x86/intel_hdmi_audio.c</span>
<span class="p_header">+++ b/sound/x86/intel_hdmi_audio.c</span>
<span class="p_chunk">@@ -1827,6 +1827,8 @@</span> <span class="p_context"> static int hdmi_lpe_audio_probe(struct platform_device *pdev)</span>
 		ctx-&gt;port = port;
 		ctx-&gt;pipe = -1;
 
<span class="p_add">+		spin_lock_init(&amp;ctx-&gt;had_spinlock);</span>
<span class="p_add">+		mutex_init(&amp;ctx-&gt;mutex);</span>
 		INIT_WORK(&amp;ctx-&gt;hdmi_audio_wq, had_audio_wq);
 
 		ret = snd_pcm_new(card, INTEL_HAD, port, MAX_PB_STREAMS,
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 210bf820385a..e536977e7b6d 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -974,8 +974,7 @@</span> <span class="p_context"> int __kvm_set_memory_region(struct kvm *kvm,</span>
 		/* Check for overlaps */
 		r = -EEXIST;
 		kvm_for_each_memslot(slot, __kvm_memslots(kvm, as_id)) {
<span class="p_del">-			if ((slot-&gt;id &gt;= KVM_USER_MEM_SLOTS) ||</span>
<span class="p_del">-			    (slot-&gt;id == id))</span>
<span class="p_add">+			if (slot-&gt;id == id)</span>
 				continue;
 			if (!((base_gfn + npages &lt;= slot-&gt;base_gfn) ||
 			      (base_gfn &gt;= slot-&gt;base_gfn + slot-&gt;npages)))

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



