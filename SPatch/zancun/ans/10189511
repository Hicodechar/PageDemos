
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] EFI changes for v4.16 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] EFI changes for v4.16</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 29, 2018, 10:33 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180129103310.2gwdcrjibba2msvl@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10189511/mbox/"
   >mbox</a>
|
   <a href="/patch/10189511/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10189511/">/patch/10189511/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9C11A60375 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 29 Jan 2018 10:33:22 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A24D428676
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 29 Jan 2018 10:33:22 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 95AD52868C; Mon, 29 Jan 2018 10:33:22 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-3.4 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	FSL_HELO_FAKE, RCVD_IN_DNSWL_HI,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2A54A28676
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 29 Jan 2018 10:33:21 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751609AbeA2KdR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 29 Jan 2018 05:33:17 -0500
Received: from mail-wm0-f51.google.com ([74.125.82.51]:39143 &quot;EHLO
	mail-wm0-f51.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750913AbeA2KdO (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 29 Jan 2018 05:33:14 -0500
Received: by mail-wm0-f51.google.com with SMTP id b21so32636112wme.4;
	Mon, 29 Jan 2018 02:33:13 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=fN5pLkDXJpcDmb4rO4+eYvMITbTxTtw4S2/TBMn2CCE=;
	b=QTbEOc2w2JRyAoCw2LYsG2NfKOHvUeXQFbKNJiKsp7B7hO0T6nSUg5uGU5iIqavC6P
	jbEPMF2tqC/S8Ze4FBkNZeyf6fin75p7doZXa8XC47p0/HQMXM51eg6gIOulubBDaLJV
	nEf2qUKCQaF1L8ZnfrH/NytjQlTkK2pnlzZwGI2ql/HeoDZqEnwCPnXwix0wMom7zVRJ
	yi6V9wTIvVa7vtdRx1A9hPAe1OTEtwDvtha7HMfszJZ9p4OYLX6ZLTrb8Jdnd6qYljmV
	B1BajuJMd4fMxhg64lvSFfNYnxXkowVt0kdTNKJ/Rqst5emDoBD3lqGgAGkUwxLY5THA
	dq1Q==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=fN5pLkDXJpcDmb4rO4+eYvMITbTxTtw4S2/TBMn2CCE=;
	b=jQ38l7wbzzWLRC277x5yfJlP0v0qlxP6kEQmtjY+fMTGZafX6owDbM0bJmNXobLkZE
	frKEvbzy546YBeKJoeuVleNvumekC/VQij66pp0rtI1LOuhIfa0OETXaF8+ysUEzM4PT
	UCz/WGiJH6gYLv9+W7rd7MyZ5598bqOMfin9ot0qICLuFiBgXei16ckLM6F6D5w128y0
	DyYNr03osZPWSQ4b8ruasvsPjoALNxBBM7qW6glM6q1MWOgYmcW5C+5WH87gf8zvh765
	zhEE4tZ2XrSO2HmgJ/yBWnOjV2+4UVGjZHv5KtXkC+TLtS2rFJqYdsP4+QSp7LuWYfmj
	AHag==
X-Gm-Message-State: AKwxytcMdC4t3JHBHQp76H6y9yMJfpYaBVAj8SCncBbAeB/soGFrqxGZ
	wSWP0TUqJhVdyBRcKNQlIHI=
X-Google-Smtp-Source: AH8x2249c46LpgsGPaHEp46auVC5eMzVE9swpbMUIMQCpgLPn5fRZoc5W5X3jVNL8ThLsr1D8/KBBA==
X-Received: by 10.28.209.137 with SMTP id i131mr16572577wmg.1.1517221992710; 
	Mon, 29 Jan 2018 02:33:12 -0800 (PST)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	j132sm10230146wmd.38.2018.01.29.02.33.11
	(version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
	Mon, 29 Jan 2018 02:33:12 -0800 (PST)
Date: Mon, 29 Jan 2018 11:33:10 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Ard Biesheuvel &lt;ard.biesheuvel@linaro.org&gt;,
	linux-efi@vger.kernel.org, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;
Subject: [GIT PULL] EFI changes for v4.16
Message-ID: &lt;20180129103310.2gwdcrjibba2msvl@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: NeoMutt/20170609 (1.8.3)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Jan. 29, 2018, 10:33 a.m.</div>
<pre class="content">
Linus,

Please pull the latest efi-core-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git efi-core-for-linus

   # HEAD: a5c03c31af2291f13689d11760c0b59fb70c9a5a x86/efi: Clarify that reset attack mitigation needs appropriate userspace

The biggest change in this cycle was the addition of ARM CPER error decoding when 
printing EFI errors into the kernel log. There&#39;s also misc smaller updates: 
documentation update, cleanups and an EFI memory map permissions quirk.

 Thanks,

	Ingo

------------------&gt;
Ard Biesheuvel (1):
      arm64/efi: Ignore EFI_MEMORY_XP attribute if RP and/or WP are set

Arvind Yadav (1):
      efi/capsule-loader: Fix pr_err() string to end with newline

Matthew Garrett (1):
      x86/efi: Clarify that reset attack mitigation needs appropriate userspace

Tyler Baicar (2):
      efi: Move ARM CPER code to new file
      efi: Parse ARM error information value

Vasyl Gomonovych (1):
      efi: Use PTR_ERR_OR_ZERO()


 arch/arm64/kernel/efi.c               |   4 +-
 drivers/firmware/efi/Kconfig          |  10 +-
 drivers/firmware/efi/Makefile         |   1 +
 drivers/firmware/efi/capsule-loader.c |   2 +-
 drivers/firmware/efi/cper-arm.c       | 356 ++++++++++++++++++++++++++++++++++
 drivers/firmware/efi/cper.c           | 122 +-----------
 drivers/firmware/efi/efi.c            |   2 +-
 include/linux/cper.h                  |  48 +++++
 8 files changed, 422 insertions(+), 123 deletions(-)
 create mode 100644 drivers/firmware/efi/cper-arm.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm64/kernel/efi.c b/arch/arm64/kernel/efi.c</span>
<span class="p_header">index 82cd07592519..f85ac58d08a3 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/efi.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/efi.c</span>
<span class="p_chunk">@@ -48,7 +48,9 @@</span> <span class="p_context"> static __init pteval_t create_mapping_protection(efi_memory_desc_t *md)</span>
 		return pgprot_val(PAGE_KERNEL_ROX);
 
 	/* RW- */
<span class="p_del">-	if (attr &amp; EFI_MEMORY_XP || type != EFI_RUNTIME_SERVICES_CODE)</span>
<span class="p_add">+	if (((attr &amp; (EFI_MEMORY_RP | EFI_MEMORY_WP | EFI_MEMORY_XP)) ==</span>
<span class="p_add">+	     EFI_MEMORY_XP) ||</span>
<span class="p_add">+	    type != EFI_RUNTIME_SERVICES_CODE)</span>
 		return pgprot_val(PAGE_KERNEL);
 
 	/* RWX */
<span class="p_header">diff --git a/drivers/firmware/efi/Kconfig b/drivers/firmware/efi/Kconfig</span>
<span class="p_header">index 2b4c39fdfa91..6047ed4e8a3d 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/Kconfig</span>
<span class="p_header">+++ b/drivers/firmware/efi/Kconfig</span>
<span class="p_chunk">@@ -159,13 +159,21 @@</span> <span class="p_context"> config RESET_ATTACK_MITIGATION</span>
 	  using the TCG Platform Reset Attack Mitigation specification. This
 	  protects against an attacker forcibly rebooting the system while it
 	  still contains secrets in RAM, booting another OS and extracting the
<span class="p_del">-	  secrets.</span>
<span class="p_add">+	  secrets. This should only be enabled when userland is configured to</span>
<span class="p_add">+	  clear the MemoryOverwriteRequest flag on clean shutdown after secrets</span>
<span class="p_add">+	  have been evicted, since otherwise it will trigger even on clean</span>
<span class="p_add">+	  reboots.</span>
 
 endmenu
 
 config UEFI_CPER
 	bool
 
<span class="p_add">+config UEFI_CPER_ARM</span>
<span class="p_add">+	bool</span>
<span class="p_add">+	depends on UEFI_CPER &amp;&amp; ( ARM || ARM64 )</span>
<span class="p_add">+	default y</span>
<span class="p_add">+</span>
 config EFI_DEV_PATH_PARSER
 	bool
 	depends on ACPI
<span class="p_header">diff --git a/drivers/firmware/efi/Makefile b/drivers/firmware/efi/Makefile</span>
<span class="p_header">index 269501dfba53..a3e73d6e8a43 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/Makefile</span>
<span class="p_header">+++ b/drivers/firmware/efi/Makefile</span>
<span class="p_chunk">@@ -30,3 +30,4 @@</span> <span class="p_context"> arm-obj-$(CONFIG_EFI)			:= arm-init.o arm-runtime.o</span>
 obj-$(CONFIG_ARM)			+= $(arm-obj-y)
 obj-$(CONFIG_ARM64)			+= $(arm-obj-y)
 obj-$(CONFIG_EFI_CAPSULE_LOADER)	+= capsule-loader.o
<span class="p_add">+obj-$(CONFIG_UEFI_CPER_ARM)		+= cper-arm.o</span>
<span class="p_header">diff --git a/drivers/firmware/efi/capsule-loader.c b/drivers/firmware/efi/capsule-loader.c</span>
<span class="p_header">index 055e2e8f985a..e456f4602df1 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/capsule-loader.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/capsule-loader.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> int __efi_capsule_setup_info(struct capsule_info *cap_info)</span>
 	pages_needed = ALIGN(cap_info-&gt;total_size, PAGE_SIZE) / PAGE_SIZE;
 
 	if (pages_needed == 0) {
<span class="p_del">-		pr_err(&quot;invalid capsule size&quot;);</span>
<span class="p_add">+		pr_err(&quot;invalid capsule size\n&quot;);</span>
 		return -EINVAL;
 	}
 
<span class="p_header">diff --git a/drivers/firmware/efi/cper-arm.c b/drivers/firmware/efi/cper-arm.c</span>
new file mode 100644
<span class="p_header">index 000000000000..698e5c8e0c8d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/firmware/efi/cper-arm.c</span>
<span class="p_chunk">@@ -0,0 +1,356 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * UEFI Common Platform Error Record (CPER) support</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2017, The Linux Foundation. All rights reserved.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or</span>
<span class="p_add">+ * modify it under the terms of the GNU General Public License version</span>
<span class="p_add">+ * 2 as published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program; if not, write to the Free Software</span>
<span class="p_add">+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/time.h&gt;</span>
<span class="p_add">+#include &lt;linux/cper.h&gt;</span>
<span class="p_add">+#include &lt;linux/dmi.h&gt;</span>
<span class="p_add">+#include &lt;linux/acpi.h&gt;</span>
<span class="p_add">+#include &lt;linux/pci.h&gt;</span>
<span class="p_add">+#include &lt;linux/aer.h&gt;</span>
<span class="p_add">+#include &lt;linux/printk.h&gt;</span>
<span class="p_add">+#include &lt;linux/bcd.h&gt;</span>
<span class="p_add">+#include &lt;acpi/ghes.h&gt;</span>
<span class="p_add">+#include &lt;ras/ras_event.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define INDENT_SP	&quot; &quot;</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const arm_reg_ctx_strs[] = {</span>
<span class="p_add">+	&quot;AArch32 general purpose registers&quot;,</span>
<span class="p_add">+	&quot;AArch32 EL1 context registers&quot;,</span>
<span class="p_add">+	&quot;AArch32 EL2 context registers&quot;,</span>
<span class="p_add">+	&quot;AArch32 secure context registers&quot;,</span>
<span class="p_add">+	&quot;AArch64 general purpose registers&quot;,</span>
<span class="p_add">+	&quot;AArch64 EL1 context registers&quot;,</span>
<span class="p_add">+	&quot;AArch64 EL2 context registers&quot;,</span>
<span class="p_add">+	&quot;AArch64 EL3 context registers&quot;,</span>
<span class="p_add">+	&quot;Misc. system register structure&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const arm_err_trans_type_strs[] = {</span>
<span class="p_add">+	&quot;Instruction&quot;,</span>
<span class="p_add">+	&quot;Data Access&quot;,</span>
<span class="p_add">+	&quot;Generic&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const arm_bus_err_op_strs[] = {</span>
<span class="p_add">+	&quot;Generic error (type cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Generic read (type of instruction or data request cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Generic write (type of instruction of data request cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Data read&quot;,</span>
<span class="p_add">+	&quot;Data write&quot;,</span>
<span class="p_add">+	&quot;Instruction fetch&quot;,</span>
<span class="p_add">+	&quot;Prefetch&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const arm_cache_err_op_strs[] = {</span>
<span class="p_add">+	&quot;Generic error (type cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Generic read (type of instruction or data request cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Generic write (type of instruction of data request cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Data read&quot;,</span>
<span class="p_add">+	&quot;Data write&quot;,</span>
<span class="p_add">+	&quot;Instruction fetch&quot;,</span>
<span class="p_add">+	&quot;Prefetch&quot;,</span>
<span class="p_add">+	&quot;Eviction&quot;,</span>
<span class="p_add">+	&quot;Snooping (processor initiated a cache snoop that resulted in an error)&quot;,</span>
<span class="p_add">+	&quot;Snooped (processor raised a cache error caused by another processor or device snooping its cache)&quot;,</span>
<span class="p_add">+	&quot;Management&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const arm_tlb_err_op_strs[] = {</span>
<span class="p_add">+	&quot;Generic error (type cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Generic read (type of instruction or data request cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Generic write (type of instruction of data request cannot be determined)&quot;,</span>
<span class="p_add">+	&quot;Data read&quot;,</span>
<span class="p_add">+	&quot;Data write&quot;,</span>
<span class="p_add">+	&quot;Instruction fetch&quot;,</span>
<span class="p_add">+	&quot;Prefetch&quot;,</span>
<span class="p_add">+	&quot;Local management operation (processor initiated a TLB management operation that resulted in an error)&quot;,</span>
<span class="p_add">+	&quot;External management operation (processor raised a TLB error caused by another processor or device broadcasting TLB operations)&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const arm_bus_err_part_type_strs[] = {</span>
<span class="p_add">+	&quot;Local processor originated request&quot;,</span>
<span class="p_add">+	&quot;Local processor responded to request&quot;,</span>
<span class="p_add">+	&quot;Local processor observed&quot;,</span>
<span class="p_add">+	&quot;Generic&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const char * const arm_bus_err_addr_space_strs[] = {</span>
<span class="p_add">+	&quot;External Memory Access&quot;,</span>
<span class="p_add">+	&quot;Internal Memory Access&quot;,</span>
<span class="p_add">+	&quot;Unknown&quot;,</span>
<span class="p_add">+	&quot;Device Memory Access&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void cper_print_arm_err_info(const char *pfx, u32 type,</span>
<span class="p_add">+				    u64 error_info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 trans_type, op_type, level, participation_type, address_space;</span>
<span class="p_add">+	u16 mem_attributes;</span>
<span class="p_add">+	bool proc_context_corrupt, corrected, precise_pc, restartable_pc;</span>
<span class="p_add">+	bool time_out, access_mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If the type is unknown, bail. */</span>
<span class="p_add">+	if (type &gt; CPER_ARM_MAX_TYPE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Vendor type errors have error information values that are vendor</span>
<span class="p_add">+	 * specific.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (type == CPER_ARM_VENDOR_ERROR)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_TRANSACTION_TYPE) {</span>
<span class="p_add">+		trans_type = ((error_info &gt;&gt; CPER_ARM_ERR_TRANSACTION_SHIFT)</span>
<span class="p_add">+			      &amp; CPER_ARM_ERR_TRANSACTION_MASK);</span>
<span class="p_add">+		if (trans_type &lt; ARRAY_SIZE(arm_err_trans_type_strs)) {</span>
<span class="p_add">+			printk(&quot;%stransaction type: %s\n&quot;, pfx,</span>
<span class="p_add">+			       arm_err_trans_type_strs[trans_type]);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_OPERATION_TYPE) {</span>
<span class="p_add">+		op_type = ((error_info &gt;&gt; CPER_ARM_ERR_OPERATION_SHIFT)</span>
<span class="p_add">+			   &amp; CPER_ARM_ERR_OPERATION_MASK);</span>
<span class="p_add">+		switch (type) {</span>
<span class="p_add">+		case CPER_ARM_CACHE_ERROR:</span>
<span class="p_add">+			if (op_type &lt; ARRAY_SIZE(arm_cache_err_op_strs)) {</span>
<span class="p_add">+				printk(&quot;%soperation type: %s\n&quot;, pfx,</span>
<span class="p_add">+				       arm_cache_err_op_strs[op_type]);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case CPER_ARM_TLB_ERROR:</span>
<span class="p_add">+			if (op_type &lt; ARRAY_SIZE(arm_tlb_err_op_strs)) {</span>
<span class="p_add">+				printk(&quot;%soperation type: %s\n&quot;, pfx,</span>
<span class="p_add">+				       arm_tlb_err_op_strs[op_type]);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case CPER_ARM_BUS_ERROR:</span>
<span class="p_add">+			if (op_type &lt; ARRAY_SIZE(arm_bus_err_op_strs)) {</span>
<span class="p_add">+				printk(&quot;%soperation type: %s\n&quot;, pfx,</span>
<span class="p_add">+				       arm_bus_err_op_strs[op_type]);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_LEVEL) {</span>
<span class="p_add">+		level = ((error_info &gt;&gt; CPER_ARM_ERR_LEVEL_SHIFT)</span>
<span class="p_add">+			 &amp; CPER_ARM_ERR_LEVEL_MASK);</span>
<span class="p_add">+		switch (type) {</span>
<span class="p_add">+		case CPER_ARM_CACHE_ERROR:</span>
<span class="p_add">+			printk(&quot;%scache level: %d\n&quot;, pfx, level);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case CPER_ARM_TLB_ERROR:</span>
<span class="p_add">+			printk(&quot;%sTLB level: %d\n&quot;, pfx, level);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case CPER_ARM_BUS_ERROR:</span>
<span class="p_add">+			printk(&quot;%saffinity level at which the bus error occurred: %d\n&quot;,</span>
<span class="p_add">+			       pfx, level);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_PROC_CONTEXT_CORRUPT) {</span>
<span class="p_add">+		proc_context_corrupt = ((error_info &gt;&gt; CPER_ARM_ERR_PC_CORRUPT_SHIFT)</span>
<span class="p_add">+					&amp; CPER_ARM_ERR_PC_CORRUPT_MASK);</span>
<span class="p_add">+		if (proc_context_corrupt)</span>
<span class="p_add">+			printk(&quot;%sprocessor context corrupted\n&quot;, pfx);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			printk(&quot;%sprocessor context not corrupted\n&quot;, pfx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_CORRECTED) {</span>
<span class="p_add">+		corrected = ((error_info &gt;&gt; CPER_ARM_ERR_CORRECTED_SHIFT)</span>
<span class="p_add">+			     &amp; CPER_ARM_ERR_CORRECTED_MASK);</span>
<span class="p_add">+		if (corrected)</span>
<span class="p_add">+			printk(&quot;%sthe error has been corrected\n&quot;, pfx);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			printk(&quot;%sthe error has not been corrected\n&quot;, pfx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_PRECISE_PC) {</span>
<span class="p_add">+		precise_pc = ((error_info &gt;&gt; CPER_ARM_ERR_PRECISE_PC_SHIFT)</span>
<span class="p_add">+			      &amp; CPER_ARM_ERR_PRECISE_PC_MASK);</span>
<span class="p_add">+		if (precise_pc)</span>
<span class="p_add">+			printk(&quot;%sPC is precise\n&quot;, pfx);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			printk(&quot;%sPC is imprecise\n&quot;, pfx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_RESTARTABLE_PC) {</span>
<span class="p_add">+		restartable_pc = ((error_info &gt;&gt; CPER_ARM_ERR_RESTARTABLE_PC_SHIFT)</span>
<span class="p_add">+				  &amp; CPER_ARM_ERR_RESTARTABLE_PC_MASK);</span>
<span class="p_add">+		if (restartable_pc)</span>
<span class="p_add">+			printk(&quot;%sProgram execution can be restarted reliably at the PC associated with the error.\n&quot;, pfx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The rest of the fields are specific to bus errors */</span>
<span class="p_add">+	if (type != CPER_ARM_BUS_ERROR)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_PARTICIPATION_TYPE) {</span>
<span class="p_add">+		participation_type = ((error_info &gt;&gt; CPER_ARM_ERR_PARTICIPATION_TYPE_SHIFT)</span>
<span class="p_add">+				      &amp; CPER_ARM_ERR_PARTICIPATION_TYPE_MASK);</span>
<span class="p_add">+		if (participation_type &lt; ARRAY_SIZE(arm_bus_err_part_type_strs)) {</span>
<span class="p_add">+			printk(&quot;%sparticipation type: %s\n&quot;, pfx,</span>
<span class="p_add">+			       arm_bus_err_part_type_strs[participation_type]);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_TIME_OUT) {</span>
<span class="p_add">+		time_out = ((error_info &gt;&gt; CPER_ARM_ERR_TIME_OUT_SHIFT)</span>
<span class="p_add">+			    &amp; CPER_ARM_ERR_TIME_OUT_MASK);</span>
<span class="p_add">+		if (time_out)</span>
<span class="p_add">+			printk(&quot;%srequest timed out\n&quot;, pfx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_ADDRESS_SPACE) {</span>
<span class="p_add">+		address_space = ((error_info &gt;&gt; CPER_ARM_ERR_ADDRESS_SPACE_SHIFT)</span>
<span class="p_add">+				 &amp; CPER_ARM_ERR_ADDRESS_SPACE_MASK);</span>
<span class="p_add">+		if (address_space &lt; ARRAY_SIZE(arm_bus_err_addr_space_strs)) {</span>
<span class="p_add">+			printk(&quot;%saddress space: %s\n&quot;, pfx,</span>
<span class="p_add">+			       arm_bus_err_addr_space_strs[address_space]);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_MEM_ATTRIBUTES) {</span>
<span class="p_add">+		mem_attributes = ((error_info &gt;&gt; CPER_ARM_ERR_MEM_ATTRIBUTES_SHIFT)</span>
<span class="p_add">+				  &amp; CPER_ARM_ERR_MEM_ATTRIBUTES_MASK);</span>
<span class="p_add">+		printk(&quot;%smemory access attributes:0x%x\n&quot;, pfx, mem_attributes);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (error_info &amp; CPER_ARM_ERR_VALID_ACCESS_MODE) {</span>
<span class="p_add">+		access_mode = ((error_info &gt;&gt; CPER_ARM_ERR_ACCESS_MODE_SHIFT)</span>
<span class="p_add">+			       &amp; CPER_ARM_ERR_ACCESS_MODE_MASK);</span>
<span class="p_add">+		if (access_mode)</span>
<span class="p_add">+			printk(&quot;%saccess mode: normal\n&quot;, pfx);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			printk(&quot;%saccess mode: secure\n&quot;, pfx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void cper_print_proc_arm(const char *pfx,</span>
<span class="p_add">+			 const struct cper_sec_proc_arm *proc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i, len, max_ctx_type;</span>
<span class="p_add">+	struct cper_arm_err_info *err_info;</span>
<span class="p_add">+	struct cper_arm_ctx_info *ctx_info;</span>
<span class="p_add">+	char newpfx[64], infopfx[64];</span>
<span class="p_add">+</span>
<span class="p_add">+	printk(&quot;%sMIDR: 0x%016llx\n&quot;, pfx, proc-&gt;midr);</span>
<span class="p_add">+</span>
<span class="p_add">+	len = proc-&gt;section_length - (sizeof(*proc) +</span>
<span class="p_add">+		proc-&gt;err_info_num * (sizeof(*err_info)));</span>
<span class="p_add">+	if (len &lt; 0) {</span>
<span class="p_add">+		printk(&quot;%ssection length: %d\n&quot;, pfx, proc-&gt;section_length);</span>
<span class="p_add">+		printk(&quot;%ssection length is too small\n&quot;, pfx);</span>
<span class="p_add">+		printk(&quot;%sfirmware-generated error record is incorrect\n&quot;, pfx);</span>
<span class="p_add">+		printk(&quot;%sERR_INFO_NUM is %d\n&quot;, pfx, proc-&gt;err_info_num);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (proc-&gt;validation_bits &amp; CPER_ARM_VALID_MPIDR)</span>
<span class="p_add">+		printk(&quot;%sMultiprocessor Affinity Register (MPIDR): 0x%016llx\n&quot;,</span>
<span class="p_add">+			pfx, proc-&gt;mpidr);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (proc-&gt;validation_bits &amp; CPER_ARM_VALID_AFFINITY_LEVEL)</span>
<span class="p_add">+		printk(&quot;%serror affinity level: %d\n&quot;, pfx,</span>
<span class="p_add">+			proc-&gt;affinity_level);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (proc-&gt;validation_bits &amp; CPER_ARM_VALID_RUNNING_STATE) {</span>
<span class="p_add">+		printk(&quot;%srunning state: 0x%x\n&quot;, pfx, proc-&gt;running_state);</span>
<span class="p_add">+		printk(&quot;%sPower State Coordination Interface state: %d\n&quot;,</span>
<span class="p_add">+			pfx, proc-&gt;psci_state);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	snprintf(newpfx, sizeof(newpfx), &quot;%s%s&quot;, pfx, INDENT_SP);</span>
<span class="p_add">+</span>
<span class="p_add">+	err_info = (struct cper_arm_err_info *)(proc + 1);</span>
<span class="p_add">+	for (i = 0; i &lt; proc-&gt;err_info_num; i++) {</span>
<span class="p_add">+		printk(&quot;%sError info structure %d:\n&quot;, pfx, i);</span>
<span class="p_add">+</span>
<span class="p_add">+		printk(&quot;%snum errors: %d\n&quot;, pfx, err_info-&gt;multiple_error + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_FLAGS) {</span>
<span class="p_add">+			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_FIRST)</span>
<span class="p_add">+				printk(&quot;%sfirst error captured\n&quot;, newpfx);</span>
<span class="p_add">+			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_LAST)</span>
<span class="p_add">+				printk(&quot;%slast error captured\n&quot;, newpfx);</span>
<span class="p_add">+			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_PROPAGATED)</span>
<span class="p_add">+				printk(&quot;%spropagated error captured\n&quot;,</span>
<span class="p_add">+				       newpfx);</span>
<span class="p_add">+			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_OVERFLOW)</span>
<span class="p_add">+				printk(&quot;%soverflow occurred, error info is incomplete\n&quot;,</span>
<span class="p_add">+				       newpfx);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		printk(&quot;%serror_type: %d, %s\n&quot;, newpfx, err_info-&gt;type,</span>
<span class="p_add">+			err_info-&gt;type &lt; ARRAY_SIZE(cper_proc_error_type_strs) ?</span>
<span class="p_add">+			cper_proc_error_type_strs[err_info-&gt;type] : &quot;unknown&quot;);</span>
<span class="p_add">+		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_ERR_INFO) {</span>
<span class="p_add">+			printk(&quot;%serror_info: 0x%016llx\n&quot;, newpfx,</span>
<span class="p_add">+			       err_info-&gt;error_info);</span>
<span class="p_add">+			snprintf(infopfx, sizeof(infopfx), &quot;%s%s&quot;, newpfx, INDENT_SP);</span>
<span class="p_add">+			cper_print_arm_err_info(infopfx, err_info-&gt;type,</span>
<span class="p_add">+						err_info-&gt;error_info);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_VIRT_ADDR)</span>
<span class="p_add">+			printk(&quot;%svirtual fault address: 0x%016llx\n&quot;,</span>
<span class="p_add">+				newpfx, err_info-&gt;virt_fault_addr);</span>
<span class="p_add">+		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_PHYSICAL_ADDR)</span>
<span class="p_add">+			printk(&quot;%sphysical fault address: 0x%016llx\n&quot;,</span>
<span class="p_add">+				newpfx, err_info-&gt;physical_fault_addr);</span>
<span class="p_add">+		err_info += 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ctx_info = (struct cper_arm_ctx_info *)err_info;</span>
<span class="p_add">+	max_ctx_type = ARRAY_SIZE(arm_reg_ctx_strs) - 1;</span>
<span class="p_add">+	for (i = 0; i &lt; proc-&gt;context_info_num; i++) {</span>
<span class="p_add">+		int size = sizeof(*ctx_info) + ctx_info-&gt;size;</span>
<span class="p_add">+</span>
<span class="p_add">+		printk(&quot;%sContext info structure %d:\n&quot;, pfx, i);</span>
<span class="p_add">+		if (len &lt; size) {</span>
<span class="p_add">+			printk(&quot;%ssection length is too small\n&quot;, newpfx);</span>
<span class="p_add">+			printk(&quot;%sfirmware-generated error record is incorrect\n&quot;, pfx);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (ctx_info-&gt;type &gt; max_ctx_type) {</span>
<span class="p_add">+			printk(&quot;%sInvalid context type: %d (max: %d)\n&quot;,</span>
<span class="p_add">+				newpfx, ctx_info-&gt;type, max_ctx_type);</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		printk(&quot;%sregister context type: %s\n&quot;, newpfx,</span>
<span class="p_add">+			arm_reg_ctx_strs[ctx_info-&gt;type]);</span>
<span class="p_add">+		print_hex_dump(newpfx, &quot;&quot;, DUMP_PREFIX_OFFSET, 16, 4,</span>
<span class="p_add">+				(ctx_info + 1), ctx_info-&gt;size, 0);</span>
<span class="p_add">+		len -= size;</span>
<span class="p_add">+		ctx_info = (struct cper_arm_ctx_info *)((long)ctx_info + size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (len &gt; 0) {</span>
<span class="p_add">+		printk(&quot;%sVendor specific error info has %u bytes:\n&quot;, pfx,</span>
<span class="p_add">+		       len);</span>
<span class="p_add">+		print_hex_dump(newpfx, &quot;&quot;, DUMP_PREFIX_OFFSET, 16, 4, ctx_info,</span>
<span class="p_add">+				len, true);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/firmware/efi/cper.c b/drivers/firmware/efi/cper.c</span>
<span class="p_header">index d2fcafcea07e..c165933ebf38 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/cper.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/cper.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> static const char * const proc_isa_strs[] = {</span>
 	&quot;ARM A64&quot;,
 };
 
<span class="p_del">-static const char * const proc_error_type_strs[] = {</span>
<span class="p_add">+const char * const cper_proc_error_type_strs[] = {</span>
 	&quot;cache error&quot;,
 	&quot;TLB error&quot;,
 	&quot;bus error&quot;,
<span class="p_chunk">@@ -157,8 +157,8 @@</span> <span class="p_context"> static void cper_print_proc_generic(const char *pfx,</span>
 	if (proc-&gt;validation_bits &amp; CPER_PROC_VALID_ERROR_TYPE) {
 		printk(&quot;%s&quot;&quot;error_type: 0x%02x\n&quot;, pfx, proc-&gt;proc_error_type);
 		cper_print_bits(pfx, proc-&gt;proc_error_type,
<span class="p_del">-				proc_error_type_strs,</span>
<span class="p_del">-				ARRAY_SIZE(proc_error_type_strs));</span>
<span class="p_add">+				cper_proc_error_type_strs,</span>
<span class="p_add">+				ARRAY_SIZE(cper_proc_error_type_strs));</span>
 	}
 	if (proc-&gt;validation_bits &amp; CPER_PROC_VALID_OPERATION)
 		printk(&quot;%s&quot;&quot;operation: %d, %s\n&quot;, pfx, proc-&gt;operation,
<span class="p_chunk">@@ -188,122 +188,6 @@</span> <span class="p_context"> static void cper_print_proc_generic(const char *pfx,</span>
 		printk(&quot;%s&quot;&quot;IP: 0x%016llx\n&quot;, pfx, proc-&gt;ip);
 }
 
<span class="p_del">-#if defined(CONFIG_ARM64) || defined(CONFIG_ARM)</span>
<span class="p_del">-static const char * const arm_reg_ctx_strs[] = {</span>
<span class="p_del">-	&quot;AArch32 general purpose registers&quot;,</span>
<span class="p_del">-	&quot;AArch32 EL1 context registers&quot;,</span>
<span class="p_del">-	&quot;AArch32 EL2 context registers&quot;,</span>
<span class="p_del">-	&quot;AArch32 secure context registers&quot;,</span>
<span class="p_del">-	&quot;AArch64 general purpose registers&quot;,</span>
<span class="p_del">-	&quot;AArch64 EL1 context registers&quot;,</span>
<span class="p_del">-	&quot;AArch64 EL2 context registers&quot;,</span>
<span class="p_del">-	&quot;AArch64 EL3 context registers&quot;,</span>
<span class="p_del">-	&quot;Misc. system register structure&quot;,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static void cper_print_proc_arm(const char *pfx,</span>
<span class="p_del">-				const struct cper_sec_proc_arm *proc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, len, max_ctx_type;</span>
<span class="p_del">-	struct cper_arm_err_info *err_info;</span>
<span class="p_del">-	struct cper_arm_ctx_info *ctx_info;</span>
<span class="p_del">-	char newpfx[64];</span>
<span class="p_del">-</span>
<span class="p_del">-	printk(&quot;%sMIDR: 0x%016llx\n&quot;, pfx, proc-&gt;midr);</span>
<span class="p_del">-</span>
<span class="p_del">-	len = proc-&gt;section_length - (sizeof(*proc) +</span>
<span class="p_del">-		proc-&gt;err_info_num * (sizeof(*err_info)));</span>
<span class="p_del">-	if (len &lt; 0) {</span>
<span class="p_del">-		printk(&quot;%ssection length: %d\n&quot;, pfx, proc-&gt;section_length);</span>
<span class="p_del">-		printk(&quot;%ssection length is too small\n&quot;, pfx);</span>
<span class="p_del">-		printk(&quot;%sfirmware-generated error record is incorrect\n&quot;, pfx);</span>
<span class="p_del">-		printk(&quot;%sERR_INFO_NUM is %d\n&quot;, pfx, proc-&gt;err_info_num);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (proc-&gt;validation_bits &amp; CPER_ARM_VALID_MPIDR)</span>
<span class="p_del">-		printk(&quot;%sMultiprocessor Affinity Register (MPIDR): 0x%016llx\n&quot;,</span>
<span class="p_del">-			pfx, proc-&gt;mpidr);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (proc-&gt;validation_bits &amp; CPER_ARM_VALID_AFFINITY_LEVEL)</span>
<span class="p_del">-		printk(&quot;%serror affinity level: %d\n&quot;, pfx,</span>
<span class="p_del">-			proc-&gt;affinity_level);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (proc-&gt;validation_bits &amp; CPER_ARM_VALID_RUNNING_STATE) {</span>
<span class="p_del">-		printk(&quot;%srunning state: 0x%x\n&quot;, pfx, proc-&gt;running_state);</span>
<span class="p_del">-		printk(&quot;%sPower State Coordination Interface state: %d\n&quot;,</span>
<span class="p_del">-			pfx, proc-&gt;psci_state);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	snprintf(newpfx, sizeof(newpfx), &quot;%s%s&quot;, pfx, INDENT_SP);</span>
<span class="p_del">-</span>
<span class="p_del">-	err_info = (struct cper_arm_err_info *)(proc + 1);</span>
<span class="p_del">-	for (i = 0; i &lt; proc-&gt;err_info_num; i++) {</span>
<span class="p_del">-		printk(&quot;%sError info structure %d:\n&quot;, pfx, i);</span>
<span class="p_del">-</span>
<span class="p_del">-		printk(&quot;%snum errors: %d\n&quot;, pfx, err_info-&gt;multiple_error + 1);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_FLAGS) {</span>
<span class="p_del">-			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_FIRST)</span>
<span class="p_del">-				printk(&quot;%sfirst error captured\n&quot;, newpfx);</span>
<span class="p_del">-			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_LAST)</span>
<span class="p_del">-				printk(&quot;%slast error captured\n&quot;, newpfx);</span>
<span class="p_del">-			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_PROPAGATED)</span>
<span class="p_del">-				printk(&quot;%spropagated error captured\n&quot;,</span>
<span class="p_del">-				       newpfx);</span>
<span class="p_del">-			if (err_info-&gt;flags &amp; CPER_ARM_INFO_FLAGS_OVERFLOW)</span>
<span class="p_del">-				printk(&quot;%soverflow occurred, error info is incomplete\n&quot;,</span>
<span class="p_del">-				       newpfx);</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		printk(&quot;%serror_type: %d, %s\n&quot;, newpfx, err_info-&gt;type,</span>
<span class="p_del">-			err_info-&gt;type &lt; ARRAY_SIZE(proc_error_type_strs) ?</span>
<span class="p_del">-			proc_error_type_strs[err_info-&gt;type] : &quot;unknown&quot;);</span>
<span class="p_del">-		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_ERR_INFO)</span>
<span class="p_del">-			printk(&quot;%serror_info: 0x%016llx\n&quot;, newpfx,</span>
<span class="p_del">-			       err_info-&gt;error_info);</span>
<span class="p_del">-		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_VIRT_ADDR)</span>
<span class="p_del">-			printk(&quot;%svirtual fault address: 0x%016llx\n&quot;,</span>
<span class="p_del">-				newpfx, err_info-&gt;virt_fault_addr);</span>
<span class="p_del">-		if (err_info-&gt;validation_bits &amp; CPER_ARM_INFO_VALID_PHYSICAL_ADDR)</span>
<span class="p_del">-			printk(&quot;%sphysical fault address: 0x%016llx\n&quot;,</span>
<span class="p_del">-				newpfx, err_info-&gt;physical_fault_addr);</span>
<span class="p_del">-		err_info += 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ctx_info = (struct cper_arm_ctx_info *)err_info;</span>
<span class="p_del">-	max_ctx_type = ARRAY_SIZE(arm_reg_ctx_strs) - 1;</span>
<span class="p_del">-	for (i = 0; i &lt; proc-&gt;context_info_num; i++) {</span>
<span class="p_del">-		int size = sizeof(*ctx_info) + ctx_info-&gt;size;</span>
<span class="p_del">-</span>
<span class="p_del">-		printk(&quot;%sContext info structure %d:\n&quot;, pfx, i);</span>
<span class="p_del">-		if (len &lt; size) {</span>
<span class="p_del">-			printk(&quot;%ssection length is too small\n&quot;, newpfx);</span>
<span class="p_del">-			printk(&quot;%sfirmware-generated error record is incorrect\n&quot;, pfx);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (ctx_info-&gt;type &gt; max_ctx_type) {</span>
<span class="p_del">-			printk(&quot;%sInvalid context type: %d (max: %d)\n&quot;,</span>
<span class="p_del">-				newpfx, ctx_info-&gt;type, max_ctx_type);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		printk(&quot;%sregister context type: %s\n&quot;, newpfx,</span>
<span class="p_del">-			arm_reg_ctx_strs[ctx_info-&gt;type]);</span>
<span class="p_del">-		print_hex_dump(newpfx, &quot;&quot;, DUMP_PREFIX_OFFSET, 16, 4,</span>
<span class="p_del">-				(ctx_info + 1), ctx_info-&gt;size, 0);</span>
<span class="p_del">-		len -= size;</span>
<span class="p_del">-		ctx_info = (struct cper_arm_ctx_info *)((long)ctx_info + size);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (len &gt; 0) {</span>
<span class="p_del">-		printk(&quot;%sVendor specific error info has %u bytes:\n&quot;, pfx,</span>
<span class="p_del">-		       len);</span>
<span class="p_del">-		print_hex_dump(newpfx, &quot;&quot;, DUMP_PREFIX_OFFSET, 16, 4, ctx_info,</span>
<span class="p_del">-				len, true);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static const char * const mem_err_type_strs[] = {
 	&quot;unknown&quot;,
 	&quot;no error&quot;,
<span class="p_header">diff --git a/drivers/firmware/efi/efi.c b/drivers/firmware/efi/efi.c</span>
<span class="p_header">index 557a47829d03..8ce70c2e73d5 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/efi.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/efi.c</span>
<span class="p_chunk">@@ -608,7 +608,7 @@</span> <span class="p_context"> static int __init efi_load_efivars(void)</span>
 		return 0;
 
 	pdev = platform_device_register_simple(&quot;efivars&quot;, 0, NULL, 0);
<span class="p_del">-	return IS_ERR(pdev) ? PTR_ERR(pdev) : 0;</span>
<span class="p_add">+	return PTR_ERR_OR_ZERO(pdev);</span>
 }
 device_initcall(efi_load_efivars);
 #endif
<span class="p_header">diff --git a/include/linux/cper.h b/include/linux/cper.h</span>
<span class="p_header">index 723e952fde0d..d14ef4e77c8a 100644</span>
<span class="p_header">--- a/include/linux/cper.h</span>
<span class="p_header">+++ b/include/linux/cper.h</span>
<span class="p_chunk">@@ -275,6 +275,50 @@</span> <span class="p_context"> enum {</span>
 #define CPER_ARM_INFO_FLAGS_PROPAGATED		BIT(2)
 #define CPER_ARM_INFO_FLAGS_OVERFLOW		BIT(3)
 
<span class="p_add">+#define CPER_ARM_CACHE_ERROR			0</span>
<span class="p_add">+#define CPER_ARM_TLB_ERROR			1</span>
<span class="p_add">+#define CPER_ARM_BUS_ERROR			2</span>
<span class="p_add">+#define CPER_ARM_VENDOR_ERROR			3</span>
<span class="p_add">+#define CPER_ARM_MAX_TYPE			CPER_ARM_VENDOR_ERROR</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_TRANSACTION_TYPE	BIT(0)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_OPERATION_TYPE	BIT(1)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_LEVEL		BIT(2)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_PROC_CONTEXT_CORRUPT	BIT(3)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_CORRECTED		BIT(4)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_PRECISE_PC		BIT(5)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_RESTARTABLE_PC	BIT(6)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_PARTICIPATION_TYPE	BIT(7)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_TIME_OUT		BIT(8)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_ADDRESS_SPACE	BIT(9)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_MEM_ATTRIBUTES	BIT(10)</span>
<span class="p_add">+#define CPER_ARM_ERR_VALID_ACCESS_MODE		BIT(11)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CPER_ARM_ERR_TRANSACTION_SHIFT		16</span>
<span class="p_add">+#define CPER_ARM_ERR_TRANSACTION_MASK		GENMASK(1,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_OPERATION_SHIFT		18</span>
<span class="p_add">+#define CPER_ARM_ERR_OPERATION_MASK		GENMASK(3,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_LEVEL_SHIFT		22</span>
<span class="p_add">+#define CPER_ARM_ERR_LEVEL_MASK			GENMASK(2,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_PC_CORRUPT_SHIFT		25</span>
<span class="p_add">+#define CPER_ARM_ERR_PC_CORRUPT_MASK		GENMASK(0,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_CORRECTED_SHIFT		26</span>
<span class="p_add">+#define CPER_ARM_ERR_CORRECTED_MASK		GENMASK(0,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_PRECISE_PC_SHIFT		27</span>
<span class="p_add">+#define CPER_ARM_ERR_PRECISE_PC_MASK		GENMASK(0,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_RESTARTABLE_PC_SHIFT	28</span>
<span class="p_add">+#define CPER_ARM_ERR_RESTARTABLE_PC_MASK	GENMASK(0,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_PARTICIPATION_TYPE_SHIFT	29</span>
<span class="p_add">+#define CPER_ARM_ERR_PARTICIPATION_TYPE_MASK	GENMASK(1,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_TIME_OUT_SHIFT		31</span>
<span class="p_add">+#define CPER_ARM_ERR_TIME_OUT_MASK		GENMASK(0,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_ADDRESS_SPACE_SHIFT	32</span>
<span class="p_add">+#define CPER_ARM_ERR_ADDRESS_SPACE_MASK		GENMASK(1,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_MEM_ATTRIBUTES_SHIFT	34</span>
<span class="p_add">+#define CPER_ARM_ERR_MEM_ATTRIBUTES_MASK	GENMASK(8,0)</span>
<span class="p_add">+#define CPER_ARM_ERR_ACCESS_MODE_SHIFT		43</span>
<span class="p_add">+#define CPER_ARM_ERR_ACCESS_MODE_MASK		GENMASK(0,0)</span>
<span class="p_add">+</span>
 /*
  * All tables and structs must be byte-packed to match CPER
  * specification, since the tables are provided by the system BIOS
<span class="p_chunk">@@ -494,6 +538,8 @@</span> <span class="p_context"> struct cper_sec_pcie {</span>
 /* Reset to default packing */
 #pragma pack()
 
<span class="p_add">+extern const char * const cper_proc_error_type_strs[4];</span>
<span class="p_add">+</span>
 u64 cper_next_record_id(void);
 const char *cper_severity_str(unsigned int);
 const char *cper_mem_err_type_str(unsigned int);
<span class="p_chunk">@@ -503,5 +549,7 @@</span> <span class="p_context"> void cper_mem_err_pack(const struct cper_sec_mem_err *,</span>
 		       struct cper_mem_err_compact *);
 const char *cper_mem_err_unpack(struct trace_seq *,
 				struct cper_mem_err_compact *);
<span class="p_add">+void cper_print_proc_arm(const char *pfx,</span>
<span class="p_add">+			 const struct cper_sec_proc_arm *proc);</span>
 
 #endif

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



