
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.2.6 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.2.6</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 10, 2015, 1:28 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20151110012848.GB7525@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7587261/mbox/"
   >mbox</a>
|
   <a href="/patch/7587261/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7587261/">/patch/7587261/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 404539F2F7
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 10 Nov 2015 01:29:19 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 26005206F3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 10 Nov 2015 01:29:13 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 877F4205DF
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 10 Nov 2015 01:29:06 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752468AbbKJB2y (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 9 Nov 2015 20:28:54 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:38212 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752433AbbKJB2t (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 9 Nov 2015 20:28:49 -0500
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 962018FE;
	Tue, 10 Nov 2015 01:28:48 +0000 (UTC)
Date: Mon, 9 Nov 2015 17:28:48 -0800
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.2.6
Message-ID: &lt;20151110012848.GB7525@kroah.com&gt;
References: &lt;20151110012841.GA7525@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20151110012841.GA7525@kroah.com&gt;
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.2 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Nov. 10, 2015, 1:28 a.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 96076dcad18e..9ef37399b4e8 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 5</span>
<span class="p_add">+SUBLEVEL = 6</span>
 EXTRAVERSION =
 NAME = Hurr durr I&#39;ma sheep
 
<span class="p_header">diff --git a/arch/arm/boot/dts/am57xx-beagle-x15.dts b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">index a63bf78191ea..03385fabf839 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am57xx-beagle-x15.dts</span>
<span class="p_chunk">@@ -415,11 +415,12 @@</span> <span class="p_context"></span>
 				/* SMPS9 unused */
 
 				ldo1_reg: ldo1 {
<span class="p_del">-					/* VDD_SD  */</span>
<span class="p_add">+					/* VDD_SD / VDDSHV8  */</span>
 					regulator-name = &quot;ldo1&quot;;
 					regulator-min-microvolt = &lt;1800000&gt;;
 					regulator-max-microvolt = &lt;3300000&gt;;
 					regulator-boot-on;
<span class="p_add">+					regulator-always-on;</span>
 				};
 
 				ldo2_reg: ldo2 {
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-385-db-ap.dts b/arch/arm/boot/dts/armada-385-db-ap.dts</span>
<span class="p_header">index 89f5a95954ed..4047621b137e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-385-db-ap.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-385-db-ap.dts</span>
<span class="p_chunk">@@ -46,7 +46,7 @@</span> <span class="p_context"></span>
 
 / {
 	model = &quot;Marvell Armada 385 Access Point Development Board&quot;;
<span class="p_del">-	compatible = &quot;marvell,a385-db-ap&quot;, &quot;marvell,armada385&quot;, &quot;marvell,armada38x&quot;;</span>
<span class="p_add">+	compatible = &quot;marvell,a385-db-ap&quot;, &quot;marvell,armada385&quot;, &quot;marvell,armada380&quot;;</span>
 
 	chosen {
 		stdout-path = &quot;serial1:115200n8&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/berlin2q.dtsi b/arch/arm/boot/dts/berlin2q.dtsi</span>
<span class="p_header">index 63a48490e2f9..d4dbd28d348c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/berlin2q.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/berlin2q.dtsi</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"></span>
 		};
 
 		usb_phy2: phy@a2f400 {
<span class="p_del">-			compatible = &quot;marvell,berlin2-usb-phy&quot;;</span>
<span class="p_add">+			compatible = &quot;marvell,berlin2cd-usb-phy&quot;;</span>
 			reg = &lt;0xa2f400 0x128&gt;;
 			#phy-cells = &lt;0&gt;;
 			resets = &lt;&amp;chip_rst 0x104 14&gt;;
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"></span>
 		};
 
 		usb_phy0: phy@b74000 {
<span class="p_del">-			compatible = &quot;marvell,berlin2-usb-phy&quot;;</span>
<span class="p_add">+			compatible = &quot;marvell,berlin2cd-usb-phy&quot;;</span>
 			reg = &lt;0xb74000 0x128&gt;;
 			#phy-cells = &lt;0&gt;;
 			resets = &lt;&amp;chip_rst 0x104 12&gt;;
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"></span>
 		};
 
 		usb_phy1: phy@b78000 {
<span class="p_del">-			compatible = &quot;marvell,berlin2-usb-phy&quot;;</span>
<span class="p_add">+			compatible = &quot;marvell,berlin2cd-usb-phy&quot;;</span>
 			reg = &lt;0xb78000 0x128&gt;;
 			#phy-cells = &lt;0&gt;;
 			resets = &lt;&amp;chip_rst 0x104 13&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos5420-peach-pit.dts b/arch/arm/boot/dts/exynos5420-peach-pit.dts</span>
<span class="p_header">index 8f4d76c5e11c..1b95da79293c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos5420-peach-pit.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos5420-peach-pit.dts</span>
<span class="p_chunk">@@ -915,6 +915,11 @@</span> <span class="p_context"></span>
 	};
 };
 
<span class="p_add">+&amp;pmu_system_controller {</span>
<span class="p_add">+	assigned-clocks = &lt;&amp;pmu_system_controller 0&gt;;</span>
<span class="p_add">+	assigned-clock-parents = &lt;&amp;clock CLK_FIN_PLL&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 &amp;rtc {
 	status = &quot;okay&quot;;
 	clocks = &lt;&amp;clock CLK_RTC&gt;, &lt;&amp;max77802 MAX77802_CLK_32K_AP&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos5800-peach-pi.dts b/arch/arm/boot/dts/exynos5800-peach-pi.dts</span>
<span class="p_header">index 7d5b386b5ae6..8f40c7e549bd 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos5800-peach-pi.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos5800-peach-pi.dts</span>
<span class="p_chunk">@@ -878,6 +878,11 @@</span> <span class="p_context"></span>
 	};
 };
 
<span class="p_add">+&amp;pmu_system_controller {</span>
<span class="p_add">+	assigned-clocks = &lt;&amp;pmu_system_controller 0&gt;;</span>
<span class="p_add">+	assigned-clock-parents = &lt;&amp;clock CLK_FIN_PLL&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 &amp;rtc {
 	status = &quot;okay&quot;;
 	clocks = &lt;&amp;clock CLK_RTC&gt;, &lt;&amp;max77802 MAX77802_CLK_32K_AP&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx7d.dtsi b/arch/arm/boot/dts/imx7d.dtsi</span>
<span class="p_header">index c42cf8db0451..9accbae15374 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx7d.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx7d.dtsi</span>
<span class="p_chunk">@@ -340,10 +340,10 @@</span> <span class="p_context"></span>
 				status = &quot;disabled&quot;;
 			};
 
<span class="p_del">-			uart2: serial@30870000 {</span>
<span class="p_add">+			uart2: serial@30890000 {</span>
 				compatible = &quot;fsl,imx7d-uart&quot;,
 					     &quot;fsl,imx6q-uart&quot;;
<span class="p_del">-				reg = &lt;0x30870000 0x10000&gt;;</span>
<span class="p_add">+				reg = &lt;0x30890000 0x10000&gt;;</span>
 				interrupts = &lt;GIC_SPI 27 IRQ_TYPE_LEVEL_HIGH&gt;;
 				clocks = &lt;&amp;clks IMX7D_UART2_ROOT_CLK&gt;,
 					&lt;&amp;clks IMX7D_UART2_ROOT_CLK&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-hrefv60plus.dtsi b/arch/arm/boot/dts/ste-hrefv60plus.dtsi</span>
<span class="p_header">index 810cda743b6d..9c2387b34d0c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-hrefv60plus.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-hrefv60plus.dtsi</span>
<span class="p_chunk">@@ -56,7 +56,7 @@</span> <span class="p_context"></span>
 					/* VMMCI level-shifter enable */
 					default_hrefv60_cfg2 {
 						pins = &quot;GPIO169_D22&quot;;
<span class="p_del">-						ste,config = &lt;&amp;gpio_out_lo&gt;;</span>
<span class="p_add">+						ste,config = &lt;&amp;gpio_out_hi&gt;;</span>
 					};
 					/* VMMCI level-shifter voltage select */
 					default_hrefv60_cfg3 {
<span class="p_header">diff --git a/arch/arm/kvm/Kconfig b/arch/arm/kvm/Kconfig</span>
<span class="p_header">index bfb915d05665..dd5fc1e36384 100644</span>
<span class="p_header">--- a/arch/arm/kvm/Kconfig</span>
<span class="p_header">+++ b/arch/arm/kvm/Kconfig</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> config KVM</span>
 	depends on MMU &amp;&amp; OF
 	select PREEMPT_NOTIFIERS
 	select ANON_INODES
<span class="p_add">+	select ARM_GIC</span>
 	select HAVE_KVM_CPU_RELAX_INTERCEPT
 	select HAVE_KVM_ARCH_TLB_FLUSH_ALL
 	select KVM_MMIO
<span class="p_header">diff --git a/arch/arm/mach-exynos/pm_domains.c b/arch/arm/mach-exynos/pm_domains.c</span>
<span class="p_header">index 4a87e86dec45..7c21760f590f 100644</span>
<span class="p_header">--- a/arch/arm/mach-exynos/pm_domains.c</span>
<span class="p_header">+++ b/arch/arm/mach-exynos/pm_domains.c</span>
<span class="p_chunk">@@ -200,15 +200,15 @@</span> <span class="p_context"> no_clk:</span>
 		args.args_count = 0;
 		child_domain = of_genpd_get_from_provider(&amp;args);
 		if (IS_ERR(child_domain))
<span class="p_del">-			goto next_pd;</span>
<span class="p_add">+			continue;</span>
 
 		if (of_parse_phandle_with_args(np, &quot;power-domains&quot;,
 					 &quot;#power-domain-cells&quot;, 0, &amp;args) != 0)
<span class="p_del">-			goto next_pd;</span>
<span class="p_add">+			continue;</span>
 
 		parent_domain = of_genpd_get_from_provider(&amp;args);
 		if (IS_ERR(parent_domain))
<span class="p_del">-			goto next_pd;</span>
<span class="p_add">+			continue;</span>
 
 		if (pm_genpd_add_subdomain(parent_domain, child_domain))
 			pr_warn(&quot;%s failed to add subdomain: %s\n&quot;,
<span class="p_chunk">@@ -216,8 +216,6 @@</span> <span class="p_context"> no_clk:</span>
 		else
 			pr_info(&quot;%s has as child subdomain: %s.\n&quot;,
 				parent_domain-&gt;name, child_domain-&gt;name);
<span class="p_del">-next_pd:</span>
<span class="p_del">-		of_node_put(np);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/arch/arm/plat-orion/common.c b/arch/arm/plat-orion/common.c</span>
<span class="p_header">index 2235081a04ee..8861c367d061 100644</span>
<span class="p_header">--- a/arch/arm/plat-orion/common.c</span>
<span class="p_header">+++ b/arch/arm/plat-orion/common.c</span>
<span class="p_chunk">@@ -495,7 +495,7 @@</span> <span class="p_context"> void __init orion_ge00_switch_init(struct dsa_platform_data *d, int irq)</span>
 
 	d-&gt;netdev = &amp;orion_ge00.dev;
 	for (i = 0; i &lt; d-&gt;nr_chips; i++)
<span class="p_del">-		d-&gt;chip[i].host_dev = &amp;orion_ge00_shared.dev;</span>
<span class="p_add">+		d-&gt;chip[i].host_dev = &amp;orion_ge_mvmdio.dev;</span>
 	orion_switch_device.dev.platform_data = d;
 
 	platform_device_register(&amp;orion_switch_device);
<span class="p_header">diff --git a/arch/arm/vdso/vdsomunge.c b/arch/arm/vdso/vdsomunge.c</span>
<span class="p_header">index aedec81d1198..f6455273b2f8 100644</span>
<span class="p_header">--- a/arch/arm/vdso/vdsomunge.c</span>
<span class="p_header">+++ b/arch/arm/vdso/vdsomunge.c</span>
<span class="p_chunk">@@ -45,7 +45,6 @@</span> <span class="p_context"></span>
  * it does.
  */
 
<span class="p_del">-#include &lt;byteswap.h&gt;</span>
 #include &lt;elf.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;fcntl.h&gt;
<span class="p_chunk">@@ -59,6 +58,16 @@</span> <span class="p_context"></span>
 #include &lt;sys/types.h&gt;
 #include &lt;unistd.h&gt;
 
<span class="p_add">+#define swab16(x) \</span>
<span class="p_add">+	((((x) &amp; 0x00ff) &lt;&lt; 8) | \</span>
<span class="p_add">+	 (((x) &amp; 0xff00) &gt;&gt; 8))</span>
<span class="p_add">+</span>
<span class="p_add">+#define swab32(x) \</span>
<span class="p_add">+	((((x) &amp; 0x000000ff) &lt;&lt; 24) | \</span>
<span class="p_add">+	 (((x) &amp; 0x0000ff00) &lt;&lt;  8) | \</span>
<span class="p_add">+	 (((x) &amp; 0x00ff0000) &gt;&gt;  8) | \</span>
<span class="p_add">+	 (((x) &amp; 0xff000000) &gt;&gt; 24))</span>
<span class="p_add">+</span>
 #if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
 #define HOST_ORDER ELFDATA2LSB
 #elif __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
<span class="p_chunk">@@ -104,17 +113,17 @@</span> <span class="p_context"> static void cleanup(void)</span>
 
 static Elf32_Word read_elf_word(Elf32_Word word, bool swap)
 {
<span class="p_del">-	return swap ? bswap_32(word) : word;</span>
<span class="p_add">+	return swap ? swab32(word) : word;</span>
 }
 
 static Elf32_Half read_elf_half(Elf32_Half half, bool swap)
 {
<span class="p_del">-	return swap ? bswap_16(half) : half;</span>
<span class="p_add">+	return swap ? swab16(half) : half;</span>
 }
 
 static void write_elf_word(Elf32_Word val, Elf32_Word *dst, bool swap)
 {
<span class="p_del">-	*dst = swap ? bswap_32(val) : val;</span>
<span class="p_add">+	*dst = swap ? swab32(val) : val;</span>
 }
 
 int main(int argc, char **argv)
<span class="p_header">diff --git a/arch/arm64/kernel/armv8_deprecated.c b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">index 7922c2e710ca..7ac3920b1356 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/armv8_deprecated.c</span>
<span class="p_chunk">@@ -279,22 +279,24 @@</span> <span class="p_context"> static void register_insn_emulation_sysctl(struct ctl_table *table)</span>
  */
 #define __user_swpX_asm(data, addr, res, temp, B)		\
 	__asm__ __volatile__(					\
<span class="p_del">-	&quot;	mov		%w2, %w1\n&quot;			\</span>
<span class="p_del">-	&quot;0:	ldxr&quot;B&quot;		%w1, [%3]\n&quot;			\</span>
<span class="p_del">-	&quot;1:	stxr&quot;B&quot;		%w0, %w2, [%3]\n&quot;		\</span>
<span class="p_add">+	&quot;0:	ldxr&quot;B&quot;		%w2, [%3]\n&quot;			\</span>
<span class="p_add">+	&quot;1:	stxr&quot;B&quot;		%w0, %w1, [%3]\n&quot;		\</span>
 	&quot;	cbz		%w0, 2f\n&quot;			\
 	&quot;	mov		%w0, %w4\n&quot;			\
<span class="p_add">+	&quot;	b		3f\n&quot;				\</span>
 	&quot;2:\n&quot;							\
<span class="p_add">+	&quot;	mov		%w1, %w2\n&quot;			\</span>
<span class="p_add">+	&quot;3:\n&quot;							\</span>
 	&quot;	.pushsection	 .fixup,\&quot;ax\&quot;\n&quot;		\
 	&quot;	.align		2\n&quot;				\
<span class="p_del">-	&quot;3:	mov		%w0, %w5\n&quot;			\</span>
<span class="p_del">-	&quot;	b		2b\n&quot;				\</span>
<span class="p_add">+	&quot;4:	mov		%w0, %w5\n&quot;			\</span>
<span class="p_add">+	&quot;	b		3b\n&quot;				\</span>
 	&quot;	.popsection&quot;					\
 	&quot;	.pushsection	 __ex_table,\&quot;a\&quot;\n&quot;		\
 	&quot;	.align		3\n&quot;				\
<span class="p_del">-	&quot;	.quad		0b, 3b\n&quot;			\</span>
<span class="p_del">-	&quot;	.quad		1b, 3b\n&quot;			\</span>
<span class="p_del">-	&quot;	.popsection&quot;					\</span>
<span class="p_add">+	&quot;	.quad		0b, 4b\n&quot;			\</span>
<span class="p_add">+	&quot;	.quad		1b, 4b\n&quot;			\</span>
<span class="p_add">+	&quot;	.popsection\n&quot;					\</span>
 	: &quot;=&amp;r&quot; (res), &quot;+r&quot; (data), &quot;=&amp;r&quot; (temp)		\
 	: &quot;r&quot; (addr), &quot;i&quot; (-EAGAIN), &quot;i&quot; (-EFAULT)		\
 	: &quot;memory&quot;)
<span class="p_header">diff --git a/arch/arm64/kernel/stacktrace.c b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">index 407991bf79f5..ccb6078ed9f2 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/stacktrace.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -48,11 +48,7 @@</span> <span class="p_context"> int notrace unwind_frame(struct stackframe *frame)</span>
 
 	frame-&gt;sp = fp + 0x10;
 	frame-&gt;fp = *(unsigned long *)(fp);
<span class="p_del">-	/*</span>
<span class="p_del">-	 * -4 here because we care about the PC at time of bl,</span>
<span class="p_del">-	 * not where the return will go.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	frame-&gt;pc = *(unsigned long *)(fp + 8) - 4;</span>
<span class="p_add">+	frame-&gt;pc = *(unsigned long *)(fp + 8);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/suspend.c b/arch/arm64/kernel/suspend.c</span>
<span class="p_header">index 8297d502217e..44ca4143b013 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/suspend.c</span>
<span class="p_chunk">@@ -80,17 +80,21 @@</span> <span class="p_context"> int cpu_suspend(unsigned long arg, int (*fn)(unsigned long))</span>
 	if (ret == 0) {
 		/*
 		 * We are resuming from reset with TTBR0_EL1 set to the
<span class="p_del">-		 * idmap to enable the MMU; restore the active_mm mappings in</span>
<span class="p_del">-		 * TTBR0_EL1 unless the active_mm == &amp;init_mm, in which case</span>
<span class="p_del">-		 * the thread entered cpu_suspend with TTBR0_EL1 set to</span>
<span class="p_del">-		 * reserved TTBR0 page tables and should be restored as such.</span>
<span class="p_add">+		 * idmap to enable the MMU; set the TTBR0 to the reserved</span>
<span class="p_add">+		 * page tables to prevent speculative TLB allocations, flush</span>
<span class="p_add">+		 * the local tlb and set the default tcr_el1.t0sz so that</span>
<span class="p_add">+		 * the TTBR0 address space set-up is properly restored.</span>
<span class="p_add">+		 * If the current active_mm != &amp;init_mm we entered cpu_suspend</span>
<span class="p_add">+		 * with mappings in TTBR0 that must be restored, so we switch</span>
<span class="p_add">+		 * them back to complete the address space configuration</span>
<span class="p_add">+		 * restoration before returning.</span>
 		 */
<span class="p_del">-		if (mm == &amp;init_mm)</span>
<span class="p_del">-			cpu_set_reserved_ttbr0();</span>
<span class="p_del">-		else</span>
<span class="p_del">-			cpu_switch_mm(mm-&gt;pgd, mm);</span>
<span class="p_del">-</span>
<span class="p_add">+		cpu_set_reserved_ttbr0();</span>
 		flush_tlb_all();
<span class="p_add">+		cpu_set_default_tcr_t0sz();</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mm != &amp;init_mm)</span>
<span class="p_add">+			cpu_switch_mm(mm-&gt;pgd, mm);</span>
 
 		/*
 		 * Restore per-cpu offset before any kernel
<span class="p_header">diff --git a/arch/powerpc/kernel/rtas.c b/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">index caffb10e7aa3..5607693f35cf 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/rtas.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/rtas.c</span>
<span class="p_chunk">@@ -1041,6 +1041,9 @@</span> <span class="p_context"> asmlinkage int ppc_rtas(struct rtas_args __user *uargs)</span>
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
<span class="p_add">+	if (!rtas.entry)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (copy_from_user(&amp;args, uargs, 3 * sizeof(u32)) != 0)
 		return -EFAULT;
 
<span class="p_header">diff --git a/arch/um/kernel/trap.c b/arch/um/kernel/trap.c</span>
<span class="p_header">index 557232f758b6..5610b185d1e9 100644</span>
<span class="p_header">--- a/arch/um/kernel/trap.c</span>
<span class="p_header">+++ b/arch/um/kernel/trap.c</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> unsigned long segv(struct faultinfo fi, unsigned long ip, int is_user,</span>
 		show_regs(container_of(regs, struct pt_regs, regs));
 		panic(&quot;Segfault with no mm&quot;);
 	}
<span class="p_del">-	else if (!is_user &amp;&amp; address &lt; TASK_SIZE) {</span>
<span class="p_add">+	else if (!is_user &amp;&amp; address &gt; PAGE_SIZE &amp;&amp; address &lt; TASK_SIZE) {</span>
 		show_regs(container_of(regs, struct pt_regs, regs));
 		panic(&quot;Kernel tried to access user memory at addr 0x%lx, ip 0x%lx&quot;,
 		       address, ip);
<span class="p_header">diff --git a/arch/x86/boot/compressed/eboot.c b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">index 7d69afd8b6fa..16edc0f169fa 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/eboot.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/eboot.c</span>
<span class="p_chunk">@@ -667,6 +667,7 @@</span> <span class="p_context"> setup_gop32(struct screen_info *si, efi_guid_t *proto,</span>
 		bool conout_found = false;
 		void *dummy = NULL;
 		u32 h = handles[i];
<span class="p_add">+		u32 current_fb_base;</span>
 
 		status = efi_call_early(handle_protocol, h,
 					proto, (void **)&amp;gop32);
<span class="p_chunk">@@ -678,7 +679,7 @@</span> <span class="p_context"> setup_gop32(struct screen_info *si, efi_guid_t *proto,</span>
 		if (status == EFI_SUCCESS)
 			conout_found = true;
 
<span class="p_del">-		status = __gop_query32(gop32, &amp;info, &amp;size, &amp;fb_base);</span>
<span class="p_add">+		status = __gop_query32(gop32, &amp;info, &amp;size, &amp;current_fb_base);</span>
 		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {
 			/*
 			 * Systems that use the UEFI Console Splitter may
<span class="p_chunk">@@ -692,6 +693,7 @@</span> <span class="p_context"> setup_gop32(struct screen_info *si, efi_guid_t *proto,</span>
 			pixel_format = info-&gt;pixel_format;
 			pixel_info = info-&gt;pixel_information;
 			pixels_per_scan_line = info-&gt;pixels_per_scan_line;
<span class="p_add">+			fb_base = current_fb_base;</span>
 
 			/*
 			 * Once we&#39;ve found a GOP supporting ConOut,
<span class="p_chunk">@@ -770,6 +772,7 @@</span> <span class="p_context"> setup_gop64(struct screen_info *si, efi_guid_t *proto,</span>
 		bool conout_found = false;
 		void *dummy = NULL;
 		u64 h = handles[i];
<span class="p_add">+		u32 current_fb_base;</span>
 
 		status = efi_call_early(handle_protocol, h,
 					proto, (void **)&amp;gop64);
<span class="p_chunk">@@ -781,7 +784,7 @@</span> <span class="p_context"> setup_gop64(struct screen_info *si, efi_guid_t *proto,</span>
 		if (status == EFI_SUCCESS)
 			conout_found = true;
 
<span class="p_del">-		status = __gop_query64(gop64, &amp;info, &amp;size, &amp;fb_base);</span>
<span class="p_add">+		status = __gop_query64(gop64, &amp;info, &amp;size, &amp;current_fb_base);</span>
 		if (status == EFI_SUCCESS &amp;&amp; (!first_gop || conout_found)) {
 			/*
 			 * Systems that use the UEFI Console Splitter may
<span class="p_chunk">@@ -795,6 +798,7 @@</span> <span class="p_context"> setup_gop64(struct screen_info *si, efi_guid_t *proto,</span>
 			pixel_format = info-&gt;pixel_format;
 			pixel_info = info-&gt;pixel_information;
 			pixels_per_scan_line = info-&gt;pixels_per_scan_line;
<span class="p_add">+			fb_base = current_fb_base;</span>
 
 			/*
 			 * Once we&#39;ve found a GOP supporting ConOut,
<span class="p_header">diff --git a/arch/x86/kernel/apic/io_apic.c b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">index 5880b482d83c..11b46d91f4e5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/io_apic.c</span>
<span class="p_chunk">@@ -2547,7 +2547,9 @@</span> <span class="p_context"> void __init setup_ioapic_dest(void)</span>
 			mask = apic-&gt;target_cpus();
 
 		chip = irq_data_get_irq_chip(idata);
<span class="p_del">-		chip-&gt;irq_set_affinity(idata, mask, false);</span>
<span class="p_add">+		/* Might be lapic_chip for irq 0 */</span>
<span class="p_add">+		if (chip-&gt;irq_set_affinity)</span>
<span class="p_add">+			chip-&gt;irq_set_affinity(idata, mask, false);</span>
 	}
 }
 #endif
<span class="p_header">diff --git a/arch/x86/xen/enlighten.c b/arch/x86/xen/enlighten.c</span>
<span class="p_header">index 777ad2f03160..3cebc65221a2 100644</span>
<span class="p_header">--- a/arch/x86/xen/enlighten.c</span>
<span class="p_header">+++ b/arch/x86/xen/enlighten.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/memblock.h&gt;
 #include &lt;linux/edd.h&gt;
 
<span class="p_del">-#ifdef CONFIG_KEXEC_CORE</span>
<span class="p_add">+#ifdef CONFIG_KEXEC</span>
 #include &lt;linux/kexec.h&gt;
 #endif
 
<span class="p_chunk">@@ -1804,7 +1804,7 @@</span> <span class="p_context"> static struct notifier_block xen_hvm_cpu_notifier = {</span>
 	.notifier_call	= xen_hvm_cpu_notify,
 };
 
<span class="p_del">-#ifdef CONFIG_KEXEC_CORE</span>
<span class="p_add">+#ifdef CONFIG_KEXEC</span>
 static void xen_hvm_shutdown(void)
 {
 	native_machine_shutdown();
<span class="p_chunk">@@ -1838,7 +1838,7 @@</span> <span class="p_context"> static void __init xen_hvm_guest_init(void)</span>
 	x86_init.irqs.intr_init = xen_init_IRQ;
 	xen_hvm_init_time_ops();
 	xen_hvm_init_mmu_ops();
<span class="p_del">-#ifdef CONFIG_KEXEC_CORE</span>
<span class="p_add">+#ifdef CONFIG_KEXEC</span>
 	machine_ops.shutdown = xen_hvm_shutdown;
 	machine_ops.crash_shutdown = xen_hvm_crash_shutdown;
 #endif
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 627ed0c593fb..1955ed3a1fa9 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -578,7 +578,7 @@</span> <span class="p_context"> void blk_cleanup_queue(struct request_queue *q)</span>
 		q-&gt;queue_lock = &amp;q-&gt;__queue_lock;
 	spin_unlock_irq(lock);
 
<span class="p_del">-	bdi_destroy(&amp;q-&gt;backing_dev_info);</span>
<span class="p_add">+	bdi_unregister(&amp;q-&gt;backing_dev_info);</span>
 
 	/* @q is and will stay empty, shutdown and put */
 	blk_put_queue(q);
<span class="p_header">diff --git a/block/blk-mq-tag.c b/block/blk-mq-tag.c</span>
<span class="p_header">index 9115c6d59948..273519894951 100644</span>
<span class="p_header">--- a/block/blk-mq-tag.c</span>
<span class="p_header">+++ b/block/blk-mq-tag.c</span>
<span class="p_chunk">@@ -628,6 +628,7 @@</span> <span class="p_context"> void blk_mq_free_tags(struct blk_mq_tags *tags)</span>
 {
 	bt_free(&amp;tags-&gt;bitmap_tags);
 	bt_free(&amp;tags-&gt;breserved_tags);
<span class="p_add">+	free_cpumask_var(tags-&gt;cpumask);</span>
 	kfree(tags);
 }
 
<span class="p_header">diff --git a/block/blk-mq.c b/block/blk-mq.c</span>
<span class="p_header">index c69902695136..4d6ff5259a61 100644</span>
<span class="p_header">--- a/block/blk-mq.c</span>
<span class="p_header">+++ b/block/blk-mq.c</span>
<span class="p_chunk">@@ -2263,10 +2263,8 @@</span> <span class="p_context"> void blk_mq_free_tag_set(struct blk_mq_tag_set *set)</span>
 	int i;
 
 	for (i = 0; i &lt; set-&gt;nr_hw_queues; i++) {
<span class="p_del">-		if (set-&gt;tags[i]) {</span>
<span class="p_add">+		if (set-&gt;tags[i])</span>
 			blk_mq_free_rq_map(set, set-&gt;tags[i], i);
<span class="p_del">-			free_cpumask_var(set-&gt;tags[i]-&gt;cpumask);</span>
<span class="p_del">-		}</span>
 	}
 
 	kfree(set-&gt;tags);
<span class="p_header">diff --git a/block/blk-sysfs.c b/block/blk-sysfs.c</span>
<span class="p_header">index 6264b382d4d1..145ddb6c6d31 100644</span>
<span class="p_header">--- a/block/blk-sysfs.c</span>
<span class="p_header">+++ b/block/blk-sysfs.c</span>
<span class="p_chunk">@@ -502,6 +502,7 @@</span> <span class="p_context"> static void blk_release_queue(struct kobject *kobj)</span>
 	struct request_queue *q =
 		container_of(kobj, struct request_queue, kobj);
 
<span class="p_add">+	bdi_exit(&amp;q-&gt;backing_dev_info);</span>
 	blkcg_exit_queue(q);
 
 	if (q-&gt;elevator) {
<span class="p_header">diff --git a/crypto/ablkcipher.c b/crypto/ablkcipher.c</span>
<span class="p_header">index b788f169cc98..b4ffc5be1a93 100644</span>
<span class="p_header">--- a/crypto/ablkcipher.c</span>
<span class="p_header">+++ b/crypto/ablkcipher.c</span>
<span class="p_chunk">@@ -706,7 +706,7 @@</span> <span class="p_context"> struct crypto_ablkcipher *crypto_alloc_ablkcipher(const char *alg_name,</span>
 err:
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_header">diff --git a/crypto/algapi.c b/crypto/algapi.c</span>
<span class="p_header">index 3c079b7f23f6..b603b34ce8a8 100644</span>
<span class="p_header">--- a/crypto/algapi.c</span>
<span class="p_header">+++ b/crypto/algapi.c</span>
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> static void crypto_wait_for_test(struct crypto_larval *larval)</span>
 		crypto_alg_tested(larval-&gt;alg.cra_driver_name, 0);
 	}
 
<span class="p_del">-	err = wait_for_completion_interruptible(&amp;larval-&gt;completion);</span>
<span class="p_add">+	err = wait_for_completion_killable(&amp;larval-&gt;completion);</span>
 	WARN_ON(err);
 
 out:
<span class="p_header">diff --git a/crypto/api.c b/crypto/api.c</span>
<span class="p_header">index afe4610afc4b..bbc147cb5dec 100644</span>
<span class="p_header">--- a/crypto/api.c</span>
<span class="p_header">+++ b/crypto/api.c</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> static struct crypto_alg *crypto_larval_wait(struct crypto_alg *alg)</span>
 	struct crypto_larval *larval = (void *)alg;
 	long timeout;
 
<span class="p_del">-	timeout = wait_for_completion_interruptible_timeout(</span>
<span class="p_add">+	timeout = wait_for_completion_killable_timeout(</span>
 		&amp;larval-&gt;completion, 60 * HZ);
 
 	alg = larval-&gt;adult;
<span class="p_chunk">@@ -445,7 +445,7 @@</span> <span class="p_context"> struct crypto_tfm *crypto_alloc_base(const char *alg_name, u32 type, u32 mask)</span>
 err:
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> void *crypto_alloc_tfm(const char *alg_name,</span>
 err:
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_header">diff --git a/crypto/crypto_user.c b/crypto/crypto_user.c</span>
<span class="p_header">index 08ea2867fc8a..d59fb4eeed2b 100644</span>
<span class="p_header">--- a/crypto/crypto_user.c</span>
<span class="p_header">+++ b/crypto/crypto_user.c</span>
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> static struct crypto_alg *crypto_user_skcipher_alg(const char *name, u32 type,</span>
 		err = PTR_ERR(alg);
 		if (err != -EAGAIN)
 			break;
<span class="p_del">-		if (signal_pending(current)) {</span>
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
 			err = -EINTR;
 			break;
 		}
<span class="p_header">diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c</span>
<span class="p_header">index 7920c2741b47..cf91c114ed9f 100644</span>
<span class="p_header">--- a/drivers/block/nvme-core.c</span>
<span class="p_header">+++ b/drivers/block/nvme-core.c</span>
<span class="p_chunk">@@ -597,6 +597,7 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 	struct nvme_iod *iod = ctx;
 	struct request *req = iod_get_private(iod);
 	struct nvme_cmd_info *cmd_rq = blk_mq_rq_to_pdu(req);
<span class="p_add">+	bool requeue = false;</span>
 
 	u16 status = le16_to_cpup(&amp;cqe-&gt;status) &gt;&gt; 1;
 
<span class="p_chunk">@@ -605,12 +606,13 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 		    &amp;&amp; (jiffies - req-&gt;start_time) &lt; req-&gt;timeout) {
 			unsigned long flags;
 
<span class="p_add">+			requeue = true;</span>
 			blk_mq_requeue_request(req);
 			spin_lock_irqsave(req-&gt;q-&gt;queue_lock, flags);
 			if (!blk_queue_stopped(req-&gt;q))
 				blk_mq_kick_requeue_list(req-&gt;q);
 			spin_unlock_irqrestore(req-&gt;q-&gt;queue_lock, flags);
<span class="p_del">-			return;</span>
<span class="p_add">+			goto release_iod;</span>
 		}
 		if (req-&gt;cmd_type == REQ_TYPE_DRV_PRIV) {
 			if (cmd_rq-&gt;ctx == CMD_CTX_CANCELLED)
<span class="p_chunk">@@ -631,7 +633,7 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 		dev_warn(nvmeq-&gt;dev-&gt;dev,
 			&quot;completing aborted command with status:%04x\n&quot;,
 			status);
<span class="p_del">-</span>
<span class="p_add">+ release_iod:</span>
 	if (iod-&gt;nents) {
 		dma_unmap_sg(nvmeq-&gt;dev-&gt;dev, iod-&gt;sg, iod-&gt;nents,
 			rq_data_dir(req) ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
<span class="p_chunk">@@ -644,7 +646,8 @@</span> <span class="p_context"> static void req_completion(struct nvme_queue *nvmeq, void *ctx,</span>
 	}
 	nvme_free_iod(nvmeq-&gt;dev, iod);
 
<span class="p_del">-	blk_mq_complete_request(req);</span>
<span class="p_add">+	if (likely(!requeue))</span>
<span class="p_add">+		blk_mq_complete_request(req);</span>
 }
 
 /* length is in bytes.  gfp flags indicates whether we may sleep. */
<span class="p_chunk">@@ -1764,7 +1767,7 @@</span> <span class="p_context"> static int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio)</span>
 
 	length = (io.nblocks + 1) &lt;&lt; ns-&gt;lba_shift;
 	meta_len = (io.nblocks + 1) * ns-&gt;ms;
<span class="p_del">-	metadata = (void __user *)(unsigned long)io.metadata;</span>
<span class="p_add">+	metadata = (void __user *)(uintptr_t)io.metadata;</span>
 	write = io.opcode &amp; 1;
 
 	if (ns-&gt;ext) {
<span class="p_chunk">@@ -1804,7 +1807,7 @@</span> <span class="p_context"> static int nvme_submit_io(struct nvme_ns *ns, struct nvme_user_io __user *uio)</span>
 	c.rw.metadata = cpu_to_le64(meta_dma);
 
 	status = __nvme_submit_sync_cmd(ns-&gt;queue, &amp;c, NULL,
<span class="p_del">-			(void __user *)io.addr, length, NULL, 0);</span>
<span class="p_add">+			(void __user *)(uintptr_t)io.addr, length, NULL, 0);</span>
  unmap:
 	if (meta) {
 		if (status == NVME_SC_SUCCESS &amp;&amp; !write) {
<span class="p_chunk">@@ -1846,7 +1849,7 @@</span> <span class="p_context"> static int nvme_user_cmd(struct nvme_dev *dev, struct nvme_ns *ns,</span>
 		timeout = msecs_to_jiffies(cmd.timeout_ms);
 
 	status = __nvme_submit_sync_cmd(ns ? ns-&gt;queue : dev-&gt;admin_q, &amp;c,
<span class="p_del">-			NULL, (void __user *)cmd.addr, cmd.data_len,</span>
<span class="p_add">+			NULL, (void __user *)(uintptr_t)cmd.addr, cmd.data_len,</span>
 			&amp;cmd.result, timeout);
 	if (status &gt;= 0) {
 		if (put_user(cmd.result, &amp;ucmd-&gt;result))
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index 324bf35ec4dd..017b7d58ae06 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -96,6 +96,8 @@</span> <span class="p_context"> static int atomic_dec_return_safe(atomic_t *v)</span>
 #define RBD_MINORS_PER_MAJOR		256
 #define RBD_SINGLE_MAJOR_PART_SHIFT	4
 
<span class="p_add">+#define RBD_MAX_PARENT_CHAIN_LEN	16</span>
<span class="p_add">+</span>
 #define RBD_SNAP_DEV_NAME_PREFIX	&quot;snap_&quot;
 #define RBD_MAX_SNAP_NAME_LEN	\
 			(NAME_MAX - (sizeof (RBD_SNAP_DEV_NAME_PREFIX) - 1))
<span class="p_chunk">@@ -426,7 +428,7 @@</span> <span class="p_context"> static ssize_t rbd_add_single_major(struct bus_type *bus, const char *buf,</span>
 				    size_t count);
 static ssize_t rbd_remove_single_major(struct bus_type *bus, const char *buf,
 				       size_t count);
<span class="p_del">-static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping);</span>
<span class="p_add">+static int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth);</span>
 static void rbd_spec_put(struct rbd_spec *spec);
 
 static int rbd_dev_id_to_minor(int dev_id)
<span class="p_chunk">@@ -3819,6 +3821,9 @@</span> <span class="p_context"> static int rbd_init_disk(struct rbd_device *rbd_dev)</span>
 	q-&gt;limits.discard_zeroes_data = 1;
 
 	blk_queue_merge_bvec(q, rbd_merge_bvec);
<span class="p_add">+	if (!ceph_test_opt(rbd_dev-&gt;rbd_client-&gt;client, NOCRC))</span>
<span class="p_add">+		q-&gt;backing_dev_info.capabilities |= BDI_CAP_STABLE_WRITES;</span>
<span class="p_add">+</span>
 	disk-&gt;queue = q;
 
 	q-&gt;queuedata = rbd_dev;
<span class="p_chunk">@@ -5169,44 +5174,51 @@</span> <span class="p_context"> out_err:</span>
 	return ret;
 }
 
<span class="p_del">-static int rbd_dev_probe_parent(struct rbd_device *rbd_dev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * @depth is rbd_dev_image_probe() -&gt; rbd_dev_probe_parent() -&gt;</span>
<span class="p_add">+ * rbd_dev_image_probe() recursion depth, which means it&#39;s also the</span>
<span class="p_add">+ * length of the already discovered part of the parent chain.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int rbd_dev_probe_parent(struct rbd_device *rbd_dev, int depth)</span>
 {
 	struct rbd_device *parent = NULL;
<span class="p_del">-	struct rbd_spec *parent_spec;</span>
<span class="p_del">-	struct rbd_client *rbdc;</span>
 	int ret;
 
 	if (!rbd_dev-&gt;parent_spec)
 		return 0;
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to pass a reference to the client and the parent</span>
<span class="p_del">-	 * spec when creating the parent rbd_dev.  Images related by</span>
<span class="p_del">-	 * parent/child relationships always share both.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	parent_spec = rbd_spec_get(rbd_dev-&gt;parent_spec);</span>
<span class="p_del">-	rbdc = __rbd_get_client(rbd_dev-&gt;rbd_client);</span>
 
<span class="p_del">-	ret = -ENOMEM;</span>
<span class="p_del">-	parent = rbd_dev_create(rbdc, parent_spec, NULL);</span>
<span class="p_del">-	if (!parent)</span>
<span class="p_add">+	if (++depth &gt; RBD_MAX_PARENT_CHAIN_LEN) {</span>
<span class="p_add">+		pr_info(&quot;parent chain is too long (%d)\n&quot;, depth);</span>
<span class="p_add">+		ret = -EINVAL;</span>
 		goto out_err;
<span class="p_add">+	}</span>
 
<span class="p_del">-	ret = rbd_dev_image_probe(parent, false);</span>
<span class="p_add">+	parent = rbd_dev_create(rbd_dev-&gt;rbd_client, rbd_dev-&gt;parent_spec,</span>
<span class="p_add">+				NULL);</span>
<span class="p_add">+	if (!parent) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Images related by parent/child relationships always share</span>
<span class="p_add">+	 * rbd_client and spec/parent_spec, so bump their refcounts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__rbd_get_client(rbd_dev-&gt;rbd_client);</span>
<span class="p_add">+	rbd_spec_get(rbd_dev-&gt;parent_spec);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = rbd_dev_image_probe(parent, depth);</span>
 	if (ret &lt; 0)
 		goto out_err;
<span class="p_add">+</span>
 	rbd_dev-&gt;parent = parent;
 	atomic_set(&amp;rbd_dev-&gt;parent_ref, 1);
<span class="p_del">-</span>
 	return 0;
<span class="p_add">+</span>
 out_err:
<span class="p_del">-	if (parent) {</span>
<span class="p_del">-		rbd_dev_unparent(rbd_dev);</span>
<span class="p_add">+	rbd_dev_unparent(rbd_dev);</span>
<span class="p_add">+	if (parent)</span>
 		rbd_dev_destroy(parent);
<span class="p_del">-	} else {</span>
<span class="p_del">-		rbd_put_client(rbdc);</span>
<span class="p_del">-		rbd_spec_put(parent_spec);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -5324,7 +5336,7 @@</span> <span class="p_context"> static void rbd_dev_image_release(struct rbd_device *rbd_dev)</span>
  * parent), initiate a watch on its header object before using that
  * object to get detailed information about the rbd image.
  */
<span class="p_del">-static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
<span class="p_add">+static int rbd_dev_image_probe(struct rbd_device *rbd_dev, int depth)</span>
 {
 	int ret;
 
<span class="p_chunk">@@ -5342,7 +5354,7 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 	if (ret)
 		goto err_out_format;
 
<span class="p_del">-	if (mapping) {</span>
<span class="p_add">+	if (!depth) {</span>
 		ret = rbd_dev_header_watch_sync(rbd_dev);
 		if (ret) {
 			if (ret == -ENOENT)
<span class="p_chunk">@@ -5363,7 +5375,7 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 	 * Otherwise this is a parent image, identified by pool, image
 	 * and snap ids - need to fill in names for those ids.
 	 */
<span class="p_del">-	if (mapping)</span>
<span class="p_add">+	if (!depth)</span>
 		ret = rbd_spec_fill_snap_id(rbd_dev);
 	else
 		ret = rbd_spec_fill_names(rbd_dev);
<span class="p_chunk">@@ -5385,12 +5397,12 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 		 * Need to warn users if this image is the one being
 		 * mapped and has a parent.
 		 */
<span class="p_del">-		if (mapping &amp;&amp; rbd_dev-&gt;parent_spec)</span>
<span class="p_add">+		if (!depth &amp;&amp; rbd_dev-&gt;parent_spec)</span>
 			rbd_warn(rbd_dev,
 				 &quot;WARNING: kernel layering is EXPERIMENTAL!&quot;);
 	}
 
<span class="p_del">-	ret = rbd_dev_probe_parent(rbd_dev);</span>
<span class="p_add">+	ret = rbd_dev_probe_parent(rbd_dev, depth);</span>
 	if (ret)
 		goto err_out_probe;
 
<span class="p_chunk">@@ -5401,7 +5413,7 @@</span> <span class="p_context"> static int rbd_dev_image_probe(struct rbd_device *rbd_dev, bool mapping)</span>
 err_out_probe:
 	rbd_dev_unprobe(rbd_dev);
 err_out_watch:
<span class="p_del">-	if (mapping)</span>
<span class="p_add">+	if (!depth)</span>
 		rbd_dev_header_unwatch_sync(rbd_dev);
 out_header_name:
 	kfree(rbd_dev-&gt;header_name);
<span class="p_chunk">@@ -5464,7 +5476,7 @@</span> <span class="p_context"> static ssize_t do_rbd_add(struct bus_type *bus,</span>
 	spec = NULL;		/* rbd_dev now owns this */
 	rbd_opts = NULL;	/* rbd_dev now owns this */
 
<span class="p_del">-	rc = rbd_dev_image_probe(rbd_dev, true);</span>
<span class="p_add">+	rc = rbd_dev_image_probe(rbd_dev, 0);</span>
 	if (rc &lt; 0)
 		goto err_out_rbd_dev;
 
<span class="p_header">diff --git a/drivers/block/xen-blkfront.c b/drivers/block/xen-blkfront.c</span>
<span class="p_header">index 7a8a73f1fc04..d68b08ae4be1 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkfront.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkfront.c</span>
<span class="p_chunk">@@ -1984,7 +1984,8 @@</span> <span class="p_context"> static void blkback_changed(struct xenbus_device *dev,</span>
 			break;
 		/* Missed the backend&#39;s Closing state -- fallthrough */
 	case XenbusStateClosing:
<span class="p_del">-		blkfront_closing(info);</span>
<span class="p_add">+		if (info)</span>
<span class="p_add">+			blkfront_closing(info);</span>
 		break;
 	}
 }
<span class="p_header">diff --git a/drivers/bus/arm-ccn.c b/drivers/bus/arm-ccn.c</span>
<span class="p_header">index 7d9879e166cf..395cb7f9f5a4 100644</span>
<span class="p_header">--- a/drivers/bus/arm-ccn.c</span>
<span class="p_header">+++ b/drivers/bus/arm-ccn.c</span>
<span class="p_chunk">@@ -1188,7 +1188,8 @@</span> <span class="p_context"> static int arm_ccn_pmu_cpu_notifier(struct notifier_block *nb,</span>
 			break;
 		perf_pmu_migrate_context(&amp;dt-&gt;pmu, cpu, target);
 		cpumask_set_cpu(target, &amp;dt-&gt;cpu);
<span class="p_del">-		WARN_ON(irq_set_affinity(ccn-&gt;irq, &amp;dt-&gt;cpu) != 0);</span>
<span class="p_add">+		if (ccn-&gt;irq)</span>
<span class="p_add">+			WARN_ON(irq_set_affinity(ccn-&gt;irq, &amp;dt-&gt;cpu) != 0);</span>
 	default:
 		break;
 	}
<span class="p_header">diff --git a/drivers/clk/clkdev.c b/drivers/clk/clkdev.c</span>
<span class="p_header">index c0eaf0973bd2..779b6ff0c7ad 100644</span>
<span class="p_header">--- a/drivers/clk/clkdev.c</span>
<span class="p_header">+++ b/drivers/clk/clkdev.c</span>
<span class="p_chunk">@@ -333,7 +333,8 @@</span> <span class="p_context"> int clk_add_alias(const char *alias, const char *alias_dev_name,</span>
 	if (IS_ERR(r))
 		return PTR_ERR(r);
 
<span class="p_del">-	l = clkdev_create(r, alias, &quot;%s&quot;, alias_dev_name);</span>
<span class="p_add">+	l = clkdev_create(r, alias, alias_dev_name ? &quot;%s&quot; : NULL,</span>
<span class="p_add">+			  alias_dev_name);</span>
 	clk_put(r);
 
 	return l ? 0 : -ENODEV;
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index fcb929ec5304..aba2117a80c1 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -766,6 +766,11 @@</span> <span class="p_context"> static inline void intel_pstate_sample(struct cpudata *cpu)</span>
 	local_irq_save(flags);
 	rdmsrl(MSR_IA32_APERF, aperf);
 	rdmsrl(MSR_IA32_MPERF, mperf);
<span class="p_add">+	if (cpu-&gt;prev_mperf == mperf) {</span>
<span class="p_add">+		local_irq_restore(flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	tsc = native_read_tsc();
 	local_irq_restore(flags);
 
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index ca7831168298..91cf71008e11 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -1648,6 +1648,7 @@</span> <span class="p_context"> static int sbridge_mci_bind_devs(struct mem_ctl_info *mci,</span>
 {
 	struct sbridge_pvt *pvt = mci-&gt;pvt_info;
 	struct pci_dev *pdev;
<span class="p_add">+	u8 saw_chan_mask = 0;</span>
 	int i;
 
 	for (i = 0; i &lt; sbridge_dev-&gt;n_devs; i++) {
<span class="p_chunk">@@ -1681,6 +1682,7 @@</span> <span class="p_context"> static int sbridge_mci_bind_devs(struct mem_ctl_info *mci,</span>
 		{
 			int id = pdev-&gt;device - PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_TAD0;
 			pvt-&gt;pci_tad[id] = pdev;
<span class="p_add">+			saw_chan_mask |= 1 &lt;&lt; id;</span>
 		}
 			break;
 		case PCI_DEVICE_ID_INTEL_SBRIDGE_IMC_DDRIO:
<span class="p_chunk">@@ -1701,10 +1703,8 @@</span> <span class="p_context"> static int sbridge_mci_bind_devs(struct mem_ctl_info *mci,</span>
 	    !pvt-&gt; pci_tad || !pvt-&gt;pci_ras  || !pvt-&gt;pci_ta)
 		goto enodev;
 
<span class="p_del">-	for (i = 0; i &lt; NUM_CHANNELS; i++) {</span>
<span class="p_del">-		if (!pvt-&gt;pci_tad[i])</span>
<span class="p_del">-			goto enodev;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (saw_chan_mask != 0x0f)</span>
<span class="p_add">+		goto enodev;</span>
 	return 0;
 
 enodev:
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">index f7b49d5ce4b8..e3305a5aedfd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_chunk">@@ -1583,6 +1583,7 @@</span> <span class="p_context"> struct amdgpu_pm {</span>
 	u8                      fan_max_rpm;
 	/* dpm */
 	bool                    dpm_enabled;
<span class="p_add">+	bool                    sysfs_initialized;</span>
 	struct amdgpu_dpm       dpm;
 	const struct firmware	*fw;	/* SMC firmware */
 	uint32_t                fw_version;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c</span>
<span class="p_header">index ed13baa7c976..91c7556a365a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_pm.c</span>
<span class="p_chunk">@@ -693,6 +693,9 @@</span> <span class="p_context"> int amdgpu_pm_sysfs_init(struct amdgpu_device *adev)</span>
 {
 	int ret;
 
<span class="p_add">+	if (adev-&gt;pm.sysfs_initialized)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (adev-&gt;pm.funcs-&gt;get_temperature == NULL)
 		return 0;
 	adev-&gt;pm.int_hwmon_dev = hwmon_device_register_with_groups(adev-&gt;dev,
<span class="p_chunk">@@ -721,6 +724,8 @@</span> <span class="p_context"> int amdgpu_pm_sysfs_init(struct amdgpu_device *adev)</span>
 		return ret;
 	}
 
<span class="p_add">+	adev-&gt;pm.sysfs_initialized = true;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/kv_dpm.c b/drivers/gpu/drm/amd/amdgpu/kv_dpm.c</span>
<span class="p_header">index 9745ed3a9aef..7e9154c7f1db 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/kv_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/kv_dpm.c</span>
<span class="p_chunk">@@ -2997,6 +2997,9 @@</span> <span class="p_context"> static int kv_dpm_late_init(void *handle)</span>
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 	int ret;
 
<span class="p_add">+	if (!amdgpu_dpm)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/* init the sysfs and debugfs files late */
 	ret = amdgpu_pm_sysfs_init(adev);
 	if (ret)
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index fed748311b92..4e8d72d40af4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -4221,7 +4221,7 @@</span> <span class="p_context"> drm_property_create_blob(struct drm_device *dev, size_t length,</span>
 	struct drm_property_blob *blob;
 	int ret;
 
<span class="p_del">-	if (!length)</span>
<span class="p_add">+	if (!length || length &gt; ULONG_MAX - sizeof(struct drm_property_blob))</span>
 		return ERR_PTR(-EINVAL);
 
 	blob = kzalloc(sizeof(struct drm_property_blob)+length, GFP_KERNEL);
<span class="p_chunk">@@ -4573,7 +4573,7 @@</span> <span class="p_context"> int drm_mode_createblob_ioctl(struct drm_device *dev,</span>
 	 * not associated with any file_priv. */
 	mutex_lock(&amp;dev-&gt;mode_config.blob_lock);
 	out_resp-&gt;blob_id = blob-&gt;base.id;
<span class="p_del">-	list_add_tail(&amp;file_priv-&gt;blobs, &amp;blob-&gt;head_file);</span>
<span class="p_add">+	list_add_tail(&amp;blob-&gt;head_file, &amp;file_priv-&gt;blobs);</span>
 	mutex_unlock(&amp;dev-&gt;mode_config.blob_lock);
 
 	return 0;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 27a2426c3daa..1f94219f3e0e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -1193,17 +1193,18 @@</span> <span class="p_context"> static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_</span>
 
 		list_for_each_entry(port, &amp;mstb-&gt;ports, next) {
 			if (port-&gt;port_num == port_num) {
<span class="p_del">-				if (!port-&gt;mstb) {</span>
<span class="p_add">+				mstb = port-&gt;mstb;</span>
<span class="p_add">+				if (!mstb) {</span>
 					DRM_ERROR(&quot;failed to lookup MSTB with lct %d, rad %02x\n&quot;, lct, rad[0]);
<span class="p_del">-					return NULL;</span>
<span class="p_add">+					goto out;</span>
 				}
 
<span class="p_del">-				mstb = port-&gt;mstb;</span>
 				break;
 			}
 		}
 	}
 	kref_get(&amp;mstb-&gt;kref);
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;mgr-&gt;lock);
 	return mstb;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_userptr.c b/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_header">index 8fd431bcdfd3..a96b9006a51e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_userptr.c</span>
<span class="p_chunk">@@ -804,7 +804,10 @@</span> <span class="p_context"> static const struct drm_i915_gem_object_ops i915_gem_userptr_ops = {</span>
  * Also note, that the object created here is not currently a &quot;first class&quot;
  * object, in that several ioctls are banned. These are the CPU access
  * ioctls: mmap(), pwrite and pread. In practice, you are expected to use
<span class="p_del">- * direct access via your pointer rather than use those ioctls.</span>
<span class="p_add">+ * direct access via your pointer rather than use those ioctls. Another</span>
<span class="p_add">+ * restriction is that we do not allow userptr surfaces to be pinned to the</span>
<span class="p_add">+ * hardware and so we reject any attempt to create a framebuffer out of a</span>
<span class="p_add">+ * userptr.</span>
  *
  * If you think this is a good interface to use to pass GPU memory between
  * drivers, please use dma-buf instead. In fact, wherever possible use
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 107c6c0519fd..10b1b657d32a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -1729,6 +1729,8 @@</span> <span class="p_context"> static void i9xx_enable_pll(struct intel_crtc *crtc)</span>
 			   I915_READ(DPLL(!crtc-&gt;pipe)) | DPLL_DVO_2X_MODE);
 	}
 
<span class="p_add">+	I915_WRITE(reg, dpll);</span>
<span class="p_add">+</span>
 	/* Wait for the clocks to stabilize. */
 	POSTING_READ(reg);
 	udelay(150);
<span class="p_chunk">@@ -14070,6 +14072,11 @@</span> <span class="p_context"> static int intel_user_framebuffer_create_handle(struct drm_framebuffer *fb,</span>
 	struct intel_framebuffer *intel_fb = to_intel_framebuffer(fb);
 	struct drm_i915_gem_object *obj = intel_fb-&gt;obj;
 
<span class="p_add">+	if (obj-&gt;userptr.mm) {</span>
<span class="p_add">+		DRM_DEBUG(&quot;attempting to use a userptr for a framebuffer, denied\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return drm_gem_handle_create(file, &amp;obj-&gt;base, handle);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_lrc.c b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">index 7f2161a1ff5d..504728b401b6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_lrc.c</span>
<span class="p_chunk">@@ -1250,6 +1250,7 @@</span> <span class="p_context"> static int gen8_emit_flush_render(struct intel_ringbuffer *ringbuf,</span>
 	if (flush_domains) {
 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
<span class="p_add">+		flags |= PIPE_CONTROL_FLUSH_ENABLE;</span>
 	}
 
 	if (invalidate_domains) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.c b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">index 3817a6f00d9e..ba672aa980e1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ringbuffer.c</span>
<span class="p_chunk">@@ -342,6 +342,7 @@</span> <span class="p_context"> gen7_render_ring_flush(struct intel_engine_cs *ring,</span>
 	if (flush_domains) {
 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
<span class="p_add">+		flags |= PIPE_CONTROL_FLUSH_ENABLE;</span>
 	}
 	if (invalidate_domains) {
 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
<span class="p_chunk">@@ -412,6 +413,7 @@</span> <span class="p_context"> gen8_render_ring_flush(struct intel_engine_cs *ring,</span>
 	if (flush_domains) {
 		flags |= PIPE_CONTROL_RENDER_TARGET_CACHE_FLUSH;
 		flags |= PIPE_CONTROL_DEPTH_CACHE_FLUSH;
<span class="p_add">+		flags |= PIPE_CONTROL_FLUSH_ENABLE;</span>
 	}
 	if (invalidate_domains) {
 		flags |= PIPE_CONTROL_TLB_INVALIDATE;
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_gem.c b/drivers/gpu/drm/nouveau/nouveau_gem.c</span>
<span class="p_header">index af1ee517f372..0b2239423a37 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_gem.c</span>
<span class="p_chunk">@@ -227,11 +227,12 @@</span> <span class="p_context"> nouveau_gem_info(struct drm_file *file_priv, struct drm_gem_object *gem,</span>
 	struct nouveau_bo *nvbo = nouveau_gem_object(gem);
 	struct nvkm_vma *vma;
 
<span class="p_del">-	if (nvbo-&gt;bo.mem.mem_type == TTM_PL_TT)</span>
<span class="p_add">+	if (is_power_of_2(nvbo-&gt;valid_domains))</span>
<span class="p_add">+		rep-&gt;domain = nvbo-&gt;valid_domains;</span>
<span class="p_add">+	else if (nvbo-&gt;bo.mem.mem_type == TTM_PL_TT)</span>
 		rep-&gt;domain = NOUVEAU_GEM_DOMAIN_GART;
 	else
 		rep-&gt;domain = NOUVEAU_GEM_DOMAIN_VRAM;
<span class="p_del">-</span>
 	rep-&gt;offset = nvbo-&gt;bo.offset;
 	if (cli-&gt;vm) {
 		vma = nouveau_bo_vma_find(nvbo, cli-&gt;vm);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index 65adb9c72377..bb292143997e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -237,6 +237,7 @@</span> <span class="p_context"> void radeon_atom_backlight_init(struct radeon_encoder *radeon_encoder,</span>
 	backlight_update_status(bd);
 
 	DRM_INFO(&quot;radeon atom DIG backlight initialized\n&quot;);
<span class="p_add">+	rdev-&gt;mode_info.bl_encoder = radeon_encoder;</span>
 
 	return;
 
<span class="p_chunk">@@ -1624,9 +1625,14 @@</span> <span class="p_context"> radeon_atom_encoder_dpms_avivo(struct drm_encoder *encoder, int mode)</span>
 		} else
 			atom_execute_table(rdev-&gt;mode_info.atom_context, index, (uint32_t *)&amp;args);
 		if (radeon_encoder-&gt;devices &amp; (ATOM_DEVICE_LCD_SUPPORT)) {
<span class="p_del">-			struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;</span>
<span class="p_add">+			if (rdev-&gt;mode_info.bl_encoder) {</span>
<span class="p_add">+				struct radeon_encoder_atom_dig *dig = radeon_encoder-&gt;enc_priv;</span>
 
<span class="p_del">-			atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+				atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				args.ucAction = ATOM_LCD_BLON;</span>
<span class="p_add">+				atom_execute_table(rdev-&gt;mode_info.atom_context, index, (uint32_t *)&amp;args);</span>
<span class="p_add">+			}</span>
 		}
 		break;
 	case DRM_MODE_DPMS_STANDBY:
<span class="p_chunk">@@ -1706,8 +1712,13 @@</span> <span class="p_context"> radeon_atom_encoder_dpms_dig(struct drm_encoder *encoder, int mode)</span>
 			if (ASIC_IS_DCE4(rdev))
 				atombios_dig_encoder_setup(encoder, ATOM_ENCODER_CMD_DP_VIDEO_ON, 0);
 		}
<span class="p_del">-		if (radeon_encoder-&gt;devices &amp; (ATOM_DEVICE_LCD_SUPPORT))</span>
<span class="p_del">-			atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+		if (radeon_encoder-&gt;devices &amp; (ATOM_DEVICE_LCD_SUPPORT)) {</span>
<span class="p_add">+			if (rdev-&gt;mode_info.bl_encoder)</span>
<span class="p_add">+				atombios_set_backlight_level(radeon_encoder, dig-&gt;backlight_level);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				atombios_dig_transmitter_setup(encoder,</span>
<span class="p_add">+							       ATOM_TRANSMITTER_ACTION_LCD_BLON, 0, 0);</span>
<span class="p_add">+		}</span>
 		if (ext_encoder)
 			atombios_external_encoder_setup(encoder, ext_encoder, ATOM_ENABLE);
 		break;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_header">index f03b7eb15233..b6cbd816537e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon.h</span>
<span class="p_chunk">@@ -1658,6 +1658,7 @@</span> <span class="p_context"> struct radeon_pm {</span>
 	u8                      fan_max_rpm;
 	/* dpm */
 	bool                    dpm_enabled;
<span class="p_add">+	bool                    sysfs_initialized;</span>
 	struct radeon_dpm       dpm;
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_encoders.c b/drivers/gpu/drm/radeon/radeon_encoders.c</span>
<span class="p_header">index ef99917f000d..c6ee80216cf4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_encoders.c</span>
<span class="p_chunk">@@ -194,7 +194,6 @@</span> <span class="p_context"> static void radeon_encoder_add_backlight(struct radeon_encoder *radeon_encoder,</span>
 			radeon_atom_backlight_init(radeon_encoder, connector);
 		else
 			radeon_legacy_backlight_init(radeon_encoder, connector);
<span class="p_del">-		rdev-&gt;mode_info.bl_encoder = radeon_encoder;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c</span>
<span class="p_header">index 45715307db71..30de43366eae 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_legacy_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_legacy_encoders.c</span>
<span class="p_chunk">@@ -441,6 +441,7 @@</span> <span class="p_context"> void radeon_legacy_backlight_init(struct radeon_encoder *radeon_encoder,</span>
 	backlight_update_status(bd);
 
 	DRM_INFO(&quot;radeon legacy LVDS backlight initialized\n&quot;);
<span class="p_add">+	rdev-&gt;mode_info.bl_encoder = radeon_encoder;</span>
 
 	return;
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">index 948c33105801..91764320c56f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_pm.c</span>
<span class="p_chunk">@@ -720,10 +720,14 @@</span> <span class="p_context"> static umode_t hwmon_attributes_visible(struct kobject *kobj,</span>
 	struct radeon_device *rdev = dev_get_drvdata(dev);
 	umode_t effective_mode = attr-&gt;mode;
 
<span class="p_del">-	/* Skip limit attributes if DPM is not enabled */</span>
<span class="p_add">+	/* Skip attributes if DPM is not enabled */</span>
 	if (rdev-&gt;pm.pm_method != PM_METHOD_DPM &amp;&amp;
 	    (attr == &amp;sensor_dev_attr_temp1_crit.dev_attr.attr ||
<span class="p_del">-	     attr == &amp;sensor_dev_attr_temp1_crit_hyst.dev_attr.attr))</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_temp1_crit_hyst.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1_enable.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1_max.dev_attr.attr ||</span>
<span class="p_add">+	     attr == &amp;sensor_dev_attr_pwm1_min.dev_attr.attr))</span>
 		return 0;
 
 	/* Skip fan attributes if fan is not present */
<span class="p_chunk">@@ -1529,19 +1533,23 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 
 	if (rdev-&gt;pm.pm_method == PM_METHOD_DPM) {
 		if (rdev-&gt;pm.dpm_enabled) {
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_state);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_force_performance_level);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_del">-			/* XXX: these are noops for dpm but are here for backwards compat */</span>
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_profile);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for power profile\n&quot;);</span>
<span class="p_del">-			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);</span>
<span class="p_del">-			if (ret)</span>
<span class="p_del">-				DRM_ERROR(&quot;failed to create device file for power method\n&quot;);</span>
<span class="p_add">+			if (!rdev-&gt;pm.sysfs_initialized) {</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_state);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_dpm_force_performance_level);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for dpm state\n&quot;);</span>
<span class="p_add">+				/* XXX: these are noops for dpm but are here for backwards compat */</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_profile);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for power profile\n&quot;);</span>
<span class="p_add">+				ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);</span>
<span class="p_add">+				if (ret)</span>
<span class="p_add">+					DRM_ERROR(&quot;failed to create device file for power method\n&quot;);</span>
<span class="p_add">+				if (!ret)</span>
<span class="p_add">+					rdev-&gt;pm.sysfs_initialized = true;</span>
<span class="p_add">+			}</span>
 
 			mutex_lock(&amp;rdev-&gt;pm.mutex);
 			ret = radeon_dpm_late_enable(rdev);
<span class="p_chunk">@@ -1557,7 +1565,8 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 			}
 		}
 	} else {
<span class="p_del">-		if (rdev-&gt;pm.num_power_states &gt; 1) {</span>
<span class="p_add">+		if ((rdev-&gt;pm.num_power_states &gt; 1) &amp;&amp;</span>
<span class="p_add">+		    (!rdev-&gt;pm.sysfs_initialized)) {</span>
 			/* where&#39;s the best place to put these? */
 			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_profile);
 			if (ret)
<span class="p_chunk">@@ -1565,6 +1574,8 @@</span> <span class="p_context"> int radeon_pm_late_init(struct radeon_device *rdev)</span>
 			ret = device_create_file(rdev-&gt;dev, &amp;dev_attr_power_method);
 			if (ret)
 				DRM_ERROR(&quot;failed to create device file for power method\n&quot;);
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				rdev-&gt;pm.sysfs_initialized = true;</span>
 		}
 	}
 	return ret;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">index 620bb5cf617c..15a8d7746fd2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.c</span>
<span class="p_chunk">@@ -1458,6 +1458,9 @@</span> <span class="p_context"> static void __exit vmwgfx_exit(void)</span>
 	drm_pci_exit(&amp;driver, &amp;vmw_pci_driver);
 }
 
<span class="p_add">+MODULE_INFO(vmw_patch, &quot;ed7d78b2&quot;);</span>
<span class="p_add">+MODULE_INFO(vmw_patch, &quot;54c12bc3&quot;);</span>
<span class="p_add">+</span>
 module_init(vmwgfx_init);
 module_exit(vmwgfx_exit);
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_header">index d26a6daa9719..d8896ed41b9e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_drv.h</span>
<span class="p_chunk">@@ -636,7 +636,8 @@</span> <span class="p_context"> extern int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv,</span>
 				 uint32_t size,
 				 bool shareable,
 				 uint32_t *handle,
<span class="p_del">-				 struct vmw_dma_buffer **p_dma_buf);</span>
<span class="p_add">+				 struct vmw_dma_buffer **p_dma_buf,</span>
<span class="p_add">+				 struct ttm_base_object **p_base);</span>
 extern int vmw_user_dmabuf_reference(struct ttm_object_file *tfile,
 				     struct vmw_dma_buffer *dma_buf,
 				     uint32_t *handle);
<span class="p_chunk">@@ -650,7 +651,8 @@</span> <span class="p_context"> extern uint32_t vmw_dmabuf_validate_node(struct ttm_buffer_object *bo,</span>
 					 uint32_t cur_validate_node);
 extern void vmw_dmabuf_validate_clear(struct ttm_buffer_object *bo);
 extern int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile,
<span class="p_del">-				  uint32_t id, struct vmw_dma_buffer **out);</span>
<span class="p_add">+				  uint32_t id, struct vmw_dma_buffer **out,</span>
<span class="p_add">+				  struct ttm_base_object **base);</span>
 extern int vmw_stream_claim_ioctl(struct drm_device *dev, void *data,
 				  struct drm_file *file_priv);
 extern int vmw_stream_unref_ioctl(struct drm_device *dev, void *data,
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">index 97ad3bcb99a7..aee1c6ccc52d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_execbuf.c</span>
<span class="p_chunk">@@ -887,7 +887,8 @@</span> <span class="p_context"> static int vmw_translate_mob_ptr(struct vmw_private *dev_priv,</span>
 	struct vmw_relocation *reloc;
 	int ret;
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo,</span>
<span class="p_add">+				     NULL);</span>
 	if (unlikely(ret != 0)) {
 		DRM_ERROR(&quot;Could not find or use MOB buffer.\n&quot;);
 		ret = -EINVAL;
<span class="p_chunk">@@ -949,7 +950,8 @@</span> <span class="p_context"> static int vmw_translate_guest_ptr(struct vmw_private *dev_priv,</span>
 	struct vmw_relocation *reloc;
 	int ret;
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(sw_context-&gt;fp-&gt;tfile, handle, &amp;vmw_bo,</span>
<span class="p_add">+				     NULL);</span>
 	if (unlikely(ret != 0)) {
 		DRM_ERROR(&quot;Could not find or use GMR region.\n&quot;);
 		ret = -EINVAL;
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c</span>
<span class="p_header">index 87e39f68e9d0..e1898982b44a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_overlay.c</span>
<span class="p_chunk">@@ -484,7 +484,7 @@</span> <span class="p_context"> int vmw_overlay_ioctl(struct drm_device *dev, void *data,</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;buf);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;buf, NULL);</span>
 	if (ret)
 		goto out_unlock;
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">index 210ef15b1d09..c5b4c47e86d6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_resource.c</span>
<span class="p_chunk">@@ -356,7 +356,7 @@</span> <span class="p_context"> int vmw_user_lookup_handle(struct vmw_private *dev_priv,</span>
 	}
 
 	*out_surf = NULL;
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(tfile, handle, out_buf, NULL);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -483,7 +483,8 @@</span> <span class="p_context"> int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv,</span>
 			  uint32_t size,
 			  bool shareable,
 			  uint32_t *handle,
<span class="p_del">-			  struct vmw_dma_buffer **p_dma_buf)</span>
<span class="p_add">+			  struct vmw_dma_buffer **p_dma_buf,</span>
<span class="p_add">+			  struct ttm_base_object **p_base)</span>
 {
 	struct vmw_user_dma_buffer *user_bo;
 	struct ttm_buffer_object *tmp;
<span class="p_chunk">@@ -517,6 +518,10 @@</span> <span class="p_context"> int vmw_user_dmabuf_alloc(struct vmw_private *dev_priv,</span>
 	}
 
 	*p_dma_buf = &amp;user_bo-&gt;dma;
<span class="p_add">+	if (p_base) {</span>
<span class="p_add">+		*p_base = &amp;user_bo-&gt;prime.base;</span>
<span class="p_add">+		kref_get(&amp;(*p_base)-&gt;refcount);</span>
<span class="p_add">+	}</span>
 	*handle = user_bo-&gt;prime.base.hash.key;
 
 out_no_base_object:
<span class="p_chunk">@@ -633,6 +638,7 @@</span> <span class="p_context"> int vmw_user_dmabuf_synccpu_ioctl(struct drm_device *dev, void *data,</span>
 	struct vmw_dma_buffer *dma_buf;
 	struct vmw_user_dma_buffer *user_bo;
 	struct ttm_object_file *tfile = vmw_fpriv(file_priv)-&gt;tfile;
<span class="p_add">+	struct ttm_base_object *buffer_base;</span>
 	int ret;
 
 	if ((arg-&gt;flags &amp; (drm_vmw_synccpu_read | drm_vmw_synccpu_write)) == 0
<span class="p_chunk">@@ -645,7 +651,8 @@</span> <span class="p_context"> int vmw_user_dmabuf_synccpu_ioctl(struct drm_device *dev, void *data,</span>
 
 	switch (arg-&gt;op) {
 	case drm_vmw_synccpu_grab:
<span class="p_del">-		ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;dma_buf);</span>
<span class="p_add">+		ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;handle, &amp;dma_buf,</span>
<span class="p_add">+					     &amp;buffer_base);</span>
 		if (unlikely(ret != 0))
 			return ret;
 
<span class="p_chunk">@@ -653,6 +660,7 @@</span> <span class="p_context"> int vmw_user_dmabuf_synccpu_ioctl(struct drm_device *dev, void *data,</span>
 				       dma);
 		ret = vmw_user_dmabuf_synccpu_grab(user_bo, tfile, arg-&gt;flags);
 		vmw_dmabuf_unreference(&amp;dma_buf);
<span class="p_add">+		ttm_base_object_unref(&amp;buffer_base);</span>
 		if (unlikely(ret != 0 &amp;&amp; ret != -ERESTARTSYS &amp;&amp;
 			     ret != -EBUSY)) {
 			DRM_ERROR(&quot;Failed synccpu grab on handle 0x%08x.\n&quot;,
<span class="p_chunk">@@ -694,7 +702,8 @@</span> <span class="p_context"> int vmw_dmabuf_alloc_ioctl(struct drm_device *dev, void *data,</span>
 		return ret;
 
 	ret = vmw_user_dmabuf_alloc(dev_priv, vmw_fpriv(file_priv)-&gt;tfile,
<span class="p_del">-				    req-&gt;size, false, &amp;handle, &amp;dma_buf);</span>
<span class="p_add">+				    req-&gt;size, false, &amp;handle, &amp;dma_buf,</span>
<span class="p_add">+				    NULL);</span>
 	if (unlikely(ret != 0))
 		goto out_no_dmabuf;
 
<span class="p_chunk">@@ -723,7 +732,8 @@</span> <span class="p_context"> int vmw_dmabuf_unref_ioctl(struct drm_device *dev, void *data,</span>
 }
 
 int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile,
<span class="p_del">-			   uint32_t handle, struct vmw_dma_buffer **out)</span>
<span class="p_add">+			   uint32_t handle, struct vmw_dma_buffer **out,</span>
<span class="p_add">+			   struct ttm_base_object **p_base)</span>
 {
 	struct vmw_user_dma_buffer *vmw_user_bo;
 	struct ttm_base_object *base;
<span class="p_chunk">@@ -745,7 +755,10 @@</span> <span class="p_context"> int vmw_user_dmabuf_lookup(struct ttm_object_file *tfile,</span>
 	vmw_user_bo = container_of(base, struct vmw_user_dma_buffer,
 				   prime.base);
 	(void)ttm_bo_reference(&amp;vmw_user_bo-&gt;dma.base);
<span class="p_del">-	ttm_base_object_unref(&amp;base);</span>
<span class="p_add">+	if (p_base)</span>
<span class="p_add">+		*p_base = base;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ttm_base_object_unref(&amp;base);</span>
 	*out = &amp;vmw_user_bo-&gt;dma;
 
 	return 0;
<span class="p_chunk">@@ -1006,7 +1019,7 @@</span> <span class="p_context"> int vmw_dumb_create(struct drm_file *file_priv,</span>
 
 	ret = vmw_user_dmabuf_alloc(dev_priv, vmw_fpriv(file_priv)-&gt;tfile,
 				    args-&gt;size, false, &amp;args-&gt;handle,
<span class="p_del">-				    &amp;dma_buf);</span>
<span class="p_add">+				    &amp;dma_buf, NULL);</span>
 	if (unlikely(ret != 0))
 		goto out_no_dmabuf;
 
<span class="p_chunk">@@ -1034,7 +1047,7 @@</span> <span class="p_context"> int vmw_dumb_map_offset(struct drm_file *file_priv,</span>
 	struct vmw_dma_buffer *out_buf;
 	int ret;
 
<span class="p_del">-	ret = vmw_user_dmabuf_lookup(tfile, handle, &amp;out_buf);</span>
<span class="p_add">+	ret = vmw_user_dmabuf_lookup(tfile, handle, &amp;out_buf, NULL);</span>
 	if (ret != 0)
 		return -EINVAL;
 
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c b/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c</span>
<span class="p_header">index 6a4584a43aa6..d2751ada19b1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_shader.c</span>
<span class="p_chunk">@@ -470,7 +470,7 @@</span> <span class="p_context"> int vmw_shader_define_ioctl(struct drm_device *dev, void *data,</span>
 
 	if (arg-&gt;buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, arg-&gt;buffer_handle,
<span class="p_del">-					     &amp;buffer);</span>
<span class="p_add">+					     &amp;buffer, NULL);</span>
 		if (unlikely(ret != 0)) {
 			DRM_ERROR(&quot;Could not find buffer for shader &quot;
 				  &quot;creation.\n&quot;);
<span class="p_header">diff --git a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">index 4ecdbf3e59da..17a4107639b2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vmwgfx/vmwgfx_surface.c</span>
<span class="p_chunk">@@ -43,6 +43,7 @@</span> <span class="p_context"> struct vmw_user_surface {</span>
 	struct vmw_surface srf;
 	uint32_t size;
 	struct drm_master *master;
<span class="p_add">+	struct ttm_base_object *backup_base;</span>
 };
 
 /**
<span class="p_chunk">@@ -652,6 +653,8 @@</span> <span class="p_context"> static void vmw_user_surface_base_release(struct ttm_base_object **p_base)</span>
 	struct vmw_resource *res = &amp;user_srf-&gt;srf.res;
 
 	*p_base = NULL;
<span class="p_add">+	if (user_srf-&gt;backup_base)</span>
<span class="p_add">+		ttm_base_object_unref(&amp;user_srf-&gt;backup_base);</span>
 	vmw_resource_unreference(&amp;res);
 }
 
<span class="p_chunk">@@ -846,7 +849,8 @@</span> <span class="p_context"> int vmw_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 					    res-&gt;backup_size,
 					    true,
 					    &amp;backup_handle,
<span class="p_del">-					    &amp;res-&gt;backup);</span>
<span class="p_add">+					    &amp;res-&gt;backup,</span>
<span class="p_add">+					    &amp;user_srf-&gt;backup_base);</span>
 		if (unlikely(ret != 0)) {
 			vmw_resource_unreference(&amp;res);
 			goto out_unlock;
<span class="p_chunk">@@ -1309,7 +1313,8 @@</span> <span class="p_context"> int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 
 	if (req-&gt;buffer_handle != SVGA3D_INVALID_ID) {
 		ret = vmw_user_dmabuf_lookup(tfile, req-&gt;buffer_handle,
<span class="p_del">-					     &amp;res-&gt;backup);</span>
<span class="p_add">+					     &amp;res-&gt;backup,</span>
<span class="p_add">+					     &amp;user_srf-&gt;backup_base);</span>
 	} else if (req-&gt;drm_surface_flags &amp;
 		   drm_vmw_surface_flag_create_buffer)
 		ret = vmw_user_dmabuf_alloc(dev_priv, tfile,
<span class="p_chunk">@@ -1317,7 +1322,8 @@</span> <span class="p_context"> int vmw_gb_surface_define_ioctl(struct drm_device *dev, void *data,</span>
 					    req-&gt;drm_surface_flags &amp;
 					    drm_vmw_surface_flag_shareable,
 					    &amp;backup_handle,
<span class="p_del">-					    &amp;res-&gt;backup);</span>
<span class="p_add">+					    &amp;res-&gt;backup,</span>
<span class="p_add">+					    &amp;user_srf-&gt;backup_base);</span>
 
 	if (unlikely(ret != 0)) {
 		vmw_resource_unreference(&amp;res);
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-mv64xxx.c b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">index 30059c1df2a3..5801227b97ab 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-mv64xxx.c</span>
<span class="p_chunk">@@ -669,8 +669,6 @@</span> <span class="p_context"> mv64xxx_i2c_can_offload(struct mv64xxx_i2c_data *drv_data)</span>
 	struct i2c_msg *msgs = drv_data-&gt;msgs;
 	int num = drv_data-&gt;num_msgs;
 
<span class="p_del">-	return false;</span>
<span class="p_del">-</span>
 	if (!drv_data-&gt;offload_enabled)
 		return false;
 
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">index 4002e6410444..c472477f9a7d 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_chunk">@@ -149,8 +149,6 @@</span> <span class="p_context"></span>
 #define ST_ACCEL_4_BDU_MASK			0x40
 #define ST_ACCEL_4_DRDY_IRQ_ADDR		0x21
 #define ST_ACCEL_4_DRDY_IRQ_INT1_MASK		0x04
<span class="p_del">-#define ST_ACCEL_4_IG1_EN_ADDR			0x21</span>
<span class="p_del">-#define ST_ACCEL_4_IG1_EN_MASK			0x08</span>
 #define ST_ACCEL_4_MULTIREAD_BIT		true
 
 /* CUSTOM VALUES FOR SENSOR 5 */
<span class="p_chunk">@@ -484,10 +482,6 @@</span> <span class="p_context"> static const struct st_sensor_settings st_accel_sensors_settings[] = {</span>
 		.drdy_irq = {
 			.addr = ST_ACCEL_4_DRDY_IRQ_ADDR,
 			.mask_int1 = ST_ACCEL_4_DRDY_IRQ_INT1_MASK,
<span class="p_del">-			.ig1 = {</span>
<span class="p_del">-				.en_addr = ST_ACCEL_4_IG1_EN_ADDR,</span>
<span class="p_del">-				.en_mask = ST_ACCEL_4_IG1_EN_MASK,</span>
<span class="p_del">-			},</span>
 		},
 		.multi_read_bit = ST_ACCEL_4_MULTIREAD_BIT,
 		.bootime = 2, /* guess */
<span class="p_header">diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c</span>
<span class="p_header">index 3a972ebf3c0d..8be73524aabd 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cm.c</span>
<span class="p_chunk">@@ -873,6 +873,11 @@</span> <span class="p_context"> retest:</span>
 	case IB_CM_SIDR_REQ_RCVD:
 		spin_unlock_irq(&amp;cm_id_priv-&gt;lock);
 		cm_reject_sidr_req(cm_id_priv, IB_SIDR_REJECT);
<span class="p_add">+		spin_lock_irq(&amp;cm.lock);</span>
<span class="p_add">+		if (!RB_EMPTY_NODE(&amp;cm_id_priv-&gt;sidr_id_node))</span>
<span class="p_add">+			rb_erase(&amp;cm_id_priv-&gt;sidr_id_node,</span>
<span class="p_add">+				 &amp;cm.remote_sidr_table);</span>
<span class="p_add">+		spin_unlock_irq(&amp;cm.lock);</span>
 		break;
 	case IB_CM_REQ_SENT:
 	case IB_CM_MRA_REQ_RCVD:
<span class="p_chunk">@@ -3112,7 +3117,10 @@</span> <span class="p_context"> int ib_send_cm_sidr_rep(struct ib_cm_id *cm_id,</span>
 	spin_unlock_irqrestore(&amp;cm_id_priv-&gt;lock, flags);
 
 	spin_lock_irqsave(&amp;cm.lock, flags);
<span class="p_del">-	rb_erase(&amp;cm_id_priv-&gt;sidr_id_node, &amp;cm.remote_sidr_table);</span>
<span class="p_add">+	if (!RB_EMPTY_NODE(&amp;cm_id_priv-&gt;sidr_id_node)) {</span>
<span class="p_add">+		rb_erase(&amp;cm_id_priv-&gt;sidr_id_node, &amp;cm.remote_sidr_table);</span>
<span class="p_add">+		RB_CLEAR_NODE(&amp;cm_id_priv-&gt;sidr_id_node);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;cm.lock, flags);
 	return 0;
 
<span class="p_header">diff --git a/drivers/input/mouse/alps.c b/drivers/input/mouse/alps.c</span>
<span class="p_header">index 4d246861d692..41e6cb501e6a 100644</span>
<span class="p_header">--- a/drivers/input/mouse/alps.c</span>
<span class="p_header">+++ b/drivers/input/mouse/alps.c</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> static const struct alps_nibble_commands alps_v6_nibble_commands[] = {</span>
 #define ALPS_FOUR_BUTTONS	0x40	/* 4 direction button present */
 #define ALPS_PS2_INTERLEAVED	0x80	/* 3-byte PS/2 packet interleaved with
 					   6-byte ALPS packet */
<span class="p_del">-#define ALPS_DELL		0x100	/* device is a Dell laptop */</span>
<span class="p_add">+#define ALPS_STICK_BITS		0x100	/* separate stick button bits */</span>
 #define ALPS_BUTTONPAD		0x200	/* device is a clickpad */
 
 static const struct alps_model_info alps_model_data[] = {
<span class="p_chunk">@@ -159,6 +159,43 @@</span> <span class="p_context"> static const struct alps_protocol_info alps_v8_protocol_data = {</span>
 	ALPS_PROTO_V8, 0x18, 0x18, 0
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Some v2 models report the stick buttons in separate bits</span>
<span class="p_add">+ */</span>
<span class="p_add">+static const struct dmi_system_id alps_dmi_has_separate_stick_buttons[] = {</span>
<span class="p_add">+#if defined(CONFIG_DMI) &amp;&amp; defined(CONFIG_X86)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Extrapolated from other entries */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D420&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Reported-by: Hans de Bruin &lt;jmdebruin@xmsnet.nl&gt; */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D430&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Reported-by: Hans de Goede &lt;hdegoede@redhat.com&gt; */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D620&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		/* Extrapolated from other entries */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;Dell Inc.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;Latitude D630&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void alps_set_abs_params_st(struct alps_data *priv,
 				   struct input_dev *dev1);
 static void alps_set_abs_params_semi_mt(struct alps_data *priv,
<span class="p_chunk">@@ -253,9 +290,8 @@</span> <span class="p_context"> static void alps_process_packet_v1_v2(struct psmouse *psmouse)</span>
 		return;
 	}
 
<span class="p_del">-	/* Dell non interleaved V2 dualpoint has separate stick button bits */</span>
<span class="p_del">-	if (priv-&gt;proto_version == ALPS_PROTO_V2 &amp;&amp;</span>
<span class="p_del">-	    priv-&gt;flags == (ALPS_DELL | ALPS_PASS | ALPS_DUALPOINT)) {</span>
<span class="p_add">+	/* Some models have separate stick button bits */</span>
<span class="p_add">+	if (priv-&gt;flags &amp; ALPS_STICK_BITS) {</span>
 		left |= packet[0] &amp; 1;
 		right |= packet[0] &amp; 2;
 		middle |= packet[0] &amp; 4;
<span class="p_chunk">@@ -2552,8 +2588,6 @@</span> <span class="p_context"> static int alps_set_protocol(struct psmouse *psmouse,</span>
 	priv-&gt;byte0 = protocol-&gt;byte0;
 	priv-&gt;mask0 = protocol-&gt;mask0;
 	priv-&gt;flags = protocol-&gt;flags;
<span class="p_del">-	if (dmi_name_in_vendors(&quot;Dell&quot;))</span>
<span class="p_del">-		priv-&gt;flags |= ALPS_DELL;</span>
 
 	priv-&gt;x_max = 2000;
 	priv-&gt;y_max = 1400;
<span class="p_chunk">@@ -2568,6 +2602,8 @@</span> <span class="p_context"> static int alps_set_protocol(struct psmouse *psmouse,</span>
 		priv-&gt;set_abs_params = alps_set_abs_params_st;
 		priv-&gt;x_max = 1023;
 		priv-&gt;y_max = 767;
<span class="p_add">+		if (dmi_check_system(alps_dmi_has_separate_stick_buttons))</span>
<span class="p_add">+			priv-&gt;flags |= ALPS_STICK_BITS;</span>
 		break;
 
 	case ALPS_PROTO_V3:
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 658ee39e6569..1b10e5fd6ef6 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1974,8 +1974,8 @@</span> <span class="p_context"> static void set_dte_entry(u16 devid, struct protection_domain *domain, bool ats)</span>
 static void clear_dte_entry(u16 devid)
 {
 	/* remove entry from the device table seen by the hardware */
<span class="p_del">-	amd_iommu_dev_table[devid].data[0] = IOMMU_PTE_P | IOMMU_PTE_TV;</span>
<span class="p_del">-	amd_iommu_dev_table[devid].data[1] = 0;</span>
<span class="p_add">+	amd_iommu_dev_table[devid].data[0]  = IOMMU_PTE_P | IOMMU_PTE_TV;</span>
<span class="p_add">+	amd_iommu_dev_table[devid].data[1] &amp;= DTE_FLAG_MASK;</span>
 
 	amd_iommu_apply_erratum_63(devid);
 }
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_types.h b/drivers/iommu/amd_iommu_types.h</span>
<span class="p_header">index f65908841be0..c9b64722f623 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_types.h</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_types.h</span>
<span class="p_chunk">@@ -295,6 +295,7 @@</span> <span class="p_context"></span>
 #define IOMMU_PTE_IR (1ULL &lt;&lt; 61)
 #define IOMMU_PTE_IW (1ULL &lt;&lt; 62)
 
<span class="p_add">+#define DTE_FLAG_MASK	(0x3ffULL &lt;&lt; 32)</span>
 #define DTE_FLAG_IOTLB	(0x01UL &lt;&lt; 32)
 #define DTE_FLAG_GV	(0x01ULL &lt;&lt; 55)
 #define DTE_GLX_SHIFT	(56)
<span class="p_header">diff --git a/drivers/iommu/amd_iommu_v2.c b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">index f7b875bb70d4..c3b8a5b9f035 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu_v2.c</span>
<span class="p_chunk">@@ -516,6 +516,13 @@</span> <span class="p_context"> static void do_fault(struct work_struct *work)</span>
 		goto out;
 	}
 
<span class="p_add">+	if (!(vma-&gt;vm_flags &amp; (VM_READ | VM_EXEC | VM_WRITE))) {</span>
<span class="p_add">+		/* handle_mm_fault would BUG_ON() */</span>
<span class="p_add">+		up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+		handle_fault_error(fault);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ret = handle_mm_fault(mm, vma, address, write);
 	if (ret &amp; VM_FAULT_ERROR) {
 		/* failed to service fault */
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 7553cb90627f..bd1b8ad8af44 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2109,15 +2109,19 @@</span> <span class="p_context"> static int __domain_mapping(struct dmar_domain *domain, unsigned long iov_pfn,</span>
 				return -ENOMEM;
 			/* It is large page*/
 			if (largepage_lvl &gt; 1) {
<span class="p_add">+				unsigned long nr_superpages, end_pfn;</span>
<span class="p_add">+</span>
 				pteval |= DMA_PTE_LARGE_PAGE;
 				lvl_pages = lvl_to_nr_pages(largepage_lvl);
<span class="p_add">+</span>
<span class="p_add">+				nr_superpages = sg_res / lvl_pages;</span>
<span class="p_add">+				end_pfn = iov_pfn + nr_superpages * lvl_pages - 1;</span>
<span class="p_add">+</span>
 				/*
 				 * Ensure that old small page tables are
<span class="p_del">-				 * removed to make room for superpage,</span>
<span class="p_del">-				 * if they exist.</span>
<span class="p_add">+				 * removed to make room for superpage(s).</span>
 				 */
<span class="p_del">-				dma_pte_free_pagetable(domain, iov_pfn,</span>
<span class="p_del">-						       iov_pfn + lvl_pages - 1);</span>
<span class="p_add">+				dma_pte_free_pagetable(domain, iov_pfn, end_pfn);</span>
 			} else {
 				pteval &amp;= ~(uint64_t)DMA_PTE_LARGE_PAGE;
 			}
<span class="p_header">diff --git a/drivers/irqchip/irq-tegra.c b/drivers/irqchip/irq-tegra.c</span>
<span class="p_header">index f67bbd80433e..ab5353a96a82 100644</span>
<span class="p_header">--- a/drivers/irqchip/irq-tegra.c</span>
<span class="p_header">+++ b/drivers/irqchip/irq-tegra.c</span>
<span class="p_chunk">@@ -215,6 +215,7 @@</span> <span class="p_context"> static struct irq_chip tegra_ictlr_chip = {</span>
 	.irq_unmask		= tegra_unmask,
 	.irq_retrigger		= tegra_retrigger,
 	.irq_set_wake		= tegra_set_wake,
<span class="p_add">+	.irq_set_type		= irq_chip_set_type_parent,</span>
 	.flags			= IRQCHIP_MASK_ON_SUSPEND,
 #ifdef CONFIG_SMP
 	.irq_set_affinity	= irq_chip_set_affinity_parent,
<span class="p_header">diff --git a/drivers/md/dm-cache-metadata.c b/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">index 20cc36b01b77..0a17d1b91a81 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-metadata.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-metadata.c</span>
<span class="p_chunk">@@ -634,10 +634,10 @@</span> <span class="p_context"> static int __commit_transaction(struct dm_cache_metadata *cmd,</span>
 
 	disk_super = dm_block_data(sblock);
 
<span class="p_add">+	disk_super-&gt;flags = cpu_to_le32(cmd-&gt;flags);</span>
 	if (mutator)
 		update_flags(disk_super, mutator);
 
<span class="p_del">-	disk_super-&gt;flags = cpu_to_le32(cmd-&gt;flags);</span>
 	disk_super-&gt;mapping_root = cpu_to_le64(cmd-&gt;root);
 	disk_super-&gt;hint_root = cpu_to_le64(cmd-&gt;hint_root);
 	disk_super-&gt;discard_root = cpu_to_le64(cmd-&gt;discard_root);
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index e25f00f0138a..95e7b72a164a 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -8030,8 +8030,7 @@</span> <span class="p_context"> static int remove_and_add_spares(struct mddev *mddev,</span>
 		       !test_bit(Bitmap_sync, &amp;rdev-&gt;flags)))
 			continue;
 
<span class="p_del">-		if (rdev-&gt;saved_raid_disk &lt; 0)</span>
<span class="p_del">-			rdev-&gt;recovery_offset = 0;</span>
<span class="p_add">+		rdev-&gt;recovery_offset = 0;</span>
 		if (mddev-&gt;pers-&gt;
 		    hot_add_disk(mddev, rdev) == 0) {
 			if (sysfs_link_rdev(mddev, rdev))
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index 4222f774cf36..1dac15d1697c 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -301,11 +301,16 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 {
 	int s;
 	uint32_t max_entries = le32_to_cpu(left-&gt;header.max_entries);
<span class="p_del">-	unsigned target = (nr_left + nr_center + nr_right) / 3;</span>
<span class="p_del">-	BUG_ON(target &gt; max_entries);</span>
<span class="p_add">+	unsigned total = nr_left + nr_center + nr_right;</span>
<span class="p_add">+	unsigned target_right = total / 3;</span>
<span class="p_add">+	unsigned remainder = (target_right * 3) != total;</span>
<span class="p_add">+	unsigned target_left = target_right + remainder;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUG_ON(target_left &gt; max_entries);</span>
<span class="p_add">+	BUG_ON(target_right &gt; max_entries);</span>
 
 	if (nr_left &lt; nr_right) {
<span class="p_del">-		s = nr_left - target;</span>
<span class="p_add">+		s = nr_left - target_left;</span>
 
 		if (s &lt; 0 &amp;&amp; nr_center &lt; -s) {
 			/* not enough in central node */
<span class="p_chunk">@@ -316,10 +321,10 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		} else
 			shift(left, center, s);
 
<span class="p_del">-		shift(center, right, target - nr_right);</span>
<span class="p_add">+		shift(center, right, target_right - nr_right);</span>
 
 	} else {
<span class="p_del">-		s = target - nr_right;</span>
<span class="p_add">+		s = target_right - nr_right;</span>
 		if (s &gt; 0 &amp;&amp; nr_center &lt; s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
<span class="p_chunk">@@ -329,7 +334,7 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		} else
 			shift(center, right, s);
 
<span class="p_del">-		shift(left, center, nr_left - target);</span>
<span class="p_add">+		shift(left, center, nr_left - target_left);</span>
 	}
 
 	*key_ptr(parent, c-&gt;index) = center-&gt;keys[0];
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index c7726cebc495..d6e47033b5e0 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -523,7 +523,7 @@</span> <span class="p_context"> static int btree_split_beneath(struct shadow_spine *s, uint64_t key)</span>
 
 	r = new_block(s-&gt;info, &amp;right);
 	if (r &lt; 0) {
<span class="p_del">-		/* FIXME: put left */</span>
<span class="p_add">+		unlock_block(s-&gt;info, left);</span>
 		return r;
 	}
 
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 967a4ed73929..d10d3008227e 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -2249,7 +2249,7 @@</span> <span class="p_context"> static int narrow_write_error(struct r1bio *r1_bio, int i)</span>
 		bio_trim(wbio, sector - r1_bio-&gt;sector, sectors);
 		wbio-&gt;bi_iter.bi_sector += rdev-&gt;data_offset;
 		wbio-&gt;bi_bdev = rdev-&gt;bdev;
<span class="p_del">-		if (submit_bio_wait(WRITE, wbio) == 0)</span>
<span class="p_add">+		if (submit_bio_wait(WRITE, wbio) &lt; 0)</span>
 			/* failure! */
 			ok = rdev_set_badblocks(rdev, sector,
 						sectors, 0)
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index 38c58e19cfce..d4b70d90de9c 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -2580,7 +2580,7 @@</span> <span class="p_context"> static int narrow_write_error(struct r10bio *r10_bio, int i)</span>
 				   choose_data_offset(r10_bio, rdev) +
 				   (sector - r10_bio-&gt;sector));
 		wbio-&gt;bi_bdev = rdev-&gt;bdev;
<span class="p_del">-		if (submit_bio_wait(WRITE, wbio) == 0)</span>
<span class="p_add">+		if (submit_bio_wait(WRITE, wbio) &lt; 0)</span>
 			/* Failure! */
 			ok = rdev_set_badblocks(rdev, sector,
 						sectors, 0)
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index f757023fc458..0d4f7b1b7f73 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -3505,6 +3505,7 @@</span> <span class="p_context"> returnbi:</span>
 		}
 	if (!discard_pending &amp;&amp;
 	    test_bit(R5_Discard, &amp;sh-&gt;dev[sh-&gt;pd_idx].flags)) {
<span class="p_add">+		int hash;</span>
 		clear_bit(R5_Discard, &amp;sh-&gt;dev[sh-&gt;pd_idx].flags);
 		clear_bit(R5_UPTODATE, &amp;sh-&gt;dev[sh-&gt;pd_idx].flags);
 		if (sh-&gt;qd_idx &gt;= 0) {
<span class="p_chunk">@@ -3518,16 +3519,17 @@</span> <span class="p_context"> returnbi:</span>
 		 * no updated data, so remove it from hash list and the stripe
 		 * will be reinitialized
 		 */
<span class="p_del">-		spin_lock_irq(&amp;conf-&gt;device_lock);</span>
 unhash:
<span class="p_add">+		hash = sh-&gt;hash_lock_index;</span>
<span class="p_add">+		spin_lock_irq(conf-&gt;hash_locks + hash);</span>
 		remove_hash(sh);
<span class="p_add">+		spin_unlock_irq(conf-&gt;hash_locks + hash);</span>
 		if (head_sh-&gt;batch_head) {
 			sh = list_first_entry(&amp;sh-&gt;batch_list,
 					      struct stripe_head, batch_list);
 			if (sh != head_sh)
 					goto unhash;
 		}
<span class="p_del">-		spin_unlock_irq(&amp;conf-&gt;device_lock);</span>
 		sh = head_sh;
 
 		if (test_bit(STRIPE_SYNC_REQUESTED, &amp;sh-&gt;state))
<span class="p_header">diff --git a/drivers/media/dvb-frontends/m88ds3103.c b/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_header">index e9b2d2b69b1d..377fb6991ab3 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_chunk">@@ -18,6 +18,27 @@</span> <span class="p_context"></span>
 
 static struct dvb_frontend_ops m88ds3103_ops;
 
<span class="p_add">+/* write single register with mask */</span>
<span class="p_add">+static int m88ds3103_update_bits(struct m88ds3103_dev *dev,</span>
<span class="p_add">+				u8 reg, u8 mask, u8 val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	u8 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* no need for read if whole reg is written */</span>
<span class="p_add">+	if (mask != 0xff) {</span>
<span class="p_add">+		ret = regmap_bulk_read(dev-&gt;regmap, reg, &amp;tmp, 1);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		val &amp;= mask;</span>
<span class="p_add">+		tmp &amp;= ~mask;</span>
<span class="p_add">+		val |= tmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return regmap_bulk_write(dev-&gt;regmap, reg, &amp;val, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* write reg val table using reg addr auto increment */
 static int m88ds3103_wr_reg_val_tab(struct m88ds3103_dev *dev,
 		const struct m88ds3103_reg_val *tab, int tab_len)
<span class="p_chunk">@@ -394,10 +415,10 @@</span> <span class="p_context"> static int m88ds3103_set_frontend(struct dvb_frontend *fe)</span>
 			u8tmp2 = 0x00; /* 0b00 */
 			break;
 		}
<span class="p_del">-		ret = regmap_update_bits(dev-&gt;regmap, 0x22, 0xc0, u8tmp1 &lt;&lt; 6);</span>
<span class="p_add">+		ret = m88ds3103_update_bits(dev, 0x22, 0xc0, u8tmp1 &lt;&lt; 6);</span>
 		if (ret)
 			goto err;
<span class="p_del">-		ret = regmap_update_bits(dev-&gt;regmap, 0x24, 0xc0, u8tmp2 &lt;&lt; 6);</span>
<span class="p_add">+		ret = m88ds3103_update_bits(dev, 0x24, 0xc0, u8tmp2 &lt;&lt; 6);</span>
 		if (ret)
 			goto err;
 	}
<span class="p_chunk">@@ -455,13 +476,13 @@</span> <span class="p_context"> static int m88ds3103_set_frontend(struct dvb_frontend *fe)</span>
 			if (ret)
 				goto err;
 		}
<span class="p_del">-		ret = regmap_update_bits(dev-&gt;regmap, 0x9d, 0x08, 0x08);</span>
<span class="p_add">+		ret = m88ds3103_update_bits(dev, 0x9d, 0x08, 0x08);</span>
 		if (ret)
 			goto err;
 		ret = regmap_write(dev-&gt;regmap, 0xf1, 0x01);
 		if (ret)
 			goto err;
<span class="p_del">-		ret = regmap_update_bits(dev-&gt;regmap, 0x30, 0x80, 0x80);</span>
<span class="p_add">+		ret = m88ds3103_update_bits(dev, 0x30, 0x80, 0x80);</span>
 		if (ret)
 			goto err;
 	}
<span class="p_chunk">@@ -498,7 +519,7 @@</span> <span class="p_context"> static int m88ds3103_set_frontend(struct dvb_frontend *fe)</span>
 	switch (dev-&gt;cfg-&gt;ts_mode) {
 	case M88DS3103_TS_SERIAL:
 	case M88DS3103_TS_SERIAL_D7:
<span class="p_del">-		ret = regmap_update_bits(dev-&gt;regmap, 0x29, 0x20, u8tmp1);</span>
<span class="p_add">+		ret = m88ds3103_update_bits(dev, 0x29, 0x20, u8tmp1);</span>
 		if (ret)
 			goto err;
 		u8tmp1 = 0;
<span class="p_chunk">@@ -567,11 +588,11 @@</span> <span class="p_context"> static int m88ds3103_set_frontend(struct dvb_frontend *fe)</span>
 	if (ret)
 		goto err;
 
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x4d, 0x02, dev-&gt;cfg-&gt;spec_inv &lt;&lt; 1);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x4d, 0x02, dev-&gt;cfg-&gt;spec_inv &lt;&lt; 1);</span>
 	if (ret)
 		goto err;
 
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x30, 0x10, dev-&gt;cfg-&gt;agc_inv &lt;&lt; 4);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x30, 0x10, dev-&gt;cfg-&gt;agc_inv &lt;&lt; 4);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -625,13 +646,13 @@</span> <span class="p_context"> static int m88ds3103_init(struct dvb_frontend *fe)</span>
 	dev-&gt;warm = false;
 
 	/* wake up device from sleep */
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x08, 0x01, 0x01);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x01);</span>
 	if (ret)
 		goto err;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x04, 0x01, 0x00);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x00);</span>
 	if (ret)
 		goto err;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x23, 0x10, 0x00);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x00);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -749,18 +770,18 @@</span> <span class="p_context"> static int m88ds3103_sleep(struct dvb_frontend *fe)</span>
 		utmp = 0x29;
 	else
 		utmp = 0x27;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, utmp, 0x01, 0x00);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, utmp, 0x01, 0x00);</span>
 	if (ret)
 		goto err;
 
 	/* sleep */
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x08, 0x01, 0x00);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x00);</span>
 	if (ret)
 		goto err;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x04, 0x01, 0x01);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x01);</span>
 	if (ret)
 		goto err;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x23, 0x10, 0x10);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x10);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -992,12 +1013,12 @@</span> <span class="p_context"> static int m88ds3103_set_tone(struct dvb_frontend *fe,</span>
 	}
 
 	utmp = tone &lt;&lt; 7 | dev-&gt;cfg-&gt;envelope_mode &lt;&lt; 5;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0xa2, 0xe0, utmp);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);</span>
 	if (ret)
 		goto err;
 
 	utmp = 1 &lt;&lt; 2;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0xa1, reg_a1_mask, utmp);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0xa1, reg_a1_mask, utmp);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -1047,7 +1068,7 @@</span> <span class="p_context"> static int m88ds3103_set_voltage(struct dvb_frontend *fe,</span>
 	voltage_dis ^= dev-&gt;cfg-&gt;lnb_en_pol;
 
 	utmp = voltage_dis &lt;&lt; 1 | voltage_sel &lt;&lt; 0;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0xa2, 0x03, utmp);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0xa2, 0x03, utmp);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -1080,7 +1101,7 @@</span> <span class="p_context"> static int m88ds3103_diseqc_send_master_cmd(struct dvb_frontend *fe,</span>
 	}
 
 	utmp = dev-&gt;cfg-&gt;envelope_mode &lt;&lt; 5;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0xa2, 0xe0, utmp);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -1115,12 +1136,12 @@</span> <span class="p_context"> static int m88ds3103_diseqc_send_master_cmd(struct dvb_frontend *fe,</span>
 	} else {
 		dev_dbg(&amp;client-&gt;dev, &quot;diseqc tx timeout\n&quot;);
 
<span class="p_del">-		ret = regmap_update_bits(dev-&gt;regmap, 0xa1, 0xc0, 0x40);</span>
<span class="p_add">+		ret = m88ds3103_update_bits(dev, 0xa1, 0xc0, 0x40);</span>
 		if (ret)
 			goto err;
 	}
 
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0xa2, 0xc0, 0x80);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0xa2, 0xc0, 0x80);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -1152,7 +1173,7 @@</span> <span class="p_context"> static int m88ds3103_diseqc_send_burst(struct dvb_frontend *fe,</span>
 	}
 
 	utmp = dev-&gt;cfg-&gt;envelope_mode &lt;&lt; 5;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0xa2, 0xe0, utmp);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0xa2, 0xe0, utmp);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -1194,12 +1215,12 @@</span> <span class="p_context"> static int m88ds3103_diseqc_send_burst(struct dvb_frontend *fe,</span>
 	} else {
 		dev_dbg(&amp;client-&gt;dev, &quot;diseqc tx timeout\n&quot;);
 
<span class="p_del">-		ret = regmap_update_bits(dev-&gt;regmap, 0xa1, 0xc0, 0x40);</span>
<span class="p_add">+		ret = m88ds3103_update_bits(dev, 0xa1, 0xc0, 0x40);</span>
 		if (ret)
 			goto err;
 	}
 
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0xa2, 0xc0, 0x80);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0xa2, 0xc0, 0x80);</span>
 	if (ret)
 		goto err;
 
<span class="p_chunk">@@ -1435,13 +1456,13 @@</span> <span class="p_context"> static int m88ds3103_probe(struct i2c_client *client,</span>
 		goto err_kfree;
 
 	/* sleep */
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x08, 0x01, 0x00);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x08, 0x01, 0x00);</span>
 	if (ret)
 		goto err_kfree;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x04, 0x01, 0x01);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x04, 0x01, 0x01);</span>
 	if (ret)
 		goto err_kfree;
<span class="p_del">-	ret = regmap_update_bits(dev-&gt;regmap, 0x23, 0x10, 0x10);</span>
<span class="p_add">+	ret = m88ds3103_update_bits(dev, 0x23, 0x10, 0x10);</span>
 	if (ret)
 		goto err_kfree;
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/si2168.c b/drivers/media/dvb-frontends/si2168.c</span>
<span class="p_header">index 25e238c370e5..cb6a49b8c1ce 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/si2168.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/si2168.c</span>
<span class="p_chunk">@@ -502,6 +502,10 @@</span> <span class="p_context"> static int si2168_init(struct dvb_frontend *fe)</span>
 		/* firmware is in the new format */
 		for (remaining = fw-&gt;size; remaining &gt; 0; remaining -= 17) {
 			len = fw-&gt;data[fw-&gt;size - remaining];
<span class="p_add">+			if (len &gt; SI2168_ARGLEN) {</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			memcpy(cmd.args, &amp;fw-&gt;data[(fw-&gt;size - remaining) + 1], len);
 			cmd.wlen = len;
 			cmd.rlen = 1;
<span class="p_header">diff --git a/drivers/media/tuners/si2157.c b/drivers/media/tuners/si2157.c</span>
<span class="p_header">index a6245ef379c4..416c865eb595 100644</span>
<span class="p_header">--- a/drivers/media/tuners/si2157.c</span>
<span class="p_header">+++ b/drivers/media/tuners/si2157.c</span>
<span class="p_chunk">@@ -166,6 +166,10 @@</span> <span class="p_context"> static int si2157_init(struct dvb_frontend *fe)</span>
 
 	for (remaining = fw-&gt;size; remaining &gt; 0; remaining -= 17) {
 		len = fw-&gt;data[fw-&gt;size - remaining];
<span class="p_add">+		if (len &gt; SI2157_ARGLEN) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev, &quot;Bad firmware length\n&quot;);</span>
<span class="p_add">+			goto err_release_firmware;</span>
<span class="p_add">+		}</span>
 		memcpy(cmd.args, &amp;fw-&gt;data[(fw-&gt;size - remaining) + 1], len);
 		cmd.wlen = len;
 		cmd.rlen = 1;
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c</span>
<span class="p_header">index c3cac4c12fb3..197a4f2e54d2 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb-v2/rtl28xxu.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb-v2/rtl28xxu.c</span>
<span class="p_chunk">@@ -34,6 +34,14 @@</span> <span class="p_context"> static int rtl28xxu_ctrl_msg(struct dvb_usb_device *d, struct rtl28xxu_req *req)</span>
 	unsigned int pipe;
 	u8 requesttype;
 
<span class="p_add">+	mutex_lock(&amp;d-&gt;usb_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (req-&gt;size &gt; sizeof(dev-&gt;buf)) {</span>
<span class="p_add">+		dev_err(&amp;d-&gt;intf-&gt;dev, &quot;too large message %u\n&quot;, req-&gt;size);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto err_mutex_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (req-&gt;index &amp; CMD_WR_FLAG) {
 		/* write */
 		memcpy(dev-&gt;buf, req-&gt;data, req-&gt;size);
<span class="p_chunk">@@ -50,14 +58,17 @@</span> <span class="p_context"> static int rtl28xxu_ctrl_msg(struct dvb_usb_device *d, struct rtl28xxu_req *req)</span>
 	dvb_usb_dbg_usb_control_msg(d-&gt;udev, 0, requesttype, req-&gt;value,
 			req-&gt;index, dev-&gt;buf, req-&gt;size);
 	if (ret &lt; 0)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto err_mutex_unlock;</span>
 
 	/* read request, copy returned data to return buf */
 	if (requesttype == (USB_TYPE_VENDOR | USB_DIR_IN))
 		memcpy(req-&gt;data, dev-&gt;buf, req-&gt;size);
 
<span class="p_add">+	mutex_unlock(&amp;d-&gt;usb_mutex);</span>
<span class="p_add">+</span>
 	return 0;
<span class="p_del">-err:</span>
<span class="p_add">+err_mutex_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;d-&gt;usb_mutex);</span>
 	dev_dbg(&amp;d-&gt;intf-&gt;dev, &quot;failed=%d\n&quot;, ret);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb-v2/rtl28xxu.h b/drivers/media/usb/dvb-usb-v2/rtl28xxu.h</span>
<span class="p_header">index 9f6115a2ee01..138062960a73 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb-v2/rtl28xxu.h</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb-v2/rtl28xxu.h</span>
<span class="p_chunk">@@ -71,7 +71,7 @@</span> <span class="p_context"></span>
 
 
 struct rtl28xxu_dev {
<span class="p_del">-	u8 buf[28];</span>
<span class="p_add">+	u8 buf[128];</span>
 	u8 chip_id;
 	u8 tuner;
 	char *tuner_name;
<span class="p_header">diff --git a/drivers/mmc/card/mmc_test.c b/drivers/mmc/card/mmc_test.c</span>
<span class="p_header">index b78cf5d403a3..7fc9174d4619 100644</span>
<span class="p_header">--- a/drivers/mmc/card/mmc_test.c</span>
<span class="p_header">+++ b/drivers/mmc/card/mmc_test.c</span>
<span class="p_chunk">@@ -2263,15 +2263,12 @@</span> <span class="p_context"> static int mmc_test_profile_sglen_r_nonblock_perf(struct mmc_test_card *test)</span>
 /*
  * eMMC hardware reset.
  */
<span class="p_del">-static int mmc_test_hw_reset(struct mmc_test_card *test)</span>
<span class="p_add">+static int mmc_test_reset(struct mmc_test_card *test)</span>
 {
 	struct mmc_card *card = test-&gt;card;
 	struct mmc_host *host = card-&gt;host;
 	int err;
 
<span class="p_del">-	if (!mmc_card_mmc(card) || !mmc_can_reset(card))</span>
<span class="p_del">-		return RESULT_UNSUP_CARD;</span>
<span class="p_del">-</span>
 	err = mmc_hw_reset(host);
 	if (!err)
 		return RESULT_OK;
<span class="p_chunk">@@ -2605,8 +2602,8 @@</span> <span class="p_context"> static const struct mmc_test_case mmc_test_cases[] = {</span>
 	},
 
 	{
<span class="p_del">-		.name = &quot;eMMC hardware reset&quot;,</span>
<span class="p_del">-		.run = mmc_test_hw_reset,</span>
<span class="p_add">+		.name = &quot;Reset test&quot;,</span>
<span class="p_add">+		.run = mmc_test_reset,</span>
 	},
 };
 
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index e726903170a8..f6cd995dbe92 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -1924,7 +1924,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(mmc_can_reset);</span>
 static int mmc_reset(struct mmc_host *host)
 {
 	struct mmc_card *card = host-&gt;card;
<span class="p_del">-	u32 status;</span>
 
 	if (!(host-&gt;caps &amp; MMC_CAP_HW_RESET) || !host-&gt;ops-&gt;hw_reset)
 		return -EOPNOTSUPP;
<span class="p_chunk">@@ -1937,12 +1936,6 @@</span> <span class="p_context"> static int mmc_reset(struct mmc_host *host)</span>
 
 	host-&gt;ops-&gt;hw_reset(host);
 
<span class="p_del">-	/* If the reset has happened, then a status command will fail */</span>
<span class="p_del">-	if (!mmc_send_status(card, &amp;status)) {</span>
<span class="p_del">-		mmc_host_clk_release(host);</span>
<span class="p_del">-		return -ENOSYS;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* Set initial state and call mmc_set_ios */
 	mmc_set_initial_state(host);
 	mmc_host_clk_release(host);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">index eff0e5325e6a..bfddc9efd6cc 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_chunk">@@ -874,6 +874,7 @@</span> <span class="p_context"> static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)</span>
 	hw-&gt;max_rate_tries = 10;
 	hw-&gt;sta_data_size = sizeof(struct ath_node);
 	hw-&gt;vif_data_size = sizeof(struct ath_vif);
<span class="p_add">+	hw-&gt;extra_tx_headroom = 4;</span>
 
 	hw-&gt;wiphy-&gt;available_antennas_rx = BIT(ah-&gt;caps.max_rxchains) - 1;
 	hw-&gt;wiphy-&gt;available_antennas_tx = BIT(ah-&gt;caps.max_txchains) - 1;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/dvm/lib.c b/drivers/net/wireless/iwlwifi/dvm/lib.c</span>
<span class="p_header">index 1d2223df5cb0..e7d3566c714b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/dvm/lib.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/dvm/lib.c</span>
<span class="p_chunk">@@ -1022,7 +1022,7 @@</span> <span class="p_context"> static void iwlagn_wowlan_program_keys(struct ieee80211_hw *hw,</span>
 			u8 *pn = seq.ccmp.pn;
 
 			ieee80211_get_key_rx_seq(key, i, &amp;seq);
<span class="p_del">-			aes_sc-&gt;pn = cpu_to_le64(</span>
<span class="p_add">+			aes_sc[i].pn = cpu_to_le64(</span>
 					(u64)pn[5] |
 					((u64)pn[4] &lt;&lt; 8) |
 					((u64)pn[3] &lt;&lt; 16) |
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/iwl-7000.c b/drivers/net/wireless/iwlwifi/iwl-7000.c</span>
<span class="p_header">index cc35f796d406..d7acbd147bd1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/iwl-7000.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/iwl-7000.c</span>
<span class="p_chunk">@@ -348,6 +348,6 @@</span> <span class="p_context"> const struct iwl_cfg iwl7265d_n_cfg = {</span>
 };
 
 MODULE_FIRMWARE(IWL7260_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
<span class="p_del">-MODULE_FIRMWARE(IWL3160_MODULE_FIRMWARE(IWL3160_UCODE_API_OK));</span>
<span class="p_add">+MODULE_FIRMWARE(IWL3160_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));</span>
 MODULE_FIRMWARE(IWL7265_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
 MODULE_FIRMWARE(IWL7265D_MODULE_FIRMWARE(IWL7260_UCODE_API_OK));
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/d3.c b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">index 4165d104e4c3..f60b89baab7a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/d3.c</span>
<span class="p_chunk">@@ -274,18 +274,13 @@</span> <span class="p_context"> static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,</span>
 		break;
 	case WLAN_CIPHER_SUITE_CCMP:
 		if (sta) {
<span class="p_del">-			u8 *pn = seq.ccmp.pn;</span>
<span class="p_add">+			u64 pn64;</span>
 
 			aes_sc = data-&gt;rsc_tsc-&gt;all_tsc_rsc.aes.unicast_rsc;
 			aes_tx_sc = &amp;data-&gt;rsc_tsc-&gt;all_tsc_rsc.aes.tsc;
 
<span class="p_del">-			ieee80211_get_key_tx_seq(key, &amp;seq);</span>
<span class="p_del">-			aes_tx_sc-&gt;pn = cpu_to_le64((u64)pn[5] |</span>
<span class="p_del">-						    ((u64)pn[4] &lt;&lt; 8) |</span>
<span class="p_del">-						    ((u64)pn[3] &lt;&lt; 16) |</span>
<span class="p_del">-						    ((u64)pn[2] &lt;&lt; 24) |</span>
<span class="p_del">-						    ((u64)pn[1] &lt;&lt; 32) |</span>
<span class="p_del">-						    ((u64)pn[0] &lt;&lt; 40));</span>
<span class="p_add">+			pn64 = atomic64_read(&amp;key-&gt;tx_pn);</span>
<span class="p_add">+			aes_tx_sc-&gt;pn = cpu_to_le64(pn64);</span>
 		} else {
 			aes_sc = data-&gt;rsc_tsc-&gt;all_tsc_rsc.aes.multicast_rsc;
 		}
<span class="p_chunk">@@ -298,12 +293,12 @@</span> <span class="p_context"> static void iwl_mvm_wowlan_program_keys(struct ieee80211_hw *hw,</span>
 			u8 *pn = seq.ccmp.pn;
 
 			ieee80211_get_key_rx_seq(key, i, &amp;seq);
<span class="p_del">-			aes_sc-&gt;pn = cpu_to_le64((u64)pn[5] |</span>
<span class="p_del">-						 ((u64)pn[4] &lt;&lt; 8) |</span>
<span class="p_del">-						 ((u64)pn[3] &lt;&lt; 16) |</span>
<span class="p_del">-						 ((u64)pn[2] &lt;&lt; 24) |</span>
<span class="p_del">-						 ((u64)pn[1] &lt;&lt; 32) |</span>
<span class="p_del">-						 ((u64)pn[0] &lt;&lt; 40));</span>
<span class="p_add">+			aes_sc[i].pn = cpu_to_le64((u64)pn[5] |</span>
<span class="p_add">+						   ((u64)pn[4] &lt;&lt; 8) |</span>
<span class="p_add">+						   ((u64)pn[3] &lt;&lt; 16) |</span>
<span class="p_add">+						   ((u64)pn[2] &lt;&lt; 24) |</span>
<span class="p_add">+						   ((u64)pn[1] &lt;&lt; 32) |</span>
<span class="p_add">+						   ((u64)pn[0] &lt;&lt; 40));</span>
 		}
 		data-&gt;use_rsc_tsc = true;
 		break;
<span class="p_chunk">@@ -1446,15 +1441,15 @@</span> <span class="p_context"> static void iwl_mvm_d3_update_gtks(struct ieee80211_hw *hw,</span>
 
 		switch (key-&gt;cipher) {
 		case WLAN_CIPHER_SUITE_CCMP:
<span class="p_del">-			iwl_mvm_aes_sc_to_seq(&amp;sc-&gt;aes.tsc, &amp;seq);</span>
 			iwl_mvm_set_aes_rx_seq(sc-&gt;aes.unicast_rsc, key);
<span class="p_add">+			atomic64_set(&amp;key-&gt;tx_pn, le64_to_cpu(sc-&gt;aes.tsc.pn));</span>
 			break;
 		case WLAN_CIPHER_SUITE_TKIP:
 			iwl_mvm_tkip_sc_to_seq(&amp;sc-&gt;tkip.tsc, &amp;seq);
 			iwl_mvm_set_tkip_rx_seq(sc-&gt;tkip.unicast_rsc, key);
<span class="p_add">+			ieee80211_set_key_tx_seq(key, &amp;seq);</span>
 			break;
 		}
<span class="p_del">-		ieee80211_set_key_tx_seq(key, &amp;seq);</span>
 
 		/* that&#39;s it for this key */
 		return;
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/fw.c b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">index eb10c5ee4a14..b49367e1cfd2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/fw.c</span>
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)</span>
 	 * abort after reading the nvm in case RF Kill is on, we will complete
 	 * the init seq later when RF kill will switch to off
 	 */
<span class="p_del">-	if (iwl_mvm_is_radio_killed(mvm)) {</span>
<span class="p_add">+	if (iwl_mvm_is_radio_hw_killed(mvm)) {</span>
 		IWL_DEBUG_RF_KILL(mvm,
 				  &quot;jump over all phy activities due to RF kill\n&quot;);
 		iwl_remove_notification(&amp;mvm-&gt;notif_wait, &amp;calib_wait);
<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> int iwl_run_init_mvm_ucode(struct iwl_mvm *mvm, bool read_nvm)</span>
 	ret = iwl_wait_notification(&amp;mvm-&gt;notif_wait, &amp;calib_wait,
 			MVM_UCODE_CALIB_TIMEOUT);
 
<span class="p_del">-	if (ret &amp;&amp; iwl_mvm_is_radio_killed(mvm)) {</span>
<span class="p_add">+	if (ret &amp;&amp; iwl_mvm_is_radio_hw_killed(mvm)) {</span>
 		IWL_DEBUG_RF_KILL(mvm, &quot;RFKILL while calibrating.\n&quot;);
 		ret = 1;
 	}
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index dfdab38e2d4a..f82019c0c4c0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -2373,6 +2373,7 @@</span> <span class="p_context"> static void iwl_mvm_stop_ap_ibss(struct ieee80211_hw *hw,</span>
 		iwl_mvm_remove_time_event(mvm, mvmvif,
 					  &amp;mvmvif-&gt;time_event_data);
 		RCU_INIT_POINTER(mvm-&gt;csa_vif, NULL);
<span class="p_add">+		mvmvif-&gt;csa_countdown = false;</span>
 	}
 
 	if (rcu_access_pointer(mvm-&gt;csa_tx_blocked_vif) == vif) {
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mvm.h b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">index 2d4bad5fe825..4a6f1627ae43 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_chunk">@@ -848,6 +848,11 @@</span> <span class="p_context"> static inline bool iwl_mvm_is_radio_killed(struct iwl_mvm *mvm)</span>
 	       test_bit(IWL_MVM_STATUS_HW_CTKILL, &amp;mvm-&gt;status);
 }
 
<span class="p_add">+static inline bool iwl_mvm_is_radio_hw_killed(struct iwl_mvm *mvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return test_bit(IWL_MVM_STATUS_HW_RFKILL, &amp;mvm-&gt;status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Must be called with rcu_read_lock() held and it can only be
  * released when mvmsta is not needed anymore.
  */
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/ops.c b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">index e4fa50075ffd..61c2b0ad5db7 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/ops.c</span>
<span class="p_chunk">@@ -582,6 +582,7 @@</span> <span class="p_context"> iwl_op_mode_mvm_start(struct iwl_trans *trans, const struct iwl_cfg *cfg,</span>
 	ieee80211_unregister_hw(mvm-&gt;hw);
 	iwl_mvm_leds_exit(mvm);
  out_free:
<span class="p_add">+	flush_delayed_work(&amp;mvm-&gt;fw_dump_wk);</span>
 	iwl_phy_db_free(mvm-&gt;phy_db);
 	kfree(mvm-&gt;scan_cmd);
 	if (!cfg-&gt;no_power_up_nic_in_init || !mvm-&gt;nvm_file_name)
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/drv.c b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">index 9f65c1cff1b1..865d578dee82 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_chunk">@@ -414,6 +414,11 @@</span> <span class="p_context"> static const struct pci_device_id iwl_hw_card_ids[] = {</span>
 	{IWL_PCI_DEVICE(0x095A, 0x5590, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095B, 0x5290, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x5490, iwl7265_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x5F10, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x5212, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095B, 0x520A, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x9000, iwl7265_2ac_cfg)},</span>
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x9400, iwl7265_2ac_cfg)},</span>
 
 /* 8000 Series */
 	{IWL_PCI_DEVICE(0x24F3, 0x0010, iwl8260_2ac_cfg)},
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/pci.h b/drivers/net/wireless/rtlwifi/pci.h</span>
<span class="p_header">index d4567d12e07e..5da6703942d9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/pci.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/pci.h</span>
<span class="p_chunk">@@ -247,6 +247,8 @@</span> <span class="p_context"> struct rtl_pci {</span>
 	/* MSI support */
 	bool msi_support;
 	bool using_msi;
<span class="p_add">+	/* interrupt clear before set */</span>
<span class="p_add">+	bool int_clear;</span>
 };
 
 struct mp_adapter {
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index b7f18e2155eb..6e9418ed90c2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -2253,11 +2253,28 @@</span> <span class="p_context"> void rtl8821ae_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_add">+static void rtl8821ae_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_add">+	u32 tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_add">+</span>
<span class="p_add">+	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_add">+	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_add">+	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_add">+	if (!rtlpci-&gt;int_clear)</span>
<span class="p_add">+		rtl8821ae_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_add">+</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">index a4988121e1ab..8ee141a55bc5 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/sw.c</span>
<span class="p_chunk">@@ -96,6 +96,7 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 
 	rtl8821ae_bt_reg_init(hw);
 	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;
<span class="p_add">+	rtlpci-&gt;int_clear = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
 	rtlpriv-&gt;btcoexist.btc_ops = rtl_btc_get_ops_pointer();
 
 	rtlpriv-&gt;dm.dm_initialgain_enable = 1;
<span class="p_chunk">@@ -167,6 +168,7 @@</span> <span class="p_context"> int rtl8821ae_init_sw_vars(struct ieee80211_hw *hw)</span>
 	rtlpriv-&gt;psc.swctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;swctrl_lps;
 	rtlpriv-&gt;psc.fwctrl_lps = rtlpriv-&gt;cfg-&gt;mod_params-&gt;fwctrl_lps;
 	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;msi_support;
<span class="p_add">+	rtlpci-&gt;msi_support = rtlpriv-&gt;cfg-&gt;mod_params-&gt;int_clear;</span>
 	if (rtlpriv-&gt;cfg-&gt;mod_params-&gt;disable_watchdog)
 		pr_info(&quot;watchdog disabled\n&quot;);
 	rtlpriv-&gt;psc.reg_fwctrl_lps = 3;
<span class="p_chunk">@@ -308,6 +310,7 @@</span> <span class="p_context"> static struct rtl_mod_params rtl8821ae_mod_params = {</span>
 	.swctrl_lps = false,
 	.fwctrl_lps = true,
 	.msi_support = true,
<span class="p_add">+	.int_clear = true,</span>
 	.debug = DBG_EMERG,
 	.disable_watchdog = 0,
 };
<span class="p_chunk">@@ -437,6 +440,7 @@</span> <span class="p_context"> module_param_named(fwlps, rtl8821ae_mod_params.fwctrl_lps, bool, 0444);</span>
 module_param_named(msi, rtl8821ae_mod_params.msi_support, bool, 0444);
 module_param_named(disable_watchdog, rtl8821ae_mod_params.disable_watchdog,
 		   bool, 0444);
<span class="p_add">+module_param_named(int_clear, rtl8821ae_mod_params.int_clear, bool, 0444);</span>
 MODULE_PARM_DESC(swenc, &quot;Set to 1 for software crypto (default 0)\n&quot;);
 MODULE_PARM_DESC(ips, &quot;Set to 0 to not use link power save (default 1)\n&quot;);
 MODULE_PARM_DESC(swlps, &quot;Set to 1 to use SW control power save (default 0)\n&quot;);
<span class="p_chunk">@@ -444,6 +448,7 @@</span> <span class="p_context"> MODULE_PARM_DESC(fwlps, &quot;Set to 1 to use FW control power save (default 1)\n&quot;);</span>
 MODULE_PARM_DESC(msi, &quot;Set to 1 to use MSI interrupts mode (default 1)\n&quot;);
 MODULE_PARM_DESC(debug, &quot;Set debug level (0-5) (default 0)&quot;);
 MODULE_PARM_DESC(disable_watchdog, &quot;Set to 1 to disable the watchdog (default 0)\n&quot;);
<span class="p_add">+MODULE_PARM_DESC(int_clear, &quot;Set to 1 to disable interrupt clear before set (default 0)\n&quot;);</span>
 
 static SIMPLE_DEV_PM_OPS(rtlwifi_pm_ops, rtl_pci_suspend, rtl_pci_resume);
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/wifi.h b/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_header">index 2b770b5e2620..0a3570aa6651 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/wifi.h</span>
<span class="p_chunk">@@ -2234,6 +2234,9 @@</span> <span class="p_context"> struct rtl_mod_params {</span>
 
 	/* default 0: 1 means disable */
 	bool disable_watchdog;
<span class="p_add">+</span>
<span class="p_add">+	/* default 0: 1 means do not disable interrupts */</span>
<span class="p_add">+	bool int_clear;</span>
 };
 
 struct rtl_hal_usbint_cfg {
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index 312f23a8429c..92618686604c 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -216,7 +216,7 @@</span> <span class="p_context"> static ssize_t numa_node_store(struct device *dev,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	if (!node_online(node))</span>
<span class="p_add">+	if (node &gt;= MAX_NUMNODES || !node_online(node))</span>
 		return -EINVAL;
 
 	add_taint(TAINT_FIRMWARE_WORKAROUND, LOCKDEP_STILL_OK);
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-baytrail.c b/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_header">index 2062c224e32f..b2602210784d 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-baytrail.c</span>
<span class="p_chunk">@@ -146,7 +146,7 @@</span> <span class="p_context"> struct byt_gpio_pin_context {</span>
 struct byt_gpio {
 	struct gpio_chip		chip;
 	struct platform_device		*pdev;
<span class="p_del">-	spinlock_t			lock;</span>
<span class="p_add">+	raw_spinlock_t			lock;</span>
 	void __iomem			*reg_base;
 	struct pinctrl_gpio_range	*range;
 	struct byt_gpio_pin_context	*saved_context;
<span class="p_chunk">@@ -174,11 +174,11 @@</span> <span class="p_context"> static void byt_gpio_clear_triggering(struct byt_gpio *vg, unsigned offset)</span>
 	unsigned long flags;
 	u32 value;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 	value = readl(reg);
 	value &amp;= ~(BYT_TRIG_POS | BYT_TRIG_NEG | BYT_TRIG_LVL);
 	writel(value, reg);
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static u32 byt_get_gpio_mux(struct byt_gpio *vg, unsigned offset)
<span class="p_chunk">@@ -201,6 +201,9 @@</span> <span class="p_context"> static int byt_gpio_request(struct gpio_chip *chip, unsigned offset)</span>
 	struct byt_gpio *vg = to_byt_gpio(chip);
 	void __iomem *reg = byt_gpio_reg(chip, offset, BYT_CONF0_REG);
 	u32 value, gpio_mux;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	/*
 	 * In most cases, func pin mux 000 means GPIO function.
<span class="p_chunk">@@ -214,18 +217,16 @@</span> <span class="p_context"> static int byt_gpio_request(struct gpio_chip *chip, unsigned offset)</span>
 	value = readl(reg) &amp; BYT_PIN_MUX;
 	gpio_mux = byt_get_gpio_mux(vg, offset);
 	if (WARN_ON(gpio_mux != value)) {
<span class="p_del">-		unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 		value = readl(reg) &amp; ~BYT_PIN_MUX;
 		value |= gpio_mux;
 		writel(value, reg);
<span class="p_del">-		spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 		dev_warn(&amp;vg-&gt;pdev-&gt;dev,
 			 &quot;pin %u forcibly re-configured as GPIO\n&quot;, offset);
 	}
 
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	pm_runtime_get(&amp;vg-&gt;pdev-&gt;dev);
 
 	return 0;
<span class="p_chunk">@@ -250,7 +251,7 @@</span> <span class="p_context"> static int byt_irq_type(struct irq_data *d, unsigned type)</span>
 	if (offset &gt;= vg-&gt;chip.ngpio)
 		return -EINVAL;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 	value = readl(reg);
 
 	WARN(value &amp; BYT_DIRECT_IRQ_EN,
<span class="p_chunk">@@ -269,7 +270,7 @@</span> <span class="p_context"> static int byt_irq_type(struct irq_data *d, unsigned type)</span>
 	else if (type &amp; IRQ_TYPE_LEVEL_MASK)
 		__irq_set_handler_locked(d-&gt;irq, handle_level_irq);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -277,7 +278,15 @@</span> <span class="p_context"> static int byt_irq_type(struct irq_data *d, unsigned type)</span>
 static int byt_gpio_get(struct gpio_chip *chip, unsigned offset)
 {
 	void __iomem *reg = byt_gpio_reg(chip, offset, BYT_VAL_REG);
<span class="p_del">-	return readl(reg) &amp; BYT_LEVEL;</span>
<span class="p_add">+	struct byt_gpio *vg = to_byt_gpio(chip);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	val = readl(reg);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return val &amp; BYT_LEVEL;</span>
 }
 
 static void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)
<span class="p_chunk">@@ -287,7 +296,7 @@</span> <span class="p_context"> static void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	unsigned long flags;
 	u32 old_val;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	old_val = readl(reg);
 
<span class="p_chunk">@@ -296,7 +305,7 @@</span> <span class="p_context"> static void byt_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	else
 		writel(old_val &amp; ~BYT_LEVEL, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static int byt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)
<span class="p_chunk">@@ -306,13 +315,13 @@</span> <span class="p_context"> static int byt_gpio_direction_input(struct gpio_chip *chip, unsigned offset)</span>
 	unsigned long flags;
 	u32 value;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	value = readl(reg) | BYT_DIR_MASK;
 	value &amp;= ~BYT_INPUT_EN;		/* active low */
 	writel(value, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -326,7 +335,7 @@</span> <span class="p_context"> static int byt_gpio_direction_output(struct gpio_chip *chip,</span>
 	unsigned long flags;
 	u32 reg_val;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 
 	/*
 	 * Before making any direction modifications, do a check if gpio
<span class="p_chunk">@@ -345,7 +354,7 @@</span> <span class="p_context"> static int byt_gpio_direction_output(struct gpio_chip *chip,</span>
 	else
 		writel(reg_val &amp; ~BYT_LEVEL, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -354,18 +363,19 @@</span> <span class="p_context"> static void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)</span>
 {
 	struct byt_gpio *vg = to_byt_gpio(chip);
 	int i;
<span class="p_del">-	unsigned long flags;</span>
 	u32 conf0, val, offs;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; vg-&gt;chip.ngpio; i++) {
 		const char *pull_str = NULL;
 		const char *pull = NULL;
<span class="p_add">+		unsigned long flags;</span>
 		const char *label;
 		offs = vg-&gt;range-&gt;pins[i] * 16;
<span class="p_add">+</span>
<span class="p_add">+		raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 		conf0 = readl(vg-&gt;reg_base + offs + BYT_CONF0_REG);
 		val = readl(vg-&gt;reg_base + offs + BYT_VAL_REG);
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 
 		label = gpiochip_is_requested(chip, i);
 		if (!label)
<span class="p_chunk">@@ -418,7 +428,6 @@</span> <span class="p_context"> static void byt_gpio_dbg_show(struct seq_file *s, struct gpio_chip *chip)</span>
 
 		seq_puts(s, &quot;\n&quot;);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static void byt_gpio_irq_handler(unsigned irq, struct irq_desc *desc)
<span class="p_chunk">@@ -450,8 +459,10 @@</span> <span class="p_context"> static void byt_irq_ack(struct irq_data *d)</span>
 	unsigned offset = irqd_to_hwirq(d);
 	void __iomem *reg;
 
<span class="p_add">+	raw_spin_lock(&amp;vg-&gt;lock);</span>
 	reg = byt_gpio_reg(&amp;vg-&gt;chip, offset, BYT_INT_STAT_REG);
 	writel(BIT(offset % 32), reg);
<span class="p_add">+	raw_spin_unlock(&amp;vg-&gt;lock);</span>
 }
 
 static void byt_irq_unmask(struct irq_data *d)
<span class="p_chunk">@@ -463,9 +474,9 @@</span> <span class="p_context"> static void byt_irq_unmask(struct irq_data *d)</span>
 	void __iomem *reg;
 	u32 value;
 
<span class="p_del">-	spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
<span class="p_del">-</span>
 	reg = byt_gpio_reg(&amp;vg-&gt;chip, offset, BYT_CONF0_REG);
<span class="p_add">+</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;vg-&gt;lock, flags);</span>
 	value = readl(reg);
 
 	switch (irqd_get_trigger_type(d)) {
<span class="p_chunk">@@ -486,7 +497,7 @@</span> <span class="p_context"> static void byt_irq_unmask(struct irq_data *d)</span>
 
 	writel(value, reg);
 
<span class="p_del">-	spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;vg-&gt;lock, flags);</span>
 }
 
 static void byt_irq_mask(struct irq_data *d)
<span class="p_chunk">@@ -578,7 +589,7 @@</span> <span class="p_context"> static int byt_gpio_probe(struct platform_device *pdev)</span>
 	if (IS_ERR(vg-&gt;reg_base))
 		return PTR_ERR(vg-&gt;reg_base);
 
<span class="p_del">-	spin_lock_init(&amp;vg-&gt;lock);</span>
<span class="p_add">+	raw_spin_lock_init(&amp;vg-&gt;lock);</span>
 
 	gc = &amp;vg-&gt;chip;
 	gc-&gt;label = dev_name(&amp;pdev-&gt;dev);
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index 454536c49315..9c780740fb82 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -887,6 +887,8 @@</span> <span class="p_context"> static void mvs_slot_free(struct mvs_info *mvi, u32 rx_desc)</span>
 static void mvs_slot_task_free(struct mvs_info *mvi, struct sas_task *task,
 			  struct mvs_slot_info *slot, u32 slot_idx)
 {
<span class="p_add">+	if (!slot)</span>
<span class="p_add">+		return;</span>
 	if (!slot-&gt;task)
 		return;
 	if (!sas_protocol_ata(task-&gt;task_proto))
<span class="p_header">diff --git a/drivers/staging/iio/accel/sca3000_ring.c b/drivers/staging/iio/accel/sca3000_ring.c</span>
<span class="p_header">index 23685e74917e..bd2c69f85949 100644</span>
<span class="p_header">--- a/drivers/staging/iio/accel/sca3000_ring.c</span>
<span class="p_header">+++ b/drivers/staging/iio/accel/sca3000_ring.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> static int sca3000_read_first_n_hw_rb(struct iio_buffer *r,</span>
 	if (ret)
 		goto error_ret;
 
<span class="p_del">-	for (i = 0; i &lt; num_read; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; num_read / sizeof(u16); i++)</span>
 		*(((u16 *)rx) + i) = be16_to_cpup((__be16 *)rx + i);
 
 	if (copy_to_user(buf, rx, num_read))
<span class="p_header">diff --git a/drivers/staging/iio/adc/mxs-lradc.c b/drivers/staging/iio/adc/mxs-lradc.c</span>
<span class="p_header">index d7c5223f1c3e..2931ea9b75d1 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/mxs-lradc.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/mxs-lradc.c</span>
<span class="p_chunk">@@ -919,11 +919,12 @@</span> <span class="p_context"> static int mxs_lradc_read_raw(struct iio_dev *iio_dev,</span>
 	case IIO_CHAN_INFO_OFFSET:
 		if (chan-&gt;type == IIO_TEMP) {
 			/* The calculated value from the ADC is in Kelvin, we
<span class="p_del">-			 * want Celsius for hwmon so the offset is</span>
<span class="p_del">-			 * -272.15 * scale</span>
<span class="p_add">+			 * want Celsius for hwmon so the offset is -273.15</span>
<span class="p_add">+			 * The offset is applied before scaling so it is</span>
<span class="p_add">+			 * actually -213.15 * 4 / 1.012 = -1079.644268</span>
 			 */
<span class="p_del">-			*val = -1075;</span>
<span class="p_del">-			*val2 = 691699;</span>
<span class="p_add">+			*val = -1079;</span>
<span class="p_add">+			*val2 = 644268;</span>
 
 			return IIO_VAL_INT_PLUS_MICRO;
 		}
<span class="p_header">diff --git a/drivers/thermal/samsung/exynos_tmu.c b/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_header">index c96ff10b869e..af68d06fd193 100644</span>
<span class="p_header">--- a/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_header">+++ b/drivers/thermal/samsung/exynos_tmu.c</span>
<span class="p_chunk">@@ -933,7 +933,7 @@</span> <span class="p_context"> static void exynos4412_tmu_set_emulation(struct exynos_tmu_data *data,</span>
 
 	if (data-&gt;soc == SOC_ARCH_EXYNOS5260)
 		emul_con = EXYNOS5260_EMUL_CON;
<span class="p_del">-	if (data-&gt;soc == SOC_ARCH_EXYNOS5433)</span>
<span class="p_add">+	else if (data-&gt;soc == SOC_ARCH_EXYNOS5433)</span>
 		emul_con = EXYNOS5433_TMU_EMUL_CON;
 	else if (data-&gt;soc == SOC_ARCH_EXYNOS7)
 		emul_con = EXYNOS7_TMU_REG_EMUL_CON;
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_dma.c b/drivers/tty/serial/8250/8250_dma.c</span>
<span class="p_header">index 21d01a491405..e508939daea3 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_dma.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_dma.c</span>
<span class="p_chunk">@@ -80,10 +80,6 @@</span> <span class="p_context"> int serial8250_tx_dma(struct uart_8250_port *p)</span>
 		return 0;
 
 	dma-&gt;tx_size = CIRC_CNT_TO_END(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);
<span class="p_del">-	if (dma-&gt;tx_size &lt; p-&gt;port.fifosize) {</span>
<span class="p_del">-		ret = -EINVAL;</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-	}</span>
 
 	desc = dmaengine_prep_slave_single(dma-&gt;txchan,
 					   dma-&gt;tx_addr + xmit-&gt;tail,
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c79d33676672..c47d3e480586 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -147,6 +147,7 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		pdev-&gt;device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
<span class="p_add">+		xhci-&gt;quirks |= XHCI_SPURIOUS_WAKEUP;</span>
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
 		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI ||
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 8aadf3def901..63041c1e5a9f 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2239,6 +2239,7 @@</span> <span class="p_context"> static int handle_tx_event(struct xhci_hcd *xhci,</span>
 	u32 trb_comp_code;
 	int ret = 0;
 	int td_num = 0;
<span class="p_add">+	bool handling_skipped_tds = false;</span>
 
 	slot_id = TRB_TO_SLOT_ID(le32_to_cpu(event-&gt;flags));
 	xdev = xhci-&gt;devs[slot_id];
<span class="p_chunk">@@ -2372,6 +2373,10 @@</span> <span class="p_context"> static int handle_tx_event(struct xhci_hcd *xhci,</span>
 		ep-&gt;skip = true;
 		xhci_dbg(xhci, &quot;Miss service interval error, set skip flag\n&quot;);
 		goto cleanup;
<span class="p_add">+	case COMP_PING_ERR:</span>
<span class="p_add">+		ep-&gt;skip = true;</span>
<span class="p_add">+		xhci_dbg(xhci, &quot;No Ping response error, Skip one Isoc TD\n&quot;);</span>
<span class="p_add">+		goto cleanup;</span>
 	default:
 		if (xhci_is_vendor_info_code(xhci, trb_comp_code)) {
 			status = 0;
<span class="p_chunk">@@ -2508,13 +2513,18 @@</span> <span class="p_context"> static int handle_tx_event(struct xhci_hcd *xhci,</span>
 						 ep, &amp;status);
 
 cleanup:
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+		handling_skipped_tds = ep-&gt;skip &amp;&amp;</span>
<span class="p_add">+			trb_comp_code != COMP_MISSED_INT &amp;&amp;</span>
<span class="p_add">+			trb_comp_code != COMP_PING_ERR;</span>
<span class="p_add">+</span>
 		/*
<span class="p_del">-		 * Do not update event ring dequeue pointer if ep-&gt;skip is set.</span>
<span class="p_del">-		 * Will roll back to continue process missed tds.</span>
<span class="p_add">+		 * Do not update event ring dequeue pointer if we&#39;re in a loop</span>
<span class="p_add">+		 * processing missed tds.</span>
 		 */
<span class="p_del">-		if (trb_comp_code == COMP_MISSED_INT || !ep-&gt;skip) {</span>
<span class="p_add">+		if (!handling_skipped_tds)</span>
 			inc_deq(xhci, xhci-&gt;event_ring);
<span class="p_del">-		}</span>
 
 		if (ret) {
 			urb = td-&gt;urb;
<span class="p_chunk">@@ -2549,7 +2559,7 @@</span> <span class="p_context"> cleanup:</span>
 	 * Process them as short transfer until reach the td pointed by
 	 * the event.
 	 */
<span class="p_del">-	} while (ep-&gt;skip &amp;&amp; trb_comp_code != COMP_MISSED_INT);</span>
<span class="p_add">+	} while (handling_skipped_tds);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/serial/qcserial.c b/drivers/usb/serial/qcserial.c</span>
<span class="p_header">index ebcec8cda858..f49d262e926b 100644</span>
<span class="p_header">--- a/drivers/usb/serial/qcserial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/qcserial.c</span>
<span class="p_chunk">@@ -153,6 +153,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{DEVICE_SWI(0x1199, 0x9056)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9060)},	/* Sierra Wireless Modem */
 	{DEVICE_SWI(0x1199, 0x9061)},	/* Sierra Wireless Modem */
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9070)},	/* Sierra Wireless MC74xx/EM74xx */</span>
<span class="p_add">+	{DEVICE_SWI(0x1199, 0x9071)},	/* Sierra Wireless MC74xx/EM74xx */</span>
 	{DEVICE_SWI(0x413c, 0x81a2)},	/* Dell Wireless 5806 Gobi(TM) 4G LTE Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a3)},	/* Dell Wireless 5570 HSPA+ (42Mbps) Mobile Broadband Card */
 	{DEVICE_SWI(0x413c, 0x81a4)},	/* Dell Wireless 5570e HSPA+ (42Mbps) Mobile Broadband Card */
<span class="p_header">diff --git a/drivers/video/console/fbcon.c b/drivers/video/console/fbcon.c</span>
<span class="p_header">index 1aaf89300621..92f394927f24 100644</span>
<span class="p_header">--- a/drivers/video/console/fbcon.c</span>
<span class="p_header">+++ b/drivers/video/console/fbcon.c</span>
<span class="p_chunk">@@ -1093,6 +1093,7 @@</span> <span class="p_context"> static void fbcon_init(struct vc_data *vc, int init)</span>
 		con_copy_unimap(vc, svc);
 
 	ops = info-&gt;fbcon_par;
<span class="p_add">+	ops-&gt;cur_blink_jiffies = msecs_to_jiffies(vc-&gt;vc_cur_blink_ms);</span>
 	p-&gt;con_rotate = initial_rotation;
 	set_blitting_type(vc, info);
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index f490b6155091..641d3dc4f31e 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -4649,7 +4649,7 @@</span> <span class="p_context"> locked:</span>
 
 	if (bctl-&gt;flags &amp; ~(BTRFS_BALANCE_ARGS_MASK | BTRFS_BALANCE_TYPE_MASK)) {
 		ret = -EINVAL;
<span class="p_del">-		goto out_bargs;</span>
<span class="p_add">+		goto out_bctl;</span>
 	}
 
 do_balance:
<span class="p_chunk">@@ -4663,12 +4663,15 @@</span> <span class="p_context"> do_balance:</span>
 	need_unlock = false;
 
 	ret = btrfs_balance(bctl, bargs);
<span class="p_add">+	bctl = NULL;</span>
 
 	if (arg) {
 		if (copy_to_user(arg, bargs, sizeof(*bargs)))
 			ret = -EFAULT;
 	}
 
<span class="p_add">+out_bctl:</span>
<span class="p_add">+	kfree(bctl);</span>
 out_bargs:
 	kfree(bargs);
 out_unlock:
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 84d693d37428..871fcb67be97 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -81,11 +81,11 @@</span> <span class="p_context"> static int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)</span>
 	if (len == 0)
 		return 0;
 
<span class="p_del">-	old_file = ovl_path_open(old, O_RDONLY);</span>
<span class="p_add">+	old_file = ovl_path_open(old, O_LARGEFILE | O_RDONLY);</span>
 	if (IS_ERR(old_file))
 		return PTR_ERR(old_file);
 
<span class="p_del">-	new_file = ovl_path_open(new, O_WRONLY);</span>
<span class="p_add">+	new_file = ovl_path_open(new, O_LARGEFILE | O_WRONLY);</span>
 	if (IS_ERR(new_file)) {
 		error = PTR_ERR(new_file);
 		goto out_fput;
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> out:</span>
 
 out_cleanup:
 	ovl_cleanup(wdir, newdentry);
<span class="p_del">-	goto out;</span>
<span class="p_add">+	goto out2;</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c</span>
<span class="p_header">index d9da5a4e9382..ec0c2a050043 100644</span>
<span class="p_header">--- a/fs/overlayfs/inode.c</span>
<span class="p_header">+++ b/fs/overlayfs/inode.c</span>
<span class="p_chunk">@@ -363,6 +363,9 @@</span> <span class="p_context"> struct inode *ovl_d_select_inode(struct dentry *dentry, unsigned file_flags)</span>
 		ovl_path_upper(dentry, &amp;realpath);
 	}
 
<span class="p_add">+	if (realpath.dentry-&gt;d_flags &amp; DCACHE_OP_SELECT_INODE)</span>
<span class="p_add">+		return realpath.dentry-&gt;d_op-&gt;d_select_inode(realpath.dentry, file_flags);</span>
<span class="p_add">+</span>
 	return d_backing_inode(realpath.dentry);
 }
 
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index 79073d68b475..e38ee0fed24a 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -544,6 +544,7 @@</span> <span class="p_context"> static void ovl_put_super(struct super_block *sb)</span>
 	mntput(ufs-&gt;upper_mnt);
 	for (i = 0; i &lt; ufs-&gt;numlower; i++)
 		mntput(ufs-&gt;lower_mnt[i]);
<span class="p_add">+	kfree(ufs-&gt;lower_mnt);</span>
 
 	kfree(ufs-&gt;config.lowerdir);
 	kfree(ufs-&gt;config.upperdir);
<span class="p_chunk">@@ -1048,6 +1049,7 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 		oe-&gt;lowerstack[i].dentry = stack[i].dentry;
 		oe-&gt;lowerstack[i].mnt = ufs-&gt;lower_mnt[i];
 	}
<span class="p_add">+	kfree(stack);</span>
 
 	root_dentry-&gt;d_fsdata = oe;
 
<span class="p_header">diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h</span>
<span class="p_header">index 0fe9df983ab7..fe0ab983859b 100644</span>
<span class="p_header">--- a/include/linux/backing-dev.h</span>
<span class="p_header">+++ b/include/linux/backing-dev.h</span>
<span class="p_chunk">@@ -18,13 +18,17 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 
 int __must_check bdi_init(struct backing_dev_info *bdi);
<span class="p_del">-void bdi_destroy(struct backing_dev_info *bdi);</span>
<span class="p_add">+void bdi_exit(struct backing_dev_info *bdi);</span>
 
 __printf(3, 4)
 int bdi_register(struct backing_dev_info *bdi, struct device *parent,
 		const char *fmt, ...);
 int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev);
<span class="p_add">+void bdi_unregister(struct backing_dev_info *bdi);</span>
<span class="p_add">+</span>
 int __must_check bdi_setup_and_register(struct backing_dev_info *, char *);
<span class="p_add">+void bdi_destroy(struct backing_dev_info *bdi);</span>
<span class="p_add">+</span>
 void wb_start_writeback(struct bdi_writeback *wb, long nr_pages,
 			bool range_cyclic, enum wb_reason reason);
 void wb_start_background_writeback(struct bdi_writeback *wb);
<span class="p_header">diff --git a/include/linux/omap-dma.h b/include/linux/omap-dma.h</span>
<span class="p_header">index e5a70132a240..88fa8af2b937 100644</span>
<span class="p_header">--- a/include/linux/omap-dma.h</span>
<span class="p_header">+++ b/include/linux/omap-dma.h</span>
<span class="p_chunk">@@ -17,7 +17,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/platform_device.h&gt;
 
<span class="p_del">-#define INT_DMA_LCD			25</span>
<span class="p_add">+#define INT_DMA_LCD			(NR_IRQS_LEGACY + 25)</span>
 
 #define OMAP1_DMA_TOUT_IRQ		(1 &lt;&lt; 0)
 #define OMAP_DMA_DROP_IRQ		(1 &lt;&lt; 1)
<span class="p_header">diff --git a/include/sound/soc.h b/include/sound/soc.h</span>
<span class="p_header">index 93df8bf9d54a..334d0d292020 100644</span>
<span class="p_header">--- a/include/sound/soc.h</span>
<span class="p_header">+++ b/include/sound/soc.h</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"></span>
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
 	SNDRV_CTL_ELEM_ACCESS_READWRITE, \
 	.tlv.p  = (tlv_array),\
<span class="p_del">-	.info = snd_soc_info_volsw, \</span>
<span class="p_add">+	.info = snd_soc_info_volsw_sx, \</span>
 	.get = snd_soc_get_volsw_sx,\
 	.put = snd_soc_put_volsw_sx, \
 	.private_value = (unsigned long)&amp;(struct soc_mixer_control) \
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"></span>
 	.access = SNDRV_CTL_ELEM_ACCESS_TLV_READ | \
 	SNDRV_CTL_ELEM_ACCESS_READWRITE, \
 	.tlv.p  = (tlv_array), \
<span class="p_del">-	.info = snd_soc_info_volsw, \</span>
<span class="p_add">+	.info = snd_soc_info_volsw_sx, \</span>
 	.get = snd_soc_get_volsw_sx, \
 	.put = snd_soc_put_volsw_sx, \
 	.private_value = (unsigned long)&amp;(struct soc_mixer_control) \
<span class="p_chunk">@@ -573,6 +573,8 @@</span> <span class="p_context"> int snd_soc_put_enum_double(struct snd_kcontrol *kcontrol,</span>
 	struct snd_ctl_elem_value *ucontrol);
 int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_info *uinfo);
<span class="p_add">+int snd_soc_info_volsw_sx(struct snd_kcontrol *kcontrol,</span>
<span class="p_add">+			  struct snd_ctl_elem_info *uinfo);</span>
 #define snd_soc_info_bool_ext		snd_ctl_boolean_mono_info
 int snd_soc_get_volsw(struct snd_kcontrol *kcontrol,
 	struct snd_ctl_elem_value *ucontrol);
<span class="p_header">diff --git a/include/sound/wm8904.h b/include/sound/wm8904.h</span>
<span class="p_header">index 898be3a8db9a..6d8f8fba3341 100644</span>
<span class="p_header">--- a/include/sound/wm8904.h</span>
<span class="p_header">+++ b/include/sound/wm8904.h</span>
<span class="p_chunk">@@ -119,7 +119,7 @@</span> <span class="p_context"></span>
 #define WM8904_MIC_REGS  2
 #define WM8904_GPIO_REGS 4
 #define WM8904_DRC_REGS  4
<span class="p_del">-#define WM8904_EQ_REGS   25</span>
<span class="p_add">+#define WM8904_EQ_REGS   24</span>
 
 /**
  * DRC configurations are specified with a label and a set of register
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index b86b7bf1be38..8f051a106676 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -1063,11 +1063,15 @@</span> <span class="p_context"> void symbol_put_addr(void *addr)</span>
 	if (core_kernel_text(a))
 		return;
 
<span class="p_del">-	/* module_text_address is safe here: we&#39;re supposed to have reference</span>
<span class="p_del">-	 * to module from symbol_get, so it can&#39;t go away. */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Even though we hold a reference on the module; we still need to</span>
<span class="p_add">+	 * disable preemption in order to safely traverse the data structure.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
 	modaddr = __module_text_address(a);
 	BUG_ON(!modaddr);
 	module_put(modaddr);
<span class="p_add">+	preempt_enable();</span>
 }
 EXPORT_SYMBOL_GPL(symbol_put_addr);
 
<span class="p_header">diff --git a/kernel/sched/deadline.c b/kernel/sched/deadline.c</span>
<span class="p_header">index 0a17af35670a..da7f8266913b 100644</span>
<span class="p_header">--- a/kernel/sched/deadline.c</span>
<span class="p_header">+++ b/kernel/sched/deadline.c</span>
<span class="p_chunk">@@ -1066,8 +1066,9 @@</span> <span class="p_context"> select_task_rq_dl(struct task_struct *p, int cpu, int sd_flag, int flags)</span>
 		int target = find_later_rq(p);
 
 		if (target != -1 &amp;&amp;
<span class="p_del">-				dl_time_before(p-&gt;dl.deadline,</span>
<span class="p_del">-					cpu_rq(target)-&gt;dl.earliest_dl.curr))</span>
<span class="p_add">+				(dl_time_before(p-&gt;dl.deadline,</span>
<span class="p_add">+					cpu_rq(target)-&gt;dl.earliest_dl.curr) ||</span>
<span class="p_add">+				(cpu_rq(target)-&gt;dl.dl_nr_running == 0)))</span>
 			cpu = target;
 	}
 	rcu_read_unlock();
<span class="p_chunk">@@ -1417,7 +1418,8 @@</span> <span class="p_context"> static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)</span>
 
 		later_rq = cpu_rq(cpu);
 
<span class="p_del">-		if (!dl_time_before(task-&gt;dl.deadline,</span>
<span class="p_add">+		if (later_rq-&gt;dl.dl_nr_running &amp;&amp;</span>
<span class="p_add">+		    !dl_time_before(task-&gt;dl.deadline,</span>
 					later_rq-&gt;dl.earliest_dl.curr)) {
 			/*
 			 * Target rq has tasks of equal or earlier deadline,
<span class="p_header">diff --git a/kernel/trace/trace_stack.c b/kernel/trace/trace_stack.c</span>
<span class="p_header">index 3f34496244e9..96969012f242 100644</span>
<span class="p_header">--- a/kernel/trace/trace_stack.c</span>
<span class="p_header">+++ b/kernel/trace/trace_stack.c</span>
<span class="p_chunk">@@ -94,6 +94,12 @@</span> <span class="p_context"> check_stack(unsigned long ip, unsigned long *stack)</span>
 	local_irq_save(flags);
 	arch_spin_lock(&amp;max_stack_lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * RCU may not be watching, make it see us.</span>
<span class="p_add">+	 * The stack trace code uses rcu_sched.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rcu_irq_enter();</span>
<span class="p_add">+</span>
 	/* In case another CPU set the tracer_frame on us */
 	if (unlikely(!frame_size))
 		this_size -= tracer_frame;
<span class="p_chunk">@@ -174,6 +180,7 @@</span> <span class="p_context"> check_stack(unsigned long ip, unsigned long *stack)</span>
 	}
 
  out:
<span class="p_add">+	rcu_irq_exit();</span>
 	arch_spin_unlock(&amp;max_stack_lock);
 	local_irq_restore(flags);
 }
<span class="p_header">diff --git a/lib/fault-inject.c b/lib/fault-inject.c</span>
<span class="p_header">index f1cdeb024d17..6a823a53e357 100644</span>
<span class="p_header">--- a/lib/fault-inject.c</span>
<span class="p_header">+++ b/lib/fault-inject.c</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> static void fail_dump(struct fault_attr *attr)</span>
 		printk(KERN_NOTICE &quot;FAULT_INJECTION: forcing a failure.\n&quot;
 		       &quot;name %pd, interval %lu, probability %lu, &quot;
 		       &quot;space %d, times %d\n&quot;, attr-&gt;dname,
<span class="p_del">-		       attr-&gt;probability, attr-&gt;interval,</span>
<span class="p_add">+		       attr-&gt;interval, attr-&gt;probability,</span>
 		       atomic_read(&amp;attr-&gt;space),
 		       atomic_read(&amp;attr-&gt;times));
 		if (attr-&gt;verbose &gt; 1)
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index dac5bf59309d..dc07d8866d9a 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -823,7 +823,7 @@</span> <span class="p_context"> static void bdi_remove_from_list(struct backing_dev_info *bdi)</span>
 	synchronize_rcu_expedited();
 }
 
<span class="p_del">-void bdi_destroy(struct backing_dev_info *bdi)</span>
<span class="p_add">+void bdi_unregister(struct backing_dev_info *bdi)</span>
 {
 	/* make sure nobody finds us on the bdi_list anymore */
 	bdi_remove_from_list(bdi);
<span class="p_chunk">@@ -835,9 +835,19 @@</span> <span class="p_context"> void bdi_destroy(struct backing_dev_info *bdi)</span>
 		device_unregister(bdi-&gt;dev);
 		bdi-&gt;dev = NULL;
 	}
<span class="p_add">+}</span>
 
<span class="p_add">+void bdi_exit(struct backing_dev_info *bdi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	WARN_ON_ONCE(bdi-&gt;dev);</span>
 	wb_exit(&amp;bdi-&gt;wb);
 }
<span class="p_add">+</span>
<span class="p_add">+void bdi_destroy(struct backing_dev_info *bdi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bdi_unregister(bdi);</span>
<span class="p_add">+	bdi_exit(bdi);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(bdi_destroy);
 
 /*
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 1283fc825458..3fd68ee183c6 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -2488,6 +2488,11 @@</span> <span class="p_context"> again:</span>
 			break;
 		}
 
<span class="p_add">+		if (fatal_signal_pending(current)) {</span>
<span class="p_add">+			status = -EINTR;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		status = a_ops-&gt;write_begin(file, mapping, pos, bytes, flags,
 						&amp;page, &amp;fsdata);
 		if (unlikely(status &lt; 0))
<span class="p_chunk">@@ -2525,10 +2530,6 @@</span> <span class="p_context"> again:</span>
 		written += copied;
 
 		balance_dirty_pages_ratelimited(mapping);
<span class="p_del">-		if (fatal_signal_pending(current)) {</span>
<span class="p_del">-			status = -EINTR;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 	} while (iov_iter_count(i));
 
 	return written ? written : status;
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 097c7a4bfbd9..da0ac6a0445f 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -2132,7 +2132,8 @@</span> <span class="p_context"> static int __collapse_huge_page_isolate(struct vm_area_struct *vma,</span>
 	for (_pte = pte; _pte &lt; pte+HPAGE_PMD_NR;
 	     _pte++, address += PAGE_SIZE) {
 		pte_t pteval = *_pte;
<span class="p_del">-		if (pte_none(pteval) || is_zero_pfn(pte_pfn(pteval))) {</span>
<span class="p_add">+		if (pte_none(pteval) || (pte_present(pteval) &amp;&amp;</span>
<span class="p_add">+			is_zero_pfn(pte_pfn(pteval)))) {</span>
 			if (++none_or_zero &lt;= khugepaged_max_ptes_none)
 				continue;
 			else
<span class="p_header">diff --git a/net/mac80211/debugfs.c b/net/mac80211/debugfs.c</span>
<span class="p_header">index 3ea8b7de9633..58d9a8167dd2 100644</span>
<span class="p_header">--- a/net/mac80211/debugfs.c</span>
<span class="p_header">+++ b/net/mac80211/debugfs.c</span>
<span class="p_chunk">@@ -148,7 +148,7 @@</span> <span class="p_context"> static ssize_t hwflags_read(struct file *file, char __user *user_buf,</span>
 
 	for (i = 0; i &lt; NUM_IEEE80211_HW_FLAGS; i++) {
 		if (test_bit(i, local-&gt;hw.flags))
<span class="p_del">-			pos += scnprintf(pos, end - pos, &quot;%s&quot;,</span>
<span class="p_add">+			pos += scnprintf(pos, end - pos, &quot;%s\n&quot;,</span>
 					 hw_flag_names[i]);
 	}
 
<span class="p_header">diff --git a/net/netfilter/ipset/ip_set_list_set.c b/net/netfilter/ipset/ip_set_list_set.c</span>
<span class="p_header">index a1fe5377a2b3..5a30ce6e8c90 100644</span>
<span class="p_header">--- a/net/netfilter/ipset/ip_set_list_set.c</span>
<span class="p_header">+++ b/net/netfilter/ipset/ip_set_list_set.c</span>
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> list_set_uadd(struct ip_set *set, void *value, const struct ip_set_ext *ext,</span>
 	      ip_set_timeout_expired(ext_timeout(n, set))))
 		n =  NULL;
 
<span class="p_del">-	e = kzalloc(set-&gt;dsize, GFP_KERNEL);</span>
<span class="p_add">+	e = kzalloc(set-&gt;dsize, GFP_ATOMIC);</span>
 	if (!e)
 		return -ENOMEM;
 	e-&gt;id = d-&gt;id;
<span class="p_header">diff --git a/sound/hda/ext/hdac_ext_bus.c b/sound/hda/ext/hdac_ext_bus.c</span>
<span class="p_header">index 0aa5d9eb6c3f..d85aa1a75188 100644</span>
<span class="p_header">--- a/sound/hda/ext/hdac_ext_bus.c</span>
<span class="p_header">+++ b/sound/hda/ext/hdac_ext_bus.c</span>
<span class="p_chunk">@@ -19,6 +19,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/module.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
 #include &lt;sound/hdaudio_ext.h&gt;
 
 MODULE_DESCRIPTION(&quot;HDA extended core&quot;);
<span class="p_header">diff --git a/sound/pci/hda/hda_codec.c b/sound/pci/hda/hda_codec.c</span>
<span class="p_header">index d1a2cb65e27c..ca374462d7e5 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_codec.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_codec.c</span>
<span class="p_chunk">@@ -3438,10 +3438,8 @@</span> <span class="p_context"> int snd_hda_codec_build_pcms(struct hda_codec *codec)</span>
 	int dev, err;
 
 	err = snd_hda_codec_parse_pcms(codec);
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		snd_hda_codec_reset(codec);</span>
<span class="p_add">+	if (err &lt; 0)</span>
 		return err;
<span class="p_del">-	}</span>
 
 	/* attach a new PCM streams */
 	list_for_each_entry(cpcm, &amp;codec-&gt;pcm_list_head, list) {
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index ca03c40609fc..2f0ec7c45fc7 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -819,6 +819,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x21da, &quot;Lenovo X220&quot;, CXT_PINCFG_LENOVO_TP410),
 	SND_PCI_QUIRK(0x17aa, 0x21db, &quot;Lenovo X220-tablet&quot;, CXT_PINCFG_LENOVO_TP410),
 	SND_PCI_QUIRK(0x17aa, 0x38af, &quot;Lenovo IdeaPad Z560&quot;, CXT_FIXUP_MUTE_LED_EAPD),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x390b, &quot;Lenovo G50-80&quot;, CXT_FIXUP_STEREO_DMIC),</span>
 	SND_PCI_QUIRK(0x17aa, 0x3975, &quot;Lenovo U300s&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x3977, &quot;Lenovo IdeaPad U310&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x17aa, 0x397b, &quot;Lenovo S205&quot;, CXT_FIXUP_STEREO_DMIC),
<span class="p_header">diff --git a/sound/soc/soc-ops.c b/sound/soc/soc-ops.c</span>
<span class="p_header">index 100d92b5b77e..05977ae1ff2a 100644</span>
<span class="p_header">--- a/sound/soc/soc-ops.c</span>
<span class="p_header">+++ b/sound/soc/soc-ops.c</span>
<span class="p_chunk">@@ -207,6 +207,34 @@</span> <span class="p_context"> int snd_soc_info_volsw(struct snd_kcontrol *kcontrol,</span>
 EXPORT_SYMBOL_GPL(snd_soc_info_volsw);
 
 /**
<span class="p_add">+ * snd_soc_info_volsw_sx - Mixer info callback for SX TLV controls</span>
<span class="p_add">+ * @kcontrol: mixer control</span>
<span class="p_add">+ * @uinfo: control element information</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Callback to provide information about a single mixer control, or a double</span>
<span class="p_add">+ * mixer control that spans 2 registers of the SX TLV type. SX TLV controls</span>
<span class="p_add">+ * have a range that represents both positive and negative values either side</span>
<span class="p_add">+ * of zero but without a sign bit.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns 0 for success.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int snd_soc_info_volsw_sx(struct snd_kcontrol *kcontrol,</span>
<span class="p_add">+			  struct snd_ctl_elem_info *uinfo)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct soc_mixer_control *mc =</span>
<span class="p_add">+		(struct soc_mixer_control *)kcontrol-&gt;private_value;</span>
<span class="p_add">+</span>
<span class="p_add">+	snd_soc_info_volsw(kcontrol, uinfo);</span>
<span class="p_add">+	/* Max represents the number of levels in an SX control not the</span>
<span class="p_add">+	 * maximum value, so add the minimum value back on</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	uinfo-&gt;value.integer.max += mc-&gt;min;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(snd_soc_info_volsw_sx);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * snd_soc_get_volsw - single mixer get callback
  * @kcontrol: mixer control
  * @ucontrol: control element information
<span class="p_header">diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c</span>
<span class="p_header">index 21c14244f4c4..d7ea8e20dae4 100644</span>
<span class="p_header">--- a/virt/kvm/irqchip.c</span>
<span class="p_header">+++ b/virt/kvm/irqchip.c</span>
<span class="p_chunk">@@ -213,11 +213,15 @@</span> <span class="p_context"> int kvm_set_irq_routing(struct kvm *kvm,</span>
 			goto out;
 
 		r = -EINVAL;
<span class="p_del">-		if (ue-&gt;flags)</span>
<span class="p_add">+		if (ue-&gt;flags) {</span>
<span class="p_add">+			kfree(e);</span>
 			goto out;
<span class="p_add">+		}</span>
 		r = setup_routing_entry(new, e, ue);
<span class="p_del">-		if (r)</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			kfree(e);</span>
 			goto out;
<span class="p_add">+		}</span>
 		++ue;
 	}
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



