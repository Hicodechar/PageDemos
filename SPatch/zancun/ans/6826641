
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.16.y-ckt,stable] Linux 3.16.7-ckt15 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.16.y-ckt,stable] Linux 3.16.7-ckt15</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 20, 2015, 12:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1437394040-6263-2-git-send-email-luis.henriques@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6826641/mbox/"
   >mbox</a>
|
   <a href="/patch/6826641/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6826641/">/patch/6826641/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id C518F9F358
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Jul 2015 12:08:26 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id F0DD420570
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Jul 2015 12:08:09 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 3D26B203E9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 20 Jul 2015 12:07:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755543AbbGTMHv (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 20 Jul 2015 08:07:51 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:52588 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752813AbbGTMH0 (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 20 Jul 2015 08:07:26 -0400
Received: from av-217-129-142-138.netvisao.pt ([217.129.142.138]
	helo=localhost) by youngberry.canonical.com with esmtpsa
	(TLS1.0:RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;luis.henriques@canonical.com&gt;)
	id 1ZH9qs-0003zo-DH; Mon, 20 Jul 2015 12:07:22 +0000
From: Luis Henriques &lt;luis.henriques@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.16.y-ckt stable] Linux 3.16.7-ckt15
Date: Mon, 20 Jul 2015 13:07:20 +0100
Message-Id: &lt;1437394040-6263-2-git-send-email-luis.henriques@canonical.com&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1437394040-6263-1-git-send-email-luis.henriques@canonical.com&gt;
References: &lt;1437394040-6263-1-git-send-email-luis.henriques@canonical.com&gt;
X-Extended-Stable: 3.16
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=45061">Luis Henriques</a> - July 20, 2015, 12:07 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_header">index 750d577e8083..f5a8ca29aff0 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/net/marvell-armada-370-neta.txt</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 * Marvell Armada 370 / Armada XP Ethernet Controller (NETA)
 
 Required properties:
<span class="p_del">-- compatible: should be &quot;marvell,armada-370-neta&quot;.</span>
<span class="p_add">+- compatible: &quot;marvell,armada-370-neta&quot; or &quot;marvell,armada-xp-neta&quot;.</span>
 - reg: address and length of the register set for the device.
 - interrupts: interrupt for the device
 - phy: See ethernet.txt file in the same directory.
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">index adda2a8d1d52..e357b020861d 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_chunk">@@ -92,5 +92,5 @@</span> <span class="p_context"> mpp61         61       gpo, dev(wen1), uart1(txd), audio(rclk)</span>
 mpp62         62       gpio, dev(a2), uart1(cts), tdm(drx), pcie(clkreq0),
                        audio(mclk), uart0(cts)
 mpp63         63       gpo, spi0(sck), tclk
<span class="p_del">-mpp64         64       gpio, spi0(miso), spi0-1(cs1)</span>
<span class="p_del">-mpp65         65       gpio, spi0(mosi), spi0-1(cs2)</span>
<span class="p_add">+mpp64         64       gpio, spi0(miso), spi0(cs1)</span>
<span class="p_add">+mpp65         65       gpio, spi0(mosi), spi0(cs2)</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_header">index 7de0cda4a379..bedbe42c8c0a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_chunk">@@ -22,8 +22,8 @@</span> <span class="p_context"> mpp5          5        gpio, dev(ad7), spi0(cs2), spi1(cs2)</span>
 mpp6          6        gpio, dev(ad0), led(p1), audio(rclk)
 mpp7          7        gpio, dev(ad1), ptp(clk), led(p2), audio(extclk)
 mpp8          8        gpio, dev (bootcs), spi0(cs0), spi1(cs0)
<span class="p_del">-mpp9          9        gpio, nf(wen), spi0(sck), spi1(sck)</span>
<span class="p_del">-mpp10        10        gpio, nf(ren), dram(vttctrl), led(c1)</span>
<span class="p_add">+mpp9          9        gpio, spi0(sck), spi1(sck), nand(we)</span>
<span class="p_add">+mpp10        10        gpio, dram(vttctrl), led(c1), nand(re)</span>
 mpp11        11        gpio, dev(a0), led(c2), audio(sdo)
 mpp12        12        gpio, dev(a1), audio(bclk)
 mpp13        13        gpio, dev(readyn), pcie0(rstoutn), pcie1(rstoutn)
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_header">index b17c96849fc9..4ac138aaaf87 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_chunk">@@ -27,15 +27,15 @@</span> <span class="p_context"> mpp8          8        gpio, ge0(txd1), dev(ad10)</span>
 mpp9          9        gpio, ge0(txd2), dev(ad11)
 mpp10         10       gpio, ge0(txd3), dev(ad12)
 mpp11         11       gpio, ge0(txctl), dev(ad13)
<span class="p_del">-mpp12         12       gpio, ge0(rxd0), pcie0(rstout), pcie1(rstout) [1], spi0(cs1), dev(ad14)</span>
<span class="p_del">-mpp13         13       gpio, ge0(rxd1), pcie0(clkreq), pcie1(clkreq) [1], spi0(cs2), dev(ad15)</span>
<span class="p_del">-mpp14         14       gpio, ge0(rxd2), ptp(clk), m(vtt_ctrl), spi0(cs3), dev(wen1)</span>
<span class="p_del">-mpp15         15       gpio, ge0(rxd3), ge(mdc slave), pcie0(rstout), spi0(mosi), pcie1(rstout) [1]</span>
<span class="p_del">-mpp16         16       gpio, ge0(rxctl), ge(mdio slave), m(decc_err), spi0(miso), pcie0(clkreq)</span>
<span class="p_add">+mpp12         12       gpio, ge0(rxd0), pcie0(rstout), spi0(cs1), dev(ad14), pcie3(clkreq)</span>
<span class="p_add">+mpp13         13       gpio, ge0(rxd1), pcie0(clkreq), pcie1(clkreq) [1], spi0(cs2), dev(ad15), pcie2(clkreq)</span>
<span class="p_add">+mpp14         14       gpio, ge0(rxd2), ptp(clk), m(vtt_ctrl), spi0(cs3), dev(wen1), pcie3(clkreq)</span>
<span class="p_add">+mpp15         15       gpio, ge0(rxd3), ge(mdc slave), pcie0(rstout), spi0(mosi)</span>
<span class="p_add">+mpp16         16       gpio, ge0(rxctl), ge(mdio slave), m(decc_err), spi0(miso), pcie0(clkreq), pcie1(clkreq) [1]</span>
 mpp17         17       gpio, ge0(rxclk), ptp(clk), ua1(rxd), spi0(sck), sata1(prsnt)
<span class="p_del">-mpp18         18       gpio, ge0(rxerr), ptp(trig_gen), ua1(txd), spi0(cs0), pcie1(rstout) [1]</span>
<span class="p_del">-mpp19         19       gpio, ge0(col), ptp(event_req), pcie0(clkreq), sata1(prsnt), ua0(cts)</span>
<span class="p_del">-mpp20         20       gpio, ge0(txclk), ptp(clk), pcie1(rstout) [1], sata0(prsnt), ua0(rts)</span>
<span class="p_add">+mpp18         18       gpio, ge0(rxerr), ptp(trig_gen), ua1(txd), spi0(cs0)</span>
<span class="p_add">+mpp19         19       gpio, ge0(col), ptp(event_req), ge0(txerr), sata1(prsnt), ua0(cts)</span>
<span class="p_add">+mpp20         20       gpio, ge0(txclk), ptp(clk), sata0(prsnt), ua0(rts)</span>
 mpp21         21       gpio, spi0(cs1), ge1(rxd0), sata0(prsnt), sd0(cmd), dev(bootcs)
 mpp22         22       gpio, spi0(mosi), dev(ad0)
 mpp23         23       gpio, spi0(sck), dev(ad2)
<span class="p_chunk">@@ -58,23 +58,23 @@</span> <span class="p_context"> mpp39         39       gpio, i2c1(sck), ge1(rxd2), ua0(cts), sd0(d1), dev(a2)</span>
 mpp40         40       gpio, i2c1(sda), ge1(rxd3), ua0(rts), sd0(d2), dev(ad6)
 mpp41         41       gpio, ua1(rxd), ge1(rxctl), ua0(cts), spi1(cs3), dev(burst/last)
 mpp42         42       gpio, ua1(txd), ua0(rts), dev(ad7)
<span class="p_del">-mpp43         43       gpio, pcie0(clkreq), m(vtt_ctrl), m(decc_err), pcie0(rstout), dev(clkout)</span>
<span class="p_del">-mpp44         44       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [3], pcie0(rstout)</span>
<span class="p_del">-mpp45         45       gpio, ref(clk_out0), pcie0(rstout), pcie1(rstout) [1], pcie2(rstout), pcie3(rstout)</span>
<span class="p_del">-mpp46         46       gpio, ref(clk_out1), pcie0(rstout), pcie1(rstout) [1], pcie2(rstout), pcie3(rstout)</span>
<span class="p_del">-mpp47         47       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], spi1(cs2), sata3(prsnt) [2]</span>
<span class="p_del">-mpp48         48       gpio, sata0(prsnt), m(vtt_ctrl), tdm2c(pclk), audio(mclk), sd0(d4)</span>
<span class="p_del">-mpp49         49       gpio, sata2(prsnt) [2], sata3(prsnt) [2], tdm2c(fsync), audio(lrclk), sd0(d5)</span>
<span class="p_del">-mpp50         50       gpio, pcie0(rstout), pcie1(rstout) [1], tdm2c(drx), audio(extclk), sd0(cmd)</span>
<span class="p_add">+mpp43         43       gpio, pcie0(clkreq), m(vtt_ctrl), m(decc_err), spi1(cs2), dev(clkout)</span>
<span class="p_add">+mpp44         44       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [3]</span>
<span class="p_add">+mpp45         45       gpio, ref(clk_out0), pcie0(rstout)</span>
<span class="p_add">+mpp46         46       gpio, ref(clk_out1), pcie0(rstout)</span>
<span class="p_add">+mpp47         47       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [2]</span>
<span class="p_add">+mpp48         48       gpio, sata0(prsnt), m(vtt_ctrl), tdm2c(pclk), audio(mclk), sd0(d4), pcie0(clkreq)</span>
<span class="p_add">+mpp49         49       gpio, sata2(prsnt) [2], sata3(prsnt) [2], tdm2c(fsync), audio(lrclk), sd0(d5), pcie1(clkreq)</span>
<span class="p_add">+mpp50         50       gpio, pcie0(rstout), tdm2c(drx), audio(extclk), sd0(cmd)</span>
 mpp51         51       gpio, tdm2c(dtx), audio(sdo), m(decc_err)
<span class="p_del">-mpp52         52       gpio, pcie0(rstout), pcie1(rstout) [1], tdm2c(intn), audio(sdi), sd0(d6)</span>
<span class="p_add">+mpp52         52       gpio, pcie0(rstout), tdm2c(intn), audio(sdi), sd0(d6)</span>
 mpp53         53       gpio, sata1(prsnt), sata0(prsnt), tdm2c(rstn), audio(bclk), sd0(d7)
<span class="p_del">-mpp54         54       gpio, sata0(prsnt), sata1(prsnt), pcie0(rstout), pcie1(rstout) [1], sd0(d3)</span>
<span class="p_add">+mpp54         54       gpio, sata0(prsnt), sata1(prsnt), pcie0(rstout), ge0(txerr), sd0(d3)</span>
 mpp55         55       gpio, ua1(cts), ge(mdio), pcie1(clkreq) [1], spi1(cs1), sd0(d0)
 mpp56         56       gpio, ua1(rts), ge(mdc), m(decc_err), spi1(mosi)
 mpp57         57       gpio, spi1(sck), sd0(clk)
 mpp58         58       gpio, pcie1(clkreq) [1], i2c1(sck), pcie2(clkreq), spi1(miso), sd0(d1)
<span class="p_del">-mpp59         59       gpio, pcie0(rstout), i2c1(sda), pcie1(rstout) [1], spi1(cs0), sd0(d2)</span>
<span class="p_add">+mpp59         59       gpio, pcie0(rstout), i2c1(sda), spi1(cs0), sd0(d2)</span>
 
 [1]: only available on 88F6820 and 88F6828
 [2]: only available on 88F6828
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">index 373dbccd7ab0..96e7744cab84 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_chunk">@@ -42,15 +42,15 @@</span> <span class="p_context"> mpp20         20       gpio, ge0(rxd4), ge1(rxd2), lcd(d20), ptp(clk)</span>
 mpp21         21       gpio, ge0(rxd5), ge1(rxd3), lcd(d21), mem(bat)
 mpp22         22       gpio, ge0(rxd6), ge1(rxctl), lcd(d22), sata0(prsnt)
 mpp23         23       gpio, ge0(rxd7), ge1(rxclk), lcd(d23), sata1(prsnt)
<span class="p_del">-mpp24         24       gpio, lcd(hsync), sata1(prsnt), nf(bootcs-re), tdm(rst)</span>
<span class="p_del">-mpp25         25       gpio, lcd(vsync), sata0(prsnt), nf(bootcs-we), tdm(pclk)</span>
<span class="p_del">-mpp26         26       gpio, lcd(clk), tdm(fsync), vdd(cpu1-pd)</span>
<span class="p_add">+mpp24         24       gpio, lcd(hsync), sata1(prsnt), tdm(rst)</span>
<span class="p_add">+mpp25         25       gpio, lcd(vsync), sata0(prsnt), tdm(pclk)</span>
<span class="p_add">+mpp26         26       gpio, lcd(clk), tdm(fsync)</span>
 mpp27         27       gpio, lcd(e), tdm(dtx), ptp(trig)
 mpp28         28       gpio, lcd(pwm), tdm(drx), ptp(evreq)
<span class="p_del">-mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk), vdd(cpu0-pd)</span>
<span class="p_add">+mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk)</span>
 mpp30         30       gpio, tdm(int1), sd0(clk)
<span class="p_del">-mpp31         31       gpio, tdm(int2), sd0(cmd), vdd(cpu0-pd)</span>
<span class="p_del">-mpp32         32       gpio, tdm(int3), sd0(d0), vdd(cpu1-pd)</span>
<span class="p_add">+mpp31         31       gpio, tdm(int2), sd0(cmd)</span>
<span class="p_add">+mpp32         32       gpio, tdm(int3), sd0(d0)</span>
 mpp33         33       gpio, tdm(int4), sd0(d1), mem(bat)
 mpp34         34       gpio, tdm(int5), sd0(d2), sata0(prsnt)
 mpp35         35       gpio, tdm(int6), sd0(d3), sata1(prsnt)
<span class="p_chunk">@@ -58,21 +58,18 @@</span> <span class="p_context"> mpp36         36       gpio, spi(mosi)</span>
 mpp37         37       gpio, spi(miso)
 mpp38         38       gpio, spi(sck)
 mpp39         39       gpio, spi(cs0)
<span class="p_del">-mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), vdd(cpu1-pd),</span>
<span class="p_del">-                       pcie(clkreq0)</span>
<span class="p_add">+mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), pcie(clkreq0)</span>
 mpp41         41       gpio, spi(cs2), uart2(rts), lcd(vga-vsync), sata1(prsnt),
                        pcie(clkreq1)
<span class="p_del">-mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer),</span>
<span class="p_del">-                       vdd(cpu0-pd)</span>
<span class="p_del">-mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout),</span>
<span class="p_del">-                       vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer)</span>
<span class="p_add">+mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout)</span>
 mpp44         44       gpio, uart2(cts), uart3(rxd), spi(cs4), pcie(clkreq2),
                        mem(bat)
 mpp45         45       gpio, uart2(rts), uart3(txd), spi(cs5), sata1(prsnt)
 mpp46         46       gpio, uart3(rts), uart1(rts), spi(cs6), sata0(prsnt)
 mpp47         47       gpio, uart3(cts), uart1(cts), spi(cs7), pcie(clkreq3),
                        ref(clkout)
<span class="p_del">-mpp48         48       gpio, tclk, dev(burst/last)</span>
<span class="p_add">+mpp48         48       gpio, dev(clkout), dev(burst/last)</span>
 
 * Marvell Armada XP (mv78260 and mv78460 only)
 
<span class="p_chunk">@@ -84,9 +81,9 @@</span> <span class="p_context"> mpp51         51       gpio, dev(ad16)</span>
 mpp52         52       gpio, dev(ad17)
 mpp53         53       gpio, dev(ad18)
 mpp54         54       gpio, dev(ad19)
<span class="p_del">-mpp55         55       gpio, dev(ad20), vdd(cpu0-pd)</span>
<span class="p_del">-mpp56         56       gpio, dev(ad21), vdd(cpu1-pd)</span>
<span class="p_del">-mpp57         57       gpio, dev(ad22), vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp55         55       gpio, dev(ad20)</span>
<span class="p_add">+mpp56         56       gpio, dev(ad21)</span>
<span class="p_add">+mpp57         57       gpio, dev(ad22)</span>
 mpp58         58       gpio, dev(ad23)
 mpp59         59       gpio, dev(ad24)
 mpp60         60       gpio, dev(ad25)
<span class="p_chunk">@@ -96,6 +93,3 @@</span> <span class="p_context"> mpp63         63       gpio, dev(ad28)</span>
 mpp64         64       gpio, dev(ad29)
 mpp65         65       gpio, dev(ad30)
 mpp66         66       gpio, dev(ad31)
<span class="p_del">-</span>
<span class="p_del">-Notes:</span>
<span class="p_del">-* {1} vdd(cpu2-3-pd) only available on mv78460.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index d0c3a2795c09..7fb85a24d17c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
 SUBLEVEL = 7
<span class="p_del">-EXTRAVERSION =-ckt14</span>
<span class="p_add">+EXTRAVERSION =-ckt15</span>
 NAME = Museum of Fishiegoodies
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/include/asm/atomic.h b/arch/arc/include/asm/atomic.h</span>
<span class="p_header">index 83f03ca6caf6..223138716c2e 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/atomic.h</span>
<span class="p_chunk">@@ -25,79 +25,44 @@</span> <span class="p_context"></span>
 
 #define atomic_set(v, i) (((v)-&gt;counter) = (i))
 
<span class="p_del">-static inline void atomic_add(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	add     %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)	/* Early clobber, to prevent reg reuse */</span>
<span class="p_del">-	: &quot;r&quot;(&amp;v-&gt;counter), &quot;ir&quot;(i)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void atomic_sub(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	sub     %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(&amp;v-&gt;counter), &quot;ir&quot;(i)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* add and also return the new value */</span>
<span class="p_del">-static inline int atomic_add_return(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	add     %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(&amp;v-&gt;counter), &quot;ir&quot;(i)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	return temp;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int atomic_sub_return(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	sub     %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(&amp;v-&gt;counter), &quot;ir&quot;(i)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	return temp;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	__asm__ __volatile__(</span>
<span class="p_del">-	&quot;1:	llock   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bic     %0, %0, %2	\n&quot;</span>
<span class="p_del">-	&quot;	scond   %0, [%1]	\n&quot;</span>
<span class="p_del">-	&quot;	bnz     1b		\n&quot;</span>
<span class="p_del">-	: &quot;=&amp;r&quot;(temp)</span>
<span class="p_del">-	: &quot;r&quot;(addr), &quot;ir&quot;(mask)</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_add">+#define ATOMIC_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+static inline void atomic_##op(int i, atomic_t *v)			\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned int temp;						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	__asm__ __volatile__(						\</span>
<span class="p_add">+	&quot;1:	llock   %0, [%1]	\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot; #asm_op &quot; %0, %0, %2	\n&quot;				\</span>
<span class="p_add">+	&quot;	scond   %0, [%1]	\n&quot;				\</span>
<span class="p_add">+	&quot;	bnz     1b		\n&quot;				\</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(temp)	/* Early clobber, to prevent reg reuse */	\</span>
<span class="p_add">+	: &quot;r&quot;(&amp;v-&gt;counter), &quot;ir&quot;(i)					\</span>
<span class="p_add">+	: &quot;cc&quot;);							\</span>
<span class="p_add">+}									\</span>
<span class="p_add">+</span>
<span class="p_add">+#define ATOMIC_OP_RETURN(op, c_op, asm_op)				\</span>
<span class="p_add">+static inline int atomic_##op##_return(int i, atomic_t *v)		\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned int temp;						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as		\</span>
<span class="p_add">+	 * LLOCK/SCOND thmeselves don&#39;t provide any such semantics	\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	__asm__ __volatile__(						\</span>
<span class="p_add">+	&quot;1:	llock   %0, [%1]	\n&quot;				\</span>
<span class="p_add">+	&quot;	&quot; #asm_op &quot; %0, %0, %2	\n&quot;				\</span>
<span class="p_add">+	&quot;	scond   %0, [%1]	\n&quot;				\</span>
<span class="p_add">+	&quot;	bnz     1b		\n&quot;				\</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(temp)							\</span>
<span class="p_add">+	: &quot;r&quot;(&amp;v-&gt;counter), &quot;ir&quot;(i)					\</span>
<span class="p_add">+	: &quot;cc&quot;);							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	return temp;							\</span>
 }
 
 #else	/* !CONFIG_ARC_HAS_LLSC */
<span class="p_chunk">@@ -126,6 +91,7 @@</span> <span class="p_context"> static inline void atomic_set(atomic_t *v, int i)</span>
 	v-&gt;counter = i;
 	atomic_ops_unlock(flags);
 }
<span class="p_add">+</span>
 #endif
 
 /*
<span class="p_chunk">@@ -133,62 +99,49 @@</span> <span class="p_context"> static inline void atomic_set(atomic_t *v, int i)</span>
  * Locking would change to irq-disabling only (UP) and spinlocks (SMP)
  */
 
<span class="p_del">-static inline void atomic_add(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	atomic_ops_lock(flags);</span>
<span class="p_del">-	v-&gt;counter += i;</span>
<span class="p_del">-	atomic_ops_unlock(flags);</span>
<span class="p_add">+#define ATOMIC_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+static inline void atomic_##op(int i, atomic_t *v)			\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned long flags;						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	atomic_ops_lock(flags);						\</span>
<span class="p_add">+	v-&gt;counter c_op i;						\</span>
<span class="p_add">+	atomic_ops_unlock(flags);					\</span>
 }
 
<span class="p_del">-static inline void atomic_sub(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	atomic_ops_lock(flags);</span>
<span class="p_del">-	v-&gt;counter -= i;</span>
<span class="p_del">-	atomic_ops_unlock(flags);</span>
<span class="p_add">+#define ATOMIC_OP_RETURN(op, c_op)					\</span>
<span class="p_add">+static inline int atomic_##op##_return(int i, atomic_t *v)		\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	unsigned long flags;						\</span>
<span class="p_add">+	unsigned long temp;						\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * spin lock/unlock provides the needed smp_mb() before/after	\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	atomic_ops_lock(flags);						\</span>
<span class="p_add">+	temp = v-&gt;counter;						\</span>
<span class="p_add">+	temp c_op i;							\</span>
<span class="p_add">+	v-&gt;counter = temp;						\</span>
<span class="p_add">+	atomic_ops_unlock(flags);					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	return temp;							\</span>
 }
 
<span class="p_del">-static inline int atomic_add_return(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	unsigned long temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	atomic_ops_lock(flags);</span>
<span class="p_del">-	temp = v-&gt;counter;</span>
<span class="p_del">-	temp += i;</span>
<span class="p_del">-	v-&gt;counter = temp;</span>
<span class="p_del">-	atomic_ops_unlock(flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	return temp;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int atomic_sub_return(int i, atomic_t *v)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	unsigned long temp;</span>
<span class="p_del">-</span>
<span class="p_del">-	atomic_ops_lock(flags);</span>
<span class="p_del">-	temp = v-&gt;counter;</span>
<span class="p_del">-	temp -= i;</span>
<span class="p_del">-	v-&gt;counter = temp;</span>
<span class="p_del">-	atomic_ops_unlock(flags);</span>
<span class="p_add">+#endif /* !CONFIG_ARC_HAS_LLSC */</span>
 
<span class="p_del">-	return temp;</span>
<span class="p_del">-}</span>
<span class="p_add">+#define ATOMIC_OPS(op, c_op, asm_op)					\</span>
<span class="p_add">+	ATOMIC_OP(op, c_op, asm_op)					\</span>
<span class="p_add">+	ATOMIC_OP_RETURN(op, c_op, asm_op)</span>
 
<span class="p_del">-static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+ATOMIC_OPS(add, +=, add)</span>
<span class="p_add">+ATOMIC_OPS(sub, -=, sub)</span>
<span class="p_add">+ATOMIC_OP(and, &amp;=, and)</span>
 
<span class="p_del">-	atomic_ops_lock(flags);</span>
<span class="p_del">-	*addr &amp;= ~mask;</span>
<span class="p_del">-	atomic_ops_unlock(flags);</span>
<span class="p_del">-}</span>
<span class="p_add">+#define atomic_clear_mask(mask, v) atomic_and(~(mask), (v))</span>
 
<span class="p_del">-#endif /* !CONFIG_ARC_HAS_LLSC */</span>
<span class="p_add">+#undef ATOMIC_OPS</span>
<span class="p_add">+#undef ATOMIC_OP_RETURN</span>
<span class="p_add">+#undef ATOMIC_OP</span>
 
 /**
  * __atomic_add_unless - add unless the number is a given value
<span class="p_chunk">@@ -202,9 +155,19 @@</span> <span class="p_context"> static inline void atomic_clear_mask(unsigned long mask, unsigned long *addr)</span>
 #define __atomic_add_unless(v, a, u)					\
 ({									\
 	int c, old;							\
<span class="p_add">+									\</span>
<span class="p_add">+	/*								\</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as		\</span>
<span class="p_add">+	 * LLOCK/SCOND thmeselves don&#39;t provide any such semantics	\</span>
<span class="p_add">+	 */								\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
 	c = atomic_read(v);						\
 	while (c != (u) &amp;&amp; (old = atomic_cmpxchg((v), c, c + (a))) != c)\
 		c = old;						\
<span class="p_add">+									\</span>
<span class="p_add">+	smp_mb();							\</span>
<span class="p_add">+									\</span>
 	c;								\
 })
 
<span class="p_header">diff --git a/arch/arc/include/asm/bitops.h b/arch/arc/include/asm/bitops.h</span>
<span class="p_header">index ebc0cf3164dc..72e50ec9d00b 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/bitops.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/bitops.h</span>
<span class="p_chunk">@@ -105,6 +105,12 @@</span> <span class="p_context"> static inline int test_and_set_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as</span>
<span class="p_add">+	 * LLOCK/SCOND themselves don&#39;t provide any such semantics</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%2]	\n&quot;
 	&quot;	bset    %1, %0, %3	\n&quot;
<span class="p_chunk">@@ -114,6 +120,8 @@</span> <span class="p_context"> static inline int test_and_set_bit(unsigned long nr, volatile unsigned long *m)</span>
 	: &quot;r&quot;(m), &quot;ir&quot;(nr)
 	: &quot;cc&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (old &amp; (1 &lt;&lt; nr)) != 0;
 }
 
<span class="p_chunk">@@ -127,6 +135,8 @@</span> <span class="p_context"> test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%2]	\n&quot;
 	&quot;	bclr    %1, %0, %3	\n&quot;
<span class="p_chunk">@@ -136,6 +146,8 @@</span> <span class="p_context"> test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
 	: &quot;r&quot;(m), &quot;ir&quot;(nr)
 	: &quot;cc&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (old &amp; (1 &lt;&lt; nr)) != 0;
 }
 
<span class="p_chunk">@@ -149,6 +161,8 @@</span> <span class="p_context"> test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%2]	\n&quot;
 	&quot;	bxor    %1, %0, %3	\n&quot;
<span class="p_chunk">@@ -158,6 +172,8 @@</span> <span class="p_context"> test_and_change_bit(unsigned long nr, volatile unsigned long *m)</span>
 	: &quot;r&quot;(m), &quot;ir&quot;(nr)
 	: &quot;cc&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (old &amp; (1 &lt;&lt; nr)) != 0;
 }
 
<span class="p_chunk">@@ -256,6 +272,9 @@</span> <span class="p_context"> test_and_clear_bit(unsigned long nr, volatile unsigned long *m)</span>
 	if (__builtin_constant_p(nr))
 		nr &amp;= 0x1f;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * spin lock/unlock provide the needed smp_mb() before/after</span>
<span class="p_add">+	 */</span>
 	bitops_lock(flags);
 
 	old = *m;
<span class="p_header">diff --git a/arch/arc/include/asm/cmpxchg.h b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">index 03cd6894855d..44fd531f4d7b 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -10,6 +10,8 @@</span> <span class="p_context"></span>
 #define __ASM_ARC_CMPXCHG_H
 
 #include &lt;linux/types.h&gt;
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/barrier.h&gt;</span>
 #include &lt;asm/smp.h&gt;
 
 #ifdef CONFIG_ARC_HAS_LLSC
<span class="p_chunk">@@ -19,16 +21,25 @@</span> <span class="p_context"> __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)</span>
 {
 	unsigned long prev;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Explicit full memory barrier needed before/after as</span>
<span class="p_add">+	 * LLOCK/SCOND thmeselves don&#39;t provide any such semantics</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	llock   %0, [%1]	\n&quot;
 	&quot;	brne    %0, %2, 2f	\n&quot;
 	&quot;	scond   %3, [%1]	\n&quot;
 	&quot;	bnz     1b		\n&quot;
 	&quot;2:				\n&quot;
<span class="p_del">-	: &quot;=&amp;r&quot;(prev)</span>
<span class="p_del">-	: &quot;r&quot;(ptr), &quot;ir&quot;(expected),</span>
<span class="p_del">-	  &quot;r&quot;(new) /* can&#39;t be &quot;ir&quot;. scond can&#39;t take limm for &quot;b&quot; */</span>
<span class="p_del">-	: &quot;cc&quot;);</span>
<span class="p_add">+	: &quot;=&amp;r&quot;(prev)	/* Early clobber, to prevent reg reuse */</span>
<span class="p_add">+	: &quot;r&quot;(ptr),	/* Not &quot;m&quot;: llock only supports reg direct addr mode */</span>
<span class="p_add">+	  &quot;ir&quot;(expected),</span>
<span class="p_add">+	  &quot;r&quot;(new)	/* can&#39;t be &quot;ir&quot;. scond can&#39;t take LIMM for &quot;b&quot; */</span>
<span class="p_add">+	: &quot;cc&quot;, &quot;memory&quot;); /* so that gcc knows memory is being written here */</span>
<span class="p_add">+</span>
<span class="p_add">+	smp_mb();</span>
 
 	return prev;
 }
<span class="p_chunk">@@ -42,6 +53,9 @@</span> <span class="p_context"> __cmpxchg(volatile void *ptr, unsigned long expected, unsigned long new)</span>
 	int prev;
 	volatile unsigned long *p = ptr;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * spin lock/unlock provide the needed smp_mb() before/after</span>
<span class="p_add">+	 */</span>
 	atomic_ops_lock(flags);
 	prev = *p;
 	if (prev == expected)
<span class="p_chunk">@@ -77,12 +91,16 @@</span> <span class="p_context"> static inline unsigned long __xchg(unsigned long val, volatile void *ptr,</span>
 
 	switch (size) {
 	case 4:
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		__asm__ __volatile__(
 		&quot;	ex  %0, [%1]	\n&quot;
 		: &quot;+r&quot;(val)
 		: &quot;r&quot;(ptr)
 		: &quot;memory&quot;);
 
<span class="p_add">+		smp_mb();</span>
<span class="p_add">+</span>
 		return val;
 	}
 	return __xchg_bad_pointer();
<span class="p_header">diff --git a/arch/arc/include/asm/spinlock.h b/arch/arc/include/asm/spinlock.h</span>
<span class="p_header">index b6a8c2dfbe6e..e1651df6a93d 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/spinlock.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/spinlock.h</span>
<span class="p_chunk">@@ -22,24 +22,46 @@</span> <span class="p_context"> static inline void arch_spin_lock(arch_spinlock_t *lock)</span>
 {
 	unsigned int tmp = __ARCH_SPIN_LOCK_LOCKED__;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This smp_mb() is technically superfluous, we only need the one</span>
<span class="p_add">+	 * after the lock for providing the ACQUIRE semantics.</span>
<span class="p_add">+	 * However doing the &quot;right&quot; thing was regressing hackbench</span>
<span class="p_add">+	 * so keeping this, pending further investigation</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	ex  %0, [%1]		\n&quot;
 	&quot;	breq  %0, %2, 1b	\n&quot;
 	: &quot;+&amp;r&quot; (tmp)
 	: &quot;r&quot;(&amp;(lock-&gt;slock)), &quot;ir&quot;(__ARCH_SPIN_LOCK_LOCKED__)
 	: &quot;memory&quot;);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * ACQUIRE barrier to ensure load/store after taking the lock</span>
<span class="p_add">+	 * don&#39;t &quot;bleed-up&quot; out of the critical section (leak-in is allowed)</span>
<span class="p_add">+	 * http://www.spinics.net/lists/kernel/msg2010409.html</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * ARCv2 only has load-load, store-store and all-all barrier</span>
<span class="p_add">+	 * thus need the full all-all barrier</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
 }
 
 static inline int arch_spin_trylock(arch_spinlock_t *lock)
 {
 	unsigned int tmp = __ARCH_SPIN_LOCK_LOCKED__;
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;1:	ex  %0, [%1]		\n&quot;
 	: &quot;+r&quot; (tmp)
 	: &quot;r&quot;(&amp;(lock-&gt;slock))
 	: &quot;memory&quot;);
 
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	return (tmp == __ARCH_SPIN_LOCK_UNLOCKED__);
 }
 
<span class="p_chunk">@@ -47,12 +69,22 @@</span> <span class="p_context"> static inline void arch_spin_unlock(arch_spinlock_t *lock)</span>
 {
 	unsigned int tmp = __ARCH_SPIN_LOCK_UNLOCKED__;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * RELEASE barrier: given the instructions avail on ARCv2, full barrier</span>
<span class="p_add">+	 * is the only option</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_mb();</span>
<span class="p_add">+</span>
 	__asm__ __volatile__(
 	&quot;	ex  %0, [%1]		\n&quot;
 	: &quot;+r&quot; (tmp)
 	: &quot;r&quot;(&amp;(lock-&gt;slock))
 	: &quot;memory&quot;);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * superfluous, but keeping for now - see pairing version in</span>
<span class="p_add">+	 * arch_spin_lock above</span>
<span class="p_add">+	 */</span>
 	smp_mb();
 }
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-370-xp.dtsi b/arch/arm/boot/dts/armada-370-xp.dtsi</span>
<span class="p_header">index 23227e0027ec..c02e43adadae 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-370-xp.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-370-xp.dtsi</span>
<span class="p_chunk">@@ -225,7 +225,6 @@</span> <span class="p_context"></span>
 			};
 
 			eth0: ethernet@70000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
 				reg = &lt;0x70000 0x4000&gt;;
 				interrupts = &lt;8&gt;;
 				clocks = &lt;&amp;gateclk 4&gt;;
<span class="p_chunk">@@ -241,7 +240,6 @@</span> <span class="p_context"></span>
 			};
 
 			eth1: ethernet@74000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
 				reg = &lt;0x74000 0x4000&gt;;
 				interrupts = &lt;10&gt;;
 				clocks = &lt;&amp;gateclk 3&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-370.dtsi b/arch/arm/boot/dts/armada-370.dtsi</span>
<span class="p_header">index 77d22d82faf5..adcc244b781e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-370.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-370.dtsi</span>
<span class="p_chunk">@@ -279,6 +279,14 @@</span> <span class="p_context"></span>
 					dmacap,memset;
 				};
 			};
<span class="p_add">+</span>
<span class="p_add">+			ethernet@70000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
<span class="p_add">+			ethernet@74000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+			};</span>
 		};
 	};
 };
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-mv78260.dtsi b/arch/arm/boot/dts/armada-xp-mv78260.dtsi</span>
<span class="p_header">index 3396b25b39e1..caae3310ed00 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-mv78260.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-mv78260.dtsi</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"></span>
 			};
 
 			eth3: ethernet@34000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
 				reg = &lt;0x34000 0x4000&gt;;
 				interrupts = &lt;14&gt;;
 				clocks = &lt;&amp;gateclk 1&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp-mv78460.dtsi b/arch/arm/boot/dts/armada-xp-mv78460.dtsi</span>
<span class="p_header">index 6da84bf40aaf..908d491b1b65 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp-mv78460.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp-mv78460.dtsi</span>
<span class="p_chunk">@@ -330,7 +330,7 @@</span> <span class="p_context"></span>
 			};
 
 			eth3: ethernet@34000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
 				reg = &lt;0x34000 0x4000&gt;;
 				interrupts = &lt;14&gt;;
 				clocks = &lt;&amp;gateclk 1&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-xp.dtsi b/arch/arm/boot/dts/armada-xp.dtsi</span>
<span class="p_header">index 5902e8359c91..aa4dad7203b5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-xp.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-xp.dtsi</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"></span>
 			};
 
 			eth2: ethernet@30000 {
<span class="p_del">-				compatible = &quot;marvell,armada-370-neta&quot;;</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
 				reg = &lt;0x30000 0x4000&gt;;
 				interrupts = &lt;12&gt;;
 				clocks = &lt;&amp;gateclk 2&gt;;
<span class="p_chunk">@@ -168,6 +168,14 @@</span> <span class="p_context"></span>
 				};
 			};
 
<span class="p_add">+			ethernet@70000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
<span class="p_add">+			ethernet@74000 {</span>
<span class="p_add">+				compatible = &quot;marvell,armada-xp-neta&quot;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+</span>
 			xor@f0900 {
 				compatible = &quot;marvell,orion-xor&quot;;
 				reg = &lt;0xF0900 0x100
<span class="p_header">diff --git a/arch/arm/kvm/interrupts.S b/arch/arm/kvm/interrupts.S</span>
<span class="p_header">index 0d68d4073068..a1467e7689f5 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts.S</span>
<span class="p_chunk">@@ -159,13 +159,9 @@</span> <span class="p_context"> __kvm_vcpu_return:</span>
 	@ Don&#39;t trap coprocessor accesses for host kernel
 	set_hstr vmexit
 	set_hdcr vmexit
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmexit, (HCPTR_TTA | HCPTR_TCP(10) | HCPTR_TCP(11)), after_vfp_restore</span>
 
 #ifdef CONFIG_VFPv3
<span class="p_del">-	@ Save floating point registers we if let guest use them.</span>
<span class="p_del">-	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_del">-	bne	after_vfp_restore</span>
<span class="p_del">-</span>
 	@ Switch VFP/NEON hardware state to the host&#39;s
 	add	r7, vcpu, #VCPU_VFP_GUEST
 	store_vfp_state r7
<span class="p_chunk">@@ -177,6 +173,8 @@</span> <span class="p_context"> after_vfp_restore:</span>
 	@ Restore FPEXC_EN which we clobbered on entry
 	pop	{r2}
 	VFPFMXR FPEXC, r2
<span class="p_add">+#else</span>
<span class="p_add">+after_vfp_restore:</span>
 #endif
 
 	@ Reset Hyp-role
<span class="p_chunk">@@ -467,7 +465,7 @@</span> <span class="p_context"> switch_to_guest_vfp:</span>
 	push	{r3-r7}
 
 	@ NEON/VFP used.  Turn on VFP access.
<span class="p_del">-	set_hcptr vmexit, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	set_hcptr vmtrap, (HCPTR_TCP(10) | HCPTR_TCP(11))</span>
 
 	@ Switch VFP/NEON hardware state to the guest&#39;s
 	add	r7, r0, #VCPU_VFP_HOST
<span class="p_header">diff --git a/arch/arm/kvm/interrupts_head.S b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">index 76af93025574..2973b2d342fa 100644</span>
<span class="p_header">--- a/arch/arm/kvm/interrupts_head.S</span>
<span class="p_header">+++ b/arch/arm/kvm/interrupts_head.S</span>
<span class="p_chunk">@@ -578,8 +578,13 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 .endm
 
 /* Configures the HCPTR (Hyp Coprocessor Trap Register) on entry/return
<span class="p_del">- * (hardware reset value is 0). Keep previous value in r2. */</span>
<span class="p_del">-.macro set_hcptr operation, mask</span>
<span class="p_add">+ * (hardware reset value is 0). Keep previous value in r2.</span>
<span class="p_add">+ * An ISB is emited on vmexit/vmtrap, but executed on vmexit only if</span>
<span class="p_add">+ * VFP wasn&#39;t already enabled (always executed on vmtrap).</span>
<span class="p_add">+ * If a label is specified with vmexit, it is branched to if VFP wasn&#39;t</span>
<span class="p_add">+ * enabled.</span>
<span class="p_add">+ */</span>
<span class="p_add">+.macro set_hcptr operation, mask, label = none</span>
 	mrc	p15, 4, r2, c1, c1, 2
 	ldr	r3, =\mask
 	.if \operation == vmentry
<span class="p_chunk">@@ -588,6 +593,17 @@</span> <span class="p_context"> vcpu	.req	r0		@ vcpu pointer always in r0</span>
 	bic	r3, r2, r3		@ Don&#39;t trap defined coproc-accesses
 	.endif
 	mcr	p15, 4, r3, c1, c1, 2
<span class="p_add">+	.if \operation != vmentry</span>
<span class="p_add">+	.if \operation == vmexit</span>
<span class="p_add">+	tst	r2, #(HCPTR_TCP(10) | HCPTR_TCP(11))</span>
<span class="p_add">+	beq	1f</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	.if \label != none</span>
<span class="p_add">+	b	\label</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+1:</span>
<span class="p_add">+	.endif</span>
 .endm
 
 /* Configures the HDCR (Hyp Debug Configuration Register) on entry/return
<span class="p_header">diff --git a/arch/arm/mach-imx/clk-imx6q.c b/arch/arm/mach-imx/clk-imx6q.c</span>
<span class="p_header">index 3433b10ca968..032d1b958889 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/clk-imx6q.c</span>
<span class="p_header">+++ b/arch/arm/mach-imx/clk-imx6q.c</span>
<span class="p_chunk">@@ -413,7 +413,7 @@</span> <span class="p_context"> static void __init imx6q_clocks_init(struct device_node *ccm_node)</span>
 	clk[gpmi_io]      = imx_clk_gate2(&quot;gpmi_io&quot;,       &quot;enfc&quot;,              base + 0x78, 28);
 	clk[gpmi_apb]     = imx_clk_gate2(&quot;gpmi_apb&quot;,      &quot;usdhc3&quot;,            base + 0x78, 30);
 	clk[rom]          = imx_clk_gate2(&quot;rom&quot;,           &quot;ahb&quot;,               base + 0x7c, 0);
<span class="p_del">-	clk[sata]         = imx_clk_gate2(&quot;sata&quot;,          &quot;ipg&quot;,               base + 0x7c, 4);</span>
<span class="p_add">+	clk[sata]         = imx_clk_gate2(&quot;sata&quot;,          &quot;ahb&quot;,               base + 0x7c, 4);</span>
 	clk[sdma]         = imx_clk_gate2(&quot;sdma&quot;,          &quot;ahb&quot;,               base + 0x7c, 6);
 	clk[spba]         = imx_clk_gate2(&quot;spba&quot;,          &quot;ipg&quot;,               base + 0x7c, 12);
 	clk[spdif]        = imx_clk_gate2(&quot;spdif&quot;,         &quot;spdif_podf&quot;,    	base + 0x7c, 14);
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/Makefile b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">index a268a9af0c2d..a622dd0be9c4 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/Makefile</span>
<span class="p_chunk">@@ -15,6 +15,10 @@</span> <span class="p_context"> ccflags-y := -shared -fno-common -fno-builtin</span>
 ccflags-y += -nostdlib -Wl,-soname=linux-vdso.so.1 \
 		$(call cc-ldoption, -Wl$(comma)--hash-style=sysv)
 
<span class="p_add">+# Workaround for bare-metal (ELF) toolchains that neglect to pass -shared</span>
<span class="p_add">+# down to collect2, resulting in silent corruption of the vDSO image.</span>
<span class="p_add">+ccflags-y += -Wl,-shared</span>
<span class="p_add">+</span>
 obj-y += vdso.o
 extra-y += vdso.lds vdso-offsets.h
 CPPFLAGS_vdso.lds += -P -C -U$(ARCH)
<span class="p_header">diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c</span>
<span class="p_header">index baa758d37021..76c1e6cd36fc 100644</span>
<span class="p_header">--- a/arch/arm64/mm/context.c</span>
<span class="p_header">+++ b/arch/arm64/mm/context.c</span>
<span class="p_chunk">@@ -92,6 +92,14 @@</span> <span class="p_context"> static void reset_context(void *info)</span>
 	unsigned int cpu = smp_processor_id();
 	struct mm_struct *mm = current-&gt;active_mm;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * current-&gt;active_mm could be init_mm for the idle thread immediately</span>
<span class="p_add">+	 * after secondary CPU boot or hotplug. TTBR0_EL1 is already set to</span>
<span class="p_add">+	 * the reserved value, so no need to reset any context.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mm == &amp;init_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	smp_rmb();
 	asid = cpu_last_asid + cpu;
 
<span class="p_header">diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">index 023747bf4dd7..e3a24b75e53c 100644</span>
<span class="p_header">--- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -46,13 +46,13 @@</span> <span class="p_context"> struct page *follow_huge_addr(struct mm_struct *mm, unsigned long address,</span>
 
 int pmd_huge(pmd_t pmd)
 {
<span class="p_del">-	return !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
<span class="p_add">+	return pmd_val(pmd) &amp;&amp; !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
 }
 
 int pud_huge(pud_t pud)
 {
 #ifndef __PAGETABLE_PMD_FOLDED
<span class="p_del">-	return !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
<span class="p_add">+	return pud_val(pud) &amp;&amp; !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
 #else
 	return 0;
 #endif
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index e90c5426fe14..01bfca35b0aa 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static void __init free_unused_memmap(void)</span>
 		 * memmap entries are valid from the bank end aligned to
 		 * MAX_ORDER_NR_PAGES.
 		 */
<span class="p_del">-		prev_end = ALIGN(start + __phys_to_pfn(reg-&gt;size),</span>
<span class="p_add">+		prev_end = ALIGN(__phys_to_pfn(reg-&gt;base + reg-&gt;size),</span>
 				 MAX_ORDER_NR_PAGES);
 	}
 
<span class="p_header">diff --git a/arch/mips/include/asm/mach-generic/spaces.h b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">index 9488fa5f8866..afc96ecb9004 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-generic/spaces.h</span>
<span class="p_chunk">@@ -94,7 +94,11 @@</span> <span class="p_context"></span>
 #endif
 
 #ifndef FIXADDR_TOP
<span class="p_add">+#ifdef CONFIG_KVM_GUEST</span>
<span class="p_add">+#define FIXADDR_TOP		((unsigned long)(long)(int)0x7ffe0000)</span>
<span class="p_add">+#else</span>
 #define FIXADDR_TOP		((unsigned long)(long)(int)0xfffe0000)
 #endif
<span class="p_add">+#endif</span>
 
 #endif /* __ASM_MACH_GENERIC_SPACES_H */
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips.c b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">index 59298b97ac39..cc721a3c8996 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips.c</span>
<span class="p_chunk">@@ -813,7 +813,7 @@</span> <span class="p_context"> int kvm_vm_ioctl_get_dirty_log(struct kvm *kvm, struct kvm_dirty_log *log)</span>
 
 	/* If nothing is dirty, don&#39;t bother messing with page tables. */
 	if (is_dirty) {
<span class="p_del">-		memslot = &amp;kvm-&gt;memslots-&gt;memslots[log-&gt;slot];</span>
<span class="p_add">+		memslot = id_to_memslot(kvm-&gt;memslots, log-&gt;slot);</span>
 
 		ga = memslot-&gt;base_gfn &lt;&lt; PAGE_SHIFT;
 		ga_end = ga + (memslot-&gt;npages &lt;&lt; PAGE_SHIFT);
<span class="p_header">diff --git a/arch/powerpc/perf/core-book3s.c b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">index fe52db2eea6a..97579de6853b 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/core-book3s.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/core-book3s.c</span>
<span class="p_chunk">@@ -126,7 +126,16 @@</span> <span class="p_context"> static void pmao_restore_workaround(bool ebb) { }</span>
 
 static bool regs_use_siar(struct pt_regs *regs)
 {
<span class="p_del">-	return !!regs-&gt;result;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we take a performance monitor exception the regs are setup</span>
<span class="p_add">+	 * using perf_read_regs() which overloads some fields, in particular</span>
<span class="p_add">+	 * regs-&gt;result to tell us whether to use SIAR.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * However if the regs are from another exception, eg. a syscall, then</span>
<span class="p_add">+	 * they have not been setup using perf_read_regs() and so regs-&gt;result</span>
<span class="p_add">+	 * is something random.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return ((TRAP(regs) == 0xf00) &amp;&amp; regs-&gt;result);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index 06685498b681..7d82a2321fc7 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -416,11 +416,10 @@</span> <span class="p_context"> static ssize_t dlpar_cpu_probe(const char *buf, size_t count)</span>
 		return -ENODEV;
 
 	dn = dlpar_configure_connector(drc_index, parent);
<span class="p_add">+	of_node_put(parent);</span>
 	if (!dn)
 		return -EINVAL;
 
<span class="p_del">-	of_node_put(parent);</span>
<span class="p_del">-</span>
 	rc = dlpar_attach_node(dn);
 	if (rc) {
 		dlpar_release_drc(drc_index);
<span class="p_header">diff --git a/arch/sparc/kernel/ldc.c b/arch/sparc/kernel/ldc.c</span>
<span class="p_header">index 27bb55485472..7ef28625c199 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/ldc.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/ldc.c</span>
<span class="p_chunk">@@ -2307,7 +2307,7 @@</span> <span class="p_context"> void *ldc_alloc_exp_dring(struct ldc_channel *lp, unsigned int len,</span>
 	if (len &amp; (8UL - 1))
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	buf = kzalloc(len, GFP_KERNEL);</span>
<span class="p_add">+	buf = kzalloc(len, GFP_ATOMIC);</span>
 	if (!buf)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 04fe4a66c3ec..a51d8286c75d 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -2405,9 +2405,19 @@</span> <span class="p_context"> config X86_DMA_REMAP</span>
 	depends on STA2X11
 
 config IOSF_MBI
<span class="p_del">-	tristate</span>
<span class="p_del">-	default m</span>
<span class="p_add">+	tristate &quot;Intel System On Chip IOSF Sideband support&quot;</span>
 	depends on PCI
<span class="p_add">+	---help---</span>
<span class="p_add">+	  Enables sideband access to mailbox registers on SoC&#39;s. The sideband is</span>
<span class="p_add">+	  available on the following platforms. This list is not meant to be</span>
<span class="p_add">+	  exclusive.</span>
<span class="p_add">+	   - BayTrail</span>
<span class="p_add">+	   - Cherryview</span>
<span class="p_add">+	   - Braswell</span>
<span class="p_add">+	   - Quark</span>
<span class="p_add">+</span>
<span class="p_add">+	  You should say Y if you are running a kernel on one of these</span>
<span class="p_add">+	  platforms.</span>
 
 source &quot;net/Kconfig&quot;
 
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index 554dcdf7ad82..b1ecb145d9a5 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -571,7 +571,7 @@</span> <span class="p_context"> struct kvm_arch {</span>
 	struct kvm_pic *vpic;
 	struct kvm_ioapic *vioapic;
 	struct kvm_pit *vpit;
<span class="p_del">-	int vapics_in_nmi_mode;</span>
<span class="p_add">+	atomic_t vapics_in_nmi_mode;</span>
 	struct mutex apic_map_lock;
 	struct kvm_apic_map *apic_map;
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">index 9a79c8dbd8e8..5648b506f3ae 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_chunk">@@ -660,6 +660,7 @@</span> <span class="p_context"> static int mce_no_way_out(struct mce *m, char **msg, unsigned long *validp,</span>
 			  struct pt_regs *regs)
 {
 	int i, ret = 0;
<span class="p_add">+	char *tmp;</span>
 
 	for (i = 0; i &lt; mca_cfg.banks; i++) {
 		m-&gt;status = mce_rdmsrl(MSR_IA32_MCx_STATUS(i));
<span class="p_chunk">@@ -668,8 +669,11 @@</span> <span class="p_context"> static int mce_no_way_out(struct mce *m, char **msg, unsigned long *validp,</span>
 			if (quirk_no_way_out)
 				quirk_no_way_out(i, m, regs);
 		}
<span class="p_del">-		if (mce_severity(m, mca_cfg.tolerant, msg) &gt;= MCE_PANIC_SEVERITY)</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mce_severity(m, mca_cfg.tolerant, &amp;tmp) &gt;= MCE_PANIC_SEVERITY) {</span>
<span class="p_add">+			*msg = tmp;</span>
 			ret = 1;
<span class="p_add">+		}</span>
 	}
 	return ret;
 }
<span class="p_header">diff --git a/arch/x86/kvm/i8254.c b/arch/x86/kvm/i8254.c</span>
<span class="p_header">index 298781d4cfb4..1406ffde3e35 100644</span>
<span class="p_header">--- a/arch/x86/kvm/i8254.c</span>
<span class="p_header">+++ b/arch/x86/kvm/i8254.c</span>
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> static void pit_do_work(struct kthread_work *work)</span>
 		 * LVT0 to NMI delivery. Other PIC interrupts are just sent to
 		 * VCPU0, and only if its LVT0 is in EXTINT mode.
 		 */
<span class="p_del">-		if (kvm-&gt;arch.vapics_in_nmi_mode &gt; 0)</span>
<span class="p_add">+		if (atomic_read(&amp;kvm-&gt;arch.vapics_in_nmi_mode) &gt; 0)</span>
 			kvm_for_each_vcpu(i, vcpu, kvm)
 				kvm_apic_nmi_wd_deliver(vcpu);
 	}
<span class="p_header">diff --git a/arch/x86/kvm/lapic.c b/arch/x86/kvm/lapic.c</span>
<span class="p_header">index f96b8a4d3fed..1f4e8e4ea865 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.c</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.c</span>
<span class="p_chunk">@@ -1115,10 +1115,10 @@</span> <span class="p_context"> static void apic_manage_nmi_watchdog(struct kvm_lapic *apic, u32 lvt0_val)</span>
 		if (!nmi_wd_enabled) {
 			apic_debug(&quot;Receive NMI setting on APIC_LVT0 &quot;
 				   &quot;for cpu %d\n&quot;, apic-&gt;vcpu-&gt;vcpu_id);
<span class="p_del">-			apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode++;</span>
<span class="p_add">+			atomic_inc(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 		}
 	} else if (nmi_wd_enabled)
<span class="p_del">-		apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode--;</span>
<span class="p_add">+		atomic_dec(&amp;apic-&gt;vcpu-&gt;kvm-&gt;arch.vapics_in_nmi_mode);</span>
 }
 
 static int apic_reg_write(struct kvm_lapic *apic, u32 reg, u32 val)
<span class="p_chunk">@@ -1685,6 +1685,7 @@</span> <span class="p_context"> void kvm_apic_post_state_restore(struct kvm_vcpu *vcpu,</span>
 
 	apic_update_ppr(apic);
 	hrtimer_cancel(&amp;apic-&gt;lapic_timer.timer);
<span class="p_add">+	apic_manage_nmi_watchdog(apic, kvm_apic_get_reg(apic, APIC_LVT0));</span>
 	update_divide_count(apic);
 	start_apic_timer(apic);
 	apic-&gt;irr_pending = true;
<span class="p_header">diff --git a/arch/x86/kvm/lapic.h b/arch/x86/kvm/lapic.h</span>
<span class="p_header">index 6a11845fd8b9..72051730caf1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/lapic.h</span>
<span class="p_header">+++ b/arch/x86/kvm/lapic.h</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> static inline u16 apic_logical_id(struct kvm_apic_map *map, u32 ldr)</span>
 
 static inline bool kvm_apic_has_events(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	return vcpu-&gt;arch.apic-&gt;pending_events;</span>
<span class="p_add">+	return kvm_vcpu_has_lapic(vcpu) &amp;&amp; vcpu-&gt;arch.apic-&gt;pending_events;</span>
 }
 
 bool kvm_apic_pending_eoi(struct kvm_vcpu *vcpu, int vector);
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 1c10d9071958..37e85d0a1940 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -511,8 +511,10 @@</span> <span class="p_context"> static void skip_emulated_instruction(struct kvm_vcpu *vcpu)</span>
 {
 	struct vcpu_svm *svm = to_svm(vcpu);
 
<span class="p_del">-	if (svm-&gt;vmcb-&gt;control.next_rip != 0)</span>
<span class="p_add">+	if (svm-&gt;vmcb-&gt;control.next_rip != 0) {</span>
<span class="p_add">+		WARN_ON(!static_cpu_has(X86_FEATURE_NRIPS));</span>
 		svm-&gt;next_rip = svm-&gt;vmcb-&gt;control.next_rip;
<span class="p_add">+	}</span>
 
 	if (!svm-&gt;next_rip) {
 		if (emulate_instruction(vcpu, EMULTYPE_SKIP) !=
<span class="p_chunk">@@ -4282,7 +4284,9 @@</span> <span class="p_context"> static int svm_check_intercept(struct kvm_vcpu *vcpu,</span>
 		break;
 	}
 
<span class="p_del">-	vmcb-&gt;control.next_rip  = info-&gt;next_rip;</span>
<span class="p_add">+	/* TODO: Advertise NRIPS to guest hypervisor unconditionally */</span>
<span class="p_add">+	if (static_cpu_has(X86_FEATURE_NRIPS))</span>
<span class="p_add">+		vmcb-&gt;control.next_rip  = info-&gt;next_rip;</span>
 	vmcb-&gt;control.exit_code = icpt_info.exit_code;
 	vmexit = nested_svm_exit_handled(svm);
 
<span class="p_header">diff --git a/arch/x86/pci/acpi.c b/arch/x86/pci/acpi.c</span>
<span class="p_header">index 5075371ab593..0f8002ca2a5c 100644</span>
<span class="p_header">--- a/arch/x86/pci/acpi.c</span>
<span class="p_header">+++ b/arch/x86/pci/acpi.c</span>
<span class="p_chunk">@@ -84,6 +84,17 @@</span> <span class="p_context"> static const struct dmi_system_id pci_crs_quirks[] __initconst = {</span>
 			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),
 		},
 	},
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/931368 */</span>
<span class="p_add">+	/* https://bugs.launchpad.net/ubuntu/+source/alsa-driver/+bug/1033299 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = set_use_crs,</span>
<span class="p_add">+		.ident = &quot;Foxconn K8M890-8237A&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_VENDOR, &quot;Foxconn&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BOARD_NAME, &quot;K8M890-8237A&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_BIOS_VENDOR, &quot;Phoenix Technologies, LTD&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 
 	/* Now for the blacklist.. */
 
<span class="p_chunk">@@ -124,8 +135,10 @@</span> <span class="p_context"> void __init pci_acpi_crs_quirks(void)</span>
 {
 	int year;
 
<span class="p_del">-	if (dmi_get_date(DMI_BIOS_DATE, &amp;year, NULL, NULL) &amp;&amp; year &lt; 2008)</span>
<span class="p_del">-		pci_use_crs = false;</span>
<span class="p_add">+	if (dmi_get_date(DMI_BIOS_DATE, &amp;year, NULL, NULL) &amp;&amp; year &lt; 2008) {</span>
<span class="p_add">+		if (iomem_resource.end &lt;= 0xffffffff)</span>
<span class="p_add">+			pci_use_crs = false;</span>
<span class="p_add">+	}</span>
 
 	dmi_check_system(pci_crs_quirks);
 
<span class="p_header">diff --git a/drivers/acpi/acpica/aclocal.h b/drivers/acpi/acpica/aclocal.h</span>
<span class="p_header">index 494775a67ffa..3fc71e7fb847 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/aclocal.h</span>
<span class="p_header">+++ b/drivers/acpi/acpica/aclocal.h</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> struct acpi_table_list {</span>
 
 #define ACPI_TABLE_INDEX_DSDT           (0)
 #define ACPI_TABLE_INDEX_FACS           (1)
<span class="p_add">+#define ACPI_TABLE_INDEX_X_FACS         (2)</span>
 
 struct acpi_find_context {
 	char *search_for;
<span class="p_header">diff --git a/drivers/acpi/acpica/tbfadt.c b/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_header">index 41519a958083..dfa3f367f364 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_chunk">@@ -350,9 +350,18 @@</span> <span class="p_context"> void acpi_tb_parse_fadt(u32 table_index)</span>
 	/* If Hardware Reduced flag is set, there is no FACS */
 
 	if (!acpi_gbl_reduced_hardware) {
<span class="p_del">-		acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_del">-					    acpi_gbl_FADT.Xfacs, ACPI_SIG_FACS,</span>
<span class="p_del">-					    ACPI_TABLE_INDEX_FACS);</span>
<span class="p_add">+		if (acpi_gbl_FADT.facs) {</span>
<span class="p_add">+			acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_add">+						    acpi_gbl_FADT.facs,</span>
<span class="p_add">+						    ACPI_SIG_FACS,</span>
<span class="p_add">+						    ACPI_TABLE_INDEX_FACS);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (acpi_gbl_FADT.Xfacs) {</span>
<span class="p_add">+			acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_add">+						    acpi_gbl_FADT.Xfacs,</span>
<span class="p_add">+						    ACPI_SIG_FACS,</span>
<span class="p_add">+						    ACPI_TABLE_INDEX_X_FACS);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -491,13 +500,9 @@</span> <span class="p_context"> static void acpi_tb_convert_fadt(void)</span>
 	acpi_gbl_FADT.header.length = sizeof(struct acpi_table_fadt);
 
 	/*
<span class="p_del">-	 * Expand the 32-bit FACS and DSDT addresses to 64-bit as necessary.</span>
<span class="p_add">+	 * Expand the 32-bit DSDT addresses to 64-bit as necessary.</span>
 	 * Later ACPICA code will always use the X 64-bit field.
 	 */
<span class="p_del">-	acpi_gbl_FADT.Xfacs = acpi_tb_select_address(&quot;FACS&quot;,</span>
<span class="p_del">-						     acpi_gbl_FADT.facs,</span>
<span class="p_del">-						     acpi_gbl_FADT.Xfacs);</span>
<span class="p_del">-</span>
 	acpi_gbl_FADT.Xdsdt = acpi_tb_select_address(&quot;DSDT&quot;,
 						     acpi_gbl_FADT.dsdt,
 						     acpi_gbl_FADT.Xdsdt);
<span class="p_header">diff --git a/drivers/acpi/acpica/tbutils.c b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">index 6b1ca9991b90..0912b166ac66 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> acpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size);</span>
 
 acpi_status acpi_tb_initialize_facs(void)
 {
<span class="p_del">-	acpi_status status;</span>
<span class="p_add">+	struct acpi_table_facs *facs32;</span>
<span class="p_add">+	struct acpi_table_facs *facs64;</span>
 
 	/* If Hardware Reduced flag is set, there is no FACS */
 
<span class="p_chunk">@@ -77,11 +78,22 @@</span> <span class="p_context"> acpi_status acpi_tb_initialize_facs(void)</span>
 		return (AE_OK);
 	}
 
<span class="p_del">-	status = acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,</span>
<span class="p_del">-					 ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_del">-								acpi_table_header,</span>
<span class="p_del">-								&amp;acpi_gbl_FACS));</span>
<span class="p_del">-	return (status);</span>
<span class="p_add">+	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,</span>
<span class="p_add">+				      ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_add">+							     acpi_table_header,</span>
<span class="p_add">+							     &amp;facs32));</span>
<span class="p_add">+	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_X_FACS,</span>
<span class="p_add">+				      ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_add">+							     acpi_table_header,</span>
<span class="p_add">+							     &amp;facs64));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (acpi_gbl_use32_bit_facs_addresses) {</span>
<span class="p_add">+		acpi_gbl_FACS = facs32 ? facs32 : facs64;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		acpi_gbl_FACS = facs64 ? facs64 : facs32;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return (AE_OK);</span>
 }
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_chunk">@@ -101,7 +113,7 @@</span> <span class="p_context"> acpi_status acpi_tb_initialize_facs(void)</span>
 u8 acpi_tb_tables_loaded(void)
 {
 
<span class="p_del">-	if (acpi_gbl_root_table_list.current_table_count &gt;= 3) {</span>
<span class="p_add">+	if (acpi_gbl_root_table_list.current_table_count &gt;= 4) {</span>
 		return (TRUE);
 	}
 
<span class="p_chunk">@@ -357,11 +369,11 @@</span> <span class="p_context"> acpi_status __init acpi_tb_parse_root_table(acpi_physical_address rsdp_address)</span>
 	table_entry = ACPI_ADD_PTR(u8, table, sizeof(struct acpi_table_header));
 
 	/*
<span class="p_del">-	 * First two entries in the table array are reserved for the DSDT</span>
<span class="p_del">-	 * and FACS, which are not actually present in the RSDT/XSDT - they</span>
<span class="p_del">-	 * come from the FADT</span>
<span class="p_add">+	 * First three entries in the table array are reserved for the DSDT</span>
<span class="p_add">+	 * and 32bit/64bit FACS, which are not actually present in the</span>
<span class="p_add">+	 * RSDT/XSDT - they come from the FADT</span>
 	 */
<span class="p_del">-	acpi_gbl_root_table_list.current_table_count = 2;</span>
<span class="p_add">+	acpi_gbl_root_table_list.current_table_count = 3;</span>
 
 	/* Initialize the root table array from the RSDT/XSDT */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfload.c b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">index ab5308b81aa8..435f71648e17 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_chunk">@@ -166,7 +166,8 @@</span> <span class="p_context"> static acpi_status acpi_tb_load_namespace(void)</span>
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 	for (i = 0; i &lt; acpi_gbl_root_table_list.current_table_count; ++i) {
<span class="p_del">-		if ((!ACPI_COMPARE_NAME</span>
<span class="p_add">+		if (!acpi_gbl_root_table_list.tables[i].address ||</span>
<span class="p_add">+		    (!ACPI_COMPARE_NAME</span>
 		     (&amp;(acpi_gbl_root_table_list.tables[i].signature),
 		      ACPI_SIG_SSDT)
 		     &amp;&amp;
<span class="p_header">diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">index 13380d818462..64f8f307243b 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_chunk">@@ -175,10 +175,12 @@</span> <span class="p_context"> acpi_status __init acpi_enable_subsystem(u32 flags)</span>
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
<span class="p_del">-	status = acpi_tb_initialize_facs();</span>
<span class="p_del">-	if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-		ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_del">-		return_ACPI_STATUS(status);</span>
<span class="p_add">+	if (!(flags &amp; ACPI_NO_FACS_INIT)) {</span>
<span class="p_add">+		status = acpi_tb_initialize_facs();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
 	}
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_header">diff --git a/drivers/acpi/bus.c b/drivers/acpi/bus.c</span>
<span class="p_header">index c5bc8cfe09fa..60a38349f297 100644</span>
<span class="p_header">--- a/drivers/acpi/bus.c</span>
<span class="p_header">+++ b/drivers/acpi/bus.c</span>
<span class="p_chunk">@@ -480,6 +480,16 @@</span> <span class="p_context"> static int __init acpi_bus_init_irq(void)</span>
 u8 acpi_gbl_permanent_mmap;
 
 
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_early_init - Initialize ACPICA and populate the ACPI namespace.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The ACPI tables are accessible after this, but the handling of events has not</span>
<span class="p_add">+ * been initialized and the global lock is not available yet, so AML should not</span>
<span class="p_add">+ * be executed at this point.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Doing this before switching the EFI runtime services to virtual mode allows</span>
<span class="p_add">+ * the EfiBootServices memory to be freed slightly earlier on boot.</span>
<span class="p_add">+ */</span>
 void __init acpi_early_init(void)
 {
 	acpi_status status;
<span class="p_chunk">@@ -543,26 +553,42 @@</span> <span class="p_context"> void __init acpi_early_init(void)</span>
 		acpi_gbl_FADT.sci_interrupt = acpi_sci_override_gsi;
 	}
 #endif
<span class="p_add">+	return;</span>
<span class="p_add">+</span>
<span class="p_add">+ error0:</span>
<span class="p_add">+	disable_acpi();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * acpi_subsystem_init - Finalize the early initialization of ACPI.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Switch over the platform to the ACPI mode (if possible), initialize the</span>
<span class="p_add">+ * handling of ACPI events, install the interrupt and global lock handlers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Doing this too early is generally unsafe, but at the same time it needs to be</span>
<span class="p_add">+ * done before all things that really depend on ACPI.  The right spot appears to</span>
<span class="p_add">+ * be before finalizing the EFI initialization.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __init acpi_subsystem_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	acpi_status status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (acpi_disabled)</span>
<span class="p_add">+		return;</span>
 
 	status = acpi_enable_subsystem(~ACPI_NO_ACPI_ENABLE);
 	if (ACPI_FAILURE(status)) {
 		printk(KERN_ERR PREFIX &quot;Unable to enable ACPI\n&quot;);
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		disable_acpi();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the system is using ACPI then we can be reasonably</span>
<span class="p_add">+		 * confident that any regulators are managed by the firmware</span>
<span class="p_add">+		 * so tell the regulator core it has everything it needs to</span>
<span class="p_add">+		 * know.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		regulator_has_full_constraints();</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If the system is using ACPI then we can be reasonably</span>
<span class="p_del">-	 * confident that any regulators are managed by the firmware</span>
<span class="p_del">-	 * so tell the regulator core it has everything it needs to</span>
<span class="p_del">-	 * know.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	regulator_has_full_constraints();</span>
<span class="p_del">-</span>
<span class="p_del">-	return;</span>
<span class="p_del">-</span>
<span class="p_del">-      error0:</span>
<span class="p_del">-	disable_acpi();</span>
<span class="p_del">-	return;</span>
 }
 
 static int __init acpi_bus_init(void)
<span class="p_header">diff --git a/drivers/acpi/device_pm.c b/drivers/acpi/device_pm.c</span>
<span class="p_header">index f702dcef4df9..e9f44a210712 100644</span>
<span class="p_header">--- a/drivers/acpi/device_pm.c</span>
<span class="p_header">+++ b/drivers/acpi/device_pm.c</span>
<span class="p_chunk">@@ -930,6 +930,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(acpi_subsys_prepare);</span>
  */
 void acpi_subsys_complete(struct device *dev)
 {
<span class="p_add">+	pm_generic_complete(dev);</span>
 	/*
 	 * If the device had been runtime-suspended before the system went into
 	 * the sleep state it is going out of and it has never been resumed till
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index 1b2d872c7398..5e240a479b71 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *gas,</span>
 		request_mem_region(addr, length, desc);
 }
 
<span class="p_del">-static void __init acpi_reserve_resources(void)</span>
<span class="p_add">+static int __init acpi_reserve_resources(void)</span>
 {
 	acpi_request_region(&amp;acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		&quot;ACPI PM1a_EVT_BLK&quot;);
<span class="p_chunk">@@ -201,7 +201,10 @@</span> <span class="p_context"> static void __init acpi_reserve_resources(void)</span>
 	if (!(acpi_gbl_FADT.gpe1_block_length &amp; 0x1))
 		acpi_request_region(&amp;acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, &quot;ACPI GPE1_BLK&quot;);
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
<span class="p_add">+fs_initcall_sync(acpi_reserve_resources);</span>
 
 void acpi_os_printf(const char *fmt, ...)
 {
<span class="p_chunk">@@ -1824,7 +1827,6 @@</span> <span class="p_context"> acpi_status __init acpi_os_initialize(void)</span>
 
 acpi_status __init acpi_os_initialize1(void)
 {
<span class="p_del">-	acpi_reserve_resources();</span>
 	kacpid_wq = alloc_workqueue(&quot;kacpid&quot;, 0, 1);
 	kacpi_notify_wq = alloc_workqueue(&quot;kacpi_notify&quot;, 0, 1);
 	kacpi_hotplug_wq = alloc_ordered_workqueue(&quot;kacpi_hotplug&quot;, 0);
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 29358ff3e05e..a554b2e17cd4 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4224,7 +4224,7 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;PIONEER DVD-RW  DVR-216D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 
 	/* devices that don&#39;t properly handle queued TRIM commands */
<span class="p_del">-	{ &quot;Micron_M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
<span class="p_add">+	{ &quot;Micron_M500_*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },</span>
 	{ &quot;Crucial_CT*M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Micron_M5[15]0*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },
 	{ &quot;Crucial_CT*M550*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM, },
<span class="p_header">diff --git a/drivers/base/regmap/regmap.c b/drivers/base/regmap/regmap.c</span>
<span class="p_header">index 457d335f8495..27487c289ee0 100644</span>
<span class="p_header">--- a/drivers/base/regmap/regmap.c</span>
<span class="p_header">+++ b/drivers/base/regmap/regmap.c</span>
<span class="p_chunk">@@ -887,11 +887,10 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(devm_regmap_init);</span>
 static void regmap_field_init(struct regmap_field *rm_field,
 	struct regmap *regmap, struct reg_field reg_field)
 {
<span class="p_del">-	int field_bits = reg_field.msb - reg_field.lsb + 1;</span>
 	rm_field-&gt;regmap = regmap;
 	rm_field-&gt;reg = reg_field.reg;
 	rm_field-&gt;shift = reg_field.lsb;
<span class="p_del">-	rm_field-&gt;mask = ((BIT(field_bits) - 1) &lt;&lt; reg_field.lsb);</span>
<span class="p_add">+	rm_field-&gt;mask = GENMASK(reg_field.msb, reg_field.lsb);</span>
 	rm_field-&gt;id_size = reg_field.id_size;
 	rm_field-&gt;id_offset = reg_field.id_offset;
 }
<span class="p_chunk">@@ -2247,7 +2246,7 @@</span> <span class="p_context"> int regmap_bulk_read(struct regmap *map, unsigned int reg, void *val,</span>
 					  &amp;ival);
 			if (ret != 0)
 				return ret;
<span class="p_del">-			memcpy(val + (i * val_bytes), &amp;ival, val_bytes);</span>
<span class="p_add">+			map-&gt;format.format_val(val + (i * val_bytes), ival, 0);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index f017d1964eb6..b3fdc1b7ea76 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -1909,11 +1909,11 @@</span> <span class="p_context"> static struct rbd_obj_request *rbd_obj_request_create(const char *object_name,</span>
 	rbd_assert(obj_request_type_valid(type));
 
 	size = strlen(object_name) + 1;
<span class="p_del">-	name = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	name = kmalloc(size, GFP_NOIO);</span>
 	if (!name)
 		return NULL;
 
<span class="p_del">-	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_KERNEL);</span>
<span class="p_add">+	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);</span>
 	if (!obj_request) {
 		kfree(name);
 		return NULL;
<span class="p_header">diff --git a/drivers/bluetooth/ath3k.c b/drivers/bluetooth/ath3k.c</span>
<span class="p_header">index b526e7c7b109..5b19c4384ec5 100644</span>
<span class="p_header">--- a/drivers/bluetooth/ath3k.c</span>
<span class="p_header">+++ b/drivers/bluetooth/ath3k.c</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe057) },
 	{ USB_DEVICE(0x0489, 0xe056) },
 	{ USB_DEVICE(0x0489, 0xe05f) },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076) },</span>
 	{ USB_DEVICE(0x0489, 0xe078) },
 	{ USB_DEVICE(0x04c5, 0x1330) },
 	{ USB_DEVICE(0x04CA, 0x3004) },
<span class="p_chunk">@@ -88,6 +89,8 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x04CA, 0x3007) },
 	{ USB_DEVICE(0x04CA, 0x3008) },
 	{ USB_DEVICE(0x04CA, 0x300b) },
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300d) },</span>
<span class="p_add">+	{ USB_DEVICE(0x04CA, 0x300f) },</span>
 	{ USB_DEVICE(0x04CA, 0x3010) },
 	{ USB_DEVICE(0x0930, 0x0219) },
 	{ USB_DEVICE(0x0930, 0x0220) },
<span class="p_chunk">@@ -111,6 +114,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408) },
 	{ USB_DEVICE(0x13d3, 0x3423) },
 	{ USB_DEVICE(0x13d3, 0x3432) },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474) },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE02C) },
<span class="p_chunk">@@ -135,6 +139,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -143,6 +148,8 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -166,6 +173,7 @@</span> <span class="p_context"> static const struct usb_device_id ath3k_blist_tbl[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU22 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xE036), .driver_info = BTUSB_ATH3012 },
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index ae854bab7dfa..41abfa124c34 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -170,6 +170,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0489, 0xe056), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe057), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0489, 0xe05f), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x0489, 0xe076), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x0489, 0xe078), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04c5, 0x1330), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3004), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -178,6 +179,8 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x04ca, 0x3007), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x3008), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x04ca, 0x300b), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300d), .driver_info = BTUSB_ATH3012 },</span>
<span class="p_add">+	{ USB_DEVICE(0x04ca, 0x300f), .driver_info = BTUSB_ATH3012 },</span>
 	{ USB_DEVICE(0x04ca, 0x3010), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0219), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x0930, 0x0220), .driver_info = BTUSB_ATH3012 },
<span class="p_chunk">@@ -201,6 +204,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x13d3, 0x3408), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3423), .driver_info = BTUSB_ATH3012 },
 	{ USB_DEVICE(0x13d3, 0x3432), .driver_info = BTUSB_ATH3012 },
<span class="p_add">+	{ USB_DEVICE(0x13d3, 0x3474), .driver_info = BTUSB_ATH3012 },</span>
 
 	/* Atheros AR5BBU12 with sflash firmware */
 	{ USB_DEVICE(0x0489, 0xe02c), .driver_info = BTUSB_IGNORE },
<span class="p_chunk">@@ -1305,6 +1309,8 @@</span> <span class="p_context"> static int btusb_setup_intel(struct hci_dev *hdev)</span>
 	}
 	fw_ptr = fw-&gt;data;
 
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+</span>
 	/* This Intel specific command enables the manufacturer mode of the
 	 * controller.
 	 *
<span class="p_header">diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">index 9a024f899dd4..9a99d0a3ff08 100644</span>
<span class="p_header">--- a/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">+++ b/drivers/char/agp/intel-gtt.c</span>
<span class="p_chunk">@@ -585,7 +585,7 @@</span> <span class="p_context"> static inline int needs_ilk_vtd_wa(void)</span>
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
<span class="p_del">-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||</span>
<span class="p_add">+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||</span>
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &amp;&amp;
 	     intel_iommu_gfx_mapped)
 		return 1;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 102463ba745d..643bba7d6f81 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -579,6 +579,9 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	ibmvtpm-&gt;dev = dev;</span>
<span class="p_add">+	ibmvtpm-&gt;vdev = vio_dev;</span>
<span class="p_add">+</span>
 	crq_q = &amp;ibmvtpm-&gt;crq_queue;
 	crq_q-&gt;crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);
 	if (!crq_q-&gt;crq_addr) {
<span class="p_chunk">@@ -623,8 +626,6 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 
 	crq_q-&gt;index = 0;
 
<span class="p_del">-	ibmvtpm-&gt;dev = dev;</span>
<span class="p_del">-	ibmvtpm-&gt;vdev = vio_dev;</span>
 	TPM_VPRIV(chip) = (void *)ibmvtpm;
 
 	spin_lock_init(&amp;ibmvtpm-&gt;rtce_lock);
<span class="p_header">diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c</span>
<span class="p_header">index 1dee8d2086fb..604f79f867d1 100644</span>
<span class="p_header">--- a/drivers/clk/clk.c</span>
<span class="p_header">+++ b/drivers/clk/clk.c</span>
<span class="p_chunk">@@ -165,11 +165,12 @@</span> <span class="p_context"> static void clk_dump_one(struct seq_file *s, struct clk *c, int level)</span>
 	if (!c)
 		return;
 
<span class="p_add">+	/* This should be JSON format, i.e. elements separated with a comma */</span>
 	seq_printf(s, &quot;\&quot;%s\&quot;: { &quot;, c-&gt;name);
 	seq_printf(s, &quot;\&quot;enable_count\&quot;: %d,&quot;, c-&gt;enable_count);
 	seq_printf(s, &quot;\&quot;prepare_count\&quot;: %d,&quot;, c-&gt;prepare_count);
<span class="p_del">-	seq_printf(s, &quot;\&quot;rate\&quot;: %lu&quot;, clk_get_rate(c));</span>
<span class="p_del">-	seq_printf(s, &quot;\&quot;accuracy\&quot;: %lu&quot;, clk_get_accuracy(c));</span>
<span class="p_add">+	seq_printf(s, &quot;\&quot;rate\&quot;: %lu,&quot;, clk_get_rate(c));</span>
<span class="p_add">+	seq_printf(s, &quot;\&quot;accuracy\&quot;: %lu,&quot;, clk_get_accuracy(c));</span>
 }
 
 static void clk_dump_subtree(struct seq_file *s, struct clk *c, int level)
<span class="p_header">diff --git a/drivers/clk/ti/clk-dra7-atl.c b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">index af29359677da..d1db76887b8b 100644</span>
<span class="p_header">--- a/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">+++ b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_chunk">@@ -250,6 +250,11 @@</span> <span class="p_context"> static int of_dra7_atl_clk_probe(struct platform_device *pdev)</span>
 		}
 
 		clk = of_clk_get_from_provider(&amp;clkspec);
<span class="p_add">+		if (IS_ERR(clk)) {</span>
<span class="p_add">+			pr_err(&quot;%s: failed to get atl clock %d from provider\n&quot;,</span>
<span class="p_add">+			       __func__, i);</span>
<span class="p_add">+			return PTR_ERR(clk);</span>
<span class="p_add">+		}</span>
 
 		cdesc = to_atl_desc(__clk_get_hw(clk));
 		cdesc-&gt;cinfo = cinfo;
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index 336a60fbabf9..5d1b7f64947c 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -441,15 +441,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 	exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);
 
 	if (mct_int_type == MCT_INT_SPI) {
<span class="p_del">-		evt-&gt;irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_del">-		if (request_irq(evt-&gt;irq, exynos4_mct_tick_isr,</span>
<span class="p_del">-				IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_del">-				evt-&gt;name, mevt)) {</span>
<span class="p_del">-			pr_err(&quot;exynos-mct: cannot register IRQ %d\n&quot;,</span>
<span class="p_del">-				evt-&gt;irq);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (evt-&gt;irq == -1)</span>
 			return -EIO;
<span class="p_del">-		}</span>
<span class="p_del">-		irq_force_affinity(mct_irqs[MCT_L0_IRQ + cpu], cpumask_of(cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+		irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span>
<span class="p_add">+		enable_irq(evt-&gt;irq);</span>
 	} else {
 		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);
 	}
<span class="p_chunk">@@ -462,10 +459,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
 	evt-&gt;set_mode(CLOCK_EVT_MODE_UNUSED, evt);
<span class="p_del">-	if (mct_int_type == MCT_INT_SPI)</span>
<span class="p_del">-		free_irq(evt-&gt;irq, this_cpu_ptr(&amp;percpu_mct_tick));</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (mct_int_type == MCT_INT_SPI) {</span>
<span class="p_add">+		if (evt-&gt;irq != -1)</span>
<span class="p_add">+			disable_irq_nosync(evt-&gt;irq);</span>
<span class="p_add">+	} else {</span>
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
<span class="p_add">+	}</span>
 }
 
 static int exynos4_mct_cpu_notify(struct notifier_block *self,
<span class="p_chunk">@@ -497,7 +496,7 @@</span> <span class="p_context"> static struct notifier_block exynos4_mct_cpu_nb = {</span>
 
 static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, cpu;</span>
 	struct mct_clock_event_device *mevt = this_cpu_ptr(&amp;percpu_mct_tick);
 	struct clk *mct_clk, *tick_clk;
 
<span class="p_chunk">@@ -524,7 +523,25 @@</span> <span class="p_context"> static void __init exynos4_timer_resources(struct device_node *np, void __iomem</span>
 		WARN(err, &quot;MCT: can&#39;t request IRQ %d (%d)\n&quot;,
 		     mct_irqs[MCT_L0_IRQ], err);
 	} else {
<span class="p_del">-		irq_set_affinity(mct_irqs[MCT_L0_IRQ], cpumask_of(0));</span>
<span class="p_add">+		for_each_possible_cpu(cpu) {</span>
<span class="p_add">+			int mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_add">+			struct mct_clock_event_device *pcpu_mevt =</span>
<span class="p_add">+				per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span>
<span class="p_add">+			if (request_irq(mct_irq,</span>
<span class="p_add">+					exynos4_mct_tick_isr,</span>
<span class="p_add">+					IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_add">+					pcpu_mevt-&gt;name, pcpu_mevt)) {</span>
<span class="p_add">+				pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span>
<span class="p_add">+									cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = mct_irq;</span>
<span class="p_add">+		}</span>
 	}
 
 	err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index fafc7d05e1f9..0a91eea08198 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -442,7 +442,7 @@</span> <span class="p_context"> static void byt_set_pstate(struct cpudata *cpudata, int pstate)</span>
 
 	val |= vid;
 
<span class="p_del">-	wrmsrl(MSR_IA32_PERF_CTL, val);</span>
<span class="p_add">+	wrmsrl_on_cpu(cpudata-&gt;cpu, MSR_IA32_PERF_CTL, val);</span>
 }
 
 #define BYT_BCLK_FREQS 5
<span class="p_header">diff --git a/drivers/crypto/talitos.c b/drivers/crypto/talitos.c</span>
<span class="p_header">index 624b8be0c365..307931528eb2 100644</span>
<span class="p_header">--- a/drivers/crypto/talitos.c</span>
<span class="p_header">+++ b/drivers/crypto/talitos.c</span>
<span class="p_chunk">@@ -927,7 +927,8 @@</span> <span class="p_context"> static int sg_to_link_tbl(struct scatterlist *sg, int sg_count,</span>
 		sg_count--;
 		link_tbl_ptr--;
 	}
<span class="p_del">-	be16_add_cpu(&amp;link_tbl_ptr-&gt;len, cryptlen);</span>
<span class="p_add">+	link_tbl_ptr-&gt;len = cpu_to_be16(be16_to_cpu(link_tbl_ptr-&gt;len)</span>
<span class="p_add">+					+ cryptlen);</span>
 
 	/* tag end of link table */
 	link_tbl_ptr-&gt;j_extent = DESC_PTR_LNKTBL_RETURN;
<span class="p_chunk">@@ -2563,6 +2564,7 @@</span> <span class="p_context"> static struct talitos_crypto_alg *talitos_alg_alloc(struct device *dev,</span>
 		break;
 	default:
 		dev_err(dev, &quot;unknown algorithm type %d\n&quot;, t_alg-&gt;algt.type);
<span class="p_add">+		kfree(t_alg);</span>
 		return ERR_PTR(-EINVAL);
 	}
 
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index 394cbc5c93e3..6b2f01d60527 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -316,7 +316,8 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
<span class="p_del">-	int seen_current = 0;</span>
<span class="p_add">+	int current_cleaned = 0;</span>
<span class="p_add">+	struct mv_xor_desc *hw_desc;</span>
 
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;%s %d\n&quot;, __func__, __LINE__);
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;current_desc %x\n&quot;, current_desc);
<span class="p_chunk">@@ -328,38 +329,57 @@</span> <span class="p_context"> static void __mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 
 	list_for_each_entry_safe(iter, _iter, &amp;mv_chan-&gt;chain,
 					chain_node) {
<span class="p_del">-		prefetch(_iter);</span>
<span class="p_del">-		prefetch(&amp;_iter-&gt;async_tx);</span>
 
<span class="p_del">-		/* do not advance past the current descriptor loaded into the</span>
<span class="p_del">-		 * hardware channel, subsequent descriptors are either in</span>
<span class="p_del">-		 * process or have not been submitted</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (seen_current)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		/* clean finished descriptors */</span>
<span class="p_add">+		hw_desc = iter-&gt;hw_desc;</span>
<span class="p_add">+		if (hw_desc-&gt;status &amp; XOR_DESC_SUCCESS) {</span>
<span class="p_add">+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,</span>
<span class="p_add">+								cookie);</span>
 
<span class="p_del">-		/* stop the search if we reach the current descriptor and the</span>
<span class="p_del">-		 * channel is busy</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_del">-			seen_current = 1;</span>
<span class="p_del">-			if (busy)</span>
<span class="p_add">+			/* done processing desc, clean slot */</span>
<span class="p_add">+			mv_xor_clean_slot(iter, mv_chan);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* break if we did cleaned the current */</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 0;</span>
 				break;
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mv_xor_clean_slot(iter, mv_chan))</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((busy == 0) &amp;&amp; !list_empty(&amp;mv_chan-&gt;chain)) {
<span class="p_del">-		struct mv_xor_desc_slot *chain_head;</span>
<span class="p_del">-		chain_head = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_del">-					struct mv_xor_desc_slot,</span>
<span class="p_del">-					chain_node);</span>
<span class="p_del">-</span>
<span class="p_del">-		mv_xor_start_new_chain(mv_chan, chain_head);</span>
<span class="p_add">+		if (current_cleaned) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * current descriptor cleaned and removed, run</span>
<span class="p_add">+			 * from list head</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			iter = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_add">+					  struct mv_xor_desc_slot,</span>
<span class="p_add">+					  chain_node);</span>
<span class="p_add">+			mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (!list_is_last(&amp;iter-&gt;chain_node, &amp;mv_chan-&gt;chain)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * descriptors are still waiting after</span>
<span class="p_add">+				 * current, trigger them</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				iter = list_entry(iter-&gt;chain_node.next,</span>
<span class="p_add">+						  struct mv_xor_desc_slot,</span>
<span class="p_add">+						  chain_node);</span>
<span class="p_add">+				mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * some descriptors are still waiting</span>
<span class="p_add">+				 * to be cleaned</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tasklet_schedule(&amp;mv_chan-&gt;irq_tasklet);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cookie &gt; 0)
<span class="p_header">diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h</span>
<span class="p_header">index d0749229c875..5d14e4b21692 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.h</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.h</span>
<span class="p_chunk">@@ -33,6 +33,7 @@</span> <span class="p_context"></span>
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_DESCRIPTOR_SWAP		BIT(14)
<span class="p_add">+#define XOR_DESC_SUCCESS		0x40000000</span>
 
 #define XOR_CURR_DESC(chan)	(chan-&gt;mmr_high_base + 0x10 + (chan-&gt;idx * 4))
 #define XOR_NEXT_DESC(chan)	(chan-&gt;mmr_high_base + 0x00 + (chan-&gt;idx * 4))
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index dda970cb01c1..fa0ec5aed9ed 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -2898,6 +2898,7 @@</span> <span class="p_context"> enum punit_power_well {</span>
 #define   BLM_POLARITY_PNV			(1 &lt;&lt; 0) /* pnv only */
 
 #define BLC_HIST_CTL	(dev_priv-&gt;info.display_mmio_offset + 0x61260)
<span class="p_add">+#define  BLM_HISTOGRAM_ENABLE			(1 &lt;&lt; 31)</span>
 
 /* New registers for PCH-split platforms. Safe where new bits show up, the
  * register layout machtes with gen4 BLC_PWM_CTL[12]. */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_panel.c b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">index 59b294c5fe41..a25816cb3df1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_chunk">@@ -774,6 +774,14 @@</span> <span class="p_context"> static void i9xx_enable_backlight(struct intel_connector *connector)</span>
 
 	/* XXX: combine this into above write? */
 	intel_panel_actually_set_backlight(connector, panel-&gt;backlight.level);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Needed to enable backlight on some 855gm models. BLC_HIST_CTL is</span>
<span class="p_add">+	 * 855gm only, but checking for gen2 is safe, as 855gm is the only gen2</span>
<span class="p_add">+	 * that has backlight.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_GEN2(dev))</span>
<span class="p_add">+		I915_WRITE(BLC_HIST_CTL, BLM_HISTOGRAM_ENABLE);</span>
 }
 
 static void i965_enable_backlight(struct intel_connector *connector)
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">index eb89653a7a17..c5e96a38f859 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_chunk">@@ -505,6 +505,7 @@</span> <span class="p_context"> int qxl_hw_surface_alloc(struct qxl_device *qdev,</span>
 
 	cmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_SURFACE_CMD_CREATE;
<span class="p_add">+	cmd-&gt;flags = QXL_SURF_FLAG_KEEP_DATA;</span>
 	cmd-&gt;u.surface_create.format = surf-&gt;surf.format;
 	cmd-&gt;u.surface_create.width = surf-&gt;surf.width;
 	cmd-&gt;u.surface_create.height = surf-&gt;surf.height;
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">index b110883f8253..7354a4cda59d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_chunk">@@ -122,8 +122,10 @@</span> <span class="p_context"> static struct qxl_bo *qxlhw_handle_to_bo(struct qxl_device *qdev,</span>
 	qobj = gem_to_qxl_bo(gobj);
 
 	ret = qxl_release_list_add(release, qobj);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(gobj);</span>
 		return NULL;
<span class="p_add">+	}</span>
 
 	return qobj;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index 0cf54a4b83bd..6bdaa9500f78 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -4245,6 +4245,31 @@</span> <span class="p_context"> void cik_compute_set_wptr(struct radeon_device *rdev,</span>
 	WDOORBELL32(ring-&gt;doorbell_index, ring-&gt;wptr);
 }
 
<span class="p_add">+static void cik_compute_stop(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 j, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	cik_srbm_select(rdev, ring-&gt;me, ring-&gt;pipe, ring-&gt;queue, 0);</span>
<span class="p_add">+	/* Disable wptr polling. */</span>
<span class="p_add">+	tmp = RREG32(CP_PQ_WPTR_POLL_CNTL);</span>
<span class="p_add">+	tmp &amp;= ~WPTR_POLL_EN;</span>
<span class="p_add">+	WREG32(CP_PQ_WPTR_POLL_CNTL, tmp);</span>
<span class="p_add">+	/* Disable HQD. */</span>
<span class="p_add">+	if (RREG32(CP_HQD_ACTIVE) &amp; 1) {</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 1);</span>
<span class="p_add">+		for (j = 0; j &lt; rdev-&gt;usec_timeout; j++) {</span>
<span class="p_add">+			if (!(RREG32(CP_HQD_ACTIVE) &amp; 1))</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			udelay(1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_RPTR, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_WPTR, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cik_srbm_select(rdev, 0, 0, 0, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * cik_cp_compute_enable - enable/disable the compute CP MEs
  *
<span class="p_chunk">@@ -4258,6 +4283,15 @@</span> <span class="p_context"> static void cik_cp_compute_enable(struct radeon_device *rdev, bool enable)</span>
 	if (enable)
 		WREG32(CP_MEC_CNTL, 0);
 	else {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * To make hibernation reliable we need to clear compute ring</span>
<span class="p_add">+		 * configuration before halting the compute ring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mutex_lock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX]);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX]);</span>
<span class="p_add">+		mutex_unlock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+</span>
 		WREG32(CP_MEC_CNTL, (MEC_ME1_HALT | MEC_ME2_HALT));
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik_sdma.c b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">index 4208ae639407..f3e0d00a2666 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_chunk">@@ -266,6 +266,17 @@</span> <span class="p_context"> static void cik_sdma_gfx_stop(struct radeon_device *rdev)</span>
 	}
 	rdev-&gt;ring[R600_RING_TYPE_DMA_INDEX].ready = false;
 	rdev-&gt;ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready = false;
<span class="p_add">+</span>
<span class="p_add">+	/* FIXME use something else than big hammer but after few days can not</span>
<span class="p_add">+	 * seem to find good combination so reset SDMA blocks as it seems we</span>
<span class="p_add">+	 * do not shut them down properly. This fix hibernation and does not</span>
<span class="p_add">+	 * affect suspend to ram.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, SOFT_RESET_SDMA | SOFT_RESET_SDMA1);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, 0);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index c74f12d125f7..dd49f8c61878 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -79,10 +79,12 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	mutex_lock(&amp;mode_config-&gt;mutex);</span>
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
<span class="p_add">+	mutex_unlock(&amp;mode_config-&gt;mutex);</span>
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/tegra/dpaux.c b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">index 708f783ead47..7fb27458444f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_chunk">@@ -72,34 +72,32 @@</span> <span class="p_context"> static inline void tegra_dpaux_writel(struct tegra_dpaux *dpaux,</span>
 static void tegra_dpaux_write_fifo(struct tegra_dpaux *dpaux, const u8 *buffer,
 				   size_t size)
 {
<span class="p_del">-	unsigned long offset = DPAUX_DP_AUXDATA_WRITE(0);</span>
 	size_t i, j;
 
<span class="p_del">-	for (i = 0; i &lt; size; i += 4) {</span>
<span class="p_del">-		size_t num = min_t(size_t, size - i, 4);</span>
<span class="p_add">+	for (i = 0; i &lt; DIV_ROUND_UP(size, 4); i++) {</span>
<span class="p_add">+		size_t num = min_t(size_t, size - i * 4, 4);</span>
 		unsigned long value = 0;
 
 		for (j = 0; j &lt; num; j++)
<span class="p_del">-			value |= buffer[i + j] &lt;&lt; (j * 8);</span>
<span class="p_add">+			value |= buffer[i * 4 + j] &lt;&lt; (j * 8);</span>
 
<span class="p_del">-		tegra_dpaux_writel(dpaux, value, offset++);</span>
<span class="p_add">+		tegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXDATA_WRITE(i));</span>
 	}
 }
 
 static void tegra_dpaux_read_fifo(struct tegra_dpaux *dpaux, u8 *buffer,
 				  size_t size)
 {
<span class="p_del">-	unsigned long offset = DPAUX_DP_AUXDATA_READ(0);</span>
 	size_t i, j;
 
<span class="p_del">-	for (i = 0; i &lt; size; i += 4) {</span>
<span class="p_del">-		size_t num = min_t(size_t, size - i, 4);</span>
<span class="p_add">+	for (i = 0; i &lt; DIV_ROUND_UP(size, 4); i++) {</span>
<span class="p_add">+		size_t num = min_t(size_t, size - i * 4, 4);</span>
 		unsigned long value;
 
<span class="p_del">-		value = tegra_dpaux_readl(dpaux, offset++);</span>
<span class="p_add">+		value = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXDATA_READ(i));</span>
 
 		for (j = 0; j &lt; num; j++)
<span class="p_del">-			buffer[i + j] = value &gt;&gt; (j * 8);</span>
<span class="p_add">+			buffer[i * 4 + j] = value &gt;&gt; (j * 8);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/hid/hid-rmi.c b/drivers/hid/hid-rmi.c</span>
<span class="p_header">index 53df21735cea..bedc1acd0c4a 100644</span>
<span class="p_header">--- a/drivers/hid/hid-rmi.c</span>
<span class="p_header">+++ b/drivers/hid/hid-rmi.c</span>
<span class="p_chunk">@@ -29,9 +29,9 @@</span> <span class="p_context"></span>
 #define RMI_SET_RMI_MODE_REPORT_ID	0x0f /* Feature Report */
 
 /* flags */
<span class="p_del">-#define RMI_READ_REQUEST_PENDING	BIT(0)</span>
<span class="p_del">-#define RMI_READ_DATA_PENDING		BIT(1)</span>
<span class="p_del">-#define RMI_STARTED			BIT(2)</span>
<span class="p_add">+#define RMI_READ_REQUEST_PENDING	0</span>
<span class="p_add">+#define RMI_READ_DATA_PENDING		1</span>
<span class="p_add">+#define RMI_STARTED			2</span>
 
 enum rmi_mode_type {
 	RMI_MODE_OFF			= 0,
<span class="p_header">diff --git a/drivers/hid/i2c-hid/i2c-hid.c b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">index 1c313e3aa0fd..d40d1f36f47e 100644</span>
<span class="p_header">--- a/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_header">+++ b/drivers/hid/i2c-hid/i2c-hid.c</span>
<span class="p_chunk">@@ -41,9 +41,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/i2c/i2c-hid.h&gt;
 
 /* flags */
<span class="p_del">-#define I2C_HID_STARTED		(1 &lt;&lt; 0)</span>
<span class="p_del">-#define I2C_HID_RESET_PENDING	(1 &lt;&lt; 1)</span>
<span class="p_del">-#define I2C_HID_READ_PENDING	(1 &lt;&lt; 2)</span>
<span class="p_add">+#define I2C_HID_STARTED		0</span>
<span class="p_add">+#define I2C_HID_RESET_PENDING	1</span>
<span class="p_add">+#define I2C_HID_READ_PENDING	2</span>
 
 #define I2C_HID_PWR_ON		0x00
 #define I2C_HID_PWR_SLEEP	0x01
<span class="p_header">diff --git a/drivers/hwmon/mcp3021.c b/drivers/hwmon/mcp3021.c</span>
<span class="p_header">index d219c06a857b..972444a14cca 100644</span>
<span class="p_header">--- a/drivers/hwmon/mcp3021.c</span>
<span class="p_header">+++ b/drivers/hwmon/mcp3021.c</span>
<span class="p_chunk">@@ -31,14 +31,11 @@</span> <span class="p_context"></span>
 /* output format */
 #define MCP3021_SAR_SHIFT	2
 #define MCP3021_SAR_MASK	0x3ff
<span class="p_del">-</span>
 #define MCP3021_OUTPUT_RES	10	/* 10-bit resolution */
<span class="p_del">-#define MCP3021_OUTPUT_SCALE	4</span>
 
 #define MCP3221_SAR_SHIFT	0
 #define MCP3221_SAR_MASK	0xfff
 #define MCP3221_OUTPUT_RES	12	/* 12-bit resolution */
<span class="p_del">-#define MCP3221_OUTPUT_SCALE	1</span>
 
 enum chips {
 	mcp3021,
<span class="p_chunk">@@ -54,7 +51,6 @@</span> <span class="p_context"> struct mcp3021_data {</span>
 	u16 sar_shift;
 	u16 sar_mask;
 	u8 output_res;
<span class="p_del">-	u8 output_scale;</span>
 };
 
 static int mcp3021_read16(struct i2c_client *client)
<span class="p_chunk">@@ -84,13 +80,7 @@</span> <span class="p_context"> static int mcp3021_read16(struct i2c_client *client)</span>
 
 static inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)
 {
<span class="p_del">-	if (val == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	val = val * data-&gt;output_scale - data-&gt;output_scale / 2;</span>
<span class="p_del">-</span>
<span class="p_del">-	return val * DIV_ROUND_CLOSEST(data-&gt;vdd,</span>
<span class="p_del">-			(1 &lt;&lt; data-&gt;output_res) * data-&gt;output_scale);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(data-&gt;vdd * val, 1 &lt;&lt; data-&gt;output_res);</span>
 }
 
 static ssize_t show_in_input(struct device *dev, struct device_attribute *attr,
<span class="p_chunk">@@ -132,14 +122,12 @@</span> <span class="p_context"> static int mcp3021_probe(struct i2c_client *client,</span>
 		data-&gt;sar_shift = MCP3021_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3021_SAR_MASK;
 		data-&gt;output_res = MCP3021_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3021_OUTPUT_SCALE;</span>
 		break;
 
 	case mcp3221:
 		data-&gt;sar_shift = MCP3221_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3221_SAR_MASK;
 		data-&gt;output_res = MCP3221_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3221_OUTPUT_SCALE;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">index 30c8c1e738e1..c8ec841cf705 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_chunk">@@ -62,6 +62,9 @@</span> <span class="p_context"></span>
 #define	AT91_TWI_UNRE		0x0080	/* Underrun Error */
 #define	AT91_TWI_NACK		0x0100	/* Not Acknowledged */
 
<span class="p_add">+#define	AT91_TWI_INT_MASK \</span>
<span class="p_add">+	(AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY | AT91_TWI_NACK)</span>
<span class="p_add">+</span>
 #define	AT91_TWI_IER		0x0024	/* Interrupt Enable Register */
 #define	AT91_TWI_IDR		0x0028	/* Interrupt Disable Register */
 #define	AT91_TWI_IMR		0x002c	/* Interrupt Mask Register */
<span class="p_chunk">@@ -117,13 +120,12 @@</span> <span class="p_context"> static void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)</span>
 
 static void at91_disable_twi_interrupts(struct at91_twi_dev *dev)
 {
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IDR,</span>
<span class="p_del">-		       AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);</span>
 }
 
 static void at91_twi_irq_save(struct at91_twi_dev *dev)
 {
<span class="p_del">-	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; 0x7;</span>
<span class="p_add">+	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; AT91_TWI_INT_MASK;</span>
 	at91_disable_twi_interrupts(dev);
 }
 
<span class="p_chunk">@@ -213,6 +215,14 @@</span> <span class="p_context"> static void at91_twi_write_data_dma_callback(void *data)</span>
 	dma_unmap_single(dev-&gt;dev, sg_dma_address(&amp;dev-&gt;dma.sg),
 			 dev-&gt;buf_len, DMA_TO_DEVICE);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When this callback is called, THR/TX FIFO is likely not to be empty</span>
<span class="p_add">+	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the</span>
<span class="p_add">+	 * Status Register to be sure that the STOP bit has been sent and the</span>
<span class="p_add">+	 * transfer is completed. The NACK interrupt has already been enabled,</span>
<span class="p_add">+	 * we just have to enable TXCOMP one.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);
 }
 
<span class="p_chunk">@@ -307,7 +317,7 @@</span> <span class="p_context"> static void at91_twi_read_data_dma_callback(void *data)</span>
 	/* The last two bytes have to be read without using dma */
 	dev-&gt;buf += dev-&gt;buf_len - 2;
 	dev-&gt;buf_len = 2;
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY | AT91_TWI_TXCOMP);</span>
 }
 
 static void at91_twi_read_data_dma(struct at91_twi_dev *dev)
<span class="p_chunk">@@ -368,7 +378,7 @@</span> <span class="p_context"> static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)</span>
 	/* catch error flags */
 	dev-&gt;transfer_status |= status;
 
<span class="p_del">-	if (irqstatus &amp; AT91_TWI_TXCOMP) {</span>
<span class="p_add">+	if (irqstatus &amp; (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {</span>
 		at91_disable_twi_interrupts(dev);
 		complete(&amp;dev-&gt;cmd_complete);
 	}
<span class="p_chunk">@@ -381,6 +391,34 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	int ret;
 	bool has_unre_flag = dev-&gt;pdata-&gt;has_unre_flag;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on</span>
<span class="p_add">+	 * read flag but shows the state of the transmission at the time the</span>
<span class="p_add">+	 * Status Register is read. According to the programmer datasheet,</span>
<span class="p_add">+	 * TXCOMP is set when both holding register and internal shifter are</span>
<span class="p_add">+	 * empty and STOP condition has been sent.</span>
<span class="p_add">+	 * Consequently, we should enable NACK interrupt rather than TXCOMP to</span>
<span class="p_add">+	 * detect transmission failure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Besides, the TXCOMP bit is already set before the i2c transaction</span>
<span class="p_add">+	 * has been started. For read transactions, this bit is cleared when</span>
<span class="p_add">+	 * writing the START bit into the Control Register. So the</span>
<span class="p_add">+	 * corresponding interrupt can safely be enabled just after.</span>
<span class="p_add">+	 * However for write transactions managed by the CPU, we first write</span>
<span class="p_add">+	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP</span>
<span class="p_add">+	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,</span>
<span class="p_add">+	 * the interrupt handler would be called immediately and the i2c command</span>
<span class="p_add">+	 * would be reported as completed.</span>
<span class="p_add">+	 * Also when a write transaction is managed by the DMA controller,</span>
<span class="p_add">+	 * enabling the TXCOMP interrupt in this function may lead to a race</span>
<span class="p_add">+	 * condition since we don&#39;t know whether the TXCOMP interrupt is enabled</span>
<span class="p_add">+	 * before or after the DMA has started to write into THR. So the TXCOMP</span>
<span class="p_add">+	 * interrupt is enabled later by at91_twi_write_data_dma_callback().</span>
<span class="p_add">+	 * Immediately after in that DMA callback, we still need to send the</span>
<span class="p_add">+	 * STOP condition manually writing the corresponding bit into the</span>
<span class="p_add">+	 * Control Register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	dev_dbg(dev-&gt;dev, &quot;transfer: %s %d bytes.\n&quot;,
 		(dev-&gt;msg-&gt;flags &amp; I2C_M_RD) ? &quot;read&quot; : &quot;write&quot;, dev-&gt;buf_len);
 
<span class="p_chunk">@@ -411,26 +449,24 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 		 * seems to be the best solution.
 		 */
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_read_data_dma(dev);
<span class="p_del">-			/*</span>
<span class="p_del">-			 * It is important to enable TXCOMP irq here because</span>
<span class="p_del">-			 * doing it only when transferring the last two bytes</span>
<span class="p_del">-			 * will mask NACK errors since TXCOMP is set when a</span>
<span class="p_del">-			 * NACK occurs.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER,</span>
<span class="p_del">-			       AT91_TWI_TXCOMP);</span>
<span class="p_del">-		} else</span>
<span class="p_add">+		} else {</span>
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-			       AT91_TWI_TXCOMP | AT91_TWI_RXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_RXRDY);</span>
<span class="p_add">+		}</span>
 	} else {
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_write_data_dma(dev);
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 		} else {
 			at91_twi_write_next_byte(dev);
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-				AT91_TWI_TXCOMP | AT91_TWI_TXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_TXRDY);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index c128abd5f4c2..35df708ffa53 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -1365,14 +1365,17 @@</span> <span class="p_context"> static void mlx4_ib_multiplex_mad(struct mlx4_ib_demux_pv_ctx *ctx, struct ib_wc</span>
 	 * stadard address handle by decoding the tunnelled mlx4_ah fields */
 	memcpy(&amp;ah.av, &amp;tunnel-&gt;hdr.av, sizeof (struct mlx4_av));
 	ah.ibah.device = ctx-&gt;ib_dev;
<span class="p_add">+</span>
<span class="p_add">+	port = be32_to_cpu(ah.av.ib.port_pd) &gt;&gt; 24;</span>
<span class="p_add">+	port = mlx4_slave_convert_port(dev-&gt;dev, slave, port);</span>
<span class="p_add">+	if (port &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	ah.av.ib.port_pd = cpu_to_be32(port &lt;&lt; 24 | (be32_to_cpu(ah.av.ib.port_pd) &amp; 0xffffff));</span>
<span class="p_add">+</span>
 	mlx4_ib_query_ah(&amp;ah.ibah, &amp;ah_attr);
 	if (ah_attr.ah_flags &amp; IB_AH_GRH)
 		fill_in_real_sgid_index(dev, slave, ctx-&gt;port, &amp;ah_attr);
 
<span class="p_del">-	port = mlx4_slave_convert_port(dev-&gt;dev, slave, ah_attr.port_num);</span>
<span class="p_del">-	if (port &lt; 0)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	ah_attr.port_num = port;</span>
 	memcpy(ah_attr.dmac, tunnel-&gt;hdr.mac, 6);
 	ah_attr.vlan_id = be16_to_cpu(tunnel-&gt;hdr.vlan);
 	/* if slave have default vlan use it */
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 710ffa1830ae..706cbc5bd5cc 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1922,9 +1922,15 @@</span> <span class="p_context"> static void free_pt_##LVL (unsigned long __pt)			\</span>
 	pt = (u64 *)__pt;					\
 								\
 	for (i = 0; i &lt; 512; ++i) {				\
<span class="p_add">+		/* PTE present? */				\</span>
 		if (!IOMMU_PTE_PRESENT(pt[i]))			\
 			continue;				\
 								\
<span class="p_add">+		/* Large PTE? */				\</span>
<span class="p_add">+		if (PM_PTE_LEVEL(pt[i]) == 0 ||			\</span>
<span class="p_add">+		    PM_PTE_LEVEL(pt[i]) == 7)			\</span>
<span class="p_add">+			continue;				\</span>
<span class="p_add">+								\</span>
 		p = (unsigned long)IOMMU_PTE_PAGE(pt[i]);	\
 		FN(p);						\
 	}							\
<span class="p_header">diff --git a/drivers/leds/led-class.c b/drivers/leds/led-class.c</span>
<span class="p_header">index f37d63cf726b..825545cdfb10 100644</span>
<span class="p_header">--- a/drivers/leds/led-class.c</span>
<span class="p_header">+++ b/drivers/leds/led-class.c</span>
<span class="p_chunk">@@ -178,6 +178,7 @@</span> <span class="p_context"> void led_classdev_resume(struct led_classdev *led_cdev)</span>
 }
 EXPORT_SYMBOL_GPL(led_classdev_resume);
 
<span class="p_add">+#ifdef CONFIG_PM_SLEEP</span>
 static int led_suspend(struct device *dev)
 {
 	struct led_classdev *led_cdev = dev_get_drvdata(dev);
<span class="p_chunk">@@ -197,11 +198,9 @@</span> <span class="p_context"> static int led_resume(struct device *dev)</span>
 
 	return 0;
 }
<span class="p_add">+#endif</span>
 
<span class="p_del">-static const struct dev_pm_ops leds_class_dev_pm_ops = {</span>
<span class="p_del">-	.suspend        = led_suspend,</span>
<span class="p_del">-	.resume         = led_resume,</span>
<span class="p_del">-};</span>
<span class="p_add">+static SIMPLE_DEV_PM_OPS(leds_class_dev_pm_ops, led_suspend, led_resume);</span>
 
 /**
  * led_classdev_register - register a new object of led_classdev class.
<span class="p_header">diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c</span>
<span class="p_header">index 28a90122a5a8..b3b0697a9fd7 100644</span>
<span class="p_header">--- a/drivers/md/dm-stats.c</span>
<span class="p_header">+++ b/drivers/md/dm-stats.c</span>
<span class="p_chunk">@@ -795,6 +795,8 @@</span> <span class="p_context"> static int message_stats_create(struct mapped_device *md,</span>
 		return -EINVAL;
 
 	if (sscanf(argv[2], &quot;/%u%c&quot;, &amp;divisor, &amp;dummy) == 1) {
<span class="p_add">+		if (!divisor)</span>
<span class="p_add">+			return -EINVAL;</span>
 		step = end - start;
 		if (do_div(step, divisor))
 			step++;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index f4e22bcc7fb8..199c9ccd1f5d 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -204,6 +204,27 @@</span> <span class="p_context"> static void in(struct sm_metadata *smm)</span>
 	smm-&gt;recursion_count++;
 }
 
<span class="p_add">+static int apply_bops(struct sm_metadata *smm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int r = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_add">+		struct block_op bop;</span>
<span class="p_add">+</span>
<span class="p_add">+		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		r = commit_bop(smm, &amp;bop);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int out(struct sm_metadata *smm)
 {
 	int r = 0;
<span class="p_chunk">@@ -216,21 +237,8 @@</span> <span class="p_context"> static int out(struct sm_metadata *smm)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	if (smm-&gt;recursion_count == 1) {</span>
<span class="p_del">-		while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_del">-			struct block_op bop;</span>
<span class="p_del">-</span>
<span class="p_del">-			r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_del">-			if (r) {</span>
<span class="p_del">-				DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			r = commit_bop(smm, &amp;bop);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (smm-&gt;recursion_count == 1)</span>
<span class="p_add">+		apply_bops(smm);</span>
 
 	smm-&gt;recursion_count--;
 
<span class="p_chunk">@@ -702,6 +710,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 		}
 		old_len = smm-&gt;begin;
 
<span class="p_add">+		r = apply_bops(smm);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		r = sm_ll_commit(&amp;smm-&gt;ll);
 		if (r)
 			goto out;
<span class="p_chunk">@@ -771,6 +785,12 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	if (r)
 		return r;
 
<span class="p_add">+	r = apply_bops(smm);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return sm_metadata_commit(sm);
 }
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">index fb504f1e9125..5930aee6b5d0 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_chunk">@@ -606,6 +606,10 @@</span> <span class="p_context"> static int af9013_set_frontend(struct dvb_frontend *fe)</span>
 			}
 		}
 
<span class="p_add">+		/* Return an error if can&#39;t find bandwidth or the right clock */</span>
<span class="p_add">+		if (i == ARRAY_SIZE(coeff_lut))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24116.c b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">index 2916d7c74a1d..7bc68b355c0b 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_chunk">@@ -963,6 +963,10 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	struct cx24116_state *state = fe-&gt;demodulator_priv;
 	int i, ret;
 
<span class="p_add">+	/* Validate length */</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
<span class="p_add">+                return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO &quot;cx24116: %s(&quot;, __func__);
<span class="p_chunk">@@ -974,10 +978,6 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 		printk(&quot;) toneburst=%d\n&quot;, toneburst);
 	}
 
<span class="p_del">-	/* Validate length */</span>
<span class="p_del">-	if (d-&gt;msg_len &gt; (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DiSEqC message */
 	for (i = 0; i &lt; d-&gt;msg_len; i++)
 		state-&gt;dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d-&gt;msg[i];
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24117.c b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">index a6c3c9e2e897..d2eab0676d30 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_chunk">@@ -1043,7 +1043,7 @@</span> <span class="p_context"> static int cx24117_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	dev_dbg(&amp;state-&gt;priv-&gt;i2c-&gt;dev, &quot;)\n&quot;);
 
 	/* Validate length */
<span class="p_del">-	if (d-&gt;msg_len &gt; 15)</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
 		return -EINVAL;
 
 	/* DiSEqC message */
<span class="p_header">diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">index 93eeaf7118fd..0b4f8fe6bf99 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int s5h1420_send_master_cmd (struct dvb_frontend* fe,</span>
 	int result = 0;
 
 	dprintk(&quot;enter %s\n&quot;, __func__);
<span class="p_del">-	if (cmd-&gt;msg_len &gt; 8)</span>
<span class="p_add">+	if (cmd-&gt;msg_len &gt; sizeof(cmd-&gt;msg))</span>
 		return -EINVAL;
 
 	/* setup for DISEQC */
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index e32206ecfa04..7ec3c79852e5 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1910,9 +1910,11 @@</span> <span class="p_context"> static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span>
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
<span class="p_del">-			if (!mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			goto cmd_abort;</span>
<span class="p_add">+			if (mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_add">+				goto cmd_abort;</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				goto start_new_req;</span>
<span class="p_add">+			break;</span>
 		case MMC_BLK_RETRY:
 			if (retry++ &lt; 5)
 				break;
<span class="p_header">diff --git a/drivers/mtd/maps/dc21285.c b/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">index f8a7dd14cee0..70a3db3ab856 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/dc21285.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/dc21285.c</span>
<span class="p_chunk">@@ -38,9 +38,9 @@</span> <span class="p_context"> static void nw_en_write(void)</span>
 	 * we want to write a bit pattern XXX1 to Xilinx to enable
 	 * the write gate, which will be open for about the next 2ms.
 	 */
<span class="p_del">-	spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;nw_gpio_lock, flags);</span>
 	nw_cpld_modify(CPLD_FLASH_WR_ENABLE, CPLD_FLASH_WR_ENABLE);
<span class="p_del">-	spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;nw_gpio_lock, flags);</span>
 
 	/*
 	 * let the ISA bus to catch on...
<span class="p_header">diff --git a/drivers/mtd/mtd_blkdevs.c b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">index 43e30992a369..7266a318628c 100644</span>
<span class="p_header">--- a/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_header">+++ b/drivers/mtd/mtd_blkdevs.c</span>
<span class="p_chunk">@@ -200,6 +200,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 		return -ERESTARTSYS; /* FIXME: busy loop! -arnd*/
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -223,6 +224,7 @@</span> <span class="p_context"> static int blktrans_open(struct block_device *bdev, fmode_t mode)</span>
 
 unlock:
 	dev-&gt;open++;
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -233,6 +235,7 @@</span> <span class="p_context"> error_release:</span>
 error_put:
 	module_put(dev-&gt;tr-&gt;owner);
 	kref_put(&amp;dev-&gt;ref, blktrans_dev_release);
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 	return ret;
<span class="p_chunk">@@ -246,6 +249,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		return;
 
 	mutex_lock(&amp;dev-&gt;lock);
<span class="p_add">+	mutex_lock(&amp;mtd_table_mutex);</span>
 
 	if (--dev-&gt;open)
 		goto unlock;
<span class="p_chunk">@@ -259,6 +263,7 @@</span> <span class="p_context"> static void blktrans_release(struct gendisk *disk, fmode_t mode)</span>
 		__put_mtd_device(dev-&gt;mtd);
 	}
 unlock:
<span class="p_add">+	mutex_unlock(&amp;mtd_table_mutex);</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 	blktrans_dev_put(dev);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/82571.c b/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_header">index 218481e509f9..c1396829ca96 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_chunk">@@ -2014,7 +2014,7 @@</span> <span class="p_context"> const struct e1000_info e1000_82573_info = {</span>
 	.flags2			= FLAG2_DISABLE_ASPM_L1
 				  | FLAG2_DISABLE_ASPM_L0S,
 	.pba			= 20,
<span class="p_del">-	.max_hw_frame_size	= ETH_FRAME_LEN + ETH_FCS_LEN,</span>
<span class="p_add">+	.max_hw_frame_size	= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,</span>
 	.get_variants		= e1000_get_variants_82571,
 	.mac_ops		= &amp;e82571_mac_ops,
 	.phy_ops		= &amp;e82_phy_ops_m88,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/ich8lan.c b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">index 8894ab8ed6bd..060c5510b0c4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_chunk">@@ -1495,7 +1495,7 @@</span> <span class="p_context"> static s32 e1000_get_variants_ich8lan(struct e1000_adapter *adapter)</span>
 	    ((adapter-&gt;hw.mac.type &gt;= e1000_pch2lan) &amp;&amp;
 	     (!(er32(CTRL_EXT) &amp; E1000_CTRL_EXT_LSECCK)))) {
 		adapter-&gt;flags &amp;= ~FLAG_HAS_JUMBO_FRAMES;
<span class="p_del">-		adapter-&gt;max_hw_frame_size = ETH_FRAME_LEN + ETH_FCS_LEN;</span>
<span class="p_add">+		adapter-&gt;max_hw_frame_size = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 
 		hw-&gt;mac.ops.blink_led = NULL;
 	}
<span class="p_chunk">@@ -5054,7 +5054,7 @@</span> <span class="p_context"> const struct e1000_info e1000_ich8_info = {</span>
 				  | FLAG_HAS_FLASH
 				  | FLAG_APME_IN_WUC,
 	.pba			= 8,
<span class="p_del">-	.max_hw_frame_size	= ETH_FRAME_LEN + ETH_FCS_LEN,</span>
<span class="p_add">+	.max_hw_frame_size	= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_chunk">@@ -5127,7 +5127,7 @@</span> <span class="p_context"> const struct e1000_info e1000_pch2_info = {</span>
 	.flags2			= FLAG2_HAS_PHY_STATS
 				  | FLAG2_HAS_EEE,
 	.pba			= 26,
<span class="p_del">-	.max_hw_frame_size	= 9018,</span>
<span class="p_add">+	.max_hw_frame_size	= 9022,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_chunk">@@ -5147,7 +5147,7 @@</span> <span class="p_context"> const struct e1000_info e1000_pch_lpt_info = {</span>
 	.flags2			= FLAG2_HAS_PHY_STATS
 				  | FLAG2_HAS_EEE,
 	.pba			= 26,
<span class="p_del">-	.max_hw_frame_size	= 9018,</span>
<span class="p_add">+	.max_hw_frame_size	= 9022,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">index 201cc93f3625..fe03a752b84b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_chunk">@@ -3787,7 +3787,7 @@</span> <span class="p_context"> void e1000e_reset(struct e1000_adapter *adapter)</span>
 	/* reset Packet Buffer Allocation to default */
 	ew32(PBA, pba);
 
<span class="p_del">-	if (adapter-&gt;max_frame_size &gt; ETH_FRAME_LEN + ETH_FCS_LEN) {</span>
<span class="p_add">+	if (adapter-&gt;max_frame_size &gt; (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) {</span>
 		/* To maintain wire speed transmits, the Tx FIFO should be
 		 * large enough to accommodate two full transmit packets,
 		 * rounded up to the next 1KB and expressed in KB.  Likewise,
<span class="p_chunk">@@ -4175,9 +4175,9 @@</span> <span class="p_context"> static int e1000_sw_init(struct e1000_adapter *adapter)</span>
 {
 	struct net_device *netdev = adapter-&gt;netdev;
 
<span class="p_del">-	adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	adapter-&gt;rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 	adapter-&gt;rx_ps_bsize0 = 128;
<span class="p_del">-	adapter-&gt;max_frame_size = netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	adapter-&gt;max_frame_size = netdev-&gt;mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;</span>
 	adapter-&gt;min_frame_size = ETH_ZLEN + ETH_FCS_LEN;
 	adapter-&gt;tx_ring_count = E1000_DEFAULT_TXD;
 	adapter-&gt;rx_ring_count = E1000_DEFAULT_RXD;
<span class="p_chunk">@@ -5759,17 +5759,17 @@</span> <span class="p_context"> struct rtnl_link_stats64 *e1000e_get_stats64(struct net_device *netdev,</span>
 static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
<span class="p_del">-	int max_frame = new_mtu + VLAN_HLEN + ETH_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	int max_frame = new_mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;</span>
 
 	/* Jumbo frame support */
<span class="p_del">-	if ((max_frame &gt; ETH_FRAME_LEN + ETH_FCS_LEN) &amp;&amp;</span>
<span class="p_add">+	if ((max_frame &gt; (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) &amp;&amp;</span>
 	    !(adapter-&gt;flags &amp; FLAG_HAS_JUMBO_FRAMES)) {
 		e_err(&quot;Jumbo Frames not supported.\n&quot;);
 		return -EINVAL;
 	}
 
 	/* Supported frame sizes */
<span class="p_del">-	if ((new_mtu &lt; ETH_ZLEN + ETH_FCS_LEN + VLAN_HLEN) ||</span>
<span class="p_add">+	if ((new_mtu &lt; (VLAN_ETH_ZLEN + ETH_FCS_LEN)) ||</span>
 	    (max_frame &gt; adapter-&gt;max_hw_frame_size)) {
 		e_err(&quot;Unsupported MTU setting\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -5809,10 +5809,8 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		adapter-&gt;rx_buffer_len = 4096;
 
 	/* adjust allocation if LPE protects us, and we aren&#39;t using SBP */
<span class="p_del">-	if ((max_frame == ETH_FRAME_LEN + ETH_FCS_LEN) ||</span>
<span class="p_del">-	    (max_frame == ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN))</span>
<span class="p_del">-		adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN</span>
<span class="p_del">-		    + ETH_FCS_LEN;</span>
<span class="p_add">+	if (max_frame &lt;= (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN))</span>
<span class="p_add">+		adapter-&gt;rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 
 	if (netif_running(netdev))
 		e1000e_up(adapter);
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 393d49202f23..807fbdc4b21b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -303,6 +303,7 @@</span> <span class="p_context"> struct mvneta_port {</span>
 	unsigned int link;
 	unsigned int duplex;
 	unsigned int speed;
<span class="p_add">+	unsigned int tx_csum_limit;</span>
 };
 
 /* The mvneta_tx_desc and mvneta_rx_desc structures describe the
<span class="p_chunk">@@ -2439,8 +2440,10 @@</span> <span class="p_context"> static int mvneta_change_mtu(struct net_device *dev, int mtu)</span>
 
 	dev-&gt;mtu = mtu;
 
<span class="p_del">-	if (!netif_running(dev))</span>
<span class="p_add">+	if (!netif_running(dev)) {</span>
<span class="p_add">+		netdev_update_features(dev);</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/* The interface is running, so we have to force a
 	 * reallocation of the queues
<span class="p_chunk">@@ -2469,9 +2472,26 @@</span> <span class="p_context"> static int mvneta_change_mtu(struct net_device *dev, int mtu)</span>
 	mvneta_start_dev(pp);
 	mvneta_port_up(pp);
 
<span class="p_add">+	netdev_update_features(dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_add">+static netdev_features_t mvneta_fix_features(struct net_device *dev,</span>
<span class="p_add">+					     netdev_features_t features)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mvneta_port *pp = netdev_priv(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pp-&gt;tx_csum_limit &amp;&amp; dev-&gt;mtu &gt; pp-&gt;tx_csum_limit) {</span>
<span class="p_add">+		features &amp;= ~(NETIF_F_IP_CSUM | NETIF_F_TSO);</span>
<span class="p_add">+		netdev_info(dev,</span>
<span class="p_add">+			    &quot;Disable IP checksum for MTU greater than %dB\n&quot;,</span>
<span class="p_add">+			    pp-&gt;tx_csum_limit);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return features;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Get mac address */
 static void mvneta_get_mac_addr(struct mvneta_port *pp, unsigned char *addr)
 {
<span class="p_chunk">@@ -2789,6 +2809,7 @@</span> <span class="p_context"> static const struct net_device_ops mvneta_netdev_ops = {</span>
 	.ndo_set_rx_mode     = mvneta_set_rx_mode,
 	.ndo_set_mac_address = mvneta_set_mac_addr,
 	.ndo_change_mtu      = mvneta_change_mtu,
<span class="p_add">+	.ndo_fix_features    = mvneta_fix_features,</span>
 	.ndo_get_stats64     = mvneta_get_stats64,
 	.ndo_do_ioctl        = mvneta_ioctl,
 };
<span class="p_chunk">@@ -3027,6 +3048,9 @@</span> <span class="p_context"> static int mvneta_probe(struct platform_device *pdev)</span>
 		}
 	}
 
<span class="p_add">+	if (of_device_is_compatible(dn, &quot;marvell,armada-370-neta&quot;))</span>
<span class="p_add">+		pp-&gt;tx_csum_limit = 1600;</span>
<span class="p_add">+</span>
 	pp-&gt;tx_ring_size = MVNETA_MAX_TXD;
 	pp-&gt;rx_ring_size = MVNETA_MAX_RXD;
 
<span class="p_chunk">@@ -3096,6 +3120,7 @@</span> <span class="p_context"> static int mvneta_remove(struct platform_device *pdev)</span>
 
 static const struct of_device_id mvneta_match[] = {
 	{ .compatible = &quot;marvell,armada-370-neta&quot; },
<span class="p_add">+	{ .compatible = &quot;marvell,armada-xp-neta&quot; },</span>
 	{ }
 };
 MODULE_DEVICE_TABLE(of, mvneta_match);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_header">index c9d2988e364d..27fccfdeb12e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_chunk">@@ -714,7 +714,7 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 {
 	struct ib_smp *smp = inbox-&gt;buf;
 	u32 index;
<span class="p_del">-	u8 port;</span>
<span class="p_add">+	u8 port, slave_port;</span>
 	u8 opcode_modifier;
 	u16 *table;
 	int err;
<span class="p_chunk">@@ -726,7 +726,8 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 	__be32 slave_cap_mask;
 	__be64 slave_node_guid;
 
<span class="p_del">-	port = vhcr-&gt;in_modifier;</span>
<span class="p_add">+	slave_port = vhcr-&gt;in_modifier;</span>
<span class="p_add">+	port = mlx4_slave_convert_port(dev, slave, slave_port);</span>
 
 	/* network-view bit is for driver use only, and should not be passed to FW */
 	opcode_modifier = vhcr-&gt;op_modifier &amp; ~0x8; /* clear netw view bit */
<span class="p_chunk">@@ -760,8 +761,9 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 			if (smp-&gt;attr_id == IB_SMP_ATTR_PORT_INFO) {
 				/*get the slave specific caps:*/
 				/*do the command */
<span class="p_add">+				smp-&gt;attr_mod = cpu_to_be32(port);</span>
 				err = mlx4_cmd_box(dev, inbox-&gt;dma, outbox-&gt;dma,
<span class="p_del">-					    vhcr-&gt;in_modifier, opcode_modifier,</span>
<span class="p_add">+					    port, opcode_modifier,</span>
 					    vhcr-&gt;op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);
 				/* modify the response for slaves */
 				if (!err &amp;&amp; slave != mlx4_master_func_num(dev)) {
<span class="p_chunk">@@ -792,7 +794,7 @@</span> <span class="p_context"> static int mlx4_MAD_IFC_wrapper(struct mlx4_dev *dev, int slave,</span>
 			}
 			if (smp-&gt;attr_id == IB_SMP_ATTR_NODE_INFO) {
 				err = mlx4_cmd_box(dev, inbox-&gt;dma, outbox-&gt;dma,
<span class="p_del">-					     vhcr-&gt;in_modifier, opcode_modifier,</span>
<span class="p_add">+					     port, opcode_modifier,</span>
 					     vhcr-&gt;op, MLX4_CMD_TIME_CLASS_C, MLX4_CMD_NATIVE);
 				if (!err) {
 					slave_node_guid =  mlx4_get_slave_node_guid(dev, slave);
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/descs.h b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">index ad3996038018..799c2929c536 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/descs.h</span>
<span class="p_chunk">@@ -158,6 +158,8 @@</span> <span class="p_context"> struct dma_desc {</span>
 			u32 buffer2_size:13;
 			u32 reserved4:3;
 		} etx;		/* -- enhanced -- */
<span class="p_add">+</span>
<span class="p_add">+		u64 all_flags;</span>
 	} des01;
 	unsigned int des2;
 	unsigned int des3;
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">index 1e2bcf5f89e1..7d944449f5ef 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/enh_desc.c</span>
<span class="p_chunk">@@ -240,6 +240,7 @@</span> <span class="p_context"> static int enh_desc_get_rx_status(void *data, struct stmmac_extra_stats *x,</span>
 static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,
 				  int mode, int end)
 {
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	p-&gt;des01.erx.own = 1;
 	p-&gt;des01.erx.buffer1_size = BUF_SIZE_8KiB - 1;
 
<span class="p_chunk">@@ -254,7 +255,7 @@</span> <span class="p_context"> static void enh_desc_init_rx_desc(struct dma_desc *p, int disable_rx_ic,</span>
 
 static void enh_desc_init_tx_desc(struct dma_desc *p, int mode, int end)
 {
<span class="p_del">-	p-&gt;des01.etx.own = 0;</span>
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	if (mode == STMMAC_CHAIN_MODE)
 		ehn_desc_tx_set_on_chain(p, end);
 	else
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">index 35ad4f427ae2..48c3456445b2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/norm_desc.c</span>
<span class="p_chunk">@@ -123,6 +123,7 @@</span> <span class="p_context"> static int ndesc_get_rx_status(void *data, struct stmmac_extra_stats *x,</span>
 static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,
 			       int end)
 {
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	p-&gt;des01.rx.own = 1;
 	p-&gt;des01.rx.buffer1_size = BUF_SIZE_2KiB - 1;
 
<span class="p_chunk">@@ -137,7 +138,7 @@</span> <span class="p_context"> static void ndesc_init_rx_desc(struct dma_desc *p, int disable_rx_ic, int mode,</span>
 
 static void ndesc_init_tx_desc(struct dma_desc *p, int mode, int end)
 {
<span class="p_del">-	p-&gt;des01.tx.own = 0;</span>
<span class="p_add">+	p-&gt;des01.all_flags = 0;</span>
 	if (mode == STMMAC_CHAIN_MODE)
 		ndesc_tx_set_on_chain(p, end);
 	else
<span class="p_header">diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">index 057a1208e594..641086fc14b5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c</span>
<span class="p_chunk">@@ -1142,41 +1142,41 @@</span> <span class="p_context"> static int alloc_dma_desc_resources(struct stmmac_priv *priv)</span>
 		goto err_tx_skbuff;
 
 	if (priv-&gt;extend_desc) {
<span class="p_del">-		priv-&gt;dma_erx = dma_alloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_del">-						   sizeof(struct</span>
<span class="p_del">-							  dma_extended_desc),</span>
<span class="p_del">-						   &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_del">-						   GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_erx = dma_zalloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_add">+						    sizeof(struct</span>
<span class="p_add">+							   dma_extended_desc),</span>
<span class="p_add">+						    &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_add">+						    GFP_KERNEL);</span>
 		if (!priv-&gt;dma_erx)
 			goto err_dma;
 
<span class="p_del">-		priv-&gt;dma_etx = dma_alloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_del">-						   sizeof(struct</span>
<span class="p_del">-							  dma_extended_desc),</span>
<span class="p_del">-						   &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_del">-						   GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_etx = dma_zalloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_add">+						    sizeof(struct</span>
<span class="p_add">+							   dma_extended_desc),</span>
<span class="p_add">+						    &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_add">+						    GFP_KERNEL);</span>
 		if (!priv-&gt;dma_etx) {
 			dma_free_coherent(priv-&gt;device, priv-&gt;dma_rx_size *
<span class="p_del">-					sizeof(struct dma_extended_desc),</span>
<span class="p_del">-					priv-&gt;dma_erx, priv-&gt;dma_rx_phy);</span>
<span class="p_add">+					  sizeof(struct dma_extended_desc),</span>
<span class="p_add">+					  priv-&gt;dma_erx, priv-&gt;dma_rx_phy);</span>
 			goto err_dma;
 		}
 	} else {
<span class="p_del">-		priv-&gt;dma_rx = dma_alloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_rx = dma_zalloc_coherent(priv-&gt;device, rxsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_rx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 		if (!priv-&gt;dma_rx)
 			goto err_dma;
 
<span class="p_del">-		priv-&gt;dma_tx = dma_alloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_del">-						  sizeof(struct dma_desc),</span>
<span class="p_del">-						  &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_del">-						  GFP_KERNEL);</span>
<span class="p_add">+		priv-&gt;dma_tx = dma_zalloc_coherent(priv-&gt;device, txsize *</span>
<span class="p_add">+						   sizeof(struct dma_desc),</span>
<span class="p_add">+						   &amp;priv-&gt;dma_tx_phy,</span>
<span class="p_add">+						   GFP_KERNEL);</span>
 		if (!priv-&gt;dma_tx) {
 			dma_free_coherent(priv-&gt;device, priv-&gt;dma_rx_size *
<span class="p_del">-					sizeof(struct dma_desc),</span>
<span class="p_del">-					priv-&gt;dma_rx, priv-&gt;dma_rx_phy);</span>
<span class="p_add">+					  sizeof(struct dma_desc),</span>
<span class="p_add">+					  priv-&gt;dma_rx, priv-&gt;dma_rx_phy);</span>
 			goto err_dma;
 		}
 	}
<span class="p_header">diff --git a/drivers/net/phy/phy_device.c b/drivers/net/phy/phy_device.c</span>
<span class="p_header">index 22c57be4dfa0..5a501bca344f 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy_device.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy_device.c</span>
<span class="p_chunk">@@ -780,10 +780,11 @@</span> <span class="p_context"> static int genphy_config_advert(struct phy_device *phydev)</span>
 	if (phydev-&gt;supported &amp; (SUPPORTED_1000baseT_Half |
 				 SUPPORTED_1000baseT_Full)) {
 		adv |= ethtool_adv_to_mii_ctrl1000_t(advertise);
<span class="p_del">-		if (adv != oldadv)</span>
<span class="p_del">-			changed = 1;</span>
 	}
 
<span class="p_add">+	if (adv != oldadv)</span>
<span class="p_add">+		changed = 1;</span>
<span class="p_add">+</span>
 	err = phy_write(phydev, MII_CTRL1000, adv);
 	if (err &lt; 0)
 		return err;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/htc.h b/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_header">index 09a5d72f3ff5..792fa3c891f2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_chunk">@@ -437,9 +437,9 @@</span> <span class="p_context"> static inline void ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)</span>
 }
 #endif /* CONFIG_ATH9K_BTCOEX_SUPPORT */
 
<span class="p_del">-#define OP_BT_PRIORITY_DETECTED    BIT(3)</span>
<span class="p_del">-#define OP_BT_SCAN                 BIT(4)</span>
<span class="p_del">-#define OP_TSF_RESET               BIT(6)</span>
<span class="p_add">+#define OP_BT_PRIORITY_DETECTED    3</span>
<span class="p_add">+#define OP_BT_SCAN                 4</span>
<span class="p_add">+#define OP_TSF_RESET               6</span>
 
 struct ath9k_htc_priv {
 	struct device *dev;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index 62ac95d6bb9d..bf6efbc2c9c0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -205,11 +205,13 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc)</span>
 	ath_stop_ani(sc);
 	ath9k_hw_disable_interrupts(ah);
 
<span class="p_del">-	if (!ath_drain_all_txq(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ath_stoprecv(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_add">+	if (AR_SREV_9300_20_OR_LATER(ah)) {</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/wireless/b43/main.c b/drivers/net/wireless/b43/main.c</span>
<span class="p_header">index 0d6a0bb1f876..8556325e98a3 100644</span>
<span class="p_header">--- a/drivers/net/wireless/b43/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/b43/main.c</span>
<span class="p_chunk">@@ -5130,6 +5130,10 @@</span> <span class="p_context"> static void b43_supported_bands(struct b43_wldev *dev, bool *have_2ghz_phy,</span>
 		*have_5ghz_phy = true;
 		return;
 	case 0x4321: /* BCM4306 */
<span class="p_add">+		/* There are 14e4:4321 PCI devs with 2.4 GHz BCM4321 (N-PHY) */</span>
<span class="p_add">+		if (dev-&gt;phy.type != B43_PHYTYPE_G)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/* fall through */</span>
 	case 0x4313: /* BCM4311 */
 	case 0x431a: /* BCM4318 */
 	case 0x432a: /* BCM4321 */
<span class="p_header">diff --git a/drivers/net/wireless/rndis_wlan.c b/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_header">index d2a9a08210be..19a1c9cde772 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rndis_wlan.c</span>
<span class="p_chunk">@@ -356,9 +356,9 @@</span> <span class="p_context"> struct ndis_80211_pmkid {</span>
 #define CAP_MODE_80211G		4
 #define CAP_MODE_MASK		7
 
<span class="p_del">-#define WORK_LINK_UP		(1&lt;&lt;0)</span>
<span class="p_del">-#define WORK_LINK_DOWN		(1&lt;&lt;1)</span>
<span class="p_del">-#define WORK_SET_MULTICAST_LIST	(1&lt;&lt;2)</span>
<span class="p_add">+#define WORK_LINK_UP		0</span>
<span class="p_add">+#define WORK_LINK_DOWN		1</span>
<span class="p_add">+#define WORK_SET_MULTICAST_LIST	2</span>
 
 #define RNDIS_WLAN_ALG_NONE	0
 #define RNDIS_WLAN_ALG_WEP	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 296bc43d26cc..9985665f7397 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(of_n_size_cells);</span>
 #ifdef CONFIG_NUMA
 int __weak of_node_to_nid(struct device_node *np)
 {
<span class="p_del">-	return numa_node_id();</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/pcmcia/topic.h b/drivers/pcmcia/topic.h</span>
<span class="p_header">index 615a45a8fe86..582688fe7505 100644</span>
<span class="p_header">--- a/drivers/pcmcia/topic.h</span>
<span class="p_header">+++ b/drivers/pcmcia/topic.h</span>
<span class="p_chunk">@@ -104,6 +104,9 @@</span> <span class="p_context"></span>
 #define TOPIC_EXCA_IF_CONTROL		0x3e	/* 8 bit */
 #define TOPIC_EXCA_IFC_33V_ENA		0x01
 
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN		0x3e	/* 16-bit */</span>
<span class="p_add">+#define TOPIC_PCI_CFG_PPBCN_WBEN	0x0400</span>
<span class="p_add">+</span>
 static void topic97_zoom_video(struct pcmcia_socket *sock, int onoff)
 {
 	struct yenta_socket *socket = container_of(sock, struct yenta_socket, socket);
<span class="p_chunk">@@ -138,6 +141,7 @@</span> <span class="p_context"> static int topic97_override(struct yenta_socket *socket)</span>
 static int topic95_override(struct yenta_socket *socket)
 {
 	u8 fctrl;
<span class="p_add">+	u16 ppbcn;</span>
 
 	/* enable 3.3V support for 16bit cards */
 	fctrl = exca_readb(socket, TOPIC_EXCA_IF_CONTROL);
<span class="p_chunk">@@ -146,6 +150,18 @@</span> <span class="p_context"> static int topic95_override(struct yenta_socket *socket)</span>
 	/* tell yenta to use exca registers to power 16bit cards */
 	socket-&gt;flags |= YENTA_16BIT_POWER_EXCA | YENTA_16BIT_POWER_DF;
 
<span class="p_add">+	/* Disable write buffers to prevent lockups under load with numerous</span>
<span class="p_add">+	   Cardbus cards, observed on Tecra 500CDT and reported elsewhere on the</span>
<span class="p_add">+	   net.  This is not a power-on default according to the datasheet</span>
<span class="p_add">+	   but some BIOSes seem to set it. */</span>
<span class="p_add">+	if (pci_read_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, &amp;ppbcn) == 0</span>
<span class="p_add">+	    &amp;&amp; socket-&gt;dev-&gt;revision &lt;= 7</span>
<span class="p_add">+	    &amp;&amp; (ppbcn &amp; TOPIC_PCI_CFG_PPBCN_WBEN)) {</span>
<span class="p_add">+		ppbcn &amp;= ~TOPIC_PCI_CFG_PPBCN_WBEN;</span>
<span class="p_add">+		pci_write_config_word(socket-&gt;dev, TOPIC_PCI_CFG_PPBCN, ppbcn);</span>
<span class="p_add">+		dev_info(&amp;socket-&gt;dev-&gt;dev, &quot;Disabled ToPIC95 Cardbus write buffers.\n&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/phy/phy-twl4030-usb.c b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">index ef4f3350faa1..a2b877911b0f 100644</span>
<span class="p_header">--- a/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_chunk">@@ -745,7 +745,6 @@</span> <span class="p_context"> static int twl4030_usb_probe(struct platform_device *pdev)</span>
 	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);
 	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, 2000);
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
 
 	/* Our job is to use irqs and status from the power module
 	 * to keep the transceiver disabled when nothing&#39;s connected.
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-370.c b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">index 670e5b01c678..5e423e0b0cb2 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_chunk">@@ -370,11 +370,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6710_mpp_modes[] = {</span>
 	MPP_MODE(64,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;miso&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs1&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs1&quot;)),</span>
 	MPP_MODE(65,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;mosi&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs2&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs2&quot;)),</span>
 };
 
 static struct mvebu_pinctrl_soc_info armada_370_pinctrl_info;
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-375.c b/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_header">index db078fe7ace6..64cc1184ecc2 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_chunk">@@ -92,19 +92,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6720_mpp_modes[] = {</span>
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;io1&quot;)),
 	MPP_MODE(8,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;dev &quot;, &quot;bootcs&quot;),</span>
<span class="p_add">+		 MPP_FUNCTION(0x1, &quot;dev&quot;, &quot;bootcs&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs0&quot;),
 		 MPP_FUNCTION(0x3, &quot;spi1&quot;, &quot;cs0&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;ce&quot;)),
 	MPP_MODE(9,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;nf&quot;, &quot;wen&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;sck&quot;),
 		 MPP_FUNCTION(0x3, &quot;spi1&quot;, &quot;sck&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;we&quot;)),
 	MPP_MODE(10,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;nf&quot;, &quot;ren&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;dram&quot;, &quot;vttctrl&quot;),
 		 MPP_FUNCTION(0x3, &quot;led&quot;, &quot;c1&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;re&quot;),
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-38x.c b/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_header">index 1049f82fb62f..adb6c238f059 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_chunk">@@ -94,37 +94,39 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd0&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs1&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad14&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad14&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie3&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(13,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd1&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad15&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad15&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie2&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(14,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd2&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;clk&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs3&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;wen1&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;wen1&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie3&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(15,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd3&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ge&quot;,    &quot;mdc slave&quot;,  V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;mosi&quot;,       V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;mosi&quot;,       V_88F6810_PLUS)),</span>
 	MPP_MODE(16,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxctl&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ge&quot;,    &quot;mdio slave&quot;, V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;decc_err&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;miso&quot;,       V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS)),</span>
 	MPP_MODE(17,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxclk&quot;,      V_88F6810_PLUS),
<span class="p_chunk">@@ -137,20 +139,18 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxerr&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;trig_gen&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;ua1&quot;,   &quot;txd&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS)),</span>
 	MPP_MODE(19,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;col&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;event_req&quot;,  V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(3, &quot;ge0&quot;,   &quot;txerr&quot;,      V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;ua0&quot;,   &quot;cts&quot;,        V_88F6810_PLUS)),
 	MPP_MODE(20,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;txclk&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;clk&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;ua0&quot;,   &quot;rts&quot;,        V_88F6810_PLUS)),
 	MPP_MODE(21,
<span class="p_chunk">@@ -275,35 +275,27 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;decc_err&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;clkout&quot;,     V_88F6810_PLUS)),
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828)),</span>
 	MPP_MODE(45,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ref&quot;,   &quot;clk_out0&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie2&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie3&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(46,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ref&quot;,   &quot;clk_out1&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie2&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie3&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(47,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
<span class="p_chunk">@@ -311,18 +303,19 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(2, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;pclk&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;mclk&quot;,       V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d4&quot;,         V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d4&quot;,         V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
 		 MPP_VAR_FUNCTION(2, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828),
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;fsync&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;lrclk&quot;,      V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d5&quot;,         V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d5&quot;,         V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS)),</span>
 	MPP_MODE(50,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;drx&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;extclk&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;cmd&quot;,        V_88F6810_PLUS)),
<span class="p_chunk">@@ -334,7 +327,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 	MPP_MODE(52,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;intn&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;sdi&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d6&quot;,         V_88F6810_PLUS)),
<span class="p_chunk">@@ -350,7 +342,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;ge0&quot;,   &quot;txerr&quot;,      V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d3&quot;,         V_88F6810_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
<span class="p_chunk">@@ -380,7 +372,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;i2c1&quot;,  &quot;sda&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d2&quot;,         V_88F6810_PLUS)),
 };
<span class="p_chunk">@@ -409,7 +400,7 @@</span> <span class="p_context"> static struct mvebu_mpp_ctrl armada_38x_mpp_controls[] = {</span>
 
 static struct pinctrl_gpio_range armada_38x_mpp_gpio_ranges[] = {
 	MPP_GPIO_RANGE(0,   0,  0, 32),
<span class="p_del">-	MPP_GPIO_RANGE(1,  32, 32, 27),</span>
<span class="p_add">+	MPP_GPIO_RANGE(1,  32, 32, 28),</span>
 };
 
 static int armada_38x_pinctrl_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">index de311129f7a0..cb06fd293fd2 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_chunk">@@ -14,10 +14,7 @@</span> <span class="p_context"></span>
  * available: mv78230, mv78260 and mv78460. From a pin muxing
  * perspective, the mv78230 has 49 MPP pins. The mv78260 and mv78460
  * both have 67 MPP pins (more GPIOs and address lines for the memory
<span class="p_del">- * bus mainly). The only difference between the mv78260 and the</span>
<span class="p_del">- * mv78460 in terms of pin muxing is the addition of two functions on</span>
<span class="p_del">- * pins 43 and 56 to access the VDD of the CPU2 and 3 (mv78260 has two</span>
<span class="p_del">- * cores, mv78460 has four cores).</span>
<span class="p_add">+ * bus mainly).</span>
  */
 
 #include &lt;linux/err.h&gt;
<span class="p_chunk">@@ -171,20 +168,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(24,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata1&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-re&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;rst&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;hsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(25,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata0&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-we&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;pclk&quot;,       V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(26,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;fsync&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS)),</span>
 	MPP_MODE(27,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;trig&quot;,       V_MV78230_PLUS),
<span class="p_chunk">@@ -199,8 +193,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int0&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(30,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
<span class="p_chunk">@@ -208,13 +201,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(31,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;cmd&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(32,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d0&quot;,         V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(33,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d1&quot;,         V_MV78230_PLUS),
<span class="p_chunk">@@ -246,7 +237,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;spi&quot;, &quot;cs1&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vga-hsync&quot;,  V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq0&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(41,
<span class="p_chunk">@@ -261,15 +251,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;rxd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int7&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(43,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;txd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;rts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;spi&quot;, &quot;cs3&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_chunk">@@ -298,7 +286,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq3&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;tclk&quot;, NULL,        V_MV78230_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;clkout&quot;,     V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x2, &quot;dev&quot;, &quot;burst/last&quot;, V_MV78230_PLUS)),
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_chunk">@@ -320,16 +308,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad19&quot;,       V_MV78260_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(56,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(57,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(58,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad23&quot;,       V_MV78260_PLUS)),
<span class="p_header">diff --git a/drivers/platform/x86/dell-laptop.c b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">index fed4111ac31a..1beb232ef03b 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_chunk">@@ -272,7 +272,6 @@</span> <span class="p_context"> static struct dmi_system_id dell_quirks[] = {</span>
 };
 
 static struct calling_interface_buffer *buffer;
<span class="p_del">-static struct page *bufferpage;</span>
 static DEFINE_MUTEX(buffer_mutex);
 
 static int hwswitch_state;
<span class="p_chunk">@@ -825,12 +824,11 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 	 * Allocate buffer below 4GB for SMI data--only 32-bit physical addr
 	 * is passed to SMI handler.
 	 */
<span class="p_del">-	bufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_del">-	if (!bufferpage) {</span>
<span class="p_add">+	buffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_add">+	if (!buffer) {</span>
 		ret = -ENOMEM;
 		goto fail_buffer;
 	}
<span class="p_del">-	buffer = page_address(bufferpage);</span>
 
 	ret = dell_setup_rfkill();
 
<span class="p_chunk">@@ -892,7 +890,7 @@</span> <span class="p_context"> fail_backlight:</span>
 	cancel_delayed_work_sync(&amp;dell_rfkill_work);
 	dell_cleanup_rfkill();
 fail_rfkill:
<span class="p_del">-	free_page((unsigned long)bufferpage);</span>
<span class="p_add">+	free_page((unsigned long)buffer);</span>
 fail_buffer:
 	platform_device_del(platform_device);
 fail_platform_device2:
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index 7fe7ed830d8d..627d43f3f078 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -464,8 +464,9 @@</span> <span class="p_context"> const struct ideapad_rfk_data ideapad_rfk_data[] = {</span>
 static int ideapad_rfk_set(void *data, bool blocked)
 {
 	struct ideapad_rfk_priv *priv = data;
<span class="p_add">+	int opcode = ideapad_rfk_data[priv-&gt;dev].opcode;</span>
 
<span class="p_del">-	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, priv-&gt;dev, !blocked);</span>
<span class="p_add">+	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, opcode, !blocked);</span>
 }
 
 static struct rfkill_ops ideapad_rfk_ops = {
<span class="p_chunk">@@ -831,6 +832,13 @@</span> <span class="p_context"> static void ideapad_acpi_notify(acpi_handle handle, u32 event, void *data)</span>
  */
 static struct dmi_system_id no_hw_rfkill_list[] = {
 	{
<span class="p_add">+		.ident = &quot;Lenovo G50-30&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo G50-30&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.ident = &quot;Lenovo Yoga 2 11 / 13 / Pro&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="p_header">diff --git a/drivers/regulator/core.c b/drivers/regulator/core.c</span>
<span class="p_header">index efeb4b42c5ed..a2e836478549 100644</span>
<span class="p_header">--- a/drivers/regulator/core.c</span>
<span class="p_header">+++ b/drivers/regulator/core.c</span>
<span class="p_chunk">@@ -773,7 +773,7 @@</span> <span class="p_context"> static int suspend_prepare(struct regulator_dev *rdev, suspend_state_t state)</span>
 static void print_constraints(struct regulator_dev *rdev)
 {
 	struct regulation_constraints *constraints = rdev-&gt;constraints;
<span class="p_del">-	char buf[80] = &quot;&quot;;</span>
<span class="p_add">+	char buf[160] = &quot;&quot;;</span>
 	int count = 0;
 	int ret;
 
<span class="p_header">diff --git a/drivers/s390/kvm/virtio_ccw.c b/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_header">index d2c0b442bce5..b6ade163445c 100644</span>
<span class="p_header">--- a/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_header">+++ b/drivers/s390/kvm/virtio_ccw.c</span>
<span class="p_chunk">@@ -64,6 +64,7 @@</span> <span class="p_context"> struct virtio_ccw_device {</span>
 	bool is_thinint;
 	bool going_away;
 	bool device_lost;
<span class="p_add">+	unsigned int config_ready;</span>
 	void *airq_info;
 };
 
<span class="p_chunk">@@ -758,8 +759,11 @@</span> <span class="p_context"> static void virtio_ccw_get_config(struct virtio_device *vdev,</span>
 	if (ret)
 		goto out_free;
 
<span class="p_del">-	memcpy(vcdev-&gt;config, config_area, sizeof(vcdev-&gt;config));</span>
<span class="p_del">-	memcpy(buf, &amp;vcdev-&gt;config[offset], len);</span>
<span class="p_add">+	memcpy(vcdev-&gt;config, config_area, offset + len);</span>
<span class="p_add">+	if (buf)</span>
<span class="p_add">+		memcpy(buf, &amp;vcdev-&gt;config[offset], len);</span>
<span class="p_add">+	if (vcdev-&gt;config_ready &lt; offset + len)</span>
<span class="p_add">+		vcdev-&gt;config_ready = offset + len;</span>
 
 out_free:
 	kfree(config_area);
<span class="p_chunk">@@ -782,6 +786,9 @@</span> <span class="p_context"> static void virtio_ccw_set_config(struct virtio_device *vdev,</span>
 	if (!config_area)
 		goto out_free;
 
<span class="p_add">+	/* Make sure we don&#39;t overwrite fields. */</span>
<span class="p_add">+	if (vcdev-&gt;config_ready &lt; offset)</span>
<span class="p_add">+		virtio_ccw_get_config(vdev, 0, NULL, offset);</span>
 	memcpy(&amp;vcdev-&gt;config[offset], buf, len);
 	/* Write the config area to the host. */
 	memcpy(config_area, vcdev-&gt;config, sizeof(vcdev-&gt;config));
<span class="p_header">diff --git a/drivers/scsi/ipr.h b/drivers/scsi/ipr.h</span>
<span class="p_header">index c24c747595ba..b22b23586f93 100644</span>
<span class="p_header">--- a/drivers/scsi/ipr.h</span>
<span class="p_header">+++ b/drivers/scsi/ipr.h</span>
<span class="p_chunk">@@ -269,7 +269,7 @@</span> <span class="p_context"></span>
 #define IPR_RUNTIME_RESET				0x40000000
 
 #define IPR_IPL_INIT_MIN_STAGE_TIME			5
<span class="p_del">-#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 15</span>
<span class="p_add">+#define IPR_IPL_INIT_DEFAULT_STAGE_TIME                 30</span>
 #define IPR_IPL_INIT_STAGE_UNKNOWN			0x0
 #define IPR_IPL_INIT_STAGE_TRANSOP			0xB0000000
 #define IPR_IPL_INIT_STAGE_MASK				0xff000000
<span class="p_header">diff --git a/drivers/scsi/scsi_transport_srp.c b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">index a0c5bfdc5366..a68079d66d9e 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_transport_srp.c</span>
<span class="p_chunk">@@ -397,6 +397,36 @@</span> <span class="p_context"> static void srp_reconnect_work(struct work_struct *work)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_add">+ * @shost: SCSI host for which to count the number of scsi_request_fn() callers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To do: add support for scsi-mq in this function.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct scsi_device *sdev;</span>
<span class="p_add">+	struct request_queue *q;</span>
<span class="p_add">+	int request_fn_active = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	shost_for_each_device(sdev, shost) {</span>
<span class="p_add">+		q = sdev-&gt;request_queue;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_add">+		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return request_fn_active;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Wait until ongoing shost-&gt;hostt-&gt;queuecommand() calls have finished. */</span>
<span class="p_add">+static void srp_wait_for_queuecommand(struct Scsi_Host *shost)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (scsi_request_fn_active(shost))</span>
<span class="p_add">+		msleep(20);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __rport_fail_io_fast(struct srp_rport *rport)
 {
 	struct Scsi_Host *shost = rport_to_shost(rport);
<span class="p_chunk">@@ -410,8 +440,10 @@</span> <span class="p_context"> static void __rport_fail_io_fast(struct srp_rport *rport)</span>
 
 	/* Involve the LLD if possible to terminate all I/O on the rport. */
 	i = to_srp_internal(shost-&gt;transportt);
<span class="p_del">-	if (i-&gt;f-&gt;terminate_rport_io)</span>
<span class="p_add">+	if (i-&gt;f-&gt;terminate_rport_io) {</span>
<span class="p_add">+		srp_wait_for_queuecommand(shost);</span>
 		i-&gt;f-&gt;terminate_rport_io(rport);
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -505,27 +537,6 @@</span> <span class="p_context"> void srp_start_tl_fail_timers(struct srp_rport *rport)</span>
 EXPORT_SYMBOL(srp_start_tl_fail_timers);
 
 /**
<span class="p_del">- * scsi_request_fn_active() - number of kernel threads inside scsi_request_fn()</span>
<span class="p_del">- * @shost: SCSI host for which to count the number of scsi_request_fn() callers.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int scsi_request_fn_active(struct Scsi_Host *shost)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct scsi_device *sdev;</span>
<span class="p_del">-	struct request_queue *q;</span>
<span class="p_del">-	int request_fn_active = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	shost_for_each_device(sdev, shost) {</span>
<span class="p_del">-		q = sdev-&gt;request_queue;</span>
<span class="p_del">-</span>
<span class="p_del">-		spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-		request_fn_active += q-&gt;request_fn_active;</span>
<span class="p_del">-		spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return request_fn_active;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  * srp_reconnect_rport() - reconnect to an SRP target port
  * @rport: SRP target port.
  *
<span class="p_chunk">@@ -560,8 +571,7 @@</span> <span class="p_context"> int srp_reconnect_rport(struct srp_rport *rport)</span>
 	if (res)
 		goto out;
 	scsi_target_block(&amp;shost-&gt;shost_gendev);
<span class="p_del">-	while (scsi_request_fn_active(shost))</span>
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+	srp_wait_for_queuecommand(shost);</span>
 	res = rport-&gt;state != SRP_RPORT_LOST ? i-&gt;f-&gt;reconnect(rport) : -ENODEV;
 	pr_debug(&quot;%s (state %d): transport.reconnect() returned %d\n&quot;,
 		 dev_name(&amp;shost-&gt;shost_gendev), rport-&gt;state, res);
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index 577605167be2..3950e4495093 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -1039,9 +1039,6 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 
 	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);
 	mesg = master-&gt;cur_msg;
<span class="p_del">-	master-&gt;cur_msg = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
 	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);
 
 	spi_unmap_msg(master, mesg);
<span class="p_chunk">@@ -1054,9 +1051,13 @@</span> <span class="p_context"> void spi_finalize_current_message(struct spi_master *master)</span>
 		}
 	}
 
<span class="p_del">-	trace_spi_message_done(mesg);</span>
<span class="p_del">-</span>
<span class="p_add">+	spin_lock_irqsave(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+	master-&gt;cur_msg = NULL;</span>
 	master-&gt;cur_msg_prepared = false;
<span class="p_add">+	queue_kthread_work(&amp;master-&gt;kworker, &amp;master-&gt;pump_messages);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;master-&gt;queue_lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_spi_message_done(mesg);</span>
 
 	mesg-&gt;state = NULL;
 	if (mesg-&gt;complete)
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">index 1f700171af13..6971ca67729f 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_chunk">@@ -1069,7 +1069,8 @@</span> <span class="p_context"> static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)</span>
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) &amp;&amp; (frag == 0))
<span class="p_del">-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			alloc_sz = max_t(u16, tmp_len, 1658);</span>
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index 5a5fd937a442..e3ae2599a2b7 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -1402,6 +1402,10 @@</span> <span class="p_context"> static int device_rx_srv(PSDevice pDevice, unsigned int uIdx) {</span>
 	     pRD = pRD-&gt;next) {
 		if (works++ &gt; 15)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		if (!pRD-&gt;pRDInfo-&gt;skb)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		if (device_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
 				DBG_PRT(MSG_LEVEL_ERR, KERN_ERR
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index 454b65898e2c..b5e98de489dc 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -55,9 +55,6 @@</span> <span class="p_context"></span>
 static int __read_mostly sysrq_enabled = CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE;
 static bool __read_mostly sysrq_always_enabled;
 
<span class="p_del">-unsigned short platform_sysrq_reset_seq[] __weak = { KEY_RESERVED };</span>
<span class="p_del">-int sysrq_reset_downtime_ms __weak;</span>
<span class="p_del">-</span>
 static bool sysrq_on(void)
 {
 	return sysrq_enabled || sysrq_always_enabled;
<span class="p_chunk">@@ -567,6 +564,7 @@</span> <span class="p_context"> void handle_sysrq(int key)</span>
 EXPORT_SYMBOL(handle_sysrq);
 
 #ifdef CONFIG_INPUT
<span class="p_add">+static int sysrq_reset_downtime_ms;</span>
 
 /* Simple translation table for the SysRq keys */
 static const unsigned char sysrq_xlate[KEY_CNT] =
<span class="p_chunk">@@ -947,23 +945,8 @@</span> <span class="p_context"> static bool sysrq_handler_registered;</span>
 
 static inline void sysrq_register_handler(void)
 {
<span class="p_del">-	unsigned short key;</span>
 	int error;
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First check if a __weak interface was instantiated. */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(sysrq_reset_seq); i++) {</span>
<span class="p_del">-		key = platform_sysrq_reset_seq[i];</span>
<span class="p_del">-		if (key == KEY_RESERVED || key &gt; KEY_MAX)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		sysrq_reset_seq[sysrq_reset_seq_len++] = key;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * DT configuration takes precedence over anything that would</span>
<span class="p_del">-	 * have been defined via the __weak interface.</span>
<span class="p_del">-	 */</span>
 	sysrq_of_get_keyreset_config();
 
 	error = input_register_handler(&amp;sysrq_handler);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index a8946e88978e..54c79f7fdaf5 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1480,6 +1480,11 @@</span> <span class="p_context"> skip_countries:</span>
 		goto alloc_fail8;
 	}
 
<span class="p_add">+	if (quirks &amp; CLEAR_HALT_CONDITIONS) {</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress));</span>
<span class="p_add">+		usb_clear_halt(usb_dev, usb_sndbulkpipe(usb_dev, epwrite-&gt;bEndpointAddress));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 alloc_fail8:
 	if (acm-&gt;country_codes) {
<span class="p_chunk">@@ -1759,6 +1764,10 @@</span> <span class="p_context"> static const struct usb_device_id acm_ids[] = {</span>
 	.driver_info = NO_UNION_NORMAL, /* reports zero length descriptor */
 	},
 
<span class="p_add">+	{ USB_DEVICE(0x2912, 0x0001), /* ATOL FPrint */</span>
<span class="p_add">+	.driver_info = CLEAR_HALT_CONDITIONS,</span>
<span class="p_add">+	},</span>
<span class="p_add">+</span>
 	/* Nokia S60 phones expose two ACM channels. The first is
 	 * a modem and is picked up by the standard AT-command
 	 * information below. The second is &#39;vendor-specific&#39; but
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index d3251ebd09e2..9cca2e7280bb 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -134,3 +134,4 @@</span> <span class="p_context"> struct acm {</span>
 #define NO_DATA_INTERFACE		BIT(4)
 #define IGNORE_DEVICE			BIT(5)
 #define QUIRK_CONTROL_LINE_STATE	BIT(6)
<span class="p_add">+#define CLEAR_HALT_CONDITIONS		BIT(7)</span>
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index e500243803d8..fae81924fd4b 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	snoop(&amp;urb-&gt;dev-&gt;dev, &quot;urb complete\n&quot;);
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE, NULL, 0);
<span class="p_del">-	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == USB_DIR_IN)</span>
<span class="p_add">+	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN)</span>
 		snoop_urb_data(urb, urb-&gt;actual_length);
 
 	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 4209fc7d91c6..a3ab650a1f72 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -2608,9 +2608,6 @@</span> <span class="p_context"> static bool use_new_scheme(struct usb_device *udev, int retry)</span>
 	return USE_NEW_SCHEME(retry);
 }
 
<span class="p_del">-static int hub_port_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, unsigned int delay, bool warm);</span>
<span class="p_del">-</span>
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?
  * Port worm reset is required to recover
  */
<span class="p_chunk">@@ -2691,44 +2688,6 @@</span> <span class="p_context"> static int hub_port_wait_reset(struct usb_hub *hub, int port1,</span>
 	return 0;
 }
 
<span class="p_del">-static void hub_port_finish_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, int *status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (*status) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_del">-		msleep(10 + 40);</span>
<span class="p_del">-		if (udev) {</span>
<span class="p_del">-			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_del">-</span>
<span class="p_del">-			update_devnum(udev, 0);</span>
<span class="p_del">-			/* The xHC may think the device is already reset,</span>
<span class="p_del">-			 * so ignore the status.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_del">-				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* FALL THROUGH */</span>
<span class="p_del">-	case -ENOTCONN:</span>
<span class="p_del">-	case -ENODEV:</span>
<span class="p_del">-		usb_clear_port_feature(hub-&gt;hdev,</span>
<span class="p_del">-				port1, USB_PORT_FEAT_C_RESET);</span>
<span class="p_del">-		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (udev)</span>
<span class="p_del">-			usb_set_device_state(udev, *status</span>
<span class="p_del">-					? USB_STATE_NOTATTACHED</span>
<span class="p_del">-					: USB_STATE_DEFAULT);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */
 static int hub_port_reset(struct usb_hub *hub, int port1,
 			struct usb_device *udev, unsigned int delay, bool warm)
<span class="p_chunk">@@ -2752,13 +2711,9 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 		 * If the caller hasn&#39;t explicitly requested a warm reset,
 		 * double check and see if one is needed.
 		 */
<span class="p_del">-		status = hub_port_status(hub, port1,</span>
<span class="p_del">-					&amp;portstatus, &amp;portchange);</span>
<span class="p_del">-		if (status &lt; 0)</span>
<span class="p_del">-			goto done;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (hub_port_warm_reset_required(hub, portstatus))</span>
<span class="p_del">-			warm = true;</span>
<span class="p_add">+		if (hub_port_status(hub, port1, &amp;portstatus, &amp;portchange) == 0)</span>
<span class="p_add">+			if (hub_port_warm_reset_required(hub, portstatus))</span>
<span class="p_add">+				warm = true;</span>
 	}
 
 	/* Reset the port */
<span class="p_chunk">@@ -2783,11 +2738,19 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 
 		/* Check for disconnect or reset */
 		if (status == 0 || status == -ENOTCONN || status == -ENODEV) {
<span class="p_del">-			hub_port_finish_reset(hub, port1, udev, &amp;status);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_RESET);</span>
 
 			if (!hub_is_superspeed(hub-&gt;hdev))
 				goto done;
 
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_add">+</span>
 			/*
 			 * If a USB 3.0 device migrates from reset to an error
 			 * state, re-issue the warm reset.
<span class="p_chunk">@@ -2819,6 +2782,26 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 	dev_err(&amp;port_dev-&gt;dev, &quot;Cannot enable. Maybe the USB cable is bad?\n&quot;);
 
 done:
<span class="p_add">+	if (status == 0) {</span>
<span class="p_add">+		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_add">+		msleep(10 + 40);</span>
<span class="p_add">+		if (udev) {</span>
<span class="p_add">+			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_add">+</span>
<span class="p_add">+			update_devnum(udev, 0);</span>
<span class="p_add">+			/* The xHC may think the device is already reset,</span>
<span class="p_add">+			 * so ignore the status.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_add">+				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_DEFAULT);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (udev)</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_NOTATTACHED);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!hub_is_superspeed(hub-&gt;hdev))
 		up_read(&amp;ehci_cf_port_reset_rwsem);
 
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index c24c0bb7f6f3..18d2ffcc462b 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -376,6 +376,8 @@</span> <span class="p_context"> int dwc3_send_gadget_generic_command(struct dwc3 *dwc, int cmd, u32 param)</span>
 		if (!(reg &amp; DWC3_DGCMD_CMDACT)) {
 			dev_vdbg(dwc-&gt;dev, &quot;Command Complete --&gt; %d\n&quot;,
 					DWC3_DGCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DGCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_chunk">@@ -1985,12 +1987,16 @@</span> <span class="p_context"> static void dwc3_endpoint_transfer_complete(struct dwc3 *dwc,</span>
 {
 	unsigned		status = 0;
 	int			clean_busy;
<span class="p_add">+	u32			is_xfer_complete;</span>
<span class="p_add">+</span>
<span class="p_add">+	is_xfer_complete = (event-&gt;endpoint_event == DWC3_DEPEVT_XFERCOMPLETE);</span>
 
 	if (event-&gt;status &amp; DEPEVT_STATUS_BUSERR)
 		status = -ECONNRESET;
 
 	clean_busy = dwc3_cleanup_done_reqs(dwc, dep, event, status);
<span class="p_del">-	if (clean_busy)</span>
<span class="p_add">+	if (clean_busy &amp;&amp; (is_xfer_complete ||</span>
<span class="p_add">+				usb_endpoint_xfer_isoc(dep-&gt;endpoint.desc)))</span>
 		dep-&gt;flags &amp;= ~DWC3_EP_BUSY;
 
 	/*
<span class="p_header">diff --git a/drivers/w1/slaves/w1_therm.c b/drivers/w1/slaves/w1_therm.c</span>
<span class="p_header">index 1f11a20a8ab9..55eb86c9e214 100644</span>
<span class="p_header">--- a/drivers/w1/slaves/w1_therm.c</span>
<span class="p_header">+++ b/drivers/w1/slaves/w1_therm.c</span>
<span class="p_chunk">@@ -59,16 +59,32 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;w1-family-&quot; __stringify(W1_THERM_DS28EA00));</span>
 static int w1_strong_pullup = 1;
 module_param_named(strong_pullup, w1_strong_pullup, int, 0);
 
<span class="p_add">+struct w1_therm_family_data {</span>
<span class="p_add">+	uint8_t rom[9];</span>
<span class="p_add">+	atomic_t refcnt;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* return the address of the refcnt in the family data */</span>
<span class="p_add">+#define THERM_REFCNT(family_data) \</span>
<span class="p_add">+	(&amp;((struct w1_therm_family_data*)family_data)-&gt;refcnt)</span>
<span class="p_add">+</span>
 static int w1_therm_add_slave(struct w1_slave *sl)
 {
<span class="p_del">-	sl-&gt;family_data = kzalloc(9, GFP_KERNEL);</span>
<span class="p_add">+	sl-&gt;family_data = kzalloc(sizeof(struct w1_therm_family_data),</span>
<span class="p_add">+		GFP_KERNEL);</span>
 	if (!sl-&gt;family_data)
 		return -ENOMEM;
<span class="p_add">+	atomic_set(THERM_REFCNT(sl-&gt;family_data), 1);</span>
 	return 0;
 }
 
 static void w1_therm_remove_slave(struct w1_slave *sl)
 {
<span class="p_add">+	int refcnt = atomic_sub_return(1, THERM_REFCNT(sl-&gt;family_data));</span>
<span class="p_add">+	while(refcnt) {</span>
<span class="p_add">+		msleep(1000);</span>
<span class="p_add">+		refcnt = atomic_read(THERM_REFCNT(sl-&gt;family_data));</span>
<span class="p_add">+	}</span>
 	kfree(sl-&gt;family_data);
 	sl-&gt;family_data = NULL;
 }
<span class="p_chunk">@@ -194,13 +210,22 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 	struct w1_slave *sl = dev_to_w1_slave(device);
 	struct w1_master *dev = sl-&gt;master;
 	u8 rom[9], crc, verdict, external_power;
<span class="p_del">-	int i, max_trying = 10;</span>
<span class="p_add">+	int i, ret, max_trying = 10;</span>
 	ssize_t c = PAGE_SIZE;
<span class="p_add">+	u8 *family_data = sl-&gt;family_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_add">+	if (ret != 0)</span>
<span class="p_add">+		goto post_unlock;</span>
 
<span class="p_del">-	i = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-	if (i != 0)</span>
<span class="p_del">-		return i;</span>
<span class="p_add">+	if(!sl-&gt;family_data)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto pre_unlock;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	/* prevent the slave from going away in sleep */</span>
<span class="p_add">+	atomic_inc(THERM_REFCNT(family_data));</span>
 	memset(rom, 0, sizeof(rom));
 
 	while (max_trying--) {
<span class="p_chunk">@@ -230,17 +255,19 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 				mutex_unlock(&amp;dev-&gt;bus_mutex);
 
 				sleep_rem = msleep_interruptible(tm);
<span class="p_del">-				if (sleep_rem != 0)</span>
<span class="p_del">-					return -EINTR;</span>
<span class="p_add">+				if (sleep_rem != 0) {</span>
<span class="p_add">+					ret = -EINTR;</span>
<span class="p_add">+					goto post_unlock;</span>
<span class="p_add">+				}</span>
 
<span class="p_del">-				i = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-				if (i != 0)</span>
<span class="p_del">-					return i;</span>
<span class="p_add">+				ret = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_add">+				if (ret != 0)</span>
<span class="p_add">+					goto post_unlock;</span>
 			} else if (!w1_strong_pullup) {
 				sleep_rem = msleep_interruptible(tm);
 				if (sleep_rem != 0) {
<span class="p_del">-					mutex_unlock(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-					return -EINTR;</span>
<span class="p_add">+					ret = -EINTR;</span>
<span class="p_add">+					goto pre_unlock;</span>
 				}
 			}
 
<span class="p_chunk">@@ -269,19 +296,24 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 	c -= snprintf(buf + PAGE_SIZE - c, c, &quot;: crc=%02x %s\n&quot;,
 			   crc, (verdict) ? &quot;YES&quot; : &quot;NO&quot;);
 	if (verdict)
<span class="p_del">-		memcpy(sl-&gt;family_data, rom, sizeof(rom));</span>
<span class="p_add">+		memcpy(family_data, rom, sizeof(rom));</span>
 	else
 		dev_warn(device, &quot;Read failed CRC check\n&quot;);
 
 	for (i = 0; i &lt; 9; ++i)
 		c -= snprintf(buf + PAGE_SIZE - c, c, &quot;%02x &quot;,
<span class="p_del">-			      ((u8 *)sl-&gt;family_data)[i]);</span>
<span class="p_add">+			      ((u8 *)family_data)[i]);</span>
 
 	c -= snprintf(buf + PAGE_SIZE - c, c, &quot;t=%d\n&quot;,
 		w1_convert_temp(rom, sl-&gt;family-&gt;fid));
<span class="p_add">+	ret = PAGE_SIZE - c;</span>
<span class="p_add">+</span>
<span class="p_add">+pre_unlock:</span>
 	mutex_unlock(&amp;dev-&gt;bus_mutex);
 
<span class="p_del">-	return PAGE_SIZE - c;</span>
<span class="p_add">+post_unlock:</span>
<span class="p_add">+	atomic_dec(THERM_REFCNT(family_data));</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int __init w1_therm_init(void)
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index 3691b157516a..0c8868eceb4d 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -132,6 +132,13 @@</span> <span class="p_context"> static int omap_wdt_start(struct watchdog_device *wdog)</span>
 
 	pm_runtime_get_sync(wdev-&gt;dev);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the watchdog is disabled. This is unfortunately required</span>
<span class="p_add">+	 * because writing to various registers with the watchdog running has no</span>
<span class="p_add">+	 * effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	omap_wdt_disable(wdev);</span>
<span class="p_add">+</span>
 	/* initialize prescaler */
 	while (readl_relaxed(base + OMAP_WATCHDOG_WPS) &amp; 0x01)
 		cpu_relax();
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 600035120ca3..863f3d65fe39 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -1203,7 +1203,9 @@</span> <span class="p_context"> static struct dentry *mount_subvol(const char *subvol_name, int flags,</span>
 				return ERR_CAST(mnt);
 			}
 
<span class="p_add">+			down_write(&amp;mnt-&gt;mnt_sb-&gt;s_umount);</span>
 			r = btrfs_remount(mnt-&gt;mnt_sb, &amp;flags, NULL);
<span class="p_add">+			up_write(&amp;mnt-&gt;mnt_sb-&gt;s_umount);</span>
 			if (r &lt; 0) {
 				/* FIXME: release vfsmount mnt ??*/
 				kfree(newargs);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 05a041a134c4..df0de6b95409 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -2898,17 +2898,6 @@</span> <span class="p_context"> restart:</span>
 				vfsmnt = &amp;mnt-&gt;mnt;
 				continue;
 			}
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Filesystems needing to implement special &quot;root names&quot;</span>
<span class="p_del">-			 * should do so with -&gt;d_dname()</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (IS_ROOT(dentry) &amp;&amp;</span>
<span class="p_del">-			   (dentry-&gt;d_name.len != 1 ||</span>
<span class="p_del">-			    dentry-&gt;d_name.name[0] != &#39;/&#39;)) {</span>
<span class="p_del">-				WARN(1, &quot;Root dentry has weird name &lt;%.*s&gt;\n&quot;,</span>
<span class="p_del">-				     (int) dentry-&gt;d_name.len,</span>
<span class="p_del">-				     dentry-&gt;d_name.name);</span>
<span class="p_del">-			}</span>
 			if (!error)
 				error = is_mounted(vfsmnt) ? 1 : 2;
 			break;
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index 944c49dd83e3..0c9ed67fe055 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -576,7 +576,7 @@</span> <span class="p_context"> int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, &quot;Can&#39;t allocate blocks for &quot;
 				 &quot;non-extent mapped inodes with bigalloc&quot;);
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_add">+		return -EUCLEAN;</span>
 	}
 
 	goal = ext4_find_goal(inode, map-&gt;m_lblk, partial);
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 6a37a1f51e56..fd3c9d5ac932 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1740,19 +1740,32 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
<span class="p_del">-	/* As soon as we unlock the page, it can go away, but we have</span>
<span class="p_del">-	 * references to buffers so we are safe */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to release the page lock before we start the</span>
<span class="p_add">+	 * journal, so grab a reference so the page won&#39;t disappear</span>
<span class="p_add">+	 * out from under us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	get_page(page);</span>
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		goto out_no_pagelock;</span>
 	}
<span class="p_del">-</span>
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_add">+	lock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	if (page-&gt;mapping != mapping) {</span>
<span class="p_add">+		/* The page got truncated from under us */</span>
<span class="p_add">+		ext4_journal_stop(handle);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (inline_data) {
 		BUFFER_TRACE(inode_bh, &quot;get write access&quot;);
 		ret = ext4_journal_get_write_access(handle, inode_bh);
<span class="p_chunk">@@ -1778,6 +1791,8 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_no_pagelock:</span>
 	brelse(inode_bh);
 	return ret;
 }
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 447ccd4af707..cf977e2f8a6f 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -833,6 +833,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
<span class="p_add">+	sync_blockdev(sb-&gt;s_bdev);</span>
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index 03246cd9d47a..9e3f6cfee2fb 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -1049,6 +1049,7 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto err_fput;
 
 	fuse_conn_init(fc);
<span class="p_add">+	fc-&gt;release = fuse_free_conn;</span>
 
 	fc-&gt;dev = sb-&gt;s_dev;
 	fc-&gt;sb = sb;
<span class="p_chunk">@@ -1063,7 +1064,6 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		fc-&gt;dont_mask = 1;
 	sb-&gt;s_flags |= MS_POSIXACL;
 
<span class="p_del">-	fc-&gt;release = fuse_free_conn;</span>
 	fc-&gt;flags = d.flags;
 	fc-&gt;user_id = d.user_id;
 	fc-&gt;group_id = d.group_id;
<span class="p_header">diff --git a/fs/inode.c b/fs/inode.c</span>
<span class="p_header">index 6eecb7ff0b9a..f5a842698580 100644</span>
<span class="p_header">--- a/fs/inode.c</span>
<span class="p_header">+++ b/fs/inode.c</span>
<span class="p_chunk">@@ -1630,8 +1630,8 @@</span> <span class="p_context"> int file_remove_suid(struct file *file)</span>
 		error = security_inode_killpriv(dentry);
 	if (!error &amp;&amp; killsuid)
 		error = __remove_suid(dentry, killsuid);
<span class="p_del">-	if (!error &amp;&amp; (inode-&gt;i_sb-&gt;s_flags &amp; MS_NOSEC))</span>
<span class="p_del">-		inode-&gt;i_flags |= S_NOSEC;</span>
<span class="p_add">+	if (!error)</span>
<span class="p_add">+		inode_has_no_xattr(inode);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 7f34f4716165..b892355f1944 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	unsigned long	blocknr;
 
 	if (is_journal_aborted(journal))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EIO;</span>
 
 	if (!jbd2_journal_get_log_tail(journal, &amp;first_tid, &amp;blocknr))
 		return 1;
<span class="p_chunk">@@ -463,10 +463,9 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	 * jbd2_cleanup_journal_tail() doesn&#39;t get called all that often.
 	 */
 	if (journal-&gt;j_flags &amp; JBD2_BARRIER)
<span class="p_del">-		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_NOFS, NULL);</span>
 
<span class="p_del">-	__jbd2_update_log_tail(journal, first_tid, blocknr);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return __jbd2_update_log_tail(journal, first_tid, blocknr);</span>
 }
 
 
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index 19d74d86d99c..72e238b50ad1 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -885,9 +885,10 @@</span> <span class="p_context"> int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
  *
  * Requires j_checkpoint_mutex
  */
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 {
 	unsigned long freed;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 
<span class="p_chunk">@@ -897,7 +898,10 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	 * space and if we lose sb update during power failure we&#39;d replay
 	 * old transaction with possibly newly overwritten data.
 	 */
<span class="p_del">-	jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
 	freed = block - journal-&gt;j_tail;
 	if (block &lt; journal-&gt;j_tail)
<span class="p_chunk">@@ -913,6 +917,9 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	journal-&gt;j_tail_sequence = tid;
 	journal-&gt;j_tail = block;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -1331,7 +1338,7 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 	return jbd2_journal_start_thread(journal);
 }
 
<span class="p_del">-static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
<span class="p_add">+static int jbd2_write_superblock(journal_t *journal, int write_op)</span>
 {
 	struct buffer_head *bh = journal-&gt;j_sb_buffer;
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_chunk">@@ -1370,7 +1377,10 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
 		printk(KERN_ERR &quot;JBD2: Error %d detected when updating &quot;
 		       &quot;journal superblock for %s.\n&quot;, ret,
 		       journal-&gt;j_devname);
<span class="p_add">+		jbd2_journal_abort(journal, ret);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1383,10 +1393,11 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
  * Update a journal&#39;s superblock information about log tail and write it to
  * disk, waiting for the IO to complete.
  */
<span class="p_del">-void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
<span class="p_add">+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 				     unsigned long tail_block, int write_op)
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,
<span class="p_chunk">@@ -1395,13 +1406,18 @@</span> <span class="p_context"> void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 	sb-&gt;s_sequence = cpu_to_be32(tail_tid);
 	sb-&gt;s_start    = cpu_to_be32(tail_block);
 
<span class="p_del">-	jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	ret = jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Log is no longer empty */
 	write_lock(&amp;journal-&gt;j_state_lock);
 	WARN_ON(!sb-&gt;s_sequence);
 	journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1952,7 +1968,14 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 		return -EIO;
 
 	mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-	jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		err = jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+	}</span>
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
<span class="p_chunk">@@ -1968,7 +1991,8 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	J_ASSERT(journal-&gt;j_head == journal-&gt;j_tail);
 	J_ASSERT(journal-&gt;j_tail_sequence == journal-&gt;j_transaction_sequence);
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/kernfs/dir.c b/fs/kernfs/dir.c</span>
<span class="p_header">index a693f5b01ae6..6309457847cd 100644</span>
<span class="p_header">--- a/fs/kernfs/dir.c</span>
<span class="p_header">+++ b/fs/kernfs/dir.c</span>
<span class="p_chunk">@@ -594,6 +594,9 @@</span> <span class="p_context"> int kernfs_add_one(struct kernfs_node *kn)</span>
 		goto out_unlock;
 
 	ret = -ENOENT;
<span class="p_add">+	if (parent-&gt;flags &amp; KERNFS_EMPTY_DIR)</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+</span>
 	if ((parent-&gt;flags &amp; KERNFS_ACTIVATED) &amp;&amp; !kernfs_active(parent))
 		goto out_unlock;
 
<span class="p_chunk">@@ -785,6 +788,38 @@</span> <span class="p_context"> struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,</span>
 	return ERR_PTR(rc);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * kernfs_create_empty_dir - create an always empty directory</span>
<span class="p_add">+ * @parent: parent in which to create a new directory</span>
<span class="p_add">+ * @name: name of the new directory</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the created node on success, ERR_PTR() value on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,</span>
<span class="p_add">+					    const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kernfs_node *kn;</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* allocate */</span>
<span class="p_add">+	kn = kernfs_new_node(parent, name, S_IRUGO|S_IXUGO|S_IFDIR, KERNFS_DIR);</span>
<span class="p_add">+	if (!kn)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	kn-&gt;flags |= KERNFS_EMPTY_DIR;</span>
<span class="p_add">+	kn-&gt;dir.root = parent-&gt;dir.root;</span>
<span class="p_add">+	kn-&gt;ns = NULL;</span>
<span class="p_add">+	kn-&gt;priv = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* link in */</span>
<span class="p_add">+	rc = kernfs_add_one(kn);</span>
<span class="p_add">+	if (!rc)</span>
<span class="p_add">+		return kn;</span>
<span class="p_add">+</span>
<span class="p_add">+	kernfs_put(kn);</span>
<span class="p_add">+	return ERR_PTR(rc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct dentry *kernfs_iop_lookup(struct inode *dir,
 					struct dentry *dentry,
 					unsigned int flags)
<span class="p_chunk">@@ -1256,7 +1291,8 @@</span> <span class="p_context"> int kernfs_rename_ns(struct kernfs_node *kn, struct kernfs_node *new_parent,</span>
 	mutex_lock(&amp;kernfs_mutex);
 
 	error = -ENOENT;
<span class="p_del">-	if (!kernfs_active(kn) || !kernfs_active(new_parent))</span>
<span class="p_add">+	if (!kernfs_active(kn) || !kernfs_active(new_parent) ||</span>
<span class="p_add">+	    (new_parent-&gt;flags &amp; KERNFS_EMPTY_DIR))</span>
 		goto out;
 
 	error = 0;
<span class="p_header">diff --git a/fs/kernfs/inode.c b/fs/kernfs/inode.c</span>
<span class="p_header">index 985217626e66..5b8ab29494b7 100644</span>
<span class="p_header">--- a/fs/kernfs/inode.c</span>
<span class="p_header">+++ b/fs/kernfs/inode.c</span>
<span class="p_chunk">@@ -309,6 +309,8 @@</span> <span class="p_context"> static void kernfs_init_inode(struct kernfs_node *kn, struct inode *inode)</span>
 	case KERNFS_DIR:
 		inode-&gt;i_op = &amp;kernfs_dir_iops;
 		inode-&gt;i_fop = &amp;kernfs_dir_fops;
<span class="p_add">+		if (kn-&gt;flags &amp; KERNFS_EMPTY_DIR)</span>
<span class="p_add">+			make_empty_dir_inode(inode);</span>
 		break;
 	case KERNFS_FILE:
 		inode-&gt;i_size = kn-&gt;attr.size;
<span class="p_header">diff --git a/fs/libfs.c b/fs/libfs.c</span>
<span class="p_header">index e801b983b46b..c4c5f7223477 100644</span>
<span class="p_header">--- a/fs/libfs.c</span>
<span class="p_header">+++ b/fs/libfs.c</span>
<span class="p_chunk">@@ -1075,3 +1075,99 @@</span> <span class="p_context"> struct inode *alloc_anon_inode(struct super_block *s)</span>
 	return inode;
 }
 EXPORT_SYMBOL(alloc_anon_inode);
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Operations for a permanently empty directory.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct dentry *empty_dir_lookup(struct inode *dir, struct dentry *dentry, unsigned int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ERR_PTR(-ENOENT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_getattr(struct vfsmount *mnt, struct dentry *dentry,</span>
<span class="p_add">+				 struct kstat *stat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = d_inode(dentry);</span>
<span class="p_add">+	generic_fillattr(inode, stat);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_setattr(struct dentry *dentry, struct iattr *attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EPERM;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_setxattr(struct dentry *dentry, const char *name,</span>
<span class="p_add">+			      const void *value, size_t size, int flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t empty_dir_getxattr(struct dentry *dentry, const char *name,</span>
<span class="p_add">+				  void *value, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_removexattr(struct dentry *dentry, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t empty_dir_listxattr(struct dentry *dentry, char *list, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return -EOPNOTSUPP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct inode_operations empty_dir_inode_operations = {</span>
<span class="p_add">+	.lookup		= empty_dir_lookup,</span>
<span class="p_add">+	.permission	= generic_permission,</span>
<span class="p_add">+	.setattr	= empty_dir_setattr,</span>
<span class="p_add">+	.getattr	= empty_dir_getattr,</span>
<span class="p_add">+	.setxattr	= empty_dir_setxattr,</span>
<span class="p_add">+	.getxattr	= empty_dir_getxattr,</span>
<span class="p_add">+	.removexattr	= empty_dir_removexattr,</span>
<span class="p_add">+	.listxattr	= empty_dir_listxattr,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static loff_t empty_dir_llseek(struct file *file, loff_t offset, int whence)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* An empty directory has two entries . and .. at offsets 0 and 1 */</span>
<span class="p_add">+	return generic_file_llseek_size(file, offset, whence, 2, 2);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int empty_dir_readdir(struct file *file, struct dir_context *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dir_emit_dots(file, ctx);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct file_operations empty_dir_operations = {</span>
<span class="p_add">+	.llseek		= empty_dir_llseek,</span>
<span class="p_add">+	.read		= generic_read_dir,</span>
<span class="p_add">+	.iterate	= empty_dir_readdir,</span>
<span class="p_add">+	.fsync		= noop_fsync,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+void make_empty_dir_inode(struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set_nlink(inode, 2);</span>
<span class="p_add">+	inode-&gt;i_mode = S_IFDIR | S_IRUGO | S_IXUGO;</span>
<span class="p_add">+	inode-&gt;i_uid = GLOBAL_ROOT_UID;</span>
<span class="p_add">+	inode-&gt;i_gid = GLOBAL_ROOT_GID;</span>
<span class="p_add">+	inode-&gt;i_rdev = 0;</span>
<span class="p_add">+	inode-&gt;i_size = 2;</span>
<span class="p_add">+	inode-&gt;i_blkbits = PAGE_SHIFT;</span>
<span class="p_add">+	inode-&gt;i_blocks = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	inode-&gt;i_op = &amp;empty_dir_inode_operations;</span>
<span class="p_add">+	inode-&gt;i_fop = &amp;empty_dir_operations;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+bool is_empty_dir_inode(struct inode *inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (inode-&gt;i_fop == &amp;empty_dir_operations) &amp;&amp;</span>
<span class="p_add">+		(inode-&gt;i_op == &amp;empty_dir_inode_operations);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/fs/namespace.c b/fs/namespace.c</span>
<span class="p_header">index 6dfb6fc34286..b50d8daa7cb0 100644</span>
<span class="p_header">--- a/fs/namespace.c</span>
<span class="p_header">+++ b/fs/namespace.c</span>
<span class="p_chunk">@@ -2172,6 +2172,8 @@</span> <span class="p_context"> unlock:</span>
 	return err;
 }
 
<span class="p_add">+static bool fs_fully_visible(struct file_system_type *fs_type, int *new_mnt_flags);</span>
<span class="p_add">+</span>
 /*
  * create a new mount for userspace and request it to be added into the
  * namespace&#39;s tree
<span class="p_chunk">@@ -2203,6 +2205,10 @@</span> <span class="p_context"> static int do_new_mount(struct path *path, const char *fstype, int flags,</span>
 			flags |= MS_NODEV;
 			mnt_flags |= MNT_NODEV | MNT_LOCK_NODEV;
 		}
<span class="p_add">+		if (type-&gt;fs_flags &amp; FS_USERNS_VISIBLE) {</span>
<span class="p_add">+			if (!fs_fully_visible(type, &amp;mnt_flags))</span>
<span class="p_add">+				return -EPERM;</span>
<span class="p_add">+		}</span>
 	}
 
 	mnt = vfs_kern_mount(type, flags, name, data);
<span class="p_chunk">@@ -3023,9 +3029,10 @@</span> <span class="p_context"> bool current_chrooted(void)</span>
 	return chrooted;
 }
 
<span class="p_del">-bool fs_fully_visible(struct file_system_type *type)</span>
<span class="p_add">+static bool fs_fully_visible(struct file_system_type *type, int *new_mnt_flags)</span>
 {
 	struct mnt_namespace *ns = current-&gt;nsproxy-&gt;mnt_ns;
<span class="p_add">+	int new_flags = *new_mnt_flags;</span>
 	struct mount *mnt;
 	bool visible = false;
 
<span class="p_chunk">@@ -3044,16 +3051,36 @@</span> <span class="p_context"> bool fs_fully_visible(struct file_system_type *type)</span>
 		if (mnt-&gt;mnt.mnt_root != mnt-&gt;mnt.mnt_sb-&gt;s_root)
 			continue;
 
<span class="p_del">-		/* This mount is not fully visible if there are any child mounts</span>
<span class="p_del">-		 * that cover anything except for empty directories.</span>
<span class="p_add">+		/* Verify the mount flags are equal to or more permissive</span>
<span class="p_add">+		 * than the proposed new mount.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_READONLY) &amp;&amp;</span>
<span class="p_add">+		    !(new_flags &amp; MNT_READONLY))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_NODEV) &amp;&amp;</span>
<span class="p_add">+		    !(new_flags &amp; MNT_NODEV))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		if ((mnt-&gt;mnt.mnt_flags &amp; MNT_LOCK_ATIME) &amp;&amp;</span>
<span class="p_add">+		    ((mnt-&gt;mnt.mnt_flags &amp; MNT_ATIME_MASK) != (new_flags &amp; MNT_ATIME_MASK)))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* This mount is not fully visible if there are any</span>
<span class="p_add">+		 * locked child mounts that cover anything except for</span>
<span class="p_add">+		 * empty directories.</span>
 		 */
 		list_for_each_entry(child, &amp;mnt-&gt;mnt_mounts, mnt_child) {
 			struct inode *inode = child-&gt;mnt_mountpoint-&gt;d_inode;
<span class="p_del">-			if (!S_ISDIR(inode-&gt;i_mode))</span>
<span class="p_del">-				goto next;</span>
<span class="p_del">-			if (inode-&gt;i_nlink &gt; 2)</span>
<span class="p_add">+			/* Only worry about locked mounts */</span>
<span class="p_add">+			if (!(mnt-&gt;mnt.mnt_flags &amp; MNT_LOCKED))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			/* Is the directory permanetly empty? */</span>
<span class="p_add">+			if (!is_empty_dir_inode(inode))</span>
 				goto next;
 		}
<span class="p_add">+		/* Preserve the locked attributes */</span>
<span class="p_add">+		*new_mnt_flags |= mnt-&gt;mnt.mnt_flags &amp; (MNT_LOCK_READONLY | \</span>
<span class="p_add">+							MNT_LOCK_NODEV    | \</span>
<span class="p_add">+							MNT_LOCK_ATIME);</span>
 		visible = true;
 		goto found;
 	next:	;
<span class="p_header">diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c</span>
<span class="p_header">index 8f4cbe7f4aa8..53853ca134e5 100644</span>
<span class="p_header">--- a/fs/nfs/nfs3xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs3xdr.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,</span>
 	if (args-&gt;npages != 0)
 		xdr_write_pages(xdr, args-&gt;pages, 0, args-&gt;len);
 	else
<span class="p_del">-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);</span>
<span class="p_add">+		xdr_reserve_space(xdr, args-&gt;len);</span>
 
 	error = nfsacl_encode(xdr-&gt;buf, base, args-&gt;inode,
 			    (args-&gt;mask &amp; NFS_ACL) ?
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index c401b4de6b01..dd15268c003c 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -38,6 +38,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/errno.h&gt;
<span class="p_add">+#include &lt;linux/file.h&gt;</span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/ratelimit.h&gt;
 #include &lt;linux/printk.h&gt;
<span class="p_chunk">@@ -5433,6 +5434,7 @@</span> <span class="p_context"> static struct nfs4_lockdata *nfs4_alloc_lockdata(struct file_lock *fl,</span>
 	p-&gt;server = server;
 	atomic_inc(&amp;lsp-&gt;ls_count);
 	p-&gt;ctx = get_nfs_open_context(ctx);
<span class="p_add">+	get_file(fl-&gt;fl_file);</span>
 	memcpy(&amp;p-&gt;fl, fl, sizeof(p-&gt;fl));
 	return p;
 out_free_seqid:
<span class="p_chunk">@@ -5522,6 +5524,7 @@</span> <span class="p_context"> static void nfs4_lock_release(void *calldata)</span>
 		nfs_free_seqid(data-&gt;arg.lock_seqid);
 	nfs4_put_lock_state(data-&gt;lsp);
 	put_nfs_open_context(data-&gt;ctx);
<span class="p_add">+	fput(data-&gt;fl.fl_file);</span>
 	kfree(data);
 	dprintk(&quot;%s: done!\n&quot;, __func__);
 }
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index db7792c30462..46d876487795 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1482,6 +1482,8 @@</span> <span class="p_context"> restart:</span>
 					spin_unlock(&amp;state-&gt;state_lock);
 				}
 				nfs4_put_open_state(state);
<span class="p_add">+				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+					&amp;state-&gt;flags);</span>
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
 			}
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index dea11c2c8c1e..77498f9ba554 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -1558,6 +1558,7 @@</span> <span class="p_context"> pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		desc-&gt;pg_recoalesce = 1;
 	}
 	nfs_pgio_data_destroy(hdr);
<span class="p_add">+	hdr-&gt;release(hdr);</span>
 }
 
 static enum pnfs_try_status
<span class="p_chunk">@@ -1695,6 +1696,7 @@</span> <span class="p_context"> pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		desc-&gt;pg_recoalesce = 1;
 	}
 	nfs_pgio_data_destroy(hdr);
<span class="p_add">+	hdr-&gt;release(hdr);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/proc/generic.c b/fs/proc/generic.c</span>
<span class="p_header">index 2e2d9d5d78d9..c18d9b05cea9 100644</span>
<span class="p_header">--- a/fs/proc/generic.c</span>
<span class="p_header">+++ b/fs/proc/generic.c</span>
<span class="p_chunk">@@ -334,6 +334,11 @@</span> <span class="p_context"> static struct proc_dir_entry *__proc_create(struct proc_dir_entry **parent,</span>
 
 	len = strlen(fn);
 
<span class="p_add">+	if (is_empty_pde(*parent)) {</span>
<span class="p_add">+		WARN(1, &quot;attempt to add to permanently empty directory&quot;);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ent = kzalloc(sizeof(struct proc_dir_entry) + len + 1, GFP_KERNEL);
 	if (!ent)
 		goto out;
<span class="p_chunk">@@ -409,6 +414,25 @@</span> <span class="p_context"> struct proc_dir_entry *proc_mkdir(const char *name,</span>
 }
 EXPORT_SYMBOL(proc_mkdir);
 
<span class="p_add">+struct proc_dir_entry *proc_create_mount_point(const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	umode_t mode = S_IFDIR | S_IRUGO | S_IXUGO;</span>
<span class="p_add">+	struct proc_dir_entry *ent, *parent = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ent = __proc_create(&amp;parent, name, mode, 2);</span>
<span class="p_add">+	if (ent) {</span>
<span class="p_add">+		ent-&gt;data = NULL;</span>
<span class="p_add">+		ent-&gt;proc_fops = NULL;</span>
<span class="p_add">+		ent-&gt;proc_iops = NULL;</span>
<span class="p_add">+		if (proc_register(parent, ent) &lt; 0) {</span>
<span class="p_add">+			kfree(ent);</span>
<span class="p_add">+			parent-&gt;nlink--;</span>
<span class="p_add">+			ent = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ent;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct proc_dir_entry *proc_create_data(const char *name, umode_t mode,
 					struct proc_dir_entry *parent,
 					const struct file_operations *proc_fops,
<span class="p_header">diff --git a/fs/proc/inode.c b/fs/proc/inode.c</span>
<span class="p_header">index 965b82e61570..6582583201ee 100644</span>
<span class="p_header">--- a/fs/proc/inode.c</span>
<span class="p_header">+++ b/fs/proc/inode.c</span>
<span class="p_chunk">@@ -431,6 +431,10 @@</span> <span class="p_context"> struct inode *proc_get_inode(struct super_block *sb, struct proc_dir_entry *de)</span>
 		inode-&gt;i_mtime = inode-&gt;i_atime = inode-&gt;i_ctime = CURRENT_TIME;
 		PROC_I(inode)-&gt;pde = de;
 
<span class="p_add">+		if (is_empty_pde(de)) {</span>
<span class="p_add">+			make_empty_dir_inode(inode);</span>
<span class="p_add">+			return inode;</span>
<span class="p_add">+		}</span>
 		if (de-&gt;mode) {
 			inode-&gt;i_mode = de-&gt;mode;
 			inode-&gt;i_uid = de-&gt;uid;
<span class="p_header">diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="p_header">index 8b24f3640cd9..e62c247b46cc 100644</span>
<span class="p_header">--- a/fs/proc/internal.h</span>
<span class="p_header">+++ b/fs/proc/internal.h</span>
<span class="p_chunk">@@ -193,6 +193,12 @@</span> <span class="p_context"> static inline struct proc_dir_entry *pde_get(struct proc_dir_entry *pde)</span>
 }
 extern void pde_put(struct proc_dir_entry *);
 
<span class="p_add">+static inline bool is_empty_pde(const struct proc_dir_entry *pde)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return S_ISDIR(pde-&gt;mode) &amp;&amp; !pde-&gt;proc_iops;</span>
<span class="p_add">+}</span>
<span class="p_add">+struct proc_dir_entry *proc_create_mount_point(const char *name);</span>
<span class="p_add">+</span>
 /*
  * inode.c
  */
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index 71290463a1d3..b45db1ddb8e0 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -19,6 +19,28 @@</span> <span class="p_context"> static const struct inode_operations proc_sys_inode_operations;</span>
 static const struct file_operations proc_sys_dir_file_operations;
 static const struct inode_operations proc_sys_dir_operations;
 
<span class="p_add">+/* Support for permanently empty directories */</span>
<span class="p_add">+</span>
<span class="p_add">+struct ctl_table sysctl_mount_point[] = {</span>
<span class="p_add">+	{ }</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static bool is_empty_dir(struct ctl_table_header *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return head-&gt;ctl_table[0].child == sysctl_mount_point;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void set_empty_dir(struct ctl_dir *dir)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dir-&gt;header.ctl_table[0].child = sysctl_mount_point;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void clear_empty_dir(struct ctl_dir *dir)</span>
<span class="p_add">+</span>
<span class="p_add">+{</span>
<span class="p_add">+	dir-&gt;header.ctl_table[0].child = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void proc_sys_poll_notify(struct ctl_table_poll *poll)
 {
 	if (!poll)
<span class="p_chunk">@@ -187,6 +209,17 @@</span> <span class="p_context"> static int insert_header(struct ctl_dir *dir, struct ctl_table_header *header)</span>
 	struct ctl_table *entry;
 	int err;
 
<span class="p_add">+	/* Is this a permanently empty directory? */</span>
<span class="p_add">+	if (is_empty_dir(&amp;dir-&gt;header))</span>
<span class="p_add">+		return -EROFS;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Am I creating a permanently empty directory? */</span>
<span class="p_add">+	if (header-&gt;ctl_table == sysctl_mount_point) {</span>
<span class="p_add">+		if (!RB_EMPTY_ROOT(&amp;dir-&gt;root))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		set_empty_dir(dir);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dir-&gt;header.nreg++;
 	header-&gt;parent = dir;
 	err = insert_links(header);
<span class="p_chunk">@@ -202,6 +235,8 @@</span> <span class="p_context"> fail:</span>
 	erase_header(header);
 	put_links(header);
 fail_links:
<span class="p_add">+	if (header-&gt;ctl_table == sysctl_mount_point)</span>
<span class="p_add">+		clear_empty_dir(dir);</span>
 	header-&gt;parent = NULL;
 	drop_sysctl_table(&amp;dir-&gt;header);
 	return err;
<span class="p_chunk">@@ -419,6 +454,8 @@</span> <span class="p_context"> static struct inode *proc_sys_make_inode(struct super_block *sb,</span>
 		inode-&gt;i_mode |= S_IFDIR;
 		inode-&gt;i_op = &amp;proc_sys_dir_operations;
 		inode-&gt;i_fop = &amp;proc_sys_dir_file_operations;
<span class="p_add">+		if (is_empty_dir(head))</span>
<span class="p_add">+			make_empty_dir_inode(inode);</span>
 	}
 out:
 	return inode;
<span class="p_header">diff --git a/fs/proc/root.c b/fs/proc/root.c</span>
<span class="p_header">index 5dbadecb234d..dd77e1483196 100644</span>
<span class="p_header">--- a/fs/proc/root.c</span>
<span class="p_header">+++ b/fs/proc/root.c</span>
<span class="p_chunk">@@ -112,9 +112,6 @@</span> <span class="p_context"> static struct dentry *proc_mount(struct file_system_type *fs_type,</span>
 		ns = task_active_pid_ns(current);
 		options = data;
 
<span class="p_del">-		if (!capable(CAP_SYS_ADMIN) &amp;&amp; !fs_fully_visible(fs_type))</span>
<span class="p_del">-			return ERR_PTR(-EPERM);</span>
<span class="p_del">-</span>
 		/* Does the mounter have privilege over the pid namespace? */
 		if (!ns_capable(ns-&gt;user_ns, CAP_SYS_ADMIN))
 			return ERR_PTR(-EPERM);
<span class="p_chunk">@@ -157,7 +154,7 @@</span> <span class="p_context"> static struct file_system_type proc_fs_type = {</span>
 	.name		= &quot;proc&quot;,
 	.mount		= proc_mount,
 	.kill_sb	= proc_kill_sb,
<span class="p_del">-	.fs_flags	= FS_USERNS_MOUNT,</span>
<span class="p_add">+	.fs_flags	= FS_USERNS_VISIBLE | FS_USERNS_MOUNT,</span>
 };
 
 void __init proc_root_init(void)
<span class="p_chunk">@@ -179,10 +176,10 @@</span> <span class="p_context"> void __init proc_root_init(void)</span>
 #endif
 	proc_mkdir(&quot;fs&quot;, NULL);
 	proc_mkdir(&quot;driver&quot;, NULL);
<span class="p_del">-	proc_mkdir(&quot;fs/nfsd&quot;, NULL); /* somewhere for the nfsd filesystem to be mounted */</span>
<span class="p_add">+	proc_create_mount_point(&quot;fs/nfsd&quot;); /* somewhere for the nfsd filesystem to be mounted */</span>
 #if defined(CONFIG_SUN_OPENPROMFS) || defined(CONFIG_SUN_OPENPROMFS_MODULE)
 	/* just give it a mountpoint */
<span class="p_del">-	proc_mkdir(&quot;openprom&quot;, NULL);</span>
<span class="p_add">+	proc_create_mount_point(&quot;openprom&quot;);</span>
 #endif
 	proc_tty_init();
 	proc_mkdir(&quot;bus&quot;, NULL);
<span class="p_header">diff --git a/fs/sysfs/dir.c b/fs/sysfs/dir.c</span>
<span class="p_header">index 0b45ff42f374..94374e435025 100644</span>
<span class="p_header">--- a/fs/sysfs/dir.c</span>
<span class="p_header">+++ b/fs/sysfs/dir.c</span>
<span class="p_chunk">@@ -121,3 +121,37 @@</span> <span class="p_context"> int sysfs_move_dir_ns(struct kobject *kobj, struct kobject *new_parent_kobj,</span>
 
 	return kernfs_rename_ns(kn, new_parent, kn-&gt;name, new_ns);
 }
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * sysfs_create_mount_point - create an always empty directory</span>
<span class="p_add">+ * @parent_kobj:  kobject that will contain this always empty directory</span>
<span class="p_add">+ * @name: The name of the always empty directory to add</span>
<span class="p_add">+ */</span>
<span class="p_add">+int sysfs_create_mount_point(struct kobject *parent_kobj, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kernfs_node *kn, *parent = parent_kobj-&gt;sd;</span>
<span class="p_add">+</span>
<span class="p_add">+	kn = kernfs_create_empty_dir(parent, name);</span>
<span class="p_add">+	if (IS_ERR(kn)) {</span>
<span class="p_add">+		if (PTR_ERR(kn) == -EEXIST)</span>
<span class="p_add">+			sysfs_warn_dup(parent, name);</span>
<span class="p_add">+		return PTR_ERR(kn);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sysfs_create_mount_point);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ *	sysfs_remove_mount_point - remove an always empty directory.</span>
<span class="p_add">+ *	@parent_kobj: kobject that will contain this always empty directory</span>
<span class="p_add">+ *	@name: The name of the always empty directory to remove</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+void sysfs_remove_mount_point(struct kobject *parent_kobj, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kernfs_node *parent = parent_kobj-&gt;sd;</span>
<span class="p_add">+</span>
<span class="p_add">+	kernfs_remove_by_name_ns(parent, name, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sysfs_remove_mount_point);</span>
<span class="p_header">diff --git a/fs/sysfs/mount.c b/fs/sysfs/mount.c</span>
<span class="p_header">index 8a49486bf30c..1c6ac6fcee9f 100644</span>
<span class="p_header">--- a/fs/sysfs/mount.c</span>
<span class="p_header">+++ b/fs/sysfs/mount.c</span>
<span class="p_chunk">@@ -31,9 +31,6 @@</span> <span class="p_context"> static struct dentry *sysfs_mount(struct file_system_type *fs_type,</span>
 	bool new_sb;
 
 	if (!(flags &amp; MS_KERNMOUNT)) {
<span class="p_del">-		if (!capable(CAP_SYS_ADMIN) &amp;&amp; !fs_fully_visible(fs_type))</span>
<span class="p_del">-			return ERR_PTR(-EPERM);</span>
<span class="p_del">-</span>
 		if (!kobj_ns_current_may_mount(KOBJ_NS_TYPE_NET))
 			return ERR_PTR(-EPERM);
 	}
<span class="p_chunk">@@ -58,7 +55,7 @@</span> <span class="p_context"> static struct file_system_type sysfs_fs_type = {</span>
 	.name		= &quot;sysfs&quot;,
 	.mount		= sysfs_mount,
 	.kill_sb	= sysfs_kill_sb,
<span class="p_del">-	.fs_flags	= FS_USERNS_MOUNT,</span>
<span class="p_add">+	.fs_flags	= FS_USERNS_VISIBLE | FS_USERNS_MOUNT,</span>
 };
 
 int __init sysfs_init(void)
<span class="p_header">diff --git a/fs/ufs/balloc.c b/fs/ufs/balloc.c</span>
<span class="p_header">index 7bc20809c99e..fe1b53d441e0 100644</span>
<span class="p_header">--- a/fs/ufs/balloc.c</span>
<span class="p_header">+++ b/fs/ufs/balloc.c</span>
<span class="p_chunk">@@ -51,8 +51,8 @@</span> <span class="p_context"> void ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)</span>
 	
 	if (ufs_fragnum(fragment) + count &gt; uspi-&gt;s_fpg)
 		ufs_error (sb, &quot;ufs_free_fragments&quot;, &quot;internal error&quot;);
<span class="p_del">-	</span>
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	
 	cgno = ufs_dtog(uspi, fragment);
 	bit = ufs_dtogd(uspi, fragment);
<span class="p_chunk">@@ -115,13 +115,13 @@</span> <span class="p_context"> void ufs_free_fragments(struct inode *inode, u64 fragment, unsigned count)</span>
 	if (sb-&gt;s_flags &amp; MS_SYNCHRONOUS)
 		ubh_sync_block(UCPI_UBH(ucpi));
 	ufs_mark_sb_dirty(sb);
<span class="p_del">-	</span>
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT\n&quot;);
 	return;
 
 failed:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT (FAILED)\n&quot;);
 	return;
 }
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> void ufs_free_blocks(struct inode *inode, u64 fragment, unsigned count)</span>
 		goto failed;
 	}
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	
 do_more:
 	overflow = 0;
<span class="p_chunk">@@ -211,12 +211,12 @@</span> <span class="p_context"> do_more:</span>
 	}
 
 	ufs_mark_sb_dirty(sb);
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT\n&quot;);
 	return;
 
 failed_unlock:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 failed:
 	UFSD(&quot;EXIT (FAILED)\n&quot;);
 	return;
<span class="p_chunk">@@ -357,7 +357,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 	usb1 = ubh_get_usb_first(uspi);
 	*err = -ENOSPC;
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	tmp = ufs_data_ptr_to_cpu(sb, p);
 
 	if (count + ufs_fragnum(fragment) &gt; uspi-&gt;s_fpb) {
<span class="p_chunk">@@ -378,19 +378,19 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 				  &quot;fragment %llu, tmp %llu\n&quot;,
 				  (unsigned long long)fragment,
 				  (unsigned long long)tmp);
<span class="p_del">-			unlock_ufs(sb);</span>
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			return INVBLOCK;
 		}
 		if (fragment &lt; UFS_I(inode)-&gt;i_lastfrag) {
 			UFSD(&quot;EXIT (ALREADY ALLOCATED)\n&quot;);
<span class="p_del">-			unlock_ufs(sb);</span>
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			return 0;
 		}
 	}
 	else {
 		if (tmp) {
 			UFSD(&quot;EXIT (ALREADY ALLOCATED)\n&quot;);
<span class="p_del">-			unlock_ufs(sb);</span>
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			return 0;
 		}
 	}
<span class="p_chunk">@@ -399,7 +399,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 	 * There is not enough space for user on the device
 	 */
 	if (!capable(CAP_SYS_RESOURCE) &amp;&amp; ufs_freespace(uspi, UFS_MINFREE) &lt;= 0) {
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		UFSD(&quot;EXIT (FAILED)\n&quot;);
 		return 0;
 	}
<span class="p_chunk">@@ -424,7 +424,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 			ufs_clear_frags(inode, result + oldcount,
 					newcount - oldcount, locked_page != NULL);
 		}
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		UFSD(&quot;EXIT, result %llu\n&quot;, (unsigned long long)result);
 		return result;
 	}
<span class="p_chunk">@@ -439,7 +439,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 						fragment + count);
 		ufs_clear_frags(inode, result + oldcount, newcount - oldcount,
 				locked_page != NULL);
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		UFSD(&quot;EXIT, result %llu\n&quot;, (unsigned long long)result);
 		return result;
 	}
<span class="p_chunk">@@ -477,7 +477,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 		*err = 0;
 		UFS_I(inode)-&gt;i_lastfrag = max(UFS_I(inode)-&gt;i_lastfrag,
 						fragment + count);
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		if (newcount &lt; request)
 			ufs_free_fragments (inode, result + newcount, request - newcount);
 		ufs_free_fragments (inode, tmp, oldcount);
<span class="p_chunk">@@ -485,7 +485,7 @@</span> <span class="p_context"> u64 ufs_new_fragments(struct inode *inode, void *p, u64 fragment,</span>
 		return result;
 	}
 
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT (FAILED)\n&quot;);
 	return 0;
 }		
<span class="p_header">diff --git a/fs/ufs/ialloc.c b/fs/ufs/ialloc.c</span>
<span class="p_header">index a9cc75ffa925..758ab7c305a4 100644</span>
<span class="p_header">--- a/fs/ufs/ialloc.c</span>
<span class="p_header">+++ b/fs/ufs/ialloc.c</span>
<span class="p_chunk">@@ -69,11 +69,11 @@</span> <span class="p_context"> void ufs_free_inode (struct inode * inode)</span>
 	
 	ino = inode-&gt;i_ino;
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 
 	if (!((ino &gt; 1) &amp;&amp; (ino &lt; (uspi-&gt;s_ncg * uspi-&gt;s_ipg )))) {
 		ufs_warning(sb, &quot;ufs_free_inode&quot;, &quot;reserved inode or nonexistent inode %u\n&quot;, ino);
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		return;
 	}
 	
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> void ufs_free_inode (struct inode * inode)</span>
 	bit = ufs_inotocgoff (ino);
 	ucpi = ufs_load_cylinder (sb, cg);
 	if (!ucpi) {
<span class="p_del">-		unlock_ufs(sb);</span>
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		return;
 	}
 	ucg = ubh_get_ucg(UCPI_UBH(ucpi));
<span class="p_chunk">@@ -115,7 +115,7 @@</span> <span class="p_context"> void ufs_free_inode (struct inode * inode)</span>
 		ubh_sync_block(UCPI_UBH(ucpi));
 	
 	ufs_mark_sb_dirty(sb);
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	UFSD(&quot;EXIT\n&quot;);
 }
 
<span class="p_chunk">@@ -193,7 +193,7 @@</span> <span class="p_context"> struct inode *ufs_new_inode(struct inode *dir, umode_t mode)</span>
 	sbi = UFS_SB(sb);
 	uspi = sbi-&gt;s_uspi;
 
<span class="p_del">-	lock_ufs(sb);</span>
<span class="p_add">+	mutex_lock(&amp;sbi-&gt;s_lock);</span>
 
 	/*
 	 * Try to place the inode in its parent directory
<span class="p_chunk">@@ -328,20 +328,20 @@</span> <span class="p_context"> cg_found:</span>
 			sync_dirty_buffer(bh);
 		brelse(bh);
 	}
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;sbi-&gt;s_lock);</span>
 
 	UFSD(&quot;allocating inode %lu\n&quot;, inode-&gt;i_ino);
 	UFSD(&quot;EXIT\n&quot;);
 	return inode;
 
 fail_remove_inode:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;sbi-&gt;s_lock);</span>
 	clear_nlink(inode);
 	iput(inode);
 	UFSD(&quot;EXIT (FAILED): err %d\n&quot;, err);
 	return ERR_PTR(err);
 failed:
<span class="p_del">-	unlock_ufs(sb);</span>
<span class="p_add">+	mutex_unlock(&amp;sbi-&gt;s_lock);</span>
 	make_bad_inode(inode);
 	iput (inode);
 	UFSD(&quot;EXIT (FAILED): err %d\n&quot;, err);
<span class="p_header">diff --git a/fs/ufs/inode.c b/fs/ufs/inode.c</span>
<span class="p_header">index 42234a871b22..40d6423429cb 100644</span>
<span class="p_header">--- a/fs/ufs/inode.c</span>
<span class="p_header">+++ b/fs/ufs/inode.c</span>
<span class="p_chunk">@@ -902,6 +902,9 @@</span> <span class="p_context"> void ufs_evict_inode(struct inode * inode)</span>
 	invalidate_inode_buffers(inode);
 	clear_inode(inode);
 
<span class="p_del">-	if (want_delete)</span>
<span class="p_add">+	if (want_delete) {</span>
<span class="p_add">+		lock_ufs(inode-&gt;i_sb);</span>
 		ufs_free_inode(inode);
<span class="p_add">+		unlock_ufs(inode-&gt;i_sb);</span>
<span class="p_add">+	}</span>
 }
<span class="p_header">diff --git a/fs/ufs/namei.c b/fs/ufs/namei.c</span>
<span class="p_header">index 2df62a73f20c..90d74b8f8eba 100644</span>
<span class="p_header">--- a/fs/ufs/namei.c</span>
<span class="p_header">+++ b/fs/ufs/namei.c</span>
<span class="p_chunk">@@ -126,12 +126,12 @@</span> <span class="p_context"> static int ufs_symlink (struct inode * dir, struct dentry * dentry,</span>
 	if (l &gt; sb-&gt;s_blocksize)
 		goto out_notlocked;
 
<span class="p_add">+	lock_ufs(dir-&gt;i_sb);</span>
 	inode = ufs_new_inode(dir, S_IFLNK | S_IRWXUGO);
 	err = PTR_ERR(inode);
 	if (IS_ERR(inode))
<span class="p_del">-		goto out_notlocked;</span>
<span class="p_add">+		goto out;</span>
 
<span class="p_del">-	lock_ufs(dir-&gt;i_sb);</span>
 	if (l &gt; UFS_SB(sb)-&gt;s_uspi-&gt;s_maxsymlinklen) {
 		/* slow symlink */
 		inode-&gt;i_op = &amp;ufs_symlink_inode_operations;
<span class="p_chunk">@@ -181,9 +181,13 @@</span> <span class="p_context"> static int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)</span>
 	struct inode * inode;
 	int err;
 
<span class="p_add">+	lock_ufs(dir-&gt;i_sb);</span>
<span class="p_add">+	inode_inc_link_count(dir);</span>
<span class="p_add">+</span>
 	inode = ufs_new_inode(dir, S_IFDIR|mode);
<span class="p_add">+	err = PTR_ERR(inode);</span>
 	if (IS_ERR(inode))
<span class="p_del">-		return PTR_ERR(inode);</span>
<span class="p_add">+		goto out_dir;</span>
 
 	inode-&gt;i_op = &amp;ufs_dir_inode_operations;
 	inode-&gt;i_fop = &amp;ufs_dir_operations;
<span class="p_chunk">@@ -191,9 +195,6 @@</span> <span class="p_context"> static int ufs_mkdir(struct inode * dir, struct dentry * dentry, umode_t mode)</span>
 
 	inode_inc_link_count(inode);
 
<span class="p_del">-	lock_ufs(dir-&gt;i_sb);</span>
<span class="p_del">-	inode_inc_link_count(dir);</span>
<span class="p_del">-</span>
 	err = ufs_make_empty(inode, dir);
 	if (err)
 		goto out_fail;
<span class="p_chunk">@@ -211,6 +212,7 @@</span> <span class="p_context"> out_fail:</span>
 	inode_dec_link_count(inode);
 	inode_dec_link_count(inode);
 	iput (inode);
<span class="p_add">+out_dir:</span>
 	inode_dec_link_count(dir);
 	unlock_ufs(dir-&gt;i_sb);
 	goto out;
<span class="p_header">diff --git a/fs/ufs/super.c b/fs/ufs/super.c</span>
<span class="p_header">index b879f1ba3439..f5fb525ae201 100644</span>
<span class="p_header">--- a/fs/ufs/super.c</span>
<span class="p_header">+++ b/fs/ufs/super.c</span>
<span class="p_chunk">@@ -697,6 +697,7 @@</span> <span class="p_context"> static int ufs_sync_fs(struct super_block *sb, int wait)</span>
 	unsigned flags;
 
 	lock_ufs(sb);
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 
 	UFSD(&quot;ENTER\n&quot;);
 
<span class="p_chunk">@@ -714,6 +715,7 @@</span> <span class="p_context"> static int ufs_sync_fs(struct super_block *sb, int wait)</span>
 	ufs_put_cstotal(sb);
 
 	UFSD(&quot;EXIT\n&quot;);
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	unlock_ufs(sb);
 
 	return 0;
<span class="p_chunk">@@ -803,6 +805,7 @@</span> <span class="p_context"> static int ufs_fill_super(struct super_block *sb, void *data, int silent)</span>
 	UFSD(&quot;flag %u\n&quot;, (int)(sb-&gt;s_flags &amp; MS_RDONLY));
 	
 	mutex_init(&amp;sbi-&gt;mutex);
<span class="p_add">+	mutex_init(&amp;sbi-&gt;s_lock);</span>
 	spin_lock_init(&amp;sbi-&gt;work_lock);
 	INIT_DELAYED_WORK(&amp;sbi-&gt;sync_work, delayed_sync_fs);
 	/*
<span class="p_chunk">@@ -1280,6 +1283,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 
 	sync_filesystem(sb);
 	lock_ufs(sb);
<span class="p_add">+	mutex_lock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	uspi = UFS_SB(sb)-&gt;s_uspi;
 	flags = UFS_SB(sb)-&gt;s_flags;
 	usb1 = ubh_get_usb_first(uspi);
<span class="p_chunk">@@ -1293,6 +1297,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 	new_mount_opt = 0;
 	ufs_set_opt (new_mount_opt, ONERROR_LOCK);
 	if (!ufs_parse_options (data, &amp;new_mount_opt)) {
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -1300,12 +1305,14 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 		new_mount_opt |= ufstype;
 	} else if ((new_mount_opt &amp; UFS_MOUNT_UFSTYPE) != ufstype) {
 		printk(&quot;ufstype can&#39;t be changed during remount\n&quot;);
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return -EINVAL;
 	}
 
 	if ((*mount_flags &amp; MS_RDONLY) == (sb-&gt;s_flags &amp; MS_RDONLY)) {
 		UFS_SB(sb)-&gt;s_mount_opt = new_mount_opt;
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return 0;
 	}
<span class="p_chunk">@@ -1330,6 +1337,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 #ifndef CONFIG_UFS_FS_WRITE
 		printk(&quot;ufs was compiled with read-only support, &quot;
 		&quot;can&#39;t be mounted as read-write\n&quot;);
<span class="p_add">+		mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 		unlock_ufs(sb);
 		return -EINVAL;
 #else
<span class="p_chunk">@@ -1339,11 +1347,13 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 		    ufstype != UFS_MOUNT_UFSTYPE_SUNx86 &amp;&amp;
 		    ufstype != UFS_MOUNT_UFSTYPE_UFS2) {
 			printk(&quot;this ufstype is read-only supported\n&quot;);
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			unlock_ufs(sb);
 			return -EINVAL;
 		}
 		if (!ufs_read_cylinder_structures(sb)) {
 			printk(&quot;failed during remounting\n&quot;);
<span class="p_add">+			mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 			unlock_ufs(sb);
 			return -EPERM;
 		}
<span class="p_chunk">@@ -1351,6 +1361,7 @@</span> <span class="p_context"> static int ufs_remount (struct super_block *sb, int *mount_flags, char *data)</span>
 #endif
 	}
 	UFS_SB(sb)-&gt;s_mount_opt = new_mount_opt;
<span class="p_add">+	mutex_unlock(&amp;UFS_SB(sb)-&gt;s_lock);</span>
 	unlock_ufs(sb);
 	return 0;
 }
<span class="p_header">diff --git a/fs/ufs/ufs.h b/fs/ufs/ufs.h</span>
<span class="p_header">index 343e6fc571e5..ff2c15ab81aa 100644</span>
<span class="p_header">--- a/fs/ufs/ufs.h</span>
<span class="p_header">+++ b/fs/ufs/ufs.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> struct ufs_sb_info {</span>
 	int work_queued; /* non-zero if the delayed work is queued */
 	struct delayed_work sync_work; /* FS sync delayed work */
 	spinlock_t work_lock; /* protects sync_work and work_queued */
<span class="p_add">+	struct mutex s_lock;</span>
 };
 
 struct ufs_inode_info {
<span class="p_header">diff --git a/fs/xfs/xfs_attr_inactive.c b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">index ced1dd9dd095..00f68393adf2 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_chunk">@@ -437,8 +437,14 @@</span> <span class="p_context"> xfs_attr_inactive(</span>
 	 */
 	xfs_trans_ijoin(trans, dp, 0);
 
<span class="p_del">-	/* invalidate and truncate the attribute fork extents */</span>
<span class="p_del">-	if (dp-&gt;i_d.di_aformat != XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Invalidate and truncate the attribute fork extents. Make sure the</span>
<span class="p_add">+	 * fork actually has attributes as otherwise the invalidation has no</span>
<span class="p_add">+	 * blocks to read and returns an error. In this case, just do the fork</span>
<span class="p_add">+	 * removal below.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xfs_inode_hasattr(dp) &amp;&amp;</span>
<span class="p_add">+	    dp-&gt;i_d.di_aformat != XFS_DINODE_FMT_LOCAL) {</span>
 		error = xfs_attr3_root_inactive(&amp;trans, dp);
 		if (error)
 			goto out_cancel;
<span class="p_header">diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c</span>
<span class="p_header">index d69363c833e1..484583ef8821 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_symlink.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_symlink.c</span>
<span class="p_chunk">@@ -107,7 +107,7 @@</span> <span class="p_context"> xfs_readlink_bmap(</span>
 			cur_chunk += sizeof(struct xfs_dsymlink_hdr);
 		}
 
<span class="p_del">-		memcpy(link + offset, bp-&gt;b_addr, byte_cnt);</span>
<span class="p_add">+		memcpy(link + offset, cur_chunk, byte_cnt);</span>
 
 		pathlen -= byte_cnt;
 		offset += byte_cnt;
<span class="p_header">diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h</span>
<span class="p_header">index 664a1a4b6f6a..d95681144545 100644</span>
<span class="p_header">--- a/include/acpi/acpixf.h</span>
<span class="p_header">+++ b/include/acpi/acpixf.h</span>
<span class="p_chunk">@@ -197,9 +197,18 @@</span> <span class="p_context"> ACPI_INIT_GLOBAL(u8, acpi_gbl_do_not_use_xsdt, FALSE);</span>
  * address. Although ACPICA adheres to the ACPI specification which
  * requires the use of the corresponding 64-bit address if it is non-zero,
  * some machines have been found to have a corrupted non-zero 64-bit
<span class="p_del">- * address. Default is TRUE, favor the 32-bit addresses.</span>
<span class="p_add">+ * address. Default is FALSE, do not favor the 32-bit addresses.</span>
  */
<span class="p_del">-ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_fadt_addresses, TRUE);</span>
<span class="p_add">+ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_fadt_addresses, FALSE);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Optionally use 32-bit FACS table addresses.</span>
<span class="p_add">+ * It is reported that some platforms fail to resume from system suspending</span>
<span class="p_add">+ * if 64-bit FACS table address is selected:</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=74021</span>
<span class="p_add">+ * Default is TRUE, favor the 32-bit addresses.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_facs_addresses, TRUE);</span>
 
 /*
  * Optionally truncate I/O addresses to 16 bits. Provides compatibility
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index f0a23d7fd302..00b6e76c8d4c 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -572,6 +572,7 @@</span> <span class="p_context"> typedef u64 acpi_integer;</span>
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
<span class="p_add">+#define ACPI_NO_FACS_INIT               0x80</span>
 
 /*
  * Initialization state
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index 358c01b971db..3b18cb3d5307 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -403,6 +403,7 @@</span> <span class="p_context"> extern acpi_status acpi_pci_osc_control_set(acpi_handle handle,</span>
 #define ACPI_OST_SC_INSERT_NOT_SUPPORTED	0x82
 
 extern void acpi_early_init(void);
<span class="p_add">+extern void acpi_subsystem_init(void);</span>
 
 extern int acpi_nvs_register(__u64 start, __u64 size);
 
<span class="p_chunk">@@ -437,6 +438,7 @@</span> <span class="p_context"> static inline const char *acpi_dev_name(struct acpi_device *adev)</span>
 }
 
 static inline void acpi_early_init(void) { }
<span class="p_add">+static inline void acpi_subsystem_init(void) { }</span>
 
 static inline int early_acpi_boot_init(void)
 {
<span class="p_header">diff --git a/include/linux/dcache.h b/include/linux/dcache.h</span>
<span class="p_header">index 6cddc8708a95..3597f13088a8 100644</span>
<span class="p_header">--- a/include/linux/dcache.h</span>
<span class="p_header">+++ b/include/linux/dcache.h</span>
<span class="p_chunk">@@ -473,4 +473,61 @@</span> <span class="p_context"> static inline unsigned long vfs_pressure_ratio(unsigned long val)</span>
 {
 	return mult_frac(val, sysctl_vfs_cache_pressure, 100);
 }
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_inode - Get the actual inode of this dentry</span>
<span class="p_add">+ * @dentry: The dentry to query</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper normal filesystems should use to get at their own inodes</span>
<span class="p_add">+ * in their own dentries and ignore the layering superimposed upon them.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct inode *d_inode(const struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dentry-&gt;d_inode;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_inode_rcu - Get the actual inode of this dentry with ACCESS_ONCE()</span>
<span class="p_add">+ * @dentry: The dentry to query</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper normal filesystems should use to get at their own inodes</span>
<span class="p_add">+ * in their own dentries and ignore the layering superimposed upon them.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct inode *d_inode_rcu(const struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ACCESS_ONCE(dentry-&gt;d_inode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_backing_inode - Get upper or lower inode we should be using</span>
<span class="p_add">+ * @upper: The upper layer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper that should be used to get at the inode that will be used</span>
<span class="p_add">+ * if this dentry were to be opened as a file.  The inode may be on the upper</span>
<span class="p_add">+ * dentry or it may be on a lower dentry pinned by the upper.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Normal filesystems should not use this to access their own inodes.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct inode *d_backing_inode(const struct dentry *upper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inode *inode = upper-&gt;d_inode;</span>
<span class="p_add">+</span>
<span class="p_add">+	return inode;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * d_backing_dentry - Get upper or lower dentry we should be using</span>
<span class="p_add">+ * @upper: The upper layer</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is the helper that should be used to get the dentry of the inode that</span>
<span class="p_add">+ * will be used if this dentry were opened as a file.  It may be the upper</span>
<span class="p_add">+ * dentry or it may be a lower dentry pinned by the upper.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Normal filesystems should not use this to access their own dentries.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline struct dentry *d_backing_dentry(struct dentry *upper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return upper;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif	/* __LINUX_DCACHE_H */
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index e11d60cc867b..9bd6f37d885a 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -1755,6 +1755,7 @@</span> <span class="p_context"> struct file_system_type {</span>
 #define FS_HAS_SUBTYPE		4
 #define FS_USERNS_MOUNT		8	/* Can be mounted by userns root */
 #define FS_USERNS_DEV_MOUNT	16 /* A userns mount does not imply MNT_NODEV */
<span class="p_add">+#define FS_USERNS_VISIBLE	32	/* FS must already be visible */</span>
 #define FS_RENAME_DOES_D_MOVE	32768	/* FS will handle d_move() during rename() internally. */
 	struct dentry *(*mount) (struct file_system_type *, int,
 		       const char *, void *);
<span class="p_chunk">@@ -1841,7 +1842,6 @@</span> <span class="p_context"> extern int vfs_ustat(dev_t, struct kstatfs *);</span>
 extern int freeze_super(struct super_block *super);
 extern int thaw_super(struct super_block *super);
 extern bool our_mnt(struct vfsmount *mnt);
<span class="p_del">-extern bool fs_fully_visible(struct file_system_type *);</span>
 
 extern int current_umask(void);
 
<span class="p_chunk">@@ -2590,6 +2590,8 @@</span> <span class="p_context"> extern struct dentry *simple_lookup(struct inode *, struct dentry *, unsigned in</span>
 extern ssize_t generic_read_dir(struct file *, char __user *, size_t, loff_t *);
 extern const struct file_operations simple_dir_operations;
 extern const struct inode_operations simple_dir_inode_operations;
<span class="p_add">+extern void make_empty_dir_inode(struct inode *inode);</span>
<span class="p_add">+extern bool is_empty_dir_inode(struct inode *inode);</span>
 struct tree_descr { char *name; const struct file_operations *ops; int mode; };
 struct dentry *d_alloc_name(struct dentry *, const char *);
 extern int simple_fill_super(struct super_block *, unsigned long, struct tree_descr *);
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index 0dae71e9971c..e1fb0f613a99 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -1035,7 +1035,7 @@</span> <span class="p_context"> struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal);</span>
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
 int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
 			      unsigned long *block);
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 
 /* Commit management */
<span class="p_chunk">@@ -1157,7 +1157,7 @@</span> <span class="p_context"> extern int	   jbd2_journal_recover    (journal_t *journal);</span>
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
 extern void	   jbd2_journal_update_sb_errno(journal_t *);
<span class="p_del">-extern void	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
<span class="p_add">+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
 				unsigned long, int);
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
<span class="p_header">diff --git a/include/linux/kernfs.h b/include/linux/kernfs.h</span>
<span class="p_header">index 30faf797c2c3..6658ff53203e 100644</span>
<span class="p_header">--- a/include/linux/kernfs.h</span>
<span class="p_header">+++ b/include/linux/kernfs.h</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> enum kernfs_node_flag {</span>
 	KERNFS_STATIC_NAME	= 0x0200,
 	KERNFS_SUICIDAL		= 0x0400,
 	KERNFS_SUICIDED		= 0x0800,
<span class="p_add">+	KERNFS_EMPTY_DIR	= 0x1000,</span>
 };
 
 /* @flags for kernfs_create_root() */
<span class="p_chunk">@@ -278,6 +279,8 @@</span> <span class="p_context"> void kernfs_destroy_root(struct kernfs_root *root);</span>
 struct kernfs_node *kernfs_create_dir_ns(struct kernfs_node *parent,
 					 const char *name, umode_t mode,
 					 void *priv, const void *ns);
<span class="p_add">+struct kernfs_node *kernfs_create_empty_dir(struct kernfs_node *parent,</span>
<span class="p_add">+					    const char *name);</span>
 struct kernfs_node *__kernfs_create_file(struct kernfs_node *parent,
 					 const char *name,
 					 umode_t mode, loff_t size,
<span class="p_header">diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h</span>
<span class="p_header">index 6f2ca8976069..162a86b2c072 100644</span>
<span class="p_header">--- a/include/linux/nfs_xdr.h</span>
<span class="p_header">+++ b/include/linux/nfs_xdr.h</span>
<span class="p_chunk">@@ -1139,7 +1139,7 @@</span> <span class="p_context"> struct nfs41_state_protection {</span>
 	struct nfs4_op_map allow;
 };
 
<span class="p_del">-#define NFS4_EXCHANGE_ID_LEN	(48)</span>
<span class="p_add">+#define NFS4_EXCHANGE_ID_LEN	(127)</span>
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
<span class="p_header">diff --git a/include/linux/of.h b/include/linux/of.h</span>
<span class="p_header">index db2f8ac18dad..55452d38ae06 100644</span>
<span class="p_header">--- a/include/linux/of.h</span>
<span class="p_header">+++ b/include/linux/of.h</span>
<span class="p_chunk">@@ -580,7 +580,10 @@</span> <span class="p_context"> static inline const char *of_prop_next_string(struct property *prop,</span>
 #if defined(CONFIG_OF) &amp;&amp; defined(CONFIG_NUMA)
 extern int of_node_to_nid(struct device_node *np);
 #else
<span class="p_del">-static inline int of_node_to_nid(struct device_node *device) { return 0; }</span>
<span class="p_add">+static inline int of_node_to_nid(struct device_node *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
<span class="p_add">+}</span>
 #endif
 
 static inline struct device_node *of_find_matching_node(
<span class="p_header">diff --git a/include/linux/sysctl.h b/include/linux/sysctl.h</span>
<span class="p_header">index 14a8ff2de11e..07e597b8802f 100644</span>
<span class="p_header">--- a/include/linux/sysctl.h</span>
<span class="p_header">+++ b/include/linux/sysctl.h</span>
<span class="p_chunk">@@ -190,6 +190,9 @@</span> <span class="p_context"> struct ctl_table_header *register_sysctl_paths(const struct ctl_path *path,</span>
 void unregister_sysctl_table(struct ctl_table_header * table);
 
 extern int sysctl_init(void);
<span class="p_add">+</span>
<span class="p_add">+extern struct ctl_table sysctl_mount_point[];</span>
<span class="p_add">+</span>
 #else /* CONFIG_SYSCTL */
 static inline struct ctl_table_header *register_sysctl_table(struct ctl_table * table)
 {
<span class="p_header">diff --git a/include/linux/sysfs.h b/include/linux/sysfs.h</span>
<span class="p_header">index f97d0dbb59fa..8ce4e648efc1 100644</span>
<span class="p_header">--- a/include/linux/sysfs.h</span>
<span class="p_header">+++ b/include/linux/sysfs.h</span>
<span class="p_chunk">@@ -186,6 +186,10 @@</span> <span class="p_context"> int __must_check sysfs_rename_dir_ns(struct kobject *kobj, const char *new_name,</span>
 int __must_check sysfs_move_dir_ns(struct kobject *kobj,
 				   struct kobject *new_parent_kobj,
 				   const void *new_ns);
<span class="p_add">+int __must_check sysfs_create_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+					  const char *name);</span>
<span class="p_add">+void sysfs_remove_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+			      const char *name);</span>
 
 int __must_check sysfs_create_file_ns(struct kobject *kobj,
 				      const struct attribute *attr,
<span class="p_chunk">@@ -274,6 +278,17 @@</span> <span class="p_context"> static inline int sysfs_move_dir_ns(struct kobject *kobj,</span>
 	return 0;
 }
 
<span class="p_add">+static inline int sysfs_create_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+					   const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void sysfs_remove_mount_point(struct kobject *parent_kobj,</span>
<span class="p_add">+					    const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int sysfs_create_file_ns(struct kobject *kobj,
 				       const struct attribute *attr,
 				       const void *ns)
<span class="p_header">diff --git a/include/net/netfilter/nf_queue.h b/include/net/netfilter/nf_queue.h</span>
<span class="p_header">index 84a53d780306..1a91f979160e 100644</span>
<span class="p_header">--- a/include/net/netfilter/nf_queue.h</span>
<span class="p_header">+++ b/include/net/netfilter/nf_queue.h</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"> struct nf_queue_entry {</span>
 struct nf_queue_handler {
 	int			(*outfn)(struct nf_queue_entry *entry,
 					 unsigned int queuenum);
<span class="p_add">+	void			(*nf_hook_drop)(struct net *net,</span>
<span class="p_add">+						struct nf_hook_ops *ops);</span>
 };
 
 void nf_register_queue_handler(const struct nf_queue_handler *qh);
<span class="p_header">diff --git a/include/net/netns/sctp.h b/include/net/netns/sctp.h</span>
<span class="p_header">index 3573a81815ad..8ba379f9e467 100644</span>
<span class="p_header">--- a/include/net/netns/sctp.h</span>
<span class="p_header">+++ b/include/net/netns/sctp.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> struct netns_sctp {</span>
 	struct list_head addr_waitq;
 	struct timer_list addr_wq_timer;
 	struct list_head auto_asconf_splist;
<span class="p_add">+	/* Lock that protects both addr_waitq and auto_asconf_splist */</span>
 	spinlock_t addr_wq_lock;
 
 	/* Lock that protects the local_addr_list writers */
<span class="p_header">diff --git a/include/net/sctp/structs.h b/include/net/sctp/structs.h</span>
<span class="p_header">index f38588bf3462..2ba9fe6f9812 100644</span>
<span class="p_header">--- a/include/net/sctp/structs.h</span>
<span class="p_header">+++ b/include/net/sctp/structs.h</span>
<span class="p_chunk">@@ -219,6 +219,10 @@</span> <span class="p_context"> struct sctp_sock {</span>
 	atomic_t pd_mode;
 	/* Receive to here while partial delivery is in effect. */
 	struct sk_buff_head pd_lobby;
<span class="p_add">+</span>
<span class="p_add">+	/* These must be the last fields, as they will skipped on copies,</span>
<span class="p_add">+	 * like on accept and peeloff operations</span>
<span class="p_add">+	 */</span>
 	struct list_head auto_asconf_list;
 	int do_auto_asconf;
 };
<span class="p_header">diff --git a/init/main.c b/init/main.c</span>
<span class="p_header">index ed5f48edc7a8..44af5b583cf4 100644</span>
<span class="p_header">--- a/init/main.c</span>
<span class="p_header">+++ b/init/main.c</span>
<span class="p_chunk">@@ -666,6 +666,7 @@</span> <span class="p_context"> asmlinkage __visible void __init start_kernel(void)</span>
 
 	check_bugs();
 
<span class="p_add">+	acpi_subsystem_init();</span>
 	sfi_init_late();
 
 	if (efi_enabled(EFI_RUNTIME_SERVICES)) {
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 92320781b140..40338799dcb0 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3944,20 +3944,20 @@</span> <span class="p_context"> static void ring_buffer_attach(struct perf_event *event,</span>
 		WARN_ON_ONCE(event-&gt;rcu_pending);
 
 		old_rb = event-&gt;rb;
<span class="p_del">-		event-&gt;rcu_batches = get_state_synchronize_rcu();</span>
<span class="p_del">-		event-&gt;rcu_pending = 1;</span>
<span class="p_del">-</span>
 		spin_lock_irqsave(&amp;old_rb-&gt;event_lock, flags);
 		list_del_rcu(&amp;event-&gt;rb_entry);
 		spin_unlock_irqrestore(&amp;old_rb-&gt;event_lock, flags);
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (event-&gt;rcu_pending &amp;&amp; rb) {</span>
<span class="p_del">-		cond_synchronize_rcu(event-&gt;rcu_batches);</span>
<span class="p_del">-		event-&gt;rcu_pending = 0;</span>
<span class="p_add">+		event-&gt;rcu_batches = get_state_synchronize_rcu();</span>
<span class="p_add">+		event-&gt;rcu_pending = 1;</span>
 	}
 
 	if (rb) {
<span class="p_add">+		if (event-&gt;rcu_pending) {</span>
<span class="p_add">+			cond_synchronize_rcu(event-&gt;rcu_batches);</span>
<span class="p_add">+			event-&gt;rcu_pending = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		spin_lock_irqsave(&amp;rb-&gt;event_lock, flags);
 		list_add_rcu(&amp;event-&gt;rb_entry, &amp;rb-&gt;event_list);
 		spin_unlock_irqrestore(&amp;rb-&gt;event_lock, flags);
<span class="p_header">diff --git a/kernel/irq/devres.c b/kernel/irq/devres.c</span>
<span class="p_header">index 1ef0606797c9..0296d6fd7d4e 100644</span>
<span class="p_header">--- a/kernel/irq/devres.c</span>
<span class="p_header">+++ b/kernel/irq/devres.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> int devm_request_any_context_irq(struct device *dev, unsigned int irq,</span>
 		return -ENOMEM;
 
 	rc = request_any_context_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_del">-	if (rc) {</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
 		devres_free(dr);
 		return rc;
 	}
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> int devm_request_any_context_irq(struct device *dev, unsigned int irq,</span>
 	dr-&gt;dev_id = dev_id;
 	devres_add(dev, dr);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return rc;</span>
 }
 EXPORT_SYMBOL(devm_request_any_context_irq);
 
<span class="p_header">diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig</span>
<span class="p_header">index 9a83d780facd..ff6150d05e82 100644</span>
<span class="p_header">--- a/kernel/power/Kconfig</span>
<span class="p_header">+++ b/kernel/power/Kconfig</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> config DPM_WATCHDOG</span>
 config DPM_WATCHDOG_TIMEOUT
 	int &quot;Watchdog timeout in seconds&quot;
 	range 1 120
<span class="p_del">-	default 12</span>
<span class="p_add">+	default 60</span>
 	depends on DPM_WATCHDOG
 
 config PM_TRACE
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index cce20d2f38d5..f7f6f7e5ff8a 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -478,11 +478,11 @@</span> <span class="p_context"> static int check_syslog_permissions(int type, bool from_file)</span>
 	 * already done the capabilities checks at open time.
 	 */
 	if (from_file &amp;&amp; type != SYSLOG_ACTION_OPEN)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto ok;</span>
 
 	if (syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		/*
 		 * For historical reasons, accept CAP_SYS_ADMIN too, with
 		 * a warning.
<span class="p_chunk">@@ -492,10 +492,11 @@</span> <span class="p_context"> static int check_syslog_permissions(int type, bool from_file)</span>
 				     &quot;CAP_SYS_ADMIN but no CAP_SYSLOG &quot;
 				     &quot;(deprecated).\n&quot;,
 				 current-&gt;comm, task_pid_nr(current));
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		}
 		return -EPERM;
 	}
<span class="p_add">+ok:</span>
 	return security_syslog(type);
 }
 
<span class="p_chunk">@@ -1221,10 +1222,6 @@</span> <span class="p_context"> int do_syslog(int type, char __user *buf, int len, bool from_file)</span>
 	if (error)
 		goto out;
 
<span class="p_del">-	error = security_syslog(type);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	switch (type) {
 	case SYSLOG_ACTION_CLOSE:	/* Close log */
 		break;
<span class="p_header">diff --git a/kernel/rcu/tiny.c b/kernel/rcu/tiny.c</span>
<span class="p_header">index d9efcc13008c..90fdef66aa4a 100644</span>
<span class="p_header">--- a/kernel/rcu/tiny.c</span>
<span class="p_header">+++ b/kernel/rcu/tiny.c</span>
<span class="p_chunk">@@ -280,6 +280,11 @@</span> <span class="p_context"> static void __rcu_process_callbacks(struct rcu_ctrlblk *rcp)</span>
 
 	/* Move the ready-to-invoke callbacks to a local list. */
 	local_irq_save(flags);
<span class="p_add">+	if (rcp-&gt;donetail == &amp;rcp-&gt;rcucblist) {</span>
<span class="p_add">+		/* No callbacks ready, so just leave. */</span>
<span class="p_add">+		local_irq_restore(flags);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 	RCU_TRACE(trace_rcu_batch_start(rcp-&gt;name, 0, rcp-&gt;qlen, -1));
 	list = rcp-&gt;rcucblist;
 	rcp-&gt;rcucblist = *rcp-&gt;donetail;
<span class="p_header">diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c</span>
<span class="p_header">index fea7d3335e1f..123078569a96 100644</span>
<span class="p_header">--- a/kernel/sched/fair.c</span>
<span class="p_header">+++ b/kernel/sched/fair.c</span>
<span class="p_chunk">@@ -4773,18 +4773,21 @@</span> <span class="p_context"> again:</span>
 		 * entity, update_curr() will update its vruntime, otherwise
 		 * forget we&#39;ve ever seen it.
 		 */
<span class="p_del">-		if (curr &amp;&amp; curr-&gt;on_rq)</span>
<span class="p_del">-			update_curr(cfs_rq);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			curr = NULL;</span>
<span class="p_add">+		if (curr) {</span>
<span class="p_add">+			if (curr-&gt;on_rq)</span>
<span class="p_add">+				update_curr(cfs_rq);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				curr = NULL;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * This call to check_cfs_rq_runtime() will do the throttle and</span>
<span class="p_del">-		 * dequeue its entity in the parent(s). Therefore the &#39;simple&#39;</span>
<span class="p_del">-		 * nr_running test will indeed be correct.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (unlikely(check_cfs_rq_runtime(cfs_rq)))</span>
<span class="p_del">-			goto simple;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This call to check_cfs_rq_runtime() will do the</span>
<span class="p_add">+			 * throttle and dequeue its entity in the parent(s).</span>
<span class="p_add">+			 * Therefore the &#39;simple&#39; nr_running test will indeed</span>
<span class="p_add">+			 * be correct.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (unlikely(check_cfs_rq_runtime(cfs_rq)))</span>
<span class="p_add">+				goto simple;</span>
<span class="p_add">+		}</span>
 
 		se = pick_next_entity(cfs_rq, curr);
 		cfs_rq = group_cfs_rq(se);
<span class="p_header">diff --git a/kernel/sysctl.c b/kernel/sysctl.c</span>
<span class="p_header">index 75b22e22a72c..344788eba906 100644</span>
<span class="p_header">--- a/kernel/sysctl.c</span>
<span class="p_header">+++ b/kernel/sysctl.c</span>
<span class="p_chunk">@@ -1507,12 +1507,6 @@</span> <span class="p_context"> static struct ctl_table vm_table[] = {</span>
 	{ }
 };
 
<span class="p_del">-#if defined(CONFIG_BINFMT_MISC) || defined(CONFIG_BINFMT_MISC_MODULE)</span>
<span class="p_del">-static struct ctl_table binfmt_misc_table[] = {</span>
<span class="p_del">-	{ }</span>
<span class="p_del">-};</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static struct ctl_table fs_table[] = {
 	{
 		.procname	= &quot;inode-nr&quot;,
<span class="p_chunk">@@ -1666,7 +1660,7 @@</span> <span class="p_context"> static struct ctl_table fs_table[] = {</span>
 	{
 		.procname	= &quot;binfmt_misc&quot;,
 		.mode		= 0555,
<span class="p_del">-		.child		= binfmt_misc_table,</span>
<span class="p_add">+		.child		= sysctl_mount_point,</span>
 	},
 #endif
 	{
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index cb347e85f75e..7b244d004d68 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1086,6 +1086,9 @@</span> <span class="p_context"> static void parse_init(struct filter_parse_state *ps,</span>
 
 static char infix_next(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 
 	return ps-&gt;infix.string[ps-&gt;infix.tail++];
<span class="p_chunk">@@ -1101,6 +1104,9 @@</span> <span class="p_context"> static char infix_peek(struct filter_parse_state *ps)</span>
 
 static void infix_advance(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 	ps-&gt;infix.tail++;
 }
<span class="p_chunk">@@ -1413,7 +1419,9 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 			continue;
 		}
 		n_normal_preds++;
<span class="p_del">-		WARN_ON_ONCE(cnt &lt; 0);</span>
<span class="p_add">+		/* all ops should have operands */</span>
<span class="p_add">+		if (cnt &lt; 0)</span>
<span class="p_add">+			break;</span>
 	}
 
 	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {
<span class="p_header">diff --git a/lib/bitmap.c b/lib/bitmap.c</span>
<span class="p_header">index e5c4ebe586ba..c0634aa923a6 100644</span>
<span class="p_header">--- a/lib/bitmap.c</span>
<span class="p_header">+++ b/lib/bitmap.c</span>
<span class="p_chunk">@@ -603,12 +603,12 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
<span class="p_del">-	int exp_digit, in_range;</span>
<span class="p_add">+	int at_start, in_range;</span>
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
<span class="p_del">-		exp_digit = 1;</span>
<span class="p_add">+		at_start = 1;</span>
 		in_range = 0;
 		a = b = 0;
 
<span class="p_chunk">@@ -637,11 +637,10 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 				break;
 
 			if (c == &#39;-&#39;) {
<span class="p_del">-				if (exp_digit || in_range)</span>
<span class="p_add">+				if (at_start || in_range)</span>
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
<span class="p_del">-				exp_digit = 1;</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -651,16 +650,18 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 			b = b * 10 + (c - &#39;0&#39;);
 			if (!in_range)
 				a = b;
<span class="p_del">-			exp_digit = 0;</span>
<span class="p_add">+			at_start = 0;</span>
 			totaldigits++;
 		}
 		if (!(a &lt;= b))
 			return -EINVAL;
 		if (b &gt;= nmaskbits)
 			return -ERANGE;
<span class="p_del">-		while (a &lt;= b) {</span>
<span class="p_del">-			set_bit(a, maskp);</span>
<span class="p_del">-			a++;</span>
<span class="p_add">+		if (!at_start) {</span>
<span class="p_add">+			while (a &lt;= b) {</span>
<span class="p_add">+				set_bit(a, maskp);</span>
<span class="p_add">+				a++;</span>
<span class="p_add">+			}</span>
 		}
 	} while (buflen &amp;&amp; c == &#39;,&#39;);
 	return 0;
<span class="p_header">diff --git a/lib/lz4/lz4_decompress.c b/lib/lz4/lz4_decompress.c</span>
<span class="p_header">index 7a85967060a5..8a742b195c69 100644</span>
<span class="p_header">--- a/lib/lz4/lz4_decompress.c</span>
<span class="p_header">+++ b/lib/lz4/lz4_decompress.c</span>
<span class="p_chunk">@@ -139,6 +139,13 @@</span> <span class="p_context"> static int lz4_uncompress(const char *source, char *dest, int osize)</span>
 			/* Error: request to write beyond destination buffer */
 			if (cpy &gt; oend)
 				goto _output_error;
<span class="p_add">+#if LZ4_ARCH64</span>
<span class="p_add">+			if ((ref + COPYLENGTH) &gt; oend)</span>
<span class="p_add">+#else</span>
<span class="p_add">+			if ((ref + COPYLENGTH) &gt; oend ||</span>
<span class="p_add">+					(op + COPYLENGTH) &gt; oend)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+				goto _output_error;</span>
 			LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));
 			while (op &lt; cpy)
 				*op++ = *ref++;
<span class="p_chunk">@@ -267,7 +274,13 @@</span> <span class="p_context"> static int lz4_uncompress_unknownoutputsize(const char *source, char *dest,</span>
 		if (cpy &gt; oend - COPYLENGTH) {
 			if (cpy &gt; oend)
 				goto _output_error; /* write outside of buf */
<span class="p_del">-</span>
<span class="p_add">+#if LZ4_ARCH64</span>
<span class="p_add">+			if ((ref + COPYLENGTH) &gt; oend)</span>
<span class="p_add">+#else</span>
<span class="p_add">+			if ((ref + COPYLENGTH) &gt; oend ||</span>
<span class="p_add">+					(op + COPYLENGTH) &gt; oend)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+				goto _output_error;</span>
 			LZ4_SECURECOPY(ref, op, (oend - COPYLENGTH));
 			while (op &lt; cpy)
 				*op++ = *ref++;
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 5f217e906ff9..94add6da0fad 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -41,6 +41,11 @@</span> <span class="p_context"> unsigned long hugepages_treat_as_movable;</span>
 int hugetlb_max_hstate __read_mostly;
 unsigned int default_hstate_idx;
 struct hstate hstates[HUGE_MAX_HSTATE];
<span class="p_add">+/*</span>
<span class="p_add">+ * Minimum page order among possible hugepage sizes, set to a proper value</span>
<span class="p_add">+ * at boot time.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int minimum_order __read_mostly = UINT_MAX;</span>
 
 __initdata LIST_HEAD(huge_boot_pages);
 
<span class="p_chunk">@@ -1085,19 +1090,13 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
  */
 void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_del">-	unsigned int order = 8 * sizeof(void *);</span>
 	unsigned long pfn;
<span class="p_del">-	struct hstate *h;</span>
 
 	if (!hugepages_supported())
 		return;
 
<span class="p_del">-	/* Set scan step to minimum hugepage size */</span>
<span class="p_del">-	for_each_hstate(h)</span>
<span class="p_del">-		if (order &gt; huge_page_order(h))</span>
<span class="p_del">-			order = huge_page_order(h);</span>
<span class="p_del">-	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; order));</span>
<span class="p_del">-	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; order)</span>
<span class="p_add">+	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; minimum_order));</span>
<span class="p_add">+	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)</span>
 		dissolve_free_huge_page(pfn_to_page(pfn));
 }
 
<span class="p_chunk">@@ -1524,10 +1523,14 @@</span> <span class="p_context"> static void __init hugetlb_init_hstates(void)</span>
 	struct hstate *h;
 
 	for_each_hstate(h) {
<span class="p_add">+		if (minimum_order &gt; huge_page_order(h))</span>
<span class="p_add">+			minimum_order = huge_page_order(h);</span>
<span class="p_add">+</span>
 		/* oversize hugepages were init&#39;ed in early boot */
 		if (!hstate_is_gigantic(h))
 			hugetlb_hstate_alloc_pages(h);
 	}
<span class="p_add">+	VM_BUG_ON(minimum_order == UINT_MAX);</span>
 }
 
 static char * __init memfmt(char *buf, unsigned long n)
<span class="p_header">diff --git a/mm/kmemleak.c b/mm/kmemleak.c</span>
<span class="p_header">index 3cda50c1e394..6691476a66fc 100644</span>
<span class="p_header">--- a/mm/kmemleak.c</span>
<span class="p_header">+++ b/mm/kmemleak.c</span>
<span class="p_chunk">@@ -193,6 +193,8 @@</span> <span class="p_context"> static struct kmem_cache *scan_area_cache;</span>
 
 /* set if tracing memory operations is enabled */
 static int kmemleak_enabled;
<span class="p_add">+/* same as above but only for the kmemleak_free() callback */</span>
<span class="p_add">+static int kmemleak_free_enabled;</span>
 /* set in the late_initcall if there were no errors */
 static int kmemleak_initialized;
 /* enables or disables early logging of the memory operations */
<span class="p_chunk">@@ -940,7 +942,7 @@</span> <span class="p_context"> void __ref kmemleak_free(const void *ptr)</span>
 {
 	pr_debug(&quot;%s(0x%p)\n&quot;, __func__, ptr);
 
<span class="p_del">-	if (kmemleak_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
<span class="p_add">+	if (kmemleak_free_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
 		delete_object_full((unsigned long)ptr);
 	else if (kmemleak_early_log)
 		log_early(KMEMLEAK_FREE, ptr, 0, 0);
<span class="p_chunk">@@ -980,7 +982,7 @@</span> <span class="p_context"> void __ref kmemleak_free_percpu(const void __percpu *ptr)</span>
 
 	pr_debug(&quot;%s(0x%p)\n&quot;, __func__, ptr);
 
<span class="p_del">-	if (kmemleak_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
<span class="p_add">+	if (kmemleak_free_enabled &amp;&amp; ptr &amp;&amp; !IS_ERR(ptr))</span>
 		for_each_possible_cpu(cpu)
 			delete_object_full((unsigned long)per_cpu_ptr(ptr,
 								      cpu));
<span class="p_chunk">@@ -1743,6 +1745,13 @@</span> <span class="p_context"> static void kmemleak_do_cleanup(struct work_struct *work)</span>
 	mutex_lock(&amp;scan_mutex);
 	stop_scan_thread();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once the scan thread has stopped, it is safe to no longer track</span>
<span class="p_add">+	 * object freeing. Ordering of the scan thread stopping and the memory</span>
<span class="p_add">+	 * accesses below is guaranteed by the kthread_stop() function.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kmemleak_free_enabled = 0;</span>
<span class="p_add">+</span>
 	if (!kmemleak_found_leaks)
 		__kmemleak_do_cleanup();
 	else
<span class="p_chunk">@@ -1769,6 +1778,8 @@</span> <span class="p_context"> static void kmemleak_disable(void)</span>
 	/* check whether it is too early for a kernel thread */
 	if (kmemleak_initialized)
 		schedule_work(&amp;cleanup_work);
<span class="p_add">+	else</span>
<span class="p_add">+		kmemleak_free_enabled = 0;</span>
 
 	pr_info(&quot;Kernel memory leak detector disabled\n&quot;);
 }
<span class="p_chunk">@@ -1833,8 +1844,10 @@</span> <span class="p_context"> void __init kmemleak_init(void)</span>
 	if (kmemleak_error) {
 		local_irq_restore(flags);
 		return;
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		kmemleak_enabled = 1;
<span class="p_add">+		kmemleak_free_enabled = 1;</span>
<span class="p_add">+	}</span>
 	local_irq_restore(flags);
 
 	/*
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index 0004cbaac4a4..55a55ce92dc1 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -850,7 +850,8 @@</span> <span class="p_context"> static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,</span>
 	if (err &lt; 0) {
 		if (err == -EIO)
 			c-&gt;status = Disconnected;
<span class="p_del">-		goto reterr;</span>
<span class="p_add">+		if (err != -ERESTARTSYS)</span>
<span class="p_add">+			goto reterr;</span>
 	}
 	if (req-&gt;status == REQ_STATUS_ERROR) {
 		p9_debug(P9_DEBUG_ERROR, &quot;req_status error %d\n&quot;, req-&gt;t_err);
<span class="p_header">diff --git a/net/bridge/br_ioctl.c b/net/bridge/br_ioctl.c</span>
<span class="p_header">index a9a4a1b7863d..8d423bc649b9 100644</span>
<span class="p_header">--- a/net/bridge/br_ioctl.c</span>
<span class="p_header">+++ b/net/bridge/br_ioctl.c</span>
<span class="p_chunk">@@ -247,9 +247,7 @@</span> <span class="p_context"> static int old_dev_ioctl(struct net_device *dev, struct ifreq *rq, int cmd)</span>
 		if (!ns_capable(dev_net(dev)-&gt;user_ns, CAP_NET_ADMIN))
 			return -EPERM;
 
<span class="p_del">-		spin_lock_bh(&amp;br-&gt;lock);</span>
 		br_stp_set_bridge_priority(br, args[1]);
<span class="p_del">-		spin_unlock_bh(&amp;br-&gt;lock);</span>
 		return 0;
 
 	case BRCTL_SET_PORT_PRIORITY:
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 799379e81264..46ac609d0882 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -37,6 +37,8 @@</span> <span class="p_context"></span>
 
 static void br_multicast_start_querier(struct net_bridge *br,
 				       struct bridge_mcast_own_query *query);
<span class="p_add">+static void br_multicast_add_router(struct net_bridge *br,</span>
<span class="p_add">+				    struct net_bridge_port *port);</span>
 unsigned int br_mdb_rehash_seq;
 
 static inline int br_ip_equal(const struct br_ip *a, const struct br_ip *b)
<span class="p_chunk">@@ -935,6 +937,8 @@</span> <span class="p_context"> void br_multicast_enable_port(struct net_bridge_port *port)</span>
 #if IS_ENABLED(CONFIG_IPV6)
 	br_multicast_enable(&amp;port-&gt;ip6_own_query);
 #endif
<span class="p_add">+	if (port-&gt;multicast_router == 2 &amp;&amp; hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		br_multicast_add_router(br, port);</span>
 
 out:
 	spin_unlock(&amp;br-&gt;multicast_lock);
<span class="p_chunk">@@ -1166,6 +1170,9 @@</span> <span class="p_context"> static void br_multicast_add_router(struct net_bridge *br,</span>
 	struct net_bridge_port *p;
 	struct hlist_node *slot = NULL;
 
<span class="p_add">+	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	hlist_for_each_entry(p, &amp;br-&gt;router_list, rlist) {
 		if ((unsigned long) port &gt;= (unsigned long) p)
 			break;
<span class="p_chunk">@@ -1193,12 +1200,8 @@</span> <span class="p_context"> static void br_multicast_mark_router(struct net_bridge *br,</span>
 	if (port-&gt;multicast_router != 1)
 		return;
 
<span class="p_del">-	if (!hlist_unhashed(&amp;port-&gt;rlist))</span>
<span class="p_del">-		goto timer;</span>
<span class="p_del">-</span>
 	br_multicast_add_router(br, port);
 
<span class="p_del">-timer:</span>
 	mod_timer(&amp;port-&gt;multicast_router_timer,
 		  now + br-&gt;multicast_querier_interval);
 }
<span class="p_header">diff --git a/net/bridge/br_stp_if.c b/net/bridge/br_stp_if.c</span>
<span class="p_header">index 189ba1e7d851..9a0005aee9ad 100644</span>
<span class="p_header">--- a/net/bridge/br_stp_if.c</span>
<span class="p_header">+++ b/net/bridge/br_stp_if.c</span>
<span class="p_chunk">@@ -243,12 +243,13 @@</span> <span class="p_context"> bool br_stp_recalculate_bridge_id(struct net_bridge *br)</span>
 	return true;
 }
 
<span class="p_del">-/* called under bridge lock */</span>
<span class="p_add">+/* Acquires and releases bridge lock */</span>
 void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)
 {
 	struct net_bridge_port *p;
 	int wasroot;
 
<span class="p_add">+	spin_lock_bh(&amp;br-&gt;lock);</span>
 	wasroot = br_is_root_bridge(br);
 
 	list_for_each_entry(p, &amp;br-&gt;port_list, list) {
<span class="p_chunk">@@ -266,6 +267,7 @@</span> <span class="p_context"> void br_stp_set_bridge_priority(struct net_bridge *br, u16 newprio)</span>
 	br_port_state_selection(br);
 	if (br_is_root_bridge(br) &amp;&amp; !wasroot)
 		br_become_root_bridge(br);
<span class="p_add">+	spin_unlock_bh(&amp;br-&gt;lock);</span>
 }
 
 /* called under bridge lock */
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index c547e46084d3..5740f71b609d 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int crush_decode_tree_bucket(void **p, void *end,</span>
 {
 	int j;
 	dout(&quot;crush_decode_tree_bucket %p to %p\n&quot;, *p, end);
<span class="p_del">-	ceph_decode_32_safe(p, end, b-&gt;num_nodes, bad);</span>
<span class="p_add">+	ceph_decode_8_safe(p, end, b-&gt;num_nodes, bad);</span>
 	b-&gt;node_weights = kcalloc(b-&gt;num_nodes, sizeof(u32), GFP_NOFS);
 	if (b-&gt;node_weights == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/core/neighbour.c b/net/core/neighbour.c</span>
<span class="p_header">index ef31fef25e5a..2b0d99dad8be 100644</span>
<span class="p_header">--- a/net/core/neighbour.c</span>
<span class="p_header">+++ b/net/core/neighbour.c</span>
<span class="p_chunk">@@ -977,6 +977,8 @@</span> <span class="p_context"> int __neigh_event_send(struct neighbour *neigh, struct sk_buff *skb)</span>
 	rc = 0;
 	if (neigh-&gt;nud_state &amp; (NUD_CONNECTED | NUD_DELAY | NUD_PROBE))
 		goto out_unlock_bh;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out_dead;</span>
 
 	if (!(neigh-&gt;nud_state &amp; (NUD_STALE | NUD_INCOMPLETE))) {
 		if (NEIGH_VAR(neigh-&gt;parms, MCAST_PROBES) +
<span class="p_chunk">@@ -1033,6 +1035,13 @@</span> <span class="p_context"> out_unlock_bh:</span>
 		write_unlock(&amp;neigh-&gt;lock);
 	local_bh_enable();
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_dead:</span>
<span class="p_add">+	if (neigh-&gt;nud_state &amp; NUD_STALE)</span>
<span class="p_add">+		goto out_unlock_bh;</span>
<span class="p_add">+	write_unlock_bh(&amp;neigh-&gt;lock);</span>
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+	return 1;</span>
 }
 EXPORT_SYMBOL(__neigh_event_send);
 
<span class="p_chunk">@@ -1096,6 +1105,8 @@</span> <span class="p_context"> int neigh_update(struct neighbour *neigh, const u8 *lladdr, u8 new,</span>
 	if (!(flags &amp; NEIGH_UPDATE_F_ADMIN) &amp;&amp;
 	    (old &amp; (NUD_NOARP | NUD_PERMANENT)))
 		goto out;
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		goto out;</span>
 
 	if (!(new &amp; NUD_VALID)) {
 		neigh_del_timer(neigh);
<span class="p_chunk">@@ -1245,6 +1256,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(neigh_update);</span>
  */
 void __neigh_set_probe_once(struct neighbour *neigh)
 {
<span class="p_add">+	if (neigh-&gt;dead)</span>
<span class="p_add">+		return;</span>
 	neigh-&gt;updated = jiffies;
 	if (!(neigh-&gt;nud_state &amp; NUD_FAILED))
 		return;
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 5901a1187cd2..0e5719c20d61 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -563,7 +563,7 @@</span> <span class="p_context"> static int pktgen_if_show(struct seq_file *seq, void *v)</span>
 			   &quot;     dst_min: %s  dst_max: %s\n&quot;,
 			   pkt_dev-&gt;dst_min, pkt_dev-&gt;dst_max);
 		seq_printf(seq,
<span class="p_del">-			   &quot;        src_min: %s  src_max: %s\n&quot;,</span>
<span class="p_add">+			   &quot;     src_min: %s  src_max: %s\n&quot;,</span>
 			   pkt_dev-&gt;src_min, pkt_dev-&gt;src_max);
 	}
 
<span class="p_header">diff --git a/net/core/skbuff.c b/net/core/skbuff.c</span>
<span class="p_header">index dc27721ece4d..167a92c896b9 100644</span>
<span class="p_header">--- a/net/core/skbuff.c</span>
<span class="p_header">+++ b/net/core/skbuff.c</span>
<span class="p_chunk">@@ -368,9 +368,11 @@</span> <span class="p_context"> refill:</span>
 		for (order = NETDEV_FRAG_PAGE_MAX_ORDER; ;) {
 			gfp_t gfp = gfp_mask;
 
<span class="p_del">-			if (order)</span>
<span class="p_add">+			if (order) {</span>
 				gfp |= __GFP_COMP | __GFP_NOWARN |
 				       __GFP_NOMEMALLOC;
<span class="p_add">+				gfp &amp;= ~__GFP_WAIT;</span>
<span class="p_add">+			}</span>
 			nc-&gt;frag.page = alloc_pages(gfp, order);
 			if (likely(nc-&gt;frag.page))
 				break;
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index a6ddd4ada315..9956e854d0e6 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -1914,8 +1914,10 @@</span> <span class="p_context"> bool skb_page_frag_refill(unsigned int sz, struct page_frag *pfrag, gfp_t prio)</span>
 	do {
 		gfp_t gfp = prio;
 
<span class="p_del">-		if (order)</span>
<span class="p_add">+		if (order) {</span>
 			gfp |= __GFP_COMP | __GFP_NOWARN | __GFP_NORETRY;
<span class="p_add">+			gfp &amp;= ~__GFP_WAIT;</span>
<span class="p_add">+		}</span>
 		pfrag-&gt;page = alloc_pages(gfp, order);
 		if (likely(pfrag-&gt;page)) {
 			pfrag-&gt;offset = 0;
<span class="p_header">diff --git a/net/ieee802154/dgram.c b/net/ieee802154/dgram.c</span>
<span class="p_header">index 4f0ed8780194..9c9b27be78e7 100644</span>
<span class="p_header">--- a/net/ieee802154/dgram.c</span>
<span class="p_header">+++ b/net/ieee802154/dgram.c</span>
<span class="p_chunk">@@ -330,6 +330,12 @@</span> <span class="p_context"> static int dgram_recvmsg(struct kiocb *iocb, struct sock *sk,</span>
 	sock_recv_ts_and_drops(msg, sk, skb);
 
 	if (saddr) {
<span class="p_add">+		/* Clear the implicit padding in struct sockaddr_ieee802154</span>
<span class="p_add">+		 * (16 bits between &#39;family&#39; and &#39;addr&#39;) and in struct</span>
<span class="p_add">+		 * ieee802154_addr_sa (16 bits at the end of the structure).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		memset(saddr, 0, sizeof(*saddr));</span>
<span class="p_add">+</span>
 		saddr-&gt;family = AF_IEEE802154;
 		ieee802154_addr_to_sa(&amp;saddr-&gt;addr, &amp;mac_cb(skb)-&gt;source);
 		*addr_len = sizeof(*saddr);
<span class="p_header">diff --git a/net/ipv4/af_inet.c b/net/ipv4/af_inet.c</span>
<span class="p_header">index d156b3c5f363..13fa803ff549 100644</span>
<span class="p_header">--- a/net/ipv4/af_inet.c</span>
<span class="p_header">+++ b/net/ipv4/af_inet.c</span>
<span class="p_chunk">@@ -228,6 +228,8 @@</span> <span class="p_context"> int inet_listen(struct socket *sock, int backlog)</span>
 				err = 0;
 			if (err)
 				goto out;
<span class="p_add">+</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
 		}
 		err = inet_csk_listen_start(sk, backlog);
 		if (err)
<span class="p_header">diff --git a/net/ipv4/ipip.c b/net/ipv4/ipip.c</span>
<span class="p_header">index 62eaa005e146..2299f9fafd86 100644</span>
<span class="p_header">--- a/net/ipv4/ipip.c</span>
<span class="p_header">+++ b/net/ipv4/ipip.c</span>
<span class="p_chunk">@@ -249,7 +249,8 @@</span> <span class="p_context"> ipip_tunnel_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)</span>
 			return -EINVAL;
 	}
 
<span class="p_del">-	p.i_key = p.o_key = p.i_flags = p.o_flags = 0;</span>
<span class="p_add">+	p.i_key = p.o_key = 0;</span>
<span class="p_add">+	p.i_flags = p.o_flags = 0;</span>
 	if (p.iph.ttl)
 		p.iph.frag_off |= htons(IP_DF);
 
<span class="p_header">diff --git a/net/ipv4/tcp.c b/net/ipv4/tcp.c</span>
<span class="p_header">index 59b579683c1f..9c4f0d2f2892 100644</span>
<span class="p_header">--- a/net/ipv4/tcp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp.c</span>
<span class="p_chunk">@@ -2684,10 +2684,13 @@</span> <span class="p_context"> static int do_tcp_setsockopt(struct sock *sk, int level,</span>
 
 	case TCP_FASTOPEN:
 		if (val &gt;= 0 &amp;&amp; ((1 &lt;&lt; sk-&gt;sk_state) &amp; (TCPF_CLOSE |
<span class="p_del">-		    TCPF_LISTEN)))</span>
<span class="p_add">+		    TCPF_LISTEN))) {</span>
<span class="p_add">+			tcp_fastopen_init_key_once(true);</span>
<span class="p_add">+</span>
 			err = fastopen_init_queue(sk, val);
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			err = -EINVAL;
<span class="p_add">+		}</span>
 		break;
 	case TCP_TIMESTAMP:
 		if (!tp-&gt;repair)
<span class="p_header">diff --git a/net/ipv4/tcp_fastopen.c b/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">index 2d925f65c2cc..6088c58bc54c 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_fastopen.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_fastopen.c</span>
<span class="p_chunk">@@ -78,8 +78,6 @@</span> <span class="p_context"> static bool __tcp_fastopen_cookie_gen(const void *path,</span>
 	struct tcp_fastopen_context *ctx;
 	bool ok = false;
 
<span class="p_del">-	tcp_fastopen_init_key_once(true);</span>
<span class="p_del">-</span>
 	rcu_read_lock();
 	ctx = rcu_dereference(tcp_fastopen_ctx);
 	if (ctx) {
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index d17c26d6e369..8915b1e081e4 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -248,6 +248,7 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 {
 	struct ieee80211_local *local =
 		container_of(work, struct ieee80211_local, restart_work);
<span class="p_add">+	struct ieee80211_sub_if_data *sdata;</span>
 
 	/* wait for scan work complete */
 	flush_workqueue(local-&gt;workqueue);
<span class="p_chunk">@@ -256,6 +257,8 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 	     &quot;%s called with hardware scan in progress\n&quot;, __func__);
 
 	rtnl_lock();
<span class="p_add">+	list_for_each_entry(sdata, &amp;local-&gt;interfaces, list)</span>
<span class="p_add">+		flush_delayed_work(&amp;sdata-&gt;dec_tailroom_needed_wk);</span>
 	ieee80211_scan_cancel(local);
 	ieee80211_reconfig(local);
 	rtnl_unlock();
<span class="p_header">diff --git a/net/netfilter/core.c b/net/netfilter/core.c</span>
<span class="p_header">index 1fbab0cdd302..32c5db5a8569 100644</span>
<span class="p_header">--- a/net/netfilter/core.c</span>
<span class="p_header">+++ b/net/netfilter/core.c</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> void nf_unregister_hook(struct nf_hook_ops *reg)</span>
 	static_key_slow_dec(&amp;nf_hooks_needed[reg-&gt;pf][reg-&gt;hooknum]);
 #endif
 	synchronize_net();
<span class="p_add">+	nf_queue_nf_hook_drop(reg);</span>
 }
 EXPORT_SYMBOL(nf_unregister_hook);
 
<span class="p_header">diff --git a/net/netfilter/nf_internals.h b/net/netfilter/nf_internals.h</span>
<span class="p_header">index 61a3c927e63c..aba1d7dac17c 100644</span>
<span class="p_header">--- a/net/netfilter/nf_internals.h</span>
<span class="p_header">+++ b/net/netfilter/nf_internals.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> int nf_queue(struct sk_buff *skb, struct nf_hook_ops *elem, u_int8_t pf,</span>
 	     unsigned int hook, struct net_device *indev,
 	     struct net_device *outdev, int (*okfn)(struct sk_buff *),
 	     unsigned int queuenum);
<span class="p_add">+void nf_queue_nf_hook_drop(struct nf_hook_ops *ops);</span>
 int __init netfilter_queue_init(void);
 
 /* nf_log.c */
<span class="p_header">diff --git a/net/netfilter/nf_queue.c b/net/netfilter/nf_queue.c</span>
<span class="p_header">index 5d24b1fdb593..df046ed74f2b 100644</span>
<span class="p_header">--- a/net/netfilter/nf_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nf_queue.c</span>
<span class="p_chunk">@@ -95,6 +95,23 @@</span> <span class="p_context"> bool nf_queue_entry_get_refs(struct nf_queue_entry *entry)</span>
 }
 EXPORT_SYMBOL_GPL(nf_queue_entry_get_refs);
 
<span class="p_add">+void nf_queue_nf_hook_drop(struct nf_hook_ops *ops)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct nf_queue_handler *qh;</span>
<span class="p_add">+	struct net *net;</span>
<span class="p_add">+</span>
<span class="p_add">+	rtnl_lock();</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	qh = rcu_dereference(queue_handler);</span>
<span class="p_add">+	if (qh) {</span>
<span class="p_add">+		for_each_net(net) {</span>
<span class="p_add">+			qh-&gt;nf_hook_drop(net, ops);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Any packet that leaves via this function must come back
  * through nf_reinject().
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue_core.c b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">index 5b169db2049a..219ccff2d71c 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue_core.c</span>
<span class="p_chunk">@@ -815,6 +815,27 @@</span> <span class="p_context"> static struct notifier_block nfqnl_dev_notifier = {</span>
 	.notifier_call	= nfqnl_rcv_dev_event,
 };
 
<span class="p_add">+static int nf_hook_cmp(struct nf_queue_entry *entry, unsigned long ops_ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return entry-&gt;elem == (struct nf_hook_ops *)ops_ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void nfqnl_nf_hook_drop(struct net *net, struct nf_hook_ops *hook)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfnl_queue_net *q = nfnl_queue_pernet(net);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	for (i = 0; i &lt; INSTANCE_BUCKETS; i++) {</span>
<span class="p_add">+		struct nfqnl_instance *inst;</span>
<span class="p_add">+		struct hlist_head *head = &amp;q-&gt;instance_table[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		hlist_for_each_entry_rcu(inst, head, hlist)</span>
<span class="p_add">+			nfqnl_flush(inst, nf_hook_cmp, (unsigned long)hook);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 nfqnl_rcv_nl_event(struct notifier_block *this,
 		   unsigned long event, void *ptr)
<span class="p_chunk">@@ -1022,7 +1043,8 @@</span> <span class="p_context"> static const struct nla_policy nfqa_cfg_policy[NFQA_CFG_MAX+1] = {</span>
 };
 
 static const struct nf_queue_handler nfqh = {
<span class="p_del">-	.outfn	= &amp;nfqnl_enqueue_packet,</span>
<span class="p_add">+	.outfn		= &amp;nfqnl_enqueue_packet,</span>
<span class="p_add">+	.nf_hook_drop	= &amp;nfqnl_nf_hook_drop,</span>
 };
 
 static int
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 3eb786fd3f22..fb0c09f85ff2 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -1265,16 +1265,6 @@</span> <span class="p_context"> static void packet_sock_destruct(struct sock *sk)</span>
 	sk_refcnt_debug_dec(sk);
 }
 
<span class="p_del">-static int fanout_rr_next(struct packet_fanout *f, unsigned int num)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int x = atomic_read(&amp;f-&gt;rr_cur) + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (x &gt;= num)</span>
<span class="p_del">-		x = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return x;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static unsigned int fanout_demux_hash(struct packet_fanout *f,
 				      struct sk_buff *skb,
 				      unsigned int num)
<span class="p_chunk">@@ -1286,13 +1276,9 @@</span> <span class="p_context"> static unsigned int fanout_demux_lb(struct packet_fanout *f,</span>
 				    struct sk_buff *skb,
 				    unsigned int num)
 {
<span class="p_del">-	int cur, old;</span>
<span class="p_add">+	unsigned int val = atomic_inc_return(&amp;f-&gt;rr_cur);</span>
 
<span class="p_del">-	cur = atomic_read(&amp;f-&gt;rr_cur);</span>
<span class="p_del">-	while ((old = atomic_cmpxchg(&amp;f-&gt;rr_cur, cur,</span>
<span class="p_del">-				     fanout_rr_next(f, num))) != cur)</span>
<span class="p_del">-		cur = old;</span>
<span class="p_del">-	return cur;</span>
<span class="p_add">+	return val % num;</span>
 }
 
 static unsigned int fanout_demux_cpu(struct packet_fanout *f,
<span class="p_chunk">@@ -1346,7 +1332,7 @@</span> <span class="p_context"> static int packet_rcv_fanout(struct sk_buff *skb, struct net_device *dev,</span>
 			     struct packet_type *pt, struct net_device *orig_dev)
 {
 	struct packet_fanout *f = pt-&gt;af_packet_priv;
<span class="p_del">-	unsigned int num = f-&gt;num_members;</span>
<span class="p_add">+	unsigned int num = ACCESS_ONCE(f-&gt;num_members);</span>
 	struct packet_sock *po;
 	unsigned int idx;
 
<span class="p_header">diff --git a/net/rose/af_rose.c b/net/rose/af_rose.c</span>
<span class="p_header">index 8451c8cdc9de..60823136dafb 100644</span>
<span class="p_header">--- a/net/rose/af_rose.c</span>
<span class="p_header">+++ b/net/rose/af_rose.c</span>
<span class="p_chunk">@@ -192,7 +192,8 @@</span> <span class="p_context"> static void rose_kill_by_device(struct net_device *dev)</span>
 
 		if (rose-&gt;device == dev) {
 			rose_disconnect(s, ENETUNREACH, ROSE_OUT_OF_ORDER, 0);
<span class="p_del">-			rose-&gt;neighbour-&gt;use--;</span>
<span class="p_add">+			if (rose-&gt;neighbour)</span>
<span class="p_add">+				rose-&gt;neighbour-&gt;use--;</span>
 			rose-&gt;device = NULL;
 		}
 	}
<span class="p_header">diff --git a/net/sctp/output.c b/net/sctp/output.c</span>
<span class="p_header">index 3f5b7221dda3..1cfa46bc60c6 100644</span>
<span class="p_header">--- a/net/sctp/output.c</span>
<span class="p_header">+++ b/net/sctp/output.c</span>
<span class="p_chunk">@@ -599,7 +599,9 @@</span> <span class="p_context"> out:</span>
 	return err;
 no_route:
 	kfree_skb(nskb);
<span class="p_del">-	IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (asoc)</span>
<span class="p_add">+		IP_INC_STATS(sock_net(asoc-&gt;base.sk), IPSTATS_MIB_OUTNOROUTES);</span>
 
 	/* FIXME: Returning the &#39;err&#39; will effect all the associations
 	 * associated with a socket, although only one of the paths of the
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index e3528c40a6ea..16991386baa3 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -1533,8 +1533,10 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 
 	/* Supposedly, no process has access to the socket, but
 	 * the net layers still may.
<span class="p_add">+	 * Also, sctp_destroy_sock() needs to be called with addr_wq_lock</span>
<span class="p_add">+	 * held and that should be grabbed before socket lock.</span>
 	 */
<span class="p_del">-	local_bh_disable();</span>
<span class="p_add">+	spin_lock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 	bh_lock_sock(sk);
 
 	/* Hold the sock, since sk_common_release() will put sock_put()
<span class="p_chunk">@@ -1544,7 +1546,7 @@</span> <span class="p_context"> static void sctp_close(struct sock *sk, long timeout)</span>
 	sk_common_release(sk);
 
 	bh_unlock_sock(sk);
<span class="p_del">-	local_bh_enable();</span>
<span class="p_add">+	spin_unlock_bh(&amp;net-&gt;sctp.addr_wq_lock);</span>
 
 	sock_put(sk);
 
<span class="p_chunk">@@ -3519,6 +3521,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 	if ((val &amp;&amp; sp-&gt;do_auto_asconf) || (!val &amp;&amp; !sp-&gt;do_auto_asconf))
 		return 0;
 
<span class="p_add">+	spin_lock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	if (val == 0 &amp;&amp; sp-&gt;do_auto_asconf) {
 		list_del(&amp;sp-&gt;auto_asconf_list);
 		sp-&gt;do_auto_asconf = 0;
<span class="p_chunk">@@ -3527,6 +3530,7 @@</span> <span class="p_context"> static int sctp_setsockopt_auto_asconf(struct sock *sk, char __user *optval,</span>
 		    &amp;sock_net(sk)-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
 	}
<span class="p_add">+	spin_unlock_bh(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -4017,18 +4021,28 @@</span> <span class="p_context"> static int sctp_init_sock(struct sock *sk)</span>
 	local_bh_disable();
 	percpu_counter_inc(&amp;sctp_sockets_allocated);
 	sock_prot_inuse_add(net, sk-&gt;sk_prot, 1);
<span class="p_add">+</span>
<span class="p_add">+	/* Nothing can fail after this block, otherwise</span>
<span class="p_add">+	 * sctp_destroy_sock() will be called without addr_wq_lock held</span>
<span class="p_add">+	 */</span>
 	if (net-&gt;sctp.default_auto_asconf) {
<span class="p_add">+		spin_lock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
 		list_add_tail(&amp;sp-&gt;auto_asconf_list,
 		    &amp;net-&gt;sctp.auto_asconf_splist);
 		sp-&gt;do_auto_asconf = 1;
<span class="p_del">-	} else</span>
<span class="p_add">+		spin_unlock(&amp;sock_net(sk)-&gt;sctp.addr_wq_lock);</span>
<span class="p_add">+	} else {</span>
 		sp-&gt;do_auto_asconf = 0;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	local_bh_enable();
 
 	return 0;
 }
 
<span class="p_del">-/* Cleanup any SCTP per socket resources.  */</span>
<span class="p_add">+/* Cleanup any SCTP per socket resources. Must be called with</span>
<span class="p_add">+ * sock_net(sk)-&gt;sctp.addr_wq_lock held if sp-&gt;do_auto_asconf is true</span>
<span class="p_add">+ */</span>
 static void sctp_destroy_sock(struct sock *sk)
 {
 	struct sctp_sock *sp;
<span class="p_chunk">@@ -6987,6 +7001,19 @@</span> <span class="p_context"> void sctp_copy_sock(struct sock *newsk, struct sock *sk,</span>
 	newinet-&gt;mc_list = NULL;
 }
 
<span class="p_add">+static inline void sctp_copy_descendant(struct sock *sk_to,</span>
<span class="p_add">+					const struct sock *sk_from)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ancestor_size = sizeof(struct inet_sock) +</span>
<span class="p_add">+			    sizeof(struct sctp_sock) -</span>
<span class="p_add">+			    offsetof(struct sctp_sock, auto_asconf_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sk_from-&gt;sk_family == PF_INET6)</span>
<span class="p_add">+		ancestor_size += sizeof(struct ipv6_pinfo);</span>
<span class="p_add">+</span>
<span class="p_add">+	__inet_sk_copy_descendant(sk_to, sk_from, ancestor_size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Populate the fields of the newsk from the oldsk and migrate the assoc
  * and its messages to the newsk.
  */
<span class="p_chunk">@@ -7001,7 +7028,6 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	struct sk_buff *skb, *tmp;
 	struct sctp_ulpevent *event;
 	struct sctp_bind_hashbucket *head;
<span class="p_del">-	struct list_head tmplist;</span>
 
 	/* Migrate socket buffer sizes and all the socket level options to the
 	 * new socket.
<span class="p_chunk">@@ -7009,12 +7035,7 @@</span> <span class="p_context"> static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,</span>
 	newsk-&gt;sk_sndbuf = oldsk-&gt;sk_sndbuf;
 	newsk-&gt;sk_rcvbuf = oldsk-&gt;sk_rcvbuf;
 	/* Brute force copy old sctp opt. */
<span class="p_del">-	if (oldsp-&gt;do_auto_asconf) {</span>
<span class="p_del">-		memcpy(&amp;tmplist, &amp;newsp-&gt;auto_asconf_list, sizeof(tmplist));</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_del">-		memcpy(&amp;newsp-&gt;auto_asconf_list, &amp;tmplist, sizeof(tmplist));</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		inet_sk_copy_descendant(newsk, oldsk);</span>
<span class="p_add">+	sctp_copy_descendant(newsk, oldsk);</span>
 
 	/* Restore the ep value that was overwritten with the above structure
 	 * copy.
<span class="p_header">diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">index 1bb4d26fbd6b..ca9ff71134f9 100644</span>
<span class="p_header">--- a/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">+++ b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static void xprt_free_allocation(struct rpc_rqst *req)</span>
 
 	dprintk(&quot;RPC:        free allocations for req= %p\n&quot;, req);
 	WARN_ON_ONCE(test_bit(RPC_BC_PA_IN_USE, &amp;req-&gt;rq_bc_pa_state));
<span class="p_del">-	xbufp = &amp;req-&gt;rq_private_buf;</span>
<span class="p_add">+	xbufp = &amp;req-&gt;rq_rcv_buf;</span>
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
 	xbufp = &amp;req-&gt;rq_snd_buf;
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
<span class="p_header">diff --git a/net/wireless/util.c b/net/wireless/util.c</span>
<span class="p_header">index 728f1c0dc70d..b5dd3c829b1a 100644</span>
<span class="p_header">--- a/net/wireless/util.c</span>
<span class="p_header">+++ b/net/wireless/util.c</span>
<span class="p_chunk">@@ -891,7 +891,7 @@</span> <span class="p_context"> int cfg80211_change_iface(struct cfg80211_registered_device *rdev,</span>
 	     ntype == NL80211_IFTYPE_P2P_CLIENT))
 		return -EBUSY;
 
<span class="p_del">-	if (ntype != otype &amp;&amp; netif_running(dev)) {</span>
<span class="p_add">+	if (ntype != otype) {</span>
 		dev-&gt;ieee80211_ptr-&gt;use_4addr = false;
 		dev-&gt;ieee80211_ptr-&gt;mesh_id_up_len = 0;
 		wdev_lock(dev-&gt;ieee80211_ptr);
<span class="p_header">diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h</span>
<span class="p_header">index f79fa8be203c..5cb7de9046fa 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima.h</span>
<span class="p_header">+++ b/security/integrity/ima/ima.h</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void ima_add_violation(struct file *file, const unsigned char *filename,</span>
 		       const char *op, const char *cause);
 int ima_init_crypto(void);
 void ima_putc(struct seq_file *m, void *data, int datalen);
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size);</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size);</span>
 struct ima_template_desc *ima_template_desc_current(void);
 int ima_init_template(void);
 
<span class="p_header">diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c</span>
<span class="p_header">index da92fcc08d15..d30afe461070 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_fs.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_fs.c</span>
<span class="p_chunk">@@ -186,9 +186,9 @@</span> <span class="p_context"> static const struct file_operations ima_measurements_ops = {</span>
 	.release = seq_release,
 };
 
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size)</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	u32 i;</span>
 
 	for (i = 0; i &lt; size; i++)
 		seq_printf(m, &quot;%02x&quot;, *(digest + i));
<span class="p_header">diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">index 1506f0248572..1eb173ddefd6 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_chunk">@@ -70,7 +70,8 @@</span> <span class="p_context"> static void ima_show_template_data_ascii(struct seq_file *m,</span>
 					 enum data_formats datafmt,
 					 struct ima_field_data *field_data)
 {
<span class="p_del">-	u8 *buf_ptr = field_data-&gt;data, buflen = field_data-&gt;len;</span>
<span class="p_add">+	u8 *buf_ptr = field_data-&gt;data;</span>
<span class="p_add">+	u32 buflen = field_data-&gt;len;</span>
 
 	switch (datafmt) {
 	case DATA_FMT_DIGEST_WITH_ALGO:
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index a2aa95ecd1d5..9a23a7cccdc4 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -394,7 +394,8 @@</span> <span class="p_context"> static int selinux_is_sblabel_mnt(struct super_block *sb)</span>
 
 	if (sbsec-&gt;behavior == SECURITY_FS_USE_XATTR ||
 	    sbsec-&gt;behavior == SECURITY_FS_USE_TRANS ||
<span class="p_del">-	    sbsec-&gt;behavior == SECURITY_FS_USE_TASK)</span>
<span class="p_add">+	    sbsec-&gt;behavior == SECURITY_FS_USE_TASK ||</span>
<span class="p_add">+	    sbsec-&gt;behavior == SECURITY_FS_USE_NATIVE)</span>
 		return 1;
 
 	/* Special handling for sysfs. Is genfs but also has setxattr handler*/
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 9d2aedb84797..78d333c4a526 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4269,6 +4269,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_LIFEBOOK,
 	ALC269_FIXUP_LIFEBOOK_EXTMIC,
 	ALC269_FIXUP_LIFEBOOK_HP_PIN,
<span class="p_add">+	ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT,</span>
 	ALC269_FIXUP_AMIC,
 	ALC269_FIXUP_DMIC,
 	ALC269VB_FIXUP_AMIC,
<span class="p_chunk">@@ -4287,6 +4288,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_FIXUP_DELL3_MIC_NO_PRESENCE,
 	ALC269_FIXUP_HEADSET_MODE,
 	ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC,
<span class="p_add">+	ALC269_FIXUP_ASPIRE_HEADSET_MIC,</span>
 	ALC269_FIXUP_ASUS_X101_FUNC,
 	ALC269_FIXUP_ASUS_X101_VERB,
 	ALC269_FIXUP_ASUS_X101,
<span class="p_chunk">@@ -4314,6 +4316,7 @@</span> <span class="p_context"> enum {</span>
 	ALC255_FIXUP_HEADSET_MODE_NO_HP_MIC,
 	ALC293_FIXUP_DELL1_MIC_NO_PRESENCE,
 	ALC292_FIXUP_TPT440_DOCK,
<span class="p_add">+	ALC292_FIXUP_TPT440_DOCK2,</span>
 };
 
 static const struct hda_fixup alc269_fixups[] = {
<span class="p_chunk">@@ -4420,6 +4423,10 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 			{ }
 		},
 	},
<span class="p_add">+	[ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,</span>
<span class="p_add">+	},</span>
 	[ALC269_FIXUP_AMIC] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4538,6 +4545,15 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc_fixup_headset_mode_no_hp_mic,
 	},
<span class="p_add">+	[ALC269_FIXUP_ASPIRE_HEADSET_MIC] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x19, 0x01a1913c }, /* headset mic w/o jack detect */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HEADSET_MODE,</span>
<span class="p_add">+	},</span>
 	[ALC286_FIXUP_SONY_MIC_NO_PRESENCE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -4738,6 +4754,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chain_id = ALC269_FIXUP_HEADSET_MODE
 	},
 	[ALC292_FIXUP_TPT440_DOCK] = {
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc269_fixup_pincfg_no_hp_to_lineout,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC292_FIXUP_TPT440_DOCK2</span>
<span class="p_add">+	},</span>
<span class="p_add">+	[ALC292_FIXUP_TPT440_DOCK2] = {</span>
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
 			{ 0x16, 0x21211010 }, /* dock headphone */
<span class="p_chunk">@@ -4754,6 +4776,8 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x029b, &quot;Acer 1810TZ&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x0349, &quot;Acer AOD260&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x047c, &quot;Acer AC700&quot;, ALC269_FIXUP_ACER_AC700),
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x072d, &quot;Acer Aspire V5-571G&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1025, 0x080d, &quot;Acer Aspire V5-122P&quot;, ALC269_FIXUP_ASPIRE_HEADSET_MIC),</span>
 	SND_PCI_QUIRK(0x1025, 0x0740, &quot;Acer AO725&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK(0x1025, 0x0742, &quot;Acer AO756&quot;, ALC271_FIXUP_HP_GATE_MIC_JACK),
 	SND_PCI_QUIRK_VENDOR(0x1025, &quot;Acer Aspire&quot;, ALC271_FIXUP_DMIC),
<span class="p_chunk">@@ -4879,6 +4903,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9099, &quot;Sony VAIO S13&quot;, ALC275_FIXUP_SONY_DISABLE_AAMIX),
 	SND_PCI_QUIRK_VENDOR(0x104d, &quot;Sony VAIO&quot;, ALC269_FIXUP_SONY_VAIO),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x159f, &quot;Lifebook E780&quot;, ALC269_FIXUP_LIFEBOOK_NO_HP_TO_LINEOUT),</span>
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
<span class="p_header">diff --git a/sound/soc/codecs/wm5102.c b/sound/soc/codecs/wm5102.c</span>
<span class="p_header">index 289b64d89abd..62cfa74bf83b 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5102.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5102.c</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> struct wm5102_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct wm_adsp_region wm5102_dsp1_regions[] = {
<span class="p_header">diff --git a/sound/soc/codecs/wm5110.c b/sound/soc/codecs/wm5110.c</span>
<span class="p_header">index 2e5fcb559e90..8a0d9787a6fc 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5110.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5110.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> static int wm5110_sysclk_ev(struct snd_soc_dapm_widget *w,</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 #define WM5110_NG_SRC(name, base) \
<span class="p_header">diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c</span>
<span class="p_header">index b27f26cdc049..daa8e70c41d8 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8737.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8737.c</span>
<span class="p_chunk">@@ -494,7 +494,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-					    WM8737_VMIDSEL_MASK, 0x4);</span>
<span class="p_add">+					    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+					    2 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
<span class="p_chunk">@@ -508,7 +509,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-				    WM8737_VMIDSEL_MASK, 2);</span>
<span class="p_add">+				    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+				    1 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 		break;
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h</span>
<span class="p_header">index db949311c0f2..0bb4a647755d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.h</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.h</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> extern int wm8903_mic_detect(struct snd_soc_codec *codec,</span>
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
<span class="p_del">-#define WM8903_VMID_RES_250K                         3</span>
<span class="p_add">+#define WM8903_VMID_RES_250K                         4</span>
 #define WM8903_VMID_RES_5K                           6
 
 /*
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index b8a9f8c84b7c..559ee33ae709 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static int wm8955_configure_clocking(struct snd_soc_codec *codec)</span>
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k &gt;&gt; 9) &amp; WM8955_K_17_9_MASK);
<span class="p_del">-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,</span>
 				    WM8955_K_8_0_MASK,
 				    pll.k &amp; WM8955_K_8_0_MASK);
 		if (pll.k)
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index 1f5a5eebfd67..c2acb2fabf33 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> SOC_SINGLE(&quot;PCM Playback -6dB Switch&quot;, WM8960_DACCTL1, 7, 1, 0),</span>
 SOC_ENUM(&quot;ADC Polarity&quot;, wm8960_enum[0]),
 SOC_SINGLE(&quot;ADC High Pass Filter Switch&quot;, WM8960_DACCTL1, 0, 1, 0),
 
<span class="p_del">-SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[2]),</span>
<span class="p_add">+SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[1]),</span>
 SOC_SINGLE_BOOL_EXT(&quot;DAC Deemphasis Switch&quot;, 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8997.c b/sound/soc/codecs/wm8997.c</span>
<span class="p_header">index bb9b47b956aa..0de5960064e0 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8997.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8997.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct wm8997_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct reg_default wm8997_sysclk_reva_patch[] = {
<span class="p_header">diff --git a/sound/soc/fsl/imx-wm8962.c b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">index 3a3d17ce6ba4..664452599497 100644</span>
<span class="p_header">--- a/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">+++ b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> static int imx_wm8962_probe(struct platform_device *pdev)</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;audmux internal port setup failed\n&quot;);
 		return ret;
 	}
<span class="p_del">-	imx_audmux_v2_configure_port(ext_port,</span>
<span class="p_add">+	ret = imx_audmux_v2_configure_port(ext_port,</span>
 			IMX_AUDMUX_V2_PTCR_SYN,
 			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
 	if (ret) {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



