
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.8.7 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.8.7</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 10, 2016, 4:08 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20161110160818.GB16246@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9421357/mbox/"
   >mbox</a>
|
   <a href="/patch/9421357/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9421357/">/patch/9421357/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	BC56860484 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 10 Nov 2016 16:08:48 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A12662977C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 10 Nov 2016 16:08:48 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 94D4B297B1; Thu, 10 Nov 2016 16:08:48 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C1642297B3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 10 Nov 2016 16:08:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934831AbcKJQIV (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 10 Nov 2016 11:08:21 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:36070 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S934752AbcKJQIM (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 10 Nov 2016 11:08:12 -0500
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 77CB2C4B;
	Thu, 10 Nov 2016 16:08:09 +0000 (UTC)
Date: Thu, 10 Nov 2016 17:08:18 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.8.7
Message-ID: &lt;20161110160818.GB16246@kroah.com&gt;
References: &lt;20161110160811.GA16246@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20161110160811.GA16246@kroah.com&gt;
User-Agent: Mutt/1.7.1 (2016-10-04)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Nov. 10, 2016, 4:08 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/device-mapper/dm-raid.txt b/Documentation/device-mapper/dm-raid.txt</span>
<span class="p_header">index e5b6497116f4..c75b64a85859 100644</span>
<span class="p_header">--- a/Documentation/device-mapper/dm-raid.txt</span>
<span class="p_header">+++ b/Documentation/device-mapper/dm-raid.txt</span>
<span class="p_chunk">@@ -309,3 +309,4 @@</span> <span class="p_context"> Version History</span>
 	with a reshape in progress.
 1.9.0   Add support for RAID level takeover/reshape/region size
 	and set size reduction.
<span class="p_add">+1.9.1   Fix activation of existing RAID 4/10 mapped devices</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index b249529204cd..4d0f28cb481d 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 8
<span class="p_del">-SUBLEVEL = 6</span>
<span class="p_add">+SUBLEVEL = 7</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-snowball.dts b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">index b3df1c60d465..386eee6de232 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-snowball.dts</span>
<span class="p_chunk">@@ -239,14 +239,25 @@</span> <span class="p_context"></span>
 			arm,primecell-periphid = &lt;0x10480180&gt;;
 			max-frequency = &lt;100000000&gt;;
 			bus-width = &lt;4&gt;;
<span class="p_add">+			cap-sd-highspeed;</span>
 			cap-mmc-highspeed;
<span class="p_add">+			sd-uhs-sdr12;</span>
<span class="p_add">+			sd-uhs-sdr25;</span>
<span class="p_add">+			/* All direction control is used */</span>
<span class="p_add">+			st,sig-dir-cmd;</span>
<span class="p_add">+			st,sig-dir-dat0;</span>
<span class="p_add">+			st,sig-dir-dat2;</span>
<span class="p_add">+			st,sig-dir-dat31;</span>
<span class="p_add">+			st,sig-pin-fbclk;</span>
<span class="p_add">+			full-pwr-cycle;</span>
 			vmmc-supply = &lt;&amp;ab8500_ldo_aux3_reg&gt;;
 			vqmmc-supply = &lt;&amp;vmmci&gt;;
 			pinctrl-names = &quot;default&quot;, &quot;sleep&quot;;
 			pinctrl-0 = &lt;&amp;sdi0_default_mode&gt;;
 			pinctrl-1 = &lt;&amp;sdi0_sleep_mode&gt;;
 
<span class="p_del">-			cd-gpios  = &lt;&amp;gpio6 26 GPIO_ACTIVE_LOW&gt;; // 218</span>
<span class="p_add">+			/* GPIO218 MMC_CD */</span>
<span class="p_add">+			cd-gpios  = &lt;&amp;gpio6 26 GPIO_ACTIVE_LOW&gt;;</span>
 
 			status = &quot;okay&quot;;
 		};
<span class="p_chunk">@@ -549,7 +560,7 @@</span> <span class="p_context"></span>
 					/* VMMCI level-shifter enable */
 					snowball_cfg3 {
 						pins = &quot;GPIO217_AH12&quot;;
<span class="p_del">-						ste,config = &lt;&amp;gpio_out_lo&gt;;</span>
<span class="p_add">+						ste,config = &lt;&amp;gpio_out_hi&gt;;</span>
 					};
 					/* VMMCI level-shifter voltage select */
 					snowball_cfg4 {
<span class="p_header">diff --git a/arch/arm/mach-mvebu/Kconfig b/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_header">index f9b6bd306cfe..541647f57192 100644</span>
<span class="p_header">--- a/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"> config MACH_MVEBU_V7</span>
 	select CACHE_L2X0
 	select ARM_CPU_SUSPEND
 	select MACH_MVEBU_ANY
<span class="p_add">+	select MVEBU_CLK_COREDIV</span>
 
 config MACH_ARMADA_370
 	bool &quot;Marvell Armada 370 boards&quot;
<span class="p_chunk">@@ -32,7 +33,6 @@</span> <span class="p_context"> config MACH_ARMADA_370</span>
 	select CPU_PJ4B
 	select MACH_MVEBU_V7
 	select PINCTRL_ARMADA_370
<span class="p_del">-	select MVEBU_CLK_COREDIV</span>
 	help
 	  Say &#39;Y&#39; here if you want your kernel to support boards based
 	  on the Marvell Armada 370 SoC with device tree.
<span class="p_chunk">@@ -50,7 +50,6 @@</span> <span class="p_context"> config MACH_ARMADA_375</span>
 	select HAVE_SMP
 	select MACH_MVEBU_V7
 	select PINCTRL_ARMADA_375
<span class="p_del">-	select MVEBU_CLK_COREDIV</span>
 	help
 	  Say &#39;Y&#39; here if you want your kernel to support boards based
 	  on the Marvell Armada 375 SoC with device tree.
<span class="p_chunk">@@ -68,7 +67,6 @@</span> <span class="p_context"> config MACH_ARMADA_38X</span>
 	select HAVE_SMP
 	select MACH_MVEBU_V7
 	select PINCTRL_ARMADA_38X
<span class="p_del">-	select MVEBU_CLK_COREDIV</span>
 	help
 	  Say &#39;Y&#39; here if you want your kernel to support boards based
 	  on the Marvell Armada 380/385 SoC with device tree.
<span class="p_header">diff --git a/arch/arm/mm/abort-lv4t.S b/arch/arm/mm/abort-lv4t.S</span>
<span class="p_header">index 6d8e8e3365d1..4cdfab31a0b6 100644</span>
<span class="p_header">--- a/arch/arm/mm/abort-lv4t.S</span>
<span class="p_header">+++ b/arch/arm/mm/abort-lv4t.S</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"></span>
  *	   : r4 = aborted context pc
  *	   : r5 = aborted context psr
  *
<span class="p_del">- * Returns : r4-r5, r10-r11, r13 preserved</span>
<span class="p_add">+ * Returns : r4-r5, r9-r11, r13 preserved</span>
  *
  * Purpose : obtain information about current aborted instruction.
  * Note: we read user space.  This means we might cause a data
<span class="p_chunk">@@ -48,7 +48,10 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 /* c */	b	do_DataAbort			@ ldc	rd, [rn], #m	@ Same as ldr	rd, [rn], #m
 /* d */	b	do_DataAbort			@ ldc	rd, [rn, #m]
 /* e */	b	.data_unknown
<span class="p_del">-/* f */</span>
<span class="p_add">+/* f */	b	.data_unknown</span>
<span class="p_add">+</span>
<span class="p_add">+.data_unknown_r9:</span>
<span class="p_add">+	ldr	r9, [sp], #4</span>
 .data_unknown:	@ Part of jumptable
 	mov	r0, r4
 	mov	r1, r8
<span class="p_chunk">@@ -57,6 +60,7 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 .data_arm_ldmstm:
 	tst	r8, #1 &lt;&lt; 21			@ check writeback bit
 	beq	do_DataAbort			@ no writeback -&gt; no fixup
<span class="p_add">+	str	r9, [sp, #-4]!</span>
 	mov	r7, #0x11
 	orr	r7, r7, #0x1100
 	and	r6, r8, r7
<span class="p_chunk">@@ -75,12 +79,14 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 	subne	r7, r7, r6, lsl #2		@ Undo increment
 	addeq	r7, r7, r6, lsl #2		@ Undo decrement
 	str	r7, [r2, r9, lsr #14]		@ Put register &#39;Rn&#39;
<span class="p_add">+	ldr	r9, [sp], #4</span>
 	b	do_DataAbort
 
 .data_arm_lateldrhpre:
 	tst	r8, #1 &lt;&lt; 21			@ Check writeback bit
 	beq	do_DataAbort			@ No writeback -&gt; no fixup
 .data_arm_lateldrhpost:
<span class="p_add">+	str	r9, [sp, #-4]!</span>
 	and	r9, r8, #0x00f			@ get Rm / low nibble of immediate value
 	tst	r8, #1 &lt;&lt; 22			@ if (immediate offset)
 	andne	r6, r8, #0xf00			@ { immediate high nibble
<span class="p_chunk">@@ -93,6 +99,7 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 	subne	r7, r7, r6			@ Undo incrmenet
 	addeq	r7, r7, r6			@ Undo decrement
 	str	r7, [r2, r9, lsr #14]		@ Put register &#39;Rn&#39;
<span class="p_add">+	ldr	r9, [sp], #4</span>
 	b	do_DataAbort
 
 .data_arm_lateldrpreconst:
<span class="p_chunk">@@ -101,12 +108,14 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 .data_arm_lateldrpostconst:
 	movs	r6, r8, lsl #20			@ Get offset
 	beq	do_DataAbort			@ zero -&gt; no fixup
<span class="p_add">+	str	r9, [sp, #-4]!</span>
 	and	r9, r8, #15 &lt;&lt; 16		@ Extract &#39;n&#39; from instruction
 	ldr	r7, [r2, r9, lsr #14]		@ Get register &#39;Rn&#39;
 	tst	r8, #1 &lt;&lt; 23			@ Check U bit
 	subne	r7, r7, r6, lsr #20		@ Undo increment
 	addeq	r7, r7, r6, lsr #20		@ Undo decrement
 	str	r7, [r2, r9, lsr #14]		@ Put register &#39;Rn&#39;
<span class="p_add">+	ldr	r9, [sp], #4</span>
 	b	do_DataAbort
 
 .data_arm_lateldrprereg:
<span class="p_chunk">@@ -115,6 +124,7 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 .data_arm_lateldrpostreg:
 	and	r7, r8, #15			@ Extract &#39;m&#39; from instruction
 	ldr	r6, [r2, r7, lsl #2]		@ Get register &#39;Rm&#39;
<span class="p_add">+	str	r9, [sp, #-4]!</span>
 	mov	r9, r8, lsr #7			@ get shift count
 	ands	r9, r9, #31
 	and	r7, r8, #0x70			@ get shift type
<span class="p_chunk">@@ -126,33 +136,33 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 	b	.data_arm_apply_r6_and_rn
 	b	.data_arm_apply_r6_and_rn	@ 1: LSL #0
 	nop
<span class="p_del">-	b	.data_unknown			@ 2: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ 2: MUL?</span>
 	nop
<span class="p_del">-	b	.data_unknown			@ 3: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ 3: MUL?</span>
 	nop
 	mov	r6, r6, lsr r9			@ 4: LSR #!0
 	b	.data_arm_apply_r6_and_rn
 	mov	r6, r6, lsr #32			@ 5: LSR #32
 	b	.data_arm_apply_r6_and_rn
<span class="p_del">-	b	.data_unknown			@ 6: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ 6: MUL?</span>
 	nop
<span class="p_del">-	b	.data_unknown			@ 7: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ 7: MUL?</span>
 	nop
 	mov	r6, r6, asr r9			@ 8: ASR #!0
 	b	.data_arm_apply_r6_and_rn
 	mov	r6, r6, asr #32			@ 9: ASR #32
 	b	.data_arm_apply_r6_and_rn
<span class="p_del">-	b	.data_unknown			@ A: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ A: MUL?</span>
 	nop
<span class="p_del">-	b	.data_unknown			@ B: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ B: MUL?</span>
 	nop
 	mov	r6, r6, ror r9			@ C: ROR #!0
 	b	.data_arm_apply_r6_and_rn
 	mov	r6, r6, rrx			@ D: RRX
 	b	.data_arm_apply_r6_and_rn
<span class="p_del">-	b	.data_unknown			@ E: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ E: MUL?</span>
 	nop
<span class="p_del">-	b	.data_unknown			@ F: MUL?</span>
<span class="p_add">+	b	.data_unknown_r9		@ F: MUL?</span>
 
 .data_thumb_abort:
 	ldrh	r8, [r4]			@ read instruction
<span class="p_chunk">@@ -190,6 +200,7 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 .data_thumb_pushpop:
 	tst	r8, #1 &lt;&lt; 10
 	beq	.data_unknown
<span class="p_add">+	str	r9, [sp, #-4]!</span>
 	and	r6, r8, #0x55			@ hweight8(r8) + R bit
 	and	r9, r8, #0xaa
 	add	r6, r6, r9, lsr #1
<span class="p_chunk">@@ -204,9 +215,11 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 	addeq	r7, r7, r6, lsl #2		@ increment SP if PUSH
 	subne	r7, r7, r6, lsl #2		@ decrement SP if POP
 	str	r7, [r2, #13 &lt;&lt; 2]
<span class="p_add">+	ldr	r9, [sp], #4</span>
 	b	do_DataAbort
 
 .data_thumb_ldmstm:
<span class="p_add">+	str	r9, [sp, #-4]!</span>
 	and	r6, r8, #0x55			@ hweight8(r8)
 	and	r9, r8, #0xaa
 	add	r6, r6, r9, lsr #1
<span class="p_chunk">@@ -219,4 +232,5 @@</span> <span class="p_context"> ENTRY(v4t_late_abort)</span>
 	and	r6, r6, #15			@ number of regs to transfer
 	sub	r7, r7, r6, lsl #2		@ always decrement
 	str	r7, [r2, r9, lsr #6]
<span class="p_add">+	ldr	r9, [sp], #4</span>
 	b	do_DataAbort
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi b/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi</span>
<span class="p_header">index da31bbbbb59e..399271853aad 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-cp110-master.dtsi</span>
<span class="p_chunk">@@ -131,7 +131,7 @@</span> <span class="p_context"></span>
 				#address-cells = &lt;0x1&gt;;
 				#size-cells = &lt;0x0&gt;;
 				cell-index = &lt;1&gt;;
<span class="p_del">-				clocks = &lt;&amp;cpm_syscon0 0 3&gt;;</span>
<span class="p_add">+				clocks = &lt;&amp;cpm_syscon0 1 21&gt;;</span>
 				status = &quot;disabled&quot;;
 			};
 
<span class="p_header">diff --git a/arch/h8300/include/asm/thread_info.h b/arch/h8300/include/asm/thread_info.h</span>
<span class="p_header">index b408fe660cf8..3cef06875f5c 100644</span>
<span class="p_header">--- a/arch/h8300/include/asm/thread_info.h</span>
<span class="p_header">+++ b/arch/h8300/include/asm/thread_info.h</span>
<span class="p_chunk">@@ -31,7 +31,6 @@</span> <span class="p_context"> struct thread_info {</span>
 	int		   cpu;			/* cpu we&#39;re on */
 	int		   preempt_count;	/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */
 	mm_segment_t		addr_limit;
<span class="p_del">-	struct restart_block restart_block;</span>
 };
 
 /*
<span class="p_chunk">@@ -44,9 +43,6 @@</span> <span class="p_context"> struct thread_info {</span>
 	.cpu =		0,			\
 	.preempt_count = INIT_PREEMPT_COUNT,	\
 	.addr_limit	= KERNEL_DS,		\
<span class="p_del">-	.restart_block	= {			\</span>
<span class="p_del">-		.fn = do_no_restart_syscall,	\</span>
<span class="p_del">-	},					\</span>
 }
 
 #define init_thread_info	(init_thread_union.thread_info)
<span class="p_header">diff --git a/arch/h8300/kernel/signal.c b/arch/h8300/kernel/signal.c</span>
<span class="p_header">index ad1f81f574e5..7138303cbbf2 100644</span>
<span class="p_header">--- a/arch/h8300/kernel/signal.c</span>
<span class="p_header">+++ b/arch/h8300/kernel/signal.c</span>
<span class="p_chunk">@@ -79,7 +79,7 @@</span> <span class="p_context"> restore_sigcontext(struct sigcontext *usc, int *pd0)</span>
 	unsigned int er0;
 
 	/* Always make any pending restarted system calls return -EINTR */
<span class="p_del">-	current_thread_info()-&gt;restart_block.fn = do_no_restart_syscall;</span>
<span class="p_add">+	current-&gt;restart_block.fn = do_no_restart_syscall;</span>
 
 	/* restore passed registers */
 #define COPY(r)  do { err |= get_user(regs-&gt;r, &amp;usc-&gt;sc_##r); } while (0)
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index b54bcadd8aec..45799ef232df 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -279,7 +279,10 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	/* Host KSEG0 address of the EI/DI offset */
 	void *kseg0_commpage;
 
<span class="p_del">-	u32 io_gpr;		/* GPR used as IO source/target */</span>
<span class="p_add">+	/* Resume PC after MMIO completion */</span>
<span class="p_add">+	unsigned long io_pc;</span>
<span class="p_add">+	/* GPR used as IO source/target */</span>
<span class="p_add">+	u32 io_gpr;</span>
 
 	struct hrtimer comparecount_timer;
 	/* Count timer control KVM register */
<span class="p_chunk">@@ -301,8 +304,6 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	/* Bitmask of pending exceptions to be cleared */
 	unsigned long pending_exceptions_clr;
 
<span class="p_del">-	u32 pending_load_cause;</span>
<span class="p_del">-</span>
 	/* Save/Restore the entryhi register when are are preempted/scheduled back in */
 	unsigned long preempt_entryhi;
 
<span class="p_header">diff --git a/arch/mips/kernel/relocate.c b/arch/mips/kernel/relocate.c</span>
<span class="p_header">index ca1cc30c0891..1958910b75c0 100644</span>
<span class="p_header">--- a/arch/mips/kernel/relocate.c</span>
<span class="p_header">+++ b/arch/mips/kernel/relocate.c</span>
<span class="p_chunk">@@ -200,7 +200,7 @@</span> <span class="p_context"> static inline __init unsigned long get_random_boot(void)</span>
 
 #if defined(CONFIG_USE_OF)
 	/* Get any additional entropy passed in device tree */
<span class="p_del">-	{</span>
<span class="p_add">+	if (initial_boot_params) {</span>
 		int node, len;
 		u64 *prop;
 
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index 43853ec6e160..4d65285ca418 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -791,15 +791,15 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_eret(struct kvm_vcpu *vcpu)</span>
 	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;
 	enum emulation_result er = EMULATE_DONE;
 
<span class="p_del">-	if (kvm_read_c0_guest_status(cop0) &amp; ST0_EXL) {</span>
<span class="p_add">+	if (kvm_read_c0_guest_status(cop0) &amp; ST0_ERL) {</span>
<span class="p_add">+		kvm_clear_c0_guest_status(cop0, ST0_ERL);</span>
<span class="p_add">+		vcpu-&gt;arch.pc = kvm_read_c0_guest_errorepc(cop0);</span>
<span class="p_add">+	} else if (kvm_read_c0_guest_status(cop0) &amp; ST0_EXL) {</span>
 		kvm_debug(&quot;[%#lx] ERET to %#lx\n&quot;, vcpu-&gt;arch.pc,
 			  kvm_read_c0_guest_epc(cop0));
 		kvm_clear_c0_guest_status(cop0, ST0_EXL);
 		vcpu-&gt;arch.pc = kvm_read_c0_guest_epc(cop0);
 
<span class="p_del">-	} else if (kvm_read_c0_guest_status(cop0) &amp; ST0_ERL) {</span>
<span class="p_del">-		kvm_clear_c0_guest_status(cop0, ST0_ERL);</span>
<span class="p_del">-		vcpu-&gt;arch.pc = kvm_read_c0_guest_errorepc(cop0);</span>
 	} else {
 		kvm_err(&quot;[%#lx] ERET when MIPS_SR_EXL|MIPS_SR_ERL == 0\n&quot;,
 			vcpu-&gt;arch.pc);
<span class="p_chunk">@@ -1522,13 +1522,25 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_load(union mips_instruction inst,</span>
 					    struct kvm_vcpu *vcpu)
 {
 	enum emulation_result er = EMULATE_DO_MMIO;
<span class="p_add">+	unsigned long curr_pc;</span>
 	u32 op, rt;
 	u32 bytes;
 
 	rt = inst.i_format.rt;
 	op = inst.i_format.opcode;
 
<span class="p_del">-	vcpu-&gt;arch.pending_load_cause = cause;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Find the resume PC now while we have safe and easy access to the</span>
<span class="p_add">+	 * prior branch instruction, and save it for</span>
<span class="p_add">+	 * kvm_mips_complete_mmio_load() to restore later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	curr_pc = vcpu-&gt;arch.pc;</span>
<span class="p_add">+	er = update_pc(vcpu, cause);</span>
<span class="p_add">+	if (er == EMULATE_FAIL)</span>
<span class="p_add">+		return er;</span>
<span class="p_add">+	vcpu-&gt;arch.io_pc = vcpu-&gt;arch.pc;</span>
<span class="p_add">+	vcpu-&gt;arch.pc = curr_pc;</span>
<span class="p_add">+</span>
 	vcpu-&gt;arch.io_gpr = rt;
 
 	switch (op) {
<span class="p_chunk">@@ -2488,9 +2500,8 @@</span> <span class="p_context"> enum emulation_result kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu,</span>
 		goto done;
 	}
 
<span class="p_del">-	er = update_pc(vcpu, vcpu-&gt;arch.pending_load_cause);</span>
<span class="p_del">-	if (er == EMULATE_FAIL)</span>
<span class="p_del">-		return er;</span>
<span class="p_add">+	/* Restore saved resume PC */</span>
<span class="p_add">+	vcpu-&gt;arch.pc = vcpu-&gt;arch.io_pc;</span>
 
 	switch (run-&gt;mmio.len) {
 	case 4:
<span class="p_chunk">@@ -2512,11 +2523,6 @@</span> <span class="p_context"> enum emulation_result kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu,</span>
 		break;
 	}
 
<span class="p_del">-	if (vcpu-&gt;arch.pending_load_cause &amp; CAUSEF_BD)</span>
<span class="p_del">-		kvm_debug(&quot;[%#lx] Completing %d byte BD Load to gpr %d (0x%08lx) type %d\n&quot;,</span>
<span class="p_del">-			  vcpu-&gt;arch.pc, run-&gt;mmio.len, vcpu-&gt;arch.io_gpr, *gpr,</span>
<span class="p_del">-			  vcpu-&gt;mmio_needed);</span>
<span class="p_del">-</span>
 done:
 	return er;
 }
<span class="p_header">diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S</span>
<span class="p_header">index d03422e5f188..7ed036c57d00 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall.S</span>
<span class="p_chunk">@@ -106,8 +106,6 @@</span> <span class="p_context"> linux_gateway_entry:</span>
 	mtsp	%r0,%sr4			/* get kernel space into sr4 */
 	mtsp	%r0,%sr5			/* get kernel space into sr5 */
 	mtsp	%r0,%sr6			/* get kernel space into sr6 */
<span class="p_del">-	mfsp    %sr7,%r1                        /* save user sr7 */</span>
<span class="p_del">-	mtsp    %r1,%sr3                        /* and store it in sr3 */</span>
 
 #ifdef CONFIG_64BIT
 	/* for now we can *always* set the W bit on entry to the syscall
<span class="p_chunk">@@ -133,6 +131,14 @@</span> <span class="p_context"> linux_gateway_entry:</span>
 	depdi	0, 31, 32, %r21
 1:	
 #endif
<span class="p_add">+</span>
<span class="p_add">+	/* We use a rsm/ssm pair to prevent sr3 from being clobbered</span>
<span class="p_add">+	 * by external interrupts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mfsp    %sr7,%r1                        /* save user sr7 */</span>
<span class="p_add">+	rsm	PSW_SM_I, %r0			/* disable interrupts */</span>
<span class="p_add">+	mtsp    %r1,%sr3                        /* and store it in sr3 */</span>
<span class="p_add">+</span>
 	mfctl   %cr30,%r1
 	xor     %r1,%r30,%r30                   /* ye olde xor trick */
 	xor     %r1,%r30,%r1
<span class="p_chunk">@@ -147,6 +153,7 @@</span> <span class="p_context"> linux_gateway_entry:</span>
 	 */
 
 	mtsp	%r0,%sr7			/* get kernel space into sr7 */
<span class="p_add">+	ssm	PSW_SM_I, %r0			/* enable interrupts */</span>
 	STREGM	%r1,FRAME_SIZE(%r30)		/* save r1 (usp) here for now */
 	mfctl	%cr30,%r1			/* get task ptr in %r1 */
 	LDREG	TI_TASK(%r1),%r1
<span class="p_header">diff --git a/arch/powerpc/include/asm/cpuidle.h b/arch/powerpc/include/asm/cpuidle.h</span>
<span class="p_header">index 01b8a13f0224..3919332965af 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/cpuidle.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/cpuidle.h</span>
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"> extern u64 pnv_first_deep_stop_state;</span>
 	std	r0,0(r1);					\
 	ptesync;						\
 	ld	r0,0(r1);					\
<span class="p_del">-1:	cmp	cr0,r0,r0;					\</span>
<span class="p_add">+1:	cmpd	cr0,r0,r0;					\</span>
 	bne	1b;						\
 	IDLE_INST;						\
 	b	.
<span class="p_header">diff --git a/arch/powerpc/include/asm/tlb.h b/arch/powerpc/include/asm/tlb.h</span>
<span class="p_header">index f6f68f73e858..99e1397b71da 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/tlb.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/tlb.h</span>
<span class="p_chunk">@@ -52,11 +52,23 @@</span> <span class="p_context"> static inline int mm_is_core_local(struct mm_struct *mm)</span>
 	return cpumask_subset(mm_cpumask(mm),
 			      topology_sibling_cpumask(smp_processor_id()));
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int mm_is_thread_local(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return cpumask_equal(mm_cpumask(mm),</span>
<span class="p_add">+			      cpumask_of(smp_processor_id()));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #else
 static inline int mm_is_core_local(struct mm_struct *mm)
 {
 	return 1;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int mm_is_thread_local(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
 #endif
 
 #endif /* __KERNEL__ */
<span class="p_header">diff --git a/arch/powerpc/kernel/idle_book3s.S b/arch/powerpc/kernel/idle_book3s.S</span>
<span class="p_header">index bd739fed26e3..72dac0b58061 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/idle_book3s.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/idle_book3s.S</span>
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"> ALT_FTR_SECTION_END_IFSET(CPU_FTR_ARCH_300)</span>
  * Threads will spin in HMT_LOW until the lock bit is cleared.
  * r14 - pointer to core_idle_state
  * r15 - used to load contents of core_idle_state
<span class="p_add">+ * r9  - used as a temporary variable</span>
  */
 
 core_idle_lock_held:
<span class="p_chunk">@@ -99,6 +100,8 @@</span> <span class="p_context"> core_idle_lock_held:</span>
 	bne	3b
 	HMT_MEDIUM
 	lwarx	r15,0,r14
<span class="p_add">+	andi.	r9,r15,PNV_CORE_IDLE_LOCK_BIT</span>
<span class="p_add">+	bne	core_idle_lock_held</span>
 	blr
 
 /*
<span class="p_chunk">@@ -163,12 +166,6 @@</span> <span class="p_context"> _GLOBAL(pnv_powersave_common)</span>
 	std	r9,_MSR(r1)
 	std	r1,PACAR1(r13)
 
<span class="p_del">-#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE</span>
<span class="p_del">-	/* Tell KVM we&#39;re entering idle */</span>
<span class="p_del">-	li	r4,KVM_HWTHREAD_IN_IDLE</span>
<span class="p_del">-	stb	r4,HSTATE_HWTHREAD_STATE(r13)</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	/*
 	 * Go to real mode to do the nap, as required by the architecture.
 	 * Also, we need to be in real mode before setting hwthread_state,
<span class="p_chunk">@@ -185,6 +182,26 @@</span> <span class="p_context"> _GLOBAL(pnv_powersave_common)</span>
 
 	.globl pnv_enter_arch207_idle_mode
 pnv_enter_arch207_idle_mode:
<span class="p_add">+#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE</span>
<span class="p_add">+	/* Tell KVM we&#39;re entering idle */</span>
<span class="p_add">+	li	r4,KVM_HWTHREAD_IN_IDLE</span>
<span class="p_add">+	/******************************************************/</span>
<span class="p_add">+	/*  N O T E   W E L L    ! ! !    N O T E   W E L L   */</span>
<span class="p_add">+	/* The following store to HSTATE_HWTHREAD_STATE(r13)  */</span>
<span class="p_add">+	/* MUST occur in real mode, i.e. with the MMU off,    */</span>
<span class="p_add">+	/* and the MMU must stay off until we clear this flag */</span>
<span class="p_add">+	/* and test HSTATE_HWTHREAD_REQ(r13) in the system    */</span>
<span class="p_add">+	/* reset interrupt vector in exceptions-64s.S.        */</span>
<span class="p_add">+	/* The reason is that another thread can switch the   */</span>
<span class="p_add">+	/* MMU to a guest context whenever this flag is set   */</span>
<span class="p_add">+	/* to KVM_HWTHREAD_IN_IDLE, and if the MMU was on,    */</span>
<span class="p_add">+	/* that would potentially cause this thread to start  */</span>
<span class="p_add">+	/* executing instructions from guest memory in        */</span>
<span class="p_add">+	/* hypervisor mode, leading to a host crash or data   */</span>
<span class="p_add">+	/* corruption, or worse.                              */</span>
<span class="p_add">+	/******************************************************/</span>
<span class="p_add">+	stb	r4,HSTATE_HWTHREAD_STATE(r13)</span>
<span class="p_add">+#endif</span>
 	stb	r3,PACA_THREAD_IDLE_STATE(r13)
 	cmpwi	cr3,r3,PNV_THREAD_SLEEP
 	bge	cr3,2f
<span class="p_chunk">@@ -250,6 +267,12 @@</span> <span class="p_context"> enter_winkle:</span>
  * r3 - requested stop state
  */
 power_enter_stop:
<span class="p_add">+#ifdef CONFIG_KVM_BOOK3S_HV_POSSIBLE</span>
<span class="p_add">+	/* Tell KVM we&#39;re entering idle */</span>
<span class="p_add">+	li	r4,KVM_HWTHREAD_IN_IDLE</span>
<span class="p_add">+	/* DO THIS IN REAL MODE!  See comment above. */</span>
<span class="p_add">+	stb	r4,HSTATE_HWTHREAD_STATE(r13)</span>
<span class="p_add">+#endif</span>
 /*
  * Check if the requested state is a deep idle state.
  */
<span class="p_header">diff --git a/arch/powerpc/mm/tlb-radix.c b/arch/powerpc/mm/tlb-radix.c</span>
<span class="p_header">index 48df05ef5231..d6960681939a 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/tlb-radix.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/tlb-radix.c</span>
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"> void radix__flush_tlb_mm(struct mm_struct *mm)</span>
 	if (unlikely(pid == MMU_NO_CONTEXT))
 		goto no_context;
 
<span class="p_del">-	if (!mm_is_core_local(mm)) {</span>
<span class="p_add">+	if (!mm_is_thread_local(mm)) {</span>
 		int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
 
 		if (lock_tlbie)
<span class="p_chunk">@@ -201,7 +201,7 @@</span> <span class="p_context"> void radix__flush_tlb_pwc(struct mmu_gather *tlb, unsigned long addr)</span>
 	if (unlikely(pid == MMU_NO_CONTEXT))
 		goto no_context;
 
<span class="p_del">-	if (!mm_is_core_local(mm)) {</span>
<span class="p_add">+	if (!mm_is_thread_local(mm)) {</span>
 		int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
 
 		if (lock_tlbie)
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> void radix__flush_tlb_page_psize(struct mm_struct *mm, unsigned long vmaddr,</span>
 	pid = mm ? mm-&gt;context.id : 0;
 	if (unlikely(pid == MMU_NO_CONTEXT))
 		goto bail;
<span class="p_del">-	if (!mm_is_core_local(mm)) {</span>
<span class="p_add">+	if (!mm_is_thread_local(mm)) {</span>
 		int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
 
 		if (lock_tlbie)
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> void radix__flush_tlb_range_psize(struct mm_struct *mm, unsigned long start,</span>
 {
 	unsigned long pid;
 	unsigned long addr;
<span class="p_del">-	int local = mm_is_core_local(mm);</span>
<span class="p_add">+	int local = mm_is_thread_local(mm);</span>
 	unsigned long ap = mmu_get_ap(psize);
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
 	unsigned long page_size = 1UL &lt;&lt; mmu_psize_defs[psize].shift;
<span class="p_header">diff --git a/arch/s390/kvm/sthyi.c b/arch/s390/kvm/sthyi.c</span>
<span class="p_header">index bd98b7d25200..05c98bb853cf 100644</span>
<span class="p_header">--- a/arch/s390/kvm/sthyi.c</span>
<span class="p_header">+++ b/arch/s390/kvm/sthyi.c</span>
<span class="p_chunk">@@ -315,7 +315,7 @@</span> <span class="p_context"> static void fill_diag(struct sthyi_sctns *sctns)</span>
 	if (r &lt; 0)
 		goto out;
 
<span class="p_del">-	diag224_buf = kmalloc(PAGE_SIZE, GFP_KERNEL | GFP_DMA);</span>
<span class="p_add">+	diag224_buf = (void *)__get_free_page(GFP_KERNEL | GFP_DMA);</span>
 	if (!diag224_buf || diag224(diag224_buf))
 		goto out;
 
<span class="p_chunk">@@ -378,7 +378,7 @@</span> <span class="p_context"> static void fill_diag(struct sthyi_sctns *sctns)</span>
 	sctns-&gt;par.infpval1 |= PAR_WGHT_VLD;
 
 out:
<span class="p_del">-	kfree(diag224_buf);</span>
<span class="p_add">+	free_page((unsigned long)diag224_buf);</span>
 	vfree(diag204_buf);
 }
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd.c b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">index 620ab06bcf45..017bda12caae 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_chunk">@@ -429,7 +429,7 @@</span> <span class="p_context"> int __init save_microcode_in_initrd_amd(void)</span>
 	 * We need the physical address of the container for both bitness since
 	 * boot_params.hdr.ramdisk_image is a physical address.
 	 */
<span class="p_del">-	cont    = __pa(container);</span>
<span class="p_add">+	cont    = __pa_nodebug(container);</span>
 	cont_va = container;
 #endif
 
<span class="p_header">diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c</span>
<span class="p_header">index 98c9cd6f3b5d..d5219b1c8775 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup.c</span>
<span class="p_chunk">@@ -1222,11 +1222,16 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 	if (smp_found_config)
 		get_smp_config();
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Systems w/o ACPI and mptables might not have it mapped the local</span>
<span class="p_add">+	 * APIC yet, but prefill_possible_map() might need to access it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	init_apic_mappings();</span>
<span class="p_add">+</span>
 	prefill_possible_map();
 
 	init_cpu_to_node();
 
<span class="p_del">-	init_apic_mappings();</span>
 	io_apic_init_mappings();
 
 	kvm_guest_init();
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 4e95d3eb2955..cbd7b92585bb 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -5045,7 +5045,7 @@</span> <span class="p_context"> done_prefixes:</span>
 	/* Decode and fetch the destination operand: register or memory. */
 	rc = decode_operand(ctxt, &amp;ctxt-&gt;dst, (ctxt-&gt;d &gt;&gt; DstShift) &amp; OpMask);
 
<span class="p_del">-	if (ctxt-&gt;rip_relative)</span>
<span class="p_add">+	if (ctxt-&gt;rip_relative &amp;&amp; likely(ctxt-&gt;memopp))</span>
 		ctxt-&gt;memopp-&gt;addr.mem.ea = address_mask(ctxt,
 					ctxt-&gt;memopp-&gt;addr.mem.ea + ctxt-&gt;_eip);
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 699f8726539a..46f74d461f3f 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -7372,10 +7372,12 @@</span> <span class="p_context"> void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)</span>
 
 void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	void *wbinvd_dirty_mask = vcpu-&gt;arch.wbinvd_dirty_mask;</span>
<span class="p_add">+</span>
 	kvmclock_reset(vcpu);
 
<span class="p_del">-	free_cpumask_var(vcpu-&gt;arch.wbinvd_dirty_mask);</span>
 	kvm_x86_ops-&gt;vcpu_free(vcpu);
<span class="p_add">+	free_cpumask_var(wbinvd_dirty_mask);</span>
 }
 
 struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
<span class="p_header">diff --git a/drivers/android/binder.c b/drivers/android/binder.c</span>
<span class="p_header">index 16288e777ec3..4b1e4eabeba4 100644</span>
<span class="p_header">--- a/drivers/android/binder.c</span>
<span class="p_header">+++ b/drivers/android/binder.c</span>
<span class="p_chunk">@@ -1003,7 +1003,7 @@</span> <span class="p_context"> static int binder_dec_node(struct binder_node *node, int strong, int internal)</span>
 
 
 static struct binder_ref *binder_get_ref(struct binder_proc *proc,
<span class="p_del">-					 uint32_t desc)</span>
<span class="p_add">+					 u32 desc, bool need_strong_ref)</span>
 {
 	struct rb_node *n = proc-&gt;refs_by_desc.rb_node;
 	struct binder_ref *ref;
<span class="p_chunk">@@ -1011,12 +1011,16 @@</span> <span class="p_context"> static struct binder_ref *binder_get_ref(struct binder_proc *proc,</span>
 	while (n) {
 		ref = rb_entry(n, struct binder_ref, rb_node_desc);
 
<span class="p_del">-		if (desc &lt; ref-&gt;desc)</span>
<span class="p_add">+		if (desc &lt; ref-&gt;desc) {</span>
 			n = n-&gt;rb_left;
<span class="p_del">-		else if (desc &gt; ref-&gt;desc)</span>
<span class="p_add">+		} else if (desc &gt; ref-&gt;desc) {</span>
 			n = n-&gt;rb_right;
<span class="p_del">-		else</span>
<span class="p_add">+		} else if (need_strong_ref &amp;&amp; !ref-&gt;strong) {</span>
<span class="p_add">+			binder_user_error(&quot;tried to use weak ref as strong ref\n&quot;);</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		} else {</span>
 			return ref;
<span class="p_add">+		}</span>
 	}
 	return NULL;
 }
<span class="p_chunk">@@ -1286,7 +1290,10 @@</span> <span class="p_context"> static void binder_transaction_buffer_release(struct binder_proc *proc,</span>
 		} break;
 		case BINDER_TYPE_HANDLE:
 		case BINDER_TYPE_WEAK_HANDLE: {
<span class="p_del">-			struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span>
<span class="p_add">+			struct binder_ref *ref;</span>
<span class="p_add">+</span>
<span class="p_add">+			ref = binder_get_ref(proc, fp-&gt;handle,</span>
<span class="p_add">+					     fp-&gt;type == BINDER_TYPE_HANDLE);</span>
 
 			if (ref == NULL) {
 				pr_err(&quot;transaction release %d bad handle %d\n&quot;,
<span class="p_chunk">@@ -1381,7 +1388,7 @@</span> <span class="p_context"> static void binder_transaction(struct binder_proc *proc,</span>
 		if (tr-&gt;target.handle) {
 			struct binder_ref *ref;
 
<span class="p_del">-			ref = binder_get_ref(proc, tr-&gt;target.handle);</span>
<span class="p_add">+			ref = binder_get_ref(proc, tr-&gt;target.handle, true);</span>
 			if (ref == NULL) {
 				binder_user_error(&quot;%d:%d got transaction to invalid handle\n&quot;,
 					proc-&gt;pid, thread-&gt;pid);
<span class="p_chunk">@@ -1578,7 +1585,9 @@</span> <span class="p_context"> static void binder_transaction(struct binder_proc *proc,</span>
 				fp-&gt;type = BINDER_TYPE_HANDLE;
 			else
 				fp-&gt;type = BINDER_TYPE_WEAK_HANDLE;
<span class="p_add">+			fp-&gt;binder = 0;</span>
 			fp-&gt;handle = ref-&gt;desc;
<span class="p_add">+			fp-&gt;cookie = 0;</span>
 			binder_inc_ref(ref, fp-&gt;type == BINDER_TYPE_HANDLE,
 				       &amp;thread-&gt;todo);
 
<span class="p_chunk">@@ -1590,7 +1599,10 @@</span> <span class="p_context"> static void binder_transaction(struct binder_proc *proc,</span>
 		} break;
 		case BINDER_TYPE_HANDLE:
 		case BINDER_TYPE_WEAK_HANDLE: {
<span class="p_del">-			struct binder_ref *ref = binder_get_ref(proc, fp-&gt;handle);</span>
<span class="p_add">+			struct binder_ref *ref;</span>
<span class="p_add">+</span>
<span class="p_add">+			ref = binder_get_ref(proc, fp-&gt;handle,</span>
<span class="p_add">+					     fp-&gt;type == BINDER_TYPE_HANDLE);</span>
 
 			if (ref == NULL) {
 				binder_user_error(&quot;%d:%d got transaction with invalid handle, %d\n&quot;,
<span class="p_chunk">@@ -1625,7 +1637,9 @@</span> <span class="p_context"> static void binder_transaction(struct binder_proc *proc,</span>
 					return_error = BR_FAILED_REPLY;
 					goto err_binder_get_ref_for_node_failed;
 				}
<span class="p_add">+				fp-&gt;binder = 0;</span>
 				fp-&gt;handle = new_ref-&gt;desc;
<span class="p_add">+				fp-&gt;cookie = 0;</span>
 				binder_inc_ref(new_ref, fp-&gt;type == BINDER_TYPE_HANDLE, NULL);
 				trace_binder_transaction_ref_to_ref(t, ref,
 								    new_ref);
<span class="p_chunk">@@ -1679,6 +1693,7 @@</span> <span class="p_context"> static void binder_transaction(struct binder_proc *proc,</span>
 			binder_debug(BINDER_DEBUG_TRANSACTION,
 				     &quot;        fd %d -&gt; %d\n&quot;, fp-&gt;handle, target_fd);
 			/* TODO: fput? */
<span class="p_add">+			fp-&gt;binder = 0;</span>
 			fp-&gt;handle = target_fd;
 		} break;
 
<span class="p_chunk">@@ -1801,7 +1816,9 @@</span> <span class="p_context"> static int binder_thread_write(struct binder_proc *proc,</span>
 						ref-&gt;desc);
 				}
 			} else
<span class="p_del">-				ref = binder_get_ref(proc, target);</span>
<span class="p_add">+				ref = binder_get_ref(proc, target,</span>
<span class="p_add">+						     cmd == BC_ACQUIRE ||</span>
<span class="p_add">+						     cmd == BC_RELEASE);</span>
 			if (ref == NULL) {
 				binder_user_error(&quot;%d:%d refcount change on invalid ref %d\n&quot;,
 					proc-&gt;pid, thread-&gt;pid, target);
<span class="p_chunk">@@ -1997,7 +2014,7 @@</span> <span class="p_context"> static int binder_thread_write(struct binder_proc *proc,</span>
 			if (get_user(cookie, (binder_uintptr_t __user *)ptr))
 				return -EFAULT;
 			ptr += sizeof(binder_uintptr_t);
<span class="p_del">-			ref = binder_get_ref(proc, target);</span>
<span class="p_add">+			ref = binder_get_ref(proc, target, false);</span>
 			if (ref == NULL) {
 				binder_user_error(&quot;%d:%d %s invalid ref %d\n&quot;,
 					proc-&gt;pid, thread-&gt;pid,
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index 5da47e26a012..4aae0d27e382 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -1540,19 +1540,29 @@</span> <span class="p_context"> static void remove_port_data(struct port *port)</span>
 	spin_lock_irq(&amp;port-&gt;inbuf_lock);
 	/* Remove unused data this port might have received. */
 	discard_port_data(port);
<span class="p_add">+	spin_unlock_irq(&amp;port-&gt;inbuf_lock);</span>
 
 	/* Remove buffers we queued up for the Host to send us data in. */
<span class="p_del">-	while ((buf = virtqueue_detach_unused_buf(port-&gt;in_vq)))</span>
<span class="p_del">-		free_buf(buf, true);</span>
<span class="p_del">-	spin_unlock_irq(&amp;port-&gt;inbuf_lock);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		spin_lock_irq(&amp;port-&gt;inbuf_lock);</span>
<span class="p_add">+		buf = virtqueue_detach_unused_buf(port-&gt;in_vq);</span>
<span class="p_add">+		spin_unlock_irq(&amp;port-&gt;inbuf_lock);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			free_buf(buf, true);</span>
<span class="p_add">+	} while (buf);</span>
 
 	spin_lock_irq(&amp;port-&gt;outvq_lock);
 	reclaim_consumed_buffers(port);
<span class="p_add">+	spin_unlock_irq(&amp;port-&gt;outvq_lock);</span>
 
 	/* Free pending buffers from the out-queue. */
<span class="p_del">-	while ((buf = virtqueue_detach_unused_buf(port-&gt;out_vq)))</span>
<span class="p_del">-		free_buf(buf, true);</span>
<span class="p_del">-	spin_unlock_irq(&amp;port-&gt;outvq_lock);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		spin_lock_irq(&amp;port-&gt;outvq_lock);</span>
<span class="p_add">+		buf = virtqueue_detach_unused_buf(port-&gt;out_vq);</span>
<span class="p_add">+		spin_unlock_irq(&amp;port-&gt;outvq_lock);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			free_buf(buf, true);</span>
<span class="p_add">+	} while (buf);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index b46547e907be..8c347f5c2562 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -1133,10 +1133,8 @@</span> <span class="p_context"> static void intel_pstate_get_min_max(struct cpudata *cpu, int *min, int *max)</span>
 	*min = clamp_t(int, min_perf, cpu-&gt;pstate.min_pstate, max_perf);
 }
 
<span class="p_del">-static void intel_pstate_set_min_pstate(struct cpudata *cpu)</span>
<span class="p_add">+static void intel_pstate_set_pstate(struct cpudata *cpu, int pstate)</span>
 {
<span class="p_del">-	int pstate = cpu-&gt;pstate.min_pstate;</span>
<span class="p_del">-</span>
 	trace_cpu_frequency(pstate * cpu-&gt;pstate.scaling, cpu-&gt;cpu);
 	cpu-&gt;pstate.current_pstate = pstate;
 	/*
<span class="p_chunk">@@ -1148,6 +1146,20 @@</span> <span class="p_context"> static void intel_pstate_set_min_pstate(struct cpudata *cpu)</span>
 		      pstate_funcs.get_val(cpu, pstate));
 }
 
<span class="p_add">+static void intel_pstate_set_min_pstate(struct cpudata *cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	intel_pstate_set_pstate(cpu, cpu-&gt;pstate.min_pstate);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void intel_pstate_max_within_limits(struct cpudata *cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int min_pstate, max_pstate;</span>
<span class="p_add">+</span>
<span class="p_add">+	update_turbo_state();</span>
<span class="p_add">+	intel_pstate_get_min_max(cpu, &amp;min_pstate, &amp;max_pstate);</span>
<span class="p_add">+	intel_pstate_set_pstate(cpu, max_pstate);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void intel_pstate_get_cpu_pstates(struct cpudata *cpu)
 {
 	cpu-&gt;pstate.min_pstate = pstate_funcs.get_min();
<span class="p_chunk">@@ -1465,7 +1477,7 @@</span> <span class="p_context"> static int intel_pstate_set_policy(struct cpufreq_policy *policy)</span>
 	pr_debug(&quot;set_policy cpuinfo.max %u policy-&gt;max %u\n&quot;,
 		 policy-&gt;cpuinfo.max_freq, policy-&gt;max);
 
<span class="p_del">-	cpu = all_cpu_data[0];</span>
<span class="p_add">+	cpu = all_cpu_data[policy-&gt;cpu];</span>
 	if (cpu-&gt;pstate.max_pstate_physical &gt; cpu-&gt;pstate.max_pstate &amp;&amp;
 	    policy-&gt;max &lt; policy-&gt;cpuinfo.max_freq &amp;&amp;
 	    policy-&gt;max &gt; cpu-&gt;pstate.max_pstate * cpu-&gt;pstate.scaling) {
<span class="p_chunk">@@ -1509,6 +1521,15 @@</span> <span class="p_context"> static int intel_pstate_set_policy(struct cpufreq_policy *policy)</span>
 	limits-&gt;max_perf = round_up(limits-&gt;max_perf, FRAC_BITS);
 
  out:
<span class="p_add">+	if (policy-&gt;policy == CPUFREQ_POLICY_PERFORMANCE) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * NOHZ_FULL CPUs need this as the governor callback may not</span>
<span class="p_add">+		 * be invoked on them.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		intel_pstate_clear_update_util_hook(policy-&gt;cpu);</span>
<span class="p_add">+		intel_pstate_max_within_limits(cpu);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	intel_pstate_set_update_util_hook(policy-&gt;cpu);
 
 	intel_pstate_hwp_set_policy(policy);
<span class="p_header">diff --git a/drivers/dax/pmem.c b/drivers/dax/pmem.c</span>
<span class="p_header">index 1f01e98c83c7..73ae849f5170 100644</span>
<span class="p_header">--- a/drivers/dax/pmem.c</span>
<span class="p_header">+++ b/drivers/dax/pmem.c</span>
<span class="p_chunk">@@ -44,7 +44,6 @@</span> <span class="p_context"> static void dax_pmem_percpu_exit(void *data)</span>
 
 	dev_dbg(dax_pmem-&gt;dev, &quot;%s\n&quot;, __func__);
 	percpu_ref_exit(ref);
<span class="p_del">-	wait_for_completion(&amp;dax_pmem-&gt;cmp);</span>
 }
 
 static void dax_pmem_percpu_kill(void *data)
<span class="p_chunk">@@ -54,6 +53,7 @@</span> <span class="p_context"> static void dax_pmem_percpu_kill(void *data)</span>
 
 	dev_dbg(dax_pmem-&gt;dev, &quot;%s\n&quot;, __func__);
 	percpu_ref_kill(ref);
<span class="p_add">+	wait_for_completion(&amp;dax_pmem-&gt;cmp);</span>
 }
 
 static int dax_pmem_probe(struct device *dev)
<span class="p_header">diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c</span>
<span class="p_header">index 309311b1faae..15475892af0c 100644</span>
<span class="p_header">--- a/drivers/firewire/net.c</span>
<span class="p_header">+++ b/drivers/firewire/net.c</span>
<span class="p_chunk">@@ -73,13 +73,13 @@</span> <span class="p_context"> struct rfc2734_header {</span>
 
 #define fwnet_get_hdr_lf(h)		(((h)-&gt;w0 &amp; 0xc0000000) &gt;&gt; 30)
 #define fwnet_get_hdr_ether_type(h)	(((h)-&gt;w0 &amp; 0x0000ffff))
<span class="p_del">-#define fwnet_get_hdr_dg_size(h)	(((h)-&gt;w0 &amp; 0x0fff0000) &gt;&gt; 16)</span>
<span class="p_add">+#define fwnet_get_hdr_dg_size(h)	((((h)-&gt;w0 &amp; 0x0fff0000) &gt;&gt; 16) + 1)</span>
 #define fwnet_get_hdr_fg_off(h)		(((h)-&gt;w0 &amp; 0x00000fff))
 #define fwnet_get_hdr_dgl(h)		(((h)-&gt;w1 &amp; 0xffff0000) &gt;&gt; 16)
 
<span class="p_del">-#define fwnet_set_hdr_lf(lf)		((lf)  &lt;&lt; 30)</span>
<span class="p_add">+#define fwnet_set_hdr_lf(lf)		((lf) &lt;&lt; 30)</span>
 #define fwnet_set_hdr_ether_type(et)	(et)
<span class="p_del">-#define fwnet_set_hdr_dg_size(dgs)	((dgs) &lt;&lt; 16)</span>
<span class="p_add">+#define fwnet_set_hdr_dg_size(dgs)	(((dgs) - 1) &lt;&lt; 16)</span>
 #define fwnet_set_hdr_fg_off(fgo)	(fgo)
 
 #define fwnet_set_hdr_dgl(dgl)		((dgl) &lt;&lt; 16)
<span class="p_chunk">@@ -578,6 +578,9 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 	int retval;
 	u16 ether_type;
 
<span class="p_add">+	if (len &lt;= RFC2374_UNFRAG_HDR_SIZE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	hdr.w0 = be32_to_cpu(buf[0]);
 	lf = fwnet_get_hdr_lf(&amp;hdr);
 	if (lf == RFC2374_HDR_UNFRAG) {
<span class="p_chunk">@@ -602,7 +605,12 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 		return fwnet_finish_incoming_packet(net, skb, source_node_id,
 						    is_broadcast, ether_type);
 	}
<span class="p_add">+</span>
 	/* A datagram fragment has been received, now the fun begins. */
<span class="p_add">+</span>
<span class="p_add">+	if (len &lt;= RFC2374_FRAG_HDR_SIZE)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	hdr.w1 = ntohl(buf[1]);
 	buf += 2;
 	len -= RFC2374_FRAG_HDR_SIZE;
<span class="p_chunk">@@ -614,7 +622,10 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 		fg_off = fwnet_get_hdr_fg_off(&amp;hdr);
 	}
 	datagram_label = fwnet_get_hdr_dgl(&amp;hdr);
<span class="p_del">-	dg_size = fwnet_get_hdr_dg_size(&amp;hdr); /* ??? + 1 */</span>
<span class="p_add">+	dg_size = fwnet_get_hdr_dg_size(&amp;hdr);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fg_off + len &gt; dg_size)</span>
<span class="p_add">+		return 0;</span>
 
 	spin_lock_irqsave(&amp;dev-&gt;lock, flags);
 
<span class="p_chunk">@@ -722,6 +733,22 @@</span> <span class="p_context"> static void fwnet_receive_packet(struct fw_card *card, struct fw_request *r,</span>
 	fw_send_response(card, r, rcode);
 }
 
<span class="p_add">+static int gasp_source_id(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(p[0]) &gt;&gt; 16;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 gasp_specifier_id(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (be32_to_cpu(p[0]) &amp; 0xffff) &lt;&lt; 8 |</span>
<span class="p_add">+	       (be32_to_cpu(p[1]) &amp; 0xff000000) &gt;&gt; 24;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 gasp_version(__be32 *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(p[1]) &amp; 0xffffff;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void fwnet_receive_broadcast(struct fw_iso_context *context,
 		u32 cycle, size_t header_length, void *header, void *data)
 {
<span class="p_chunk">@@ -731,9 +758,6 @@</span> <span class="p_context"> static void fwnet_receive_broadcast(struct fw_iso_context *context,</span>
 	__be32 *buf_ptr;
 	int retval;
 	u32 length;
<span class="p_del">-	u16 source_node_id;</span>
<span class="p_del">-	u32 specifier_id;</span>
<span class="p_del">-	u32 ver;</span>
 	unsigned long offset;
 	unsigned long flags;
 
<span class="p_chunk">@@ -750,22 +774,17 @@</span> <span class="p_context"> static void fwnet_receive_broadcast(struct fw_iso_context *context,</span>
 
 	spin_unlock_irqrestore(&amp;dev-&gt;lock, flags);
 
<span class="p_del">-	specifier_id =    (be32_to_cpu(buf_ptr[0]) &amp; 0xffff) &lt;&lt; 8</span>
<span class="p_del">-			| (be32_to_cpu(buf_ptr[1]) &amp; 0xff000000) &gt;&gt; 24;</span>
<span class="p_del">-	ver = be32_to_cpu(buf_ptr[1]) &amp; 0xffffff;</span>
<span class="p_del">-	source_node_id = be32_to_cpu(buf_ptr[0]) &gt;&gt; 16;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (specifier_id == IANA_SPECIFIER_ID &amp;&amp;</span>
<span class="p_del">-	    (ver == RFC2734_SW_VERSION</span>
<span class="p_add">+	if (length &gt; IEEE1394_GASP_HDR_SIZE &amp;&amp;</span>
<span class="p_add">+	    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &amp;&amp;</span>
<span class="p_add">+	    (gasp_version(buf_ptr) == RFC2734_SW_VERSION</span>
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_del">-	     || ver == RFC3146_SW_VERSION</span>
<span class="p_add">+	     || gasp_version(buf_ptr) == RFC3146_SW_VERSION</span>
 #endif
<span class="p_del">-	    )) {</span>
<span class="p_del">-		buf_ptr += 2;</span>
<span class="p_del">-		length -= IEEE1394_GASP_HDR_SIZE;</span>
<span class="p_del">-		fwnet_incoming_packet(dev, buf_ptr, length, source_node_id,</span>
<span class="p_add">+	    ))</span>
<span class="p_add">+		fwnet_incoming_packet(dev, buf_ptr + 2,</span>
<span class="p_add">+				      length - IEEE1394_GASP_HDR_SIZE,</span>
<span class="p_add">+				      gasp_source_id(buf_ptr),</span>
 				      context-&gt;card-&gt;generation, true);
<span class="p_del">-	}</span>
 
 	packet.payload_length = dev-&gt;rcv_buffer_size;
 	packet.interrupt = 1;
<span class="p_header">diff --git a/drivers/gpio/gpiolib-acpi.c b/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_header">index af514618d7fb..14f2d9835723 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib-acpi.c</span>
<span class="p_chunk">@@ -602,14 +602,17 @@</span> <span class="p_context"> int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)</span>
 {
 	int idx, i;
 	unsigned int irq_flags;
<span class="p_add">+	int ret = -ENOENT;</span>
 
 	for (i = 0, idx = 0; idx &lt;= index; i++) {
 		struct acpi_gpio_info info;
 		struct gpio_desc *desc;
 
 		desc = acpi_get_gpiod_by_index(adev, NULL, i, &amp;info);
<span class="p_del">-		if (IS_ERR(desc))</span>
<span class="p_add">+		if (IS_ERR(desc)) {</span>
<span class="p_add">+			ret = PTR_ERR(desc);</span>
 			break;
<span class="p_add">+		}</span>
 		if (info.gpioint &amp;&amp; idx++ == index) {
 			int irq = gpiod_to_irq(desc);
 
<span class="p_chunk">@@ -628,7 +631,7 @@</span> <span class="p_context"> int acpi_dev_gpio_irq_get(struct acpi_device *adev, int index)</span>
 		}
 
 	}
<span class="p_del">-	return -ENOENT;</span>
<span class="p_add">+	return ret;</span>
 }
 EXPORT_SYMBOL_GPL(acpi_dev_gpio_irq_get);
 
<span class="p_header">diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c</span>
<span class="p_header">index 53ff25ac66d8..b2dee1024166 100644</span>
<span class="p_header">--- a/drivers/gpio/gpiolib.c</span>
<span class="p_header">+++ b/drivers/gpio/gpiolib.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/anon_inodes.h&gt;
<span class="p_add">+#include &lt;linux/file.h&gt;</span>
 #include &lt;linux/kfifo.h&gt;
 #include &lt;linux/poll.h&gt;
 #include &lt;linux/timekeeping.h&gt;
<span class="p_chunk">@@ -331,6 +332,13 @@</span> <span class="p_context"> struct linehandle_state {</span>
 	u32 numdescs;
 };
 
<span class="p_add">+#define GPIOHANDLE_REQUEST_VALID_FLAGS \</span>
<span class="p_add">+	(GPIOHANDLE_REQUEST_INPUT | \</span>
<span class="p_add">+	GPIOHANDLE_REQUEST_OUTPUT | \</span>
<span class="p_add">+	GPIOHANDLE_REQUEST_ACTIVE_LOW | \</span>
<span class="p_add">+	GPIOHANDLE_REQUEST_OPEN_DRAIN | \</span>
<span class="p_add">+	GPIOHANDLE_REQUEST_OPEN_SOURCE)</span>
<span class="p_add">+</span>
 static long linehandle_ioctl(struct file *filep, unsigned int cmd,
 			     unsigned long arg)
 {
<span class="p_chunk">@@ -342,6 +350,8 @@</span> <span class="p_context"> static long linehandle_ioctl(struct file *filep, unsigned int cmd,</span>
 	if (cmd == GPIOHANDLE_GET_LINE_VALUES_IOCTL) {
 		int val;
 
<span class="p_add">+		memset(&amp;ghd, 0, sizeof(ghd));</span>
<span class="p_add">+</span>
 		/* TODO: check if descriptors are really input */
 		for (i = 0; i &lt; lh-&gt;numdescs; i++) {
 			val = gpiod_get_value_cansleep(lh-&gt;descs[i]);
<span class="p_chunk">@@ -412,6 +422,7 @@</span> <span class="p_context"> static int linehandle_create(struct gpio_device *gdev, void __user *ip)</span>
 {
 	struct gpiohandle_request handlereq;
 	struct linehandle_state *lh;
<span class="p_add">+	struct file *file;</span>
 	int fd, i, ret;
 
 	if (copy_from_user(&amp;handlereq, ip, sizeof(handlereq)))
<span class="p_chunk">@@ -442,6 +453,17 @@</span> <span class="p_context"> static int linehandle_create(struct gpio_device *gdev, void __user *ip)</span>
 		u32 lflags = handlereq.flags;
 		struct gpio_desc *desc;
 
<span class="p_add">+		if (offset &gt;= gdev-&gt;ngpio) {</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto out_free_descs;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Return an error if a unknown flag is set */</span>
<span class="p_add">+		if (lflags &amp; ~GPIOHANDLE_REQUEST_VALID_FLAGS) {</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto out_free_descs;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		desc = &amp;gdev-&gt;descs[offset];
 		ret = gpiod_request(desc, lh-&gt;label);
 		if (ret)
<span class="p_chunk">@@ -477,26 +499,41 @@</span> <span class="p_context"> static int linehandle_create(struct gpio_device *gdev, void __user *ip)</span>
 	i--;
 	lh-&gt;numdescs = handlereq.lines;
 
<span class="p_del">-	fd = anon_inode_getfd(&quot;gpio-linehandle&quot;,</span>
<span class="p_del">-			      &amp;linehandle_fileops,</span>
<span class="p_del">-			      lh,</span>
<span class="p_del">-			      O_RDONLY | O_CLOEXEC);</span>
<span class="p_add">+	fd = get_unused_fd_flags(O_RDONLY | O_CLOEXEC);</span>
 	if (fd &lt; 0) {
 		ret = fd;
 		goto out_free_descs;
 	}
 
<span class="p_add">+	file = anon_inode_getfile(&quot;gpio-linehandle&quot;,</span>
<span class="p_add">+				  &amp;linehandle_fileops,</span>
<span class="p_add">+				  lh,</span>
<span class="p_add">+				  O_RDONLY | O_CLOEXEC);</span>
<span class="p_add">+	if (IS_ERR(file)) {</span>
<span class="p_add">+		ret = PTR_ERR(file);</span>
<span class="p_add">+		goto out_put_unused_fd;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	handlereq.fd = fd;
 	if (copy_to_user(ip, &amp;handlereq, sizeof(handlereq))) {
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto out_free_descs;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * fput() will trigger the release() callback, so do not go onto</span>
<span class="p_add">+		 * the regular error cleanup path here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		fput(file);</span>
<span class="p_add">+		put_unused_fd(fd);</span>
<span class="p_add">+		return -EFAULT;</span>
 	}
 
<span class="p_add">+	fd_install(fd, file);</span>
<span class="p_add">+</span>
 	dev_dbg(&amp;gdev-&gt;dev, &quot;registered chardev handle for %d lines\n&quot;,
 		lh-&gt;numdescs);
 
 	return 0;
 
<span class="p_add">+out_put_unused_fd:</span>
<span class="p_add">+	put_unused_fd(fd);</span>
 out_free_descs:
 	for (; i &gt;= 0; i--)
 		gpiod_free(lh-&gt;descs[i]);
<span class="p_chunk">@@ -534,6 +571,10 @@</span> <span class="p_context"> struct lineevent_state {</span>
 	struct mutex read_lock;
 };
 
<span class="p_add">+#define GPIOEVENT_REQUEST_VALID_FLAGS \</span>
<span class="p_add">+	(GPIOEVENT_REQUEST_RISING_EDGE | \</span>
<span class="p_add">+	GPIOEVENT_REQUEST_FALLING_EDGE)</span>
<span class="p_add">+</span>
 static unsigned int lineevent_poll(struct file *filep,
 				   struct poll_table_struct *wait)
 {
<span class="p_chunk">@@ -621,6 +662,8 @@</span> <span class="p_context"> static long lineevent_ioctl(struct file *filep, unsigned int cmd,</span>
 	if (cmd == GPIOHANDLE_GET_LINE_VALUES_IOCTL) {
 		int val;
 
<span class="p_add">+		memset(&amp;ghd, 0, sizeof(ghd));</span>
<span class="p_add">+</span>
 		val = gpiod_get_value_cansleep(le-&gt;desc);
 		if (val &lt; 0)
 			return val;
<span class="p_chunk">@@ -693,6 +736,7 @@</span> <span class="p_context"> static int lineevent_create(struct gpio_device *gdev, void __user *ip)</span>
 	struct gpioevent_request eventreq;
 	struct lineevent_state *le;
 	struct gpio_desc *desc;
<span class="p_add">+	struct file *file;</span>
 	u32 offset;
 	u32 lflags;
 	u32 eflags;
<span class="p_chunk">@@ -724,6 +768,18 @@</span> <span class="p_context"> static int lineevent_create(struct gpio_device *gdev, void __user *ip)</span>
 	lflags = eventreq.handleflags;
 	eflags = eventreq.eventflags;
 
<span class="p_add">+	if (offset &gt;= gdev-&gt;ngpio) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out_free_label;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Return an error if a unknown flag is set */</span>
<span class="p_add">+	if ((lflags &amp; ~GPIOHANDLE_REQUEST_VALID_FLAGS) ||</span>
<span class="p_add">+	    (eflags &amp; ~GPIOEVENT_REQUEST_VALID_FLAGS)) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out_free_label;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* This is just wrong: we don&#39;t look for events on output lines */
 	if (lflags &amp; GPIOHANDLE_REQUEST_OUTPUT) {
 		ret = -EINVAL;
<span class="p_chunk">@@ -775,23 +831,38 @@</span> <span class="p_context"> static int lineevent_create(struct gpio_device *gdev, void __user *ip)</span>
 	if (ret)
 		goto out_free_desc;
 
<span class="p_del">-	fd = anon_inode_getfd(&quot;gpio-event&quot;,</span>
<span class="p_del">-			      &amp;lineevent_fileops,</span>
<span class="p_del">-			      le,</span>
<span class="p_del">-			      O_RDONLY | O_CLOEXEC);</span>
<span class="p_add">+	fd = get_unused_fd_flags(O_RDONLY | O_CLOEXEC);</span>
 	if (fd &lt; 0) {
 		ret = fd;
 		goto out_free_irq;
 	}
 
<span class="p_add">+	file = anon_inode_getfile(&quot;gpio-event&quot;,</span>
<span class="p_add">+				  &amp;lineevent_fileops,</span>
<span class="p_add">+				  le,</span>
<span class="p_add">+				  O_RDONLY | O_CLOEXEC);</span>
<span class="p_add">+	if (IS_ERR(file)) {</span>
<span class="p_add">+		ret = PTR_ERR(file);</span>
<span class="p_add">+		goto out_put_unused_fd;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	eventreq.fd = fd;
 	if (copy_to_user(ip, &amp;eventreq, sizeof(eventreq))) {
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto out_free_irq;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * fput() will trigger the release() callback, so do not go onto</span>
<span class="p_add">+		 * the regular error cleanup path here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		fput(file);</span>
<span class="p_add">+		put_unused_fd(fd);</span>
<span class="p_add">+		return -EFAULT;</span>
 	}
 
<span class="p_add">+	fd_install(fd, file);</span>
<span class="p_add">+</span>
 	return 0;
 
<span class="p_add">+out_put_unused_fd:</span>
<span class="p_add">+	put_unused_fd(fd);</span>
 out_free_irq:
 	free_irq(le-&gt;irq, le);
 out_free_desc:
<span class="p_chunk">@@ -821,6 +892,8 @@</span> <span class="p_context"> static long gpio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span>
 	if (cmd == GPIO_GET_CHIPINFO_IOCTL) {
 		struct gpiochip_info chipinfo;
 
<span class="p_add">+		memset(&amp;chipinfo, 0, sizeof(chipinfo));</span>
<span class="p_add">+</span>
 		strncpy(chipinfo.name, dev_name(&amp;gdev-&gt;dev),
 			sizeof(chipinfo.name));
 		chipinfo.name[sizeof(chipinfo.name)-1] = &#39;\0&#39;;
<span class="p_chunk">@@ -837,7 +910,7 @@</span> <span class="p_context"> static long gpio_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span>
 
 		if (copy_from_user(&amp;lineinfo, ip, sizeof(lineinfo)))
 			return -EFAULT;
<span class="p_del">-		if (lineinfo.line_offset &gt; gdev-&gt;ngpio)</span>
<span class="p_add">+		if (lineinfo.line_offset &gt;= gdev-&gt;ngpio)</span>
 			return -EINVAL;
 
 		desc = &amp;gdev-&gt;descs[lineinfo.line_offset];
<span class="p_header">diff --git a/drivers/gpu/drm/drm_atomic.c b/drivers/gpu/drm/drm_atomic.c</span>
<span class="p_header">index 2a3ded44cf2a..7c8c185c90ea 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_atomic.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_atomic.c</span>
<span class="p_chunk">@@ -420,18 +420,21 @@</span> <span class="p_context"> drm_atomic_replace_property_blob_from_id(struct drm_crtc *crtc,</span>
 					 ssize_t expected_size,
 					 bool *replaced)
 {
<span class="p_del">-	struct drm_device *dev = crtc-&gt;dev;</span>
 	struct drm_property_blob *new_blob = NULL;
 
 	if (blob_id != 0) {
<span class="p_del">-		new_blob = drm_property_lookup_blob(dev, blob_id);</span>
<span class="p_add">+		new_blob = drm_property_lookup_blob(crtc-&gt;dev, blob_id);</span>
 		if (new_blob == NULL)
 			return -EINVAL;
<span class="p_del">-		if (expected_size &gt; 0 &amp;&amp; expected_size != new_blob-&gt;length)</span>
<span class="p_add">+</span>
<span class="p_add">+		if (expected_size &gt; 0 &amp;&amp; expected_size != new_blob-&gt;length) {</span>
<span class="p_add">+			drm_property_unreference_blob(new_blob);</span>
 			return -EINVAL;
<span class="p_add">+		}</span>
 	}
 
 	drm_atomic_replace_property_blob(blob, new_blob, replaced);
<span class="p_add">+	drm_property_unreference_blob(new_blob);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 04e457117980..aa644487749c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -914,6 +914,7 @@</span> <span class="p_context"> static void drm_dp_destroy_port(struct kref *kref)</span>
 		/* no need to clean up vcpi
 		 * as if we have no connector we never setup a vcpi */
 		drm_dp_port_teardown_pdt(port, port-&gt;pdt);
<span class="p_add">+		port-&gt;pdt = DP_PEER_DEVICE_NONE;</span>
 	}
 	kfree(port);
 }
<span class="p_chunk">@@ -1159,7 +1160,9 @@</span> <span class="p_context"> static void drm_dp_add_port(struct drm_dp_mst_branch *mstb,</span>
 			drm_dp_put_port(port);
 			goto out;
 		}
<span class="p_del">-		if (port-&gt;port_num &gt;= DP_MST_LOGICAL_PORT_0) {</span>
<span class="p_add">+		if ((port-&gt;pdt == DP_PEER_DEVICE_DP_LEGACY_CONV ||</span>
<span class="p_add">+		     port-&gt;pdt == DP_PEER_DEVICE_SST_SINK) &amp;&amp;</span>
<span class="p_add">+		    port-&gt;port_num &gt;= DP_MST_LOGICAL_PORT_0) {</span>
 			port-&gt;cached_edid = drm_get_edid(port-&gt;connector, &amp;port-&gt;aux.ddc);
 			drm_mode_connector_set_tile_property(port-&gt;connector);
 		}
<span class="p_chunk">@@ -2919,6 +2922,7 @@</span> <span class="p_context"> static void drm_dp_destroy_connector_work(struct work_struct *work)</span>
 		mgr-&gt;cbs-&gt;destroy_connector(mgr, port-&gt;connector);
 
 		drm_dp_port_teardown_pdt(port, port-&gt;pdt);
<span class="p_add">+		port-&gt;pdt = DP_PEER_DEVICE_NONE;</span>
 
 		if (!port-&gt;input &amp;&amp; port-&gt;vcpi.vcpi &gt; 0) {
 			drm_dp_mst_reset_vcpi_slots(mgr, port);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_fb_helper.c b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">index 0a06f9120b5a..337c55597ccd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_fb_helper.c</span>
<span class="p_chunk">@@ -129,7 +129,12 @@</span> <span class="p_context"> int drm_fb_helper_single_add_all_connectors(struct drm_fb_helper *fb_helper)</span>
 	return 0;
 fail:
 	for (i = 0; i &lt; fb_helper-&gt;connector_count; i++) {
<span class="p_del">-		kfree(fb_helper-&gt;connector_info[i]);</span>
<span class="p_add">+		struct drm_fb_helper_connector *fb_helper_connector =</span>
<span class="p_add">+			fb_helper-&gt;connector_info[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		drm_connector_unreference(fb_helper_connector-&gt;connector);</span>
<span class="p_add">+</span>
<span class="p_add">+		kfree(fb_helper_connector);</span>
 		fb_helper-&gt;connector_info[i] = NULL;
 	}
 	fb_helper-&gt;connector_count = 0;
<span class="p_chunk">@@ -601,6 +606,24 @@</span> <span class="p_context"> int drm_fb_helper_blank(int blank, struct fb_info *info)</span>
 }
 EXPORT_SYMBOL(drm_fb_helper_blank);
 
<span class="p_add">+static void drm_fb_helper_modeset_release(struct drm_fb_helper *helper,</span>
<span class="p_add">+					  struct drm_mode_set *modeset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; modeset-&gt;num_connectors; i++) {</span>
<span class="p_add">+		drm_connector_unreference(modeset-&gt;connectors[i]);</span>
<span class="p_add">+		modeset-&gt;connectors[i] = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	modeset-&gt;num_connectors = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	drm_mode_destroy(helper-&gt;dev, modeset-&gt;mode);</span>
<span class="p_add">+	modeset-&gt;mode = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* FIXME should hold a ref? */</span>
<span class="p_add">+	modeset-&gt;fb = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void drm_fb_helper_crtc_free(struct drm_fb_helper *helper)
 {
 	int i;
<span class="p_chunk">@@ -610,10 +633,12 @@</span> <span class="p_context"> static void drm_fb_helper_crtc_free(struct drm_fb_helper *helper)</span>
 		kfree(helper-&gt;connector_info[i]);
 	}
 	kfree(helper-&gt;connector_info);
<span class="p_add">+</span>
 	for (i = 0; i &lt; helper-&gt;crtc_count; i++) {
<span class="p_del">-		kfree(helper-&gt;crtc_info[i].mode_set.connectors);</span>
<span class="p_del">-		if (helper-&gt;crtc_info[i].mode_set.mode)</span>
<span class="p_del">-			drm_mode_destroy(helper-&gt;dev, helper-&gt;crtc_info[i].mode_set.mode);</span>
<span class="p_add">+		struct drm_mode_set *modeset = &amp;helper-&gt;crtc_info[i].mode_set;</span>
<span class="p_add">+</span>
<span class="p_add">+		drm_fb_helper_modeset_release(helper, modeset);</span>
<span class="p_add">+		kfree(modeset-&gt;connectors);</span>
 	}
 	kfree(helper-&gt;crtc_info);
 }
<span class="p_chunk">@@ -632,7 +657,9 @@</span> <span class="p_context"> static void drm_fb_helper_dirty_work(struct work_struct *work)</span>
 	clip-&gt;x2 = clip-&gt;y2 = 0;
 	spin_unlock_irqrestore(&amp;helper-&gt;dirty_lock, flags);
 
<span class="p_del">-	helper-&gt;fb-&gt;funcs-&gt;dirty(helper-&gt;fb, NULL, 0, 0, &amp;clip_copy, 1);</span>
<span class="p_add">+	/* call dirty callback only when it has been really touched */</span>
<span class="p_add">+	if (clip_copy.x1 &lt; clip_copy.x2 &amp;&amp; clip_copy.y1 &lt; clip_copy.y2)</span>
<span class="p_add">+		helper-&gt;fb-&gt;funcs-&gt;dirty(helper-&gt;fb, NULL, 0, 0, &amp;clip_copy, 1);</span>
 }
 
 /**
<span class="p_chunk">@@ -2027,7 +2054,6 @@</span> <span class="p_context"> static void drm_setup_crtcs(struct drm_fb_helper *fb_helper)</span>
 	struct drm_fb_helper_crtc **crtcs;
 	struct drm_display_mode **modes;
 	struct drm_fb_offset *offsets;
<span class="p_del">-	struct drm_mode_set *modeset;</span>
 	bool *enabled;
 	int width, height;
 	int i;
<span class="p_chunk">@@ -2075,45 +2101,35 @@</span> <span class="p_context"> static void drm_setup_crtcs(struct drm_fb_helper *fb_helper)</span>
 
 	/* need to set the modesets up here for use later */
 	/* fill out the connector&lt;-&gt;crtc mappings into the modesets */
<span class="p_del">-	for (i = 0; i &lt; fb_helper-&gt;crtc_count; i++) {</span>
<span class="p_del">-		modeset = &amp;fb_helper-&gt;crtc_info[i].mode_set;</span>
<span class="p_del">-		modeset-&gt;num_connectors = 0;</span>
<span class="p_del">-		modeset-&gt;fb = NULL;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	for (i = 0; i &lt; fb_helper-&gt;crtc_count; i++)</span>
<span class="p_add">+		drm_fb_helper_modeset_release(fb_helper,</span>
<span class="p_add">+					      &amp;fb_helper-&gt;crtc_info[i].mode_set);</span>
 
 	for (i = 0; i &lt; fb_helper-&gt;connector_count; i++) {
 		struct drm_display_mode *mode = modes[i];
 		struct drm_fb_helper_crtc *fb_crtc = crtcs[i];
 		struct drm_fb_offset *offset = &amp;offsets[i];
<span class="p_del">-		modeset = &amp;fb_crtc-&gt;mode_set;</span>
<span class="p_add">+		struct drm_mode_set *modeset = &amp;fb_crtc-&gt;mode_set;</span>
 
 		if (mode &amp;&amp; fb_crtc) {
<span class="p_add">+			struct drm_connector *connector =</span>
<span class="p_add">+				fb_helper-&gt;connector_info[i]-&gt;connector;</span>
<span class="p_add">+</span>
 			DRM_DEBUG_KMS(&quot;desired mode %s set on crtc %d (%d,%d)\n&quot;,
 				      mode-&gt;name, fb_crtc-&gt;mode_set.crtc-&gt;base.id, offset-&gt;x, offset-&gt;y);
<span class="p_add">+</span>
 			fb_crtc-&gt;desired_mode = mode;
 			fb_crtc-&gt;x = offset-&gt;x;
 			fb_crtc-&gt;y = offset-&gt;y;
<span class="p_del">-			if (modeset-&gt;mode)</span>
<span class="p_del">-				drm_mode_destroy(dev, modeset-&gt;mode);</span>
 			modeset-&gt;mode = drm_mode_duplicate(dev,
 							   fb_crtc-&gt;desired_mode);
<span class="p_del">-			modeset-&gt;connectors[modeset-&gt;num_connectors++] = fb_helper-&gt;connector_info[i]-&gt;connector;</span>
<span class="p_add">+			drm_connector_reference(connector);</span>
<span class="p_add">+			modeset-&gt;connectors[modeset-&gt;num_connectors++] = connector;</span>
 			modeset-&gt;fb = fb_helper-&gt;fb;
 			modeset-&gt;x = offset-&gt;x;
 			modeset-&gt;y = offset-&gt;y;
 		}
 	}
<span class="p_del">-</span>
<span class="p_del">-	/* Clear out any old modes if there are no more connected outputs. */</span>
<span class="p_del">-	for (i = 0; i &lt; fb_helper-&gt;crtc_count; i++) {</span>
<span class="p_del">-		modeset = &amp;fb_helper-&gt;crtc_info[i].mode_set;</span>
<span class="p_del">-		if (modeset-&gt;num_connectors == 0) {</span>
<span class="p_del">-			BUG_ON(modeset-&gt;fb);</span>
<span class="p_del">-			if (modeset-&gt;mode)</span>
<span class="p_del">-				drm_mode_destroy(dev, modeset-&gt;mode);</span>
<span class="p_del">-			modeset-&gt;mode = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
 out:
 	kfree(crtcs);
 	kfree(modes);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_bios.c b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">index c6e69e4cfa83..1f8af87c6294 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_bios.c</span>
<span class="p_chunk">@@ -1031,6 +1031,77 @@</span> <span class="p_context"> static u8 translate_iboost(u8 val)</span>
 	return mapping[val];
 }
 
<span class="p_add">+static void sanitize_ddc_pin(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+			     enum port port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct ddi_vbt_port_info *info =</span>
<span class="p_add">+		&amp;dev_priv-&gt;vbt.ddi_port_info[port];</span>
<span class="p_add">+	enum port p;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!info-&gt;alternate_ddc_pin)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_port_masked(p, (1 &lt;&lt; port) - 1) {</span>
<span class="p_add">+		struct ddi_vbt_port_info *i = &amp;dev_priv-&gt;vbt.ddi_port_info[p];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (info-&gt;alternate_ddc_pin != i-&gt;alternate_ddc_pin)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;port %c trying to use the same DDC pin (0x%x) as port %c, &quot;</span>
<span class="p_add">+			      &quot;disabling port %c DVI/HDMI support\n&quot;,</span>
<span class="p_add">+			      port_name(p), i-&gt;alternate_ddc_pin,</span>
<span class="p_add">+			      port_name(port), port_name(p));</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we have multiple ports supposedly sharing the</span>
<span class="p_add">+		 * pin, then dvi/hdmi couldn&#39;t exist on the shared</span>
<span class="p_add">+		 * port. Otherwise they share the same ddc bin and</span>
<span class="p_add">+		 * system couldn&#39;t communicate with them separately.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Due to parsing the ports in alphabetical order,</span>
<span class="p_add">+		 * a higher port will always clobber a lower one.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		i-&gt;supports_dvi = false;</span>
<span class="p_add">+		i-&gt;supports_hdmi = false;</span>
<span class="p_add">+		i-&gt;alternate_ddc_pin = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void sanitize_aux_ch(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+			    enum port port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct ddi_vbt_port_info *info =</span>
<span class="p_add">+		&amp;dev_priv-&gt;vbt.ddi_port_info[port];</span>
<span class="p_add">+	enum port p;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!info-&gt;alternate_aux_channel)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_port_masked(p, (1 &lt;&lt; port) - 1) {</span>
<span class="p_add">+		struct ddi_vbt_port_info *i = &amp;dev_priv-&gt;vbt.ddi_port_info[p];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (info-&gt;alternate_aux_channel != i-&gt;alternate_aux_channel)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;port %c trying to use the same AUX CH (0x%x) as port %c, &quot;</span>
<span class="p_add">+			      &quot;disabling port %c DP support\n&quot;,</span>
<span class="p_add">+			      port_name(p), i-&gt;alternate_aux_channel,</span>
<span class="p_add">+			      port_name(port), port_name(p));</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we have multiple ports supposedlt sharing the</span>
<span class="p_add">+		 * aux channel, then DP couldn&#39;t exist on the shared</span>
<span class="p_add">+		 * port. Otherwise they share the same aux channel</span>
<span class="p_add">+		 * and system couldn&#39;t communicate with them separately.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Due to parsing the ports in alphabetical order,</span>
<span class="p_add">+		 * a higher port will always clobber a lower one.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		i-&gt;supports_dp = false;</span>
<span class="p_add">+		i-&gt;alternate_aux_channel = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,
 			   const struct bdb_header *bdb)
 {
<span class="p_chunk">@@ -1105,54 +1176,15 @@</span> <span class="p_context"> static void parse_ddi_port(struct drm_i915_private *dev_priv, enum port port,</span>
 		DRM_DEBUG_KMS(&quot;Port %c is internal DP\n&quot;, port_name(port));
 
 	if (is_dvi) {
<span class="p_del">-		if (port == PORT_E) {</span>
<span class="p_del">-			info-&gt;alternate_ddc_pin = ddc_pin;</span>
<span class="p_del">-			/* if DDIE share ddc pin with other port, then</span>
<span class="p_del">-			 * dvi/hdmi couldn&#39;t exist on the shared port.</span>
<span class="p_del">-			 * Otherwise they share the same ddc bin and system</span>
<span class="p_del">-			 * couldn&#39;t communicate with them seperately. */</span>
<span class="p_del">-			if (ddc_pin == DDC_PIN_B) {</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_B].supports_dvi = 0;</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_B].supports_hdmi = 0;</span>
<span class="p_del">-			} else if (ddc_pin == DDC_PIN_C) {</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_C].supports_dvi = 0;</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_C].supports_hdmi = 0;</span>
<span class="p_del">-			} else if (ddc_pin == DDC_PIN_D) {</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_D].supports_dvi = 0;</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_D].supports_hdmi = 0;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else if (ddc_pin == DDC_PIN_B &amp;&amp; port != PORT_B)</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Unexpected DDC pin for port B\n&quot;);</span>
<span class="p_del">-		else if (ddc_pin == DDC_PIN_C &amp;&amp; port != PORT_C)</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Unexpected DDC pin for port C\n&quot;);</span>
<span class="p_del">-		else if (ddc_pin == DDC_PIN_D &amp;&amp; port != PORT_D)</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Unexpected DDC pin for port D\n&quot;);</span>
<span class="p_add">+		info-&gt;alternate_ddc_pin = ddc_pin;</span>
<span class="p_add">+</span>
<span class="p_add">+		sanitize_ddc_pin(dev_priv, port);</span>
 	}
 
 	if (is_dp) {
<span class="p_del">-		if (port == PORT_E) {</span>
<span class="p_del">-			info-&gt;alternate_aux_channel = aux_channel;</span>
<span class="p_del">-			/* if DDIE share aux channel with other port, then</span>
<span class="p_del">-			 * DP couldn&#39;t exist on the shared port. Otherwise</span>
<span class="p_del">-			 * they share the same aux channel and system</span>
<span class="p_del">-			 * couldn&#39;t communicate with them seperately. */</span>
<span class="p_del">-			if (aux_channel == DP_AUX_A)</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_A].supports_dp = 0;</span>
<span class="p_del">-			else if (aux_channel == DP_AUX_B)</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_B].supports_dp = 0;</span>
<span class="p_del">-			else if (aux_channel == DP_AUX_C)</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_C].supports_dp = 0;</span>
<span class="p_del">-			else if (aux_channel == DP_AUX_D)</span>
<span class="p_del">-				dev_priv-&gt;vbt.ddi_port_info[PORT_D].supports_dp = 0;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		else if (aux_channel == DP_AUX_A &amp;&amp; port != PORT_A)</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port A\n&quot;);</span>
<span class="p_del">-		else if (aux_channel == DP_AUX_B &amp;&amp; port != PORT_B)</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port B\n&quot;);</span>
<span class="p_del">-		else if (aux_channel == DP_AUX_C &amp;&amp; port != PORT_C)</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port C\n&quot;);</span>
<span class="p_del">-		else if (aux_channel == DP_AUX_D &amp;&amp; port != PORT_D)</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;Unexpected AUX channel for port D\n&quot;);</span>
<span class="p_add">+		info-&gt;alternate_aux_channel = aux_channel;</span>
<span class="p_add">+</span>
<span class="p_add">+		sanitize_aux_ch(dev_priv, port);</span>
 	}
 
 	if (bdb-&gt;version &gt;= 158) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index e9a64fba6333..63462f279187 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -13834,7 +13834,7 @@</span> <span class="p_context"> static void intel_atomic_commit_tail(struct drm_atomic_state *state)</span>
 
 	for_each_plane_in_state(state, plane, plane_state, i) {
 		struct intel_plane_state *intel_plane_state =
<span class="p_del">-			to_intel_plane_state(plane_state);</span>
<span class="p_add">+			to_intel_plane_state(plane-&gt;state);</span>
 
 		if (!intel_plane_state-&gt;wait_req)
 			continue;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 1ca155f4d368..3051182cf483 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -1090,6 +1090,44 @@</span> <span class="p_context"> intel_dp_aux_transfer(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg)</span>
 	return ret;
 }
 
<span class="p_add">+static enum port intel_aux_port(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+				enum port port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct ddi_vbt_port_info *info =</span>
<span class="p_add">+		&amp;dev_priv-&gt;vbt.ddi_port_info[port];</span>
<span class="p_add">+	enum port aux_port;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!info-&gt;alternate_aux_channel) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;using AUX %c for port %c (platform default)\n&quot;,</span>
<span class="p_add">+			      port_name(port), port_name(port));</span>
<span class="p_add">+		return port;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (info-&gt;alternate_aux_channel) {</span>
<span class="p_add">+	case DP_AUX_A:</span>
<span class="p_add">+		aux_port = PORT_A;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case DP_AUX_B:</span>
<span class="p_add">+		aux_port = PORT_B;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case DP_AUX_C:</span>
<span class="p_add">+		aux_port = PORT_C;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case DP_AUX_D:</span>
<span class="p_add">+		aux_port = PORT_D;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		MISSING_CASE(info-&gt;alternate_aux_channel);</span>
<span class="p_add">+		aux_port = PORT_A;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	DRM_DEBUG_KMS(&quot;using AUX %c for port %c (VBT)\n&quot;,</span>
<span class="p_add">+		      port_name(aux_port), port_name(port));</span>
<span class="p_add">+</span>
<span class="p_add">+	return aux_port;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static i915_reg_t g4x_aux_ctl_reg(struct drm_i915_private *dev_priv,
 				       enum port port)
 {
<span class="p_chunk">@@ -1150,36 +1188,9 @@</span> <span class="p_context"> static i915_reg_t ilk_aux_data_reg(struct drm_i915_private *dev_priv,</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * On SKL we don&#39;t have Aux for port E so we rely</span>
<span class="p_del">- * on VBT to set a proper alternate aux channel.</span>
<span class="p_del">- */</span>
<span class="p_del">-static enum port skl_porte_aux_port(struct drm_i915_private *dev_priv)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct ddi_vbt_port_info *info =</span>
<span class="p_del">-		&amp;dev_priv-&gt;vbt.ddi_port_info[PORT_E];</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (info-&gt;alternate_aux_channel) {</span>
<span class="p_del">-	case DP_AUX_A:</span>
<span class="p_del">-		return PORT_A;</span>
<span class="p_del">-	case DP_AUX_B:</span>
<span class="p_del">-		return PORT_B;</span>
<span class="p_del">-	case DP_AUX_C:</span>
<span class="p_del">-		return PORT_C;</span>
<span class="p_del">-	case DP_AUX_D:</span>
<span class="p_del">-		return PORT_D;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		MISSING_CASE(info-&gt;alternate_aux_channel);</span>
<span class="p_del">-		return PORT_A;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static i915_reg_t skl_aux_ctl_reg(struct drm_i915_private *dev_priv,
 				       enum port port)
 {
<span class="p_del">-	if (port == PORT_E)</span>
<span class="p_del">-		port = skl_porte_aux_port(dev_priv);</span>
<span class="p_del">-</span>
 	switch (port) {
 	case PORT_A:
 	case PORT_B:
<span class="p_chunk">@@ -1195,9 +1206,6 @@</span> <span class="p_context"> static i915_reg_t skl_aux_ctl_reg(struct drm_i915_private *dev_priv,</span>
 static i915_reg_t skl_aux_data_reg(struct drm_i915_private *dev_priv,
 					enum port port, int index)
 {
<span class="p_del">-	if (port == PORT_E)</span>
<span class="p_del">-		port = skl_porte_aux_port(dev_priv);</span>
<span class="p_del">-</span>
 	switch (port) {
 	case PORT_A:
 	case PORT_B:
<span class="p_chunk">@@ -1235,7 +1243,8 @@</span> <span class="p_context"> static i915_reg_t intel_aux_data_reg(struct drm_i915_private *dev_priv,</span>
 static void intel_aux_reg_init(struct intel_dp *intel_dp)
 {
 	struct drm_i915_private *dev_priv = to_i915(intel_dp_to_dev(intel_dp));
<span class="p_del">-	enum port port = dp_to_dig_port(intel_dp)-&gt;port;</span>
<span class="p_add">+	enum port port = intel_aux_port(dev_priv,</span>
<span class="p_add">+					dp_to_dig_port(intel_dp)-&gt;port);</span>
 	int i;
 
 	intel_dp-&gt;aux_ch_ctl_reg = intel_aux_ctl_reg(dev_priv, port);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_fbc.c b/drivers/gpu/drm/i915/intel_fbc.c</span>
<span class="p_header">index 3836a1c79714..ad483376bdfa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_fbc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_fbc.c</span>
<span class="p_chunk">@@ -104,8 +104,10 @@</span> <span class="p_context"> static int intel_fbc_calculate_cfb_size(struct drm_i915_private *dev_priv,</span>
 	int lines;
 
 	intel_fbc_get_plane_source_size(cache, NULL, &amp;lines);
<span class="p_del">-	if (INTEL_INFO(dev_priv)-&gt;gen &gt;= 7)</span>
<span class="p_add">+	if (INTEL_GEN(dev_priv) == 7)</span>
 		lines = min(lines, 2048);
<span class="p_add">+	else if (INTEL_GEN(dev_priv) &gt;= 8)</span>
<span class="p_add">+		lines = min(lines, 2560);</span>
 
 	/* Hardware needs the full buffer stride, not just the active area. */
 	return lines * cache-&gt;fb.stride;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index e59a28cb3158..a69160568254 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -3363,13 +3363,15 @@</span> <span class="p_context"> skl_allocate_pipe_ddb(struct intel_crtc_state *cstate,</span>
 	int num_active;
 	int id, i;
 
<span class="p_add">+	/* Clear the partitioning for disabled planes. */</span>
<span class="p_add">+	memset(ddb-&gt;plane[pipe], 0, sizeof(ddb-&gt;plane[pipe]));</span>
<span class="p_add">+	memset(ddb-&gt;y_plane[pipe], 0, sizeof(ddb-&gt;y_plane[pipe]));</span>
<span class="p_add">+</span>
 	if (WARN_ON(!state))
 		return 0;
 
 	if (!cstate-&gt;base.active) {
 		ddb-&gt;pipe[pipe].start = ddb-&gt;pipe[pipe].end = 0;
<span class="p_del">-		memset(ddb-&gt;plane[pipe], 0, sizeof(ddb-&gt;plane[pipe]));</span>
<span class="p_del">-		memset(ddb-&gt;y_plane[pipe], 0, sizeof(ddb-&gt;y_plane[pipe]));</span>
 		return 0;
 	}
 
<span class="p_chunk">@@ -3469,12 +3471,6 @@</span> <span class="p_context"> skl_allocate_pipe_ddb(struct intel_crtc_state *cstate,</span>
 	return 0;
 }
 
<span class="p_del">-static uint32_t skl_pipe_pixel_rate(const struct intel_crtc_state *config)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* TODO: Take into account the scalers once we support them */</span>
<span class="p_del">-	return config-&gt;base.adjusted_mode.crtc_clock;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * The max latency should be 257 (max the punit can code is 255 and we add 2us
  * for the read latency) and cpp should always be &lt;= 8, so that
<span class="p_chunk">@@ -3525,7 +3521,7 @@</span> <span class="p_context"> static uint32_t skl_adjusted_plane_pixel_rate(const struct intel_crtc_state *cst</span>
 	 * Adjusted plane pixel rate is just the pipe&#39;s adjusted pixel rate
 	 * with additional adjustments for plane-specific scaling.
 	 */
<span class="p_del">-	adjusted_pixel_rate = skl_pipe_pixel_rate(cstate);</span>
<span class="p_add">+	adjusted_pixel_rate = ilk_pipe_pixel_rate(cstate);</span>
 	downscale_amount = skl_plane_downscale_amount(pstate);
 
 	pixel_rate = adjusted_pixel_rate * downscale_amount &gt;&gt; 16;
<span class="p_chunk">@@ -3737,11 +3733,11 @@</span> <span class="p_context"> skl_compute_linetime_wm(struct intel_crtc_state *cstate)</span>
 	if (!cstate-&gt;base.active)
 		return 0;
 
<span class="p_del">-	if (WARN_ON(skl_pipe_pixel_rate(cstate) == 0))</span>
<span class="p_add">+	if (WARN_ON(ilk_pipe_pixel_rate(cstate) == 0))</span>
 		return 0;
 
 	return DIV_ROUND_UP(8 * cstate-&gt;base.adjusted_mode.crtc_htotal * 1000,
<span class="p_del">-			    skl_pipe_pixel_rate(cstate));</span>
<span class="p_add">+			    ilk_pipe_pixel_rate(cstate));</span>
 }
 
 static void skl_compute_transition_wm(struct intel_crtc_state *cstate,
<span class="p_chunk">@@ -4051,6 +4047,12 @@</span> <span class="p_context"> skl_compute_ddb(struct drm_atomic_state *state)</span>
 		intel_state-&gt;wm_results.dirty_pipes = ~0;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We&#39;re not recomputing for the pipes not included in the commit, so</span>
<span class="p_add">+	 * make sure we start with the current state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memcpy(ddb, &amp;dev_priv-&gt;wm.skl_hw.ddb, sizeof(*ddb));</span>
<span class="p_add">+</span>
 	for_each_intel_crtc_mask(dev, intel_crtc, realloc_pipes) {
 		struct intel_crtc_state *cstate;
 
<span class="p_header">diff --git a/drivers/gpu/drm/imx/ipuv3-plane.c b/drivers/gpu/drm/imx/ipuv3-plane.c</span>
<span class="p_header">index 29423e757d36..927c51e8abc6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/imx/ipuv3-plane.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/imx/ipuv3-plane.c</span>
<span class="p_chunk">@@ -108,6 +108,7 @@</span> <span class="p_context"> static void ipu_plane_atomic_set_base(struct ipu_plane *ipu_plane,</span>
 {
 	struct drm_plane *plane = &amp;ipu_plane-&gt;base;
 	struct drm_plane_state *state = plane-&gt;state;
<span class="p_add">+	struct drm_crtc_state *crtc_state = state-&gt;crtc-&gt;state;</span>
 	struct drm_framebuffer *fb = state-&gt;fb;
 	unsigned long eba, ubo, vbo;
 	int active;
<span class="p_chunk">@@ -149,7 +150,7 @@</span> <span class="p_context"> static void ipu_plane_atomic_set_base(struct ipu_plane *ipu_plane,</span>
 		break;
 	}
 
<span class="p_del">-	if (old_state-&gt;fb) {</span>
<span class="p_add">+	if (!drm_atomic_crtc_needs_modeset(crtc_state)) {</span>
 		active = ipu_idmac_get_current_buffer(ipu_plane-&gt;ipu_ch);
 		ipu_cpmem_set_buffer(ipu_plane-&gt;ipu_ch, !active, eba);
 		ipu_idmac_select_buffer(ipu_plane-&gt;ipu_ch, !active);
<span class="p_chunk">@@ -359,7 +360,9 @@</span> <span class="p_context"> static int ipu_plane_atomic_check(struct drm_plane *plane,</span>
 		if ((ubo &gt; 0xfffff8) || (vbo &gt; 0xfffff8))
 			return -EINVAL;
 
<span class="p_del">-		if (old_fb) {</span>
<span class="p_add">+		if (old_fb &amp;&amp;</span>
<span class="p_add">+		    (old_fb-&gt;pixel_format == DRM_FORMAT_YUV420 ||</span>
<span class="p_add">+		     old_fb-&gt;pixel_format == DRM_FORMAT_YVU420)) {</span>
 			old_ubo = drm_plane_state_to_ubo(old_state);
 			old_vbo = drm_plane_state_to_vbo(old_state);
 			if (ubo != old_ubo || vbo != old_vbo)
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_acpi.c b/drivers/gpu/drm/nouveau/nouveau_acpi.c</span>
<span class="p_header">index dc57b628e074..193573d191e5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_acpi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_acpi.c</span>
<span class="p_chunk">@@ -240,7 +240,8 @@</span> <span class="p_context"> static bool nouveau_pr3_present(struct pci_dev *pdev)</span>
 	if (!parent_adev)
 		return false;
 
<span class="p_del">-	return acpi_has_method(parent_adev-&gt;handle, &quot;_PR3&quot;);</span>
<span class="p_add">+	return parent_adev-&gt;power.flags.power_resources &amp;&amp;</span>
<span class="p_add">+		acpi_has_method(parent_adev-&gt;handle, &quot;_PR3&quot;);</span>
 }
 
 static void nouveau_dsm_pci_probe(struct pci_dev *pdev, acpi_handle *dhandle_out,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">index 4a3d7cab83f7..4b9c2d5ff6a1 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_chunk">@@ -1396,9 +1396,7 @@</span> <span class="p_context"> static void cayman_pcie_gart_fini(struct radeon_device *rdev)</span>
 void cayman_cp_int_cntl_setup(struct radeon_device *rdev,
 			      int ring, u32 cp_int_cntl)
 {
<span class="p_del">-	u32 srbm_gfx_cntl = RREG32(SRBM_GFX_CNTL) &amp; ~3;</span>
<span class="p_del">-</span>
<span class="p_del">-	WREG32(SRBM_GFX_CNTL, srbm_gfx_cntl | (ring &amp; 3));</span>
<span class="p_add">+	WREG32(SRBM_GFX_CNTL, RINGID(ring));</span>
 	WREG32(CP_INT_CNTL, cp_int_cntl);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_dp_auxch.c b/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_header">index db64e0062689..3b0c229d7dcd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_dp_auxch.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> radeon_dp_aux_transfer_native(struct drm_dp_aux *aux, struct drm_dp_aux_msg *msg</span>
 
 	tmp &amp;= AUX_HPD_SEL(0x7);
 	tmp |= AUX_HPD_SEL(chan-&gt;rec.hpd);
<span class="p_del">-	tmp |= AUX_EN | AUX_LS_READ_EN | AUX_HPD_DISCON(0x1);</span>
<span class="p_add">+	tmp |= AUX_EN | AUX_LS_READ_EN;</span>
 
 	WREG32(AUX_CONTROL + aux_offset[instance], tmp);
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 89bdf20344ae..c49934527a87 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2999,6 +2999,49 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 	int i;
 	struct si_dpm_quirk *p = si_dpm_quirk_list;
 
<span class="p_add">+	/* limit all SI kickers */</span>
<span class="p_add">+	if (rdev-&gt;family == CHIP_PITCAIRN) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6810) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6811) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6816) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6817) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6806))</span>
<span class="p_add">+			max_mclk = 120000;</span>
<span class="p_add">+	} else if (rdev-&gt;family == CHIP_VERDE) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x682B)) {</span>
<span class="p_add">+			max_sclk = 75000;</span>
<span class="p_add">+			max_mclk = 80000;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (rdev-&gt;family == CHIP_OLAND) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0xC7) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x80) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6604) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6605)) {</span>
<span class="p_add">+			max_sclk = 75000;</span>
<span class="p_add">+			max_mclk = 80000;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (rdev-&gt;family == CHIP_HAINAN) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0xC3) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6664) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6665) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6667)) {</span>
<span class="p_add">+			max_sclk = 75000;</span>
<span class="p_add">+			max_mclk = 80000;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	/* Apply dpm quirks */
 	while (p &amp;&amp; p-&gt;chip_device != 0) {
 		if (rdev-&gt;pdev-&gt;vendor == p-&gt;chip_vendor &amp;&amp;
<span class="p_chunk">@@ -3011,16 +3054,6 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 		}
 		++p;
 	}
<span class="p_del">-	/* limit mclk on all R7 370 parts for stability */</span>
<span class="p_del">-	if (rdev-&gt;pdev-&gt;device == 0x6811 &amp;&amp;</span>
<span class="p_del">-	    rdev-&gt;pdev-&gt;revision == 0x81)</span>
<span class="p_del">-		max_mclk = 120000;</span>
<span class="p_del">-	/* limit sclk/mclk on Jet parts for stability */</span>
<span class="p_del">-	if (rdev-&gt;pdev-&gt;device == 0x6665 &amp;&amp;</span>
<span class="p_del">-	    rdev-&gt;pdev-&gt;revision == 0xc3) {</span>
<span class="p_del">-		max_sclk = 75000;</span>
<span class="p_del">-		max_mclk = 80000;</span>
<span class="p_del">-	}</span>
 
 	if (rps-&gt;vce_active) {
 		rps-&gt;evclk = rdev-&gt;pm.dpm.vce_states[rdev-&gt;pm.dpm.vce_level].evclk;
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index e92b09d32605..9ab703c1042e 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -179,6 +179,7 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_ATEN_4PORTKVM	0x2205
 #define USB_DEVICE_ID_ATEN_4PORTKVMC	0x2208
 #define USB_DEVICE_ID_ATEN_CS682	0x2213
<span class="p_add">+#define USB_DEVICE_ID_ATEN_CS692	0x8021</span>
 
 #define USB_VENDOR_ID_ATMEL		0x03eb
 #define USB_DEVICE_ID_ATMEL_MULTITOUCH	0x211c
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index bb400081efe4..85fcf60f3bba 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -63,6 +63,7 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVMC, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS682, HID_QUIRK_NOGET },
<span class="p_add">+	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS692, HID_QUIRK_NOGET },</span>
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_FIGHTERSTICK, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_COMBATSTICK, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE, HID_QUIRK_NOGET },
<span class="p_header">diff --git a/drivers/hv/hv_util.c b/drivers/hv/hv_util.c</span>
<span class="p_header">index d5acaa2d8e61..9dc63725363d 100644</span>
<span class="p_header">--- a/drivers/hv/hv_util.c</span>
<span class="p_header">+++ b/drivers/hv/hv_util.c</span>
<span class="p_chunk">@@ -283,10 +283,14 @@</span> <span class="p_context"> static void heartbeat_onchannelcallback(void *context)</span>
 	u8 *hbeat_txf_buf = util_heartbeat.recv_buffer;
 	struct icmsg_negotiate *negop = NULL;
 
<span class="p_del">-	vmbus_recvpacket(channel, hbeat_txf_buf,</span>
<span class="p_del">-			 PAGE_SIZE, &amp;recvlen, &amp;requestid);</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+</span>
<span class="p_add">+		vmbus_recvpacket(channel, hbeat_txf_buf,</span>
<span class="p_add">+				 PAGE_SIZE, &amp;recvlen, &amp;requestid);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!recvlen)</span>
<span class="p_add">+			break;</span>
 
<span class="p_del">-	if (recvlen &gt; 0) {</span>
 		icmsghdrp = (struct icmsg_hdr *)&amp;hbeat_txf_buf[
 				sizeof(struct vmbuspipe_hdr)];
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-rk3x.c b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">index 5c5b7cada8be..dfae43523d34 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-rk3x.c</span>
<span class="p_chunk">@@ -694,6 +694,8 @@</span> <span class="p_context"> static int rk3x_i2c_v0_calc_timings(unsigned long clk_rate,</span>
 	t_calc-&gt;div_low--;
 	t_calc-&gt;div_high--;
 
<span class="p_add">+	/* Give the tuning value 0, that would not update con register */</span>
<span class="p_add">+	t_calc-&gt;tuning = 0;</span>
 	/* Maximum divider supported by hw is 0xffff */
 	if (t_calc-&gt;div_low &gt; 0xffff) {
 		t_calc-&gt;div_low = 0xffff;
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-xgene-slimpro.c b/drivers/i2c/busses/i2c-xgene-slimpro.c</span>
<span class="p_header">index 4233f5695352..3c38029e3fe9 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-xgene-slimpro.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-xgene-slimpro.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> struct slimpro_i2c_dev {</span>
 	struct mbox_chan *mbox_chan;
 	struct mbox_client mbox_client;
 	struct completion rd_complete;
<span class="p_del">-	u8 dma_buffer[I2C_SMBUS_BLOCK_MAX];</span>
<span class="p_add">+	u8 dma_buffer[I2C_SMBUS_BLOCK_MAX + 1]; /* dma_buffer[0] is used for length */</span>
 	u32 *resp_msg;
 };
 
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index da3a02ef4a31..a9a9f66947e8 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -1592,6 +1592,7 @@</span> <span class="p_context"> static struct i2c_client *of_i2c_register_device(struct i2c_adapter *adap,</span>
 static void of_i2c_register_devices(struct i2c_adapter *adap)
 {
 	struct device_node *node;
<span class="p_add">+	struct i2c_client *client;</span>
 
 	/* Only register child devices if the adapter has a node pointer set */
 	if (!adap-&gt;dev.of_node)
<span class="p_chunk">@@ -1602,7 +1603,14 @@</span> <span class="p_context"> static void of_i2c_register_devices(struct i2c_adapter *adap)</span>
 	for_each_available_child_of_node(adap-&gt;dev.of_node, node) {
 		if (of_node_test_and_set_flag(node, OF_POPULATED))
 			continue;
<span class="p_del">-		of_i2c_register_device(adap, node);</span>
<span class="p_add">+</span>
<span class="p_add">+		client = of_i2c_register_device(adap, node);</span>
<span class="p_add">+		if (IS_ERR(client)) {</span>
<span class="p_add">+			dev_warn(&amp;adap-&gt;dev,</span>
<span class="p_add">+				 &quot;Failed to create I2C device for %s\n&quot;,</span>
<span class="p_add">+				 node-&gt;full_name);</span>
<span class="p_add">+			of_node_clear_flag(node, OF_POPULATED);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -2073,6 +2081,7 @@</span> <span class="p_context"> int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span>
 	/* add the driver to the list of i2c drivers in the driver core */
 	driver-&gt;driver.owner = owner;
 	driver-&gt;driver.bus = &amp;i2c_bus_type;
<span class="p_add">+	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span>
 
 	/* When registration returns, the driver core
 	 * will have called probe() for all matching-but-unbound devices.
<span class="p_chunk">@@ -2083,7 +2092,6 @@</span> <span class="p_context"> int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span>
 
 	pr_debug(&quot;driver [%s] registered\n&quot;, driver-&gt;driver.name);
 
<span class="p_del">-	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span>
 	/* Walk the adapters that are already present */
 	i2c_for_each_dev(driver, __process_new_driver);
 
<span class="p_chunk">@@ -2201,6 +2209,7 @@</span> <span class="p_context"> static int of_i2c_notify(struct notifier_block *nb, unsigned long action,</span>
 		if (IS_ERR(client)) {
 			dev_err(&amp;adap-&gt;dev, &quot;failed to create client for &#39;%s&#39;\n&quot;,
 				 rd-&gt;dn-&gt;full_name);
<span class="p_add">+			of_node_clear_flag(rd-&gt;dn, OF_POPULATED);</span>
 			return notifier_from_errno(PTR_ERR(client));
 		}
 		break;
<span class="p_header">diff --git a/drivers/iio/chemical/atlas-ph-sensor.c b/drivers/iio/chemical/atlas-ph-sensor.c</span>
<span class="p_header">index 407f141a1eee..a3fbdb761b5f 100644</span>
<span class="p_header">--- a/drivers/iio/chemical/atlas-ph-sensor.c</span>
<span class="p_header">+++ b/drivers/iio/chemical/atlas-ph-sensor.c</span>
<span class="p_chunk">@@ -207,13 +207,14 @@</span> <span class="p_context"> static int atlas_check_ec_calibration(struct atlas_data *data)</span>
 	struct device *dev = &amp;data-&gt;client-&gt;dev;
 	int ret;
 	unsigned int val;
<span class="p_add">+	__be16	rval;</span>
 
<span class="p_del">-	ret = regmap_bulk_read(data-&gt;regmap, ATLAS_REG_EC_PROBE, &amp;val, 2);</span>
<span class="p_add">+	ret = regmap_bulk_read(data-&gt;regmap, ATLAS_REG_EC_PROBE, &amp;rval, 2);</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	dev_info(dev, &quot;probe set to K = %d.%.2d&quot;, be16_to_cpu(val) / 100,</span>
<span class="p_del">-						 be16_to_cpu(val) % 100);</span>
<span class="p_add">+	val = be16_to_cpu(rval);</span>
<span class="p_add">+	dev_info(dev, &quot;probe set to K = %d.%.2d&quot;, val / 100, val % 100);</span>
 
 	ret = regmap_read(data-&gt;regmap, ATLAS_REG_EC_CALIB_STATUS, &amp;val);
 	if (ret)
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index f4bfb4b2d50a..073246c7d163 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -877,6 +877,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_kbdreset_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P34&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Schenker XMG C504 - Elantech touchpad */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;XMG&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;C504&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/md/dm-raid.c b/drivers/md/dm-raid.c</span>
<span class="p_header">index 8abde6b8cedc..6d53810963f7 100644</span>
<span class="p_header">--- a/drivers/md/dm-raid.c</span>
<span class="p_header">+++ b/drivers/md/dm-raid.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static struct raid_type {</span>
 	{&quot;raid10_offset&quot;, &quot;raid10 offset (striped mirrors)&quot;,	    0, 2, 10, ALGORITHM_RAID10_OFFSET},
 	{&quot;raid10_near&quot;,	  &quot;raid10 near (striped mirrors)&quot;,	    0, 2, 10, ALGORITHM_RAID10_NEAR},
 	{&quot;raid10&quot;,	  &quot;raid10 (striped mirrors)&quot;,		    0, 2, 10, ALGORITHM_RAID10_DEFAULT},
<span class="p_del">-	{&quot;raid4&quot;,	  &quot;raid4 (dedicated last parity disk)&quot;,	    1, 2, 4,  ALGORITHM_PARITY_N}, /* raid4 layout = raid5_n */</span>
<span class="p_add">+	{&quot;raid4&quot;,	  &quot;raid4 (dedicated first parity disk)&quot;,    1, 2, 5,  ALGORITHM_PARITY_0}, /* raid4 layout = raid5_0 */</span>
 	{&quot;raid5_n&quot;,	  &quot;raid5 (dedicated last parity disk)&quot;,	    1, 2, 5,  ALGORITHM_PARITY_N},
 	{&quot;raid5_ls&quot;,	  &quot;raid5 (left symmetric)&quot;,		    1, 2, 5,  ALGORITHM_LEFT_SYMMETRIC},
 	{&quot;raid5_rs&quot;,	  &quot;raid5 (right symmetric)&quot;,		    1, 2, 5,  ALGORITHM_RIGHT_SYMMETRIC},
<span class="p_chunk">@@ -2087,11 +2087,11 @@</span> <span class="p_context"> static int super_init_validation(struct raid_set *rs, struct md_rdev *rdev)</span>
 		/*
 		 * No takeover/reshaping, because we don&#39;t have the extended v1.9.0 metadata
 		 */
<span class="p_del">-		if (le32_to_cpu(sb-&gt;level) != mddev-&gt;level) {</span>
<span class="p_add">+		if (le32_to_cpu(sb-&gt;level) != mddev-&gt;new_level) {</span>
 			DMERR(&quot;Reshaping/takeover raid sets not yet supported. (raid level/stripes/size change)&quot;);
 			return -EINVAL;
 		}
<span class="p_del">-		if (le32_to_cpu(sb-&gt;layout) != mddev-&gt;layout) {</span>
<span class="p_add">+		if (le32_to_cpu(sb-&gt;layout) != mddev-&gt;new_layout) {</span>
 			DMERR(&quot;Reshaping raid sets not yet supported. (raid layout change)&quot;);
 			DMERR(&quot;	 0x%X vs 0x%X&quot;, le32_to_cpu(sb-&gt;layout), mddev-&gt;layout);
 			DMERR(&quot;	 Old layout: %s w/ %d copies&quot;,
<span class="p_chunk">@@ -2102,7 +2102,7 @@</span> <span class="p_context"> static int super_init_validation(struct raid_set *rs, struct md_rdev *rdev)</span>
 			      raid10_md_layout_to_copies(mddev-&gt;layout));
 			return -EINVAL;
 		}
<span class="p_del">-		if (le32_to_cpu(sb-&gt;stripe_sectors) != mddev-&gt;chunk_sectors) {</span>
<span class="p_add">+		if (le32_to_cpu(sb-&gt;stripe_sectors) != mddev-&gt;new_chunk_sectors) {</span>
 			DMERR(&quot;Reshaping raid sets not yet supported. (stripe sectors change)&quot;);
 			return -EINVAL;
 		}
<span class="p_chunk">@@ -2115,6 +2115,8 @@</span> <span class="p_context"> static int super_init_validation(struct raid_set *rs, struct md_rdev *rdev)</span>
 			return -EINVAL;
 		}
 
<span class="p_add">+		DMINFO(&quot;Discovered old metadata format; upgrading to extended metadata format&quot;);</span>
<span class="p_add">+</span>
 		/* Table line is checked vs. authoritative superblock */
 		rs_set_new(rs);
 	}
<span class="p_chunk">@@ -2258,7 +2260,8 @@</span> <span class="p_context"> static int super_validate(struct raid_set *rs, struct md_rdev *rdev)</span>
 	if (!mddev-&gt;events &amp;&amp; super_init_validation(rs, rdev))
 		return -EINVAL;
 
<span class="p_del">-	if (le32_to_cpu(sb-&gt;compat_features) != FEATURE_FLAG_SUPPORTS_V190) {</span>
<span class="p_add">+	if (le32_to_cpu(sb-&gt;compat_features) &amp;&amp;</span>
<span class="p_add">+	    le32_to_cpu(sb-&gt;compat_features) != FEATURE_FLAG_SUPPORTS_V190) {</span>
 		rs-&gt;ti-&gt;error = &quot;Unable to assemble array: Unknown flag(s) in compatible feature flags&quot;;
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -3646,7 +3649,7 @@</span> <span class="p_context"> static void raid_resume(struct dm_target *ti)</span>
 
 static struct target_type raid_target = {
 	.name = &quot;raid&quot;,
<span class="p_del">-	.version = {1, 9, 0},</span>
<span class="p_add">+	.version = {1, 9, 1},</span>
 	.module = THIS_MODULE,
 	.ctr = raid_ctr,
 	.dtr = raid_dtr,
<span class="p_header">diff --git a/drivers/md/dm-raid1.c b/drivers/md/dm-raid1.c</span>
<span class="p_header">index bdf1606f67bc..7a6254d54baf 100644</span>
<span class="p_header">--- a/drivers/md/dm-raid1.c</span>
<span class="p_header">+++ b/drivers/md/dm-raid1.c</span>
<span class="p_chunk">@@ -1292,6 +1292,7 @@</span> <span class="p_context"> static int mirror_end_io(struct dm_target *ti, struct bio *bio, int error)</span>
 
 			dm_bio_restore(bd, bio);
 			bio_record-&gt;details.bi_bdev = NULL;
<span class="p_add">+			bio-&gt;bi_error = 0;</span>
 
 			queue_bio(ms, bio, rw);
 			return DM_ENDIO_INCOMPLETE;
<span class="p_header">diff --git a/drivers/md/dm-rq.c b/drivers/md/dm-rq.c</span>
<span class="p_header">index 5da86c8b6545..2154596eedf3 100644</span>
<span class="p_header">--- a/drivers/md/dm-rq.c</span>
<span class="p_header">+++ b/drivers/md/dm-rq.c</span>
<span class="p_chunk">@@ -835,8 +835,11 @@</span> <span class="p_context"> int dm_old_init_request_queue(struct mapped_device *md)</span>
 	init_kthread_worker(&amp;md-&gt;kworker);
 	md-&gt;kworker_task = kthread_run(kthread_worker_fn, &amp;md-&gt;kworker,
 				       &quot;kdmwork-%s&quot;, dm_device_name(md));
<span class="p_del">-	if (IS_ERR(md-&gt;kworker_task))</span>
<span class="p_del">-		return PTR_ERR(md-&gt;kworker_task);</span>
<span class="p_add">+	if (IS_ERR(md-&gt;kworker_task)) {</span>
<span class="p_add">+		int error = PTR_ERR(md-&gt;kworker_task);</span>
<span class="p_add">+		md-&gt;kworker_task = NULL;</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	}</span>
 
 	elv_register_queue(md-&gt;queue);
 
<span class="p_header">diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c</span>
<span class="p_header">index 3e407a9cde1f..c4b53b332607 100644</span>
<span class="p_header">--- a/drivers/md/dm-table.c</span>
<span class="p_header">+++ b/drivers/md/dm-table.c</span>
<span class="p_chunk">@@ -695,37 +695,32 @@</span> <span class="p_context"> int dm_table_add_target(struct dm_table *t, const char *type,</span>
 
 	tgt-&gt;type = dm_get_target_type(type);
 	if (!tgt-&gt;type) {
<span class="p_del">-		DMERR(&quot;%s: %s: unknown target type&quot;, dm_device_name(t-&gt;md),</span>
<span class="p_del">-		      type);</span>
<span class="p_add">+		DMERR(&quot;%s: %s: unknown target type&quot;, dm_device_name(t-&gt;md), type);</span>
 		return -EINVAL;
 	}
 
 	if (dm_target_needs_singleton(tgt-&gt;type)) {
 		if (t-&gt;num_targets) {
<span class="p_del">-			DMERR(&quot;%s: target type %s must appear alone in table&quot;,</span>
<span class="p_del">-			      dm_device_name(t-&gt;md), type);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			tgt-&gt;error = &quot;singleton target type must appear alone in table&quot;;</span>
<span class="p_add">+			goto bad;</span>
 		}
 		t-&gt;singleton = true;
 	}
 
 	if (dm_target_always_writeable(tgt-&gt;type) &amp;&amp; !(t-&gt;mode &amp; FMODE_WRITE)) {
<span class="p_del">-		DMERR(&quot;%s: target type %s may not be included in read-only tables&quot;,</span>
<span class="p_del">-		      dm_device_name(t-&gt;md), type);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		tgt-&gt;error = &quot;target type may not be included in a read-only table&quot;;</span>
<span class="p_add">+		goto bad;</span>
 	}
 
 	if (t-&gt;immutable_target_type) {
 		if (t-&gt;immutable_target_type != tgt-&gt;type) {
<span class="p_del">-			DMERR(&quot;%s: immutable target type %s cannot be mixed with other target types&quot;,</span>
<span class="p_del">-			      dm_device_name(t-&gt;md), t-&gt;immutable_target_type-&gt;name);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			tgt-&gt;error = &quot;immutable target type cannot be mixed with other target types&quot;;</span>
<span class="p_add">+			goto bad;</span>
 		}
 	} else if (dm_target_is_immutable(tgt-&gt;type)) {
 		if (t-&gt;num_targets) {
<span class="p_del">-			DMERR(&quot;%s: immutable target type %s cannot be mixed with other target types&quot;,</span>
<span class="p_del">-			      dm_device_name(t-&gt;md), tgt-&gt;type-&gt;name);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			tgt-&gt;error = &quot;immutable target type cannot be mixed with other target types&quot;;</span>
<span class="p_add">+			goto bad;</span>
 		}
 		t-&gt;immutable_target_type = tgt-&gt;type;
 	}
<span class="p_chunk">@@ -740,7 +735,6 @@</span> <span class="p_context"> int dm_table_add_target(struct dm_table *t, const char *type,</span>
 	 */
 	if (!adjoin(t, tgt)) {
 		tgt-&gt;error = &quot;Gap in table&quot;;
<span class="p_del">-		r = -EINVAL;</span>
 		goto bad;
 	}
 
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index 0f2928b3136b..eeef575fb54b 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -1423,8 +1423,6 @@</span> <span class="p_context"> static void cleanup_mapped_device(struct mapped_device *md)</span>
 	if (md-&gt;bs)
 		bioset_free(md-&gt;bs);
 
<span class="p_del">-	cleanup_srcu_struct(&amp;md-&gt;io_barrier);</span>
<span class="p_del">-</span>
 	if (md-&gt;disk) {
 		spin_lock(&amp;_minor_lock);
 		md-&gt;disk-&gt;private_data = NULL;
<span class="p_chunk">@@ -1436,6 +1434,8 @@</span> <span class="p_context"> static void cleanup_mapped_device(struct mapped_device *md)</span>
 	if (md-&gt;queue)
 		blk_cleanup_queue(md-&gt;queue);
 
<span class="p_add">+	cleanup_srcu_struct(&amp;md-&gt;io_barrier);</span>
<span class="p_add">+</span>
 	if (md-&gt;bdev) {
 		bdput(md-&gt;bdev);
 		md-&gt;bdev = NULL;
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 915e84d631a2..db0aa6c058e7 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -8120,14 +8120,14 @@</span> <span class="p_context"> void md_do_sync(struct md_thread *thread)</span>
 
 	if (!test_bit(MD_RECOVERY_RESHAPE, &amp;mddev-&gt;recovery) &amp;&amp;
 	    !test_bit(MD_RECOVERY_INTR, &amp;mddev-&gt;recovery) &amp;&amp;
<span class="p_del">-	    mddev-&gt;curr_resync &gt; 2) {</span>
<span class="p_add">+	    mddev-&gt;curr_resync &gt; 3) {</span>
 		mddev-&gt;curr_resync_completed = mddev-&gt;curr_resync;
 		sysfs_notify(&amp;mddev-&gt;kobj, NULL, &quot;sync_completed&quot;);
 	}
 	mddev-&gt;pers-&gt;sync_request(mddev, max_sectors, &amp;skipped);
 
 	if (!test_bit(MD_RECOVERY_CHECK, &amp;mddev-&gt;recovery) &amp;&amp;
<span class="p_del">-	    mddev-&gt;curr_resync &gt; 2) {</span>
<span class="p_add">+	    mddev-&gt;curr_resync &gt; 3) {</span>
 		if (test_bit(MD_RECOVERY_SYNC, &amp;mddev-&gt;recovery)) {
 			if (test_bit(MD_RECOVERY_INTR, &amp;mddev-&gt;recovery)) {
 				if (mddev-&gt;curr_resync &gt;= mddev-&gt;recovery_cp) {
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 21dc00eb1989..95bf4cd8fcc0 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -407,11 +407,14 @@</span> <span class="p_context"> static void raid1_end_write_request(struct bio *bio)</span>
 	struct bio *to_put = NULL;
 	int mirror = find_bio_disk(r1_bio, bio);
 	struct md_rdev *rdev = conf-&gt;mirrors[mirror].rdev;
<span class="p_add">+	bool discard_error;</span>
<span class="p_add">+</span>
<span class="p_add">+	discard_error = bio-&gt;bi_error &amp;&amp; bio_op(bio) == REQ_OP_DISCARD;</span>
 
 	/*
 	 * &#39;one mirror IO has finished&#39; event handler:
 	 */
<span class="p_del">-	if (bio-&gt;bi_error) {</span>
<span class="p_add">+	if (bio-&gt;bi_error &amp;&amp; !discard_error) {</span>
 		set_bit(WriteErrorSeen,	&amp;rdev-&gt;flags);
 		if (!test_and_set_bit(WantReplacement, &amp;rdev-&gt;flags))
 			set_bit(MD_RECOVERY_NEEDED, &amp;
<span class="p_chunk">@@ -448,7 +451,7 @@</span> <span class="p_context"> static void raid1_end_write_request(struct bio *bio)</span>
 
 		/* Maybe we can clear some bad blocks. */
 		if (is_badblock(rdev, r1_bio-&gt;sector, r1_bio-&gt;sectors,
<span class="p_del">-				&amp;first_bad, &amp;bad_sectors)) {</span>
<span class="p_add">+				&amp;first_bad, &amp;bad_sectors) &amp;&amp; !discard_error) {</span>
 			r1_bio-&gt;bios[mirror] = IO_MADE_GOOD;
 			set_bit(R1BIO_MadeGood, &amp;r1_bio-&gt;state);
 		}
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index be1a9fca3b2d..39fddda2fef2 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -447,6 +447,9 @@</span> <span class="p_context"> static void raid10_end_write_request(struct bio *bio)</span>
 	struct r10conf *conf = r10_bio-&gt;mddev-&gt;private;
 	int slot, repl;
 	struct md_rdev *rdev = NULL;
<span class="p_add">+	bool discard_error;</span>
<span class="p_add">+</span>
<span class="p_add">+	discard_error = bio-&gt;bi_error &amp;&amp; bio_op(bio) == REQ_OP_DISCARD;</span>
 
 	dev = find_bio_disk(conf, r10_bio, bio, &amp;slot, &amp;repl);
 
<span class="p_chunk">@@ -460,7 +463,7 @@</span> <span class="p_context"> static void raid10_end_write_request(struct bio *bio)</span>
 	/*
 	 * this branch is our &#39;one mirror IO has finished&#39; event handler:
 	 */
<span class="p_del">-	if (bio-&gt;bi_error) {</span>
<span class="p_add">+	if (bio-&gt;bi_error &amp;&amp; !discard_error) {</span>
 		if (repl)
 			/* Never record new bad blocks to replacement,
 			 * just fail it.
<span class="p_chunk">@@ -503,7 +506,7 @@</span> <span class="p_context"> static void raid10_end_write_request(struct bio *bio)</span>
 		if (is_badblock(rdev,
 				r10_bio-&gt;devs[slot].addr,
 				r10_bio-&gt;sectors,
<span class="p_del">-				&amp;first_bad, &amp;bad_sectors)) {</span>
<span class="p_add">+				&amp;first_bad, &amp;bad_sectors) &amp;&amp; !discard_error) {</span>
 			bio_put(bio);
 			if (repl)
 				r10_bio-&gt;devs[slot].repl_bio = IO_MADE_GOOD;
<span class="p_header">diff --git a/drivers/media/platform/vsp1/vsp1_video.c b/drivers/media/platform/vsp1/vsp1_video.c</span>
<span class="p_header">index 9fb4fc26a359..ed9759e8a6fc 100644</span>
<span class="p_header">--- a/drivers/media/platform/vsp1/vsp1_video.c</span>
<span class="p_header">+++ b/drivers/media/platform/vsp1/vsp1_video.c</span>
<span class="p_chunk">@@ -675,6 +675,13 @@</span> <span class="p_context"> static void vsp1_video_stop_streaming(struct vb2_queue *vq)</span>
 	unsigned long flags;
 	int ret;
 
<span class="p_add">+	/* Clear the buffers ready flag to make sure the device won&#39;t be started</span>
<span class="p_add">+	 * by a QBUF on the video node on the other side of the pipeline.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock_irqsave(&amp;video-&gt;irqlock, flags);</span>
<span class="p_add">+	pipe-&gt;buffers_ready &amp;= ~(1 &lt;&lt; video-&gt;pipe_index);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;video-&gt;irqlock, flags);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;pipe-&gt;lock);
 	if (--pipe-&gt;stream_count == pipe-&gt;num_inputs) {
 		/* Stop the pipeline. */
<span class="p_header">diff --git a/drivers/misc/cxl/api.c b/drivers/misc/cxl/api.c</span>
<span class="p_header">index af23d7dfe752..2e5233b60971 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/api.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/api.c</span>
<span class="p_chunk">@@ -247,7 +247,9 @@</span> <span class="p_context"> int cxl_start_context(struct cxl_context *ctx, u64 wed,</span>
 	cxl_ctx_get();
 
 	if ((rc = cxl_ops-&gt;attach_process(ctx, kernel, wed, 0))) {
<span class="p_add">+		put_pid(ctx-&gt;glpid);</span>
 		put_pid(ctx-&gt;pid);
<span class="p_add">+		ctx-&gt;glpid = ctx-&gt;pid = NULL;</span>
 		cxl_adapter_context_put(ctx-&gt;afu-&gt;adapter);
 		cxl_ctx_put();
 		goto out;
<span class="p_header">diff --git a/drivers/misc/cxl/file.c b/drivers/misc/cxl/file.c</span>
<span class="p_header">index d0b421f49b39..77080cc5fa0a 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/file.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/file.c</span>
<span class="p_chunk">@@ -194,6 +194,16 @@</span> <span class="p_context"> static long afu_ioctl_start_work(struct cxl_context *ctx,</span>
 	ctx-&gt;mmio_err_ff = !!(work.flags &amp; CXL_START_WORK_ERR_FF);
 
 	/*
<span class="p_add">+	 * Increment the mapped context count for adapter. This also checks</span>
<span class="p_add">+	 * if adapter_context_lock is taken.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rc = cxl_adapter_context_get(ctx-&gt;afu-&gt;adapter);</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		afu_release_irqs(ctx, ctx);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
 	 * We grab the PID here and not in the file open to allow for the case
 	 * where a process (master, some daemon, etc) has opened the chardev on
 	 * behalf of another process, so the AFU&#39;s mm gets bound to the process
<span class="p_chunk">@@ -205,15 +215,6 @@</span> <span class="p_context"> static long afu_ioctl_start_work(struct cxl_context *ctx,</span>
 	ctx-&gt;pid = get_task_pid(current, PIDTYPE_PID);
 	ctx-&gt;glpid = get_task_pid(current-&gt;group_leader, PIDTYPE_PID);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Increment the mapped context count for adapter. This also checks</span>
<span class="p_del">-	 * if adapter_context_lock is taken.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	rc = cxl_adapter_context_get(ctx-&gt;afu-&gt;adapter);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		afu_release_irqs(ctx, ctx);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
 
 	trace_cxl_attach(ctx, work.work_element_descriptor, work.num_interrupts, amr);
 
<span class="p_chunk">@@ -221,6 +222,9 @@</span> <span class="p_context"> static long afu_ioctl_start_work(struct cxl_context *ctx,</span>
 							amr))) {
 		afu_release_irqs(ctx, ctx);
 		cxl_adapter_context_put(ctx-&gt;afu-&gt;adapter);
<span class="p_add">+		put_pid(ctx-&gt;glpid);</span>
<span class="p_add">+		put_pid(ctx-&gt;pid);</span>
<span class="p_add">+		ctx-&gt;glpid = ctx-&gt;pid = NULL;</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/drivers/misc/genwqe/card_utils.c b/drivers/misc/genwqe/card_utils.c</span>
<span class="p_header">index 222367cc8c81..524660510599 100644</span>
<span class="p_header">--- a/drivers/misc/genwqe/card_utils.c</span>
<span class="p_header">+++ b/drivers/misc/genwqe/card_utils.c</span>
<span class="p_chunk">@@ -352,17 +352,27 @@</span> <span class="p_context"> int genwqe_alloc_sync_sgl(struct genwqe_dev *cd, struct genwqe_sgl *sgl,</span>
 		if (copy_from_user(sgl-&gt;lpage, user_addr + user_size -
 				   sgl-&gt;lpage_size, sgl-&gt;lpage_size)) {
 			rc = -EFAULT;
<span class="p_del">-			goto err_out1;</span>
<span class="p_add">+			goto err_out2;</span>
 		}
 	}
 	return 0;
 
<span class="p_add">+ err_out2:</span>
<span class="p_add">+	__genwqe_free_consistent(cd, PAGE_SIZE, sgl-&gt;lpage,</span>
<span class="p_add">+				 sgl-&gt;lpage_dma_addr);</span>
<span class="p_add">+	sgl-&gt;lpage = NULL;</span>
<span class="p_add">+	sgl-&gt;lpage_dma_addr = 0;</span>
  err_out1:
 	__genwqe_free_consistent(cd, PAGE_SIZE, sgl-&gt;fpage,
 				 sgl-&gt;fpage_dma_addr);
<span class="p_add">+	sgl-&gt;fpage = NULL;</span>
<span class="p_add">+	sgl-&gt;fpage_dma_addr = 0;</span>
  err_out:
 	__genwqe_free_consistent(cd, sgl-&gt;sgl_size, sgl-&gt;sgl,
 				 sgl-&gt;sgl_dma_addr);
<span class="p_add">+	sgl-&gt;sgl = NULL;</span>
<span class="p_add">+	sgl-&gt;sgl_dma_addr = 0;</span>
<span class="p_add">+	sgl-&gt;sgl_size = 0;</span>
 	return -ENOMEM;
 }
 
<span class="p_header">diff --git a/drivers/misc/mei/hw-txe.c b/drivers/misc/mei/hw-txe.c</span>
<span class="p_header">index 4a6c1b85f11e..2d23cdf8a734 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-txe.c</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-txe.c</span>
<span class="p_chunk">@@ -978,11 +978,13 @@</span> <span class="p_context"> static bool mei_txe_check_and_ack_intrs(struct mei_device *dev, bool do_ack)</span>
 	hisr = mei_txe_br_reg_read(hw, HISR_REG);
 
 	aliveness = mei_txe_aliveness_get(dev);
<span class="p_del">-	if (hhisr &amp; IPC_HHIER_SEC &amp;&amp; aliveness)</span>
<span class="p_add">+	if (hhisr &amp; IPC_HHIER_SEC &amp;&amp; aliveness) {</span>
 		ipc_isr = mei_txe_sec_reg_read_silent(hw,
 				SEC_IPC_HOST_INT_STATUS_REG);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		ipc_isr = 0;
<span class="p_add">+		hhisr &amp;= ~IPC_HHIER_SEC;</span>
<span class="p_add">+	}</span>
 
 	generated = generated ||
 		(hisr &amp; HISR_INT_STS_MSK) ||
<span class="p_header">diff --git a/drivers/mmc/host/dw_mmc-pltfm.c b/drivers/mmc/host/dw_mmc-pltfm.c</span>
<span class="p_header">index c0bb0c793e84..dbbc4303bdd0 100644</span>
<span class="p_header">--- a/drivers/mmc/host/dw_mmc-pltfm.c</span>
<span class="p_header">+++ b/drivers/mmc/host/dw_mmc-pltfm.c</span>
<span class="p_chunk">@@ -46,12 +46,13 @@</span> <span class="p_context"> int dw_mci_pltfm_register(struct platform_device *pdev,</span>
 	host-&gt;pdata = pdev-&gt;dev.platform_data;
 
 	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
<span class="p_del">-	/* Get registers&#39; physical base address */</span>
<span class="p_del">-	host-&gt;phy_regs = regs-&gt;start;</span>
 	host-&gt;regs = devm_ioremap_resource(&amp;pdev-&gt;dev, regs);
 	if (IS_ERR(host-&gt;regs))
 		return PTR_ERR(host-&gt;regs);
 
<span class="p_add">+	/* Get registers&#39; physical base address */</span>
<span class="p_add">+	host-&gt;phy_regs = regs-&gt;start;</span>
<span class="p_add">+</span>
 	platform_set_drvdata(pdev, host);
 	return dw_mci_probe(host);
 }
<span class="p_header">diff --git a/drivers/mtd/ubi/fastmap.c b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">index 48eb55f344eb..a01a70a8fd3b 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_chunk">@@ -515,10 +515,11 @@</span> <span class="p_context"> static int scan_pool(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 			unsigned long long ec = be64_to_cpu(ech-&gt;ec);
 			unmap_peb(ai, pnum);
 			dbg_bld(&quot;Adding PEB to free: %i&quot;, pnum);
<span class="p_add">+</span>
 			if (err == UBI_IO_FF_BITFLIPS)
<span class="p_del">-				add_aeb(ai, free, pnum, ec, 1);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				add_aeb(ai, free, pnum, ec, 0);</span>
<span class="p_add">+				scrub = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			add_aeb(ai, free, pnum, ec, scrub);</span>
 			continue;
 		} else if (err == 0 || err == UBI_IO_BITFLIPS) {
 			dbg_bld(&quot;Found non empty PEB:%i in pool&quot;, pnum);
<span class="p_chunk">@@ -750,11 +751,11 @@</span> <span class="p_context"> static int ubi_attach_fastmap(struct ubi_device *ubi,</span>
 			     fmvhdr-&gt;vol_type,
 			     be32_to_cpu(fmvhdr-&gt;last_eb_bytes));
 
<span class="p_del">-		if (!av)</span>
<span class="p_del">-			goto fail_bad;</span>
<span class="p_del">-		if (PTR_ERR(av) == -EINVAL) {</span>
<span class="p_del">-			ubi_err(ubi, &quot;volume (ID %i) already exists&quot;,</span>
<span class="p_del">-				fmvhdr-&gt;vol_id);</span>
<span class="p_add">+		if (IS_ERR(av)) {</span>
<span class="p_add">+			if (PTR_ERR(av) == -EEXIST)</span>
<span class="p_add">+				ubi_err(ubi, &quot;volume (ID %i) already exists&quot;,</span>
<span class="p_add">+					fmvhdr-&gt;vol_id);</span>
<span class="p_add">+</span>
 			goto fail_bad;
 		}
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/core.h b/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_header">index 30ae5bf81611..76ad825a823d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/core.h</span>
<span class="p_chunk">@@ -445,6 +445,7 @@</span> <span class="p_context"> struct ath10k_debug {</span>
 	u32 pktlog_filter;
 	u32 reg_addr;
 	u32 nf_cal_period;
<span class="p_add">+	void *cal_data;</span>
 
 	struct ath10k_fw_crash_data *fw_crash_data;
 };
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath10k/debug.c b/drivers/net/wireless/ath/ath10k/debug.c</span>
<span class="p_header">index 8f0fd41dfd4b..8c6a5dd7e178 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath10k/debug.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath10k/debug.c</span>
<span class="p_chunk">@@ -30,6 +30,8 @@</span> <span class="p_context"></span>
 /* ms */
 #define ATH10K_DEBUG_HTT_STATS_INTERVAL 1000
 
<span class="p_add">+#define ATH10K_DEBUG_CAL_DATA_LEN 12064</span>
<span class="p_add">+</span>
 #define ATH10K_FW_CRASH_DUMP_VERSION 1
 
 /**
<span class="p_chunk">@@ -1450,56 +1452,51 @@</span> <span class="p_context"> static const struct file_operations fops_fw_dbglog = {</span>
 	.llseek = default_llseek,
 };
 
<span class="p_del">-static int ath10k_debug_cal_data_open(struct inode *inode, struct file *file)</span>
<span class="p_add">+static int ath10k_debug_cal_data_fetch(struct ath10k *ar)</span>
 {
<span class="p_del">-	struct ath10k *ar = inode-&gt;i_private;</span>
<span class="p_del">-	void *buf;</span>
 	u32 hi_addr;
 	__le32 addr;
 	int ret;
 
<span class="p_del">-	mutex_lock(&amp;ar-&gt;conf_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ar-&gt;state != ATH10K_STATE_ON &amp;&amp;</span>
<span class="p_del">-	    ar-&gt;state != ATH10K_STATE_UTF) {</span>
<span class="p_del">-		ret = -ENETDOWN;</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	lockdep_assert_held(&amp;ar-&gt;conf_mutex);</span>
 
<span class="p_del">-	buf = vmalloc(ar-&gt;hw_params.cal_data_len);</span>
<span class="p_del">-	if (!buf) {</span>
<span class="p_del">-		ret = -ENOMEM;</span>
<span class="p_del">-		goto err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (WARN_ON(ar-&gt;hw_params.cal_data_len &gt; ATH10K_DEBUG_CAL_DATA_LEN))</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	hi_addr = host_interest_item_address(HI_ITEM(hi_board_data));
 
 	ret = ath10k_hif_diag_read(ar, hi_addr, &amp;addr, sizeof(addr));
 	if (ret) {
<span class="p_del">-		ath10k_warn(ar, &quot;failed to read hi_board_data address: %d\n&quot;, ret);</span>
<span class="p_del">-		goto err_vfree;</span>
<span class="p_add">+		ath10k_warn(ar, &quot;failed to read hi_board_data address: %d\n&quot;,</span>
<span class="p_add">+			    ret);</span>
<span class="p_add">+		return ret;</span>
 	}
 
<span class="p_del">-	ret = ath10k_hif_diag_read(ar, le32_to_cpu(addr), buf,</span>
<span class="p_add">+	ret = ath10k_hif_diag_read(ar, le32_to_cpu(addr), ar-&gt;debug.cal_data,</span>
 				   ar-&gt;hw_params.cal_data_len);
 	if (ret) {
 		ath10k_warn(ar, &quot;failed to read calibration data: %d\n&quot;, ret);
<span class="p_del">-		goto err_vfree;</span>
<span class="p_add">+		return ret;</span>
 	}
 
<span class="p_del">-	file-&gt;private_data = buf;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	mutex_unlock(&amp;ar-&gt;conf_mutex);</span>
<span class="p_add">+static int ath10k_debug_cal_data_open(struct inode *inode, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ath10k *ar = inode-&gt;i_private;</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	mutex_lock(&amp;ar-&gt;conf_mutex);</span>
 
<span class="p_del">-err_vfree:</span>
<span class="p_del">-	vfree(buf);</span>
<span class="p_add">+	if (ar-&gt;state == ATH10K_STATE_ON ||</span>
<span class="p_add">+	    ar-&gt;state == ATH10K_STATE_UTF) {</span>
<span class="p_add">+		ath10k_debug_cal_data_fetch(ar);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-err:</span>
<span class="p_add">+	file-&gt;private_data = ar;</span>
 	mutex_unlock(&amp;ar-&gt;conf_mutex);
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static ssize_t ath10k_debug_cal_data_read(struct file *file,
<span class="p_chunk">@@ -1507,18 +1504,16 @@</span> <span class="p_context"> static ssize_t ath10k_debug_cal_data_read(struct file *file,</span>
 					  size_t count, loff_t *ppos)
 {
 	struct ath10k *ar = file-&gt;private_data;
<span class="p_del">-	void *buf = file-&gt;private_data;</span>
 
<span class="p_del">-	return simple_read_from_buffer(user_buf, count, ppos,</span>
<span class="p_del">-				       buf, ar-&gt;hw_params.cal_data_len);</span>
<span class="p_del">-}</span>
<span class="p_add">+	mutex_lock(&amp;ar-&gt;conf_mutex);</span>
 
<span class="p_del">-static int ath10k_debug_cal_data_release(struct inode *inode,</span>
<span class="p_del">-					 struct file *file)</span>
<span class="p_del">-{</span>
<span class="p_del">-	vfree(file-&gt;private_data);</span>
<span class="p_add">+	count = simple_read_from_buffer(user_buf, count, ppos,</span>
<span class="p_add">+					ar-&gt;debug.cal_data,</span>
<span class="p_add">+					ar-&gt;hw_params.cal_data_len);</span>
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	mutex_unlock(&amp;ar-&gt;conf_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return count;</span>
 }
 
 static ssize_t ath10k_write_ani_enable(struct file *file,
<span class="p_chunk">@@ -1579,7 +1574,6 @@</span> <span class="p_context"> static const struct file_operations fops_ani_enable = {</span>
 static const struct file_operations fops_cal_data = {
 	.open = ath10k_debug_cal_data_open,
 	.read = ath10k_debug_cal_data_read,
<span class="p_del">-	.release = ath10k_debug_cal_data_release,</span>
 	.owner = THIS_MODULE,
 	.llseek = default_llseek,
 };
<span class="p_chunk">@@ -1931,6 +1925,8 @@</span> <span class="p_context"> void ath10k_debug_stop(struct ath10k *ar)</span>
 {
 	lockdep_assert_held(&amp;ar-&gt;conf_mutex);
 
<span class="p_add">+	ath10k_debug_cal_data_fetch(ar);</span>
<span class="p_add">+</span>
 	/* Must not use _sync to avoid deadlock, we do that in
 	 * ath10k_debug_destroy(). The check for htt_stats_mask is to avoid
 	 * warning from del_timer(). */
<span class="p_chunk">@@ -2343,6 +2339,10 @@</span> <span class="p_context"> int ath10k_debug_create(struct ath10k *ar)</span>
 	if (!ar-&gt;debug.fw_crash_data)
 		return -ENOMEM;
 
<span class="p_add">+	ar-&gt;debug.cal_data = vzalloc(ATH10K_DEBUG_CAL_DATA_LEN);</span>
<span class="p_add">+	if (!ar-&gt;debug.cal_data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	INIT_LIST_HEAD(&amp;ar-&gt;debug.fw_stats.pdevs);
 	INIT_LIST_HEAD(&amp;ar-&gt;debug.fw_stats.vdevs);
 	INIT_LIST_HEAD(&amp;ar-&gt;debug.fw_stats.peers);
<span class="p_chunk">@@ -2356,6 +2356,9 @@</span> <span class="p_context"> void ath10k_debug_destroy(struct ath10k *ar)</span>
 	vfree(ar-&gt;debug.fw_crash_data);
 	ar-&gt;debug.fw_crash_data = NULL;
 
<span class="p_add">+	vfree(ar-&gt;debug.cal_data);</span>
<span class="p_add">+	ar-&gt;debug.cal_data = NULL;</span>
<span class="p_add">+</span>
 	ath10k_debug_fw_stats_reset(ar);
 
 	kfree(ar-&gt;debug.tpc_stats);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/ar9003_calib.c b/drivers/net/wireless/ath/ath9k/ar9003_calib.c</span>
<span class="p_header">index b6f064a8d264..7e27a06e5df1 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/ar9003_calib.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/ar9003_calib.c</span>
<span class="p_chunk">@@ -33,7 +33,6 @@</span> <span class="p_context"> struct coeff {</span>
 
 enum ar9003_cal_types {
 	IQ_MISMATCH_CAL = BIT(0),
<span class="p_del">-	TEMP_COMP_CAL = BIT(1),</span>
 };
 
 static void ar9003_hw_setup_calibration(struct ath_hw *ah,
<span class="p_chunk">@@ -59,12 +58,6 @@</span> <span class="p_context"> static void ar9003_hw_setup_calibration(struct ath_hw *ah,</span>
 		/* Kick-off cal */
 		REG_SET_BIT(ah, AR_PHY_TIMING4, AR_PHY_TIMING4_DO_CAL);
 		break;
<span class="p_del">-	case TEMP_COMP_CAL:</span>
<span class="p_del">-		ath_dbg(common, CALIBRATE,</span>
<span class="p_del">-			&quot;starting Temperature Compensation Calibration\n&quot;);</span>
<span class="p_del">-		REG_SET_BIT(ah, AR_CH0_THERM, AR_CH0_THERM_LOCAL);</span>
<span class="p_del">-		REG_SET_BIT(ah, AR_CH0_THERM, AR_CH0_THERM_START);</span>
<span class="p_del">-		break;</span>
 	default:
 		ath_err(common, &quot;Invalid calibration type\n&quot;);
 		break;
<span class="p_chunk">@@ -93,8 +86,7 @@</span> <span class="p_context"> static bool ar9003_hw_per_calibration(struct ath_hw *ah,</span>
 		/*
 		* Accumulate cal measures for active chains
 		*/
<span class="p_del">-		if (cur_caldata-&gt;calCollect)</span>
<span class="p_del">-			cur_caldata-&gt;calCollect(ah);</span>
<span class="p_add">+		cur_caldata-&gt;calCollect(ah);</span>
 		ah-&gt;cal_samples++;
 
 		if (ah-&gt;cal_samples &gt;= cur_caldata-&gt;calNumSamples) {
<span class="p_chunk">@@ -107,8 +99,7 @@</span> <span class="p_context"> static bool ar9003_hw_per_calibration(struct ath_hw *ah,</span>
 			/*
 			* Process accumulated data
 			*/
<span class="p_del">-			if (cur_caldata-&gt;calPostProc)</span>
<span class="p_del">-				cur_caldata-&gt;calPostProc(ah, numChains);</span>
<span class="p_add">+			cur_caldata-&gt;calPostProc(ah, numChains);</span>
 
 			/* Calibration has finished. */
 			caldata-&gt;CalValid |= cur_caldata-&gt;calType;
<span class="p_chunk">@@ -323,16 +314,9 @@</span> <span class="p_context"> static const struct ath9k_percal_data iq_cal_single_sample = {</span>
 	ar9003_hw_iqcalibrate
 };
 
<span class="p_del">-static const struct ath9k_percal_data temp_cal_single_sample = {</span>
<span class="p_del">-	TEMP_COMP_CAL,</span>
<span class="p_del">-	MIN_CAL_SAMPLES,</span>
<span class="p_del">-	PER_MAX_LOG_COUNT,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static void ar9003_hw_init_cal_settings(struct ath_hw *ah)
 {
 	ah-&gt;iq_caldata.calData = &amp;iq_cal_single_sample;
<span class="p_del">-	ah-&gt;temp_caldata.calData = &amp;temp_cal_single_sample;</span>
 
 	if (AR_SREV_9300_20_OR_LATER(ah)) {
 		ah-&gt;enabled_cals |= TX_IQ_CAL;
<span class="p_chunk">@@ -340,7 +324,7 @@</span> <span class="p_context"> static void ar9003_hw_init_cal_settings(struct ath_hw *ah)</span>
 			ah-&gt;enabled_cals |= TX_IQ_ON_AGC_CAL;
 	}
 
<span class="p_del">-	ah-&gt;supp_cals = IQ_MISMATCH_CAL | TEMP_COMP_CAL;</span>
<span class="p_add">+	ah-&gt;supp_cals = IQ_MISMATCH_CAL;</span>
 }
 
 #define OFF_UPPER_LT 24
<span class="p_chunk">@@ -1399,9 +1383,6 @@</span> <span class="p_context"> static void ar9003_hw_init_cal_common(struct ath_hw *ah)</span>
 	INIT_CAL(&amp;ah-&gt;iq_caldata);
 	INSERT_CAL(ah, &amp;ah-&gt;iq_caldata);
 
<span class="p_del">-	INIT_CAL(&amp;ah-&gt;temp_caldata);</span>
<span class="p_del">-	INSERT_CAL(ah, &amp;ah-&gt;temp_caldata);</span>
<span class="p_del">-</span>
 	/* Initialize current pointer to first element in list */
 	ah-&gt;cal_list_curr = ah-&gt;cal_list;
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/hw.h b/drivers/net/wireless/ath/ath9k/hw.h</span>
<span class="p_header">index 2a5d3ad1169c..9cbca1229bac 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/hw.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/hw.h</span>
<span class="p_chunk">@@ -830,7 +830,6 @@</span> <span class="p_context"> struct ath_hw {</span>
 	/* Calibration */
 	u32 supp_cals;
 	struct ath9k_cal_list iq_caldata;
<span class="p_del">-	struct ath9k_cal_list temp_caldata;</span>
 	struct ath9k_cal_list adcgain_caldata;
 	struct ath9k_cal_list adcdc_caldata;
 	struct ath9k_cal_list *cal_list;
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h</span>
<span class="p_header">index 4341d56805f8..a28093235ee0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu.h</span>
<span class="p_chunk">@@ -231,7 +231,7 @@</span> <span class="p_context"> struct rtl8xxxu_rxdesc16 {</span>
 	u32 pattern1match:1;
 	u32 pattern0match:1;
 #endif
<span class="p_del">-	__le32 tsfl;</span>
<span class="p_add">+	u32 tsfl;</span>
 #if 0
 	u32 bassn:12;
 	u32 bavld:1;
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> struct rtl8xxxu_rxdesc24 {</span>
 	u32 ldcp:1;
 	u32 splcp:1;
 #endif
<span class="p_del">-	__le32 tsfl;</span>
<span class="p_add">+	u32 tsfl;</span>
 };
 
 struct rtl8xxxu_txdesc32 {
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8723b.c b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8723b.c</span>
<span class="p_header">index 9d45afb0e3fd..c831a586766c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8723b.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_8723b.c</span>
<span class="p_chunk">@@ -1498,6 +1498,10 @@</span> <span class="p_context"> static void rtl8723b_enable_rf(struct rtl8xxxu_priv *priv)</span>
 	u32 val32;
 	u8 val8;
 
<span class="p_add">+	val32 = rtl8xxxu_read32(priv, REG_RX_WAIT_CCA);</span>
<span class="p_add">+	val32 |= (BIT(22) | BIT(23));</span>
<span class="p_add">+	rtl8xxxu_write32(priv, REG_RX_WAIT_CCA, val32);</span>
<span class="p_add">+</span>
 	/*
 	 * No indication anywhere as to what 0x0790 does. The 2 antenna
 	 * vendor code preserves bits 6-7 here.
<span class="p_header">diff --git a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c</span>
<span class="p_header">index 77048db3b32a..c6b246aa2419 100644</span>
<span class="p_header">--- a/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c</span>
<span class="p_header">+++ b/drivers/net/wireless/realtek/rtl8xxxu/rtl8xxxu_core.c</span>
<span class="p_chunk">@@ -5201,7 +5201,12 @@</span> <span class="p_context"> int rtl8xxxu_parse_rxdesc16(struct rtl8xxxu_priv *priv, struct sk_buff *skb)</span>
 		pkt_offset = roundup(pkt_len + drvinfo_sz + desc_shift +
 				     sizeof(struct rtl8xxxu_rxdesc16), 128);
 
<span class="p_del">-		if (pkt_cnt &gt; 1)</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Only clone the skb if there&#39;s enough data at the end to</span>
<span class="p_add">+		 * at least cover the rx descriptor</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (pkt_cnt &gt; 1 &amp;&amp;</span>
<span class="p_add">+		    urb_len &gt; (pkt_offset + sizeof(struct rtl8xxxu_rxdesc16)))</span>
 			next_skb = skb_clone(skb, GFP_ATOMIC);
 
 		rx_status = IEEE80211_SKB_RXCB(skb);
<span class="p_chunk">@@ -5219,7 +5224,7 @@</span> <span class="p_context"> int rtl8xxxu_parse_rxdesc16(struct rtl8xxxu_priv *priv, struct sk_buff *skb)</span>
 			rtl8xxxu_rx_parse_phystats(priv, rx_status, phy_stats,
 						   rx_desc-&gt;rxmcs);
 
<span class="p_del">-		rx_status-&gt;mactime = le32_to_cpu(rx_desc-&gt;tsfl);</span>
<span class="p_add">+		rx_status-&gt;mactime = rx_desc-&gt;tsfl;</span>
 		rx_status-&gt;flag |= RX_FLAG_MACTIME_START;
 
 		if (!rx_desc-&gt;swdec)
<span class="p_chunk">@@ -5289,7 +5294,7 @@</span> <span class="p_context"> int rtl8xxxu_parse_rxdesc24(struct rtl8xxxu_priv *priv, struct sk_buff *skb)</span>
 		rtl8xxxu_rx_parse_phystats(priv, rx_status, phy_stats,
 					   rx_desc-&gt;rxmcs);
 
<span class="p_del">-	rx_status-&gt;mactime = le32_to_cpu(rx_desc-&gt;tsfl);</span>
<span class="p_add">+	rx_status-&gt;mactime = rx_desc-&gt;tsfl;</span>
 	rx_status-&gt;flag |= RX_FLAG_MACTIME_START;
 
 	if (!rx_desc-&gt;swdec)
<span class="p_header">diff --git a/drivers/pwm/core.c b/drivers/pwm/core.c</span>
<span class="p_header">index 0dbd29e287db..172ef8245811 100644</span>
<span class="p_header">--- a/drivers/pwm/core.c</span>
<span class="p_header">+++ b/drivers/pwm/core.c</span>
<span class="p_chunk">@@ -339,6 +339,8 @@</span> <span class="p_context"> int pwmchip_remove(struct pwm_chip *chip)</span>
 	unsigned int i;
 	int ret = 0;
 
<span class="p_add">+	pwmchip_sysfs_unexport_children(chip);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;pwm_lock);
 
 	for (i = 0; i &lt; chip-&gt;npwm; i++) {
<span class="p_header">diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c</span>
<span class="p_header">index 18ed725594c3..0296d8178ae2 100644</span>
<span class="p_header">--- a/drivers/pwm/sysfs.c</span>
<span class="p_header">+++ b/drivers/pwm/sysfs.c</span>
<span class="p_chunk">@@ -409,6 +409,24 @@</span> <span class="p_context"> void pwmchip_sysfs_unexport(struct pwm_chip *chip)</span>
 	}
 }
 
<span class="p_add">+void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *parent;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	parent = class_find_device(&amp;pwm_class, NULL, chip,</span>
<span class="p_add">+				   pwmchip_sysfs_match);</span>
<span class="p_add">+	if (!parent)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; chip-&gt;npwm; i++) {</span>
<span class="p_add">+		struct pwm_device *pwm = &amp;chip-&gt;pwms[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (test_bit(PWMF_EXPORTED, &amp;pwm-&gt;flags))</span>
<span class="p_add">+			pwm_unexport_child(parent, pwm);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init pwm_sysfs_init(void)
 {
 	return class_register(&amp;pwm_class);
<span class="p_header">diff --git a/drivers/scsi/arcmsr/arcmsr_hba.c b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">index 3d53d636b17b..f0cfb0451757 100644</span>
<span class="p_header">--- a/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">+++ b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_chunk">@@ -2636,18 +2636,9 @@</span> <span class="p_context"> static int arcmsr_queue_command_lck(struct scsi_cmnd *cmd,</span>
 	struct AdapterControlBlock *acb = (struct AdapterControlBlock *) host-&gt;hostdata;
 	struct CommandControlBlock *ccb;
 	int target = cmd-&gt;device-&gt;id;
<span class="p_del">-	int lun = cmd-&gt;device-&gt;lun;</span>
<span class="p_del">-	uint8_t scsicmd = cmd-&gt;cmnd[0];</span>
 	cmd-&gt;scsi_done = done;
 	cmd-&gt;host_scribble = NULL;
 	cmd-&gt;result = 0;
<span class="p_del">-	if ((scsicmd == SYNCHRONIZE_CACHE) ||(scsicmd == SEND_DIAGNOSTIC)){</span>
<span class="p_del">-		if(acb-&gt;devstate[target][lun] == ARECA_RAID_GONE) {</span>
<span class="p_del">-    			cmd-&gt;result = (DID_NO_CONNECT &lt;&lt; 16);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		cmd-&gt;scsi_done(cmd);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 	if (target == 16) {
 		/* virtual device for iop message transfer */
 		arcmsr_handle_virtual_command(acb, cmd);
<span class="p_header">diff --git a/drivers/scsi/scsi_debug.c b/drivers/scsi/scsi_debug.c</span>
<span class="p_header">index 6a219a0844d3..05e892a231a5 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_debug.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_debug.c</span>
<span class="p_chunk">@@ -5134,6 +5134,7 @@</span> <span class="p_context"> static void __exit scsi_debug_exit(void)</span>
 	bus_unregister(&amp;pseudo_lld_bus);
 	root_device_unregister(pseudo_primary);
 
<span class="p_add">+	vfree(map_storep);</span>
 	vfree(dif_storep);
 	vfree(fake_storep);
 	kfree(sdebug_q_arr);
<span class="p_header">diff --git a/drivers/spi/spi-fsl-espi.c b/drivers/spi/spi-fsl-espi.c</span>
<span class="p_header">index 8d85a3c343da..3f3561371410 100644</span>
<span class="p_header">--- a/drivers/spi/spi-fsl-espi.c</span>
<span class="p_header">+++ b/drivers/spi/spi-fsl-espi.c</span>
<span class="p_chunk">@@ -581,7 +581,7 @@</span> <span class="p_context"> void fsl_espi_cpu_irq(struct mpc8xxx_spi *mspi, u32 events)</span>
 
 		mspi-&gt;len -= rx_nr_bytes;
 
<span class="p_del">-		if (mspi-&gt;rx)</span>
<span class="p_add">+		if (rx_nr_bytes &amp;&amp; mspi-&gt;rx)</span>
 			mspi-&gt;get_rx(rx_data, mspi);
 	}
 
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index 200ca228d885..935f1a511856 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -1607,9 +1607,11 @@</span> <span class="p_context"> static void of_register_spi_devices(struct spi_master *master)</span>
 		if (of_node_test_and_set_flag(nc, OF_POPULATED))
 			continue;
 		spi = of_register_spi_device(master, nc);
<span class="p_del">-		if (IS_ERR(spi))</span>
<span class="p_add">+		if (IS_ERR(spi)) {</span>
 			dev_warn(&amp;master-&gt;dev, &quot;Failed to create SPI device for %s\n&quot;,
 				nc-&gt;full_name);
<span class="p_add">+			of_node_clear_flag(nc, OF_POPULATED);</span>
<span class="p_add">+		}</span>
 	}
 }
 #else
<span class="p_chunk">@@ -3120,6 +3122,7 @@</span> <span class="p_context"> static int of_spi_notify(struct notifier_block *nb, unsigned long action,</span>
 		if (IS_ERR(spi)) {
 			pr_err(&quot;%s: failed to create for &#39;%s&#39;\n&quot;,
 					__func__, rd-&gt;dn-&gt;full_name);
<span class="p_add">+			of_node_clear_flag(rd-&gt;dn, OF_POPULATED);</span>
 			return notifier_from_errno(PTR_ERR(spi));
 		}
 		break;
<span class="p_header">diff --git a/drivers/staging/wilc1000/host_interface.c b/drivers/staging/wilc1000/host_interface.c</span>
<span class="p_header">index 78f524fcd214..f4dbcb19d7c5 100644</span>
<span class="p_header">--- a/drivers/staging/wilc1000/host_interface.c</span>
<span class="p_header">+++ b/drivers/staging/wilc1000/host_interface.c</span>
<span class="p_chunk">@@ -3391,7 +3391,6 @@</span> <span class="p_context"> int wilc_init(struct net_device *dev, struct host_if_drv **hif_drv_handler)</span>
 
 	clients_count++;
 
<span class="p_del">-	destroy_workqueue(hif_workqueue);</span>
 _fail_:
 	return result;
 }
<span class="p_header">diff --git a/drivers/thermal/intel_powerclamp.c b/drivers/thermal/intel_powerclamp.c</span>
<span class="p_header">index 0e4dc0afcfd2..7a223074df3d 100644</span>
<span class="p_header">--- a/drivers/thermal/intel_powerclamp.c</span>
<span class="p_header">+++ b/drivers/thermal/intel_powerclamp.c</span>
<span class="p_chunk">@@ -669,20 +669,10 @@</span> <span class="p_context"> static struct thermal_cooling_device_ops powerclamp_cooling_ops = {</span>
 	.set_cur_state = powerclamp_set_cur_state,
 };
 
<span class="p_del">-static const struct x86_cpu_id intel_powerclamp_ids[] __initconst = {</span>
<span class="p_del">-	{ X86_VENDOR_INTEL, X86_FAMILY_ANY, X86_MODEL_ANY, X86_FEATURE_MWAIT },</span>
<span class="p_del">-	{ X86_VENDOR_INTEL, X86_FAMILY_ANY, X86_MODEL_ANY, X86_FEATURE_ARAT },</span>
<span class="p_del">-	{ X86_VENDOR_INTEL, X86_FAMILY_ANY, X86_MODEL_ANY, X86_FEATURE_NONSTOP_TSC },</span>
<span class="p_del">-	{ X86_VENDOR_INTEL, X86_FAMILY_ANY, X86_MODEL_ANY, X86_FEATURE_CONSTANT_TSC},</span>
<span class="p_del">-	{}</span>
<span class="p_del">-};</span>
<span class="p_del">-MODULE_DEVICE_TABLE(x86cpu, intel_powerclamp_ids);</span>
<span class="p_del">-</span>
 static int __init powerclamp_probe(void)
 {
<span class="p_del">-	if (!x86_match_cpu(intel_powerclamp_ids)) {</span>
<span class="p_del">-		pr_err(&quot;Intel powerclamp does not run on family %d model %d\n&quot;,</span>
<span class="p_del">-				boot_cpu_data.x86, boot_cpu_data.x86_model);</span>
<span class="p_add">+	if (!boot_cpu_has(X86_FEATURE_MWAIT)) {</span>
<span class="p_add">+		pr_err(&quot;CPU does not support MWAIT&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 2705ca960e92..fd375f15bbbd 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -870,10 +870,15 @@</span> <span class="p_context"> static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,</span>
 	if (new_cols == vc-&gt;vc_cols &amp;&amp; new_rows == vc-&gt;vc_rows)
 		return 0;
 
<span class="p_add">+	if (new_screen_size &gt; (4 &lt;&lt; 20))</span>
<span class="p_add">+		return -EINVAL;</span>
 	newscreen = kmalloc(new_screen_size, GFP_USER);
 	if (!newscreen)
 		return -ENOMEM;
 
<span class="p_add">+	if (vc == sel_cons)</span>
<span class="p_add">+		clear_selection();</span>
<span class="p_add">+</span>
 	old_rows = vc-&gt;vc_rows;
 	old_row_size = vc-&gt;vc_size_row;
 
<span class="p_chunk">@@ -1176,7 +1181,7 @@</span> <span class="p_context"> static void csi_J(struct vc_data *vc, int vpar)</span>
 			break;
 		case 3: /* erase scroll-back buffer (and whole display) */
 			scr_memsetw(vc-&gt;vc_screenbuf, vc-&gt;vc_video_erase_char,
<span class="p_del">-				    vc-&gt;vc_screenbuf_size &gt;&gt; 1);</span>
<span class="p_add">+				    vc-&gt;vc_screenbuf_size);</span>
 			set_origin(vc);
 			if (con_is_visible(vc))
 				update_screen(vc);
<span class="p_header">diff --git a/drivers/usb/chipidea/host.c b/drivers/usb/chipidea/host.c</span>
<span class="p_header">index 053bac9d983c..887be343fcd4 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/host.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/host.c</span>
<span class="p_chunk">@@ -185,6 +185,8 @@</span> <span class="p_context"> static void host_stop(struct ci_hdrc *ci)</span>
 
 	if (hcd) {
 		usb_remove_hcd(hcd);
<span class="p_add">+		ci-&gt;role = CI_ROLE_END;</span>
<span class="p_add">+		synchronize_irq(ci-&gt;irq);</span>
 		usb_put_hcd(hcd);
 		if (ci-&gt;platdata-&gt;reg_vbus &amp;&amp; !ci_otg_is_fsm_mode(ci) &amp;&amp;
 			(ci-&gt;platdata-&gt;flags &amp; CI_HDRC_TURN_VBUS_EARLY_ON))
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 68544618982e..6443cfba7b55 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -3055,7 +3055,7 @@</span> <span class="p_context"> err3:</span>
 	kfree(dwc-&gt;setup_buf);
 
 err2:
<span class="p_del">-	dma_free_coherent(dwc-&gt;dev, sizeof(*dwc-&gt;ep0_trb),</span>
<span class="p_add">+	dma_free_coherent(dwc-&gt;dev, sizeof(*dwc-&gt;ep0_trb) * 2,</span>
 			dwc-&gt;ep0_trb, dwc-&gt;ep0_trb_addr);
 
 err1:
<span class="p_chunk">@@ -3080,7 +3080,7 @@</span> <span class="p_context"> void dwc3_gadget_exit(struct dwc3 *dwc)</span>
 	kfree(dwc-&gt;setup_buf);
 	kfree(dwc-&gt;zlp_buf);
 
<span class="p_del">-	dma_free_coherent(dwc-&gt;dev, sizeof(*dwc-&gt;ep0_trb),</span>
<span class="p_add">+	dma_free_coherent(dwc-&gt;dev, sizeof(*dwc-&gt;ep0_trb) * 2,</span>
 			dwc-&gt;ep0_trb, dwc-&gt;ep0_trb_addr);
 
 	dma_free_coherent(dwc-&gt;dev, sizeof(*dwc-&gt;ctrl_req),
<span class="p_header">diff --git a/drivers/usb/gadget/function/u_ether.c b/drivers/usb/gadget/function/u_ether.c</span>
<span class="p_header">index 5f562c1ec795..9b9e71f2c66e 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/u_ether.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/u_ether.c</span>
<span class="p_chunk">@@ -587,8 +587,9 @@</span> <span class="p_context"> static netdev_tx_t eth_start_xmit(struct sk_buff *skb,</span>
 
 	/* throttle high/super speed IRQ rate back slightly */
 	if (gadget_is_dualspeed(dev-&gt;gadget))
<span class="p_del">-		req-&gt;no_interrupt = (dev-&gt;gadget-&gt;speed == USB_SPEED_HIGH ||</span>
<span class="p_del">-				     dev-&gt;gadget-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_add">+		req-&gt;no_interrupt = (((dev-&gt;gadget-&gt;speed == USB_SPEED_HIGH ||</span>
<span class="p_add">+				       dev-&gt;gadget-&gt;speed == USB_SPEED_SUPER)) &amp;&amp;</span>
<span class="p_add">+					!list_empty(&amp;dev-&gt;tx_reqs))</span>
 			? ((atomic_read(&amp;dev-&gt;tx_qlen) % dev-&gt;qmult) != 0)
 			: 0;
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/atmel_usba_udc.c b/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_header">index bb1f6c8f0f01..45bc997d0711 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/atmel_usba_udc.c</span>
<span class="p_chunk">@@ -1978,7 +1978,7 @@</span> <span class="p_context"> static struct usba_ep * atmel_udc_of_init(struct platform_device *pdev,</span>
 			dev_err(&amp;pdev-&gt;dev, &quot;of_probe: name error(%d)\n&quot;, ret);
 			goto err;
 		}
<span class="p_del">-		ep-&gt;ep.name = name;</span>
<span class="p_add">+		ep-&gt;ep.name = kasprintf(GFP_KERNEL, &quot;ep%d&quot;, ep-&gt;index);</span>
 
 		ep-&gt;ep_regs = udc-&gt;regs + USBA_EPT_BASE(i);
 		ep-&gt;dma_regs = udc-&gt;regs + USBA_DMA_BASE(i);
<span class="p_header">diff --git a/drivers/usb/host/ohci-hcd.c b/drivers/usb/host/ohci-hcd.c</span>
<span class="p_header">index 1700908b84ef..86612ac3fda2 100644</span>
<span class="p_header">--- a/drivers/usb/host/ohci-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/ohci-hcd.c</span>
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"></span>
 static const char	hcd_name [] = &quot;ohci_hcd&quot;;
 
 #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
<span class="p_del">-#define	IO_WATCHDOG_DELAY	msecs_to_jiffies(250)</span>
<span class="p_add">+#define	IO_WATCHDOG_DELAY	msecs_to_jiffies(275)</span>
 
 #include &quot;ohci.h&quot;
 #include &quot;pci-quirks.h&quot;
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 730b9fd26685..0ef16900efed 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -1166,7 +1166,7 @@</span> <span class="p_context"> int xhci_hub_control(struct usb_hcd *hcd, u16 typeReq, u16 wValue,</span>
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_RESUME);
 				spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_del">-				msleep(20);</span>
<span class="p_add">+				msleep(USB_RESUME_TIMEOUT);</span>
 				spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 				xhci_set_link_state(xhci, port_array, wIndex,
 							XDEV_U0);
<span class="p_chunk">@@ -1355,6 +1355,35 @@</span> <span class="p_context"> int xhci_bus_suspend(struct usb_hcd *hcd)</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Workaround for missing Cold Attach Status (CAS) if device re-plugged in S3.</span>
<span class="p_add">+ * warm reset a USB3 device stuck in polling or compliance mode after resume.</span>
<span class="p_add">+ * See Intel 100/c230 series PCH specification update Doc #332692-006 Errata #8</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool xhci_port_missing_cas_quirk(int port_index,</span>
<span class="p_add">+					     __le32 __iomem **port_array)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 portsc;</span>
<span class="p_add">+</span>
<span class="p_add">+	portsc = readl(port_array[port_index]);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if any of these are set we are not stuck */</span>
<span class="p_add">+	if (portsc &amp; (PORT_CONNECT | PORT_CAS))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (((portsc &amp; PORT_PLS_MASK) != XDEV_POLLING) &amp;&amp;</span>
<span class="p_add">+	    ((portsc &amp; PORT_PLS_MASK) != XDEV_COMP_MODE))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear wakeup/change bits, and do a warm port reset */</span>
<span class="p_add">+	portsc &amp;= ~(PORT_RWC_BITS | PORT_CEC | PORT_WAKE_BITS);</span>
<span class="p_add">+	portsc |= PORT_WR;</span>
<span class="p_add">+	writel(portsc, port_array[port_index]);</span>
<span class="p_add">+	/* flush write */</span>
<span class="p_add">+	readl(port_array[port_index]);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int xhci_bus_resume(struct usb_hcd *hcd)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
<span class="p_chunk">@@ -1392,6 +1421,14 @@</span> <span class="p_context"> int xhci_bus_resume(struct usb_hcd *hcd)</span>
 		u32 temp;
 
 		temp = readl(port_array[port_index]);
<span class="p_add">+</span>
<span class="p_add">+		/* warm reset CAS limited ports stuck in polling/compliance */</span>
<span class="p_add">+		if ((xhci-&gt;quirks &amp; XHCI_MISSING_CAS) &amp;&amp;</span>
<span class="p_add">+		    (hcd-&gt;speed &gt;= HCD_USB3) &amp;&amp;</span>
<span class="p_add">+		    xhci_port_missing_cas_quirk(port_index, port_array)) {</span>
<span class="p_add">+			xhci_dbg(xhci, &quot;reset stuck port %d\n&quot;, port_index);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 		if (DEV_SUPERSPEED_ANY(temp))
 			temp &amp;= ~(PORT_RWC_BITS | PORT_CEC | PORT_WAKE_BITS);
 		else
<span class="p_chunk">@@ -1410,7 +1447,7 @@</span> <span class="p_context"> int xhci_bus_resume(struct usb_hcd *hcd)</span>
 
 	if (need_usb2_u3_exit) {
 		spin_unlock_irqrestore(&amp;xhci-&gt;lock, flags);
<span class="p_del">-		msleep(20);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		spin_lock_irqsave(&amp;xhci-&gt;lock, flags);
 	}
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index d7b0f97abbad..e96ae80d107e 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -45,11 +45,13 @@</span> <span class="p_context"></span>
 
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI	0x9cb1</span>
 #define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
 #define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -153,7 +155,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
<span class="p_del">-		pdev-&gt;device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {</span>
<span class="p_add">+		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
 		xhci-&gt;quirks |= XHCI_SPURIOUS_WAKEUP;
 	}
<span class="p_chunk">@@ -169,6 +172,11 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI) {
 		xhci-&gt;quirks |= XHCI_SSIC_PORT_UNUSED;
 	}
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;</span>
<span class="p_add">+	    (pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||</span>
<span class="p_add">+	     pdev-&gt;device == PCI_DEVICE_ID_INTEL_APL_XHCI))</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_MISSING_CAS;</span>
<span class="p_add">+</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
 			pdev-&gt;device == PCI_DEVICE_ID_EJ168) {
 		xhci-&gt;quirks |= XHCI_RESET_ON_RESUME;
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index b2c1dc5dc0f3..f945380035d0 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -314,6 +314,8 @@</span> <span class="p_context"> struct xhci_op_regs {</span>
 #define XDEV_U2		(0x2 &lt;&lt; 5)
 #define XDEV_U3		(0x3 &lt;&lt; 5)
 #define XDEV_INACTIVE	(0x6 &lt;&lt; 5)
<span class="p_add">+#define XDEV_POLLING	(0x7 &lt;&lt; 5)</span>
<span class="p_add">+#define XDEV_COMP_MODE  (0xa &lt;&lt; 5)</span>
 #define XDEV_RESUME	(0xf &lt;&lt; 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 &lt;&lt; 9)
<span class="p_chunk">@@ -1653,6 +1655,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 #define XHCI_MTK_HOST		(1 &lt;&lt; 21)
 #define XHCI_SSIC_PORT_UNUSED	(1 &lt;&lt; 22)
 #define XHCI_NO_64BIT_SUPPORT	(1 &lt;&lt; 23)
<span class="p_add">+#define XHCI_MISSING_CAS	(1 &lt;&lt; 24)</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/musb/omap2430.c b/drivers/usb/musb/omap2430.c</span>
<span class="p_header">index 0b4cec940386..dae92de92592 100644</span>
<span class="p_header">--- a/drivers/usb/musb/omap2430.c</span>
<span class="p_header">+++ b/drivers/usb/musb/omap2430.c</span>
<span class="p_chunk">@@ -337,6 +337,7 @@</span> <span class="p_context"> static int omap2430_musb_init(struct musb *musb)</span>
 	}
 	musb-&gt;isr = omap2430_musb_interrupt;
 	phy_init(musb-&gt;phy);
<span class="p_add">+	phy_power_on(musb-&gt;phy);</span>
 
 	l = musb_readl(musb-&gt;mregs, OTG_INTERFSEL);
 
<span class="p_chunk">@@ -373,8 +374,6 @@</span> <span class="p_context"> static void omap2430_musb_enable(struct musb *musb)</span>
 	struct musb_hdrc_platform_data *pdata = dev_get_platdata(dev);
 	struct omap_musb_board_data *data = pdata-&gt;board_data;
 
<span class="p_del">-	if (!WARN_ON(!musb-&gt;phy))</span>
<span class="p_del">-		phy_power_on(musb-&gt;phy);</span>
 
 	omap2430_set_power(musb, true, glue-&gt;cable_connected);
 
<span class="p_chunk">@@ -413,9 +412,6 @@</span> <span class="p_context"> static void omap2430_musb_disable(struct musb *musb)</span>
 	struct device *dev = musb-&gt;controller;
 	struct omap2430_glue *glue = dev_get_drvdata(dev-&gt;parent);
 
<span class="p_del">-	if (!WARN_ON(!musb-&gt;phy))</span>
<span class="p_del">-		phy_power_off(musb-&gt;phy);</span>
<span class="p_del">-</span>
 	if (glue-&gt;status != MUSB_UNKNOWN)
 		omap_control_usb_set_mode(glue-&gt;control_otghs,
 			USB_MODE_DISCONNECT);
<span class="p_chunk">@@ -429,6 +425,7 @@</span> <span class="p_context"> static int omap2430_musb_exit(struct musb *musb)</span>
 	struct omap2430_glue *glue = dev_get_drvdata(dev-&gt;parent);
 
 	omap2430_low_level_exit(musb);
<span class="p_add">+	phy_power_off(musb-&gt;phy);</span>
 	phy_exit(musb-&gt;phy);
 	musb-&gt;phy = NULL;
 	cancel_work_sync(&amp;glue-&gt;omap_musb_mailbox_work);
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/rcar3.c b/drivers/usb/renesas_usbhs/rcar3.c</span>
<span class="p_header">index 1d70add926f0..d544b331c9f2 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/rcar3.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/rcar3.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  *
  */
 
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/io.h&gt;
 #include &quot;common.h&quot;
 #include &quot;rcar3.h&quot;
<span class="p_chunk">@@ -35,10 +36,13 @@</span> <span class="p_context"> static int usbhs_rcar3_power_ctrl(struct platform_device *pdev,</span>
 
 	usbhs_write32(priv, UGCTRL2, UGCTRL2_RESERVED_3 | UGCTRL2_USB0SEL_OTG);
 
<span class="p_del">-	if (enable)</span>
<span class="p_add">+	if (enable) {</span>
 		usbhs_bset(priv, LPSTS, LPSTS_SUSPM, LPSTS_SUSPM);
<span class="p_del">-	else</span>
<span class="p_add">+		/* The controller on R-Car Gen3 needs to wait up to 45 usec */</span>
<span class="p_add">+		udelay(45);</span>
<span class="p_add">+	} else {</span>
 		usbhs_bset(priv, LPSTS, LPSTS_SUSPM, 0);
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 54a4de0efdba..f61477bed3a8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -1077,7 +1077,9 @@</span> <span class="p_context"> static int cp210x_tiocmget(struct tty_struct *tty)</span>
 	u8 control;
 	int result;
 
<span class="p_del">-	cp210x_read_u8_reg(port, CP210X_GET_MDMSTS, &amp;control);</span>
<span class="p_add">+	result = cp210x_read_u8_reg(port, CP210X_GET_MDMSTS, &amp;control);</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		return result;</span>
 
 	result = ((control &amp; CONTROL_DTR) ? TIOCM_DTR : 0)
 		|((control &amp; CONTROL_RTS) ? TIOCM_RTS : 0)
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index b2d767e743fc..0ff7f38d7800 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -986,7 +986,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	/* ekey Devices */
 	{ USB_DEVICE(FTDI_VID, FTDI_EKEY_CONV_USB_PID) },
 	/* Infineon Devices */
<span class="p_del">-	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_PID, 1) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC1798_PID, 1) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC2X7_PID, 1) },</span>
 	/* GE Healthcare devices */
 	{ USB_DEVICE(GE_HEALTHCARE_VID, GE_HEALTHCARE_NEMO_TRACKER_PID) },
 	/* Active Research (Actisense) devices */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index f87a938cf005..21011c0a4c64 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -626,8 +626,9 @@</span> <span class="p_context"></span>
 /*
  * Infineon Technologies
  */
<span class="p_del">-#define INFINEON_VID		0x058b</span>
<span class="p_del">-#define INFINEON_TRIBOARD_PID	0x0028 /* DAS JTAG TriBoard TC1798 V1.0 */</span>
<span class="p_add">+#define INFINEON_VID		        0x058b</span>
<span class="p_add">+#define INFINEON_TRIBOARD_TC1798_PID	0x0028 /* DAS JTAG TriBoard TC1798 V1.0 */</span>
<span class="p_add">+#define INFINEON_TRIBOARD_TC2X7_PID	0x0043 /* DAS JTAG TriBoard TC2X7 V1.0 */</span>
 
 /*
  * Acton Research Corp.
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index d213cf44a7e4..4a037b4a79cf 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1078,7 +1078,8 @@</span> <span class="p_context"> static int usb_serial_probe(struct usb_interface *interface,</span>
 
 	serial-&gt;disconnected = 0;
 
<span class="p_del">-	usb_serial_console_init(serial-&gt;port[0]-&gt;minor);</span>
<span class="p_add">+	if (num_ports &gt; 0)</span>
<span class="p_add">+		usb_serial_console_init(serial-&gt;port[0]-&gt;minor);</span>
 exit:
 	module_put(type-&gt;driver.owner);
 	return 0;
<span class="p_header">diff --git a/drivers/video/fbdev/omap2/omapfb/dss/dsi.c b/drivers/video/fbdev/omap2/omapfb/dss/dsi.c</span>
<span class="p_header">index 9e4800a4e3d1..951dd93f89b2 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/omap2/omapfb/dss/dsi.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/omap2/omapfb/dss/dsi.c</span>
<span class="p_chunk">@@ -5348,7 +5348,7 @@</span> <span class="p_context"> static int dsi_bind(struct device *dev, struct device *master, void *data)</span>
 
 	dsi-&gt;phy_base = devm_ioremap(&amp;dsidev-&gt;dev, res-&gt;start,
 		resource_size(res));
<span class="p_del">-	if (!dsi-&gt;proto_base) {</span>
<span class="p_add">+	if (!dsi-&gt;phy_base) {</span>
 		DSSERR(&quot;can&#39;t ioremap DSI PHY\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -5368,7 +5368,7 @@</span> <span class="p_context"> static int dsi_bind(struct device *dev, struct device *master, void *data)</span>
 
 	dsi-&gt;pll_base = devm_ioremap(&amp;dsidev-&gt;dev, res-&gt;start,
 		resource_size(res));
<span class="p_del">-	if (!dsi-&gt;proto_base) {</span>
<span class="p_add">+	if (!dsi-&gt;pll_base) {</span>
 		DSSERR(&quot;can&#39;t ioremap DSI PLL\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_header">diff --git a/drivers/video/fbdev/pxafb.c b/drivers/video/fbdev/pxafb.c</span>
<span class="p_header">index 2c0487f4f805..ed41fdb42d13 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/pxafb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/pxafb.c</span>
<span class="p_chunk">@@ -2125,7 +2125,7 @@</span> <span class="p_context"> static int of_get_pxafb_display(struct device *dev, struct device_node *disp,</span>
 
 	timings = of_get_display_timings(disp);
 	if (!timings)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	ret = -ENOMEM;
 	info-&gt;modes = kmalloc_array(timings-&gt;num_timings,
<span class="p_header">diff --git a/drivers/virtio/virtio_pci_legacy.c b/drivers/virtio/virtio_pci_legacy.c</span>
<span class="p_header">index 8c4e61783441..6d9e5173d5fa 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_pci_legacy.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_pci_legacy.c</span>
<span class="p_chunk">@@ -212,10 +212,18 @@</span> <span class="p_context"> int virtio_pci_legacy_probe(struct virtio_pci_device *vp_dev)</span>
 		return -ENODEV;
 	}
 
<span class="p_del">-	rc = dma_set_mask_and_coherent(&amp;pci_dev-&gt;dev, DMA_BIT_MASK(64));</span>
<span class="p_del">-	if (rc)</span>
<span class="p_del">-		rc = dma_set_mask_and_coherent(&amp;pci_dev-&gt;dev,</span>
<span class="p_del">-						DMA_BIT_MASK(32));</span>
<span class="p_add">+	rc = dma_set_mask(&amp;pci_dev-&gt;dev, DMA_BIT_MASK(64));</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		rc = dma_set_mask_and_coherent(&amp;pci_dev-&gt;dev, DMA_BIT_MASK(32));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The virtio ring base address is expressed as a 32-bit PFN,</span>
<span class="p_add">+		 * with a page size of 1 &lt;&lt; VIRTIO_PCI_QUEUE_ADDR_SHIFT.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		dma_set_coherent_mask(&amp;pci_dev-&gt;dev,</span>
<span class="p_add">+				DMA_BIT_MASK(32 + VIRTIO_PCI_QUEUE_ADDR_SHIFT));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (rc)
 		dev_warn(&amp;pci_dev-&gt;dev, &quot;Failed to enable 64-bit or 32-bit DMA.  Trying to continue, but this might not work.\n&quot;);
 
<span class="p_header">diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c</span>
<span class="p_header">index ed9c9eeedfe5..6b2cd922d322 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_ring.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_ring.c</span>
<span class="p_chunk">@@ -732,7 +732,8 @@</span> <span class="p_context"> void virtqueue_disable_cb(struct virtqueue *_vq)</span>
 
 	if (!(vq-&gt;avail_flags_shadow &amp; VRING_AVAIL_F_NO_INTERRUPT)) {
 		vq-&gt;avail_flags_shadow |= VRING_AVAIL_F_NO_INTERRUPT;
<span class="p_del">-		vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_flags_shadow);</span>
<span class="p_add">+		if (!vq-&gt;event)</span>
<span class="p_add">+			vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_flags_shadow);</span>
 	}
 
 }
<span class="p_chunk">@@ -764,7 +765,8 @@</span> <span class="p_context"> unsigned virtqueue_enable_cb_prepare(struct virtqueue *_vq)</span>
 	 * entry. Always do both to keep code simple. */
 	if (vq-&gt;avail_flags_shadow &amp; VRING_AVAIL_F_NO_INTERRUPT) {
 		vq-&gt;avail_flags_shadow &amp;= ~VRING_AVAIL_F_NO_INTERRUPT;
<span class="p_del">-		vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_flags_shadow);</span>
<span class="p_add">+		if (!vq-&gt;event)</span>
<span class="p_add">+			vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_flags_shadow);</span>
 	}
 	vring_used_event(&amp;vq-&gt;vring) = cpu_to_virtio16(_vq-&gt;vdev, last_used_idx = vq-&gt;last_used_idx);
 	END_USE(vq);
<span class="p_chunk">@@ -832,10 +834,11 @@</span> <span class="p_context"> bool virtqueue_enable_cb_delayed(struct virtqueue *_vq)</span>
 	 * more to do. */
 	/* Depending on the VIRTIO_RING_F_USED_EVENT_IDX feature, we need to
 	 * either clear the flags bit or point the event index at the next
<span class="p_del">-	 * entry. Always do both to keep code simple. */</span>
<span class="p_add">+	 * entry. Always update the event index to keep code simple. */</span>
 	if (vq-&gt;avail_flags_shadow &amp; VRING_AVAIL_F_NO_INTERRUPT) {
 		vq-&gt;avail_flags_shadow &amp;= ~VRING_AVAIL_F_NO_INTERRUPT;
<span class="p_del">-		vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_flags_shadow);</span>
<span class="p_add">+		if (!vq-&gt;event)</span>
<span class="p_add">+			vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(_vq-&gt;vdev, vq-&gt;avail_flags_shadow);</span>
 	}
 	/* TODO: tune this threshold */
 	bufs = (u16)(vq-&gt;avail_idx_shadow - vq-&gt;last_used_idx) * 3 / 4;
<span class="p_chunk">@@ -953,7 +956,8 @@</span> <span class="p_context"> struct virtqueue *__vring_new_virtqueue(unsigned int index,</span>
 	/* No callback?  Tell other side not to bother us. */
 	if (!callback) {
 		vq-&gt;avail_flags_shadow |= VRING_AVAIL_F_NO_INTERRUPT;
<span class="p_del">-		vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(vdev, vq-&gt;avail_flags_shadow);</span>
<span class="p_add">+		if (!vq-&gt;event)</span>
<span class="p_add">+			vq-&gt;vring.avail-&gt;flags = cpu_to_virtio16(vdev, vq-&gt;avail_flags_shadow);</span>
 	}
 
 	/* Put everything in free lists. */
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index e6811c42e41e..bc1a004d4264 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -8915,9 +8915,14 @@</span> <span class="p_context"> again:</span>
 	 *    So even we call qgroup_free_data(), it won&#39;t decrease reserved
 	 *    space.
 	 * 2) Not written to disk
<span class="p_del">-	 *    This means the reserved space should be freed here.</span>
<span class="p_add">+	 *    This means the reserved space should be freed here. However,</span>
<span class="p_add">+	 *    if a truncate invalidates the page (by clearing PageDirty)</span>
<span class="p_add">+	 *    and the page is accounted for while allocating extent</span>
<span class="p_add">+	 *    in btrfs_check_data_free_space() we let delayed_ref to</span>
<span class="p_add">+	 *    free the entire extent.</span>
 	 */
<span class="p_del">-	btrfs_qgroup_free_data(inode, page_start, PAGE_SIZE);</span>
<span class="p_add">+	if (PageDirty(page))</span>
<span class="p_add">+		btrfs_qgroup_free_data(inode, page_start, PAGE_SIZE);</span>
 	if (!inode_evicting) {
 		clear_extent_bit(tree, page_start, page_end,
 				 EXTENT_LOCKED | EXTENT_DIRTY |
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index ef9c55bc7907..90e1198bc63d 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -2713,14 +2713,12 @@</span> <span class="p_context"> static inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,</span>
 					     int index, int error)
 {
 	struct btrfs_log_ctx *ctx;
<span class="p_add">+	struct btrfs_log_ctx *safe;</span>
 
<span class="p_del">-	if (!error) {</span>
<span class="p_del">-		INIT_LIST_HEAD(&amp;root-&gt;log_ctxs[index]);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(ctx, &amp;root-&gt;log_ctxs[index], list)</span>
<span class="p_add">+	list_for_each_entry_safe(ctx, safe, &amp;root-&gt;log_ctxs[index], list) {</span>
<span class="p_add">+		list_del_init(&amp;ctx-&gt;list);</span>
 		ctx-&gt;log_ret = error;
<span class="p_add">+	}</span>
 
 	INIT_LIST_HEAD(&amp;root-&gt;log_ctxs[index]);
 }
<span class="p_chunk">@@ -2961,13 +2959,9 @@</span> <span class="p_context"> int btrfs_sync_log(struct btrfs_trans_handle *trans,</span>
 	mutex_unlock(&amp;root-&gt;log_mutex);
 
 out_wake_log_root:
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We needn&#39;t get log_mutex here because we are sure all</span>
<span class="p_del">-	 * the other tasks are blocked.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	mutex_lock(&amp;log_root_tree-&gt;log_mutex);</span>
 	btrfs_remove_all_log_ctxs(log_root_tree, index2, ret);
 
<span class="p_del">-	mutex_lock(&amp;log_root_tree-&gt;log_mutex);</span>
 	log_root_tree-&gt;log_transid_committed++;
 	atomic_set(&amp;log_root_tree-&gt;log_commit[index2], 0);
 	mutex_unlock(&amp;log_root_tree-&gt;log_mutex);
<span class="p_chunk">@@ -2978,10 +2972,8 @@</span> <span class="p_context"> out_wake_log_root:</span>
 	if (waitqueue_active(&amp;log_root_tree-&gt;log_commit_wait[index2]))
 		wake_up(&amp;log_root_tree-&gt;log_commit_wait[index2]);
 out:
<span class="p_del">-	/* See above. */</span>
<span class="p_del">-	btrfs_remove_all_log_ctxs(root, index1, ret);</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;root-&gt;log_mutex);
<span class="p_add">+	btrfs_remove_all_log_ctxs(root, index1, ret);</span>
 	root-&gt;log_transid_committed++;
 	atomic_set(&amp;root-&gt;log_commit[index1], 0);
 	mutex_unlock(&amp;root-&gt;log_mutex);
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index a204d7e109d4..0fe31b4b110d 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -1147,9 +1147,7 @@</span> <span class="p_context"> static void put_ol_stateid_locked(struct nfs4_ol_stateid *stp,</span>
 
 static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)
 {
<span class="p_del">-	struct nfs4_openowner *oo = openowner(stp-&gt;st_openstp-&gt;st_stateowner);</span>
<span class="p_del">-</span>
<span class="p_del">-	lockdep_assert_held(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);</span>
<span class="p_add">+	lockdep_assert_held(&amp;stp-&gt;st_stid.sc_client-&gt;cl_lock);</span>
 
 	list_del_init(&amp;stp-&gt;st_locks);
 	nfs4_unhash_stid(&amp;stp-&gt;st_stid);
<span class="p_chunk">@@ -1158,12 +1156,12 @@</span> <span class="p_context"> static bool unhash_lock_stateid(struct nfs4_ol_stateid *stp)</span>
 
 static void release_lock_stateid(struct nfs4_ol_stateid *stp)
 {
<span class="p_del">-	struct nfs4_openowner *oo = openowner(stp-&gt;st_openstp-&gt;st_stateowner);</span>
<span class="p_add">+	struct nfs4_client *clp = stp-&gt;st_stid.sc_client;</span>
 	bool unhashed;
 
<span class="p_del">-	spin_lock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);</span>
<span class="p_add">+	spin_lock(&amp;clp-&gt;cl_lock);</span>
 	unhashed = unhash_lock_stateid(stp);
<span class="p_del">-	spin_unlock(&amp;oo-&gt;oo_owner.so_client-&gt;cl_lock);</span>
<span class="p_add">+	spin_unlock(&amp;clp-&gt;cl_lock);</span>
 	if (unhashed)
 		nfs4_put_stid(&amp;stp-&gt;st_stid);
 }
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index abadbc30e013..767377e522c6 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -171,6 +171,8 @@</span> <span class="p_context"> static int ovl_copy_up_data(struct path *old, struct path *new, loff_t len)</span>
 		len -= bytes;
 	}
 
<span class="p_add">+	if (!error)</span>
<span class="p_add">+		error = vfs_fsync(new_file, 0);</span>
 	fput(new_file);
 out_fput:
 	fput(old_file);
<span class="p_header">diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c</span>
<span class="p_header">index c75625c1efa3..cf2bfeb1b385 100644</span>
<span class="p_header">--- a/fs/overlayfs/inode.c</span>
<span class="p_header">+++ b/fs/overlayfs/inode.c</span>
<span class="p_chunk">@@ -294,9 +294,6 @@</span> <span class="p_context"> struct posix_acl *ovl_get_acl(struct inode *inode, int type)</span>
 	if (!IS_ENABLED(CONFIG_FS_POSIX_ACL) || !IS_POSIXACL(realinode))
 		return NULL;
 
<span class="p_del">-	if (!realinode-&gt;i_op-&gt;get_acl)</span>
<span class="p_del">-		return NULL;</span>
<span class="p_del">-</span>
 	old_cred = ovl_override_creds(inode-&gt;i_sb);
 	acl = get_acl(realinode, type);
 	revert_creds(old_cred);
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index e2a94a26767b..a78415d77434 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -1026,6 +1026,21 @@</span> <span class="p_context"> ovl_posix_acl_xattr_set(const struct xattr_handler *handler,</span>
 
 	posix_acl_release(acl);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check if sgid bit needs to be cleared (actual setacl operation will</span>
<span class="p_add">+	 * be done with mounter&#39;s capabilities and so that won&#39;t do it for us).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(inode-&gt;i_mode &amp; S_ISGID) &amp;&amp;</span>
<span class="p_add">+	    handler-&gt;flags == ACL_TYPE_ACCESS &amp;&amp;</span>
<span class="p_add">+	    !in_group_p(inode-&gt;i_gid) &amp;&amp;</span>
<span class="p_add">+	    !capable_wrt_inode_uidgid(inode, CAP_FSETID)) {</span>
<span class="p_add">+		struct iattr iattr = { .ia_valid = ATTR_KILL_SGID };</span>
<span class="p_add">+</span>
<span class="p_add">+		err = ovl_setattr(dentry, &amp;iattr);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	err = ovl_xattr_set(dentry, handler-&gt;name, value, size, flags);
 	if (!err)
 		ovl_copyattr(ovl_inode_real(inode, NULL), inode);
<span class="p_header">diff --git a/fs/ubifs/dir.c b/fs/ubifs/dir.c</span>
<span class="p_header">index 4b86d3a738e1..3b27145f985f 100644</span>
<span class="p_header">--- a/fs/ubifs/dir.c</span>
<span class="p_header">+++ b/fs/ubifs/dir.c</span>
<span class="p_chunk">@@ -350,7 +350,7 @@</span> <span class="p_context"> static unsigned int vfs_dent_type(uint8_t type)</span>
  */
 static int ubifs_readdir(struct file *file, struct dir_context *ctx)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err = 0;</span>
 	struct qstr nm;
 	union ubifs_key key;
 	struct ubifs_dent_node *dent;
<span class="p_chunk">@@ -452,14 +452,20 @@</span> <span class="p_context"> out:</span>
 	kfree(file-&gt;private_data);
 	file-&gt;private_data = NULL;
 
<span class="p_del">-	if (err != -ENOENT) {</span>
<span class="p_add">+	if (err != -ENOENT)</span>
 		ubifs_err(c, &quot;cannot find next direntry, error %d&quot;, err);
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * -ENOENT is a non-fatal error in this context, the TNC uses</span>
<span class="p_add">+		 * it to indicate that the cursor moved past the current directory</span>
<span class="p_add">+		 * and readdir() has to stop.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+</span>
 
 	/* 2 is a special value indicating that there are no more direntries */
 	ctx-&gt;pos = 2;
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 /* Free saved readdir() state when the directory is closed */
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_dquot_buf.c b/fs/xfs/libxfs/xfs_dquot_buf.c</span>
<span class="p_header">index 3cc3cf767474..ac9a003dd29a 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_dquot_buf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_dquot_buf.c</span>
<span class="p_chunk">@@ -191,8 +191,7 @@</span> <span class="p_context"> xfs_dquot_buf_verify_crc(</span>
 	if (mp-&gt;m_quotainfo)
 		ndquots = mp-&gt;m_quotainfo-&gt;qi_dqperchunk;
 	else
<span class="p_del">-		ndquots = xfs_calc_dquots_per_chunk(</span>
<span class="p_del">-					XFS_BB_TO_FSB(mp, bp-&gt;b_length));</span>
<span class="p_add">+		ndquots = xfs_calc_dquots_per_chunk(bp-&gt;b_length);</span>
 
 	for (i = 0; i &lt; ndquots; i++, d++) {
 		if (!xfs_verify_cksum((char *)d, sizeof(struct xfs_dqblk),
<span class="p_header">diff --git a/include/linux/pwm.h b/include/linux/pwm.h</span>
<span class="p_header">index f1bbae014889..2c6c5114c089 100644</span>
<span class="p_header">--- a/include/linux/pwm.h</span>
<span class="p_header">+++ b/include/linux/pwm.h</span>
<span class="p_chunk">@@ -641,6 +641,7 @@</span> <span class="p_context"> static inline void pwm_remove_table(struct pwm_lookup *table, size_t num)</span>
 #ifdef CONFIG_PWM_SYSFS
 void pwmchip_sysfs_export(struct pwm_chip *chip);
 void pwmchip_sysfs_unexport(struct pwm_chip *chip);
<span class="p_add">+void pwmchip_sysfs_unexport_children(struct pwm_chip *chip);</span>
 #else
 static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
 {
<span class="p_chunk">@@ -649,6 +650,10 @@</span> <span class="p_context"> static inline void pwmchip_sysfs_export(struct pwm_chip *chip)</span>
 static inline void pwmchip_sysfs_unexport(struct pwm_chip *chip)
 {
 }
<span class="p_add">+</span>
<span class="p_add">+static inline void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 #endif /* CONFIG_PWM_SYSFS */
 
 #endif /* __LINUX_PWM_H */
<span class="p_header">diff --git a/include/uapi/linux/Kbuild b/include/uapi/linux/Kbuild</span>
<span class="p_header">index 185f8ea2702f..407ca0d7a938 100644</span>
<span class="p_header">--- a/include/uapi/linux/Kbuild</span>
<span class="p_header">+++ b/include/uapi/linux/Kbuild</span>
<span class="p_chunk">@@ -396,6 +396,7 @@</span> <span class="p_context"> header-y += string.h</span>
 header-y += suspend_ioctls.h
 header-y += swab.h
 header-y += synclink.h
<span class="p_add">+header-y += sync_file.h</span>
 header-y += sysctl.h
 header-y += sysinfo.h
 header-y += target_core_user.h
<span class="p_header">diff --git a/kernel/time/timer.c b/kernel/time/timer.c</span>
<span class="p_header">index 32bf6f75a8fe..96db64bdedbb 100644</span>
<span class="p_header">--- a/kernel/time/timer.c</span>
<span class="p_header">+++ b/kernel/time/timer.c</span>
<span class="p_chunk">@@ -878,7 +878,7 @@</span> <span class="p_context"> static inline struct timer_base *get_timer_base(u32 tflags)</span>
 
 #ifdef CONFIG_NO_HZ_COMMON
 static inline struct timer_base *
<span class="p_del">-__get_target_base(struct timer_base *base, unsigned tflags)</span>
<span class="p_add">+get_target_base(struct timer_base *base, unsigned tflags)</span>
 {
 #ifdef CONFIG_SMP
 	if ((tflags &amp; TIMER_PINNED) || !base-&gt;migration_enabled)
<span class="p_chunk">@@ -891,25 +891,27 @@</span> <span class="p_context"> __get_target_base(struct timer_base *base, unsigned tflags)</span>
 
 static inline void forward_timer_base(struct timer_base *base)
 {
<span class="p_add">+	unsigned long jnow = READ_ONCE(jiffies);</span>
<span class="p_add">+</span>
 	/*
 	 * We only forward the base when it&#39;s idle and we have a delta between
 	 * base clock and jiffies.
 	 */
<span class="p_del">-	if (!base-&gt;is_idle || (long) (jiffies - base-&gt;clk) &lt; 2)</span>
<span class="p_add">+	if (!base-&gt;is_idle || (long) (jnow - base-&gt;clk) &lt; 2)</span>
 		return;
 
 	/*
 	 * If the next expiry value is &gt; jiffies, then we fast forward to
 	 * jiffies otherwise we forward to the next expiry value.
 	 */
<span class="p_del">-	if (time_after(base-&gt;next_expiry, jiffies))</span>
<span class="p_del">-		base-&gt;clk = jiffies;</span>
<span class="p_add">+	if (time_after(base-&gt;next_expiry, jnow))</span>
<span class="p_add">+		base-&gt;clk = jnow;</span>
 	else
 		base-&gt;clk = base-&gt;next_expiry;
 }
 #else
 static inline struct timer_base *
<span class="p_del">-__get_target_base(struct timer_base *base, unsigned tflags)</span>
<span class="p_add">+get_target_base(struct timer_base *base, unsigned tflags)</span>
 {
 	return get_timer_this_cpu_base(tflags);
 }
<span class="p_chunk">@@ -917,14 +919,6 @@</span> <span class="p_context"> __get_target_base(struct timer_base *base, unsigned tflags)</span>
 static inline void forward_timer_base(struct timer_base *base) { }
 #endif
 
<span class="p_del">-static inline struct timer_base *</span>
<span class="p_del">-get_target_base(struct timer_base *base, unsigned tflags)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct timer_base *target = __get_target_base(base, tflags);</span>
<span class="p_del">-</span>
<span class="p_del">-	forward_timer_base(target);</span>
<span class="p_del">-	return target;</span>
<span class="p_del">-}</span>
 
 /*
  * We are using hashed locking: Holding per_cpu(timer_bases[x]).lock means
<span class="p_chunk">@@ -943,7 +937,14 @@</span> <span class="p_context"> static struct timer_base *lock_timer_base(struct timer_list *timer,</span>
 {
 	for (;;) {
 		struct timer_base *base;
<span class="p_del">-		u32 tf = timer-&gt;flags;</span>
<span class="p_add">+		u32 tf;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We need to use READ_ONCE() here, otherwise the compiler</span>
<span class="p_add">+		 * might re-read @tf between the check for TIMER_MIGRATING</span>
<span class="p_add">+		 * and spin_lock().</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tf = READ_ONCE(timer-&gt;flags);</span>
 
 		if (!(tf &amp; TIMER_MIGRATING)) {
 			base = get_timer_base(tf);
<span class="p_chunk">@@ -964,6 +965,8 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 	unsigned long clk = 0, flags;
 	int ret = 0;
 
<span class="p_add">+	BUG_ON(!timer-&gt;function);</span>
<span class="p_add">+</span>
 	/*
 	 * This is a common optimization triggered by the networking code - if
 	 * the timer is re-modified to have the same timeout or ends up in the
<span class="p_chunk">@@ -972,13 +975,16 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 	if (timer_pending(timer)) {
 		if (timer-&gt;expires == expires)
 			return 1;
<span class="p_add">+</span>
 		/*
<span class="p_del">-		 * Take the current timer_jiffies of base, but without holding</span>
<span class="p_del">-		 * the lock!</span>
<span class="p_add">+		 * We lock timer base and calculate the bucket index right</span>
<span class="p_add">+		 * here. If the timer ends up in the same bucket, then we</span>
<span class="p_add">+		 * just update the expiry time and avoid the whole</span>
<span class="p_add">+		 * dequeue/enqueue dance.</span>
 		 */
<span class="p_del">-		base = get_timer_base(timer-&gt;flags);</span>
<span class="p_del">-		clk = base-&gt;clk;</span>
<span class="p_add">+		base = lock_timer_base(timer, &amp;flags);</span>
 
<span class="p_add">+		clk = base-&gt;clk;</span>
 		idx = calc_wheel_index(expires, clk);
 
 		/*
<span class="p_chunk">@@ -988,14 +994,14 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 		 */
 		if (idx == timer_get_idx(timer)) {
 			timer-&gt;expires = expires;
<span class="p_del">-			return 1;</span>
<span class="p_add">+			ret = 1;</span>
<span class="p_add">+			goto out_unlock;</span>
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		base = lock_timer_base(timer, &amp;flags);</span>
 	}
 
 	timer_stats_timer_set_start_info(timer);
<span class="p_del">-	BUG_ON(!timer-&gt;function);</span>
<span class="p_del">-</span>
<span class="p_del">-	base = lock_timer_base(timer, &amp;flags);</span>
 
 	ret = detach_if_pending(timer, base, false);
 	if (!ret &amp;&amp; pending_only)
<span class="p_chunk">@@ -1025,12 +1031,16 @@</span> <span class="p_context"> __mod_timer(struct timer_list *timer, unsigned long expires, bool pending_only)</span>
 		}
 	}
 
<span class="p_add">+	/* Try to forward a stale timer base clock */</span>
<span class="p_add">+	forward_timer_base(base);</span>
<span class="p_add">+</span>
 	timer-&gt;expires = expires;
 	/*
 	 * If &#39;idx&#39; was calculated above and the base time did not advance
<span class="p_del">-	 * between calculating &#39;idx&#39; and taking the lock, only enqueue_timer()</span>
<span class="p_del">-	 * and trigger_dyntick_cpu() is required. Otherwise we need to</span>
<span class="p_del">-	 * (re)calculate the wheel index via internal_add_timer().</span>
<span class="p_add">+	 * between calculating &#39;idx&#39; and possibly switching the base, only</span>
<span class="p_add">+	 * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise</span>
<span class="p_add">+	 * we need to (re)calculate the wheel index via</span>
<span class="p_add">+	 * internal_add_timer().</span>
 	 */
 	if (idx != UINT_MAX &amp;&amp; clk == base-&gt;clk) {
 		enqueue_timer(base, timer, idx);
<span class="p_chunk">@@ -1510,12 +1520,16 @@</span> <span class="p_context"> u64 get_next_timer_interrupt(unsigned long basej, u64 basem)</span>
 	is_max_delta = (nextevt == base-&gt;clk + NEXT_TIMER_MAX_DELTA);
 	base-&gt;next_expiry = nextevt;
 	/*
<span class="p_del">-	 * We have a fresh next event. Check whether we can forward the base:</span>
<span class="p_add">+	 * We have a fresh next event. Check whether we can forward the</span>
<span class="p_add">+	 * base. We can only do that when @basej is past base-&gt;clk</span>
<span class="p_add">+	 * otherwise we might rewind base-&gt;clk.</span>
 	 */
<span class="p_del">-	if (time_after(nextevt, jiffies))</span>
<span class="p_del">-		base-&gt;clk = jiffies;</span>
<span class="p_del">-	else if (time_after(nextevt, base-&gt;clk))</span>
<span class="p_del">-		base-&gt;clk = nextevt;</span>
<span class="p_add">+	if (time_after(basej, base-&gt;clk)) {</span>
<span class="p_add">+		if (time_after(nextevt, basej))</span>
<span class="p_add">+			base-&gt;clk = basej;</span>
<span class="p_add">+		else if (time_after(nextevt, base-&gt;clk))</span>
<span class="p_add">+			base-&gt;clk = nextevt;</span>
<span class="p_add">+	}</span>
 
 	if (time_before_eq(nextevt, basej)) {
 		expires = basem;
<span class="p_header">diff --git a/mm/list_lru.c b/mm/list_lru.c</span>
<span class="p_header">index 1d05cb9d363d..234676e31edd 100644</span>
<span class="p_header">--- a/mm/list_lru.c</span>
<span class="p_header">+++ b/mm/list_lru.c</span>
<span class="p_chunk">@@ -554,6 +554,8 @@</span> <span class="p_context"> int __list_lru_init(struct list_lru *lru, bool memcg_aware,</span>
 	err = memcg_init_list_lru(lru, memcg_aware);
 	if (err) {
 		kfree(lru-&gt;node);
<span class="p_add">+		/* Do this so a list_lru_destroy() doesn&#39;t crash: */</span>
<span class="p_add">+		lru-&gt;node = NULL;</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 4be518d4e68a..dddead146459 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -1947,6 +1947,15 @@</span> <span class="p_context"> retry:</span>
 		     current-&gt;flags &amp; PF_EXITING))
 		goto force;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prevent unbounded recursion when reclaim operations need to</span>
<span class="p_add">+	 * allocate memory. This might exceed the limits temporarily,</span>
<span class="p_add">+	 * but we prefer facilitating memory reclaim and getting back</span>
<span class="p_add">+	 * under the limit over triggering OOM kills in these cases.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(current-&gt;flags &amp; PF_MEMALLOC))</span>
<span class="p_add">+		goto force;</span>
<span class="p_add">+</span>
 	if (unlikely(task_in_memcg_oom(current)))
 		goto nomem;
 
<span class="p_header">diff --git a/mm/slab.c b/mm/slab.c</span>
<span class="p_header">index b67271024135..525a911985a2 100644</span>
<span class="p_header">--- a/mm/slab.c</span>
<span class="p_header">+++ b/mm/slab.c</span>
<span class="p_chunk">@@ -964,7 +964,7 @@</span> <span class="p_context"> static int setup_kmem_cache_node(struct kmem_cache *cachep,</span>
 	 * guaranteed to be valid until irq is re-enabled, because it will be
 	 * freed after synchronize_sched().
 	 */
<span class="p_del">-	if (force_change)</span>
<span class="p_add">+	if (old_shared &amp;&amp; force_change)</span>
 		synchronize_sched();
 
 fail:
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 0fe8b7113868..ba0fad78e5d4 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -3048,7 +3048,9 @@</span> <span class="p_context"> unsigned long try_to_free_mem_cgroup_pages(struct mem_cgroup *memcg,</span>
 					    sc.gfp_mask,
 					    sc.reclaim_idx);
 
<span class="p_add">+	current-&gt;flags |= PF_MEMALLOC;</span>
 	nr_reclaimed = do_try_to_free_pages(zonelist, &amp;sc);
<span class="p_add">+	current-&gt;flags &amp;= ~PF_MEMALLOC;</span>
 
 	trace_mm_vmscan_memcg_reclaim_end(nr_reclaimed);
 
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 9dce3b157908..59a96034979b 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -2253,16 +2253,22 @@</span> <span class="p_context"> ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)</span>
 	if (!(status-&gt;rx_flags &amp; IEEE80211_RX_AMSDU))
 		return RX_CONTINUE;
 
<span class="p_del">-	if (ieee80211_has_a4(hdr-&gt;frame_control) &amp;&amp;</span>
<span class="p_del">-	    rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN &amp;&amp;</span>
<span class="p_del">-	    !rx-&gt;sdata-&gt;u.vlan.sta)</span>
<span class="p_del">-		return RX_DROP_UNUSABLE;</span>
<span class="p_add">+	if (unlikely(ieee80211_has_a4(hdr-&gt;frame_control))) {</span>
<span class="p_add">+		switch (rx-&gt;sdata-&gt;vif.type) {</span>
<span class="p_add">+		case NL80211_IFTYPE_AP_VLAN:</span>
<span class="p_add">+			if (!rx-&gt;sdata-&gt;u.vlan.sta)</span>
<span class="p_add">+				return RX_DROP_UNUSABLE;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case NL80211_IFTYPE_STATION:</span>
<span class="p_add">+			if (!rx-&gt;sdata-&gt;u.mgd.use_4addr)</span>
<span class="p_add">+				return RX_DROP_UNUSABLE;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return RX_DROP_UNUSABLE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (is_multicast_ether_addr(hdr-&gt;addr1) &amp;&amp;</span>
<span class="p_del">-	    ((rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN &amp;&amp;</span>
<span class="p_del">-	      rx-&gt;sdata-&gt;u.vlan.sta) ||</span>
<span class="p_del">-	     (rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_STATION &amp;&amp;</span>
<span class="p_del">-	      rx-&gt;sdata-&gt;u.mgd.use_4addr)))</span>
<span class="p_add">+	if (is_multicast_ether_addr(hdr-&gt;addr1))</span>
 		return RX_DROP_UNUSABLE;
 
 	skb-&gt;dev = dev;
<span class="p_header">diff --git a/net/netfilter/xt_NFLOG.c b/net/netfilter/xt_NFLOG.c</span>
<span class="p_header">index 018eed7e1ff1..8668a5c18dc3 100644</span>
<span class="p_header">--- a/net/netfilter/xt_NFLOG.c</span>
<span class="p_header">+++ b/net/netfilter/xt_NFLOG.c</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"> nflog_tg(struct sk_buff *skb, const struct xt_action_param *par)</span>
 	li.u.ulog.copy_len   = info-&gt;len;
 	li.u.ulog.group	     = info-&gt;group;
 	li.u.ulog.qthreshold = info-&gt;threshold;
<span class="p_add">+	li.u.ulog.flags	     = 0;</span>
 
 	if (info-&gt;flags &amp; XT_NFLOG_F_COPY_LEN)
 		li.u.ulog.flags |= NF_LOG_F_COPY_LEN;
<span class="p_header">diff --git a/security/keys/Kconfig b/security/keys/Kconfig</span>
<span class="p_header">index f826e8739023..d942c7c2bc0a 100644</span>
<span class="p_header">--- a/security/keys/Kconfig</span>
<span class="p_header">+++ b/security/keys/Kconfig</span>
<span class="p_chunk">@@ -41,7 +41,7 @@</span> <span class="p_context"> config BIG_KEYS</span>
 	bool &quot;Large payload keys&quot;
 	depends on KEYS
 	depends on TMPFS
<span class="p_del">-	select CRYPTO</span>
<span class="p_add">+	depends on (CRYPTO_ANSI_CPRNG = y || CRYPTO_DRBG = y)</span>
 	select CRYPTO_AES
 	select CRYPTO_ECB
 	select CRYPTO_RNG
<span class="p_header">diff --git a/security/keys/big_key.c b/security/keys/big_key.c</span>
<span class="p_header">index c0b3030b5634..835c1ab30d01 100644</span>
<span class="p_header">--- a/security/keys/big_key.c</span>
<span class="p_header">+++ b/security/keys/big_key.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
  * 2 of the Licence, or (at your option) any later version.
  */
 
<span class="p_add">+#define pr_fmt(fmt) &quot;big_key: &quot;fmt</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/seq_file.h&gt;
 #include &lt;linux/file.h&gt;
<span class="p_chunk">@@ -341,44 +342,48 @@</span> <span class="p_context"> error:</span>
  */
 static int __init big_key_init(void)
 {
<span class="p_del">-	return register_key_type(&amp;key_type_big_key);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Initialize big_key crypto and RNG algorithms</span>
<span class="p_del">- */</span>
<span class="p_del">-static int __init big_key_crypto_init(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret = -EINVAL;</span>
<span class="p_add">+	struct crypto_skcipher *cipher;</span>
<span class="p_add">+	struct crypto_rng *rng;</span>
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	/* init RNG */</span>
<span class="p_del">-	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);</span>
<span class="p_del">-	if (IS_ERR(big_key_rng)) {</span>
<span class="p_del">-		big_key_rng = NULL;</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+	rng = crypto_alloc_rng(big_key_rng_name, 0, 0);</span>
<span class="p_add">+	if (IS_ERR(rng)) {</span>
<span class="p_add">+		pr_err(&quot;Can&#39;t alloc rng: %ld\n&quot;, PTR_ERR(rng));</span>
<span class="p_add">+		return PTR_ERR(rng);</span>
 	}
 
<span class="p_add">+	big_key_rng = rng;</span>
<span class="p_add">+</span>
 	/* seed RNG */
<span class="p_del">-	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+	ret = crypto_rng_reset(rng, NULL, crypto_rng_seedsize(rng));</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;Can&#39;t reset rng: %d\n&quot;, ret);</span>
<span class="p_add">+		goto error_rng;</span>
<span class="p_add">+	}</span>
 
 	/* init block cipher */
<span class="p_del">-	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,</span>
<span class="p_del">-						 0, CRYPTO_ALG_ASYNC);</span>
<span class="p_del">-	if (IS_ERR(big_key_skcipher)) {</span>
<span class="p_del">-		big_key_skcipher = NULL;</span>
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto error;</span>
<span class="p_add">+	cipher = crypto_alloc_skcipher(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);</span>
<span class="p_add">+	if (IS_ERR(cipher)) {</span>
<span class="p_add">+		ret = PTR_ERR(cipher);</span>
<span class="p_add">+		pr_err(&quot;Can&#39;t alloc crypto: %d\n&quot;, ret);</span>
<span class="p_add">+		goto error_rng;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	big_key_skcipher = cipher;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = register_key_type(&amp;key_type_big_key);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		pr_err(&quot;Can&#39;t register type: %d\n&quot;, ret);</span>
<span class="p_add">+		goto error_cipher;</span>
 	}
 
 	return 0;
 
<span class="p_del">-error:</span>
<span class="p_add">+error_cipher:</span>
<span class="p_add">+	crypto_free_skcipher(big_key_skcipher);</span>
<span class="p_add">+error_rng:</span>
 	crypto_free_rng(big_key_rng);
<span class="p_del">-	big_key_rng = NULL;</span>
 	return ret;
 }
 
<span class="p_del">-device_initcall(big_key_init);</span>
<span class="p_del">-late_initcall(big_key_crypto_init);</span>
<span class="p_add">+late_initcall(big_key_init);</span>
<span class="p_header">diff --git a/security/keys/proc.c b/security/keys/proc.c</span>
<span class="p_header">index f0611a6368cd..b9f531c9e4fa 100644</span>
<span class="p_header">--- a/security/keys/proc.c</span>
<span class="p_header">+++ b/security/keys/proc.c</span>
<span class="p_chunk">@@ -181,7 +181,7 @@</span> <span class="p_context"> static int proc_keys_show(struct seq_file *m, void *v)</span>
 	struct timespec now;
 	unsigned long timo;
 	key_ref_t key_ref, skey_ref;
<span class="p_del">-	char xbuf[12];</span>
<span class="p_add">+	char xbuf[16];</span>
 	int rc;
 
 	struct keyring_search_context ctx = {
<span class="p_header">diff --git a/sound/core/seq/seq_timer.c b/sound/core/seq/seq_timer.c</span>
<span class="p_header">index dcc102813aef..37d9cfbc29f9 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_timer.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_timer.c</span>
<span class="p_chunk">@@ -448,8 +448,8 @@</span> <span class="p_context"> snd_seq_real_time_t snd_seq_timer_get_cur_time(struct snd_seq_timer *tmr)</span>
 
 		ktime_get_ts64(&amp;tm);
 		tm = timespec64_sub(tm, tmr-&gt;last_update);
<span class="p_del">-		cur_time.tv_nsec = tm.tv_nsec;</span>
<span class="p_del">-		cur_time.tv_sec = tm.tv_sec;</span>
<span class="p_add">+		cur_time.tv_nsec += tm.tv_nsec;</span>
<span class="p_add">+		cur_time.tv_sec += tm.tv_sec;</span>
 		snd_seq_sanity_real_time(&amp;cur_time);
 	}
 	spin_unlock_irqrestore(&amp;tmr-&gt;lock, flags);
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 160c7f713722..487fcbf9473e 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -340,8 +340,7 @@</span> <span class="p_context"> enum {</span>
 
 /* quirks for Nvidia */
 #define AZX_DCAPS_PRESET_NVIDIA \
<span class="p_del">-	(AZX_DCAPS_NO_MSI | /*AZX_DCAPS_ALIGN_BUFSIZE |*/ \</span>
<span class="p_del">-	 AZX_DCAPS_NO_64BIT | AZX_DCAPS_CORBRP_SELF_CLEAR |\</span>
<span class="p_add">+	(AZX_DCAPS_NO_MSI | AZX_DCAPS_CORBRP_SELF_CLEAR |\</span>
 	 AZX_DCAPS_SNOOP_TYPE(NVIDIA))
 
 #define AZX_DCAPS_PRESET_CTHDA \
<span class="p_chunk">@@ -1699,6 +1698,10 @@</span> <span class="p_context"> static int azx_first_init(struct azx *chip)</span>
 		}
 	}
 
<span class="p_add">+	/* NVidia hardware normally only supports up to 40 bits of DMA */</span>
<span class="p_add">+	if (chip-&gt;pci-&gt;vendor == PCI_VENDOR_ID_NVIDIA)</span>
<span class="p_add">+		dma_bits = 40;</span>
<span class="p_add">+</span>
 	/* disable 64bit DMA address on some devices */
 	if (chip-&gt;driver_caps &amp; AZX_DCAPS_NO_64BIT) {
 		dev_dbg(card-&gt;dev, &quot;Disabling 64bit DMA\n&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index bd481ac23faf..26e866f65314 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5809,8 +5809,6 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 #define ALC295_STANDARD_PINS \
 	{0x12, 0xb7a60130}, \
 	{0x14, 0x90170110}, \
<span class="p_del">-	{0x17, 0x21014020}, \</span>
<span class="p_del">-	{0x18, 0x21a19030}, \</span>
 	{0x21, 0x04211020}
 
 #define ALC298_STANDARD_PINS \
<span class="p_chunk">@@ -5857,11 +5855,19 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x1b, 0x02011020},
 		{0x21, 0x0221101f}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x1b, 0x01011020},</span>
<span class="p_add">+		{0x21, 0x0221101f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x14, 0x90170130},
 		{0x1b, 0x01014020},
 		{0x21, 0x0221103f}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		{0x14, 0x90170130},
<span class="p_add">+		{0x1b, 0x01011020},</span>
<span class="p_add">+		{0x21, 0x0221103f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x14, 0x90170130},</span>
 		{0x1b, 0x02011020},
 		{0x21, 0x0221103f}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_chunk">@@ -6037,7 +6043,13 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		ALC292_STANDARD_PINS,
 		{0x13, 0x90a60140}),
 	SND_HDA_PIN_QUIRK(0x10ec0295, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_del">-		ALC295_STANDARD_PINS),</span>
<span class="p_add">+		ALC295_STANDARD_PINS,</span>
<span class="p_add">+		{0x17, 0x21014020},</span>
<span class="p_add">+		{0x18, 0x21a19030}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0295, 0x1028, &quot;Dell&quot;, ALC269_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC295_STANDARD_PINS,</span>
<span class="p_add">+		{0x17, 0x21014040},</span>
<span class="p_add">+		{0x18, 0x21a19050}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0298, 0x1028, &quot;Dell&quot;, ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,
 		ALC298_STANDARD_PINS,
 		{0x17, 0x90170110}),
<span class="p_chunk">@@ -6611,6 +6623,7 @@</span> <span class="p_context"> enum {</span>
 	ALC891_FIXUP_HEADSET_MODE,
 	ALC891_FIXUP_DELL_MIC_NO_PRESENCE,
 	ALC662_FIXUP_ACER_VERITON,
<span class="p_add">+	ALC892_FIXUP_ASROCK_MOBO,</span>
 };
 
 static const struct hda_fixup alc662_fixups[] = {
<span class="p_chunk">@@ -6887,6 +6900,16 @@</span> <span class="p_context"> static const struct hda_fixup alc662_fixups[] = {</span>
 			{ }
 		}
 	},
<span class="p_add">+	[ALC892_FIXUP_ASROCK_MOBO] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x15, 0x40f000f0 }, /* disabled */</span>
<span class="p_add">+			{ 0x16, 0x40f000f0 }, /* disabled */</span>
<span class="p_add">+			{ 0x18, 0x01014011 }, /* LO */</span>
<span class="p_add">+			{ 0x1a, 0x01014012 }, /* LO */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
<span class="p_chunk">@@ -6924,6 +6947,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x144d, 0xc051, &quot;Samsung R720&quot;, ALC662_FIXUP_IDEAPAD),
 	SND_PCI_QUIRK(0x17aa, 0x38af, &quot;Lenovo Ideapad Y550P&quot;, ALC662_FIXUP_IDEAPAD),
 	SND_PCI_QUIRK(0x17aa, 0x3a0d, &quot;Lenovo Ideapad Y550&quot;, ALC662_FIXUP_IDEAPAD),
<span class="p_add">+	SND_PCI_QUIRK(0x1849, 0x5892, &quot;ASRock B150M&quot;, ALC892_FIXUP_ASROCK_MOBO),</span>
 	SND_PCI_QUIRK(0x19da, 0xa130, &quot;Zotac Z68&quot;, ALC662_FIXUP_ZOTAC_Z68),
 	SND_PCI_QUIRK(0x1b0a, 0x01b8, &quot;ACER Veriton&quot;, ALC662_FIXUP_ACER_VERITON),
 	SND_PCI_QUIRK(0x1b35, 0x2206, &quot;CZC P10T&quot;, ALC662_FIXUP_CZC_P10T),
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index c60a776e815d..8a59d4782a0f 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -2907,6 +2907,23 @@</span> <span class="p_context"> AU0828_DEVICE(0x2040, 0x7260, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),</span>
 AU0828_DEVICE(0x2040, 0x7213, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),
 AU0828_DEVICE(0x2040, 0x7270, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),
 
<span class="p_add">+/* Syntek STK1160 */</span>
<span class="p_add">+{</span>
<span class="p_add">+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE |</span>
<span class="p_add">+		       USB_DEVICE_ID_MATCH_INT_CLASS |</span>
<span class="p_add">+		       USB_DEVICE_ID_MATCH_INT_SUBCLASS,</span>
<span class="p_add">+	.idVendor = 0x05e1,</span>
<span class="p_add">+	.idProduct = 0x0408,</span>
<span class="p_add">+	.bInterfaceClass = USB_CLASS_AUDIO,</span>
<span class="p_add">+	.bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL,</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp;(const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.vendor_name = &quot;Syntek&quot;,</span>
<span class="p_add">+		.product_name = &quot;STK1160&quot;,</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_AUDIO_ALIGN_TRANSFER</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* Digidesign Mbox */
 {
 	/* Thanks to Clemens Ladisch &lt;clemens@ladisch.de&gt; */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



