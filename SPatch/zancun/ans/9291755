
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.19 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.19</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 20, 2016, 4:15 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160820161554.GB28356@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9291755/mbox/"
   >mbox</a>
|
   <a href="/patch/9291755/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9291755/">/patch/9291755/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E6FB160574 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:16:20 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CCB7728BAC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:16:20 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id BC51528BAE; Sat, 20 Aug 2016 16:16:20 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 330D628BAC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 20 Aug 2016 16:16:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932162AbcHTQQA (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 20 Aug 2016 12:16:00 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:51585 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753108AbcHTQPu (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 20 Aug 2016 12:15:50 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id D2A0F7AA;
	Sat, 20 Aug 2016 16:15:47 +0000 (UTC)
Date: Sat, 20 Aug 2016 18:15:54 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.19
Message-ID: &lt;20160820161554.GB28356@kroah.com&gt;
References: &lt;20160820161549.GA28356@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;20160820161549.GA28356@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 20, 2016, 4:15 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/module-signing.txt b/Documentation/module-signing.txt</span>
<span class="p_header">index a78bf1ffa68c..39b7f612c418 100644</span>
<span class="p_header">--- a/Documentation/module-signing.txt</span>
<span class="p_header">+++ b/Documentation/module-signing.txt</span>
<span class="p_chunk">@@ -271,3 +271,9 @@</span> <span class="p_context"> Since the private key is used to sign modules, viruses and malware could use</span>
 the private key to sign modules and compromise the operating system.  The
 private key must be either destroyed or moved to a secure location and not kept
 in the root node of the kernel source tree.
<span class="p_add">+</span>
<span class="p_add">+If you use the same private key to sign modules for multiple kernel</span>
<span class="p_add">+configurations, you must ensure that the module version information is</span>
<span class="p_add">+sufficient to prevent loading a module into a different kernel.  Either</span>
<span class="p_add">+set CONFIG_MODVERSIONS=y or ensure that each configuration has a different</span>
<span class="p_add">+kernel release string by changing EXTRAVERSION or CONFIG_LOCALVERSION.</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index eaedea88a8a7..695c64ec160c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 18</span>
<span class="p_add">+SUBLEVEL = 19</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arc/include/asm/pgtable.h b/arch/arc/include/asm/pgtable.h</span>
<span class="p_header">index 57af2f05ae84..3cab04255ae0 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"></span>
 #define ___DEF (_PAGE_PRESENT | _PAGE_CACHEABLE)
 
 /* Set of bits not changed in pte_modify */
<span class="p_del">-#define _PAGE_CHG_MASK	(PAGE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY)</span>
<span class="p_add">+#define _PAGE_CHG_MASK	(PAGE_MASK | _PAGE_ACCESSED | _PAGE_DIRTY | _PAGE_SPECIAL)</span>
 
 /* More Abbrevaited helpers */
 #define PAGE_U_NONE     __pgprot(___DEF)
<span class="p_header">diff --git a/arch/arm/boot/dts/sun4i-a10-a1000.dts b/arch/arm/boot/dts/sun4i-a10-a1000.dts</span>
<span class="p_header">index 97570cb7f2fc..1d23527d4ecf 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun4i-a10-a1000.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun4i-a10-a1000.dts</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 7 15 GPIO_ACTIVE_HIGH&gt;;
 	};
<span class="p_header">diff --git a/arch/arm/boot/dts/sun4i-a10-hackberry.dts b/arch/arm/boot/dts/sun4i-a10-hackberry.dts</span>
<span class="p_header">index 2b17c5199151..6de83a6187d0 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun4i-a10-hackberry.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun4i-a10-hackberry.dts</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 7 19 GPIO_ACTIVE_HIGH&gt;;
 	};
<span class="p_header">diff --git a/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts b/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts</span>
<span class="p_header">index 7afc7a64eef1..e28f080b1fd5 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun4i-a10-jesurun-q5.dts</span>
<span class="p_chunk">@@ -80,6 +80,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 7 19 GPIO_ACTIVE_HIGH&gt;;   /* PH19 */
 	};
<span class="p_header">diff --git a/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts b/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts</span>
<span class="p_header">index 9fea918f949e..39731a78f087 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sun5i-a10s-wobo-i5.dts</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"></span>
 		regulator-name = &quot;emac-3v3&quot;;
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
<span class="p_add">+		startup-delay-us = &lt;20000&gt;;</span>
 		enable-active-high;
 		gpio = &lt;&amp;pio 0 2 GPIO_ACTIVE_HIGH&gt;;
 	};
<span class="p_header">diff --git a/arch/arm64/boot/dts/rockchip/rk3368.dtsi b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">index cc093a482aa4..8fe39e1b680e 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_chunk">@@ -517,7 +517,7 @@</span> <span class="p_context"></span>
 		#address-cells = &lt;0&gt;;
 
 		reg = &lt;0x0 0xffb71000 0x0 0x1000&gt;,
<span class="p_del">-		      &lt;0x0 0xffb72000 0x0 0x1000&gt;,</span>
<span class="p_add">+		      &lt;0x0 0xffb72000 0x0 0x2000&gt;,</span>
 		      &lt;0x0 0xffb74000 0x0 0x2000&gt;,
 		      &lt;0x0 0xffb76000 0x0 0x2000&gt;;
 		interrupts = &lt;GIC_PPI 9
<span class="p_header">diff --git a/arch/arm64/include/asm/ptrace.h b/arch/arm64/include/asm/ptrace.h</span>
<span class="p_header">index a307eb6e7fa8..7f94755089e2 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -117,6 +117,8 @@</span> <span class="p_context"> struct pt_regs {</span>
 	};
 	u64 orig_x0;
 	u64 syscallno;
<span class="p_add">+	u64 orig_addr_limit;</span>
<span class="p_add">+	u64 unused;	// maintain 16 byte alignment</span>
 };
 
 #define arch_has_single_step()	(1)
<span class="p_header">diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_header">index 25de8b244961..087cf9a65359 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -58,6 +58,7 @@</span> <span class="p_context"> int main(void)</span>
   DEFINE(S_PC,			offsetof(struct pt_regs, pc));
   DEFINE(S_ORIG_X0,		offsetof(struct pt_regs, orig_x0));
   DEFINE(S_SYSCALLNO,		offsetof(struct pt_regs, syscallno));
<span class="p_add">+  DEFINE(S_ORIG_ADDR_LIMIT,	offsetof(struct pt_regs, orig_addr_limit));</span>
   DEFINE(S_FRAME_SIZE,		sizeof(struct pt_regs));
   BLANK();
   DEFINE(MM_CONTEXT_ID,		offsetof(struct mm_struct, context.id.counter));
<span class="p_header">diff --git a/arch/arm64/kernel/debug-monitors.c b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">index c1492ba1f6d1..e51f27ac13fd 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_chunk">@@ -152,7 +152,6 @@</span> <span class="p_context"> static int debug_monitors_init(void)</span>
 	/* Clear the OS lock. */
 	on_each_cpu(clear_os_lock, NULL, 1);
 	isb();
<span class="p_del">-	local_dbg_enable();</span>
 
 	/* Register hotplug handler. */
 	__register_cpu_notifier(&amp;os_lock_nb);
<span class="p_header">diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S</span>
<span class="p_header">index 7ed3d75f6304..5a3753d09e20 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/entry.S</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/cpufeature.h&gt;
 #include &lt;asm/errno.h&gt;
 #include &lt;asm/esr.h&gt;
<span class="p_add">+#include &lt;asm/memory.h&gt;</span>
 #include &lt;asm/thread_info.h&gt;
 #include &lt;asm/unistd.h&gt;
 
<span class="p_chunk">@@ -93,7 +94,13 @@</span> <span class="p_context"></span>
 	disable_step_tsk x19, x20		// exceptions when scheduling.
 	.else
 	add	x21, sp, #S_FRAME_SIZE
<span class="p_del">-	.endif</span>
<span class="p_add">+	get_thread_info tsk</span>
<span class="p_add">+	/* Save the task&#39;s original addr_limit and set USER_DS (TASK_SIZE_64) */</span>
<span class="p_add">+	ldr	x20, [tsk, #TI_ADDR_LIMIT]</span>
<span class="p_add">+	str	x20, [sp, #S_ORIG_ADDR_LIMIT]</span>
<span class="p_add">+	mov	x20, #TASK_SIZE_64</span>
<span class="p_add">+	str	x20, [tsk, #TI_ADDR_LIMIT]</span>
<span class="p_add">+	.endif /* \el == 0 */</span>
 	mrs	x22, elr_el1
 	mrs	x23, spsr_el1
 	stp	lr, x21, [sp, #S_LR]
<span class="p_chunk">@@ -117,6 +124,12 @@</span> <span class="p_context"></span>
 	.endm
 
 	.macro	kernel_exit, el
<span class="p_add">+	.if	\el != 0</span>
<span class="p_add">+	/* Restore the task&#39;s original addr_limit. */</span>
<span class="p_add">+	ldr	x20, [sp, #S_ORIG_ADDR_LIMIT]</span>
<span class="p_add">+	str	x20, [tsk, #TI_ADDR_LIMIT]</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+</span>
 	ldp	x21, x22, [sp, #S_PC]		// load ELR, SPSR
 	.if	\el == 0
 	ct_user_enter
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index b1adc51b2c2e..f3c3d8fee5ba 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -188,7 +188,6 @@</span> <span class="p_context"> asmlinkage void secondary_start_kernel(void)</span>
 	set_cpu_online(cpu, true);
 	complete(&amp;cpu_running);
 
<span class="p_del">-	local_dbg_enable();</span>
 	local_irq_enable();
 	local_async_enable();
 
<span class="p_chunk">@@ -334,8 +333,8 @@</span> <span class="p_context"> void __init smp_cpus_done(unsigned int max_cpus)</span>
 
 void __init smp_prepare_boot_cpu(void)
 {
<span class="p_del">-	cpuinfo_store_boot_cpu();</span>
 	set_my_cpu_offset(per_cpu_offset(smp_processor_id()));
<span class="p_add">+	cpuinfo_store_boot_cpu();</span>
 }
 
 static u64 __init of_get_cpu_mpidr(struct device_node *dn)
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index 116ad654dd59..653735a8c58a 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -652,9 +652,9 @@</span> <span class="p_context"> void *__init fixmap_remap_fdt(phys_addr_t dt_phys)</span>
 	/*
 	 * Check whether the physical FDT address is set and meets the minimum
 	 * alignment requirement. Since we are relying on MIN_FDT_ALIGN to be
<span class="p_del">-	 * at least 8 bytes so that we can always access the size field of the</span>
<span class="p_del">-	 * FDT header after mapping the first chunk, double check here if that</span>
<span class="p_del">-	 * is indeed the case.</span>
<span class="p_add">+	 * at least 8 bytes so that we can always access the magic and size</span>
<span class="p_add">+	 * fields of the FDT header after mapping the first chunk, double check</span>
<span class="p_add">+	 * here if that is indeed the case.</span>
 	 */
 	BUILD_BUG_ON(MIN_FDT_ALIGN &lt; 8);
 	if (!dt_phys || dt_phys % MIN_FDT_ALIGN)
<span class="p_chunk">@@ -682,7 +682,7 @@</span> <span class="p_context"> void *__init fixmap_remap_fdt(phys_addr_t dt_phys)</span>
 	create_mapping(round_down(dt_phys, SWAPPER_BLOCK_SIZE), dt_virt_base,
 		       SWAPPER_BLOCK_SIZE, prot);
 
<span class="p_del">-	if (fdt_check_header(dt_virt) != 0)</span>
<span class="p_add">+	if (fdt_magic(dt_virt) != FDT_MAGIC)</span>
 		return NULL;
 
 	size = fdt_totalsize(dt_virt);
<span class="p_header">diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S</span>
<span class="p_header">index b8f04b3f2786..1f6bb29ca53b 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc.S</span>
<span class="p_chunk">@@ -156,6 +156,8 @@</span> <span class="p_context"> ENTRY(__cpu_setup)</span>
 	msr	cpacr_el1, x0			// Enable FP/ASIMD
 	mov	x0, #1 &lt;&lt; 12			// Reset mdscr_el1 and disable
 	msr	mdscr_el1, x0			// access to the DCC from EL0
<span class="p_add">+	isb					// Unmask debug exceptions now,</span>
<span class="p_add">+	enable_dbg				// since this is per-cpu</span>
 	reset_pmuserenr_el0 x0			// Disable PMU access from EL0
 	/*
 	 * Memory region attributes for LPAE:
<span class="p_header">diff --git a/arch/metag/include/asm/cmpxchg_lnkget.h b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">index 0154e2807ebb..2369ad394876 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/cmpxchg_lnkget.h</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static inline unsigned long __cmpxchg_u32(volatile int *m, unsigned long old,</span>
 		      &quot;	DCACHE	[%2], %0\n&quot;
 #endif
 		      &quot;2:\n&quot;
<span class="p_del">-		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;da&quot; (retval)</span>
<span class="p_add">+		      : &quot;=&amp;d&quot; (temp), &quot;=&amp;d&quot; (retval)</span>
 		      : &quot;da&quot; (m), &quot;bd&quot; (old), &quot;da&quot; (new)
 		      : &quot;cc&quot;
 		      );
<span class="p_header">diff --git a/arch/mips/kernel/csrc-r4k.c b/arch/mips/kernel/csrc-r4k.c</span>
<span class="p_header">index 1f910563fdf6..d76275da54cb 100644</span>
<span class="p_header">--- a/arch/mips/kernel/csrc-r4k.c</span>
<span class="p_header">+++ b/arch/mips/kernel/csrc-r4k.c</span>
<span class="p_chunk">@@ -23,7 +23,7 @@</span> <span class="p_context"> static struct clocksource clocksource_mips = {</span>
 	.flags		= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
<span class="p_del">-static u64 notrace r4k_read_sched_clock(void)</span>
<span class="p_add">+static u64 __maybe_unused notrace r4k_read_sched_clock(void)</span>
 {
 	return read_c0_count();
 }
<span class="p_chunk">@@ -82,7 +82,9 @@</span> <span class="p_context"> int __init init_r4k_clocksource(void)</span>
 
 	clocksource_register_hz(&amp;clocksource_mips, mips_hpt_frequency);
 
<span class="p_add">+#ifndef CONFIG_CPU_FREQ</span>
 	sched_clock_register(r4k_read_sched_clock, 32, mips_hpt_frequency);
<span class="p_add">+#endif</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/mips/kvm/emulate.c b/arch/mips/kvm/emulate.c</span>
<span class="p_header">index dc10c77b7500..d6476d11212e 100644</span>
<span class="p_header">--- a/arch/mips/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/mips/kvm/emulate.c</span>
<span class="p_chunk">@@ -1629,8 +1629,14 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc,</span>
 
 	preempt_disable();
 	if (KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG0) {
<span class="p_del">-		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0)</span>
<span class="p_del">-			kvm_mips_handle_kseg0_tlb_fault(va, vcpu);</span>
<span class="p_add">+		if (kvm_mips_host_tlb_lookup(vcpu, va) &lt; 0 &amp;&amp;</span>
<span class="p_add">+		    kvm_mips_handle_kseg0_tlb_fault(va, vcpu)) {</span>
<span class="p_add">+			kvm_err(&quot;%s: handling mapped kseg0 tlb fault for %lx, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+				__func__, va, vcpu, read_c0_entryhi());</span>
<span class="p_add">+			er = EMULATE_FAIL;</span>
<span class="p_add">+			preempt_enable();</span>
<span class="p_add">+			goto done;</span>
<span class="p_add">+		}</span>
 	} else if ((KVM_GUEST_KSEGX(va) &lt; KVM_GUEST_KSEG0) ||
 		   KVM_GUEST_KSEGX(va) == KVM_GUEST_KSEG23) {
 		int index;
<span class="p_chunk">@@ -1665,14 +1671,19 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emulate_cache(uint32_t inst, uint32_t *opc,</span>
 								run, vcpu);
 				preempt_enable();
 				goto dont_update_pc;
<span class="p_del">-			} else {</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * We fault an entry from the guest tlb to the</span>
<span class="p_del">-				 * shadow host TLB</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_del">-								     NULL,</span>
<span class="p_del">-								     NULL);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We fault an entry from the guest tlb to the</span>
<span class="p_add">+			 * shadow host TLB</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+				preempt_enable();</span>
<span class="p_add">+				goto done;</span>
 			}
 		}
 	} else {
<span class="p_chunk">@@ -2633,8 +2644,13 @@</span> <span class="p_context"> enum emulation_result kvm_mips_handle_tlbmiss(unsigned long cause,</span>
 			 * OK we have a Guest TLB entry, now inject it into the
 			 * shadow host TLB
 			 */
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb, NULL,</span>
<span class="p_del">-							     NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu, tlb,</span>
<span class="p_add">+								 NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault for %lx, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, va, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				er = EMULATE_FAIL;</span>
<span class="p_add">+			}</span>
 		}
 	}
 
<span class="p_header">diff --git a/arch/mips/kvm/tlb.c b/arch/mips/kvm/tlb.c</span>
<span class="p_header">index aed0ac2a4972..7a7ed9ca01bb 100644</span>
<span class="p_header">--- a/arch/mips/kvm/tlb.c</span>
<span class="p_header">+++ b/arch/mips/kvm/tlb.c</span>
<span class="p_chunk">@@ -276,7 +276,7 @@</span> <span class="p_context"> int kvm_mips_handle_kseg0_tlb_fault(unsigned long badvaddr,</span>
 	}
 
 	gfn = (KVM_GUEST_CPHYSADDR(badvaddr) &gt;&gt; PAGE_SHIFT);
<span class="p_del">-	if (gfn &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+	if ((gfn | 1) &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
 		kvm_err(&quot;%s: Invalid gfn: %#llx, BadVaddr: %#lx\n&quot;, __func__,
 			gfn, badvaddr);
 		kvm_mips_dump_host_tlbs();
<span class="p_chunk">@@ -361,25 +361,39 @@</span> <span class="p_context"> int kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 	unsigned long entryhi = 0, entrylo0 = 0, entrylo1 = 0;
 	struct kvm *kvm = vcpu-&gt;kvm;
 	pfn_t pfn0, pfn1;
<span class="p_del">-</span>
<span class="p_del">-	if ((tlb-&gt;tlb_hi &amp; VPN2_MASK) == 0) {</span>
<span class="p_del">-		pfn0 = 0;</span>
<span class="p_del">-		pfn1 = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0)</span>
<span class="p_del">-					   &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (kvm_mips_map_page(kvm, mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1)</span>
<span class="p_del">-					   &gt;&gt; PAGE_SHIFT) &lt; 0)</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-		pfn0 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo0)</span>
<span class="p_del">-					    &gt;&gt; PAGE_SHIFT];</span>
<span class="p_del">-		pfn1 = kvm-&gt;arch.guest_pmap[mips3_tlbpfn_to_paddr(tlb-&gt;tlb_lo1)</span>
<span class="p_del">-					    &gt;&gt; PAGE_SHIFT];</span>
<span class="p_add">+	gfn_t gfn0, gfn1;</span>
<span class="p_add">+	long tlb_lo[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	tlb_lo[0] = tlb-&gt;tlb_lo0;</span>
<span class="p_add">+	tlb_lo[1] = tlb-&gt;tlb_lo1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The commpage address must not be mapped to anything else if the guest</span>
<span class="p_add">+	 * TLB contains entries nearby, or commpage accesses will break.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!((tlb-&gt;tlb_hi ^ KVM_GUEST_COMMPAGE_ADDR) &amp;</span>
<span class="p_add">+			VPN2_MASK &amp; (PAGE_MASK &lt;&lt; 1)))</span>
<span class="p_add">+		tlb_lo[(KVM_GUEST_COMMPAGE_ADDR &gt;&gt; PAGE_SHIFT) &amp; 1] = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	gfn0 = mips3_tlbpfn_to_paddr(tlb_lo[0]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	gfn1 = mips3_tlbpfn_to_paddr(tlb_lo[1]) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	if (gfn0 &gt;= kvm-&gt;arch.guest_pmap_npages ||</span>
<span class="p_add">+	    gfn1 &gt;= kvm-&gt;arch.guest_pmap_npages) {</span>
<span class="p_add">+		kvm_err(&quot;%s: Invalid gfn: [%#llx, %#llx], EHi: %#lx\n&quot;,</span>
<span class="p_add">+			__func__, gfn0, gfn1, tlb-&gt;tlb_hi);</span>
<span class="p_add">+		kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+		return -1;</span>
 	}
 
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn0) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kvm_mips_map_page(kvm, gfn1) &lt; 0)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	pfn0 = kvm-&gt;arch.guest_pmap[gfn0];</span>
<span class="p_add">+	pfn1 = kvm-&gt;arch.guest_pmap[gfn1];</span>
<span class="p_add">+</span>
 	if (hpa0)
 		*hpa0 = pfn0 &lt;&lt; PAGE_SHIFT;
 
<span class="p_chunk">@@ -391,9 +405,9 @@</span> <span class="p_context"> int kvm_mips_handle_mapped_seg_tlb_fault(struct kvm_vcpu *vcpu,</span>
 					       kvm_mips_get_kernel_asid(vcpu) :
 					       kvm_mips_get_user_asid(vcpu));
 	entrylo0 = mips3_paddr_to_tlbpfn(pfn0 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-		   (tlb-&gt;tlb_lo0 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo0 &amp; MIPS3_PG_V);</span>
<span class="p_add">+		   (tlb_lo[0] &amp; MIPS3_PG_D) | (tlb_lo[0] &amp; MIPS3_PG_V);</span>
 	entrylo1 = mips3_paddr_to_tlbpfn(pfn1 &lt;&lt; PAGE_SHIFT) | (0x3 &lt;&lt; 3) |
<span class="p_del">-		   (tlb-&gt;tlb_lo1 &amp; MIPS3_PG_D) | (tlb-&gt;tlb_lo1 &amp; MIPS3_PG_V);</span>
<span class="p_add">+		   (tlb_lo[1] &amp; MIPS3_PG_D) | (tlb_lo[1] &amp; MIPS3_PG_V);</span>
 
 	kvm_debug(&quot;@ %#lx tlb_lo0: 0x%08lx tlb_lo1: 0x%08lx\n&quot;, vcpu-&gt;arch.pc,
 		  tlb-&gt;tlb_lo0, tlb-&gt;tlb_lo1);
<span class="p_chunk">@@ -794,10 +808,16 @@</span> <span class="p_context"> uint32_t kvm_get_inst(uint32_t *opc, struct kvm_vcpu *vcpu)</span>
 				local_irq_restore(flags);
 				return KVM_INVALID_INST;
 			}
<span class="p_del">-			kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_del">-							     &amp;vcpu-&gt;arch.</span>
<span class="p_del">-							     guest_tlb[index],</span>
<span class="p_del">-							     NULL, NULL);</span>
<span class="p_add">+			if (kvm_mips_handle_mapped_seg_tlb_fault(vcpu,</span>
<span class="p_add">+						&amp;vcpu-&gt;arch.guest_tlb[index],</span>
<span class="p_add">+						NULL, NULL)) {</span>
<span class="p_add">+				kvm_err(&quot;%s: handling mapped seg tlb fault failed for %p, index: %u, vcpu: %p, ASID: %#lx\n&quot;,</span>
<span class="p_add">+					__func__, opc, index, vcpu,</span>
<span class="p_add">+					read_c0_entryhi());</span>
<span class="p_add">+				kvm_mips_dump_guest_tlbs(vcpu);</span>
<span class="p_add">+				local_irq_restore(flags);</span>
<span class="p_add">+				return KVM_INVALID_INST;</span>
<span class="p_add">+			}</span>
 			inst = *(opc);
 		}
 		local_irq_restore(flags);
<span class="p_header">diff --git a/arch/mips/loongson64/loongson-3/hpet.c b/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_header">index a2631a52ca99..444802e78554 100644</span>
<span class="p_header">--- a/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_header">+++ b/arch/mips/loongson64/loongson-3/hpet.c</span>
<span class="p_chunk">@@ -13,8 +13,8 @@</span> <span class="p_context"></span>
 #define SMBUS_PCI_REG64		0x64
 #define SMBUS_PCI_REGB4		0xb4
 
<span class="p_del">-#define HPET_MIN_CYCLES		64</span>
<span class="p_del">-#define HPET_MIN_PROG_DELTA	(HPET_MIN_CYCLES + (HPET_MIN_CYCLES &gt;&gt; 1))</span>
<span class="p_add">+#define HPET_MIN_CYCLES		16</span>
<span class="p_add">+#define HPET_MIN_PROG_DELTA	(HPET_MIN_CYCLES * 12)</span>
 
 static DEFINE_SPINLOCK(hpet_lock);
 DEFINE_PER_CPU(struct clock_event_device, hpet_clockevent_device);
<span class="p_chunk">@@ -157,14 +157,14 @@</span> <span class="p_context"> static int hpet_tick_resume(struct clock_event_device *evt)</span>
 static int hpet_next_event(unsigned long delta,
 		struct clock_event_device *evt)
 {
<span class="p_del">-	unsigned int cnt;</span>
<span class="p_del">-	int res;</span>
<span class="p_add">+	u32 cnt;</span>
<span class="p_add">+	s32 res;</span>
 
 	cnt = hpet_read(HPET_COUNTER);
<span class="p_del">-	cnt += delta;</span>
<span class="p_add">+	cnt += (u32) delta;</span>
 	hpet_write(HPET_T0_CMP, cnt);
 
<span class="p_del">-	res = (int)(cnt - hpet_read(HPET_COUNTER));</span>
<span class="p_add">+	res = (s32)(cnt - hpet_read(HPET_COUNTER));</span>
 
 	return res &lt; HPET_MIN_CYCLES ? -ETIME : 0;
 }
<span class="p_chunk">@@ -230,7 +230,7 @@</span> <span class="p_context"> void __init setup_hpet_timer(void)</span>
 
 	cd = &amp;per_cpu(hpet_clockevent_device, cpu);
 	cd-&gt;name = &quot;hpet&quot;;
<span class="p_del">-	cd-&gt;rating = 320;</span>
<span class="p_add">+	cd-&gt;rating = 100;</span>
 	cd-&gt;features = CLOCK_EVT_FEAT_PERIODIC | CLOCK_EVT_FEAT_ONESHOT;
 	cd-&gt;set_state_shutdown = hpet_set_state_shutdown;
 	cd-&gt;set_state_periodic = hpet_set_state_periodic;
<span class="p_header">diff --git a/arch/mips/mm/uasm-mips.c b/arch/mips/mm/uasm-mips.c</span>
<span class="p_header">index b4a837893562..5abe51cad899 100644</span>
<span class="p_header">--- a/arch/mips/mm/uasm-mips.c</span>
<span class="p_header">+++ b/arch/mips/mm/uasm-mips.c</span>
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> static struct insn insn_table[] = {</span>
 #ifndef CONFIG_CPU_MIPSR6
 	{ insn_cache,  M(cache_op, 0, 0, 0, 0, 0),  RS | RT | SIMM },
 #else
<span class="p_del">-	{ insn_cache,  M6(cache_op, 0, 0, 0, cache6_op),  RS | RT | SIMM9 },</span>
<span class="p_add">+	{ insn_cache,  M6(spec3_op, 0, 0, 0, cache6_op),  RS | RT | SIMM9 },</span>
 #endif
 	{ insn_daddiu, M(daddiu_op, 0, 0, 0, 0, 0), RS | RT | SIMM },
 	{ insn_daddu, M(spec_op, 0, 0, 0, 0, daddu_op), RS | RT | RD },
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index 463af88c95a2..974f73df00bb 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -655,112 +655,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 
 #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 BEGIN_FTR_SECTION
<span class="p_del">-	b	skip_tm</span>
<span class="p_del">-END_FTR_SECTION_IFCLR(CPU_FTR_TM)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Turn on TM/FP/VSX/VMX so we can restore them. */</span>
<span class="p_del">-	mfmsr	r5</span>
<span class="p_del">-	li	r6, MSR_TM &gt;&gt; 32</span>
<span class="p_del">-	sldi	r6, r6, 32</span>
<span class="p_del">-	or	r5, r5, r6</span>
<span class="p_del">-	ori	r5, r5, MSR_FP</span>
<span class="p_del">-	oris	r5, r5, (MSR_VEC | MSR_VSX)@h</span>
<span class="p_del">-	mtmsrd	r5</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The user may change these outside of a transaction, so they must</span>
<span class="p_del">-	 * always be context switched.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ld	r5, VCPU_TFHAR(r4)</span>
<span class="p_del">-	ld	r6, VCPU_TFIAR(r4)</span>
<span class="p_del">-	ld	r7, VCPU_TEXASR(r4)</span>
<span class="p_del">-	mtspr	SPRN_TFHAR, r5</span>
<span class="p_del">-	mtspr	SPRN_TFIAR, r6</span>
<span class="p_del">-	mtspr	SPRN_TEXASR, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_MSR(r4)</span>
<span class="p_del">-	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_del">-	beq	skip_tm	/* TM not active in guest */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Make sure the failure summary is set, otherwise we&#39;ll program check</span>
<span class="p_del">-	 * when we trechkpt.  It&#39;s possible that this might have been not set</span>
<span class="p_del">-	 * on a kvmppc_set_one_reg() call but we shouldn&#39;t let this crash the</span>
<span class="p_del">-	 * host.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	oris	r7, r7, (TEXASR_FS)@h</span>
<span class="p_del">-	mtspr	SPRN_TEXASR, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to load up the checkpointed state for the guest.</span>
<span class="p_del">-	 * We need to do this early as it will blow away any GPRs, VSRs and</span>
<span class="p_del">-	 * some SPRs.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	mr	r31, r4</span>
<span class="p_del">-	addi	r3, r31, VCPU_FPRS_TM</span>
<span class="p_del">-	bl	load_fp_state</span>
<span class="p_del">-	addi	r3, r31, VCPU_VRS_TM</span>
<span class="p_del">-	bl	load_vr_state</span>
<span class="p_del">-	mr	r4, r31</span>
<span class="p_del">-	lwz	r7, VCPU_VRSAVE_TM(r4)</span>
<span class="p_del">-	mtspr	SPRN_VRSAVE, r7</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_LR_TM(r4)</span>
<span class="p_del">-	lwz	r6, VCPU_CR_TM(r4)</span>
<span class="p_del">-	ld	r7, VCPU_CTR_TM(r4)</span>
<span class="p_del">-	ld	r8, VCPU_AMR_TM(r4)</span>
<span class="p_del">-	ld	r9, VCPU_TAR_TM(r4)</span>
<span class="p_del">-	mtlr	r5</span>
<span class="p_del">-	mtcr	r6</span>
<span class="p_del">-	mtctr	r7</span>
<span class="p_del">-	mtspr	SPRN_AMR, r8</span>
<span class="p_del">-	mtspr	SPRN_TAR, r9</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Load up PPR and DSCR values but don&#39;t put them in the actual SPRs</span>
<span class="p_del">-	 * till the last moment to avoid running with userspace PPR and DSCR for</span>
<span class="p_del">-	 * too long.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ld	r29, VCPU_DSCR_TM(r4)</span>
<span class="p_del">-	ld	r30, VCPU_PPR_TM(r4)</span>
<span class="p_del">-</span>
<span class="p_del">-	std	r2, PACATMSCRATCH(r13) /* Save TOC */</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_del">-	li	r5, 0</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Load GPRs r0-r28 */</span>
<span class="p_del">-	reg = 0</span>
<span class="p_del">-	.rept	29</span>
<span class="p_del">-	ld	reg, VCPU_GPRS_TM(reg)(r31)</span>
<span class="p_del">-	reg = reg + 1</span>
<span class="p_del">-	.endr</span>
<span class="p_del">-</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-	mtspr	SPRN_PPR, r30</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Load final GPRs */</span>
<span class="p_del">-	ld	29, VCPU_GPRS_TM(29)(r31)</span>
<span class="p_del">-	ld	30, VCPU_GPRS_TM(30)(r31)</span>
<span class="p_del">-	ld	31, VCPU_GPRS_TM(31)(r31)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* TM checkpointed state is now setup.  All GPRs are now volatile. */</span>
<span class="p_del">-	TRECHKPT</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Now let&#39;s get back the state we need. */</span>
<span class="p_del">-	HMT_MEDIUM</span>
<span class="p_del">-	GET_PACA(r13)</span>
<span class="p_del">-	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-	ld	r4, HSTATE_KVM_VCPU(r13)</span>
<span class="p_del">-	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_del">-	ld	r2, PACATMSCRATCH(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set the MSR RI since we have our registers back. */</span>
<span class="p_del">-	li	r5, MSR_RI</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-skip_tm:</span>
<span class="p_add">+	bl	kvmppc_restore_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
 #endif
 
 	/* Load guest PMU registers */
<span class="p_chunk">@@ -841,12 +737,6 @@</span> <span class="p_context"> BEGIN_FTR_SECTION</span>
 	/* Skip next section on POWER7 */
 	b	8f
 END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)
<span class="p_del">-	/* Turn on TM so we can access TFHAR/TFIAR/TEXASR */</span>
<span class="p_del">-	mfmsr	r8</span>
<span class="p_del">-	li	r0, 1</span>
<span class="p_del">-	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_del">-	mtmsrd	r8</span>
<span class="p_del">-</span>
 	/* Load up POWER8-specific registers */
 	ld	r5, VCPU_IAMR(r4)
 	lwz	r6, VCPU_PSPB(r4)
<span class="p_chunk">@@ -1436,106 +1326,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 
 #ifdef CONFIG_PPC_TRANSACTIONAL_MEM
 BEGIN_FTR_SECTION
<span class="p_del">-	b	2f</span>
<span class="p_del">-END_FTR_SECTION_IFCLR(CPU_FTR_TM)</span>
<span class="p_del">-	/* Turn on TM. */</span>
<span class="p_del">-	mfmsr	r8</span>
<span class="p_del">-	li	r0, 1</span>
<span class="p_del">-	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_del">-	mtmsrd	r8</span>
<span class="p_del">-</span>
<span class="p_del">-	ld	r5, VCPU_MSR(r9)</span>
<span class="p_del">-	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_del">-	beq	1f	/* TM not active in guest. */</span>
<span class="p_del">-</span>
<span class="p_del">-	li	r3, TM_CAUSE_KVM_RESCHED</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_del">-	li	r5, 0</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* All GPRs are volatile at this point. */</span>
<span class="p_del">-	TRECLAIM(R3)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Temporarily store r13 and r9 so we have some regs to play with */</span>
<span class="p_del">-	SET_SCRATCH0(r13)</span>
<span class="p_del">-	GET_PACA(r13)</span>
<span class="p_del">-	std	r9, PACATMSCRATCH(r13)</span>
<span class="p_del">-	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Get a few more GPRs free. */</span>
<span class="p_del">-	std	r29, VCPU_GPRS_TM(29)(r9)</span>
<span class="p_del">-	std	r30, VCPU_GPRS_TM(30)(r9)</span>
<span class="p_del">-	std	r31, VCPU_GPRS_TM(31)(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save away PPR and DSCR soon so don&#39;t run with user values. */</span>
<span class="p_del">-	mfspr	r31, SPRN_PPR</span>
<span class="p_del">-	HMT_MEDIUM</span>
<span class="p_del">-	mfspr	r30, SPRN_DSCR</span>
<span class="p_del">-	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_del">-	mtspr	SPRN_DSCR, r29</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save all but r9, r13 &amp; r29-r31 */</span>
<span class="p_del">-	reg = 0</span>
<span class="p_del">-	.rept	29</span>
<span class="p_del">-	.if (reg != 9) &amp;&amp; (reg != 13)</span>
<span class="p_del">-	std	reg, VCPU_GPRS_TM(reg)(r9)</span>
<span class="p_del">-	.endif</span>
<span class="p_del">-	reg = reg + 1</span>
<span class="p_del">-	.endr</span>
<span class="p_del">-	/* ... now save r13 */</span>
<span class="p_del">-	GET_SCRATCH0(r4)</span>
<span class="p_del">-	std	r4, VCPU_GPRS_TM(13)(r9)</span>
<span class="p_del">-	/* ... and save r9 */</span>
<span class="p_del">-	ld	r4, PACATMSCRATCH(r13)</span>
<span class="p_del">-	std	r4, VCPU_GPRS_TM(9)(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Reload stack pointer and TOC. */</span>
<span class="p_del">-	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_del">-	ld	r2, PACATOC(r13)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set MSR RI now we have r1 and r13 back. */</span>
<span class="p_del">-	li	r5, MSR_RI</span>
<span class="p_del">-	mtmsrd	r5, 1</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save away checkpinted SPRs. */</span>
<span class="p_del">-	std	r31, VCPU_PPR_TM(r9)</span>
<span class="p_del">-	std	r30, VCPU_DSCR_TM(r9)</span>
<span class="p_del">-	mflr	r5</span>
<span class="p_del">-	mfcr	r6</span>
<span class="p_del">-	mfctr	r7</span>
<span class="p_del">-	mfspr	r8, SPRN_AMR</span>
<span class="p_del">-	mfspr	r10, SPRN_TAR</span>
<span class="p_del">-	std	r5, VCPU_LR_TM(r9)</span>
<span class="p_del">-	stw	r6, VCPU_CR_TM(r9)</span>
<span class="p_del">-	std	r7, VCPU_CTR_TM(r9)</span>
<span class="p_del">-	std	r8, VCPU_AMR_TM(r9)</span>
<span class="p_del">-	std	r10, VCPU_TAR_TM(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Restore r12 as trap number. */</span>
<span class="p_del">-	lwz	r12, VCPU_TRAP(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Save FP/VSX. */</span>
<span class="p_del">-	addi	r3, r9, VCPU_FPRS_TM</span>
<span class="p_del">-	bl	store_fp_state</span>
<span class="p_del">-	addi	r3, r9, VCPU_VRS_TM</span>
<span class="p_del">-	bl	store_vr_state</span>
<span class="p_del">-	mfspr	r6, SPRN_VRSAVE</span>
<span class="p_del">-	stw	r6, VCPU_VRSAVE_TM(r9)</span>
<span class="p_del">-1:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need to save these SPRs after the treclaim so that the software</span>
<span class="p_del">-	 * error code is recorded correctly in the TEXASR.  Also the user may</span>
<span class="p_del">-	 * change these outside of a transaction, so they must always be</span>
<span class="p_del">-	 * context switched.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mfspr	r5, SPRN_TFHAR</span>
<span class="p_del">-	mfspr	r6, SPRN_TFIAR</span>
<span class="p_del">-	mfspr	r7, SPRN_TEXASR</span>
<span class="p_del">-	std	r5, VCPU_TFHAR(r9)</span>
<span class="p_del">-	std	r6, VCPU_TFIAR(r9)</span>
<span class="p_del">-	std	r7, VCPU_TEXASR(r9)</span>
<span class="p_del">-2:</span>
<span class="p_add">+	bl	kvmppc_save_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
 #endif
 
 	/* Increment yield count if they have a VPA */
<span class="p_chunk">@@ -2245,6 +2037,13 @@</span> <span class="p_context"> _GLOBAL(kvmppc_h_cede)		/* r3 = vcpu pointer, r11 = msr, r13 = paca */</span>
 	/* save FP state */
 	bl	kvmppc_save_fp
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+	bl	kvmppc_save_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/*
 	 * Set DEC to the smaller of DEC and HDEC, so that we wake
 	 * no later than the end of our timeslice (HDEC interrupts
<span class="p_chunk">@@ -2321,6 +2120,12 @@</span> <span class="p_context"> kvm_end_cede:</span>
 	bl	kvmhv_accumulate_time
 #endif
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	bl	kvmppc_restore_tm</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	/* load up FP state */
 	bl	kvmppc_load_fp
 
<span class="p_chunk">@@ -2629,6 +2434,239 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ALTIVEC)</span>
 	mr	r4,r31
 	blr
 
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save transactional state and TM-related registers.</span>
<span class="p_add">+ * Called with r9 pointing to the vcpu struct.</span>
<span class="p_add">+ * This can modify all checkpointed registers, but</span>
<span class="p_add">+ * restores r1, r2 and r9 (vcpu pointer) before exit.</span>
<span class="p_add">+ */</span>
<span class="p_add">+kvmppc_save_tm:</span>
<span class="p_add">+	mflr	r0</span>
<span class="p_add">+	std	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on TM. */</span>
<span class="p_add">+	mfmsr	r8</span>
<span class="p_add">+	li	r0, 1</span>
<span class="p_add">+	rldimi	r8, r0, MSR_TM_LG, 63-MSR_TM_LG</span>
<span class="p_add">+	mtmsrd	r8</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_MSR(r9)</span>
<span class="p_add">+	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_add">+	beq	1f	/* TM not active in guest. */</span>
<span class="p_add">+</span>
<span class="p_add">+	std	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	li	r3, TM_CAUSE_KVM_RESCHED</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_add">+	li	r5, 0</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All GPRs are volatile at this point. */</span>
<span class="p_add">+	TRECLAIM(R3)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Temporarily store r13 and r9 so we have some regs to play with */</span>
<span class="p_add">+	SET_SCRATCH0(r13)</span>
<span class="p_add">+	GET_PACA(r13)</span>
<span class="p_add">+	std	r9, PACATMSCRATCH(r13)</span>
<span class="p_add">+	ld	r9, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get a few more GPRs free. */</span>
<span class="p_add">+	std	r29, VCPU_GPRS_TM(29)(r9)</span>
<span class="p_add">+	std	r30, VCPU_GPRS_TM(30)(r9)</span>
<span class="p_add">+	std	r31, VCPU_GPRS_TM(31)(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save away PPR and DSCR soon so don&#39;t run with user values. */</span>
<span class="p_add">+	mfspr	r31, SPRN_PPR</span>
<span class="p_add">+	HMT_MEDIUM</span>
<span class="p_add">+	mfspr	r30, SPRN_DSCR</span>
<span class="p_add">+	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save all but r9, r13 &amp; r29-r31 */</span>
<span class="p_add">+	reg = 0</span>
<span class="p_add">+	.rept	29</span>
<span class="p_add">+	.if (reg != 9) &amp;&amp; (reg != 13)</span>
<span class="p_add">+	std	reg, VCPU_GPRS_TM(reg)(r9)</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	reg = reg + 1</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+	/* ... now save r13 */</span>
<span class="p_add">+	GET_SCRATCH0(r4)</span>
<span class="p_add">+	std	r4, VCPU_GPRS_TM(13)(r9)</span>
<span class="p_add">+	/* ... and save r9 */</span>
<span class="p_add">+	ld	r4, PACATMSCRATCH(r13)</span>
<span class="p_add">+	std	r4, VCPU_GPRS_TM(9)(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reload stack pointer and TOC. */</span>
<span class="p_add">+	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	ld	r2, PACATOC(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set MSR RI now we have r1 and r13 back. */</span>
<span class="p_add">+	li	r5, MSR_RI</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save away checkpinted SPRs. */</span>
<span class="p_add">+	std	r31, VCPU_PPR_TM(r9)</span>
<span class="p_add">+	std	r30, VCPU_DSCR_TM(r9)</span>
<span class="p_add">+	mflr	r5</span>
<span class="p_add">+	mfcr	r6</span>
<span class="p_add">+	mfctr	r7</span>
<span class="p_add">+	mfspr	r8, SPRN_AMR</span>
<span class="p_add">+	mfspr	r10, SPRN_TAR</span>
<span class="p_add">+	std	r5, VCPU_LR_TM(r9)</span>
<span class="p_add">+	stw	r6, VCPU_CR_TM(r9)</span>
<span class="p_add">+	std	r7, VCPU_CTR_TM(r9)</span>
<span class="p_add">+	std	r8, VCPU_AMR_TM(r9)</span>
<span class="p_add">+	std	r10, VCPU_TAR_TM(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore r12 as trap number. */</span>
<span class="p_add">+	lwz	r12, VCPU_TRAP(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Save FP/VSX. */</span>
<span class="p_add">+	addi	r3, r9, VCPU_FPRS_TM</span>
<span class="p_add">+	bl	store_fp_state</span>
<span class="p_add">+	addi	r3, r9, VCPU_VRS_TM</span>
<span class="p_add">+	bl	store_vr_state</span>
<span class="p_add">+	mfspr	r6, SPRN_VRSAVE</span>
<span class="p_add">+	stw	r6, VCPU_VRSAVE_TM(r9)</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to save these SPRs after the treclaim so that the software</span>
<span class="p_add">+	 * error code is recorded correctly in the TEXASR.  Also the user may</span>
<span class="p_add">+	 * change these outside of a transaction, so they must always be</span>
<span class="p_add">+	 * context switched.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mfspr	r5, SPRN_TFHAR</span>
<span class="p_add">+	mfspr	r6, SPRN_TFIAR</span>
<span class="p_add">+	mfspr	r7, SPRN_TEXASR</span>
<span class="p_add">+	std	r5, VCPU_TFHAR(r9)</span>
<span class="p_add">+	std	r6, VCPU_TFIAR(r9)</span>
<span class="p_add">+	std	r7, VCPU_TEXASR(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	mtlr	r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Restore transactional state and TM-related registers.</span>
<span class="p_add">+ * Called with r4 pointing to the vcpu struct.</span>
<span class="p_add">+ * This potentially modifies all checkpointed registers.</span>
<span class="p_add">+ * It restores r1, r2, r4 from the PACA.</span>
<span class="p_add">+ */</span>
<span class="p_add">+kvmppc_restore_tm:</span>
<span class="p_add">+	mflr	r0</span>
<span class="p_add">+	std	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Turn on TM/FP/VSX/VMX so we can restore them. */</span>
<span class="p_add">+	mfmsr	r5</span>
<span class="p_add">+	li	r6, MSR_TM &gt;&gt; 32</span>
<span class="p_add">+	sldi	r6, r6, 32</span>
<span class="p_add">+	or	r5, r5, r6</span>
<span class="p_add">+	ori	r5, r5, MSR_FP</span>
<span class="p_add">+	oris	r5, r5, (MSR_VEC | MSR_VSX)@h</span>
<span class="p_add">+	mtmsrd	r5</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The user may change these outside of a transaction, so they must</span>
<span class="p_add">+	 * always be context switched.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ld	r5, VCPU_TFHAR(r4)</span>
<span class="p_add">+	ld	r6, VCPU_TFIAR(r4)</span>
<span class="p_add">+	ld	r7, VCPU_TEXASR(r4)</span>
<span class="p_add">+	mtspr	SPRN_TFHAR, r5</span>
<span class="p_add">+	mtspr	SPRN_TFIAR, r6</span>
<span class="p_add">+	mtspr	SPRN_TEXASR, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_MSR(r4)</span>
<span class="p_add">+	rldicl. r5, r5, 64 - MSR_TS_S_LG, 62</span>
<span class="p_add">+	beqlr		/* TM not active in guest */</span>
<span class="p_add">+	std	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Make sure the failure summary is set, otherwise we&#39;ll program check</span>
<span class="p_add">+	 * when we trechkpt.  It&#39;s possible that this might have been not set</span>
<span class="p_add">+	 * on a kvmppc_set_one_reg() call but we shouldn&#39;t let this crash the</span>
<span class="p_add">+	 * host.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	oris	r7, r7, (TEXASR_FS)@h</span>
<span class="p_add">+	mtspr	SPRN_TEXASR, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to load up the checkpointed state for the guest.</span>
<span class="p_add">+	 * We need to do this early as it will blow away any GPRs, VSRs and</span>
<span class="p_add">+	 * some SPRs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	mr	r31, r4</span>
<span class="p_add">+	addi	r3, r31, VCPU_FPRS_TM</span>
<span class="p_add">+	bl	load_fp_state</span>
<span class="p_add">+	addi	r3, r31, VCPU_VRS_TM</span>
<span class="p_add">+	bl	load_vr_state</span>
<span class="p_add">+	mr	r4, r31</span>
<span class="p_add">+	lwz	r7, VCPU_VRSAVE_TM(r4)</span>
<span class="p_add">+	mtspr	SPRN_VRSAVE, r7</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r5, VCPU_LR_TM(r4)</span>
<span class="p_add">+	lwz	r6, VCPU_CR_TM(r4)</span>
<span class="p_add">+	ld	r7, VCPU_CTR_TM(r4)</span>
<span class="p_add">+	ld	r8, VCPU_AMR_TM(r4)</span>
<span class="p_add">+	ld	r9, VCPU_TAR_TM(r4)</span>
<span class="p_add">+	mtlr	r5</span>
<span class="p_add">+	mtcr	r6</span>
<span class="p_add">+	mtctr	r7</span>
<span class="p_add">+	mtspr	SPRN_AMR, r8</span>
<span class="p_add">+	mtspr	SPRN_TAR, r9</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Load up PPR and DSCR values but don&#39;t put them in the actual SPRs</span>
<span class="p_add">+	 * till the last moment to avoid running with userspace PPR and DSCR for</span>
<span class="p_add">+	 * too long.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ld	r29, VCPU_DSCR_TM(r4)</span>
<span class="p_add">+	ld	r30, VCPU_PPR_TM(r4)</span>
<span class="p_add">+</span>
<span class="p_add">+	std	r2, PACATMSCRATCH(r13) /* Save TOC */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear the MSR RI since r1, r13 are all going to be foobar. */</span>
<span class="p_add">+	li	r5, 0</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load GPRs r0-r28 */</span>
<span class="p_add">+	reg = 0</span>
<span class="p_add">+	.rept	29</span>
<span class="p_add">+	ld	reg, VCPU_GPRS_TM(reg)(r31)</span>
<span class="p_add">+	reg = reg + 1</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+	mtspr	SPRN_PPR, r30</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Load final GPRs */</span>
<span class="p_add">+	ld	29, VCPU_GPRS_TM(29)(r31)</span>
<span class="p_add">+	ld	30, VCPU_GPRS_TM(30)(r31)</span>
<span class="p_add">+	ld	31, VCPU_GPRS_TM(31)(r31)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* TM checkpointed state is now setup.  All GPRs are now volatile. */</span>
<span class="p_add">+	TRECHKPT</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Now let&#39;s get back the state we need. */</span>
<span class="p_add">+	HMT_MEDIUM</span>
<span class="p_add">+	GET_PACA(r13)</span>
<span class="p_add">+	ld	r29, HSTATE_DSCR(r13)</span>
<span class="p_add">+	mtspr	SPRN_DSCR, r29</span>
<span class="p_add">+	ld	r4, HSTATE_KVM_VCPU(r13)</span>
<span class="p_add">+	ld	r1, HSTATE_HOST_R1(r13)</span>
<span class="p_add">+	ld	r2, PACATMSCRATCH(r13)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the MSR RI since we have our registers back. */</span>
<span class="p_add">+	li	r5, MSR_RI</span>
<span class="p_add">+	mtmsrd	r5, 1</span>
<span class="p_add">+</span>
<span class="p_add">+	ld	r0, PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	mtlr	r0</span>
<span class="p_add">+	blr</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * We come here if we get any exception or interrupt while we are
  * executing host real mode code while in guest MMU context.
<span class="p_header">diff --git a/arch/x86/kvm/mtrr.c b/arch/x86/kvm/mtrr.c</span>
<span class="p_header">index c146f3c262c3..0149ac59c273 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mtrr.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mtrr.c</span>
<span class="p_chunk">@@ -539,6 +539,7 @@</span> <span class="p_context"> static void mtrr_lookup_var_start(struct mtrr_iter *iter)</span>
 
 	iter-&gt;fixed = false;
 	iter-&gt;start_max = iter-&gt;start;
<span class="p_add">+	iter-&gt;range = NULL;</span>
 	iter-&gt;range = list_prepare_entry(iter-&gt;range, &amp;mtrr_state-&gt;head, node);
 
 	__mtrr_lookup_var_next(iter);
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 41e7943004fe..4589b6feeb7b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -8124,6 +8124,7 @@</span> <span class="p_context"> static int vmx_handle_exit(struct kvm_vcpu *vcpu)</span>
 	if ((vectoring_info &amp; VECTORING_INFO_VALID_MASK) &amp;&amp;
 			(exit_reason != EXIT_REASON_EXCEPTION_NMI &amp;&amp;
 			exit_reason != EXIT_REASON_EPT_VIOLATION &amp;&amp;
<span class="p_add">+			exit_reason != EXIT_REASON_PML_FULL &amp;&amp;</span>
 			exit_reason != EXIT_REASON_TASK_SWITCH)) {
 		vcpu-&gt;run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;
 		vcpu-&gt;run-&gt;internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;
<span class="p_chunk">@@ -8736,6 +8737,22 @@</span> <span class="p_context"> static void vmx_load_vmcs01(struct kvm_vcpu *vcpu)</span>
 	put_cpu();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Ensure that the current vmcs of the logical processor is the</span>
<span class="p_add">+ * vmcs01 of the vcpu before calling free_nested().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void vmx_free_vcpu_nested(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+       struct vcpu_vmx *vmx = to_vmx(vcpu);</span>
<span class="p_add">+       int r;</span>
<span class="p_add">+</span>
<span class="p_add">+       r = vcpu_load(vcpu);</span>
<span class="p_add">+       BUG_ON(r);</span>
<span class="p_add">+       vmx_load_vmcs01(vcpu);</span>
<span class="p_add">+       free_nested(vmx);</span>
<span class="p_add">+       vcpu_put(vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void vmx_free_vcpu(struct kvm_vcpu *vcpu)
 {
 	struct vcpu_vmx *vmx = to_vmx(vcpu);
<span class="p_chunk">@@ -8744,8 +8761,7 @@</span> <span class="p_context"> static void vmx_free_vcpu(struct kvm_vcpu *vcpu)</span>
 		vmx_destroy_pml_buffer(vmx);
 	free_vpid(vmx-&gt;vpid);
 	leave_guest_mode(vcpu);
<span class="p_del">-	vmx_load_vmcs01(vcpu);</span>
<span class="p_del">-	free_nested(vmx);</span>
<span class="p_add">+	vmx_free_vcpu_nested(vcpu);</span>
 	free_loaded_vmcs(vmx-&gt;loaded_vmcs);
 	kfree(vmx-&gt;guest_msrs);
 	kvm_vcpu_uninit(vcpu);
<span class="p_header">diff --git a/arch/x86/pci/intel_mid_pci.c b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">index 8b93e634af84..ae97f24a4371 100644</span>
<span class="p_header">--- a/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_header">+++ b/arch/x86/pci/intel_mid_pci.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 
 /* Quirks for the listed devices */
 #define PCI_DEVICE_ID_INTEL_MRFL_MMC	0x1190
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_MRFL_HSU	0x1191</span>
 
 /* Fixed BAR fields */
 #define PCIE_VNDR_CAP_ID_FIXED_BAR 0x00	/* Fixed BAR (TBD) */
<span class="p_chunk">@@ -225,13 +226,20 @@</span> <span class="p_context"> static int intel_mid_pci_irq_enable(struct pci_dev *dev)</span>
 		/* Special treatment for IRQ0 */
 		if (dev-&gt;irq == 0) {
 			/*
<span class="p_add">+			 * Skip HS UART common registers device since it has</span>
<span class="p_add">+			 * IRQ0 assigned and not used by the kernel.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (dev-&gt;device == PCI_DEVICE_ID_INTEL_MRFL_HSU)</span>
<span class="p_add">+				return -EBUSY;</span>
<span class="p_add">+			/*</span>
 			 * TNG has IRQ0 assigned to eMMC controller. But there
 			 * are also other devices with bogus PCI configuration
 			 * that have IRQ0 assigned. This check ensures that
<span class="p_del">-			 * eMMC gets it.</span>
<span class="p_add">+			 * eMMC gets it. The rest of devices still could be</span>
<span class="p_add">+			 * enabled without interrupt line being allocated.</span>
 			 */
 			if (dev-&gt;device != PCI_DEVICE_ID_INTEL_MRFL_MMC)
<span class="p_del">-				return -EBUSY;</span>
<span class="p_add">+				return 0;</span>
 		}
 		break;
 	default:
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index d4d144363250..46e2cc1d4016 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -584,6 +584,8 @@</span> <span class="p_context"> void __bio_clone_fast(struct bio *bio, struct bio *bio_src)</span>
 	bio-&gt;bi_rw = bio_src-&gt;bi_rw;
 	bio-&gt;bi_iter = bio_src-&gt;bi_iter;
 	bio-&gt;bi_io_vec = bio_src-&gt;bi_io_vec;
<span class="p_add">+</span>
<span class="p_add">+	bio_clone_blkcg_association(bio, bio_src);</span>
 }
 EXPORT_SYMBOL(__bio_clone_fast);
 
<span class="p_chunk">@@ -689,6 +691,8 @@</span> <span class="p_context"> integrity_clone:</span>
 		}
 	}
 
<span class="p_add">+	bio_clone_blkcg_association(bio, bio_src);</span>
<span class="p_add">+</span>
 	return bio;
 }
 EXPORT_SYMBOL(bio_clone_bioset);
<span class="p_chunk">@@ -2014,6 +2018,17 @@</span> <span class="p_context"> void bio_disassociate_task(struct bio *bio)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * bio_clone_blkcg_association - clone blkcg association from src to dst bio</span>
<span class="p_add">+ * @dst: destination bio</span>
<span class="p_add">+ * @src: source bio</span>
<span class="p_add">+ */</span>
<span class="p_add">+void bio_clone_blkcg_association(struct bio *dst, struct bio *src)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (src-&gt;bi_css)</span>
<span class="p_add">+		WARN_ON(bio_associate_blkcg(dst, src-&gt;bi_css));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* CONFIG_BLK_CGROUP */
 
 static void __init biovec_init_slabs(void)
<span class="p_header">diff --git a/block/genhd.c b/block/genhd.c</span>
<span class="p_header">index d2a1d43bf9fa..a5bed6bc869d 100644</span>
<span class="p_header">--- a/block/genhd.c</span>
<span class="p_header">+++ b/block/genhd.c</span>
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> void add_disk(struct gendisk *disk)</span>
 
 	/* Register BDI before referencing it from bdev */
 	bdi = &amp;disk-&gt;queue-&gt;backing_dev_info;
<span class="p_del">-	bdi_register_dev(bdi, disk_devt(disk));</span>
<span class="p_add">+	bdi_register_owner(bdi, disk_to_dev(disk));</span>
 
 	blk_register_region(disk_devt(disk), disk-&gt;minors, NULL,
 			    exact_match, exact_lock, disk);
<span class="p_header">diff --git a/drivers/acpi/ec.c b/drivers/acpi/ec.c</span>
<span class="p_header">index b420fb46669d..43f20328f830 100644</span>
<span class="p_header">--- a/drivers/acpi/ec.c</span>
<span class="p_header">+++ b/drivers/acpi/ec.c</span>
<span class="p_chunk">@@ -101,6 +101,7 @@</span> <span class="p_context"> enum ec_command {</span>
 #define ACPI_EC_UDELAY_POLL	550	/* Wait 1ms for EC transaction polling */
 #define ACPI_EC_CLEAR_MAX	100	/* Maximum number of events to query
 					 * when trying to clear the EC */
<span class="p_add">+#define ACPI_EC_MAX_QUERIES	16	/* Maximum number of parallel queries */</span>
 
 enum {
 	EC_FLAGS_QUERY_PENDING,		/* Query is pending */
<span class="p_chunk">@@ -121,6 +122,10 @@</span> <span class="p_context"> static unsigned int ec_delay __read_mostly = ACPI_EC_DELAY;</span>
 module_param(ec_delay, uint, 0644);
 MODULE_PARM_DESC(ec_delay, &quot;Timeout(ms) waited until an EC command completes&quot;);
 
<span class="p_add">+static unsigned int ec_max_queries __read_mostly = ACPI_EC_MAX_QUERIES;</span>
<span class="p_add">+module_param(ec_max_queries, uint, 0644);</span>
<span class="p_add">+MODULE_PARM_DESC(ec_max_queries, &quot;Maximum parallel _Qxx evaluations&quot;);</span>
<span class="p_add">+</span>
 static bool ec_busy_polling __read_mostly;
 module_param(ec_busy_polling, bool, 0644);
 MODULE_PARM_DESC(ec_busy_polling, &quot;Use busy polling to advance EC transaction&quot;);
<span class="p_chunk">@@ -174,6 +179,7 @@</span> <span class="p_context"> static void acpi_ec_event_processor(struct work_struct *work);</span>
 
 struct acpi_ec *boot_ec, *first_ec;
 EXPORT_SYMBOL(first_ec);
<span class="p_add">+static struct workqueue_struct *ec_query_wq;</span>
 
 static int EC_FLAGS_VALIDATE_ECDT; /* ASUStec ECDTs need to be validated */
 static int EC_FLAGS_SKIP_DSDT_SCAN; /* Not all BIOS survive early DSDT scan */
<span class="p_chunk">@@ -1097,7 +1103,7 @@</span> <span class="p_context"> static int acpi_ec_query(struct acpi_ec *ec, u8 *data)</span>
 	 * work queue execution.
 	 */
 	ec_dbg_evt(&quot;Query(0x%02x) scheduled&quot;, value);
<span class="p_del">-	if (!schedule_work(&amp;q-&gt;work)) {</span>
<span class="p_add">+	if (!queue_work(ec_query_wq, &amp;q-&gt;work)) {</span>
 		ec_dbg_evt(&quot;Query(0x%02x) overlapped&quot;, value);
 		result = -EBUSY;
 	}
<span class="p_chunk">@@ -1657,15 +1663,41 @@</span> <span class="p_context"> static struct acpi_driver acpi_ec_driver = {</span>
 		},
 };
 
<span class="p_add">+static inline int acpi_ec_query_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!ec_query_wq) {</span>
<span class="p_add">+		ec_query_wq = alloc_workqueue(&quot;kec_query&quot;, 0,</span>
<span class="p_add">+					      ec_max_queries);</span>
<span class="p_add">+		if (!ec_query_wq)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void acpi_ec_query_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ec_query_wq) {</span>
<span class="p_add">+		destroy_workqueue(ec_query_wq);</span>
<span class="p_add">+		ec_query_wq = NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int __init acpi_ec_init(void)
 {
<span class="p_del">-	int result = 0;</span>
<span class="p_add">+	int result;</span>
 
<span class="p_add">+	/* register workqueue for _Qxx evaluations */</span>
<span class="p_add">+	result = acpi_ec_query_init();</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		goto err_exit;</span>
 	/* Now register the driver for the EC */
 	result = acpi_bus_register_driver(&amp;acpi_ec_driver);
<span class="p_del">-	if (result &lt; 0)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		goto err_exit;</span>
 
<span class="p_add">+err_exit:</span>
<span class="p_add">+	if (result)</span>
<span class="p_add">+		acpi_ec_query_exit();</span>
 	return result;
 }
 
<span class="p_chunk">@@ -1675,5 +1707,6 @@</span> <span class="p_context"> static void __exit acpi_ec_exit(void)</span>
 {
 
 	acpi_bus_unregister_driver(&amp;acpi_ec_driver);
<span class="p_add">+	acpi_ec_query_exit();</span>
 }
 #endif	/* 0 */
<span class="p_header">diff --git a/drivers/bluetooth/hci_intel.c b/drivers/bluetooth/hci_intel.c</span>
<span class="p_header">index 4a414a5a3165..b9065506a847 100644</span>
<span class="p_header">--- a/drivers/bluetooth/hci_intel.c</span>
<span class="p_header">+++ b/drivers/bluetooth/hci_intel.c</span>
<span class="p_chunk">@@ -1234,8 +1234,7 @@</span> <span class="p_context"> static int intel_probe(struct platform_device *pdev)</span>
 
 	idev-&gt;pdev = pdev;
 
<span class="p_del">-	idev-&gt;reset = devm_gpiod_get_optional(&amp;pdev-&gt;dev, &quot;reset&quot;,</span>
<span class="p_del">-					      GPIOD_OUT_LOW);</span>
<span class="p_add">+	idev-&gt;reset = devm_gpiod_get(&amp;pdev-&gt;dev, &quot;reset&quot;, GPIOD_OUT_LOW);</span>
 	if (IS_ERR(idev-&gt;reset)) {
 		dev_err(&amp;pdev-&gt;dev, &quot;Unable to retrieve gpio\n&quot;);
 		return PTR_ERR(idev-&gt;reset);
<span class="p_chunk">@@ -1247,8 +1246,7 @@</span> <span class="p_context"> static int intel_probe(struct platform_device *pdev)</span>
 
 		dev_err(&amp;pdev-&gt;dev, &quot;No IRQ, falling back to gpio-irq\n&quot;);
 
<span class="p_del">-		host_wake = devm_gpiod_get_optional(&amp;pdev-&gt;dev, &quot;host-wake&quot;,</span>
<span class="p_del">-						    GPIOD_IN);</span>
<span class="p_add">+		host_wake = devm_gpiod_get(&amp;pdev-&gt;dev, &quot;host-wake&quot;, GPIOD_IN);</span>
 		if (IS_ERR(host_wake)) {
 			dev_err(&amp;pdev-&gt;dev, &quot;Unable to retrieve IRQ\n&quot;);
 			goto no_irq;
<span class="p_header">diff --git a/drivers/char/random.c b/drivers/char/random.c</span>
<span class="p_header">index 0227b0465b40..491a4dce13fe 100644</span>
<span class="p_header">--- a/drivers/char/random.c</span>
<span class="p_header">+++ b/drivers/char/random.c</span>
<span class="p_chunk">@@ -948,6 +948,7 @@</span> <span class="p_context"> void add_interrupt_randomness(int irq, int irq_flags)</span>
 	/* award one bit for the contents of the fast pool */
 	credit_entropy_bits(r, credit + 1);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(add_interrupt_randomness);</span>
 
 #ifdef CONFIG_BLOCK
 void add_disk_randomness(struct gendisk *disk)
<span class="p_chunk">@@ -1460,12 +1461,16 @@</span> <span class="p_context"> random_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)</span>
 static ssize_t
 urandom_read(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
 {
<span class="p_add">+	static int maxwarn = 10;</span>
 	int ret;
 
<span class="p_del">-	if (unlikely(nonblocking_pool.initialized == 0))</span>
<span class="p_del">-		printk_once(KERN_NOTICE &quot;random: %s urandom read &quot;</span>
<span class="p_del">-			    &quot;with %d bits of entropy available\n&quot;,</span>
<span class="p_del">-			    current-&gt;comm, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	if (unlikely(nonblocking_pool.initialized == 0) &amp;&amp;</span>
<span class="p_add">+	    maxwarn &gt; 0) {</span>
<span class="p_add">+		maxwarn--;</span>
<span class="p_add">+		printk(KERN_NOTICE &quot;random: %s: uninitialized urandom read &quot;</span>
<span class="p_add">+		       &quot;(%zd bytes read, %d bits of entropy available)\n&quot;,</span>
<span class="p_add">+		       current-&gt;comm, nbytes, nonblocking_pool.entropy_total);</span>
<span class="p_add">+	}</span>
 
 	nbytes = min_t(size_t, nbytes, INT_MAX &gt;&gt; (ENTROPY_SHIFT + 3));
 	ret = extract_entropy_user(&amp;nonblocking_pool, buf, nbytes);
<span class="p_chunk">@@ -1847,12 +1852,18 @@</span> <span class="p_context"> void add_hwgenerator_randomness(const char *buffer, size_t count,</span>
 {
 	struct entropy_store *poolp = &amp;input_pool;
 
<span class="p_del">-	/* Suspend writing if we&#39;re above the trickle threshold.</span>
<span class="p_del">-	 * We&#39;ll be woken up again once below random_write_wakeup_thresh,</span>
<span class="p_del">-	 * or when the calling thread is about to terminate.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	wait_event_interruptible(random_write_wait, kthread_should_stop() ||</span>
<span class="p_add">+	if (unlikely(nonblocking_pool.initialized == 0))</span>
<span class="p_add">+		poolp = &amp;nonblocking_pool;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		/* Suspend writing if we&#39;re above the trickle</span>
<span class="p_add">+		 * threshold.  We&#39;ll be woken up again once below</span>
<span class="p_add">+		 * random_write_wakeup_thresh, or when the calling</span>
<span class="p_add">+		 * thread is about to terminate.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		wait_event_interruptible(random_write_wait,</span>
<span class="p_add">+					 kthread_should_stop() ||</span>
 			ENTROPY_BITS(&amp;input_pool) &lt;= random_write_wakeup_bits);
<span class="p_add">+	}</span>
 	mix_pool_bytes(poolp, buffer, count);
 	credit_entropy_bits(poolp, entropy);
 }
<span class="p_header">diff --git a/drivers/cpufreq/intel_pstate.c b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">index f53b02a6bc05..6e80e4298274 100644</span>
<span class="p_header">--- a/drivers/cpufreq/intel_pstate.c</span>
<span class="p_header">+++ b/drivers/cpufreq/intel_pstate.c</span>
<span class="p_chunk">@@ -662,7 +662,7 @@</span> <span class="p_context"> static int core_get_max_pstate(void)</span>
 			if (err)
 				goto skip_tar;
 
<span class="p_del">-			tdp_msr = MSR_CONFIG_TDP_NOMINAL + tdp_ctrl;</span>
<span class="p_add">+			tdp_msr = MSR_CONFIG_TDP_NOMINAL + (tdp_ctrl &amp; 0x3);</span>
 			err = rdmsrl_safe(tdp_msr, &amp;tdp_ratio);
 			if (err)
 				goto skip_tar;
<span class="p_header">diff --git a/drivers/edac/edac_mc_sysfs.c b/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_header">index 58aed67b7eba..3c8f19f5ac81 100644</span>
<span class="p_header">--- a/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_header">+++ b/drivers/edac/edac_mc_sysfs.c</span>
<span class="p_chunk">@@ -313,7 +313,6 @@</span> <span class="p_context"> static struct device_type csrow_attr_type = {</span>
  * possible dynamic channel DIMM Label attribute files
  *
  */
<span class="p_del">-</span>
 DEVICE_CHANNEL(ch0_dimm_label, S_IRUGO | S_IWUSR,
 	channel_dimm_label_show, channel_dimm_label_store, 0);
 DEVICE_CHANNEL(ch1_dimm_label, S_IRUGO | S_IWUSR,
<span class="p_chunk">@@ -326,6 +325,10 @@</span> <span class="p_context"> DEVICE_CHANNEL(ch4_dimm_label, S_IRUGO | S_IWUSR,</span>
 	channel_dimm_label_show, channel_dimm_label_store, 4);
 DEVICE_CHANNEL(ch5_dimm_label, S_IRUGO | S_IWUSR,
 	channel_dimm_label_show, channel_dimm_label_store, 5);
<span class="p_add">+DEVICE_CHANNEL(ch6_dimm_label, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+	channel_dimm_label_show, channel_dimm_label_store, 6);</span>
<span class="p_add">+DEVICE_CHANNEL(ch7_dimm_label, S_IRUGO | S_IWUSR,</span>
<span class="p_add">+	channel_dimm_label_show, channel_dimm_label_store, 7);</span>
 
 /* Total possible dynamic DIMM Label attribute file table */
 static struct attribute *dynamic_csrow_dimm_attr[] = {
<span class="p_chunk">@@ -335,6 +338,8 @@</span> <span class="p_context"> static struct attribute *dynamic_csrow_dimm_attr[] = {</span>
 	&amp;dev_attr_legacy_ch3_dimm_label.attr.attr,
 	&amp;dev_attr_legacy_ch4_dimm_label.attr.attr,
 	&amp;dev_attr_legacy_ch5_dimm_label.attr.attr,
<span class="p_add">+	&amp;dev_attr_legacy_ch6_dimm_label.attr.attr,</span>
<span class="p_add">+	&amp;dev_attr_legacy_ch7_dimm_label.attr.attr,</span>
 	NULL
 };
 
<span class="p_chunk">@@ -351,6 +356,10 @@</span> <span class="p_context"> DEVICE_CHANNEL(ch4_ce_count, S_IRUGO,</span>
 		   channel_ce_count_show, NULL, 4);
 DEVICE_CHANNEL(ch5_ce_count, S_IRUGO,
 		   channel_ce_count_show, NULL, 5);
<span class="p_add">+DEVICE_CHANNEL(ch6_ce_count, S_IRUGO,</span>
<span class="p_add">+		   channel_ce_count_show, NULL, 6);</span>
<span class="p_add">+DEVICE_CHANNEL(ch7_ce_count, S_IRUGO,</span>
<span class="p_add">+		   channel_ce_count_show, NULL, 7);</span>
 
 /* Total possible dynamic ce_count attribute file table */
 static struct attribute *dynamic_csrow_ce_count_attr[] = {
<span class="p_chunk">@@ -360,6 +369,8 @@</span> <span class="p_context"> static struct attribute *dynamic_csrow_ce_count_attr[] = {</span>
 	&amp;dev_attr_legacy_ch3_ce_count.attr.attr,
 	&amp;dev_attr_legacy_ch4_ce_count.attr.attr,
 	&amp;dev_attr_legacy_ch5_ce_count.attr.attr,
<span class="p_add">+	&amp;dev_attr_legacy_ch6_ce_count.attr.attr,</span>
<span class="p_add">+	&amp;dev_attr_legacy_ch7_ce_count.attr.attr,</span>
 	NULL
 };
 
<span class="p_chunk">@@ -371,9 +382,16 @@</span> <span class="p_context"> static umode_t csrow_dev_is_visible(struct kobject *kobj,</span>
 
 	if (idx &gt;= csrow-&gt;nr_channels)
 		return 0;
<span class="p_add">+</span>
<span class="p_add">+	if (idx &gt;= ARRAY_SIZE(dynamic_csrow_ce_count_attr) - 1) {</span>
<span class="p_add">+		WARN_ONCE(1, &quot;idx: %d\n&quot;, idx);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Only expose populated DIMMs */
 	if (!csrow-&gt;channels[idx]-&gt;dimm-&gt;nr_pages)
 		return 0;
<span class="p_add">+</span>
 	return attr-&gt;mode;
 }
 
<span class="p_header">diff --git a/drivers/gpio/gpio-intel-mid.c b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">index 70097472b02c..c50e930d97d3 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-intel-mid.c</span>
<span class="p_chunk">@@ -17,7 +17,6 @@</span> <span class="p_context"></span>
  * Moorestown platform Langwell chip.
  * Medfield platform Penwell chip.
  * Clovertrail platform Cloverview chip.
<span class="p_del">- * Merrifield platform Tangier chip.</span>
  */
 
 #include &lt;linux/module.h&gt;
<span class="p_chunk">@@ -64,10 +63,6 @@</span> <span class="p_context"> enum GPIO_REG {</span>
 /* intel_mid gpio driver data */
 struct intel_mid_gpio_ddata {
 	u16 ngpio;		/* number of gpio pins */
<span class="p_del">-	u32 gplr_offset;	/* offset of first GPLR register from base */</span>
<span class="p_del">-	u32 flis_base;		/* base address of FLIS registers */</span>
<span class="p_del">-	u32 flis_len;		/* length of FLIS registers */</span>
<span class="p_del">-	u32 (*get_flis_offset)(int gpio);</span>
 	u32 chip_irq_type;	/* chip interrupt type */
 };
 
<span class="p_chunk">@@ -257,15 +252,6 @@</span> <span class="p_context"> static const struct intel_mid_gpio_ddata gpio_cloverview_core = {</span>
 	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,
 };
 
<span class="p_del">-static const struct intel_mid_gpio_ddata gpio_tangier = {</span>
<span class="p_del">-	.ngpio = 192,</span>
<span class="p_del">-	.gplr_offset = 4,</span>
<span class="p_del">-	.flis_base = 0xff0c0000,</span>
<span class="p_del">-	.flis_len = 0x8000,</span>
<span class="p_del">-	.get_flis_offset = NULL,</span>
<span class="p_del">-	.chip_irq_type = INTEL_MID_IRQ_TYPE_EDGE,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static const struct pci_device_id intel_gpio_ids[] = {
 	{
 		/* Lincroft */
<span class="p_chunk">@@ -292,11 +278,6 @@</span> <span class="p_context"> static const struct pci_device_id intel_gpio_ids[] = {</span>
 		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x08f7),
 		.driver_data = (kernel_ulong_t)&amp;gpio_cloverview_core,
 	},
<span class="p_del">-	{</span>
<span class="p_del">-		/* Tangier */</span>
<span class="p_del">-		PCI_DEVICE(PCI_VENDOR_ID_INTEL, 0x1199),</span>
<span class="p_del">-		.driver_data = (kernel_ulong_t)&amp;gpio_tangier,</span>
<span class="p_del">-	},</span>
 	{ 0 }
 };
 MODULE_DEVICE_TABLE(pci, intel_gpio_ids);
<span class="p_header">diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">index 2d4892cc70fb..c844d7eccb6c 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-pca953x.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-pca953x.c</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(acpi, pca953x_acpi_ids);</span>
 #define MAX_BANK 5
 #define BANK_SZ 8
 
<span class="p_del">-#define NBANK(chip) (chip-&gt;gpio_chip.ngpio / BANK_SZ)</span>
<span class="p_add">+#define NBANK(chip) DIV_ROUND_UP(chip-&gt;gpio_chip.ngpio, BANK_SZ)</span>
 
 struct pca953x_chip {
 	unsigned gpio_start;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index 9416e0f5c1db..0aaa457a1710 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -566,28 +566,19 @@</span> <span class="p_context"> int amdgpu_atombios_get_clock_info(struct amdgpu_device *adev)</span>
 		    le16_to_cpu(firmware_info-&gt;info.usReferenceClock);
 		ppll-&gt;reference_div = 0;
 
<span class="p_del">-		if (crev &lt; 2)</span>
<span class="p_del">-			ppll-&gt;pll_out_min =</span>
<span class="p_del">-				le16_to_cpu(firmware_info-&gt;info.usMinPixelClockPLL_Output);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ppll-&gt;pll_out_min =</span>
<span class="p_del">-				le32_to_cpu(firmware_info-&gt;info_12.ulMinPixelClockPLL_Output);</span>
<span class="p_add">+		ppll-&gt;pll_out_min =</span>
<span class="p_add">+			le32_to_cpu(firmware_info-&gt;info_12.ulMinPixelClockPLL_Output);</span>
 		ppll-&gt;pll_out_max =
 		    le32_to_cpu(firmware_info-&gt;info.ulMaxPixelClockPLL_Output);
 
<span class="p_del">-		if (crev &gt;= 4) {</span>
<span class="p_del">-			ppll-&gt;lcd_pll_out_min =</span>
<span class="p_del">-				le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;</span>
<span class="p_del">-			if (ppll-&gt;lcd_pll_out_min == 0)</span>
<span class="p_del">-				ppll-&gt;lcd_pll_out_min = ppll-&gt;pll_out_min;</span>
<span class="p_del">-			ppll-&gt;lcd_pll_out_max =</span>
<span class="p_del">-				le16_to_cpu(firmware_info-&gt;info_14.usLcdMaxPixelClockPLL_Output) * 100;</span>
<span class="p_del">-			if (ppll-&gt;lcd_pll_out_max == 0)</span>
<span class="p_del">-				ppll-&gt;lcd_pll_out_max = ppll-&gt;pll_out_max;</span>
<span class="p_del">-		} else {</span>
<span class="p_add">+		ppll-&gt;lcd_pll_out_min =</span>
<span class="p_add">+			le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;</span>
<span class="p_add">+		if (ppll-&gt;lcd_pll_out_min == 0)</span>
 			ppll-&gt;lcd_pll_out_min = ppll-&gt;pll_out_min;
<span class="p_add">+		ppll-&gt;lcd_pll_out_max =</span>
<span class="p_add">+			le16_to_cpu(firmware_info-&gt;info_14.usLcdMaxPixelClockPLL_Output) * 100;</span>
<span class="p_add">+		if (ppll-&gt;lcd_pll_out_max == 0)</span>
 			ppll-&gt;lcd_pll_out_max = ppll-&gt;pll_out_max;
<span class="p_del">-		}</span>
 
 		if (ppll-&gt;pll_out_min == 0)
 			ppll-&gt;pll_out_min = 64800;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">index 5a8fbadbd27b..29adbbe225c4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atpx_handler.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/pci.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #include &quot;amdgpu_acpi.h&quot;
 
<span class="p_chunk">@@ -256,6 +257,10 @@</span> <span class="p_context"> static int amdgpu_atpx_set_discrete_state(struct amdgpu_atpx *atpx, u8 state)</span>
 		if (!info)
 			return -EIO;
 		kfree(info);
<span class="p_add">+</span>
<span class="p_add">+		/* 200ms delay is required after off */</span>
<span class="p_add">+		if (state == 0)</span>
<span class="p_add">+			msleep(200);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_header">index 7ef2c13921b4..930083336968 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c</span>
<span class="p_chunk">@@ -1690,7 +1690,6 @@</span> <span class="p_context"> amdgpu_connector_add(struct amdgpu_device *adev,</span>
 						   DRM_MODE_SCALE_NONE);
 			/* no HPD on analog connectors */
 			amdgpu_connector-&gt;hpd.hpd = AMDGPU_HPD_NONE;
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 			connector-&gt;interlace_allowed = true;
 			connector-&gt;doublescan_allowed = true;
 			break;
<span class="p_chunk">@@ -1893,8 +1892,10 @@</span> <span class="p_context"> amdgpu_connector_add(struct amdgpu_device *adev,</span>
 	}
 
 	if (amdgpu_connector-&gt;hpd.hpd == AMDGPU_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">index c961fe093e12..16302f7d59f6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c</span>
<span class="p_chunk">@@ -1793,7 +1793,23 @@</span> <span class="p_context"> int amdgpu_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 	}
 
 	drm_kms_helper_poll_enable(dev);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Most of the connector probing functions try to acquire runtime pm</span>
<span class="p_add">+	 * refs to ensure that the GPU is powered on when connector polling is</span>
<span class="p_add">+	 * performed. Since we&#39;re calling this from a runtime PM callback,</span>
<span class="p_add">+	 * trying to acquire rpm refs will cause us to deadlock.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Since we&#39;re guaranteed to be holding the rpm lock, it&#39;s safe to</span>
<span class="p_add">+	 * temporarily disable the rpm helpers so this doesn&#39;t deadlock us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+	dev-&gt;dev-&gt;power.disable_depth++;</span>
<span class="p_add">+#endif</span>
 	drm_helper_hpd_irq_event(dev);
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+	dev-&gt;dev-&gt;power.disable_depth--;</span>
<span class="p_add">+#endif</span>
 
 	if (fbcon) {
 		amdgpu_fbdev_set_suspend(adev, 0);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c</span>
<span class="p_header">index 1cd6de575305..542517d4e584 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c</span>
<span class="p_chunk">@@ -98,6 +98,7 @@</span> <span class="p_context"> amdgpu_atombios_encoder_set_backlight_level(struct amdgpu_encoder *amdgpu_encode</span>
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
<span class="p_add">+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:</span>
 			if (dig-&gt;backlight_level == 0)
 				amdgpu_atombios_encoder_setup_dig_transmitter(encoder,
 								       ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_header">index ea87033bfaf6..df17fababbd6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c</span>
<span class="p_chunk">@@ -167,6 +167,7 @@</span> <span class="p_context"> static int gmc_v7_0_init_microcode(struct amdgpu_device *adev)</span>
 		break;
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
<span class="p_add">+	case CHIP_MULLINS:</span>
 		return 0;
 	default: BUG();
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/drm_cache.c b/drivers/gpu/drm/drm_cache.c</span>
<span class="p_header">index 6743ff7dccfa..7f4a6c550319 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_cache.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_cache.c</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> drm_clflush_virt_range(void *addr, unsigned long length)</span>
 		mb();
 		for (; addr &lt; end; addr += size)
 			clflushopt(addr);
<span class="p_add">+		clflushopt(end - 1); /* force serialisation */</span>
 		mb();
 		return;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index d5d2c03fd136..8c9ac021608f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -73,6 +73,8 @@</span> <span class="p_context"></span>
 #define EDID_QUIRK_FORCE_8BPC			(1 &lt;&lt; 8)
 /* Force 12bpc */
 #define EDID_QUIRK_FORCE_12BPC			(1 &lt;&lt; 9)
<span class="p_add">+/* Force 6bpc */</span>
<span class="p_add">+#define EDID_QUIRK_FORCE_6BPC			(1 &lt;&lt; 10)</span>
 
 struct detailed_mode_closure {
 	struct drm_connector *connector;
<span class="p_chunk">@@ -99,6 +101,9 @@</span> <span class="p_context"> static struct edid_quirk {</span>
 	/* Unknown Acer */
 	{ &quot;ACR&quot;, 2423, EDID_QUIRK_FIRST_DETAILED_PREFERRED },
 
<span class="p_add">+	/* AEO model 0 reports 8 bpc, but is a 6 bpc panel */</span>
<span class="p_add">+	{ &quot;AEO&quot;, 0, EDID_QUIRK_FORCE_6BPC },</span>
<span class="p_add">+</span>
 	/* Belinea 10 15 55 */
 	{ &quot;MAX&quot;, 1516, EDID_QUIRK_PREFER_LARGE_60 },
 	{ &quot;MAX&quot;, 0x77e, EDID_QUIRK_PREFER_LARGE_60 },
<span class="p_chunk">@@ -3820,6 +3825,9 @@</span> <span class="p_context"> int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)</span>
 
 	drm_add_display_info(edid, &amp;connector-&gt;display_info, connector);
 
<span class="p_add">+	if (quirks &amp; EDID_QUIRK_FORCE_6BPC)</span>
<span class="p_add">+		connector-&gt;display_info.bpc = 6;</span>
<span class="p_add">+</span>
 	if (quirks &amp; EDID_QUIRK_FORCE_8BPC)
 		connector-&gt;display_info.bpc = 8;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index c41bc42b6fa7..3292495ee10f 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -11952,21 +11952,11 @@</span> <span class="p_context"> connected_sink_compute_bpp(struct intel_connector *connector,</span>
 		pipe_config-&gt;pipe_bpp = connector-&gt;base.display_info.bpc*3;
 	}
 
<span class="p_del">-	/* Clamp bpp to default limit on screens without EDID 1.4 */</span>
<span class="p_del">-	if (connector-&gt;base.display_info.bpc == 0) {</span>
<span class="p_del">-		int type = connector-&gt;base.connector_type;</span>
<span class="p_del">-		int clamp_bpp = 24;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Fall back to 18 bpp when DP sink capability is unknown. */</span>
<span class="p_del">-		if (type == DRM_MODE_CONNECTOR_DisplayPort ||</span>
<span class="p_del">-		    type == DRM_MODE_CONNECTOR_eDP)</span>
<span class="p_del">-			clamp_bpp = 18;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (bpp &gt; clamp_bpp) {</span>
<span class="p_del">-			DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of %d\n&quot;,</span>
<span class="p_del">-				      bpp, clamp_bpp);</span>
<span class="p_del">-			pipe_config-&gt;pipe_bpp = clamp_bpp;</span>
<span class="p_del">-		}</span>
<span class="p_add">+	/* Clamp bpp to 8 on screens without EDID 1.4 */</span>
<span class="p_add">+	if (connector-&gt;base.display_info.bpc == 0 &amp;&amp; bpp &gt; 24) {</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;clamping display bpp (was %d) to default limit of 24\n&quot;,</span>
<span class="p_add">+			      bpp);</span>
<span class="p_add">+		pipe_config-&gt;pipe_bpp = 24;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_opregion.c b/drivers/gpu/drm/i915/intel_opregion.c</span>
<span class="p_header">index 6dc13c02c28e..e362a30776fa 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_opregion.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_opregion.c</span>
<span class="p_chunk">@@ -682,7 +682,7 @@</span> <span class="p_context"> static void intel_didl_outputs(struct drm_device *dev)</span>
 	}
 
 	if (!acpi_video_bus) {
<span class="p_del">-		DRM_ERROR(&quot;No ACPI video bus found\n&quot;);</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;No ACPI video bus found\n&quot;);</span>
 		return;
 	}
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index eb434881ddbc..1e851e037c29 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -4526,7 +4526,8 @@</span> <span class="p_context"> void gen6_rps_idle(struct drm_i915_private *dev_priv)</span>
 		else
 			gen6_set_rps(dev_priv-&gt;dev, dev_priv-&gt;rps.idle_freq);
 		dev_priv-&gt;rps.last_adj = 0;
<span class="p_del">-		I915_WRITE(GEN6_PMINTRMSK, 0xffffffff);</span>
<span class="p_add">+		I915_WRITE(GEN6_PMINTRMSK,</span>
<span class="p_add">+			   gen6_sanitize_rps_pm_mask(dev_priv, ~0));</span>
 	}
 	mutex_unlock(&amp;dev_priv-&gt;rps.hw_lock);
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nouveau_drm.c b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">index 1d3ee5179ab8..d236fc7c425b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nouveau_drm.c</span>
<span class="p_chunk">@@ -308,7 +308,16 @@</span> <span class="p_context"> static int nouveau_drm_probe(struct pci_dev *pdev,</span>
 	bool boot = false;
 	int ret;
 
<span class="p_del">-	/* remove conflicting drivers (vesafb, efifb etc) */</span>
<span class="p_add">+	/* We need to check that the chipset is supported before booting</span>
<span class="p_add">+	 * fbdev off the hardware, as there&#39;s no way to put it back.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = nvkm_device_pci_new(pdev, NULL, &quot;error&quot;, true, false, 0, &amp;device);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	nvkm_device_del(&amp;device);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Remove conflicting drivers (vesafb, efifb etc). */</span>
 	aper = alloc_apertures(3);
 	if (!aper)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv04_fbcon.c b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">index 8f715feadf56..f90568327468 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv04_fbcon.c</span>
<span class="p_chunk">@@ -107,11 +107,11 @@</span> <span class="p_context"> nv04_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 			 ((image-&gt;dx + image-&gt;width) &amp; 0xffff));
 	OUT_RING(chan, bg);
 	OUT_RING(chan, fg);
<span class="p_del">-	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);</span>
<span class="p_add">+	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | ALIGN(image-&gt;width, 8));</span>
 	OUT_RING(chan, (image-&gt;height &lt;&lt; 16) | image-&gt;width);
 	OUT_RING(chan, (image-&gt;dy &lt;&lt; 16) | (image-&gt;dx &amp; 0xffff));
 
<span class="p_del">-	dsize = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dsize = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dsize) {
 		int iter_len = dsize &gt; 128 ? 128 : dsize;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nv50_fbcon.c b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">index a4e259a00430..c8e096533f60 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nv50_fbcon.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> nv50_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING(chan, 0);
 	OUT_RING(chan, image-&gt;dy);
 
<span class="p_del">-	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dwords = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvc0_fbcon.c b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">index f28315e865a5..22d32578dafd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvc0_fbcon.c</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> nvc0_fbcon_imageblit(struct fb_info *info, const struct fb_image *image)</span>
 	OUT_RING  (chan, 0);
 	OUT_RING  (chan, image-&gt;dy);
 
<span class="p_del">-	dwords = ALIGN(image-&gt;width * image-&gt;height, 32) &gt;&gt; 5;</span>
<span class="p_add">+	dwords = ALIGN(ALIGN(image-&gt;width, 8) * image-&gt;height, 32) &gt;&gt; 5;</span>
 	while (dwords) {
 		int push = dwords &gt; 2047 ? 2047 : dwords;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c</span>
<span class="p_header">index 69de8c6259fe..f1e15a4d4f64 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv30.c</span>
<span class="p_chunk">@@ -76,8 +76,8 @@</span> <span class="p_context"> nv30_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,</span>
 		nvkm_wo32(chan-&gt;inst, i, 0x00040004);
 	for (i = 0x1f18; i &lt;= 0x3088 ; i += 16) {
 		nvkm_wo32(chan-&gt;inst, i + 0, 0x10700ff9);
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 1, 0x0436086c);</span>
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 2, 0x000c001b);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 4, 0x0436086c);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 8, 0x000c001b);</span>
 	}
 	for (i = 0x30b8; i &lt; 0x30c8; i += 4)
 		nvkm_wo32(chan-&gt;inst, i, 0x0000ffff);
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c</span>
<span class="p_header">index 2207dac23981..300f5ed5de0b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/gr/nv34.c</span>
<span class="p_chunk">@@ -75,8 +75,8 @@</span> <span class="p_context"> nv34_gr_chan_new(struct nvkm_gr *base, struct nvkm_fifo_chan *fifoch,</span>
 		nvkm_wo32(chan-&gt;inst, i, 0x00040004);
 	for (i = 0x15ac; i &lt;= 0x271c ; i += 16) {
 		nvkm_wo32(chan-&gt;inst, i + 0, 0x10700ff9);
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 1, 0x0436086c);</span>
<span class="p_del">-		nvkm_wo32(chan-&gt;inst, i + 2, 0x000c001b);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 4, 0x0436086c);</span>
<span class="p_add">+		nvkm_wo32(chan-&gt;inst, i + 8, 0x000c001b);</span>
 	}
 	for (i = 0x274c; i &lt; 0x275c; i += 4)
 		nvkm_wo32(chan-&gt;inst, i, 0x0000ffff);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">index 0b04b9282f56..d4ac8c837314 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_encoders.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> atombios_set_backlight_level(struct radeon_encoder *radeon_encoder, u8 level)</span>
 		case ENCODER_OBJECT_ID_INTERNAL_KLDSCP_LVTMA:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY1:
 		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY2:
<span class="p_add">+		case ENCODER_OBJECT_ID_INTERNAL_UNIPHY3:</span>
 			if (dig-&gt;backlight_level == 0)
 				atombios_dig_transmitter_setup(encoder, ATOM_TRANSMITTER_ACTION_LCD_BLOFF, 0, 0);
 			else {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atombios.c b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">index de9a2ffcf5f7..0c5b3eeff82d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atombios.c</span>
<span class="p_chunk">@@ -1155,7 +1155,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		    le16_to_cpu(firmware_info-&gt;info.usReferenceClock);
 		p1pll-&gt;reference_div = 0;
 
<span class="p_del">-		if (crev &lt; 2)</span>
<span class="p_add">+		if ((frev &lt; 2) &amp;&amp; (crev &lt; 2))</span>
 			p1pll-&gt;pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info.usMinPixelClockPLL_Output);
 		else
<span class="p_chunk">@@ -1164,7 +1164,7 @@</span> <span class="p_context"> bool radeon_atom_get_clock_info(struct drm_device *dev)</span>
 		p1pll-&gt;pll_out_max =
 		    le32_to_cpu(firmware_info-&gt;info.ulMaxPixelClockPLL_Output);
 
<span class="p_del">-		if (crev &gt;= 4) {</span>
<span class="p_add">+		if (((frev &lt; 2) &amp;&amp; (crev &gt;= 4)) || (frev &gt;= 2)) {</span>
 			p1pll-&gt;lcd_pll_out_min =
 				le16_to_cpu(firmware_info-&gt;info_14.usLcdMinPixelClockPLL_Output) * 100;
 			if (p1pll-&gt;lcd_pll_out_min == 0)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_atpx_handler.c b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">index c4b4f298a283..69ce95571136 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_atpx_handler.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/acpi.h&gt;
 #include &lt;linux/pci.h&gt;
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 
 #include &quot;radeon_acpi.h&quot;
 
<span class="p_chunk">@@ -255,6 +256,10 @@</span> <span class="p_context"> static int radeon_atpx_set_discrete_state(struct radeon_atpx *atpx, u8 state)</span>
 		if (!info)
 			return -EIO;
 		kfree(info);
<span class="p_add">+</span>
<span class="p_add">+		/* 200ms delay is required after off */</span>
<span class="p_add">+		if (state == 0)</span>
<span class="p_add">+			msleep(200);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 9cfc1c3e1965..30f00748ed37 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -2058,7 +2058,6 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 							   RADEON_OUTPUT_CSC_BYPASS);
 			/* no HPD on analog connectors */
 			radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 			connector-&gt;interlace_allowed = true;
 			connector-&gt;doublescan_allowed = true;
 			break;
<span class="p_chunk">@@ -2308,8 +2307,10 @@</span> <span class="p_context"> radeon_add_atom_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
 
<span class="p_chunk">@@ -2385,7 +2386,6 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 					      1);
 		/* no HPD on analog connectors */
 		radeon_connector-&gt;hpd.hpd = RADEON_HPD_NONE;
<span class="p_del">-		connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
 		connector-&gt;interlace_allowed = true;
 		connector-&gt;doublescan_allowed = true;
 		break;
<span class="p_chunk">@@ -2470,10 +2470,13 @@</span> <span class="p_context"> radeon_add_legacy_connector(struct drm_device *dev,</span>
 	}
 
 	if (radeon_connector-&gt;hpd.hpd == RADEON_HPD_NONE) {
<span class="p_del">-		if (i2c_bus-&gt;valid)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT;</span>
<span class="p_add">+		if (i2c_bus-&gt;valid) {</span>
<span class="p_add">+			connector-&gt;polled = DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+			                    DRM_CONNECTOR_POLL_DISCONNECT;</span>
<span class="p_add">+		}</span>
 	} else
 		connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;
<span class="p_add">+</span>
 	connector-&gt;display_info.subpixel_order = subpixel_order;
 	drm_connector_register(connector);
 }
<span class="p_header">diff --git a/drivers/hid/uhid.c b/drivers/hid/uhid.c</span>
<span class="p_header">index e094c572b86e..1a2032c2c1fb 100644</span>
<span class="p_header">--- a/drivers/hid/uhid.c</span>
<span class="p_header">+++ b/drivers/hid/uhid.c</span>
<span class="p_chunk">@@ -51,10 +51,26 @@</span> <span class="p_context"> struct uhid_device {</span>
 	u32 report_id;
 	u32 report_type;
 	struct uhid_event report_buf;
<span class="p_add">+	struct work_struct worker;</span>
 };
 
 static struct miscdevice uhid_misc;
 
<span class="p_add">+static void uhid_device_add_worker(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct uhid_device *uhid = container_of(work, struct uhid_device, worker);</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = hid_add_device(uhid-&gt;hid);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		hid_err(uhid-&gt;hid, &quot;Cannot register HID device: error %d\n&quot;, ret);</span>
<span class="p_add">+</span>
<span class="p_add">+		hid_destroy_device(uhid-&gt;hid);</span>
<span class="p_add">+		uhid-&gt;hid = NULL;</span>
<span class="p_add">+		uhid-&gt;running = false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void uhid_queue(struct uhid_device *uhid, struct uhid_event *ev)
 {
 	__u8 newhead;
<span class="p_chunk">@@ -498,18 +514,14 @@</span> <span class="p_context"> static int uhid_dev_create2(struct uhid_device *uhid,</span>
 	uhid-&gt;hid = hid;
 	uhid-&gt;running = true;
 
<span class="p_del">-	ret = hid_add_device(hid);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		hid_err(hid, &quot;Cannot register HID device\n&quot;);</span>
<span class="p_del">-		goto err_hid;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Adding of a HID device is done through a worker, to allow HID drivers</span>
<span class="p_add">+	 * which use feature requests during .probe to work, without they would</span>
<span class="p_add">+	 * be blocked on devlock, which is held by uhid_char_write.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	schedule_work(&amp;uhid-&gt;worker);</span>
 
 	return 0;
 
<span class="p_del">-err_hid:</span>
<span class="p_del">-	hid_destroy_device(hid);</span>
<span class="p_del">-	uhid-&gt;hid = NULL;</span>
<span class="p_del">-	uhid-&gt;running = false;</span>
 err_free:
 	kfree(uhid-&gt;rd_data);
 	uhid-&gt;rd_data = NULL;
<span class="p_chunk">@@ -550,6 +562,8 @@</span> <span class="p_context"> static int uhid_dev_destroy(struct uhid_device *uhid)</span>
 	uhid-&gt;running = false;
 	wake_up_interruptible(&amp;uhid-&gt;report_wait);
 
<span class="p_add">+	cancel_work_sync(&amp;uhid-&gt;worker);</span>
<span class="p_add">+</span>
 	hid_destroy_device(uhid-&gt;hid);
 	kfree(uhid-&gt;rd_data);
 
<span class="p_chunk">@@ -612,6 +626,7 @@</span> <span class="p_context"> static int uhid_char_open(struct inode *inode, struct file *file)</span>
 	init_waitqueue_head(&amp;uhid-&gt;waitq);
 	init_waitqueue_head(&amp;uhid-&gt;report_wait);
 	uhid-&gt;running = false;
<span class="p_add">+	INIT_WORK(&amp;uhid-&gt;worker, uhid_device_add_worker);</span>
 
 	file-&gt;private_data = uhid;
 	nonseekable_open(inode, file);
<span class="p_header">diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c</span>
<span class="p_header">index f19b6f7a467a..9b5440f6b3b4 100644</span>
<span class="p_header">--- a/drivers/hv/vmbus_drv.c</span>
<span class="p_header">+++ b/drivers/hv/vmbus_drv.c</span>
<span class="p_chunk">@@ -41,6 +41,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/ptrace.h&gt;
 #include &lt;linux/screen_info.h&gt;
 #include &lt;linux/kdebug.h&gt;
<span class="p_add">+#include &lt;linux/random.h&gt;</span>
 #include &quot;hyperv_vmbus.h&quot;
 
 static struct acpi_device  *hv_acpi_dev;
<span class="p_chunk">@@ -826,6 +827,8 @@</span> <span class="p_context"> static void vmbus_isr(void)</span>
 		else
 			tasklet_schedule(&amp;msg_dpc);
 	}
<span class="p_add">+</span>
<span class="p_add">+	add_interrupt_randomness(HYPERVISOR_CALLBACK_VECTOR, 0);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-efm32.c b/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_header">index 8eff62738877..e253598d764c 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-efm32.c</span>
<span class="p_chunk">@@ -433,7 +433,7 @@</span> <span class="p_context"> static int efm32_i2c_probe(struct platform_device *pdev)</span>
 	ret = request_irq(ddata-&gt;irq, efm32_i2c_irq, 0, DRIVER_NAME, ddata);
 	if (ret &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to request irq (%d)\n&quot;, ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_disable_clk;</span>
 	}
 
 	ret = i2c_add_adapter(&amp;ddata-&gt;adapter);
<span class="p_header">diff --git a/drivers/infiniband/core/iwpm_util.c b/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_header">index 5fb089e91353..fb43a242847b 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/iwpm_util.c</span>
<span class="p_chunk">@@ -634,6 +634,7 @@</span> <span class="p_context"> static int send_nlmsg_done(struct sk_buff *skb, u8 nl_client, int iwpm_pid)</span>
 	if (!(ibnl_put_msg(skb, &amp;nlh, 0, 0, nl_client,
 			   RDMA_NL_IWPM_MAPINFO, NLM_F_MULTI))) {
 		pr_warn(&quot;%s Unable to put NLMSG_DONE\n&quot;, __func__);
<span class="p_add">+		dev_kfree_skb(skb);</span>
 		return -ENOMEM;
 	}
 	nlh-&gt;nlmsg_type = NLMSG_DONE;
<span class="p_header">diff --git a/drivers/infiniband/core/sa_query.c b/drivers/infiniband/core/sa_query.c</span>
<span class="p_header">index a95a32ba596e..d3b7ecd106f7 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/sa_query.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/sa_query.c</span>
<span class="p_chunk">@@ -534,7 +534,7 @@</span> <span class="p_context"> static int ib_nl_send_msg(struct ib_sa_query *query, gfp_t gfp_mask)</span>
 	data = ibnl_put_msg(skb, &amp;nlh, query-&gt;seq, 0, RDMA_NL_LS,
 			    RDMA_NL_LS_OP_RESOLVE, NLM_F_REQUEST);
 	if (!data) {
<span class="p_del">-		kfree_skb(skb);</span>
<span class="p_add">+		nlmsg_free(skb);</span>
 		return -EMSGSIZE;
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/mad.c b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">index 870e56b6b25f..05179f47bbde 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/mad.c</span>
<span class="p_chunk">@@ -526,7 +526,7 @@</span> <span class="p_context"> int mlx4_ib_send_to_slave(struct mlx4_ib_dev *dev, int slave, u8 port,</span>
 		tun_tx_ix = (++tun_qp-&gt;tx_ix_head) &amp; (MLX4_NUM_TUNNEL_BUFS - 1);
 	spin_unlock(&amp;tun_qp-&gt;tx_lock);
 	if (ret)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto end;</span>
 
 	tun_mad = (struct mlx4_rcv_tunnel_mad *) (tun_qp-&gt;tx_ring[tun_tx_ix].buf.addr);
 	if (tun_qp-&gt;tx_ring[tun_tx_ix].ah)
<span class="p_chunk">@@ -595,9 +595,15 @@</span> <span class="p_context"> int mlx4_ib_send_to_slave(struct mlx4_ib_dev *dev, int slave, u8 port,</span>
 	wr.wr.send_flags = IB_SEND_SIGNALED;
 
 	ret = ib_post_send(src_qp, &amp;wr.wr, &amp;bad_wr);
<span class="p_del">-out:</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		ib_destroy_ah(ah);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+ out:</span>
<span class="p_add">+	spin_lock(&amp;tun_qp-&gt;tx_lock);</span>
<span class="p_add">+	tun_qp-&gt;tx_ix_tail++;</span>
<span class="p_add">+	spin_unlock(&amp;tun_qp-&gt;tx_lock);</span>
<span class="p_add">+	tun_qp-&gt;tx_ring[tun_tx_ix].ah = NULL;</span>
<span class="p_add">+end:</span>
<span class="p_add">+	ib_destroy_ah(ah);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1278,9 +1284,15 @@</span> <span class="p_context"> int mlx4_ib_send_to_wire(struct mlx4_ib_dev *dev, int slave, u8 port,</span>
 
 
 	ret = ib_post_send(send_qp, &amp;wr.wr, &amp;bad_wr);
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;sqp-&gt;tx_lock);</span>
<span class="p_add">+	sqp-&gt;tx_ix_tail++;</span>
<span class="p_add">+	spin_unlock(&amp;sqp-&gt;tx_lock);</span>
<span class="p_add">+	sqp-&gt;tx_ring[wire_tx_ix].ah = NULL;</span>
 out:
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		ib_destroy_ah(ah);</span>
<span class="p_add">+	ib_destroy_ah(ah);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 13eaaf45288f..ea1e2ddaddf5 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -357,7 +357,7 @@</span> <span class="p_context"> static int send_wqe_overhead(enum mlx4_ib_qp_type type, u32 flags)</span>
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_RC:
 		return sizeof (struct mlx4_wqe_ctrl_seg) +
<span class="p_del">-			sizeof (struct mlx4_wqe_atomic_seg) +</span>
<span class="p_add">+			sizeof (struct mlx4_wqe_masked_atomic_seg) +</span>
 			sizeof (struct mlx4_wqe_raddr_seg);
 	case MLX4_IB_QPT_SMI:
 	case MLX4_IB_QPT_GSI:
<span class="p_chunk">@@ -1162,8 +1162,10 @@</span> <span class="p_context"> struct ib_qp *mlx4_ib_create_qp(struct ib_pd *pd,</span>
 	{
 		err = create_qp_common(to_mdev(pd-&gt;device), pd, init_attr,
 				       udata, 0, &amp;qp, gfp);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			kfree(qp);</span>
 			return ERR_PTR(err);
<span class="p_add">+		}</span>
 
 		qp-&gt;ibqp.qp_num = qp-&gt;mqp.qpn;
 		qp-&gt;xrcdn = xrcdn;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/cq.c b/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_header">index 92ddae101ecc..8184267c7901 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_chunk">@@ -763,7 +763,8 @@</span> <span class="p_context"> struct ib_cq *mlx5_ib_create_cq(struct ib_device *ibdev,</span>
 	if (attr-&gt;flags)
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	if (entries &lt; 0)</span>
<span class="p_add">+	if (entries &lt; 0 ||</span>
<span class="p_add">+	    (entries &gt; (1 &lt;&lt; MLX5_CAP_GEN(dev-&gt;mdev, log_max_cq_sz))))</span>
 		return ERR_PTR(-EINVAL);
 
 	entries = roundup_pow_of_two(entries + 1);
<span class="p_chunk">@@ -1094,11 +1095,16 @@</span> <span class="p_context"> int mlx5_ib_resize_cq(struct ib_cq *ibcq, int entries, struct ib_udata *udata)</span>
 		return -ENOSYS;
 	}
 
<span class="p_del">-	if (entries &lt; 1)</span>
<span class="p_add">+	if (entries &lt; 1 ||</span>
<span class="p_add">+	    entries &gt; (1 &lt;&lt; MLX5_CAP_GEN(dev-&gt;mdev, log_max_cq_sz))) {</span>
<span class="p_add">+		mlx5_ib_warn(dev, &quot;wrong entries number %d, max %d\n&quot;,</span>
<span class="p_add">+			     entries,</span>
<span class="p_add">+			     1 &lt;&lt; MLX5_CAP_GEN(dev-&gt;mdev, log_max_cq_sz));</span>
 		return -EINVAL;
<span class="p_add">+	}</span>
 
 	entries = roundup_pow_of_two(entries + 1);
<span class="p_del">-	if (entries &gt;  (1 &lt;&lt; MLX5_CAP_GEN(dev-&gt;mdev, log_max_cq_sz)) + 1)</span>
<span class="p_add">+	if (entries &gt; (1 &lt;&lt; MLX5_CAP_GEN(dev-&gt;mdev, log_max_cq_sz)) + 1)</span>
 		return -EINVAL;
 
 	if (entries == ibcq-&gt;cqe + 1)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/main.c b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">index fd17443aeacd..bfc940ff9c8a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/main.c</span>
<span class="p_chunk">@@ -962,14 +962,11 @@</span> <span class="p_context"> static void mlx5_ib_event(struct mlx5_core_dev *dev, void *context,</span>
 		break;
 
 	case MLX5_DEV_EVENT_PORT_DOWN:
<span class="p_add">+	case MLX5_DEV_EVENT_PORT_INITIALIZED:</span>
 		ibev.event = IB_EVENT_PORT_ERR;
 		port = (u8)param;
 		break;
 
<span class="p_del">-	case MLX5_DEV_EVENT_PORT_INITIALIZED:</span>
<span class="p_del">-		/* not used by ULPs */</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	case MLX5_DEV_EVENT_LID_CHANGE:
 		ibev.event = IB_EVENT_LID_CHANGE;
 		port = (u8)param;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">index 307bdbca8938..cfcfbb6b84d7 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_chunk">@@ -226,6 +226,8 @@</span> <span class="p_context"> static int set_rq_size(struct mlx5_ib_dev *dev, struct ib_qp_cap *cap,</span>
 		qp-&gt;rq.max_gs = 0;
 		qp-&gt;rq.wqe_cnt = 0;
 		qp-&gt;rq.wqe_shift = 0;
<span class="p_add">+		cap-&gt;max_recv_wr = 0;</span>
<span class="p_add">+		cap-&gt;max_recv_sge = 0;</span>
 	} else {
 		if (ucmd) {
 			qp-&gt;rq.wqe_cnt = ucmd-&gt;rq_wqe_count;
<span class="p_chunk">@@ -2525,10 +2527,11 @@</span> <span class="p_context"> static u8 get_fence(u8 fence, struct ib_send_wr *wr)</span>
 			return MLX5_FENCE_MODE_SMALL_AND_FENCE;
 		else
 			return fence;
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	} else if (unlikely(wr-&gt;send_flags &amp; IB_SEND_FENCE)) {</span>
<span class="p_add">+		return MLX5_FENCE_MODE_FENCE;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int begin_wqe(struct mlx5_ib_qp *qp, void **seg,
<span class="p_chunk">@@ -3092,17 +3095,19 @@</span> <span class="p_context"> int mlx5_ib_query_qp(struct ib_qp *ibqp, struct ib_qp_attr *qp_attr, int qp_attr</span>
 	qp_attr-&gt;cap.max_recv_sge    = qp-&gt;rq.max_gs;
 
 	if (!ibqp-&gt;uobject) {
<span class="p_del">-		qp_attr-&gt;cap.max_send_wr  = qp-&gt;sq.wqe_cnt;</span>
<span class="p_add">+		qp_attr-&gt;cap.max_send_wr  = qp-&gt;sq.max_post;</span>
 		qp_attr-&gt;cap.max_send_sge = qp-&gt;sq.max_gs;
<span class="p_add">+		qp_init_attr-&gt;qp_context = ibqp-&gt;qp_context;</span>
 	} else {
 		qp_attr-&gt;cap.max_send_wr  = 0;
 		qp_attr-&gt;cap.max_send_sge = 0;
 	}
 
<span class="p_del">-	/* We don&#39;t support inline sends for kernel QPs (yet), and we</span>
<span class="p_del">-	 * don&#39;t know what userspace&#39;s value should be.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	qp_attr-&gt;cap.max_inline_data = 0;</span>
<span class="p_add">+	qp_init_attr-&gt;qp_type = ibqp-&gt;qp_type;</span>
<span class="p_add">+	qp_init_attr-&gt;recv_cq = ibqp-&gt;recv_cq;</span>
<span class="p_add">+	qp_init_attr-&gt;send_cq = ibqp-&gt;send_cq;</span>
<span class="p_add">+	qp_init_attr-&gt;srq = ibqp-&gt;srq;</span>
<span class="p_add">+	qp_attr-&gt;cap.max_inline_data = qp-&gt;max_inline_data;</span>
 
 	qp_init_attr-&gt;cap	     = qp_attr-&gt;cap;
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 7d3281866ffc..942dffca6a9d 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -1131,7 +1131,9 @@</span> <span class="p_context"> struct ipoib_neigh *ipoib_neigh_get(struct net_device *dev, u8 *daddr)</span>
 				neigh = NULL;
 				goto out_unlock;
 			}
<span class="p_del">-			neigh-&gt;alive = jiffies;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (likely(skb_queue_len(&amp;neigh-&gt;queue) &lt; IPOIB_MAX_PATH_REC_QUEUE))</span>
<span class="p_add">+				neigh-&gt;alive = jiffies;</span>
 			goto out_unlock;
 		}
 	}
<span class="p_header">diff --git a/drivers/input/mouse/elan_i2c_core.c b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">index 2f589857a039..d15b33813021 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elan_i2c_core.c</span>
<span class="p_chunk">@@ -4,7 +4,8 @@</span> <span class="p_context"></span>
  * Copyright (c) 2013 ELAN Microelectronics Corp.
  *
  * Author: 林政維 (Duson Lin) &lt;dusonlin@emc.com.tw&gt;
<span class="p_del">- * Version: 1.6.0</span>
<span class="p_add">+ * Author: KT Liao &lt;kt.liao@emc.com.tw&gt;</span>
<span class="p_add">+ * Version: 1.6.2</span>
  *
  * Based on cyapa driver:
  * copyright (c) 2011-2012 Cypress Semiconductor, Inc.
<span class="p_chunk">@@ -40,7 +41,7 @@</span> <span class="p_context"></span>
 #include &quot;elan_i2c.h&quot;
 
 #define DRIVER_NAME		&quot;elan_i2c&quot;
<span class="p_del">-#define ELAN_DRIVER_VERSION	&quot;1.6.1&quot;</span>
<span class="p_add">+#define ELAN_DRIVER_VERSION	&quot;1.6.2&quot;</span>
 #define ELAN_VENDOR_ID		0x04f3
 #define ETP_MAX_PRESSURE	255
 #define ETP_FWIDTH_REDUCE	90
<span class="p_chunk">@@ -199,9 +200,41 @@</span> <span class="p_context"> static int elan_sleep(struct elan_tp_data *data)</span>
 	return error;
 }
 
<span class="p_add">+static int elan_query_product(struct elan_tp_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = data-&gt;ops-&gt;get_product_id(data-&gt;client, &amp;data-&gt;product_id);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+</span>
<span class="p_add">+	error = data-&gt;ops-&gt;get_sm_version(data-&gt;client, &amp;data-&gt;ic_type,</span>
<span class="p_add">+					  &amp;data-&gt;sm_version);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int elan_check_ASUS_special_fw(struct elan_tp_data *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (data-&gt;ic_type != 0x0E)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (data-&gt;product_id) {</span>
<span class="p_add">+	case 0x05 ... 0x07:</span>
<span class="p_add">+	case 0x09:</span>
<span class="p_add">+	case 0x13:</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __elan_initialize(struct elan_tp_data *data)
 {
 	struct i2c_client *client = data-&gt;client;
<span class="p_add">+	bool woken_up = false;</span>
 	int error;
 
 	error = data-&gt;ops-&gt;initialize(client);
<span class="p_chunk">@@ -210,6 +243,27 @@</span> <span class="p_context"> static int __elan_initialize(struct elan_tp_data *data)</span>
 		return error;
 	}
 
<span class="p_add">+	error = elan_query_product(data);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some ASUS devices were shipped with firmware that requires</span>
<span class="p_add">+	 * touchpads to be woken up first, before attempting to switch</span>
<span class="p_add">+	 * them into absolute reporting mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (elan_check_ASUS_special_fw(data)) {</span>
<span class="p_add">+		error = data-&gt;ops-&gt;sleep_control(client, false);</span>
<span class="p_add">+		if (error) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev,</span>
<span class="p_add">+				&quot;failed to wake device up: %d\n&quot;, error);</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		msleep(200);</span>
<span class="p_add">+		woken_up = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	data-&gt;mode |= ETP_ENABLE_ABS;
 	error = data-&gt;ops-&gt;set_mode(client, data-&gt;mode);
 	if (error) {
<span class="p_chunk">@@ -218,11 +272,13 @@</span> <span class="p_context"> static int __elan_initialize(struct elan_tp_data *data)</span>
 		return error;
 	}
 
<span class="p_del">-	error = data-&gt;ops-&gt;sleep_control(client, false);</span>
<span class="p_del">-	if (error) {</span>
<span class="p_del">-		dev_err(&amp;client-&gt;dev,</span>
<span class="p_del">-			&quot;failed to wake device up: %d\n&quot;, error);</span>
<span class="p_del">-		return error;</span>
<span class="p_add">+	if (!woken_up) {</span>
<span class="p_add">+		error = data-&gt;ops-&gt;sleep_control(client, false);</span>
<span class="p_add">+		if (error) {</span>
<span class="p_add">+			dev_err(&amp;client-&gt;dev,</span>
<span class="p_add">+				&quot;failed to wake device up: %d\n&quot;, error);</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -248,10 +304,6 @@</span> <span class="p_context"> static int elan_query_device_info(struct elan_tp_data *data)</span>
 {
 	int error;
 
<span class="p_del">-	error = data-&gt;ops-&gt;get_product_id(data-&gt;client, &amp;data-&gt;product_id);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	error = data-&gt;ops-&gt;get_version(data-&gt;client, false, &amp;data-&gt;fw_version);
 	if (error)
 		return error;
<span class="p_chunk">@@ -261,11 +313,6 @@</span> <span class="p_context"> static int elan_query_device_info(struct elan_tp_data *data)</span>
 	if (error)
 		return error;
 
<span class="p_del">-	error = data-&gt;ops-&gt;get_sm_version(data-&gt;client, &amp;data-&gt;ic_type,</span>
<span class="p_del">-					  &amp;data-&gt;sm_version);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	error = data-&gt;ops-&gt;get_version(data-&gt;client, true, &amp;data-&gt;iap_version);
 	if (error)
 		return error;
<span class="p_header">diff --git a/drivers/input/touchscreen/sur40.c b/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">index d214f22ed305..45b466e3bbe8 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/sur40.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/sur40.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> struct sur40_image_header {</span>
 #define VIDEO_PACKET_SIZE  16384
 
 /* polling interval (ms) */
<span class="p_del">-#define POLL_INTERVAL 4</span>
<span class="p_add">+#define POLL_INTERVAL 1</span>
 
 /* maximum number of contacts FIXME: this is a guess? */
 #define MAX_CONTACTS 64
<span class="p_chunk">@@ -441,7 +441,7 @@</span> <span class="p_context"> static void sur40_process_video(struct sur40_state *sur40)</span>
 
 	/* return error if streaming was stopped in the meantime */
 	if (sur40-&gt;sequence == -1)
<span class="p_del">-		goto err_poll;</span>
<span class="p_add">+		return;</span>
 
 	/* mark as finished */
 	v4l2_get_timestamp(&amp;new_buf-&gt;vb.timestamp);
<span class="p_chunk">@@ -730,6 +730,7 @@</span> <span class="p_context"> static int sur40_start_streaming(struct vb2_queue *vq, unsigned int count)</span>
 static void sur40_stop_streaming(struct vb2_queue *vq)
 {
 	struct sur40_state *sur40 = vb2_get_drv_priv(vq);
<span class="p_add">+	vb2_wait_for_all_buffers(vq);</span>
 	sur40-&gt;sequence = -1;
 
 	/* Release all active buffers */
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index b9319b76a8a1..0397985a2601 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -352,9 +352,11 @@</span> <span class="p_context"> static void init_iommu_group(struct device *dev)</span>
 	if (!domain)
 		goto out;
 
<span class="p_del">-	dma_domain = to_pdomain(domain)-&gt;priv;</span>
<span class="p_add">+	if (to_pdomain(domain)-&gt;flags == PD_DMA_OPS_MASK) {</span>
<span class="p_add">+		dma_domain = to_pdomain(domain)-&gt;priv;</span>
<span class="p_add">+		init_unity_mappings_for_device(dev, dma_domain);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	init_unity_mappings_for_device(dev, dma_domain);</span>
 out:
 	iommu_group_put(group);
 }
<span class="p_chunk">@@ -2322,8 +2324,15 @@</span> <span class="p_context"> static void update_device_table(struct protection_domain *domain)</span>
 {
 	struct iommu_dev_data *dev_data;
 
<span class="p_del">-	list_for_each_entry(dev_data, &amp;domain-&gt;dev_list, list)</span>
<span class="p_add">+	list_for_each_entry(dev_data, &amp;domain-&gt;dev_list, list) {</span>
 		set_dte_entry(dev_data-&gt;devid, domain, dev_data-&gt;ats.enabled);
<span class="p_add">+</span>
<span class="p_add">+		if (dev_data-&gt;devid == dev_data-&gt;alias)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* There is an alias, update device table entry for it */</span>
<span class="p_add">+		set_dte_entry(dev_data-&gt;alias, domain, dev_data-&gt;ats.enabled);</span>
<span class="p_add">+	}</span>
 }
 
 static void update_domain(struct protection_domain *domain)
<span class="p_chunk">@@ -2970,9 +2979,7 @@</span> <span class="p_context"> static struct iommu_domain *amd_iommu_domain_alloc(unsigned type)</span>
 static void amd_iommu_domain_free(struct iommu_domain *dom)
 {
 	struct protection_domain *domain;
<span class="p_del">-</span>
<span class="p_del">-	if (!dom)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	struct dma_ops_domain *dma_dom;</span>
 
 	domain = to_pdomain(dom);
 
<span class="p_chunk">@@ -2981,13 +2988,24 @@</span> <span class="p_context"> static void amd_iommu_domain_free(struct iommu_domain *dom)</span>
 
 	BUG_ON(domain-&gt;dev_cnt != 0);
 
<span class="p_del">-	if (domain-&gt;mode != PAGE_MODE_NONE)</span>
<span class="p_del">-		free_pagetable(domain);</span>
<span class="p_add">+	if (!dom)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (dom-&gt;type) {</span>
<span class="p_add">+	case IOMMU_DOMAIN_DMA:</span>
<span class="p_add">+		dma_dom = domain-&gt;priv;</span>
<span class="p_add">+		dma_ops_domain_free(dma_dom);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		if (domain-&gt;mode != PAGE_MODE_NONE)</span>
<span class="p_add">+			free_pagetable(domain);</span>
 
<span class="p_del">-	if (domain-&gt;flags &amp; PD_IOMMUV2_MASK)</span>
<span class="p_del">-		free_gcr3_table(domain);</span>
<span class="p_add">+		if (domain-&gt;flags &amp; PD_IOMMUV2_MASK)</span>
<span class="p_add">+			free_gcr3_table(domain);</span>
 
<span class="p_del">-	protection_domain_free(domain);</span>
<span class="p_add">+		protection_domain_free(domain);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 static void amd_iommu_detach_device(struct iommu_domain *dom,
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index 97c41b8ab5d9..29a31eb9ace3 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -647,6 +647,7 @@</span> <span class="p_context"> static struct platform_driver exynos_sysmmu_driver __refdata = {</span>
 		.name		= &quot;exynos-sysmmu&quot;,
 		.of_match_table	= sysmmu_of_match,
 		.pm		= &amp;sysmmu_pm_ops,
<span class="p_add">+		.suppress_bind_attrs = true,</span>
 	}
 };
 
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 6763a4dfed94..24d81308a1a6 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -2032,7 +2032,7 @@</span> <span class="p_context"> out_unlock:</span>
 	spin_unlock(&amp;iommu-&gt;lock);
 	spin_unlock_irqrestore(&amp;device_domain_lock, flags);
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 struct domain_context_mapping_data {
<span class="p_header">diff --git a/drivers/md/dm-flakey.c b/drivers/md/dm-flakey.c</span>
<span class="p_header">index 09e2afcafd2d..cd0a93df4cb7 100644</span>
<span class="p_header">--- a/drivers/md/dm-flakey.c</span>
<span class="p_header">+++ b/drivers/md/dm-flakey.c</span>
<span class="p_chunk">@@ -289,10 +289,16 @@</span> <span class="p_context"> static int flakey_map(struct dm_target *ti, struct bio *bio)</span>
 		pb-&gt;bio_submitted = true;
 
 		/*
<span class="p_del">-		 * Map reads as normal.</span>
<span class="p_add">+		 * Map reads as normal only if corrupt_bio_byte set.</span>
 		 */
<span class="p_del">-		if (bio_data_dir(bio) == READ)</span>
<span class="p_del">-			goto map_bio;</span>
<span class="p_add">+		if (bio_data_dir(bio) == READ) {</span>
<span class="p_add">+			/* If flags were specified, only corrupt those that match. */</span>
<span class="p_add">+			if (fc-&gt;corrupt_bio_byte &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_add">+			    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_add">+				goto map_bio;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				return -EIO;</span>
<span class="p_add">+		}</span>
 
 		/*
 		 * Drop writes?
<span class="p_chunk">@@ -330,12 +336,13 @@</span> <span class="p_context"> static int flakey_end_io(struct dm_target *ti, struct bio *bio, int error)</span>
 
 	/*
 	 * Corrupt successful READs while in down state.
<span class="p_del">-	 * If flags were specified, only corrupt those that match.</span>
 	 */
<span class="p_del">-	if (fc-&gt;corrupt_bio_byte &amp;&amp; !error &amp;&amp; pb-&gt;bio_submitted &amp;&amp;</span>
<span class="p_del">-	    (bio_data_dir(bio) == READ) &amp;&amp; (fc-&gt;corrupt_bio_rw == READ) &amp;&amp;</span>
<span class="p_del">-	    all_corrupt_bio_flags_match(bio, fc))</span>
<span class="p_del">-		corrupt_bio_data(bio, fc);</span>
<span class="p_add">+	if (!error &amp;&amp; pb-&gt;bio_submitted &amp;&amp; (bio_data_dir(bio) == READ)) {</span>
<span class="p_add">+		if (fc-&gt;corrupt_bio_byte)</span>
<span class="p_add">+			corrupt_bio_data(bio, fc);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+	}</span>
 
 	return error;
 }
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index c338aebb4ccd..a42729ebf272 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -3078,7 +3078,8 @@</span> <span class="p_context"> static void unlock_fs(struct mapped_device *md)</span>
  * Caller must hold md-&gt;suspend_lock
  */
 static int __dm_suspend(struct mapped_device *md, struct dm_table *map,
<span class="p_del">-			unsigned suspend_flags, int interruptible)</span>
<span class="p_add">+			unsigned suspend_flags, int interruptible,</span>
<span class="p_add">+			int dmf_suspended_flag)</span>
 {
 	bool do_lockfs = suspend_flags &amp; DM_SUSPEND_LOCKFS_FLAG;
 	bool noflush = suspend_flags &amp; DM_SUSPEND_NOFLUSH_FLAG;
<span class="p_chunk">@@ -3145,6 +3146,8 @@</span> <span class="p_context"> static int __dm_suspend(struct mapped_device *md, struct dm_table *map,</span>
 	 * to finish.
 	 */
 	r = dm_wait_for_completion(md, interruptible);
<span class="p_add">+	if (!r)</span>
<span class="p_add">+		set_bit(dmf_suspended_flag, &amp;md-&gt;flags);</span>
 
 	if (noflush)
 		clear_bit(DMF_NOFLUSH_SUSPENDING, &amp;md-&gt;flags);
<span class="p_chunk">@@ -3206,12 +3209,10 @@</span> <span class="p_context"> retry:</span>
 
 	map = rcu_dereference_protected(md-&gt;map, lockdep_is_held(&amp;md-&gt;suspend_lock));
 
<span class="p_del">-	r = __dm_suspend(md, map, suspend_flags, TASK_INTERRUPTIBLE);</span>
<span class="p_add">+	r = __dm_suspend(md, map, suspend_flags, TASK_INTERRUPTIBLE, DMF_SUSPENDED);</span>
 	if (r)
 		goto out_unlock;
 
<span class="p_del">-	set_bit(DMF_SUSPENDED, &amp;md-&gt;flags);</span>
<span class="p_del">-</span>
 	dm_table_postsuspend_targets(map);
 
 out_unlock:
<span class="p_chunk">@@ -3305,9 +3306,8 @@</span> <span class="p_context"> static void __dm_internal_suspend(struct mapped_device *md, unsigned suspend_fla</span>
 	 * would require changing .presuspend to return an error -- avoid this
 	 * until there is a need for more elaborate variants of internal suspend.
 	 */
<span class="p_del">-	(void) __dm_suspend(md, map, suspend_flags, TASK_UNINTERRUPTIBLE);</span>
<span class="p_del">-</span>
<span class="p_del">-	set_bit(DMF_SUSPENDED_INTERNALLY, &amp;md-&gt;flags);</span>
<span class="p_add">+	(void) __dm_suspend(md, map, suspend_flags, TASK_UNINTERRUPTIBLE,</span>
<span class="p_add">+			    DMF_SUSPENDED_INTERNALLY);</span>
 
 	dm_table_postsuspend_targets(map);
 }
<span class="p_header">diff --git a/drivers/media/dvb-core/dvb_ringbuffer.c b/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_header">index 1100e98a7b1d..7df7fb3738a0 100644</span>
<span class="p_header">--- a/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_header">+++ b/drivers/media/dvb-core/dvb_ringbuffer.c</span>
<span class="p_chunk">@@ -55,7 +55,13 @@</span> <span class="p_context"> void dvb_ringbuffer_init(struct dvb_ringbuffer *rbuf, void *data, size_t len)</span>
 
 int dvb_ringbuffer_empty(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	return (rbuf-&gt;pread==rbuf-&gt;pwrite);</span>
<span class="p_add">+	/* smp_load_acquire() to load write pointer on reader side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),</span>
<span class="p_add">+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * for memory barriers also see Documentation/circular-buffers.txt</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	return (rbuf-&gt;pread == smp_load_acquire(&amp;rbuf-&gt;pwrite));</span>
 }
 
 
<span class="p_chunk">@@ -64,7 +70,12 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_free(struct dvb_ringbuffer *rbuf)</span>
 {
 	ssize_t free;
 
<span class="p_del">-	free = rbuf-&gt;pread - rbuf-&gt;pwrite;</span>
<span class="p_add">+	/* ACCESS_ONCE() to load read pointer on writer side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_read(),</span>
<span class="p_add">+	 * dvb_ringbuffer_read_user(), dvb_ringbuffer_flush(),</span>
<span class="p_add">+	 * or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	free = ACCESS_ONCE(rbuf-&gt;pread) - rbuf-&gt;pwrite;</span>
 	if (free &lt;= 0)
 		free += rbuf-&gt;size;
 	return free-1;
<span class="p_chunk">@@ -76,7 +87,11 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)</span>
 {
 	ssize_t avail;
 
<span class="p_del">-	avail = rbuf-&gt;pwrite - rbuf-&gt;pread;</span>
<span class="p_add">+	/* smp_load_acquire() to load write pointer on reader side</span>
<span class="p_add">+	 * this pairs with smp_store_release() in dvb_ringbuffer_write(),</span>
<span class="p_add">+	 * dvb_ringbuffer_write_user(), or dvb_ringbuffer_reset()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	avail = smp_load_acquire(&amp;rbuf-&gt;pwrite) - rbuf-&gt;pread;</span>
 	if (avail &lt; 0)
 		avail += rbuf-&gt;size;
 	return avail;
<span class="p_chunk">@@ -86,14 +101,25 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_avail(struct dvb_ringbuffer *rbuf)</span>
 
 void dvb_ringbuffer_flush(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	rbuf-&gt;pread = rbuf-&gt;pwrite;</span>
<span class="p_add">+	/* dvb_ringbuffer_flush() counts as read operation</span>
<span class="p_add">+	 * smp_load_acquire() to load write pointer</span>
<span class="p_add">+	 * smp_store_release() to update read pointer, this ensures that the</span>
<span class="p_add">+	 * correct pointer is visible for subsequent dvb_ringbuffer_free()</span>
<span class="p_add">+	 * calls on other cpu cores</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, smp_load_acquire(&amp;rbuf-&gt;pwrite));</span>
 	rbuf-&gt;error = 0;
 }
 EXPORT_SYMBOL(dvb_ringbuffer_flush);
 
 void dvb_ringbuffer_reset(struct dvb_ringbuffer *rbuf)
 {
<span class="p_del">-	rbuf-&gt;pread = rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+	/* dvb_ringbuffer_reset() counts as read and write operation</span>
<span class="p_add">+	 * smp_store_release() to update read pointer</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
<span class="p_add">+	/* smp_store_release() to update write pointer */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	rbuf-&gt;error = 0;
 }
 
<span class="p_chunk">@@ -119,12 +145,17 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_read_user(struct dvb_ringbuffer *rbuf, u8 __user *buf, si</span>
 			return -EFAULT;
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pread = 0;</span>
<span class="p_add">+		/* smp_store_release() for read pointer update to ensure</span>
<span class="p_add">+		 * that buf is not overwritten until read is complete,</span>
<span class="p_add">+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
 	}
 	if (copy_to_user(buf, rbuf-&gt;data+rbuf-&gt;pread, todo))
 		return -EFAULT;
 
<span class="p_del">-	rbuf-&gt;pread = (rbuf-&gt;pread + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() to update read pointer, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, (rbuf-&gt;pread + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_chunk">@@ -139,11 +170,16 @@</span> <span class="p_context"> void dvb_ringbuffer_read(struct dvb_ringbuffer *rbuf, u8 *buf, size_t len)</span>
 		memcpy(buf, rbuf-&gt;data+rbuf-&gt;pread, split);
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pread = 0;</span>
<span class="p_add">+		/* smp_store_release() for read pointer update to ensure</span>
<span class="p_add">+		 * that buf is not overwritten until read is complete,</span>
<span class="p_add">+		 * this pairs with ACCESS_ONCE() in dvb_ringbuffer_free()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pread, 0);</span>
 	}
 	memcpy(buf, rbuf-&gt;data+rbuf-&gt;pread, todo);
 
<span class="p_del">-	rbuf-&gt;pread = (rbuf-&gt;pread + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() to update read pointer, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pread, (rbuf-&gt;pread + todo) % rbuf-&gt;size);</span>
 }
 
 
<span class="p_chunk">@@ -158,10 +194,16 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_write(struct dvb_ringbuffer *rbuf, const u8 *buf, size_t</span>
 		memcpy(rbuf-&gt;data+rbuf-&gt;pwrite, buf, split);
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+		/* smp_store_release() for write pointer update to ensure that</span>
<span class="p_add">+		 * written data is visible on other cpu cores before the pointer</span>
<span class="p_add">+		 * update, this pairs with smp_load_acquire() in</span>
<span class="p_add">+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	}
 	memcpy(rbuf-&gt;data+rbuf-&gt;pwrite, buf, todo);
<span class="p_del">-	rbuf-&gt;pwrite = (rbuf-&gt;pwrite + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() for write pointer update, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, (rbuf-&gt;pwrite + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_chunk">@@ -181,12 +223,18 @@</span> <span class="p_context"> ssize_t dvb_ringbuffer_write_user(struct dvb_ringbuffer *rbuf,</span>
 			return len - todo;
 		buf += split;
 		todo -= split;
<span class="p_del">-		rbuf-&gt;pwrite = 0;</span>
<span class="p_add">+		/* smp_store_release() for write pointer update to ensure that</span>
<span class="p_add">+		 * written data is visible on other cpu cores before the pointer</span>
<span class="p_add">+		 * update, this pairs with smp_load_acquire() in</span>
<span class="p_add">+		 * dvb_ringbuffer_empty() or dvb_ringbuffer_avail()</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_store_release(&amp;rbuf-&gt;pwrite, 0);</span>
 	}
 	status = copy_from_user(rbuf-&gt;data+rbuf-&gt;pwrite, buf, todo);
 	if (status)
 		return len - todo;
<span class="p_del">-	rbuf-&gt;pwrite = (rbuf-&gt;pwrite + todo) % rbuf-&gt;size;</span>
<span class="p_add">+	/* smp_store_release() for write pointer update, see above */</span>
<span class="p_add">+	smp_store_release(&amp;rbuf-&gt;pwrite, (rbuf-&gt;pwrite + todo) % rbuf-&gt;size);</span>
 
 	return len;
 }
<span class="p_header">diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">index 3ffe2ecfd5ef..c8946f98ced4 100644</span>
<span class="p_header">--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_chunk">@@ -1029,6 +1029,11 @@</span> <span class="p_context"> static int match_child(struct device *dev, void *data)</span>
 	return !strcmp(dev_name(dev), (char *)data);
 }
 
<span class="p_add">+static void s5p_mfc_memdev_release(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dma_release_declared_memory(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void *mfc_get_drv_data(struct platform_device *pdev);
 
 static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)
<span class="p_chunk">@@ -1041,6 +1046,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_l, &quot;%s&quot;, &quot;s5p-mfc-l&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_l-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_l);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-l&quot;, mem_info, 2);
<span class="p_chunk">@@ -1058,6 +1066,9 @@</span> <span class="p_context"> static int s5p_mfc_alloc_memdevs(struct s5p_mfc_dev *dev)</span>
 		mfc_err(&quot;Not enough memory\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+</span>
<span class="p_add">+	dev_set_name(dev-&gt;mem_dev_r, &quot;%s&quot;, &quot;s5p-mfc-r&quot;);</span>
<span class="p_add">+	dev-&gt;mem_dev_r-&gt;release = s5p_mfc_memdev_release;</span>
 	device_initialize(dev-&gt;mem_dev_r);
 	of_property_read_u32_array(dev-&gt;plat_dev-&gt;dev.of_node,
 			&quot;samsung,mfc-r&quot;, mem_info, 2);
<span class="p_header">diff --git a/drivers/media/rc/ir-rc5-decoder.c b/drivers/media/rc/ir-rc5-decoder.c</span>
<span class="p_header">index 84fa6e9b59a1..67314c034cdb 100644</span>
<span class="p_header">--- a/drivers/media/rc/ir-rc5-decoder.c</span>
<span class="p_header">+++ b/drivers/media/rc/ir-rc5-decoder.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"></span>
 #define RC5_BIT_START		(1 * RC5_UNIT)
 #define RC5_BIT_END		(1 * RC5_UNIT)
 #define RC5X_SPACE		(4 * RC5_UNIT)
<span class="p_del">-#define RC5_TRAILER		(10 * RC5_UNIT) /* In reality, approx 100 */</span>
<span class="p_add">+#define RC5_TRAILER		(6 * RC5_UNIT) /* In reality, approx 100 */</span>
 
 enum rc5_state {
 	STATE_INACTIVE,
<span class="p_header">diff --git a/drivers/media/usb/usbtv/usbtv-audio.c b/drivers/media/usb/usbtv/usbtv-audio.c</span>
<span class="p_header">index 78c12d22dfbb..5dab02432e82 100644</span>
<span class="p_header">--- a/drivers/media/usb/usbtv/usbtv-audio.c</span>
<span class="p_header">+++ b/drivers/media/usb/usbtv/usbtv-audio.c</span>
<span class="p_chunk">@@ -278,6 +278,9 @@</span> <span class="p_context"> static void snd_usbtv_trigger(struct work_struct *work)</span>
 {
 	struct usbtv *chip = container_of(work, struct usbtv, snd_trigger);
 
<span class="p_add">+	if (!chip-&gt;snd)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (atomic_read(&amp;chip-&gt;snd_stream))
 		usbtv_audio_start(chip);
 	else
<span class="p_chunk">@@ -378,6 +381,8 @@</span> <span class="p_context"> err:</span>
 
 void usbtv_audio_free(struct usbtv *usbtv)
 {
<span class="p_add">+	cancel_work_sync(&amp;usbtv-&gt;snd_trigger);</span>
<span class="p_add">+</span>
 	if (usbtv-&gt;snd &amp;&amp; usbtv-&gt;udev) {
 		snd_card_free(usbtv-&gt;snd);
 		usbtv-&gt;snd = NULL;
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 11f39791ec33..47f37683893a 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -1505,7 +1505,7 @@</span> <span class="p_context"> static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,</span>
 			     void *pb, int nonblocking)
 {
 	unsigned long flags;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	/*
 	 * Wait for at least one buffer to become available on the done_list.
<span class="p_chunk">@@ -1521,10 +1521,12 @@</span> <span class="p_context"> static int __vb2_get_done_vb(struct vb2_queue *q, struct vb2_buffer **vb,</span>
 	spin_lock_irqsave(&amp;q-&gt;done_lock, flags);
 	*vb = list_first_entry(&amp;q-&gt;done_list, struct vb2_buffer, done_entry);
 	/*
<span class="p_del">-	 * Only remove the buffer from done_list if v4l2_buffer can handle all</span>
<span class="p_del">-	 * the planes.</span>
<span class="p_add">+	 * Only remove the buffer from done_list if all planes can be</span>
<span class="p_add">+	 * handled. Some cases such as V4L2 file I/O and DVB have pb</span>
<span class="p_add">+	 * == NULL; skip the check then as there&#39;s nothing to verify.</span>
 	 */
<span class="p_del">-	ret = call_bufop(q, verify_planes_array, *vb, pb);</span>
<span class="p_add">+	if (pb)</span>
<span class="p_add">+		ret = call_bufop(q, verify_planes_array, *vb, pb);</span>
 	if (!ret)
 		list_del(&amp;(*vb)-&gt;done_entry);
 	spin_unlock_irqrestore(&amp;q-&gt;done_lock, flags);
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-v4l2.c b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">index 502984c724ff..6c441be8f893 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-v4l2.c</span>
<span class="p_chunk">@@ -67,6 +67,11 @@</span> <span class="p_context"> static int __verify_planes_array(struct vb2_buffer *vb, const struct v4l2_buffer</span>
 	return 0;
 }
 
<span class="p_add">+static int __verify_planes_array_core(struct vb2_buffer *vb, const void *pb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __verify_planes_array(vb, pb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * __verify_length() - Verify that the bytesused value for each plane fits in
  * the plane length and that the data offset doesn&#39;t exceed the bytesused value.
<span class="p_chunk">@@ -432,6 +437,7 @@</span> <span class="p_context"> static int __fill_vb2_buffer(struct vb2_buffer *vb,</span>
 }
 
 static const struct vb2_buf_ops v4l2_buf_ops = {
<span class="p_add">+	.verify_planes_array	= __verify_planes_array_core,</span>
 	.fill_user_buffer	= __fill_v4l2_buffer,
 	.fill_vb2_buffer	= __fill_vb2_buffer,
 	.set_timestamp		= __set_timestamp,
<span class="p_header">diff --git a/drivers/mfd/qcom_rpm.c b/drivers/mfd/qcom_rpm.c</span>
<span class="p_header">index 207a3bd68559..a867cc91657e 100644</span>
<span class="p_header">--- a/drivers/mfd/qcom_rpm.c</span>
<span class="p_header">+++ b/drivers/mfd/qcom_rpm.c</span>
<span class="p_chunk">@@ -34,7 +34,13 @@</span> <span class="p_context"> struct qcom_rpm_resource {</span>
 struct qcom_rpm_data {
 	u32 version;
 	const struct qcom_rpm_resource *resource_table;
<span class="p_del">-	unsigned n_resources;</span>
<span class="p_add">+	unsigned int n_resources;</span>
<span class="p_add">+	unsigned int req_ctx_off;</span>
<span class="p_add">+	unsigned int req_sel_off;</span>
<span class="p_add">+	unsigned int ack_ctx_off;</span>
<span class="p_add">+	unsigned int ack_sel_off;</span>
<span class="p_add">+	unsigned int req_sel_size;</span>
<span class="p_add">+	unsigned int ack_sel_size;</span>
 };
 
 struct qcom_rpm {
<span class="p_chunk">@@ -61,11 +67,7 @@</span> <span class="p_context"> struct qcom_rpm {</span>
 
 #define RPM_REQUEST_TIMEOUT	(5 * HZ)
 
<span class="p_del">-#define RPM_REQUEST_CONTEXT	3</span>
<span class="p_del">-#define RPM_REQ_SELECT		11</span>
<span class="p_del">-#define RPM_ACK_CONTEXT		15</span>
<span class="p_del">-#define RPM_ACK_SELECTOR	23</span>
<span class="p_del">-#define RPM_SELECT_SIZE		7</span>
<span class="p_add">+#define RPM_MAX_SEL_SIZE	7</span>
 
 #define RPM_NOTIFICATION	BIT(30)
 #define RPM_REJECTED		BIT(31)
<span class="p_chunk">@@ -157,6 +159,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data apq8064_template = {</span>
 	.version = 3,
 	.resource_table = apq8064_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(apq8064_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 15,</span>
<span class="p_add">+	.ack_sel_off = 23,</span>
<span class="p_add">+	.req_sel_size = 4,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct qcom_rpm_resource msm8660_rpm_resource_table[] = {
<span class="p_chunk">@@ -240,6 +248,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data msm8660_template = {</span>
 	.version = 2,
 	.resource_table = msm8660_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(msm8660_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 19,</span>
<span class="p_add">+	.ack_sel_off = 27,</span>
<span class="p_add">+	.req_sel_size = 7,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct qcom_rpm_resource msm8960_rpm_resource_table[] = {
<span class="p_chunk">@@ -322,6 +336,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data msm8960_template = {</span>
 	.version = 3,
 	.resource_table = msm8960_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(msm8960_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 15,</span>
<span class="p_add">+	.ack_sel_off = 23,</span>
<span class="p_add">+	.req_sel_size = 4,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct qcom_rpm_resource ipq806x_rpm_resource_table[] = {
<span class="p_chunk">@@ -362,6 +382,12 @@</span> <span class="p_context"> static const struct qcom_rpm_data ipq806x_template = {</span>
 	.version = 3,
 	.resource_table = ipq806x_rpm_resource_table,
 	.n_resources = ARRAY_SIZE(ipq806x_rpm_resource_table),
<span class="p_add">+	.req_ctx_off = 3,</span>
<span class="p_add">+	.req_sel_off = 11,</span>
<span class="p_add">+	.ack_ctx_off = 15,</span>
<span class="p_add">+	.ack_sel_off = 23,</span>
<span class="p_add">+	.req_sel_size = 4,</span>
<span class="p_add">+	.ack_sel_size = 7,</span>
 };
 
 static const struct of_device_id qcom_rpm_of_match[] = {
<span class="p_chunk">@@ -380,7 +406,7 @@</span> <span class="p_context"> int qcom_rpm_write(struct qcom_rpm *rpm,</span>
 {
 	const struct qcom_rpm_resource *res;
 	const struct qcom_rpm_data *data = rpm-&gt;data;
<span class="p_del">-	u32 sel_mask[RPM_SELECT_SIZE] = { 0 };</span>
<span class="p_add">+	u32 sel_mask[RPM_MAX_SEL_SIZE] = { 0 };</span>
 	int left;
 	int ret = 0;
 	int i;
<span class="p_chunk">@@ -398,12 +424,12 @@</span> <span class="p_context"> int qcom_rpm_write(struct qcom_rpm *rpm,</span>
 		writel_relaxed(buf[i], RPM_REQ_REG(rpm, res-&gt;target_id + i));
 
 	bitmap_set((unsigned long *)sel_mask, res-&gt;select_id, 1);
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(sel_mask); i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; rpm-&gt;data-&gt;req_sel_size; i++) {</span>
 		writel_relaxed(sel_mask[i],
<span class="p_del">-			       RPM_CTRL_REG(rpm, RPM_REQ_SELECT + i));</span>
<span class="p_add">+			       RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;req_sel_off + i));</span>
 	}
 
<span class="p_del">-	writel_relaxed(BIT(state), RPM_CTRL_REG(rpm, RPM_REQUEST_CONTEXT));</span>
<span class="p_add">+	writel_relaxed(BIT(state), RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;req_ctx_off));</span>
 
 	reinit_completion(&amp;rpm-&gt;ack);
 	regmap_write(rpm-&gt;ipc_regmap, rpm-&gt;ipc_offset, BIT(rpm-&gt;ipc_bit));
<span class="p_chunk">@@ -426,10 +452,11 @@</span> <span class="p_context"> static irqreturn_t qcom_rpm_ack_interrupt(int irq, void *dev)</span>
 	u32 ack;
 	int i;
 
<span class="p_del">-	ack = readl_relaxed(RPM_CTRL_REG(rpm, RPM_ACK_CONTEXT));</span>
<span class="p_del">-	for (i = 0; i &lt; RPM_SELECT_SIZE; i++)</span>
<span class="p_del">-		writel_relaxed(0, RPM_CTRL_REG(rpm, RPM_ACK_SELECTOR + i));</span>
<span class="p_del">-	writel(0, RPM_CTRL_REG(rpm, RPM_ACK_CONTEXT));</span>
<span class="p_add">+	ack = readl_relaxed(RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;ack_ctx_off));</span>
<span class="p_add">+	for (i = 0; i &lt; rpm-&gt;data-&gt;ack_sel_size; i++)</span>
<span class="p_add">+		writel_relaxed(0,</span>
<span class="p_add">+			RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;ack_sel_off + i));</span>
<span class="p_add">+	writel(0, RPM_CTRL_REG(rpm, rpm-&gt;data-&gt;ack_ctx_off));</span>
 
 	if (ack &amp; RPM_NOTIFICATION) {
 		dev_warn(rpm-&gt;dev, &quot;ignoring notification!\n&quot;);
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index ce7b2cab5762..54ab48827258 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2586,7 +2586,7 @@</span> <span class="p_context"> static int nand_do_write_ops(struct mtd_info *mtd, loff_t to,</span>
 		int cached = writelen &gt; bytes &amp;&amp; page != blockmask;
 		uint8_t *wbuf = buf;
 		int use_bufpoi;
<span class="p_del">-		int part_pagewr = (column || writelen &lt; (mtd-&gt;writesize - 1));</span>
<span class="p_add">+		int part_pagewr = (column || writelen &lt; mtd-&gt;writesize);</span>
 
 		if (part_pagewr)
 			use_bufpoi = 1;
<span class="p_header">diff --git a/drivers/mtd/ubi/build.c b/drivers/mtd/ubi/build.c</span>
<span class="p_header">index 22fd19c0c5d3..27de0463226e 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/build.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/build.c</span>
<span class="p_chunk">@@ -869,7 +869,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	for (i = 0; i &lt; UBI_MAX_DEVICES; i++) {
 		ubi = ubi_devices[i];
 		if (ubi &amp;&amp; mtd-&gt;index == ubi-&gt;mtd-&gt;index) {
<span class="p_del">-			ubi_err(ubi, &quot;mtd%d is already attached to ubi%d&quot;,</span>
<span class="p_add">+			pr_err(&quot;ubi: mtd%d is already attached to ubi%d&quot;,</span>
 				mtd-&gt;index, i);
 			return -EEXIST;
 		}
<span class="p_chunk">@@ -884,7 +884,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	 * no sense to attach emulated MTD devices, so we prohibit this.
 	 */
 	if (mtd-&gt;type == MTD_UBIVOLUME) {
<span class="p_del">-		ubi_err(ubi, &quot;refuse attaching mtd%d - it is already emulated on top of UBI&quot;,</span>
<span class="p_add">+		pr_err(&quot;ubi: refuse attaching mtd%d - it is already emulated on top of UBI&quot;,</span>
 			mtd-&gt;index);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -895,7 +895,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 			if (!ubi_devices[ubi_num])
 				break;
 		if (ubi_num == UBI_MAX_DEVICES) {
<span class="p_del">-			ubi_err(ubi, &quot;only %d UBI devices may be created&quot;,</span>
<span class="p_add">+			pr_err(&quot;ubi: only %d UBI devices may be created&quot;,</span>
 				UBI_MAX_DEVICES);
 			return -ENFILE;
 		}
<span class="p_chunk">@@ -905,7 +905,7 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 
 		/* Make sure ubi_num is not busy */
 		if (ubi_devices[ubi_num]) {
<span class="p_del">-			ubi_err(ubi, &quot;already exists&quot;);</span>
<span class="p_add">+			pr_err(&quot;ubi: ubi%i already exists&quot;, ubi_num);</span>
 			return -EEXIST;
 		}
 	}
<span class="p_chunk">@@ -987,6 +987,9 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 			goto out_detach;
 	}
 
<span class="p_add">+	/* Make device &quot;available&quot; before it becomes accessible via sysfs */</span>
<span class="p_add">+	ubi_devices[ubi_num] = ubi;</span>
<span class="p_add">+</span>
 	err = uif_init(ubi, &amp;ref);
 	if (err)
 		goto out_detach;
<span class="p_chunk">@@ -1031,7 +1034,6 @@</span> <span class="p_context"> int ubi_attach_mtd_dev(struct mtd_info *mtd, int ubi_num,</span>
 	wake_up_process(ubi-&gt;bgt_thread);
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 
<span class="p_del">-	ubi_devices[ubi_num] = ubi;</span>
 	ubi_notify_all(ubi, UBI_VOLUME_ADDED, NULL);
 	return ubi_num;
 
<span class="p_chunk">@@ -1042,6 +1044,7 @@</span> <span class="p_context"> out_uif:</span>
 	ubi_assert(ref);
 	uif_close(ubi);
 out_detach:
<span class="p_add">+	ubi_devices[ubi_num] = NULL;</span>
 	ubi_wl_close(ubi);
 	ubi_free_internal_volumes(ubi);
 	vfree(ubi-&gt;vtbl);
<span class="p_header">diff --git a/drivers/mtd/ubi/vmt.c b/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">index 1ae17bb9b889..3ea4c022cbb9 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/vmt.c</span>
<span class="p_chunk">@@ -488,13 +488,6 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_del">-	/* Change volume table record */</span>
<span class="p_del">-	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_del">-	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_del">-	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out_acc;</span>
<span class="p_del">-</span>
 	if (pebs &lt; 0) {
 		for (i = 0; i &lt; -pebs; i++) {
 			err = ubi_eba_unmap_leb(ubi, vol, reserved_pebs + i);
<span class="p_chunk">@@ -512,6 +505,24 @@</span> <span class="p_context"> int ubi_resize_volume(struct ubi_volume_desc *desc, int reserved_pebs)</span>
 		spin_unlock(&amp;ubi-&gt;volumes_lock);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When we shrink a volume we have to flush all pending (erase) work.</span>
<span class="p_add">+	 * Otherwise it can happen that upon next attach UBI finds a LEB with</span>
<span class="p_add">+	 * lnum &gt; highest_lnum and refuses to attach.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (pebs &lt; 0) {</span>
<span class="p_add">+		err = ubi_wl_flush(ubi, vol_id, UBI_ALL);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_acc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Change volume table record */</span>
<span class="p_add">+	vtbl_rec = ubi-&gt;vtbl[vol_id];</span>
<span class="p_add">+	vtbl_rec.reserved_pebs = cpu_to_be32(reserved_pebs);</span>
<span class="p_add">+	err = ubi_change_vtbl_record(ubi, vol_id, &amp;vtbl_rec);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out_acc;</span>
<span class="p_add">+</span>
 	vol-&gt;reserved_pebs = reserved_pebs;
 	if (vol-&gt;vol_type == UBI_DYNAMIC_VOLUME) {
 		vol-&gt;used_ebs = reserved_pebs;
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 017dd94f16ea..942461f36616 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"> static ssize_t of_node_property_read(struct file *filp, struct kobject *kobj,</span>
 	return memory_read_from_buffer(buf, count, &amp;offset, pp-&gt;value, pp-&gt;length);
 }
 
<span class="p_add">+/* always return newly allocated name, caller must free after use */</span>
 static const char *safe_name(struct kobject *kobj, const char *orig_name)
 {
 	const char *name = orig_name;
<span class="p_chunk">@@ -126,9 +127,12 @@</span> <span class="p_context"> static const char *safe_name(struct kobject *kobj, const char *orig_name)</span>
 		name = kasprintf(GFP_KERNEL, &quot;%s#%i&quot;, orig_name, ++i);
 	}
 
<span class="p_del">-	if (name != orig_name)</span>
<span class="p_add">+	if (name == orig_name) {</span>
<span class="p_add">+		name = kstrdup(orig_name, GFP_KERNEL);</span>
<span class="p_add">+	} else {</span>
 		pr_warn(&quot;device-tree: Duplicate name in %s, renamed to \&quot;%s\&quot;\n&quot;,
 			kobject_name(kobj), name);
<span class="p_add">+	}</span>
 	return name;
 }
 
<span class="p_chunk">@@ -159,6 +163,7 @@</span> <span class="p_context"> int __of_add_property_sysfs(struct device_node *np, struct property *pp)</span>
 int __of_attach_node_sysfs(struct device_node *np)
 {
 	const char *name;
<span class="p_add">+	struct kobject *parent;</span>
 	struct property *pp;
 	int rc;
 
<span class="p_chunk">@@ -171,15 +176,16 @@</span> <span class="p_context"> int __of_attach_node_sysfs(struct device_node *np)</span>
 	np-&gt;kobj.kset = of_kset;
 	if (!np-&gt;parent) {
 		/* Nodes without parents are new top level trees */
<span class="p_del">-		rc = kobject_add(&amp;np-&gt;kobj, NULL, &quot;%s&quot;,</span>
<span class="p_del">-				 safe_name(&amp;of_kset-&gt;kobj, &quot;base&quot;));</span>
<span class="p_add">+		name = safe_name(&amp;of_kset-&gt;kobj, &quot;base&quot;);</span>
<span class="p_add">+		parent = NULL;</span>
 	} else {
 		name = safe_name(&amp;np-&gt;parent-&gt;kobj, kbasename(np-&gt;full_name));
<span class="p_del">-		if (!name || !name[0])</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-		rc = kobject_add(&amp;np-&gt;kobj, &amp;np-&gt;parent-&gt;kobj, &quot;%s&quot;, name);</span>
<span class="p_add">+		parent = &amp;np-&gt;parent-&gt;kobj;</span>
 	}
<span class="p_add">+	if (!name)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	rc = kobject_add(&amp;np-&gt;kobj, parent, &quot;%s&quot;, name);</span>
<span class="p_add">+	kfree(name);</span>
 	if (rc)
 		return rc;
 
<span class="p_chunk">@@ -1753,6 +1759,12 @@</span> <span class="p_context"> int __of_remove_property(struct device_node *np, struct property *prop)</span>
 	return 0;
 }
 
<span class="p_add">+void __of_sysfs_remove_bin_file(struct device_node *np, struct property *prop)</span>
<span class="p_add">+{</span>
<span class="p_add">+	sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;prop-&gt;attr);</span>
<span class="p_add">+	kfree(prop-&gt;attr.attr.name);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void __of_remove_property_sysfs(struct device_node *np, struct property *prop)
 {
 	if (!IS_ENABLED(CONFIG_SYSFS))
<span class="p_chunk">@@ -1760,7 +1772,7 @@</span> <span class="p_context"> void __of_remove_property_sysfs(struct device_node *np, struct property *prop)</span>
 
 	/* at early boot, bail here and defer setup to of_init() */
 	if (of_kset &amp;&amp; of_node_is_attached(np))
<span class="p_del">-		sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;prop-&gt;attr);</span>
<span class="p_add">+		__of_sysfs_remove_bin_file(np, prop);</span>
 }
 
 /**
<span class="p_chunk">@@ -1830,7 +1842,7 @@</span> <span class="p_context"> void __of_update_property_sysfs(struct device_node *np, struct property *newprop</span>
 		return;
 
 	if (oldprop)
<span class="p_del">-		sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;oldprop-&gt;attr);</span>
<span class="p_add">+		__of_sysfs_remove_bin_file(np, oldprop);</span>
 	__of_add_property_sysfs(np, newprop);
 }
 
<span class="p_header">diff --git a/drivers/of/dynamic.c b/drivers/of/dynamic.c</span>
<span class="p_header">index 53826b84e0ec..2d72ddcf534f 100644</span>
<span class="p_header">--- a/drivers/of/dynamic.c</span>
<span class="p_header">+++ b/drivers/of/dynamic.c</span>
<span class="p_chunk">@@ -55,7 +55,7 @@</span> <span class="p_context"> void __of_detach_node_sysfs(struct device_node *np)</span>
 	/* only remove properties if on sysfs */
 	if (of_node_is_attached(np)) {
 		for_each_property_of_node(np, pp)
<span class="p_del">-			sysfs_remove_bin_file(&amp;np-&gt;kobj, &amp;pp-&gt;attr);</span>
<span class="p_add">+			__of_sysfs_remove_bin_file(np, pp);</span>
 		kobject_del(&amp;np-&gt;kobj);
 	}
 
<span class="p_header">diff --git a/drivers/of/of_private.h b/drivers/of/of_private.h</span>
<span class="p_header">index 8e882e706cd8..46ddbee22ce3 100644</span>
<span class="p_header">--- a/drivers/of/of_private.h</span>
<span class="p_header">+++ b/drivers/of/of_private.h</span>
<span class="p_chunk">@@ -81,6 +81,9 @@</span> <span class="p_context"> extern int __of_attach_node_sysfs(struct device_node *np);</span>
 extern void __of_detach_node(struct device_node *np);
 extern void __of_detach_node_sysfs(struct device_node *np);
 
<span class="p_add">+extern void __of_sysfs_remove_bin_file(struct device_node *np,</span>
<span class="p_add">+				       struct property *prop);</span>
<span class="p_add">+</span>
 /* iterators for transactions, used for overlays */
 /* forward iterator */
 #define for_each_transaction_entry(_oft, _te) \
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 7e327309cf69..3c4752a288e2 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3115,13 +3115,15 @@</span> <span class="p_context"> static void quirk_no_bus_reset(struct pci_dev *dev)</span>
 }
 
 /*
<span class="p_del">- * Atheros AR93xx chips do not behave after a bus reset.  The device will</span>
<span class="p_del">- * throw a Link Down error on AER-capable systems and regardless of AER,</span>
<span class="p_del">- * config space of the device is never accessible again and typically</span>
<span class="p_del">- * causes the system to hang or reset when access is attempted.</span>
<span class="p_add">+ * Some Atheros AR9xxx and QCA988x chips do not behave after a bus reset.</span>
<span class="p_add">+ * The device will throw a Link Down error on AER-capable systems and</span>
<span class="p_add">+ * regardless of AER, config space of the device is never accessible again</span>
<span class="p_add">+ * and typically causes the system to hang or reset when access is attempted.</span>
  * http://www.spinics.net/lists/linux-pci/msg34797.html
  */
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);</span>
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);</span>
 
 static void quirk_no_pm_reset(struct pci_dev *dev)
 {
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-cherryview.c b/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_header">index 84936bae6e5e..4e377599d266 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-cherryview.c</span>
<span class="p_chunk">@@ -160,7 +160,6 @@</span> <span class="p_context"> struct chv_pin_context {</span>
  * @pctldev: Pointer to the pin controller device
  * @chip: GPIO chip in this pin controller
  * @regs: MMIO registers
<span class="p_del">- * @lock: Lock to serialize register accesses</span>
  * @intr_lines: Stores mapping between 16 HW interrupt wires and GPIO
  *		offset (in GPIO number space)
  * @community: Community this pinctrl instance represents
<span class="p_chunk">@@ -174,7 +173,6 @@</span> <span class="p_context"> struct chv_pinctrl {</span>
 	struct pinctrl_dev *pctldev;
 	struct gpio_chip chip;
 	void __iomem *regs;
<span class="p_del">-	raw_spinlock_t lock;</span>
 	unsigned intr_lines[16];
 	const struct chv_community *community;
 	u32 saved_intmask;
<span class="p_chunk">@@ -659,6 +657,17 @@</span> <span class="p_context"> static const struct chv_community *chv_communities[] = {</span>
 	&amp;southeast_community,
 };
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Lock to serialize register accesses</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Due to a silicon issue, a shared lock must be used to prevent</span>
<span class="p_add">+ * concurrent accesses across the 4 GPIO controllers.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * See Intel Atom Z8000 Processor Series Specification Update (Rev. 005),</span>
<span class="p_add">+ * errata #CHT34, for further information.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static DEFINE_RAW_SPINLOCK(chv_lock);</span>
<span class="p_add">+</span>
 static void __iomem *chv_padreg(struct chv_pinctrl *pctrl, unsigned offset,
 				unsigned reg)
 {
<span class="p_chunk">@@ -720,13 +729,13 @@</span> <span class="p_context"> static void chv_pin_dbg_show(struct pinctrl_dev *pctldev, struct seq_file *s,</span>
 	u32 ctrl0, ctrl1;
 	bool locked;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	ctrl0 = readl(chv_padreg(pctrl, offset, CHV_PADCTRL0));
 	ctrl1 = readl(chv_padreg(pctrl, offset, CHV_PADCTRL1));
 	locked = chv_pad_locked(pctrl, offset);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	if (ctrl0 &amp; CHV_PADCTRL0_GPIOEN) {
 		seq_puts(s, &quot;GPIO &quot;);
<span class="p_chunk">@@ -789,14 +798,14 @@</span> <span class="p_context"> static int chv_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,</span>
 
 	grp = &amp;pctrl-&gt;community-&gt;groups[group];
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	/* Check first that the pad is not locked */
 	for (i = 0; i &lt; grp-&gt;npins; i++) {
 		if (chv_pad_locked(pctrl, grp-&gt;pins[i])) {
 			dev_warn(pctrl-&gt;dev, &quot;unable to set mode for locked pin %u\n&quot;,
 				 grp-&gt;pins[i]);
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EBUSY;
 		}
 	}
<span class="p_chunk">@@ -839,7 +848,7 @@</span> <span class="p_context"> static int chv_pinmux_set_mux(struct pinctrl_dev *pctldev, unsigned function,</span>
 			pin, altfunc-&gt;mode, altfunc-&gt;invert_oe ? &quot;&quot; : &quot;not &quot;);
 	}
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -853,13 +862,13 @@</span> <span class="p_context"> static int chv_gpio_request_enable(struct pinctrl_dev *pctldev,</span>
 	void __iomem *reg;
 	u32 value;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	if (chv_pad_locked(pctrl, offset)) {
 		value = readl(chv_padreg(pctrl, offset, CHV_PADCTRL0));
 		if (!(value &amp; CHV_PADCTRL0_GPIOEN)) {
 			/* Locked so cannot enable */
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EBUSY;
 		}
 	} else {
<span class="p_chunk">@@ -899,7 +908,7 @@</span> <span class="p_context"> static int chv_gpio_request_enable(struct pinctrl_dev *pctldev,</span>
 		chv_writel(value, reg);
 	}
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -913,13 +922,13 @@</span> <span class="p_context"> static void chv_gpio_disable_free(struct pinctrl_dev *pctldev,</span>
 	void __iomem *reg;
 	u32 value;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	reg = chv_padreg(pctrl, offset, CHV_PADCTRL0);
 	value = readl(reg) &amp; ~CHV_PADCTRL0_GPIOEN;
 	chv_writel(value, reg);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 }
 
 static int chv_gpio_set_direction(struct pinctrl_dev *pctldev,
<span class="p_chunk">@@ -931,7 +940,7 @@</span> <span class="p_context"> static int chv_gpio_set_direction(struct pinctrl_dev *pctldev,</span>
 	unsigned long flags;
 	u32 ctrl0;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	ctrl0 = readl(reg) &amp; ~CHV_PADCTRL0_GPIOCFG_MASK;
 	if (input)
<span class="p_chunk">@@ -940,7 +949,7 @@</span> <span class="p_context"> static int chv_gpio_set_direction(struct pinctrl_dev *pctldev,</span>
 		ctrl0 |= CHV_PADCTRL0_GPIOCFG_GPO &lt;&lt; CHV_PADCTRL0_GPIOCFG_SHIFT;
 	chv_writel(ctrl0, reg);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -965,10 +974,10 @@</span> <span class="p_context"> static int chv_config_get(struct pinctrl_dev *pctldev, unsigned pin,</span>
 	u16 arg = 0;
 	u32 term;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 	ctrl1 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL1));
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	term = (ctrl0 &amp; CHV_PADCTRL0_TERM_MASK) &gt;&gt; CHV_PADCTRL0_TERM_SHIFT;
 
<span class="p_chunk">@@ -1042,7 +1051,7 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 	unsigned long flags;
 	u32 ctrl0, pull;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(reg);
 
 	switch (param) {
<span class="p_chunk">@@ -1065,7 +1074,7 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 			pull = CHV_PADCTRL0_TERM_20K &lt;&lt; CHV_PADCTRL0_TERM_SHIFT;
 			break;
 		default:
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EINVAL;
 		}
 
<span class="p_chunk">@@ -1083,7 +1092,7 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 			pull = CHV_PADCTRL0_TERM_20K &lt;&lt; CHV_PADCTRL0_TERM_SHIFT;
 			break;
 		default:
<span class="p_del">-			raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+			raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 			return -EINVAL;
 		}
 
<span class="p_chunk">@@ -1091,12 +1100,12 @@</span> <span class="p_context"> static int chv_config_set_pull(struct chv_pinctrl *pctrl, unsigned pin,</span>
 		break;
 
 	default:
<span class="p_del">-		raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 		return -EINVAL;
 	}
 
 	chv_writel(ctrl0, reg);
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1162,9 +1171,9 @@</span> <span class="p_context"> static int chv_gpio_get(struct gpio_chip *chip, unsigned offset)</span>
 	unsigned long flags;
 	u32 ctrl0, cfg;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	cfg = ctrl0 &amp; CHV_PADCTRL0_GPIOCFG_MASK;
 	cfg &gt;&gt;= CHV_PADCTRL0_GPIOCFG_SHIFT;
<span class="p_chunk">@@ -1182,7 +1191,7 @@</span> <span class="p_context"> static void chv_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 	void __iomem *reg;
 	u32 ctrl0;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	reg = chv_padreg(pctrl, pin, CHV_PADCTRL0);
 	ctrl0 = readl(reg);
<span class="p_chunk">@@ -1194,7 +1203,7 @@</span> <span class="p_context"> static void chv_gpio_set(struct gpio_chip *chip, unsigned offset, int value)</span>
 
 	chv_writel(ctrl0, reg);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 }
 
 static int chv_gpio_get_direction(struct gpio_chip *chip, unsigned offset)
<span class="p_chunk">@@ -1204,9 +1213,9 @@</span> <span class="p_context"> static int chv_gpio_get_direction(struct gpio_chip *chip, unsigned offset)</span>
 	u32 ctrl0, direction;
 	unsigned long flags;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 	ctrl0 = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	direction = ctrl0 &amp; CHV_PADCTRL0_GPIOCFG_MASK;
 	direction &gt;&gt;= CHV_PADCTRL0_GPIOCFG_SHIFT;
<span class="p_chunk">@@ -1244,14 +1253,14 @@</span> <span class="p_context"> static void chv_gpio_irq_ack(struct irq_data *d)</span>
 	int pin = chv_gpio_offset_to_pin(pctrl, irqd_to_hwirq(d));
 	u32 intr_line;
 
<span class="p_del">-	raw_spin_lock(&amp;pctrl-&gt;lock);</span>
<span class="p_add">+	raw_spin_lock(&amp;chv_lock);</span>
 
 	intr_line = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 	intr_line &amp;= CHV_PADCTRL0_INTSEL_MASK;
 	intr_line &gt;&gt;= CHV_PADCTRL0_INTSEL_SHIFT;
 	chv_writel(BIT(intr_line), pctrl-&gt;regs + CHV_INTSTAT);
 
<span class="p_del">-	raw_spin_unlock(&amp;pctrl-&gt;lock);</span>
<span class="p_add">+	raw_spin_unlock(&amp;chv_lock);</span>
 }
 
 static void chv_gpio_irq_mask_unmask(struct irq_data *d, bool mask)
<span class="p_chunk">@@ -1262,7 +1271,7 @@</span> <span class="p_context"> static void chv_gpio_irq_mask_unmask(struct irq_data *d, bool mask)</span>
 	u32 value, intr_line;
 	unsigned long flags;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	intr_line = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 	intr_line &amp;= CHV_PADCTRL0_INTSEL_MASK;
<span class="p_chunk">@@ -1275,7 +1284,7 @@</span> <span class="p_context"> static void chv_gpio_irq_mask_unmask(struct irq_data *d, bool mask)</span>
 		value |= BIT(intr_line);
 	chv_writel(value, pctrl-&gt;regs + CHV_INTMASK);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 }
 
 static void chv_gpio_irq_mask(struct irq_data *d)
<span class="p_chunk">@@ -1309,7 +1318,7 @@</span> <span class="p_context"> static unsigned chv_gpio_irq_startup(struct irq_data *d)</span>
 		unsigned long flags;
 		u32 intsel, value;
 
<span class="p_del">-		raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+		raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 		intsel = readl(chv_padreg(pctrl, pin, CHV_PADCTRL0));
 		intsel &amp;= CHV_PADCTRL0_INTSEL_MASK;
 		intsel &gt;&gt;= CHV_PADCTRL0_INTSEL_SHIFT;
<span class="p_chunk">@@ -1324,7 +1333,7 @@</span> <span class="p_context"> static unsigned chv_gpio_irq_startup(struct irq_data *d)</span>
 			irq_set_handler_locked(d, handler);
 			pctrl-&gt;intr_lines[intsel] = offset;
 		}
<span class="p_del">-		raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+		raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 	}
 
 	chv_gpio_irq_unmask(d);
<span class="p_chunk">@@ -1340,7 +1349,7 @@</span> <span class="p_context"> static int chv_gpio_irq_type(struct irq_data *d, unsigned type)</span>
 	unsigned long flags;
 	u32 value;
 
<span class="p_del">-	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_lock_irqsave(&amp;chv_lock, flags);</span>
 
 	/*
 	 * Pins which can be used as shared interrupt are configured in
<span class="p_chunk">@@ -1389,7 +1398,7 @@</span> <span class="p_context"> static int chv_gpio_irq_type(struct irq_data *d, unsigned type)</span>
 	else if (type &amp; IRQ_TYPE_LEVEL_MASK)
 		irq_set_handler_locked(d, handle_level_irq);
 
<span class="p_del">-	raw_spin_unlock_irqrestore(&amp;pctrl-&gt;lock, flags);</span>
<span class="p_add">+	raw_spin_unlock_irqrestore(&amp;chv_lock, flags);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1501,7 +1510,6 @@</span> <span class="p_context"> static int chv_pinctrl_probe(struct platform_device *pdev)</span>
 	if (i == ARRAY_SIZE(chv_communities))
 		return -ENODEV;
 
<span class="p_del">-	raw_spin_lock_init(&amp;pctrl-&gt;lock);</span>
 	pctrl-&gt;dev = &amp;pdev-&gt;dev;
 
 #ifdef CONFIG_PM_SLEEP
<span class="p_header">diff --git a/drivers/platform/x86/hp-wmi.c b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">index fb4dd7b3ee71..af2046c87806 100644</span>
<span class="p_header">--- a/drivers/platform/x86/hp-wmi.c</span>
<span class="p_header">+++ b/drivers/platform/x86/hp-wmi.c</span>
<span class="p_chunk">@@ -723,6 +723,11 @@</span> <span class="p_context"> static int __init hp_wmi_rfkill_setup(struct platform_device *device)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	err = hp_wmi_perform_query(HPWMI_WIRELESS_QUERY, 1, &amp;wireless,</span>
<span class="p_add">+				   sizeof(wireless), 0);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	if (wireless &amp; 0x1) {
 		wifi_rfkill = rfkill_alloc(&quot;hp-wifi&quot;, &amp;device-&gt;dev,
 					   RFKILL_TYPE_WLAN,
<span class="p_chunk">@@ -910,7 +915,7 @@</span> <span class="p_context"> static int __init hp_wmi_bios_setup(struct platform_device *device)</span>
 	gps_rfkill = NULL;
 	rfkill2_count = 0;
 
<span class="p_del">-	if (hp_wmi_bios_2009_later() || hp_wmi_rfkill_setup(device))</span>
<span class="p_add">+	if (hp_wmi_rfkill_setup(device))</span>
 		hp_wmi_rfkill2_setup(device);
 
 	err = device_create_file(&amp;device-&gt;dev, &amp;dev_attr_display);
<span class="p_header">diff --git a/drivers/remoteproc/remoteproc_core.c b/drivers/remoteproc/remoteproc_core.c</span>
<span class="p_header">index 9e03d158f411..4f7ce0097191 100644</span>
<span class="p_header">--- a/drivers/remoteproc/remoteproc_core.c</span>
<span class="p_header">+++ b/drivers/remoteproc/remoteproc_core.c</span>
<span class="p_chunk">@@ -1239,11 +1239,6 @@</span> <span class="p_context"> int rproc_add(struct rproc *rproc)</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	/* expose to rproc_get_by_phandle users */</span>
<span class="p_del">-	mutex_lock(&amp;rproc_list_mutex);</span>
<span class="p_del">-	list_add(&amp;rproc-&gt;node, &amp;rproc_list);</span>
<span class="p_del">-	mutex_unlock(&amp;rproc_list_mutex);</span>
<span class="p_del">-</span>
 	dev_info(dev, &quot;%s is available\n&quot;, rproc-&gt;name);
 
 	dev_info(dev, &quot;Note: remoteproc is still under development and considered experimental.\n&quot;);
<span class="p_chunk">@@ -1251,8 +1246,16 @@</span> <span class="p_context"> int rproc_add(struct rproc *rproc)</span>
 
 	/* create debugfs entries */
 	rproc_create_debug_dir(rproc);
<span class="p_add">+	ret = rproc_add_virtio_devices(rproc);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-	return rproc_add_virtio_devices(rproc);</span>
<span class="p_add">+	/* expose to rproc_get_by_phandle users */</span>
<span class="p_add">+	mutex_lock(&amp;rproc_list_mutex);</span>
<span class="p_add">+	list_add(&amp;rproc-&gt;node, &amp;rproc_list);</span>
<span class="p_add">+	mutex_unlock(&amp;rproc_list_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL(rproc_add);
 
<span class="p_header">diff --git a/drivers/rtc/rtc-s3c.c b/drivers/rtc/rtc-s3c.c</span>
<span class="p_header">index ffb860d18701..f92528822f06 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-s3c.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-s3c.c</span>
<span class="p_chunk">@@ -149,12 +149,14 @@</span> <span class="p_context"> static int s3c_rtc_setfreq(struct s3c_rtc *info, int freq)</span>
 	if (!is_power_of_2(freq))
 		return -EINVAL;
 
<span class="p_add">+	s3c_rtc_enable_clk(info);</span>
 	spin_lock_irq(&amp;info-&gt;pie_lock);
 
 	if (info-&gt;data-&gt;set_freq)
 		info-&gt;data-&gt;set_freq(info, freq);
 
 	spin_unlock_irq(&amp;info-&gt;pie_lock);
<span class="p_add">+	s3c_rtc_disable_clk(info);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/s390/cio/cmf.c b/drivers/s390/cio/cmf.c</span>
<span class="p_header">index b2afad5a5682..2a34eb5f6161 100644</span>
<span class="p_header">--- a/drivers/s390/cio/cmf.c</span>
<span class="p_header">+++ b/drivers/s390/cio/cmf.c</span>
<span class="p_chunk">@@ -753,6 +753,17 @@</span> <span class="p_context"> static void reset_cmb(struct ccw_device *cdev)</span>
 	cmf_generic_reset(cdev);
 }
 
<span class="p_add">+static int cmf_enabled(struct ccw_device *cdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int enabled;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(cdev-&gt;ccwlock);</span>
<span class="p_add">+	enabled = !!cdev-&gt;private-&gt;cmb;</span>
<span class="p_add">+	spin_unlock_irq(cdev-&gt;ccwlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return enabled;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct attribute_group cmf_attr_group;
 
 static struct cmb_operations cmbops_basic = {
<span class="p_chunk">@@ -1153,13 +1164,8 @@</span> <span class="p_context"> static ssize_t cmb_enable_show(struct device *dev,</span>
 			       char *buf)
 {
 	struct ccw_device *cdev = to_ccwdev(dev);
<span class="p_del">-	int enabled;</span>
 
<span class="p_del">-	spin_lock_irq(cdev-&gt;ccwlock);</span>
<span class="p_del">-	enabled = !!cdev-&gt;private-&gt;cmb;</span>
<span class="p_del">-	spin_unlock_irq(cdev-&gt;ccwlock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sprintf(buf, &quot;%d\n&quot;, enabled);</span>
<span class="p_add">+	return sprintf(buf, &quot;%d\n&quot;, cmf_enabled(cdev));</span>
 }
 
 static ssize_t cmb_enable_store(struct device *dev,
<span class="p_chunk">@@ -1199,15 +1205,20 @@</span> <span class="p_context"> int ccw_set_cmf(struct ccw_device *cdev, int enable)</span>
  *  @cdev:	The ccw device to be enabled
  *
  *  Returns %0 for success or a negative error value.
<span class="p_del">- *</span>
<span class="p_add">+ *  Note: If this is called on a device for which channel measurement is already</span>
<span class="p_add">+ *	  enabled a reset of the measurement data is triggered.</span>
  *  Context:
  *    non-atomic
  */
 int enable_cmf(struct ccw_device *cdev)
 {
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	device_lock(&amp;cdev-&gt;dev);
<span class="p_add">+	if (cmf_enabled(cdev)) {</span>
<span class="p_add">+		cmbops-&gt;reset(cdev);</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
 	get_device(&amp;cdev-&gt;dev);
 	ret = cmbops-&gt;alloc(cdev);
 	if (ret)
<span class="p_chunk">@@ -1226,7 +1237,7 @@</span> <span class="p_context"> int enable_cmf(struct ccw_device *cdev)</span>
 out:
 	if (ret)
 		put_device(&amp;cdev-&gt;dev);
<span class="p_del">-</span>
<span class="p_add">+out_unlock:</span>
 	device_unlock(&amp;cdev-&gt;dev);
 	return ret;
 }
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_scsi.c b/drivers/scsi/lpfc/lpfc_scsi.c</span>
<span class="p_header">index 4679ed4444a7..9e165bc05ee1 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_scsi.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_scsi.c</span>
<span class="p_chunk">@@ -3859,7 +3859,7 @@</span> <span class="p_context"> int lpfc_sli4_scmd_to_wqidx_distr(struct lpfc_hba *phba,</span>
 	uint32_t tag;
 	uint16_t hwq;
 
<span class="p_del">-	if (shost_use_blk_mq(cmnd-&gt;device-&gt;host)) {</span>
<span class="p_add">+	if (cmnd &amp;&amp; shost_use_blk_mq(cmnd-&gt;device-&gt;host)) {</span>
 		tag = blk_mq_unique_tag(cmnd-&gt;request);
 		hwq = blk_mq_unique_tag_to_hwq(tag);
 
<span class="p_header">diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">index 73c8ea0b1360..3cac73e4c3e4 100644</span>
<span class="p_header">--- a/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_chunk">@@ -548,7 +548,14 @@</span> <span class="p_context"> static void reset_sccr1(struct driver_data *drv_data)</span>
 	u32 sccr1_reg;
 
 	sccr1_reg = pxa2xx_spi_read(drv_data, SSCR1) &amp; ~drv_data-&gt;int_cr1;
<span class="p_del">-	sccr1_reg &amp;= ~SSCR1_RFT;</span>
<span class="p_add">+	switch (drv_data-&gt;ssp_type) {</span>
<span class="p_add">+	case QUARK_X1000_SSP:</span>
<span class="p_add">+		sccr1_reg &amp;= ~QUARK_X1000_SSCR1_RFT;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		sccr1_reg &amp;= ~SSCR1_RFT;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 	sccr1_reg |= chip-&gt;threshold;
 	pxa2xx_spi_write(drv_data, SSCR1, sccr1_reg);
 }
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 72204fbf2bb1..bd810c109277 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -492,7 +492,8 @@</span> <span class="p_context"> static void iscsit_aborted_task(struct iscsi_conn *conn, struct iscsi_cmd *cmd)</span>
 	bool scsi_cmd = (cmd-&gt;iscsi_opcode == ISCSI_OP_SCSI_CMD);
 
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	if (!list_empty(&amp;cmd-&gt;i_conn_node))</span>
<span class="p_add">+	if (!list_empty(&amp;cmd-&gt;i_conn_node) &amp;&amp;</span>
<span class="p_add">+	    !(cmd-&gt;se_cmd.transport_state &amp; CMD_T_FABRIC_STOP))</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
 	spin_unlock_bh(&amp;conn-&gt;cmd_lock);
 
<span class="p_chunk">@@ -4194,6 +4195,7 @@</span> <span class="p_context"> transport_err:</span>
 
 static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)
 {
<span class="p_add">+	LIST_HEAD(tmp_list);</span>
 	struct iscsi_cmd *cmd = NULL, *cmd_tmp = NULL;
 	struct iscsi_session *sess = conn-&gt;sess;
 	/*
<span class="p_chunk">@@ -4202,18 +4204,26 @@</span> <span class="p_context"> static void iscsit_release_commands_from_conn(struct iscsi_conn *conn)</span>
 	 * has been reset -&gt; returned sleeping pre-handler state.
 	 */
 	spin_lock_bh(&amp;conn-&gt;cmd_lock);
<span class="p_del">-	list_for_each_entry_safe(cmd, cmd_tmp, &amp;conn-&gt;conn_cmd_list, i_conn_node) {</span>
<span class="p_add">+	list_splice_init(&amp;conn-&gt;conn_cmd_list, &amp;tmp_list);</span>
 
<span class="p_add">+	list_for_each_entry(cmd, &amp;tmp_list, i_conn_node) {</span>
<span class="p_add">+		struct se_cmd *se_cmd = &amp;cmd-&gt;se_cmd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (se_cmd-&gt;se_tfo != NULL) {</span>
<span class="p_add">+			spin_lock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+			se_cmd-&gt;transport_state |= CMD_T_FABRIC_STOP;</span>
<span class="p_add">+			spin_unlock(&amp;se_cmd-&gt;t_state_lock);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(cmd, cmd_tmp, &amp;tmp_list, i_conn_node) {</span>
 		list_del_init(&amp;cmd-&gt;i_conn_node);
<span class="p_del">-		spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 
 		iscsit_increment_maxcmdsn(cmd, sess);
<span class="p_del">-</span>
 		iscsit_free_cmd(cmd, true);
 
<span class="p_del">-		spin_lock_bh(&amp;conn-&gt;cmd_lock);</span>
 	}
<span class="p_del">-	spin_unlock_bh(&amp;conn-&gt;cmd_lock);</span>
 }
 
 static void iscsit_stop_timers_for_cmds(
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_login.c b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">index 96e78c823d13..316f66172335 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_login.c</span>
<span class="p_chunk">@@ -1357,8 +1357,9 @@</span> <span class="p_context"> static int __iscsi_target_login_thread(struct iscsi_np *np)</span>
 	}
 	login-&gt;zero_tsih = zero_tsih;
 
<span class="p_del">-	conn-&gt;sess-&gt;se_sess-&gt;sup_prot_ops =</span>
<span class="p_del">-		conn-&gt;conn_transport-&gt;iscsit_get_sup_prot_ops(conn);</span>
<span class="p_add">+	if (conn-&gt;sess)</span>
<span class="p_add">+		conn-&gt;sess-&gt;se_sess-&gt;sup_prot_ops =</span>
<span class="p_add">+			conn-&gt;conn_transport-&gt;iscsit_get_sup_prot_ops(conn);</span>
 
 	tpg = conn-&gt;tpg;
 	if (!tpg) {
<span class="p_header">diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c</span>
<span class="p_header">index 3436a83568ea..dcd5ed26eb18 100644</span>
<span class="p_header">--- a/drivers/target/target_core_device.c</span>
<span class="p_header">+++ b/drivers/target/target_core_device.c</span>
<span class="p_chunk">@@ -832,13 +832,15 @@</span> <span class="p_context"> struct se_device *target_alloc_device(struct se_hba *hba, const char *name)</span>
  * in ATA and we need to set TPE=1
  */
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size)</span>
<span class="p_add">+				       struct request_queue *q)</span>
 {
<span class="p_add">+	int block_size = queue_logical_block_size(q);</span>
<span class="p_add">+</span>
 	if (!blk_queue_discard(q))
 		return false;
 
<span class="p_del">-	attrib-&gt;max_unmap_lba_count = (q-&gt;limits.max_discard_sectors &lt;&lt; 9) /</span>
<span class="p_del">-								block_size;</span>
<span class="p_add">+	attrib-&gt;max_unmap_lba_count =</span>
<span class="p_add">+		q-&gt;limits.max_discard_sectors &gt;&gt; (ilog2(block_size) - 9);</span>
 	/*
 	 * Currently hardcoded to 1 in Linux/SCSI code..
 	 */
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index 75f0f08b2a34..79291869bce6 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -161,8 +161,7 @@</span> <span class="p_context"> static int fd_configure_device(struct se_device *dev)</span>
 			dev_size, div_u64(dev_size, fd_dev-&gt;fd_block_size),
 			fd_dev-&gt;fd_block_size);
 
<span class="p_del">-		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-						      fd_dev-&gt;fd_block_size))</span>
<span class="p_add">+		if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 			pr_debug(&quot;IFILE: BLOCK Discard support available,&quot;
 				 &quot; disabled by default\n&quot;);
 		/*
<span class="p_header">diff --git a/drivers/target/target_core_iblock.c b/drivers/target/target_core_iblock.c</span>
<span class="p_header">index 2c53dcefff3e..4620c1dcdbc7 100644</span>
<span class="p_header">--- a/drivers/target/target_core_iblock.c</span>
<span class="p_header">+++ b/drivers/target/target_core_iblock.c</span>
<span class="p_chunk">@@ -121,8 +121,7 @@</span> <span class="p_context"> static int iblock_configure_device(struct se_device *dev)</span>
 	dev-&gt;dev_attrib.hw_max_sectors = queue_max_hw_sectors(q);
 	dev-&gt;dev_attrib.hw_queue_depth = q-&gt;nr_requests;
 
<span class="p_del">-	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q,</span>
<span class="p_del">-					      dev-&gt;dev_attrib.hw_block_size))</span>
<span class="p_add">+	if (target_configure_unmap_from_queue(&amp;dev-&gt;dev_attrib, q))</span>
 		pr_debug(&quot;IBLOCK: BLOCK Discard support available,&quot;
 			 &quot; disabled by default\n&quot;);
 
<span class="p_header">diff --git a/drivers/target/target_core_internal.h b/drivers/target/target_core_internal.h</span>
<span class="p_header">index dae0750c2032..253a91bff943 100644</span>
<span class="p_header">--- a/drivers/target/target_core_internal.h</span>
<span class="p_header">+++ b/drivers/target/target_core_internal.h</span>
<span class="p_chunk">@@ -148,6 +148,7 @@</span> <span class="p_context"> sense_reason_t	target_cmd_size_check(struct se_cmd *cmd, unsigned int size);</span>
 void	target_qf_do_work(struct work_struct *work);
 bool	target_check_wce(struct se_device *dev);
 bool	target_check_fua(struct se_device *dev);
<span class="p_add">+void	__target_execute_cmd(struct se_cmd *, bool);</span>
 
 /* target_core_stat.c */
 void	target_stat_setup_dev_default_groups(struct se_device *);
<span class="p_header">diff --git a/drivers/target/target_core_sbc.c b/drivers/target/target_core_sbc.c</span>
<span class="p_header">index 98698d875742..c220bb8dfa9d 100644</span>
<span class="p_header">--- a/drivers/target/target_core_sbc.c</span>
<span class="p_header">+++ b/drivers/target/target_core_sbc.c</span>
<span class="p_chunk">@@ -594,7 +594,7 @@</span> <span class="p_context"> static sense_reason_t compare_and_write_callback(struct se_cmd *cmd, bool succes</span>
 	cmd-&gt;transport_state |= CMD_T_ACTIVE|CMD_T_BUSY|CMD_T_SENT;
 	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);
 
<span class="p_del">-	__target_execute_cmd(cmd);</span>
<span class="p_add">+	__target_execute_cmd(cmd, false);</span>
 
 	kfree(buf);
 	return ret;
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index d151bc3d6971..7bc3778a1ac9 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1270,23 +1270,6 @@</span> <span class="p_context"> target_setup_cmd_from_cdb(struct se_cmd *cmd, unsigned char *cdb)</span>
 
 	trace_target_sequencer_start(cmd);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Check for an existing UNIT ATTENTION condition</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = target_scsi3_ua_check(cmd);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = target_alua_state_check(cmd);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = target_check_reservation(cmd);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		cmd-&gt;scsi_status = SAM_STAT_RESERVATION_CONFLICT;</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = dev-&gt;transport-&gt;parse_cdb(cmd);
 	if (ret == TCM_UNSUPPORTED_SCSI_OPCODE)
 		pr_warn_ratelimited(&quot;%s/%s: Unsupported SCSI Opcode 0x%02x, sending CHECK_CONDITION.\n&quot;,
<span class="p_chunk">@@ -1749,20 +1732,45 @@</span> <span class="p_context"> queue_full:</span>
 }
 EXPORT_SYMBOL(transport_generic_request_failure);
 
<span class="p_del">-void __target_execute_cmd(struct se_cmd *cmd)</span>
<span class="p_add">+void __target_execute_cmd(struct se_cmd *cmd, bool do_checks)</span>
 {
 	sense_reason_t ret;
 
<span class="p_del">-	if (cmd-&gt;execute_cmd) {</span>
<span class="p_del">-		ret = cmd-&gt;execute_cmd(cmd);</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			spin_lock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_del">-			cmd-&gt;transport_state &amp;= ~(CMD_T_BUSY|CMD_T_SENT);</span>
<span class="p_del">-			spin_unlock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_add">+	if (!cmd-&gt;execute_cmd) {</span>
<span class="p_add">+		ret = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (do_checks) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check for an existing UNIT ATTENTION condition after</span>
<span class="p_add">+		 * target_handle_task_attr() has done SAM task attr</span>
<span class="p_add">+		 * checking, and possibly have already defered execution</span>
<span class="p_add">+		 * out to target_restart_delayed_cmds() context.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = target_scsi3_ua_check(cmd);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = target_alua_state_check(cmd);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto err;</span>
 
<span class="p_del">-			transport_generic_request_failure(cmd, ret);</span>
<span class="p_add">+		ret = target_check_reservation(cmd);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			cmd-&gt;scsi_status = SAM_STAT_RESERVATION_CONFLICT;</span>
<span class="p_add">+			goto err;</span>
 		}
 	}
<span class="p_add">+</span>
<span class="p_add">+	ret = cmd-&gt;execute_cmd(cmd);</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+err:</span>
<span class="p_add">+	spin_lock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_add">+	cmd-&gt;transport_state &amp;= ~(CMD_T_BUSY|CMD_T_SENT);</span>
<span class="p_add">+	spin_unlock_irq(&amp;cmd-&gt;t_state_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	transport_generic_request_failure(cmd, ret);</span>
 }
 
 static int target_write_prot_action(struct se_cmd *cmd)
<span class="p_chunk">@@ -1807,6 +1815,8 @@</span> <span class="p_context"> static bool target_handle_task_attr(struct se_cmd *cmd)</span>
 	if (dev-&gt;transport-&gt;transport_flags &amp; TRANSPORT_FLAG_PASSTHROUGH)
 		return false;
 
<span class="p_add">+	cmd-&gt;se_cmd_flags |= SCF_TASK_ATTR_SET;</span>
<span class="p_add">+</span>
 	/*
 	 * Check for the existence of HEAD_OF_QUEUE, and if true return 1
 	 * to allow the passed struct se_cmd list of tasks to the front of the list.
<span class="p_chunk">@@ -1887,7 +1897,7 @@</span> <span class="p_context"> void target_execute_cmd(struct se_cmd *cmd)</span>
 		return;
 	}
 
<span class="p_del">-	__target_execute_cmd(cmd);</span>
<span class="p_add">+	__target_execute_cmd(cmd, true);</span>
 }
 EXPORT_SYMBOL(target_execute_cmd);
 
<span class="p_chunk">@@ -1911,7 +1921,7 @@</span> <span class="p_context"> static void target_restart_delayed_cmds(struct se_device *dev)</span>
 		list_del(&amp;cmd-&gt;se_delayed_node);
 		spin_unlock(&amp;dev-&gt;delayed_cmd_lock);
 
<span class="p_del">-		__target_execute_cmd(cmd);</span>
<span class="p_add">+		__target_execute_cmd(cmd, true);</span>
 
 		if (cmd-&gt;sam_task_attr == TCM_ORDERED_TAG)
 			break;
<span class="p_chunk">@@ -1929,6 +1939,9 @@</span> <span class="p_context"> static void transport_complete_task_attr(struct se_cmd *cmd)</span>
 	if (dev-&gt;transport-&gt;transport_flags &amp; TRANSPORT_FLAG_PASSTHROUGH)
 		return;
 
<span class="p_add">+	if (!(cmd-&gt;se_cmd_flags &amp; SCF_TASK_ATTR_SET))</span>
<span class="p_add">+		goto restart;</span>
<span class="p_add">+</span>
 	if (cmd-&gt;sam_task_attr == TCM_SIMPLE_TAG) {
 		atomic_dec_mb(&amp;dev-&gt;simple_cmds);
 		dev-&gt;dev_cur_ordered_id++;
<span class="p_chunk">@@ -1945,7 +1958,7 @@</span> <span class="p_context"> static void transport_complete_task_attr(struct se_cmd *cmd)</span>
 		pr_debug(&quot;Incremented dev_cur_ordered_id: %u for ORDERED\n&quot;,
 			 dev-&gt;dev_cur_ordered_id);
 	}
<span class="p_del">-</span>
<span class="p_add">+restart:</span>
 	target_restart_delayed_cmds(dev);
 }
 
<span class="p_chunk">@@ -2533,15 +2546,10 @@</span> <span class="p_context"> static void target_release_cmd_kref(struct kref *kref)</span>
 	bool fabric_stop;
 
 	spin_lock_irqsave(&amp;se_sess-&gt;sess_cmd_lock, flags);
<span class="p_del">-	if (list_empty(&amp;se_cmd-&gt;se_cmd_list)) {</span>
<span class="p_del">-		spin_unlock_irqrestore(&amp;se_sess-&gt;sess_cmd_lock, flags);</span>
<span class="p_del">-		target_free_cmd_mem(se_cmd);</span>
<span class="p_del">-		se_cmd-&gt;se_tfo-&gt;release_cmd(se_cmd);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
 
 	spin_lock(&amp;se_cmd-&gt;t_state_lock);
<span class="p_del">-	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP);</span>
<span class="p_add">+	fabric_stop = (se_cmd-&gt;transport_state &amp; CMD_T_FABRIC_STOP) &amp;&amp;</span>
<span class="p_add">+		      (se_cmd-&gt;transport_state &amp; CMD_T_ABORTED);</span>
 	spin_unlock(&amp;se_cmd-&gt;t_state_lock);
 
 	if (se_cmd-&gt;cmd_wait_set || fabric_stop) {
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 7bbadd176c74..7b5462eb8388 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -485,19 +485,21 @@</span> <span class="p_context"> static void atmel_start_tx(struct uart_port *port)</span>
 {
 	struct atmel_uart_port *atmel_port = to_atmel_uart_port(port);
 
<span class="p_del">-	if (atmel_use_pdc_tx(port)) {</span>
<span class="p_del">-		if (atmel_uart_readl(port, ATMEL_PDC_PTSR) &amp; ATMEL_PDC_TXTEN)</span>
<span class="p_del">-			/* The transmitter is already running.  Yes, we</span>
<span class="p_del">-			   really need this.*/</span>
<span class="p_del">-			return;</span>
<span class="p_add">+	if (atmel_use_pdc_tx(port) &amp;&amp; (atmel_uart_readl(port, ATMEL_PDC_PTSR)</span>
<span class="p_add">+				       &amp; ATMEL_PDC_TXTEN))</span>
<span class="p_add">+		/* The transmitter is already running.  Yes, we</span>
<span class="p_add">+		   really need this.*/</span>
<span class="p_add">+		return;</span>
 
<span class="p_add">+	if (atmel_use_pdc_tx(port) || atmel_use_dma_tx(port))</span>
 		if ((port-&gt;rs485.flags &amp; SER_RS485_ENABLED) &amp;&amp;
 		    !(port-&gt;rs485.flags &amp; SER_RS485_RX_DURING_TX))
 			atmel_stop_rx(port);
 
<span class="p_add">+	if (atmel_use_pdc_tx(port))</span>
 		/* re-enable PDC transmit */
 		atmel_uart_writel(port, ATMEL_PDC_PTCR, ATMEL_PDC_TXTEN);
<span class="p_del">-	}</span>
<span class="p_add">+</span>
 	/* Enable interrupts */
 	atmel_uart_writel(port, ATMEL_US_IER, atmel_port-&gt;tx_done_mask);
 }
<span class="p_header">diff --git a/drivers/tty/serial/msm_serial.c b/drivers/tty/serial/msm_serial.c</span>
<span class="p_header">index dcde955475dc..e1de4944e0ce 100644</span>
<span class="p_header">--- a/drivers/tty/serial/msm_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/msm_serial.c</span>
<span class="p_chunk">@@ -726,7 +726,7 @@</span> <span class="p_context"> static void msm_handle_tx(struct uart_port *port)</span>
 		return;
 	}
 
<span class="p_del">-	pio_count = CIRC_CNT(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);</span>
<span class="p_add">+	pio_count = CIRC_CNT_TO_END(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);</span>
 	dma_count = CIRC_CNT_TO_END(xmit-&gt;head, xmit-&gt;tail, UART_XMIT_SIZE);
 
 	dma_min = 1;	/* Always DMA */
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index 8320173af846..237ef5573c18 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -1676,7 +1676,7 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 		return -ENODEV;
 
 	if (port-&gt;mapbase != 0)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	/* setup info for port */
 	port-&gt;dev	= &amp;platdev-&gt;dev;
<span class="p_chunk">@@ -1730,22 +1730,25 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 		ourport-&gt;dma = devm_kzalloc(port-&gt;dev,
 					    sizeof(*ourport-&gt;dma),
 					    GFP_KERNEL);
<span class="p_del">-		if (!ourport-&gt;dma)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_add">+		if (!ourport-&gt;dma) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 	}
 
 	ourport-&gt;clk	= clk_get(&amp;platdev-&gt;dev, &quot;uart&quot;);
 	if (IS_ERR(ourport-&gt;clk)) {
 		pr_err(&quot;%s: Controller clock not found\n&quot;,
 				dev_name(&amp;platdev-&gt;dev));
<span class="p_del">-		return PTR_ERR(ourport-&gt;clk);</span>
<span class="p_add">+		ret = PTR_ERR(ourport-&gt;clk);</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	ret = clk_prepare_enable(ourport-&gt;clk);
 	if (ret) {
 		pr_err(&quot;uart: clock failed to prepare+enable: %d\n&quot;, ret);
 		clk_put(ourport-&gt;clk);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err;</span>
 	}
 
 	/* Keep all interrupts masked and cleared */
<span class="p_chunk">@@ -1761,7 +1764,12 @@</span> <span class="p_context"> static int s3c24xx_serial_init_port(struct s3c24xx_uart_port *ourport,</span>
 
 	/* reset the fifos (and setup the uart) */
 	s3c24xx_serial_resetport(port, cfg);
<span class="p_add">+</span>
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	port-&gt;mapbase = 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /* Device driver serial port probe */
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 38ae877c46e3..3ffb01ff6549 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -1203,10 +1203,11 @@</span> <span class="p_context"> static int proc_getdriver(struct usb_dev_state *ps, void __user *arg)</span>
 
 static int proc_connectinfo(struct usb_dev_state *ps, void __user *arg)
 {
<span class="p_del">-	struct usbdevfs_connectinfo ci = {</span>
<span class="p_del">-		.devnum = ps-&gt;dev-&gt;devnum,</span>
<span class="p_del">-		.slow = ps-&gt;dev-&gt;speed == USB_SPEED_LOW</span>
<span class="p_del">-	};</span>
<span class="p_add">+	struct usbdevfs_connectinfo ci;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;ci, 0, sizeof(ci));</span>
<span class="p_add">+	ci.devnum = ps-&gt;dev-&gt;devnum;</span>
<span class="p_add">+	ci.slow = ps-&gt;dev-&gt;speed == USB_SPEED_LOW;</span>
 
 	if (copy_to_user(arg, &amp;ci, sizeof(ci)))
 		return -EFAULT;
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 944a6dca0fcb..d2e50a27140c 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -128,6 +128,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	{ USB_DEVICE(0x04f3, 0x016f), .driver_info =
 			USB_QUIRK_DEVICE_QUALIFIER },
 
<span class="p_add">+	{ USB_DEVICE(0x04f3, 0x0381), .driver_info =</span>
<span class="p_add">+			USB_QUIRK_NO_LPM },</span>
<span class="p_add">+</span>
 	{ USB_DEVICE(0x04f3, 0x21b8), .driver_info =
 			USB_QUIRK_DEVICE_QUALIFIER },
 
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 69ffe6e8d77f..70900e6ca9bc 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1965,6 +1965,10 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 		return 1;
 	}
 
<span class="p_add">+	if (usb_endpoint_xfer_isoc(dep-&gt;endpoint.desc))</span>
<span class="p_add">+		if ((event-&gt;status &amp; DEPEVT_STATUS_IOC) &amp;&amp;</span>
<span class="p_add">+				(trb-&gt;ctrl &amp; DWC3_TRB_CTRL_IOC))</span>
<span class="p_add">+			return 0;</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 97ef75af9632..803c503a2e3d 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -2740,6 +2740,7 @@</span> <span class="p_context"> static int _ffs_func_bind(struct usb_configuration *c,</span>
 		func-&gt;ffs-&gt;ss_descs_count;
 
 	int fs_len, hs_len, ss_len, ret, i;
<span class="p_add">+	struct ffs_ep *eps_ptr;</span>
 
 	/* Make it a single chunk, less management later on */
 	vla_group(d);
<span class="p_chunk">@@ -2788,12 +2789,9 @@</span> <span class="p_context"> static int _ffs_func_bind(struct usb_configuration *c,</span>
 	       ffs-&gt;raw_descs_length);
 
 	memset(vla_ptr(vlabuf, d, inums), 0xff, d_inums__sz);
<span class="p_del">-	for (ret = ffs-&gt;eps_count; ret; --ret) {</span>
<span class="p_del">-		struct ffs_ep *ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-		ptr = vla_ptr(vlabuf, d, eps);</span>
<span class="p_del">-		ptr[ret].num = -1;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	eps_ptr = vla_ptr(vlabuf, d, eps);</span>
<span class="p_add">+	for (i = 0; i &lt; ffs-&gt;eps_count; i++)</span>
<span class="p_add">+		eps_ptr[i].num = -1;</span>
 
 	/* Save pointers
 	 * d_eps == vlabuf, func-&gt;eps used to kfree vlabuf later
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_uac2.c b/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_header">index 044ca79d3cb5..12628dd36e55 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_uac2.c</span>
<span class="p_chunk">@@ -1291,6 +1291,7 @@</span> <span class="p_context"> in_rq_cur(struct usb_function *fn, const struct usb_ctrlrequest *cr)</span>
 
 	if (control_selector == UAC2_CS_CONTROL_SAM_FREQ) {
 		struct cntrl_cur_lay3 c;
<span class="p_add">+		memset(&amp;c, 0, sizeof(struct cntrl_cur_lay3));</span>
 
 		if (entity_id == USB_IN_CLK_ID)
 			c.dCUR = p_srate;
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index f1893e08e51a..db565f620f82 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -808,20 +808,27 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 {
 	struct usbhs_pkt *pkt = container_of(work, struct usbhs_pkt, work);
 	struct usbhs_pipe *pipe = pkt-&gt;pipe;
<span class="p_del">-	struct usbhs_fifo *fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	struct usbhs_fifo *fifo;</span>
 	struct usbhs_priv *priv = usbhs_pipe_to_priv(pipe);
 	struct dma_async_tx_descriptor *desc;
<span class="p_del">-	struct dma_chan *chan = usbhsf_dma_chan_get(fifo, pkt);</span>
<span class="p_add">+	struct dma_chan *chan;</span>
 	struct device *dev = usbhs_priv_to_dev(priv);
 	enum dma_transfer_direction dir;
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	usbhs_lock(priv, flags);</span>
<span class="p_add">+	fifo = usbhs_pipe_to_fifo(pipe);</span>
<span class="p_add">+	if (!fifo)</span>
<span class="p_add">+		goto xfer_work_end;</span>
<span class="p_add">+</span>
<span class="p_add">+	chan = usbhsf_dma_chan_get(fifo, pkt);</span>
 	dir = usbhs_pipe_is_dir_in(pipe) ? DMA_DEV_TO_MEM : DMA_MEM_TO_DEV;
 
 	desc = dmaengine_prep_slave_single(chan, pkt-&gt;dma + pkt-&gt;actual,
 					pkt-&gt;trans, dir,
 					DMA_PREP_INTERRUPT | DMA_CTRL_ACK);
 	if (!desc)
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 
 	desc-&gt;callback		= usbhsf_dma_complete;
 	desc-&gt;callback_param	= pipe;
<span class="p_chunk">@@ -829,7 +836,7 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 	pkt-&gt;cookie = dmaengine_submit(desc);
 	if (pkt-&gt;cookie &lt; 0) {
 		dev_err(dev, &quot;Failed to submit dma descriptor\n&quot;);
<span class="p_del">-		return;</span>
<span class="p_add">+		goto xfer_work_end;</span>
 	}
 
 	dev_dbg(dev, &quot;  %s %d (%d/ %d)\n&quot;,
<span class="p_chunk">@@ -840,6 +847,9 @@</span> <span class="p_context"> static void xfer_work(struct work_struct *work)</span>
 	usbhs_pipe_set_trans_count_if_bulk(pipe, pkt-&gt;trans);
 	dma_async_issue_pending(chan);
 	usbhs_pipe_enable(pipe);
<span class="p_add">+</span>
<span class="p_add">+xfer_work_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index fa14198daf77..5a3abf56d56b 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -586,6 +586,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	struct usbhs_priv *priv = usbhsg_gpriv_to_priv(gpriv);
 	struct usbhs_pipe *pipe;
 	int ret = -EIO;
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	usbhs_lock(priv, flags);</span>
 
 	/*
 	 * if it already have pipe,
<span class="p_chunk">@@ -594,7 +597,8 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 	if (uep-&gt;pipe) {
 		usbhs_pipe_clear(uep-&gt;pipe);
 		usbhs_pipe_sequence_data0(uep-&gt;pipe);
<span class="p_del">-		return 0;</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto usbhsg_ep_enable_end;</span>
 	}
 
 	pipe = usbhs_pipe_malloc(priv,
<span class="p_chunk">@@ -622,6 +626,9 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 		ret = 0;
 	}
 
<span class="p_add">+usbhsg_ep_enable_end:</span>
<span class="p_add">+	usbhs_unlock(priv, flags);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index d96d423d00e6..8e07536c233a 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -273,6 +273,7 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE922_USBCFG5		0x1045
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
<span class="p_add">+#define TELIT_PRODUCT_LE910_USBCFG4		0x1206</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -1198,6 +1199,8 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg0 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910),
 		.driver_info = (kernel_ulong_t)&amp;telit_le910_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE910_USBCFG4),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 8ab6238c9299..56f7e2521202 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -196,6 +196,8 @@</span> <span class="p_context"> static unsigned leak_balloon(struct virtio_balloon *vb, size_t num)</span>
 	num = min(num, ARRAY_SIZE(vb-&gt;pfns));
 
 	mutex_lock(&amp;vb-&gt;balloon_lock);
<span class="p_add">+	/* We can&#39;t release more pages than taken */</span>
<span class="p_add">+	num = min(num, (size_t)vb-&gt;num_pages);</span>
 	for (vb-&gt;num_pfns = 0; vb-&gt;num_pfns &lt; num;
 	     vb-&gt;num_pfns += VIRTIO_BALLOON_PAGES_PER_PAGE) {
 		page = balloon_page_dequeue(vb_dev_info);
<span class="p_header">diff --git a/drivers/w1/masters/omap_hdq.c b/drivers/w1/masters/omap_hdq.c</span>
<span class="p_header">index 0e2f43bccf1f..0c427d6a12d1 100644</span>
<span class="p_header">--- a/drivers/w1/masters/omap_hdq.c</span>
<span class="p_header">+++ b/drivers/w1/masters/omap_hdq.c</span>
<span class="p_chunk">@@ -390,8 +390,6 @@</span> <span class="p_context"> static int hdq_read_byte(struct hdq_data *hdq_data, u8 *val)</span>
 		goto out;
 	}
 
<span class="p_del">-	hdq_data-&gt;hdq_irqstatus = 0;</span>
<span class="p_del">-</span>
 	if (!(hdq_data-&gt;hdq_irqstatus &amp; OMAP_HDQ_INT_STATUS_RXCOMPLETE)) {
 		hdq_reg_merge(hdq_data, OMAP_HDQ_CTRL_STATUS,
 			OMAP_HDQ_CTRL_STATUS_DIR | OMAP_HDQ_CTRL_STATUS_GO,
<span class="p_header">diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c</span>
<span class="p_header">index 9abe18763a7f..257bbdcb5df6 100644</span>
<span class="p_header">--- a/fs/btrfs/extent_io.c</span>
<span class="p_header">+++ b/fs/btrfs/extent_io.c</span>
<span class="p_chunk">@@ -2786,12 +2786,6 @@</span> <span class="p_context"> struct bio *btrfs_bio_clone(struct bio *bio, gfp_t gfp_mask)</span>
 		btrfs_bio-&gt;csum = NULL;
 		btrfs_bio-&gt;csum_allocated = NULL;
 		btrfs_bio-&gt;end_io = NULL;
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_BLK_CGROUP</span>
<span class="p_del">-		/* FIXME, put this into bio_clone_bioset */</span>
<span class="p_del">-		if (bio-&gt;bi_css)</span>
<span class="p_del">-			bio_associate_blkcg(new, bio-&gt;bi_css);</span>
<span class="p_del">-#endif</span>
 	}
 	return new;
 }
<span class="p_header">diff --git a/fs/cifs/cifs_fs_sb.h b/fs/cifs/cifs_fs_sb.h</span>
<span class="p_header">index 3182273a3407..1418daa03d95 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_fs_sb.h</span>
<span class="p_header">+++ b/fs/cifs/cifs_fs_sb.h</span>
<span class="p_chunk">@@ -46,6 +46,9 @@</span> <span class="p_context"></span>
 #define CIFS_MOUNT_CIFS_BACKUPUID 0x200000 /* backup intent bit for a user */
 #define CIFS_MOUNT_CIFS_BACKUPGID 0x400000 /* backup intent bit for a group */
 #define CIFS_MOUNT_MAP_SFM_CHR	0x800000 /* SFM/MAC mapping for illegal chars */
<span class="p_add">+#define CIFS_MOUNT_USE_PREFIX_PATH 0x1000000 /* make subpath with unaccessible</span>
<span class="p_add">+					      * root mountable</span>
<span class="p_add">+					      */</span>
 
 struct cifs_sb_info {
 	struct rb_root tlink_tree;
<span class="p_chunk">@@ -67,5 +70,6 @@</span> <span class="p_context"> struct cifs_sb_info {</span>
 	struct backing_dev_info bdi;
 	struct delayed_work prune_tlinks;
 	struct rcu_head rcu;
<span class="p_add">+	char *prepath;</span>
 };
 #endif				/* _CIFS_FS_SB_H */
<span class="p_header">diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c</span>
<span class="p_header">index e682b36a210f..4acbc390a7d6 100644</span>
<span class="p_header">--- a/fs/cifs/cifsencrypt.c</span>
<span class="p_header">+++ b/fs/cifs/cifsencrypt.c</span>
<span class="p_chunk">@@ -731,24 +731,26 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 
 	memcpy(ses-&gt;auth_key.response + baselen, tiblob, tilen);
 
<span class="p_add">+	mutex_lock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
<span class="p_add">+</span>
 	rc = crypto_hmacmd5_alloc(ses-&gt;server);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not crypto alloc hmacmd5 rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate ntlmv2_hash */
 	rc = calc_ntlmv2_hash(ses, ntlmv2_hash, nls_cp);
 	if (rc) {
 		cifs_dbg(VFS, &quot;could not get v2 hash rc %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* calculate first part of the client response (CR1) */
 	rc = CalcNTLMv2_response(ses, ntlmv2_hash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;Could not calculate CR1 rc: %d\n&quot;, rc);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	/* now calculate the session key for NTLMv2 */
<span class="p_chunk">@@ -757,13 +759,13 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not set NTLMV2 Hash as a key\n&quot;,
 			 __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_init(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not init hmacmd5\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_update(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -771,7 +773,7 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 		CIFS_HMAC_MD5_HASH_SIZE);
 	if (rc) {
 		cifs_dbg(VFS, &quot;%s: Could not update with response\n&quot;, __func__);
<span class="p_del">-		goto setup_ntlmv2_rsp_ret;</span>
<span class="p_add">+		goto unlock;</span>
 	}
 
 	rc = crypto_shash_final(&amp;ses-&gt;server-&gt;secmech.sdeschmacmd5-&gt;shash,
<span class="p_chunk">@@ -779,6 +781,8 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	if (rc)
 		cifs_dbg(VFS, &quot;%s: Could not generate md5 hash\n&quot;, __func__);
 
<span class="p_add">+unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;ses-&gt;server-&gt;srv_mutex);</span>
 setup_ntlmv2_rsp_ret:
 	kfree(tiblob);
 
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index cbc0f4bca0c0..450578097fb7 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -686,6 +686,14 @@</span> <span class="p_context"> cifs_do_mount(struct file_system_type *fs_type,</span>
 		goto out_cifs_sb;
 	}
 
<span class="p_add">+	if (volume_info-&gt;prepath) {</span>
<span class="p_add">+		cifs_sb-&gt;prepath = kstrdup(volume_info-&gt;prepath, GFP_KERNEL);</span>
<span class="p_add">+		if (cifs_sb-&gt;prepath == NULL) {</span>
<span class="p_add">+			root = ERR_PTR(-ENOMEM);</span>
<span class="p_add">+			goto out_cifs_sb;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	cifs_setup_cifs_sb(volume_info, cifs_sb);
 
 	rc = cifs_mount(cifs_sb, volume_info);
<span class="p_chunk">@@ -724,7 +732,11 @@</span> <span class="p_context"> cifs_do_mount(struct file_system_type *fs_type,</span>
 		sb-&gt;s_flags |= MS_ACTIVE;
 	}
 
<span class="p_del">-	root = cifs_get_root(volume_info, sb);</span>
<span class="p_add">+	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+		root = dget(sb-&gt;s_root);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		root = cifs_get_root(volume_info, sb);</span>
<span class="p_add">+</span>
 	if (IS_ERR(root))
 		goto out_super;
 
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 5481a6eb9a95..61c3a5ab8637 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -3517,6 +3517,44 @@</span> <span class="p_context"> cifs_get_volume_info(char *mount_data, const char *devname)</span>
 	return volume_info;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+cifs_are_all_path_components_accessible(struct TCP_Server_Info *server,</span>
<span class="p_add">+					unsigned int xid,</span>
<span class="p_add">+					struct cifs_tcon *tcon,</span>
<span class="p_add">+					struct cifs_sb_info *cifs_sb,</span>
<span class="p_add">+					char *full_path)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+	char *s;</span>
<span class="p_add">+	char sep, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	sep = CIFS_DIR_SEP(cifs_sb);</span>
<span class="p_add">+	s = full_path;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = server-&gt;ops-&gt;is_path_accessible(xid, tcon, cifs_sb, &quot;&quot;);</span>
<span class="p_add">+	while (rc == 0) {</span>
<span class="p_add">+		/* skip separators */</span>
<span class="p_add">+		while (*s == sep)</span>
<span class="p_add">+			s++;</span>
<span class="p_add">+		if (!*s)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		/* next separator */</span>
<span class="p_add">+		while (*s &amp;&amp; *s != sep)</span>
<span class="p_add">+			s++;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * temporarily null-terminate the path at the end of</span>
<span class="p_add">+		 * the current component</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmp = *s;</span>
<span class="p_add">+		*s = 0;</span>
<span class="p_add">+		rc = server-&gt;ops-&gt;is_path_accessible(xid, tcon, cifs_sb,</span>
<span class="p_add">+						     full_path);</span>
<span class="p_add">+		*s = tmp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int
 cifs_mount(struct cifs_sb_info *cifs_sb, struct smb_vol *volume_info)
 {
<span class="p_chunk">@@ -3654,6 +3692,16 @@</span> <span class="p_context"> remote_path_check:</span>
 			kfree(full_path);
 			goto mount_fail_check;
 		}
<span class="p_add">+</span>
<span class="p_add">+		rc = cifs_are_all_path_components_accessible(server,</span>
<span class="p_add">+							     xid, tcon, cifs_sb,</span>
<span class="p_add">+							     full_path);</span>
<span class="p_add">+		if (rc != 0) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;cannot query dirs between root and final path, &quot;</span>
<span class="p_add">+				 &quot;enabling CIFS_MOUNT_USE_PREFIX_PATH\n&quot;);</span>
<span class="p_add">+			cifs_sb-&gt;mnt_cifs_flags |= CIFS_MOUNT_USE_PREFIX_PATH;</span>
<span class="p_add">+			rc = 0;</span>
<span class="p_add">+		}</span>
 		kfree(full_path);
 	}
 
<span class="p_chunk">@@ -3923,6 +3971,7 @@</span> <span class="p_context"> cifs_umount(struct cifs_sb_info *cifs_sb)</span>
 
 	bdi_destroy(&amp;cifs_sb-&gt;bdi);
 	kfree(cifs_sb-&gt;mountdata);
<span class="p_add">+	kfree(cifs_sb-&gt;prepath);</span>
 	call_rcu(&amp;cifs_sb-&gt;rcu, delayed_free);
 }
 
<span class="p_header">diff --git a/fs/cifs/dir.c b/fs/cifs/dir.c</span>
<span class="p_header">index c3eb998a99bd..26a3b389a265 100644</span>
<span class="p_header">--- a/fs/cifs/dir.c</span>
<span class="p_header">+++ b/fs/cifs/dir.c</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 	struct dentry *temp;
 	int namelen;
 	int dfsplen;
<span class="p_add">+	int pplen = 0;</span>
 	char *full_path;
 	char dirsep;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(direntry-&gt;d_sb);
<span class="p_chunk">@@ -95,8 +96,12 @@</span> <span class="p_context"> build_path_from_dentry(struct dentry *direntry)</span>
 		dfsplen = strnlen(tcon-&gt;treeName, MAX_TREE_SIZE + 1);
 	else
 		dfsplen = 0;
<span class="p_add">+</span>
<span class="p_add">+	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+		pplen = cifs_sb-&gt;prepath ? strlen(cifs_sb-&gt;prepath) + 1 : 0;</span>
<span class="p_add">+</span>
 cifs_bp_rename_retry:
<span class="p_del">-	namelen = dfsplen;</span>
<span class="p_add">+	namelen = dfsplen + pplen;</span>
 	seq = read_seqbegin(&amp;rename_lock);
 	rcu_read_lock();
 	for (temp = direntry; !IS_ROOT(temp);) {
<span class="p_chunk">@@ -137,7 +142,7 @@</span> <span class="p_context"> cifs_bp_rename_retry:</span>
 		}
 	}
 	rcu_read_unlock();
<span class="p_del">-	if (namelen != dfsplen || read_seqretry(&amp;rename_lock, seq)) {</span>
<span class="p_add">+	if (namelen != dfsplen + pplen || read_seqretry(&amp;rename_lock, seq)) {</span>
 		cifs_dbg(FYI, &quot;did not end path lookup where expected. namelen=%ddfsplen=%d\n&quot;,
 			 namelen, dfsplen);
 		/* presumably this is only possible if racing with a rename
<span class="p_chunk">@@ -153,6 +158,17 @@</span> <span class="p_context"> cifs_bp_rename_retry:</span>
 	   those safely to &#39;/&#39; if any are found in the middle of the prepath */
 	/* BB test paths to Windows with &#39;/&#39; in the midst of prepath */
 
<span class="p_add">+	if (pplen) {</span>
<span class="p_add">+		int i;</span>
<span class="p_add">+</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;using cifs_sb prepath &lt;%s&gt;\n&quot;, cifs_sb-&gt;prepath);</span>
<span class="p_add">+		memcpy(full_path+dfsplen+1, cifs_sb-&gt;prepath, pplen-1);</span>
<span class="p_add">+		full_path[dfsplen] = &#39;\\&#39;;</span>
<span class="p_add">+		for (i = 0; i &lt; pplen-1; i++)</span>
<span class="p_add">+			if (full_path[dfsplen+1+i] == &#39;/&#39;)</span>
<span class="p_add">+				full_path[dfsplen+1+i] = CIFS_DIR_SEP(cifs_sb);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (dfsplen) {
 		strncpy(full_path, tcon-&gt;treeName, dfsplen);
 		if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_POSIX_PATHS) {
<span class="p_chunk">@@ -229,6 +245,13 @@</span> <span class="p_context"> cifs_do_create(struct inode *inode, struct dentry *direntry, unsigned int xid,</span>
 				goto cifs_create_get_file_info;
 			}
 
<span class="p_add">+			if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+				CIFSSMBClose(xid, tcon, fid-&gt;netfid);</span>
<span class="p_add">+				iput(newinode);</span>
<span class="p_add">+				rc = -EISDIR;</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			if (!S_ISREG(newinode-&gt;i_mode)) {
 				/*
 				 * The server may allow us to open things like
<span class="p_chunk">@@ -399,10 +422,14 @@</span> <span class="p_context"> cifs_create_set_dentry:</span>
 	if (rc != 0) {
 		cifs_dbg(FYI, &quot;Create worked, get_inode_info failed rc = %d\n&quot;,
 			 rc);
<span class="p_del">-		if (server-&gt;ops-&gt;close)</span>
<span class="p_del">-			server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_err;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (S_ISDIR(newinode-&gt;i_mode)) {</span>
<span class="p_add">+		rc = -EISDIR;</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	d_drop(direntry);
 	d_add(direntry, newinode);
 
<span class="p_chunk">@@ -410,6 +437,13 @@</span> <span class="p_context"> out:</span>
 	kfree(buf);
 	kfree(full_path);
 	return rc;
<span class="p_add">+</span>
<span class="p_add">+out_err:</span>
<span class="p_add">+	if (server-&gt;ops-&gt;close)</span>
<span class="p_add">+		server-&gt;ops-&gt;close(xid, tcon, fid);</span>
<span class="p_add">+	if (newinode)</span>
<span class="p_add">+		iput(newinode);</span>
<span class="p_add">+	goto out;</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/inode.c b/fs/cifs/inode.c</span>
<span class="p_header">index a329f5ba35aa..9cdeb0293267 100644</span>
<span class="p_header">--- a/fs/cifs/inode.c</span>
<span class="p_header">+++ b/fs/cifs/inode.c</span>
<span class="p_chunk">@@ -982,10 +982,26 @@</span> <span class="p_context"> struct inode *cifs_root_iget(struct super_block *sb)</span>
 	struct inode *inode = NULL;
 	long rc;
 	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);
<span class="p_add">+	char *path = NULL;</span>
<span class="p_add">+	int len;</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_USE_PREFIX_PATH)</span>
<span class="p_add">+	    &amp;&amp; cifs_sb-&gt;prepath) {</span>
<span class="p_add">+		len = strlen(cifs_sb-&gt;prepath);</span>
<span class="p_add">+		path = kzalloc(len + 2 /* leading sep + null */, GFP_KERNEL);</span>
<span class="p_add">+		if (path == NULL)</span>
<span class="p_add">+			return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+		path[0] = &#39;/&#39;;</span>
<span class="p_add">+		memcpy(path+1, cifs_sb-&gt;prepath, len);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		path = kstrdup(&quot;&quot;, GFP_KERNEL);</span>
<span class="p_add">+		if (path == NULL)</span>
<span class="p_add">+			return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	}</span>
 
 	xid = get_xid();
 	if (tcon-&gt;unix_ext) {
<span class="p_del">-		rc = cifs_get_inode_info_unix(&amp;inode, &quot;&quot;, sb, xid);</span>
<span class="p_add">+		rc = cifs_get_inode_info_unix(&amp;inode, path, sb, xid);</span>
 		/* some servers mistakenly claim POSIX support */
 		if (rc != -EOPNOTSUPP)
 			goto iget_no_retry;
<span class="p_chunk">@@ -993,7 +1009,8 @@</span> <span class="p_context"> struct inode *cifs_root_iget(struct super_block *sb)</span>
 		tcon-&gt;unix_ext = false;
 	}
 
<span class="p_del">-	rc = cifs_get_inode_info(&amp;inode, &quot;&quot;, NULL, sb, xid, NULL);</span>
<span class="p_add">+	convert_delimiter(path, CIFS_DIR_SEP(cifs_sb));</span>
<span class="p_add">+	rc = cifs_get_inode_info(&amp;inode, path, NULL, sb, xid, NULL);</span>
 
 iget_no_retry:
 	if (!inode) {
<span class="p_chunk">@@ -1022,6 +1039,7 @@</span> <span class="p_context"> iget_no_retry:</span>
 	}
 
 out:
<span class="p_add">+	kfree(path);</span>
 	/* can not call macro free_xid here since in a void func
 	 * TODO: This is no longer true
 	 */
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index 53ccdde6ff18..dd8543caa56e 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -1039,6 +1039,9 @@</span> <span class="p_context"> smb2_new_lease_key(struct cifs_fid *fid)</span>
 	get_random_bytes(fid-&gt;lease_key, SMB2_LEASE_KEY_SIZE);
 }
 
<span class="p_add">+#define SMB2_SYMLINK_STRUCT_SIZE \</span>
<span class="p_add">+	(sizeof(struct smb2_err_rsp) - 1 + sizeof(struct smb2_symlink_err_rsp))</span>
<span class="p_add">+</span>
 static int
 smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,
 		   const char *full_path, char **target_path,
<span class="p_chunk">@@ -1051,7 +1054,10 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 	struct cifs_fid fid;
 	struct smb2_err_rsp *err_buf = NULL;
 	struct smb2_symlink_err_rsp *symlink;
<span class="p_del">-	unsigned int sub_len, sub_offset;</span>
<span class="p_add">+	unsigned int sub_len;</span>
<span class="p_add">+	unsigned int sub_offset;</span>
<span class="p_add">+	unsigned int print_len;</span>
<span class="p_add">+	unsigned int print_offset;</span>
 
 	cifs_dbg(FYI, &quot;%s: path: %s\n&quot;, __func__, full_path);
 
<span class="p_chunk">@@ -1072,11 +1078,33 @@</span> <span class="p_context"> smb2_query_symlink(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		kfree(utf16_path);
 		return -ENOENT;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (le32_to_cpu(err_buf-&gt;ByteCount) &lt; sizeof(struct smb2_symlink_err_rsp) ||</span>
<span class="p_add">+	    get_rfc1002_length(err_buf) + 4 &lt; SMB2_SYMLINK_STRUCT_SIZE) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* open must fail on symlink - reset rc */
 	rc = 0;
 	symlink = (struct smb2_symlink_err_rsp *)err_buf-&gt;ErrorData;
 	sub_len = le16_to_cpu(symlink-&gt;SubstituteNameLength);
 	sub_offset = le16_to_cpu(symlink-&gt;SubstituteNameOffset);
<span class="p_add">+	print_len = le16_to_cpu(symlink-&gt;PrintNameLength);</span>
<span class="p_add">+	print_offset = le16_to_cpu(symlink-&gt;PrintNameOffset);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + sub_offset + sub_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_rfc1002_length(err_buf) + 4 &lt;</span>
<span class="p_add">+			SMB2_SYMLINK_STRUCT_SIZE + print_offset + print_len) {</span>
<span class="p_add">+		kfree(utf16_path);</span>
<span class="p_add">+		return -ENOENT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	*target_path = cifs_strndup_from_utf16(
 				(char *)symlink-&gt;PathBuffer + sub_offset,
 				sub_len, true, cifs_sb-&gt;local_nls);
<span class="p_header">diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c</span>
<span class="p_header">index 36345fefa3ff..2d964ce45606 100644</span>
<span class="p_header">--- a/fs/jbd2/commit.c</span>
<span class="p_header">+++ b/fs/jbd2/commit.c</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> static int journal_submit_commit_record(journal_t *journal,</span>
 	struct commit_header *tmp;
 	struct buffer_head *bh;
 	int ret;
<span class="p_del">-	struct timespec now = current_kernel_time();</span>
<span class="p_add">+	struct timespec64 now = current_kernel_time64();</span>
 
 	*cbh = NULL;
 
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index 7b9316406930..7a9b6e347249 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -1261,6 +1261,9 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 	dprintk(&quot;NFS:       nfs_updatepage(%pD2 %d@%lld)\n&quot;,
 		file, count, (long long)(page_file_offset(page) + offset));
 
<span class="p_add">+	if (!count)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (nfs_can_extend_write(file, page, inode)) {
 		count = max(count + offset, nfs_page_length(page));
 		offset = 0;
<span class="p_chunk">@@ -1271,7 +1274,7 @@</span> <span class="p_context"> int nfs_updatepage(struct file *file, struct page *page,</span>
 		nfs_set_pageerror(page);
 	else
 		__set_page_dirty_nobuffers(page);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	dprintk(&quot;NFS:       nfs_updatepage returns %d (isize %lld)\n&quot;,
 			status, (long long)i_size_read(inode));
 	return status;
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index ed2f64ca49de..f7ea624780a7 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -4882,6 +4882,32 @@</span> <span class="p_context"> nfsd4_test_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 	return nfs_ok;
 }
 
<span class="p_add">+static __be32</span>
<span class="p_add">+nfsd4_free_lock_stateid(stateid_t *stateid, struct nfs4_stid *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nfs4_ol_stateid *stp = openlockstateid(s);</span>
<span class="p_add">+	__be32 ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = check_stateid_generation(stateid, &amp;s-&gt;sc_stateid, 1);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = nfserr_locks_held;</span>
<span class="p_add">+	if (check_for_locks(stp-&gt;st_stid.sc_file,</span>
<span class="p_add">+			    lockowner(stp-&gt;st_stateowner)))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	release_lock_stateid(stp);</span>
<span class="p_add">+	ret = nfs_ok;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;stp-&gt;st_mutex);</span>
<span class="p_add">+	nfs4_put_stid(s);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 __be32
 nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,
 		   struct nfsd4_free_stateid *free_stateid)
<span class="p_chunk">@@ -4889,7 +4915,6 @@</span> <span class="p_context"> nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 	stateid_t *stateid = &amp;free_stateid-&gt;fr_stateid;
 	struct nfs4_stid *s;
 	struct nfs4_delegation *dp;
<span class="p_del">-	struct nfs4_ol_stateid *stp;</span>
 	struct nfs4_client *cl = cstate-&gt;session-&gt;se_client;
 	__be32 ret = nfserr_bad_stateid;
 
<span class="p_chunk">@@ -4908,18 +4933,9 @@</span> <span class="p_context"> nfsd4_free_stateid(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 		ret = nfserr_locks_held;
 		break;
 	case NFS4_LOCK_STID:
<span class="p_del">-		ret = check_stateid_generation(stateid, &amp;s-&gt;sc_stateid, 1);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		stp = openlockstateid(s);</span>
<span class="p_del">-		ret = nfserr_locks_held;</span>
<span class="p_del">-		if (check_for_locks(stp-&gt;st_stid.sc_file,</span>
<span class="p_del">-				    lockowner(stp-&gt;st_stateowner)))</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		WARN_ON(!unhash_lock_stateid(stp));</span>
<span class="p_add">+		atomic_inc(&amp;s-&gt;sc_count);</span>
 		spin_unlock(&amp;cl-&gt;cl_lock);
<span class="p_del">-		nfs4_put_stid(s);</span>
<span class="p_del">-		ret = nfs_ok;</span>
<span class="p_add">+		ret = nfsd4_free_lock_stateid(stateid, s);</span>
 		goto out;
 	case NFS4_REVOKED_DELEG_STID:
 		dp = delegstateid(s);
<span class="p_chunk">@@ -5486,7 +5502,7 @@</span> <span class="p_context"> static __be32</span>
 lookup_or_create_lock_state(struct nfsd4_compound_state *cstate,
 			    struct nfs4_ol_stateid *ost,
 			    struct nfsd4_lock *lock,
<span class="p_del">-			    struct nfs4_ol_stateid **lst, bool *new)</span>
<span class="p_add">+			    struct nfs4_ol_stateid **plst, bool *new)</span>
 {
 	__be32 status;
 	struct nfs4_file *fi = ost-&gt;st_stid.sc_file;
<span class="p_chunk">@@ -5494,7 +5510,9 @@</span> <span class="p_context"> lookup_or_create_lock_state(struct nfsd4_compound_state *cstate,</span>
 	struct nfs4_client *cl = oo-&gt;oo_owner.so_client;
 	struct inode *inode = d_inode(cstate-&gt;current_fh.fh_dentry);
 	struct nfs4_lockowner *lo;
<span class="p_add">+	struct nfs4_ol_stateid *lst;</span>
 	unsigned int strhashval;
<span class="p_add">+	bool hashed;</span>
 
 	lo = find_lockowner_str(cl, &amp;lock-&gt;lk_new_owner);
 	if (!lo) {
<span class="p_chunk">@@ -5510,12 +5528,27 @@</span> <span class="p_context"> lookup_or_create_lock_state(struct nfsd4_compound_state *cstate,</span>
 			goto out;
 	}
 
<span class="p_del">-	*lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);</span>
<span class="p_del">-	if (*lst == NULL) {</span>
<span class="p_add">+retry:</span>
<span class="p_add">+	lst = find_or_create_lock_stateid(lo, fi, inode, ost, new);</span>
<span class="p_add">+	if (lst == NULL) {</span>
 		status = nfserr_jukebox;
 		goto out;
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;lst-&gt;st_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* See if it&#39;s still hashed to avoid race with FREE_STATEID */</span>
<span class="p_add">+	spin_lock(&amp;cl-&gt;cl_lock);</span>
<span class="p_add">+	hashed = !list_empty(&amp;lst-&gt;st_perfile);</span>
<span class="p_add">+	spin_unlock(&amp;cl-&gt;cl_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!hashed) {</span>
<span class="p_add">+		mutex_unlock(&amp;lst-&gt;st_mutex);</span>
<span class="p_add">+		nfs4_put_stid(&amp;lst-&gt;st_stid);</span>
<span class="p_add">+		goto retry;</span>
<span class="p_add">+	}</span>
 	status = nfs_ok;
<span class="p_add">+	*plst = lst;</span>
 out:
 	nfs4_put_stateowner(&amp;lo-&gt;lo_owner);
 	return status;
<span class="p_chunk">@@ -5582,8 +5615,6 @@</span> <span class="p_context"> nfsd4_lock(struct svc_rqst *rqstp, struct nfsd4_compound_state *cstate,</span>
 			goto out;
 		status = lookup_or_create_lock_state(cstate, open_stp, lock,
 							&amp;lock_stp, &amp;new);
<span class="p_del">-		if (status == nfs_ok)</span>
<span class="p_del">-			mutex_lock(&amp;lock_stp-&gt;st_mutex);</span>
 	} else {
 		status = nfs4_preprocess_seqid_op(cstate,
 				       lock-&gt;lk_old_lock_seqid,
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index a1acc6004a91..70a7bbe199d0 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -376,7 +376,8 @@</span> <span class="p_context"> static struct ovl_entry *ovl_alloc_entry(unsigned int numlower)</span>
 static bool ovl_dentry_remote(struct dentry *dentry)
 {
 	return dentry-&gt;d_flags &amp;
<span class="p_del">-		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE);</span>
<span class="p_add">+		(DCACHE_OP_REVALIDATE | DCACHE_OP_WEAK_REVALIDATE |</span>
<span class="p_add">+		 DCACHE_OP_REAL);</span>
 }
 
 static bool ovl_dentry_weird(struct dentry *dentry)
<span class="p_header">diff --git a/include/linux/backing-dev-defs.h b/include/linux/backing-dev-defs.h</span>
<span class="p_header">index 1b4d69f68c33..140c29635069 100644</span>
<span class="p_header">--- a/include/linux/backing-dev-defs.h</span>
<span class="p_header">+++ b/include/linux/backing-dev-defs.h</span>
<span class="p_chunk">@@ -163,6 +163,7 @@</span> <span class="p_context"> struct backing_dev_info {</span>
 	wait_queue_head_t wb_waitq;
 
 	struct device *dev;
<span class="p_add">+	struct device *owner;</span>
 
 	struct timer_list laptop_mode_wb_timer;
 
<span class="p_header">diff --git a/include/linux/backing-dev.h b/include/linux/backing-dev.h</span>
<span class="p_header">index c82794f20110..89d3de3e096b 100644</span>
<span class="p_header">--- a/include/linux/backing-dev.h</span>
<span class="p_header">+++ b/include/linux/backing-dev.h</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"> __printf(3, 4)</span>
 int bdi_register(struct backing_dev_info *bdi, struct device *parent,
 		const char *fmt, ...);
 int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev);
<span class="p_add">+int bdi_register_owner(struct backing_dev_info *bdi, struct device *owner);</span>
 void bdi_unregister(struct backing_dev_info *bdi);
 
 int __must_check bdi_setup_and_register(struct backing_dev_info *, char *);
<span class="p_header">diff --git a/include/linux/bio.h b/include/linux/bio.h</span>
<span class="p_header">index fbe47bc700bd..42e4e3cbb001 100644</span>
<span class="p_header">--- a/include/linux/bio.h</span>
<span class="p_header">+++ b/include/linux/bio.h</span>
<span class="p_chunk">@@ -527,11 +527,14 @@</span> <span class="p_context"> extern unsigned int bvec_nr_vecs(unsigned short idx);</span>
 int bio_associate_blkcg(struct bio *bio, struct cgroup_subsys_state *blkcg_css);
 int bio_associate_current(struct bio *bio);
 void bio_disassociate_task(struct bio *bio);
<span class="p_add">+void bio_clone_blkcg_association(struct bio *dst, struct bio *src);</span>
 #else	/* CONFIG_BLK_CGROUP */
 static inline int bio_associate_blkcg(struct bio *bio,
 			struct cgroup_subsys_state *blkcg_css) { return 0; }
 static inline int bio_associate_current(struct bio *bio) { return -ENOENT; }
 static inline void bio_disassociate_task(struct bio *bio) { }
<span class="p_add">+static inline void bio_clone_blkcg_association(struct bio *dst,</span>
<span class="p_add">+			struct bio *src) { }</span>
 #endif	/* CONFIG_BLK_CGROUP */
 
 #ifdef CONFIG_HIGHMEM
<span class="p_header">diff --git a/include/linux/mlx5/qp.h b/include/linux/mlx5/qp.h</span>
<span class="p_header">index f079fb1a31f7..a8786d27ab81 100644</span>
<span class="p_header">--- a/include/linux/mlx5/qp.h</span>
<span class="p_header">+++ b/include/linux/mlx5/qp.h</span>
<span class="p_chunk">@@ -160,6 +160,7 @@</span> <span class="p_context"> enum {</span>
 enum {
 	MLX5_FENCE_MODE_NONE			= 0 &lt;&lt; 5,
 	MLX5_FENCE_MODE_INITIATOR_SMALL		= 1 &lt;&lt; 5,
<span class="p_add">+	MLX5_FENCE_MODE_FENCE			= 2 &lt;&lt; 5,</span>
 	MLX5_FENCE_MODE_STRONG_ORDERING		= 3 &lt;&lt; 5,
 	MLX5_FENCE_MODE_SMALL_AND_FENCE		= 4 &lt;&lt; 5,
 };
<span class="p_chunk">@@ -534,9 +535,9 @@</span> <span class="p_context"> struct mlx5_destroy_qp_mbox_out {</span>
 struct mlx5_modify_qp_mbox_in {
 	struct mlx5_inbox_hdr	hdr;
 	__be32			qpn;
<span class="p_del">-	u8			rsvd1[4];</span>
<span class="p_del">-	__be32			optparam;</span>
 	u8			rsvd0[4];
<span class="p_add">+	__be32			optparam;</span>
<span class="p_add">+	u8			rsvd1[4];</span>
 	struct mlx5_qp_context	ctx;
 };
 
<span class="p_header">diff --git a/include/target/target_core_backend.h b/include/target/target_core_backend.h</span>
<span class="p_header">index 28ee5c2e6bcd..711322a8ee35 100644</span>
<span class="p_header">--- a/include/target/target_core_backend.h</span>
<span class="p_header">+++ b/include/target/target_core_backend.h</span>
<span class="p_chunk">@@ -96,6 +96,6 @@</span> <span class="p_context"> sense_reason_t passthrough_parse_cdb(struct se_cmd *cmd,</span>
 bool target_sense_desc_format(struct se_device *dev);
 sector_t target_to_linux_sector(struct se_device *dev, sector_t lb);
 bool target_configure_unmap_from_queue(struct se_dev_attrib *attrib,
<span class="p_del">-				       struct request_queue *q, int block_size);</span>
<span class="p_add">+				       struct request_queue *q);</span>
 
 #endif /* TARGET_CORE_BACKEND_H */
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index 689f4d207122..59081c73b296 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> enum se_cmd_flags_table {</span>
 	SCF_COMPARE_AND_WRITE_POST	= 0x00100000,
 	SCF_PASSTHROUGH_PROT_SG_TO_MEM_NOALLOC = 0x00200000,
 	SCF_ACK_KREF			= 0x00400000,
<span class="p_add">+	SCF_TASK_ATTR_SET		= 0x01000000,</span>
 };
 
 /* struct se_dev_entry-&gt;lun_flags and struct se_lun-&gt;lun_access */
<span class="p_header">diff --git a/include/target/target_core_fabric.h b/include/target/target_core_fabric.h</span>
<span class="p_header">index 7fb2557a760e..ce9ea736f1d7 100644</span>
<span class="p_header">--- a/include/target/target_core_fabric.h</span>
<span class="p_header">+++ b/include/target/target_core_fabric.h</span>
<span class="p_chunk">@@ -163,7 +163,6 @@</span> <span class="p_context"> int	core_tmr_alloc_req(struct se_cmd *, void *, u8, gfp_t);</span>
 void	core_tmr_release_req(struct se_tmr_req *);
 int	transport_generic_handle_tmr(struct se_cmd *);
 void	transport_generic_request_failure(struct se_cmd *, sense_reason_t);
<span class="p_del">-void	__target_execute_cmd(struct se_cmd *);</span>
 int	transport_lookup_tmr_lun(struct se_cmd *, u64);
 void	core_allocate_nexus_loss_ua(struct se_node_acl *acl);
 
<span class="p_header">diff --git a/include/trace/events/sunrpc.h b/include/trace/events/sunrpc.h</span>
<span class="p_header">index 003dca933803..5664ca07c9c7 100644</span>
<span class="p_header">--- a/include/trace/events/sunrpc.h</span>
<span class="p_header">+++ b/include/trace/events/sunrpc.h</span>
<span class="p_chunk">@@ -529,20 +529,27 @@</span> <span class="p_context"> TRACE_EVENT(svc_xprt_do_enqueue,</span>
 
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
<span class="p_del">-		__field_struct(struct sockaddr_storage, ss)</span>
 		__field(int, pid)
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, xprt != NULL ?</span>
<span class="p_add">+			xprt-&gt;xpt_remotelen : 0)</span>
 	),
 
 	TP_fast_assign(
 		__entry-&gt;xprt = xprt;
<span class="p_del">-		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
 		__entry-&gt;pid = rqst? rqst-&gt;rq_task-&gt;pid : 0;
<span class="p_del">-		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
<span class="p_add">+		if (xprt) {</span>
<span class="p_add">+			memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+				&amp;xprt-&gt;xpt_remote,</span>
<span class="p_add">+				xprt-&gt;xpt_remotelen);</span>
<span class="p_add">+			__entry-&gt;flags = xprt-&gt;xpt_flags;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			__entry-&gt;flags = 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp pid=%d flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__get_dynamic_array_len(addr) != 0 ?</span>
<span class="p_add">+			(struct sockaddr *)__get_dynamic_array(addr) : NULL,</span>
 		__entry-&gt;pid, show_svc_xprt_flags(__entry-&gt;flags))
 );
 
<span class="p_chunk">@@ -553,18 +560,25 @@</span> <span class="p_context"> TRACE_EVENT(svc_xprt_dequeue,</span>
 
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
<span class="p_del">-		__field_struct(struct sockaddr_storage, ss)</span>
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, xprt != NULL ?</span>
<span class="p_add">+			xprt-&gt;xpt_remotelen : 0)</span>
 	),
 
 	TP_fast_assign(
<span class="p_del">-		__entry-&gt;xprt = xprt,</span>
<span class="p_del">-		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
<span class="p_del">-		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
<span class="p_add">+		__entry-&gt;xprt = xprt;</span>
<span class="p_add">+		if (xprt) {</span>
<span class="p_add">+			memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+					&amp;xprt-&gt;xpt_remote,</span>
<span class="p_add">+					xprt-&gt;xpt_remotelen);</span>
<span class="p_add">+			__entry-&gt;flags = xprt-&gt;xpt_flags;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			__entry-&gt;flags = 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__get_dynamic_array_len(addr) != 0 ?</span>
<span class="p_add">+			(struct sockaddr *)__get_dynamic_array(addr) : NULL,</span>
 		show_svc_xprt_flags(__entry-&gt;flags))
 );
 
<span class="p_chunk">@@ -592,19 +606,26 @@</span> <span class="p_context"> TRACE_EVENT(svc_handle_xprt,</span>
 	TP_STRUCT__entry(
 		__field(struct svc_xprt *, xprt)
 		__field(int, len)
<span class="p_del">-		__field_struct(struct sockaddr_storage, ss)</span>
 		__field(unsigned long, flags)
<span class="p_add">+		__dynamic_array(unsigned char, addr, xprt != NULL ?</span>
<span class="p_add">+			xprt-&gt;xpt_remotelen : 0)</span>
 	),
 
 	TP_fast_assign(
 		__entry-&gt;xprt = xprt;
<span class="p_del">-		xprt ? memcpy(&amp;__entry-&gt;ss, &amp;xprt-&gt;xpt_remote, sizeof(__entry-&gt;ss)) : memset(&amp;__entry-&gt;ss, 0, sizeof(__entry-&gt;ss));</span>
 		__entry-&gt;len = len;
<span class="p_del">-		__entry-&gt;flags = xprt ? xprt-&gt;xpt_flags : 0;</span>
<span class="p_add">+		if (xprt) {</span>
<span class="p_add">+			memcpy(__get_dynamic_array(addr),</span>
<span class="p_add">+					&amp;xprt-&gt;xpt_remote,</span>
<span class="p_add">+					xprt-&gt;xpt_remotelen);</span>
<span class="p_add">+			__entry-&gt;flags = xprt-&gt;xpt_flags;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+			__entry-&gt;flags = 0;</span>
 	),
 
 	TP_printk(&quot;xprt=0x%p addr=%pIScp len=%d flags=%s&quot;, __entry-&gt;xprt,
<span class="p_del">-		(struct sockaddr *)&amp;__entry-&gt;ss,</span>
<span class="p_add">+		__get_dynamic_array_len(addr) != 0 ?</span>
<span class="p_add">+			(struct sockaddr *)__get_dynamic_array(addr) : NULL,</span>
 		__entry-&gt;len, show_svc_xprt_flags(__entry-&gt;flags))
 );
 #endif /* _TRACE_SUNRPC_H */
<span class="p_header">diff --git a/kernel/auditsc.c b/kernel/auditsc.c</span>
<span class="p_header">index b86cc04959de..48f45987dc6c 100644</span>
<span class="p_header">--- a/kernel/auditsc.c</span>
<span class="p_header">+++ b/kernel/auditsc.c</span>
<span class="p_chunk">@@ -73,6 +73,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/ctype.h&gt;
 #include &lt;linux/string.h&gt;
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
 #include &lt;uapi/linux/limits.h&gt;
 
 #include &quot;audit.h&quot;
<span class="p_chunk">@@ -82,7 +83,8 @@</span> <span class="p_context"></span>
 #define AUDITSC_SUCCESS 1
 #define AUDITSC_FAILURE 2
 
<span class="p_del">-/* no execve audit message should be longer than this (userspace limits) */</span>
<span class="p_add">+/* no execve audit message should be longer than this (userspace limits),</span>
<span class="p_add">+ * see the note near the top of audit_log_execve_info() about this value */</span>
 #define MAX_EXECVE_AUDIT_LEN 7500
 
 /* max length to print of cmdline/proctitle value during audit */
<span class="p_chunk">@@ -988,184 +990,178 @@</span> <span class="p_context"> static int audit_log_pid_context(struct audit_context *context, pid_t pid,</span>
 	return rc;
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * to_send and len_sent accounting are very loose estimates.  We aren&#39;t</span>
<span class="p_del">- * really worried about a hard cap to MAX_EXECVE_AUDIT_LEN so much as being</span>
<span class="p_del">- * within about 500 bytes (next page boundary)</span>
<span class="p_del">- *</span>
<span class="p_del">- * why snprintf?  an int is up to 12 digits long.  if we just assumed when</span>
<span class="p_del">- * logging that a[%d]= was going to be 16 characters long we would be wasting</span>
<span class="p_del">- * space in every audit message.  In one 7500 byte message we can log up to</span>
<span class="p_del">- * about 1000 min size arguments.  That comes down to about 50% waste of space</span>
<span class="p_del">- * if we didn&#39;t do the snprintf to find out how long arg_num_len was.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int audit_log_single_execve_arg(struct audit_context *context,</span>
<span class="p_del">-					struct audit_buffer **ab,</span>
<span class="p_del">-					int arg_num,</span>
<span class="p_del">-					size_t *len_sent,</span>
<span class="p_del">-					const char __user *p,</span>
<span class="p_del">-					char *buf)</span>
<span class="p_add">+static void audit_log_execve_info(struct audit_context *context,</span>
<span class="p_add">+				  struct audit_buffer **ab)</span>
 {
<span class="p_del">-	char arg_num_len_buf[12];</span>
<span class="p_del">-	const char __user *tmp_p = p;</span>
<span class="p_del">-	/* how many digits are in arg_num? 5 is the length of &#39; a=&quot;&quot;&#39; */</span>
<span class="p_del">-	size_t arg_num_len = snprintf(arg_num_len_buf, 12, &quot;%d&quot;, arg_num) + 5;</span>
<span class="p_del">-	size_t len, len_left, to_send;</span>
<span class="p_del">-	size_t max_execve_audit_len = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_del">-	unsigned int i, has_cntl = 0, too_long = 0;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* strnlen_user includes the null we don&#39;t want to send */</span>
<span class="p_del">-	len_left = len = strnlen_user(p, MAX_ARG_STRLEN) - 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We just created this mm, if we can&#39;t find the strings</span>
<span class="p_del">-	 * we just copied into it something is _very_ wrong. Similar</span>
<span class="p_del">-	 * for strings that are too long, we should not have created</span>
<span class="p_del">-	 * any.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (WARN_ON_ONCE(len &lt; 0 || len &gt; MAX_ARG_STRLEN - 1)) {</span>
<span class="p_del">-		send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+	long len_max;</span>
<span class="p_add">+	long len_rem;</span>
<span class="p_add">+	long len_full;</span>
<span class="p_add">+	long len_buf;</span>
<span class="p_add">+	long len_abuf;</span>
<span class="p_add">+	long len_tmp;</span>
<span class="p_add">+	bool require_data;</span>
<span class="p_add">+	bool encode;</span>
<span class="p_add">+	unsigned int iter;</span>
<span class="p_add">+	unsigned int arg;</span>
<span class="p_add">+	char *buf_head;</span>
<span class="p_add">+	char *buf;</span>
<span class="p_add">+	const char __user *p = (const char __user *)current-&gt;mm-&gt;arg_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: this buffer needs to be large enough to hold all the non-arg</span>
<span class="p_add">+	 *       data we put in the audit record for this argument (see the</span>
<span class="p_add">+	 *       code below) ... at this point in time 96 is plenty */</span>
<span class="p_add">+	char abuf[96];</span>
<span class="p_add">+</span>
<span class="p_add">+	/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the</span>
<span class="p_add">+	 *       current value of 7500 is not as important as the fact that it</span>
<span class="p_add">+	 *       is less than 8k, a setting of 7500 gives us plenty of wiggle</span>
<span class="p_add">+	 *       room if we go over a little bit in the logging below */</span>
<span class="p_add">+	WARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN &gt; 7500);</span>
<span class="p_add">+	len_max = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* scratch buffer to hold the userspace args */</span>
<span class="p_add">+	buf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);</span>
<span class="p_add">+	if (!buf_head) {</span>
<span class="p_add">+		audit_panic(&quot;out of memory for argv string&quot;);</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+	buf = buf_head;</span>
 
<span class="p_del">-	/* walk the whole argument looking for non-ascii chars */</span>
<span class="p_add">+	audit_log_format(*ab, &quot;argc=%d&quot;, context-&gt;execve.argc);</span>
<span class="p_add">+</span>
<span class="p_add">+	len_rem = len_max;</span>
<span class="p_add">+	len_buf = 0;</span>
<span class="p_add">+	len_full = 0;</span>
<span class="p_add">+	require_data = true;</span>
<span class="p_add">+	encode = false;</span>
<span class="p_add">+	iter = 0;</span>
<span class="p_add">+	arg = 0;</span>
 	do {
<span class="p_del">-		if (len_left &gt; MAX_EXECVE_AUDIT_LEN)</span>
<span class="p_del">-			to_send = MAX_EXECVE_AUDIT_LEN;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			to_send = len_left;</span>
<span class="p_del">-		ret = copy_from_user(buf, tmp_p, to_send);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * There is no reason for this copy to be short. We just</span>
<span class="p_del">-		 * copied them here, and the mm hasn&#39;t been exposed to user-</span>
<span class="p_del">-		 * space yet.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			WARN_ON(1);</span>
<span class="p_del">-			send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-			return -1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		buf[to_send] = &#39;\0&#39;;</span>
<span class="p_del">-		has_cntl = audit_string_contains_control(buf, to_send);</span>
<span class="p_del">-		if (has_cntl) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * hex messages get logged as 2 bytes, so we can only</span>
<span class="p_del">-			 * send half as much in each message</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			max_execve_audit_len = MAX_EXECVE_AUDIT_LEN / 2;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		len_left -= to_send;</span>
<span class="p_del">-		tmp_p += to_send;</span>
<span class="p_del">-	} while (len_left &gt; 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	len_left = len;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (len &gt; max_execve_audit_len)</span>
<span class="p_del">-		too_long = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* rewalk the argument actually logging the message */</span>
<span class="p_del">-	for (i = 0; len_left &gt; 0; i++) {</span>
<span class="p_del">-		int room_left;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (len_left &gt; max_execve_audit_len)</span>
<span class="p_del">-			to_send = max_execve_audit_len;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			to_send = len_left;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* do we have space left to send this argument in this ab? */</span>
<span class="p_del">-		room_left = MAX_EXECVE_AUDIT_LEN - arg_num_len - *len_sent;</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			room_left -= (to_send * 2);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			room_left -= to_send;</span>
<span class="p_del">-		if (room_left &lt; 0) {</span>
<span class="p_del">-			*len_sent = 0;</span>
<span class="p_del">-			audit_log_end(*ab);</span>
<span class="p_del">-			*ab = audit_log_start(context, GFP_KERNEL, AUDIT_EXECVE);</span>
<span class="p_del">-			if (!*ab)</span>
<span class="p_del">-				return 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* NOTE: we don&#39;t ever want to trust this value for anything</span>
<span class="p_add">+		 *       serious, but the audit record format insists we</span>
<span class="p_add">+		 *       provide an argument length for really long arguments,</span>
<span class="p_add">+		 *       e.g. &gt; MAX_EXECVE_AUDIT_LEN, so we have no choice but</span>
<span class="p_add">+		 *       to use strncpy_from_user() to obtain this value for</span>
<span class="p_add">+		 *       recording in the log, although we don&#39;t use it</span>
<span class="p_add">+		 *       anywhere here to avoid a double-fetch problem */</span>
<span class="p_add">+		if (len_full == 0)</span>
<span class="p_add">+			len_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* read more data from userspace */</span>
<span class="p_add">+		if (require_data) {</span>
<span class="p_add">+			/* can we make more room in the buffer? */</span>
<span class="p_add">+			if (buf != buf_head) {</span>
<span class="p_add">+				memmove(buf_head, buf, len_buf);</span>
<span class="p_add">+				buf = buf_head;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/* fetch as much as we can of the argument */</span>
<span class="p_add">+			len_tmp = strncpy_from_user(&amp;buf_head[len_buf], p,</span>
<span class="p_add">+						    len_max - len_buf);</span>
<span class="p_add">+			if (len_tmp == -EFAULT) {</span>
<span class="p_add">+				/* unable to copy from userspace */</span>
<span class="p_add">+				send_sig(SIGKILL, current, 0);</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+			} else if (len_tmp == (len_max - len_buf)) {</span>
<span class="p_add">+				/* buffer is not large enough */</span>
<span class="p_add">+				require_data = true;</span>
<span class="p_add">+				/* NOTE: if we are going to span multiple</span>
<span class="p_add">+				 *       buffers force the encoding so we stand</span>
<span class="p_add">+				 *       a chance at a sane len_full value and</span>
<span class="p_add">+				 *       consistent record encoding */</span>
<span class="p_add">+				encode = true;</span>
<span class="p_add">+				len_full = len_full * 2;</span>
<span class="p_add">+				p += len_tmp;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				require_data = false;</span>
<span class="p_add">+				if (!encode)</span>
<span class="p_add">+					encode = audit_string_contains_control(</span>
<span class="p_add">+								buf, len_tmp);</span>
<span class="p_add">+				/* try to use a trusted value for len_full */</span>
<span class="p_add">+				if (len_full &lt; len_max)</span>
<span class="p_add">+					len_full = (encode ?</span>
<span class="p_add">+						    len_tmp * 2 : len_tmp);</span>
<span class="p_add">+				p += len_tmp + 1;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			len_buf += len_tmp;</span>
<span class="p_add">+			buf_head[len_buf] = &#39;\0&#39;;</span>
 
<span class="p_del">-		/*</span>
<span class="p_del">-		 * first record needs to say how long the original string was</span>
<span class="p_del">-		 * so we can be sure nothing was lost.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if ((i == 0) &amp;&amp; (too_long))</span>
<span class="p_del">-			audit_log_format(*ab, &quot; a%d_len=%zu&quot;, arg_num,</span>
<span class="p_del">-					 has_cntl ? 2*len : len);</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * normally arguments are small enough to fit and we already</span>
<span class="p_del">-		 * filled buf above when we checked for control characters</span>
<span class="p_del">-		 * so don&#39;t bother with another copy_from_user</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (len &gt;= max_execve_audit_len)</span>
<span class="p_del">-			ret = copy_from_user(buf, p, to_send);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			ret = 0;</span>
<span class="p_del">-		if (ret) {</span>
<span class="p_del">-			WARN_ON(1);</span>
<span class="p_del">-			send_sig(SIGKILL, current, 0);</span>
<span class="p_del">-			return -1;</span>
<span class="p_add">+			/* length of the buffer in the audit record? */</span>
<span class="p_add">+			len_abuf = (encode ? len_buf * 2 : len_buf + 2);</span>
 		}
<span class="p_del">-		buf[to_send] = &#39;\0&#39;;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* actually log it */</span>
<span class="p_del">-		audit_log_format(*ab, &quot; a%d&quot;, arg_num);</span>
<span class="p_del">-		if (too_long)</span>
<span class="p_del">-			audit_log_format(*ab, &quot;[%d]&quot;, i);</span>
<span class="p_del">-		audit_log_format(*ab, &quot;=&quot;);</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			audit_log_n_hex(*ab, buf, to_send);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			audit_log_string(*ab, buf);</span>
<span class="p_del">-</span>
<span class="p_del">-		p += to_send;</span>
<span class="p_del">-		len_left -= to_send;</span>
<span class="p_del">-		*len_sent += arg_num_len;</span>
<span class="p_del">-		if (has_cntl)</span>
<span class="p_del">-			*len_sent += to_send * 2;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			*len_sent += to_send;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	/* include the null we didn&#39;t log */</span>
<span class="p_del">-	return len + 1;</span>
<span class="p_del">-}</span>
 
<span class="p_del">-static void audit_log_execve_info(struct audit_context *context,</span>
<span class="p_del">-				  struct audit_buffer **ab)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, len;</span>
<span class="p_del">-	size_t len_sent = 0;</span>
<span class="p_del">-	const char __user *p;</span>
<span class="p_del">-	char *buf;</span>
<span class="p_add">+		/* write as much as we can to the audit log */</span>
<span class="p_add">+		if (len_buf &gt; 0) {</span>
<span class="p_add">+			/* NOTE: some magic numbers here - basically if we</span>
<span class="p_add">+			 *       can&#39;t fit a reasonable amount of data into the</span>
<span class="p_add">+			 *       existing audit buffer, flush it and start with</span>
<span class="p_add">+			 *       a new buffer */</span>
<span class="p_add">+			if ((sizeof(abuf) + 8) &gt; len_rem) {</span>
<span class="p_add">+				len_rem = len_max;</span>
<span class="p_add">+				audit_log_end(*ab);</span>
<span class="p_add">+				*ab = audit_log_start(context,</span>
<span class="p_add">+						      GFP_KERNEL, AUDIT_EXECVE);</span>
<span class="p_add">+				if (!*ab)</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-	p = (const char __user *)current-&gt;mm-&gt;arg_start;</span>
<span class="p_add">+			/* create the non-arg portion of the arg record */</span>
<span class="p_add">+			len_tmp = 0;</span>
<span class="p_add">+			if (require_data || (iter &gt; 0) ||</span>
<span class="p_add">+			    ((len_abuf + sizeof(abuf)) &gt; len_rem)) {</span>
<span class="p_add">+				if (iter == 0) {</span>
<span class="p_add">+					len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+							sizeof(abuf) - len_tmp,</span>
<span class="p_add">+							&quot; a%d_len=%lu&quot;,</span>
<span class="p_add">+							arg, len_full);</span>
<span class="p_add">+				}</span>
<span class="p_add">+				len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+						    sizeof(abuf) - len_tmp,</span>
<span class="p_add">+						    &quot; a%d[%d]=&quot;, arg, iter++);</span>
<span class="p_add">+			} else</span>
<span class="p_add">+				len_tmp += snprintf(&amp;abuf[len_tmp],</span>
<span class="p_add">+						    sizeof(abuf) - len_tmp,</span>
<span class="p_add">+						    &quot; a%d=&quot;, arg);</span>
<span class="p_add">+			WARN_ON(len_tmp &gt;= sizeof(abuf));</span>
<span class="p_add">+			abuf[sizeof(abuf) - 1] = &#39;\0&#39;;</span>
<span class="p_add">+</span>
<span class="p_add">+			/* log the arg in the audit record */</span>
<span class="p_add">+			audit_log_format(*ab, &quot;%s&quot;, abuf);</span>
<span class="p_add">+			len_rem -= len_tmp;</span>
<span class="p_add">+			len_tmp = len_buf;</span>
<span class="p_add">+			if (encode) {</span>
<span class="p_add">+				if (len_abuf &gt; len_rem)</span>
<span class="p_add">+					len_tmp = len_rem / 2; /* encoding */</span>
<span class="p_add">+				audit_log_n_hex(*ab, buf, len_tmp);</span>
<span class="p_add">+				len_rem -= len_tmp * 2;</span>
<span class="p_add">+				len_abuf -= len_tmp * 2;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				if (len_abuf &gt; len_rem)</span>
<span class="p_add">+					len_tmp = len_rem - 2; /* quotes */</span>
<span class="p_add">+				audit_log_n_string(*ab, buf, len_tmp);</span>
<span class="p_add">+				len_rem -= len_tmp + 2;</span>
<span class="p_add">+				/* don&#39;t subtract the &quot;2&quot; because we still need</span>
<span class="p_add">+				 * to add quotes to the remaining string */</span>
<span class="p_add">+				len_abuf -= len_tmp;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			len_buf -= len_tmp;</span>
<span class="p_add">+			buf += len_tmp;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	audit_log_format(*ab, &quot;argc=%d&quot;, context-&gt;execve.argc);</span>
<span class="p_add">+		/* ready to move to the next argument? */</span>
<span class="p_add">+		if ((len_buf == 0) &amp;&amp; !require_data) {</span>
<span class="p_add">+			arg++;</span>
<span class="p_add">+			iter = 0;</span>
<span class="p_add">+			len_full = 0;</span>
<span class="p_add">+			require_data = true;</span>
<span class="p_add">+			encode = false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (arg &lt; context-&gt;execve.argc);</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * we need some kernel buffer to hold the userspace args.  Just</span>
<span class="p_del">-	 * allocate one big one rather than allocating one of the right size</span>
<span class="p_del">-	 * for every single argument inside audit_log_single_execve_arg()</span>
<span class="p_del">-	 * should be &lt;8k allocation so should be pretty safe.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	buf = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);</span>
<span class="p_del">-	if (!buf) {</span>
<span class="p_del">-		audit_panic(&quot;out of memory for argv string&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* NOTE: the caller handles the final audit_log_end() call */</span>
 
<span class="p_del">-	for (i = 0; i &lt; context-&gt;execve.argc; i++) {</span>
<span class="p_del">-		len = audit_log_single_execve_arg(context, ab, i,</span>
<span class="p_del">-						  &amp;len_sent, p, buf);</span>
<span class="p_del">-		if (len &lt;= 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		p += len;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	kfree(buf);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(buf_head);</span>
 }
 
 static void show_special(struct audit_context *context, int *call_panic)
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index 0e5c71195f18..b14a4f31221f 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -2606,13 +2606,18 @@</span> <span class="p_context"> static inline void kmemleak_load_module(const struct module *mod,</span>
 #endif
 
 #ifdef CONFIG_MODULE_SIG
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	int err = -ENOKEY;
 	const unsigned long markerlen = sizeof(MODULE_SIG_STRING) - 1;
 	const void *mod = info-&gt;hdr;
 
<span class="p_del">-	if (info-&gt;len &gt; markerlen &amp;&amp;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Require flags == 0, as a module with version information</span>
<span class="p_add">+	 * removed is no longer the module that was signed</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (flags == 0 &amp;&amp;</span>
<span class="p_add">+	    info-&gt;len &gt; markerlen &amp;&amp;</span>
 	    memcmp(mod + info-&gt;len - markerlen, MODULE_SIG_STRING, markerlen) == 0) {
 		/* We truncate the module to discard the signature */
 		info-&gt;len -= markerlen;
<span class="p_chunk">@@ -2631,7 +2636,7 @@</span> <span class="p_context"> static int module_sig_check(struct load_info *info)</span>
 	return err;
 }
 #else /* !CONFIG_MODULE_SIG */
<span class="p_del">-static int module_sig_check(struct load_info *info)</span>
<span class="p_add">+static int module_sig_check(struct load_info *info, int flags)</span>
 {
 	return 0;
 }
<span class="p_chunk">@@ -3444,7 +3449,7 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 	long err;
 	char *after_dashes;
 
<span class="p_del">-	err = module_sig_check(info);</span>
<span class="p_add">+	err = module_sig_check(info, flags);</span>
 	if (err)
 		goto free_copy;
 
<span class="p_header">diff --git a/mm/backing-dev.c b/mm/backing-dev.c</span>
<span class="p_header">index cbe6f0b96f29..9ef80bf441b3 100644</span>
<span class="p_header">--- a/mm/backing-dev.c</span>
<span class="p_header">+++ b/mm/backing-dev.c</span>
<span class="p_chunk">@@ -825,6 +825,20 @@</span> <span class="p_context"> int bdi_register_dev(struct backing_dev_info *bdi, dev_t dev)</span>
 }
 EXPORT_SYMBOL(bdi_register_dev);
 
<span class="p_add">+int bdi_register_owner(struct backing_dev_info *bdi, struct device *owner)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = bdi_register(bdi, NULL, &quot;%u:%u&quot;, MAJOR(owner-&gt;devt),</span>
<span class="p_add">+			MINOR(owner-&gt;devt));</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		return rc;</span>
<span class="p_add">+	bdi-&gt;owner = owner;</span>
<span class="p_add">+	get_device(owner);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(bdi_register_owner);</span>
<span class="p_add">+</span>
 /*
  * Remove bdi from bdi_list, and ensure that it is no longer visible
  */
<span class="p_chunk">@@ -849,6 +863,11 @@</span> <span class="p_context"> void bdi_unregister(struct backing_dev_info *bdi)</span>
 		device_unregister(bdi-&gt;dev);
 		bdi-&gt;dev = NULL;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (bdi-&gt;owner) {</span>
<span class="p_add">+		put_device(bdi-&gt;owner);</span>
<span class="p_add">+		bdi-&gt;owner = NULL;</span>
<span class="p_add">+	}</span>
 }
 
 void bdi_exit(struct backing_dev_info *bdi)
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index ef6963b577fd..0c31f184daf8 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -2170,6 +2170,10 @@</span> <span class="p_context"> static unsigned long set_max_huge_pages(struct hstate *h, unsigned long count,</span>
 		 * and reducing the surplus.
 		 */
 		spin_unlock(&amp;hugetlb_lock);
<span class="p_add">+</span>
<span class="p_add">+		/* yield cpu to avoid soft lockup */</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+</span>
 		if (hstate_is_gigantic(h))
 			ret = alloc_fresh_gigantic_page(h, nodes_allowed);
 		else
<span class="p_header">diff --git a/net/bluetooth/l2cap_sock.c b/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">index 1bb551527044..d9bbbded49ef 100644</span>
<span class="p_header">--- a/net/bluetooth/l2cap_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/l2cap_sock.c</span>
<span class="p_chunk">@@ -927,7 +927,7 @@</span> <span class="p_context"> static int l2cap_sock_setsockopt(struct socket *sock, int level, int optname,</span>
 			break;
 		}
 
<span class="p_del">-		if (get_user(opt, (u32 __user *) optval)) {</span>
<span class="p_add">+		if (get_user(opt, (u16 __user *) optval)) {</span>
 			err = -EFAULT;
 			break;
 		}
<span class="p_header">diff --git a/net/netlabel/netlabel_kapi.c b/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">index 28cddc85b700..bfa2b6d5b5cf 100644</span>
<span class="p_header">--- a/net/netlabel/netlabel_kapi.c</span>
<span class="p_header">+++ b/net/netlabel/netlabel_kapi.c</span>
<span class="p_chunk">@@ -824,7 +824,11 @@</span> <span class="p_context"> socket_setattr_return:</span>
  */
 void netlbl_sock_delattr(struct sock *sk)
 {
<span class="p_del">-	cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+	switch (sk-&gt;sk_family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_sock_delattr(sk);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -987,7 +991,11 @@</span> <span class="p_context"> req_setattr_return:</span>
 */
 void netlbl_req_delattr(struct request_sock *req)
 {
<span class="p_del">-	cipso_v4_req_delattr(req);</span>
<span class="p_add">+	switch (req-&gt;rsk_ops-&gt;family) {</span>
<span class="p_add">+	case AF_INET:</span>
<span class="p_add">+		cipso_v4_req_delattr(req);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/scripts/recordmcount.c b/scripts/recordmcount.c</span>
<span class="p_header">index e167592793a7..42396a74405d 100644</span>
<span class="p_header">--- a/scripts/recordmcount.c</span>
<span class="p_header">+++ b/scripts/recordmcount.c</span>
<span class="p_chunk">@@ -33,10 +33,17 @@</span> <span class="p_context"></span>
 #include &lt;string.h&gt;
 #include &lt;unistd.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * glibc synced up and added the metag number but didn&#39;t add the relocations.</span>
<span class="p_add">+ * Work around this in a crude manner for now.</span>
<span class="p_add">+ */</span>
 #ifndef EM_METAG
<span class="p_del">-/* Remove this when these make it to the standard system elf.h. */</span>
 #define EM_METAG      174
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_ADDR32</span>
 #define R_METAG_ADDR32                   2
<span class="p_add">+#endif</span>
<span class="p_add">+#ifndef R_METAG_NONE</span>
 #define R_METAG_NONE                     3
 #endif
 
<span class="p_header">diff --git a/sound/hda/array.c b/sound/hda/array.c</span>
<span class="p_header">index 516795baa7db..5dfa610e4471 100644</span>
<span class="p_header">--- a/sound/hda/array.c</span>
<span class="p_header">+++ b/sound/hda/array.c</span>
<span class="p_chunk">@@ -21,13 +21,15 @@</span> <span class="p_context"> void *snd_array_new(struct snd_array *array)</span>
 		return NULL;
 	if (array-&gt;used &gt;= array-&gt;alloced) {
 		int num = array-&gt;alloced + array-&gt;alloc_align;
<span class="p_add">+		int oldsize = array-&gt;alloced * array-&gt;elem_size;</span>
 		int size = (num + 1) * array-&gt;elem_size;
 		void *nlist;
 		if (snd_BUG_ON(num &gt;= 4096))
 			return NULL;
<span class="p_del">-		nlist = krealloc(array-&gt;list, size, GFP_KERNEL | __GFP_ZERO);</span>
<span class="p_add">+		nlist = krealloc(array-&gt;list, size, GFP_KERNEL);</span>
 		if (!nlist)
 			return NULL;
<span class="p_add">+		memset(nlist + oldsize, 0, size - oldsize);</span>
 		array-&gt;list = nlist;
 		array-&gt;alloced = num;
 	}
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 8218cace8fea..e769e5764cba 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2288,6 +2288,8 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	{ PCI_DEVICE(0x1022, 0x780d),
 	  .driver_data = AZX_DRIVER_GENERIC | AZX_DCAPS_PRESET_ATI_SB },
 	/* ATI HDMI */
<span class="p_add">+	{ PCI_DEVICE(0x1002, 0x0002),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },</span>
 	{ PCI_DEVICE(0x1002, 0x1308),
 	  .driver_data = AZX_DRIVER_ATIHDMI_NS | AZX_DCAPS_PRESET_ATI_HDMI_NS },
 	{ PCI_DEVICE(0x1002, 0x157a),
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index abcb5a6a1cd9..f25479ba3981 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4674,6 +4674,22 @@</span> <span class="p_context"> static void alc290_fixup_mono_speakers(struct hda_codec *codec,</span>
 	}
 }
 
<span class="p_add">+static void alc298_fixup_speaker_volume(struct hda_codec *codec,</span>
<span class="p_add">+					const struct hda_fixup *fix, int action)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (action == HDA_FIXUP_ACT_PRE_PROBE) {</span>
<span class="p_add">+		/* The speaker is routed to the Node 0x06 by a mistake, as a result</span>
<span class="p_add">+		   we can&#39;t adjust the speaker&#39;s volume since this node does not has</span>
<span class="p_add">+		   Amp-out capability. we change the speaker&#39;s route to:</span>
<span class="p_add">+		   Node 0x02 (Audio Output) -&gt; Node 0x0c (Audio Mixer) -&gt; Node 0x17 (</span>
<span class="p_add">+		   Pin Complex), since Node 0x02 has Amp-out caps, we can adjust</span>
<span class="p_add">+		   speaker&#39;s volume now. */</span>
<span class="p_add">+</span>
<span class="p_add">+		hda_nid_t conn1[1] = { 0x0c };</span>
<span class="p_add">+		snd_hda_override_conn_list(codec, 0x17, 1, conn1);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Hook to update amp GPIO4 for automute */
 static void alc280_hp_gpio4_automute_hook(struct hda_codec *codec,
 					  struct hda_jack_callback *jack)
<span class="p_chunk">@@ -4823,6 +4839,7 @@</span> <span class="p_context"> enum {</span>
 	ALC280_FIXUP_HP_HEADSET_MIC,
 	ALC221_FIXUP_HP_FRONT_MIC,
 	ALC292_FIXUP_TPT460,
<span class="p_add">+	ALC298_FIXUP_SPK_VOLUME,</span>
 };
 
 static const struct hda_fixup alc269_fixups[] = {
<span class="p_chunk">@@ -5478,6 +5495,12 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC293_FIXUP_LENOVO_SPK_NOISE,
 	},
<span class="p_add">+	[ALC298_FIXUP_SPK_VOLUME] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_FUNC,</span>
<span class="p_add">+		.v.func = alc298_fixup_speaker_volume,</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC298_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc269_fixup_tbl[] = {
<span class="p_chunk">@@ -5524,6 +5547,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x1028, 0x0704, &quot;Dell XPS 13 9350&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),
 	SND_PCI_QUIRK(0x1028, 0x0725, &quot;Dell Inspiron 3162&quot;, ALC255_FIXUP_DELL_SPK_NOISE),
 	SND_PCI_QUIRK(0x1028, 0x075b, &quot;Dell XPS 13 9360&quot;, ALC256_FIXUP_DELL_XPS_13_HEADPHONE_NOISE),
<span class="p_add">+	SND_PCI_QUIRK(0x1028, 0x075d, &quot;Dell AIO&quot;, ALC298_FIXUP_SPK_VOLUME),</span>
 	SND_PCI_QUIRK(0x1028, 0x164a, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x1028, 0x164b, &quot;Dell&quot;, ALC293_FIXUP_DELL1_MIC_NO_PRESENCE),
 	SND_PCI_QUIRK(0x103c, 0x1586, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC2),
<span class="p_chunk">@@ -5799,6 +5823,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x1b, 0x01014020},
 		{0x21, 0x0221103f}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x1b, 0x02011020},</span>
<span class="p_add">+		{0x21, 0x0221103f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x14, 0x90170150},
 		{0x1b, 0x02011020},
 		{0x21, 0x0221105f}),
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 510df220d1b5..336ed267c407 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -142,6 +142,7 @@</span> <span class="p_context"> int vcpu_load(struct kvm_vcpu *vcpu)</span>
 	put_cpu();
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_load);</span>
 
 void vcpu_put(struct kvm_vcpu *vcpu)
 {
<span class="p_chunk">@@ -151,6 +152,7 @@</span> <span class="p_context"> void vcpu_put(struct kvm_vcpu *vcpu)</span>
 	preempt_enable();
 	mutex_unlock(&amp;vcpu-&gt;mutex);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(vcpu_put);</span>
 
 static void ack_flush(void *_completed)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



