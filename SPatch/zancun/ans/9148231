
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.14.71 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.14.71</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 1, 2016, 9:45 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160601214512.GB19005@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9148231/mbox/"
   >mbox</a>
|
   <a href="/patch/9148231/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9148231/">/patch/9148231/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	5337460751 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  1 Jun 2016 21:45:34 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 450582712D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  1 Jun 2016 21:45:34 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 39C262714B; Wed,  1 Jun 2016 21:45:34 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C6DE12712D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  1 Jun 2016 21:45:32 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752467AbcFAVpY (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 1 Jun 2016 17:45:24 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:42789 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752324AbcFAVpS (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 1 Jun 2016 17:45:18 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id B4E4B86;
	Wed,  1 Jun 2016 21:45:12 +0000 (UTC)
Date: Wed, 1 Jun 2016 14:45:12 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.14.71
Message-ID: &lt;20160601214512.GB19005@kroah.com&gt;
References: &lt;20160601214502.GA19005@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160601214502.GA19005@kroah.com&gt;
User-Agent: Mutt/1.6.1 (2016-04-27)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 1, 2016, 9:45 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index bc3311a0893b..98282e65bb46 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 70</span>
<span class="p_add">+SUBLEVEL = 71</span>
 EXTRAVERSION =
 NAME = Remembering Coco
 
<span class="p_header">diff --git a/arch/arm/kvm/mmu.c b/arch/arm/kvm/mmu.c</span>
<span class="p_header">index c612e37166ad..2036f191c56f 100644</span>
<span class="p_header">--- a/arch/arm/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/arm/kvm/mmu.c</span>
<span class="p_chunk">@@ -682,11 +682,14 @@</span> <span class="p_context"> static int stage2_set_pmd_huge(struct kvm *kvm, struct kvm_mmu_memory_cache</span>
 	VM_BUG_ON(pmd_present(*pmd) &amp;&amp; pmd_pfn(*pmd) != pmd_pfn(*new_pmd));
 
 	old_pmd = *pmd;
<span class="p_del">-	kvm_set_pmd(pmd, *new_pmd);</span>
<span class="p_del">-	if (pmd_present(old_pmd))</span>
<span class="p_add">+	if (pmd_present(old_pmd)) {</span>
<span class="p_add">+		pmd_clear(pmd);</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pmd));
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kvm_set_pmd(pmd, *new_pmd);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -723,12 +726,14 @@</span> <span class="p_context"> static int stage2_set_pte(struct kvm *kvm, struct kvm_mmu_memory_cache *cache,</span>
 
 	/* Create 2nd stage page table mapping - Level 3 */
 	old_pte = *pte;
<span class="p_del">-	kvm_set_pte(pte, *new_pte);</span>
<span class="p_del">-	if (pte_present(old_pte))</span>
<span class="p_add">+	if (pte_present(old_pte)) {</span>
<span class="p_add">+		kvm_set_pte(pte, __pte(0));</span>
 		kvm_tlb_flush_vmid_ipa(kvm, addr);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		get_page(virt_to_page(pte));
<span class="p_add">+	}</span>
 
<span class="p_add">+	kvm_set_pte(pte, *new_pte);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index 726c969b8a81..f83020db593a 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -138,7 +138,7 @@</span> <span class="p_context"> static struct osi_linux {</span>
 	unsigned int	enable:1;
 	unsigned int	dmi:1;
 	unsigned int	cmdline:1;
<span class="p_del">-	unsigned int	default_disabling:1;</span>
<span class="p_add">+	u8		default_disabling;</span>
 } osi_linux = {0, 0, 0, 0};
 
 static u32 acpi_osi_handler(acpi_string interface, u32 supported)
<span class="p_chunk">@@ -1420,10 +1420,13 @@</span> <span class="p_context"> void __init acpi_osi_setup(char *str)</span>
 	if (*str == &#39;!&#39;) {
 		str++;
 		if (*str == &#39;\0&#39;) {
<span class="p_del">-			osi_linux.default_disabling = 1;</span>
<span class="p_add">+			/* Do not override acpi_osi=!* */</span>
<span class="p_add">+			if (!osi_linux.default_disabling)</span>
<span class="p_add">+				osi_linux.default_disabling =</span>
<span class="p_add">+					ACPI_DISABLE_ALL_VENDOR_STRINGS;</span>
 			return;
 		} else if (*str == &#39;*&#39;) {
<span class="p_del">-			acpi_update_interfaces(ACPI_DISABLE_ALL_STRINGS);</span>
<span class="p_add">+			osi_linux.default_disabling = ACPI_DISABLE_ALL_STRINGS;</span>
 			for (i = 0; i &lt; OSI_STRING_ENTRIES_MAX; i++) {
 				osi = &amp;osi_setup_entries[i];
 				osi-&gt;enable = false;
<span class="p_chunk">@@ -1496,10 +1499,13 @@</span> <span class="p_context"> static void __init acpi_osi_setup_late(void)</span>
 	acpi_status status;
 
 	if (osi_linux.default_disabling) {
<span class="p_del">-		status = acpi_update_interfaces(ACPI_DISABLE_ALL_VENDOR_STRINGS);</span>
<span class="p_add">+		status = acpi_update_interfaces(osi_linux.default_disabling);</span>
 
 		if (ACPI_SUCCESS(status))
<span class="p_del">-			printk(KERN_INFO PREFIX &quot;Disabled all _OSI OS vendors\n&quot;);</span>
<span class="p_add">+			printk(KERN_INFO PREFIX &quot;Disabled all _OSI OS vendors%s\n&quot;,</span>
<span class="p_add">+				osi_linux.default_disabling ==</span>
<span class="p_add">+				ACPI_DISABLE_ALL_STRINGS ?</span>
<span class="p_add">+				&quot; and feature groups&quot; : &quot;&quot;);</span>
 	}
 
 	for (i = 0; i &lt; OSI_STRING_ENTRIES_MAX; i++) {
<span class="p_header">diff --git a/drivers/bluetooth/hci_vhci.c b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">index 1ef6990a5c7e..bbe6643e299d 100644</span>
<span class="p_header">--- a/drivers/bluetooth/hci_vhci.c</span>
<span class="p_header">+++ b/drivers/bluetooth/hci_vhci.c</span>
<span class="p_chunk">@@ -340,6 +340,7 @@</span> <span class="p_context"> static int vhci_release(struct inode *inode, struct file *file)</span>
 		hci_free_dev(hdev);
 	}
 
<span class="p_add">+	skb_queue_purge(&amp;data-&gt;readq);</span>
 	file-&gt;private_data = NULL;
 	kfree(data);
 
<span class="p_header">diff --git a/drivers/crypto/caam/jr.c b/drivers/crypto/caam/jr.c</span>
<span class="p_header">index b512a4ba7569..33308810d1b5 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/jr.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/jr.c</span>
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> static void caam_jr_dequeue(unsigned long devarg)</span>
 struct device *caam_jr_alloc(void)
 {
 	struct caam_drv_private_jr *jrpriv, *min_jrpriv = NULL;
<span class="p_del">-	struct device *dev = NULL;</span>
<span class="p_add">+	struct device *dev = ERR_PTR(-ENODEV);</span>
 	int min_tfm_cnt	= INT_MAX;
 	int tfm_cnt;
 
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index 5ee50f779ef6..0ce45874c14b 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -269,6 +269,8 @@</span> <span class="p_context"> static int usbtll_omap_probe(struct platform_device *pdev)</span>
 
 		if (IS_ERR(tll-&gt;ch_clk[i]))
 			dev_dbg(dev, &quot;can&#39;t get clock : %s\n&quot;, clkname);
<span class="p_add">+		else</span>
<span class="p_add">+			clk_prepare(tll-&gt;ch_clk[i]);</span>
 	}
 
 	pm_runtime_put_sync(dev);
<span class="p_chunk">@@ -301,9 +303,12 @@</span> <span class="p_context"> static int usbtll_omap_remove(struct platform_device *pdev)</span>
 	tll_dev = NULL;
 	spin_unlock(&amp;tll_lock);
 
<span class="p_del">-	for (i = 0; i &lt; tll-&gt;nch; i++)</span>
<span class="p_del">-		if (!IS_ERR(tll-&gt;ch_clk[i]))</span>
<span class="p_add">+	for (i = 0; i &lt; tll-&gt;nch; i++) {</span>
<span class="p_add">+		if (!IS_ERR(tll-&gt;ch_clk[i])) {</span>
<span class="p_add">+			clk_unprepare(tll-&gt;ch_clk[i]);</span>
 			clk_put(tll-&gt;ch_clk[i]);
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 	return 0;
<span class="p_chunk">@@ -421,7 +426,7 @@</span> <span class="p_context"> int omap_tll_enable(struct usbhs_omap_platform_data *pdata)</span>
 			if (IS_ERR(tll-&gt;ch_clk[i]))
 				continue;
 
<span class="p_del">-			r = clk_prepare_enable(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+			r = clk_enable(tll-&gt;ch_clk[i]);</span>
 			if (r) {
 				dev_err(tll_dev,
 				 &quot;Error enabling ch %d clock: %d\n&quot;, i, r);
<span class="p_chunk">@@ -449,7 +454,7 @@</span> <span class="p_context"> int omap_tll_disable(struct usbhs_omap_platform_data *pdata)</span>
 	for (i = 0; i &lt; tll-&gt;nch; i++) {
 		if (omap_usb_mode_needs_tll(pdata-&gt;port_mode[i])) {
 			if (!IS_ERR(tll-&gt;ch_clk[i]))
<span class="p_del">-				clk_disable_unprepare(tll-&gt;ch_clk[i]);</span>
<span class="p_add">+				clk_disable(tll-&gt;ch_clk[i]);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 92aeb1d2b41b..508380b6a10d 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -2352,11 +2352,12 @@</span> <span class="p_context"> static const struct mmc_fixup blk_fixups[] =</span>
 		  MMC_QUIRK_BLK_NO_CMD23),
 
 	/*
<span class="p_del">-	 * Some Micron MMC cards needs longer data read timeout than</span>
<span class="p_del">-	 * indicated in CSD.</span>
<span class="p_add">+	 * Some MMC cards need longer data read timeout than indicated in CSD.</span>
 	 */
 	MMC_FIXUP(CID_NAME_ANY, CID_MANFID_MICRON, 0x200, add_quirk_mmc,
 		  MMC_QUIRK_LONG_READ_TIME),
<span class="p_add">+	MMC_FIXUP(&quot;008GE0&quot;, CID_MANFID_TOSHIBA, CID_OEMID_ANY, add_quirk_mmc,</span>
<span class="p_add">+		  MMC_QUIRK_LONG_READ_TIME),</span>
 
 	/*
 	 * On these Samsung MoviNAND parts, performing secure erase or
<span class="p_header">diff --git a/drivers/mmc/core/core.c b/drivers/mmc/core/core.c</span>
<span class="p_header">index 4a50b5049c51..1bbe372a9e04 100644</span>
<span class="p_header">--- a/drivers/mmc/core/core.c</span>
<span class="p_header">+++ b/drivers/mmc/core/core.c</span>
<span class="p_chunk">@@ -822,11 +822,11 @@</span> <span class="p_context"> void mmc_set_data_timeout(struct mmc_data *data, const struct mmc_card *card)</span>
 	/*
 	 * Some cards require longer data read timeout than indicated in CSD.
 	 * Address this by setting the read timeout to a &quot;reasonably high&quot;
<span class="p_del">-	 * value. For the cards tested, 300ms has proven enough. If necessary,</span>
<span class="p_add">+	 * value. For the cards tested, 600ms has proven enough. If necessary,</span>
 	 * this value can be increased if other problematic cards require this.
 	 */
 	if (mmc_card_long_read_time(card) &amp;&amp; data-&gt;flags &amp; MMC_DATA_READ) {
<span class="p_del">-		data-&gt;timeout_ns = 300000000;</span>
<span class="p_add">+		data-&gt;timeout_ns = 600000000;</span>
 		data-&gt;timeout_clks = 0;
 	}
 
<span class="p_header">diff --git a/drivers/mmc/core/mmc.c b/drivers/mmc/core/mmc.c</span>
<span class="p_header">index 98e9eb0f6643..229407229ecd 100644</span>
<span class="p_header">--- a/drivers/mmc/core/mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/core/mmc.c</span>
<span class="p_chunk">@@ -267,6 +267,9 @@</span> <span class="p_context"> static void mmc_select_card_type(struct mmc_card *card)</span>
 	card-&gt;ext_csd.card_type = card_type;
 }
 
<span class="p_add">+/* Minimum partition switch timeout in milliseconds */</span>
<span class="p_add">+#define MMC_MIN_PART_SWITCH_TIME	300</span>
<span class="p_add">+</span>
 /*
  * Decode extended CSD.
  */
<span class="p_chunk">@@ -331,6 +334,10 @@</span> <span class="p_context"> static int mmc_read_ext_csd(struct mmc_card *card, u8 *ext_csd)</span>
 
 		/* EXT_CSD value is in units of 10ms, but we store in ms */
 		card-&gt;ext_csd.part_time = 10 * ext_csd[EXT_CSD_PART_SWITCH_TIME];
<span class="p_add">+		/* Some eMMC set the value too low so set a minimum */</span>
<span class="p_add">+		if (card-&gt;ext_csd.part_time &amp;&amp;</span>
<span class="p_add">+		    card-&gt;ext_csd.part_time &lt; MMC_MIN_PART_SWITCH_TIME)</span>
<span class="p_add">+			card-&gt;ext_csd.part_time = MMC_MIN_PART_SWITCH_TIME;</span>
 
 		/* Sleep / awake timeout in 100ns units */
 		if (sa_shift &gt; 0 &amp;&amp; sa_shift &lt;= 0x17)
<span class="p_header">diff --git a/drivers/tty/serial/samsung.c b/drivers/tty/serial/samsung.c</span>
<span class="p_header">index 7d3a3f5cb5ba..0a70d12fe33c 100644</span>
<span class="p_header">--- a/drivers/tty/serial/samsung.c</span>
<span class="p_header">+++ b/drivers/tty/serial/samsung.c</span>
<span class="p_chunk">@@ -734,6 +734,8 @@</span> <span class="p_context"> static void s3c24xx_serial_set_termios(struct uart_port *port,</span>
 	/* check to see if we need  to change clock source */
 
 	if (ourport-&gt;baudclk != clk) {
<span class="p_add">+		clk_prepare_enable(clk);</span>
<span class="p_add">+</span>
 		s3c24xx_serial_setsource(port, clk_sel);
 
 		if (!IS_ERR(ourport-&gt;baudclk)) {
<span class="p_chunk">@@ -741,8 +743,6 @@</span> <span class="p_context"> static void s3c24xx_serial_set_termios(struct uart_port *port,</span>
 			ourport-&gt;baudclk = ERR_PTR(-EINVAL);
 		}
 
<span class="p_del">-		clk_prepare_enable(clk);</span>
<span class="p_del">-</span>
 		ourport-&gt;baudclk = clk;
 		ourport-&gt;baudclk_rate = clk ? clk_get_rate(clk) : 0;
 	}
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 693091ab726b..abf17b6fe237 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -3512,9 +3512,10 @@</span> <span class="p_context"> static int do_register_con_driver(const struct consw *csw, int first, int last)</span>
 		goto err;
 
 	desc = csw-&gt;con_startup();
<span class="p_del">-</span>
<span class="p_del">-	if (!desc)</span>
<span class="p_add">+	if (!desc) {</span>
<span class="p_add">+		retval = -ENODEV;</span>
 		goto err;
<span class="p_add">+	}</span>
 
 	retval = -EINVAL;
 
<span class="p_header">diff --git a/drivers/usb/serial/io_edgeport.c b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">index c0866971db2b..1947ea0e0988 100644</span>
<span class="p_header">--- a/drivers/usb/serial/io_edgeport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/io_edgeport.c</span>
<span class="p_chunk">@@ -2856,14 +2856,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;interrupt_read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;interrupt_read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;interrupt_read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;interrupt_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;interrupt_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;interrupt_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2891,14 +2893,16 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 				/* not set up yet, so do it now */
 				edge_serial-&gt;read_urb =
 						usb_alloc_urb(0, GFP_KERNEL);
<span class="p_del">-				if (!edge_serial-&gt;read_urb)</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+				if (!edge_serial-&gt;read_urb) {</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 
 				edge_serial-&gt;bulk_in_buffer =
 					kmalloc(buffer_size, GFP_KERNEL);
 				if (!edge_serial-&gt;bulk_in_buffer) {
<span class="p_del">-					usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-					return -ENOMEM;</span>
<span class="p_add">+					response = -ENOMEM;</span>
<span class="p_add">+					break;</span>
 				}
 				edge_serial-&gt;bulk_in_endpoint =
 						endpoint-&gt;bEndpointAddress;
<span class="p_chunk">@@ -2924,9 +2928,22 @@</span> <span class="p_context"> static int edge_startup(struct usb_serial *serial)</span>
 			}
 		}
 
<span class="p_del">-		if (!interrupt_in_found || !bulk_in_found || !bulk_out_found) {</span>
<span class="p_del">-			dev_err(ddev, &quot;Error - the proper endpoints were not found!\n&quot;);</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+		if (response || !interrupt_in_found || !bulk_in_found ||</span>
<span class="p_add">+							!bulk_out_found) {</span>
<span class="p_add">+			if (!response) {</span>
<span class="p_add">+				dev_err(ddev, &quot;expected endpoints not found\n&quot;);</span>
<span class="p_add">+				response = -ENODEV;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+			kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+			kfree(edge_serial);</span>
<span class="p_add">+</span>
<span class="p_add">+			return response;</span>
 		}
 
 		/* start interrupt read for this edgeport this interrupt will
<span class="p_chunk">@@ -2949,16 +2966,9 @@</span> <span class="p_context"> static void edge_disconnect(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_del">-	/* stop reads and writes on all ports */</span>
<span class="p_del">-	/* free up our endpoint stuff */</span>
 	if (edge_serial-&gt;is_epic) {
 		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_del">-</span>
 		usb_kill_urb(edge_serial-&gt;read_urb);
<span class="p_del">-		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_del">-		kfree(edge_serial-&gt;bulk_in_buffer);</span>
 	}
 }
 
<span class="p_chunk">@@ -2971,6 +2981,16 @@</span> <span class="p_context"> static void edge_release(struct usb_serial *serial)</span>
 {
 	struct edgeport_serial *edge_serial = usb_get_serial_data(serial);
 
<span class="p_add">+	if (edge_serial-&gt;is_epic) {</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;interrupt_read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;interrupt_in_buffer);</span>
<span class="p_add">+</span>
<span class="p_add">+		usb_kill_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		usb_free_urb(edge_serial-&gt;read_urb);</span>
<span class="p_add">+		kfree(edge_serial-&gt;bulk_in_buffer);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(edge_serial);
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/keyspan.c b/drivers/usb/serial/keyspan.c</span>
<span class="p_header">index 35297a845a63..118dba285b5d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/keyspan.c</span>
<span class="p_header">+++ b/drivers/usb/serial/keyspan.c</span>
<span class="p_chunk">@@ -2406,6 +2406,10 @@</span> <span class="p_context"> static void keyspan_release(struct usb_serial *serial)</span>
 
 	s_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	/* Make sure to unlink the URBs submitted in attach. */</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;instat_urb);</span>
<span class="p_add">+	usb_kill_urb(s_priv-&gt;indat_urb);</span>
<span class="p_add">+</span>
 	usb_free_urb(s_priv-&gt;instat_urb);
 	usb_free_urb(s_priv-&gt;indat_urb);
 	usb_free_urb(s_priv-&gt;glocont_urb);
<span class="p_header">diff --git a/drivers/usb/serial/mxuport.c b/drivers/usb/serial/mxuport.c</span>
<span class="p_header">index 460a40669967..d029b2fc0f75 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mxuport.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mxuport.c</span>
<span class="p_chunk">@@ -1263,6 +1263,15 @@</span> <span class="p_context"> static int mxuport_attach(struct usb_serial *serial)</span>
 	return 0;
 }
 
<span class="p_add">+static void mxuport_release(struct usb_serial *serial)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_serial_port *port0 = serial-&gt;port[0];</span>
<span class="p_add">+	struct usb_serial_port *port1 = serial-&gt;port[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	usb_serial_generic_close(port1);</span>
<span class="p_add">+	usb_serial_generic_close(port0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mxuport_open(struct tty_struct *tty, struct usb_serial_port *port)
 {
 	struct mxuport_port *mxport = usb_get_serial_port_data(port);
<span class="p_chunk">@@ -1365,6 +1374,7 @@</span> <span class="p_context"> static struct usb_serial_driver mxuport_device = {</span>
 	.probe			= mxuport_probe,
 	.port_probe		= mxuport_port_probe,
 	.attach			= mxuport_attach,
<span class="p_add">+	.release		= mxuport_release,</span>
 	.calc_num_ports		= mxuport_calc_num_ports,
 	.open			= mxuport_open,
 	.close			= mxuport_close,
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 99c89d7fa1ad..bcb6f5c2bae4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -375,18 +375,22 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define HAIER_PRODUCT_CE81B			0x10f8
 #define HAIER_PRODUCT_CE100			0x2009
 
<span class="p_del">-/* Cinterion (formerly Siemens) products */</span>
<span class="p_del">-#define SIEMENS_VENDOR_ID				0x0681</span>
<span class="p_del">-#define CINTERION_VENDOR_ID				0x1e2d</span>
<span class="p_add">+/* Gemalto&#39;s Cinterion products (formerly Siemens) */</span>
<span class="p_add">+#define SIEMENS_VENDOR_ID			0x0681</span>
<span class="p_add">+#define CINTERION_VENDOR_ID			0x1e2d</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC25_MDMNET		0x0040</span>
 #define CINTERION_PRODUCT_HC25_MDM		0x0047
<span class="p_del">-#define CINTERION_PRODUCT_HC25_MDMNET	0x0040</span>
<span class="p_add">+#define CINTERION_PRODUCT_HC28_MDMNET		0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_HC28_MDM		0x004C
<span class="p_del">-#define CINTERION_PRODUCT_HC28_MDMNET	0x004A /* same for HC28J */</span>
 #define CINTERION_PRODUCT_EU3_E			0x0051
 #define CINTERION_PRODUCT_EU3_P			0x0052
 #define CINTERION_PRODUCT_PH8			0x0053
 #define CINTERION_PRODUCT_AHXX			0x0055
 #define CINTERION_PRODUCT_PLXX			0x0060
<span class="p_add">+#define CINTERION_PRODUCT_PH8_2RMNET		0x0082</span>
<span class="p_add">+#define CINTERION_PRODUCT_PH8_AUDIO		0x0083</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_2RMNET		0x0084</span>
<span class="p_add">+#define CINTERION_PRODUCT_AHXX_AUDIO		0x0085</span>
 
 /* Olivetti products */
 #define OLIVETTI_VENDOR_ID			0x0b3c
<span class="p_chunk">@@ -641,6 +645,10 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le922_blacklist_usbcfg3 = {</span>
 	.reserved = BIT(1) | BIT(2) | BIT(3),
 };
 
<span class="p_add">+static const struct option_blacklist_info cinterion_rmnet2_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(4) | BIT(5),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_RICOLA) },
<span class="p_chunk">@@ -1712,7 +1720,13 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX, 0xff) },
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PLXX),
 		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
<span class="p_del">-	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) }, </span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_2RMNET, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;cinterion_rmnet2_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_PH8_AUDIO, 0xff),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_2RMNET, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(CINTERION_VENDOR_ID, CINTERION_PRODUCT_AHXX_AUDIO, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDM) },</span>
 	{ USB_DEVICE(CINTERION_VENDOR_ID, CINTERION_PRODUCT_HC28_MDMNET) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDM) },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, CINTERION_PRODUCT_HC25_MDMNET) },
<span class="p_header">diff --git a/drivers/usb/serial/quatech2.c b/drivers/usb/serial/quatech2.c</span>
<span class="p_header">index 7725ed261ed6..62e449db24c3 100644</span>
<span class="p_header">--- a/drivers/usb/serial/quatech2.c</span>
<span class="p_header">+++ b/drivers/usb/serial/quatech2.c</span>
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static void qt2_release(struct usb_serial *serial)</span>
 
 	serial_priv = usb_get_serial_data(serial);
 
<span class="p_add">+	usb_kill_urb(serial_priv-&gt;read_urb);</span>
 	usb_free_urb(serial_priv-&gt;read_urb);
 	kfree(serial_priv-&gt;read_buffer);
 	kfree(serial_priv);
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index d40ae42ba6d4..a65fa2ae094f 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -1574,7 +1574,7 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_transid(struct file *file,</span>
 
 		src_inode = file_inode(src.file);
 		if (src_inode-&gt;i_sb != file_inode(file)-&gt;i_sb) {
<span class="p_del">-			btrfs_info(BTRFS_I(src_inode)-&gt;root-&gt;fs_info,</span>
<span class="p_add">+			btrfs_info(BTRFS_I(file_inode(file))-&gt;root-&gt;fs_info,</span>
 				   &quot;Snapshot src from another FS&quot;);
 			ret = -EINVAL;
 		} else if (!inode_owner_or_capable(src_inode)) {
<span class="p_header">diff --git a/fs/cifs/sess.c b/fs/cifs/sess.c</span>
<span class="p_header">index e87387dbf39f..bbb50be00ef5 100644</span>
<span class="p_header">--- a/fs/cifs/sess.c</span>
<span class="p_header">+++ b/fs/cifs/sess.c</span>
<span class="p_chunk">@@ -399,19 +399,27 @@</span> <span class="p_context"> int build_ntlmssp_auth_blob(unsigned char *pbuffer,</span>
 	sec_blob-&gt;LmChallengeResponse.MaximumLength = 0;
 
 	sec_blob-&gt;NtChallengeResponse.BufferOffset = cpu_to_le32(tmp - pbuffer);
<span class="p_del">-	rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_del">-	if (rc) {</span>
<span class="p_del">-		cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_del">-		goto setup_ntlmv2_ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_del">-			ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
<span class="p_add">+	if (ses-&gt;user_name != NULL) {</span>
<span class="p_add">+		rc = setup_ntlmv2_rsp(ses, nls_cp);</span>
<span class="p_add">+		if (rc) {</span>
<span class="p_add">+			cifs_dbg(VFS, &quot;Error %d during NTLMSSP authentication\n&quot;, rc);</span>
<span class="p_add">+			goto setup_ntlmv2_ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		memcpy(tmp, ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE,</span>
<span class="p_add">+				ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		tmp += ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE;</span>
 
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_del">-	sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_del">-			cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength =</span>
<span class="p_add">+				cpu_to_le16(ses-&gt;auth_key.len - CIFS_SESS_KEY_SIZE);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * don&#39;t send an NT Response for anonymous access</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.Length = 0;</span>
<span class="p_add">+		sec_blob-&gt;NtChallengeResponse.MaximumLength = 0;</span>
<span class="p_add">+	}</span>
 
 	if (ses-&gt;domainName == NULL) {
 		sec_blob-&gt;DomainName.BufferOffset = cpu_to_le32(tmp - pbuffer);
<span class="p_header">diff --git a/fs/cifs/smb2glob.h b/fs/cifs/smb2glob.h</span>
<span class="p_header">index bc0bb9c34f72..0ffa18094335 100644</span>
<span class="p_header">--- a/fs/cifs/smb2glob.h</span>
<span class="p_header">+++ b/fs/cifs/smb2glob.h</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #define SMB2_OP_DELETE 7
 #define SMB2_OP_HARDLINK 8
 #define SMB2_OP_SET_EOF 9
<span class="p_add">+#define SMB2_OP_RMDIR 10</span>
 
 /* Used when constructing chained read requests. */
 #define CHAINED_REQUEST 1
<span class="p_header">diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c</span>
<span class="p_header">index 215f8d3e3e53..f970c5d5b253 100644</span>
<span class="p_header">--- a/fs/cifs/smb2inode.c</span>
<span class="p_header">+++ b/fs/cifs/smb2inode.c</span>
<span class="p_chunk">@@ -80,6 +80,10 @@</span> <span class="p_context"> smb2_open_op_close(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		 * SMB2_open() call.
 		 */
 		break;
<span class="p_add">+	case SMB2_OP_RMDIR:</span>
<span class="p_add">+		tmprc = SMB2_rmdir(xid, tcon, fid.persistent_fid,</span>
<span class="p_add">+				   fid.volatile_fid);</span>
<span class="p_add">+		break;</span>
 	case SMB2_OP_RENAME:
 		tmprc = SMB2_rename(xid, tcon, fid.persistent_fid,
 				    fid.volatile_fid, (__le16 *)data);
<span class="p_chunk">@@ -191,8 +195,8 @@</span> <span class="p_context"> smb2_rmdir(const unsigned int xid, struct cifs_tcon *tcon, const char *name,</span>
 	   struct cifs_sb_info *cifs_sb)
 {
 	return smb2_open_op_close(xid, tcon, cifs_sb, name, DELETE, FILE_OPEN,
<span class="p_del">-				  CREATE_NOT_FILE | CREATE_DELETE_ON_CLOSE,</span>
<span class="p_del">-				  NULL, SMB2_OP_DELETE);</span>
<span class="p_add">+				  CREATE_NOT_FILE,</span>
<span class="p_add">+				  NULL, SMB2_OP_RMDIR);</span>
 }
 
 int
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index ae375dff03da..fc656bc5d6cb 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -2291,6 +2291,22 @@</span> <span class="p_context"> SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,</span>
 }
 
 int
<span class="p_add">+SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		  u64 persistent_fid, u64 volatile_fid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__u8 delete_pending = 1;</span>
<span class="p_add">+	void *data;</span>
<span class="p_add">+	unsigned int size;</span>
<span class="p_add">+</span>
<span class="p_add">+	data = &amp;delete_pending;</span>
<span class="p_add">+	size = 1; /* sizeof __u8 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return send_set_info(xid, tcon, persistent_fid, volatile_fid,</span>
<span class="p_add">+			current-&gt;tgid, FILE_DISPOSITION_INFORMATION, 1, &amp;data,</span>
<span class="p_add">+			&amp;size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int</span>
 SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 		  u64 persistent_fid, u64 volatile_fid, __le16 *target_file)
 {
<span class="p_header">diff --git a/fs/cifs/smb2proto.h b/fs/cifs/smb2proto.h</span>
<span class="p_header">index 0ce48db20a65..8e0d57bf446b 100644</span>
<span class="p_header">--- a/fs/cifs/smb2proto.h</span>
<span class="p_header">+++ b/fs/cifs/smb2proto.h</span>
<span class="p_chunk">@@ -134,6 +134,8 @@</span> <span class="p_context"> extern int SMB2_query_directory(const unsigned int xid, struct cifs_tcon *tcon,</span>
 extern int SMB2_rename(const unsigned int xid, struct cifs_tcon *tcon,
 		       u64 persistent_fid, u64 volatile_fid,
 		       __le16 *target_file);
<span class="p_add">+extern int SMB2_rmdir(const unsigned int xid, struct cifs_tcon *tcon,</span>
<span class="p_add">+		      u64 persistent_fid, u64 volatile_fid);</span>
 extern int SMB2_set_hardlink(const unsigned int xid, struct cifs_tcon *tcon,
 			     u64 persistent_fid, u64 volatile_fid,
 			     __le16 *target_file);
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index c798ed2fc281..0d3af0a47c6d 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -463,7 +463,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	raw_spinlock_t			reader_lock;	/* serialize readers */
 	arch_spinlock_t			lock;
 	struct lock_class_key		lock_key;
<span class="p_del">-	unsigned int			nr_pages;</span>
<span class="p_add">+	unsigned long			nr_pages;</span>
 	struct list_head		*pages;
 	struct buffer_page		*head_page;	/* read from head */
 	struct buffer_page		*tail_page;	/* write to tail */
<span class="p_chunk">@@ -483,7 +483,7 @@</span> <span class="p_context"> struct ring_buffer_per_cpu {</span>
 	u64				write_stamp;
 	u64				read_stamp;
 	/* ring buffer pages to update, &gt; 0 to add, &lt; 0 to remove */
<span class="p_del">-	int				nr_pages_to_update;</span>
<span class="p_add">+	long				nr_pages_to_update;</span>
 	struct list_head		new_pages; /* new pages to add */
 	struct work_struct		update_pages_work;
 	struct completion		update_done;
<span class="p_chunk">@@ -1120,10 +1120,10 @@</span> <span class="p_context"> static int rb_check_pages(struct ring_buffer_per_cpu *cpu_buffer)</span>
 	return 0;
 }
 
<span class="p_del">-static int __rb_allocate_pages(int nr_pages, struct list_head *pages, int cpu)</span>
<span class="p_add">+static int __rb_allocate_pages(long nr_pages, struct list_head *pages, int cpu)</span>
 {
<span class="p_del">-	int i;</span>
 	struct buffer_page *bpage, *tmp;
<span class="p_add">+	long i;</span>
 
 	for (i = 0; i &lt; nr_pages; i++) {
 		struct page *page;
<span class="p_chunk">@@ -1160,7 +1160,7 @@</span> <span class="p_context"> free_pages:</span>
 }
 
 static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,
<span class="p_del">-			     unsigned nr_pages)</span>
<span class="p_add">+			     unsigned long nr_pages)</span>
 {
 	LIST_HEAD(pages);
 
<span class="p_chunk">@@ -1185,7 +1185,7 @@</span> <span class="p_context"> static int rb_allocate_pages(struct ring_buffer_per_cpu *cpu_buffer,</span>
 }
 
 static struct ring_buffer_per_cpu *
<span class="p_del">-rb_allocate_cpu_buffer(struct ring_buffer *buffer, int nr_pages, int cpu)</span>
<span class="p_add">+rb_allocate_cpu_buffer(struct ring_buffer *buffer, long nr_pages, int cpu)</span>
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
 	struct buffer_page *bpage;
<span class="p_chunk">@@ -1284,8 +1284,9 @@</span> <span class="p_context"> struct ring_buffer *__ring_buffer_alloc(unsigned long size, unsigned flags,</span>
 					struct lock_class_key *key)
 {
 	struct ring_buffer *buffer;
<span class="p_add">+	long nr_pages;</span>
 	int bsize;
<span class="p_del">-	int cpu, nr_pages;</span>
<span class="p_add">+	int cpu;</span>
 
 	/* keep it in its own cache line */
 	buffer = kzalloc(ALIGN(sizeof(*buffer), cache_line_size()),
<span class="p_chunk">@@ -1408,12 +1409,12 @@</span> <span class="p_context"> static inline unsigned long rb_page_write(struct buffer_page *bpage)</span>
 }
 
 static int
<span class="p_del">-rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned int nr_pages)</span>
<span class="p_add">+rb_remove_pages(struct ring_buffer_per_cpu *cpu_buffer, unsigned long nr_pages)</span>
 {
 	struct list_head *tail_page, *to_remove, *next_page;
 	struct buffer_page *to_remove_page, *tmp_iter_page;
 	struct buffer_page *last_page, *first_page;
<span class="p_del">-	unsigned int nr_removed;</span>
<span class="p_add">+	unsigned long nr_removed;</span>
 	unsigned long head_bit;
 	int page_entries;
 
<span class="p_chunk">@@ -1630,7 +1631,7 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 			int cpu_id)
 {
 	struct ring_buffer_per_cpu *cpu_buffer;
<span class="p_del">-	unsigned nr_pages;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 	int cpu, err = 0;
 
 	/*
<span class="p_chunk">@@ -1644,14 +1645,13 @@</span> <span class="p_context"> int ring_buffer_resize(struct ring_buffer *buffer, unsigned long size,</span>
 	    !cpumask_test_cpu(cpu_id, buffer-&gt;cpumask))
 		return size;
 
<span class="p_del">-	size = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_del">-	size *= BUF_PAGE_SIZE;</span>
<span class="p_add">+	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
 
 	/* we need a minimum of two pages */
<span class="p_del">-	if (size &lt; BUF_PAGE_SIZE * 2)</span>
<span class="p_del">-		size = BUF_PAGE_SIZE * 2;</span>
<span class="p_add">+	if (nr_pages &lt; 2)</span>
<span class="p_add">+		nr_pages = 2;</span>
 
<span class="p_del">-	nr_pages = DIV_ROUND_UP(size, BUF_PAGE_SIZE);</span>
<span class="p_add">+	size = nr_pages * BUF_PAGE_SIZE;</span>
 
 	/*
 	 * Don&#39;t succeed if resizing is disabled, as a reader might be
<span class="p_chunk">@@ -4609,8 +4609,9 @@</span> <span class="p_context"> static int rb_cpu_notify(struct notifier_block *self,</span>
 	struct ring_buffer *buffer =
 		container_of(self, struct ring_buffer, cpu_notify);
 	long cpu = (long)hcpu;
<span class="p_del">-	int cpu_i, nr_pages_same;</span>
<span class="p_del">-	unsigned int nr_pages;</span>
<span class="p_add">+	long nr_pages_same;</span>
<span class="p_add">+	int cpu_i;</span>
<span class="p_add">+	unsigned long nr_pages;</span>
 
 	switch (action) {
 	case CPU_UP_PREPARE:

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



