
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[PACTH,v1] mm, proc: Implement /proc/&lt;pid&gt;/totmaps - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [PACTH,v1] mm, proc: Implement /proc/&lt;pid&gt;/totmaps</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 9, 2016, 4:05 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1470758743-17685-1-git-send-email-robert.foss@collabora.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9271631/mbox/"
   >mbox</a>
|
   <a href="/patch/9271631/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9271631/">/patch/9271631/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9F9C660754 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 Aug 2016 16:05:58 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8E79C2832B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 Aug 2016 16:05:58 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 82B18283E5; Tue,  9 Aug 2016 16:05:58 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	UNPARSEABLE_RELAY autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 4ABE82832B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 Aug 2016 16:05:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752747AbcHIQFw (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 9 Aug 2016 12:05:52 -0400
Received: from bhuna.collabora.co.uk ([46.235.227.227]:41193 &quot;EHLO
	bhuna.collabora.co.uk&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750916AbcHIQFv (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 9 Aug 2016 12:05:51 -0400
Received: from [127.0.0.1] (localhost [127.0.0.1])
	(Authenticated sender: robertfoss) with ESMTPSA id A8EFC2608F4
From: robert.foss@collabora.com
To: akpm@linux-foundation.org, keescook@chromium.org,
	viro@zeniv.linux.org.uk, gorcunov@openvz.org,
	john.stultz@linaro.org, plaguedbypenguins@gmail.com,
	sonnyrao@chromium.org, mguzik@redhat.com, adobriyan@gmail.com,
	jdanis@google.com, calvinowens@fb.com, jann@thejh.net,
	robert.foss@collabora.com, mhocko@suse.com, koct9i@gmail.com,
	vbabka@suse.cz, n-horiguchi@ah.jp.nec.com,
	kirill.shutemov@linux.intel.com, ldufour@linux.vnet.ibm.com,
	hannes@cmpxchg.org, linux-kernel@vger.kernel.org,
	Ben Zhang &lt;benzh@chromium.org&gt;, Bryan Freed &lt;bfreed@chromium.org&gt;,
	Filipe Brandenburger &lt;filbranden@chromium.org&gt;
Subject: [PACTH v1] mm, proc: Implement /proc/&lt;pid&gt;/totmaps
Date: Tue,  9 Aug 2016 12:05:43 -0400
Message-Id: &lt;1470758743-17685-1-git-send-email-robert.foss@collabora.com&gt;
X-Mailer: git-send-email 2.7.4
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 9, 2016, 4:05 p.m.</div>
<pre class="content">
<span class="from">From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>

This is based on earlier work by Thiago Goncales. It implements a new
per process proc file which summarizes the contents of the smaps file
but doesn&#39;t display any addresses.  It gives more detailed information
than statm like the PSS (proprotional set size).  It differs from the
original implementation in that it doesn&#39;t use the full blown set of
seq operations, uses a different termination condition, and doesn&#39;t
displayed &quot;Locked&quot; as that was broken on the original implemenation.

This new proc file provides information faster than parsing the potentially
huge smaps file.
<span class="signed-off-by">
Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="tested-by">
Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>

---
 fs/proc/base.c     |   1 +
 fs/proc/internal.h |   4 ++
 fs/proc/task_mmu.c | 126 +++++++++++++++++++++++++++++++++++++++++++++++++++++
 3 files changed, 131 insertions(+)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=61421">Mateusz Guzik</a> - Aug. 9, 2016, 4:29 p.m.</div>
<pre class="content">
On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:
<span class="quote">&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt; huge smaps file.</span>

I have no idea about usefulness of this.

The patch is definitely buggy with respect to how it implements actual
access to mm.
<span class="quote">
&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; +	struct mm_struct *mm;</span>
<span class="quote">&gt; +	struct vm_area_struct *vma;</span>
<span class="quote">&gt; +	struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; +	/* but need to get the mm here because */</span>
<span class="quote">&gt; +	/* task could be in the process of exiting */</span>
<span class="quote">&gt; +	mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt; +	if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt; +		return -EINVAL;</span>
<span class="quote">&gt; +</span>

That&#39;s not how it&#39;s done in smaps.
<span class="quote">
&gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct proc_maps_private *priv;</span>
<span class="quote">&gt; +	int ret = -ENOMEM;</span>
<span class="quote">&gt; +	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (priv) {</span>
<span class="quote">&gt; +		priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt; +		if (!priv-&gt;mss)</span>
<span class="quote">&gt; +			return -ENOMEM;</span>

Cases below explicitly kfree(priv). I can&#39;t remember whether the close
routine gets called if this one fails. Either way, something is wrong
here.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		/* we need to grab references to the task_struct */</span>
<span class="quote">&gt; +		/* at open time, because there&#39;s a potential information */</span>
<span class="quote">&gt; +		/* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt; +		/* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt; +		/* underneath it */</span>
<span class="quote">&gt; +		priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>

This performs no permission checks that I would see. If you take a look
at smaps you will see the user ends up in proc_maps_open which performs
proc_mem_open(inode, PTRACE_MODE_READ) and gets a mm from there.
<span class="quote">

&gt; +		if (!priv-&gt;task) {</span>
<span class="quote">&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt; +			kfree(priv);</span>
<span class="quote">&gt; +			return -ESRCH;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt; +		if (ret) {</span>
<span class="quote">&gt; +			put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt; +			kfree(priv);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=26032">Sonny Rao</a> - Aug. 9, 2016, 4:56 p.m.</div>
<pre class="content">
On Tue, Aug 9, 2016 at 9:29 AM, Mateusz Guzik &lt;mguzik@redhat.com&gt; wrote:
<span class="quote">&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt;&gt; huge smaps file.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I have no idea about usefulness of this.</span>

I can comment about this.  The use case is to speed up monitoring of
memory consumption in environments where RSS isn&#39;t precise.

For example Chrome tends to many processes which have hundreds of VMAs
with a substantial amount of shared memory, and the error of using
RSS rather than PSS tends to be very large when looking at overall
memory consumption.  PSS isn&#39;t kept as a single number that&#39;s exported
like RSS, so to calculate PSS means having to parse a very large smaps
file.

This process is slow and has to be repeated for many processes, and we
found that the just act of doing the parsing was taking up a
significant amount of CPU time, so this patch is an attempt to make
that process cheaper.
<span class="quote">
&gt;</span>
<span class="quote">&gt; The patch is definitely buggy with respect to how it implements actual</span>
<span class="quote">&gt; access to mm.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +     struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt; +     struct mm_struct *mm;</span>
<span class="quote">&gt;&gt; +     struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt; +     struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +     /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt; +     /* but need to get the mm here because */</span>
<span class="quote">&gt;&gt; +     /* task could be in the process of exiting */</span>
<span class="quote">&gt;&gt; +     mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt;&gt; +     if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt;&gt; +             return -EINVAL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; That&#39;s not how it&#39;s done in smaps.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +     struct proc_maps_private *priv;</span>
<span class="quote">&gt;&gt; +     int ret = -ENOMEM;</span>
<span class="quote">&gt;&gt; +     priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +     if (priv) {</span>
<span class="quote">&gt;&gt; +             priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +             if (!priv-&gt;mss)</span>
<span class="quote">&gt;&gt; +                     return -ENOMEM;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Cases below explicitly kfree(priv). I can&#39;t remember whether the close</span>
<span class="quote">&gt; routine gets called if this one fails. Either way, something is wrong</span>
<span class="quote">&gt; here.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +             /* we need to grab references to the task_struct */</span>
<span class="quote">&gt;&gt; +             /* at open time, because there&#39;s a potential information */</span>
<span class="quote">&gt;&gt; +             /* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt;&gt; +             /* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt;&gt; +             /* underneath it */</span>
<span class="quote">&gt;&gt; +             priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This performs no permission checks that I would see. If you take a look</span>
<span class="quote">&gt; at smaps you will see the user ends up in proc_maps_open which performs</span>
<span class="quote">&gt; proc_mem_open(inode, PTRACE_MODE_READ) and gets a mm from there.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +             if (!priv-&gt;task) {</span>
<span class="quote">&gt;&gt; +                     kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt; +                     kfree(priv);</span>
<span class="quote">&gt;&gt; +                     return -ESRCH;</span>
<span class="quote">&gt;&gt; +             }</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +             ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt;&gt; +             if (ret) {</span>
<span class="quote">&gt;&gt; +                     put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt;&gt; +                     kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt; +                     kfree(priv);</span>
<span class="quote">&gt;&gt; +             }</span>
<span class="quote">&gt;&gt; +     }</span>
<span class="quote">&gt;&gt; +     return ret;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; Mateusz Guzik</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=88">Alexey Dobriyan</a> - Aug. 9, 2016, 4:58 p.m.</div>
<pre class="content">
On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:
<span class="quote">&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt; huge smaps file.</span>

You can &quot;parse&quot; /proc/*/pagemap . RSS, swap are there.
So which ones do you really need?
Why the separate anon hugepages and anon regular pages?
<span class="quote">
&gt; +	seq_printf(m,</span>
<span class="quote">&gt; +		   &quot;Rss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Pss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +		   &quot;Swap:           %8lu kB\n&quot;,</span>
<span class="quote">&gt; +		   mss_sum-&gt;resident &gt;&gt; 10,</span>
<span class="quote">&gt; +		   (unsigned long)(mss_sum-&gt;pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; +		   mss_sum-&gt;shared_clean  &gt;&gt; 10,</span>
<span class="quote">&gt; +		   mss_sum-&gt;shared_dirty  &gt;&gt; 10,</span>
<span class="quote">&gt; +		   mss_sum-&gt;private_clean &gt;&gt; 10,</span>
<span class="quote">&gt; +		   mss_sum-&gt;private_dirty &gt;&gt; 10,</span>
<span class="quote">&gt; +		   mss_sum-&gt;referenced &gt;&gt; 10,</span>
<span class="quote">&gt; +		   mss_sum-&gt;anonymous &gt;&gt; 10,</span>
<span class="quote">&gt; +		   mss_sum-&gt;anonymous_thp &gt;&gt; 10,</span>
<span class="quote">&gt; +		   mss_sum-&gt;swap &gt;&gt; 10);</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=26032">Sonny Rao</a> - Aug. 9, 2016, 6:28 p.m.</div>
<pre class="content">
On Tue, Aug 9, 2016 at 9:58 AM, Alexey Dobriyan &lt;adobriyan@gmail.com&gt; wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt; &gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; &gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; &gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; &gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; &gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; &gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; &gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt; &gt; huge smaps file.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; You can &quot;parse&quot; /proc/*/pagemap . RSS, swap are there.</span>


/proc/*pagemap is generally restricted and I don&#39;t believe it would
quickly give PSS.
<span class="quote">
&gt;</span>
<span class="quote">&gt; So which ones do you really need?</span>

PSS and Swap are the most important.  RSS isn&#39;t precise enough because
it counts shared pages fully, and there tends to be a lot of sharing.
<span class="quote">
&gt; Why the separate anon hugepages and anon regular pages?</span>

I&#39;m not sure if it&#39;s necessary, but that&#39;s how it&#39;s broken out in smaps.
<span class="quote">
&gt;</span>
<span class="quote">&gt; &gt; +     seq_printf(m,</span>
<span class="quote">&gt; &gt; +                &quot;Rss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Pss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                &quot;Swap:           %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;resident &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                (unsigned long)(mss_sum-&gt;pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;shared_clean  &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;shared_dirty  &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;private_clean &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;private_dirty &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;referenced &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;anonymous &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;anonymous_thp &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                mss_sum-&gt;swap &gt;&gt; 10);</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80221">Konstantin Khlebnikov</a> - Aug. 9, 2016, 7:16 p.m.</div>
<pre class="content">
On Tue, Aug 9, 2016 at 7:05 PM,  &lt;robert.foss@collabora.com&gt; wrote:
<span class="quote">&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt; huge smaps file.</span>

What statistics do you really need?

I think, performance and flexibility issues could be really solved only by new
syscall for querying memory statistics for address range in any process:
process_vm_stat() or some kind of pumped fincore() for /proc/$pid/mem
<span class="quote">
&gt;</span>
<span class="quote">&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  fs/proc/base.c     |   1 +</span>
<span class="quote">&gt;  fs/proc/internal.h |   4 ++</span>
<span class="quote">&gt;  fs/proc/task_mmu.c | 126 +++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  3 files changed, 131 insertions(+)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="quote">&gt; index a11eb71..de3acdf 100644</span>
<span class="quote">&gt; --- a/fs/proc/base.c</span>
<span class="quote">&gt; +++ b/fs/proc/base.c</span>
<span class="quote">&gt; @@ -2855,6 +2855,7 @@ static const struct pid_entry tgid_base_stuff[] = {</span>
<span class="quote">&gt;         REG(&quot;clear_refs&quot;, S_IWUSR, proc_clear_refs_operations),</span>
<span class="quote">&gt;         REG(&quot;smaps&quot;,      S_IRUGO, proc_pid_smaps_operations),</span>
<span class="quote">&gt;         REG(&quot;pagemap&quot;,    S_IRUSR, proc_pagemap_operations),</span>
<span class="quote">&gt; +       REG(&quot;totmaps&quot;,    S_IRUGO, proc_totmaps_operations),</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  #ifdef CONFIG_SECURITY</span>
<span class="quote">&gt;         DIR(&quot;attr&quot;,       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),</span>
<span class="quote">&gt; diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="quote">&gt; index aa27810..6f3540f 100644</span>
<span class="quote">&gt; --- a/fs/proc/internal.h</span>
<span class="quote">&gt; +++ b/fs/proc/internal.h</span>
<span class="quote">&gt; @@ -58,6 +58,9 @@ union proc_op {</span>
<span class="quote">&gt;                 struct task_struct *task);</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +extern const struct file_operations proc_totmaps_operations;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  struct proc_inode {</span>
<span class="quote">&gt;         struct pid *pid;</span>
<span class="quote">&gt;         int fd;</span>
<span class="quote">&gt; @@ -281,6 +284,7 @@ struct proc_maps_private {</span>
<span class="quote">&gt;         struct mm_struct *mm;</span>
<span class="quote">&gt;  #ifdef CONFIG_MMU</span>
<span class="quote">&gt;         struct vm_area_struct *tail_vma;</span>
<span class="quote">&gt; +       struct mem_size_stats *mss;</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  #ifdef CONFIG_NUMA</span>
<span class="quote">&gt;         struct mempolicy *task_mempolicy;</span>
<span class="quote">&gt; diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="quote">&gt; index 4648c7f..b61873e 100644</span>
<span class="quote">&gt; --- a/fs/proc/task_mmu.c</span>
<span class="quote">&gt; +++ b/fs/proc/task_mmu.c</span>
<span class="quote">&gt; @@ -802,6 +802,81 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
<span class="quote">&gt;         return 0;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static void add_smaps_sum(struct mem_size_stats *mss,</span>
<span class="quote">&gt; +               struct mem_size_stats *mss_sum)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       mss_sum-&gt;resident += mss-&gt;resident;</span>
<span class="quote">&gt; +       mss_sum-&gt;pss += mss-&gt;pss;</span>
<span class="quote">&gt; +       mss_sum-&gt;shared_clean += mss-&gt;shared_clean;</span>
<span class="quote">&gt; +       mss_sum-&gt;shared_dirty += mss-&gt;shared_dirty;</span>
<span class="quote">&gt; +       mss_sum-&gt;private_clean += mss-&gt;private_clean;</span>
<span class="quote">&gt; +       mss_sum-&gt;private_dirty += mss-&gt;private_dirty;</span>
<span class="quote">&gt; +       mss_sum-&gt;referenced += mss-&gt;referenced;</span>
<span class="quote">&gt; +       mss_sum-&gt;anonymous += mss-&gt;anonymous;</span>
<span class="quote">&gt; +       mss_sum-&gt;anonymous_thp += mss-&gt;anonymous_thp;</span>
<span class="quote">&gt; +       mss_sum-&gt;swap += mss-&gt;swap;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt; +       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; +       /* but need to get the mm here because */</span>
<span class="quote">&gt; +       /* task could be in the process of exiting */</span>
<span class="quote">&gt; +       mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt; +       if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt; +               return -EINVAL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; +       hold_task_mempolicy(priv);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt; +               struct mem_size_stats mss;</span>
<span class="quote">&gt; +               struct mm_walk smaps_walk = {</span>
<span class="quote">&gt; +                       .pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt; +                       .mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt; +                       .private = &amp;mss,</span>
<span class="quote">&gt; +               };</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt; +                       memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt; +                       walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt; +                       add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       seq_printf(m,</span>
<span class="quote">&gt; +                  &quot;Rss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Pss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +                  &quot;Swap:           %8lu kB\n&quot;,</span>
<span class="quote">&gt; +                  mss_sum-&gt;resident &gt;&gt; 10,</span>
<span class="quote">&gt; +                  (unsigned long)(mss_sum-&gt;pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; +                  mss_sum-&gt;shared_clean  &gt;&gt; 10,</span>
<span class="quote">&gt; +                  mss_sum-&gt;shared_dirty  &gt;&gt; 10,</span>
<span class="quote">&gt; +                  mss_sum-&gt;private_clean &gt;&gt; 10,</span>
<span class="quote">&gt; +                  mss_sum-&gt;private_dirty &gt;&gt; 10,</span>
<span class="quote">&gt; +                  mss_sum-&gt;referenced &gt;&gt; 10,</span>
<span class="quote">&gt; +                  mss_sum-&gt;anonymous &gt;&gt; 10,</span>
<span class="quote">&gt; +                  mss_sum-&gt;anonymous_thp &gt;&gt; 10,</span>
<span class="quote">&gt; +                  mss_sum-&gt;swap &gt;&gt; 10);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       release_task_mempolicy(priv);</span>
<span class="quote">&gt; +       up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; +       mmput(mm);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static int show_pid_smap(struct seq_file *m, void *v)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;         return show_smap(m, v, 1);</span>
<span class="quote">&gt; @@ -836,6 +911,50 @@ static int tid_smaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;         return do_maps_open(inode, file, &amp;proc_tid_smaps_op);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct proc_maps_private *priv;</span>
<span class="quote">&gt; +       int ret = -ENOMEM;</span>
<span class="quote">&gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +       if (priv) {</span>
<span class="quote">&gt; +               priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt; +               if (!priv-&gt;mss)</span>
<span class="quote">&gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               /* we need to grab references to the task_struct */</span>
<span class="quote">&gt; +               /* at open time, because there&#39;s a potential information */</span>
<span class="quote">&gt; +               /* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt; +               /* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt; +               /* underneath it */</span>
<span class="quote">&gt; +               priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="quote">&gt; +               if (!priv-&gt;task) {</span>
<span class="quote">&gt; +                       kfree(priv-&gt;mss);</span>
<span class="quote">&gt; +                       kfree(priv);</span>
<span class="quote">&gt; +                       return -ESRCH;</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +               ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt; +               if (ret) {</span>
<span class="quote">&gt; +                       put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt; +                       kfree(priv-&gt;mss);</span>
<span class="quote">&gt; +                       kfree(priv);</span>
<span class="quote">&gt; +               }</span>
<span class="quote">&gt; +       }</span>
<span class="quote">&gt; +       return ret;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static int totmaps_release(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +       struct seq_file *m = file-&gt;private_data;</span>
<span class="quote">&gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +       put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt; +       kfree(priv-&gt;mss);</span>
<span class="quote">&gt; +       kfree(priv);</span>
<span class="quote">&gt; +       m-&gt;private = NULL;</span>
<span class="quote">&gt; +       return single_release(inode, file);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  const struct file_operations proc_pid_smaps_operations = {</span>
<span class="quote">&gt;         .open           = pid_smaps_open,</span>
<span class="quote">&gt;         .read           = seq_read,</span>
<span class="quote">&gt; @@ -850,6 +969,13 @@ const struct file_operations proc_tid_smaps_operations = {</span>
<span class="quote">&gt;         .release        = proc_map_release,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; +const struct file_operations proc_totmaps_operations = {</span>
<span class="quote">&gt; +       .open           = totmaps_open,</span>
<span class="quote">&gt; +       .read           = seq_read,</span>
<span class="quote">&gt; +       .llseek         = seq_lseek,</span>
<span class="quote">&gt; +       .release        = totmaps_release,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  enum clear_refs_types {</span>
<span class="quote">&gt;         CLEAR_REFS_ALL = 1,</span>
<span class="quote">&gt;         CLEAR_REFS_ANON,</span>
<span class="quote">&gt; --</span>
<span class="quote">&gt; 2.7.4</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Aug. 9, 2016, 7:24 p.m.</div>
<pre class="content">
On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:
<span class="quote">&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt; huge smaps file.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">

&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; +	struct mm_struct *mm;</span>
<span class="quote">&gt; +	struct vm_area_struct *vma;</span>
<span class="quote">&gt; +	struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	/* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; +	/* but need to get the mm here because */</span>
<span class="quote">&gt; +	/* task could be in the process of exiting */</span>

Can you please elaborate on this? My understanding here is that you
intend for the caller to be able to repeatedly read the same totmaps
file with pread() and still see updated information after the target
process has called execve() and be able to detect process death
(instead of simply seeing stale values). Is that accurate?

I would prefer it if you could grab a reference to the mm_struct
directly at open time.
<span class="quote">

&gt; +	mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt; +	if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt; +		return -EINVAL;</span>

get_task_mm() doesn&#39;t return error codes, and all other callers just
check whether the return value is NULL.
<span class="quote">

&gt; +	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; +	hold_task_mempolicy(priv);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt; +		struct mem_size_stats mss;</span>
<span class="quote">&gt; +		struct mm_walk smaps_walk = {</span>
<span class="quote">&gt; +			.pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt; +			.mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt; +			.private = &amp;mss,</span>
<span class="quote">&gt; +		};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt; +			memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt; +			walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt; +			add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>

Errrr... what? You accumulate values from mem_size_stats items into a
struct mss_sum that is associated with the struct file? So when you
read the file the second time, you get the old values plus the new ones?
And when you read the file in parallel, you get inconsistent values?

For most files in procfs, the behavior is that you can just call
pread(fd, buf, sizeof(buf), 0) on the same fd again and again, giving
you the current values every time, without mutating state. I strongly
recommend that you get rid of priv-&gt;mss and just accumulate the state
in a local variable (maybe one on the stack).
<span class="quote">

&gt; @@ -836,6 +911,50 @@ static int tid_smaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;  	return do_maps_open(inode, file, &amp;proc_tid_smaps_op);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct proc_maps_private *priv;</span>
<span class="quote">&gt; +	int ret = -ENOMEM;</span>
<span class="quote">&gt; +	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (priv) {</span>
<span class="quote">&gt; +		priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt; +		if (!priv-&gt;mss)</span>
<span class="quote">&gt; +			return -ENOMEM;</span>

Memory leak: If the first allocation works and the second one doesn&#39;t, this
doesn&#39;t free the first allocation.

Please change this to use the typical goto pattern for error handling.
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		/* we need to grab references to the task_struct */</span>
<span class="quote">&gt; +		/* at open time, because there&#39;s a potential information */</span>
<span class="quote">&gt; +		/* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt; +		/* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt; +		/* underneath it */</span>

Nit: That&#39;s not how comments are done in the kernel. Maybe change this to
a normal block comment instead of one block comment per line?
<span class="quote">
&gt; +		priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>

`get_pid_task(proc_pid(inode), PIDTYPE_PID)` is exactly the definition
of get_proc_task(inode), maybe use that instead?
<span class="quote">
&gt; +		if (!priv-&gt;task) {</span>
<span class="quote">&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt; +			kfree(priv);</span>
<span class="quote">&gt; +			return -ESRCH;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt; +		if (ret) {</span>
<span class="quote">&gt; +			put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt; +			kfree(priv);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt; +}</span>

Please change this method to use the typical goto pattern for error
handling. IMO repeating the undo steps in all error cases makes
mistakes (like the one above) more likely and increases the amount
of redundant code.

Also: The smaps file is only accessible to callers with
PTRACE_MODE_READ privileges on the target task. Your thing doesn&#39;t
do any access checks, neither in the open handler nor in the read
handler. Can you give an analysis of why it&#39;s okay to expose this
data? As far as I can tell, without spending a lot of time thinking
about it, this kind of data looks like it might potentially be
useful for side-channel information leaks or so.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 9, 2016, 8:17 p.m.</div>
<pre class="content">
On 2016-08-09 12:29 PM, Mateusz Guzik wrote:
<span class="quote">&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt;&gt; huge smaps file.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I have no idea about usefulness of this.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The patch is definitely buggy with respect to how it implements actual</span>
<span class="quote">&gt; access to mm.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt; +	struct mm_struct *mm;</span>
<span class="quote">&gt;&gt; +	struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt; +	struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt; +	/* but need to get the mm here because */</span>
<span class="quote">&gt;&gt; +	/* task could be in the process of exiting */</span>
<span class="quote">&gt;&gt; +	mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt;&gt; +	if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt;&gt; +		return -EINVAL;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; That&#39;s not how it&#39;s done in smaps.</span>

Alright, I&#39;ll have to look into the difference between this approach and 
the smaps one.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct proc_maps_private *priv;</span>
<span class="quote">&gt;&gt; +	int ret = -ENOMEM;</span>
<span class="quote">&gt;&gt; +	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +	if (priv) {</span>
<span class="quote">&gt;&gt; +		priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +		if (!priv-&gt;mss)</span>
<span class="quote">&gt;&gt; +			return -ENOMEM;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Cases below explicitly kfree(priv). I can&#39;t remember whether the close</span>
<span class="quote">&gt; routine gets called if this one fails. Either way, something is wrong</span>
<span class="quote">&gt; here.</span>

It looks fishy to me too, I&#39;ll have it reworked in v2.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		/* we need to grab references to the task_struct */</span>
<span class="quote">&gt;&gt; +		/* at open time, because there&#39;s a potential information */</span>
<span class="quote">&gt;&gt; +		/* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt;&gt; +		/* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt;&gt; +		/* underneath it */</span>
<span class="quote">&gt;&gt; +		priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This performs no permission checks that I would see. If you take a look</span>
<span class="quote">&gt; at smaps you will see the user ends up in proc_maps_open which performs</span>
<span class="quote">&gt; proc_mem_open(inode, PTRACE_MODE_READ) and gets a mm from there.</span>

The proc_maps_open() function does seem to be doing everything I need 
it. I&#39;ll have a look at switching to using it.

Thanks for the heads up!


Rob.
<span class="quote">
&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +		if (!priv-&gt;task) {</span>
<span class="quote">&gt;&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt; +			kfree(priv);</span>
<span class="quote">&gt;&gt; +			return -ESRCH;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt;&gt; +		if (ret) {</span>
<span class="quote">&gt;&gt; +			put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt;&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt; +			kfree(priv);</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +	return ret;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 9, 2016, 9:01 p.m.</div>
<pre class="content">
On 2016-08-09 03:24 PM, Jann Horn wrote:
<span class="quote">&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt;&gt; huge smaps file.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt; +	struct mm_struct *mm;</span>
<span class="quote">&gt;&gt; +	struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt; +	struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	/* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt; +	/* but need to get the mm here because */</span>
<span class="quote">&gt;&gt; +	/* task could be in the process of exiting */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Can you please elaborate on this? My understanding here is that you</span>
<span class="quote">&gt; intend for the caller to be able to repeatedly read the same totmaps</span>
<span class="quote">&gt; file with pread() and still see updated information after the target</span>
<span class="quote">&gt; process has called execve() and be able to detect process death</span>
<span class="quote">&gt; (instead of simply seeing stale values). Is that accurate?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I would prefer it if you could grab a reference to the mm_struct</span>
<span class="quote">&gt; directly at open time.</span>

Sonny, do you know more about the above comment?
<span class="quote">
&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +	mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt;&gt; +	if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt;&gt; +		return -EINVAL;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; get_task_mm() doesn&#39;t return error codes, and all other callers just</span>
<span class="quote">&gt; check whether the return value is NULL.</span>
<span class="quote">&gt;</span>

I&#39;ll have that fixed in v2, thanks for spotting it!
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt;&gt; +	hold_task_mempolicy(priv);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +	for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt;&gt; +		struct mem_size_stats mss;</span>
<span class="quote">&gt;&gt; +		struct mm_walk smaps_walk = {</span>
<span class="quote">&gt;&gt; +			.pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt;&gt; +			.mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt;&gt; +			.private = &amp;mss,</span>
<span class="quote">&gt;&gt; +		};</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt;&gt; +			memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt;&gt; +			walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt;&gt; +			add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Errrr... what? You accumulate values from mem_size_stats items into a</span>
<span class="quote">&gt; struct mss_sum that is associated with the struct file? So when you</span>
<span class="quote">&gt; read the file the second time, you get the old values plus the new ones?</span>
<span class="quote">&gt; And when you read the file in parallel, you get inconsistent values?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; For most files in procfs, the behavior is that you can just call</span>
<span class="quote">&gt; pread(fd, buf, sizeof(buf), 0) on the same fd again and again, giving</span>
<span class="quote">&gt; you the current values every time, without mutating state. I strongly</span>
<span class="quote">&gt; recommend that you get rid of priv-&gt;mss and just accumulate the state</span>
<span class="quote">&gt; in a local variable (maybe one on the stack).</span>

So a simple &quot;static struct mem_size_stats&quot; in totmaps_proc_show() would 
be a better solution?
<span class="quote">
&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; @@ -836,6 +911,50 @@ static int tid_smaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;&gt;  	return do_maps_open(inode, file, &amp;proc_tid_smaps_op);</span>
<span class="quote">&gt;&gt;  }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +	struct proc_maps_private *priv;</span>
<span class="quote">&gt;&gt; +	int ret = -ENOMEM;</span>
<span class="quote">&gt;&gt; +	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +	if (priv) {</span>
<span class="quote">&gt;&gt; +		priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt;&gt; +		if (!priv-&gt;mss)</span>
<span class="quote">&gt;&gt; +			return -ENOMEM;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Memory leak: If the first allocation works and the second one doesn&#39;t, this</span>
<span class="quote">&gt; doesn&#39;t free the first allocation.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Please change this to use the typical goto pattern for error handling.</span>

Fix will be implemented in v2.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		/* we need to grab references to the task_struct */</span>
<span class="quote">&gt;&gt; +		/* at open time, because there&#39;s a potential information */</span>
<span class="quote">&gt;&gt; +		/* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt;&gt; +		/* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt;&gt; +		/* underneath it */</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Nit: That&#39;s not how comments are done in the kernel. Maybe change this to</span>
<span class="quote">&gt; a normal block comment instead of one block comment per line?</span>

I&#39;m not sure how that one slipped by, but I&#39;ll change it in v2.
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; +		priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; `get_pid_task(proc_pid(inode), PIDTYPE_PID)` is exactly the definition</span>
<span class="quote">&gt; of get_proc_task(inode), maybe use that instead?</span>
<span class="quote">&gt;</span>

Will do. v2 will fix this.
<span class="quote">
&gt;&gt; +		if (!priv-&gt;task) {</span>
<span class="quote">&gt;&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt; +			kfree(priv);</span>
<span class="quote">&gt;&gt; +			return -ESRCH;</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +		ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt;&gt; +		if (ret) {</span>
<span class="quote">&gt;&gt; +			put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt;&gt; +			kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt; +			kfree(priv);</span>
<span class="quote">&gt;&gt; +		}</span>
<span class="quote">&gt;&gt; +	}</span>
<span class="quote">&gt;&gt; +	return ret;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Please change this method to use the typical goto pattern for error</span>
<span class="quote">&gt; handling. IMO repeating the undo steps in all error cases makes</span>
<span class="quote">&gt; mistakes (like the one above) more likely and increases the amount</span>
<span class="quote">&gt; of redundant code.</span>

Agreed. Change queued for v2.
<span class="quote">
&gt;</span>
<span class="quote">&gt; Also: The smaps file is only accessible to callers with</span>
<span class="quote">&gt; PTRACE_MODE_READ privileges on the target task. Your thing doesn&#39;t</span>
<span class="quote">&gt; do any access checks, neither in the open handler nor in the read</span>
<span class="quote">&gt; handler. Can you give an analysis of why it&#39;s okay to expose this</span>
<span class="quote">&gt; data? As far as I can tell, without spending a lot of time thinking</span>
<span class="quote">&gt; about it, this kind of data looks like it might potentially be</span>
<span class="quote">&gt; useful for side-channel information leaks or so.</span>
<span class="quote">&gt;</span>

I think it should require the same permissions as smaps, so changing the 
code to require PTRACE_MODE_READ privileges is most likely a good idea. 
I&#39;ll have a look at it for v2.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Aug. 9, 2016, 10:30 p.m.</div>
<pre class="content">
On Tue, Aug 09, 2016 at 05:01:44PM -0400, Robert Foss wrote:
<span class="quote">&gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt; &gt;On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt; &gt;&gt;+	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; &gt;&gt;+	hold_task_mempolicy(priv);</span>
<span class="quote">&gt; &gt;&gt;+</span>
<span class="quote">&gt; &gt;&gt;+	for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt; &gt;&gt;+		struct mem_size_stats mss;</span>
<span class="quote">&gt; &gt;&gt;+		struct mm_walk smaps_walk = {</span>
<span class="quote">&gt; &gt;&gt;+			.pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt; &gt;&gt;+			.mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt; &gt;&gt;+			.private = &amp;mss,</span>
<span class="quote">&gt; &gt;&gt;+		};</span>
<span class="quote">&gt; &gt;&gt;+</span>
<span class="quote">&gt; &gt;&gt;+		if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt; &gt;&gt;+			memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt; &gt;&gt;+			walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt; &gt;&gt;+			add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt; &gt;&gt;+		}</span>
<span class="quote">&gt; &gt;&gt;+	}</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Errrr... what? You accumulate values from mem_size_stats items into a</span>
<span class="quote">&gt; &gt;struct mss_sum that is associated with the struct file? So when you</span>
<span class="quote">&gt; &gt;read the file the second time, you get the old values plus the new ones?</span>
<span class="quote">&gt; &gt;And when you read the file in parallel, you get inconsistent values?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;For most files in procfs, the behavior is that you can just call</span>
<span class="quote">&gt; &gt;pread(fd, buf, sizeof(buf), 0) on the same fd again and again, giving</span>
<span class="quote">&gt; &gt;you the current values every time, without mutating state. I strongly</span>
<span class="quote">&gt; &gt;recommend that you get rid of priv-&gt;mss and just accumulate the state</span>
<span class="quote">&gt; &gt;in a local variable (maybe one on the stack).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So a simple &quot;static struct mem_size_stats&quot; in totmaps_proc_show() would be a</span>
<span class="quote">&gt; better solution?</span>

Er, why &quot;static&quot;? Are you trying to create shared state between different
readers for some reason?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=26032">Sonny Rao</a> - Aug. 10, 2016, 12:30 a.m.</div>
<pre class="content">
On Tue, Aug 9, 2016 at 12:16 PM, Konstantin Khlebnikov &lt;koct9i@gmail.com&gt; wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt; On Tue, Aug 9, 2016 at 7:05 PM,  &lt;robert.foss@collabora.com&gt; wrote:</span>
<span class="quote">&gt; &gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; &gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; &gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; &gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; &gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; &gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; &gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; This new proc file provides information faster than parsing the potentially</span>
<span class="quote">&gt; &gt; huge smaps file.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What statistics do you really need?</span>

PSS (Proportional Set Size) and related accounting of shared pages
(swap could be shared) is where the existing summaries of memory usage
are cumbersome.
<span class="quote">
&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I think, performance and flexibility issues could be really solved only by new</span>
<span class="quote">&gt; syscall for querying memory statistics for address range in any process:</span>
<span class="quote">&gt; process_vm_stat() or some kind of pumped fincore() for /proc/$pid/mem</span>


That would be a good long term solution if people want similarly
complicated statistics without having to iterate through current
interfaces.
I mentioned monitoring before but I&#39;ll add that Proportional Set size,
Unique Set Size, Swap are per process are also useful because they
help us make better decisions about what processes need to be
throttled or gracefully killed.
<span class="quote">
&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; ---</span>
<span class="quote">&gt; &gt;  fs/proc/base.c     |   1 +</span>
<span class="quote">&gt; &gt;  fs/proc/internal.h |   4 ++</span>
<span class="quote">&gt; &gt;  fs/proc/task_mmu.c | 126 +++++++++++++++++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt; &gt;  3 files changed, 131 insertions(+)</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="quote">&gt; &gt; index a11eb71..de3acdf 100644</span>
<span class="quote">&gt; &gt; --- a/fs/proc/base.c</span>
<span class="quote">&gt; &gt; +++ b/fs/proc/base.c</span>
<span class="quote">&gt; &gt; @@ -2855,6 +2855,7 @@ static const struct pid_entry tgid_base_stuff[] = {</span>
<span class="quote">&gt; &gt;         REG(&quot;clear_refs&quot;, S_IWUSR, proc_clear_refs_operations),</span>
<span class="quote">&gt; &gt;         REG(&quot;smaps&quot;,      S_IRUGO, proc_pid_smaps_operations),</span>
<span class="quote">&gt; &gt;         REG(&quot;pagemap&quot;,    S_IRUSR, proc_pagemap_operations),</span>
<span class="quote">&gt; &gt; +       REG(&quot;totmaps&quot;,    S_IRUGO, proc_totmaps_operations),</span>
<span class="quote">&gt; &gt;  #endif</span>
<span class="quote">&gt; &gt;  #ifdef CONFIG_SECURITY</span>
<span class="quote">&gt; &gt;         DIR(&quot;attr&quot;,       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),</span>
<span class="quote">&gt; &gt; diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="quote">&gt; &gt; index aa27810..6f3540f 100644</span>
<span class="quote">&gt; &gt; --- a/fs/proc/internal.h</span>
<span class="quote">&gt; &gt; +++ b/fs/proc/internal.h</span>
<span class="quote">&gt; &gt; @@ -58,6 +58,9 @@ union proc_op {</span>
<span class="quote">&gt; &gt;                 struct task_struct *task);</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +extern const struct file_operations proc_totmaps_operations;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  struct proc_inode {</span>
<span class="quote">&gt; &gt;         struct pid *pid;</span>
<span class="quote">&gt; &gt;         int fd;</span>
<span class="quote">&gt; &gt; @@ -281,6 +284,7 @@ struct proc_maps_private {</span>
<span class="quote">&gt; &gt;         struct mm_struct *mm;</span>
<span class="quote">&gt; &gt;  #ifdef CONFIG_MMU</span>
<span class="quote">&gt; &gt;         struct vm_area_struct *tail_vma;</span>
<span class="quote">&gt; &gt; +       struct mem_size_stats *mss;</span>
<span class="quote">&gt; &gt;  #endif</span>
<span class="quote">&gt; &gt;  #ifdef CONFIG_NUMA</span>
<span class="quote">&gt; &gt;         struct mempolicy *task_mempolicy;</span>
<span class="quote">&gt; &gt; diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="quote">&gt; &gt; index 4648c7f..b61873e 100644</span>
<span class="quote">&gt; &gt; --- a/fs/proc/task_mmu.c</span>
<span class="quote">&gt; &gt; +++ b/fs/proc/task_mmu.c</span>
<span class="quote">&gt; &gt; @@ -802,6 +802,81 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
<span class="quote">&gt; &gt;         return 0;</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; +static void add_smaps_sum(struct mem_size_stats *mss,</span>
<span class="quote">&gt; &gt; +               struct mem_size_stats *mss_sum)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;resident += mss-&gt;resident;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;pss += mss-&gt;pss;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;shared_clean += mss-&gt;shared_clean;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;shared_dirty += mss-&gt;shared_dirty;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;private_clean += mss-&gt;private_clean;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;private_dirty += mss-&gt;private_dirty;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;referenced += mss-&gt;referenced;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;anonymous += mss-&gt;anonymous;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;anonymous_thp += mss-&gt;anonymous_thp;</span>
<span class="quote">&gt; &gt; +       mss_sum-&gt;swap += mss-&gt;swap;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; &gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt; &gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt; &gt; +       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; &gt; +       /* but need to get the mm here because */</span>
<span class="quote">&gt; &gt; +       /* task could be in the process of exiting */</span>
<span class="quote">&gt; &gt; +       mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt; &gt; +       if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt; &gt; +               return -EINVAL;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; &gt; +       hold_task_mempolicy(priv);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt; &gt; +               struct mem_size_stats mss;</span>
<span class="quote">&gt; &gt; +               struct mm_walk smaps_walk = {</span>
<span class="quote">&gt; &gt; +                       .pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt; &gt; +                       .mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt; &gt; +                       .private = &amp;mss,</span>
<span class="quote">&gt; &gt; +               };</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt; &gt; +                       memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt; &gt; +                       walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt; &gt; +                       add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +       seq_printf(m,</span>
<span class="quote">&gt; &gt; +                  &quot;Rss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Pss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="quote">&gt; &gt; +                  &quot;Swap:           %8lu kB\n&quot;,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;resident &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  (unsigned long)(mss_sum-&gt;pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;shared_clean  &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;shared_dirty  &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;private_clean &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;private_dirty &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;referenced &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;anonymous &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;anonymous_thp &gt;&gt; 10,</span>
<span class="quote">&gt; &gt; +                  mss_sum-&gt;swap &gt;&gt; 10);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       release_task_mempolicy(priv);</span>
<span class="quote">&gt; &gt; +       up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; &gt; +       mmput(mm);</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       return 0;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  static int show_pid_smap(struct seq_file *m, void *v)</span>
<span class="quote">&gt; &gt;  {</span>
<span class="quote">&gt; &gt;         return show_smap(m, v, 1);</span>
<span class="quote">&gt; &gt; @@ -836,6 +911,50 @@ static int tid_smaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; &gt;         return do_maps_open(inode, file, &amp;proc_tid_smaps_op);</span>
<span class="quote">&gt; &gt;  }</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct proc_maps_private *priv;</span>
<span class="quote">&gt; &gt; +       int ret = -ENOMEM;</span>
<span class="quote">&gt; &gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +       if (priv) {</span>
<span class="quote">&gt; &gt; +               priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt; &gt; +               if (!priv-&gt;mss)</span>
<span class="quote">&gt; &gt; +                       return -ENOMEM;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               /* we need to grab references to the task_struct */</span>
<span class="quote">&gt; &gt; +               /* at open time, because there&#39;s a potential information */</span>
<span class="quote">&gt; &gt; +               /* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt; &gt; +               /* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt; &gt; +               /* underneath it */</span>
<span class="quote">&gt; &gt; +               priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="quote">&gt; &gt; +               if (!priv-&gt;task) {</span>
<span class="quote">&gt; &gt; +                       kfree(priv-&gt;mss);</span>
<span class="quote">&gt; &gt; +                       kfree(priv);</span>
<span class="quote">&gt; &gt; +                       return -ESRCH;</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +               ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt; &gt; +               if (ret) {</span>
<span class="quote">&gt; &gt; +                       put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt; &gt; +                       kfree(priv-&gt;mss);</span>
<span class="quote">&gt; &gt; +                       kfree(priv);</span>
<span class="quote">&gt; &gt; +               }</span>
<span class="quote">&gt; &gt; +       }</span>
<span class="quote">&gt; &gt; +       return ret;</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +static int totmaps_release(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +       struct seq_file *m = file-&gt;private_data;</span>
<span class="quote">&gt; &gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt; +       put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt; &gt; +       kfree(priv-&gt;mss);</span>
<span class="quote">&gt; &gt; +       kfree(priv);</span>
<span class="quote">&gt; &gt; +       m-&gt;private = NULL;</span>
<span class="quote">&gt; &gt; +       return single_release(inode, file);</span>
<span class="quote">&gt; &gt; +}</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  const struct file_operations proc_pid_smaps_operations = {</span>
<span class="quote">&gt; &gt;         .open           = pid_smaps_open,</span>
<span class="quote">&gt; &gt;         .read           = seq_read,</span>
<span class="quote">&gt; &gt; @@ -850,6 +969,13 @@ const struct file_operations proc_tid_smaps_operations = {</span>
<span class="quote">&gt; &gt;         .release        = proc_map_release,</span>
<span class="quote">&gt; &gt;  };</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; +const struct file_operations proc_totmaps_operations = {</span>
<span class="quote">&gt; &gt; +       .open           = totmaps_open,</span>
<span class="quote">&gt; &gt; +       .read           = seq_read,</span>
<span class="quote">&gt; &gt; +       .llseek         = seq_lseek,</span>
<span class="quote">&gt; &gt; +       .release        = totmaps_release,</span>
<span class="quote">&gt; &gt; +};</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; &gt;  enum clear_refs_types {</span>
<span class="quote">&gt; &gt;         CLEAR_REFS_ALL = 1,</span>
<span class="quote">&gt; &gt;         CLEAR_REFS_ANON,</span>
<span class="quote">&gt; &gt; --</span>
<span class="quote">&gt; &gt; 2.7.4</span>
<span class="quote">&gt; &gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 10, 2016, 2:16 p.m.</div>
<pre class="content">
On 2016-08-09 06:30 PM, Jann Horn wrote:
<span class="quote">&gt; On Tue, Aug 09, 2016 at 05:01:44PM -0400, Robert Foss wrote:</span>
<span class="quote">&gt;&gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt;&gt;&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; +	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt;&gt;&gt;&gt; +	hold_task_mempolicy(priv);</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +	for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt;&gt;&gt;&gt; +		struct mem_size_stats mss;</span>
<span class="quote">&gt;&gt;&gt;&gt; +		struct mm_walk smaps_walk = {</span>
<span class="quote">&gt;&gt;&gt;&gt; +			.pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt;&gt;&gt;&gt; +			.mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt;&gt;&gt;&gt; +			.private = &amp;mss,</span>
<span class="quote">&gt;&gt;&gt;&gt; +		};</span>
<span class="quote">&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt; +		if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt;&gt;&gt;&gt; +			memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt;&gt;&gt;&gt; +			walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt;&gt;&gt;&gt; +			add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt;&gt;&gt;&gt; +		}</span>
<span class="quote">&gt;&gt;&gt;&gt; +	}</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Errrr... what? You accumulate values from mem_size_stats items into a</span>
<span class="quote">&gt;&gt;&gt; struct mss_sum that is associated with the struct file? So when you</span>
<span class="quote">&gt;&gt;&gt; read the file the second time, you get the old values plus the new ones?</span>
<span class="quote">&gt;&gt;&gt; And when you read the file in parallel, you get inconsistent values?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; For most files in procfs, the behavior is that you can just call</span>
<span class="quote">&gt;&gt;&gt; pread(fd, buf, sizeof(buf), 0) on the same fd again and again, giving</span>
<span class="quote">&gt;&gt;&gt; you the current values every time, without mutating state. I strongly</span>
<span class="quote">&gt;&gt;&gt; recommend that you get rid of priv-&gt;mss and just accumulate the state</span>
<span class="quote">&gt;&gt;&gt; in a local variable (maybe one on the stack).</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; So a simple &quot;static struct mem_size_stats&quot; in totmaps_proc_show() would be a</span>
<span class="quote">&gt;&gt; better solution?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Er, why &quot;static&quot;? Are you trying to create shared state between different</span>
<span class="quote">&gt; readers for some reason?</span>
<span class="quote">&gt;</span>

I think I&#39;m a bit confused now, how are you suggesting that I replace 
priv-&gt;mss?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Aug. 10, 2016, 3:02 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 10:16:45AM -0400, Robert Foss wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 2016-08-09 06:30 PM, Jann Horn wrote:</span>
<span class="quote">&gt; &gt;On Tue, Aug 09, 2016 at 05:01:44PM -0400, Robert Foss wrote:</span>
<span class="quote">&gt; &gt;&gt;On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+	hold_task_mempolicy(priv);</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+	for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+		struct mem_size_stats mss;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+		struct mm_walk smaps_walk = {</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+			.pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+			.mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+			.private = &amp;mss,</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+		};</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+		if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+			memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+			walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+			add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+		}</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;+	}</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;Errrr... what? You accumulate values from mem_size_stats items into a</span>
<span class="quote">&gt; &gt;&gt;&gt;struct mss_sum that is associated with the struct file? So when you</span>
<span class="quote">&gt; &gt;&gt;&gt;read the file the second time, you get the old values plus the new ones?</span>
<span class="quote">&gt; &gt;&gt;&gt;And when you read the file in parallel, you get inconsistent values?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;For most files in procfs, the behavior is that you can just call</span>
<span class="quote">&gt; &gt;&gt;&gt;pread(fd, buf, sizeof(buf), 0) on the same fd again and again, giving</span>
<span class="quote">&gt; &gt;&gt;&gt;you the current values every time, without mutating state. I strongly</span>
<span class="quote">&gt; &gt;&gt;&gt;recommend that you get rid of priv-&gt;mss and just accumulate the state</span>
<span class="quote">&gt; &gt;&gt;&gt;in a local variable (maybe one on the stack).</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;So a simple &quot;static struct mem_size_stats&quot; in totmaps_proc_show() would be a</span>
<span class="quote">&gt; &gt;&gt;better solution?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Er, why &quot;static&quot;? Are you trying to create shared state between different</span>
<span class="quote">&gt; &gt;readers for some reason?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think I&#39;m a bit confused now, how are you suggesting that I replace</span>
<span class="quote">&gt; priv-&gt;mss?</span>

Like this:

static int totmaps_proc_show(struct seq_file *m, void *data)
{
        struct proc_maps_private *priv = m-&gt;private;
        struct mm_struct *mm;
        struct vm_area_struct *vma;
        struct mem_size_stats mss_sum;

        memset(&amp;mss_sum, 0, sizeof(mss_sum));

        [...]

        for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {
                struct mem_size_stats mss;
                struct mm_walk smaps_walk = {
                        .pmd_entry = smaps_pte_range,
                        .mm = vma-&gt;vm_mm,
                        .private = &amp;mss,
                };

                if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {
                        memset(&amp;mss, 0, sizeof(mss));
                        walk_page_vma(vma, &amp;smaps_walk);
                        add_smaps_sum(&amp;mss, &amp;mss_sum);
                }
        }
        seq_printf(m,
                   &quot;Rss:            %8lu kB\n&quot;
                   &quot;Pss:            %8lu kB\n&quot;
                   &quot;Shared_Clean:   %8lu kB\n&quot;
                   [...],
                   mss_sum.resident &gt;&gt; 10,
                   (unsigned long)(mss_sum.pss &gt;&gt; (10 + PSS_SHIFT)),
                   mss_sum.shared_clean  &gt;&gt; 10,
                   [...]);
        [...]
}
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 10, 2016, 3:39 p.m.</div>
<pre class="content">
On 2016-08-09 04:17 PM, Robert Foss wrote:
<span class="quote">&gt;&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +    struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt;&gt; +    struct mm_struct *mm;</span>
<span class="quote">&gt;&gt;&gt; +    struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt;&gt; +    struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +    /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt;&gt; +    /* but need to get the mm here because */</span>
<span class="quote">&gt;&gt;&gt; +    /* task could be in the process of exiting */</span>
<span class="quote">&gt;&gt;&gt; +    mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt;&gt;&gt; +    if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt;&gt;&gt; +        return -EINVAL;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; That&#39;s not how it&#39;s done in smaps.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Alright, I&#39;ll have to look into the difference between this approach and</span>
<span class="quote">&gt; the smaps one.</span>


I had a look at show_smaps(), and it&#39;s not entirely clear to me what the 
advantage of doing it show_smaps() way.

mm = get_task_mm(priv-&gt;task) is needed to iterate through all of the 
mappings. Is there a preferable way of doing that?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=61421">Mateusz Guzik</a> - Aug. 10, 2016, 3:42 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 11:39:12AM -0400, Robert Foss wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 2016-08-09 04:17 PM, Robert Foss wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; &gt; &gt; &gt; +{</span>
<span class="quote">&gt; &gt; &gt; &gt; +    struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; &gt; &gt; &gt; +    struct mm_struct *mm;</span>
<span class="quote">&gt; &gt; &gt; &gt; +    struct vm_area_struct *vma;</span>
<span class="quote">&gt; &gt; &gt; &gt; +    struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; +    /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; &gt; &gt; &gt; +    /* but need to get the mm here because */</span>
<span class="quote">&gt; &gt; &gt; &gt; +    /* task could be in the process of exiting */</span>
<span class="quote">&gt; &gt; &gt; &gt; +    mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt; &gt; &gt; &gt; +    if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt; &gt; &gt; &gt; +        return -EINVAL;</span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; That&#39;s not how it&#39;s done in smaps.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Alright, I&#39;ll have to look into the difference between this approach and</span>
<span class="quote">&gt; &gt; the smaps one.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I had a look at show_smaps(), and it&#39;s not entirely clear to me what the</span>
<span class="quote">&gt; advantage of doing it show_smaps() way.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; mm = get_task_mm(priv-&gt;task) is needed to iterate through all of the</span>
<span class="quote">&gt; mappings. Is there a preferable way of doing that?</span>

In the other part of the mail I stated smaps goes to proc_maps_open
which has:
priv-&gt;mm = proc_mem_open(inode, PTRACE_MODE_READ);

This gives you stable access to mm and all needed permission checks.

Then, in the read routine you can just:
if (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))
	goto thats_it;

See smaps routines or e.g. environ_read.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 10, 2016, 3:50 p.m.</div>
<pre class="content">
On 2016-08-10 11:42 AM, Mateusz Guzik wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 11:39:12AM -0400, Robert Foss wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 2016-08-09 04:17 PM, Robert Foss wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    struct mm_struct *mm;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    /* but need to get the mm here because */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    /* task could be in the process of exiting */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +    if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +        return -EINVAL;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; That&#39;s not how it&#39;s done in smaps.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Alright, I&#39;ll have to look into the difference between this approach and</span>
<span class="quote">&gt;&gt;&gt; the smaps one.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I had a look at show_smaps(), and it&#39;s not entirely clear to me what the</span>
<span class="quote">&gt;&gt; advantage of doing it show_smaps() way.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; mm = get_task_mm(priv-&gt;task) is needed to iterate through all of the</span>
<span class="quote">&gt;&gt; mappings. Is there a preferable way of doing that?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; In the other part of the mail I stated smaps goes to proc_maps_open</span>
<span class="quote">&gt; which has:</span>
<span class="quote">&gt; priv-&gt;mm = proc_mem_open(inode, PTRACE_MODE_READ);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; This gives you stable access to mm and all needed permission checks.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Then, in the read routine you can just:</span>
<span class="quote">&gt; if (!atomic_inc_not_zero(&amp;mm-&gt;mm_users))</span>
<span class="quote">&gt; 	goto thats_it;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; See smaps routines or e.g. environ_read.</span>
<span class="quote">&gt;</span>

Ah! I see what you mean now. Thanks for the clarification!


Rob.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 10, 2016, 4:24 p.m.</div>
<pre class="content">
On 2016-08-10 11:02 AM, Jann Horn wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 10:16:45AM -0400, Robert Foss wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On 2016-08-09 06:30 PM, Jann Horn wrote:</span>
<span class="quote">&gt;&gt;&gt; On Tue, Aug 09, 2016 at 05:01:44PM -0400, Robert Foss wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +	hold_task_mempolicy(priv);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +	for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +		struct mem_size_stats mss;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +		struct mm_walk smaps_walk = {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +			.pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +			.mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +			.private = &amp;mss,</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +		};</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +		if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +			memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +			walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +			add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +		}</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; +	}</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Errrr... what? You accumulate values from mem_size_stats items into a</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; struct mss_sum that is associated with the struct file? So when you</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; read the file the second time, you get the old values plus the new ones?</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; And when you read the file in parallel, you get inconsistent values?</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; For most files in procfs, the behavior is that you can just call</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; pread(fd, buf, sizeof(buf), 0) on the same fd again and again, giving</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; you the current values every time, without mutating state. I strongly</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; recommend that you get rid of priv-&gt;mss and just accumulate the state</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; in a local variable (maybe one on the stack).</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; So a simple &quot;static struct mem_size_stats&quot; in totmaps_proc_show() would be a</span>
<span class="quote">&gt;&gt;&gt;&gt; better solution?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Er, why &quot;static&quot;? Are you trying to create shared state between different</span>
<span class="quote">&gt;&gt;&gt; readers for some reason?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I think I&#39;m a bit confused now, how are you suggesting that I replace</span>
<span class="quote">&gt;&gt; priv-&gt;mss?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Like this:</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; {</span>
<span class="quote">&gt;         struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;         struct mm_struct *mm;</span>
<span class="quote">&gt;         struct vm_area_struct *vma;</span>
<span class="quote">&gt;         struct mem_size_stats mss_sum;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         memset(&amp;mss_sum, 0, sizeof(mss_sum));</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         [...]</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;         for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt;                 struct mem_size_stats mss;</span>
<span class="quote">&gt;                 struct mm_walk smaps_walk = {</span>
<span class="quote">&gt;                         .pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt;                         .mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt;                         .private = &amp;mss,</span>
<span class="quote">&gt;                 };</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;                 if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt;                         memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt;                         walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt;                         add_smaps_sum(&amp;mss, &amp;mss_sum);</span>
<span class="quote">&gt;                 }</span>
<span class="quote">&gt;         }</span>
<span class="quote">&gt;         seq_printf(m,</span>
<span class="quote">&gt;                    &quot;Rss:            %8lu kB\n&quot;</span>
<span class="quote">&gt;                    &quot;Pss:            %8lu kB\n&quot;</span>
<span class="quote">&gt;                    &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="quote">&gt;                    [...],</span>
<span class="quote">&gt;                    mss_sum.resident &gt;&gt; 10,</span>
<span class="quote">&gt;                    (unsigned long)(mss_sum.pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt;                    mss_sum.shared_clean  &gt;&gt; 10,</span>
<span class="quote">&gt;                    [...]);</span>
<span class="quote">&gt;         [...]</span>
<span class="quote">&gt; }</span>
<span class="quote">&gt;</span>


Thanks Jann for being really clear about this stuff. It is much appreciated!
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=26032">Sonny Rao</a> - Aug. 10, 2016, 5:23 p.m.</div>
<pre class="content">
On Tue, Aug 9, 2016 at 2:01 PM, Robert Foss &lt;robert.foss@collabora.com&gt; wrote:
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt;&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt;&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt;&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt;&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt;&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt;&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; This new proc file provides information faster than parsing the</span>
<span class="quote">&gt;&gt;&gt; potentially</span>
<span class="quote">&gt;&gt;&gt; huge smaps file.</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;&gt;&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt;&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt;&gt;&gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt;&gt; +       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt;&gt; +       /* but need to get the mm here because */</span>
<span class="quote">&gt;&gt;&gt; +       /* task could be in the process of exiting */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Can you please elaborate on this? My understanding here is that you</span>
<span class="quote">&gt;&gt; intend for the caller to be able to repeatedly read the same totmaps</span>
<span class="quote">&gt;&gt; file with pread() and still see updated information after the target</span>
<span class="quote">&gt;&gt; process has called execve() and be able to detect process death</span>
<span class="quote">&gt;&gt; (instead of simply seeing stale values). Is that accurate?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I would prefer it if you could grab a reference to the mm_struct</span>
<span class="quote">&gt;&gt; directly at open time.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Sonny, do you know more about the above comment?</span>

I think right now the file gets re-opened every time, but the mode
where the file is opened once and repeatedly read is interesting
because it avoids having to open the file again and again.

I guess you could end up with a wierd situation where you don&#39;t read
the entire contents of the file in open call to read() and you might
get inconsistent data across the different statistics?
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +       mm = get_task_mm(priv-&gt;task);</span>
<span class="quote">&gt;&gt;&gt; +       if (!mm || IS_ERR(mm))</span>
<span class="quote">&gt;&gt;&gt; +               return -EINVAL;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; get_task_mm() doesn&#39;t return error codes, and all other callers just</span>
<span class="quote">&gt;&gt; check whether the return value is NULL.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;ll have that fixed in v2, thanks for spotting it!</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +       down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="quote">&gt;&gt;&gt; +       hold_task_mempolicy(priv);</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +       for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="quote">&gt;&gt;&gt; +               struct mem_size_stats mss;</span>
<span class="quote">&gt;&gt;&gt; +               struct mm_walk smaps_walk = {</span>
<span class="quote">&gt;&gt;&gt; +                       .pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt;&gt;&gt; +                       .mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt;&gt;&gt; +                       .private = &amp;mss,</span>
<span class="quote">&gt;&gt;&gt; +               };</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +               if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="quote">&gt;&gt;&gt; +                       memset(&amp;mss, 0, sizeof(mss));</span>
<span class="quote">&gt;&gt;&gt; +                       walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt;&gt;&gt; +                       add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="quote">&gt;&gt;&gt; +               }</span>
<span class="quote">&gt;&gt;&gt; +       }</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Errrr... what? You accumulate values from mem_size_stats items into a</span>
<span class="quote">&gt;&gt; struct mss_sum that is associated with the struct file? So when you</span>
<span class="quote">&gt;&gt; read the file the second time, you get the old values plus the new ones?</span>
<span class="quote">&gt;&gt; And when you read the file in parallel, you get inconsistent values?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; For most files in procfs, the behavior is that you can just call</span>
<span class="quote">&gt;&gt; pread(fd, buf, sizeof(buf), 0) on the same fd again and again, giving</span>
<span class="quote">&gt;&gt; you the current values every time, without mutating state. I strongly</span>
<span class="quote">&gt;&gt; recommend that you get rid of priv-&gt;mss and just accumulate the state</span>
<span class="quote">&gt;&gt; in a local variable (maybe one on the stack).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So a simple &quot;static struct mem_size_stats&quot; in totmaps_proc_show() would be a</span>
<span class="quote">&gt; better solution?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; @@ -836,6 +911,50 @@ static int tid_smaps_open(struct inode *inode,</span>
<span class="quote">&gt;&gt;&gt; struct file *file)</span>
<span class="quote">&gt;&gt;&gt;         return do_maps_open(inode, file, &amp;proc_tid_smaps_op);</span>
<span class="quote">&gt;&gt;&gt;  }</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt; +       struct proc_maps_private *priv;</span>
<span class="quote">&gt;&gt;&gt; +       int ret = -ENOMEM;</span>
<span class="quote">&gt;&gt;&gt; +       priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="quote">&gt;&gt;&gt; +       if (priv) {</span>
<span class="quote">&gt;&gt;&gt; +               priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="quote">&gt;&gt;&gt; +               if (!priv-&gt;mss)</span>
<span class="quote">&gt;&gt;&gt; +                       return -ENOMEM;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Memory leak: If the first allocation works and the second one doesn&#39;t,</span>
<span class="quote">&gt;&gt; this</span>
<span class="quote">&gt;&gt; doesn&#39;t free the first allocation.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Please change this to use the typical goto pattern for error handling.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Fix will be implemented in v2.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +               /* we need to grab references to the task_struct */</span>
<span class="quote">&gt;&gt;&gt; +               /* at open time, because there&#39;s a potential information</span>
<span class="quote">&gt;&gt;&gt; */</span>
<span class="quote">&gt;&gt;&gt; +               /* leak where the totmaps file is opened and held open */</span>
<span class="quote">&gt;&gt;&gt; +               /* while the underlying pid to task mapping changes */</span>
<span class="quote">&gt;&gt;&gt; +               /* underneath it */</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Nit: That&#39;s not how comments are done in the kernel. Maybe change this to</span>
<span class="quote">&gt;&gt; a normal block comment instead of one block comment per line?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I&#39;m not sure how that one slipped by, but I&#39;ll change it in v2.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; +               priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; `get_pid_task(proc_pid(inode), PIDTYPE_PID)` is exactly the definition</span>
<span class="quote">&gt;&gt; of get_proc_task(inode), maybe use that instead?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Will do. v2 will fix this.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;&gt; +               if (!priv-&gt;task) {</span>
<span class="quote">&gt;&gt;&gt; +                       kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt;&gt; +                       kfree(priv);</span>
<span class="quote">&gt;&gt;&gt; +                       return -ESRCH;</span>
<span class="quote">&gt;&gt;&gt; +               }</span>
<span class="quote">&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt; +               ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="quote">&gt;&gt;&gt; +               if (ret) {</span>
<span class="quote">&gt;&gt;&gt; +                       put_task_struct(priv-&gt;task);</span>
<span class="quote">&gt;&gt;&gt; +                       kfree(priv-&gt;mss);</span>
<span class="quote">&gt;&gt;&gt; +                       kfree(priv);</span>
<span class="quote">&gt;&gt;&gt; +               }</span>
<span class="quote">&gt;&gt;&gt; +       }</span>
<span class="quote">&gt;&gt;&gt; +       return ret;</span>
<span class="quote">&gt;&gt;&gt; +}</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Please change this method to use the typical goto pattern for error</span>
<span class="quote">&gt;&gt; handling. IMO repeating the undo steps in all error cases makes</span>
<span class="quote">&gt;&gt; mistakes (like the one above) more likely and increases the amount</span>
<span class="quote">&gt;&gt; of redundant code.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Agreed. Change queued for v2.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Also: The smaps file is only accessible to callers with</span>
<span class="quote">&gt;&gt; PTRACE_MODE_READ privileges on the target task. Your thing doesn&#39;t</span>
<span class="quote">&gt;&gt; do any access checks, neither in the open handler nor in the read</span>
<span class="quote">&gt;&gt; handler. Can you give an analysis of why it&#39;s okay to expose this</span>
<span class="quote">&gt;&gt; data? As far as I can tell, without spending a lot of time thinking</span>
<span class="quote">&gt;&gt; about it, this kind of data looks like it might potentially be</span>
<span class="quote">&gt;&gt; useful for side-channel information leaks or so.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I think it should require the same permissions as smaps, so changing the</span>
<span class="quote">&gt; code to require PTRACE_MODE_READ privileges is most likely a good idea. I&#39;ll</span>
<span class="quote">&gt; have a look at it for v2.</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Aug. 10, 2016, 5:37 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 10:23:53AM -0700, Sonny Rao wrote:
<span class="quote">&gt; On Tue, Aug 9, 2016 at 2:01 PM, Robert Foss &lt;robert.foss@collabora.com&gt; wrote:</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; &gt;&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; &gt;&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; &gt;&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; &gt;&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; &gt;&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; &gt;&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; This new proc file provides information faster than parsing the</span>
<span class="quote">&gt; &gt;&gt;&gt; potentially</span>
<span class="quote">&gt; &gt;&gt;&gt; huge smaps file.</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt;&gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; &gt;&gt;&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt; &gt;&gt;&gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt; &gt;&gt;&gt; +       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt;&gt; +       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; &gt;&gt;&gt; +       /* but need to get the mm here because */</span>
<span class="quote">&gt; &gt;&gt;&gt; +       /* task could be in the process of exiting */</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; Can you please elaborate on this? My understanding here is that you</span>
<span class="quote">&gt; &gt;&gt; intend for the caller to be able to repeatedly read the same totmaps</span>
<span class="quote">&gt; &gt;&gt; file with pread() and still see updated information after the target</span>
<span class="quote">&gt; &gt;&gt; process has called execve() and be able to detect process death</span>
<span class="quote">&gt; &gt;&gt; (instead of simply seeing stale values). Is that accurate?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I would prefer it if you could grab a reference to the mm_struct</span>
<span class="quote">&gt; &gt;&gt; directly at open time.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Sonny, do you know more about the above comment?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think right now the file gets re-opened every time, but the mode</span>
<span class="quote">&gt; where the file is opened once and repeatedly read is interesting</span>
<span class="quote">&gt; because it avoids having to open the file again and again.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I guess you could end up with a wierd situation where you don&#39;t read</span>
<span class="quote">&gt; the entire contents of the file in open call to read() and you might</span>
<span class="quote">&gt; get inconsistent data across the different statistics?</span>

If the file is read in two chunks, totmaps_proc_show is only called
once. The patch specifies seq_read as read handler. Have a look at its
definition. As long as you don&#39;t read from the same seq file in
parallel or seek around in it, simple sequential reads will not
re-invoke the show() method for data that has already been formatted.
For partially consumed data, the kernel buffers the rest until someone
reads it or seeks to another offset.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=26032">Sonny Rao</a> - Aug. 10, 2016, 5:45 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 10:37 AM, Jann Horn &lt;jann@thejh.net&gt; wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 10:23:53AM -0700, Sonny Rao wrote:</span>
<span class="quote">&gt;&gt; On Tue, Aug 9, 2016 at 2:01 PM, Robert Foss &lt;robert.foss@collabora.com&gt; wrote:</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; This new proc file provides information faster than parsing the</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; potentially</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; huge smaps file.</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       /* but need to get the mm here because */</span>
<span class="quote">&gt;&gt; &gt;&gt;&gt; +       /* task could be in the process of exiting */</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; Can you please elaborate on this? My understanding here is that you</span>
<span class="quote">&gt;&gt; &gt;&gt; intend for the caller to be able to repeatedly read the same totmaps</span>
<span class="quote">&gt;&gt; &gt;&gt; file with pread() and still see updated information after the target</span>
<span class="quote">&gt;&gt; &gt;&gt; process has called execve() and be able to detect process death</span>
<span class="quote">&gt;&gt; &gt;&gt; (instead of simply seeing stale values). Is that accurate?</span>
<span class="quote">&gt;&gt; &gt;&gt;</span>
<span class="quote">&gt;&gt; &gt;&gt; I would prefer it if you could grab a reference to the mm_struct</span>
<span class="quote">&gt;&gt; &gt;&gt; directly at open time.</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt;</span>
<span class="quote">&gt;&gt; &gt; Sonny, do you know more about the above comment?</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I think right now the file gets re-opened every time, but the mode</span>
<span class="quote">&gt;&gt; where the file is opened once and repeatedly read is interesting</span>
<span class="quote">&gt;&gt; because it avoids having to open the file again and again.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; I guess you could end up with a wierd situation where you don&#39;t read</span>
<span class="quote">&gt;&gt; the entire contents of the file in open call to read() and you might</span>
<span class="quote">&gt;&gt; get inconsistent data across the different statistics?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; If the file is read in two chunks, totmaps_proc_show is only called</span>
<span class="quote">&gt; once. The patch specifies seq_read as read handler. Have a look at its</span>
<span class="quote">&gt; definition. As long as you don&#39;t read from the same seq file in</span>
<span class="quote">&gt; parallel or seek around in it, simple sequential reads will not</span>
<span class="quote">&gt; re-invoke the show() method for data that has already been formatted.</span>
<span class="quote">&gt; For partially consumed data, the kernel buffers the rest until someone</span>
<span class="quote">&gt; reads it or seeks to another offset.</span>

Ok that&#39;s good.  If the consumer were using pread() though, would that
look like a seek?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Aug. 10, 2016, 6:05 p.m.</div>
<pre class="content">
On Wed, Aug 10, 2016 at 10:45:51AM -0700, Sonny Rao wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 10:37 AM, Jann Horn &lt;jann@thejh.net&gt; wrote:</span>
<span class="quote">&gt; &gt; On Wed, Aug 10, 2016 at 10:23:53AM -0700, Sonny Rao wrote:</span>
<span class="quote">&gt; &gt;&gt; On Tue, Aug 9, 2016 at 2:01 PM, Robert Foss &lt;robert.foss@collabora.com&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; This new proc file provides information faster than parsing the</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; potentially</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; huge smaps file.</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +{</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +       /* but need to get the mm here because */</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;&gt; +       /* task could be in the process of exiting */</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; Can you please elaborate on this? My understanding here is that you</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; intend for the caller to be able to repeatedly read the same totmaps</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; file with pread() and still see updated information after the target</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; process has called execve() and be able to detect process death</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; (instead of simply seeing stale values). Is that accurate?</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; I would prefer it if you could grab a reference to the mm_struct</span>
<span class="quote">&gt; &gt;&gt; &gt;&gt; directly at open time.</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt;</span>
<span class="quote">&gt; &gt;&gt; &gt; Sonny, do you know more about the above comment?</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I think right now the file gets re-opened every time, but the mode</span>
<span class="quote">&gt; &gt;&gt; where the file is opened once and repeatedly read is interesting</span>
<span class="quote">&gt; &gt;&gt; because it avoids having to open the file again and again.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt; I guess you could end up with a wierd situation where you don&#39;t read</span>
<span class="quote">&gt; &gt;&gt; the entire contents of the file in open call to read() and you might</span>
<span class="quote">&gt; &gt;&gt; get inconsistent data across the different statistics?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; If the file is read in two chunks, totmaps_proc_show is only called</span>
<span class="quote">&gt; &gt; once. The patch specifies seq_read as read handler. Have a look at its</span>
<span class="quote">&gt; &gt; definition. As long as you don&#39;t read from the same seq file in</span>
<span class="quote">&gt; &gt; parallel or seek around in it, simple sequential reads will not</span>
<span class="quote">&gt; &gt; re-invoke the show() method for data that has already been formatted.</span>
<span class="quote">&gt; &gt; For partially consumed data, the kernel buffers the rest until someone</span>
<span class="quote">&gt; &gt; reads it or seeks to another offset.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Ok that&#39;s good.  If the consumer were using pread() though, would that</span>
<span class="quote">&gt; look like a seek?</span>

Only if the consumer uses pread() with an offset that is not the same as
the end offset of the previous read.

So if you tried to use the same file from multiple threads in parallel,
you might still have issues, but as long as you don&#39;t do that, it should
be fine.

I guess it might make sense to document this behavior somewhere - maybe
the proc.5 manpage?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=161351">robert.foss@collabora.com</a> - Aug. 12, 2016, 4:28 p.m.</div>
<pre class="content">
On 2016-08-10 02:05 PM, Jann Horn wrote:
<span class="quote">&gt; On Wed, Aug 10, 2016 at 10:45:51AM -0700, Sonny Rao wrote:</span>
<span class="quote">&gt;&gt; On Wed, Aug 10, 2016 at 10:37 AM, Jann Horn &lt;jann@thejh.net&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt; On Wed, Aug 10, 2016 at 10:23:53AM -0700, Sonny Rao wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt; On Tue, Aug 9, 2016 at 2:01 PM, Robert Foss &lt;robert.foss@collabora.com&gt; wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; This new proc file provides information faster than parsing the</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; potentially</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; huge smaps file.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +{</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +       struct mm_struct *mm;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +       struct vm_area_struct *vma;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +       /* but need to get the mm here because */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;&gt; +       /* task could be in the process of exiting */</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; Can you please elaborate on this? My understanding here is that you</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; intend for the caller to be able to repeatedly read the same totmaps</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; file with pread() and still see updated information after the target</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; process has called execve() and be able to detect process death</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; (instead of simply seeing stale values). Is that accurate?</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; I would prefer it if you could grab a reference to the mm_struct</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;&gt; directly at open time.</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt;&gt; Sonny, do you know more about the above comment?</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I think right now the file gets re-opened every time, but the mode</span>
<span class="quote">&gt;&gt;&gt;&gt; where the file is opened once and repeatedly read is interesting</span>
<span class="quote">&gt;&gt;&gt;&gt; because it avoids having to open the file again and again.</span>
<span class="quote">&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt;&gt; I guess you could end up with a wierd situation where you don&#39;t read</span>
<span class="quote">&gt;&gt;&gt;&gt; the entire contents of the file in open call to read() and you might</span>
<span class="quote">&gt;&gt;&gt;&gt; get inconsistent data across the different statistics?</span>
<span class="quote">&gt;&gt;&gt;</span>
<span class="quote">&gt;&gt;&gt; If the file is read in two chunks, totmaps_proc_show is only called</span>
<span class="quote">&gt;&gt;&gt; once. The patch specifies seq_read as read handler. Have a look at its</span>
<span class="quote">&gt;&gt;&gt; definition. As long as you don&#39;t read from the same seq file in</span>
<span class="quote">&gt;&gt;&gt; parallel or seek around in it, simple sequential reads will not</span>
<span class="quote">&gt;&gt;&gt; re-invoke the show() method for data that has already been formatted.</span>
<span class="quote">&gt;&gt;&gt; For partially consumed data, the kernel buffers the rest until someone</span>
<span class="quote">&gt;&gt;&gt; reads it or seeks to another offset.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Ok that&#39;s good.  If the consumer were using pread() though, would that</span>
<span class="quote">&gt;&gt; look like a seek?</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Only if the consumer uses pread() with an offset that is not the same as</span>
<span class="quote">&gt; the end offset of the previous read.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; So if you tried to use the same file from multiple threads in parallel,</span>
<span class="quote">&gt; you might still have issues, but as long as you don&#39;t do that, it should</span>
<span class="quote">&gt; be fine.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I guess it might make sense to document this behavior somewhere - maybe</span>
<span class="quote">&gt; the proc.5 manpage?</span>
<span class="quote">&gt;</span>

I&#39;ll add a note about limitations for parallel read. The overall 
documentation for this feature should live in the proc.5 manpage as well?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=96711">Jann Horn</a> - Aug. 13, 2016, 12:39 p.m.</div>
<pre class="content">
On Fri, Aug 12, 2016 at 12:28:11PM -0400, Robert Foss wrote:
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On 2016-08-10 02:05 PM, Jann Horn wrote:</span>
<span class="quote">&gt; &gt;On Wed, Aug 10, 2016 at 10:45:51AM -0700, Sonny Rao wrote:</span>
<span class="quote">&gt; &gt;&gt;On Wed, Aug 10, 2016 at 10:37 AM, Jann Horn &lt;jann@thejh.net&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;On Wed, Aug 10, 2016 at 10:23:53AM -0700, Sonny Rao wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;On Tue, Aug 9, 2016 at 2:01 PM, Robert Foss &lt;robert.foss@collabora.com&gt; wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;On 2016-08-09 03:24 PM, Jann Horn wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;On Tue, Aug 09, 2016 at 12:05:43PM -0400, robert.foss@collabora.com wrote:</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;From: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;This is based on earlier work by Thiago Goncales. It implements a new</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;per process proc file which summarizes the contents of the smaps file</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;but doesn&#39;t display any addresses.  It gives more detailed information</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;than statm like the PSS (proprotional set size).  It differs from the</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;original implementation in that it doesn&#39;t use the full blown set of</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;seq operations, uses a different termination condition, and doesn&#39;t</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;displayed &quot;Locked&quot; as that was broken on the original implemenation.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;This new proc file provides information faster than parsing the</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;potentially</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;huge smaps file.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;Signed-off-by: Sonny Rao &lt;sonnyrao@chromium.org&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;Tested-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;Signed-off-by: Robert Foss &lt;robert.foss@collabora.com&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+{</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+       struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+       struct mm_struct *mm;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+       struct vm_area_struct *vma;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+       struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+       /* reference to priv-&gt;task already taken */</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+       /* but need to get the mm here because */</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;&gt;+       /* task could be in the process of exiting */</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;Can you please elaborate on this? My understanding here is that you</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;intend for the caller to be able to repeatedly read the same totmaps</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;file with pread() and still see updated information after the target</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;process has called execve() and be able to detect process death</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;(instead of simply seeing stale values). Is that accurate?</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;I would prefer it if you could grab a reference to the mm_struct</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;&gt;directly at open time.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;&gt;Sonny, do you know more about the above comment?</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;I think right now the file gets re-opened every time, but the mode</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;where the file is opened once and repeatedly read is interesting</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;because it avoids having to open the file again and again.</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;I guess you could end up with a wierd situation where you don&#39;t read</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;the entire contents of the file in open call to read() and you might</span>
<span class="quote">&gt; &gt;&gt;&gt;&gt;get inconsistent data across the different statistics?</span>
<span class="quote">&gt; &gt;&gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;&gt;If the file is read in two chunks, totmaps_proc_show is only called</span>
<span class="quote">&gt; &gt;&gt;&gt;once. The patch specifies seq_read as read handler. Have a look at its</span>
<span class="quote">&gt; &gt;&gt;&gt;definition. As long as you don&#39;t read from the same seq file in</span>
<span class="quote">&gt; &gt;&gt;&gt;parallel or seek around in it, simple sequential reads will not</span>
<span class="quote">&gt; &gt;&gt;&gt;re-invoke the show() method for data that has already been formatted.</span>
<span class="quote">&gt; &gt;&gt;&gt;For partially consumed data, the kernel buffers the rest until someone</span>
<span class="quote">&gt; &gt;&gt;&gt;reads it or seeks to another offset.</span>
<span class="quote">&gt; &gt;&gt;</span>
<span class="quote">&gt; &gt;&gt;Ok that&#39;s good.  If the consumer were using pread() though, would that</span>
<span class="quote">&gt; &gt;&gt;look like a seek?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;Only if the consumer uses pread() with an offset that is not the same as</span>
<span class="quote">&gt; &gt;the end offset of the previous read.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;So if you tried to use the same file from multiple threads in parallel,</span>
<span class="quote">&gt; &gt;you might still have issues, but as long as you don&#39;t do that, it should</span>
<span class="quote">&gt; &gt;be fine.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt;I guess it might make sense to document this behavior somewhere - maybe</span>
<span class="quote">&gt; &gt;the proc.5 manpage?</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I&#39;ll add a note about limitations for parallel read. The overall</span>
<span class="quote">&gt; documentation for this feature should live in the proc.5 manpage as well?</span>

Yes, I think so.

+Cc linux-api@vger.kernel.org
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index a11eb71..de3acdf 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -2855,6 +2855,7 @@</span> <span class="p_context"> static const struct pid_entry tgid_base_stuff[] = {</span>
 	REG(&quot;clear_refs&quot;, S_IWUSR, proc_clear_refs_operations),
 	REG(&quot;smaps&quot;,      S_IRUGO, proc_pid_smaps_operations),
 	REG(&quot;pagemap&quot;,    S_IRUSR, proc_pagemap_operations),
<span class="p_add">+	REG(&quot;totmaps&quot;,    S_IRUGO, proc_totmaps_operations),</span>
 #endif
 #ifdef CONFIG_SECURITY
 	DIR(&quot;attr&quot;,       S_IRUGO|S_IXUGO, proc_attr_dir_inode_operations, proc_attr_dir_operations),
<span class="p_header">diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="p_header">index aa27810..6f3540f 100644</span>
<span class="p_header">--- a/fs/proc/internal.h</span>
<span class="p_header">+++ b/fs/proc/internal.h</span>
<span class="p_chunk">@@ -58,6 +58,9 @@</span> <span class="p_context"> union proc_op {</span>
 		struct task_struct *task);
 };
 
<span class="p_add">+</span>
<span class="p_add">+extern const struct file_operations proc_totmaps_operations;</span>
<span class="p_add">+</span>
 struct proc_inode {
 	struct pid *pid;
 	int fd;
<span class="p_chunk">@@ -281,6 +284,7 @@</span> <span class="p_context"> struct proc_maps_private {</span>
 	struct mm_struct *mm;
 #ifdef CONFIG_MMU
 	struct vm_area_struct *tail_vma;
<span class="p_add">+	struct mem_size_stats *mss;</span>
 #endif
 #ifdef CONFIG_NUMA
 	struct mempolicy *task_mempolicy;
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index 4648c7f..b61873e 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -802,6 +802,81 @@</span> <span class="p_context"> static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
 	return 0;
 }
 
<span class="p_add">+static void add_smaps_sum(struct mem_size_stats *mss,</span>
<span class="p_add">+		struct mem_size_stats *mss_sum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mss_sum-&gt;resident += mss-&gt;resident;</span>
<span class="p_add">+	mss_sum-&gt;pss += mss-&gt;pss;</span>
<span class="p_add">+	mss_sum-&gt;shared_clean += mss-&gt;shared_clean;</span>
<span class="p_add">+	mss_sum-&gt;shared_dirty += mss-&gt;shared_dirty;</span>
<span class="p_add">+	mss_sum-&gt;private_clean += mss-&gt;private_clean;</span>
<span class="p_add">+	mss_sum-&gt;private_dirty += mss-&gt;private_dirty;</span>
<span class="p_add">+	mss_sum-&gt;referenced += mss-&gt;referenced;</span>
<span class="p_add">+	mss_sum-&gt;anonymous += mss-&gt;anonymous;</span>
<span class="p_add">+	mss_sum-&gt;anonymous_thp += mss-&gt;anonymous_thp;</span>
<span class="p_add">+	mss_sum-&gt;swap += mss-&gt;swap;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int totmaps_proc_show(struct seq_file *m, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct proc_maps_private *priv = m-&gt;private;</span>
<span class="p_add">+	struct mm_struct *mm;</span>
<span class="p_add">+	struct vm_area_struct *vma;</span>
<span class="p_add">+	struct mem_size_stats *mss_sum = priv-&gt;mss;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* reference to priv-&gt;task already taken */</span>
<span class="p_add">+	/* but need to get the mm here because */</span>
<span class="p_add">+	/* task could be in the process of exiting */</span>
<span class="p_add">+	mm = get_task_mm(priv-&gt;task);</span>
<span class="p_add">+	if (!mm || IS_ERR(mm))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	hold_task_mempolicy(priv);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (vma = mm-&gt;mmap; vma != priv-&gt;tail_vma; vma = vma-&gt;vm_next) {</span>
<span class="p_add">+		struct mem_size_stats mss;</span>
<span class="p_add">+		struct mm_walk smaps_walk = {</span>
<span class="p_add">+			.pmd_entry = smaps_pte_range,</span>
<span class="p_add">+			.mm = vma-&gt;vm_mm,</span>
<span class="p_add">+			.private = &amp;mss,</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
<span class="p_add">+		if (vma-&gt;vm_mm &amp;&amp; !is_vm_hugetlb_page(vma)) {</span>
<span class="p_add">+			memset(&amp;mss, 0, sizeof(mss));</span>
<span class="p_add">+			walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="p_add">+			add_smaps_sum(&amp;mss, mss_sum);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	seq_printf(m,</span>
<span class="p_add">+		   &quot;Rss:            %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Pss:            %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="p_add">+		   &quot;Swap:           %8lu kB\n&quot;,</span>
<span class="p_add">+		   mss_sum-&gt;resident &gt;&gt; 10,</span>
<span class="p_add">+		   (unsigned long)(mss_sum-&gt;pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="p_add">+		   mss_sum-&gt;shared_clean  &gt;&gt; 10,</span>
<span class="p_add">+		   mss_sum-&gt;shared_dirty  &gt;&gt; 10,</span>
<span class="p_add">+		   mss_sum-&gt;private_clean &gt;&gt; 10,</span>
<span class="p_add">+		   mss_sum-&gt;private_dirty &gt;&gt; 10,</span>
<span class="p_add">+		   mss_sum-&gt;referenced &gt;&gt; 10,</span>
<span class="p_add">+		   mss_sum-&gt;anonymous &gt;&gt; 10,</span>
<span class="p_add">+		   mss_sum-&gt;anonymous_thp &gt;&gt; 10,</span>
<span class="p_add">+		   mss_sum-&gt;swap &gt;&gt; 10);</span>
<span class="p_add">+</span>
<span class="p_add">+	release_task_mempolicy(priv);</span>
<span class="p_add">+	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	mmput(mm);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int show_pid_smap(struct seq_file *m, void *v)
 {
 	return show_smap(m, v, 1);
<span class="p_chunk">@@ -836,6 +911,50 @@</span> <span class="p_context"> static int tid_smaps_open(struct inode *inode, struct file *file)</span>
 	return do_maps_open(inode, file, &amp;proc_tid_smaps_op);
 }
 
<span class="p_add">+static int totmaps_open(struct inode *inode, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct proc_maps_private *priv;</span>
<span class="p_add">+	int ret = -ENOMEM;</span>
<span class="p_add">+	priv = kzalloc(sizeof(*priv), GFP_KERNEL);</span>
<span class="p_add">+	if (priv) {</span>
<span class="p_add">+		priv-&gt;mss = kzalloc(sizeof(*priv-&gt;mss), GFP_KERNEL);</span>
<span class="p_add">+		if (!priv-&gt;mss)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* we need to grab references to the task_struct */</span>
<span class="p_add">+		/* at open time, because there&#39;s a potential information */</span>
<span class="p_add">+		/* leak where the totmaps file is opened and held open */</span>
<span class="p_add">+		/* while the underlying pid to task mapping changes */</span>
<span class="p_add">+		/* underneath it */</span>
<span class="p_add">+		priv-&gt;task = get_pid_task(proc_pid(inode), PIDTYPE_PID);</span>
<span class="p_add">+		if (!priv-&gt;task) {</span>
<span class="p_add">+			kfree(priv-&gt;mss);</span>
<span class="p_add">+			kfree(priv);</span>
<span class="p_add">+			return -ESRCH;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = single_open(file, totmaps_proc_show, priv);</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			put_task_struct(priv-&gt;task);</span>
<span class="p_add">+			kfree(priv-&gt;mss);</span>
<span class="p_add">+			kfree(priv);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int totmaps_release(struct inode *inode, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct seq_file *m = file-&gt;private_data;</span>
<span class="p_add">+	struct proc_maps_private *priv = m-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	put_task_struct(priv-&gt;task);</span>
<span class="p_add">+	kfree(priv-&gt;mss);</span>
<span class="p_add">+	kfree(priv);</span>
<span class="p_add">+	m-&gt;private = NULL;</span>
<span class="p_add">+	return single_release(inode, file);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 const struct file_operations proc_pid_smaps_operations = {
 	.open		= pid_smaps_open,
 	.read		= seq_read,
<span class="p_chunk">@@ -850,6 +969,13 @@</span> <span class="p_context"> const struct file_operations proc_tid_smaps_operations = {</span>
 	.release	= proc_map_release,
 };
 
<span class="p_add">+const struct file_operations proc_totmaps_operations = {</span>
<span class="p_add">+	.open		= totmaps_open,</span>
<span class="p_add">+	.read		= seq_read,</span>
<span class="p_add">+	.llseek		= seq_lseek,</span>
<span class="p_add">+	.release	= totmaps_release,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 enum clear_refs_types {
 	CLEAR_REFS_ALL = 1,
 	CLEAR_REFS_ANON,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



