
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.3 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.3</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 26, 2016, 5:27 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160226052732.GB30420@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8431311/mbox/"
   >mbox</a>
|
   <a href="/patch/8431311/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8431311/">/patch/8431311/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 29B26C0553
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 26 Feb 2016 05:28:13 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id B564620397
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 26 Feb 2016 05:28:04 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 301CC20392
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 26 Feb 2016 05:27:56 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753391AbcBZF1o (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 26 Feb 2016 00:27:44 -0500
Received: from mail12.wdc04.mandrillapp.com ([205.201.139.12]:50436 &quot;EHLO
	mail12.wdc04.mandrillapp.com&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1752783AbcBZF1g (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 26 Feb 2016 00:27:36 -0500
DKIM-Signature: v=1; a=rsa-sha1; c=relaxed/relaxed; s=mandrill;
	d=linuxfoundation.org; 
	h=From:Subject:To:Cc:Message-Id:References:In-Reply-To:Date:MIME-Version:Content-Type:Content-Transfer-Encoding;
	i=gregkh@linuxfoundation.org; 
	bh=QhZx9x0F9jPrAxAz97uPcviCOXQ=;
	b=iSAvBltmv9yxTtMLw2B5iNSo1Uo5fdKh3qYW9+kZfAq/+8mBmwiyRpE/di54sKcDlbgB3samKDDy
	rmfCi7zkKfYHgeuKDC3MwF6ID+xCAHPXLA3x9LF3Zawj/MVpimiST5Ee4yujWknqVfgDq4X/x3zx
	TnUCEOWMU0scYUmrwY0=
DomainKey-Signature: a=rsa-sha1; c=nofws; q=dns; s=mandrill;
	d=linuxfoundation.org; 
	b=oeIAmjSDSCOfze6C2Z3IJzutdalYA09pOXFrxai/mYVHrYxUMeWAHQQDajTvxfDYsVUL45rH+lEe
	lG4Tbvh4UNTg1RzVC2oVUb9LPBGXTWhSuw+YGrhjxBS5KKU5MhARpCkP6kh/nNMNhUdBYZs3agUY
	gSqQ4chfno2N2r8CWps=;
Received: from pmta05.wdc01.mailchimp.com (127.0.0.1) by
	mail12.wdc04.mandrillapp.com id hpvh4g1jvjgs for
	&lt;linux-kernel@vger.kernel.org&gt;;
	Fri, 26 Feb 2016 05:27:35 +0000 (envelope-from
	&lt;bounce-md_30481620.56cfe247.v1-76f29e699ab04944a34a8665b69c1cfa@mandrillapp.com&gt;)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=mandrillapp.com; 
	i=@mandrillapp.com; q=dns/txt; s=mandrill; t=1456464455; h=From : 
	Subject : To : Cc : Message-Id : References : In-Reply-To : Date : 
	MIME-Version : Content-Type : Content-Transfer-Encoding : From : 
	Subject : Date : X-Mandrill-User : List-Unsubscribe; 
	bh=bihGqw2N8OuDuSa5gwNa18MO0uEfABo4dClUNYqxm0U=; 
	b=qDSg4ccLBvPaM3WCF9xrVMPB9C8QICQDBy2WvlteXR8a3coy8SylCNEFtZyU5bMo/lTKlb
	T16xc+LHpFb+T/uRwiKesZygvnW89ktsMn+cH9Tg+i3L0hc7umyyL8XEfzY1ncVg+7BB8XKA
	jTcvhFkIj4C3uI8FWD0kgX0yfWT3E=
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
Subject: Re: Linux 4.4.3
Received: from [50.170.35.168] by mandrillapp.com id
	76f29e699ab04944a34a8665b69c1cfa; Fri, 26 Feb 2016 05:27:35 +0000
To: &lt;linux-kernel@vger.kernel.org&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	&lt;torvalds@linux-foundation.org&gt;, &lt;stable@vger.kernel.org&gt;
Cc: &lt;lwn@lwn.net&gt;, Jiri Slaby &lt;jslaby@suse.cz&gt;
Message-Id: &lt;20160226052732.GB30420@kroah.com&gt;
References: &lt;20160226052724.GA30420@kroah.com&gt;
In-Reply-To: &lt;20160226052724.GA30420@kroah.com&gt;
X-Report-Abuse: Please forward a copy of this message, including all headers,
	to abuse@mandrill.com
X-Report-Abuse: You can also report abuse here:
	http://mandrillapp.com/contact/abuse?id=30481620.76f29e699ab04944a34a8665b69c1cfa
X-Mandrill-User: md_30481620
Date: Fri, 26 Feb 2016 05:27:35 +0000
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8
Content-Transfer-Encoding: 7bit
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.6 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, RCVD_IN_DNSWL_HI, RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY, 
	URIBL_GREY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Feb. 26, 2016, 5:27 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 233f83464814..d826f1b9eb02 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -10289,9 +10289,11 @@</span> <span class="p_context"> S:	Maintained</span>
 F:	drivers/net/ethernet/dlink/sundance.c
 
 SUPERH
<span class="p_add">+M:	Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;</span>
<span class="p_add">+M:	Rich Felker &lt;dalias@libc.org&gt;</span>
 L:	linux-sh@vger.kernel.org
 Q:	http://patchwork.kernel.org/project/linux-sh/list/
<span class="p_del">-S:	Orphan</span>
<span class="p_add">+S:	Maintained</span>
 F:	Documentation/sh/
 F:	arch/sh/
 F:	drivers/sh/
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index e7a2958eb771..802be10c40c5 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 2</span>
<span class="p_add">+SUBLEVEL = 3</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/boot/dts/armada-388-gp.dts b/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_header">index a633be3defda..cd316021d6ce 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/armada-388-gp.dts</span>
<span class="p_chunk">@@ -303,16 +303,6 @@</span> <span class="p_context"></span>
 		gpio = &lt;&amp;expander0 4 GPIO_ACTIVE_HIGH&gt;;
 	};
 
<span class="p_del">-	reg_usb2_1_vbus: v5-vbus1 {</span>
<span class="p_del">-		compatible = &quot;regulator-fixed&quot;;</span>
<span class="p_del">-		regulator-name = &quot;v5.0-vbus1&quot;;</span>
<span class="p_del">-		regulator-min-microvolt = &lt;5000000&gt;;</span>
<span class="p_del">-		regulator-max-microvolt = &lt;5000000&gt;;</span>
<span class="p_del">-		enable-active-high;</span>
<span class="p_del">-		regulator-always-on;</span>
<span class="p_del">-		gpio = &lt;&amp;expander0 4 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
 	reg_sata0: pwr-sata0 {
 		compatible = &quot;regulator-fixed&quot;;
 		regulator-name = &quot;pwr_en_sata0&quot;;
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d4_xplained.dts b/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_header">index 131614f28e75..569026e8f96c 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d4_xplained.dts</span>
<span class="p_chunk">@@ -86,10 +86,12 @@</span> <span class="p_context"></span>
 			macb0: ethernet@f8020000 {
 				phy-mode = &quot;rmii&quot;;
 				status = &quot;okay&quot;;
<span class="p_add">+				pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+				pinctrl-0 = &lt;&amp;pinctrl_macb0_rmii &amp;pinctrl_macb0_phy_irq&gt;;</span>
 
 				phy0: ethernet-phy@1 {
 					interrupt-parent = &lt;&amp;pioE&gt;;
<span class="p_del">-					interrupts = &lt;1 IRQ_TYPE_EDGE_FALLING&gt;;</span>
<span class="p_add">+					interrupts = &lt;1 IRQ_TYPE_LEVEL_LOW&gt;;</span>
 					reg = &lt;1&gt;;
 				};
 			};
<span class="p_chunk">@@ -152,6 +154,10 @@</span> <span class="p_context"></span>
 						atmel,pins =
 							&lt;AT91_PIOE 8 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_UP_DEGLITCH&gt;;
 					};
<span class="p_add">+					pinctrl_macb0_phy_irq: macb0_phy_irq_0 {</span>
<span class="p_add">+						atmel,pins =</span>
<span class="p_add">+							&lt;AT91_PIOE 1 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_UP_DEGLITCH&gt;;</span>
<span class="p_add">+					};</span>
 				};
 			};
 		};
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d4ek.dts b/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_header">index 2d4a33100af6..4e98cda97403 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_chunk">@@ -160,8 +160,15 @@</span> <span class="p_context"></span>
 			};
 
 			macb0: ethernet@f8020000 {
<span class="p_add">+				pinctrl-0 = &lt;&amp;pinctrl_macb0_rmii &amp;pinctrl_macb0_phy_irq&gt;;</span>
 				phy-mode = &quot;rmii&quot;;
 				status = &quot;okay&quot;;
<span class="p_add">+</span>
<span class="p_add">+				ethernet-phy@1 {</span>
<span class="p_add">+					reg = &lt;0x1&gt;;</span>
<span class="p_add">+					interrupt-parent = &lt;&amp;pioE&gt;;</span>
<span class="p_add">+					interrupts = &lt;1 IRQ_TYPE_LEVEL_LOW&gt;;</span>
<span class="p_add">+				};</span>
 			};
 
 			mmc1: mmc@fc000000 {
<span class="p_chunk">@@ -193,6 +200,10 @@</span> <span class="p_context"></span>
 
 			pinctrl@fc06a000 {
 				board {
<span class="p_add">+					pinctrl_macb0_phy_irq: macb0_phy_irq {</span>
<span class="p_add">+						atmel,pins =</span>
<span class="p_add">+							&lt;AT91_PIOE 1 AT91_PERIPH_GPIO AT91_PINCTRL_NONE&gt;;</span>
<span class="p_add">+					};</span>
 					pinctrl_mmc0_cd: mmc0_cd {
 						atmel,pins =
 							&lt;AT91_PIOE 5 AT91_PERIPH_GPIO AT91_PINCTRL_PULL_UP_DEGLITCH&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">index 36387b11451d..80f6c786a37e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_chunk">@@ -122,6 +122,7 @@</span> <span class="p_context"></span>
 		interrupt-parent = &lt;&amp;gpio5&gt;;
 		interrupts = &lt;24 IRQ_TYPE_LEVEL_HIGH&gt;; /* gpio 152 */
 		ref-clock-frequency = &lt;26000000&gt;;
<span class="p_add">+		tcxo-clock-frequency = &lt;26000000&gt;;</span>
 	};
 };
 
<span class="p_header">diff --git a/arch/arm/boot/dts/omap5-board-common.dtsi b/arch/arm/boot/dts/omap5-board-common.dtsi</span>
<span class="p_header">index 5cf76a1c5c75..41e80e7f20be 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/omap5-board-common.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/omap5-board-common.dtsi</span>
<span class="p_chunk">@@ -130,6 +130,16 @@</span> <span class="p_context"></span>
 	};
 };
 
<span class="p_add">+&amp;gpio8 {</span>
<span class="p_add">+	/* TI trees use GPIO instead of msecure, see also muxing */</span>
<span class="p_add">+	p234 {</span>
<span class="p_add">+		gpio-hog;</span>
<span class="p_add">+		gpios = &lt;10 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+		output-high;</span>
<span class="p_add">+		line-name = &quot;gpio8_234/msecure&quot;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 &amp;omap5_pmx_core {
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;
<span class="p_chunk">@@ -213,6 +223,13 @@</span> <span class="p_context"></span>
 		&gt;;
 	};
 
<span class="p_add">+	/* TI trees use GPIO mode; msecure mode does not work reliably? */</span>
<span class="p_add">+	palmas_msecure_pins: palmas_msecure_pins {</span>
<span class="p_add">+		pinctrl-single,pins = &lt;</span>
<span class="p_add">+			OMAP5_IOPAD(0x180, PIN_OUTPUT | MUX_MODE6) /* gpio8_234 */</span>
<span class="p_add">+		&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 	usbhost_pins: pinmux_usbhost_pins {
 		pinctrl-single,pins = &lt;
 			0x84 (PIN_INPUT | MUX_MODE0) /* usbb2_hsic_strobe */
<span class="p_chunk">@@ -278,6 +295,12 @@</span> <span class="p_context"></span>
 			&amp;usbhost_wkup_pins
 	&gt;;
 
<span class="p_add">+	palmas_sys_nirq_pins: pinmux_palmas_sys_nirq_pins {</span>
<span class="p_add">+		pinctrl-single,pins = &lt;</span>
<span class="p_add">+			OMAP5_IOPAD(0x068, PIN_INPUT_PULLUP | MUX_MODE0) /* sys_nirq1 */</span>
<span class="p_add">+		&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 	usbhost_wkup_pins: pinmux_usbhost_wkup_pins {
 		pinctrl-single,pins = &lt;
 			0x1A (PIN_OUTPUT | MUX_MODE0) /* fref_clk1_out, USB hub clk */
<span class="p_chunk">@@ -345,6 +368,8 @@</span> <span class="p_context"></span>
 		interrupt-controller;
 		#interrupt-cells = &lt;2&gt;;
 		ti,system-power-controller;
<span class="p_add">+		pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+		pinctrl-0 = &lt;&amp;palmas_sys_nirq_pins &amp;palmas_msecure_pins&gt;;</span>
 
 		extcon_usb3: palmas_usb {
 			compatible = &quot;ti,palmas-usb-vid&quot;;
<span class="p_chunk">@@ -358,6 +383,14 @@</span> <span class="p_context"></span>
 			#clock-cells = &lt;0&gt;;
 		};
 
<span class="p_add">+		rtc {</span>
<span class="p_add">+			compatible = &quot;ti,palmas-rtc&quot;;</span>
<span class="p_add">+			interrupt-parent = &lt;&amp;palmas&gt;;</span>
<span class="p_add">+			interrupts = &lt;8 IRQ_TYPE_NONE&gt;;</span>
<span class="p_add">+			ti,backup-battery-chargeable;</span>
<span class="p_add">+			ti,backup-battery-charge-high-current;</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
 		palmas_pmic {
 			compatible = &quot;ti,palmas-pmic&quot;;
 			interrupt-parent = &lt;&amp;palmas&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/sama5d4.dtsi b/arch/arm/boot/dts/sama5d4.dtsi</span>
<span class="p_header">index 2193637b9cd2..3daf8d5d7878 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sama5d4.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sama5d4.dtsi</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"></span>
 			dbgu: serial@fc069000 {
 				compatible = &quot;atmel,at91sam9260-dbgu&quot;, &quot;atmel,at91sam9260-usart&quot;;
 				reg = &lt;0xfc069000 0x200&gt;;
<span class="p_del">-				interrupts = &lt;2 IRQ_TYPE_LEVEL_HIGH 7&gt;;</span>
<span class="p_add">+				interrupts = &lt;45 IRQ_TYPE_LEVEL_HIGH 7&gt;;</span>
 				pinctrl-names = &quot;default&quot;;
 				pinctrl-0 = &lt;&amp;pinctrl_dbgu&gt;;
 				clocks = &lt;&amp;dbgu_clk&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/ste-nomadik-stn8815.dtsi b/arch/arm/boot/dts/ste-nomadik-stn8815.dtsi</span>
<span class="p_header">index d0c743853318..27a333eb8987 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/ste-nomadik-stn8815.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/ste-nomadik-stn8815.dtsi</span>
<span class="p_chunk">@@ -127,22 +127,14 @@</span> <span class="p_context"></span>
 			};
 			mmcsd_default_mode: mmcsd_default {
 				mmcsd_default_cfg1 {
<span class="p_del">-					/* MCCLK */</span>
<span class="p_del">-					pins = &quot;GPIO8_B10&quot;;</span>
<span class="p_del">-					ste,output = &lt;0&gt;;</span>
<span class="p_del">-				};</span>
<span class="p_del">-				mmcsd_default_cfg2 {</span>
<span class="p_del">-					/* MCCMDDIR, MCDAT0DIR, MCDAT31DIR, MCDATDIR2 */</span>
<span class="p_del">-					pins = &quot;GPIO10_C11&quot;, &quot;GPIO15_A12&quot;,</span>
<span class="p_del">-					&quot;GPIO16_C13&quot;, &quot;GPIO23_D15&quot;;</span>
<span class="p_del">-					ste,output = &lt;1&gt;;</span>
<span class="p_del">-				};</span>
<span class="p_del">-				mmcsd_default_cfg3 {</span>
<span class="p_del">-					/* MCCMD, MCDAT3-0, MCMSFBCLK */</span>
<span class="p_del">-					pins = &quot;GPIO9_A10&quot;, &quot;GPIO11_B11&quot;,</span>
<span class="p_del">-					&quot;GPIO12_A11&quot;, &quot;GPIO13_C12&quot;,</span>
<span class="p_del">-					&quot;GPIO14_B12&quot;, &quot;GPIO24_C15&quot;;</span>
<span class="p_del">-					ste,input = &lt;1&gt;;</span>
<span class="p_add">+					/*</span>
<span class="p_add">+					 * MCCLK, MCCMDDIR, MCDAT0DIR, MCDAT31DIR, MCDATDIR2</span>
<span class="p_add">+					 * MCCMD, MCDAT3-0, MCMSFBCLK</span>
<span class="p_add">+					 */</span>
<span class="p_add">+					pins = &quot;GPIO8_B10&quot;, &quot;GPIO9_A10&quot;, &quot;GPIO10_C11&quot;, &quot;GPIO11_B11&quot;,</span>
<span class="p_add">+					       &quot;GPIO12_A11&quot;, &quot;GPIO13_C12&quot;, &quot;GPIO14_B12&quot;, &quot;GPIO15_A12&quot;,</span>
<span class="p_add">+					       &quot;GPIO16_C13&quot;, &quot;GPIO23_D15&quot;, &quot;GPIO24_C15&quot;;</span>
<span class="p_add">+					ste,output = &lt;2&gt;;</span>
 				};
 			};
 		};
<span class="p_chunk">@@ -802,10 +794,21 @@</span> <span class="p_context"></span>
 			clock-names = &quot;mclk&quot;, &quot;apb_pclk&quot;;
 			interrupt-parent = &lt;&amp;vica&gt;;
 			interrupts = &lt;22&gt;;
<span class="p_del">-			max-frequency = &lt;48000000&gt;;</span>
<span class="p_add">+			max-frequency = &lt;400000&gt;;</span>
 			bus-width = &lt;4&gt;;
 			cap-mmc-highspeed;
 			cap-sd-highspeed;
<span class="p_add">+			full-pwr-cycle;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The STw4811 circuit used with the Nomadik strictly</span>
<span class="p_add">+			 * requires that all of these signal direction pins be</span>
<span class="p_add">+			 * routed and used for its 4-bit levelshifter.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			st,sig-dir-dat0;</span>
<span class="p_add">+			st,sig-dir-dat2;</span>
<span class="p_add">+			st,sig-dir-dat31;</span>
<span class="p_add">+			st,sig-dir-cmd;</span>
<span class="p_add">+			st,sig-pin-fbclk;</span>
 			pinctrl-names = &quot;default&quot;;
 			pinctrl-0 = &lt;&amp;mmcsd_default_mux&gt;, &lt;&amp;mmcsd_default_mode&gt;;
 			vmmc-supply = &lt;&amp;vmmc_regulator&gt;;
<span class="p_header">diff --git a/arch/arm/common/icst.c b/arch/arm/common/icst.c</span>
<span class="p_header">index 2dc6da70ae59..d7ed252708c5 100644</span>
<span class="p_header">--- a/arch/arm/common/icst.c</span>
<span class="p_header">+++ b/arch/arm/common/icst.c</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"></span>
  */
 #include &lt;linux/module.h&gt;
 #include &lt;linux/kernel.h&gt;
<span class="p_del">-</span>
<span class="p_add">+#include &lt;asm/div64.h&gt;</span>
 #include &lt;asm/hardware/icst.h&gt;
 
 /*
<span class="p_chunk">@@ -29,7 +29,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(icst525_s2div);</span>
 
 unsigned long icst_hz(const struct icst_params *p, struct icst_vco vco)
 {
<span class="p_del">-	return p-&gt;ref * 2 * (vco.v + 8) / ((vco.r + 2) * p-&gt;s2div[vco.s]);</span>
<span class="p_add">+	u64 dividend = p-&gt;ref * 2 * (u64)(vco.v + 8);</span>
<span class="p_add">+	u32 divisor = (vco.r + 2) * p-&gt;s2div[vco.s];</span>
<span class="p_add">+</span>
<span class="p_add">+	do_div(dividend, divisor);</span>
<span class="p_add">+	return (unsigned long)dividend;</span>
 }
 
 EXPORT_SYMBOL(icst_hz);
<span class="p_chunk">@@ -58,6 +62,7 @@</span> <span class="p_context"> icst_hz_to_vco(const struct icst_params *p, unsigned long freq)</span>
 
 		if (f &gt; p-&gt;vco_min &amp;&amp; f &lt;= p-&gt;vco_max)
 			break;
<span class="p_add">+		i++;</span>
 	} while (i &lt; 8);
 
 	if (i &gt;= 8)
<span class="p_header">diff --git a/arch/arm/mach-omap2/sleep34xx.S b/arch/arm/mach-omap2/sleep34xx.S</span>
<span class="p_header">index eafd120b53f1..1b9f0520dea9 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/sleep34xx.S</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/sleep34xx.S</span>
<span class="p_chunk">@@ -86,13 +86,18 @@</span> <span class="p_context"> ENTRY(enable_omap3630_toggle_l2_on_restore)</span>
 	stmfd	sp!, {lr}	@ save registers on stack
 	/* Setup so that we will disable and enable l2 */
 	mov	r1, #0x1
<span class="p_del">-	adrl	r2, l2dis_3630	@ may be too distant for plain adr</span>
<span class="p_del">-	str	r1, [r2]</span>
<span class="p_add">+	adrl	r3, l2dis_3630_offset	@ may be too distant for plain adr</span>
<span class="p_add">+	ldr	r2, [r3]		@ value for offset</span>
<span class="p_add">+	str	r1, [r2, r3]		@ write to l2dis_3630</span>
 	ldmfd	sp!, {pc}	@ restore regs and return
 ENDPROC(enable_omap3630_toggle_l2_on_restore)
 
<span class="p_del">-	.text</span>
<span class="p_del">-/* Function to call rom code to save secure ram context */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Function to call rom code to save secure ram context. This gets</span>
<span class="p_add">+ * relocated to SRAM, so it can be all in .data section. Otherwise</span>
<span class="p_add">+ * we need to initialize api_params separately.</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.data</span>
 	.align	3
 ENTRY(save_secure_ram_context)
 	stmfd	sp!, {r4 - r11, lr}	@ save registers on stack
<span class="p_chunk">@@ -126,6 +131,8 @@</span> <span class="p_context"> ENDPROC(save_secure_ram_context)</span>
 ENTRY(save_secure_ram_context_sz)
 	.word	. - save_secure_ram_context
 
<span class="p_add">+	.text</span>
<span class="p_add">+</span>
 /*
  * ======================
  * == Idle entry point ==
<span class="p_chunk">@@ -289,12 +296,6 @@</span> <span class="p_context"> wait_sdrc_ready:</span>
 	bic	r5, r5, #0x40
 	str	r5, [r4]
 
<span class="p_del">-/*</span>
<span class="p_del">- * PC-relative stores lead to undefined behaviour in Thumb-2: use a r7 as a</span>
<span class="p_del">- * base instead.</span>
<span class="p_del">- * Be careful not to clobber r7 when maintaing this code.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
 is_dll_in_lock_mode:
 	/* Is dll in lock mode? */
 	ldr	r4, sdrc_dlla_ctrl
<span class="p_chunk">@@ -302,11 +303,7 @@</span> <span class="p_context"> is_dll_in_lock_mode:</span>
 	tst	r5, #0x4
 	bne	exit_nonoff_modes	@ Return if locked
 	/* wait till dll locks */
<span class="p_del">-	adr	r7, kick_counter</span>
 wait_dll_lock_timed:
<span class="p_del">-	ldr	r4, wait_dll_lock_counter</span>
<span class="p_del">-	add	r4, r4, #1</span>
<span class="p_del">-	str	r4, [r7, #wait_dll_lock_counter - kick_counter]</span>
 	ldr	r4, sdrc_dlla_status
 	/* Wait 20uS for lock */
 	mov	r6, #8
<span class="p_chunk">@@ -330,9 +327,6 @@</span> <span class="p_context"> kick_dll:</span>
 	orr	r6, r6, #(1&lt;&lt;3)		@ enable dll
 	str	r6, [r4]
 	dsb
<span class="p_del">-	ldr	r4, kick_counter</span>
<span class="p_del">-	add	r4, r4, #1</span>
<span class="p_del">-	str	r4, [r7]		@ kick_counter</span>
 	b	wait_dll_lock_timed
 
 exit_nonoff_modes:
<span class="p_chunk">@@ -360,15 +354,6 @@</span> <span class="p_context"> sdrc_dlla_status:</span>
 	.word	SDRC_DLLA_STATUS_V
 sdrc_dlla_ctrl:
 	.word	SDRC_DLLA_CTRL_V
<span class="p_del">-	/*</span>
<span class="p_del">-	 * When exporting to userspace while the counters are in SRAM,</span>
<span class="p_del">-	 * these 2 words need to be at the end to facilitate retrival!</span>
<span class="p_del">-	 */</span>
<span class="p_del">-kick_counter:</span>
<span class="p_del">-	.word	0</span>
<span class="p_del">-wait_dll_lock_counter:</span>
<span class="p_del">-	.word	0</span>
<span class="p_del">-</span>
 ENTRY(omap3_do_wfi_sz)
 	.word	. - omap3_do_wfi
 
<span class="p_chunk">@@ -437,7 +422,9 @@</span> <span class="p_context"> ENTRY(omap3_restore)</span>
 	cmp	r2, #0x0	@ Check if target power state was OFF or RET
 	bne	logic_l1_restore
 
<span class="p_del">-	ldr	r0, l2dis_3630</span>
<span class="p_add">+	adr	r1, l2dis_3630_offset	@ address for offset</span>
<span class="p_add">+	ldr	r0, [r1]		@ value for offset</span>
<span class="p_add">+	ldr	r0, [r1, r0]		@ value at l2dis_3630</span>
 	cmp	r0, #0x1	@ should we disable L2 on 3630?
 	bne	skipl2dis
 	mrc	p15, 0, r0, c1, c0, 1
<span class="p_chunk">@@ -449,12 +436,14 @@</span> <span class="p_context"> skipl2dis:</span>
 	and	r1, #0x700
 	cmp	r1, #0x300
 	beq	l2_inv_gp
<span class="p_add">+	adr	r0, l2_inv_api_params_offset</span>
<span class="p_add">+	ldr	r3, [r0]</span>
<span class="p_add">+	add	r3, r3, r0		@ r3 points to dummy parameters</span>
 	mov	r0, #40			@ set service ID for PPA
 	mov	r12, r0			@ copy secure Service ID in r12
 	mov	r1, #0			@ set task id for ROM code in r1
 	mov	r2, #4			@ set some flags in r2, r6
 	mov	r6, #0xff
<span class="p_del">-	adr	r3, l2_inv_api_params	@ r3 points to dummy parameters</span>
 	dsb				@ data write barrier
 	dmb				@ data memory barrier
 	smc	#1			@ call SMI monitor (smi #1)
<span class="p_chunk">@@ -488,8 +477,8 @@</span> <span class="p_context"> skipl2dis:</span>
 	b	logic_l1_restore
 
 	.align
<span class="p_del">-l2_inv_api_params:</span>
<span class="p_del">-	.word	0x1, 0x00</span>
<span class="p_add">+l2_inv_api_params_offset:</span>
<span class="p_add">+	.long	l2_inv_api_params - .</span>
 l2_inv_gp:
 	/* Execute smi to invalidate L2 cache */
 	mov r12, #0x1			@ set up to invalidate L2
<span class="p_chunk">@@ -506,7 +495,9 @@</span> <span class="p_context"> l2_inv_gp:</span>
 	mov	r12, #0x2
 	smc	#0			@ Call SMI monitor (smieq)
 logic_l1_restore:
<span class="p_del">-	ldr	r1, l2dis_3630</span>
<span class="p_add">+	adr	r0, l2dis_3630_offset	@ adress for offset</span>
<span class="p_add">+	ldr	r1, [r0]		@ value for offset</span>
<span class="p_add">+	ldr	r1, [r0, r1]		@ value at l2dis_3630</span>
 	cmp	r1, #0x1		@ Test if L2 re-enable needed on 3630
 	bne	skipl2reen
 	mrc	p15, 0, r1, c1, c0, 1
<span class="p_chunk">@@ -535,9 +526,17 @@</span> <span class="p_context"> control_stat:</span>
 	.word	CONTROL_STAT
 control_mem_rta:
 	.word	CONTROL_MEM_RTA_CTRL
<span class="p_add">+l2dis_3630_offset:</span>
<span class="p_add">+	.long	l2dis_3630 - .</span>
<span class="p_add">+</span>
<span class="p_add">+	.data</span>
 l2dis_3630:
 	.word	0
 
<span class="p_add">+	.data</span>
<span class="p_add">+l2_inv_api_params:</span>
<span class="p_add">+	.word	0x1, 0x00</span>
<span class="p_add">+</span>
 /*
  * Internal functions
  */
<span class="p_header">diff --git a/arch/arm/mach-omap2/sleep44xx.S b/arch/arm/mach-omap2/sleep44xx.S</span>
<span class="p_header">index 9b09d85d811a..c7a3b4aab4b5 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/sleep44xx.S</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/sleep44xx.S</span>
<span class="p_chunk">@@ -29,12 +29,6 @@</span> <span class="p_context"></span>
 	dsb
 .endm
 
<span class="p_del">-ppa_zero_params:</span>
<span class="p_del">-	.word		0x0</span>
<span class="p_del">-</span>
<span class="p_del">-ppa_por_params:</span>
<span class="p_del">-	.word		1, 0</span>
<span class="p_del">-</span>
 #ifdef CONFIG_ARCH_OMAP4
 
 /*
<span class="p_chunk">@@ -266,7 +260,9 @@</span> <span class="p_context"> ENTRY(omap4_cpu_resume)</span>
 	beq	skip_ns_smp_enable
 ppa_actrl_retry:
 	mov     r0, #OMAP4_PPA_CPU_ACTRL_SMP_INDEX
<span class="p_del">-	adr	r3, ppa_zero_params		@ Pointer to parameters</span>
<span class="p_add">+	adr	r1, ppa_zero_params_offset</span>
<span class="p_add">+	ldr	r3, [r1]</span>
<span class="p_add">+	add	r3, r3, r1			@ Pointer to ppa_zero_params</span>
 	mov	r1, #0x0			@ Process ID
 	mov	r2, #0x4			@ Flag
 	mov	r6, #0xff
<span class="p_chunk">@@ -303,7 +299,9 @@</span> <span class="p_context"> skip_ns_smp_enable:</span>
 	ldr     r0, =OMAP4_PPA_L2_POR_INDEX
 	ldr     r1, =OMAP44XX_SAR_RAM_BASE
 	ldr     r4, [r1, #L2X0_PREFETCH_CTRL_OFFSET]
<span class="p_del">-	adr     r3, ppa_por_params</span>
<span class="p_add">+	adr     r1, ppa_por_params_offset</span>
<span class="p_add">+	ldr	r3, [r1]</span>
<span class="p_add">+	add	r3, r3, r1			@ Pointer to ppa_por_params</span>
 	str     r4, [r3, #0x04]
 	mov	r1, #0x0			@ Process ID
 	mov	r2, #0x4			@ Flag
<span class="p_chunk">@@ -328,6 +326,8 @@</span> <span class="p_context"> skip_l2en:</span>
 #endif
 
 	b	cpu_resume			@ Jump to generic resume
<span class="p_add">+ppa_por_params_offset:</span>
<span class="p_add">+	.long	ppa_por_params - .</span>
 ENDPROC(omap4_cpu_resume)
 #endif	/* CONFIG_ARCH_OMAP4 */
 
<span class="p_chunk">@@ -380,4 +380,13 @@</span> <span class="p_context"> ENTRY(omap_do_wfi)</span>
 	nop
 
 	ldmfd	sp!, {pc}
<span class="p_add">+ppa_zero_params_offset:</span>
<span class="p_add">+	.long	ppa_zero_params - .</span>
 ENDPROC(omap_do_wfi)
<span class="p_add">+</span>
<span class="p_add">+	.data</span>
<span class="p_add">+ppa_zero_params:</span>
<span class="p_add">+	.word		0</span>
<span class="p_add">+</span>
<span class="p_add">+ppa_por_params:</span>
<span class="p_add">+	.word		1, 0</span>
<span class="p_header">diff --git a/arch/arm64/mm/dma-mapping.c b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">index 7963aa4b5d28..354144e33218 100644</span>
<span class="p_header">--- a/arch/arm64/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm64/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -933,6 +933,10 @@</span> <span class="p_context"> static int __init __iommu_dma_init(void)</span>
 		ret = register_iommu_dma_ops_notifier(&amp;platform_bus_type);
 	if (!ret)
 		ret = register_iommu_dma_ops_notifier(&amp;amba_bustype);
<span class="p_add">+</span>
<span class="p_add">+	/* handle devices queued before this arch_initcall */</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		__iommu_attach_notifier(NULL, BUS_NOTIFY_ADD_DEVICE, NULL);</span>
 	return ret;
 }
 arch_initcall(__iommu_dma_init);
<span class="p_header">diff --git a/arch/arm64/mm/pageattr.c b/arch/arm64/mm/pageattr.c</span>
<span class="p_header">index 3571c7309c5e..cf6240741134 100644</span>
<span class="p_header">--- a/arch/arm64/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/arm64/mm/pageattr.c</span>
<span class="p_chunk">@@ -57,6 +57,9 @@</span> <span class="p_context"> static int change_memory_common(unsigned long addr, int numpages,</span>
 	if (end &lt; MODULES_VADDR || end &gt;= MODULES_END)
 		return -EINVAL;
 
<span class="p_add">+	if (!numpages)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	data.set_mask = set_mask;
 	data.clear_mask = clear_mask;
 
<span class="p_header">diff --git a/arch/m32r/kernel/setup.c b/arch/m32r/kernel/setup.c</span>
<span class="p_header">index 0392112a5d70..a5ecef7188ba 100644</span>
<span class="p_header">--- a/arch/m32r/kernel/setup.c</span>
<span class="p_header">+++ b/arch/m32r/kernel/setup.c</span>
<span class="p_chunk">@@ -81,7 +81,10 @@</span> <span class="p_context"> static struct resource code_resource = {</span>
 };
 
 unsigned long memory_start;
<span class="p_add">+EXPORT_SYMBOL(memory_start);</span>
<span class="p_add">+</span>
 unsigned long memory_end;
<span class="p_add">+EXPORT_SYMBOL(memory_end);</span>
 
 void __init setup_arch(char **);
 int get_cpuinfo(char *);
<span class="p_header">diff --git a/arch/powerpc/include/asm/eeh.h b/arch/powerpc/include/asm/eeh.h</span>
<span class="p_header">index c5eb86f3d452..867c39b45df6 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/eeh.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/eeh.h</span>
<span class="p_chunk">@@ -81,6 +81,7 @@</span> <span class="p_context"> struct pci_dn;</span>
 #define EEH_PE_KEEP		(1 &lt;&lt; 8)	/* Keep PE on hotplug	*/
 #define EEH_PE_CFG_RESTRICTED	(1 &lt;&lt; 9)	/* Block config on error */
 #define EEH_PE_REMOVED		(1 &lt;&lt; 10)	/* Removed permanently	*/
<span class="p_add">+#define EEH_PE_PRI_BUS		(1 &lt;&lt; 11)	/* Cached primary bus   */</span>
 
 struct eeh_pe {
 	int type;			/* PE type: PHB/Bus/Device	*/
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index 8d14feb40f12..f69ecaa7ce33 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -564,6 +564,7 @@</span> <span class="p_context"> static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)</span>
 	 */
 	eeh_pe_state_mark(pe, EEH_PE_KEEP);
 	if (bus) {
<span class="p_add">+		eeh_pe_state_clear(pe, EEH_PE_PRI_BUS);</span>
 		pci_lock_rescan_remove();
 		pcibios_remove_pci_devices(bus);
 		pci_unlock_rescan_remove();
<span class="p_chunk">@@ -803,6 +804,7 @@</span> <span class="p_context"> perm_error:</span>
 	 * the their PCI config any more.
 	 */
 	if (frozen_bus) {
<span class="p_add">+		eeh_pe_state_clear(pe, EEH_PE_PRI_BUS);</span>
 		eeh_pe_dev_mode_mark(pe, EEH_DEV_REMOVED);
 
 		pci_lock_rescan_remove();
<span class="p_chunk">@@ -886,6 +888,7 @@</span> <span class="p_context"> static void eeh_handle_special_event(void)</span>
 					continue;
 
 				/* Notify all devices to be down */
<span class="p_add">+				eeh_pe_state_clear(pe, EEH_PE_PRI_BUS);</span>
 				bus = eeh_pe_bus_get(phb_pe);
 				eeh_pe_dev_traverse(pe,
 					eeh_report_failure, NULL);
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_pe.c b/arch/powerpc/kernel/eeh_pe.c</span>
<span class="p_header">index 8654cb166c19..98f81800e00c 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_pe.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_pe.c</span>
<span class="p_chunk">@@ -883,32 +883,29 @@</span> <span class="p_context"> void eeh_pe_restore_bars(struct eeh_pe *pe)</span>
 const char *eeh_pe_loc_get(struct eeh_pe *pe)
 {
 	struct pci_bus *bus = eeh_pe_bus_get(pe);
<span class="p_del">-	struct device_node *dn = pci_bus_to_OF_node(bus);</span>
<span class="p_add">+	struct device_node *dn;</span>
 	const char *loc = NULL;
 
<span class="p_del">-	if (!dn)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	while (bus) {</span>
<span class="p_add">+		dn = pci_bus_to_OF_node(bus);</span>
<span class="p_add">+		if (!dn) {</span>
<span class="p_add">+			bus = bus-&gt;parent;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	/* PHB PE or root PE ? */</span>
<span class="p_del">-	if (pci_is_root_bus(bus)) {</span>
<span class="p_del">-		loc = of_get_property(dn, &quot;ibm,loc-code&quot;, NULL);</span>
<span class="p_del">-		if (!loc)</span>
<span class="p_add">+		if (pci_is_root_bus(bus))</span>
 			loc = of_get_property(dn, &quot;ibm,io-base-loc-code&quot;, NULL);
<span class="p_add">+		else</span>
<span class="p_add">+			loc = of_get_property(dn, &quot;ibm,slot-location-code&quot;,</span>
<span class="p_add">+					      NULL);</span>
<span class="p_add">+</span>
 		if (loc)
<span class="p_del">-			goto out;</span>
<span class="p_add">+			return loc;</span>
 
<span class="p_del">-		/* Check the root port */</span>
<span class="p_del">-		dn = dn-&gt;child;</span>
<span class="p_del">-		if (!dn)</span>
<span class="p_del">-			goto out;</span>
<span class="p_add">+		bus = bus-&gt;parent;</span>
 	}
 
<span class="p_del">-	loc = of_get_property(dn, &quot;ibm,loc-code&quot;, NULL);</span>
<span class="p_del">-	if (!loc)</span>
<span class="p_del">-		loc = of_get_property(dn, &quot;ibm,slot-location-code&quot;, NULL);</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return loc ? loc : &quot;N/A&quot;;</span>
<span class="p_add">+	return &quot;N/A&quot;;</span>
 }
 
 /**
<span class="p_chunk">@@ -931,7 +928,7 @@</span> <span class="p_context"> struct pci_bus *eeh_pe_bus_get(struct eeh_pe *pe)</span>
 		bus = pe-&gt;phb-&gt;bus;
 	} else if (pe-&gt;type &amp; EEH_PE_BUS ||
 		   pe-&gt;type &amp; EEH_PE_DEVICE) {
<span class="p_del">-		if (pe-&gt;bus) {</span>
<span class="p_add">+		if (pe-&gt;state &amp; EEH_PE_PRI_BUS) {</span>
 			bus = pe-&gt;bus;
 			goto out;
 		}
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index 3c6badcd53ef..e57cc383e5da 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -2153,7 +2153,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
 
 	/* Emulate H_SET_DABR/X on P8 for the sake of compat mode guests */
 2:	rlwimi	r5, r4, 5, DAWRX_DR | DAWRX_DW
<span class="p_del">-	rlwimi	r5, r4, 1, DAWRX_WT</span>
<span class="p_add">+	rlwimi	r5, r4, 2, DAWRX_WT</span>
 	clrrdi	r4, r4, 3
 	std	r4, VCPU_DAWR(r3)
 	std	r5, VCPU_DAWRX(r3)
<span class="p_header">diff --git a/arch/powerpc/kvm/powerpc.c b/arch/powerpc/kvm/powerpc.c</span>
<span class="p_header">index 6fd2405c7f4a..a3b182dcb823 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/powerpc.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/powerpc.c</span>
<span class="p_chunk">@@ -919,21 +919,17 @@</span> <span class="p_context"> int kvm_vcpu_ioctl_get_one_reg(struct kvm_vcpu *vcpu, struct kvm_one_reg *reg)</span>
 				r = -ENXIO;
 				break;
 			}
<span class="p_del">-			vcpu-&gt;arch.vr.vr[reg-&gt;id - KVM_REG_PPC_VR0] = val.vval;</span>
<span class="p_add">+			val.vval = vcpu-&gt;arch.vr.vr[reg-&gt;id - KVM_REG_PPC_VR0];</span>
 			break;
 		case KVM_REG_PPC_VSCR:
 			if (!cpu_has_feature(CPU_FTR_ALTIVEC)) {
 				r = -ENXIO;
 				break;
 			}
<span class="p_del">-			vcpu-&gt;arch.vr.vscr.u[3] = set_reg_val(reg-&gt;id, val);</span>
<span class="p_add">+			val = get_reg_val(reg-&gt;id, vcpu-&gt;arch.vr.vscr.u[3]);</span>
 			break;
 		case KVM_REG_PPC_VRSAVE:
<span class="p_del">-			if (!cpu_has_feature(CPU_FTR_ALTIVEC)) {</span>
<span class="p_del">-				r = -ENXIO;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			vcpu-&gt;arch.vrsave = set_reg_val(reg-&gt;id, val);</span>
<span class="p_add">+			val = get_reg_val(reg-&gt;id, vcpu-&gt;arch.vrsave);</span>
 			break;
 #endif /* CONFIG_ALTIVEC */
 		default:
<span class="p_chunk">@@ -974,17 +970,21 @@</span> <span class="p_context"> int kvm_vcpu_ioctl_set_one_reg(struct kvm_vcpu *vcpu, struct kvm_one_reg *reg)</span>
 				r = -ENXIO;
 				break;
 			}
<span class="p_del">-			val.vval = vcpu-&gt;arch.vr.vr[reg-&gt;id - KVM_REG_PPC_VR0];</span>
<span class="p_add">+			vcpu-&gt;arch.vr.vr[reg-&gt;id - KVM_REG_PPC_VR0] = val.vval;</span>
 			break;
 		case KVM_REG_PPC_VSCR:
 			if (!cpu_has_feature(CPU_FTR_ALTIVEC)) {
 				r = -ENXIO;
 				break;
 			}
<span class="p_del">-			val = get_reg_val(reg-&gt;id, vcpu-&gt;arch.vr.vscr.u[3]);</span>
<span class="p_add">+			vcpu-&gt;arch.vr.vscr.u[3] = set_reg_val(reg-&gt;id, val);</span>
 			break;
 		case KVM_REG_PPC_VRSAVE:
<span class="p_del">-			val = get_reg_val(reg-&gt;id, vcpu-&gt;arch.vrsave);</span>
<span class="p_add">+			if (!cpu_has_feature(CPU_FTR_ALTIVEC)) {</span>
<span class="p_add">+				r = -ENXIO;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			vcpu-&gt;arch.vrsave = set_reg_val(reg-&gt;id, val);</span>
 			break;
 #endif /* CONFIG_ALTIVEC */
 		default:
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/eeh-powernv.c b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">index e1c90725522a..2ba602591a20 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/eeh-powernv.c</span>
<span class="p_chunk">@@ -444,9 +444,12 @@</span> <span class="p_context"> static void *pnv_eeh_probe(struct pci_dn *pdn, void *data)</span>
 	 * PCI devices of the PE are expected to be removed prior
 	 * to PE reset.
 	 */
<span class="p_del">-	if (!edev-&gt;pe-&gt;bus)</span>
<span class="p_add">+	if (!(edev-&gt;pe-&gt;state &amp; EEH_PE_PRI_BUS)) {</span>
 		edev-&gt;pe-&gt;bus = pci_find_bus(hose-&gt;global_number,
 					     pdn-&gt;busno);
<span class="p_add">+		if (edev-&gt;pe-&gt;bus)</span>
<span class="p_add">+			edev-&gt;pe-&gt;state |= EEH_PE_PRI_BUS;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * Enable EEH explicitly so that we will do EEH check
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci-ioda.c b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">index 414fd1a00fda..e40d0714679e 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci-ioda.c</span>
<span class="p_chunk">@@ -3034,6 +3034,7 @@</span> <span class="p_context"> static void pnv_pci_ioda_shutdown(struct pci_controller *hose)</span>
 
 static const struct pci_controller_ops pnv_pci_ioda_controller_ops = {
        .dma_dev_setup = pnv_pci_dma_dev_setup,
<span class="p_add">+       .dma_bus_setup = pnv_pci_dma_bus_setup,</span>
 #ifdef CONFIG_PCI_MSI
        .setup_msi_irqs = pnv_setup_msi_irqs,
        .teardown_msi_irqs = pnv_teardown_msi_irqs,
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">index f2dd77234240..ad8c3f4a5e0b 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_chunk">@@ -601,6 +601,9 @@</span> <span class="p_context"> int pnv_tce_build(struct iommu_table *tbl, long index, long npages,</span>
 	u64 rpn = __pa(uaddr) &gt;&gt; tbl-&gt;it_page_shift;
 	long i;
 
<span class="p_add">+	if (proto_tce &amp; TCE_PCI_WRITE)</span>
<span class="p_add">+		proto_tce |= TCE_PCI_READ;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; npages; i++) {
 		unsigned long newtce = proto_tce |
 			((rpn + i) &lt;&lt; tbl-&gt;it_page_shift);
<span class="p_chunk">@@ -622,6 +625,9 @@</span> <span class="p_context"> int pnv_tce_xchg(struct iommu_table *tbl, long index,</span>
 
 	BUG_ON(*hpa &amp; ~IOMMU_PAGE_MASK(tbl));
 
<span class="p_add">+	if (newtce &amp; TCE_PCI_WRITE)</span>
<span class="p_add">+		newtce |= TCE_PCI_READ;</span>
<span class="p_add">+</span>
 	oldtce = xchg(pnv_tce(tbl, idx), cpu_to_be64(newtce));
 	*hpa = be64_to_cpu(oldtce) &amp; ~(TCE_PCI_READ | TCE_PCI_WRITE);
 	*direction = iommu_tce_direction(oldtce);
<span class="p_chunk">@@ -762,6 +768,26 @@</span> <span class="p_context"> void pnv_pci_dma_dev_setup(struct pci_dev *pdev)</span>
 		phb-&gt;dma_dev_setup(phb, pdev);
 }
 
<span class="p_add">+void pnv_pci_dma_bus_setup(struct pci_bus *bus)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_controller *hose = bus-&gt;sysdata;</span>
<span class="p_add">+	struct pnv_phb *phb = hose-&gt;private_data;</span>
<span class="p_add">+	struct pnv_ioda_pe *pe;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(pe, &amp;phb-&gt;ioda.pe_list, list) {</span>
<span class="p_add">+		if (!(pe-&gt;flags &amp; (PNV_IODA_PE_BUS | PNV_IODA_PE_BUS_ALL)))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!pe-&gt;pbus)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (bus-&gt;number == ((pe-&gt;rid &gt;&gt; 8) &amp; 0xFF)) {</span>
<span class="p_add">+			pe-&gt;pbus = bus;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void pnv_pci_shutdown(void)
 {
 	struct pci_controller *hose;
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci.h b/arch/powerpc/platforms/powernv/pci.h</span>
<span class="p_header">index c8ff50e90766..36a99feab7d8 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci.h</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci.h</span>
<span class="p_chunk">@@ -235,6 +235,7 @@</span> <span class="p_context"> extern void pnv_pci_reset_secondary_bus(struct pci_dev *dev);</span>
 extern int pnv_eeh_phb_reset(struct pci_controller *hose, int option);
 
 extern void pnv_pci_dma_dev_setup(struct pci_dev *pdev);
<span class="p_add">+extern void pnv_pci_dma_bus_setup(struct pci_bus *bus);</span>
 extern int pnv_setup_msi_irqs(struct pci_dev *pdev, int nvec, int type);
 extern void pnv_teardown_msi_irqs(struct pci_dev *pdev);
 
<span class="p_header">diff --git a/arch/x86/include/asm/pgtable_types.h b/arch/x86/include/asm/pgtable_types.h</span>
<span class="p_header">index a471cadb9630..79c91853e50e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pgtable_types.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pgtable_types.h</span>
<span class="p_chunk">@@ -363,20 +363,18 @@</span> <span class="p_context"> static inline enum page_cache_mode pgprot2cachemode(pgprot_t pgprot)</span>
 }
 static inline pgprot_t pgprot_4k_2_large(pgprot_t pgprot)
 {
<span class="p_add">+	pgprotval_t val = pgprot_val(pgprot);</span>
 	pgprot_t new;
<span class="p_del">-	unsigned long val;</span>
 
<span class="p_del">-	val = pgprot_val(pgprot);</span>
 	pgprot_val(new) = (val &amp; ~(_PAGE_PAT | _PAGE_PAT_LARGE)) |
 		((val &amp; _PAGE_PAT) &lt;&lt; (_PAGE_BIT_PAT_LARGE - _PAGE_BIT_PAT));
 	return new;
 }
 static inline pgprot_t pgprot_large_2_4k(pgprot_t pgprot)
 {
<span class="p_add">+	pgprotval_t val = pgprot_val(pgprot);</span>
 	pgprot_t new;
<span class="p_del">-	unsigned long val;</span>
 
<span class="p_del">-	val = pgprot_val(pgprot);</span>
 	pgprot_val(new) = (val &amp; ~(_PAGE_PAT | _PAGE_PAT_LARGE)) |
 			  ((val &amp; _PAGE_PAT_LARGE) &gt;&gt;
 			   (_PAGE_BIT_PAT_LARGE - _PAGE_BIT_PAT));
<span class="p_header">diff --git a/arch/x86/lib/copy_user_64.S b/arch/x86/lib/copy_user_64.S</span>
<span class="p_header">index 982ce34f4a9b..27f89c79a44b 100644</span>
<span class="p_header">--- a/arch/x86/lib/copy_user_64.S</span>
<span class="p_header">+++ b/arch/x86/lib/copy_user_64.S</span>
<span class="p_chunk">@@ -232,17 +232,31 @@</span> <span class="p_context"> ENDPROC(copy_user_enhanced_fast_string)</span>
 
 /*
  * copy_user_nocache - Uncached memory copy with exception handling
<span class="p_del">- * This will force destination/source out of cache for more performance.</span>
<span class="p_add">+ * This will force destination out of cache for more performance.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note: Cached memory copy is used when destination or size is not</span>
<span class="p_add">+ * naturally aligned. That is:</span>
<span class="p_add">+ *  - Require 8-byte alignment when size is 8 bytes or larger.</span>
<span class="p_add">+ *  - Require 4-byte alignment when size is 4 bytes.</span>
  */
 ENTRY(__copy_user_nocache)
 	ASM_STAC
<span class="p_add">+</span>
<span class="p_add">+	/* If size is less than 8 bytes, go to 4-byte copy */</span>
 	cmpl $8,%edx
<span class="p_del">-	jb 20f		/* less then 8 bytes, go to byte copy loop */</span>
<span class="p_add">+	jb .L_4b_nocache_copy_entry</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If destination is not 8-byte aligned, &quot;cache&quot; copy to align it */</span>
 	ALIGN_DESTINATION
<span class="p_add">+</span>
<span class="p_add">+	/* Set 4x8-byte copy count and remainder */</span>
 	movl %edx,%ecx
 	andl $63,%edx
 	shrl $6,%ecx
<span class="p_del">-	jz 17f</span>
<span class="p_add">+	jz .L_8b_nocache_copy_entry	/* jump if count is 0 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Perform 4x8-byte nocache loop-copy */</span>
<span class="p_add">+.L_4x8b_nocache_copy_loop:</span>
 1:	movq (%rsi),%r8
 2:	movq 1*8(%rsi),%r9
 3:	movq 2*8(%rsi),%r10
<span class="p_chunk">@@ -262,60 +276,106 @@</span> <span class="p_context"> ENTRY(__copy_user_nocache)</span>
 	leaq 64(%rsi),%rsi
 	leaq 64(%rdi),%rdi
 	decl %ecx
<span class="p_del">-	jnz 1b</span>
<span class="p_del">-17:	movl %edx,%ecx</span>
<span class="p_add">+	jnz .L_4x8b_nocache_copy_loop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set 8-byte copy count and remainder */</span>
<span class="p_add">+.L_8b_nocache_copy_entry:</span>
<span class="p_add">+	movl %edx,%ecx</span>
 	andl $7,%edx
 	shrl $3,%ecx
<span class="p_del">-	jz 20f</span>
<span class="p_del">-18:	movq (%rsi),%r8</span>
<span class="p_del">-19:	movnti %r8,(%rdi)</span>
<span class="p_add">+	jz .L_4b_nocache_copy_entry	/* jump if count is 0 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Perform 8-byte nocache loop-copy */</span>
<span class="p_add">+.L_8b_nocache_copy_loop:</span>
<span class="p_add">+20:	movq (%rsi),%r8</span>
<span class="p_add">+21:	movnti %r8,(%rdi)</span>
 	leaq 8(%rsi),%rsi
 	leaq 8(%rdi),%rdi
 	decl %ecx
<span class="p_del">-	jnz 18b</span>
<span class="p_del">-20:	andl %edx,%edx</span>
<span class="p_del">-	jz 23f</span>
<span class="p_add">+	jnz .L_8b_nocache_copy_loop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If no byte left, we&#39;re done */</span>
<span class="p_add">+.L_4b_nocache_copy_entry:</span>
<span class="p_add">+	andl %edx,%edx</span>
<span class="p_add">+	jz .L_finish_copy</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If destination is not 4-byte aligned, go to byte copy: */</span>
<span class="p_add">+	movl %edi,%ecx</span>
<span class="p_add">+	andl $3,%ecx</span>
<span class="p_add">+	jnz .L_1b_cache_copy_entry</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set 4-byte copy count (1 or 0) and remainder */</span>
 	movl %edx,%ecx
<span class="p_del">-21:	movb (%rsi),%al</span>
<span class="p_del">-22:	movb %al,(%rdi)</span>
<span class="p_add">+	andl $3,%edx</span>
<span class="p_add">+	shrl $2,%ecx</span>
<span class="p_add">+	jz .L_1b_cache_copy_entry	/* jump if count is 0 */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Perform 4-byte nocache copy: */</span>
<span class="p_add">+30:	movl (%rsi),%r8d</span>
<span class="p_add">+31:	movnti %r8d,(%rdi)</span>
<span class="p_add">+	leaq 4(%rsi),%rsi</span>
<span class="p_add">+	leaq 4(%rdi),%rdi</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If no bytes left, we&#39;re done: */</span>
<span class="p_add">+	andl %edx,%edx</span>
<span class="p_add">+	jz .L_finish_copy</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Perform byte &quot;cache&quot; loop-copy for the remainder */</span>
<span class="p_add">+.L_1b_cache_copy_entry:</span>
<span class="p_add">+	movl %edx,%ecx</span>
<span class="p_add">+.L_1b_cache_copy_loop:</span>
<span class="p_add">+40:	movb (%rsi),%al</span>
<span class="p_add">+41:	movb %al,(%rdi)</span>
 	incq %rsi
 	incq %rdi
 	decl %ecx
<span class="p_del">-	jnz 21b</span>
<span class="p_del">-23:	xorl %eax,%eax</span>
<span class="p_add">+	jnz .L_1b_cache_copy_loop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Finished copying; fence the prior stores */</span>
<span class="p_add">+.L_finish_copy:</span>
<span class="p_add">+	xorl %eax,%eax</span>
 	ASM_CLAC
 	sfence
 	ret
 
 	.section .fixup,&quot;ax&quot;
<span class="p_del">-30:	shll $6,%ecx</span>
<span class="p_add">+.L_fixup_4x8b_copy:</span>
<span class="p_add">+	shll $6,%ecx</span>
 	addl %ecx,%edx
<span class="p_del">-	jmp 60f</span>
<span class="p_del">-40:	lea (%rdx,%rcx,8),%rdx</span>
<span class="p_del">-	jmp 60f</span>
<span class="p_del">-50:	movl %ecx,%edx</span>
<span class="p_del">-60:	sfence</span>
<span class="p_add">+	jmp .L_fixup_handle_tail</span>
<span class="p_add">+.L_fixup_8b_copy:</span>
<span class="p_add">+	lea (%rdx,%rcx,8),%rdx</span>
<span class="p_add">+	jmp .L_fixup_handle_tail</span>
<span class="p_add">+.L_fixup_4b_copy:</span>
<span class="p_add">+	lea (%rdx,%rcx,4),%rdx</span>
<span class="p_add">+	jmp .L_fixup_handle_tail</span>
<span class="p_add">+.L_fixup_1b_copy:</span>
<span class="p_add">+	movl %ecx,%edx</span>
<span class="p_add">+.L_fixup_handle_tail:</span>
<span class="p_add">+	sfence</span>
 	jmp copy_user_handle_tail
 	.previous
 
<span class="p_del">-	_ASM_EXTABLE(1b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(2b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(3b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(4b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(5b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(6b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(7b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(8b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(9b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(10b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(11b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(12b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(13b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(14b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(15b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(16b,30b)</span>
<span class="p_del">-	_ASM_EXTABLE(18b,40b)</span>
<span class="p_del">-	_ASM_EXTABLE(19b,40b)</span>
<span class="p_del">-	_ASM_EXTABLE(21b,50b)</span>
<span class="p_del">-	_ASM_EXTABLE(22b,50b)</span>
<span class="p_add">+	_ASM_EXTABLE(1b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(2b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(3b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(4b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(5b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(6b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(7b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(8b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(9b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(10b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(11b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(12b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(13b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(14b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(15b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(16b,.L_fixup_4x8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(20b,.L_fixup_8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(21b,.L_fixup_8b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(30b,.L_fixup_4b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(31b,.L_fixup_4b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(40b,.L_fixup_1b_copy)</span>
<span class="p_add">+	_ASM_EXTABLE(41b,.L_fixup_1b_copy)</span>
 ENDPROC(__copy_user_nocache)
<span class="p_header">diff --git a/arch/x86/mm/fault.c b/arch/x86/mm/fault.c</span>
<span class="p_header">index eef44d9a3f77..e830c71a1323 100644</span>
<span class="p_header">--- a/arch/x86/mm/fault.c</span>
<span class="p_header">+++ b/arch/x86/mm/fault.c</span>
<span class="p_chunk">@@ -287,6 +287,9 @@</span> <span class="p_context"> static noinline int vmalloc_fault(unsigned long address)</span>
 	if (!pmd_k)
 		return -1;
 
<span class="p_add">+	if (pmd_huge(*pmd_k))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	pte_k = pte_offset_kernel(pmd_k, address);
 	if (!pte_present(*pte_k))
 		return -1;
<span class="p_chunk">@@ -360,8 +363,6 @@</span> <span class="p_context"> void vmalloc_sync_all(void)</span>
  * 64-bit:
  *
  *   Handle a fault on the vmalloc area
<span class="p_del">- *</span>
<span class="p_del">- * This assumes no large pages in there.</span>
  */
 static noinline int vmalloc_fault(unsigned long address)
 {
<span class="p_chunk">@@ -403,17 +404,23 @@</span> <span class="p_context"> static noinline int vmalloc_fault(unsigned long address)</span>
 	if (pud_none(*pud_ref))
 		return -1;
 
<span class="p_del">-	if (pud_none(*pud) || pud_page_vaddr(*pud) != pud_page_vaddr(*pud_ref))</span>
<span class="p_add">+	if (pud_none(*pud) || pud_pfn(*pud) != pud_pfn(*pud_ref))</span>
 		BUG();
 
<span class="p_add">+	if (pud_huge(*pud))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	pmd = pmd_offset(pud, address);
 	pmd_ref = pmd_offset(pud_ref, address);
 	if (pmd_none(*pmd_ref))
 		return -1;
 
<span class="p_del">-	if (pmd_none(*pmd) || pmd_page(*pmd) != pmd_page(*pmd_ref))</span>
<span class="p_add">+	if (pmd_none(*pmd) || pmd_pfn(*pmd) != pmd_pfn(*pmd_ref))</span>
 		BUG();
 
<span class="p_add">+	if (pmd_huge(*pmd))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	pte_ref = pte_offset_kernel(pmd_ref, address);
 	if (!pte_present(*pte_ref))
 		return -1;
<span class="p_header">diff --git a/arch/x86/mm/pageattr.c b/arch/x86/mm/pageattr.c</span>
<span class="p_header">index a3137a4feed1..db20ee9a413a 100644</span>
<span class="p_header">--- a/arch/x86/mm/pageattr.c</span>
<span class="p_header">+++ b/arch/x86/mm/pageattr.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> struct cpa_data {</span>
 	pgd_t		*pgd;
 	pgprot_t	mask_set;
 	pgprot_t	mask_clr;
<span class="p_del">-	int		numpages;</span>
<span class="p_add">+	unsigned long	numpages;</span>
 	int		flags;
 	unsigned long	pfn;
 	unsigned	force_split : 1;
<span class="p_chunk">@@ -1345,7 +1345,7 @@</span> <span class="p_context"> static int __change_page_attr_set_clr(struct cpa_data *cpa, int checkalias)</span>
 		 * CPA operation. Either a large page has been
 		 * preserved or a single page update happened.
 		 */
<span class="p_del">-		BUG_ON(cpa-&gt;numpages &gt; numpages);</span>
<span class="p_add">+		BUG_ON(cpa-&gt;numpages &gt; numpages || !cpa-&gt;numpages);</span>
 		numpages -= cpa-&gt;numpages;
 		if (cpa-&gt;flags &amp; (CPA_PAGES_ARRAY | CPA_ARRAY))
 			cpa-&gt;curpage++;
<span class="p_header">diff --git a/drivers/hwspinlock/hwspinlock_core.c b/drivers/hwspinlock/hwspinlock_core.c</span>
<span class="p_header">index 52f708bcf77f..d50c701b19d6 100644</span>
<span class="p_header">--- a/drivers/hwspinlock/hwspinlock_core.c</span>
<span class="p_header">+++ b/drivers/hwspinlock/hwspinlock_core.c</span>
<span class="p_chunk">@@ -313,6 +313,10 @@</span> <span class="p_context"> int of_hwspin_lock_get_id(struct device_node *np, int index)</span>
 		hwlock = radix_tree_deref_slot(slot);
 		if (unlikely(!hwlock))
 			continue;
<span class="p_add">+		if (radix_tree_is_indirect_ptr(hwlock)) {</span>
<span class="p_add">+			slot = radix_tree_iter_retry(&amp;iter);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
 		if (hwlock-&gt;bank-&gt;dev-&gt;of_node == args.np) {
 			ret = 0;
<span class="p_header">diff --git a/drivers/iio/accel/Kconfig b/drivers/iio/accel/Kconfig</span>
<span class="p_header">index 969428dd6329..16cc5c691a55 100644</span>
<span class="p_header">--- a/drivers/iio/accel/Kconfig</span>
<span class="p_header">+++ b/drivers/iio/accel/Kconfig</span>
<span class="p_chunk">@@ -173,6 +173,7 @@</span> <span class="p_context"> config STK8312</span>
 config STK8BA50
 	tristate &quot;Sensortek STK8BA50 3-Axis Accelerometer Driver&quot;
 	depends on I2C
<span class="p_add">+	depends on IIO_TRIGGER</span>
 	help
 	  Say yes here to get support for the Sensortek STK8BA50 3-axis
 	  accelerometer.
<span class="p_header">diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig</span>
<span class="p_header">index 7868c744fd4b..1e7aded53117 100644</span>
<span class="p_header">--- a/drivers/iio/adc/Kconfig</span>
<span class="p_header">+++ b/drivers/iio/adc/Kconfig</span>
<span class="p_chunk">@@ -372,6 +372,7 @@</span> <span class="p_context"> config TWL6030_GPADC</span>
 config VF610_ADC
 	tristate &quot;Freescale vf610 ADC driver&quot;
 	depends on OF
<span class="p_add">+	depends on HAS_IOMEM</span>
 	select IIO_BUFFER
 	select IIO_TRIGGERED_BUFFER
 	help
<span class="p_header">diff --git a/drivers/iio/adc/ti_am335x_adc.c b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">index 942320e32753..c1e05532d437 100644</span>
<span class="p_header">--- a/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/ti_am335x_adc.c</span>
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> static int tiadc_iio_buffered_hardware_setup(struct iio_dev *indio_dev,</span>
 		goto error_kfifo_free;
 
 	indio_dev-&gt;setup_ops = setup_ops;
<span class="p_del">-	indio_dev-&gt;modes |= INDIO_BUFFER_HARDWARE;</span>
<span class="p_add">+	indio_dev-&gt;modes |= INDIO_BUFFER_SOFTWARE;</span>
 
 	return 0;
 
<span class="p_header">diff --git a/drivers/iio/dac/mcp4725.c b/drivers/iio/dac/mcp4725.c</span>
<span class="p_header">index 43d14588448d..b4dde8315210 100644</span>
<span class="p_header">--- a/drivers/iio/dac/mcp4725.c</span>
<span class="p_header">+++ b/drivers/iio/dac/mcp4725.c</span>
<span class="p_chunk">@@ -300,6 +300,7 @@</span> <span class="p_context"> static int mcp4725_probe(struct i2c_client *client,</span>
 	data-&gt;client = client;
 
 	indio_dev-&gt;dev.parent = &amp;client-&gt;dev;
<span class="p_add">+	indio_dev-&gt;name = id-&gt;name;</span>
 	indio_dev-&gt;info = &amp;mcp4725_info;
 	indio_dev-&gt;channels = &amp;mcp4725_channel;
 	indio_dev-&gt;num_channels = 1;
<span class="p_header">diff --git a/drivers/iio/imu/adis_buffer.c b/drivers/iio/imu/adis_buffer.c</span>
<span class="p_header">index cb32b593f1c5..36607d52fee0 100644</span>
<span class="p_header">--- a/drivers/iio/imu/adis_buffer.c</span>
<span class="p_header">+++ b/drivers/iio/imu/adis_buffer.c</span>
<span class="p_chunk">@@ -43,7 +43,7 @@</span> <span class="p_context"> int adis_update_scan_mode(struct iio_dev *indio_dev,</span>
 		return -ENOMEM;
 
 	rx = adis-&gt;buffer;
<span class="p_del">-	tx = rx + indio_dev-&gt;scan_bytes;</span>
<span class="p_add">+	tx = rx + scan_count;</span>
 
 	spi_message_init(&amp;adis-&gt;msg);
 
<span class="p_header">diff --git a/drivers/iio/inkern.c b/drivers/iio/inkern.c</span>
<span class="p_header">index c8bad3cf891d..217e9306aa0f 100644</span>
<span class="p_header">--- a/drivers/iio/inkern.c</span>
<span class="p_header">+++ b/drivers/iio/inkern.c</span>
<span class="p_chunk">@@ -351,6 +351,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(iio_channel_get);</span>
 
 void iio_channel_release(struct iio_channel *channel)
 {
<span class="p_add">+	if (!channel)</span>
<span class="p_add">+		return;</span>
 	iio_device_put(channel-&gt;indio_dev);
 	kfree(channel);
 }
<span class="p_header">diff --git a/drivers/iio/light/acpi-als.c b/drivers/iio/light/acpi-als.c</span>
<span class="p_header">index 60537ec0c923..53201d99a16c 100644</span>
<span class="p_header">--- a/drivers/iio/light/acpi-als.c</span>
<span class="p_header">+++ b/drivers/iio/light/acpi-als.c</span>
<span class="p_chunk">@@ -54,7 +54,9 @@</span> <span class="p_context"> static const struct iio_chan_spec acpi_als_channels[] = {</span>
 			.realbits	= 32,
 			.storagebits	= 32,
 		},
<span class="p_del">-		.info_mask_separate	= BIT(IIO_CHAN_INFO_RAW),</span>
<span class="p_add">+		/* _RAW is here for backward ABI compatibility */</span>
<span class="p_add">+		.info_mask_separate	= BIT(IIO_CHAN_INFO_RAW) |</span>
<span class="p_add">+					  BIT(IIO_CHAN_INFO_PROCESSED),</span>
 	},
 };
 
<span class="p_chunk">@@ -152,7 +154,7 @@</span> <span class="p_context"> static int acpi_als_read_raw(struct iio_dev *indio_dev,</span>
 	s32 temp_val;
 	int ret;
 
<span class="p_del">-	if (mask != IIO_CHAN_INFO_RAW)</span>
<span class="p_add">+	if ((mask != IIO_CHAN_INFO_PROCESSED) &amp;&amp; (mask != IIO_CHAN_INFO_RAW))</span>
 		return -EINVAL;
 
 	/* we support only illumination (_ALI) so far. */
<span class="p_header">diff --git a/drivers/iio/light/ltr501.c b/drivers/iio/light/ltr501.c</span>
<span class="p_header">index 809a961b9a7f..6bf89d8f3741 100644</span>
<span class="p_header">--- a/drivers/iio/light/ltr501.c</span>
<span class="p_header">+++ b/drivers/iio/light/ltr501.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static const struct ltr501_samp_table ltr501_ps_samp_table[] = {</span>
 			{500000, 2000000}
 };
 
<span class="p_del">-static unsigned int ltr501_match_samp_freq(const struct ltr501_samp_table *tab,</span>
<span class="p_add">+static int ltr501_match_samp_freq(const struct ltr501_samp_table *tab,</span>
 					   int len, int val, int val2)
 {
 	int i, freq;
<span class="p_header">diff --git a/drivers/iio/pressure/mpl115.c b/drivers/iio/pressure/mpl115.c</span>
<span class="p_header">index f5ecd6e19f5d..a0d7deeac62f 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/mpl115.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/mpl115.c</span>
<span class="p_chunk">@@ -117,7 +117,7 @@</span> <span class="p_context"> static int mpl115_read_raw(struct iio_dev *indio_dev,</span>
 		*val = ret &gt;&gt; 6;
 		return IIO_VAL_INT;
 	case IIO_CHAN_INFO_OFFSET:
<span class="p_del">-		*val = 605;</span>
<span class="p_add">+		*val = -605;</span>
 		*val2 = 750000;
 		return IIO_VAL_INT_PLUS_MICRO;
 	case IIO_CHAN_INFO_SCALE:
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 537ebb0e193a..78f93cf68840 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1222,7 +1222,7 @@</span> <span class="p_context"> static int elantech_set_input_params(struct psmouse *psmouse)</span>
 			input_set_abs_params(dev, ABS_TOOL_WIDTH, ETP_WMIN_V2,
 					     ETP_WMAX_V2, 0, 0);
 		}
<span class="p_del">-		input_mt_init_slots(dev, 2, 0);</span>
<span class="p_add">+		input_mt_init_slots(dev, 2, INPUT_MT_SEMI_MT);</span>
 		input_set_abs_params(dev, ABS_MT_POSITION_X, x_min, x_max, 0, 0);
 		input_set_abs_params(dev, ABS_MT_POSITION_Y, y_min, y_max, 0, 0);
 		break;
<span class="p_header">diff --git a/drivers/input/mouse/vmmouse.c b/drivers/input/mouse/vmmouse.c</span>
<span class="p_header">index e272f06258ce..a3f0f5a47490 100644</span>
<span class="p_header">--- a/drivers/input/mouse/vmmouse.c</span>
<span class="p_header">+++ b/drivers/input/mouse/vmmouse.c</span>
<span class="p_chunk">@@ -458,8 +458,6 @@</span> <span class="p_context"> int vmmouse_init(struct psmouse *psmouse)</span>
 	priv-&gt;abs_dev = abs_dev;
 	psmouse-&gt;private = priv;
 
<span class="p_del">-	input_set_capability(rel_dev, EV_REL, REL_WHEEL);</span>
<span class="p_del">-</span>
 	/* Set up and register absolute device */
 	snprintf(priv-&gt;phys, sizeof(priv-&gt;phys), &quot;%s/input1&quot;,
 		 psmouse-&gt;ps2dev.serio-&gt;phys);
<span class="p_chunk">@@ -475,10 +473,6 @@</span> <span class="p_context"> int vmmouse_init(struct psmouse *psmouse)</span>
 	abs_dev-&gt;id.version = psmouse-&gt;model;
 	abs_dev-&gt;dev.parent = &amp;psmouse-&gt;ps2dev.serio-&gt;dev;
 
<span class="p_del">-	error = input_register_device(priv-&gt;abs_dev);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto init_fail;</span>
<span class="p_del">-</span>
 	/* Set absolute device capabilities */
 	input_set_capability(abs_dev, EV_KEY, BTN_LEFT);
 	input_set_capability(abs_dev, EV_KEY, BTN_RIGHT);
<span class="p_chunk">@@ -488,6 +482,13 @@</span> <span class="p_context"> int vmmouse_init(struct psmouse *psmouse)</span>
 	input_set_abs_params(abs_dev, ABS_X, 0, VMMOUSE_MAX_X, 0, 0);
 	input_set_abs_params(abs_dev, ABS_Y, 0, VMMOUSE_MAX_Y, 0, 0);
 
<span class="p_add">+	error = input_register_device(priv-&gt;abs_dev);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		goto init_fail;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add wheel capability to the relative device */</span>
<span class="p_add">+	input_set_capability(rel_dev, EV_REL, REL_WHEEL);</span>
<span class="p_add">+</span>
 	psmouse-&gt;protocol_handler = vmmouse_process_byte;
 	psmouse-&gt;disconnect = vmmouse_disconnect;
 	psmouse-&gt;reconnect = vmmouse_reconnect;
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index c11556563ef0..68f5f4a0f1e7 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -258,6 +258,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_nomux_table[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Fujitsu Lifebook U745 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK U745&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* Fujitsu T70H */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index 8b2be1e7714f..fc836f523afa 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -1905,7 +1905,7 @@</span> <span class="p_context"> static void do_attach(struct iommu_dev_data *dev_data,</span>
 	/* Update device table */
 	set_dte_entry(dev_data-&gt;devid, domain, ats);
 	if (alias != dev_data-&gt;devid)
<span class="p_del">-		set_dte_entry(dev_data-&gt;devid, domain, ats);</span>
<span class="p_add">+		set_dte_entry(alias, domain, ats);</span>
 
 	device_flush_dte(dev_data);
 }
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index 80e3c176008e..55a19e49205b 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -1347,7 +1347,7 @@</span> <span class="p_context"> void dmar_disable_qi(struct intel_iommu *iommu)</span>
 
 	raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flags);
 
<span class="p_del">-	sts =  dmar_readq(iommu-&gt;reg + DMAR_GSTS_REG);</span>
<span class="p_add">+	sts =  readl(iommu-&gt;reg + DMAR_GSTS_REG);</span>
 	if (!(sts &amp; DMA_GSTS_QIES))
 		goto end;
 
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index ac7387686ddc..986a53e3eb96 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -1489,7 +1489,7 @@</span> <span class="p_context"> static void iommu_disable_dev_iotlb(struct device_domain_info *info)</span>
 {
 	struct pci_dev *pdev;
 
<span class="p_del">-	if (dev_is_pci(info-&gt;dev))</span>
<span class="p_add">+	if (!dev_is_pci(info-&gt;dev))</span>
 		return;
 
 	pdev = to_pci_dev(info-&gt;dev);
<span class="p_header">diff --git a/drivers/iommu/intel-svm.c b/drivers/iommu/intel-svm.c</span>
<span class="p_header">index 50464833d0b8..d9939fa9b588 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-svm.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-svm.c</span>
<span class="p_chunk">@@ -249,12 +249,30 @@</span> <span class="p_context"> static void intel_flush_pasid_dev(struct intel_svm *svm, struct intel_svm_dev *s</span>
 static void intel_mm_release(struct mmu_notifier *mn, struct mm_struct *mm)
 {
 	struct intel_svm *svm = container_of(mn, struct intel_svm, notifier);
<span class="p_add">+	struct intel_svm_dev *sdev;</span>
 
<span class="p_add">+	/* This might end up being called from exit_mmap(), *before* the page</span>
<span class="p_add">+	 * tables are cleared. And __mmu_notifier_release() will delete us from</span>
<span class="p_add">+	 * the list of notifiers so that our invalidate_range() callback doesn&#39;t</span>
<span class="p_add">+	 * get called when the page tables are cleared. So we need to protect</span>
<span class="p_add">+	 * against hardware accessing those page tables.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We do it by clearing the entry in the PASID table and then flushing</span>
<span class="p_add">+	 * the IOTLB and the PASID table caches. This might upset hardware;</span>
<span class="p_add">+	 * perhaps we&#39;ll want to point the PASID to a dummy PGD (like the zero</span>
<span class="p_add">+	 * page) so that we end up taking a fault that the hardware really</span>
<span class="p_add">+	 * *has* to handle gracefully without affecting other processes.</span>
<span class="p_add">+	 */</span>
 	svm-&gt;iommu-&gt;pasid_table[svm-&gt;pasid].val = 0;
<span class="p_add">+	wmb();</span>
<span class="p_add">+</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	list_for_each_entry_rcu(sdev, &amp;svm-&gt;devs, list) {</span>
<span class="p_add">+		intel_flush_pasid_dev(svm, sdev, svm-&gt;pasid);</span>
<span class="p_add">+		intel_flush_svm_range_dev(svm, sdev, 0, -1, 0, !svm-&gt;mm);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
 
<span class="p_del">-	/* There&#39;s no need to do any flush because we can&#39;t get here if there</span>
<span class="p_del">-	 * are any devices left anyway. */</span>
<span class="p_del">-	WARN_ON(!list_empty(&amp;svm-&gt;devs));</span>
 }
 
 static const struct mmu_notifier_ops intel_mmuops = {
<span class="p_chunk">@@ -379,7 +397,6 @@</span> <span class="p_context"> int intel_svm_bind_mm(struct device *dev, int *pasid, int flags, struct svm_dev_</span>
 				goto out;
 			}
 			iommu-&gt;pasid_table[svm-&gt;pasid].val = (u64)__pa(mm-&gt;pgd) | 1;
<span class="p_del">-			mm = NULL;</span>
 		} else
 			iommu-&gt;pasid_table[svm-&gt;pasid].val = (u64)__pa(init_mm.pgd) | 1 | (1ULL &lt;&lt; 11);
 		wmb();
<span class="p_chunk">@@ -442,11 +459,11 @@</span> <span class="p_context"> int intel_svm_unbind_mm(struct device *dev, int pasid)</span>
 				kfree_rcu(sdev, rcu);
 
 				if (list_empty(&amp;svm-&gt;devs)) {
<span class="p_del">-					mmu_notifier_unregister(&amp;svm-&gt;notifier, svm-&gt;mm);</span>
 
 					idr_remove(&amp;svm-&gt;iommu-&gt;pasid_idr, svm-&gt;pasid);
 					if (svm-&gt;mm)
<span class="p_del">-						mmput(svm-&gt;mm);</span>
<span class="p_add">+						mmu_notifier_unregister(&amp;svm-&gt;notifier, svm-&gt;mm);</span>
<span class="p_add">+</span>
 					/* We mandate that no page faults may be outstanding
 					 * for the PASID when intel_svm_unbind_mm() is called.
 					 * If that is not obeyed, subtle errors will happen.
<span class="p_chunk">@@ -507,6 +524,10 @@</span> <span class="p_context"> static irqreturn_t prq_event_thread(int irq, void *d)</span>
 	struct intel_svm *svm = NULL;
 	int head, tail, handled = 0;
 
<span class="p_add">+	/* Clear PPR bit before reading head/tail registers, to</span>
<span class="p_add">+	 * ensure that we get a new interrupt if needed. */</span>
<span class="p_add">+	writel(DMA_PRS_PPR, iommu-&gt;reg + DMAR_PRS_REG);</span>
<span class="p_add">+</span>
 	tail = dmar_readq(iommu-&gt;reg + DMAR_PQT_REG) &amp; PRQ_RING_MASK;
 	head = dmar_readq(iommu-&gt;reg + DMAR_PQH_REG) &amp; PRQ_RING_MASK;
 	while (head != tail) {
<span class="p_chunk">@@ -551,6 +572,9 @@</span> <span class="p_context"> static irqreturn_t prq_event_thread(int irq, void *d)</span>
 		 * any faults on kernel addresses. */
 		if (!svm-&gt;mm)
 			goto bad_req;
<span class="p_add">+		/* If the mm is already defunct, don&#39;t handle faults. */</span>
<span class="p_add">+		if (!atomic_inc_not_zero(&amp;svm-&gt;mm-&gt;mm_users))</span>
<span class="p_add">+			goto bad_req;</span>
 		down_read(&amp;svm-&gt;mm-&gt;mmap_sem);
 		vma = find_extend_vma(svm-&gt;mm, address);
 		if (!vma || address &lt; vma-&gt;vm_start)
<span class="p_chunk">@@ -567,6 +591,7 @@</span> <span class="p_context"> static irqreturn_t prq_event_thread(int irq, void *d)</span>
 		result = QI_RESP_SUCCESS;
 	invalid:
 		up_read(&amp;svm-&gt;mm-&gt;mmap_sem);
<span class="p_add">+		mmput(svm-&gt;mm);</span>
 	bad_req:
 		/* Accounting for major/minor faults? */
 		rcu_read_lock();
<span class="p_header">diff --git a/drivers/iommu/intel_irq_remapping.c b/drivers/iommu/intel_irq_remapping.c</span>
<span class="p_header">index 1fae1881648c..e9b241b1c9dd 100644</span>
<span class="p_header">--- a/drivers/iommu/intel_irq_remapping.c</span>
<span class="p_header">+++ b/drivers/iommu/intel_irq_remapping.c</span>
<span class="p_chunk">@@ -629,7 +629,7 @@</span> <span class="p_context"> static void iommu_disable_irq_remapping(struct intel_iommu *iommu)</span>
 
 	raw_spin_lock_irqsave(&amp;iommu-&gt;register_lock, flags);
 
<span class="p_del">-	sts = dmar_readq(iommu-&gt;reg + DMAR_GSTS_REG);</span>
<span class="p_add">+	sts = readl(iommu-&gt;reg + DMAR_GSTS_REG);</span>
 	if (!(sts &amp; DMA_GSTS_IRES))
 		goto end;
 
<span class="p_header">diff --git a/drivers/nvdimm/namespace_devs.c b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">index 0955b2cb10fe..62120c38d56b 100644</span>
<span class="p_header">--- a/drivers/nvdimm/namespace_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/namespace_devs.c</span>
<span class="p_chunk">@@ -77,6 +77,59 @@</span> <span class="p_context"> static bool is_namespace_io(struct device *dev)</span>
 	return dev ? dev-&gt;type == &amp;namespace_io_device_type : false;
 }
 
<span class="p_add">+static int is_uuid_busy(struct device *dev, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *uuid1 = data, *uuid2 = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (is_namespace_pmem(dev)) {</span>
<span class="p_add">+		struct nd_namespace_pmem *nspm = to_nd_namespace_pmem(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		uuid2 = nspm-&gt;uuid;</span>
<span class="p_add">+	} else if (is_namespace_blk(dev)) {</span>
<span class="p_add">+		struct nd_namespace_blk *nsblk = to_nd_namespace_blk(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		uuid2 = nsblk-&gt;uuid;</span>
<span class="p_add">+	} else if (is_nd_btt(dev)) {</span>
<span class="p_add">+		struct nd_btt *nd_btt = to_nd_btt(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		uuid2 = nd_btt-&gt;uuid;</span>
<span class="p_add">+	} else if (is_nd_pfn(dev)) {</span>
<span class="p_add">+		struct nd_pfn *nd_pfn = to_nd_pfn(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		uuid2 = nd_pfn-&gt;uuid;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (uuid2 &amp;&amp; memcmp(uuid1, uuid2, NSLABEL_UUID_LEN) == 0)</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int is_namespace_uuid_busy(struct device *dev, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (is_nd_pmem(dev) || is_nd_blk(dev))</span>
<span class="p_add">+		return device_for_each_child(dev, data, is_uuid_busy);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * nd_is_uuid_unique - verify that no other namespace has @uuid</span>
<span class="p_add">+ * @dev: any device on a nvdimm_bus</span>
<span class="p_add">+ * @uuid: uuid to check</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool nd_is_uuid_unique(struct device *dev, u8 *uuid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!nvdimm_bus)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	WARN_ON_ONCE(!is_nvdimm_bus_locked(&amp;nvdimm_bus-&gt;dev));</span>
<span class="p_add">+	if (device_for_each_child(&amp;nvdimm_bus-&gt;dev, uuid,</span>
<span class="p_add">+				is_namespace_uuid_busy) != 0)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 bool pmem_should_map_pages(struct device *dev)
 {
 	struct nd_region *nd_region = to_nd_region(dev-&gt;parent);
<span class="p_header">diff --git a/drivers/nvdimm/region_devs.c b/drivers/nvdimm/region_devs.c</span>
<span class="p_header">index 529f3f02e7b2..9521696c9385 100644</span>
<span class="p_header">--- a/drivers/nvdimm/region_devs.c</span>
<span class="p_header">+++ b/drivers/nvdimm/region_devs.c</span>
<span class="p_chunk">@@ -134,62 +134,6 @@</span> <span class="p_context"> int nd_region_to_nstype(struct nd_region *nd_region)</span>
 }
 EXPORT_SYMBOL(nd_region_to_nstype);
 
<span class="p_del">-static int is_uuid_busy(struct device *dev, void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct nd_region *nd_region = to_nd_region(dev-&gt;parent);</span>
<span class="p_del">-	u8 *uuid = data;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (nd_region_to_nstype(nd_region)) {</span>
<span class="p_del">-	case ND_DEVICE_NAMESPACE_PMEM: {</span>
<span class="p_del">-		struct nd_namespace_pmem *nspm = to_nd_namespace_pmem(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!nspm-&gt;uuid)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		if (memcmp(uuid, nspm-&gt;uuid, NSLABEL_UUID_LEN) == 0)</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	case ND_DEVICE_NAMESPACE_BLK: {</span>
<span class="p_del">-		struct nd_namespace_blk *nsblk = to_nd_namespace_blk(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!nsblk-&gt;uuid)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		if (memcmp(uuid, nsblk-&gt;uuid, NSLABEL_UUID_LEN) == 0)</span>
<span class="p_del">-			return -EBUSY;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int is_namespace_uuid_busy(struct device *dev, void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (is_nd_pmem(dev) || is_nd_blk(dev))</span>
<span class="p_del">-		return device_for_each_child(dev, data, is_uuid_busy);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * nd_is_uuid_unique - verify that no other namespace has @uuid</span>
<span class="p_del">- * @dev: any device on a nvdimm_bus</span>
<span class="p_del">- * @uuid: uuid to check</span>
<span class="p_del">- */</span>
<span class="p_del">-bool nd_is_uuid_unique(struct device *dev, u8 *uuid)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct nvdimm_bus *nvdimm_bus = walk_to_nvdimm_bus(dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!nvdimm_bus)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	WARN_ON_ONCE(!is_nvdimm_bus_locked(&amp;nvdimm_bus-&gt;dev));</span>
<span class="p_del">-	if (device_for_each_child(&amp;nvdimm_bus-&gt;dev, uuid,</span>
<span class="p_del">-				is_namespace_uuid_busy) != 0)</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-	return true;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static ssize_t size_show(struct device *dev,
 		struct device_attribute *attr, char *buf)
 {
<span class="p_header">diff --git a/drivers/phy/phy-twl4030-usb.c b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">index 3a707dd14238..f96065a81d1e 100644</span>
<span class="p_header">--- a/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_chunk">@@ -715,6 +715,7 @@</span> <span class="p_context"> static int twl4030_usb_probe(struct platform_device *pdev)</span>
 	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);
 	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, 2000);
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_add">+	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
 
 	/* Our job is to use irqs and status from the power module
 	 * to keep the transceiver disabled when nothing&#39;s connected.
<span class="p_chunk">@@ -750,6 +751,7 @@</span> <span class="p_context"> static int twl4030_usb_remove(struct platform_device *pdev)</span>
 	struct twl4030_usb *twl = platform_get_drvdata(pdev);
 	int val;
 
<span class="p_add">+	usb_remove_phy(&amp;twl-&gt;phy);</span>
 	pm_runtime_get_sync(twl-&gt;dev);
 	cancel_delayed_work(&amp;twl-&gt;id_workaround_work);
 	device_remove_file(twl-&gt;dev, &amp;dev_attr_vbus);
<span class="p_chunk">@@ -757,6 +759,13 @@</span> <span class="p_context"> static int twl4030_usb_remove(struct platform_device *pdev)</span>
 	/* set transceiver mode to power on defaults */
 	twl4030_usb_set_mode(twl, -1);
 
<span class="p_add">+	/* idle ulpi before powering off */</span>
<span class="p_add">+	if (cable_present(twl-&gt;linkstat))</span>
<span class="p_add">+		pm_runtime_put_noidle(twl-&gt;dev);</span>
<span class="p_add">+	pm_runtime_mark_last_busy(twl-&gt;dev);</span>
<span class="p_add">+	pm_runtime_put_sync_suspend(twl-&gt;dev);</span>
<span class="p_add">+	pm_runtime_disable(twl-&gt;dev);</span>
<span class="p_add">+</span>
 	/* autogate 60MHz ULPI clock,
 	 * clear dpll clock request for i2c access,
 	 * disable 32KHz
<span class="p_chunk">@@ -771,11 +780,6 @@</span> <span class="p_context"> static int twl4030_usb_remove(struct platform_device *pdev)</span>
 	/* disable complete OTG block */
 	twl4030_usb_clear_bits(twl, POWER_CTRL, POWER_CTRL_OTG_ENAB);
 
<span class="p_del">-	if (cable_present(twl-&gt;linkstat))</span>
<span class="p_del">-		pm_runtime_put_noidle(twl-&gt;dev);</span>
<span class="p_del">-	pm_runtime_mark_last_busy(twl-&gt;dev);</span>
<span class="p_del">-	pm_runtime_put(twl-&gt;dev);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/platform/x86/intel_scu_ipcutil.c b/drivers/platform/x86/intel_scu_ipcutil.c</span>
<span class="p_header">index 02bc5a6343c3..aa454241489c 100644</span>
<span class="p_header">--- a/drivers/platform/x86/intel_scu_ipcutil.c</span>
<span class="p_header">+++ b/drivers/platform/x86/intel_scu_ipcutil.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> struct scu_ipc_data {</span>
 
 static int scu_reg_access(u32 cmd, struct scu_ipc_data  *data)
 {
<span class="p_del">-	int count = data-&gt;count;</span>
<span class="p_add">+	unsigned int count = data-&gt;count;</span>
 
 	if (count == 0 || count == 3 || count &gt; 4)
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/scsi/device_handler/scsi_dh_rdac.c b/drivers/scsi/device_handler/scsi_dh_rdac.c</span>
<span class="p_header">index 361358134315..93880ed6291c 100644</span>
<span class="p_header">--- a/drivers/scsi/device_handler/scsi_dh_rdac.c</span>
<span class="p_header">+++ b/drivers/scsi/device_handler/scsi_dh_rdac.c</span>
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> static int mode_select_handle_sense(struct scsi_device *sdev,</span>
 			/*
 			 * Command Lock contention
 			 */
<span class="p_del">-			err = SCSI_DH_RETRY;</span>
<span class="p_add">+			err = SCSI_DH_IMM_RETRY;</span>
 		break;
 	default:
 		break;
<span class="p_chunk">@@ -612,6 +612,8 @@</span> <span class="p_context"> retry:</span>
 		err = mode_select_handle_sense(sdev, h-&gt;sense);
 		if (err == SCSI_DH_RETRY &amp;&amp; retry_cnt--)
 			goto retry;
<span class="p_add">+		if (err == SCSI_DH_IMM_RETRY)</span>
<span class="p_add">+			goto retry;</span>
 	}
 	if (err == SCSI_DH_OK) {
 		h-&gt;state = RDAC_STATE_ACTIVE;
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index 2c1160c7ec92..da2e068ee47d 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -205,6 +205,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;Intel&quot;, &quot;Multi-Flex&quot;, NULL, BLIST_NO_RSOC},
 	{&quot;iRiver&quot;, &quot;iFP Mass Driver&quot;, NULL, BLIST_NOT_LOCKABLE | BLIST_INQUIRY_36},
 	{&quot;LASOUND&quot;, &quot;CDX7405&quot;, &quot;3.10&quot;, BLIST_MAX5LUN | BLIST_SINGLELUN},
<span class="p_add">+	{&quot;Marvell&quot;, &quot;Console&quot;, NULL, BLIST_SKIP_VPD_PAGES},</span>
 	{&quot;MATSHITA&quot;, &quot;PD-1&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;MATSHITA&quot;, &quot;DMC-LC5&quot;, NULL, BLIST_NOT_LOCKABLE | BLIST_INQUIRY_36},
 	{&quot;MATSHITA&quot;, &quot;DMC-LC40&quot;, NULL, BLIST_NOT_LOCKABLE | BLIST_INQUIRY_36},
<span class="p_chunk">@@ -227,6 +228,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;Promise&quot;, &quot;VTrak E610f&quot;, NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
 	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},
<span class="p_add">+	{&quot;SYNOLOGY&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},</span>
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
 	{&quot;REGAL&quot;, &quot;CDC-4X&quot;, NULL, BLIST_MAX5LUN | BLIST_SINGLELUN},
 	{&quot;SanDisk&quot;, &quot;ImageMate CF-SD1&quot;, NULL, BLIST_FORCELUN},
<span class="p_header">diff --git a/drivers/scsi/scsi_sysfs.c b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">index 21930c9ac9cd..c8115b4fe474 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_sysfs.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_sysfs.c</span>
<span class="p_chunk">@@ -1192,16 +1192,18 @@</span> <span class="p_context"> static void __scsi_remove_target(struct scsi_target *starget)</span>
 void scsi_remove_target(struct device *dev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev-&gt;parent);
<span class="p_del">-	struct scsi_target *starget;</span>
<span class="p_add">+	struct scsi_target *starget, *last_target = NULL;</span>
 	unsigned long flags;
 
 restart:
 	spin_lock_irqsave(shost-&gt;host_lock, flags);
 	list_for_each_entry(starget, &amp;shost-&gt;__targets, siblings) {
<span class="p_del">-		if (starget-&gt;state == STARGET_DEL)</span>
<span class="p_add">+		if (starget-&gt;state == STARGET_DEL ||</span>
<span class="p_add">+		    starget == last_target)</span>
 			continue;
 		if (starget-&gt;dev.parent == dev || &amp;starget-&gt;dev == dev) {
 			kref_get(&amp;starget-&gt;reap_ref);
<span class="p_add">+			last_target = starget;</span>
 			spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 			__scsi_remove_target(starget);
 			scsi_target_reap(starget);
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index 4e08d1cd704d..84fa4c46eaa6 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -3268,8 +3268,8 @@</span> <span class="p_context"> static int sd_suspend_common(struct device *dev, bool ignore_stop_errors)</span>
 	struct scsi_disk *sdkp = dev_get_drvdata(dev);
 	int ret = 0;
 
<span class="p_del">-	if (!sdkp)</span>
<span class="p_del">-		return 0;	/* this can happen */</span>
<span class="p_add">+	if (!sdkp)	/* E.g.: runtime suspend following sd_remove() */</span>
<span class="p_add">+		return 0;</span>
 
 	if (sdkp-&gt;WCE &amp;&amp; sdkp-&gt;media_present) {
 		sd_printk(KERN_NOTICE, sdkp, &quot;Synchronizing SCSI cache\n&quot;);
<span class="p_chunk">@@ -3308,6 +3308,9 @@</span> <span class="p_context"> static int sd_resume(struct device *dev)</span>
 {
 	struct scsi_disk *sdkp = dev_get_drvdata(dev);
 
<span class="p_add">+	if (!sdkp)	/* E.g.: runtime resume at the start of sd_probe() */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (!sdkp-&gt;device-&gt;manage_start_stop)
 		return 0;
 
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index 503ab8b46c0b..5e820674432c 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -1261,7 +1261,7 @@</span> <span class="p_context"> sg_mmap(struct file *filp, struct vm_area_struct *vma)</span>
 	}
 
 	sfp-&gt;mmap_called = 1;
<span class="p_del">-	vma-&gt;vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;</span>
<span class="p_add">+	vma-&gt;vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;</span>
 	vma-&gt;vm_private_data = sfp;
 	vma-&gt;vm_ops = &amp;sg_mmap_vm_ops;
 	return 0;
<span class="p_header">diff --git a/drivers/scsi/sr.c b/drivers/scsi/sr.c</span>
<span class="p_header">index 8bd54a64efd6..64c867405ad4 100644</span>
<span class="p_header">--- a/drivers/scsi/sr.c</span>
<span class="p_header">+++ b/drivers/scsi/sr.c</span>
<span class="p_chunk">@@ -144,6 +144,9 @@</span> <span class="p_context"> static int sr_runtime_suspend(struct device *dev)</span>
 {
 	struct scsi_cd *cd = dev_get_drvdata(dev);
 
<span class="p_add">+	if (!cd)	/* E.g.: runtime suspend following sr_remove() */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	if (cd-&gt;media_present)
 		return -EBUSY;
 	else
<span class="p_chunk">@@ -985,6 +988,7 @@</span> <span class="p_context"> static int sr_remove(struct device *dev)</span>
 	scsi_autopm_get_device(cd-&gt;device);
 
 	del_gendisk(cd-&gt;disk);
<span class="p_add">+	dev_set_drvdata(dev, NULL);</span>
 
 	mutex_lock(&amp;sr_ref_mutex);
 	kref_put(&amp;cd-&gt;kref, sr_kref_release);
<span class="p_header">diff --git a/drivers/staging/speakup/selection.c b/drivers/staging/speakup/selection.c</span>
<span class="p_header">index aa5ab6c80ed4..41ef099b7aa6 100644</span>
<span class="p_header">--- a/drivers/staging/speakup/selection.c</span>
<span class="p_header">+++ b/drivers/staging/speakup/selection.c</span>
<span class="p_chunk">@@ -142,7 +142,9 @@</span> <span class="p_context"> static void __speakup_paste_selection(struct work_struct *work)</span>
 	struct tty_ldisc *ld;
 	DECLARE_WAITQUEUE(wait, current);
 
<span class="p_del">-	ld = tty_ldisc_ref_wait(tty);</span>
<span class="p_add">+	ld = tty_ldisc_ref(tty);</span>
<span class="p_add">+	if (!ld)</span>
<span class="p_add">+		goto tty_unref;</span>
 	tty_buffer_lock_exclusive(&amp;vc-&gt;port);
 
 	add_wait_queue(&amp;vc-&gt;paste_wait, &amp;wait);
<span class="p_chunk">@@ -162,6 +164,7 @@</span> <span class="p_context"> static void __speakup_paste_selection(struct work_struct *work)</span>
 
 	tty_buffer_unlock_exclusive(&amp;vc-&gt;port);
 	tty_ldisc_deref(ld);
<span class="p_add">+tty_unref:</span>
 	tty_kref_put(tty);
 }
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target_configfs.c b/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_header">index 255204cc43e6..b4bfd706ac94 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target_configfs.c</span>
<span class="p_chunk">@@ -1593,7 +1593,8 @@</span> <span class="p_context"> static int lio_tpg_check_prot_fabric_only(</span>
 }
 
 /*
<span class="p_del">- * Called with spin_lock_bh(struct se_portal_group-&gt;session_lock) held..</span>
<span class="p_add">+ * Called with spin_lock_irq(struct se_portal_group-&gt;session_lock) held</span>
<span class="p_add">+ * or not held.</span>
  *
  * Also, this function calls iscsit_inc_session_usage_count() on the
  * struct iscsi_session in question.
<span class="p_chunk">@@ -1601,19 +1602,32 @@</span> <span class="p_context"> static int lio_tpg_check_prot_fabric_only(</span>
 static int lio_tpg_shutdown_session(struct se_session *se_sess)
 {
 	struct iscsi_session *sess = se_sess-&gt;fabric_sess_ptr;
<span class="p_add">+	struct se_portal_group *se_tpg = se_sess-&gt;se_tpg;</span>
<span class="p_add">+	bool local_lock = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!spin_is_locked(&amp;se_tpg-&gt;session_lock)) {</span>
<span class="p_add">+		spin_lock_irq(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+		local_lock = true;</span>
<span class="p_add">+	}</span>
 
 	spin_lock(&amp;sess-&gt;conn_lock);
 	if (atomic_read(&amp;sess-&gt;session_fall_back_to_erl0) ||
 	    atomic_read(&amp;sess-&gt;session_logout) ||
 	    (sess-&gt;time2retain_timer_flags &amp; ISCSI_TF_EXPIRED)) {
 		spin_unlock(&amp;sess-&gt;conn_lock);
<span class="p_add">+		if (local_lock)</span>
<span class="p_add">+			spin_unlock_irq(&amp;sess-&gt;conn_lock);</span>
 		return 0;
 	}
 	atomic_set(&amp;sess-&gt;session_reinstatement, 1);
 	spin_unlock(&amp;sess-&gt;conn_lock);
 
 	iscsit_stop_time2retain_timer(sess);
<span class="p_add">+	spin_unlock_irq(&amp;se_tpg-&gt;session_lock);</span>
<span class="p_add">+</span>
 	iscsit_stop_session(sess, 1, 1);
<span class="p_add">+	if (!local_lock)</span>
<span class="p_add">+		spin_lock_irq(&amp;se_tpg-&gt;session_lock);</span>
 
 	return 1;
 }
<span class="p_header">diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c</span>
<span class="p_header">index a45660f62db5..78e983677339 100644</span>
<span class="p_header">--- a/drivers/tty/pty.c</span>
<span class="p_header">+++ b/drivers/tty/pty.c</span>
<span class="p_chunk">@@ -681,7 +681,14 @@</span> <span class="p_context"> static void pty_unix98_remove(struct tty_driver *driver, struct tty_struct *tty)</span>
 /* this is called once with whichever end is closed last */
 static void pty_unix98_shutdown(struct tty_struct *tty)
 {
<span class="p_del">-	devpts_kill_index(tty-&gt;driver_data, tty-&gt;index);</span>
<span class="p_add">+	struct inode *ptmx_inode;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tty-&gt;driver-&gt;subtype == PTY_TYPE_MASTER)</span>
<span class="p_add">+		ptmx_inode = tty-&gt;driver_data;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ptmx_inode = tty-&gt;link-&gt;driver_data;</span>
<span class="p_add">+	devpts_kill_index(ptmx_inode, tty-&gt;index);</span>
<span class="p_add">+	devpts_del_ref(ptmx_inode);</span>
 }
 
 static const struct tty_operations ptm_unix98_ops = {
<span class="p_chunk">@@ -773,6 +780,18 @@</span> <span class="p_context"> static int ptmx_open(struct inode *inode, struct file *filp)</span>
 	set_bit(TTY_PTY_LOCK, &amp;tty-&gt;flags); /* LOCK THE SLAVE */
 	tty-&gt;driver_data = inode;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In the case where all references to ptmx inode are dropped and we</span>
<span class="p_add">+	 * still have /dev/tty opened pointing to the master/slave pair (ptmx</span>
<span class="p_add">+	 * is closed/released before /dev/tty), we must make sure that the inode</span>
<span class="p_add">+	 * is still valid when we call the final pty_unix98_shutdown, thus we</span>
<span class="p_add">+	 * hold an additional reference to the ptmx inode. For the same /dev/tty</span>
<span class="p_add">+	 * last close case, we also need to make sure the super_block isn&#39;t</span>
<span class="p_add">+	 * destroyed (devpts instance unmounted), before /dev/tty is closed and</span>
<span class="p_add">+	 * on its release devpts_kill_index is called.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	devpts_add_ref(inode);</span>
<span class="p_add">+</span>
 	tty_add_file(tty, filp);
 
 	slave_inode = devpts_pty_new(inode,
<span class="p_header">diff --git a/drivers/tty/serial/8250/8250_pci.c b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">index 4097f3f65b3b..7cd6f9a90542 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250/8250_pci.c</span>
<span class="p_chunk">@@ -1379,6 +1379,9 @@</span> <span class="p_context"> ce4100_serial_setup(struct serial_private *priv,</span>
 #define PCI_DEVICE_ID_INTEL_BSW_UART1	0x228a
 #define PCI_DEVICE_ID_INTEL_BSW_UART2	0x228c
 
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_BDW_UART1	0x9ce3</span>
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_BDW_UART2	0x9ce4</span>
<span class="p_add">+</span>
 #define BYT_PRV_CLK			0x800
 #define BYT_PRV_CLK_EN			(1 &lt;&lt; 0)
 #define BYT_PRV_CLK_M_VAL_SHIFT		1
<span class="p_chunk">@@ -1461,11 +1464,13 @@</span> <span class="p_context"> byt_serial_setup(struct serial_private *priv,</span>
 	switch (pdev-&gt;device) {
 	case PCI_DEVICE_ID_INTEL_BYT_UART1:
 	case PCI_DEVICE_ID_INTEL_BSW_UART1:
<span class="p_add">+	case PCI_DEVICE_ID_INTEL_BDW_UART1:</span>
 		rx_param-&gt;src_id = 3;
 		tx_param-&gt;dst_id = 2;
 		break;
 	case PCI_DEVICE_ID_INTEL_BYT_UART2:
 	case PCI_DEVICE_ID_INTEL_BSW_UART2:
<span class="p_add">+	case PCI_DEVICE_ID_INTEL_BDW_UART2:</span>
 		rx_param-&gt;src_id = 5;
 		tx_param-&gt;dst_id = 4;
 		break;
<span class="p_chunk">@@ -1936,6 +1941,7 @@</span> <span class="p_context"> pci_wch_ch38x_setup(struct serial_private *priv,</span>
 #define PCIE_VENDOR_ID_WCH		0x1c00
 #define PCIE_DEVICE_ID_WCH_CH382_2S1P	0x3250
 #define PCIE_DEVICE_ID_WCH_CH384_4S	0x3470
<span class="p_add">+#define PCIE_DEVICE_ID_WCH_CH382_2S	0x3253</span>
 
 #define PCI_VENDOR_ID_PERICOM			0x12D8
 #define PCI_DEVICE_ID_PERICOM_PI7C9X7951	0x7951
<span class="p_chunk">@@ -2062,6 +2068,20 @@</span> <span class="p_context"> static struct pci_serial_quirk pci_serial_quirks[] __refdata = {</span>
 		.subdevice	= PCI_ANY_ID,
 		.setup		= byt_serial_setup,
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.vendor		= PCI_VENDOR_ID_INTEL,</span>
<span class="p_add">+		.device		= PCI_DEVICE_ID_INTEL_BDW_UART1,</span>
<span class="p_add">+		.subvendor	= PCI_ANY_ID,</span>
<span class="p_add">+		.subdevice	= PCI_ANY_ID,</span>
<span class="p_add">+		.setup		= byt_serial_setup,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.vendor		= PCI_VENDOR_ID_INTEL,</span>
<span class="p_add">+		.device		= PCI_DEVICE_ID_INTEL_BDW_UART2,</span>
<span class="p_add">+		.subvendor	= PCI_ANY_ID,</span>
<span class="p_add">+		.subdevice	= PCI_ANY_ID,</span>
<span class="p_add">+		.setup		= byt_serial_setup,</span>
<span class="p_add">+	},</span>
 	/*
 	 * ITE
 	 */
<span class="p_chunk">@@ -2618,6 +2638,14 @@</span> <span class="p_context"> static struct pci_serial_quirk pci_serial_quirks[] __refdata = {</span>
 		.subdevice	= PCI_ANY_ID,
 		.setup		= pci_wch_ch353_setup,
 	},
<span class="p_add">+	/* WCH CH382 2S card (16850 clone) */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.vendor         = PCIE_VENDOR_ID_WCH,</span>
<span class="p_add">+		.device         = PCIE_DEVICE_ID_WCH_CH382_2S,</span>
<span class="p_add">+		.subvendor      = PCI_ANY_ID,</span>
<span class="p_add">+		.subdevice      = PCI_ANY_ID,</span>
<span class="p_add">+		.setup          = pci_wch_ch38x_setup,</span>
<span class="p_add">+	},</span>
 	/* WCH CH382 2S1P card (16850 clone) */
 	{
 		.vendor         = PCIE_VENDOR_ID_WCH,
<span class="p_chunk">@@ -2936,6 +2964,7 @@</span> <span class="p_context"> enum pci_board_num_t {</span>
 	pbn_fintek_4,
 	pbn_fintek_8,
 	pbn_fintek_12,
<span class="p_add">+	pbn_wch382_2,</span>
 	pbn_wch384_4,
 	pbn_pericom_PI7C9X7951,
 	pbn_pericom_PI7C9X7952,
<span class="p_chunk">@@ -3756,6 +3785,13 @@</span> <span class="p_context"> static struct pciserial_board pci_boards[] = {</span>
 		.base_baud	= 115200,
 		.first_offset	= 0x40,
 	},
<span class="p_add">+	[pbn_wch382_2] = {</span>
<span class="p_add">+		.flags		= FL_BASE0,</span>
<span class="p_add">+		.num_ports	= 2,</span>
<span class="p_add">+		.base_baud	= 115200,</span>
<span class="p_add">+		.uart_offset	= 8,</span>
<span class="p_add">+		.first_offset	= 0xC0,</span>
<span class="p_add">+	},</span>
 	[pbn_wch384_4] = {
 		.flags		= FL_BASE0,
 		.num_ports	= 4,
<span class="p_chunk">@@ -5506,6 +5542,16 @@</span> <span class="p_context"> static struct pci_device_id serial_pci_tbl[] = {</span>
 		PCI_CLASS_COMMUNICATION_SERIAL &lt;&lt; 8, 0xff0000,
 		pbn_byt },
 
<span class="p_add">+	/* Intel Broadwell */</span>
<span class="p_add">+	{	PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BDW_UART1,</span>
<span class="p_add">+		PCI_ANY_ID,  PCI_ANY_ID,</span>
<span class="p_add">+		PCI_CLASS_COMMUNICATION_SERIAL &lt;&lt; 8, 0xff0000,</span>
<span class="p_add">+		pbn_byt },</span>
<span class="p_add">+	{	PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BDW_UART2,</span>
<span class="p_add">+		PCI_ANY_ID,  PCI_ANY_ID,</span>
<span class="p_add">+		PCI_CLASS_COMMUNICATION_SERIAL &lt;&lt; 8, 0xff0000,</span>
<span class="p_add">+		pbn_byt },</span>
<span class="p_add">+</span>
 	/*
 	 * Intel Quark x1000
 	 */
<span class="p_chunk">@@ -5545,6 +5591,10 @@</span> <span class="p_context"> static struct pci_device_id serial_pci_tbl[] = {</span>
 		PCI_ANY_ID, PCI_ANY_ID,
 		0, 0, pbn_b0_bt_2_115200 },
 
<span class="p_add">+	{	PCIE_VENDOR_ID_WCH, PCIE_DEVICE_ID_WCH_CH382_2S,</span>
<span class="p_add">+		PCI_ANY_ID, PCI_ANY_ID,</span>
<span class="p_add">+		0, 0, pbn_wch382_2 },</span>
<span class="p_add">+</span>
 	{	PCIE_VENDOR_ID_WCH, PCIE_DEVICE_ID_WCH_CH384_4S,
 		PCI_ANY_ID, PCI_ANY_ID,
 		0, 0, pbn_wch384_4 },
<span class="p_header">diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c</span>
<span class="p_header">index 9d4c84f7485f..24280d9a05e9 100644</span>
<span class="p_header">--- a/drivers/tty/serial/omap-serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/omap-serial.c</span>
<span class="p_chunk">@@ -1343,7 +1343,7 @@</span> <span class="p_context"> static inline void serial_omap_add_console_port(struct uart_omap_port *up)</span>
 
 /* Enable or disable the rs485 support */
 static int
<span class="p_del">-serial_omap_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)</span>
<span class="p_add">+serial_omap_config_rs485(struct uart_port *port, struct serial_rs485 *rs485)</span>
 {
 	struct uart_omap_port *up = to_uart_omap_port(port);
 	unsigned int mode;
<span class="p_chunk">@@ -1356,8 +1356,12 @@</span> <span class="p_context"> serial_omap_config_rs485(struct uart_port *port, struct serial_rs485 *rs485conf)</span>
 	up-&gt;ier = 0;
 	serial_out(up, UART_IER, 0);
 
<span class="p_add">+	/* Clamp the delays to [0, 100ms] */</span>
<span class="p_add">+	rs485-&gt;delay_rts_before_send = min(rs485-&gt;delay_rts_before_send, 100U);</span>
<span class="p_add">+	rs485-&gt;delay_rts_after_send  = min(rs485-&gt;delay_rts_after_send, 100U);</span>
<span class="p_add">+</span>
 	/* store new config */
<span class="p_del">-	port-&gt;rs485 = *rs485conf;</span>
<span class="p_add">+	port-&gt;rs485 = *rs485;</span>
 
 	/*
 	 * Just as a precaution, only allow rs485
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index eeaa6c6bd540..db0f0831b94f 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2192,10 +2192,6 @@</span> <span class="p_context"> static int process_bulk_intr_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 		}
 	/* Fast path - was this the last TRB in the TD for this URB? */
 	} else if (event_trb == td-&gt;last_trb) {
<span class="p_del">-		if (td-&gt;urb_length_set &amp;&amp; trb_comp_code == COMP_SHORT_TX)</span>
<span class="p_del">-			return finish_td(xhci, td, event_trb, event, ep,</span>
<span class="p_del">-					 status, false);</span>
<span class="p_del">-</span>
 		if (EVENT_TRB_LEN(le32_to_cpu(event-&gt;transfer_len)) != 0) {
 			td-&gt;urb-&gt;actual_length =
 				td-&gt;urb-&gt;transfer_buffer_length -
<span class="p_chunk">@@ -2247,12 +2243,6 @@</span> <span class="p_context"> static int process_bulk_intr_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 			td-&gt;urb-&gt;actual_length +=
 				TRB_LEN(le32_to_cpu(cur_trb-&gt;generic.field[2])) -
 				EVENT_TRB_LEN(le32_to_cpu(event-&gt;transfer_len));
<span class="p_del">-</span>
<span class="p_del">-		if (trb_comp_code == COMP_SHORT_TX) {</span>
<span class="p_del">-			xhci_dbg(xhci, &quot;mid bulk/intr SP, wait for last TRB event\n&quot;);</span>
<span class="p_del">-			td-&gt;urb_length_set = true;</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		}</span>
 	}
 
 	return finish_td(xhci, td, event_trb, event, ep, status, false);
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index dca0a4692f08..776d59c32bc5 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -1549,7 +1549,9 @@</span> <span class="p_context"> int xhci_urb_dequeue(struct usb_hcd *hcd, struct urb *urb, int status)</span>
 		xhci_dbg_trace(xhci, trace_xhci_dbg_cancel_urb,
 				&quot;HW died, freeing TD.&quot;);
 		urb_priv = urb-&gt;hcpriv;
<span class="p_del">-		for (i = urb_priv-&gt;td_cnt; i &lt; urb_priv-&gt;length; i++) {</span>
<span class="p_add">+		for (i = urb_priv-&gt;td_cnt;</span>
<span class="p_add">+		     i &lt; urb_priv-&gt;length &amp;&amp; xhci-&gt;devs[urb-&gt;dev-&gt;slot_id];</span>
<span class="p_add">+		     i++) {</span>
 			td = urb_priv-&gt;td[i];
 			if (!list_empty(&amp;td-&gt;td_list))
 				list_del_init(&amp;td-&gt;td_list);
<span class="p_header">diff --git a/fs/btrfs/backref.c b/fs/btrfs/backref.c</span>
<span class="p_header">index d453d62ab0c6..e2f659dc5745 100644</span>
<span class="p_header">--- a/fs/btrfs/backref.c</span>
<span class="p_header">+++ b/fs/btrfs/backref.c</span>
<span class="p_chunk">@@ -1417,7 +1417,8 @@</span> <span class="p_context"> char *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,</span>
 			read_extent_buffer(eb, dest + bytes_left,
 					   name_off, name_len);
 		if (eb != eb_in) {
<span class="p_del">-			btrfs_tree_read_unlock_blocking(eb);</span>
<span class="p_add">+			if (!path-&gt;skip_locking)</span>
<span class="p_add">+				btrfs_tree_read_unlock_blocking(eb);</span>
 			free_extent_buffer(eb);
 		}
 		ret = btrfs_find_item(fs_root, path, parent, 0,
<span class="p_chunk">@@ -1437,9 +1438,10 @@</span> <span class="p_context"> char *btrfs_ref_to_path(struct btrfs_root *fs_root, struct btrfs_path *path,</span>
 		eb = path-&gt;nodes[0];
 		/* make sure we can use eb after releasing the path */
 		if (eb != eb_in) {
<span class="p_del">-			atomic_inc(&amp;eb-&gt;refs);</span>
<span class="p_del">-			btrfs_tree_read_lock(eb);</span>
<span class="p_del">-			btrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);</span>
<span class="p_add">+			if (!path-&gt;skip_locking)</span>
<span class="p_add">+				btrfs_set_lock_blocking_rw(eb, BTRFS_READ_LOCK);</span>
<span class="p_add">+			path-&gt;nodes[0] = NULL;</span>
<span class="p_add">+			path-&gt;locks[0] = 0;</span>
 		}
 		btrfs_release_path(path);
 		iref = btrfs_item_ptr(eb, slot, struct btrfs_inode_ref);
<span class="p_header">diff --git a/fs/btrfs/delayed-inode.c b/fs/btrfs/delayed-inode.c</span>
<span class="p_header">index e0941fbb913c..02b934d0ee65 100644</span>
<span class="p_header">--- a/fs/btrfs/delayed-inode.c</span>
<span class="p_header">+++ b/fs/btrfs/delayed-inode.c</span>
<span class="p_chunk">@@ -1694,7 +1694,7 @@</span> <span class="p_context"> int btrfs_should_delete_dir_index(struct list_head *del_list,</span>
  *
  */
 int btrfs_readdir_delayed_dir_index(struct dir_context *ctx,
<span class="p_del">-				    struct list_head *ins_list)</span>
<span class="p_add">+				    struct list_head *ins_list, bool *emitted)</span>
 {
 	struct btrfs_dir_item *di;
 	struct btrfs_delayed_item *curr, *next;
<span class="p_chunk">@@ -1738,6 +1738,7 @@</span> <span class="p_context"> int btrfs_readdir_delayed_dir_index(struct dir_context *ctx,</span>
 
 		if (over)
 			return 1;
<span class="p_add">+		*emitted = true;</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/btrfs/delayed-inode.h b/fs/btrfs/delayed-inode.h</span>
<span class="p_header">index f70119f25421..0167853c84ae 100644</span>
<span class="p_header">--- a/fs/btrfs/delayed-inode.h</span>
<span class="p_header">+++ b/fs/btrfs/delayed-inode.h</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> void btrfs_put_delayed_items(struct list_head *ins_list,</span>
 int btrfs_should_delete_dir_index(struct list_head *del_list,
 				  u64 index);
 int btrfs_readdir_delayed_dir_index(struct dir_context *ctx,
<span class="p_del">-				    struct list_head *ins_list);</span>
<span class="p_add">+				    struct list_head *ins_list, bool *emitted);</span>
 
 /* for init */
 int __init btrfs_delayed_inode_init(void);
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index 974be09e7556..0ddca6734494 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -1762,7 +1762,6 @@</span> <span class="p_context"> static int cleaner_kthread(void *arg)</span>
 	int again;
 	struct btrfs_trans_handle *trans;
 
<span class="p_del">-	set_freezable();</span>
 	do {
 		again = 0;
 
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index a70c5790f8f5..54b5f0de623b 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -5741,6 +5741,7 @@</span> <span class="p_context"> static int btrfs_real_readdir(struct file *file, struct dir_context *ctx)</span>
 	char *name_ptr;
 	int name_len;
 	int is_curr = 0;	/* ctx-&gt;pos points to the current index? */
<span class="p_add">+	bool emitted;</span>
 
 	/* FIXME, use a real flag for deciding about the key type */
 	if (root-&gt;fs_info-&gt;tree_root == root)
<span class="p_chunk">@@ -5769,6 +5770,7 @@</span> <span class="p_context"> static int btrfs_real_readdir(struct file *file, struct dir_context *ctx)</span>
 	if (ret &lt; 0)
 		goto err;
 
<span class="p_add">+	emitted = false;</span>
 	while (1) {
 		leaf = path-&gt;nodes[0];
 		slot = path-&gt;slots[0];
<span class="p_chunk">@@ -5848,6 +5850,7 @@</span> <span class="p_context"> skip:</span>
 
 			if (over)
 				goto nopos;
<span class="p_add">+			emitted = true;</span>
 			di_len = btrfs_dir_name_len(leaf, di) +
 				 btrfs_dir_data_len(leaf, di) + sizeof(*di);
 			di_cur += di_len;
<span class="p_chunk">@@ -5860,11 +5863,20 @@</span> <span class="p_context"> next:</span>
 	if (key_type == BTRFS_DIR_INDEX_KEY) {
 		if (is_curr)
 			ctx-&gt;pos++;
<span class="p_del">-		ret = btrfs_readdir_delayed_dir_index(ctx, &amp;ins_list);</span>
<span class="p_add">+		ret = btrfs_readdir_delayed_dir_index(ctx, &amp;ins_list, &amp;emitted);</span>
 		if (ret)
 			goto nopos;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we haven&#39;t emitted any dir entry, we must not touch ctx-&gt;pos as</span>
<span class="p_add">+	 * it was was set to the termination value in previous call. We assume</span>
<span class="p_add">+	 * that &quot;.&quot; and &quot;..&quot; were emitted if we reach this point and set the</span>
<span class="p_add">+	 * termination value as well for an empty directory.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ctx-&gt;pos &gt; 2 &amp;&amp; !emitted)</span>
<span class="p_add">+		goto nopos;</span>
<span class="p_add">+</span>
 	/* Reached end of directory/root. Bump pos past the last item. */
 	ctx-&gt;pos++;
 
<span class="p_chunk">@@ -7985,6 +7997,7 @@</span> <span class="p_context"> static void btrfs_endio_direct_read(struct bio *bio)</span>
 
 	kfree(dip);
 
<span class="p_add">+	dio_bio-&gt;bi_error = bio-&gt;bi_error;</span>
 	dio_end_io(dio_bio, bio-&gt;bi_error);
 
 	if (io_bio-&gt;end_io)
<span class="p_chunk">@@ -8030,6 +8043,7 @@</span> <span class="p_context"> out_test:</span>
 
 	kfree(dip);
 
<span class="p_add">+	dio_bio-&gt;bi_error = bio-&gt;bi_error;</span>
 	dio_end_io(dio_bio, bio-&gt;bi_error);
 	bio_put(bio);
 }
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index da94138eb85e..08fd3f0f34fd 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2782,24 +2782,29 @@</span> <span class="p_context"> out:</span>
 static struct page *extent_same_get_page(struct inode *inode, pgoff_t index)
 {
 	struct page *page;
<span class="p_del">-	struct extent_io_tree *tree = &amp;BTRFS_I(inode)-&gt;io_tree;</span>
 
 	page = grab_cache_page(inode-&gt;i_mapping, index);
 	if (!page)
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
 
 	if (!PageUptodate(page)) {
<span class="p_del">-		if (extent_read_full_page_nolock(tree, page, btrfs_get_extent,</span>
<span class="p_del">-						 0))</span>
<span class="p_del">-			return NULL;</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = btrfs_readpage(NULL, page);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ERR_PTR(ret);</span>
 		lock_page(page);
 		if (!PageUptodate(page)) {
 			unlock_page(page);
 			page_cache_release(page);
<span class="p_del">-			return NULL;</span>
<span class="p_add">+			return ERR_PTR(-EIO);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (page-&gt;mapping != inode-&gt;i_mapping) {</span>
<span class="p_add">+			unlock_page(page);</span>
<span class="p_add">+			page_cache_release(page);</span>
<span class="p_add">+			return ERR_PTR(-EAGAIN);</span>
 		}
 	}
<span class="p_del">-	unlock_page(page);</span>
 
 	return page;
 }
<span class="p_chunk">@@ -2811,17 +2816,31 @@</span> <span class="p_context"> static int gather_extent_pages(struct inode *inode, struct page **pages,</span>
 	pgoff_t index = off &gt;&gt; PAGE_CACHE_SHIFT;
 
 	for (i = 0; i &lt; num_pages; i++) {
<span class="p_add">+again:</span>
 		pages[i] = extent_same_get_page(inode, index + i);
<span class="p_del">-		if (!pages[i])</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_add">+		if (IS_ERR(pages[i])) {</span>
<span class="p_add">+			int err = PTR_ERR(pages[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (err == -EAGAIN)</span>
<span class="p_add">+				goto again;</span>
<span class="p_add">+			pages[i] = NULL;</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		}</span>
 	}
 	return 0;
 }
 
<span class="p_del">-static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)</span>
<span class="p_add">+static int lock_extent_range(struct inode *inode, u64 off, u64 len,</span>
<span class="p_add">+			     bool retry_range_locking)</span>
 {
<span class="p_del">-	/* do any pending delalloc/csum calc on src, one way or</span>
<span class="p_del">-	   another, and lock file content */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Do any pending delalloc/csum calculations on inode, one way or</span>
<span class="p_add">+	 * another, and lock file content.</span>
<span class="p_add">+	 * The locking order is:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *   1) pages</span>
<span class="p_add">+	 *   2) range in the inode&#39;s io tree</span>
<span class="p_add">+	 */</span>
 	while (1) {
 		struct btrfs_ordered_extent *ordered;
 		lock_extent(&amp;BTRFS_I(inode)-&gt;io_tree, off, off + len - 1);
<span class="p_chunk">@@ -2839,8 +2858,11 @@</span> <span class="p_context"> static inline void lock_extent_range(struct inode *inode, u64 off, u64 len)</span>
 		unlock_extent(&amp;BTRFS_I(inode)-&gt;io_tree, off, off + len - 1);
 		if (ordered)
 			btrfs_put_ordered_extent(ordered);
<span class="p_add">+		if (!retry_range_locking)</span>
<span class="p_add">+			return -EAGAIN;</span>
 		btrfs_wait_ordered_range(inode, off, len);
 	}
<span class="p_add">+	return 0;</span>
 }
 
 static void btrfs_double_inode_unlock(struct inode *inode1, struct inode *inode2)
<span class="p_chunk">@@ -2865,15 +2887,24 @@</span> <span class="p_context"> static void btrfs_double_extent_unlock(struct inode *inode1, u64 loff1,</span>
 	unlock_extent(&amp;BTRFS_I(inode2)-&gt;io_tree, loff2, loff2 + len - 1);
 }
 
<span class="p_del">-static void btrfs_double_extent_lock(struct inode *inode1, u64 loff1,</span>
<span class="p_del">-				     struct inode *inode2, u64 loff2, u64 len)</span>
<span class="p_add">+static int btrfs_double_extent_lock(struct inode *inode1, u64 loff1,</span>
<span class="p_add">+				    struct inode *inode2, u64 loff2, u64 len,</span>
<span class="p_add">+				    bool retry_range_locking)</span>
 {
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
 	if (inode1 &lt; inode2) {
 		swap(inode1, inode2);
 		swap(loff1, loff2);
 	}
<span class="p_del">-	lock_extent_range(inode1, loff1, len);</span>
<span class="p_del">-	lock_extent_range(inode2, loff2, len);</span>
<span class="p_add">+	ret = lock_extent_range(inode1, loff1, len, retry_range_locking);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	ret = lock_extent_range(inode2, loff2, len, retry_range_locking);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		unlock_extent(&amp;BTRFS_I(inode1)-&gt;io_tree, loff1,</span>
<span class="p_add">+			      loff1 + len - 1);</span>
<span class="p_add">+	return ret;</span>
 }
 
 struct cmp_pages {
<span class="p_chunk">@@ -2889,11 +2920,15 @@</span> <span class="p_context"> static void btrfs_cmp_data_free(struct cmp_pages *cmp)</span>
 
 	for (i = 0; i &lt; cmp-&gt;num_pages; i++) {
 		pg = cmp-&gt;src_pages[i];
<span class="p_del">-		if (pg)</span>
<span class="p_add">+		if (pg) {</span>
<span class="p_add">+			unlock_page(pg);</span>
 			page_cache_release(pg);
<span class="p_add">+		}</span>
 		pg = cmp-&gt;dst_pages[i];
<span class="p_del">-		if (pg)</span>
<span class="p_add">+		if (pg) {</span>
<span class="p_add">+			unlock_page(pg);</span>
 			page_cache_release(pg);
<span class="p_add">+		}</span>
 	}
 	kfree(cmp-&gt;src_pages);
 	kfree(cmp-&gt;dst_pages);
<span class="p_chunk">@@ -2954,6 +2989,8 @@</span> <span class="p_context"> static int btrfs_cmp_data(struct inode *src, u64 loff, struct inode *dst,</span>
 
 		src_page = cmp-&gt;src_pages[i];
 		dst_page = cmp-&gt;dst_pages[i];
<span class="p_add">+		ASSERT(PageLocked(src_page));</span>
<span class="p_add">+		ASSERT(PageLocked(dst_page));</span>
 
 		addr = kmap_atomic(src_page);
 		dst_addr = kmap_atomic(dst_page);
<span class="p_chunk">@@ -3066,14 +3103,46 @@</span> <span class="p_context"> static int btrfs_extent_same(struct inode *src, u64 loff, u64 olen,</span>
 		goto out_unlock;
 	}
 
<span class="p_add">+again:</span>
 	ret = btrfs_cmp_data_prepare(src, loff, dst, dst_loff, olen, &amp;cmp);
 	if (ret)
 		goto out_unlock;
 
 	if (same_inode)
<span class="p_del">-		lock_extent_range(src, same_lock_start, same_lock_len);</span>
<span class="p_add">+		ret = lock_extent_range(src, same_lock_start, same_lock_len,</span>
<span class="p_add">+					false);</span>
 	else
<span class="p_del">-		btrfs_double_extent_lock(src, loff, dst, dst_loff, len);</span>
<span class="p_add">+		ret = btrfs_double_extent_lock(src, loff, dst, dst_loff, len,</span>
<span class="p_add">+					       false);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If one of the inodes has dirty pages in the respective range or</span>
<span class="p_add">+	 * ordered extents, we need to flush dellaloc and wait for all ordered</span>
<span class="p_add">+	 * extents in the range. We must unlock the pages and the ranges in the</span>
<span class="p_add">+	 * io trees to avoid deadlocks when flushing delalloc (requires locking</span>
<span class="p_add">+	 * pages) and when waiting for ordered extents to complete (they require</span>
<span class="p_add">+	 * range locking).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ret == -EAGAIN) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Ranges in the io trees already unlocked. Now unlock all</span>
<span class="p_add">+		 * pages before waiting for all IO to complete.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		btrfs_cmp_data_free(&amp;cmp);</span>
<span class="p_add">+		if (same_inode) {</span>
<span class="p_add">+			btrfs_wait_ordered_range(src, same_lock_start,</span>
<span class="p_add">+						 same_lock_len);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			btrfs_wait_ordered_range(src, loff, len);</span>
<span class="p_add">+			btrfs_wait_ordered_range(dst, dst_loff, len);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ASSERT(ret == 0);</span>
<span class="p_add">+	if (WARN_ON(ret)) {</span>
<span class="p_add">+		/* ranges in the io trees already unlocked */</span>
<span class="p_add">+		btrfs_cmp_data_free(&amp;cmp);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
 	/* pass original length for comparison so we stay within i_size */
 	ret = btrfs_cmp_data(src, loff, dst, dst_loff, olen, &amp;cmp);
<span class="p_chunk">@@ -3895,9 +3964,15 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 		u64 lock_start = min_t(u64, off, destoff);
 		u64 lock_len = max_t(u64, off, destoff) + len - lock_start;
 
<span class="p_del">-		lock_extent_range(src, lock_start, lock_len);</span>
<span class="p_add">+		ret = lock_extent_range(src, lock_start, lock_len, true);</span>
 	} else {
<span class="p_del">-		btrfs_double_extent_lock(src, off, inode, destoff, len);</span>
<span class="p_add">+		ret = btrfs_double_extent_lock(src, off, inode, destoff, len,</span>
<span class="p_add">+					       true);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ASSERT(ret == 0);</span>
<span class="p_add">+	if (WARN_ON(ret)) {</span>
<span class="p_add">+		/* ranges in the io trees already unlocked */</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
 
 	ret = btrfs_clone(src, inode, off, olen, len, destoff, 0);
<span class="p_header">diff --git a/fs/btrfs/volumes.c b/fs/btrfs/volumes.c</span>
<span class="p_header">index a23399e8e3ab..9e084477d320 100644</span>
<span class="p_header">--- a/fs/btrfs/volumes.c</span>
<span class="p_header">+++ b/fs/btrfs/volumes.c</span>
<span class="p_chunk">@@ -1257,6 +1257,15 @@</span> <span class="p_context"> int find_free_dev_extent_start(struct btrfs_transaction *transaction,</span>
 	int ret;
 	int slot;
 	struct extent_buffer *l;
<span class="p_add">+	u64 min_search_start;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We don&#39;t want to overwrite the superblock on the drive nor any area</span>
<span class="p_add">+	 * used by the boot loader (grub for example), so we make sure to start</span>
<span class="p_add">+	 * at an offset of at least 1MB.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	min_search_start = max(root-&gt;fs_info-&gt;alloc_start, 1024ull * 1024);</span>
<span class="p_add">+	search_start = max(search_start, min_search_start);</span>
 
 	path = btrfs_alloc_path();
 	if (!path)
<span class="p_chunk">@@ -1397,18 +1406,9 @@</span> <span class="p_context"> int find_free_dev_extent(struct btrfs_trans_handle *trans,</span>
 			 struct btrfs_device *device, u64 num_bytes,
 			 u64 *start, u64 *len)
 {
<span class="p_del">-	struct btrfs_root *root = device-&gt;dev_root;</span>
<span class="p_del">-	u64 search_start;</span>
<span class="p_del">-</span>
 	/* FIXME use last free of some kind */
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * we don&#39;t want to overwrite the superblock on the drive,</span>
<span class="p_del">-	 * so we make sure to start at an offset of at least 1MB</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	search_start = max(root-&gt;fs_info-&gt;alloc_start, 1024ull * 1024);</span>
 	return find_free_dev_extent_start(trans-&gt;transaction, device,
<span class="p_del">-					  num_bytes, search_start, start, len);</span>
<span class="p_add">+					  num_bytes, 0, start, len);</span>
 }
 
 static int btrfs_free_dev_extent(struct btrfs_trans_handle *trans,
<span class="p_chunk">@@ -6512,6 +6512,14 @@</span> <span class="p_context"> int btrfs_read_sys_array(struct btrfs_root *root)</span>
 				goto out_short_read;
 
 			num_stripes = btrfs_chunk_num_stripes(sb, chunk);
<span class="p_add">+			if (!num_stripes) {</span>
<span class="p_add">+				printk(KERN_ERR</span>
<span class="p_add">+	    &quot;BTRFS: invalid number of stripes %u in sys_array at offset %u\n&quot;,</span>
<span class="p_add">+					num_stripes, cur_offset);</span>
<span class="p_add">+				ret = -EIO;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			len = btrfs_chunk_item_size(num_stripes);
 			if (cur_offset + len &gt; array_size)
 				goto out_short_read;
<span class="p_header">diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c</span>
<span class="p_header">index 7febcf2475c5..50b268483302 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.c</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"> void cifs_vfs_err(const char *fmt, ...)</span>
 	vaf.fmt = fmt;
 	vaf.va = &amp;args;
 
<span class="p_del">-	pr_err(&quot;CIFS VFS: %pV&quot;, &amp;vaf);</span>
<span class="p_add">+	pr_err_ratelimited(&quot;CIFS VFS: %pV&quot;, &amp;vaf);</span>
 
 	va_end(args);
 }
<span class="p_header">diff --git a/fs/cifs/cifs_debug.h b/fs/cifs/cifs_debug.h</span>
<span class="p_header">index f40fbaca1b2a..66cf0f9fff89 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.h</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.h</span>
<span class="p_chunk">@@ -51,14 +51,13 @@</span> <span class="p_context"> __printf(1, 2) void cifs_vfs_err(const char *fmt, ...);</span>
 /* information message: e.g., configuration, major event */
 #define cifs_dbg(type, fmt, ...)					\
 do {									\
<span class="p_del">-	if (type == FYI) {						\</span>
<span class="p_del">-		if (cifsFYI &amp; CIFS_INFO) {				\</span>
<span class="p_del">-			pr_debug(&quot;%s: &quot; fmt, __FILE__, ##__VA_ARGS__);	\</span>
<span class="p_del">-		}							\</span>
<span class="p_add">+	if (type == FYI &amp;&amp; cifsFYI &amp; CIFS_INFO) {			\</span>
<span class="p_add">+		pr_debug_ratelimited(&quot;%s: &quot;				\</span>
<span class="p_add">+			    fmt, __FILE__, ##__VA_ARGS__);		\</span>
 	} else if (type == VFS) {					\
 		cifs_vfs_err(fmt, ##__VA_ARGS__);			\
 	} else if (type == NOISY &amp;&amp; type != 0) {			\
<span class="p_del">-		pr_debug(fmt, ##__VA_ARGS__);				\</span>
<span class="p_add">+		pr_debug_ratelimited(fmt, ##__VA_ARGS__);		\</span>
 	}								\
 } while (0)
 
<span class="p_header">diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c</span>
<span class="p_header">index afa09fce8151..e682b36a210f 100644</span>
<span class="p_header">--- a/fs/cifs/cifsencrypt.c</span>
<span class="p_header">+++ b/fs/cifs/cifsencrypt.c</span>
<span class="p_chunk">@@ -714,7 +714,7 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 
 	ses-&gt;auth_key.response = kmalloc(baselen + tilen, GFP_KERNEL);
 	if (!ses-&gt;auth_key.response) {
<span class="p_del">-		rc = ENOMEM;</span>
<span class="p_add">+		rc = -ENOMEM;</span>
 		ses-&gt;auth_key.len = 0;
 		goto setup_ntlmv2_rsp_ret;
 	}
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index ecb0803bdb0e..3c194ff0d2f0 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -368,7 +368,6 @@</span> <span class="p_context"> cifs_reconnect(struct TCP_Server_Info *server)</span>
 	server-&gt;session_key.response = NULL;
 	server-&gt;session_key.len = 0;
 	server-&gt;lstrp = jiffies;
<span class="p_del">-	mutex_unlock(&amp;server-&gt;srv_mutex);</span>
 
 	/* mark submitted MIDs for retry and issue callback */
 	INIT_LIST_HEAD(&amp;retry_list);
<span class="p_chunk">@@ -381,6 +380,7 @@</span> <span class="p_context"> cifs_reconnect(struct TCP_Server_Info *server)</span>
 		list_move(&amp;mid_entry-&gt;qhead, &amp;retry_list);
 	}
 	spin_unlock(&amp;GlobalMid_Lock);
<span class="p_add">+	mutex_unlock(&amp;server-&gt;srv_mutex);</span>
 
 	cifs_dbg(FYI, &quot;%s: issuing mid callbacks\n&quot;, __func__);
 	list_for_each_safe(tmp, tmp2, &amp;retry_list) {
<span class="p_header">diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c</span>
<span class="p_header">index 0557c45e9c33..b30a4a6d98a0 100644</span>
<span class="p_header">--- a/fs/cifs/readdir.c</span>
<span class="p_header">+++ b/fs/cifs/readdir.c</span>
<span class="p_chunk">@@ -847,6 +847,7 @@</span> <span class="p_context"> int cifs_readdir(struct file *file, struct dir_context *ctx)</span>
 		 * if buggy server returns . and .. late do we want to
 		 * check for that here?
 		 */
<span class="p_add">+		*tmp_buf = 0;</span>
 		rc = cifs_filldir(current_entry, file, ctx,
 				  tmp_buf, max_len);
 		if (rc) {
<span class="p_header">diff --git a/fs/cifs/transport.c b/fs/cifs/transport.c</span>
<span class="p_header">index 2a24c524fb9a..87abe8ed074c 100644</span>
<span class="p_header">--- a/fs/cifs/transport.c</span>
<span class="p_header">+++ b/fs/cifs/transport.c</span>
<span class="p_chunk">@@ -576,14 +576,16 @@</span> <span class="p_context"> cifs_call_async(struct TCP_Server_Info *server, struct smb_rqst *rqst,</span>
 	cifs_in_send_dec(server);
 	cifs_save_when_sent(mid);
 
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
 		server-&gt;sequence_number -= 2;
<span class="p_add">+		cifs_delete_mid(mid);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;server-&gt;srv_mutex);
 
 	if (rc == 0)
 		return 0;
 
<span class="p_del">-	cifs_delete_mid(mid);</span>
 	add_credits_and_wake_if(server, credits, optype);
 	return rc;
 }
<span class="p_header">diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c</span>
<span class="p_header">index c35ffdc12bba..706de324f2a6 100644</span>
<span class="p_header">--- a/fs/devpts/inode.c</span>
<span class="p_header">+++ b/fs/devpts/inode.c</span>
<span class="p_chunk">@@ -575,6 +575,26 @@</span> <span class="p_context"> void devpts_kill_index(struct inode *ptmx_inode, int idx)</span>
 	mutex_unlock(&amp;allocated_ptys_lock);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * pty code needs to hold extra references in case of last /dev/tty close</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+void devpts_add_ref(struct inode *ptmx_inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct super_block *sb = pts_sb_from_inode(ptmx_inode);</span>
<span class="p_add">+</span>
<span class="p_add">+	atomic_inc(&amp;sb-&gt;s_active);</span>
<span class="p_add">+	ihold(ptmx_inode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void devpts_del_ref(struct inode *ptmx_inode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct super_block *sb = pts_sb_from_inode(ptmx_inode);</span>
<span class="p_add">+</span>
<span class="p_add">+	iput(ptmx_inode);</span>
<span class="p_add">+	deactivate_super(sb);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * devpts_pty_new -- create a new inode in /dev/pts/
  * @ptmx_inode: inode of the master
<span class="p_header">diff --git a/fs/ext4/balloc.c b/fs/ext4/balloc.c</span>
<span class="p_header">index ec0668a60678..fe1f50fe764f 100644</span>
<span class="p_header">--- a/fs/ext4/balloc.c</span>
<span class="p_header">+++ b/fs/ext4/balloc.c</span>
<span class="p_chunk">@@ -191,7 +191,6 @@</span> <span class="p_context"> static int ext4_init_block_bitmap(struct super_block *sb,</span>
 	/* If checksum is bad mark all blocks used to prevent allocation
 	 * essentially implementing a per-group read-only flag. */
 	if (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {
<span class="p_del">-		ext4_error(sb, &quot;Checksum bad for group %u&quot;, block_group);</span>
 		grp = ext4_get_group_info(sb, block_group);
 		if (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 			percpu_counter_sub(&amp;sbi-&gt;s_freeclusters_counter,
<span class="p_chunk">@@ -442,14 +441,16 @@</span> <span class="p_context"> ext4_read_block_bitmap_nowait(struct super_block *sb, ext4_group_t block_group)</span>
 	}
 	ext4_lock_group(sb, block_group);
 	if (desc-&gt;bg_flags &amp; cpu_to_le16(EXT4_BG_BLOCK_UNINIT)) {
<span class="p_del">-</span>
 		err = ext4_init_block_bitmap(sb, bh, block_group, desc);
 		set_bitmap_uptodate(bh);
 		set_buffer_uptodate(bh);
 		ext4_unlock_group(sb, block_group);
 		unlock_buffer(bh);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			ext4_error(sb, &quot;Failed to init block bitmap for group &quot;</span>
<span class="p_add">+				   &quot;%u: %d&quot;, block_group, err);</span>
 			goto out;
<span class="p_add">+		}</span>
 		goto verify;
 	}
 	ext4_unlock_group(sb, block_group);
<span class="p_header">diff --git a/fs/ext4/ialloc.c b/fs/ext4/ialloc.c</span>
<span class="p_header">index 1b8024d26f65..53f2b98a69f3 100644</span>
<span class="p_header">--- a/fs/ext4/ialloc.c</span>
<span class="p_header">+++ b/fs/ext4/ialloc.c</span>
<span class="p_chunk">@@ -76,7 +76,6 @@</span> <span class="p_context"> static int ext4_init_inode_bitmap(struct super_block *sb,</span>
 	/* If checksum is bad mark all blocks and inodes use to prevent
 	 * allocation, essentially implementing a per-group read-only flag. */
 	if (!ext4_group_desc_csum_verify(sb, block_group, gdp)) {
<span class="p_del">-		ext4_error(sb, &quot;Checksum bad for group %u&quot;, block_group);</span>
 		grp = ext4_get_group_info(sb, block_group);
 		if (!EXT4_MB_GRP_BBITMAP_CORRUPT(grp))
 			percpu_counter_sub(&amp;sbi-&gt;s_freeclusters_counter,
<span class="p_chunk">@@ -191,8 +190,11 @@</span> <span class="p_context"> ext4_read_inode_bitmap(struct super_block *sb, ext4_group_t block_group)</span>
 		set_buffer_verified(bh);
 		ext4_unlock_group(sb, block_group);
 		unlock_buffer(bh);
<span class="p_del">-		if (err)</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			ext4_error(sb, &quot;Failed to init inode bitmap for group &quot;</span>
<span class="p_add">+				   &quot;%u: %d&quot;, block_group, err);</span>
 			goto out;
<span class="p_add">+		}</span>
 		return bh;
 	}
 	ext4_unlock_group(sb, block_group);
<span class="p_header">diff --git a/fs/ext4/move_extent.c b/fs/ext4/move_extent.c</span>
<span class="p_header">index fb6f11709ae6..e032a0423e35 100644</span>
<span class="p_header">--- a/fs/ext4/move_extent.c</span>
<span class="p_header">+++ b/fs/ext4/move_extent.c</span>
<span class="p_chunk">@@ -265,11 +265,12 @@</span> <span class="p_context"> move_extent_per_page(struct file *o_filp, struct inode *donor_inode,</span>
 	ext4_lblk_t orig_blk_offset, donor_blk_offset;
 	unsigned long blocksize = orig_inode-&gt;i_sb-&gt;s_blocksize;
 	unsigned int tmp_data_size, data_size, replaced_size;
<span class="p_del">-	int err2, jblocks, retries = 0;</span>
<span class="p_add">+	int i, err2, jblocks, retries = 0;</span>
 	int replaced_count = 0;
 	int from = data_offset_in_page &lt;&lt; orig_inode-&gt;i_blkbits;
 	int blocks_per_page = PAGE_CACHE_SIZE &gt;&gt; orig_inode-&gt;i_blkbits;
 	struct super_block *sb = orig_inode-&gt;i_sb;
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 
 	/*
 	 * It needs twice the amount of ordinary journal buffers because
<span class="p_chunk">@@ -380,8 +381,16 @@</span> <span class="p_context"> data_copy:</span>
 	}
 	/* Perform all necessary steps similar write_begin()/write_end()
 	 * but keeping in mind that i_size will not change */
<span class="p_del">-	*err = __block_write_begin(pagep[0], from, replaced_size,</span>
<span class="p_del">-				   ext4_get_block);</span>
<span class="p_add">+	if (!page_has_buffers(pagep[0]))</span>
<span class="p_add">+		create_empty_buffers(pagep[0], 1 &lt;&lt; orig_inode-&gt;i_blkbits, 0);</span>
<span class="p_add">+	bh = page_buffers(pagep[0]);</span>
<span class="p_add">+	for (i = 0; i &lt; data_offset_in_page; i++)</span>
<span class="p_add">+		bh = bh-&gt;b_this_page;</span>
<span class="p_add">+	for (i = 0; i &lt; block_len_in_page; i++) {</span>
<span class="p_add">+		*err = ext4_get_block(orig_inode, orig_blk_offset + i, bh, 0);</span>
<span class="p_add">+		if (*err &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
 	if (!*err)
 		*err = block_commit_write(pagep[0], from, from + replaced_size);
 
<span class="p_header">diff --git a/fs/ext4/resize.c b/fs/ext4/resize.c</span>
<span class="p_header">index ad62d7acc315..34038e3598d5 100644</span>
<span class="p_header">--- a/fs/ext4/resize.c</span>
<span class="p_header">+++ b/fs/ext4/resize.c</span>
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"> static struct ext4_new_flex_group_data *alloc_flex_gd(unsigned long flexbg_size)</span>
 	if (flex_gd == NULL)
 		goto out3;
 
<span class="p_del">-	if (flexbg_size &gt;= UINT_MAX / sizeof(struct ext4_new_flex_group_data))</span>
<span class="p_add">+	if (flexbg_size &gt;= UINT_MAX / sizeof(struct ext4_new_group_data))</span>
 		goto out2;
 	flex_gd-&gt;count = flexbg_size;
 
<span class="p_header">diff --git a/fs/hugetlbfs/inode.c b/fs/hugetlbfs/inode.c</span>
<span class="p_header">index de4bdfac0cec..595ebdb41846 100644</span>
<span class="p_header">--- a/fs/hugetlbfs/inode.c</span>
<span class="p_header">+++ b/fs/hugetlbfs/inode.c</span>
<span class="p_chunk">@@ -463,6 +463,7 @@</span> <span class="p_context"> hugetlb_vmdelete_list(struct rb_root *root, pgoff_t start, pgoff_t end)</span>
 	 */
 	vma_interval_tree_foreach(vma, root, start, end ? end : ULONG_MAX) {
 		unsigned long v_offset;
<span class="p_add">+		unsigned long v_end;</span>
 
 		/*
 		 * Can the expression below overflow on 32-bit arches?
<span class="p_chunk">@@ -475,15 +476,17 @@</span> <span class="p_context"> hugetlb_vmdelete_list(struct rb_root *root, pgoff_t start, pgoff_t end)</span>
 		else
 			v_offset = 0;
 
<span class="p_del">-		if (end) {</span>
<span class="p_del">-			end = ((end - start) &lt;&lt; PAGE_SHIFT) +</span>
<span class="p_del">-			       vma-&gt;vm_start + v_offset;</span>
<span class="p_del">-			if (end &gt; vma-&gt;vm_end)</span>
<span class="p_del">-				end = vma-&gt;vm_end;</span>
<span class="p_del">-		} else</span>
<span class="p_del">-			end = vma-&gt;vm_end;</span>
<span class="p_add">+		if (!end)</span>
<span class="p_add">+			v_end = vma-&gt;vm_end;</span>
<span class="p_add">+		else {</span>
<span class="p_add">+			v_end = ((end - vma-&gt;vm_pgoff) &lt;&lt; PAGE_SHIFT)</span>
<span class="p_add">+							+ vma-&gt;vm_start;</span>
<span class="p_add">+			if (v_end &gt; vma-&gt;vm_end)</span>
<span class="p_add">+				v_end = vma-&gt;vm_end;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		unmap_hugepage_range(vma, vma-&gt;vm_start + v_offset, end, NULL);</span>
<span class="p_add">+		unmap_hugepage_range(vma, vma-&gt;vm_start + v_offset, v_end,</span>
<span class="p_add">+									NULL);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">index 03516c80855a..2a2e2d8ddee5 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> static bool ff_mirror_match_fh(const struct nfs4_ff_layout_mirror *m1,</span>
 		return false;
 	for (i = 0; i &lt; m1-&gt;fh_versions_cnt; i++) {
 		bool found_fh = false;
<span class="p_del">-		for (j = 0; j &lt; m2-&gt;fh_versions_cnt; i++) {</span>
<span class="p_add">+		for (j = 0; j &lt; m2-&gt;fh_versions_cnt; j++) {</span>
 			if (nfs_compare_fh(&amp;m1-&gt;fh_versions[i],
 					&amp;m2-&gt;fh_versions[j]) == 0) {
 				found_fh = true;
<span class="p_chunk">@@ -1859,11 +1859,9 @@</span> <span class="p_context"> ff_layout_encode_layoutreturn(struct pnfs_layout_hdr *lo,</span>
 	start = xdr_reserve_space(xdr, 4);
 	BUG_ON(!start);
 
<span class="p_del">-	if (ff_layout_encode_ioerr(flo, xdr, args))</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_add">+	ff_layout_encode_ioerr(flo, xdr, args);</span>
 	ff_layout_encode_iostats(flo, xdr, args);
<span class="p_del">-out:</span>
<span class="p_add">+</span>
 	*start = cpu_to_be32((xdr-&gt;p - start - 1) * 4);
 	dprintk(&quot;%s: Return\n&quot;, __func__);
 }
<span class="p_header">diff --git a/fs/nfs/inode.c b/fs/nfs/inode.c</span>
<span class="p_header">index c7e8b87da5b2..3e2071a177fd 100644</span>
<span class="p_header">--- a/fs/nfs/inode.c</span>
<span class="p_header">+++ b/fs/nfs/inode.c</span>
<span class="p_chunk">@@ -1641,6 +1641,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 	unsigned long invalid = 0;
 	unsigned long now = jiffies;
 	unsigned long save_cache_validity;
<span class="p_add">+	bool cache_revalidated = true;</span>
 
 	dfprintk(VFS, &quot;NFS: %s(%s/%lu fh_crc=0x%08x ct=%d info=0x%x)\n&quot;,
 			__func__, inode-&gt;i_sb-&gt;s_id, inode-&gt;i_ino,
<span class="p_chunk">@@ -1702,22 +1703,28 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 				nfs_force_lookup_revalidate(inode);
 			inode-&gt;i_version = fattr-&gt;change_attr;
 		}
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity;
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_MTIME) {
 		memcpy(&amp;inode-&gt;i_mtime, &amp;fattr-&gt;mtime, sizeof(inode-&gt;i_mtime));
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_MTIME)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_MTIME) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_CTIME) {
 		memcpy(&amp;inode-&gt;i_ctime, &amp;fattr-&gt;ctime, sizeof(inode-&gt;i_ctime));
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_CTIME)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_CTIME) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	/* Check if our cached file size is stale */
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SIZE) {
<span class="p_chunk">@@ -1737,19 +1744,23 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 					(long long)cur_isize,
 					(long long)new_isize);
 		}
<span class="p_del">-	} else</span>
<span class="p_add">+	} else {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_PAGECACHE
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_ATIME)
 		memcpy(&amp;inode-&gt;i_atime, &amp;fattr-&gt;atime, sizeof(inode-&gt;i_atime));
<span class="p_del">-	else if (server-&gt;caps &amp; NFS_CAP_ATIME)</span>
<span class="p_add">+	else if (server-&gt;caps &amp; NFS_CAP_ATIME) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATIME
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_MODE) {
 		if ((inode-&gt;i_mode &amp; S_IALLUGO) != (fattr-&gt;mode &amp; S_IALLUGO)) {
<span class="p_chunk">@@ -1758,36 +1769,42 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 			inode-&gt;i_mode = newmode;
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_MODE)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_MODE) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_OWNER) {
 		if (!uid_eq(inode-&gt;i_uid, fattr-&gt;uid)) {
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 			inode-&gt;i_uid = fattr-&gt;uid;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_OWNER)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_OWNER) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_GROUP) {
 		if (!gid_eq(inode-&gt;i_gid, fattr-&gt;gid)) {
 			invalid |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL;
 			inode-&gt;i_gid = fattr-&gt;gid;
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_OWNER_GROUP)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_OWNER_GROUP) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_INVALID_ACCESS
 				| NFS_INO_INVALID_ACL
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_NLINK) {
 		if (inode-&gt;i_nlink != fattr-&gt;nlink) {
<span class="p_chunk">@@ -1796,19 +1813,22 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 				invalid |= NFS_INO_INVALID_DATA;
 			set_nlink(inode, fattr-&gt;nlink);
 		}
<span class="p_del">-	} else if (server-&gt;caps &amp; NFS_CAP_NLINK)</span>
<span class="p_add">+	} else if (server-&gt;caps &amp; NFS_CAP_NLINK) {</span>
 		nfsi-&gt;cache_validity |= save_cache_validity &amp;
 				(NFS_INO_INVALID_ATTR
 				| NFS_INO_REVAL_FORCED);
<span class="p_add">+		cache_revalidated = false;</span>
<span class="p_add">+	}</span>
 
 	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_SPACE_USED) {
 		/*
 		 * report the blocks in 512byte units
 		 */
 		inode-&gt;i_blocks = nfs_calc_block_size(fattr-&gt;du.nfs3.used);
<span class="p_del">- 	}</span>
<span class="p_del">-	if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_BLOCKS_USED)</span>
<span class="p_add">+	} else if (fattr-&gt;valid &amp; NFS_ATTR_FATTR_BLOCKS_USED)</span>
 		inode-&gt;i_blocks = fattr-&gt;du.nfs2.blocks;
<span class="p_add">+	else</span>
<span class="p_add">+		cache_revalidated = false;</span>
 
 	/* Update attrtimeo value if we&#39;re out of the unstable period */
 	if (invalid &amp; NFS_INO_INVALID_ATTR) {
<span class="p_chunk">@@ -1818,9 +1838,13 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 		/* Set barrier to be more recent than all outstanding updates */
 		nfsi-&gt;attr_gencount = nfs_inc_attr_generation_counter();
 	} else {
<span class="p_del">-		if (!time_in_range_open(now, nfsi-&gt;attrtimeo_timestamp, nfsi-&gt;attrtimeo_timestamp + nfsi-&gt;attrtimeo)) {</span>
<span class="p_del">-			if ((nfsi-&gt;attrtimeo &lt;&lt;= 1) &gt; NFS_MAXATTRTIMEO(inode))</span>
<span class="p_del">-				nfsi-&gt;attrtimeo = NFS_MAXATTRTIMEO(inode);</span>
<span class="p_add">+		if (cache_revalidated) {</span>
<span class="p_add">+			if (!time_in_range_open(now, nfsi-&gt;attrtimeo_timestamp,</span>
<span class="p_add">+				nfsi-&gt;attrtimeo_timestamp + nfsi-&gt;attrtimeo)) {</span>
<span class="p_add">+				nfsi-&gt;attrtimeo &lt;&lt;= 1;</span>
<span class="p_add">+				if (nfsi-&gt;attrtimeo &gt; NFS_MAXATTRTIMEO(inode))</span>
<span class="p_add">+					nfsi-&gt;attrtimeo = NFS_MAXATTRTIMEO(inode);</span>
<span class="p_add">+			}</span>
 			nfsi-&gt;attrtimeo_timestamp = now;
 		}
 		/* Set the barrier to be more recent than this fattr */
<span class="p_chunk">@@ -1829,7 +1853,7 @@</span> <span class="p_context"> static int nfs_update_inode(struct inode *inode, struct nfs_fattr *fattr)</span>
 	}
 
 	/* Don&#39;t declare attrcache up to date if there were no attrs! */
<span class="p_del">-	if (fattr-&gt;valid != 0)</span>
<span class="p_add">+	if (cache_revalidated)</span>
 		invalid &amp;= ~NFS_INO_INVALID_ATTR;
 
 	/* Don&#39;t invalidate the data if we were to blame */
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index 343b0f1f15b1..f496ed721d27 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -1385,6 +1385,7 @@</span> <span class="p_context"> static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s</span>
 	 * Protect the call to nfs4_state_set_mode_locked and
 	 * serialise the stateid update
 	 */
<span class="p_add">+	spin_lock(&amp;state-&gt;owner-&gt;so_lock);</span>
 	write_seqlock(&amp;state-&gt;seqlock);
 	if (deleg_stateid != NULL) {
 		nfs4_stateid_copy(&amp;state-&gt;stateid, deleg_stateid);
<span class="p_chunk">@@ -1393,7 +1394,6 @@</span> <span class="p_context"> static void __update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_s</span>
 	if (open_stateid != NULL)
 		nfs_set_open_stateid_locked(state, open_stateid, fmode);
 	write_sequnlock(&amp;state-&gt;seqlock);
<span class="p_del">-	spin_lock(&amp;state-&gt;owner-&gt;so_lock);</span>
 	update_open_stateflags(state, fmode);
 	spin_unlock(&amp;state-&gt;owner-&gt;so_lock);
 }
<span class="p_header">diff --git a/fs/overlayfs/copy_up.c b/fs/overlayfs/copy_up.c</span>
<span class="p_header">index 0a8983492d91..eff6319d5037 100644</span>
<span class="p_header">--- a/fs/overlayfs/copy_up.c</span>
<span class="p_header">+++ b/fs/overlayfs/copy_up.c</span>
<span class="p_chunk">@@ -22,9 +22,9 @@</span> <span class="p_context"></span>
 
 int ovl_copy_xattr(struct dentry *old, struct dentry *new)
 {
<span class="p_del">-	ssize_t list_size, size;</span>
<span class="p_del">-	char *buf, *name, *value;</span>
<span class="p_del">-	int error;</span>
<span class="p_add">+	ssize_t list_size, size, value_size = 0;</span>
<span class="p_add">+	char *buf, *name, *value = NULL;</span>
<span class="p_add">+	int uninitialized_var(error);</span>
 
 	if (!old-&gt;d_inode-&gt;i_op-&gt;getxattr ||
 	    !new-&gt;d_inode-&gt;i_op-&gt;getxattr)
<span class="p_chunk">@@ -41,29 +41,40 @@</span> <span class="p_context"> int ovl_copy_xattr(struct dentry *old, struct dentry *new)</span>
 	if (!buf)
 		return -ENOMEM;
 
<span class="p_del">-	error = -ENOMEM;</span>
<span class="p_del">-	value = kmalloc(XATTR_SIZE_MAX, GFP_KERNEL);</span>
<span class="p_del">-	if (!value)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	list_size = vfs_listxattr(old, buf, list_size);
 	if (list_size &lt;= 0) {
 		error = list_size;
<span class="p_del">-		goto out_free_value;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	for (name = buf; name &lt; (buf + list_size); name += strlen(name) + 1) {
<span class="p_del">-		size = vfs_getxattr(old, name, value, XATTR_SIZE_MAX);</span>
<span class="p_del">-		if (size &lt;= 0) {</span>
<span class="p_add">+retry:</span>
<span class="p_add">+		size = vfs_getxattr(old, name, value, value_size);</span>
<span class="p_add">+		if (size == -ERANGE)</span>
<span class="p_add">+			size = vfs_getxattr(old, name, NULL, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (size &lt; 0) {</span>
 			error = size;
<span class="p_del">-			goto out_free_value;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (size &gt; value_size) {</span>
<span class="p_add">+			void *new;</span>
<span class="p_add">+</span>
<span class="p_add">+			new = krealloc(value, size, GFP_KERNEL);</span>
<span class="p_add">+			if (!new) {</span>
<span class="p_add">+				error = -ENOMEM;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			value = new;</span>
<span class="p_add">+			value_size = size;</span>
<span class="p_add">+			goto retry;</span>
 		}
<span class="p_add">+</span>
 		error = vfs_setxattr(new, name, value, size, 0);
 		if (error)
<span class="p_del">-			goto out_free_value;</span>
<span class="p_add">+			break;</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-out_free_value:</span>
 	kfree(value);
 out:
 	kfree(buf);
<span class="p_header">diff --git a/fs/overlayfs/inode.c b/fs/overlayfs/inode.c</span>
<span class="p_header">index 4060ffde8722..b29036aa8d7c 100644</span>
<span class="p_header">--- a/fs/overlayfs/inode.c</span>
<span class="p_header">+++ b/fs/overlayfs/inode.c</span>
<span class="p_chunk">@@ -42,6 +42,19 @@</span> <span class="p_context"> int ovl_setattr(struct dentry *dentry, struct iattr *attr)</span>
 	int err;
 	struct dentry *upperdentry;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for permissions before trying to copy-up.  This is redundant</span>
<span class="p_add">+	 * since it will be rechecked later by -&gt;setattr() on upper dentry.  But</span>
<span class="p_add">+	 * without this, copy-up can be triggered by just about anybody.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We don&#39;t initialize inode-&gt;size, which just means that</span>
<span class="p_add">+	 * inode_newsize_ok() will always check against MAX_LFS_FILESIZE and not</span>
<span class="p_add">+	 * check for a swapfile (which this won&#39;t be anyway).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = inode_change_ok(dentry-&gt;d_inode, attr);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	err = ovl_want_write(dentry);
 	if (err)
 		goto out;
<span class="p_header">diff --git a/fs/overlayfs/readdir.c b/fs/overlayfs/readdir.c</span>
<span class="p_header">index 70e9af551600..adcb1398c481 100644</span>
<span class="p_header">--- a/fs/overlayfs/readdir.c</span>
<span class="p_header">+++ b/fs/overlayfs/readdir.c</span>
<span class="p_chunk">@@ -571,7 +571,8 @@</span> <span class="p_context"> void ovl_cleanup_whiteouts(struct dentry *upper, struct list_head *list)</span>
 			       (int) PTR_ERR(dentry));
 			continue;
 		}
<span class="p_del">-		ovl_cleanup(upper-&gt;d_inode, dentry);</span>
<span class="p_add">+		if (dentry-&gt;d_inode)</span>
<span class="p_add">+			ovl_cleanup(upper-&gt;d_inode, dentry);</span>
 		dput(dentry);
 	}
 	mutex_unlock(&amp;upper-&gt;d_inode-&gt;i_mutex);
<span class="p_header">diff --git a/fs/overlayfs/super.c b/fs/overlayfs/super.c</span>
<span class="p_header">index e38ee0fed24a..f42c9407fbad 100644</span>
<span class="p_header">--- a/fs/overlayfs/super.c</span>
<span class="p_header">+++ b/fs/overlayfs/super.c</span>
<span class="p_chunk">@@ -9,6 +9,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/namei.h&gt;
<span class="p_add">+#include &lt;linux/pagemap.h&gt;</span>
 #include &lt;linux/xattr.h&gt;
 #include &lt;linux/security.h&gt;
 #include &lt;linux/mount.h&gt;
<span class="p_chunk">@@ -910,6 +911,7 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 	}
 
 	sb-&gt;s_stack_depth = 0;
<span class="p_add">+	sb-&gt;s_maxbytes = MAX_LFS_FILESIZE;</span>
 	if (ufs-&gt;config.upperdir) {
 		if (!ufs-&gt;config.workdir) {
 			pr_err(&quot;overlayfs: missing &#39;workdir&#39;\n&quot;);
<span class="p_chunk">@@ -1053,6 +1055,9 @@</span> <span class="p_context"> static int ovl_fill_super(struct super_block *sb, void *data, int silent)</span>
 
 	root_dentry-&gt;d_fsdata = oe;
 
<span class="p_add">+	ovl_copyattr(ovl_dentry_real(root_dentry)-&gt;d_inode,</span>
<span class="p_add">+		     root_dentry-&gt;d_inode);</span>
<span class="p_add">+</span>
 	sb-&gt;s_magic = OVERLAYFS_SUPER_MAGIC;
 	sb-&gt;s_op = &amp;ovl_super_operations;
 	sb-&gt;s_root = root_dentry;
<span class="p_header">diff --git a/fs/proc/array.c b/fs/proc/array.c</span>
<span class="p_header">index d73291f5f0fc..b6c00ce0e29e 100644</span>
<span class="p_header">--- a/fs/proc/array.c</span>
<span class="p_header">+++ b/fs/proc/array.c</span>
<span class="p_chunk">@@ -395,7 +395,7 @@</span> <span class="p_context"> static int do_task_stat(struct seq_file *m, struct pid_namespace *ns,</span>
 
 	state = *get_task_state(task);
 	vsize = eip = esp = 0;
<span class="p_del">-	permitted = ptrace_may_access(task, PTRACE_MODE_READ | PTRACE_MODE_NOAUDIT);</span>
<span class="p_add">+	permitted = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS | PTRACE_MODE_NOAUDIT);</span>
 	mm = get_task_mm(task);
 	if (mm) {
 		vsize = task_vsize(mm);
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 4bd5d3118acd..b7de324bec11 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -403,7 +403,7 @@</span> <span class="p_context"> static const struct file_operations proc_pid_cmdline_ops = {</span>
 static int proc_pid_auxv(struct seq_file *m, struct pid_namespace *ns,
 			 struct pid *pid, struct task_struct *task)
 {
<span class="p_del">-	struct mm_struct *mm = mm_access(task, PTRACE_MODE_READ);</span>
<span class="p_add">+	struct mm_struct *mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);</span>
 	if (mm &amp;&amp; !IS_ERR(mm)) {
 		unsigned int nwords = 0;
 		do {
<span class="p_chunk">@@ -430,7 +430,8 @@</span> <span class="p_context"> static int proc_pid_wchan(struct seq_file *m, struct pid_namespace *ns,</span>
 
 	wchan = get_wchan(task);
 
<span class="p_del">-	if (wchan &amp;&amp; ptrace_may_access(task, PTRACE_MODE_READ) &amp;&amp; !lookup_symbol_name(wchan, symname))</span>
<span class="p_add">+	if (wchan &amp;&amp; ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)</span>
<span class="p_add">+			&amp;&amp; !lookup_symbol_name(wchan, symname))</span>
 		seq_printf(m, &quot;%s&quot;, symname);
 	else
 		seq_putc(m, &#39;0&#39;);
<span class="p_chunk">@@ -444,7 +445,7 @@</span> <span class="p_context"> static int lock_trace(struct task_struct *task)</span>
 	int err = mutex_lock_killable(&amp;task-&gt;signal-&gt;cred_guard_mutex);
 	if (err)
 		return err;
<span class="p_del">-	if (!ptrace_may_access(task, PTRACE_MODE_ATTACH)) {</span>
<span class="p_add">+	if (!ptrace_may_access(task, PTRACE_MODE_ATTACH_FSCREDS)) {</span>
 		mutex_unlock(&amp;task-&gt;signal-&gt;cred_guard_mutex);
 		return -EPERM;
 	}
<span class="p_chunk">@@ -697,7 +698,7 @@</span> <span class="p_context"> static int proc_fd_access_allowed(struct inode *inode)</span>
 	 */
 	task = get_proc_task(inode);
 	if (task) {
<span class="p_del">-		allowed = ptrace_may_access(task, PTRACE_MODE_READ);</span>
<span class="p_add">+		allowed = ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);</span>
 		put_task_struct(task);
 	}
 	return allowed;
<span class="p_chunk">@@ -732,7 +733,7 @@</span> <span class="p_context"> static bool has_pid_permissions(struct pid_namespace *pid,</span>
 		return true;
 	if (in_group_p(pid-&gt;pid_gid))
 		return true;
<span class="p_del">-	return ptrace_may_access(task, PTRACE_MODE_READ);</span>
<span class="p_add">+	return ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS);</span>
 }
 
 
<span class="p_chunk">@@ -809,7 +810,7 @@</span> <span class="p_context"> struct mm_struct *proc_mem_open(struct inode *inode, unsigned int mode)</span>
 	struct mm_struct *mm = ERR_PTR(-ESRCH);
 
 	if (task) {
<span class="p_del">-		mm = mm_access(task, mode);</span>
<span class="p_add">+		mm = mm_access(task, mode | PTRACE_MODE_FSCREDS);</span>
 		put_task_struct(task);
 
 		if (!IS_ERR_OR_NULL(mm)) {
<span class="p_chunk">@@ -1856,7 +1857,7 @@</span> <span class="p_context"> static int map_files_d_revalidate(struct dentry *dentry, unsigned int flags)</span>
 	if (!task)
 		goto out_notask;
 
<span class="p_del">-	mm = mm_access(task, PTRACE_MODE_READ);</span>
<span class="p_add">+	mm = mm_access(task, PTRACE_MODE_READ_FSCREDS);</span>
 	if (IS_ERR_OR_NULL(mm))
 		goto out;
 
<span class="p_chunk">@@ -2007,7 +2008,7 @@</span> <span class="p_context"> static struct dentry *proc_map_files_lookup(struct inode *dir,</span>
 		goto out;
 
 	result = -EACCES;
<span class="p_del">-	if (!ptrace_may_access(task, PTRACE_MODE_READ))</span>
<span class="p_add">+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))</span>
 		goto out_put_task;
 
 	result = -ENOENT;
<span class="p_chunk">@@ -2060,7 +2061,7 @@</span> <span class="p_context"> proc_map_files_readdir(struct file *file, struct dir_context *ctx)</span>
 		goto out;
 
 	ret = -EACCES;
<span class="p_del">-	if (!ptrace_may_access(task, PTRACE_MODE_READ))</span>
<span class="p_add">+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS))</span>
 		goto out_put_task;
 
 	ret = 0;
<span class="p_chunk">@@ -2530,7 +2531,7 @@</span> <span class="p_context"> static int do_io_accounting(struct task_struct *task, struct seq_file *m, int wh</span>
 	if (result)
 		return result;
 
<span class="p_del">-	if (!ptrace_may_access(task, PTRACE_MODE_READ)) {</span>
<span class="p_add">+	if (!ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {</span>
 		result = -EACCES;
 		goto out_unlock;
 	}
<span class="p_header">diff --git a/fs/proc/namespaces.c b/fs/proc/namespaces.c</span>
<span class="p_header">index f6e8354b8cea..1b0ea4a5d89e 100644</span>
<span class="p_header">--- a/fs/proc/namespaces.c</span>
<span class="p_header">+++ b/fs/proc/namespaces.c</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> static const char *proc_ns_follow_link(struct dentry *dentry, void **cookie)</span>
 	if (!task)
 		return error;
 
<span class="p_del">-	if (ptrace_may_access(task, PTRACE_MODE_READ)) {</span>
<span class="p_add">+	if (ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {</span>
 		error = ns_get_path(&amp;ns_path, task, ns_ops);
 		if (!error)
 			nd_jump_link(&amp;ns_path);
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static int proc_ns_readlink(struct dentry *dentry, char __user *buffer, int bufl</span>
 	if (!task)
 		return res;
 
<span class="p_del">-	if (ptrace_may_access(task, PTRACE_MODE_READ)) {</span>
<span class="p_add">+	if (ptrace_may_access(task, PTRACE_MODE_READ_FSCREDS)) {</span>
 		res = ns_get_name(name, sizeof(name), task, ns_ops);
 		if (res &gt;= 0)
 			res = readlink_copy(buffer, buflen, name);
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index 187b3b5f242e..09cd3edde08a 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -1473,18 +1473,19 @@</span> <span class="p_context"> static int gather_pte_stats(pmd_t *pmd, unsigned long addr,</span>
 static int gather_hugetlb_stats(pte_t *pte, unsigned long hmask,
 		unsigned long addr, unsigned long end, struct mm_walk *walk)
 {
<span class="p_add">+	pte_t huge_pte = huge_ptep_get(pte);</span>
 	struct numa_maps *md;
 	struct page *page;
 
<span class="p_del">-	if (!pte_present(*pte))</span>
<span class="p_add">+	if (!pte_present(huge_pte))</span>
 		return 0;
 
<span class="p_del">-	page = pte_page(*pte);</span>
<span class="p_add">+	page = pte_page(huge_pte);</span>
 	if (!page)
 		return 0;
 
 	md = walk-&gt;private;
<span class="p_del">-	gather_stats(page, md, pte_dirty(*pte), 1);</span>
<span class="p_add">+	gather_stats(page, md, pte_dirty(huge_pte), 1);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/timerfd.c b/fs/timerfd.c</span>
<span class="p_header">index b94fa6c3c6eb..053818dd6c18 100644</span>
<span class="p_header">--- a/fs/timerfd.c</span>
<span class="p_header">+++ b/fs/timerfd.c</span>
<span class="p_chunk">@@ -153,7 +153,7 @@</span> <span class="p_context"> static ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)</span>
 	if (isalarm(ctx))
 		remaining = alarm_expires_remaining(&amp;ctx-&gt;t.alarm);
 	else
<span class="p_del">-		remaining = hrtimer_expires_remaining(&amp;ctx-&gt;t.tmr);</span>
<span class="p_add">+		remaining = hrtimer_expires_remaining_adjusted(&amp;ctx-&gt;t.tmr);</span>
 
 	return remaining.tv64 &lt; 0 ? ktime_set(0, 0): remaining;
 }
<span class="p_header">diff --git a/fs/udf/inode.c b/fs/udf/inode.c</span>
<span class="p_header">index 8d0b3ade0ff0..566df9b5a6cb 100644</span>
<span class="p_header">--- a/fs/udf/inode.c</span>
<span class="p_header">+++ b/fs/udf/inode.c</span>
<span class="p_chunk">@@ -2047,14 +2047,29 @@</span> <span class="p_context"> void udf_write_aext(struct inode *inode, struct extent_position *epos,</span>
 		epos-&gt;offset += adsize;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Only 1 indirect extent in a row really makes sense but allow upto 16 in case</span>
<span class="p_add">+ * someone does some weird stuff.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define UDF_MAX_INDIR_EXTS 16</span>
<span class="p_add">+</span>
 int8_t udf_next_aext(struct inode *inode, struct extent_position *epos,
 		     struct kernel_lb_addr *eloc, uint32_t *elen, int inc)
 {
 	int8_t etype;
<span class="p_add">+	unsigned int indirections = 0;</span>
 
 	while ((etype = udf_current_aext(inode, epos, eloc, elen, inc)) ==
 	       (EXT_NEXT_EXTENT_ALLOCDECS &gt;&gt; 30)) {
 		int block;
<span class="p_add">+</span>
<span class="p_add">+		if (++indirections &gt; UDF_MAX_INDIR_EXTS) {</span>
<span class="p_add">+			udf_err(inode-&gt;i_sb,</span>
<span class="p_add">+				&quot;too many indirect extents in inode %lu\n&quot;,</span>
<span class="p_add">+				inode-&gt;i_ino);</span>
<span class="p_add">+			return -1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		epos-&gt;block = *eloc;
 		epos-&gt;offset = sizeof(struct allocExtDesc);
 		brelse(epos-&gt;bh);
<span class="p_header">diff --git a/fs/udf/unicode.c b/fs/udf/unicode.c</span>
<span class="p_header">index ab478e62baae..e788a05aab83 100644</span>
<span class="p_header">--- a/fs/udf/unicode.c</span>
<span class="p_header">+++ b/fs/udf/unicode.c</span>
<span class="p_chunk">@@ -128,11 +128,15 @@</span> <span class="p_context"> int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)</span>
 		if (c &lt; 0x80U)
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] = (uint8_t)c;
 		else if (c &lt; 0x800U) {
<span class="p_add">+			if (utf_o-&gt;u_len &gt; (UDF_NAME_LEN - 4))</span>
<span class="p_add">+				break;</span>
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0xc0 | (c &gt;&gt; 6));
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0x80 | (c &amp; 0x3f));
 		} else {
<span class="p_add">+			if (utf_o-&gt;u_len &gt; (UDF_NAME_LEN - 5))</span>
<span class="p_add">+				break;</span>
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
 						(uint8_t)(0xe0 | (c &gt;&gt; 12));
 			utf_o-&gt;u_name[utf_o-&gt;u_len++] =
<span class="p_chunk">@@ -173,17 +177,22 @@</span> <span class="p_context"> int udf_CS0toUTF8(struct ustr *utf_o, const struct ustr *ocu_i)</span>
 static int udf_UTF8toCS0(dstring *ocu, struct ustr *utf, int length)
 {
 	unsigned c, i, max_val, utf_char;
<span class="p_del">-	int utf_cnt, u_len;</span>
<span class="p_add">+	int utf_cnt, u_len, u_ch;</span>
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
<span class="p_add">+	u_ch = 1;</span>
 
 try_again:
 	u_len = 0U;
 	utf_char = 0U;
 	utf_cnt = 0U;
 	for (i = 0U; i &lt; utf-&gt;u_len; i++) {
<span class="p_add">+		/* Name didn&#39;t fit? */</span>
<span class="p_add">+		if (u_len + 1 + u_ch &gt;= length)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
 		c = (uint8_t)utf-&gt;u_name[i];
 
 		/* Complete a multi-byte UTF-8 character */
<span class="p_chunk">@@ -225,6 +234,7 @@</span> <span class="p_context"> try_again:</span>
 			if (max_val == 0xffU) {
 				max_val = 0xffffU;
 				ocu[0] = (uint8_t)0x10U;
<span class="p_add">+				u_ch = 2;</span>
 				goto try_again;
 			}
 			goto error_out;
<span class="p_chunk">@@ -277,7 +287,7 @@</span> <span class="p_context"> static int udf_CS0toNLS(struct nls_table *nls, struct ustr *utf_o,</span>
 			c = (c &lt;&lt; 8) | ocu[i++];
 
 		len = nls-&gt;uni2char(c, &amp;utf_o-&gt;u_name[utf_o-&gt;u_len],
<span class="p_del">-				    UDF_NAME_LEN - utf_o-&gt;u_len);</span>
<span class="p_add">+				    UDF_NAME_LEN - 2 - utf_o-&gt;u_len);</span>
 		/* Valid character? */
 		if (len &gt;= 0)
 			utf_o-&gt;u_len += len;
<span class="p_chunk">@@ -295,15 +305,19 @@</span> <span class="p_context"> static int udf_NLStoCS0(struct nls_table *nls, dstring *ocu, struct ustr *uni,</span>
 	int len;
 	unsigned i, max_val;
 	uint16_t uni_char;
<span class="p_del">-	int u_len;</span>
<span class="p_add">+	int u_len, u_ch;</span>
 
 	memset(ocu, 0, sizeof(dstring) * length);
 	ocu[0] = 8;
 	max_val = 0xffU;
<span class="p_add">+	u_ch = 1;</span>
 
 try_again:
 	u_len = 0U;
 	for (i = 0U; i &lt; uni-&gt;u_len; i++) {
<span class="p_add">+		/* Name didn&#39;t fit? */</span>
<span class="p_add">+		if (u_len + 1 + u_ch &gt;= length)</span>
<span class="p_add">+			return 0;</span>
 		len = nls-&gt;char2uni(&amp;uni-&gt;u_name[i], uni-&gt;u_len - i, &amp;uni_char);
 		if (!len)
 			continue;
<span class="p_chunk">@@ -316,6 +330,7 @@</span> <span class="p_context"> try_again:</span>
 		if (uni_char &gt; max_val) {
 			max_val = 0xffffU;
 			ocu[0] = (uint8_t)0x10U;
<span class="p_add">+			u_ch = 2;</span>
 			goto try_again;
 		}
 
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_format.h b/fs/xfs/libxfs/xfs_format.h</span>
<span class="p_header">index 8774498ce0ff..e2536bb1c760 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_format.h</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_format.h</span>
<span class="p_chunk">@@ -786,7 +786,7 @@</span> <span class="p_context"> typedef struct xfs_agfl {</span>
 	__be64		agfl_lsn;
 	__be32		agfl_crc;
 	__be32		agfl_bno[];	/* actually XFS_AGFL_SIZE(mp) */
<span class="p_del">-} xfs_agfl_t;</span>
<span class="p_add">+} __attribute__((packed)) xfs_agfl_t;</span>
 
 #define XFS_AGFL_CRC_OFF	offsetof(struct xfs_agfl, agfl_crc)
 
<span class="p_header">diff --git a/fs/xfs/libxfs/xfs_inode_buf.c b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">index 268c00f4f83a..65485cfc4ade 100644</span>
<span class="p_header">--- a/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_header">+++ b/fs/xfs/libxfs/xfs_inode_buf.c</span>
<span class="p_chunk">@@ -62,11 +62,12 @@</span> <span class="p_context"> xfs_inobp_check(</span>
  * has not had the inode cores stamped into it. Hence for readahead, the buffer
  * may be potentially invalid.
  *
<span class="p_del">- * If the readahead buffer is invalid, we don&#39;t want to mark it with an error,</span>
<span class="p_del">- * but we do want to clear the DONE status of the buffer so that a followup read</span>
<span class="p_del">- * will re-read it from disk. This will ensure that we don&#39;t get an unnecessary</span>
<span class="p_del">- * warnings during log recovery and we don&#39;t get unnecssary panics on debug</span>
<span class="p_del">- * kernels.</span>
<span class="p_add">+ * If the readahead buffer is invalid, we need to mark it with an error and</span>
<span class="p_add">+ * clear the DONE status of the buffer so that a followup read will re-read it</span>
<span class="p_add">+ * from disk. We don&#39;t report the error otherwise to avoid warnings during log</span>
<span class="p_add">+ * recovery and we don&#39;t get unnecssary panics on debug kernels. We use EIO here</span>
<span class="p_add">+ * because all we want to do is say readahead failed; there is no-one to report</span>
<span class="p_add">+ * the error to, so this will distinguish it from a non-ra verifier failure.</span>
  */
 static void
 xfs_inode_buf_verify(
<span class="p_chunk">@@ -93,6 +94,7 @@</span> <span class="p_context"> xfs_inode_buf_verify(</span>
 						XFS_RANDOM_ITOBP_INOTOBP))) {
 			if (readahead) {
 				bp-&gt;b_flags &amp;= ~XBF_DONE;
<span class="p_add">+				xfs_buf_ioerror(bp, -EIO);</span>
 				return;
 			}
 
<span class="p_header">diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c</span>
<span class="p_header">index 3243cdf97f33..39090fc56f09 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_buf.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_buf.c</span>
<span class="p_chunk">@@ -604,6 +604,13 @@</span> <span class="p_context"> found:</span>
 		}
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Clear b_error if this is a lookup from a caller that doesn&#39;t expect</span>
<span class="p_add">+	 * valid data to be found in the buffer.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(flags &amp; XBF_READ))</span>
<span class="p_add">+		xfs_buf_ioerror(bp, 0);</span>
<span class="p_add">+</span>
 	XFS_STATS_INC(target-&gt;bt_mount, xb_get);
 	trace_xfs_buf_get(bp, flags, _RET_IP_);
 	return bp;
<span class="p_chunk">@@ -1520,6 +1527,16 @@</span> <span class="p_context"> xfs_wait_buftarg(</span>
 	LIST_HEAD(dispose);
 	int loop = 0;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to flush the buffer workqueue to ensure that all IO</span>
<span class="p_add">+	 * completion processing is 100% done. Just waiting on buffer locks is</span>
<span class="p_add">+	 * not sufficient for async IO as the reference count held over IO is</span>
<span class="p_add">+	 * not released until after the buffer lock is dropped. Hence we need to</span>
<span class="p_add">+	 * ensure here that all reference counts have been dropped before we</span>
<span class="p_add">+	 * start walking the LRU list.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	drain_workqueue(btp-&gt;bt_mount-&gt;m_buf_workqueue);</span>
<span class="p_add">+</span>
 	/* loop until there is nothing left on the lru list. */
 	while (list_lru_count(&amp;btp-&gt;bt_lru)) {
 		list_lru_walk(&amp;btp-&gt;bt_lru, xfs_buftarg_wait_rele,
<span class="p_header">diff --git a/fs/xfs/xfs_trans_ail.c b/fs/xfs/xfs_trans_ail.c</span>
<span class="p_header">index aa67339b9537..4f18fd92ca13 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_trans_ail.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_trans_ail.c</span>
<span class="p_chunk">@@ -497,7 +497,6 @@</span> <span class="p_context"> xfsaild(</span>
 	long		tout = 0;	/* milliseconds */
 
 	current-&gt;flags |= PF_MEMALLOC;
<span class="p_del">-	set_freezable();</span>
 
 	while (!kthread_should_stop()) {
 		if (tout &amp;&amp; tout &lt;= 20)
<span class="p_header">diff --git a/include/linux/compiler.h b/include/linux/compiler.h</span>
<span class="p_header">index 4dac1036594f..6fc9a6dd5ed2 100644</span>
<span class="p_header">--- a/include/linux/compiler.h</span>
<span class="p_header">+++ b/include/linux/compiler.h</span>
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);</span>
  */
 #define if(cond, ...) __trace_if( (cond , ## __VA_ARGS__) )
 #define __trace_if(cond) \
<span class="p_del">-	if (__builtin_constant_p((cond)) ? !!(cond) :			\</span>
<span class="p_add">+	if (__builtin_constant_p(!!(cond)) ? !!(cond) :			\</span>
 	({								\
 		int ______r;						\
 		static struct ftrace_branch_data			\
<span class="p_header">diff --git a/include/linux/devpts_fs.h b/include/linux/devpts_fs.h</span>
<span class="p_header">index 251a2090a554..e0ee0b3000b2 100644</span>
<span class="p_header">--- a/include/linux/devpts_fs.h</span>
<span class="p_header">+++ b/include/linux/devpts_fs.h</span>
<span class="p_chunk">@@ -19,6 +19,8 @@</span> <span class="p_context"></span>
 
 int devpts_new_index(struct inode *ptmx_inode);
 void devpts_kill_index(struct inode *ptmx_inode, int idx);
<span class="p_add">+void devpts_add_ref(struct inode *ptmx_inode);</span>
<span class="p_add">+void devpts_del_ref(struct inode *ptmx_inode);</span>
 /* mknod in devpts */
 struct inode *devpts_pty_new(struct inode *ptmx_inode, dev_t device, int index,
 		void *priv);
<span class="p_chunk">@@ -32,6 +34,8 @@</span> <span class="p_context"> void devpts_pty_kill(struct inode *inode);</span>
 /* Dummy stubs in the no-pty case */
 static inline int devpts_new_index(struct inode *ptmx_inode) { return -EINVAL; }
 static inline void devpts_kill_index(struct inode *ptmx_inode, int idx) { }
<span class="p_add">+static inline void devpts_add_ref(struct inode *ptmx_inode) { }</span>
<span class="p_add">+static inline void devpts_del_ref(struct inode *ptmx_inode) { }</span>
 static inline struct inode *devpts_pty_new(struct inode *ptmx_inode,
 		dev_t device, int index, void *priv)
 {
<span class="p_header">diff --git a/include/linux/intel-iommu.h b/include/linux/intel-iommu.h</span>
<span class="p_header">index 821273ca4873..2d9b650047a5 100644</span>
<span class="p_header">--- a/include/linux/intel-iommu.h</span>
<span class="p_header">+++ b/include/linux/intel-iommu.h</span>
<span class="p_chunk">@@ -235,6 +235,9 @@</span> <span class="p_context"> static inline void dmar_writeq(void __iomem *addr, u64 val)</span>
 /* low 64 bit */
 #define dma_frcd_page_addr(d) (d &amp; (((u64)-1) &lt;&lt; PAGE_SHIFT))
 
<span class="p_add">+/* PRS_REG */</span>
<span class="p_add">+#define DMA_PRS_PPR	((u32)1)</span>
<span class="p_add">+</span>
 #define IOMMU_WAIT_OP(iommu, offset, op, cond, sts)			\
 do {									\
 	cycles_t start_time = get_cycles();				\
<span class="p_header">diff --git a/include/linux/ptrace.h b/include/linux/ptrace.h</span>
<span class="p_header">index 061265f92876..504c98a278d4 100644</span>
<span class="p_header">--- a/include/linux/ptrace.h</span>
<span class="p_header">+++ b/include/linux/ptrace.h</span>
<span class="p_chunk">@@ -57,7 +57,29 @@</span> <span class="p_context"> extern void exit_ptrace(struct task_struct *tracer, struct list_head *dead);</span>
 #define PTRACE_MODE_READ	0x01
 #define PTRACE_MODE_ATTACH	0x02
 #define PTRACE_MODE_NOAUDIT	0x04
<span class="p_del">-/* Returns true on success, false on denial. */</span>
<span class="p_add">+#define PTRACE_MODE_FSCREDS 0x08</span>
<span class="p_add">+#define PTRACE_MODE_REALCREDS 0x10</span>
<span class="p_add">+</span>
<span class="p_add">+/* shorthands for READ/ATTACH and FSCREDS/REALCREDS combinations */</span>
<span class="p_add">+#define PTRACE_MODE_READ_FSCREDS (PTRACE_MODE_READ | PTRACE_MODE_FSCREDS)</span>
<span class="p_add">+#define PTRACE_MODE_READ_REALCREDS (PTRACE_MODE_READ | PTRACE_MODE_REALCREDS)</span>
<span class="p_add">+#define PTRACE_MODE_ATTACH_FSCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS)</span>
<span class="p_add">+#define PTRACE_MODE_ATTACH_REALCREDS (PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS)</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * ptrace_may_access - check whether the caller is permitted to access</span>
<span class="p_add">+ * a target task.</span>
<span class="p_add">+ * @task: target task</span>
<span class="p_add">+ * @mode: selects type of access and caller credentials</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns true on success, false on denial.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * One of the flags PTRACE_MODE_FSCREDS and PTRACE_MODE_REALCREDS must</span>
<span class="p_add">+ * be set in @mode to specify whether the access was requested through</span>
<span class="p_add">+ * a filesystem syscall (should use effective capabilities and fsuid</span>
<span class="p_add">+ * of the caller) or through an explicit syscall such as</span>
<span class="p_add">+ * process_vm_writev or ptrace (and should use the real credentials).</span>
<span class="p_add">+ */</span>
 extern bool ptrace_may_access(struct task_struct *task, unsigned int mode);
 
 static inline int ptrace_reparented(struct task_struct *child)
<span class="p_header">diff --git a/include/linux/radix-tree.h b/include/linux/radix-tree.h</span>
<span class="p_header">index 33170dbd9db4..5d5174b59802 100644</span>
<span class="p_header">--- a/include/linux/radix-tree.h</span>
<span class="p_header">+++ b/include/linux/radix-tree.h</span>
<span class="p_chunk">@@ -370,12 +370,28 @@</span> <span class="p_context"> void **radix_tree_next_chunk(struct radix_tree_root *root,</span>
 			     struct radix_tree_iter *iter, unsigned flags);
 
 /**
<span class="p_add">+ * radix_tree_iter_retry - retry this chunk of the iteration</span>
<span class="p_add">+ * @iter:	iterator state</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If we iterate over a tree protected only by the RCU lock, a race</span>
<span class="p_add">+ * against deletion or creation may result in seeing a slot for which</span>
<span class="p_add">+ * radix_tree_deref_retry() returns true.  If so, call this function</span>
<span class="p_add">+ * and continue the iteration.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline __must_check</span>
<span class="p_add">+void **radix_tree_iter_retry(struct radix_tree_iter *iter)</span>
<span class="p_add">+{</span>
<span class="p_add">+	iter-&gt;next_index = iter-&gt;index;</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * radix_tree_chunk_size - get current chunk size
  *
  * @iter:	pointer to radix tree iterator
  * Returns:	current chunk size
  */
<span class="p_del">-static __always_inline unsigned</span>
<span class="p_add">+static __always_inline long</span>
 radix_tree_chunk_size(struct radix_tree_iter *iter)
 {
 	return iter-&gt;next_index - iter-&gt;index;
<span class="p_chunk">@@ -409,9 +425,9 @@</span> <span class="p_context"> radix_tree_next_slot(void **slot, struct radix_tree_iter *iter, unsigned flags)</span>
 			return slot + offset + 1;
 		}
 	} else {
<span class="p_del">-		unsigned size = radix_tree_chunk_size(iter) - 1;</span>
<span class="p_add">+		long size = radix_tree_chunk_size(iter);</span>
 
<span class="p_del">-		while (size--) {</span>
<span class="p_add">+		while (--size &gt; 0) {</span>
 			slot++;
 			iter-&gt;index++;
 			if (likely(*slot))
<span class="p_header">diff --git a/include/linux/rmap.h b/include/linux/rmap.h</span>
<span class="p_header">index 29446aeef36e..ddda2ac3446e 100644</span>
<span class="p_header">--- a/include/linux/rmap.h</span>
<span class="p_header">+++ b/include/linux/rmap.h</span>
<span class="p_chunk">@@ -108,20 +108,6 @@</span> <span class="p_context"> static inline void put_anon_vma(struct anon_vma *anon_vma)</span>
 		__put_anon_vma(anon_vma);
 }
 
<span class="p_del">-static inline void vma_lock_anon_vma(struct vm_area_struct *vma)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct anon_vma *anon_vma = vma-&gt;anon_vma;</span>
<span class="p_del">-	if (anon_vma)</span>
<span class="p_del">-		down_write(&amp;anon_vma-&gt;root-&gt;rwsem);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void vma_unlock_anon_vma(struct vm_area_struct *vma)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct anon_vma *anon_vma = vma-&gt;anon_vma;</span>
<span class="p_del">-	if (anon_vma)</span>
<span class="p_del">-		up_write(&amp;anon_vma-&gt;root-&gt;rwsem);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void anon_vma_lock_write(struct anon_vma *anon_vma)
 {
 	down_write(&amp;anon_vma-&gt;root-&gt;rwsem);
<span class="p_header">diff --git a/include/linux/tracepoint.h b/include/linux/tracepoint.h</span>
<span class="p_header">index 696a339c592c..03c7efb60c91 100644</span>
<span class="p_header">--- a/include/linux/tracepoint.h</span>
<span class="p_header">+++ b/include/linux/tracepoint.h</span>
<span class="p_chunk">@@ -14,8 +14,10 @@</span> <span class="p_context"></span>
  * See the file COPYING for more details.
  */
 
<span class="p_add">+#include &lt;linux/smp.h&gt;</span>
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/types.h&gt;
<span class="p_add">+#include &lt;linux/cpumask.h&gt;</span>
 #include &lt;linux/rcupdate.h&gt;
 #include &lt;linux/static_key.h&gt;
 
<span class="p_chunk">@@ -146,6 +148,9 @@</span> <span class="p_context"> extern void syscall_unregfunc(void);</span>
 		void *it_func;						\
 		void *__data;						\
 									\
<span class="p_add">+		if (!cpu_online(raw_smp_processor_id()))		\</span>
<span class="p_add">+			return;						\</span>
<span class="p_add">+									\</span>
 		if (!(cond))						\
 			return;						\
 		prercu;							\
<span class="p_header">diff --git a/ipc/shm.c b/ipc/shm.c</span>
<span class="p_header">index 41787276e141..3174634ca4e5 100644</span>
<span class="p_header">--- a/ipc/shm.c</span>
<span class="p_header">+++ b/ipc/shm.c</span>
<span class="p_chunk">@@ -156,11 +156,12 @@</span> <span class="p_context"> static inline struct shmid_kernel *shm_lock(struct ipc_namespace *ns, int id)</span>
 	struct kern_ipc_perm *ipcp = ipc_lock(&amp;shm_ids(ns), id);
 
 	/*
<span class="p_del">-	 * We raced in the idr lookup or with shm_destroy().  Either way, the</span>
<span class="p_del">-	 * ID is busted.</span>
<span class="p_add">+	 * Callers of shm_lock() must validate the status of the returned ipc</span>
<span class="p_add">+	 * object pointer (as returned by ipc_lock()), and error out as</span>
<span class="p_add">+	 * appropriate.</span>
 	 */
<span class="p_del">-	WARN_ON(IS_ERR(ipcp));</span>
<span class="p_del">-</span>
<span class="p_add">+	if (IS_ERR(ipcp))</span>
<span class="p_add">+		return (void *)ipcp;</span>
 	return container_of(ipcp, struct shmid_kernel, shm_perm);
 }
 
<span class="p_chunk">@@ -186,18 +187,33 @@</span> <span class="p_context"> static inline void shm_rmid(struct ipc_namespace *ns, struct shmid_kernel *s)</span>
 }
 
 
<span class="p_del">-/* This is called by fork, once for every shm attach. */</span>
<span class="p_del">-static void shm_open(struct vm_area_struct *vma)</span>
<span class="p_add">+static int __shm_open(struct vm_area_struct *vma)</span>
 {
 	struct file *file = vma-&gt;vm_file;
 	struct shm_file_data *sfd = shm_file_data(file);
 	struct shmid_kernel *shp;
 
 	shp = shm_lock(sfd-&gt;ns, sfd-&gt;id);
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ERR(shp))</span>
<span class="p_add">+		return PTR_ERR(shp);</span>
<span class="p_add">+</span>
 	shp-&gt;shm_atim = get_seconds();
 	shp-&gt;shm_lprid = task_tgid_vnr(current);
 	shp-&gt;shm_nattch++;
 	shm_unlock(shp);
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* This is called by fork, once for every shm attach. */</span>
<span class="p_add">+static void shm_open(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err = __shm_open(vma);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We raced in the idr lookup or with shm_destroy().</span>
<span class="p_add">+	 * Either way, the ID is busted.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WARN_ON_ONCE(err);</span>
 }
 
 /*
<span class="p_chunk">@@ -260,6 +276,14 @@</span> <span class="p_context"> static void shm_close(struct vm_area_struct *vma)</span>
 	down_write(&amp;shm_ids(ns).rwsem);
 	/* remove from the list of attaches of the shm segment */
 	shp = shm_lock(ns, sfd-&gt;id);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We raced in the idr lookup or with shm_destroy().</span>
<span class="p_add">+	 * Either way, the ID is busted.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (WARN_ON_ONCE(IS_ERR(shp)))</span>
<span class="p_add">+		goto done; /* no-op */</span>
<span class="p_add">+</span>
 	shp-&gt;shm_lprid = task_tgid_vnr(current);
 	shp-&gt;shm_dtim = get_seconds();
 	shp-&gt;shm_nattch--;
<span class="p_chunk">@@ -267,6 +291,7 @@</span> <span class="p_context"> static void shm_close(struct vm_area_struct *vma)</span>
 		shm_destroy(ns, shp);
 	else
 		shm_unlock(shp);
<span class="p_add">+done:</span>
 	up_write(&amp;shm_ids(ns).rwsem);
 }
 
<span class="p_chunk">@@ -388,17 +413,25 @@</span> <span class="p_context"> static int shm_mmap(struct file *file, struct vm_area_struct *vma)</span>
 	struct shm_file_data *sfd = shm_file_data(file);
 	int ret;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case of remap_file_pages() emulation, the file can represent</span>
<span class="p_add">+	 * removed IPC ID: propogate shm_lock() error to caller.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret =__shm_open(vma);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	ret = sfd-&gt;file-&gt;f_op-&gt;mmap(sfd-&gt;file, vma);
<span class="p_del">-	if (ret != 0)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		shm_close(vma);</span>
 		return ret;
<span class="p_add">+	}</span>
 	sfd-&gt;vm_ops = vma-&gt;vm_ops;
 #ifdef CONFIG_MMU
 	WARN_ON(!sfd-&gt;vm_ops-&gt;fault);
 #endif
 	vma-&gt;vm_ops = &amp;shm_vm_ops;
<span class="p_del">-	shm_open(vma);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int shm_release(struct inode *ino, struct file *file)
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index cfc227ccfceb..1087bbeb152b 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3434,7 +3434,7 @@</span> <span class="p_context"> find_lively_task_by_vpid(pid_t vpid)</span>
 
 	/* Reuse ptrace permission checks for now. */
 	err = -EACCES;
<span class="p_del">-	if (!ptrace_may_access(task, PTRACE_MODE_READ))</span>
<span class="p_add">+	if (!ptrace_may_access(task, PTRACE_MODE_READ_REALCREDS))</span>
 		goto errout;
 
 	return task;
<span class="p_header">diff --git a/kernel/futex.c b/kernel/futex.c</span>
<span class="p_header">index 684d7549825a..461c72b2dac2 100644</span>
<span class="p_header">--- a/kernel/futex.c</span>
<span class="p_header">+++ b/kernel/futex.c</span>
<span class="p_chunk">@@ -2755,6 +2755,11 @@</span> <span class="p_context"> static int futex_wait_requeue_pi(u32 __user *uaddr, unsigned int flags,</span>
 		if (q.pi_state &amp;&amp; (q.pi_state-&gt;owner != current)) {
 			spin_lock(q.lock_ptr);
 			ret = fixup_pi_state_owner(uaddr2, &amp;q, current);
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Drop the reference to the pi state which</span>
<span class="p_add">+			 * the requeue_pi() code acquired for us.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			free_pi_state(q.pi_state);</span>
 			spin_unlock(q.lock_ptr);
 		}
 	} else {
<span class="p_chunk">@@ -2881,7 +2886,7 @@</span> <span class="p_context"> SYSCALL_DEFINE3(get_robust_list, int, pid,</span>
 	}
 
 	ret = -EPERM;
<span class="p_del">-	if (!ptrace_may_access(p, PTRACE_MODE_READ))</span>
<span class="p_add">+	if (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))</span>
 		goto err_unlock;
 
 	head = p-&gt;robust_list;
<span class="p_header">diff --git a/kernel/futex_compat.c b/kernel/futex_compat.c</span>
<span class="p_header">index 55c8c9349cfe..4ae3232e7a28 100644</span>
<span class="p_header">--- a/kernel/futex_compat.c</span>
<span class="p_header">+++ b/kernel/futex_compat.c</span>
<span class="p_chunk">@@ -155,7 +155,7 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE3(get_robust_list, int, pid,</span>
 	}
 
 	ret = -EPERM;
<span class="p_del">-	if (!ptrace_may_access(p, PTRACE_MODE_READ))</span>
<span class="p_add">+	if (!ptrace_may_access(p, PTRACE_MODE_READ_REALCREDS))</span>
 		goto err_unlock;
 
 	head = p-&gt;compat_robust_list;
<span class="p_header">diff --git a/kernel/kcmp.c b/kernel/kcmp.c</span>
<span class="p_header">index 0aa69ea1d8fd..3a47fa998fe0 100644</span>
<span class="p_header">--- a/kernel/kcmp.c</span>
<span class="p_header">+++ b/kernel/kcmp.c</span>
<span class="p_chunk">@@ -122,8 +122,8 @@</span> <span class="p_context"> SYSCALL_DEFINE5(kcmp, pid_t, pid1, pid_t, pid2, int, type,</span>
 			&amp;task2-&gt;signal-&gt;cred_guard_mutex);
 	if (ret)
 		goto err;
<span class="p_del">-	if (!ptrace_may_access(task1, PTRACE_MODE_READ) ||</span>
<span class="p_del">-	    !ptrace_may_access(task2, PTRACE_MODE_READ)) {</span>
<span class="p_add">+	if (!ptrace_may_access(task1, PTRACE_MODE_READ_REALCREDS) ||</span>
<span class="p_add">+	    !ptrace_may_access(task2, PTRACE_MODE_READ_REALCREDS)) {</span>
 		ret = -EPERM;
 		goto err_unlock;
 	}
<span class="p_header">diff --git a/kernel/memremap.c b/kernel/memremap.c</span>
<span class="p_header">index 7658d32c5c78..7a4e473cea4d 100644</span>
<span class="p_header">--- a/kernel/memremap.c</span>
<span class="p_header">+++ b/kernel/memremap.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(memunmap);</span>
 
 static void devm_memremap_release(struct device *dev, void *res)
 {
<span class="p_del">-	memunmap(res);</span>
<span class="p_add">+	memunmap(*(void **)res);</span>
 }
 
 static int devm_memremap_match(struct device *dev, void *res, void *match_data)
<span class="p_header">diff --git a/kernel/module.c b/kernel/module.c</span>
<span class="p_header">index 38c7bd5583ff..14833e6d5e37 100644</span>
<span class="p_header">--- a/kernel/module.c</span>
<span class="p_header">+++ b/kernel/module.c</span>
<span class="p_chunk">@@ -3515,7 +3515,7 @@</span> <span class="p_context"> static int load_module(struct load_info *info, const char __user *uargs,</span>
 
 	/* Module is ready to execute: parsing args may do that. */
 	after_dashes = parse_args(mod-&gt;name, mod-&gt;args, mod-&gt;kp, mod-&gt;num_kp,
<span class="p_del">-				  -32768, 32767, NULL,</span>
<span class="p_add">+				  -32768, 32767, mod,</span>
 				  unknown_module_param_cb);
 	if (IS_ERR(after_dashes)) {
 		err = PTR_ERR(after_dashes);
<span class="p_chunk">@@ -3646,6 +3646,11 @@</span> <span class="p_context"> static inline int is_arm_mapping_symbol(const char *str)</span>
 	       &amp;&amp; (str[2] == &#39;\0&#39; || str[2] == &#39;.&#39;);
 }
 
<span class="p_add">+static const char *symname(struct module *mod, unsigned int symnum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return mod-&gt;strtab + mod-&gt;symtab[symnum].st_name;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const char *get_ksymbol(struct module *mod,
 			       unsigned long addr,
 			       unsigned long *size,
<span class="p_chunk">@@ -3668,15 +3673,15 @@</span> <span class="p_context"> static const char *get_ksymbol(struct module *mod,</span>
 
 		/* We ignore unnamed symbols: they&#39;re uninformative
 		 * and inserted at a whim. */
<span class="p_add">+		if (*symname(mod, i) == &#39;\0&#39;</span>
<span class="p_add">+		    || is_arm_mapping_symbol(symname(mod, i)))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		if (mod-&gt;symtab[i].st_value &lt;= addr
<span class="p_del">-		    &amp;&amp; mod-&gt;symtab[i].st_value &gt; mod-&gt;symtab[best].st_value</span>
<span class="p_del">-		    &amp;&amp; *(mod-&gt;strtab + mod-&gt;symtab[i].st_name) != &#39;\0&#39;</span>
<span class="p_del">-		    &amp;&amp; !is_arm_mapping_symbol(mod-&gt;strtab + mod-&gt;symtab[i].st_name))</span>
<span class="p_add">+		    &amp;&amp; mod-&gt;symtab[i].st_value &gt; mod-&gt;symtab[best].st_value)</span>
 			best = i;
 		if (mod-&gt;symtab[i].st_value &gt; addr
<span class="p_del">-		    &amp;&amp; mod-&gt;symtab[i].st_value &lt; nextval</span>
<span class="p_del">-		    &amp;&amp; *(mod-&gt;strtab + mod-&gt;symtab[i].st_name) != &#39;\0&#39;</span>
<span class="p_del">-		    &amp;&amp; !is_arm_mapping_symbol(mod-&gt;strtab + mod-&gt;symtab[i].st_name))</span>
<span class="p_add">+		    &amp;&amp; mod-&gt;symtab[i].st_value &lt; nextval)</span>
 			nextval = mod-&gt;symtab[i].st_value;
 	}
 
<span class="p_chunk">@@ -3687,7 +3692,7 @@</span> <span class="p_context"> static const char *get_ksymbol(struct module *mod,</span>
 		*size = nextval - mod-&gt;symtab[best].st_value;
 	if (offset)
 		*offset = addr - mod-&gt;symtab[best].st_value;
<span class="p_del">-	return mod-&gt;strtab + mod-&gt;symtab[best].st_name;</span>
<span class="p_add">+	return symname(mod, best);</span>
 }
 
 /* For kallsyms to ask for address resolution.  NULL means not found.  Careful
<span class="p_chunk">@@ -3782,8 +3787,7 @@</span> <span class="p_context"> int module_get_kallsym(unsigned int symnum, unsigned long *value, char *type,</span>
 		if (symnum &lt; mod-&gt;num_symtab) {
 			*value = mod-&gt;symtab[symnum].st_value;
 			*type = mod-&gt;symtab[symnum].st_info;
<span class="p_del">-			strlcpy(name, mod-&gt;strtab + mod-&gt;symtab[symnum].st_name,</span>
<span class="p_del">-				KSYM_NAME_LEN);</span>
<span class="p_add">+			strlcpy(name, symname(mod, symnum), KSYM_NAME_LEN);</span>
 			strlcpy(module_name, mod-&gt;name, MODULE_NAME_LEN);
 			*exported = is_exported(name, *value, mod);
 			preempt_enable();
<span class="p_chunk">@@ -3800,7 +3804,7 @@</span> <span class="p_context"> static unsigned long mod_find_symname(struct module *mod, const char *name)</span>
 	unsigned int i;
 
 	for (i = 0; i &lt; mod-&gt;num_symtab; i++)
<span class="p_del">-		if (strcmp(name, mod-&gt;strtab+mod-&gt;symtab[i].st_name) == 0 &amp;&amp;</span>
<span class="p_add">+		if (strcmp(name, symname(mod, i)) == 0 &amp;&amp;</span>
 		    mod-&gt;symtab[i].st_info != &#39;U&#39;)
 			return mod-&gt;symtab[i].st_value;
 	return 0;
<span class="p_chunk">@@ -3844,7 +3848,7 @@</span> <span class="p_context"> int module_kallsyms_on_each_symbol(int (*fn)(void *, const char *,</span>
 		if (mod-&gt;state == MODULE_STATE_UNFORMED)
 			continue;
 		for (i = 0; i &lt; mod-&gt;num_symtab; i++) {
<span class="p_del">-			ret = fn(data, mod-&gt;strtab + mod-&gt;symtab[i].st_name,</span>
<span class="p_add">+			ret = fn(data, symname(mod, i),</span>
 				 mod, mod-&gt;symtab[i].st_value);
 			if (ret != 0)
 				return ret;
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index b760bae64cf1..3189e51db7e8 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -219,6 +219,14 @@</span> <span class="p_context"> static int ptrace_has_cap(struct user_namespace *ns, unsigned int mode)</span>
 static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
 {
 	const struct cred *cred = current_cred(), *tcred;
<span class="p_add">+	int dumpable = 0;</span>
<span class="p_add">+	kuid_t caller_uid;</span>
<span class="p_add">+	kgid_t caller_gid;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(mode &amp; PTRACE_MODE_FSCREDS) == !(mode &amp; PTRACE_MODE_REALCREDS)) {</span>
<span class="p_add">+		WARN(1, &quot;denying ptrace access check without PTRACE_MODE_*CREDS\n&quot;);</span>
<span class="p_add">+		return -EPERM;</span>
<span class="p_add">+	}</span>
 
 	/* May we inspect the given task?
 	 * This check is used both for attaching with ptrace
<span class="p_chunk">@@ -228,18 +236,33 @@</span> <span class="p_context"> static int __ptrace_may_access(struct task_struct *task, unsigned int mode)</span>
 	 * because setting up the necessary parent/child relationship
 	 * or halting the specified task is impossible.
 	 */
<span class="p_del">-	int dumpable = 0;</span>
<span class="p_add">+</span>
 	/* Don&#39;t let security modules deny introspection */
 	if (same_thread_group(task, current))
 		return 0;
 	rcu_read_lock();
<span class="p_add">+	if (mode &amp; PTRACE_MODE_FSCREDS) {</span>
<span class="p_add">+		caller_uid = cred-&gt;fsuid;</span>
<span class="p_add">+		caller_gid = cred-&gt;fsgid;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Using the euid would make more sense here, but something</span>
<span class="p_add">+		 * in userland might rely on the old behavior, and this</span>
<span class="p_add">+		 * shouldn&#39;t be a security problem since</span>
<span class="p_add">+		 * PTRACE_MODE_REALCREDS implies that the caller explicitly</span>
<span class="p_add">+		 * used a syscall that requests access to another process</span>
<span class="p_add">+		 * (and not a filesystem syscall to procfs).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		caller_uid = cred-&gt;uid;</span>
<span class="p_add">+		caller_gid = cred-&gt;gid;</span>
<span class="p_add">+	}</span>
 	tcred = __task_cred(task);
<span class="p_del">-	if (uid_eq(cred-&gt;uid, tcred-&gt;euid) &amp;&amp;</span>
<span class="p_del">-	    uid_eq(cred-&gt;uid, tcred-&gt;suid) &amp;&amp;</span>
<span class="p_del">-	    uid_eq(cred-&gt;uid, tcred-&gt;uid)  &amp;&amp;</span>
<span class="p_del">-	    gid_eq(cred-&gt;gid, tcred-&gt;egid) &amp;&amp;</span>
<span class="p_del">-	    gid_eq(cred-&gt;gid, tcred-&gt;sgid) &amp;&amp;</span>
<span class="p_del">-	    gid_eq(cred-&gt;gid, tcred-&gt;gid))</span>
<span class="p_add">+	if (uid_eq(caller_uid, tcred-&gt;euid) &amp;&amp;</span>
<span class="p_add">+	    uid_eq(caller_uid, tcred-&gt;suid) &amp;&amp;</span>
<span class="p_add">+	    uid_eq(caller_uid, tcred-&gt;uid)  &amp;&amp;</span>
<span class="p_add">+	    gid_eq(caller_gid, tcred-&gt;egid) &amp;&amp;</span>
<span class="p_add">+	    gid_eq(caller_gid, tcred-&gt;sgid) &amp;&amp;</span>
<span class="p_add">+	    gid_eq(caller_gid, tcred-&gt;gid))</span>
 		goto ok;
 	if (ptrace_has_cap(tcred-&gt;user_ns, mode))
 		goto ok;
<span class="p_chunk">@@ -306,7 +329,7 @@</span> <span class="p_context"> static int ptrace_attach(struct task_struct *task, long request,</span>
 		goto out;
 
 	task_lock(task);
<span class="p_del">-	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH);</span>
<span class="p_add">+	retval = __ptrace_may_access(task, PTRACE_MODE_ATTACH_REALCREDS);</span>
 	task_unlock(task);
 	if (retval)
 		goto unlock_creds;
<span class="p_header">diff --git a/kernel/sys.c b/kernel/sys.c</span>
<span class="p_header">index 6af9212ab5aa..78947de6f969 100644</span>
<span class="p_header">--- a/kernel/sys.c</span>
<span class="p_header">+++ b/kernel/sys.c</span>
<span class="p_chunk">@@ -1853,11 +1853,13 @@</span> <span class="p_context"> static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data</span>
 		user_auxv[AT_VECTOR_SIZE - 1] = AT_NULL;
 	}
 
<span class="p_del">-	if (prctl_map.exe_fd != (u32)-1)</span>
<span class="p_add">+	if (prctl_map.exe_fd != (u32)-1) {</span>
 		error = prctl_set_mm_exe_file(mm, prctl_map.exe_fd);
<span class="p_del">-	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
 
 	/*
 	 * We don&#39;t validate if these members are pointing to
<span class="p_chunk">@@ -1894,10 +1896,8 @@</span> <span class="p_context"> static int prctl_set_mm_map(int opt, const void __user *addr, unsigned long data</span>
 	if (prctl_map.auxv_size)
 		memcpy(mm-&gt;saved_auxv, user_auxv, sizeof(user_auxv));
 
<span class="p_del">-	error = 0;</span>
<span class="p_del">-out:</span>
<span class="p_del">-	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_del">-	return error;</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	return 0;</span>
 }
 #endif /* CONFIG_CHECKPOINT_RESTORE */
 
<span class="p_chunk">@@ -1963,7 +1963,7 @@</span> <span class="p_context"> static int prctl_set_mm(int opt, unsigned long addr,</span>
 
 	error = -EINVAL;
 
<span class="p_del">-	down_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
 	vma = find_vma(mm, addr);
 
 	prctl_map.start_code	= mm-&gt;start_code;
<span class="p_chunk">@@ -2056,7 +2056,7 @@</span> <span class="p_context"> static int prctl_set_mm(int opt, unsigned long addr,</span>
 
 	error = 0;
 out:
<span class="p_del">-	up_read(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
 	return error;
 }
 
<span class="p_header">diff --git a/kernel/time/itimer.c b/kernel/time/itimer.c</span>
<span class="p_header">index 8d262b467573..1d5c7204ddc9 100644</span>
<span class="p_header">--- a/kernel/time/itimer.c</span>
<span class="p_header">+++ b/kernel/time/itimer.c</span>
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"></span>
  */
 static struct timeval itimer_get_remtime(struct hrtimer *timer)
 {
<span class="p_del">-	ktime_t rem = hrtimer_get_remaining(timer);</span>
<span class="p_add">+	ktime_t rem = __hrtimer_get_remaining(timer, true);</span>
 
 	/*
 	 * Racy but safe: if the itimer expires after the above
<span class="p_header">diff --git a/kernel/time/posix-timers.c b/kernel/time/posix-timers.c</span>
<span class="p_header">index 31d11ac9fa47..f2826c35e918 100644</span>
<span class="p_header">--- a/kernel/time/posix-timers.c</span>
<span class="p_header">+++ b/kernel/time/posix-timers.c</span>
<span class="p_chunk">@@ -760,7 +760,7 @@</span> <span class="p_context"> common_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)</span>
 	    (timr-&gt;it_sigev_notify &amp; ~SIGEV_THREAD_ID) == SIGEV_NONE))
 		timr-&gt;it_overrun += (unsigned int) hrtimer_forward(timer, now, iv);
 
<span class="p_del">-	remaining = ktime_sub(hrtimer_get_expires(timer), now);</span>
<span class="p_add">+	remaining = __hrtimer_expires_remaining_adjusted(timer, now);</span>
 	/* Return 0 only, when the timer is expired and not pending */
 	if (remaining.tv64 &lt;= 0) {
 		/*
<span class="p_header">diff --git a/lib/dma-debug.c b/lib/dma-debug.c</span>
<span class="p_header">index d34bd24c2c84..4a1515f4b452 100644</span>
<span class="p_header">--- a/lib/dma-debug.c</span>
<span class="p_header">+++ b/lib/dma-debug.c</span>
<span class="p_chunk">@@ -1181,7 +1181,7 @@</span> <span class="p_context"> static inline bool overlap(void *addr, unsigned long len, void *start, void *end</span>
 
 static void check_for_illegal_area(struct device *dev, void *addr, unsigned long len)
 {
<span class="p_del">-	if (overlap(addr, len, _text, _etext) ||</span>
<span class="p_add">+	if (overlap(addr, len, _stext, _etext) ||</span>
 	    overlap(addr, len, __start_rodata, __end_rodata))
 		err_printk(dev, NULL, &quot;DMA-API: device driver maps memory from kernel text or rodata [addr=%p] [len=%lu]\n&quot;, addr, len);
 }
<span class="p_header">diff --git a/lib/dump_stack.c b/lib/dump_stack.c</span>
<span class="p_header">index 6745c6230db3..c30d07e99dba 100644</span>
<span class="p_header">--- a/lib/dump_stack.c</span>
<span class="p_header">+++ b/lib/dump_stack.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"> static atomic_t dump_lock = ATOMIC_INIT(-1);</span>
 
 asmlinkage __visible void dump_stack(void)
 {
<span class="p_add">+	unsigned long flags;</span>
 	int was_locked;
 	int old;
 	int cpu;
<span class="p_chunk">@@ -33,9 +34,8 @@</span> <span class="p_context"> asmlinkage __visible void dump_stack(void)</span>
 	 * Permit this cpu to perform nested stack dumps while serialising
 	 * against other CPUs
 	 */
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-</span>
 retry:
<span class="p_add">+	local_irq_save(flags);</span>
 	cpu = smp_processor_id();
 	old = atomic_cmpxchg(&amp;dump_lock, -1, cpu);
 	if (old == -1) {
<span class="p_chunk">@@ -43,6 +43,7 @@</span> <span class="p_context"> retry:</span>
 	} else if (old == cpu) {
 		was_locked = 1;
 	} else {
<span class="p_add">+		local_irq_restore(flags);</span>
 		cpu_relax();
 		goto retry;
 	}
<span class="p_chunk">@@ -52,7 +53,7 @@</span> <span class="p_context"> retry:</span>
 	if (!was_locked)
 		atomic_set(&amp;dump_lock, -1);
 
<span class="p_del">-	preempt_enable();</span>
<span class="p_add">+	local_irq_restore(flags);</span>
 }
 #else
 asmlinkage __visible void dump_stack(void)
<span class="p_header">diff --git a/lib/klist.c b/lib/klist.c</span>
<span class="p_header">index d74cf7a29afd..0507fa5d84c5 100644</span>
<span class="p_header">--- a/lib/klist.c</span>
<span class="p_header">+++ b/lib/klist.c</span>
<span class="p_chunk">@@ -282,9 +282,9 @@</span> <span class="p_context"> void klist_iter_init_node(struct klist *k, struct klist_iter *i,</span>
 			  struct klist_node *n)
 {
 	i-&gt;i_klist = k;
<span class="p_del">-	i-&gt;i_cur = n;</span>
<span class="p_del">-	if (n)</span>
<span class="p_del">-		kref_get(&amp;n-&gt;n_ref);</span>
<span class="p_add">+	i-&gt;i_cur = NULL;</span>
<span class="p_add">+	if (n &amp;&amp; kref_get_unless_zero(&amp;n-&gt;n_ref))</span>
<span class="p_add">+		i-&gt;i_cur = n;</span>
 }
 EXPORT_SYMBOL_GPL(klist_iter_init_node);
 
<span class="p_header">diff --git a/lib/radix-tree.c b/lib/radix-tree.c</span>
<span class="p_header">index fcf5d98574ce..6b79e9026e24 100644</span>
<span class="p_header">--- a/lib/radix-tree.c</span>
<span class="p_header">+++ b/lib/radix-tree.c</span>
<span class="p_chunk">@@ -1019,9 +1019,13 @@</span> <span class="p_context"> radix_tree_gang_lookup(struct radix_tree_root *root, void **results,</span>
 		return 0;
 
 	radix_tree_for_each_slot(slot, root, &amp;iter, first_index) {
<span class="p_del">-		results[ret] = indirect_to_ptr(rcu_dereference_raw(*slot));</span>
<span class="p_add">+		results[ret] = rcu_dereference_raw(*slot);</span>
 		if (!results[ret])
 			continue;
<span class="p_add">+		if (radix_tree_is_indirect_ptr(results[ret])) {</span>
<span class="p_add">+			slot = radix_tree_iter_retry(&amp;iter);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 		if (++ret == max_items)
 			break;
 	}
<span class="p_chunk">@@ -1098,9 +1102,13 @@</span> <span class="p_context"> radix_tree_gang_lookup_tag(struct radix_tree_root *root, void **results,</span>
 		return 0;
 
 	radix_tree_for_each_tagged(slot, root, &amp;iter, first_index, tag) {
<span class="p_del">-		results[ret] = indirect_to_ptr(rcu_dereference_raw(*slot));</span>
<span class="p_add">+		results[ret] = rcu_dereference_raw(*slot);</span>
 		if (!results[ret])
 			continue;
<span class="p_add">+		if (radix_tree_is_indirect_ptr(results[ret])) {</span>
<span class="p_add">+			slot = radix_tree_iter_retry(&amp;iter);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 		if (++ret == max_items)
 			break;
 	}
<span class="p_header">diff --git a/lib/string_helpers.c b/lib/string_helpers.c</span>
<span class="p_header">index 5939f63d90cd..5c88204b6f1f 100644</span>
<span class="p_header">--- a/lib/string_helpers.c</span>
<span class="p_header">+++ b/lib/string_helpers.c</span>
<span class="p_chunk">@@ -43,50 +43,73 @@</span> <span class="p_context"> void string_get_size(u64 size, u64 blk_size, const enum string_size_units units,</span>
 		[STRING_UNITS_10] = 1000,
 		[STRING_UNITS_2] = 1024,
 	};
<span class="p_del">-	int i, j;</span>
<span class="p_del">-	u32 remainder = 0, sf_cap, exp;</span>
<span class="p_add">+	static const unsigned int rounding[] = { 500, 50, 5 };</span>
<span class="p_add">+	int i = 0, j;</span>
<span class="p_add">+	u32 remainder = 0, sf_cap;</span>
 	char tmp[8];
 	const char *unit;
 
 	tmp[0] = &#39;\0&#39;;
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	if (!size)</span>
<span class="p_add">+</span>
<span class="p_add">+	if (blk_size == 0)</span>
<span class="p_add">+		size = 0;</span>
<span class="p_add">+	if (size == 0)</span>
 		goto out;
 
<span class="p_del">-	while (blk_size &gt;= divisor[units]) {</span>
<span class="p_del">-		remainder = do_div(blk_size, divisor[units]);</span>
<span class="p_add">+	/* This is Napier&#39;s algorithm.  Reduce the original block size to</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * coefficient * divisor[units]^i</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * we do the reduction so both coefficients are just under 32 bits so</span>
<span class="p_add">+	 * that multiplying them together won&#39;t overflow 64 bits and we keep</span>
<span class="p_add">+	 * as much precision as possible in the numbers.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note: it&#39;s safe to throw away the remainders here because all the</span>
<span class="p_add">+	 * precision is in the coefficients.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (blk_size &gt;&gt; 32) {</span>
<span class="p_add">+		do_div(blk_size, divisor[units]);</span>
 		i++;
 	}
 
<span class="p_del">-	exp = divisor[units] / (u32)blk_size;</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * size must be strictly greater than exp here to ensure that remainder</span>
<span class="p_del">-	 * is greater than divisor[units] coming out of the if below.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (size &gt; exp) {</span>
<span class="p_del">-		remainder = do_div(size, divisor[units]);</span>
<span class="p_del">-		remainder *= blk_size;</span>
<span class="p_add">+	while (size &gt;&gt; 32) {</span>
<span class="p_add">+		do_div(size, divisor[units]);</span>
 		i++;
<span class="p_del">-	} else {</span>
<span class="p_del">-		remainder *= size;</span>
 	}
 
<span class="p_add">+	/* now perform the actual multiplication keeping i as the sum of the</span>
<span class="p_add">+	 * two logarithms */</span>
 	size *= blk_size;
<span class="p_del">-	size += remainder / divisor[units];</span>
<span class="p_del">-	remainder %= divisor[units];</span>
 
<span class="p_add">+	/* and logarithmically reduce it until it&#39;s just under the divisor */</span>
 	while (size &gt;= divisor[units]) {
 		remainder = do_div(size, divisor[units]);
 		i++;
 	}
 
<span class="p_add">+	/* work out in j how many digits of precision we need from the</span>
<span class="p_add">+	 * remainder */</span>
 	sf_cap = size;
 	for (j = 0; sf_cap*10 &lt; 1000; j++)
 		sf_cap *= 10;
 
<span class="p_del">-	if (j) {</span>
<span class="p_add">+	if (units == STRING_UNITS_2) {</span>
<span class="p_add">+		/* express the remainder as a decimal.  It&#39;s currently the</span>
<span class="p_add">+		 * numerator of a fraction whose denominator is</span>
<span class="p_add">+		 * divisor[units], which is 1 &lt;&lt; 10 for STRING_UNITS_2 */</span>
 		remainder *= 1000;
<span class="p_del">-		remainder /= divisor[units];</span>
<span class="p_add">+		remainder &gt;&gt;= 10;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* add a 5 to the digit below what will be printed to ensure</span>
<span class="p_add">+	 * an arithmetical round up and carry it through to size */</span>
<span class="p_add">+	remainder += rounding[j];</span>
<span class="p_add">+	if (remainder &gt;= 1000) {</span>
<span class="p_add">+		remainder -= 1000;</span>
<span class="p_add">+		size += 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (j) {</span>
 		snprintf(tmp, sizeof(tmp), &quot;.%03u&quot;, remainder);
 		tmp[j+1] = &#39;\0&#39;;
 	}
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index fc10620967c7..ee6acd279953 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -3522,16 +3522,17 @@</span> <span class="p_context"> static void __mem_cgroup_usage_unregister_event(struct mem_cgroup *memcg,</span>
 swap_buffers:
 	/* Swap primary and spare array */
 	thresholds-&gt;spare = thresholds-&gt;primary;
<span class="p_del">-	/* If all events are unregistered, free the spare array */</span>
<span class="p_del">-	if (!new) {</span>
<span class="p_del">-		kfree(thresholds-&gt;spare);</span>
<span class="p_del">-		thresholds-&gt;spare = NULL;</span>
<span class="p_del">-	}</span>
 
 	rcu_assign_pointer(thresholds-&gt;primary, new);
 
 	/* To be sure that nobody uses thresholds */
 	synchronize_rcu();
<span class="p_add">+</span>
<span class="p_add">+	/* If all events are unregistered, free the spare array */</span>
<span class="p_add">+	if (!new) {</span>
<span class="p_add">+		kfree(thresholds-&gt;spare);</span>
<span class="p_add">+		thresholds-&gt;spare = NULL;</span>
<span class="p_add">+	}</span>
 unlock:
 	mutex_unlock(&amp;memcg-&gt;thresholds_lock);
 }
<span class="p_header">diff --git a/mm/memory-failure.c b/mm/memory-failure.c</span>
<span class="p_header">index 8424b64711ac..750b7893ee3a 100644</span>
<span class="p_header">--- a/mm/memory-failure.c</span>
<span class="p_header">+++ b/mm/memory-failure.c</span>
<span class="p_chunk">@@ -1572,7 +1572,7 @@</span> <span class="p_context"> static int get_any_page(struct page *page, unsigned long pfn, int flags)</span>
 		 * Did it turn free?
 		 */
 		ret = __get_any_page(page, pfn, 0);
<span class="p_del">-		if (!PageLRU(page)) {</span>
<span class="p_add">+		if (ret == 1 &amp;&amp; !PageLRU(page)) {</span>
 			/* Drop page reference which is from __get_any_page() */
 			put_hwpoison_page(page);
 			pr_info(&quot;soft_offline: %#lx: unknown non LRU page type %lx\n&quot;,
<span class="p_header">diff --git a/mm/mlock.c b/mm/mlock.c</span>
<span class="p_header">index 339d9e0949b6..d6006b146fea 100644</span>
<span class="p_header">--- a/mm/mlock.c</span>
<span class="p_header">+++ b/mm/mlock.c</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> static void __munlock_isolation_failed(struct page *page)</span>
  */
 unsigned int munlock_vma_page(struct page *page)
 {
<span class="p_del">-	unsigned int nr_pages;</span>
<span class="p_add">+	int nr_pages;</span>
 	struct zone *zone = page_zone(page);
 
 	/* For try_to_munlock() and to serialize with page migration */
<span class="p_header">diff --git a/mm/mmap.c b/mm/mmap.c</span>
<span class="p_header">index 2ce04a649f6b..455772a05e54 100644</span>
<span class="p_header">--- a/mm/mmap.c</span>
<span class="p_header">+++ b/mm/mmap.c</span>
<span class="p_chunk">@@ -441,12 +441,16 @@</span> <span class="p_context"> static void validate_mm(struct mm_struct *mm)</span>
 	struct vm_area_struct *vma = mm-&gt;mmap;
 
 	while (vma) {
<span class="p_add">+		struct anon_vma *anon_vma = vma-&gt;anon_vma;</span>
 		struct anon_vma_chain *avc;
 
<span class="p_del">-		vma_lock_anon_vma(vma);</span>
<span class="p_del">-		list_for_each_entry(avc, &amp;vma-&gt;anon_vma_chain, same_vma)</span>
<span class="p_del">-			anon_vma_interval_tree_verify(avc);</span>
<span class="p_del">-		vma_unlock_anon_vma(vma);</span>
<span class="p_add">+		if (anon_vma) {</span>
<span class="p_add">+			anon_vma_lock_read(anon_vma);</span>
<span class="p_add">+			list_for_each_entry(avc, &amp;vma-&gt;anon_vma_chain, same_vma)</span>
<span class="p_add">+				anon_vma_interval_tree_verify(avc);</span>
<span class="p_add">+			anon_vma_unlock_read(anon_vma);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		highest_address = vma-&gt;vm_end;
 		vma = vma-&gt;vm_next;
 		i++;
<span class="p_chunk">@@ -2147,32 +2151,27 @@</span> <span class="p_context"> static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, uns</span>
 int expand_upwards(struct vm_area_struct *vma, unsigned long address)
 {
 	struct mm_struct *mm = vma-&gt;vm_mm;
<span class="p_del">-	int error;</span>
<span class="p_add">+	int error = 0;</span>
 
 	if (!(vma-&gt;vm_flags &amp; VM_GROWSUP))
 		return -EFAULT;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We must make sure the anon_vma is allocated</span>
<span class="p_del">-	 * so that the anon_vma locking is not a noop.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	/* Guard against wrapping around to address 0. */</span>
<span class="p_add">+	if (address &lt; PAGE_ALIGN(address+4))</span>
<span class="p_add">+		address = PAGE_ALIGN(address+4);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We must make sure the anon_vma is allocated. */</span>
 	if (unlikely(anon_vma_prepare(vma)))
 		return -ENOMEM;
<span class="p_del">-	vma_lock_anon_vma(vma);</span>
 
 	/*
 	 * vma-&gt;vm_start/vm_end cannot change under us because the caller
 	 * is required to hold the mmap_sem in read mode.  We need the
 	 * anon_vma lock to serialize against concurrent expand_stacks.
<span class="p_del">-	 * Also guard against wrapping around to address 0.</span>
 	 */
<span class="p_del">-	if (address &lt; PAGE_ALIGN(address+4))</span>
<span class="p_del">-		address = PAGE_ALIGN(address+4);</span>
<span class="p_del">-	else {</span>
<span class="p_del">-		vma_unlock_anon_vma(vma);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	error = 0;</span>
<span class="p_add">+	anon_vma_lock_write(vma-&gt;anon_vma);</span>
 
 	/* Somebody else might have raced and expanded it already */
 	if (address &gt; vma-&gt;vm_end) {
<span class="p_chunk">@@ -2190,7 +2189,7 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 				 * updates, but we only hold a shared mmap_sem
 				 * lock here, so we need to protect against
 				 * concurrent vma expansions.
<span class="p_del">-				 * vma_lock_anon_vma() doesn&#39;t help here, as</span>
<span class="p_add">+				 * anon_vma_lock_write() doesn&#39;t help here, as</span>
 				 * we don&#39;t guarantee that all growable vmas
 				 * in a mm share the same root anon vma.
 				 * So, we reuse mm-&gt;page_table_lock to guard
<span class="p_chunk">@@ -2214,7 +2213,7 @@</span> <span class="p_context"> int expand_upwards(struct vm_area_struct *vma, unsigned long address)</span>
 			}
 		}
 	}
<span class="p_del">-	vma_unlock_anon_vma(vma);</span>
<span class="p_add">+	anon_vma_unlock_write(vma-&gt;anon_vma);</span>
 	khugepaged_enter_vma_merge(vma, vma-&gt;vm_flags);
 	validate_mm(mm);
 	return error;
<span class="p_chunk">@@ -2230,25 +2229,21 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 	struct mm_struct *mm = vma-&gt;vm_mm;
 	int error;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We must make sure the anon_vma is allocated</span>
<span class="p_del">-	 * so that the anon_vma locking is not a noop.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (unlikely(anon_vma_prepare(vma)))</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
 	address &amp;= PAGE_MASK;
 	error = security_mmap_addr(address);
 	if (error)
 		return error;
 
<span class="p_del">-	vma_lock_anon_vma(vma);</span>
<span class="p_add">+	/* We must make sure the anon_vma is allocated. */</span>
<span class="p_add">+	if (unlikely(anon_vma_prepare(vma)))</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	/*
 	 * vma-&gt;vm_start/vm_end cannot change under us because the caller
 	 * is required to hold the mmap_sem in read mode.  We need the
 	 * anon_vma lock to serialize against concurrent expand_stacks.
 	 */
<span class="p_add">+	anon_vma_lock_write(vma-&gt;anon_vma);</span>
 
 	/* Somebody else might have raced and expanded it already */
 	if (address &lt; vma-&gt;vm_start) {
<span class="p_chunk">@@ -2266,7 +2261,7 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 				 * updates, but we only hold a shared mmap_sem
 				 * lock here, so we need to protect against
 				 * concurrent vma expansions.
<span class="p_del">-				 * vma_lock_anon_vma() doesn&#39;t help here, as</span>
<span class="p_add">+				 * anon_vma_lock_write() doesn&#39;t help here, as</span>
 				 * we don&#39;t guarantee that all growable vmas
 				 * in a mm share the same root anon vma.
 				 * So, we reuse mm-&gt;page_table_lock to guard
<span class="p_chunk">@@ -2288,7 +2283,7 @@</span> <span class="p_context"> int expand_downwards(struct vm_area_struct *vma,</span>
 			}
 		}
 	}
<span class="p_del">-	vma_unlock_anon_vma(vma);</span>
<span class="p_add">+	anon_vma_unlock_write(vma-&gt;anon_vma);</span>
 	khugepaged_enter_vma_merge(vma, vma-&gt;vm_flags);
 	validate_mm(mm);
 	return error;
<span class="p_chunk">@@ -2673,12 +2668,29 @@</span> <span class="p_context"> SYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,</span>
 	if (!vma || !(vma-&gt;vm_flags &amp; VM_SHARED))
 		goto out;
 
<span class="p_del">-	if (start &lt; vma-&gt;vm_start || start + size &gt; vma-&gt;vm_end)</span>
<span class="p_add">+	if (start &lt; vma-&gt;vm_start)</span>
 		goto out;
 
<span class="p_del">-	if (pgoff == linear_page_index(vma, start)) {</span>
<span class="p_del">-		ret = 0;</span>
<span class="p_del">-		goto out;</span>
<span class="p_add">+	if (start + size &gt; vma-&gt;vm_end) {</span>
<span class="p_add">+		struct vm_area_struct *next;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (next = vma-&gt;vm_next; next; next = next-&gt;vm_next) {</span>
<span class="p_add">+			/* hole between vmas ? */</span>
<span class="p_add">+			if (next-&gt;vm_start != next-&gt;vm_prev-&gt;vm_end)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (next-&gt;vm_file != vma-&gt;vm_file)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (next-&gt;vm_flags != vma-&gt;vm_flags)</span>
<span class="p_add">+				goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (start + size &lt;= next-&gt;vm_end)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!next)</span>
<span class="p_add">+			goto out;</span>
 	}
 
 	prot |= vma-&gt;vm_flags &amp; VM_READ ? PROT_READ : 0;
<span class="p_chunk">@@ -2688,9 +2700,16 @@</span> <span class="p_context"> SYSCALL_DEFINE5(remap_file_pages, unsigned long, start, unsigned long, size,</span>
 	flags &amp;= MAP_NONBLOCK;
 	flags |= MAP_SHARED | MAP_FIXED | MAP_POPULATE;
 	if (vma-&gt;vm_flags &amp; VM_LOCKED) {
<span class="p_add">+		struct vm_area_struct *tmp;</span>
 		flags |= MAP_LOCKED;
<span class="p_add">+</span>
 		/* drop PG_Mlocked flag for over-mapped range */
<span class="p_del">-		munlock_vma_pages_range(vma, start, start + size);</span>
<span class="p_add">+		for (tmp = vma; tmp-&gt;vm_start &gt;= start + size;</span>
<span class="p_add">+				tmp = tmp-&gt;vm_next) {</span>
<span class="p_add">+			munlock_vma_pages_range(tmp,</span>
<span class="p_add">+					max(tmp-&gt;vm_start, start),</span>
<span class="p_add">+					min(tmp-&gt;vm_end, start + size));</span>
<span class="p_add">+		}</span>
 	}
 
 	file = get_file(vma-&gt;vm_file);
<span class="p_header">diff --git a/mm/pgtable-generic.c b/mm/pgtable-generic.c</span>
<span class="p_header">index 7d3db0247983..1ba58213ad65 100644</span>
<span class="p_header">--- a/mm/pgtable-generic.c</span>
<span class="p_header">+++ b/mm/pgtable-generic.c</span>
<span class="p_chunk">@@ -210,7 +210,9 @@</span> <span class="p_context"> pmd_t pmdp_collapse_flush(struct vm_area_struct *vma, unsigned long address,</span>
 	VM_BUG_ON(address &amp; ~HPAGE_PMD_MASK);
 	VM_BUG_ON(pmd_trans_huge(*pmdp));
 	pmd = pmdp_huge_get_and_clear(vma-&gt;vm_mm, address, pmdp);
<span class="p_del">-	flush_pmd_tlb_range(vma, address, address + HPAGE_PMD_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* collapse entails shooting down ptes not pmd */</span>
<span class="p_add">+	flush_tlb_range(vma, address, address + HPAGE_PMD_SIZE);</span>
 	return pmd;
 }
 #endif
<span class="p_header">diff --git a/mm/process_vm_access.c b/mm/process_vm_access.c</span>
<span class="p_header">index e88d071648c2..5d453e58ddbf 100644</span>
<span class="p_header">--- a/mm/process_vm_access.c</span>
<span class="p_header">+++ b/mm/process_vm_access.c</span>
<span class="p_chunk">@@ -194,7 +194,7 @@</span> <span class="p_context"> static ssize_t process_vm_rw_core(pid_t pid, struct iov_iter *iter,</span>
 		goto free_proc_pages;
 	}
 
<span class="p_del">-	mm = mm_access(task, PTRACE_MODE_ATTACH);</span>
<span class="p_add">+	mm = mm_access(task, PTRACE_MODE_ATTACH_REALCREDS);</span>
 	if (!mm || IS_ERR(mm)) {
 		rc = IS_ERR(mm) ? PTR_ERR(mm) : -ESRCH;
 		/*
<span class="p_header">diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c</span>
<span class="p_header">index 2ffaf6a79499..027c9ef8a263 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtsock.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtsock.c</span>
<span class="p_chunk">@@ -398,7 +398,6 @@</span> <span class="p_context"> static int xs_sendpages(struct socket *sock, struct sockaddr *addr, int addrlen,</span>
 	if (unlikely(!sock))
 		return -ENOTSOCK;
 
<span class="p_del">-	clear_bit(SOCKWQ_ASYNC_NOSPACE, &amp;sock-&gt;flags);</span>
 	if (base != 0) {
 		addr = NULL;
 		addrlen = 0;
<span class="p_chunk">@@ -442,7 +441,6 @@</span> <span class="p_context"> static void xs_nospace_callback(struct rpc_task *task)</span>
 	struct sock_xprt *transport = container_of(task-&gt;tk_rqstp-&gt;rq_xprt, struct sock_xprt, xprt);
 
 	transport-&gt;inet-&gt;sk_write_pending--;
<span class="p_del">-	clear_bit(SOCKWQ_ASYNC_NOSPACE, &amp;transport-&gt;sock-&gt;flags);</span>
 }
 
 /**
<span class="p_chunk">@@ -467,20 +465,11 @@</span> <span class="p_context"> static int xs_nospace(struct rpc_task *task)</span>
 
 	/* Don&#39;t race with disconnect */
 	if (xprt_connected(xprt)) {
<span class="p_del">-		if (test_bit(SOCKWQ_ASYNC_NOSPACE, &amp;transport-&gt;sock-&gt;flags)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Notify TCP that we&#39;re limited by the application</span>
<span class="p_del">-			 * window size</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			set_bit(SOCK_NOSPACE, &amp;transport-&gt;sock-&gt;flags);</span>
<span class="p_del">-			sk-&gt;sk_write_pending++;</span>
<span class="p_del">-			/* ...and wait for more buffer space */</span>
<span class="p_del">-			xprt_wait_for_buffer_space(task, xs_nospace_callback);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		clear_bit(SOCKWQ_ASYNC_NOSPACE, &amp;transport-&gt;sock-&gt;flags);</span>
<span class="p_add">+		/* wait for more buffer space */</span>
<span class="p_add">+		sk-&gt;sk_write_pending++;</span>
<span class="p_add">+		xprt_wait_for_buffer_space(task, xs_nospace_callback);</span>
<span class="p_add">+	} else</span>
 		ret = -ENOTCONN;
<span class="p_del">-	}</span>
 
 	spin_unlock_bh(&amp;xprt-&gt;transport_lock);
 
<span class="p_chunk">@@ -616,9 +605,6 @@</span> <span class="p_context"> process_status:</span>
 	case -EAGAIN:
 		status = xs_nospace(task);
 		break;
<span class="p_del">-	default:</span>
<span class="p_del">-		dprintk(&quot;RPC:       sendmsg returned unrecognized error %d\n&quot;,</span>
<span class="p_del">-			-status);</span>
 	case -ENETUNREACH:
 	case -ENOBUFS:
 	case -EPIPE:
<span class="p_chunk">@@ -626,7 +612,10 @@</span> <span class="p_context"> process_status:</span>
 	case -EPERM:
 		/* When the server has died, an ICMP port unreachable message
 		 * prompts ECONNREFUSED. */
<span class="p_del">-		clear_bit(SOCKWQ_ASYNC_NOSPACE, &amp;transport-&gt;sock-&gt;flags);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		dprintk(&quot;RPC:       sendmsg returned unrecognized error %d\n&quot;,</span>
<span class="p_add">+			-status);</span>
 	}
 
 	return status;
<span class="p_chunk">@@ -706,16 +695,16 @@</span> <span class="p_context"> static int xs_tcp_send_request(struct rpc_task *task)</span>
 	case -EAGAIN:
 		status = xs_nospace(task);
 		break;
<span class="p_del">-	default:</span>
<span class="p_del">-		dprintk(&quot;RPC:       sendmsg returned unrecognized error %d\n&quot;,</span>
<span class="p_del">-			-status);</span>
 	case -ECONNRESET:
 	case -ECONNREFUSED:
 	case -ENOTCONN:
 	case -EADDRINUSE:
 	case -ENOBUFS:
 	case -EPIPE:
<span class="p_del">-		clear_bit(SOCKWQ_ASYNC_NOSPACE, &amp;transport-&gt;sock-&gt;flags);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		dprintk(&quot;RPC:       sendmsg returned unrecognized error %d\n&quot;,</span>
<span class="p_add">+			-status);</span>
 	}
 
 	return status;
<span class="p_chunk">@@ -1609,19 +1598,23 @@</span> <span class="p_context"> static void xs_tcp_state_change(struct sock *sk)</span>
 
 static void xs_write_space(struct sock *sk)
 {
<span class="p_del">-	struct socket *sock;</span>
<span class="p_add">+	struct socket_wq *wq;</span>
 	struct rpc_xprt *xprt;
 
<span class="p_del">-	if (unlikely(!(sock = sk-&gt;sk_socket)))</span>
<span class="p_add">+	if (!sk-&gt;sk_socket)</span>
 		return;
<span class="p_del">-	clear_bit(SOCK_NOSPACE, &amp;sock-&gt;flags);</span>
<span class="p_add">+	clear_bit(SOCK_NOSPACE, &amp;sk-&gt;sk_socket-&gt;flags);</span>
 
 	if (unlikely(!(xprt = xprt_from_sock(sk))))
 		return;
<span class="p_del">-	if (test_and_clear_bit(SOCKWQ_ASYNC_NOSPACE, &amp;sock-&gt;flags) == 0)</span>
<span class="p_del">-		return;</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	wq = rcu_dereference(sk-&gt;sk_wq);</span>
<span class="p_add">+	if (!wq || test_and_clear_bit(SOCKWQ_ASYNC_NOSPACE, &amp;wq-&gt;flags) == 0)</span>
<span class="p_add">+		goto out;</span>
 
 	xprt_write_space(xprt);
<span class="p_add">+out:</span>
<span class="p_add">+	rcu_read_unlock();</span>
 }
 
 /**
<span class="p_header">diff --git a/scripts/bloat-o-meter b/scripts/bloat-o-meter</span>
<span class="p_header">index 23e78dcd12bf..38b64f487315 100755</span>
<span class="p_header">--- a/scripts/bloat-o-meter</span>
<span class="p_header">+++ b/scripts/bloat-o-meter</span>
<span class="p_chunk">@@ -58,8 +58,8 @@</span> <span class="p_context"> for name in common:</span>
 delta.sort()
 delta.reverse()
 
<span class="p_del">-print &quot;add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)&quot; % \</span>
<span class="p_del">-      (add, remove, grow, shrink, up, -down, up-down)</span>
<span class="p_del">-print &quot;%-40s %7s %7s %+7s&quot; % (&quot;function&quot;, &quot;old&quot;, &quot;new&quot;, &quot;delta&quot;)</span>
<span class="p_add">+print(&quot;add/remove: %s/%s grow/shrink: %s/%s up/down: %s/%s (%s)&quot; % \</span>
<span class="p_add">+      (add, remove, grow, shrink, up, -down, up-down))</span>
<span class="p_add">+print(&quot;%-40s %7s %7s %+7s&quot; % (&quot;function&quot;, &quot;old&quot;, &quot;new&quot;, &quot;delta&quot;))</span>
 for d, n in delta:
<span class="p_del">-    if d: print &quot;%-40s %7s %7s %+7d&quot; % (n, old.get(n,&quot;-&quot;), new.get(n,&quot;-&quot;), d)</span>
<span class="p_add">+    if d: print(&quot;%-40s %7s %7s %+7d&quot; % (n, old.get(n,&quot;-&quot;), new.get(n,&quot;-&quot;), d))</span>
<span class="p_header">diff --git a/security/commoncap.c b/security/commoncap.c</span>
<span class="p_header">index 1832cf701c3d..48071ed7c445 100644</span>
<span class="p_header">--- a/security/commoncap.c</span>
<span class="p_header">+++ b/security/commoncap.c</span>
<span class="p_chunk">@@ -137,12 +137,17 @@</span> <span class="p_context"> int cap_ptrace_access_check(struct task_struct *child, unsigned int mode)</span>
 {
 	int ret = 0;
 	const struct cred *cred, *child_cred;
<span class="p_add">+	const kernel_cap_t *caller_caps;</span>
 
 	rcu_read_lock();
 	cred = current_cred();
 	child_cred = __task_cred(child);
<span class="p_add">+	if (mode &amp; PTRACE_MODE_FSCREDS)</span>
<span class="p_add">+		caller_caps = &amp;cred-&gt;cap_effective;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		caller_caps = &amp;cred-&gt;cap_permitted;</span>
 	if (cred-&gt;user_ns == child_cred-&gt;user_ns &amp;&amp;
<span class="p_del">-	    cap_issubset(child_cred-&gt;cap_permitted, cred-&gt;cap_permitted))</span>
<span class="p_add">+	    cap_issubset(child_cred-&gt;cap_permitted, *caller_caps))</span>
 		goto out;
 	if (ns_capable(child_cred-&gt;user_ns, CAP_SYS_PTRACE))
 		goto out;
<span class="p_header">diff --git a/sound/core/pcm_native.c b/sound/core/pcm_native.c</span>
<span class="p_header">index a8b27cdc2844..4ba64fd49759 100644</span>
<span class="p_header">--- a/sound/core/pcm_native.c</span>
<span class="p_header">+++ b/sound/core/pcm_native.c</span>
<span class="p_chunk">@@ -74,6 +74,18 @@</span> <span class="p_context"> static int snd_pcm_open(struct file *file, struct snd_pcm *pcm, int stream);</span>
 static DEFINE_RWLOCK(snd_pcm_link_rwlock);
 static DECLARE_RWSEM(snd_pcm_link_rwsem);
 
<span class="p_add">+/* Writer in rwsem may block readers even during its waiting in queue,</span>
<span class="p_add">+ * and this may lead to a deadlock when the code path takes read sem</span>
<span class="p_add">+ * twice (e.g. one in snd_pcm_action_nonatomic() and another in</span>
<span class="p_add">+ * snd_pcm_stream_lock()).  As a (suboptimal) workaround, let writer to</span>
<span class="p_add">+ * spin until it gets the lock.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void down_write_nonblock(struct rw_semaphore *lock)</span>
<span class="p_add">+{</span>
<span class="p_add">+	while (!down_write_trylock(lock))</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * snd_pcm_stream_lock - Lock the PCM stream
  * @substream: PCM substream
<span class="p_chunk">@@ -1813,7 +1825,7 @@</span> <span class="p_context"> static int snd_pcm_link(struct snd_pcm_substream *substream, int fd)</span>
 		res = -ENOMEM;
 		goto _nolock;
 	}
<span class="p_del">-	down_write(&amp;snd_pcm_link_rwsem);</span>
<span class="p_add">+	down_write_nonblock(&amp;snd_pcm_link_rwsem);</span>
 	write_lock_irq(&amp;snd_pcm_link_rwlock);
 	if (substream-&gt;runtime-&gt;status-&gt;state == SNDRV_PCM_STATE_OPEN ||
 	    substream-&gt;runtime-&gt;status-&gt;state != substream1-&gt;runtime-&gt;status-&gt;state ||
<span class="p_chunk">@@ -1860,7 +1872,7 @@</span> <span class="p_context"> static int snd_pcm_unlink(struct snd_pcm_substream *substream)</span>
 	struct snd_pcm_substream *s;
 	int res = 0;
 
<span class="p_del">-	down_write(&amp;snd_pcm_link_rwsem);</span>
<span class="p_add">+	down_write_nonblock(&amp;snd_pcm_link_rwsem);</span>
 	write_lock_irq(&amp;snd_pcm_link_rwlock);
 	if (!snd_pcm_stream_linked(substream)) {
 		res = -EALREADY;
<span class="p_header">diff --git a/sound/core/seq/seq_memory.c b/sound/core/seq/seq_memory.c</span>
<span class="p_header">index 801076687bb1..c850345c43b5 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_memory.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_memory.c</span>
<span class="p_chunk">@@ -383,15 +383,20 @@</span> <span class="p_context"> int snd_seq_pool_init(struct snd_seq_pool *pool)</span>
 
 	if (snd_BUG_ON(!pool))
 		return -EINVAL;
<span class="p_del">-	if (pool-&gt;ptr)			/* should be atomic? */</span>
<span class="p_del">-		return 0;</span>
 
<span class="p_del">-	pool-&gt;ptr = vmalloc(sizeof(struct snd_seq_event_cell) * pool-&gt;size);</span>
<span class="p_del">-	if (!pool-&gt;ptr)</span>
<span class="p_add">+	cellptr = vmalloc(sizeof(struct snd_seq_event_cell) * pool-&gt;size);</span>
<span class="p_add">+	if (!cellptr)</span>
 		return -ENOMEM;
 
 	/* add new cells to the free cell list */
 	spin_lock_irqsave(&amp;pool-&gt;lock, flags);
<span class="p_add">+	if (pool-&gt;ptr) {</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;pool-&gt;lock, flags);</span>
<span class="p_add">+		vfree(cellptr);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pool-&gt;ptr = cellptr;</span>
 	pool-&gt;free = NULL;
 
 	for (cell = 0; cell &lt; pool-&gt;size; cell++) {
<span class="p_header">diff --git a/sound/core/seq/seq_ports.c b/sound/core/seq/seq_ports.c</span>
<span class="p_header">index 921fb2bd8fad..fe686ee41c6d 100644</span>
<span class="p_header">--- a/sound/core/seq/seq_ports.c</span>
<span class="p_header">+++ b/sound/core/seq/seq_ports.c</span>
<span class="p_chunk">@@ -535,19 +535,22 @@</span> <span class="p_context"> static void delete_and_unsubscribe_port(struct snd_seq_client *client,</span>
 					bool is_src, bool ack)
 {
 	struct snd_seq_port_subs_info *grp;
<span class="p_add">+	struct list_head *list;</span>
<span class="p_add">+	bool empty;</span>
 
 	grp = is_src ? &amp;port-&gt;c_src : &amp;port-&gt;c_dest;
<span class="p_add">+	list = is_src ? &amp;subs-&gt;src_list : &amp;subs-&gt;dest_list;</span>
 	down_write(&amp;grp-&gt;list_mutex);
 	write_lock_irq(&amp;grp-&gt;list_lock);
<span class="p_del">-	if (is_src)</span>
<span class="p_del">-		list_del(&amp;subs-&gt;src_list);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		list_del(&amp;subs-&gt;dest_list);</span>
<span class="p_add">+	empty = list_empty(list);</span>
<span class="p_add">+	if (!empty)</span>
<span class="p_add">+		list_del_init(list);</span>
 	grp-&gt;exclusive = 0;
 	write_unlock_irq(&amp;grp-&gt;list_lock);
 	up_write(&amp;grp-&gt;list_mutex);
 
<span class="p_del">-	unsubscribe_port(client, port, grp, &amp;subs-&gt;info, ack);</span>
<span class="p_add">+	if (!empty)</span>
<span class="p_add">+		unsubscribe_port(client, port, grp, &amp;subs-&gt;info, ack);</span>
 }
 
 /* connect two ports */
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 02a86ba5ba22..2c13298e80b7 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2143,10 +2143,10 @@</span> <span class="p_context"> static void azx_remove(struct pci_dev *pci)</span>
 	struct hda_intel *hda;
 
 	if (card) {
<span class="p_del">-		/* flush the pending probing work */</span>
<span class="p_add">+		/* cancel the pending probing work */</span>
 		chip = card-&gt;private_data;
 		hda = container_of(chip, struct hda_intel, chip);
<span class="p_del">-		flush_work(&amp;hda-&gt;probe_work);</span>
<span class="p_add">+		cancel_work_sync(&amp;hda-&gt;probe_work);</span>
 
 		snd_card_free(card);
 	}
<span class="p_header">diff --git a/tools/lib/traceevent/event-parse.c b/tools/lib/traceevent/event-parse.c</span>
<span class="p_header">index 2a912df6771b..68276f35e323 100644</span>
<span class="p_header">--- a/tools/lib/traceevent/event-parse.c</span>
<span class="p_header">+++ b/tools/lib/traceevent/event-parse.c</span>
<span class="p_chunk">@@ -4968,13 +4968,12 @@</span> <span class="p_context"> static void pretty_print(struct trace_seq *s, void *data, int size, struct event</span>
 				    sizeof(long) != 8) {
 					char *p;
 
<span class="p_del">-					ls = 2;</span>
 					/* make %l into %ll */
<span class="p_del">-					p = strchr(format, &#39;l&#39;);</span>
<span class="p_del">-					if (p)</span>
<span class="p_add">+					if (ls == 1 &amp;&amp; (p = strchr(format, &#39;l&#39;)))</span>
 						memmove(p+1, p, strlen(p)+1);
 					else if (strcmp(format, &quot;%p&quot;) == 0)
 						strcpy(format, &quot;0x%llx&quot;);
<span class="p_add">+					ls = 2;</span>
 				}
 				switch (ls) {
 				case -2:
<span class="p_header">diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c</span>
<span class="p_header">index 6fc8cd753e1a..b48e87693aa5 100644</span>
<span class="p_header">--- a/tools/perf/util/parse-events.c</span>
<span class="p_header">+++ b/tools/perf/util/parse-events.c</span>
<span class="p_chunk">@@ -399,6 +399,9 @@</span> <span class="p_context"> static void tracepoint_error(struct parse_events_error *e, int err,</span>
 {
 	char help[BUFSIZ];
 
<span class="p_add">+	if (!e)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * We get error directly from syscall errno ( &gt; 0),
 	 * or from encoded pointer&#39;s error ( &lt; 0).
<span class="p_header">diff --git a/tools/perf/util/session.c b/tools/perf/util/session.c</span>
<span class="p_header">index c35ffdd360fe..468de95bc8bb 100644</span>
<span class="p_header">--- a/tools/perf/util/session.c</span>
<span class="p_header">+++ b/tools/perf/util/session.c</span>
<span class="p_chunk">@@ -972,7 +972,7 @@</span> <span class="p_context"> static struct machine *machines__find_for_cpumode(struct machines *machines,</span>
 
 		machine = machines__find(machines, pid);
 		if (!machine)
<span class="p_del">-			machine = machines__find(machines, DEFAULT_GUEST_KERNEL_ID);</span>
<span class="p_add">+			machine = machines__findnew(machines, DEFAULT_GUEST_KERNEL_ID);</span>
 		return machine;
 	}
 
<span class="p_header">diff --git a/virt/kvm/arm/arch_timer.c b/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">index 69bca185c471..ea6064696fe4 100644</span>
<span class="p_header">--- a/virt/kvm/arm/arch_timer.c</span>
<span class="p_header">+++ b/virt/kvm/arm/arch_timer.c</span>
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> static void kvm_timer_update_irq(struct kvm_vcpu *vcpu, bool new_level)</span>
  * Check if there was a change in the timer state (should we raise or lower
  * the line level to the GIC).
  */
<span class="p_del">-static void kvm_timer_update_state(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+static int kvm_timer_update_state(struct kvm_vcpu *vcpu)</span>
 {
 	struct arch_timer_cpu *timer = &amp;vcpu-&gt;arch.timer_cpu;
 
<span class="p_chunk">@@ -154,10 +154,12 @@</span> <span class="p_context"> static void kvm_timer_update_state(struct kvm_vcpu *vcpu)</span>
 	 * until we call this function from kvm_timer_flush_hwstate.
 	 */
 	if (!vgic_initialized(vcpu-&gt;kvm))
<span class="p_del">-	    return;</span>
<span class="p_add">+		return -ENODEV;</span>
 
 	if (kvm_timer_should_fire(vcpu) != timer-&gt;irq.level)
 		kvm_timer_update_irq(vcpu, !timer-&gt;irq.level);
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -218,7 +220,8 @@</span> <span class="p_context"> void kvm_timer_flush_hwstate(struct kvm_vcpu *vcpu)</span>
 	bool phys_active;
 	int ret;
 
<span class="p_del">-	kvm_timer_update_state(vcpu);</span>
<span class="p_add">+	if (kvm_timer_update_state(vcpu))</span>
<span class="p_add">+		return;</span>
 
 	/*
 	* If we enter the guest with the virtual input level to the VGIC

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



