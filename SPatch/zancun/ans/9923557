
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.47 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.47</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 26, 2017, 4:21 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170826162132.GL18698@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9923557/mbox/"
   >mbox</a>
|
   <a href="/patch/9923557/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9923557/">/patch/9923557/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	1E06D6022E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 26 Aug 2017 16:22:10 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E35FD285D8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 26 Aug 2017 16:22:09 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D7423285DC; Sat, 26 Aug 2017 16:22:09 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8E345285DA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 26 Aug 2017 16:22:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751194AbdHZQVv (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 26 Aug 2017 12:21:51 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:56852 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751062AbdHZQVn (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 26 Aug 2017 12:21:43 -0400
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1dldq0-0003C9-Ih; Sat, 26 Aug 2017 17:21:39 +0100
Date: Sat, 26 Aug 2017 17:21:32 +0100
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20170826162132.GL18698@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;dJyWBSYfjLochwFK&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.47
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Aug. 26, 2017, 4:21 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.47 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.46 is attached to this message.

Ben.

------------

 Makefile                                           |  2 +-
 arch/arm/boot/dts/at91-sama5d3_xplained.dts        |  5 +-
 arch/arm/kvm/psci.c                                |  8 +-
 arch/arm64/include/asm/barrier.h                   | 12 ++-
 arch/arm64/include/asm/kvm_emulate.h               |  6 ++
 arch/arm64/include/asm/uaccess.h                   |  3 +-
 arch/arm64/kvm/sys_regs.c                          |  8 +-
 arch/metag/include/asm/uaccess.h                   | 49 +++++++-----
 arch/powerpc/include/asm/qe.h                      |  1 +
 arch/powerpc/kernel/eeh_driver.c                   | 19 ++++-
 arch/powerpc/kernel/sysfs.c                        |  6 ++
 arch/powerpc/platforms/pseries/dlpar.c             |  1 -
 arch/x86/boot/boot.h                               |  2 +-
 arch/x86/kernel/cpu/perf_event.h                   |  1 +
 arch/x86/kernel/cpu/perf_event_intel.c             | 31 +++++---
 arch/x86/mm/numa_32.c                              |  1 +
 arch/x86/mm/tlb.c                                  |  4 +-
 arch/x86/um/ptrace_64.c                            |  2 +-
 drivers/Makefile                                   |  1 +
 drivers/ata/libata-scsi.c                          |  8 ++
 drivers/gpu/drm/drm_edid.c                         |  8 ++
 drivers/hsi/clients/ssi_protocol.c                 |  5 +-
 drivers/iio/dac/ad7303.c                           |  6 +-
 drivers/iio/proximity/as3935.c                     |  3 +-
 drivers/infiniband/core/uverbs_cmd.c               | 13 ++-
 drivers/infiniband/core/verbs.c                    |  8 +-
 drivers/infiniband/hw/mlx4/main.c                  |  1 +
 drivers/infiniband/ulp/ipoib/ipoib_fs.c            |  9 ++-
 drivers/infiniband/ulp/ipoib/ipoib_ib.c            | 13 +++
 drivers/infiniband/ulp/ipoib/ipoib_main.c          | 44 +++++++++--
 drivers/infiniband/ulp/ipoib/ipoib_vlan.c          |  3 -
 drivers/input/misc/twl4030-pwrbutton.c             |  2 +-
 drivers/md/dm-bufio.c                              |  9 ++-
 drivers/md/dm-era-target.c                         |  8 +-
 drivers/md/dm-ioctl.c                              |  2 +-
 drivers/md/persistent-data/dm-btree.c              |  8 +-
 drivers/media/i2c/soc_camera/ov2640.c              |  6 +-
 drivers/media/platform/s5p-mfc/s5p_mfc.c           |  1 +
 drivers/media/rc/mceusb.c                          |  4 +-
 drivers/media/usb/cx231xx/cx231xx-audio.c          | 41 +++++++---
 drivers/media/usb/cx231xx/cx231xx-cards.c          | 46 +++++++++--
 drivers/media/usb/dvb-usb/dib0700_core.c           |  3 +
 drivers/media/usb/dvb-usb/digitv.c                 |  4 +
 drivers/media/usb/dvb-usb/dw2102.c                 | 54 +++++++++++++
 drivers/media/usb/dvb-usb/ttusb2.c                 | 19 +++++
 drivers/media/usb/gspca/konica.c                   |  3 +
 drivers/media/usb/pvrusb2/pvrusb2-eeprom.c         | 13 +--
 drivers/media/usb/usbvision/usbvision-video.c      |  9 ++-
 drivers/media/usb/uvc/uvc_video.c                  |  2 +-
 drivers/media/usb/zr364xx/zr364xx.c                |  8 ++
 drivers/mfd/omap-usb-tll.c                         |  2 +-
 drivers/mtd/nand/fsmc_nand.c                       |  9 ++-
 drivers/net/ethernet/broadcom/tg3.c                |  4 -
 drivers/net/ethernet/freescale/ucc_geth.c          |  8 +-
 drivers/net/ethernet/mellanox/mlx4/en_rx.c         |  3 +-
 drivers/net/ethernet/mellanox/mlx4/mcg.c           | 15 +++-
 drivers/net/ethernet/mellanox/mlx4/qp.c            | 13 +++
 drivers/net/virtio_net.c                           | 30 ++++++-
 drivers/net/wireless/ath/ath9k/eeprom.c            |  2 +-
 drivers/net/wireless/ath/ath9k/hif_usb.c           |  7 ++
 drivers/net/wireless/mwifiex/pcie.c                |  7 ++
 drivers/net/wireless/zd1211rw/zd_usb.c             |  3 +
 drivers/of/address.c                               |  2 +-
 drivers/pci/host/pcie-designware.c                 | 28 +++----
 drivers/pci/pci-sysfs.c                            | 10 ++-
 drivers/pci/pci.c                                  |  9 ++-
 drivers/pci/proc.c                                 | 20 ++++-
 drivers/pci/quirks.c                               | 24 ++++++
 drivers/pinctrl/sh-pfc/core.c                      |  3 +
 drivers/pinctrl/sh-pfc/pfc-r8a7791.c               | 18 +++--
 drivers/power/isp1704_charger.c                    |  4 +
 drivers/power/lp8788-charger.c                     |  2 +-
 drivers/power/pda_power.c                          | 49 ++++++------
 drivers/regulator/tps65023-regulator.c             |  3 +-
 drivers/scsi/scsi_error.c                          | 18 +++++
 drivers/scsi/sd.c                                  | 27 ++++++-
 drivers/scsi/sd.h                                  |  1 +
 drivers/staging/comedi/drivers/jr3_pci.c           | 13 +--
 drivers/staging/gdm724x/gdm_mux.c                  | 21 +----
 drivers/staging/iio/light/tsl2x7x_core.c           |  2 +-
 drivers/staging/media/lirc/lirc_serial.c           |  4 +-
 drivers/staging/rtl8188eu/core/rtw_ap.c            |  2 +-
 drivers/target/target_core_file.c                  |  3 +-
 drivers/tty/serial/omap-serial.c                   |  9 ++-
 drivers/tty/serial/sh-sci.c                        | 10 ++-
 drivers/usb/class/cdc-acm.c                        | 13 ++-
 drivers/usb/core/driver.c                          | 21 +++++
 drivers/usb/core/file.c                            |  9 ++-
 drivers/usb/core/hub.c                             | 11 ++-
 drivers/usb/host/xhci-mem.c                        |  2 +-
 drivers/usb/misc/legousbtower.c                    | 38 ++++++---
 drivers/usb/serial/ftdi_sio.c                      |  1 +
 drivers/usb/serial/ftdi_sio_ids.h                  |  6 ++
 drivers/vfio/vfio_iommu_type1.c                    | 92 ++++++++++------------
 drivers/video/Makefile                             |  1 +
 drivers/video/fbdev/Kconfig                        |  2 -
 fs/ceph/xattr.c                                    |  3 +
 fs/cifs/cifsfs.c                                   | 15 +++-
 fs/cifs/cifsglob.h                                 |  1 +
 fs/cifs/cifssmb.c                                  |  3 +
 fs/cifs/misc.c                                     |  2 +-
 fs/cifs/netmisc.c                                  |  6 +-
 fs/cifs/smb2misc.c                                 |  5 +-
 fs/cifs/smb2pdu.c                                  | 14 +++-
 fs/dcache.c                                        | 37 +++++++++
 fs/debugfs/inode.c                                 | 10 +--
 fs/ext4/inode.c                                    |  5 ++
 fs/namei.c                                         | 10 +--
 fs/nfs/pagelist.c                                  | 10 ++-
 fs/nfsd/vfs.c                                      |  2 +-
 fs/notify/fanotify/fanotify_user.c                 | 26 ++++--
 fs/notify/fsnotify.c                               |  8 +-
 fs/timerfd.c                                       | 17 +++-
 fs/xattr.c                                         |  2 +-
 include/linux/dcache.h                             |  7 ++
 include/linux/fsnotify.h                           | 31 --------
 include/linux/ima.h                                |  4 +-
 include/linux/mlx4/qp.h                            |  1 +
 include/scsi/scsi_driver.h                         |  1 +
 include/uapi/linux/netfilter/nf_conntrack_common.h |  9 +++
 ipc/mqueue.c                                       |  4 +-
 kernel/locking/lockdep.c                           |  4 +-
 kernel/padata.c                                    |  2 +-
 kernel/trace/ftrace.c                              | 14 +++-
 net/bluetooth/hci_sock.c                           |  3 +-
 net/ipv4/ip_output.c                               |  7 +-
 net/ipv4/tcp_lp.c                                  |  6 +-
 net/ipv4/udp.c                                     |  2 +-
 net/ipv6/exthdrs.c                                 |  1 +
 net/ipv6/ip6_output.c                              |  7 +-
 net/ipv6/ip6_tunnel.c                              |  4 +-
 net/ipv6/ndisc.c                                   |  2 +
 net/ipv6/output_core.c                             |  8 +-
 net/netfilter/nf_conntrack_netlink.c               | 60 ++++++++------
 net/packet/af_packet.c                             | 13 ++-
 security/integrity/ima/ima.h                       |  4 +-
 security/integrity/ima/ima_appraise.c              |  7 +-
 security/integrity/ima/ima_main.c                  | 14 ++--
 tools/perf/builtin-inject.c                        |  2 +
 tools/perf/ui/browsers/hists.c                     |  2 +-
 140 files changed, 1056 insertions(+), 445 deletions(-)

Adrian Salido (1):
      dm ioctl: prevent stack leak in dm ioctl call

Ajay Kaher (1):
      USB: Proper handling of Race Condition when two USB class drivers try to call init_usb_class simultaneously

Al Viro (1):
      dentry name snapshots

Alex Williamson (1):
      vfio/type1: Remove locked page accounting workqueue

Alexander Tsoy (1):
      ath9k_htc: add device ID for Toshiba WLM-20U2/GN-1080

Alexey Brodkin (1):
      usb: Make sure usb/phy/of gets built-in

Alyssa Milburn (4):
      digitv: limit messages to buffer size
      zr364xx: enforce minimum size when reading header
      ttusb2: limit messages to buffer size
      dw2102: limit messages to buffer size

Amir Goldstein (1):
      fanotify: don&#39;t expose EOPENSTALE to userspace

Amitoj Kaur Chawla (1):
      staging: gdm724x: gdm_mux: Remove create_workqueue()

Andrew Jones (1):
      KVM: arm/arm64: fix races in kvm_psci_vcpu_on

Andy Lutomirski (1):
      x86/mm: Fix flush_tlb_page() on Xen

Arnd Bergmann (2):
      pvrusb2: reduce stack usage pvr2_eeprom_analyze()
      fbdev: sti: don&#39;t select CONFIG_VT

Ashish Kalra (1):
      x86/boot: Fix BSS corruption/overwrite bug in early x86 kernel startup

Bart Van Assche (1):
      target/fileio: Fix zero-length READ and WRITE handling

Ben Hutchings (1):
      Linux 3.16.47

Benjamin Coddington (1):
      NFS: Use GFP_NOIO for two allocations in writeback

Bjorn Helgaas (2):
      PCI: dwc: Unindent dw_handle_msi_irq() loop
      PCI: Ignore write combining when mapping I/O port space

Brian Norris (1):
      mwifiex: pcie: fix cmd_buf use-after-free in remove/reset

Changbin Du (1):
      perf hists browser: Fix typo in function switch_data_file

Christoph Hellwig (1):
      libata: reject passthrough WRITE SAME requests

Christophe Leroy (1):
      net: ethernet: ucc_geth: fix MEM_PART_MURAM mode

Cong Wang (1):
      mqueue: fix a use-after-free in sys_mq_notify()

Craig Gallek (1):
      ip6_tunnel: Fix missing tunnel encapsulation limit option

Dan Carpenter (5):
      PCI: dwc: Fix uninitialized variable in dw_handle_msi_irq()
      ath9k: off by one in ath9k_hw_nvram_read_array()
      HSI: ssi_protocol: double free in ssip_pn_xmit()
      staging: rtl8188eu: prevent an underflow in rtw_check_beacon_data()
      cifs: small underflow in cnvrtDosUnixTm()

Daniel Glöckner (1):
      ima: accept previously set IMA_NEW_FILE

David Ahern (1):
      net: ipv6: send unsolicited NA on admin up

David Carrillo-Cisneros (1):
      perf inject: Don&#39;t proceed if perf_session__process_event() fails

David S. Miller (1):
      ipv6: Need to export ipv6_push_frag_opts for tunneling now.

David Woodhouse (3):
      PCI: Fix pci_mmap_fits() for HAVE_PCI_RESOURCE_TO_USER platforms
      PCI: Fix another sanity check bug in /proc/pci mmap
      PCI: Only allow WC mmap on prefetchable resources

Dmitry Kasatkin (1):
      ima: pass &#39;opened&#39; flag to identify newly created files

Dmitry Tunin (1):
      ath9k_htc: Add support of AirTies 1eda:2315 AR9271 device

Eric Biggers (1):
      ext4: evict inline data when writing to memory map

Eric Dumazet (1):
      tcp: fix wraparound issue in tcp_lp

Eva Rachel Retuya (1):
      staging: iio: tsl2x7x_core: Fix standard deviation calculation

Fabian Frederick (1):
      IPoIB: Remove unnecessary test for NULL before debugfs_remove()

Feras Daoud (1):
      IB/ipoib: Update broadcast object if PKey value was changed in index 0

Frank Schaefer (1):
      ov2640: fix vflip control

Geert Uytterhoeven (1):
      pinctrl: sh-pfc: Update info pointer after SoC-specific init

Giedrius Statkevičius (1):
      power: supply: lp8788: prevent out of bounds array access

Guenter Roeck (2):
      usb: hub: Fix error loop seen after hub communication errors
      usb: hub: Do not attempt to autosuspend disconnected devices

Hannes Reinecke (1):
      scsi: scsi_error: count medium access timeout only once per EH run

Ian Abbott (2):
      staging: comedi: jr3_pci: fix possible null pointer dereference
      staging: comedi: jr3_pci: cope with jiffies wraparound

Jack Morgenstein (1):
      IB/mlx4: Fix ib device initialization error flow

James Hogan (2):
      metag/uaccess: Fix access_ok()
      metag/uaccess: Check access_ok in strncpy_from_user

Jason A. Donenfeld (1):
      padata: free correct variable

Johan Hovold (12):
      zd1211rw: fix NULL-deref at probe
      mceusb: fix NULL-deref at probe
      ath9k_htc: fix NULL-deref at probe
      gspca: konica: add missing endpoint sanity check
      dib0700: fix NULL-deref at probe
      usbvision: fix NULL-deref at probe
      cx231xx-cards: fix NULL-deref at probe
      cx231xx-audio: fix init error path
      cx231xx-audio: fix NULL-deref at probe
      serial: omap: fix runtime-pm handling on unbind
      serial: omap: suspend device on probe errors
      staging: gdm724x: gdm_mux: fix use-after-free on module unload

Kamal Heib (1):
      net/mlx4_en: Change the error print to debug print

Kan Liang (1):
      perf/x86: Fix spurious NMI with PEBS Load Latency event

Kieran Bingham (1):
      uvcvideo: Fix empty packet statistic

Laura Abbott (1):
      x86/mm/32: Set the &#39;__vmalloc_start_set&#39; flag in initmem_init()

Leon Nardella (1):
      ath9k_htc: Add new USB ID

Liping Zhang (2):
      netfilter: ctnetlink: fix deadlock due to acquire _expect_lock twice
      netfilter: ctnetlink: make it safer when updating ct-&gt;status

Ludovic Desroches (2):
      ARM: dts: at91: sama5d3_xplained: fix ADC vref
      ARM: dts: at91: sama5d3_xplained: not all ADC channels are available

Luis Henriques (1):
      ceph: fix memory leak in __ceph_setxattr()

Lukas Wunner (1):
      PCI: Freeze PME scan before suspending devices

Maksim Salau (2):
      usb: misc: legousbtower: Fix buffers on stack
      usb: misc: legousbtower: Fix memory leak

Marc Zyngier (1):
      arm64: KVM: Fix decoding of Rt/Rt2 when trapping AArch32 CP accesses

Marek Szyprowski (1):
      s5p-mfc: Fix unbalanced call to clock management

Marek Vasut (1):
      USB: serial: ftdi_sio: add device ID for Microsemi/Arrow SF2PLUS Dev Kit

Mario Kleiner (1):
      drm/edid: Add 10 bpc quirk for LGD 764 panel in HP zBook 17 G2

Mark Rutland (2):
      arm64: ensure extension of smp_store_release value
      arm64: uaccess: ensure extension of access_ok() addr

Matt Ranostay (1):
      iio: proximity: as3935: fix as3935_write

Michael J. Ruhl (2):
      IB/core: If the MGID/MLID pair is not on the list return an error
      IB/core: For multicast functions, verify that LIDs are multicast LIDs

Michael S. Tsirkin (1):
      virtio_net: fix support for small rings

Michael Trimarchi (1):
      power: supply: pda_power: move from timer to delayed_work

Michal Hocko (1):
      fs/xattr.c: zero out memory copied to userspace in getxattr

Mikulas Patocka (1):
      dm bufio: avoid a possible ABBA deadlock

Nikolay Borisov (1):
      lockdep: teach lockdep about memalloc_noio_save

Pan Bian (1):
      power: supply: isp1704: Fix unchecked return value of devm_kzalloc

Pavel Roskin (1):
      iio: dac: ad7303: fix channel description

Peter Chen (1):
      usb: host: xhci: print correct command ring address

Rabin Vincent (1):
      CIFS: fix oplock break deadlocks

Richard Cochran (1):
      regulator: tps65023: Fix inverted core enable logic.

Richard Weinberger (1):
      um: Fix PTRACE_POKEUSER on x86_64

Rob Herring (1):
      of: fix sparse warning in of_pci_range_parser_one

Russell Currey (1):
      powerpc/eeh: Avoid use after free in eeh_handle_special_event()

Sabrina Dubroca (1):
      ipv6: avoid overflow of offset in ip6_find_1stfragopt

Sean Young (1):
      serial_ir: iommap is a memory address, not bool

Sebastian Reichel (1):
      Input: twl4030-pwrbutton - use correct device for irq request

Sergei Shtylyov (4):
      pinctrl: sh-pfc: r8a7791: Add missing HSCIF1 pinmux data
      pinctrl: sh-pfc: r8a7791: Add missing DVC_MUTE signal
      pinctrl: sh-pfc: r8a7791: Fix SCIF2 pinmux data
      pinctrl: sh-pfc: r8a7791: Fix IPSR comment typos

Shamir Rabinovitch (1):
      IB/IPoIB: ibX: failed to create mcg debug file

Somasundaram Krishnasamy (1):
      dm era: save spacemap metadata root after the pre-commit

Stefan Assmann (1):
      PCI: Disable boot interrupt quirk for ASUS M2N-LR

Stephane Eranian (1):
      perf/x86/pebs: Fix handling of PEBS buffer overflows

Steve French (2):
      Set unicode flag on cifs echo request to avoid Mac error
      SMB3: Work around mount failure when using SMB3 dialect to Macs

Steven Rostedt (VMware) (1):
      ftrace: Fix removing of second function probe

Szymon Janc (1):
      Bluetooth: Fix user channel for 32bit userspace on 64bit kernel

Takatoshi Akiyama (1):
      serial: sh-sci: Fix panic when serial console and DMA are enabled

Talat Batheesh (2):
      net/mlx4_en: Avoid adding steering rules with invalid ring
      net/mlx4: Fix the check in attaching steering rules

Thomas Gleixner (1):
      timerfd: Protect the might cancel mechanism proper

Thomas Petazzoni (1):
      mtd: nand: fsmc: fix NAND width handling

Tobias Herzog (1):
      cdc-acm: fix possible invalid access when processing notification

Tony Lindgren (1):
      mfd: omap-usb-tll: Fix inverted bit use for USB TLL mode

Tyrel Datwyler (2):
      powerpc/pseries: Fix of_node_put() underflow during DLPAR remove
      powerpc/sysfs: Fix reference leak of cpu device_nodes present at boot

Vinothkumar Raja (1):
      dm btree: fix for dm_btree_find_lowest_key()

Willem de Bruijn (2):
      packet: fix tp_reserve race in packet_set_ring
      udp: consistently apply ufo or fragmentation

YueHaibing (1):
      tg3: don&#39;t clear stats while tg3_close

Zheng Li (1):
      ipv6: Should use consistent conditional judgement for ip6 fragment between __ip6_append_data and ip6_finish_output
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index dcff3d828383..feec4287aa87 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 46</span>
<span class="p_add">+SUBLEVEL = 47</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d3_xplained.dts b/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_header">index 5b8e40400bec..d6ca9df52fde 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d3_xplained.dts</span>
<span class="p_chunk">@@ -141,9 +141,10 @@</span> <span class="p_context"></span>
 			};
 
 			adc0: adc@f8018000 {
<span class="p_add">+				atmel,adc-vref = &lt;3300&gt;;</span>
<span class="p_add">+				atmel,adc-channels-used = &lt;0xfe&gt;;</span>
 				pinctrl-0 = &lt;
 					&amp;pinctrl_adc0_adtrg
<span class="p_del">-					&amp;pinctrl_adc0_ad0</span>
 					&amp;pinctrl_adc0_ad1
 					&amp;pinctrl_adc0_ad2
 					&amp;pinctrl_adc0_ad3
<span class="p_chunk">@@ -151,8 +152,6 @@</span> <span class="p_context"></span>
 					&amp;pinctrl_adc0_ad5
 					&amp;pinctrl_adc0_ad6
 					&amp;pinctrl_adc0_ad7
<span class="p_del">-					&amp;pinctrl_adc0_ad8</span>
<span class="p_del">-					&amp;pinctrl_adc0_ad9</span>
 					&gt;;
 				status = &quot;okay&quot;;
 			};
<span class="p_header">diff --git a/arch/arm/kvm/psci.c b/arch/arm/kvm/psci.c</span>
<span class="p_header">index 09cf37737ee2..5030facb4aaf 100644</span>
<span class="p_header">--- a/arch/arm/kvm/psci.c</span>
<span class="p_header">+++ b/arch/arm/kvm/psci.c</span>
<span class="p_chunk">@@ -191,9 +191,10 @@</span> <span class="p_context"> int kvm_psci_version(struct kvm_vcpu *vcpu)</span>
 
 static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)
 {
<span class="p_del">-	int ret = 1;</span>
<span class="p_add">+	struct kvm *kvm = vcpu-&gt;kvm;</span>
 	unsigned long psci_fn = *vcpu_reg(vcpu, 0) &amp; ~((u32) 0);
 	unsigned long val;
<span class="p_add">+	int ret = 1;</span>
 
 	switch (psci_fn) {
 	case PSCI_0_2_FN_PSCI_VERSION:
<span class="p_chunk">@@ -213,7 +214,9 @@</span> <span class="p_context"> static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)</span>
 		break;
 	case PSCI_0_2_FN_CPU_ON:
 	case PSCI_0_2_FN64_CPU_ON:
<span class="p_add">+		mutex_lock(&amp;kvm-&gt;lock);</span>
 		val = kvm_psci_vcpu_on(vcpu);
<span class="p_add">+		mutex_unlock(&amp;kvm-&gt;lock);</span>
 		break;
 	case PSCI_0_2_FN_AFFINITY_INFO:
 	case PSCI_0_2_FN64_AFFINITY_INFO:
<span class="p_chunk">@@ -269,6 +272,7 @@</span> <span class="p_context"> static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)</span>
 
 static int kvm_psci_0_1_call(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	struct kvm *kvm = vcpu-&gt;kvm;</span>
 	unsigned long psci_fn = *vcpu_reg(vcpu, 0) &amp; ~((u32) 0);
 	unsigned long val;
 
<span class="p_chunk">@@ -278,7 +282,9 @@</span> <span class="p_context"> static int kvm_psci_0_1_call(struct kvm_vcpu *vcpu)</span>
 		val = PSCI_RET_SUCCESS;
 		break;
 	case KVM_PSCI_FN_CPU_ON:
<span class="p_add">+		mutex_lock(&amp;kvm-&gt;lock);</span>
 		val = kvm_psci_vcpu_on(vcpu);
<span class="p_add">+		mutex_unlock(&amp;kvm-&gt;lock);</span>
 		break;
 	case KVM_PSCI_FN_CPU_SUSPEND:
 	case KVM_PSCI_FN_MIGRATE:
<span class="p_header">diff --git a/arch/arm64/include/asm/barrier.h b/arch/arm64/include/asm/barrier.h</span>
<span class="p_header">index 6389d60574d9..9b3172e06467 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/barrier.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/barrier.h</span>
<span class="p_chunk">@@ -58,17 +58,23 @@</span> <span class="p_context"> do {									\</span>
 #define smp_rmb()	dmb(ishld)
 #define smp_wmb()	dmb(ishst)
 
<span class="p_del">-#define smp_store_release(p, v)						\</span>
<span class="p_add">+#define smp_store_release(p, v)					\</span>
 do {									\
<span class="p_add">+	union { typeof(*p) __val; char __c[1]; } __u =			\</span>
<span class="p_add">+		{ .__val = (__force typeof(*p)) (v) }; 			\</span>
 	compiletime_assert_atomic_type(*p);				\
 	switch (sizeof(*p)) {						\
 	case 4:								\
 		asm volatile (&quot;stlr %w1, %0&quot;				\
<span class="p_del">-				: &quot;=Q&quot; (*p) : &quot;r&quot; (v) : &quot;memory&quot;);	\</span>
<span class="p_add">+				: &quot;=Q&quot; (*p)				\</span>
<span class="p_add">+				: &quot;r&quot; (*(__u32 *)__u.__c)		\</span>
<span class="p_add">+				: &quot;memory&quot;);				\</span>
 		break;							\
 	case 8:								\
 		asm volatile (&quot;stlr %1, %0&quot;				\
<span class="p_del">-				: &quot;=Q&quot; (*p) : &quot;r&quot; (v) : &quot;memory&quot;);	\</span>
<span class="p_add">+				: &quot;=Q&quot; (*p)				\</span>
<span class="p_add">+				: &quot;r&quot; (*(__u64 *)__u.__c)		\</span>
<span class="p_add">+				: &quot;memory&quot;);				\</span>
 		break;							\
 	}								\
 } while (0)
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index 2d99a58f7bf8..ef490a55cdf1 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -187,6 +187,12 @@</span> <span class="p_context"> static inline u8 kvm_vcpu_trap_get_fault(const struct kvm_vcpu *vcpu)</span>
 	return kvm_vcpu_get_hsr(vcpu) &amp; ESR_EL2_FSC_TYPE;
 }
 
<span class="p_add">+static inline int kvm_vcpu_sys_get_rt(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 esr = kvm_vcpu_get_hsr(vcpu);</span>
<span class="p_add">+	return (esr &gt;&gt; 5) &amp; 0x1f;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned long kvm_vcpu_get_mpidr(struct kvm_vcpu *vcpu)
 {
 	return vcpu_sys_reg(vcpu, MPIDR_EL1);
<span class="p_header">diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h</span>
<span class="p_header">index 3bf8f4e99a51..40d8cb5409e1 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -89,11 +89,12 @@</span> <span class="p_context"> static inline void set_fs(mm_segment_t fs)</span>
  */
 #define __range_ok(addr, size)						\
 ({									\
<span class="p_add">+	unsigned long __addr = (unsigned long __force)(addr);		\</span>
 	unsigned long flag, roksum;					\
 	__chk_user_ptr(addr);						\
 	asm(&quot;adds %1, %1, %3; ccmp %1, %4, #2, cc; cset %0, ls&quot;		\
 		: &quot;=&amp;r&quot; (flag), &quot;=&amp;r&quot; (roksum)				\
<span class="p_del">-		: &quot;1&quot; (addr), &quot;Ir&quot; (size),				\</span>
<span class="p_add">+		: &quot;1&quot; (__addr), &quot;Ir&quot; (size),				\</span>
 		  &quot;r&quot; (current_thread_info()-&gt;addr_limit)		\
 		: &quot;cc&quot;);						\
 	flag;								\
<span class="p_header">diff --git a/arch/arm64/kvm/sys_regs.c b/arch/arm64/kvm/sys_regs.c</span>
<span class="p_header">index 444e8edd71b2..9dcca0bf95de 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/sys_regs.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/sys_regs.c</span>
<span class="p_chunk">@@ -504,12 +504,12 @@</span> <span class="p_context"> int kvm_handle_cp15_64(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 {
 	struct sys_reg_params params;
 	u32 hsr = kvm_vcpu_get_hsr(vcpu);
<span class="p_del">-	int Rt2 = (hsr &gt;&gt; 10) &amp; 0xf;</span>
<span class="p_add">+	int Rt2 = (hsr &gt;&gt; 10) &amp; 0x1f;</span>
 
 	params.is_aarch32 = true;
 	params.is_32bit = false;
 	params.CRm = (hsr &gt;&gt; 1) &amp; 0xf;
<span class="p_del">-	params.Rt = (hsr &gt;&gt; 5) &amp; 0xf;</span>
<span class="p_add">+	params.Rt = kvm_vcpu_sys_get_rt(vcpu);</span>
 	params.is_write = ((hsr &amp; 1) == 0);
 
 	params.Op0 = 0;
<span class="p_chunk">@@ -554,7 +554,7 @@</span> <span class="p_context"> int kvm_handle_cp15_32(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	params.is_aarch32 = true;
 	params.is_32bit = true;
 	params.CRm = (hsr &gt;&gt; 1) &amp; 0xf;
<span class="p_del">-	params.Rt  = (hsr &gt;&gt; 5) &amp; 0xf;</span>
<span class="p_add">+	params.Rt  = kvm_vcpu_sys_get_rt(vcpu);</span>
 	params.is_write = ((hsr &amp; 1) == 0);
 	params.CRn = (hsr &gt;&gt; 10) &amp; 0xf;
 	params.Op0 = 0;
<span class="p_chunk">@@ -629,7 +629,7 @@</span> <span class="p_context"> int kvm_handle_sys_reg(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 	params.CRn = (esr &gt;&gt; 10) &amp; 0xf;
 	params.CRm = (esr &gt;&gt; 1) &amp; 0xf;
 	params.Op2 = (esr &gt;&gt; 17) &amp; 0x7;
<span class="p_del">-	params.Rt = (esr &gt;&gt; 5) &amp; 0x1f;</span>
<span class="p_add">+	params.Rt = kvm_vcpu_sys_get_rt(vcpu);</span>
 	params.is_write = !(esr &amp; 1);
 
 	return emulate_sys_reg(vcpu, &amp;params);
<span class="p_header">diff --git a/arch/metag/include/asm/uaccess.h b/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">index 9d523375f68a..560a4d5257f5 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -28,24 +28,32 @@</span> <span class="p_context"></span>
 
 #define segment_eq(a, b)	((a).seg == (b).seg)
 
<span class="p_del">-#define __kernel_ok (segment_eq(get_fs(), KERNEL_DS))</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Explicitly allow NULL pointers here. Parts of the kernel such</span>
<span class="p_del">- * as readv/writev use access_ok to validate pointers, but want</span>
<span class="p_del">- * to allow NULL pointers for various reasons. NULL pointers are</span>
<span class="p_del">- * safe to allow through because the first page is not mappable on</span>
<span class="p_del">- * Meta.</span>
<span class="p_del">- *</span>
<span class="p_del">- * We also wish to avoid letting user code access the system area</span>
<span class="p_del">- * and the kernel half of the address space.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define __user_bad(addr, size) (((addr) &gt; 0 &amp;&amp; (addr) &lt; META_MEMORY_BASE) || \</span>
<span class="p_del">-				((addr) &gt; PAGE_OFFSET &amp;&amp;		\</span>
<span class="p_del">-				 (addr) &lt; LINCORE_BASE))</span>
<span class="p_del">-</span>
 static inline int __access_ok(unsigned long addr, unsigned long size)
 {
<span class="p_del">-	return __kernel_ok || !__user_bad(addr, size);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Allow access to the user mapped memory area, but not the system area</span>
<span class="p_add">+	 * before it. The check extends to the top of the address space when</span>
<span class="p_add">+	 * kernel access is allowed (there&#39;s no real reason to user copy to the</span>
<span class="p_add">+	 * system area in any case).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (likely(addr &gt;= META_MEMORY_BASE &amp;&amp; addr &lt; get_fs().seg &amp;&amp;</span>
<span class="p_add">+		   size &lt;= get_fs().seg - addr))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Explicitly allow NULL pointers here. Parts of the kernel such</span>
<span class="p_add">+	 * as readv/writev use access_ok to validate pointers, but want</span>
<span class="p_add">+	 * to allow NULL pointers for various reasons. NULL pointers are</span>
<span class="p_add">+	 * safe to allow through because the first page is not mappable on</span>
<span class="p_add">+	 * Meta.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!addr)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	/* Allow access to core code memory area... */</span>
<span class="p_add">+	if (addr &gt;= LINCORE_CODE_BASE &amp;&amp; addr &lt;= LINCORE_CODE_LIMIT &amp;&amp;</span>
<span class="p_add">+	    size &lt;= LINCORE_CODE_LIMIT + 1 - addr)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	/* ... but no other areas. */</span>
<span class="p_add">+	return false;</span>
 }
 
 #define access_ok(type, addr, size) __access_ok((unsigned long)(addr),	\
<span class="p_chunk">@@ -181,8 +189,13 @@</span> <span class="p_context"> do {                                                            \</span>
 extern long __must_check __strncpy_from_user(char *dst, const char __user *src,
 					     long count);
 
<span class="p_del">-#define strncpy_from_user(dst, src, count) __strncpy_from_user(dst, src, count)</span>
<span class="p_del">-</span>
<span class="p_add">+static inline long</span>
<span class="p_add">+strncpy_from_user(char *dst, const char __user *src, long count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, src, 1))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	return __strncpy_from_user(dst, src, count);</span>
<span class="p_add">+}</span>
 /*
  * Return the size of a string (including the ending 0)
  *
<span class="p_header">diff --git a/arch/powerpc/include/asm/qe.h b/arch/powerpc/include/asm/qe.h</span>
<span class="p_header">index 32b9bfa0c9bd..2f760b0240f3 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/qe.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/qe.h</span>
<span class="p_chunk">@@ -193,6 +193,7 @@</span> <span class="p_context"> static inline int qe_alive_during_sleep(void)</span>
 #define qe_muram_free cpm_muram_free
 #define qe_muram_addr cpm_muram_addr
 #define qe_muram_offset cpm_muram_offset
<span class="p_add">+#define qe_muram_dma cpm_muram_dma</span>
 
 /* Structure that defines QE firmware binary files.
  *
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index e25ee5de2f6f..0e3ad5591414 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -584,7 +584,7 @@</span> <span class="p_context"> static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)</span>
  */
 #define MAX_WAIT_FOR_RECOVERY 300
 
<span class="p_del">-static void eeh_handle_normal_event(struct eeh_pe *pe)</span>
<span class="p_add">+static bool eeh_handle_normal_event(struct eeh_pe *pe)</span>
 {
 	struct pci_bus *frozen_bus;
 	int rc = 0;
<span class="p_chunk">@@ -594,7 +594,7 @@</span> <span class="p_context"> static void eeh_handle_normal_event(struct eeh_pe *pe)</span>
 	if (!frozen_bus) {
 		pr_err(&quot;%s: Cannot find PCI bus for PHB#%d-PE#%x\n&quot;,
 			__func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr);
<span class="p_del">-		return;</span>
<span class="p_add">+		return false;</span>
 	}
 
 	eeh_pe_update_time_stamp(pe);
<span class="p_chunk">@@ -711,7 +711,7 @@</span> <span class="p_context"> static void eeh_handle_normal_event(struct eeh_pe *pe)</span>
 	pr_info(&quot;EEH: Notify device driver to resume\n&quot;);
 	eeh_pe_dev_traverse(pe, eeh_report_resume, NULL);
 
<span class="p_del">-	return;</span>
<span class="p_add">+	return false;</span>
 
 excess_failures:
 	/*
<span class="p_chunk">@@ -751,7 +751,11 @@</span> <span class="p_context"> static void eeh_handle_normal_event(struct eeh_pe *pe)</span>
 		pci_lock_rescan_remove();
 		pcibios_remove_pci_devices(frozen_bus);
 		pci_unlock_rescan_remove();
<span class="p_add">+</span>
<span class="p_add">+		/* The passed PE should no longer be used */</span>
<span class="p_add">+		return true;</span>
 	}
<span class="p_add">+	return false;</span>
 }
 
 static void eeh_handle_special_event(void)
<span class="p_chunk">@@ -817,7 +821,14 @@</span> <span class="p_context"> static void eeh_handle_special_event(void)</span>
 		 */
 		if (rc == EEH_NEXT_ERR_FROZEN_PE ||
 		    rc == EEH_NEXT_ERR_FENCED_PHB) {
<span class="p_del">-			eeh_handle_normal_event(pe);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * eeh_handle_normal_event() can make the PE stale if it</span>
<span class="p_add">+			 * determines that the PE cannot possibly be recovered.</span>
<span class="p_add">+			 * Don&#39;t modify the PE state if that&#39;s the case.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (eeh_handle_normal_event(pe))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
 			eeh_pe_state_clear(pe, EEH_PE_RECOVERING);
 		} else {
 			pci_lock_rescan_remove();
<span class="p_header">diff --git a/arch/powerpc/kernel/sysfs.c b/arch/powerpc/kernel/sysfs.c</span>
<span class="p_header">index 67fd2fd2620a..52e12019e101 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/sysfs.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/sysfs.c</span>
<span class="p_chunk">@@ -672,6 +672,10 @@</span> <span class="p_context"> static void register_cpu_online(unsigned int cpu)</span>
 	struct device_attribute *attrs, *pmc_attrs;
 	int i, nattrs;
 
<span class="p_add">+	/* For cpus present at boot a reference was already grabbed in register_cpu() */</span>
<span class="p_add">+	if (!s-&gt;of_node)</span>
<span class="p_add">+		s-&gt;of_node = of_get_cpu_node(cpu, NULL);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PPC64
 	if (cpu_has_feature(CPU_FTR_SMT))
 		device_create_file(s, &amp;dev_attr_smt_snooze_delay);
<span class="p_chunk">@@ -825,6 +829,8 @@</span> <span class="p_context"> static void unregister_cpu_online(unsigned int cpu)</span>
 	}
 #endif
 	cacheinfo_cpu_offline(cpu);
<span class="p_add">+	of_node_put(s-&gt;of_node);</span>
<span class="p_add">+	s-&gt;of_node = NULL;</span>
 }
 
 #ifdef CONFIG_ARCH_CPU_PROBE_RELEASE
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/dlpar.c b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">index 7d82a2321fc7..3993608a52d9 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/dlpar.c</span>
<span class="p_chunk">@@ -298,7 +298,6 @@</span> <span class="p_context"> int dlpar_detach_node(struct device_node *dn)</span>
 	if (rc)
 		return rc;
 
<span class="p_del">-	of_node_put(dn); /* Must decrement the refcount */</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/x86/boot/boot.h b/arch/x86/boot/boot.h</span>
<span class="p_header">index bd49ec61255c..f673f92596fa 100644</span>
<span class="p_header">--- a/arch/x86/boot/boot.h</span>
<span class="p_header">+++ b/arch/x86/boot/boot.h</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"></span>
 #ifndef BOOT_BOOT_H
 #define BOOT_BOOT_H
 
<span class="p_del">-#define STACK_SIZE	512	/* Minimum number of bytes for stack */</span>
<span class="p_add">+#define STACK_SIZE	1024	/* Minimum number of bytes for stack */</span>
 
 #ifndef __ASSEMBLY__
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.h b/arch/x86/kernel/cpu/perf_event.h</span>
<span class="p_header">index 3d37c04718a5..a4fac2889e89 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.h</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.h</span>
<span class="p_chunk">@@ -79,6 +79,7 @@</span> <span class="p_context"> struct amd_nb {</span>
 
 /* The maximal number of PEBS events: */
 #define MAX_PEBS_EVENTS		8
<span class="p_add">+#define PEBS_COUNTER_MASK	((1ULL &lt;&lt; MAX_PEBS_EVENTS) - 1)</span>
 
 /*
  * A debug store configuration.
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">index 598637302db8..38b5a3514c7d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_chunk">@@ -1401,21 +1401,34 @@</span> <span class="p_context"> static int intel_pmu_handle_irq(struct pt_regs *regs)</span>
 			goto done;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In case multiple PEBS events are sampled at the same time,</span>
<span class="p_add">+	 * it is possible to have GLOBAL_STATUS bit 62 set indicating</span>
<span class="p_add">+	 * PEBS buffer overflow and also seeing at most 3 PEBS counters</span>
<span class="p_add">+	 * having their bits set in the status register. This is a sign</span>
<span class="p_add">+	 * that there was at least one PEBS record pending at the time</span>
<span class="p_add">+	 * of the PMU interrupt. PEBS counters must only be processed</span>
<span class="p_add">+	 * via the drain_pebs() calls and not via the regular sample</span>
<span class="p_add">+	 * processing loop coming after that the function, otherwise</span>
<span class="p_add">+	 * phony regular samples may be generated in the sampling buffer</span>
<span class="p_add">+	 * not marked with the EXACT tag. Another possibility is to have</span>
<span class="p_add">+	 * one PEBS event and at least one non-PEBS event whic hoverflows</span>
<span class="p_add">+	 * while PEBS has armed. In this case, bit 62 of GLOBAL_STATUS will</span>
<span class="p_add">+	 * not be set, yet the overflow status bit for the PEBS counter will</span>
<span class="p_add">+	 * be on Skylake.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * To avoid this problem, we systematically ignore the PEBS-enabled</span>
<span class="p_add">+	 * counters from the GLOBAL_STATUS mask and we always process PEBS</span>
<span class="p_add">+	 * events via drain_pebs().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	status &amp;= ~(cpuc-&gt;pebs_enabled &amp; PEBS_COUNTER_MASK);</span>
<span class="p_add">+</span>
 	/*
 	 * PEBS overflow sets bit 62 in the global status register
 	 */
 	if (__test_and_clear_bit(62, (unsigned long *)&amp;status)) {
 		handled++;
 		x86_pmu.drain_pebs(regs);
<span class="p_del">-		/*</span>
<span class="p_del">-		 * There are cases where, even though, the PEBS ovfl bit is set</span>
<span class="p_del">-		 * in GLOBAL_OVF_STATUS, the PEBS events may also have their</span>
<span class="p_del">-		 * overflow bits set for their counters. We must clear them</span>
<span class="p_del">-		 * here because they have been processed as exact samples in</span>
<span class="p_del">-		 * the drain_pebs() routine. They must not be processed again</span>
<span class="p_del">-		 * in the for_each_bit_set() loop for regular samples below.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		status &amp;= ~cpuc-&gt;pebs_enabled;</span>
 		status &amp;= x86_pmu.intel_ctrl | GLOBAL_STATUS_TRACE_TOPAPMI;
 	}
 
<span class="p_header">diff --git a/arch/x86/mm/numa_32.c b/arch/x86/mm/numa_32.c</span>
<span class="p_header">index 47b6436e41c2..3686a1db25b2 100644</span>
<span class="p_header">--- a/arch/x86/mm/numa_32.c</span>
<span class="p_header">+++ b/arch/x86/mm/numa_32.c</span>
<span class="p_chunk">@@ -100,5 +100,6 @@</span> <span class="p_context"> void __init initmem_init(void)</span>
 	printk(KERN_DEBUG &quot;High memory starts at vaddr %08lx\n&quot;,
 			(ulong) pfn_to_kaddr(highstart_pfn));
 
<span class="p_add">+	__vmalloc_start_set = true;</span>
 	setup_bootmem_allocator();
 }
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 46e82e75192e..3465445be664 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -107,8 +107,6 @@</span> <span class="p_context"> static void flush_tlb_func(void *info)</span>
 	if (this_cpu_read(cpu_tlbstate.state) == TLBSTATE_OK) {
 		if (f-&gt;flush_end == TLB_FLUSH_ALL)
 			local_flush_tlb();
<span class="p_del">-		else if (!f-&gt;flush_end)</span>
<span class="p_del">-			__flush_tlb_single(f-&gt;flush_start);</span>
 		else {
 			unsigned long addr;
 			addr = f-&gt;flush_start;
<span class="p_chunk">@@ -248,7 +246,7 @@</span> <span class="p_context"> void flush_tlb_page(struct vm_area_struct *vma, unsigned long start)</span>
 	}
 
 	if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) &lt; nr_cpu_ids)
<span class="p_del">-		flush_tlb_others(mm_cpumask(mm), mm, start, 0UL);</span>
<span class="p_add">+		flush_tlb_others(mm_cpumask(mm), mm, start, start + PAGE_SIZE);</span>
 
 	preempt_enable();
 }
<span class="p_header">diff --git a/arch/x86/um/ptrace_64.c b/arch/x86/um/ptrace_64.c</span>
<span class="p_header">index 3b52bf0b418a..b0d25e6ef464 100644</span>
<span class="p_header">--- a/arch/x86/um/ptrace_64.c</span>
<span class="p_header">+++ b/arch/x86/um/ptrace_64.c</span>
<span class="p_chunk">@@ -120,7 +120,7 @@</span> <span class="p_context"> int poke_user(struct task_struct *child, long addr, long data)</span>
 	else if ((addr &gt;= offsetof(struct user, u_debugreg[0])) &amp;&amp;
 		(addr &lt;= offsetof(struct user, u_debugreg[7]))) {
 		addr -= offsetof(struct user, u_debugreg[0]);
<span class="p_del">-		addr = addr &gt;&gt; 2;</span>
<span class="p_add">+		addr = addr &gt;&gt; 3;</span>
 		if ((addr == 4) || (addr == 5))
 			return -EIO;
 		child-&gt;thread.arch.debugregs[addr] = data;
<span class="p_header">diff --git a/drivers/Makefile b/drivers/Makefile</span>
<span class="p_header">index f98b50d8251d..848ac29b5f5e 100644</span>
<span class="p_header">--- a/drivers/Makefile</span>
<span class="p_header">+++ b/drivers/Makefile</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> obj-$(CONFIG_USB_PHY)		+= usb/</span>
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_PCI)		+= usb/
 obj-$(CONFIG_USB_GADGET)	+= usb/
<span class="p_add">+obj-$(CONFIG_OF)		+= usb/</span>
 obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index b87512ff6292..90112092d1e6 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -3097,6 +3097,14 @@</span> <span class="p_context"> static unsigned int ata_scsi_write_same_xlat(struct ata_queued_cmd *qc)</span>
 	if (unlikely(!dev-&gt;dma_mode))
 		goto invalid_fld;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We only allow sending this command through the block layer,</span>
<span class="p_add">+	 * as it modifies the DATA OUT buffer, which would corrupt user</span>
<span class="p_add">+	 * memory for SG_IO commands.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(scmd-&gt;request-&gt;cmd_type != REQ_TYPE_FS))</span>
<span class="p_add">+		goto invalid_fld;</span>
<span class="p_add">+</span>
 	if (unlikely(scmd-&gt;cmd_len &lt; 16))
 		goto invalid_fld;
 	scsi_16_lba_len(cdb, &amp;block, &amp;n_block);
<span class="p_header">diff --git a/drivers/gpu/drm/drm_edid.c b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">index 0149b1e6dd5b..1db601e109d0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_edid.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_edid.c</span>
<span class="p_chunk">@@ -74,6 +74,8 @@</span> <span class="p_context"></span>
 #define EDID_QUIRK_FORCE_12BPC			(1 &lt;&lt; 9)
 /* Force 6bpc */
 #define EDID_QUIRK_FORCE_6BPC			(1 &lt;&lt; 10)
<span class="p_add">+/* Force 10bpc */</span>
<span class="p_add">+#define EDID_QUIRK_FORCE_10BPC			(1 &lt;&lt; 11)</span>
 
 struct detailed_mode_closure {
 	struct drm_connector *connector;
<span class="p_chunk">@@ -116,6 +118,9 @@</span> <span class="p_context"> static struct edid_quirk {</span>
 	{ &quot;FCM&quot;, 13600, EDID_QUIRK_PREFER_LARGE_75 |
 	  EDID_QUIRK_DETAILED_IN_CM },
 
<span class="p_add">+	/* LGD panel of HP zBook 17 G2, eDP 10 bpc, but reports unknown bpc */</span>
<span class="p_add">+	{ &quot;LGD&quot;, 764, EDID_QUIRK_FORCE_10BPC },</span>
<span class="p_add">+</span>
 	/* LG Philips LCD LP154W01-A5 */
 	{ &quot;LPL&quot;, 0, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
 	{ &quot;LPL&quot;, 0x2a00, EDID_QUIRK_DETAILED_USE_MAXIMUM_SIZE },
<span class="p_chunk">@@ -3678,6 +3683,9 @@</span> <span class="p_context"> int drm_add_edid_modes(struct drm_connector *connector, struct edid *edid)</span>
 	if (quirks &amp; EDID_QUIRK_FORCE_8BPC)
 		connector-&gt;display_info.bpc = 8;
 
<span class="p_add">+	if (quirks &amp; EDID_QUIRK_FORCE_10BPC)</span>
<span class="p_add">+		connector-&gt;display_info.bpc = 10;</span>
<span class="p_add">+</span>
 	if (quirks &amp; EDID_QUIRK_FORCE_12BPC)
 		connector-&gt;display_info.bpc = 12;
 
<span class="p_header">diff --git a/drivers/hsi/clients/ssi_protocol.c b/drivers/hsi/clients/ssi_protocol.c</span>
<span class="p_header">index ce4be3738d46..1cd3470f1a48 100644</span>
<span class="p_header">--- a/drivers/hsi/clients/ssi_protocol.c</span>
<span class="p_header">+++ b/drivers/hsi/clients/ssi_protocol.c</span>
<span class="p_chunk">@@ -976,7 +976,7 @@</span> <span class="p_context"> static int ssip_pn_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		goto drop;
 	/* Pad to 32-bits - FIXME: Revisit*/
 	if ((skb-&gt;len &amp; 3) &amp;&amp; skb_pad(skb, 4 - (skb-&gt;len &amp; 3)))
<span class="p_del">-		goto drop;</span>
<span class="p_add">+		goto inc_dropped;</span>
 
 	/*
 	 * Modem sends Phonet messages over SSI with its own endianess...
<span class="p_chunk">@@ -1028,8 +1028,9 @@</span> <span class="p_context"> static int ssip_pn_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 drop2:
 	hsi_free_msg(msg);
 drop:
<span class="p_del">-	dev-&gt;stats.tx_dropped++;</span>
 	dev_kfree_skb(skb);
<span class="p_add">+inc_dropped:</span>
<span class="p_add">+	dev-&gt;stats.tx_dropped++;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/iio/dac/ad7303.c b/drivers/iio/dac/ad7303.c</span>
<span class="p_header">index fa2810032968..9b7d2a3311e8 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad7303.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad7303.c</span>
<span class="p_chunk">@@ -184,9 +184,9 @@</span> <span class="p_context"> static const struct iio_chan_spec_ext_info ad7303_ext_info[] = {</span>
 	.address = (chan),					\
 	.scan_type = {						\
 		.sign = &#39;u&#39;,					\
<span class="p_del">-		.realbits = &#39;8&#39;,				\</span>
<span class="p_del">-		.storagebits = &#39;8&#39;,				\</span>
<span class="p_del">-		.shift = &#39;0&#39;,					\</span>
<span class="p_add">+		.realbits = 8,					\</span>
<span class="p_add">+		.storagebits = 8,				\</span>
<span class="p_add">+		.shift = 0,					\</span>
 	},							\
 	.ext_info = ad7303_ext_info,				\
 }
<span class="p_header">diff --git a/drivers/iio/proximity/as3935.c b/drivers/iio/proximity/as3935.c</span>
<span class="p_header">index 758c14703ad8..a6370a4d6705 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/as3935.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/as3935.c</span>
<span class="p_chunk">@@ -50,7 +50,6 @@</span> <span class="p_context"></span>
 #define AS3935_TUNE_CAP		0x08
 #define AS3935_CALIBRATE	0x3D
 
<span class="p_del">-#define AS3935_WRITE_DATA	BIT(15)</span>
 #define AS3935_READ_DATA	BIT(14)
 #define AS3935_ADDRESS(x)	((x) &lt;&lt; 8)
 
<span class="p_chunk">@@ -105,7 +104,7 @@</span> <span class="p_context"> static int as3935_write(struct as3935_state *st,</span>
 {
 	u8 *buf = st-&gt;buf;
 
<span class="p_del">-	buf[0] = (AS3935_WRITE_DATA | AS3935_ADDRESS(reg)) &gt;&gt; 8;</span>
<span class="p_add">+	buf[0] = AS3935_ADDRESS(reg) &gt;&gt; 8;</span>
 	buf[1] = val;
 
 	return spi_write(st-&gt;spi, buf, 2);
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index ce649a7ffa56..779067acd270 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -2577,6 +2577,7 @@</span> <span class="p_context"> ssize_t ib_uverbs_detach_mcast(struct ib_uverbs_file *file,</span>
 	struct ib_qp                 *qp;
 	struct ib_uverbs_mcast_entry *mcast;
 	int                           ret = -EINVAL;
<span class="p_add">+	bool                          found = false;</span>
 
 	if (copy_from_user(&amp;cmd, buf, sizeof cmd))
 		return -EFAULT;
<span class="p_chunk">@@ -2585,10 +2586,6 @@</span> <span class="p_context"> ssize_t ib_uverbs_detach_mcast(struct ib_uverbs_file *file,</span>
 	if (!qp)
 		return -EINVAL;
 
<span class="p_del">-	ret = ib_detach_mcast(qp, (union ib_gid *) cmd.gid, cmd.mlid);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_put;</span>
<span class="p_del">-</span>
 	obj = container_of(qp-&gt;uobject, struct ib_uqp_object, uevent.uobject);
 
 	list_for_each_entry(mcast, &amp;obj-&gt;mcast_list, list)
<span class="p_chunk">@@ -2596,9 +2593,17 @@</span> <span class="p_context"> ssize_t ib_uverbs_detach_mcast(struct ib_uverbs_file *file,</span>
 		    !memcmp(cmd.gid, mcast-&gt;gid.raw, sizeof mcast-&gt;gid.raw)) {
 			list_del(&amp;mcast-&gt;list);
 			kfree(mcast);
<span class="p_add">+			found = true;</span>
 			break;
 		}
 
<span class="p_add">+	if (!found) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out_put;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = ib_detach_mcast(qp, (union ib_gid *)cmd.gid, cmd.mlid);</span>
<span class="p_add">+</span>
 out_put:
 	put_qp_write(qp);
 
<span class="p_header">diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c</span>
<span class="p_header">index 0c859f7fb7a4..fb0a6d8f9c32 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/verbs.c</span>
<span class="p_chunk">@@ -1346,7 +1346,9 @@</span> <span class="p_context"> int ib_attach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid)</span>
 
 	if (!qp-&gt;device-&gt;attach_mcast)
 		return -ENOSYS;
<span class="p_del">-	if (gid-&gt;raw[0] != 0xff || qp-&gt;qp_type != IB_QPT_UD)</span>
<span class="p_add">+	if (gid-&gt;raw[0] != 0xff || qp-&gt;qp_type != IB_QPT_UD ||</span>
<span class="p_add">+	    lid &lt; 0xC000 ||</span>
<span class="p_add">+	    lid == be16_to_cpu(IB_LID_PERMISSIVE))</span>
 		return -EINVAL;
 
 	ret = qp-&gt;device-&gt;attach_mcast(qp, gid, lid);
<span class="p_chunk">@@ -1362,7 +1364,9 @@</span> <span class="p_context"> int ib_detach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid)</span>
 
 	if (!qp-&gt;device-&gt;detach_mcast)
 		return -ENOSYS;
<span class="p_del">-	if (gid-&gt;raw[0] != 0xff || qp-&gt;qp_type != IB_QPT_UD)</span>
<span class="p_add">+	if (gid-&gt;raw[0] != 0xff || qp-&gt;qp_type != IB_QPT_UD ||</span>
<span class="p_add">+	    lid &lt; 0xC000 ||</span>
<span class="p_add">+	    lid == be16_to_cpu(IB_LID_PERMISSIVE))</span>
 		return -EINVAL;
 
 	ret = qp-&gt;device-&gt;detach_mcast(qp, gid, lid);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/main.c b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">index 1397da73f636..775c3cb87097 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/main.c</span>
<span class="p_chunk">@@ -2281,6 +2281,7 @@</span> <span class="p_context"> static void *mlx4_ib_add(struct mlx4_dev *dev)</span>
 			mlx4_counter_free(ibdev-&gt;dev, ibdev-&gt;counters[i - 1]);
 
 err_map:
<span class="p_add">+	mlx4_ib_free_eqs(dev, ibdev);</span>
 	iounmap(ibdev-&gt;uar_map);
 
 err_uar:
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_fs.c b/drivers/infiniband/ulp/ipoib/ipoib_fs.c</span>
<span class="p_header">index 50061854616e..09396bd7b02d 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_fs.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_fs.c</span>
<span class="p_chunk">@@ -281,10 +281,11 @@</span> <span class="p_context"> void ipoib_delete_debug_files(struct net_device *dev)</span>
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
 
<span class="p_del">-	if (priv-&gt;mcg_dentry)</span>
<span class="p_del">-		debugfs_remove(priv-&gt;mcg_dentry);</span>
<span class="p_del">-	if (priv-&gt;path_dentry)</span>
<span class="p_del">-		debugfs_remove(priv-&gt;path_dentry);</span>
<span class="p_add">+	WARN_ONCE(!priv-&gt;mcg_dentry, &quot;null mcg debug file\n&quot;);</span>
<span class="p_add">+	WARN_ONCE(!priv-&gt;path_dentry, &quot;null path debug file\n&quot;);</span>
<span class="p_add">+	debugfs_remove(priv-&gt;mcg_dentry);</span>
<span class="p_add">+	debugfs_remove(priv-&gt;path_dentry);</span>
<span class="p_add">+	priv-&gt;mcg_dentry = priv-&gt;path_dentry = NULL;</span>
 }
 
 int ipoib_register_debugfs(void)
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_ib.c b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">index fcbfdda0e585..27fe62e2fd95 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_ib.c</span>
<span class="p_chunk">@@ -961,6 +961,19 @@</span> <span class="p_context"> static inline int update_parent_pkey(struct ipoib_dev_priv *priv)</span>
 		 */
 		priv-&gt;dev-&gt;broadcast[8] = priv-&gt;pkey &gt;&gt; 8;
 		priv-&gt;dev-&gt;broadcast[9] = priv-&gt;pkey &amp; 0xff;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Update the broadcast address in the priv-&gt;broadcast object,</span>
<span class="p_add">+		 * in case it already exists, otherwise no one will do that.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (priv-&gt;broadcast) {</span>
<span class="p_add">+			spin_lock_irq(&amp;priv-&gt;lock);</span>
<span class="p_add">+			memcpy(priv-&gt;broadcast-&gt;mcmember.mgid.raw,</span>
<span class="p_add">+			       priv-&gt;dev-&gt;broadcast + 4,</span>
<span class="p_add">+			sizeof(union ib_gid));</span>
<span class="p_add">+			spin_unlock_irq(&amp;priv-&gt;lock);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 1aea17fe9cbe..40be7b4206c0 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -98,6 +98,33 @@</span> <span class="p_context"> static struct ib_client ipoib_client = {</span>
 	.remove = ipoib_remove_one
 };
 
<span class="p_add">+#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG</span>
<span class="p_add">+static int ipoib_netdev_event(struct notifier_block *this,</span>
<span class="p_add">+			      unsigned long event, void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct netdev_notifier_info *ni = ptr;</span>
<span class="p_add">+	struct net_device *dev = ni-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (dev-&gt;netdev_ops-&gt;ndo_open != ipoib_open)</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (event) {</span>
<span class="p_add">+	case NETDEV_REGISTER:</span>
<span class="p_add">+		ipoib_create_debug_files(dev);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NETDEV_CHANGENAME:</span>
<span class="p_add">+		ipoib_delete_debug_files(dev);</span>
<span class="p_add">+		ipoib_create_debug_files(dev);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case NETDEV_UNREGISTER:</span>
<span class="p_add">+		ipoib_delete_debug_files(dev);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 int ipoib_open(struct net_device *dev)
 {
 	struct ipoib_dev_priv *priv = netdev_priv(dev);
<span class="p_chunk">@@ -1313,8 +1340,6 @@</span> <span class="p_context"> void ipoib_dev_cleanup(struct net_device *dev)</span>
 
 	ASSERT_RTNL();
 
<span class="p_del">-	ipoib_delete_debug_files(dev);</span>
<span class="p_del">-</span>
 	/* Delete any child interfaces first */
 	list_for_each_entry_safe(cpriv, tcpriv, &amp;priv-&gt;child_intfs, list) {
 		/* Stop GC on child */
<span class="p_chunk">@@ -1620,8 +1645,6 @@</span> <span class="p_context"> static struct net_device *ipoib_add_port(const char *format,</span>
 		goto register_failed;
 	}
 
<span class="p_del">-	ipoib_create_debug_files(priv-&gt;dev);</span>
<span class="p_del">-</span>
 	if (ipoib_cm_add_mode_attr(priv-&gt;dev))
 		goto sysfs_failed;
 	if (ipoib_add_pkey_attr(priv-&gt;dev))
<span class="p_chunk">@@ -1636,7 +1659,6 @@</span> <span class="p_context"> static struct net_device *ipoib_add_port(const char *format,</span>
 	return priv-&gt;dev;
 
 sysfs_failed:
<span class="p_del">-	ipoib_delete_debug_files(priv-&gt;dev);</span>
 	unregister_netdev(priv-&gt;dev);
 
 register_failed:
<span class="p_chunk">@@ -1727,6 +1749,12 @@</span> <span class="p_context"> static void ipoib_remove_one(struct ib_device *device)</span>
 	kfree(dev_list);
 }
 
<span class="p_add">+#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG</span>
<span class="p_add">+static struct notifier_block ipoib_netdev_notifier = {</span>
<span class="p_add">+	.notifier_call = ipoib_netdev_event,</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 static int __init ipoib_init_module(void)
 {
 	int ret;
<span class="p_chunk">@@ -1776,6 +1804,9 @@</span> <span class="p_context"> static int __init ipoib_init_module(void)</span>
 	if (ret)
 		goto err_client;
 
<span class="p_add">+#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG</span>
<span class="p_add">+	register_netdevice_notifier(&amp;ipoib_netdev_notifier);</span>
<span class="p_add">+#endif</span>
 	return 0;
 
 err_client:
<span class="p_chunk">@@ -1793,6 +1824,9 @@</span> <span class="p_context"> static int __init ipoib_init_module(void)</span>
 
 static void __exit ipoib_cleanup_module(void)
 {
<span class="p_add">+#ifdef CONFIG_INFINIBAND_IPOIB_DEBUG</span>
<span class="p_add">+	unregister_netdevice_notifier(&amp;ipoib_netdev_notifier);</span>
<span class="p_add">+#endif</span>
 	ipoib_netlink_fini();
 	ib_unregister_client(&amp;ipoib_client);
 	ib_sa_unregister_client(&amp;ipoib_sa_client);
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">index 05467aa7f498..4c83a970e7f3 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_chunk">@@ -86,8 +86,6 @@</span> <span class="p_context"> int __ipoib_vlan_add(struct ipoib_dev_priv *ppriv, struct ipoib_dev_priv *priv,</span>
 
 	priv-&gt;parent = ppriv-&gt;dev;
 
<span class="p_del">-	ipoib_create_debug_files(priv-&gt;dev);</span>
<span class="p_del">-</span>
 	/* RTNL childs don&#39;t need proprietary sysfs entries */
 	if (type == IPOIB_LEGACY_CHILD) {
 		if (ipoib_cm_add_mode_attr(priv-&gt;dev))
<span class="p_chunk">@@ -109,7 +107,6 @@</span> <span class="p_context"> int __ipoib_vlan_add(struct ipoib_dev_priv *ppriv, struct ipoib_dev_priv *priv,</span>
 
 sysfs_failed:
 	result = -ENOMEM;
<span class="p_del">-	ipoib_delete_debug_files(priv-&gt;dev);</span>
 	unregister_netdevice(priv-&gt;dev);
 
 register_failed:
<span class="p_header">diff --git a/drivers/input/misc/twl4030-pwrbutton.c b/drivers/input/misc/twl4030-pwrbutton.c</span>
<span class="p_header">index 8400a1a34d87..d6ee310c63cd 100644</span>
<span class="p_header">--- a/drivers/input/misc/twl4030-pwrbutton.c</span>
<span class="p_header">+++ b/drivers/input/misc/twl4030-pwrbutton.c</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> static int twl4030_pwrbutton_probe(struct platform_device *pdev)</span>
 	pwr-&gt;phys = &quot;twl4030_pwrbutton/input0&quot;;
 	pwr-&gt;dev.parent = &amp;pdev-&gt;dev;
 
<span class="p_del">-	err = devm_request_threaded_irq(&amp;pwr-&gt;dev, irq, NULL, powerbutton_irq,</span>
<span class="p_add">+	err = devm_request_threaded_irq(&amp;pdev-&gt;dev, irq, NULL, powerbutton_irq,</span>
 			IRQF_TRIGGER_FALLING | IRQF_TRIGGER_RISING,
 			&quot;twl4030_pwrbutton&quot;, pwr);
 	if (err &lt; 0) {
<span class="p_header">diff --git a/drivers/md/dm-bufio.c b/drivers/md/dm-bufio.c</span>
<span class="p_header">index 4d1edcf552bb..08ae5b492bc4 100644</span>
<span class="p_header">--- a/drivers/md/dm-bufio.c</span>
<span class="p_header">+++ b/drivers/md/dm-bufio.c</span>
<span class="p_chunk">@@ -873,10 +873,11 @@</span> <span class="p_context"> static void __get_memory_limit(struct dm_bufio_client *c,</span>
 {
 	unsigned long buffers;
 
<span class="p_del">-	if (ACCESS_ONCE(dm_bufio_cache_size) != dm_bufio_cache_size_latch) {</span>
<span class="p_del">-		mutex_lock(&amp;dm_bufio_clients_lock);</span>
<span class="p_del">-		__cache_size_refresh();</span>
<span class="p_del">-		mutex_unlock(&amp;dm_bufio_clients_lock);</span>
<span class="p_add">+	if (unlikely(ACCESS_ONCE(dm_bufio_cache_size) != dm_bufio_cache_size_latch)) {</span>
<span class="p_add">+		if (mutex_trylock(&amp;dm_bufio_clients_lock)) {</span>
<span class="p_add">+			__cache_size_refresh();</span>
<span class="p_add">+			mutex_unlock(&amp;dm_bufio_clients_lock);</span>
<span class="p_add">+		}</span>
 	}
 
 	buffers = dm_bufio_cache_size_per_client &gt;&gt;
<span class="p_header">diff --git a/drivers/md/dm-era-target.c b/drivers/md/dm-era-target.c</span>
<span class="p_header">index ad913cd4aded..330151d6ee42 100644</span>
<span class="p_header">--- a/drivers/md/dm-era-target.c</span>
<span class="p_header">+++ b/drivers/md/dm-era-target.c</span>
<span class="p_chunk">@@ -957,15 +957,15 @@</span> <span class="p_context"> static int metadata_commit(struct era_metadata *md)</span>
 		}
 	}
 
<span class="p_del">-	r = save_sm_root(md);</span>
<span class="p_add">+	r = dm_tm_pre_commit(md-&gt;tm);</span>
 	if (r) {
<span class="p_del">-		DMERR(&quot;%s: save_sm_root failed&quot;, __func__);</span>
<span class="p_add">+		DMERR(&quot;%s: pre commit failed&quot;, __func__);</span>
 		return r;
 	}
 
<span class="p_del">-	r = dm_tm_pre_commit(md-&gt;tm);</span>
<span class="p_add">+	r = save_sm_root(md);</span>
 	if (r) {
<span class="p_del">-		DMERR(&quot;%s: pre commit failed&quot;, __func__);</span>
<span class="p_add">+		DMERR(&quot;%s: save_sm_root failed&quot;, __func__);</span>
 		return r;
 	}
 
<span class="p_header">diff --git a/drivers/md/dm-ioctl.c b/drivers/md/dm-ioctl.c</span>
<span class="p_header">index 51521429fb59..d20c2de3fd72 100644</span>
<span class="p_header">--- a/drivers/md/dm-ioctl.c</span>
<span class="p_header">+++ b/drivers/md/dm-ioctl.c</span>
<span class="p_chunk">@@ -1839,7 +1839,7 @@</span> <span class="p_context"> static int ctl_ioctl(uint command, struct dm_ioctl __user *user)</span>
 	if (r)
 		goto out;
 
<span class="p_del">-	param-&gt;data_size = sizeof(*param);</span>
<span class="p_add">+	param-&gt;data_size = offsetof(struct dm_ioctl, data);</span>
 	r = fn(param, input_param_size);
 
 	if (unlikely(param-&gt;flags &amp; DM_BUFFER_FULL_FLAG) &amp;&amp;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 7b4bb1f09b01..c156f4a19978 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -804,8 +804,12 @@</span> <span class="p_context"> static int find_key(struct ro_spine *s, dm_block_t block, bool find_highest,</span>
 		else
 			*result_key = le64_to_cpu(ro_node(s)-&gt;keys[0]);
 
<span class="p_del">-		if (next_block || flags &amp; INTERNAL_NODE)</span>
<span class="p_del">-			block = value64(ro_node(s), i);</span>
<span class="p_add">+		if (next_block || flags &amp; INTERNAL_NODE) {</span>
<span class="p_add">+			if (find_highest)</span>
<span class="p_add">+				block = value64(ro_node(s), i);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				block = value64(ro_node(s), 0);</span>
<span class="p_add">+		}</span>
 
 	} while (flags &amp; INTERNAL_NODE);
 
<span class="p_header">diff --git a/drivers/media/i2c/soc_camera/ov2640.c b/drivers/media/i2c/soc_camera/ov2640.c</span>
<span class="p_header">index 6c6b1c3b45e3..ee28295baaba 100644</span>
<span class="p_header">--- a/drivers/media/i2c/soc_camera/ov2640.c</span>
<span class="p_header">+++ b/drivers/media/i2c/soc_camera/ov2640.c</span>
<span class="p_chunk">@@ -713,8 +713,10 @@</span> <span class="p_context"> static int ov2640_s_ctrl(struct v4l2_ctrl *ctrl)</span>
 
 	switch (ctrl-&gt;id) {
 	case V4L2_CID_VFLIP:
<span class="p_del">-		val = ctrl-&gt;val ? REG04_VFLIP_IMG : 0x00;</span>
<span class="p_del">-		return ov2640_mask_set(client, REG04, REG04_VFLIP_IMG, val);</span>
<span class="p_add">+		val = ctrl-&gt;val ? REG04_VFLIP_IMG | REG04_VREF_EN : 0x00;</span>
<span class="p_add">+		return ov2640_mask_set(client, REG04,</span>
<span class="p_add">+				       REG04_VFLIP_IMG | REG04_VREF_EN, val);</span>
<span class="p_add">+		/* NOTE: REG04_VREF_EN: 1 line shift / even/odd line swap */</span>
 	case V4L2_CID_HFLIP:
 		val = ctrl-&gt;val ? REG04_HFLIP_IMG : 0x00;
 		return ov2640_mask_set(client, REG04, REG04_HFLIP_IMG, val);
<span class="p_header">diff --git a/drivers/media/platform/s5p-mfc/s5p_mfc.c b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">index 19c25e0245d1..2f096332db84 100644</span>
<span class="p_header">--- a/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_header">+++ b/drivers/media/platform/s5p-mfc/s5p_mfc.c</span>
<span class="p_chunk">@@ -169,6 +169,7 @@</span> <span class="p_context"> static void s5p_mfc_watchdog_worker(struct work_struct *work)</span>
 		}
 		s5p_mfc_clock_on();
 		ret = s5p_mfc_init_hw(dev);
<span class="p_add">+		s5p_mfc_clock_off();</span>
 		if (ret)
 			mfc_err(&quot;Failed to reinit FW\n&quot;);
 	}
<span class="p_header">diff --git a/drivers/media/rc/mceusb.c b/drivers/media/rc/mceusb.c</span>
<span class="p_header">index d5c1df3c9db1..6afe8a211b22 100644</span>
<span class="p_header">--- a/drivers/media/rc/mceusb.c</span>
<span class="p_header">+++ b/drivers/media/rc/mceusb.c</span>
<span class="p_chunk">@@ -1299,8 +1299,8 @@</span> <span class="p_context"> static int mceusb_dev_probe(struct usb_interface *intf,</span>
 			}
 		}
 	}
<span class="p_del">-	if (ep_in == NULL) {</span>
<span class="p_del">-		dev_dbg(&amp;intf-&gt;dev, &quot;inbound and/or endpoint not found&quot;);</span>
<span class="p_add">+	if (!ep_in || !ep_out) {</span>
<span class="p_add">+		dev_dbg(&amp;intf-&gt;dev, &quot;required endpoints not found\n&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-audio.c b/drivers/media/usb/cx231xx/cx231xx-audio.c</span>
<span class="p_header">index 9b925874d392..5f94b00d104f 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-audio.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-audio.c</span>
<span class="p_chunk">@@ -672,10 +672,8 @@</span> <span class="p_context"> static int cx231xx_audio_init(struct cx231xx *dev)</span>
 
 	spin_lock_init(&amp;adev-&gt;slock);
 	err = snd_pcm_new(card, &quot;Cx231xx Audio&quot;, 0, 0, 1, &amp;pcm);
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		snd_card_free(card);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto err_free_card;</span>
 
 	snd_pcm_set_ops(pcm, SNDRV_PCM_STREAM_CAPTURE,
 			&amp;snd_cx231xx_pcm_capture);
<span class="p_chunk">@@ -689,10 +687,9 @@</span> <span class="p_context"> static int cx231xx_audio_init(struct cx231xx *dev)</span>
 	INIT_WORK(&amp;dev-&gt;wq_trigger, audio_trigger);
 
 	err = snd_card_register(card);
<span class="p_del">-	if (err &lt; 0) {</span>
<span class="p_del">-		snd_card_free(card);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		goto err_free_card;</span>
<span class="p_add">+</span>
 	adev-&gt;sndcard = card;
 	adev-&gt;udev = dev-&gt;udev;
 
<span class="p_chunk">@@ -702,6 +699,11 @@</span> <span class="p_context"> static int cx231xx_audio_init(struct cx231xx *dev)</span>
 					    hs_config_info[0].interface_info.
 					    audio_index + 1];
 
<span class="p_add">+	if (uif-&gt;altsetting[0].desc.bNumEndpoints &lt; isoc_pipe + 1) {</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto err_free_card;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	adev-&gt;end_point_addr =
 	    uif-&gt;altsetting[0].endpoint[isoc_pipe].desc.
 			bEndpointAddress;
<span class="p_chunk">@@ -710,15 +712,21 @@</span> <span class="p_context"> static int cx231xx_audio_init(struct cx231xx *dev)</span>
 	cx231xx_info(&quot;EndPoint Addr 0x%x, Alternate settings: %i\n&quot;,
 		     adev-&gt;end_point_addr, adev-&gt;num_alt);
 	adev-&gt;alt_max_pkt_size = kmalloc(32 * adev-&gt;num_alt, GFP_KERNEL);
<span class="p_del">-</span>
<span class="p_del">-	if (adev-&gt;alt_max_pkt_size == NULL) {</span>
<span class="p_add">+	if (!adev-&gt;alt_max_pkt_size) {</span>
 		cx231xx_errdev(&quot;out of memory!\n&quot;);
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto err_free_card;</span>
 	}
 
 	for (i = 0; i &lt; adev-&gt;num_alt; i++) {
<span class="p_del">-		u16 tmp =</span>
<span class="p_del">-		    le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].desc.</span>
<span class="p_add">+		u16 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (uif-&gt;altsetting[i].desc.bNumEndpoints &lt; isoc_pipe + 1) {</span>
<span class="p_add">+			err = -ENODEV;</span>
<span class="p_add">+			goto err_free_pkt_size;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].desc.</span>
 				wMaxPacketSize);
 		adev-&gt;alt_max_pkt_size[i] =
 		    (tmp &amp; 0x07ff) * (((tmp &amp; 0x1800) &gt;&gt; 11) + 1);
<span class="p_chunk">@@ -727,6 +735,13 @@</span> <span class="p_context"> static int cx231xx_audio_init(struct cx231xx *dev)</span>
 	}
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err_free_pkt_size:</span>
<span class="p_add">+	kfree(adev-&gt;alt_max_pkt_size);</span>
<span class="p_add">+err_free_card:</span>
<span class="p_add">+	snd_card_free(card);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static int cx231xx_audio_fini(struct cx231xx *dev)
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-cards.c b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">index b62b37130f07..aae9831f05a8 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_chunk">@@ -1258,6 +1258,9 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 	uif = udev-&gt;actconfig-&gt;interface[dev-&gt;current_pcb_config.
 		       hs_config_info[0].interface_info.video_index + 1];
 
<span class="p_add">+	if (uif-&gt;altsetting[0].desc.bNumEndpoints &lt; isoc_pipe + 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	dev-&gt;video_mode.end_point_addr = uif-&gt;altsetting[0].
 			endpoint[isoc_pipe].desc.bEndpointAddress;
 
<span class="p_chunk">@@ -1275,8 +1278,12 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 	}
 
 	for (i = 0; i &lt; dev-&gt;video_mode.num_alt; i++) {
<span class="p_del">-		u16 tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].</span>
<span class="p_del">-				desc.wMaxPacketSize);</span>
<span class="p_add">+		u16 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (uif-&gt;altsetting[i].desc.bNumEndpoints &lt; isoc_pipe + 1)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].desc.wMaxPacketSize);</span>
 		dev-&gt;video_mode.alt_max_pkt_size[i] =
 		    (tmp &amp; 0x07ff) * (((tmp &amp; 0x1800) &gt;&gt; 11) + 1);
 		cx231xx_info(&quot;Alternate setting %i, max size= %i\n&quot;, i,
<span class="p_chunk">@@ -1288,6 +1295,9 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 				       hs_config_info[0].interface_info.
 				       vanc_index + 1];
 
<span class="p_add">+	if (uif-&gt;altsetting[0].desc.bNumEndpoints &lt; isoc_pipe + 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	dev-&gt;vbi_mode.end_point_addr =
 	    uif-&gt;altsetting[0].endpoint[isoc_pipe].desc.
 			bEndpointAddress;
<span class="p_chunk">@@ -1306,8 +1316,12 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 	}
 
 	for (i = 0; i &lt; dev-&gt;vbi_mode.num_alt; i++) {
<span class="p_del">-		u16 tmp =</span>
<span class="p_del">-		    le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].</span>
<span class="p_add">+		u16 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (uif-&gt;altsetting[i].desc.bNumEndpoints &lt; isoc_pipe + 1)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].</span>
 				desc.wMaxPacketSize);
 		dev-&gt;vbi_mode.alt_max_pkt_size[i] =
 		    (tmp &amp; 0x07ff) * (((tmp &amp; 0x1800) &gt;&gt; 11) + 1);
<span class="p_chunk">@@ -1320,6 +1334,9 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 				       hs_config_info[0].interface_info.
 				       hanc_index + 1];
 
<span class="p_add">+	if (uif-&gt;altsetting[0].desc.bNumEndpoints &lt; isoc_pipe + 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	dev-&gt;sliced_cc_mode.end_point_addr =
 	    uif-&gt;altsetting[0].endpoint[isoc_pipe].desc.
 			bEndpointAddress;
<span class="p_chunk">@@ -1338,7 +1355,12 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 	}
 
 	for (i = 0; i &lt; dev-&gt;sliced_cc_mode.num_alt; i++) {
<span class="p_del">-		u16 tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].</span>
<span class="p_add">+		u16 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (uif-&gt;altsetting[i].desc.bNumEndpoints &lt; isoc_pipe + 1)</span>
<span class="p_add">+			return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[isoc_pipe].</span>
 				desc.wMaxPacketSize);
 		dev-&gt;sliced_cc_mode.alt_max_pkt_size[i] =
 		    (tmp &amp; 0x07ff) * (((tmp &amp; 0x1800) &gt;&gt; 11) + 1);
<span class="p_chunk">@@ -1353,6 +1375,11 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 					       interface_info.
 					       ts1_index + 1];
 
<span class="p_add">+		if (uif-&gt;altsetting[0].desc.bNumEndpoints &lt; isoc_pipe + 1) {</span>
<span class="p_add">+			retval = -ENODEV;</span>
<span class="p_add">+			goto err_video_alt;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		dev-&gt;ts1_mode.end_point_addr =
 		    uif-&gt;altsetting[0].endpoint[isoc_pipe].
 				desc.bEndpointAddress;
<span class="p_chunk">@@ -1371,7 +1398,14 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 		}
 
 		for (i = 0; i &lt; dev-&gt;ts1_mode.num_alt; i++) {
<span class="p_del">-			u16 tmp = le16_to_cpu(uif-&gt;altsetting[i].</span>
<span class="p_add">+			u16 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (uif-&gt;altsetting[i].desc.bNumEndpoints &lt; isoc_pipe + 1) {</span>
<span class="p_add">+				retval = -ENODEV;</span>
<span class="p_add">+				goto err_video_alt;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			tmp = le16_to_cpu(uif-&gt;altsetting[i].</span>
 						endpoint[isoc_pipe].desc.
 						wMaxPacketSize);
 			dev-&gt;ts1_mode.alt_max_pkt_size[i] =
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dib0700_core.c b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">index 72eccefce9fc..4f3e71c7aec8 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_chunk">@@ -769,6 +769,9 @@</span> <span class="p_context"> int dib0700_rc_setup(struct dvb_usb_device *d, struct usb_interface *intf)</span>
 
 	/* Starting in firmware 1.20, the RC info is provided on a bulk pipe */
 
<span class="p_add">+	if (intf-&gt;altsetting[0].desc.bNumEndpoints &lt; rc_ep + 1)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	purb = usb_alloc_urb(0, GFP_KERNEL);
 	if (purb == NULL) {
 		err(&quot;rc usb alloc urb failed&quot;);
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/digitv.c b/drivers/media/usb/dvb-usb/digitv.c</span>
<span class="p_header">index 772bde3c5020..c86fef6b1c21 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/digitv.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/digitv.c</span>
<span class="p_chunk">@@ -30,6 +30,10 @@</span> <span class="p_context"> static int digitv_ctrl_msg(struct dvb_usb_device *d,</span>
 {
 	int wo = (rbuf == NULL || rlen == 0); /* write-only */
 	u8 sndbuf[7],rcvbuf[7];
<span class="p_add">+</span>
<span class="p_add">+	if (wlen &gt; 4 || rlen &gt; 4)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
 	memset(sndbuf,0,7); memset(rcvbuf,0,7);
 
 	sndbuf[0] = cmd;
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dw2102.c b/drivers/media/usb/dvb-usb/dw2102.c</span>
<span class="p_header">index ae0f56a32e4d..3ec61a9082f3 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dw2102.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dw2102.c</span>
<span class="p_chunk">@@ -247,6 +247,20 @@</span> <span class="p_context"> static int dw2102_serit_i2c_transfer(struct i2c_adapter *adap,</span>
 
 	switch (num) {
 	case 2:
<span class="p_add">+		if (msg[0].len != 1) {</span>
<span class="p_add">+			warn(&quot;i2c rd: len=%d is not 1!\n&quot;,</span>
<span class="p_add">+			     msg[0].len);</span>
<span class="p_add">+			num = -EOPNOTSUPP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (2 + msg[1].len &gt; sizeof(buf6)) {</span>
<span class="p_add">+			warn(&quot;i2c rd: len=%d is too big!\n&quot;,</span>
<span class="p_add">+			     msg[1].len);</span>
<span class="p_add">+			num = -EOPNOTSUPP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/* read si2109 register by number */
 		buf6[0] = msg[0].addr &lt;&lt; 1;
 		buf6[1] = msg[0].len;
<span class="p_chunk">@@ -262,6 +276,13 @@</span> <span class="p_context"> static int dw2102_serit_i2c_transfer(struct i2c_adapter *adap,</span>
 	case 1:
 		switch (msg[0].addr) {
 		case 0x68:
<span class="p_add">+			if (2 + msg[0].len &gt; sizeof(buf6)) {</span>
<span class="p_add">+				warn(&quot;i2c wr: len=%d is too big!\n&quot;,</span>
<span class="p_add">+				     msg[0].len);</span>
<span class="p_add">+				num = -EOPNOTSUPP;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			/* write to si2109 register */
 			buf6[0] = msg[0].addr &lt;&lt; 1;
 			buf6[1] = msg[0].len;
<span class="p_chunk">@@ -305,6 +326,13 @@</span> <span class="p_context"> static int dw2102_earda_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg ms</span>
 		/* first write first register number */
 		u8 ibuf[MAX_XFER_SIZE], obuf[3];
 
<span class="p_add">+		if (2 + msg[0].len != sizeof(obuf)) {</span>
<span class="p_add">+			warn(&quot;i2c rd: len=%d is not 1!\n&quot;,</span>
<span class="p_add">+			     msg[0].len);</span>
<span class="p_add">+			ret = -EOPNOTSUPP;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (2 + msg[1].len &gt; sizeof(ibuf)) {
 			warn(&quot;i2c rd: len=%d is too big!\n&quot;,
 			     msg[1].len);
<span class="p_chunk">@@ -505,6 +533,12 @@</span> <span class="p_context"> static int dw3101_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],</span>
 		/* first write first register number */
 		u8 ibuf[MAX_XFER_SIZE], obuf[3];
 
<span class="p_add">+		if (2 + msg[0].len != sizeof(obuf)) {</span>
<span class="p_add">+			warn(&quot;i2c rd: len=%d is not 1!\n&quot;,</span>
<span class="p_add">+			     msg[0].len);</span>
<span class="p_add">+			ret = -EOPNOTSUPP;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 		if (2 + msg[1].len &gt; sizeof(ibuf)) {
 			warn(&quot;i2c rd: len=%d is too big!\n&quot;,
 			     msg[1].len);
<span class="p_chunk">@@ -730,6 +764,13 @@</span> <span class="p_context"> static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],</span>
 			msg[0].buf[0] = ibuf[1];
 			break;
 		default:
<span class="p_add">+			if (3 + msg[0].len &gt; sizeof(obuf)) {</span>
<span class="p_add">+				warn(&quot;i2c wr: len=%d is too big!\n&quot;,</span>
<span class="p_add">+				     msg[0].len);</span>
<span class="p_add">+				num = -EOPNOTSUPP;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			/* always i2c write*/
 			obuf[0] = 0x08;
 			obuf[1] = msg[0].addr;
<span class="p_chunk">@@ -745,6 +786,19 @@</span> <span class="p_context"> static int su3000_i2c_transfer(struct i2c_adapter *adap, struct i2c_msg msg[],</span>
 		break;
 	case 2:
 		/* always i2c read */
<span class="p_add">+		if (4 + msg[0].len &gt; sizeof(obuf)) {</span>
<span class="p_add">+			warn(&quot;i2c rd: len=%d is too big!\n&quot;,</span>
<span class="p_add">+			     msg[0].len);</span>
<span class="p_add">+			num = -EOPNOTSUPP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (1 + msg[1].len &gt; sizeof(obuf)) {</span>
<span class="p_add">+			warn(&quot;i2c rd: len=%d is too big!\n&quot;,</span>
<span class="p_add">+			     msg[1].len);</span>
<span class="p_add">+			num = -EOPNOTSUPP;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		obuf[0] = 0x09;
 		obuf[1] = msg[0].len;
 		obuf[2] = msg[1].len;
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/ttusb2.c b/drivers/media/usb/dvb-usb/ttusb2.c</span>
<span class="p_header">index 2ce3d19c58ef..9dd0ee4f84de 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/ttusb2.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/ttusb2.c</span>
<span class="p_chunk">@@ -78,6 +78,9 @@</span> <span class="p_context"> static int ttusb2_msg(struct dvb_usb_device *d, u8 cmd,</span>
 	u8 *s, *r = NULL;
 	int ret = 0;
 
<span class="p_add">+	if (4 + rlen &gt; 64)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
 	s = kzalloc(wlen+4, GFP_KERNEL);
 	if (!s)
 		return -ENOMEM;
<span class="p_chunk">@@ -381,6 +384,22 @@</span> <span class="p_context"> static int ttusb2_i2c_xfer(struct i2c_adapter *adap,struct i2c_msg msg[],int num</span>
 		write_read = i+1 &lt; num &amp;&amp; (msg[i+1].flags &amp; I2C_M_RD);
 		read = msg[i].flags &amp; I2C_M_RD;
 
<span class="p_add">+		if (3 + msg[i].len &gt; sizeof(obuf)) {</span>
<span class="p_add">+			err(&quot;i2c wr len=%d too high&quot;, msg[i].len);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (write_read) {</span>
<span class="p_add">+			if (3 + msg[i+1].len &gt; sizeof(ibuf)) {</span>
<span class="p_add">+				err(&quot;i2c rd len=%d too high&quot;, msg[i+1].len);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else if (read) {</span>
<span class="p_add">+			if (3 + msg[i].len &gt; sizeof(ibuf)) {</span>
<span class="p_add">+				err(&quot;i2c rd len=%d too high&quot;, msg[i].len);</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		obuf[0] = (msg[i].addr &lt;&lt; 1) | (write_read | read);
 		if (read)
 			obuf[1] = 0;
<span class="p_header">diff --git a/drivers/media/usb/gspca/konica.c b/drivers/media/usb/gspca/konica.c</span>
<span class="p_header">index 39c96bb4c985..04972291a5a5 100644</span>
<span class="p_header">--- a/drivers/media/usb/gspca/konica.c</span>
<span class="p_header">+++ b/drivers/media/usb/gspca/konica.c</span>
<span class="p_chunk">@@ -188,6 +188,9 @@</span> <span class="p_context"> static int sd_start(struct gspca_dev *gspca_dev)</span>
 		return -EIO;
 	}
 
<span class="p_add">+	if (alt-&gt;desc.bNumEndpoints &lt; 2)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	packet_size = le16_to_cpu(alt-&gt;endpoint[0].desc.wMaxPacketSize);
 
 	n = gspca_dev-&gt;cam.cam_mode[gspca_dev-&gt;curr_mode].priv;
<span class="p_header">diff --git a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">index 9515f3a68f8f..122815e1cb65 100644</span>
<span class="p_header">--- a/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_header">+++ b/drivers/media/usb/pvrusb2/pvrusb2-eeprom.c</span>
<span class="p_chunk">@@ -123,15 +123,10 @@</span> <span class="p_context"> int pvr2_eeprom_analyze(struct pvr2_hdw *hdw)</span>
 	memset(&amp;tvdata,0,sizeof(tvdata));
 
 	eeprom = pvr2_eeprom_fetch(hdw);
<span class="p_del">-	if (!eeprom) return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	{</span>
<span class="p_del">-		struct i2c_client fake_client;</span>
<span class="p_del">-		/* Newer version expects a useless client interface */</span>
<span class="p_del">-		fake_client.addr = hdw-&gt;eeprom_addr;</span>
<span class="p_del">-		fake_client.adapter = &amp;hdw-&gt;i2c_adap;</span>
<span class="p_del">-		tveeprom_hauppauge_analog(&amp;fake_client,&amp;tvdata,eeprom);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!eeprom)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	tveeprom_hauppauge_analog(NULL, &amp;tvdata, eeprom);</span>
 
 	trace_eeprom(&quot;eeprom assumed v4l tveeprom module&quot;);
 	trace_eeprom(&quot;eeprom direct call results:&quot;);
<span class="p_header">diff --git a/drivers/media/usb/usbvision/usbvision-video.c b/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_header">index 354f5a7ae887..e70eca819be9 100644</span>
<span class="p_header">--- a/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_header">+++ b/drivers/media/usb/usbvision/usbvision-video.c</span>
<span class="p_chunk">@@ -1599,7 +1599,14 @@</span> <span class="p_context"> static int usbvision_probe(struct usb_interface *intf,</span>
 	}
 
 	for (i = 0; i &lt; usbvision-&gt;num_alt; i++) {
<span class="p_del">-		u16 tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[1].desc.</span>
<span class="p_add">+		u16 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (uif-&gt;altsetting[i].desc.bNumEndpoints &lt; 2) {</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto err_pkt;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		tmp = le16_to_cpu(uif-&gt;altsetting[i].endpoint[1].desc.</span>
 				      wMaxPacketSize);
 		usbvision-&gt;alt_max_pkt_size[i] =
 			(tmp &amp; 0x07ff) * (((tmp &amp; 0x1800) &gt;&gt; 11) + 1);
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_video.c b/drivers/media/usb/uvc/uvc_video.c</span>
<span class="p_header">index 9144a2f3ed82..72774f32da2e 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_video.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_video.c</span>
<span class="p_chunk">@@ -810,7 +810,7 @@</span> <span class="p_context"> static void uvc_video_stats_decode(struct uvc_streaming *stream,</span>
 
 	/* Update the packets counters. */
 	stream-&gt;stats.frame.nb_packets++;
<span class="p_del">-	if (len &gt; header_size)</span>
<span class="p_add">+	if (len &lt;= header_size)</span>
 		stream-&gt;stats.frame.nb_empty++;
 
 	if (data[1] &amp; UVC_STREAM_ERR)
<span class="p_header">diff --git a/drivers/media/usb/zr364xx/zr364xx.c b/drivers/media/usb/zr364xx/zr364xx.c</span>
<span class="p_header">index 74d56df3347f..886e64361e17 100644</span>
<span class="p_header">--- a/drivers/media/usb/zr364xx/zr364xx.c</span>
<span class="p_header">+++ b/drivers/media/usb/zr364xx/zr364xx.c</span>
<span class="p_chunk">@@ -605,6 +605,14 @@</span> <span class="p_context"> static int zr364xx_read_video_callback(struct zr364xx_camera *cam,</span>
 	ptr = pdest = frm-&gt;lpvbits;
 
 	if (frm-&gt;ulState == ZR364XX_READ_IDLE) {
<span class="p_add">+		if (purb-&gt;actual_length &lt; 128) {</span>
<span class="p_add">+			/* header incomplete */</span>
<span class="p_add">+			dev_info(&amp;cam-&gt;udev-&gt;dev,</span>
<span class="p_add">+				 &quot;%s: buffer (%d bytes) too small to hold jpeg header. Discarding.\n&quot;,</span>
<span class="p_add">+				 __func__, purb-&gt;actual_length);</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		frm-&gt;ulState = ZR364XX_READ_FRAME;
 		frm-&gt;cur_size = 0;
 
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index 0f8cd6bbe914..1224921217f2 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -376,8 +376,8 @@</span> <span class="p_context"> int omap_tll_init(struct usbhs_omap_platform_data *pdata)</span>
 				 * and use SDR Mode
 				 */
 				reg &amp;= ~(OMAP_TLL_CHANNEL_CONF_UTMIAUTOIDLE
<span class="p_del">-					| OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF</span>
 					| OMAP_TLL_CHANNEL_CONF_ULPIDDRMODE);
<span class="p_add">+				reg |= OMAP_TLL_CHANNEL_CONF_ULPINOBITSTUFF;</span>
 			} else if (pdata-&gt;port_mode[i] ==
 					OMAP_EHCI_PORT_MODE_HSIC) {
 				/*
<span class="p_header">diff --git a/drivers/mtd/nand/fsmc_nand.c b/drivers/mtd/nand/fsmc_nand.c</span>
<span class="p_header">index 1550692973dc..c593a3fbcdd9 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/fsmc_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/fsmc_nand.c</span>
<span class="p_chunk">@@ -874,18 +874,19 @@</span> <span class="p_context"> static int fsmc_nand_probe_config_dt(struct platform_device *pdev,</span>
 	struct fsmc_nand_platform_data *pdata = dev_get_platdata(&amp;pdev-&gt;dev);
 	u32 val;
 
<span class="p_del">-	/* Set default NAND width to 8 bits */</span>
<span class="p_del">-	pdata-&gt;width = 8;</span>
<span class="p_add">+	pdata-&gt;options = 0;</span>
<span class="p_add">+</span>
 	if (!of_property_read_u32(np, &quot;bank-width&quot;, &amp;val)) {
 		if (val == 2) {
<span class="p_del">-			pdata-&gt;width = 16;</span>
<span class="p_add">+			pdata-&gt;options |= NAND_BUSWIDTH_16;</span>
 		} else if (val != 1) {
 			dev_err(&amp;pdev-&gt;dev, &quot;invalid bank-width %u\n&quot;, val);
 			return -EINVAL;
 		}
 	}
<span class="p_add">+</span>
 	if (of_get_property(np, &quot;nand-skip-bbtscan&quot;, NULL))
<span class="p_del">-		pdata-&gt;options = NAND_SKIP_BBTSCAN;</span>
<span class="p_add">+		pdata-&gt;options |= NAND_SKIP_BBTSCAN;</span>
 
 	pdata-&gt;nand_timings = devm_kzalloc(&amp;pdev-&gt;dev,
 				sizeof(*pdata-&gt;nand_timings), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/tg3.c b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">index c13932e671fb..17036ff0b925 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/tg3.c</span>
<span class="p_chunk">@@ -11709,10 +11709,6 @@</span> <span class="p_context"> static int tg3_close(struct net_device *dev)</span>
 
 	tg3_stop(tp);
 
<span class="p_del">-	/* Clear stats across close / open calls */</span>
<span class="p_del">-	memset(&amp;tp-&gt;net_stats_prev, 0, sizeof(tp-&gt;net_stats_prev));</span>
<span class="p_del">-	memset(&amp;tp-&gt;estats_prev, 0, sizeof(tp-&gt;estats_prev));</span>
<span class="p_del">-</span>
 	if (pci_device_is_present(tp-&gt;pdev)) {
 		tg3_power_down_prepare(tp);
 
<span class="p_header">diff --git a/drivers/net/ethernet/freescale/ucc_geth.c b/drivers/net/ethernet/freescale/ucc_geth.c</span>
<span class="p_header">index 36fc429298e3..97e38b828a18 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/freescale/ucc_geth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/freescale/ucc_geth.c</span>
<span class="p_chunk">@@ -2590,11 +2590,10 @@</span> <span class="p_context"> static int ucc_geth_startup(struct ucc_geth_private *ugeth)</span>
 		} else if (ugeth-&gt;ug_info-&gt;uf_info.bd_mem_part ==
 			   MEM_PART_MURAM) {
 			out_be32(&amp;ugeth-&gt;p_send_q_mem_reg-&gt;sqqd[i].bd_ring_base,
<span class="p_del">-				 (u32) immrbar_virt_to_phys(ugeth-&gt;</span>
<span class="p_del">-							    p_tx_bd_ring[i]));</span>
<span class="p_add">+				 (u32)qe_muram_dma(ugeth-&gt;p_tx_bd_ring[i]));</span>
 			out_be32(&amp;ugeth-&gt;p_send_q_mem_reg-&gt;sqqd[i].
 				 last_bd_completed_address,
<span class="p_del">-				 (u32) immrbar_virt_to_phys(endOfRing));</span>
<span class="p_add">+				 (u32)qe_muram_dma(endOfRing));</span>
 		}
 	}
 
<span class="p_chunk">@@ -2840,8 +2839,7 @@</span> <span class="p_context"> static int ucc_geth_startup(struct ucc_geth_private *ugeth)</span>
 		} else if (ugeth-&gt;ug_info-&gt;uf_info.bd_mem_part ==
 			   MEM_PART_MURAM) {
 			out_be32(&amp;ugeth-&gt;p_rx_bd_qs_tbl[i].externalbdbaseptr,
<span class="p_del">-				 (u32) immrbar_virt_to_phys(ugeth-&gt;</span>
<span class="p_del">-							    p_rx_bd_ring[i]));</span>
<span class="p_add">+				 (u32)qe_muram_dma(ugeth-&gt;p_rx_bd_ring[i]));</span>
 		}
 		/* rest of fields handled by QE */
 	}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">index 92045adc74fd..d0fcb6831599 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_chunk">@@ -993,7 +993,8 @@</span> <span class="p_context"> void mlx4_en_calc_rx_buf(struct net_device *dev)</span>
 	en_dbg(DRV, priv, &quot;Rx buffer scatter-list (effective-mtu:%d num_frags:%d):\n&quot;,
 	       eff_mtu, priv-&gt;num_frags);
 	for (i = 0; i &lt; priv-&gt;num_frags; i++) {
<span class="p_del">-		en_err(priv,</span>
<span class="p_add">+		en_dbg(DRV,</span>
<span class="p_add">+		       priv,</span>
 		       &quot;  frag:%d - size:%d prefix:%d align:%d stride:%d\n&quot;,
 		       i,
 		       priv-&gt;frag_info[i].frag_size,
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/mcg.c b/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_header">index 5866499a38ca..1e459a59dc72 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_chunk">@@ -35,6 +35,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/etherdevice.h&gt;
 
 #include &lt;linux/mlx4/cmd.h&gt;
<span class="p_add">+#include &lt;linux/mlx4/qp.h&gt;</span>
 #include &lt;linux/export.h&gt;
 
 #include &quot;mlx4.h&quot;
<span class="p_chunk">@@ -889,16 +890,21 @@</span> <span class="p_context"> int mlx4_flow_attach(struct mlx4_dev *dev,</span>
 	if (IS_ERR(mailbox))
 		return PTR_ERR(mailbox);
 
<span class="p_add">+	if (!mlx4_qp_lookup(dev, rule-&gt;qpn)) {</span>
<span class="p_add">+		mlx4_err_rule(dev, &quot;QP doesn&#39;t exist\n&quot;, rule);</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	trans_rule_ctrl_to_hw(rule, mailbox-&gt;buf);
 
 	size += sizeof(struct mlx4_net_trans_rule_hw_ctrl);
 
 	list_for_each_entry(cur, &amp;rule-&gt;list, list) {
 		ret = parse_trans_rule(dev, cur, mailbox-&gt;buf + size);
<span class="p_del">-		if (ret &lt; 0) {</span>
<span class="p_del">-			mlx4_free_cmd_mailbox(dev, mailbox);</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 		size += ret;
 	}
 
<span class="p_chunk">@@ -910,6 +916,7 @@</span> <span class="p_context"> int mlx4_flow_attach(struct mlx4_dev *dev,</span>
 	else if (ret)
 		mlx4_err_rule(dev, &quot;Fail to register network rule\n&quot;, rule);
 
<span class="p_add">+out:</span>
 	mlx4_free_cmd_mailbox(dev, mailbox);
 
 	return ret;
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/qp.c b/drivers/net/ethernet/mellanox/mlx4/qp.c</span>
<span class="p_header">index 0dc31d85fc3b..aeaf888e0e73 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/qp.c</span>
<span class="p_chunk">@@ -355,6 +355,19 @@</span> <span class="p_context"> static void mlx4_qp_free_icm(struct mlx4_dev *dev, int qpn)</span>
 		__mlx4_qp_free_icm(dev, qpn);
 }
 
<span class="p_add">+struct mlx4_qp *mlx4_qp_lookup(struct mlx4_dev *dev, u32 qpn)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mlx4_qp_table *qp_table = &amp;mlx4_priv(dev)-&gt;qp_table;</span>
<span class="p_add">+	struct mlx4_qp *qp;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;qp_table-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	qp = __mlx4_qp_lookup(dev, qpn);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;qp_table-&gt;lock);</span>
<span class="p_add">+	return qp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int mlx4_qp_alloc(struct mlx4_dev *dev, int qpn, struct mlx4_qp *qp, gfp_t gfp)
 {
 	struct mlx4_priv *priv = mlx4_priv(dev);
<span class="p_header">diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c</span>
<span class="p_header">index 0ef4ee7289b4..e021332165c3 100644</span>
<span class="p_header">--- a/drivers/net/virtio_net.c</span>
<span class="p_header">+++ b/drivers/net/virtio_net.c</span>
<span class="p_chunk">@@ -27,6 +27,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/cpu.h&gt;
 #include &lt;linux/average.h&gt;
<span class="p_add">+#include &lt;net/route.h&gt;</span>
 
 static int napi_weight = NAPI_POLL_WEIGHT;
 module_param(napi_weight, int, 0444);
<span class="p_chunk">@@ -92,6 +93,9 @@</span> <span class="p_context"> struct receive_queue {</span>
 	/* RX: fragments + linear part + virtio header */
 	struct scatterlist sg[MAX_SKB_FRAGS + 2];
 
<span class="p_add">+	/* Min single buffer size for mergeable buffers case. */</span>
<span class="p_add">+	unsigned int min_buf_len;</span>
<span class="p_add">+</span>
 	/* Name of this receive queue: input.$index */
 	char name[40];
 };
<span class="p_chunk">@@ -600,13 +604,14 @@</span> <span class="p_context"> static int add_recvbuf_big(struct receive_queue *rq, gfp_t gfp)</span>
 	return err;
 }
 
<span class="p_del">-static unsigned int get_mergeable_buf_len(struct ewma *avg_pkt_len)</span>
<span class="p_add">+static unsigned int get_mergeable_buf_len(struct receive_queue *rq,</span>
<span class="p_add">+					  struct ewma *avg_pkt_len)</span>
 {
 	const size_t hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);
 	unsigned int len;
 
 	len = hdr_len + clamp_t(unsigned int, ewma_read(avg_pkt_len),
<span class="p_del">-			GOOD_PACKET_LEN, PAGE_SIZE - hdr_len);</span>
<span class="p_add">+				rq-&gt;min_buf_len - hdr_len, PAGE_SIZE - hdr_len);</span>
 	return ALIGN(len, MERGEABLE_BUFFER_ALIGN);
 }
 
<span class="p_chunk">@@ -618,7 +623,7 @@</span> <span class="p_context"> static int add_recvbuf_mergeable(struct receive_queue *rq, gfp_t gfp)</span>
 	int err;
 	unsigned int len, hole;
 
<span class="p_del">-	len = get_mergeable_buf_len(&amp;rq-&gt;mrg_avg_pkt_len);</span>
<span class="p_add">+	len = get_mergeable_buf_len(rq, &amp;rq-&gt;mrg_avg_pkt_len);</span>
 	if (unlikely(!skb_page_frag_refill(len, alloc_frag, gfp)))
 		return -ENOMEM;
 
<span class="p_chunk">@@ -1462,6 +1467,21 @@</span> <span class="p_context"> static void virtnet_del_vqs(struct virtnet_info *vi)</span>
 	virtnet_free_queues(vi);
 }
 
<span class="p_add">+/* How large should a single buffer be so a queue full of these can fit at</span>
<span class="p_add">+ * least one full packet?</span>
<span class="p_add">+ * Logic below assumes the mergeable buffer header is used.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int mergeable_min_buf_len(struct virtnet_info *vi, struct virtqueue *vq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const unsigned int hdr_len = sizeof(struct virtio_net_hdr_mrg_rxbuf);</span>
<span class="p_add">+	unsigned int rq_size = virtqueue_get_vring_size(vq);</span>
<span class="p_add">+	unsigned int packet_len = IP_MAX_MTU;</span>
<span class="p_add">+	unsigned int buf_len = hdr_len + ETH_HLEN + VLAN_HLEN + packet_len;</span>
<span class="p_add">+	unsigned int min_buf_len = DIV_ROUND_UP(buf_len, rq_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	return max(min_buf_len, hdr_len);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int virtnet_find_vqs(struct virtnet_info *vi)
 {
 	vq_callback_t **callbacks;
<span class="p_chunk">@@ -1517,6 +1537,7 @@</span> <span class="p_context"> static int virtnet_find_vqs(struct virtnet_info *vi)</span>
 
 	for (i = 0; i &lt; vi-&gt;max_queue_pairs; i++) {
 		vi-&gt;rq[i].vq = vqs[rxq2vq(i)];
<span class="p_add">+		vi-&gt;rq[i].min_buf_len = mergeable_min_buf_len(vi, vi-&gt;rq[i].vq);</span>
 		vi-&gt;sq[i].vq = vqs[txq2vq(i)];
 	}
 
<span class="p_chunk">@@ -1601,7 +1622,8 @@</span> <span class="p_context"> static ssize_t mergeable_rx_buffer_size_show(struct netdev_rx_queue *queue,</span>
 
 	BUG_ON(queue_index &gt;= vi-&gt;max_queue_pairs);
 	avg = &amp;vi-&gt;rq[queue_index].mrg_avg_pkt_len;
<span class="p_del">-	return sprintf(buf, &quot;%u\n&quot;, get_mergeable_buf_len(avg));</span>
<span class="p_add">+	return sprintf(buf, &quot;%u\n&quot;,</span>
<span class="p_add">+		       get_mergeable_buf_len(&amp;vi-&gt;rq[queue_index], avg));</span>
 }
 
 static struct rx_queue_attribute mergeable_rx_buffer_size_attribute =
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/eeprom.c b/drivers/net/wireless/ath/ath9k/eeprom.c</span>
<span class="p_header">index 2ac05486424b..ddef028875dc 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/eeprom.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/eeprom.c</span>
<span class="p_chunk">@@ -118,7 +118,7 @@</span> <span class="p_context"> static bool ath9k_hw_nvram_read_blob(struct ath_hw *ah, u32 off,</span>
 {
 	u16 *blob_data;
 
<span class="p_del">-	if (off * sizeof(u16) &gt; ah-&gt;eeprom_blob-&gt;size)</span>
<span class="p_add">+	if (off * sizeof(u16) &gt;= ah-&gt;eeprom_blob-&gt;size)</span>
 		return false;
 
 	blob_data = (u16 *)ah-&gt;eeprom_blob-&gt;data;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/hif_usb.c b/drivers/net/wireless/ath/ath9k/hif_usb.c</span>
<span class="p_header">index 8e7153b186ed..2bb8dd09fec2 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/hif_usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/hif_usb.c</span>
<span class="p_chunk">@@ -40,6 +40,8 @@</span> <span class="p_context"> static struct usb_device_id ath9k_hif_usb_ids[] = {</span>
 	{ USB_DEVICE(0x0cf3, 0xb003) }, /* Ubiquiti WifiStation Ext */
 	{ USB_DEVICE(0x0cf3, 0xb002) }, /* Ubiquiti WifiStation */
 	{ USB_DEVICE(0x057c, 0x8403) }, /* AVM FRITZ!WLAN 11N v2 USB */
<span class="p_add">+	{ USB_DEVICE(0x0471, 0x209e) }, /* Philips (or NXP) PTA01 */</span>
<span class="p_add">+	{ USB_DEVICE(0x1eda, 0x2315) }, /* AirTies */</span>
 
 	{ USB_DEVICE(0x0cf3, 0x7015),
 	  .driver_info = AR9287_USB },  /* Atheros */
<span class="p_chunk">@@ -58,6 +60,8 @@</span> <span class="p_context"> static struct usb_device_id ath9k_hif_usb_ids[] = {</span>
 	  .driver_info = AR9280_USB },  /* Buffalo WLI-UV-AG300P */
 	{ USB_DEVICE(0x04da, 0x3904),
 	  .driver_info = AR9280_USB },
<span class="p_add">+	{ USB_DEVICE(0x0930, 0x0a08),</span>
<span class="p_add">+	  .driver_info = AR9280_USB },  /* Toshiba WLM-20U2 and GN-1080 */</span>
 
 	{ USB_DEVICE(0x0cf3, 0x20ff),
 	  .driver_info = STORAGE_DEVICE },
<span class="p_chunk">@@ -1143,6 +1147,9 @@</span> <span class="p_context"> static int send_eject_command(struct usb_interface *interface)</span>
 	u8 bulk_out_ep;
 	int r;
 
<span class="p_add">+	if (iface_desc-&gt;desc.bNumEndpoints &lt; 2)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	/* Find bulk out endpoint */
 	for (r = 1; r &gt;= 0; r--) {
 		endpoint = &amp;iface_desc-&gt;endpoint[r].desc;
<span class="p_header">diff --git a/drivers/net/wireless/mwifiex/pcie.c b/drivers/net/wireless/mwifiex/pcie.c</span>
<span class="p_header">index 2cc9b6fca490..99119b45f996 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mwifiex/pcie.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mwifiex/pcie.c</span>
<span class="p_chunk">@@ -905,6 +905,7 @@</span> <span class="p_context"> static int mwifiex_pcie_delete_cmdrsp_buf(struct mwifiex_adapter *adapter)</span>
 	if (card &amp;&amp; card-&gt;cmd_buf) {
 		mwifiex_unmap_pci_memory(adapter, card-&gt;cmd_buf,
 					 PCI_DMA_TODEVICE);
<span class="p_add">+		dev_kfree_skb_any(card-&gt;cmd_buf);</span>
 	}
 	return 0;
 }
<span class="p_chunk">@@ -1446,6 +1447,11 @@</span> <span class="p_context"> mwifiex_pcie_send_cmd(struct mwifiex_adapter *adapter, struct sk_buff *skb)</span>
 		return -1;
 
 	card-&gt;cmd_buf = skb;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Need to keep a reference, since core driver might free up this</span>
<span class="p_add">+	 * buffer before we&#39;ve unmapped it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	skb_get(skb);</span>
 
 	/* To send a command, the driver will:
 		1. Write the 64bit physical address of the data buffer to
<span class="p_chunk">@@ -1542,6 +1548,7 @@</span> <span class="p_context"> static int mwifiex_pcie_process_cmd_complete(struct mwifiex_adapter *adapter)</span>
 	if (card-&gt;cmd_buf) {
 		mwifiex_unmap_pci_memory(adapter, card-&gt;cmd_buf,
 					 PCI_DMA_TODEVICE);
<span class="p_add">+		dev_kfree_skb_any(card-&gt;cmd_buf);</span>
 		card-&gt;cmd_buf = NULL;
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/zd1211rw/zd_usb.c b/drivers/net/wireless/zd1211rw/zd_usb.c</span>
<span class="p_header">index a912dc051111..8d621ee5f349 100644</span>
<span class="p_header">--- a/drivers/net/wireless/zd1211rw/zd_usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/zd1211rw/zd_usb.c</span>
<span class="p_chunk">@@ -1278,6 +1278,9 @@</span> <span class="p_context"> static int eject_installer(struct usb_interface *intf)</span>
 	u8 bulk_out_ep;
 	int r;
 
<span class="p_add">+	if (iface_desc-&gt;desc.bNumEndpoints &lt; 2)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	/* Find bulk out endpoint */
 	for (r = 1; r &gt;= 0; r--) {
 		endpoint = &amp;iface_desc-&gt;endpoint[r].desc;
<span class="p_header">diff --git a/drivers/of/address.c b/drivers/of/address.c</span>
<span class="p_header">index 5af2a0deff14..01570bf23842 100644</span>
<span class="p_header">--- a/drivers/of/address.c</span>
<span class="p_header">+++ b/drivers/of/address.c</span>
<span class="p_chunk">@@ -258,7 +258,7 @@</span> <span class="p_context"> struct of_pci_range *of_pci_range_parser_one(struct of_pci_range_parser *parser,</span>
 	if (!parser-&gt;range || parser-&gt;range + parser-&gt;np &gt; parser-&gt;end)
 		return NULL;
 
<span class="p_del">-	range-&gt;pci_space = parser-&gt;range[0];</span>
<span class="p_add">+	range-&gt;pci_space = be32_to_cpup(parser-&gt;range);</span>
 	range-&gt;flags = of_bus_pci_get_flags(parser-&gt;range);
 	range-&gt;pci_addr = of_read_number(parser-&gt;range + 1, ns);
 	range-&gt;cpu_addr = of_translate_address(parser-&gt;node,
<span class="p_header">diff --git a/drivers/pci/host/pcie-designware.c b/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">index 1eaf4df3618a..2015aef792f1 100644</span>
<span class="p_header">--- a/drivers/pci/host/pcie-designware.c</span>
<span class="p_header">+++ b/drivers/pci/host/pcie-designware.c</span>
<span class="p_chunk">@@ -158,25 +158,25 @@</span> <span class="p_context"> static struct irq_chip dw_msi_irq_chip = {</span>
 /* MSI int handler */
 irqreturn_t dw_handle_msi_irq(struct pcie_port *pp)
 {
<span class="p_del">-	unsigned long val;</span>
<span class="p_add">+	u32 val;</span>
 	int i, pos, irq;
 	irqreturn_t ret = IRQ_NONE;
 
 	for (i = 0; i &lt; MAX_MSI_CTRLS; i++) {
 		dw_pcie_rd_own_conf(pp, PCIE_MSI_INTR0_STATUS + i * 12, 4,
<span class="p_del">-				(u32 *)&amp;val);</span>
<span class="p_del">-		if (val) {</span>
<span class="p_del">-			ret = IRQ_HANDLED;</span>
<span class="p_del">-			pos = 0;</span>
<span class="p_del">-			while ((pos = find_next_bit(&amp;val, 32, pos)) != 32) {</span>
<span class="p_del">-				irq = irq_find_mapping(pp-&gt;irq_domain,</span>
<span class="p_del">-						i * 32 + pos);</span>
<span class="p_del">-				dw_pcie_wr_own_conf(pp,</span>
<span class="p_del">-						PCIE_MSI_INTR0_STATUS + i * 12,</span>
<span class="p_del">-						4, 1 &lt;&lt; pos);</span>
<span class="p_del">-				generic_handle_irq(irq);</span>
<span class="p_del">-				pos++;</span>
<span class="p_del">-			}</span>
<span class="p_add">+				    &amp;val);</span>
<span class="p_add">+		if (!val)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = IRQ_HANDLED;</span>
<span class="p_add">+		pos = 0;</span>
<span class="p_add">+		while ((pos = find_next_bit((unsigned long *) &amp;val, 32,</span>
<span class="p_add">+					    pos)) != 32) {</span>
<span class="p_add">+			irq = irq_find_mapping(pp-&gt;irq_domain, i * 32 + pos);</span>
<span class="p_add">+			dw_pcie_wr_own_conf(pp, PCIE_MSI_INTR0_STATUS + i * 12,</span>
<span class="p_add">+					    4, 1 &lt;&lt; pos);</span>
<span class="p_add">+			generic_handle_irq(irq);</span>
<span class="p_add">+			pos++;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/pci/pci-sysfs.c b/drivers/pci/pci-sysfs.c</span>
<span class="p_header">index ca5434b97ef4..7505fa72ea5d 100644</span>
<span class="p_header">--- a/drivers/pci/pci-sysfs.c</span>
<span class="p_header">+++ b/drivers/pci/pci-sysfs.c</span>
<span class="p_chunk">@@ -965,15 +965,19 @@</span> <span class="p_context"> void pci_remove_legacy_files(struct pci_bus *b)</span>
 int pci_mmap_fits(struct pci_dev *pdev, int resno, struct vm_area_struct *vma,
 		  enum pci_mmap_api mmap_api)
 {
<span class="p_del">-	unsigned long nr, start, size, pci_start;</span>
<span class="p_add">+	unsigned long nr, start, size;</span>
<span class="p_add">+	resource_size_t pci_start = 0, pci_end;</span>
 
 	if (pci_resource_len(pdev, resno) == 0)
 		return 0;
 	nr = vma_pages(vma);
 	start = vma-&gt;vm_pgoff;
 	size = ((pci_resource_len(pdev, resno) - 1) &gt;&gt; PAGE_SHIFT) + 1;
<span class="p_del">-	pci_start = (mmap_api == PCI_MMAP_PROCFS) ?</span>
<span class="p_del">-			pci_resource_start(pdev, resno) &gt;&gt; PAGE_SHIFT : 0;</span>
<span class="p_add">+	if (mmap_api == PCI_MMAP_PROCFS) {</span>
<span class="p_add">+		pci_resource_to_user(pdev, resno, &amp;pdev-&gt;resource[resno],</span>
<span class="p_add">+				     &amp;pci_start, &amp;pci_end);</span>
<span class="p_add">+		pci_start &gt;&gt;= PAGE_SHIFT;</span>
<span class="p_add">+	}</span>
 	if (start &gt;= pci_start &amp;&amp; start &lt; pci_start + size &amp;&amp;
 			start + nr &lt;= pci_start + size)
 		return 1;
<span class="p_header">diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c</span>
<span class="p_header">index 2e54269f5458..435d3830c181 100644</span>
<span class="p_header">--- a/drivers/pci/pci.c</span>
<span class="p_header">+++ b/drivers/pci/pci.c</span>
<span class="p_chunk">@@ -1676,8 +1676,8 @@</span> <span class="p_context"> static void pci_pme_list_scan(struct work_struct *work)</span>
 		}
 	}
 	if (!list_empty(&amp;pci_pme_list))
<span class="p_del">-		schedule_delayed_work(&amp;pci_pme_work,</span>
<span class="p_del">-				      msecs_to_jiffies(PME_TIMEOUT));</span>
<span class="p_add">+		queue_delayed_work(system_freezable_wq, &amp;pci_pme_work,</span>
<span class="p_add">+				   msecs_to_jiffies(PME_TIMEOUT));</span>
 	mutex_unlock(&amp;pci_pme_list_mutex);
 }
 
<span class="p_chunk">@@ -1737,8 +1737,9 @@</span> <span class="p_context"> void pci_pme_active(struct pci_dev *dev, bool enable)</span>
 			mutex_lock(&amp;pci_pme_list_mutex);
 			list_add(&amp;pme_dev-&gt;list, &amp;pci_pme_list);
 			if (list_is_singular(&amp;pci_pme_list))
<span class="p_del">-				schedule_delayed_work(&amp;pci_pme_work,</span>
<span class="p_del">-						      msecs_to_jiffies(PME_TIMEOUT));</span>
<span class="p_add">+				queue_delayed_work(system_freezable_wq,</span>
<span class="p_add">+						   &amp;pci_pme_work,</span>
<span class="p_add">+						   msecs_to_jiffies(PME_TIMEOUT));</span>
 			mutex_unlock(&amp;pci_pme_list_mutex);
 		} else {
 			mutex_lock(&amp;pci_pme_list_mutex);
<span class="p_header">diff --git a/drivers/pci/proc.c b/drivers/pci/proc.c</span>
<span class="p_header">index 3f155e78513f..66c886365fbc 100644</span>
<span class="p_header">--- a/drivers/pci/proc.c</span>
<span class="p_header">+++ b/drivers/pci/proc.c</span>
<span class="p_chunk">@@ -231,23 +231,35 @@</span> <span class="p_context"> static int proc_bus_pci_mmap(struct file *file, struct vm_area_struct *vma)</span>
 {
 	struct pci_dev *dev = PDE_DATA(file_inode(file));
 	struct pci_filp_private *fpriv = file-&gt;private_data;
<span class="p_del">-	int i, ret;</span>
<span class="p_add">+	int i, ret, write_combine = 0, res_bit;</span>
 
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
<span class="p_add">+	if (fpriv-&gt;mmap_state == pci_mmap_io)</span>
<span class="p_add">+		res_bit = IORESOURCE_IO;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		res_bit = IORESOURCE_MEM;</span>
<span class="p_add">+</span>
 	/* Make sure the caller is mapping a real resource for this device */
 	for (i = 0; i &lt; PCI_ROM_RESOURCE; i++) {
<span class="p_del">-		if (pci_mmap_fits(dev, i, vma,  PCI_MMAP_PROCFS))</span>
<span class="p_add">+		if (dev-&gt;resource[i].flags &amp; res_bit &amp;&amp;</span>
<span class="p_add">+		    pci_mmap_fits(dev, i, vma,  PCI_MMAP_PROCFS))</span>
 			break;
 	}
 
 	if (i &gt;= PCI_ROM_RESOURCE)
 		return -ENODEV;
 
<span class="p_add">+	if (fpriv-&gt;mmap_state == pci_mmap_mem &amp;&amp;</span>
<span class="p_add">+	    fpriv-&gt;write_combine) {</span>
<span class="p_add">+		if (dev-&gt;resource[i].flags &amp; IORESOURCE_PREFETCH)</span>
<span class="p_add">+			write_combine = 1;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+	}</span>
 	ret = pci_mmap_page_range(dev, vma,
<span class="p_del">-				  fpriv-&gt;mmap_state,</span>
<span class="p_del">-				  fpriv-&gt;write_combine);</span>
<span class="p_add">+				  fpriv-&gt;mmap_state, write_combine);</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 09215b036e94..914c1cbe4d3e 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -1637,6 +1637,29 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260a, quirk_intel_pcie_pm);</span>
 DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260b, quirk_intel_pcie_pm);
 
 #ifdef CONFIG_X86_IO_APIC
<span class="p_add">+static int dmi_disable_ioapicreroute(const struct dmi_system_id *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	noioapicreroute = 1;</span>
<span class="p_add">+	pr_info(&quot;%s detected: disable boot interrupt reroute\n&quot;, d-&gt;ident);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct dmi_system_id boot_interrupt_dmi_table[] = {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Systems to exclude from boot interrupt reroute quirks</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.callback = dmi_disable_ioapicreroute,</span>
<span class="p_add">+		.ident = &quot;ASUSTek Computer INC. M2N-LR&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;ASUSTek Computer INC.&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;M2N-LR&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Boot interrupts on some chipsets cannot be turned off. For these chipsets,
  * remap the original interrupt in the linux kernel to the boot interrupt, so
<span class="p_chunk">@@ -1645,6 +1668,7 @@</span> <span class="p_context"> DECLARE_PCI_FIXUP_FINAL(PCI_VENDOR_ID_INTEL,	0x260b, quirk_intel_pcie_pm);</span>
  */
 static void quirk_reroute_to_boot_interrupts_intel(struct pci_dev *dev)
 {
<span class="p_add">+	dmi_check_system(boot_interrupt_dmi_table);</span>
 	if (noioapicquirk || noioapicreroute)
 		return;
 
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/core.c b/drivers/pinctrl/sh-pfc/core.c</span>
<span class="p_header">index b9b464d0578c..1c7974d058a5 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/core.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/core.c</span>
<span class="p_chunk">@@ -529,6 +529,9 @@</span> <span class="p_context"> static int sh_pfc_probe(struct platform_device *pdev)</span>
 		ret = info-&gt;ops-&gt;init(pfc);
 		if (ret &lt; 0)
 			return ret;
<span class="p_add">+</span>
<span class="p_add">+		/* .init() may have overridden pfc-&gt;info */</span>
<span class="p_add">+		info = pfc-&gt;info;</span>
 	}
 
 	pinctrl_provide_dummies();
<span class="p_header">diff --git a/drivers/pinctrl/sh-pfc/pfc-r8a7791.c b/drivers/pinctrl/sh-pfc/pfc-r8a7791.c</span>
<span class="p_header">index 2e688dc4a3c8..34dbfae48646 100644</span>
<span class="p_header">--- a/drivers/pinctrl/sh-pfc/pfc-r8a7791.c</span>
<span class="p_header">+++ b/drivers/pinctrl/sh-pfc/pfc-r8a7791.c</span>
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* IPSR6 */
 	FN_AUDIO_CLKB, FN_STP_OPWM_0_B, FN_MSIOF1_SCK_B,
<span class="p_del">-	FN_SCIF_CLK, FN_BPFCLK_E,</span>
<span class="p_add">+	FN_SCIF_CLK, FN_DVC_MUTE, FN_BPFCLK_E,</span>
 	FN_AUDIO_CLKC, FN_SCIFB0_SCK_C, FN_MSIOF1_SYNC_B, FN_RX2,
 	FN_SCIFA2_RXD, FN_FMIN_E,
 	FN_AUDIO_CLKOUT, FN_MSIOF1_SS1_B, FN_TX2, FN_SCIFA2_TXD,
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> enum {</span>
 
 	/* IPSR6 */
 	AUDIO_CLKB_MARK, STP_OPWM_0_B_MARK, MSIOF1_SCK_B_MARK,
<span class="p_del">-	SCIF_CLK_MARK, BPFCLK_E_MARK,</span>
<span class="p_add">+	SCIF_CLK_MARK, DVC_MUTE_MARK, BPFCLK_E_MARK,</span>
 	AUDIO_CLKC_MARK, SCIFB0_SCK_C_MARK, MSIOF1_SYNC_B_MARK, RX2_MARK,
 	SCIFA2_RXD_MARK, FMIN_E_MARK,
 	AUDIO_CLKOUT_MARK, MSIOF1_SS1_B_MARK, TX2_MARK, SCIFA2_TXD_MARK,
<span class="p_chunk">@@ -999,14 +999,17 @@</span> <span class="p_context"> static const u16 pinmux_data[] = {</span>
 	PINMUX_IPSR_MODSEL_DATA(IP4_12_10, SCL2, SEL_IIC2_0),
 	PINMUX_IPSR_MODSEL_DATA(IP4_12_10, GPS_CLK_B, SEL_GPS_1),
 	PINMUX_IPSR_MODSEL_DATA(IP4_12_10, GLO_Q0_D, SEL_GPS_3),
<span class="p_add">+	PINMUX_IPSR_MODSEL_DATA(IP4_12_10, HSCK1_E, SEL_HSCIF1_4),</span>
 	PINMUX_IPSR_DATA(IP4_15_13, SSI_WS2),
 	PINMUX_IPSR_MODSEL_DATA(IP4_15_13, SDA2, SEL_IIC2_0),
 	PINMUX_IPSR_MODSEL_DATA(IP4_15_13, GPS_SIGN_B, SEL_GPS_1),
 	PINMUX_IPSR_MODSEL_DATA(IP4_15_13, RX2_E, SEL_SCIF2_4),
 	PINMUX_IPSR_MODSEL_DATA(IP4_15_13, GLO_Q1_D, SEL_GPS_3),
<span class="p_add">+	PINMUX_IPSR_MODSEL_DATA(IP4_15_13, HCTS1_N_E, SEL_HSCIF1_4),</span>
 	PINMUX_IPSR_DATA(IP4_18_16, SSI_SDATA2),
 	PINMUX_IPSR_MODSEL_DATA(IP4_18_16, GPS_MAG_B, SEL_GPS_1),
 	PINMUX_IPSR_MODSEL_DATA(IP4_18_16, TX2_E, SEL_SCIF2_4),
<span class="p_add">+	PINMUX_IPSR_MODSEL_DATA(IP4_18_16, HRTS1_N_E, SEL_HSCIF1_4),</span>
 	PINMUX_IPSR_DATA(IP4_19, SSI_SCK34),
 	PINMUX_IPSR_DATA(IP4_20, SSI_WS34),
 	PINMUX_IPSR_DATA(IP4_21, SSI_SDATA3),
<span class="p_chunk">@@ -1079,6 +1082,7 @@</span> <span class="p_context"> static const u16 pinmux_data[] = {</span>
 	PINMUX_IPSR_MODSEL_DATA(IP6_2_0, STP_OPWM_0_B, SEL_SSP_1),
 	PINMUX_IPSR_MODSEL_DATA(IP6_2_0, MSIOF1_SCK_B, SEL_SOF1_1),
 	PINMUX_IPSR_MODSEL_DATA(IP6_2_0, SCIF_CLK, SEL_SCIF_0),
<span class="p_add">+	PINMUX_IPSR_DATA(IP6_2_0, DVC_MUTE),</span>
 	PINMUX_IPSR_MODSEL_DATA(IP6_2_0, BPFCLK_E, SEL_FM_4),
 	PINMUX_IPSR_DATA(IP6_5_3, AUDIO_CLKC),
 	PINMUX_IPSR_MODSEL_DATA(IP6_5_3, SCIFB0_SCK_C, SEL_SCIFB_2),
<span class="p_chunk">@@ -1088,7 +1092,7 @@</span> <span class="p_context"> static const u16 pinmux_data[] = {</span>
 	PINMUX_IPSR_MODSEL_DATA(IP6_5_3, FMIN_E, SEL_FM_4),
 	PINMUX_IPSR_DATA(IP6_7_6, AUDIO_CLKOUT),
 	PINMUX_IPSR_MODSEL_DATA(IP6_7_6, MSIOF1_SS1_B, SEL_SOF1_1),
<span class="p_del">-	PINMUX_IPSR_MODSEL_DATA(IP6_5_3, TX2, SEL_SCIF2_0),</span>
<span class="p_add">+	PINMUX_IPSR_MODSEL_DATA(IP6_7_6, TX2, SEL_SCIF2_0),</span>
 	PINMUX_IPSR_MODSEL_DATA(IP6_7_6, SCIFA2_TXD, SEL_SCIFA2_0),
 	PINMUX_IPSR_DATA(IP6_9_8, IRQ0),
 	PINMUX_IPSR_MODSEL_DATA(IP6_9_8, SCIFB1_RXD_D, SEL_SCIFB1_3),
<span class="p_chunk">@@ -4956,7 +4960,7 @@</span> <span class="p_context"> static const struct pinmux_cfg_reg pinmux_config_regs[] = {</span>
 	},
 	{ PINMUX_CFG_REG_VAR(&quot;IPSR2&quot;, 0xE6060028, 32,
 			     2, 3, 2, 2, 2, 2, 3, 3, 3, 3, 2, 2, 3) {
<span class="p_del">-		/* IP2_31_20 [2] */</span>
<span class="p_add">+		/* IP2_31_30 [2] */</span>
 		0, 0, 0, 0,
 		/* IP2_29_27 [3] */
 		FN_EX_CS3_N, FN_ATADIR0_N, FN_MSIOF2_TXD,
<span class="p_chunk">@@ -4976,7 +4980,7 @@</span> <span class="p_context"> static const struct pinmux_cfg_reg pinmux_config_regs[] = {</span>
 		/* IP2_15_13 [3] */
 		FN_A24, FN_DREQ2, FN_IO3, FN_TX1, FN_SCIFA1_TXD,
 		0, 0, 0,
<span class="p_del">-		/* IP2_12_0 [3] */</span>
<span class="p_add">+		/* IP2_12_10 [3] */</span>
 		FN_A23, FN_IO2, FN_BPFCLK_B, FN_RX0, FN_SCIFA0_RXD,
 		0, 0, 0,
 		/* IP2_9_7 [3] */
<span class="p_chunk">@@ -5145,7 +5149,7 @@</span> <span class="p_context"> static const struct pinmux_cfg_reg pinmux_config_regs[] = {</span>
 		0, 0,
 		/* IP6_2_0 [3] */
 		FN_AUDIO_CLKB, FN_STP_OPWM_0_B, FN_MSIOF1_SCK_B,
<span class="p_del">-		FN_SCIF_CLK, 0, FN_BPFCLK_E,</span>
<span class="p_add">+		FN_SCIF_CLK, FN_DVC_MUTE, FN_BPFCLK_E,</span>
 		0, 0, }
 	},
 	{ PINMUX_CFG_REG_VAR(&quot;IPSR7&quot;, 0xE606003C, 32,
<span class="p_chunk">@@ -5287,7 +5291,7 @@</span> <span class="p_context"> static const struct pinmux_cfg_reg pinmux_config_regs[] = {</span>
 		/* IP10_24_22 [3] */
 		FN_VI0_R1, FN_VI2_DATA2, FN_GLO_I1_B, FN_TS_SCK0_C, FN_ATAG1_N,
 		0, 0, 0,
<span class="p_del">-		/* IP10_21_29 [3] */</span>
<span class="p_add">+		/* IP10_21_19 [3] */</span>
 		FN_VI0_R0, FN_VI2_DATA1, FN_GLO_I0_B,
 		FN_TS_SDATA0_C, FN_ATACS11_N,
 		0, 0, 0,
<span class="p_header">diff --git a/drivers/power/isp1704_charger.c b/drivers/power/isp1704_charger.c</span>
<span class="p_header">index 0b4cf9d63291..e5d88dd0a2f0 100644</span>
<span class="p_header">--- a/drivers/power/isp1704_charger.c</span>
<span class="p_header">+++ b/drivers/power/isp1704_charger.c</span>
<span class="p_chunk">@@ -415,6 +415,10 @@</span> <span class="p_context"> static int isp1704_charger_probe(struct platform_device *pdev)</span>
 
 		pdata = devm_kzalloc(&amp;pdev-&gt;dev,
 			sizeof(struct isp1704_charger_data), GFP_KERNEL);
<span class="p_add">+		if (!pdata) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto fail0;</span>
<span class="p_add">+		}</span>
 		pdata-&gt;enable_gpio = gpio;
 
 		dev_info(&amp;pdev-&gt;dev, &quot;init gpio %d\n&quot;, pdata-&gt;enable_gpio);
<span class="p_header">diff --git a/drivers/power/lp8788-charger.c b/drivers/power/lp8788-charger.c</span>
<span class="p_header">index 72da2a6c22db..620dc18b1137 100644</span>
<span class="p_header">--- a/drivers/power/lp8788-charger.c</span>
<span class="p_header">+++ b/drivers/power/lp8788-charger.c</span>
<span class="p_chunk">@@ -642,7 +642,7 @@</span> <span class="p_context"> static ssize_t lp8788_show_eoc_time(struct device *dev,</span>
 {
 	struct lp8788_charger *pchg = dev_get_drvdata(dev);
 	char *stime[] = { &quot;400ms&quot;, &quot;5min&quot;, &quot;10min&quot;, &quot;15min&quot;,
<span class="p_del">-			&quot;20min&quot;, &quot;25min&quot;, &quot;30min&quot; &quot;No timeout&quot; };</span>
<span class="p_add">+			&quot;20min&quot;, &quot;25min&quot;, &quot;30min&quot;, &quot;No timeout&quot; };</span>
 	u8 val;
 
 	lp8788_read_byte(pchg-&gt;lp, LP8788_CHG_EOC, &amp;val);
<span class="p_header">diff --git a/drivers/power/pda_power.c b/drivers/power/pda_power.c</span>
<span class="p_header">index 0c52e2a0d90c..3a36774cbdfe 100644</span>
<span class="p_header">--- a/drivers/power/pda_power.c</span>
<span class="p_header">+++ b/drivers/power/pda_power.c</span>
<span class="p_chunk">@@ -30,9 +30,9 @@</span> <span class="p_context"> static inline unsigned int get_irq_flags(struct resource *res)</span>
 static struct device *dev;
 static struct pda_power_pdata *pdata;
 static struct resource *ac_irq, *usb_irq;
<span class="p_del">-static struct timer_list charger_timer;</span>
<span class="p_del">-static struct timer_list supply_timer;</span>
<span class="p_del">-static struct timer_list polling_timer;</span>
<span class="p_add">+static struct delayed_work charger_work;</span>
<span class="p_add">+static struct delayed_work polling_work;</span>
<span class="p_add">+static struct delayed_work supply_work;</span>
 static int polling;
 
 #if IS_ENABLED(CONFIG_USB_PHY)
<span class="p_chunk">@@ -143,7 +143,7 @@</span> <span class="p_context"> static void update_charger(void)</span>
 	}
 }
 
<span class="p_del">-static void supply_timer_func(unsigned long unused)</span>
<span class="p_add">+static void supply_work_func(struct work_struct *work)</span>
 {
 	if (ac_status == PDA_PSY_TO_CHANGE) {
 		ac_status = new_ac_status;
<span class="p_chunk">@@ -164,11 +164,12 @@</span> <span class="p_context"> static void psy_changed(void)</span>
 	 * Okay, charger set. Now wait a bit before notifying supplicants,
 	 * charge power should stabilize.
 	 */
<span class="p_del">-	mod_timer(&amp;supply_timer,</span>
<span class="p_del">-		  jiffies + msecs_to_jiffies(pdata-&gt;wait_for_charger));</span>
<span class="p_add">+	cancel_delayed_work(&amp;supply_work);</span>
<span class="p_add">+	schedule_delayed_work(&amp;supply_work,</span>
<span class="p_add">+			      msecs_to_jiffies(pdata-&gt;wait_for_charger));</span>
 }
 
<span class="p_del">-static void charger_timer_func(unsigned long unused)</span>
<span class="p_add">+static void charger_work_func(struct work_struct *work)</span>
 {
 	update_status();
 	psy_changed();
<span class="p_chunk">@@ -187,13 +188,14 @@</span> <span class="p_context"> static irqreturn_t power_changed_isr(int irq, void *power_supply)</span>
 	 * Wait a bit before reading ac/usb line status and setting charger,
 	 * because ac/usb status readings may lag from irq.
 	 */
<span class="p_del">-	mod_timer(&amp;charger_timer,</span>
<span class="p_del">-		  jiffies + msecs_to_jiffies(pdata-&gt;wait_for_status));</span>
<span class="p_add">+	cancel_delayed_work(&amp;charger_work);</span>
<span class="p_add">+	schedule_delayed_work(&amp;charger_work,</span>
<span class="p_add">+			      msecs_to_jiffies(pdata-&gt;wait_for_status));</span>
 
 	return IRQ_HANDLED;
 }
 
<span class="p_del">-static void polling_timer_func(unsigned long unused)</span>
<span class="p_add">+static void polling_work_func(struct work_struct *work)</span>
 {
 	int changed = 0;
 
<span class="p_chunk">@@ -214,8 +216,9 @@</span> <span class="p_context"> static void polling_timer_func(unsigned long unused)</span>
 	if (changed)
 		psy_changed();
 
<span class="p_del">-	mod_timer(&amp;polling_timer,</span>
<span class="p_del">-		  jiffies + msecs_to_jiffies(pdata-&gt;polling_interval));</span>
<span class="p_add">+	cancel_delayed_work(&amp;polling_work);</span>
<span class="p_add">+	schedule_delayed_work(&amp;polling_work,</span>
<span class="p_add">+			      msecs_to_jiffies(pdata-&gt;polling_interval));</span>
 }
 
 #if IS_ENABLED(CONFIG_USB_PHY)
<span class="p_chunk">@@ -253,8 +256,9 @@</span> <span class="p_context"> static int otg_handle_notification(struct notifier_block *nb,</span>
 	 * Wait a bit before reading ac/usb line status and setting charger,
 	 * because ac/usb status readings may lag from irq.
 	 */
<span class="p_del">-	mod_timer(&amp;charger_timer,</span>
<span class="p_del">-		  jiffies + msecs_to_jiffies(pdata-&gt;wait_for_status));</span>
<span class="p_add">+	cancel_delayed_work(&amp;charger_work);</span>
<span class="p_add">+	schedule_delayed_work(&amp;charger_work,</span>
<span class="p_add">+			      msecs_to_jiffies(pdata-&gt;wait_for_status));</span>
 
 	return NOTIFY_OK;
 }
<span class="p_chunk">@@ -302,8 +306,8 @@</span> <span class="p_context"> static int pda_power_probe(struct platform_device *pdev)</span>
 	if (!pdata-&gt;ac_max_uA)
 		pdata-&gt;ac_max_uA = 500000;
 
<span class="p_del">-	setup_timer(&amp;charger_timer, charger_timer_func, 0);</span>
<span class="p_del">-	setup_timer(&amp;supply_timer, supply_timer_func, 0);</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;charger_work, charger_work_func);</span>
<span class="p_add">+	INIT_DELAYED_WORK(&amp;supply_work, supply_work_func);</span>
 
 	ac_irq = platform_get_resource_byname(pdev, IORESOURCE_IRQ, &quot;ac&quot;);
 	usb_irq = platform_get_resource_byname(pdev, IORESOURCE_IRQ, &quot;usb&quot;);
<span class="p_chunk">@@ -381,9 +385,10 @@</span> <span class="p_context"> static int pda_power_probe(struct platform_device *pdev)</span>
 
 	if (polling) {
 		dev_dbg(dev, &quot;will poll for status\n&quot;);
<span class="p_del">-		setup_timer(&amp;polling_timer, polling_timer_func, 0);</span>
<span class="p_del">-		mod_timer(&amp;polling_timer,</span>
<span class="p_del">-			  jiffies + msecs_to_jiffies(pdata-&gt;polling_interval));</span>
<span class="p_add">+		INIT_DELAYED_WORK(&amp;polling_work, polling_work_func);</span>
<span class="p_add">+		cancel_delayed_work(&amp;polling_work);</span>
<span class="p_add">+		schedule_delayed_work(&amp;polling_work,</span>
<span class="p_add">+				      msecs_to_jiffies(pdata-&gt;polling_interval));</span>
 	}
 
 	if (ac_irq || usb_irq)
<span class="p_chunk">@@ -429,9 +434,9 @@</span> <span class="p_context"> static int pda_power_remove(struct platform_device *pdev)</span>
 		free_irq(ac_irq-&gt;start, &amp;pda_psy_ac);
 
 	if (polling)
<span class="p_del">-		del_timer_sync(&amp;polling_timer);</span>
<span class="p_del">-	del_timer_sync(&amp;charger_timer);</span>
<span class="p_del">-	del_timer_sync(&amp;supply_timer);</span>
<span class="p_add">+		cancel_delayed_work_sync(&amp;polling_work);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;charger_work);</span>
<span class="p_add">+	cancel_delayed_work_sync(&amp;supply_work);</span>
 
 	if (pdata-&gt;is_usb_online)
 		power_supply_unregister(&amp;pda_psy_usb);
<span class="p_header">diff --git a/drivers/regulator/tps65023-regulator.c b/drivers/regulator/tps65023-regulator.c</span>
<span class="p_header">index 3ef67a86115c..99963b8d39e9 100644</span>
<span class="p_header">--- a/drivers/regulator/tps65023-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/tps65023-regulator.c</span>
<span class="p_chunk">@@ -293,8 +293,7 @@</span> <span class="p_context"> static int tps_65023_probe(struct i2c_client *client,</span>
 
 	/* Enable setting output voltage by I2C */
 	regmap_update_bits(tps-&gt;regmap, TPS65023_REG_CON_CTRL2,
<span class="p_del">-					TPS65023_REG_CTRL2_CORE_ADJ,</span>
<span class="p_del">-					TPS65023_REG_CTRL2_CORE_ADJ);</span>
<span class="p_add">+			   TPS65023_REG_CTRL2_CORE_ADJ, 0);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c</span>
<span class="p_header">index 07ab11da83a0..61f72dfa642d 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_error.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_error.c</span>
<span class="p_chunk">@@ -223,6 +223,23 @@</span> <span class="p_context"> scsi_abort_command(struct scsi_cmnd *scmd)</span>
 	return SUCCESS;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * scsi_eh_reset - call into -&gt;eh_action to reset internal counters</span>
<span class="p_add">+ * @scmd:	scmd to run eh on.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The scsi driver might be carrying internal state about the</span>
<span class="p_add">+ * devices, so we need to call into the driver to reset the</span>
<span class="p_add">+ * internal state once the error handler is started.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void scsi_eh_reset(struct scsi_cmnd *scmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (scmd-&gt;request-&gt;cmd_type == REQ_TYPE_FS) {</span>
<span class="p_add">+		struct scsi_driver *sdrv = scsi_cmd_to_driver(scmd);</span>
<span class="p_add">+		if (sdrv-&gt;eh_reset)</span>
<span class="p_add">+			sdrv-&gt;eh_reset(scmd);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * scsi_eh_scmd_add - add scsi cmd to error handling.
  * @scmd:	scmd to run eh on.
<span class="p_chunk">@@ -252,6 +269,7 @@</span> <span class="p_context"> int scsi_eh_scmd_add(struct scsi_cmnd *scmd, int eh_flag)</span>
 	if (scmd-&gt;eh_eflags &amp; SCSI_EH_ABORT_SCHEDULED)
 		eh_flag &amp;= ~SCSI_EH_CANCEL_CMD;
 	scmd-&gt;eh_eflags |= eh_flag;
<span class="p_add">+	scsi_eh_reset(scmd);</span>
 	list_add_tail(&amp;scmd-&gt;eh_entry, &amp;shost-&gt;eh_cmd_q);
 	shost-&gt;host_failed++;
 	scsi_eh_wakeup(shost);
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index cd90c300cec7..3dcb3c080c1e 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -112,6 +112,7 @@</span> <span class="p_context"> static void sd_rescan(struct device *);</span>
 static int sd_init_command(struct scsi_cmnd *SCpnt);
 static void sd_uninit_command(struct scsi_cmnd *SCpnt);
 static int sd_done(struct scsi_cmnd *);
<span class="p_add">+static void sd_eh_reset(struct scsi_cmnd *);</span>
 static int sd_eh_action(struct scsi_cmnd *, int);
 static void sd_read_capacity(struct scsi_disk *sdkp, unsigned char *buffer);
 static void scsi_disk_release(struct device *cdev);
<span class="p_chunk">@@ -509,6 +510,7 @@</span> <span class="p_context"> static struct scsi_driver sd_template = {</span>
 	.uninit_command		= sd_uninit_command,
 	.done			= sd_done,
 	.eh_action		= sd_eh_action,
<span class="p_add">+	.eh_reset		= sd_eh_reset,</span>
 };
 
 /*
<span class="p_chunk">@@ -1535,6 +1537,26 @@</span> <span class="p_context"> static const struct block_device_operations sd_fops = {</span>
 	.unlock_native_capacity	= sd_unlock_native_capacity,
 };
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	sd_eh_reset - reset error handling callback</span>
<span class="p_add">+ *	@scmd:		sd-issued command that has failed</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	This function is called by the SCSI midlayer before starting</span>
<span class="p_add">+ *	SCSI EH. When counting medium access failures we have to be</span>
<span class="p_add">+ *	careful to register it only only once per device and SCSI EH run;</span>
<span class="p_add">+ *	there might be several timed out commands which will cause the</span>
<span class="p_add">+ *	&#39;max_medium_access_timeouts&#39; counter to trigger after the first</span>
<span class="p_add">+ *	SCSI EH run already and set the device to offline.</span>
<span class="p_add">+ *	So this function resets the internal counter before starting SCSI EH.</span>
<span class="p_add">+ **/</span>
<span class="p_add">+static void sd_eh_reset(struct scsi_cmnd *scmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct scsi_disk *sdkp = scsi_disk(scmd-&gt;request-&gt;rq_disk);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* New SCSI EH run, reset gate variable */</span>
<span class="p_add">+	sdkp-&gt;ignore_medium_access_errors = false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	sd_eh_action - error handling callback
  *	@scmd:		sd-issued command that has failed
<span class="p_chunk">@@ -1564,7 +1586,10 @@</span> <span class="p_context"> static int sd_eh_action(struct scsi_cmnd *scmd, int eh_disp)</span>
 	 * process of recovering or has it suffered an internal failure
 	 * that prevents access to the storage medium.
 	 */
<span class="p_del">-	sdkp-&gt;medium_access_timed_out++;</span>
<span class="p_add">+	if (!sdkp-&gt;ignore_medium_access_errors) {</span>
<span class="p_add">+		sdkp-&gt;medium_access_timed_out++;</span>
<span class="p_add">+		sdkp-&gt;ignore_medium_access_errors = true;</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * If the device keeps failing read/write commands but TEST UNIT
<span class="p_header">diff --git a/drivers/scsi/sd.h b/drivers/scsi/sd.h</span>
<span class="p_header">index 3b3876696603..9b19adaba878 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.h</span>
<span class="p_header">+++ b/drivers/scsi/sd.h</span>
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"> struct scsi_disk {</span>
 	unsigned	lbpvpd : 1;
 	unsigned	ws10 : 1;
 	unsigned	ws16 : 1;
<span class="p_add">+	unsigned	ignore_medium_access_errors : 1;</span>
 };
 #define to_scsi_disk(obj) container_of(obj,struct scsi_disk,dev)
 
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/jr3_pci.c b/drivers/staging/comedi/drivers/jr3_pci.c</span>
<span class="p_header">index a8db9d86aadc..fa84814620d9 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/jr3_pci.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/jr3_pci.c</span>
<span class="p_chunk">@@ -608,7 +608,7 @@</span> <span class="p_context"> static void jr3_pci_poll_dev(unsigned long data)</span>
 		s = &amp;dev-&gt;subdevices[i];
 		spriv = s-&gt;private;
 
<span class="p_del">-		if (now &gt; spriv-&gt;next_time_min) {</span>
<span class="p_add">+		if (time_after_eq(now, spriv-&gt;next_time_min)) {</span>
 			struct jr3_pci_poll_delay sub_delay;
 
 			sub_delay = jr3_pci_poll_subdevice(s);
<span class="p_chunk">@@ -726,11 +726,12 @@</span> <span class="p_context"> static int jr3_pci_auto_attach(struct comedi_device *dev,</span>
 		s-&gt;insn_read	= jr3_pci_ai_insn_read;
 
 		spriv = jr3_pci_alloc_spriv(dev, s);
<span class="p_del">-		if (spriv) {</span>
<span class="p_del">-			/* Channel specific range and maxdata */</span>
<span class="p_del">-			s-&gt;range_table_list	= spriv-&gt;range_table_list;</span>
<span class="p_del">-			s-&gt;maxdata_list		= spriv-&gt;maxdata_list;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!spriv)</span>
<span class="p_add">+			return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Channel specific range and maxdata */</span>
<span class="p_add">+		s-&gt;range_table_list	= spriv-&gt;range_table_list;</span>
<span class="p_add">+		s-&gt;maxdata_list		= spriv-&gt;maxdata_list;</span>
 	}
 
 	/*  Reset DSP card */
<span class="p_header">diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">index 233e0768d1ef..629463beaa70 100644</span>
<span class="p_header">--- a/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">+++ b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_chunk">@@ -26,8 +26,6 @@</span> <span class="p_context"></span>
 
 #include &quot;gdm_mux.h&quot;
 
<span class="p_del">-static struct workqueue_struct *mux_rx_wq;</span>
<span class="p_del">-</span>
 static u16 packet_type[TTY_MAX_COUNT] = {0xF011, 0xF010};
 
 #define USB_DEVICE_CDC_DATA(vid, pid) \
<span class="p_chunk">@@ -277,7 +275,7 @@</span> <span class="p_context"> static void gdm_mux_rcv_complete(struct urb *urb)</span>
 		r-&gt;len = r-&gt;urb-&gt;actual_length;
 		spin_lock_irqsave(&amp;rx-&gt;to_host_lock, flags);
 		list_add_tail(&amp;r-&gt;to_host_list, &amp;rx-&gt;to_host_list);
<span class="p_del">-		queue_work(mux_rx_wq, &amp;mux_dev-&gt;work_rx.work);</span>
<span class="p_add">+		schedule_work(&amp;mux_dev-&gt;work_rx.work);</span>
 		spin_unlock_irqrestore(&amp;rx-&gt;to_host_lock, flags);
 	}
 }
<span class="p_chunk">@@ -604,6 +602,8 @@</span> <span class="p_context"> static int gdm_mux_suspend(struct usb_interface *intf, pm_message_t pm_msg)</span>
 	mux_dev = tty_dev-&gt;priv_dev;
 	rx = &amp;mux_dev-&gt;rx;
 
<span class="p_add">+	cancel_work_sync(&amp;mux_dev-&gt;work_rx.work);</span>
<span class="p_add">+</span>
 	if (mux_dev-&gt;usb_state != PM_NORMAL) {
 		pr_err(&quot;usb suspend - invalid state\n&quot;);
 		return -1;
<span class="p_chunk">@@ -659,13 +659,6 @@</span> <span class="p_context"> static struct usb_driver gdm_mux_driver = {</span>
 
 static int __init gdm_usb_mux_init(void)
 {
<span class="p_del">-</span>
<span class="p_del">-	mux_rx_wq = create_workqueue(&quot;mux_rx_wq&quot;);</span>
<span class="p_del">-	if (mux_rx_wq == NULL) {</span>
<span class="p_del">-		pr_err(&quot;work queue create fail\n&quot;);</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	register_lte_tty_driver();
 
 	return usb_register(&amp;gdm_mux_driver);
<span class="p_chunk">@@ -673,14 +666,8 @@</span> <span class="p_context"> static int __init gdm_usb_mux_init(void)</span>
 
 static void __exit gdm_usb_mux_exit(void)
 {
<span class="p_del">-	unregister_lte_tty_driver();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mux_rx_wq) {</span>
<span class="p_del">-		flush_workqueue(mux_rx_wq);</span>
<span class="p_del">-		destroy_workqueue(mux_rx_wq);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	usb_deregister(&amp;gdm_mux_driver);
<span class="p_add">+	unregister_lte_tty_driver();</span>
 }
 
 module_init(gdm_usb_mux_init);
<span class="p_header">diff --git a/drivers/staging/iio/light/tsl2x7x_core.c b/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_header">index ab338e3ddd05..66020a8406a0 100644</span>
<span class="p_header">--- a/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_header">+++ b/drivers/staging/iio/light/tsl2x7x_core.c</span>
<span class="p_chunk">@@ -849,7 +849,7 @@</span> <span class="p_context"> void tsl2x7x_prox_calculate(int *data, int length,</span>
 		tmp = data[i] - statP-&gt;mean;
 		sample_sum += tmp * tmp;
 	}
<span class="p_del">-	statP-&gt;stddev = int_sqrt((long)sample_sum)/length;</span>
<span class="p_add">+	statP-&gt;stddev = int_sqrt((long)sample_sum / length);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/staging/media/lirc/lirc_serial.c b/drivers/staging/media/lirc/lirc_serial.c</span>
<span class="p_header">index efe561cd0935..24edefc17e62 100644</span>
<span class="p_header">--- a/drivers/staging/media/lirc/lirc_serial.c</span>
<span class="p_header">+++ b/drivers/staging/media/lirc/lirc_serial.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> struct lirc_serial {</span>
 static int type;
 static int io;
 static int irq;
<span class="p_del">-static bool iommap;</span>
<span class="p_add">+static ulong iommap;</span>
 static int ioshift;
 static bool softcarrier = 1;
 static bool share_irq;
<span class="p_chunk">@@ -1205,7 +1205,7 @@</span> <span class="p_context"> module_param(io, int, S_IRUGO);</span>
 MODULE_PARM_DESC(io, &quot;I/O address base (0x3f8 or 0x2f8)&quot;);
 
 /* some architectures (e.g. intel xscale) have memory mapped registers */
<span class="p_del">-module_param(iommap, bool, S_IRUGO);</span>
<span class="p_add">+module_param(iommap, ulong, S_IRUGO);</span>
 MODULE_PARM_DESC(iommap, &quot;physical base for memory mapped I/O&quot;
 		&quot; (0 = no memory mapped io)&quot;);
 
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/core/rtw_ap.c b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">index 85fda6128db9..3782a580aea3 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/core/rtw_ap.c</span>
<span class="p_chunk">@@ -881,7 +881,7 @@</span> <span class="p_context"> int rtw_check_beacon_data(struct adapter *padapter, u8 *pbuf,  int len)</span>
 		return _FAIL;
 
 
<span class="p_del">-	if (len &gt; MAX_IE_SZ)</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; MAX_IE_SZ)</span>
 		return _FAIL;
 
 	pbss_network-&gt;IELength = len;
<span class="p_header">diff --git a/drivers/target/target_core_file.c b/drivers/target/target_core_file.c</span>
<span class="p_header">index 03bfa49b5590..d90b474c0a62 100644</span>
<span class="p_header">--- a/drivers/target/target_core_file.c</span>
<span class="p_header">+++ b/drivers/target/target_core_file.c</span>
<span class="p_chunk">@@ -743,8 +743,7 @@</span> <span class="p_context"> fd_execute_rw(struct se_cmd *cmd, struct scatterlist *sgl, u32 sgl_nents,</span>
 		return TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
 	}
 
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		target_complete_cmd(cmd, SAM_STAT_GOOD);</span>
<span class="p_add">+	target_complete_cmd(cmd, SAM_STAT_GOOD);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/tty/serial/omap-serial.c b/drivers/tty/serial/omap-serial.c</span>
<span class="p_header">index 9053aa7a970f..edaf1055d296 100644</span>
<span class="p_header">--- a/drivers/tty/serial/omap-serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/omap-serial.c</span>
<span class="p_chunk">@@ -1741,7 +1741,8 @@</span> <span class="p_context"> static int serial_omap_probe(struct platform_device *pdev)</span>
 	return 0;
 
 err_add_port:
<span class="p_del">-	pm_runtime_put(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	pm_runtime_dont_use_autosuspend(&amp;pdev-&gt;dev);</span>
<span class="p_add">+	pm_runtime_put_sync(&amp;pdev-&gt;dev);</span>
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 err_rs485:
 err_port_line:
<span class="p_chunk">@@ -1754,9 +1755,13 @@</span> <span class="p_context"> static int serial_omap_remove(struct platform_device *dev)</span>
 {
 	struct uart_omap_port *up = platform_get_drvdata(dev);
 
<span class="p_add">+	pm_runtime_get_sync(up-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	uart_remove_one_port(&amp;serial_omap_reg, &amp;up-&gt;port);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_runtime_dont_use_autosuspend(up-&gt;dev);</span>
 	pm_runtime_put_sync(up-&gt;dev);
 	pm_runtime_disable(up-&gt;dev);
<span class="p_del">-	uart_remove_one_port(&amp;serial_omap_reg, &amp;up-&gt;port);</span>
 	pm_qos_remove_request(&amp;up-&gt;pm_qos_request);
 	device_init_wakeup(&amp;dev-&gt;dev, false);
 
<span class="p_header">diff --git a/drivers/tty/serial/sh-sci.c b/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">index de3cdde1159e..b1d761e022f0 100644</span>
<span class="p_header">--- a/drivers/tty/serial/sh-sci.c</span>
<span class="p_header">+++ b/drivers/tty/serial/sh-sci.c</span>
<span class="p_chunk">@@ -1715,11 +1715,13 @@</span> <span class="p_context"> static int sci_startup(struct uart_port *port)</span>
 
 	dev_dbg(port-&gt;dev, &quot;%s(%d)\n&quot;, __func__, port-&gt;line);
 
<span class="p_add">+	sci_request_dma(port);</span>
<span class="p_add">+</span>
 	ret = sci_request_irq(s);
<span class="p_del">-	if (unlikely(ret &lt; 0))</span>
<span class="p_add">+	if (unlikely(ret &lt; 0)) {</span>
<span class="p_add">+		sci_free_dma(port);</span>
 		return ret;
<span class="p_del">-</span>
<span class="p_del">-	sci_request_dma(port);</span>
<span class="p_add">+	}</span>
 
 	spin_lock_irqsave(&amp;port-&gt;lock, flags);
 	sci_start_tx(port);
<span class="p_chunk">@@ -1741,8 +1743,8 @@</span> <span class="p_context"> static void sci_shutdown(struct uart_port *port)</span>
 	sci_stop_tx(port);
 	spin_unlock_irqrestore(&amp;port-&gt;lock, flags);
 
<span class="p_del">-	sci_free_dma(port);</span>
 	sci_free_irq(s);
<span class="p_add">+	sci_free_dma(port);</span>
 }
 
 static unsigned int sci_scbrr_calc(struct sci_port *s, unsigned int bps,
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 919dc6a1bdf3..2c34b1e444a4 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -312,6 +312,12 @@</span> <span class="p_context"> static void acm_ctrl_irq(struct urb *urb)</span>
 		break;
 
 	case USB_CDC_NOTIFY_SERIAL_STATE:
<span class="p_add">+		if (le16_to_cpu(dr-&gt;wLength) != 2) {</span>
<span class="p_add">+			dev_dbg(&amp;acm-&gt;control-&gt;dev,</span>
<span class="p_add">+				&quot;%s - malformed serial state\n&quot;, __func__);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		newctrl = get_unaligned_le16(data);
 
 		if (!acm-&gt;clocal &amp;&amp; (acm-&gt;ctrlin &amp; ~newctrl &amp; ACM_CTRL_DCD)) {
<span class="p_chunk">@@ -348,11 +354,10 @@</span> <span class="p_context"> static void acm_ctrl_irq(struct urb *urb)</span>
 
 	default:
 		dev_dbg(&amp;acm-&gt;control-&gt;dev,
<span class="p_del">-			&quot;%s - unknown notification %d received: index %d &quot;</span>
<span class="p_del">-			&quot;len %d data0 %d data1 %d\n&quot;,</span>
<span class="p_add">+			&quot;%s - unknown notification %d received: index %d len %d\n&quot;,</span>
 			__func__,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex,</span>
<span class="p_del">-			dr-&gt;wLength, data[0], data[1]);</span>
<span class="p_add">+			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+</span>
 		break;
 	}
 exit:
<span class="p_header">diff --git a/drivers/usb/core/driver.c b/drivers/usb/core/driver.c</span>
<span class="p_header">index e7bff99cdb2d..6307c94a59d4 100644</span>
<span class="p_header">--- a/drivers/usb/core/driver.c</span>
<span class="p_header">+++ b/drivers/usb/core/driver.c</span>
<span class="p_chunk">@@ -1331,6 +1331,24 @@</span> <span class="p_context"> static int usb_suspend_both(struct usb_device *udev, pm_message_t msg)</span>
 		 */
 		if (udev-&gt;parent &amp;&amp; !PMSG_IS_AUTO(msg))
 			status = 0;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If the device is inaccessible, don&#39;t try to resume</span>
<span class="p_add">+		 * suspended interfaces and just return the error.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (status &amp;&amp; status != -EBUSY) {</span>
<span class="p_add">+			int err;</span>
<span class="p_add">+			u16 devstat;</span>
<span class="p_add">+</span>
<span class="p_add">+			err = usb_get_status(udev, USB_RECIP_DEVICE, 0,</span>
<span class="p_add">+					     &amp;devstat);</span>
<span class="p_add">+			if (err) {</span>
<span class="p_add">+				dev_err(&amp;udev-&gt;dev,</span>
<span class="p_add">+					&quot;Failed to suspend device, error %d\n&quot;,</span>
<span class="p_add">+					status);</span>
<span class="p_add">+				goto done;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	/* If the suspend failed, resume interfaces that did get suspended */
<span class="p_chunk">@@ -1767,6 +1785,9 @@</span> <span class="p_context"> static int autosuspend_check(struct usb_device *udev)</span>
 	int			w, i;
 	struct usb_interface	*intf;
 
<span class="p_add">+	if (udev-&gt;state == USB_STATE_NOTATTACHED)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	/* Fail if autosuspend is disabled, or any interfaces are in use, or
 	 * any interface drivers require remote wakeup but it isn&#39;t available.
 	 */
<span class="p_header">diff --git a/drivers/usb/core/file.c b/drivers/usb/core/file.c</span>
<span class="p_header">index ea337a718cc1..b3de806085f0 100644</span>
<span class="p_header">--- a/drivers/usb/core/file.c</span>
<span class="p_header">+++ b/drivers/usb/core/file.c</span>
<span class="p_chunk">@@ -26,6 +26,7 @@</span> <span class="p_context"></span>
 #define MAX_USB_MINORS	256
 static const struct file_operations *usb_minors[MAX_USB_MINORS];
 static DECLARE_RWSEM(minor_rwsem);
<span class="p_add">+static DEFINE_MUTEX(init_usb_class_mutex);</span>
 
 static int usb_open(struct inode *inode, struct file *file)
 {
<span class="p_chunk">@@ -108,8 +109,9 @@</span> <span class="p_context"> static void release_usb_class(struct kref *kref)</span>
 
 static void destroy_usb_class(void)
 {
<span class="p_del">-	if (usb_class)</span>
<span class="p_del">-		kref_put(&amp;usb_class-&gt;kref, release_usb_class);</span>
<span class="p_add">+	mutex_lock(&amp;init_usb_class_mutex);</span>
<span class="p_add">+	kref_put(&amp;usb_class-&gt;kref, release_usb_class);</span>
<span class="p_add">+	mutex_unlock(&amp;init_usb_class_mutex);</span>
 }
 
 int usb_major_init(void)
<span class="p_chunk">@@ -171,7 +173,10 @@</span> <span class="p_context"> int usb_register_dev(struct usb_interface *intf,</span>
 	if (intf-&gt;minor &gt;= 0)
 		return -EADDRINUSE;
 
<span class="p_add">+	mutex_lock(&amp;init_usb_class_mutex);</span>
 	retval = init_usb_class();
<span class="p_add">+	mutex_unlock(&amp;init_usb_class_mutex);</span>
<span class="p_add">+</span>
 	if (retval)
 		return retval;
 
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 7a6ddda70386..7ed312aa0d2e 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -1044,6 +1044,9 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 
 		portstatus = portchange = 0;
 		status = hub_port_status(hub, port1, &amp;portstatus, &amp;portchange);
<span class="p_add">+		if (status)</span>
<span class="p_add">+			goto abort;</span>
<span class="p_add">+</span>
 		if (udev || (portstatus &amp; USB_PORT_STAT_CONNECTION))
 			dev_dbg(&amp;port_dev-&gt;dev, &quot;status %04x change %04x\n&quot;,
 					portstatus, portchange);
<span class="p_chunk">@@ -1176,7 +1179,7 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 
 	/* Scan all ports that need attention */
 	kick_khubd(hub);
<span class="p_del">-</span>
<span class="p_add">+ abort:</span>
 	/* Allow autosuspend if it was suppressed */
 	if (type &lt;= HUB_INIT3)
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
<span class="p_chunk">@@ -2066,6 +2069,12 @@</span> <span class="p_context"> void usb_disconnect(struct usb_device **pdev)</span>
 	dev_info(&amp;udev-&gt;dev, &quot;USB disconnect, device number %d\n&quot;,
 			udev-&gt;devnum);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure that the pm runtime code knows that the USB device</span>
<span class="p_add">+	 * is in the process of being disconnected.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pm_runtime_barrier(&amp;udev-&gt;dev);</span>
<span class="p_add">+</span>
 	usb_lock_device(udev);
 
 	hub_disconnect_children(udev);
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index 0333ccc27b13..601420407721 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -2459,7 +2459,7 @@</span> <span class="p_context"> int xhci_mem_init(struct xhci_hcd *xhci, gfp_t flags)</span>
 		(xhci-&gt;cmd_ring-&gt;first_seg-&gt;dma &amp; (u64) ~CMD_RING_RSVD_BITS) |
 		xhci-&gt;cmd_ring-&gt;cycle_state;
 	xhci_dbg_trace(xhci, trace_xhci_dbg_init,
<span class="p_del">-			&quot;// Setting command ring address to 0x%x&quot;, val);</span>
<span class="p_add">+			&quot;// Setting command ring address to 0x%016llx&quot;, val_64);</span>
 	xhci_write_64(xhci, val_64, &amp;xhci-&gt;op_regs-&gt;cmd_ring);
 	xhci_dbg_cmd_ptrs(xhci);
 
<span class="p_header">diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">index 042a1ad9698a..0f9b094343f5 100644</span>
<span class="p_header">--- a/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">+++ b/drivers/usb/misc/legousbtower.c</span>
<span class="p_chunk">@@ -317,9 +317,16 @@</span> <span class="p_context"> static int tower_open (struct inode *inode, struct file *file)</span>
 	int subminor;
 	int retval = 0;
 	struct usb_interface *interface;
<span class="p_del">-	struct tower_reset_reply reset_reply;</span>
<span class="p_add">+	struct tower_reset_reply *reset_reply;</span>
 	int result;
 
<span class="p_add">+	reset_reply = kmalloc(sizeof(*reset_reply), GFP_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!reset_reply) {</span>
<span class="p_add">+		retval = -ENOMEM;</span>
<span class="p_add">+		goto exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	nonseekable_open(inode, file);
 	subminor = iminor(inode);
 
<span class="p_chunk">@@ -364,8 +371,8 @@</span> <span class="p_context"> static int tower_open (struct inode *inode, struct file *file)</span>
 				  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,
 				  0,
 				  0,
<span class="p_del">-				  &amp;reset_reply,</span>
<span class="p_del">-				  sizeof(reset_reply),</span>
<span class="p_add">+				  reset_reply,</span>
<span class="p_add">+				  sizeof(*reset_reply),</span>
 				  1000);
 	if (result &lt; 0) {
 		dev_err(&amp;dev-&gt;udev-&gt;dev,
<span class="p_chunk">@@ -406,6 +413,7 @@</span> <span class="p_context"> static int tower_open (struct inode *inode, struct file *file)</span>
 	mutex_unlock(&amp;dev-&gt;lock);
 
 exit:
<span class="p_add">+	kfree(reset_reply);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -808,7 +816,7 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 	struct lego_usb_tower *dev = NULL;
 	struct usb_host_interface *iface_desc;
 	struct usb_endpoint_descriptor* endpoint;
<span class="p_del">-	struct tower_get_version_reply get_version_reply;</span>
<span class="p_add">+	struct tower_get_version_reply *get_version_reply = NULL;</span>
 	int i;
 	int retval = -ENOMEM;
 	int result;
<span class="p_chunk">@@ -898,6 +906,13 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 	dev-&gt;interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev-&gt;interrupt_in_endpoint-&gt;bInterval;
 	dev-&gt;interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev-&gt;interrupt_out_endpoint-&gt;bInterval;
 
<span class="p_add">+	get_version_reply = kmalloc(sizeof(*get_version_reply), GFP_KERNEL);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!get_version_reply) {</span>
<span class="p_add">+		retval = -ENOMEM;</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
<span class="p_chunk">@@ -905,18 +920,19 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 				  USB_TYPE_VENDOR | USB_DIR_IN | USB_RECIP_DEVICE,
 				  0,
 				  0,
<span class="p_del">-				  &amp;get_version_reply,</span>
<span class="p_del">-				  sizeof(get_version_reply),</span>
<span class="p_add">+				  get_version_reply,</span>
<span class="p_add">+				  sizeof(*get_version_reply),</span>
 				  1000);
 	if (result &lt; 0) {
 		dev_err(idev, &quot;LEGO USB Tower get version control request failed\n&quot;);
 		retval = result;
 		goto error;
 	}
<span class="p_del">-	dev_info(&amp;interface-&gt;dev, &quot;LEGO USB Tower firmware version is %d.%d &quot;</span>
<span class="p_del">-		 &quot;build %d\n&quot;, get_version_reply.major,</span>
<span class="p_del">-		 get_version_reply.minor,</span>
<span class="p_del">-		 le16_to_cpu(get_version_reply.build_no));</span>
<span class="p_add">+	dev_info(&amp;interface-&gt;dev,</span>
<span class="p_add">+		 &quot;LEGO USB Tower firmware version is %d.%d build %d\n&quot;,</span>
<span class="p_add">+		 get_version_reply-&gt;major,</span>
<span class="p_add">+		 get_version_reply-&gt;minor,</span>
<span class="p_add">+		 le16_to_cpu(get_version_reply-&gt;build_no));</span>
 
 	/* we can register the device now, as it is ready */
 	usb_set_intfdata (interface, dev);
<span class="p_chunk">@@ -937,9 +953,11 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 		 USB_MAJOR, dev-&gt;minor);
 
 exit:
<span class="p_add">+	kfree(get_version_reply);</span>
 	return retval;
 
 error:
<span class="p_add">+	kfree(get_version_reply);</span>
 	tower_delete(dev);
 	return retval;
 }
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 56f88df5906b..c709fbc271d8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -886,6 +886,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(MICROCHIP_VID, MICROCHIP_USB_BOARD_PID,
 					USB_CLASS_VENDOR_SPEC,
 					USB_SUBCLASS_VENDOR_SPEC, 0x00) },
<span class="p_add">+	{ USB_DEVICE_INTERFACE_NUMBER(ACTEL_VID, MICROSEMI_ARROW_SF2PLUS_BOARD_PID, 2) },</span>
 	{ USB_DEVICE(JETI_VID, JETI_SPC1201_PID) },
 	{ USB_DEVICE(MARVELL_VID, MARVELL_SHEEVAPLUG_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 7b2f2056b7ef..fe794427c1f6 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -873,6 +873,12 @@</span> <span class="p_context"></span>
 #define	FIC_VID			0x1457
 #define	FIC_NEO1973_DEBUG_PID	0x5118
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Actel / Microsemi</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ACTEL_VID				0x1514</span>
<span class="p_add">+#define MICROSEMI_ARROW_SF2PLUS_BOARD_PID	0x2008</span>
<span class="p_add">+</span>
 /* Olimex */
 #define OLIMEX_VID			0x15BA
 #define OLIMEX_ARM_USB_OCD_PID		0x0003
<span class="p_header">diff --git a/drivers/vfio/vfio_iommu_type1.c b/drivers/vfio/vfio_iommu_type1.c</span>
<span class="p_header">index 0e153f23c47f..94cf33846827 100644</span>
<span class="p_header">--- a/drivers/vfio/vfio_iommu_type1.c</span>
<span class="p_header">+++ b/drivers/vfio/vfio_iommu_type1.c</span>
<span class="p_chunk">@@ -128,57 +128,37 @@</span> <span class="p_context"> static void vfio_unlink_dma(struct vfio_iommu *iommu, struct vfio_dma *old)</span>
 	rb_erase(&amp;old-&gt;node, &amp;iommu-&gt;dma_list);
 }
 
<span class="p_del">-struct vwork {</span>
<span class="p_del">-	struct mm_struct	*mm;</span>
<span class="p_del">-	long			npage;</span>
<span class="p_del">-	struct work_struct	work;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* delayed decrement/increment for locked_vm */</span>
<span class="p_del">-static void vfio_lock_acct_bg(struct work_struct *work)</span>
<span class="p_add">+static int vfio_lock_acct(long npage, bool *lock_cap)</span>
 {
<span class="p_del">-	struct vwork *vwork = container_of(work, struct vwork, work);</span>
 	struct mm_struct *mm;
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	mm = vwork-&gt;mm;</span>
<span class="p_del">-	down_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_del">-	mm-&gt;locked_vm += vwork-&gt;npage;</span>
<span class="p_del">-	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_del">-	mmput(mm);</span>
<span class="p_del">-	kfree(vwork);</span>
<span class="p_del">-}</span>
<span class="p_add">+	if (!npage)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-static void vfio_lock_acct(long npage)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct vwork *vwork;</span>
<span class="p_del">-	struct mm_struct *mm;</span>
<span class="p_add">+	mm = current-&gt;mm;</span>
<span class="p_add">+	if (!mm)</span>
<span class="p_add">+		return -ESRCH; /* process exited */</span>
 
<span class="p_del">-	if (!current-&gt;mm || !npage)</span>
<span class="p_del">-		return; /* process exited or nothing to do */</span>
<span class="p_add">+	ret = 0;</span>
<span class="p_add">+	down_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+	if (npage &gt; 0) {</span>
<span class="p_add">+		if (lock_cap ? !*lock_cap : !capable(CAP_IPC_LOCK)) {</span>
<span class="p_add">+			unsigned long limit;</span>
 
<span class="p_del">-	if (down_write_trylock(&amp;current-&gt;mm-&gt;mmap_sem)) {</span>
<span class="p_del">-		current-&gt;mm-&gt;locked_vm += npage;</span>
<span class="p_del">-		up_write(&amp;current-&gt;mm-&gt;mmap_sem);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_add">+			limit = rlimit(RLIMIT_MEMLOCK) &gt;&gt; PAGE_SHIFT;</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Couldn&#39;t get mmap_sem lock, so must setup to update</span>
<span class="p_del">-	 * mm-&gt;locked_vm later. If locked_vm were atomic, we</span>
<span class="p_del">-	 * wouldn&#39;t need this silliness</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	vwork = kmalloc(sizeof(struct vwork), GFP_KERNEL);</span>
<span class="p_del">-	if (!vwork)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	mm = get_task_mm(current);</span>
<span class="p_del">-	if (!mm) {</span>
<span class="p_del">-		kfree(vwork);</span>
<span class="p_del">-		return;</span>
<span class="p_add">+			if (mm-&gt;locked_vm + npage &gt; limit)</span>
<span class="p_add">+				ret = -ENOMEM;</span>
<span class="p_add">+		}</span>
 	}
<span class="p_del">-	INIT_WORK(&amp;vwork-&gt;work, vfio_lock_acct_bg);</span>
<span class="p_del">-	vwork-&gt;mm = mm;</span>
<span class="p_del">-	vwork-&gt;npage = npage;</span>
<span class="p_del">-	schedule_work(&amp;vwork-&gt;work);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		mm-&gt;locked_vm += npage;</span>
<span class="p_add">+</span>
<span class="p_add">+	up_write(&amp;mm-&gt;mmap_sem);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -260,7 +240,7 @@</span> <span class="p_context"> static int vaddr_get_pfn(unsigned long vaddr, int prot, unsigned long *pfn)</span>
 static long vfio_pin_pages(unsigned long vaddr, long npage,
 			   int prot, unsigned long *pfn_base)
 {
<span class="p_del">-	unsigned long limit = rlimit(RLIMIT_MEMLOCK) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+	unsigned long pfn = 0, limit = rlimit(RLIMIT_MEMLOCK) &gt;&gt; PAGE_SHIFT;</span>
 	bool lock_cap = capable(CAP_IPC_LOCK);
 	long ret, i;
 
<span class="p_chunk">@@ -282,14 +262,13 @@</span> <span class="p_context"> static long vfio_pin_pages(unsigned long vaddr, long npage,</span>
 	}
 
 	if (unlikely(disable_hugepages)) {
<span class="p_del">-		vfio_lock_acct(1);</span>
<span class="p_del">-		return 1;</span>
<span class="p_add">+		ret = vfio_lock_acct(1, &amp;lock_cap);</span>
<span class="p_add">+		i = 1;</span>
<span class="p_add">+		goto unpin_out;</span>
 	}
 
 	/* Lock all the consecutive pages from pfn_base */
 	for (i = 1, vaddr += PAGE_SIZE; i &lt; npage; i++, vaddr += PAGE_SIZE) {
<span class="p_del">-		unsigned long pfn = 0;</span>
<span class="p_del">-</span>
 		ret = vaddr_get_pfn(vaddr, prot, &amp;pfn);
 		if (ret)
 			break;
<span class="p_chunk">@@ -303,11 +282,20 @@</span> <span class="p_context"> static long vfio_pin_pages(unsigned long vaddr, long npage,</span>
 			put_pfn(pfn, prot);
 			pr_warn(&quot;%s: RLIMIT_MEMLOCK (%ld) exceeded\n&quot;,
 				__func__, limit &lt;&lt; PAGE_SHIFT);
<span class="p_del">-			break;</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto unpin_out;</span>
 		}
 	}
 
<span class="p_del">-	vfio_lock_acct(i);</span>
<span class="p_add">+	ret = vfio_lock_acct(i, &amp;lock_cap);</span>
<span class="p_add">+</span>
<span class="p_add">+unpin_out:</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		for (pfn = *pfn_base ; i ; pfn++, i--)</span>
<span class="p_add">+			put_pfn(pfn, prot);</span>
<span class="p_add">+</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
 
 	return i;
 }
<span class="p_chunk">@@ -322,7 +310,7 @@</span> <span class="p_context"> static long vfio_unpin_pages(unsigned long pfn, long npage,</span>
 		unlocked += put_pfn(pfn++, prot);
 
 	if (do_accounting)
<span class="p_del">-		vfio_lock_acct(-unlocked);</span>
<span class="p_add">+		vfio_lock_acct(-unlocked, NULL);</span>
 
 	return unlocked;
 }
<span class="p_chunk">@@ -368,7 +356,7 @@</span> <span class="p_context"> static void vfio_unmap_unpin(struct vfio_iommu *iommu, struct vfio_dma *dma)</span>
 		iova += unmapped;
 	}
 
<span class="p_del">-	vfio_lock_acct(-unlocked);</span>
<span class="p_add">+	vfio_lock_acct(-unlocked, NULL);</span>
 }
 
 static void vfio_remove_dma(struct vfio_iommu *iommu, struct vfio_dma *dma)
<span class="p_header">diff --git a/drivers/video/Makefile b/drivers/video/Makefile</span>
<span class="p_header">index 9ad3c17d6456..445b2c230b56 100644</span>
<span class="p_header">--- a/drivers/video/Makefile</span>
<span class="p_header">+++ b/drivers/video/Makefile</span>
<span class="p_chunk">@@ -2,6 +2,7 @@</span> <span class="p_context"> obj-$(CONFIG_VGASTATE)            += vgastate.o</span>
 obj-$(CONFIG_HDMI)                += hdmi.o
 
 obj-$(CONFIG_VT)		  += console/
<span class="p_add">+obj-$(CONFIG_FB_STI)		  += console/</span>
 obj-$(CONFIG_LOGO)		  += logo/
 obj-y				  += backlight/
 
<span class="p_header">diff --git a/drivers/video/fbdev/Kconfig b/drivers/video/fbdev/Kconfig</span>
<span class="p_header">index fac73ceb90e5..81ff9b68da3e 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/Kconfig</span>
<span class="p_header">+++ b/drivers/video/fbdev/Kconfig</span>
<span class="p_chunk">@@ -650,8 +650,6 @@</span> <span class="p_context"> config FB_STI</span>
 	select FB_CFB_FILLRECT
 	select FB_CFB_COPYAREA
 	select FB_CFB_IMAGEBLIT
<span class="p_del">-	select STI_CONSOLE</span>
<span class="p_del">-	select VT</span>
 	default y
 	---help---
 	  STI refers to the HP &quot;Standard Text Interface&quot; which is a set of
<span class="p_header">diff --git a/fs/ceph/xattr.c b/fs/ceph/xattr.c</span>
<span class="p_header">index c9c2b887381e..335064342f92 100644</span>
<span class="p_header">--- a/fs/ceph/xattr.c</span>
<span class="p_header">+++ b/fs/ceph/xattr.c</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> static int __set_xattr(struct ceph_inode_info *ci,</span>
 
 	if (update_xattr) {
 		int err = 0;
<span class="p_add">+</span>
 		if (xattr &amp;&amp; (flags &amp; XATTR_CREATE))
 			err = -EEXIST;
 		else if (!xattr &amp;&amp; (flags &amp; XATTR_REPLACE))
<span class="p_chunk">@@ -376,12 +377,14 @@</span> <span class="p_context"> static int __set_xattr(struct ceph_inode_info *ci,</span>
 		if (err) {
 			kfree(name);
 			kfree(val);
<span class="p_add">+			kfree(*newxattr);</span>
 			return err;
 		}
 		if (update_xattr &lt; 0) {
 			if (xattr)
 				__remove_xattr(ci, xattr);
 			kfree(name);
<span class="p_add">+			kfree(*newxattr);</span>
 			return 0;
 		}
 	}
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index a219cf00c2f0..f16839ccf1eb 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> extern mempool_t *cifs_req_poolp;</span>
 extern mempool_t *cifs_mid_poolp;
 
 struct workqueue_struct	*cifsiod_wq;
<span class="p_add">+struct workqueue_struct	*cifsoplockd_wq;</span>
 
 /*
  * Bumps refcount for cifs super block.
<span class="p_chunk">@@ -1210,9 +1211,16 @@</span> <span class="p_context"> init_cifs(void)</span>
 		goto out_clean_proc;
 	}
 
<span class="p_add">+	cifsoplockd_wq = alloc_workqueue(&quot;cifsoplockd&quot;,</span>
<span class="p_add">+					 WQ_FREEZABLE|WQ_MEM_RECLAIM, 0);</span>
<span class="p_add">+	if (!cifsoplockd_wq) {</span>
<span class="p_add">+		rc = -ENOMEM;</span>
<span class="p_add">+		goto out_destroy_cifsiod_wq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rc = cifs_fscache_register();
 	if (rc)
<span class="p_del">-		goto out_destroy_wq;</span>
<span class="p_add">+		goto out_destroy_cifsoplockd_wq;</span>
 
 	rc = cifs_init_inodecache();
 	if (rc)
<span class="p_chunk">@@ -1260,7 +1268,9 @@</span> <span class="p_context"> init_cifs(void)</span>
 	cifs_destroy_inodecache();
 out_unreg_fscache:
 	cifs_fscache_unregister();
<span class="p_del">-out_destroy_wq:</span>
<span class="p_add">+out_destroy_cifsoplockd_wq:</span>
<span class="p_add">+	destroy_workqueue(cifsoplockd_wq);</span>
<span class="p_add">+out_destroy_cifsiod_wq:</span>
 	destroy_workqueue(cifsiod_wq);
 out_clean_proc:
 	cifs_proc_clean();
<span class="p_chunk">@@ -1283,6 +1293,7 @@</span> <span class="p_context"> exit_cifs(void)</span>
 	cifs_destroy_mids();
 	cifs_destroy_inodecache();
 	cifs_fscache_unregister();
<span class="p_add">+	destroy_workqueue(cifsoplockd_wq);</span>
 	destroy_workqueue(cifsiod_wq);
 	cifs_proc_clean();
 }
<span class="p_header">diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h</span>
<span class="p_header">index 7f2beb757957..dfdb22f6b419 100644</span>
<span class="p_header">--- a/fs/cifs/cifsglob.h</span>
<span class="p_header">+++ b/fs/cifs/cifsglob.h</span>
<span class="p_chunk">@@ -1581,6 +1581,7 @@</span> <span class="p_context"> void cifs_oplock_break(struct work_struct *work);</span>
 
 extern const struct slow_work_ops cifs_oplock_break_ops;
 extern struct workqueue_struct *cifsiod_wq;
<span class="p_add">+extern struct workqueue_struct *cifsoplockd_wq;</span>
 
 extern mempool_t *cifs_mid_poolp;
 
<span class="p_header">diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c</span>
<span class="p_header">index 90c8558383f5..36344cb2f1ca 100644</span>
<span class="p_header">--- a/fs/cifs/cifssmb.c</span>
<span class="p_header">+++ b/fs/cifs/cifssmb.c</span>
<span class="p_chunk">@@ -720,6 +720,9 @@</span> <span class="p_context"> CIFSSMBEcho(struct TCP_Server_Info *server)</span>
 	if (rc)
 		return rc;
 
<span class="p_add">+	if (server-&gt;capabilities &amp; CAP_UNICODE)</span>
<span class="p_add">+		smb-&gt;hdr.Flags2 |= SMBFLG2_UNICODE;</span>
<span class="p_add">+</span>
 	/* set up echo request */
 	smb-&gt;hdr.Tid = 0xffff;
 	smb-&gt;hdr.WordCount = 1;
<span class="p_header">diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c</span>
<span class="p_header">index 5b3735b3ca85..9f0808335536 100644</span>
<span class="p_header">--- a/fs/cifs/misc.c</span>
<span class="p_header">+++ b/fs/cifs/misc.c</span>
<span class="p_chunk">@@ -483,7 +483,7 @@</span> <span class="p_context"> is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)</span>
 					   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,
 					   &amp;pCifsInode-&gt;flags);
 
<span class="p_del">-				queue_work(cifsiod_wq,</span>
<span class="p_add">+				queue_work(cifsoplockd_wq,</span>
 					   &amp;netfile-&gt;oplock_break);
 				netfile-&gt;oplock_break_cancelled = false;
 
<span class="p_header">diff --git a/fs/cifs/netmisc.c b/fs/cifs/netmisc.c</span>
<span class="p_header">index 6834b9c3bec1..f2cb1db1b202 100644</span>
<span class="p_header">--- a/fs/cifs/netmisc.c</span>
<span class="p_header">+++ b/fs/cifs/netmisc.c</span>
<span class="p_chunk">@@ -966,10 +966,10 @@</span> <span class="p_context"> struct timespec cnvrtDosUnixTm(__le16 le_date, __le16 le_time, int offset)</span>
 		cifs_dbg(VFS, &quot;illegal hours %d\n&quot;, st-&gt;Hours);
 	days = sd-&gt;Day;
 	month = sd-&gt;Month;
<span class="p_del">-	if ((days &gt; 31) || (month &gt; 12)) {</span>
<span class="p_add">+	if (days &lt; 1 || days &gt; 31 || month &lt; 1 || month &gt; 12) {</span>
 		cifs_dbg(VFS, &quot;illegal date, month %d day: %d\n&quot;, month, days);
<span class="p_del">-		if (month &gt; 12)</span>
<span class="p_del">-			month = 12;</span>
<span class="p_add">+		days = clamp(days, 1, 31);</span>
<span class="p_add">+		month = clamp(month, 1, 12);</span>
 	}
 	month -= 1;
 	days += total_days_of_prev_months[month];
<span class="p_header">diff --git a/fs/cifs/smb2misc.c b/fs/cifs/smb2misc.c</span>
<span class="p_header">index 9f94c91ed458..ed976a94791c 100644</span>
<span class="p_header">--- a/fs/cifs/smb2misc.c</span>
<span class="p_header">+++ b/fs/cifs/smb2misc.c</span>
<span class="p_chunk">@@ -447,7 +447,7 @@</span> <span class="p_context"> smb2_tcon_has_lease(struct cifs_tcon *tcon, struct smb2_lease_break *rsp,</span>
 		else
 			cfile-&gt;oplock_break_cancelled = true;
 
<span class="p_del">-		queue_work(cifsiod_wq, &amp;cfile-&gt;oplock_break);</span>
<span class="p_add">+		queue_work(cifsoplockd_wq, &amp;cfile-&gt;oplock_break);</span>
 		kfree(lw);
 		return true;
 	}
<span class="p_chunk">@@ -591,7 +591,8 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 					   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,
 					   &amp;cinode-&gt;flags);
 				spin_unlock(&amp;cfile-&gt;file_info_lock);
<span class="p_del">-				queue_work(cifsiod_wq, &amp;cfile-&gt;oplock_break);</span>
<span class="p_add">+				queue_work(cifsoplockd_wq,</span>
<span class="p_add">+					   &amp;cfile-&gt;oplock_break);</span>
 
 				spin_unlock(&amp;tcon-&gt;open_file_lock);
 				spin_unlock(&amp;cifs_tcp_ses_lock);
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index bdc5fb4cb181..07d2f1c659e2 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -524,8 +524,12 @@</span> <span class="p_context"> int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)</span>
 	}
 
 	if (rsplen != sizeof(struct validate_negotiate_info_rsp)) {
<span class="p_del">-		cifs_dbg(VFS, &quot;invalid size of protocol negotiate response\n&quot;);</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;invalid protocol negotiate response size: %d\n&quot;,</span>
<span class="p_add">+			 rsplen);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* relax check since Mac returns max bufsize allowed on ioctl */</span>
<span class="p_add">+		if (rsplen &gt; CIFSMaxBufSize)</span>
<span class="p_add">+			return -EIO;</span>
 	}
 
 	/* check validate negotiate info response matches what we got earlier */
<span class="p_chunk">@@ -1293,8 +1297,12 @@</span> <span class="p_context"> SMB2_ioctl(const unsigned int xid, struct cifs_tcon *tcon, u64 persistent_fid,</span>
 	 * than one credit. Windows typically sets this smaller, but for some
 	 * ioctls it may be useful to allow server to send more. No point
 	 * limiting what the server can send as long as fits in one credit
<span class="p_add">+	 * Unfortunately - we can not handle more than CIFS_MAX_MSG_SIZE</span>
<span class="p_add">+	 * (by default, note that it can be overridden to make max larger)</span>
<span class="p_add">+	 * in responses (except for read responses which can be bigger.</span>
<span class="p_add">+	 * We may want to bump this limit up</span>
 	 */
<span class="p_del">-	req-&gt;MaxOutputResponse = cpu_to_le32(0xFF00); /* &lt; 64K uses 1 credit */</span>
<span class="p_add">+	req-&gt;MaxOutputResponse = cpu_to_le32(CIFSMaxBufSize);</span>
 
 	if (is_fsctl)
 		req-&gt;Flags = cpu_to_le32(SMB2_0_IOCTL_IS_FSCTL);
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 40b3fc1fb608..c35d0ee1a7da 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -244,6 +244,43 @@</span> <span class="p_context"> static void __d_free(struct rcu_head *head)</span>
 	kmem_cache_free(dentry_cache, dentry); 
 }
 
<span class="p_add">+void take_dentry_name_snapshot(struct name_snapshot *name, struct dentry *dentry)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spin_lock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+	if (unlikely(dname_external(dentry))) {</span>
<span class="p_add">+		u32 len;</span>
<span class="p_add">+		char *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (;;) {</span>
<span class="p_add">+			len = dentry-&gt;d_name.len;</span>
<span class="p_add">+			spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+			p = kmalloc(len + 1, GFP_KERNEL | __GFP_NOFAIL);</span>
<span class="p_add">+</span>
<span class="p_add">+			spin_lock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+			if (dentry-&gt;d_name.len &lt;= len)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			kfree(p);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		memcpy(p, dentry-&gt;d_name.name, dentry-&gt;d_name.len + 1);</span>
<span class="p_add">+		spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		name-&gt;name = p;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		memcpy(name-&gt;inline_name, dentry-&gt;d_iname, DNAME_INLINE_LEN);</span>
<span class="p_add">+		spin_unlock(&amp;dentry-&gt;d_lock);</span>
<span class="p_add">+		name-&gt;name = name-&gt;inline_name;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(take_dentry_name_snapshot);</span>
<span class="p_add">+</span>
<span class="p_add">+void release_dentry_name_snapshot(struct name_snapshot *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (unlikely(name-&gt;name != name-&gt;inline_name))</span>
<span class="p_add">+		kfree(name-&gt;name);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(release_dentry_name_snapshot);</span>
<span class="p_add">+</span>
 static void dentry_free(struct dentry *dentry)
 {
 	WARN_ON(!hlist_unhashed(&amp;dentry-&gt;d_u.d_alias));
<span class="p_header">diff --git a/fs/debugfs/inode.c b/fs/debugfs/inode.c</span>
<span class="p_header">index 75c865bd376d..79f310d80baf 100644</span>
<span class="p_header">--- a/fs/debugfs/inode.c</span>
<span class="p_header">+++ b/fs/debugfs/inode.c</span>
<span class="p_chunk">@@ -620,7 +620,7 @@</span> <span class="p_context"> struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,</span>
 {
 	int error;
 	struct dentry *dentry = NULL, *trap;
<span class="p_del">-	const char *old_name;</span>
<span class="p_add">+	struct name_snapshot old_name;</span>
 
 	trap = lock_rename(new_dir, old_dir);
 	/* Source or destination directories don&#39;t exist? */
<span class="p_chunk">@@ -635,19 +635,19 @@</span> <span class="p_context"> struct dentry *debugfs_rename(struct dentry *old_dir, struct dentry *old_dentry,</span>
 	if (IS_ERR(dentry) || dentry == trap || dentry-&gt;d_inode)
 		goto exit;
 
<span class="p_del">-	old_name = fsnotify_oldname_init(old_dentry-&gt;d_name.name);</span>
<span class="p_add">+	take_dentry_name_snapshot(&amp;old_name, old_dentry);</span>
 
 	error = simple_rename(old_dir-&gt;d_inode, old_dentry, new_dir-&gt;d_inode,
 		dentry);
 	if (error) {
<span class="p_del">-		fsnotify_oldname_free(old_name);</span>
<span class="p_add">+		release_dentry_name_snapshot(&amp;old_name);</span>
 		goto exit;
 	}
 	d_move(old_dentry, dentry);
<span class="p_del">-	fsnotify_move(old_dir-&gt;d_inode, new_dir-&gt;d_inode, old_name,</span>
<span class="p_add">+	fsnotify_move(old_dir-&gt;d_inode, new_dir-&gt;d_inode, old_name.name,</span>
 		S_ISDIR(old_dentry-&gt;d_inode-&gt;i_mode),
 		NULL, old_dentry);
<span class="p_del">-	fsnotify_oldname_free(old_name);</span>
<span class="p_add">+	release_dentry_name_snapshot(&amp;old_name);</span>
 	unlock_rename(new_dir, old_dir);
 	dput(dentry);
 	return old_dentry;
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 7719a2a52c97..a7702f41cf95 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -5273,6 +5273,11 @@</span> <span class="p_context"> int ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)</span>
 
 	sb_start_pagefault(inode-&gt;i_sb);
 	file_update_time(vma-&gt;vm_file);
<span class="p_add">+</span>
<span class="p_add">+	ret = ext4_convert_inline_data(inode);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out_ret;</span>
<span class="p_add">+</span>
 	/* Delalloc case is easy... */
 	if (test_opt(inode-&gt;i_sb, DELALLOC) &amp;&amp;
 	    !ext4_should_journal_data(inode) &amp;&amp;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index 55c97a75e5a7..134ca0e00d81 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -3086,7 +3086,7 @@</span> <span class="p_context"> static int do_last(struct nameidata *nd, struct path *path,</span>
 	error = open_check_o_direct(file);
 	if (error)
 		goto exit_fput;
<span class="p_del">-	error = ima_file_check(file, op-&gt;acc_mode);</span>
<span class="p_add">+	error = ima_file_check(file, op-&gt;acc_mode, *opened);</span>
 	if (error)
 		goto exit_fput;
 
<span class="p_chunk">@@ -4082,11 +4082,11 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 {
 	int error;
 	bool is_dir = d_is_dir(old_dentry);
<span class="p_del">-	const unsigned char *old_name;</span>
 	struct inode *source = old_dentry-&gt;d_inode;
 	struct inode *target = new_dentry-&gt;d_inode;
 	bool new_is_dir = false;
 	unsigned max_links = new_dir-&gt;i_sb-&gt;s_max_links;
<span class="p_add">+	struct name_snapshot old_name;</span>
 
 	if (source == target)
 		return 0;
<span class="p_chunk">@@ -4136,7 +4136,7 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 	if (error)
 		return error;
 
<span class="p_del">-	old_name = fsnotify_oldname_init(old_dentry-&gt;d_name.name);</span>
<span class="p_add">+	take_dentry_name_snapshot(&amp;old_name, old_dentry);</span>
 	dget(new_dentry);
 	if (!is_dir || (flags &amp; RENAME_EXCHANGE))
 		lock_two_nondirectories(source, target);
<span class="p_chunk">@@ -4195,14 +4195,14 @@</span> <span class="p_context"> int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,</span>
 		mutex_unlock(&amp;target-&gt;i_mutex);
 	dput(new_dentry);
 	if (!error) {
<span class="p_del">-		fsnotify_move(old_dir, new_dir, old_name, is_dir,</span>
<span class="p_add">+		fsnotify_move(old_dir, new_dir, old_name.name, is_dir,</span>
 			      !(flags &amp; RENAME_EXCHANGE) ? target : NULL, old_dentry);
 		if (flags &amp; RENAME_EXCHANGE) {
 			fsnotify_move(new_dir, old_dir, old_dentry-&gt;d_name.name,
 				      new_is_dir, NULL, new_dentry);
 		}
 	}
<span class="p_del">-	fsnotify_oldname_free(old_name);</span>
<span class="p_add">+	release_dentry_name_snapshot(&amp;old_name);</span>
 
 	return error;
 }
<span class="p_header">diff --git a/fs/nfs/pagelist.c b/fs/nfs/pagelist.c</span>
<span class="p_header">index a60f64d88df3..9fc33210f68f 100644</span>
<span class="p_header">--- a/fs/nfs/pagelist.c</span>
<span class="p_header">+++ b/fs/nfs/pagelist.c</span>
<span class="p_chunk">@@ -29,13 +29,14 @@</span> <span class="p_context"></span>
 static struct kmem_cache *nfs_page_cachep;
 static const struct rpc_call_ops nfs_pgio_common_ops;
 
<span class="p_del">-static bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount)</span>
<span class="p_add">+static bool nfs_pgarray_set(struct nfs_page_array *p, unsigned int pagecount,</span>
<span class="p_add">+					gfp_t gfp_flags)</span>
 {
 	p-&gt;npages = pagecount;
 	if (pagecount &lt;= ARRAY_SIZE(p-&gt;page_array))
 		p-&gt;pagevec = p-&gt;page_array;
 	else {
<span class="p_del">-		p-&gt;pagevec = kcalloc(pagecount, sizeof(struct page *), GFP_KERNEL);</span>
<span class="p_add">+		p-&gt;pagevec = kcalloc(pagecount, sizeof(struct page *), gfp_flags);</span>
 		if (!p-&gt;pagevec)
 			p-&gt;npages = 0;
 	}
<span class="p_chunk">@@ -739,9 +740,12 @@</span> <span class="p_context"> int nfs_generic_pgio(struct nfs_pageio_descriptor *desc,</span>
 	struct list_head *head = &amp;desc-&gt;pg_list;
 	struct nfs_commit_info cinfo;
 	unsigned int pagecount, pageused;
<span class="p_add">+	gfp_t gfp_flags = GFP_KERNEL;</span>
 
 	pagecount = nfs_page_array_len(desc-&gt;pg_base, desc-&gt;pg_count);
<span class="p_del">-	if (!nfs_pgarray_set(&amp;hdr-&gt;page_array, pagecount))</span>
<span class="p_add">+	if (desc-&gt;pg_rw_ops-&gt;rw_mode == FMODE_WRITE)</span>
<span class="p_add">+		gfp_flags = GFP_NOIO;</span>
<span class="p_add">+	if (!nfs_pgarray_set(&amp;hdr-&gt;page_array, pagecount, gfp_flags))</span>
 		return nfs_pgio_error(desc, hdr);
 
 	nfs_init_cinfo(&amp;cinfo, desc-&gt;pg_inode, desc-&gt;pg_dreq);
<span class="p_header">diff --git a/fs/nfsd/vfs.c b/fs/nfsd/vfs.c</span>
<span class="p_header">index 5c7f72cea0de..2f5de024f204 100644</span>
<span class="p_header">--- a/fs/nfsd/vfs.c</span>
<span class="p_header">+++ b/fs/nfsd/vfs.c</span>
<span class="p_chunk">@@ -736,7 +736,7 @@</span> <span class="p_context"> nfsd_open(struct svc_rqst *rqstp, struct svc_fh *fhp, umode_t type,</span>
 		host_err = PTR_ERR(*filp);
 		*filp = NULL;
 	} else {
<span class="p_del">-		host_err = ima_file_check(*filp, may_flags);</span>
<span class="p_add">+		host_err = ima_file_check(*filp, may_flags, 0);</span>
 
 		if (may_flags &amp; NFSD_MAY_64BIT_COOKIE)
 			(*filp)-&gt;f_mode |= FMODE_64BITHASH;
<span class="p_header">diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">index 394da4dc45e1..1c1a3afd434e 100644</span>
<span class="p_header">--- a/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">+++ b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_chunk">@@ -294,27 +294,37 @@</span> <span class="p_context"> static ssize_t fanotify_read(struct file *file, char __user *buf,</span>
 		}
 
 		ret = copy_event_to_user(group, kevent, buf);
<span class="p_add">+		if (unlikely(ret == -EOPENSTALE)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We cannot report events with stale fd so drop it.</span>
<span class="p_add">+			 * Setting ret to 0 will continue the event loop and</span>
<span class="p_add">+			 * do the right thing if there are no more events to</span>
<span class="p_add">+			 * read (i.e. return bytes read, -EAGAIN or wait).</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		/*
 		 * Permission events get queued to wait for response.  Other
 		 * events can be destroyed now.
 		 */
 		if (!(kevent-&gt;mask &amp; FAN_ALL_PERM_EVENTS)) {
 			fsnotify_destroy_event(group, kevent);
<span class="p_del">-			if (ret &lt; 0)</span>
<span class="p_del">-				break;</span>
 		} else {
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
<span class="p_del">-			if (ret &lt; 0) {</span>
<span class="p_add">+			if (ret &lt;= 0) {</span>
 				FANOTIFY_PE(kevent)-&gt;response = FAN_DENY;
 				wake_up(&amp;group-&gt;fanotify_data.access_waitq);
<span class="p_del">-				break;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
<span class="p_add">+				list_add_tail(&amp;kevent-&gt;list,</span>
<span class="p_add">+					&amp;group-&gt;fanotify_data.access_list);</span>
<span class="p_add">+				spin_unlock(&amp;group-&gt;fanotify_data.access_lock);</span>
 			}
<span class="p_del">-			spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
<span class="p_del">-			list_add_tail(&amp;kevent-&gt;list,</span>
<span class="p_del">-				      &amp;group-&gt;fanotify_data.access_list);</span>
<span class="p_del">-			spin_unlock(&amp;group-&gt;fanotify_data.access_lock);</span>
 #endif
 		}
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			break;</span>
 		buf += ret;
 		count -= ret;
 	}
<span class="p_header">diff --git a/fs/notify/fsnotify.c b/fs/notify/fsnotify.c</span>
<span class="p_header">index 700129940c6e..c955b9edb2d5 100644</span>
<span class="p_header">--- a/fs/notify/fsnotify.c</span>
<span class="p_header">+++ b/fs/notify/fsnotify.c</span>
<span class="p_chunk">@@ -105,16 +105,20 @@</span> <span class="p_context"> int __fsnotify_parent(struct path *path, struct dentry *dentry, __u32 mask)</span>
 	if (unlikely(!fsnotify_inode_watches_children(p_inode)))
 		__fsnotify_update_child_dentry_flags(p_inode);
 	else if (p_inode-&gt;i_fsnotify_mask &amp; mask) {
<span class="p_add">+		struct name_snapshot name;</span>
<span class="p_add">+</span>
 		/* we are notifying a parent so come up with the new mask which
 		 * specifies these are events which came from a child. */
 		mask |= FS_EVENT_ON_CHILD;
 
<span class="p_add">+		take_dentry_name_snapshot(&amp;name, dentry);</span>
 		if (path)
 			ret = fsnotify(p_inode, mask, path, FSNOTIFY_EVENT_PATH,
<span class="p_del">-				       dentry-&gt;d_name.name, 0);</span>
<span class="p_add">+				       name.name, 0);</span>
 		else
 			ret = fsnotify(p_inode, mask, dentry-&gt;d_inode, FSNOTIFY_EVENT_INODE,
<span class="p_del">-				       dentry-&gt;d_name.name, 0);</span>
<span class="p_add">+				       name.name, 0);</span>
<span class="p_add">+		release_dentry_name_snapshot(&amp;name);</span>
 	}
 
 	dput(parent);
<span class="p_header">diff --git a/fs/timerfd.c b/fs/timerfd.c</span>
<span class="p_header">index 0013142c0475..0db5b6c1b10d 100644</span>
<span class="p_header">--- a/fs/timerfd.c</span>
<span class="p_header">+++ b/fs/timerfd.c</span>
<span class="p_chunk">@@ -39,6 +39,7 @@</span> <span class="p_context"> struct timerfd_ctx {</span>
 	int clockid;
 	struct rcu_head rcu;
 	struct list_head clist;
<span class="p_add">+	spinlock_t cancel_lock;</span>
 	bool might_cancel;
 };
 
<span class="p_chunk">@@ -111,7 +112,7 @@</span> <span class="p_context"> void timerfd_clock_was_set(void)</span>
 	rcu_read_unlock();
 }
 
<span class="p_del">-static void timerfd_remove_cancel(struct timerfd_ctx *ctx)</span>
<span class="p_add">+static void __timerfd_remove_cancel(struct timerfd_ctx *ctx)</span>
 {
 	if (ctx-&gt;might_cancel) {
 		ctx-&gt;might_cancel = false;
<span class="p_chunk">@@ -121,6 +122,13 @@</span> <span class="p_context"> static void timerfd_remove_cancel(struct timerfd_ctx *ctx)</span>
 	}
 }
 
<span class="p_add">+static void timerfd_remove_cancel(struct timerfd_ctx *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	spin_lock(&amp;ctx-&gt;cancel_lock);</span>
<span class="p_add">+	__timerfd_remove_cancel(ctx);</span>
<span class="p_add">+	spin_unlock(&amp;ctx-&gt;cancel_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool timerfd_canceled(struct timerfd_ctx *ctx)
 {
 	if (!ctx-&gt;might_cancel || ctx-&gt;moffs.tv64 != KTIME_MAX)
<span class="p_chunk">@@ -131,6 +139,7 @@</span> <span class="p_context"> static bool timerfd_canceled(struct timerfd_ctx *ctx)</span>
 
 static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)
 {
<span class="p_add">+	spin_lock(&amp;ctx-&gt;cancel_lock);</span>
 	if ((ctx-&gt;clockid == CLOCK_REALTIME ||
 	     ctx-&gt;clockid == CLOCK_REALTIME_ALARM) &amp;&amp;
 	    (flags &amp; TFD_TIMER_ABSTIME) &amp;&amp; (flags &amp; TFD_TIMER_CANCEL_ON_SET)) {
<span class="p_chunk">@@ -140,9 +149,10 @@</span> <span class="p_context"> static void timerfd_setup_cancel(struct timerfd_ctx *ctx, int flags)</span>
 			list_add_rcu(&amp;ctx-&gt;clist, &amp;cancel_list);
 			spin_unlock(&amp;cancel_lock);
 		}
<span class="p_del">-	} else if (ctx-&gt;might_cancel) {</span>
<span class="p_del">-		timerfd_remove_cancel(ctx);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		__timerfd_remove_cancel(ctx);</span>
 	}
<span class="p_add">+	spin_unlock(&amp;ctx-&gt;cancel_lock);</span>
 }
 
 static ktime_t timerfd_get_remaining(struct timerfd_ctx *ctx)
<span class="p_chunk">@@ -326,6 +336,7 @@</span> <span class="p_context"> SYSCALL_DEFINE2(timerfd_create, int, clockid, int, flags)</span>
 		return -ENOMEM;
 
 	init_waitqueue_head(&amp;ctx-&gt;wqh);
<span class="p_add">+	spin_lock_init(&amp;ctx-&gt;cancel_lock);</span>
 	ctx-&gt;clockid = clockid;
 
 	if (isalarm(ctx))
<span class="p_header">diff --git a/fs/xattr.c b/fs/xattr.c</span>
<span class="p_header">index c69e6d43a0d2..7325e2ecbae9 100644</span>
<span class="p_header">--- a/fs/xattr.c</span>
<span class="p_header">+++ b/fs/xattr.c</span>
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> getxattr(struct dentry *d, const char __user *name, void __user *value,</span>
 			size = XATTR_SIZE_MAX;
 		kvalue = kzalloc(size, GFP_KERNEL | __GFP_NOWARN);
 		if (!kvalue) {
<span class="p_del">-			vvalue = vmalloc(size);</span>
<span class="p_add">+			vvalue = vzalloc(size);</span>
 			if (!vvalue)
 				return -ENOMEM;
 			kvalue = vvalue;
<span class="p_header">diff --git a/include/linux/dcache.h b/include/linux/dcache.h</span>
<span class="p_header">index 3597f13088a8..aa586fb8ee1a 100644</span>
<span class="p_header">--- a/include/linux/dcache.h</span>
<span class="p_header">+++ b/include/linux/dcache.h</span>
<span class="p_chunk">@@ -530,4 +530,11 @@</span> <span class="p_context"> static inline struct dentry *d_backing_dentry(struct dentry *upper)</span>
 	return upper;
 }
 
<span class="p_add">+struct name_snapshot {</span>
<span class="p_add">+	const char *name;</span>
<span class="p_add">+	char inline_name[DNAME_INLINE_LEN];</span>
<span class="p_add">+};</span>
<span class="p_add">+void take_dentry_name_snapshot(struct name_snapshot *, struct dentry *);</span>
<span class="p_add">+void release_dentry_name_snapshot(struct name_snapshot *);</span>
<span class="p_add">+</span>
 #endif	/* __LINUX_DCACHE_H */
<span class="p_header">diff --git a/include/linux/fsnotify.h b/include/linux/fsnotify.h</span>
<span class="p_header">index 7ee1774edee5..a7789559078b 100644</span>
<span class="p_header">--- a/include/linux/fsnotify.h</span>
<span class="p_header">+++ b/include/linux/fsnotify.h</span>
<span class="p_chunk">@@ -310,35 +310,4 @@</span> <span class="p_context"> static inline void fsnotify_change(struct dentry *dentry, unsigned int ia_valid)</span>
 	}
 }
 
<span class="p_del">-#if defined(CONFIG_FSNOTIFY)	/* notify helpers */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * fsnotify_oldname_init - save off the old filename before we change it</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline const unsigned char *fsnotify_oldname_init(const unsigned char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return kstrdup(name, GFP_KERNEL);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * fsnotify_oldname_free - free the name we got from fsnotify_oldname_init</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void fsnotify_oldname_free(const unsigned char *old_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	kfree(old_name);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#else	/* CONFIG_FSNOTIFY */</span>
<span class="p_del">-</span>
<span class="p_del">-static inline const char *fsnotify_oldname_init(const unsigned char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void fsnotify_oldname_free(const unsigned char *old_name)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#endif	/*  CONFIG_FSNOTIFY */</span>
<span class="p_del">-</span>
 #endif	/* _LINUX_FS_NOTIFY_H */
<span class="p_header">diff --git a/include/linux/ima.h b/include/linux/ima.h</span>
<span class="p_header">index 1b7f268cddce..23a87a4fac9f 100644</span>
<span class="p_header">--- a/include/linux/ima.h</span>
<span class="p_header">+++ b/include/linux/ima.h</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"> struct linux_binprm;</span>
 
 #ifdef CONFIG_IMA
 extern int ima_bprm_check(struct linux_binprm *bprm);
<span class="p_del">-extern int ima_file_check(struct file *file, int mask);</span>
<span class="p_add">+extern int ima_file_check(struct file *file, int mask, int opened);</span>
 extern void ima_file_free(struct file *file);
 extern int ima_file_mmap(struct file *file, unsigned long prot);
 extern int ima_module_check(struct file *file);
<span class="p_chunk">@@ -26,7 +26,7 @@</span> <span class="p_context"> static inline int ima_bprm_check(struct linux_binprm *bprm)</span>
 	return 0;
 }
 
<span class="p_del">-static inline int ima_file_check(struct file *file, int mask)</span>
<span class="p_add">+static inline int ima_file_check(struct file *file, int mask, int opened)</span>
 {
 	return 0;
 }
<span class="p_header">diff --git a/include/linux/mlx4/qp.h b/include/linux/mlx4/qp.h</span>
<span class="p_header">index 7040dc98ff8b..469e4e47d6ea 100644</span>
<span class="p_header">--- a/include/linux/mlx4/qp.h</span>
<span class="p_header">+++ b/include/linux/mlx4/qp.h</span>
<span class="p_chunk">@@ -429,6 +429,7 @@</span> <span class="p_context"> struct mlx4_update_qp_params {</span>
 	u8	smac_index;
 };
 
<span class="p_add">+struct mlx4_qp *mlx4_qp_lookup(struct mlx4_dev *dev, u32 qpn);</span>
 int mlx4_update_qp(struct mlx4_dev *dev, struct mlx4_qp *qp,
 		   enum mlx4_update_qp_attr attr,
 		   struct mlx4_update_qp_params *params);
<span class="p_header">diff --git a/include/scsi/scsi_driver.h b/include/scsi/scsi_driver.h</span>
<span class="p_header">index 36c4114ed9bc..2ae64850dc34 100644</span>
<span class="p_header">--- a/include/scsi/scsi_driver.h</span>
<span class="p_header">+++ b/include/scsi/scsi_driver.h</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"> struct scsi_driver {</span>
 	void (*uninit_command)(struct scsi_cmnd *);
 	int (*done)(struct scsi_cmnd *);
 	int (*eh_action)(struct scsi_cmnd *, int);
<span class="p_add">+	void (*eh_reset)(struct scsi_cmnd *);</span>
 };
 #define to_scsi_driver(drv) \
 	container_of((drv), struct scsi_driver, gendrv)
<span class="p_header">diff --git a/include/uapi/linux/netfilter/nf_conntrack_common.h b/include/uapi/linux/netfilter/nf_conntrack_common.h</span>
<span class="p_header">index 319f47128db8..a9f568f38c17 100644</span>
<span class="p_header">--- a/include/uapi/linux/netfilter/nf_conntrack_common.h</span>
<span class="p_header">+++ b/include/uapi/linux/netfilter/nf_conntrack_common.h</span>
<span class="p_chunk">@@ -91,6 +91,15 @@</span> <span class="p_context"> enum ip_conntrack_status {</span>
 	/* Conntrack got a helper explicitly attached via CT target. */
 	IPS_HELPER_BIT = 13,
 	IPS_HELPER = (1 &lt;&lt; IPS_HELPER_BIT),
<span class="p_add">+</span>
<span class="p_add">+	/* Be careful here, modifying these bits can make things messy,</span>
<span class="p_add">+	 * so don&#39;t let users modify them directly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	IPS_UNCHANGEABLE_MASK = (IPS_NAT_DONE_MASK | IPS_NAT_MASK |</span>
<span class="p_add">+				 IPS_EXPECTED | IPS_CONFIRMED | IPS_DYING |</span>
<span class="p_add">+				 IPS_SEQ_ADJUST | IPS_TEMPLATE),</span>
<span class="p_add">+</span>
<span class="p_add">+	__IPS_MAX_BIT = 14,</span>
 };
 
 /* Connection tracking event types */
<span class="p_header">diff --git a/ipc/mqueue.c b/ipc/mqueue.c</span>
<span class="p_header">index f65a044d66c5..ebe44a53fe5a 100644</span>
<span class="p_header">--- a/ipc/mqueue.c</span>
<span class="p_header">+++ b/ipc/mqueue.c</span>
<span class="p_chunk">@@ -1239,8 +1239,10 @@</span> <span class="p_context"> SYSCALL_DEFINE2(mq_notify, mqd_t, mqdes,</span>
 
 			timeo = MAX_SCHEDULE_TIMEOUT;
 			ret = netlink_attachskb(sock, nc, &amp;timeo, NULL);
<span class="p_del">-			if (ret == 1)</span>
<span class="p_add">+			if (ret == 1) {</span>
<span class="p_add">+				sock = NULL;</span>
 				goto retry;
<span class="p_add">+			}</span>
 			if (ret) {
 				sock = NULL;
 				nc = NULL;
<span class="p_header">diff --git a/kernel/locking/lockdep.c b/kernel/locking/lockdep.c</span>
<span class="p_header">index d24e4339b46d..11db49ad509d 100644</span>
<span class="p_header">--- a/kernel/locking/lockdep.c</span>
<span class="p_header">+++ b/kernel/locking/lockdep.c</span>
<span class="p_chunk">@@ -2724,6 +2724,8 @@</span> <span class="p_context"> static void __lockdep_trace_alloc(gfp_t gfp_mask, unsigned long flags)</span>
 	if (unlikely(!debug_locks))
 		return;
 
<span class="p_add">+	gfp_mask = memalloc_noio_flags(gfp_mask);</span>
<span class="p_add">+</span>
 	/* no reclaim without waiting on it */
 	if (!(gfp_mask &amp; __GFP_WAIT))
 		return;
<span class="p_chunk">@@ -3644,7 +3646,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(lock_is_held);</span>
 
 void lockdep_set_current_reclaim_state(gfp_t gfp_mask)
 {
<span class="p_del">-	current-&gt;lockdep_reclaim_gfp = gfp_mask;</span>
<span class="p_add">+	current-&gt;lockdep_reclaim_gfp = memalloc_noio_flags(gfp_mask);</span>
 }
 
 void lockdep_clear_current_reclaim_state(void)
<span class="p_header">diff --git a/kernel/padata.c b/kernel/padata.c</span>
<span class="p_header">index 161402f0b517..3ecda3294690 100644</span>
<span class="p_header">--- a/kernel/padata.c</span>
<span class="p_header">+++ b/kernel/padata.c</span>
<span class="p_chunk">@@ -356,7 +356,7 @@</span> <span class="p_context"> static int padata_setup_cpumasks(struct parallel_data *pd,</span>
 
 	cpumask_and(pd-&gt;cpumask.pcpu, pcpumask, cpu_online_mask);
 	if (!alloc_cpumask_var(&amp;pd-&gt;cpumask.cbcpu, GFP_KERNEL)) {
<span class="p_del">-		free_cpumask_var(pd-&gt;cpumask.cbcpu);</span>
<span class="p_add">+		free_cpumask_var(pd-&gt;cpumask.pcpu);</span>
 		return -ENOMEM;
 	}
 
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 6cf0ed87edbc..3b1f547a80e1 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -3119,23 +3119,24 @@</span> <span class="p_context"> static void __enable_ftrace_function_probe(void)</span>
 	ftrace_probe_registered = 1;
 }
 
<span class="p_del">-static void __disable_ftrace_function_probe(void)</span>
<span class="p_add">+static bool __disable_ftrace_function_probe(void)</span>
 {
 	int i;
 
 	if (!ftrace_probe_registered)
<span class="p_del">-		return;</span>
<span class="p_add">+		return false;</span>
 
 	for (i = 0; i &lt; FTRACE_FUNC_HASHSIZE; i++) {
 		struct hlist_head *hhd = &amp;ftrace_func_hash[i];
 		if (hhd-&gt;first)
<span class="p_del">-			return;</span>
<span class="p_add">+			return false;</span>
 	}
 
 	/* no more funcs left */
 	ftrace_shutdown(&amp;trace_probe_ops, 0);
 
 	ftrace_probe_registered = 0;
<span class="p_add">+	return true;</span>
 }
 
 
<span class="p_chunk">@@ -3263,6 +3264,7 @@</span> <span class="p_context"> __unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,</span>
 	int type = MATCH_FULL;
 	int i, len = 0;
 	char *search;
<span class="p_add">+	bool disabled;</span>
 
 	if (glob &amp;&amp; (strcmp(glob, &quot;*&quot;) == 0 || !strlen(glob)))
 		glob = NULL;
<span class="p_chunk">@@ -3316,12 +3318,16 @@</span> <span class="p_context"> __unregister_ftrace_function_probe(char *glob, struct ftrace_probe_ops *ops,</span>
 		}
 	}
 	mutex_lock(&amp;ftrace_lock);
<span class="p_del">-	__disable_ftrace_function_probe();</span>
<span class="p_add">+	disabled = __disable_ftrace_function_probe();</span>
 	/*
 	 * Remove after the disable is called. Otherwise, if the last
 	 * probe is removed, a null hash means *all enabled*.
 	 */
 	ftrace_hash_move(&amp;trace_probe_ops, 1, orig_hash, hash);
<span class="p_add">+</span>
<span class="p_add">+	/* still need to update the function call sites */</span>
<span class="p_add">+	if (ftrace_enabled &amp;&amp; !disabled)</span>
<span class="p_add">+		ftrace_run_update_code(FTRACE_UPDATE_CALLS);</span>
 	synchronize_sched();
 	list_for_each_entry_safe(entry, p, &amp;free_list, free_list) {
 		list_del(&amp;entry-&gt;free_list);
<span class="p_header">diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c</span>
<span class="p_header">index 80d25c150a65..cb970c01b6c1 100644</span>
<span class="p_header">--- a/net/bluetooth/hci_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/hci_sock.c</span>
<span class="p_chunk">@@ -886,7 +886,8 @@</span> <span class="p_context"> static int hci_sock_sendmsg(struct kiocb *iocb, struct socket *sock,</span>
 	if (msg-&gt;msg_flags &amp; MSG_OOB)
 		return -EOPNOTSUPP;
 
<span class="p_del">-	if (msg-&gt;msg_flags &amp; ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE))</span>
<span class="p_add">+	if (msg-&gt;msg_flags &amp; ~(MSG_DONTWAIT|MSG_NOSIGNAL|MSG_ERRQUEUE|</span>
<span class="p_add">+			       MSG_CMSG_COMPAT))</span>
 		return -EINVAL;
 
 	if (len &lt; 4 || len &gt; HCI_MAX_FRAME_SIZE)
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index 3d2f66fad322..d813da85bdaa 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -885,10 +885,12 @@</span> <span class="p_context"> static int __ip_append_data(struct sock *sk,</span>
 		csummode = CHECKSUM_PARTIAL;
 
 	cork-&gt;length += length;
<span class="p_del">-	if (((length &gt; mtu) || (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;</span>
<span class="p_add">+	if ((skb &amp;&amp; skb_is_gso(skb)) ||</span>
<span class="p_add">+	    ((length &gt; mtu) &amp;&amp;</span>
<span class="p_add">+	    (skb_queue_len(queue) &lt;= 1) &amp;&amp;</span>
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !dst_xfrm(&amp;rt-&gt;dst) &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM))) {</span>
 		err = ip_ufo_append_data(sk, queue, getfrag, from, length,
 					 hh_len, fragheaderlen, transhdrlen,
 					 maxfraglen, flags);
<span class="p_chunk">@@ -1203,6 +1205,7 @@</span> <span class="p_context"> ssize_t	ip_append_page(struct sock *sk, struct flowi4 *fl4, struct page *page,</span>
 
 	cork-&gt;length += size;
 	if ((size + skb-&gt;len &gt; mtu) &amp;&amp;
<span class="p_add">+	    (skb_queue_len(&amp;sk-&gt;sk_write_queue) == 1) &amp;&amp;</span>
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO)) {
 		skb_shinfo(skb)-&gt;gso_size = mtu - fragheaderlen;
<span class="p_header">diff --git a/net/ipv4/tcp_lp.c b/net/ipv4/tcp_lp.c</span>
<span class="p_header">index 1e70fa8fa793..3861dedd5365 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_lp.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_lp.c</span>
<span class="p_chunk">@@ -264,13 +264,15 @@</span> <span class="p_context"> static void tcp_lp_pkts_acked(struct sock *sk, u32 num_acked, s32 rtt_us)</span>
 {
 	struct tcp_sock *tp = tcp_sk(sk);
 	struct lp *lp = inet_csk_ca(sk);
<span class="p_add">+	u32 delta;</span>
 
 	if (rtt_us &gt; 0)
 		tcp_lp_rtt_sample(sk, rtt_us);
 
 	/* calc inference */
<span class="p_del">-	if (tcp_time_stamp &gt; tp-&gt;rx_opt.rcv_tsecr)</span>
<span class="p_del">-		lp-&gt;inference = 3 * (tcp_time_stamp - tp-&gt;rx_opt.rcv_tsecr);</span>
<span class="p_add">+	delta = tcp_time_stamp - tp-&gt;rx_opt.rcv_tsecr;</span>
<span class="p_add">+	if ((s32)delta &gt; 0)</span>
<span class="p_add">+		lp-&gt;inference = 3 * delta;</span>
 
 	/* test if within inference */
 	if (lp-&gt;last_drop &amp;&amp; (tcp_time_stamp - lp-&gt;last_drop &lt; lp-&gt;inference))
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 59ddab1fce28..0a9aaab17e00 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -824,7 +824,7 @@</span> <span class="p_context"> static int udp_send_skb(struct sk_buff *skb, struct flowi4 *fl4)</span>
 	if (is_udplite)  				 /*     UDP-Lite      */
 		csum = udplite_csum(skb);
 
<span class="p_del">-	else if (sk-&gt;sk_no_check_tx) {   /* UDP csum disabled */</span>
<span class="p_add">+	else if (sk-&gt;sk_no_check_tx &amp;&amp; !skb_is_gso(skb)) {   /* UDP csum off */</span>
 
 		skb-&gt;ip_summed = CHECKSUM_NONE;
 		goto send;
<span class="p_header">diff --git a/net/ipv6/exthdrs.c b/net/ipv6/exthdrs.c</span>
<span class="p_header">index 33dbd6c1a00d..2d57f2a1ee26 100644</span>
<span class="p_header">--- a/net/ipv6/exthdrs.c</span>
<span class="p_header">+++ b/net/ipv6/exthdrs.c</span>
<span class="p_chunk">@@ -709,6 +709,7 @@</span> <span class="p_context"> void ipv6_push_frag_opts(struct sk_buff *skb, struct ipv6_txoptions *opt, u8 *pr</span>
 	if (opt-&gt;dst1opt)
 		ipv6_push_exthdr(skb, proto, NEXTHDR_DEST, opt-&gt;dst1opt);
 }
<span class="p_add">+EXPORT_SYMBOL(ipv6_push_frag_opts);</span>
 
 struct ipv6_txoptions *
 ipv6_dup_options(struct sock *sk, struct ipv6_txoptions *opt)
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 2472ab9392ae..89da95f2b4b1 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1291,11 +1291,12 @@</span> <span class="p_context"> int ip6_append_data(struct sock *sk, int getfrag(void *from, char *to,</span>
 
 	skb = skb_peek_tail(&amp;sk-&gt;sk_write_queue);
 	cork-&gt;length += length;
<span class="p_del">-	if (((length &gt; mtu) ||</span>
<span class="p_del">-	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;</span>
<span class="p_add">+	if ((skb &amp;&amp; skb_is_gso(skb)) ||</span>
<span class="p_add">+	    (((length + fragheaderlen) &gt; mtu) &amp;&amp;</span>
<span class="p_add">+	    (skb_queue_len(&amp;sk-&gt;sk_write_queue) &lt;= 1) &amp;&amp;</span>
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
 	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !dst_xfrm(&amp;rt-&gt;dst) &amp;&amp;
<span class="p_del">-	    (sk-&gt;sk_type == SOCK_DGRAM)) {</span>
<span class="p_add">+	    (sk-&gt;sk_type == SOCK_DGRAM))) {</span>
 		err = ip6_ufo_append_data(sk, getfrag, from, length,
 					  hh_len, fragheaderlen, exthdrlen,
 					  transhdrlen, mtu, flags, rt);
<span class="p_header">diff --git a/net/ipv6/ip6_tunnel.c b/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">index 2879eb9a6049..c36764006d94 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_tunnel.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_tunnel.c</span>
<span class="p_chunk">@@ -883,7 +883,7 @@</span> <span class="p_context"> static void init_tel_txopt(struct ipv6_tel_txoption *opt, __u8 encap_limit)</span>
 	opt-&gt;dst_opt[5] = IPV6_TLV_PADN;
 	opt-&gt;dst_opt[6] = 1;
 
<span class="p_del">-	opt-&gt;ops.dst0opt = (struct ipv6_opt_hdr *) opt-&gt;dst_opt;</span>
<span class="p_add">+	opt-&gt;ops.dst1opt = (struct ipv6_opt_hdr *) opt-&gt;dst_opt;</span>
 	opt-&gt;ops.opt_nflen = 8;
 }
 
<span class="p_chunk">@@ -1051,7 +1051,7 @@</span> <span class="p_context"> static int ip6_tnl_xmit2(struct sk_buff *skb,</span>
 	proto = fl6-&gt;flowi6_proto;
 	if (encap_limit &gt;= 0) {
 		init_tel_txopt(&amp;opt, encap_limit);
<span class="p_del">-		ipv6_push_nfrag_opts(skb, &amp;opt.ops, &amp;proto, NULL);</span>
<span class="p_add">+		ipv6_push_frag_opts(skb, &amp;opt.ops, &amp;proto);</span>
 	}
 
 	if (likely(!skb-&gt;encapsulation)) {
<span class="p_header">diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c</span>
<span class="p_header">index 56f77c58c9ae..79763be1fda6 100644</span>
<span class="p_header">--- a/net/ipv6/ndisc.c</span>
<span class="p_header">+++ b/net/ipv6/ndisc.c</span>
<span class="p_chunk">@@ -1605,6 +1605,8 @@</span> <span class="p_context"> static int ndisc_netdev_event(struct notifier_block *this, unsigned long event,</span>
 	case NETDEV_CHANGEADDR:
 		neigh_changeaddr(&amp;nd_tbl, dev);
 		fib6_run_gc(0, net, false);
<span class="p_add">+		/* fallthrough */</span>
<span class="p_add">+	case NETDEV_UP:</span>
 		idev = in6_dev_get(dev);
 		if (!idev)
 			break;
<span class="p_header">diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c</span>
<span class="p_header">index 0fcaf38006f9..19f9a4a339b5 100644</span>
<span class="p_header">--- a/net/ipv6/output_core.c</span>
<span class="p_header">+++ b/net/ipv6/output_core.c</span>
<span class="p_chunk">@@ -44,7 +44,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);</span>
 
 int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
 {
<span class="p_del">-	u16 offset = sizeof(struct ipv6hdr);</span>
<span class="p_add">+	unsigned int offset = sizeof(struct ipv6hdr);</span>
 	unsigned int packet_len = skb_tail_pointer(skb) -
 		skb_network_header(skb);
 	int found_rhdr = 0;
<span class="p_chunk">@@ -52,6 +52,7 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 	while (offset &lt;= packet_len) {
 		struct ipv6_opt_hdr *exthdr;
<span class="p_add">+		unsigned int len;</span>
 
 		switch (**nexthdr) {
 
<span class="p_chunk">@@ -77,7 +78,10 @@</span> <span class="p_context"> int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)</span>
 
 		exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
 						 offset);
<span class="p_del">-		offset += ipv6_optlen(exthdr);</span>
<span class="p_add">+		len = ipv6_optlen(exthdr);</span>
<span class="p_add">+		if (len + offset &gt;= IPV6_MAXPLEN)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		offset += len;</span>
 		*nexthdr = &amp;exthdr-&gt;nexthdr;
 	}
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index 3f96dbd25389..63f734c5af79 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -1307,6 +1307,24 @@</span> <span class="p_context"> ctnetlink_parse_nat_setup(struct nf_conn *ct,</span>
 }
 #endif
 
<span class="p_add">+static void</span>
<span class="p_add">+__ctnetlink_change_status(struct nf_conn *ct, unsigned long on,</span>
<span class="p_add">+			  unsigned long off)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int bit;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Ignore these unchangable bits */</span>
<span class="p_add">+	on &amp;= ~IPS_UNCHANGEABLE_MASK;</span>
<span class="p_add">+	off &amp;= ~IPS_UNCHANGEABLE_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (bit = 0; bit &lt; __IPS_MAX_BIT; bit++) {</span>
<span class="p_add">+		if (on &amp; (1 &lt;&lt; bit))</span>
<span class="p_add">+			set_bit(bit, &amp;ct-&gt;status);</span>
<span class="p_add">+		else if (off &amp; (1 &lt;&lt; bit))</span>
<span class="p_add">+			clear_bit(bit, &amp;ct-&gt;status);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 ctnetlink_change_status(struct nf_conn *ct, const struct nlattr * const cda[])
 {
<span class="p_chunk">@@ -1326,10 +1344,7 @@</span> <span class="p_context"> ctnetlink_change_status(struct nf_conn *ct, const struct nlattr * const cda[])</span>
 		/* ASSURED bit can only be set */
 		return -EBUSY;
 
<span class="p_del">-	/* Be careful here, modifying NAT bits can screw up things,</span>
<span class="p_del">-	 * so don&#39;t let users modify them directly if they don&#39;t pass</span>
<span class="p_del">-	 * nf_nat_range. */</span>
<span class="p_del">-	ct-&gt;status |= status &amp; ~(IPS_NAT_DONE_MASK | IPS_NAT_MASK);</span>
<span class="p_add">+	__ctnetlink_change_status(ct, status, 0);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1384,24 +1399,22 @@</span> <span class="p_context"> ctnetlink_change_helper(struct nf_conn *ct, const struct nlattr * const cda[])</span>
 		return 0;
 	}
 
<span class="p_add">+	rcu_read_lock();</span>
 	helper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),
 					    nf_ct_protonum(ct));
 	if (helper == NULL) {
 #ifdef CONFIG_MODULES
<span class="p_del">-		spin_unlock_bh(&amp;nf_conntrack_expect_lock);</span>
<span class="p_add">+		rcu_read_unlock();</span>
 
<span class="p_del">-		if (request_module(&quot;nfct-helper-%s&quot;, helpname) &lt; 0) {</span>
<span class="p_del">-			spin_lock_bh(&amp;nf_conntrack_expect_lock);</span>
<span class="p_add">+		if (request_module(&quot;nfct-helper-%s&quot;, helpname) &lt; 0)</span>
 			return -EOPNOTSUPP;
<span class="p_del">-		}</span>
 
<span class="p_del">-		spin_lock_bh(&amp;nf_conntrack_expect_lock);</span>
<span class="p_add">+		rcu_read_lock();</span>
 		helper = __nf_conntrack_helper_find(helpname, nf_ct_l3num(ct),
 						    nf_ct_protonum(ct));
<span class="p_del">-		if (helper)</span>
<span class="p_del">-			return -EAGAIN;</span>
 #endif
<span class="p_del">-		return -EOPNOTSUPP;</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		return helper ? -EAGAIN : -EOPNOTSUPP;</span>
 	}
 
 	if (help) {
<span class="p_chunk">@@ -1409,13 +1422,16 @@</span> <span class="p_context"> ctnetlink_change_helper(struct nf_conn *ct, const struct nlattr * const cda[])</span>
 			/* update private helper data if allowed. */
 			if (helper-&gt;from_nlattr)
 				helper-&gt;from_nlattr(helpinfo, ct);
<span class="p_del">-			return 0;</span>
<span class="p_add">+			err = 0;</span>
 		} else
<span class="p_del">-			return -EBUSY;</span>
<span class="p_add">+			err = -EBUSY;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* we cannot set a helper for an existing conntrack */</span>
<span class="p_add">+		err = -EOPNOTSUPP;</span>
 	}
 
<span class="p_del">-	/* we cannot set a helper for an existing conntrack */</span>
<span class="p_del">-	return -EOPNOTSUPP;</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+	return err;</span>
 }
 
 static inline int
<span class="p_chunk">@@ -1512,7 +1528,7 @@</span> <span class="p_context"> ctnetlink_change_seq_adj(struct nf_conn *ct,</span>
 		if (ret &lt; 0)
 			return ret;
 
<span class="p_del">-		ct-&gt;status |= IPS_SEQ_ADJUST;</span>
<span class="p_add">+		set_bit(IPS_SEQ_ADJUST_BIT, &amp;ct-&gt;status);</span>
 	}
 
 	if (cda[CTA_SEQ_ADJ_REPLY]) {
<span class="p_chunk">@@ -1521,7 +1537,7 @@</span> <span class="p_context"> ctnetlink_change_seq_adj(struct nf_conn *ct,</span>
 		if (ret &lt; 0)
 			return ret;
 
<span class="p_del">-		ct-&gt;status |= IPS_SEQ_ADJUST;</span>
<span class="p_add">+		set_bit(IPS_SEQ_ADJUST_BIT, &amp;ct-&gt;status);</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -1831,9 +1847,7 @@</span> <span class="p_context"> ctnetlink_new_conntrack(struct sock *ctnl, struct sk_buff *skb,</span>
 	err = -EEXIST;
 	ct = nf_ct_tuplehash_to_ctrack(h);
 	if (!(nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL)) {
<span class="p_del">-		spin_lock_bh(&amp;nf_conntrack_expect_lock);</span>
 		err = ctnetlink_change_conntrack(ct, cda);
<span class="p_del">-		spin_unlock_bh(&amp;nf_conntrack_expect_lock);</span>
 		if (err == 0) {
 			nf_conntrack_eventmask_report((1 &lt;&lt; IPCT_REPLY) |
 						      (1 &lt;&lt; IPCT_ASSURED) |
<span class="p_chunk">@@ -2165,11 +2179,7 @@</span> <span class="p_context"> ctnetlink_nfqueue_parse(const struct nlattr *attr, struct nf_conn *ct)</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	spin_lock_bh(&amp;nf_conntrack_expect_lock);</span>
<span class="p_del">-	ret = ctnetlink_nfqueue_parse_ct((const struct nlattr **)cda, ct);</span>
<span class="p_del">-	spin_unlock_bh(&amp;nf_conntrack_expect_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return ctnetlink_nfqueue_parse_ct((const struct nlattr **)cda, ct);</span>
 }
 
 static int ctnetlink_nfqueue_exp_parse(const struct nlattr * const *cda,
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 5b4fb92144b0..d798c2fcd114 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -3345,14 +3345,19 @@</span> <span class="p_context"> packet_setsockopt(struct socket *sock, int level, int optname, char __user *optv</span>
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
<span class="p_del">-		if (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec)</span>
<span class="p_del">-			return -EBUSY;</span>
 		if (copy_from_user(&amp;val, optval, sizeof(val)))
 			return -EFAULT;
 		if (val &gt; INT_MAX)
 			return -EINVAL;
<span class="p_del">-		po-&gt;tp_reserve = val;</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		lock_sock(sk);</span>
<span class="p_add">+		if (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec) {</span>
<span class="p_add">+			ret = -EBUSY;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			po-&gt;tp_reserve = val;</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		release_sock(sk);</span>
<span class="p_add">+		return ret;</span>
 	}
 	case PACKET_LOSS:
 	{
<span class="p_header">diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h</span>
<span class="p_header">index 5cb7de9046fa..ec160e422ef4 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima.h</span>
<span class="p_header">+++ b/security/integrity/ima/ima.h</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> void ima_delete_rules(void);</span>
 int ima_appraise_measurement(int func, struct integrity_iint_cache *iint,
 			     struct file *file, const unsigned char *filename,
 			     struct evm_ima_xattr_data *xattr_value,
<span class="p_del">-			     int xattr_len);</span>
<span class="p_add">+			     int xattr_len, int opened);</span>
 int ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func);
 void ima_update_xattr(struct integrity_iint_cache *iint, struct file *file);
 enum integrity_status ima_get_cache_status(struct integrity_iint_cache *iint,
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> static inline int ima_appraise_measurement(int func,</span>
 					   struct file *file,
 					   const unsigned char *filename,
 					   struct evm_ima_xattr_data *xattr_value,
<span class="p_del">-					   int xattr_len)</span>
<span class="p_add">+					   int xattr_len, int opened)</span>
 {
 	return INTEGRITY_UNKNOWN;
 }
<span class="p_header">diff --git a/security/integrity/ima/ima_appraise.c b/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">index 85b147eddcf5..28aee9eb8b32 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_appraise.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_appraise.c</span>
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"> int ima_read_xattr(struct dentry *dentry,</span>
 int ima_appraise_measurement(int func, struct integrity_iint_cache *iint,
 			     struct file *file, const unsigned char *filename,
 			     struct evm_ima_xattr_data *xattr_value,
<span class="p_del">-			     int xattr_len)</span>
<span class="p_add">+			     int xattr_len, int opened)</span>
 {
 	static const char op[] = &quot;appraise_data&quot;;
 	char *cause = &quot;unknown&quot;;
<span class="p_chunk">@@ -195,10 +195,11 @@</span> <span class="p_context"> int ima_appraise_measurement(int func, struct integrity_iint_cache *iint,</span>
 
 		cause = &quot;missing-hash&quot;;
 		status = INTEGRITY_NOLABEL;
<span class="p_del">-		if (inode-&gt;i_size == 0) {</span>
<span class="p_add">+		if (opened &amp; FILE_CREATED)</span>
 			iint-&gt;flags |= IMA_NEW_FILE;
<span class="p_add">+		if ((iint-&gt;flags &amp; IMA_NEW_FILE) &amp;&amp;</span>
<span class="p_add">+		    !(iint-&gt;flags &amp; IMA_DIGSIG_REQUIRED))</span>
 			status = INTEGRITY_PASS;
<span class="p_del">-		}</span>
 		goto out;
 	}
 
<span class="p_header">diff --git a/security/integrity/ima/ima_main.c b/security/integrity/ima/ima_main.c</span>
<span class="p_header">index e7745a07146d..ac2e2cee7a2a 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_main.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_main.c</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> void ima_file_free(struct file *file)</span>
 }
 
 static int process_measurement(struct file *file, const char *filename,
<span class="p_del">-			       int mask, int function)</span>
<span class="p_add">+			       int mask, int function, int opened)</span>
 {
 	struct inode *inode = file_inode(file);
 	struct integrity_iint_cache *iint;
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static int process_measurement(struct file *file, const char *filename,</span>
 				      xattr_value, xattr_len);
 	if (action &amp; IMA_APPRAISE_SUBMASK)
 		rc = ima_appraise_measurement(_func, iint, file, pathname,
<span class="p_del">-					      xattr_value, xattr_len);</span>
<span class="p_add">+					      xattr_value, xattr_len, opened);</span>
 	if (action &amp; IMA_AUDIT)
 		ima_audit_measurement(iint, pathname);
 	kfree(pathbuf);
<span class="p_chunk">@@ -258,7 +258,7 @@</span> <span class="p_context"> static int process_measurement(struct file *file, const char *filename,</span>
 int ima_file_mmap(struct file *file, unsigned long prot)
 {
 	if (file &amp;&amp; (prot &amp; PROT_EXEC))
<span class="p_del">-		return process_measurement(file, NULL, MAY_EXEC, MMAP_CHECK);</span>
<span class="p_add">+		return process_measurement(file, NULL, MAY_EXEC, MMAP_CHECK, 0);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> int ima_bprm_check(struct linux_binprm *bprm)</span>
 	return process_measurement(bprm-&gt;file,
 				   (strcmp(bprm-&gt;filename, bprm-&gt;interp) == 0) ?
 				   bprm-&gt;filename : bprm-&gt;interp,
<span class="p_del">-				   MAY_EXEC, BPRM_CHECK);</span>
<span class="p_add">+				   MAY_EXEC, BPRM_CHECK, 0);</span>
 }
 
 /**
<span class="p_chunk">@@ -293,12 +293,12 @@</span> <span class="p_context"> int ima_bprm_check(struct linux_binprm *bprm)</span>
  * On success return 0.  On integrity appraisal error, assuming the file
  * is in policy and IMA-appraisal is in enforcing mode, return -EACCES.
  */
<span class="p_del">-int ima_file_check(struct file *file, int mask)</span>
<span class="p_add">+int ima_file_check(struct file *file, int mask, int opened)</span>
 {
 	ima_rdwr_violation_check(file);
 	return process_measurement(file, NULL,
 				   mask &amp; (MAY_READ | MAY_WRITE | MAY_EXEC),
<span class="p_del">-				   FILE_CHECK);</span>
<span class="p_add">+				   FILE_CHECK, opened);</span>
 }
 EXPORT_SYMBOL_GPL(ima_file_check);
 
<span class="p_chunk">@@ -321,7 +321,7 @@</span> <span class="p_context"> int ima_module_check(struct file *file)</span>
 #endif
 		return 0;	/* We rely on module signature checking */
 	}
<span class="p_del">-	return process_measurement(file, NULL, MAY_EXEC, MODULE_CHECK);</span>
<span class="p_add">+	return process_measurement(file, NULL, MAY_EXEC, MODULE_CHECK, 0);</span>
 }
 
 static int __init init_ima(void)
<span class="p_header">diff --git a/tools/perf/builtin-inject.c b/tools/perf/builtin-inject.c</span>
<span class="p_header">index 16c7c11ad06e..4c29ff08c9a7 100644</span>
<span class="p_header">--- a/tools/perf/builtin-inject.c</span>
<span class="p_header">+++ b/tools/perf/builtin-inject.c</span>
<span class="p_chunk">@@ -387,6 +387,8 @@</span> <span class="p_context"> static int __cmd_inject(struct perf_inject *inject)</span>
 		lseek(file_out-&gt;fd, session-&gt;header.data_offset, SEEK_SET);
 
 	ret = perf_session__process_events(session, &amp;inject-&gt;tool);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	if (!file_out-&gt;is_pipe) {
 		session-&gt;header.data_size = inject-&gt;bytes_written;
<span class="p_header">diff --git a/tools/perf/ui/browsers/hists.c b/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">index 868993d355e0..7babf14aa585 100644</span>
<span class="p_header">--- a/tools/perf/ui/browsers/hists.c</span>
<span class="p_header">+++ b/tools/perf/ui/browsers/hists.c</span>
<span class="p_chunk">@@ -1305,7 +1305,7 @@</span> <span class="p_context"> static int switch_data_file(void)</span>
 		return ret;
 
 	memset(options, 0, sizeof(options));
<span class="p_del">-	memset(options, 0, sizeof(abs_path));</span>
<span class="p_add">+	memset(abs_path, 0, sizeof(abs_path));</span>
 
 	while ((dent = readdir(pwd_dir))) {
 		char path[PATH_MAX];

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



