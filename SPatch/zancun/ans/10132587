
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.72 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.72</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 25, 2017, 2:12 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171225141209.GB24436@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10132587/mbox/"
   >mbox</a>
|
   <a href="/patch/10132587/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10132587/">/patch/10132587/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DEFD7602BC for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 25 Dec 2017 14:12:36 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id AF1E82EFBC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 25 Dec 2017 14:12:36 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A032E2F0CF; Mon, 25 Dec 2017 14:12:36 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 95C3E2F0B7
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 25 Dec 2017 14:12:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753063AbdLYOM0 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 25 Dec 2017 09:12:26 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:58870 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752972AbdLYOMJ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 25 Dec 2017 09:12:09 -0500
Received: from localhost (LFbn-1-12262-44.w90-92.abo.wanadoo.fr
	[90.92.75.44])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 7E71A486;
	Mon, 25 Dec 2017 14:12:07 +0000 (UTC)
Date: Mon, 25 Dec 2017 15:12:09 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.72
Message-ID: &lt;20171225141209.GB24436@kroah.com&gt;
References: &lt;20171225141204.GA24436@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=iso-8859-1
Content-Disposition: inline
Content-Transfer-Encoding: 8bit
In-Reply-To: &lt;20171225141204.GA24436@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 25, 2017, 2:12 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 5f2736bb4877..78dde51d9d74 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 71</span>
<span class="p_add">+SUBLEVEL = 72</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/boot/dts/am335x-evmsk.dts b/arch/arm/boot/dts/am335x-evmsk.dts</span>
<span class="p_header">index 975c36e332a2..8e6b3938bef9 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am335x-evmsk.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am335x-evmsk.dts</span>
<span class="p_chunk">@@ -668,6 +668,7 @@</span> <span class="p_context"></span>
 	ti,non-removable;
 	bus-width = &lt;4&gt;;
 	cap-power-off-card;
<span class="p_add">+	keep-power-in-suspend;</span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;mmc2_pins&gt;;
 
<span class="p_header">diff --git a/arch/arm/boot/dts/dra7.dtsi b/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_header">index 064d84f87e45..ce54a70b7695 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_chunk">@@ -282,6 +282,7 @@</span> <span class="p_context"></span>
 				device_type = &quot;pci&quot;;
 				ranges = &lt;0x81000000 0 0          0x03000 0 0x00010000
 					  0x82000000 0 0x20013000 0x13000 0 0xffed000&gt;;
<span class="p_add">+				bus-range = &lt;0x00 0xff&gt;;</span>
 				#interrupt-cells = &lt;1&gt;;
 				num-lanes = &lt;1&gt;;
 				linux,pci-domain = &lt;0&gt;;
<span class="p_chunk">@@ -318,6 +319,7 @@</span> <span class="p_context"></span>
 				device_type = &quot;pci&quot;;
 				ranges = &lt;0x81000000 0 0          0x03000 0 0x00010000
 					  0x82000000 0 0x30013000 0x13000 0 0xffed000&gt;;
<span class="p_add">+				bus-range = &lt;0x00 0xff&gt;;</span>
 				#interrupt-cells = &lt;1&gt;;
 				num-lanes = &lt;1&gt;;
 				linux,pci-domain = &lt;1&gt;;
<span class="p_header">diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">index ab7710002ba6..00e9e79b6cb8 100644</span>
<span class="p_header">--- a/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -930,13 +930,31 @@</span> <span class="p_context"> static void arm_coherent_dma_free(struct device *dev, size_t size, void *cpu_add</span>
 	__arm_dma_free(dev, size, cpu_addr, handle, attrs, true);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The whole dma_get_sgtable() idea is fundamentally unsafe - it seems</span>
<span class="p_add">+ * that the intention is to allow exporting memory allocated via the</span>
<span class="p_add">+ * coherent DMA APIs through the dma_buf API, which only accepts a</span>
<span class="p_add">+ * scattertable.  This presents a couple of problems:</span>
<span class="p_add">+ * 1. Not all memory allocated via the coherent DMA APIs is backed by</span>
<span class="p_add">+ *    a struct page</span>
<span class="p_add">+ * 2. Passing coherent DMA memory into the streaming APIs is not allowed</span>
<span class="p_add">+ *    as we will try to flush the memory through a different alias to that</span>
<span class="p_add">+ *    actually being used (and the flushes are redundant.)</span>
<span class="p_add">+ */</span>
 int arm_dma_get_sgtable(struct device *dev, struct sg_table *sgt,
 		 void *cpu_addr, dma_addr_t handle, size_t size,
 		 unsigned long attrs)
 {
<span class="p_del">-	struct page *page = pfn_to_page(dma_to_pfn(dev, handle));</span>
<span class="p_add">+	unsigned long pfn = dma_to_pfn(dev, handle);</span>
<span class="p_add">+	struct page *page;</span>
 	int ret;
 
<span class="p_add">+	/* If the PFN is not valid, we do not have a struct page */</span>
<span class="p_add">+	if (!pfn_valid(pfn))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	page = pfn_to_page(pfn);</span>
<span class="p_add">+</span>
 	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
 	if (unlikely(ret))
 		return ret;
<span class="p_header">diff --git a/arch/arm/probes/kprobes/core.c b/arch/arm/probes/kprobes/core.c</span>
<span class="p_header">index a4ec240ee7ba..3eb018fa1a1f 100644</span>
<span class="p_header">--- a/arch/arm/probes/kprobes/core.c</span>
<span class="p_header">+++ b/arch/arm/probes/kprobes/core.c</span>
<span class="p_chunk">@@ -433,6 +433,7 @@</span> <span class="p_context"> static __used __kprobes void *trampoline_handler(struct pt_regs *regs)</span>
 	struct hlist_node *tmp;
 	unsigned long flags, orig_ret_address = 0;
 	unsigned long trampoline_address = (unsigned long)&amp;kretprobe_trampoline;
<span class="p_add">+	kprobe_opcode_t *correct_ret_addr = NULL;</span>
 
 	INIT_HLIST_HEAD(&amp;empty_rp);
 	kretprobe_hash_lock(current, &amp;head, &amp;flags);
<span class="p_chunk">@@ -455,14 +456,34 @@</span> <span class="p_context"> static __used __kprobes void *trampoline_handler(struct pt_regs *regs)</span>
 			/* another task is sharing our hash bucket */
 			continue;
 
<span class="p_add">+		orig_ret_address = (unsigned long)ri-&gt;ret_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (orig_ret_address != trampoline_address)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This is the real return address. Any other</span>
<span class="p_add">+			 * instances associated with this task are for</span>
<span class="p_add">+			 * other calls deeper on the call stack</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kretprobe_assert(ri, orig_ret_address, trampoline_address);</span>
<span class="p_add">+</span>
<span class="p_add">+	correct_ret_addr = ri-&gt;ret_addr;</span>
<span class="p_add">+	hlist_for_each_entry_safe(ri, tmp, head, hlist) {</span>
<span class="p_add">+		if (ri-&gt;task != current)</span>
<span class="p_add">+			/* another task is sharing our hash bucket */</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		orig_ret_address = (unsigned long)ri-&gt;ret_addr;</span>
 		if (ri-&gt;rp &amp;&amp; ri-&gt;rp-&gt;handler) {
 			__this_cpu_write(current_kprobe, &amp;ri-&gt;rp-&gt;kp);
 			get_kprobe_ctlblk()-&gt;kprobe_status = KPROBE_HIT_ACTIVE;
<span class="p_add">+			ri-&gt;ret_addr = correct_ret_addr;</span>
 			ri-&gt;rp-&gt;handler(ri, regs);
 			__this_cpu_write(current_kprobe, NULL);
 		}
 
<span class="p_del">-		orig_ret_address = (unsigned long)ri-&gt;ret_addr;</span>
 		recycle_rp_inst(ri, &amp;empty_rp);
 
 		if (orig_ret_address != trampoline_address)
<span class="p_chunk">@@ -474,7 +495,6 @@</span> <span class="p_context"> static __used __kprobes void *trampoline_handler(struct pt_regs *regs)</span>
 			break;
 	}
 
<span class="p_del">-	kretprobe_assert(ri, orig_ret_address, trampoline_address);</span>
 	kretprobe_hash_unlock(current, &amp;flags);
 
 	hlist_for_each_entry_safe(ri, tmp, &amp;empty_rp, hlist) {
<span class="p_header">diff --git a/arch/arm/probes/kprobes/test-core.c b/arch/arm/probes/kprobes/test-core.c</span>
<span class="p_header">index 9775de22e2ff..a48354de1aa1 100644</span>
<span class="p_header">--- a/arch/arm/probes/kprobes/test-core.c</span>
<span class="p_header">+++ b/arch/arm/probes/kprobes/test-core.c</span>
<span class="p_chunk">@@ -976,7 +976,10 @@</span> <span class="p_context"> static void coverage_end(void)</span>
 void __naked __kprobes_test_case_start(void)
 {
 	__asm__ __volatile__ (
<span class="p_del">-		&quot;stmdb	sp!, {r4-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	r2, sp					\n\t&quot;</span>
<span class="p_add">+		&quot;bic	r3, r2, #7				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	sp, r3					\n\t&quot;</span>
<span class="p_add">+		&quot;stmdb	sp!, {r2-r11}				\n\t&quot;</span>
 		&quot;sub	sp, sp, #&quot;__stringify(TEST_MEMORY_SIZE)&quot;\n\t&quot;
 		&quot;bic	r0, lr, #1  @ r0 = inline data		\n\t&quot;
 		&quot;mov	r1, sp					\n\t&quot;
<span class="p_chunk">@@ -996,7 +999,8 @@</span> <span class="p_context"> void __naked __kprobes_test_case_end_32(void)</span>
 		&quot;movne	pc, r0					\n\t&quot;
 		&quot;mov	r0, r4					\n\t&quot;
 		&quot;add	sp, sp, #&quot;__stringify(TEST_MEMORY_SIZE)&quot;\n\t&quot;
<span class="p_del">-		&quot;ldmia	sp!, {r4-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;ldmia	sp!, {r2-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	sp, r2					\n\t&quot;</span>
 		&quot;mov	pc, r0					\n\t&quot;
 	);
 }
<span class="p_chunk">@@ -1012,7 +1016,8 @@</span> <span class="p_context"> void __naked __kprobes_test_case_end_16(void)</span>
 		&quot;bxne	r0					\n\t&quot;
 		&quot;mov	r0, r4					\n\t&quot;
 		&quot;add	sp, sp, #&quot;__stringify(TEST_MEMORY_SIZE)&quot;\n\t&quot;
<span class="p_del">-		&quot;ldmia	sp!, {r4-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;ldmia	sp!, {r2-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	sp, r2					\n\t&quot;</span>
 		&quot;bx	r0					\n\t&quot;
 	);
 }
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index 380ebe705093..9b8b477c363d 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -296,6 +296,7 @@</span> <span class="p_context"> void __init arm64_memblock_init(void)</span>
 		arm64_dma_phys_limit = max_zone_dma_phys();
 	else
 		arm64_dma_phys_limit = PHYS_MASK + 1;
<span class="p_add">+	high_memory = __va(memblock_end_of_DRAM() - 1) + 1;</span>
 	dma_contiguous_reserve(arm64_dma_phys_limit);
 
 	memblock_allow_resize();
<span class="p_chunk">@@ -322,7 +323,6 @@</span> <span class="p_context"> void __init bootmem_init(void)</span>
 	sparse_init();
 	zone_sizes_init(min, max);
 
<span class="p_del">-	high_memory = __va((max &lt;&lt; PAGE_SHIFT) - 1) + 1;</span>
 	memblock_dump_all();
 }
 
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index 9ade60ca08e0..7f2519cfb5d2 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -1781,7 +1781,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			SPFROMREG(fd, MIPSInst_FD(ir));
 			rv.s = ieee754sp_maddf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmsubf_op: {
<span class="p_chunk">@@ -1794,7 +1794,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			SPFROMREG(fd, MIPSInst_FD(ir));
 			rv.s = ieee754sp_msubf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case frint_op: {
<span class="p_chunk">@@ -1818,7 +1818,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.w = ieee754sp_2008class(fs);
 			rfmt = w_fmt;
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmin_op: {
<span class="p_chunk">@@ -1830,7 +1830,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmin(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmina_op: {
<span class="p_chunk">@@ -1842,7 +1842,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmina(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmax_op: {
<span class="p_chunk">@@ -1854,7 +1854,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmax(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmaxa_op: {
<span class="p_chunk">@@ -1866,7 +1866,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmaxa(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fabs_op:
<span class="p_chunk">@@ -2110,7 +2110,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			DPFROMREG(fd, MIPSInst_FD(ir));
 			rv.d = ieee754dp_maddf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmsubf_op: {
<span class="p_chunk">@@ -2123,7 +2123,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			DPFROMREG(fd, MIPSInst_FD(ir));
 			rv.d = ieee754dp_msubf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case frint_op: {
<span class="p_chunk">@@ -2147,7 +2147,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.w = ieee754dp_2008class(fs);
 			rfmt = w_fmt;
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmin_op: {
<span class="p_chunk">@@ -2159,7 +2159,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmin(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmina_op: {
<span class="p_chunk">@@ -2171,7 +2171,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmina(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmax_op: {
<span class="p_chunk">@@ -2183,7 +2183,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmax(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmaxa_op: {
<span class="p_chunk">@@ -2195,7 +2195,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmaxa(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fabs_op:
<span class="p_header">diff --git a/arch/sparc/mm/srmmu.c b/arch/sparc/mm/srmmu.c</span>
<span class="p_header">index c7f2a5295b3a..83a73cf5116a 100644</span>
<span class="p_header">--- a/arch/sparc/mm/srmmu.c</span>
<span class="p_header">+++ b/arch/sparc/mm/srmmu.c</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"></span>
 enum mbus_module srmmu_modtype;
 static unsigned int hwbug_bitmask;
 int vac_cache_size;
<span class="p_add">+EXPORT_SYMBOL(vac_cache_size);</span>
 int vac_line_size;
 
 extern struct resource sparc_iomap;
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index d29c745f10ad..0a324e120942 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -5052,13 +5052,13 @@</span> <span class="p_context"> int kvm_mmu_module_init(void)</span>
 {
 	pte_list_desc_cache = kmem_cache_create(&quot;pte_list_desc&quot;,
 					    sizeof(struct pte_list_desc),
<span class="p_del">-					    0, 0, NULL);</span>
<span class="p_add">+					    0, SLAB_ACCOUNT, NULL);</span>
 	if (!pte_list_desc_cache)
 		goto nomem;
 
 	mmu_page_header_cache = kmem_cache_create(&quot;kvm_mmu_page_header&quot;,
 						  sizeof(struct kvm_mmu_page),
<span class="p_del">-						  0, 0, NULL);</span>
<span class="p_add">+						  0, SLAB_ACCOUNT, NULL);</span>
 	if (!mmu_page_header_cache)
 		goto nomem;
 
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 23f1a6bd7a0d..8148d8ca7930 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -1382,6 +1382,9 @@</span> <span class="p_context"> static void avic_vm_destroy(struct kvm *kvm)</span>
 	unsigned long flags;
 	struct kvm_arch *vm_data = &amp;kvm-&gt;arch;
 
<span class="p_add">+	if (!avic)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	avic_free_vm_id(vm_data-&gt;avic_vm_id);
 
 	if (vm_data-&gt;avic_logical_id_table_page)
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index a929ca03b7ed..263e56059fd5 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -1199,6 +1199,11 @@</span> <span class="p_context"> static inline bool cpu_has_vmx_invvpid_global(void)</span>
 	return vmx_capability.vpid &amp; VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;
 }
 
<span class="p_add">+static inline bool cpu_has_vmx_invvpid(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vmx_capability.vpid &amp; VMX_VPID_INVVPID_BIT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool cpu_has_vmx_ept(void)
 {
 	return vmcs_config.cpu_based_2nd_exec_ctrl &amp;
<span class="p_chunk">@@ -3816,6 +3821,12 @@</span> <span class="p_context"> static void vmx_flush_tlb(struct kvm_vcpu *vcpu)</span>
 	__vmx_flush_tlb(vcpu, to_vmx(vcpu)-&gt;vpid);
 }
 
<span class="p_add">+static void vmx_flush_tlb_ept_only(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (enable_ept)</span>
<span class="p_add">+		vmx_flush_tlb(vcpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void vmx_decache_cr0_guest_bits(struct kvm_vcpu *vcpu)
 {
 	ulong cr0_guest_owned_bits = vcpu-&gt;arch.cr0_guest_owned_bits;
<span class="p_chunk">@@ -6428,8 +6439,10 @@</span> <span class="p_context"> static __init int hardware_setup(void)</span>
 	if (boot_cpu_has(X86_FEATURE_NX))
 		kvm_enable_efer_bits(EFER_NX);
 
<span class="p_del">-	if (!cpu_has_vmx_vpid())</span>
<span class="p_add">+	if (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||</span>
<span class="p_add">+		!(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))</span>
 		enable_vpid = 0;
<span class="p_add">+</span>
 	if (!cpu_has_vmx_shadow_vmcs())
 		enable_shadow_vmcs = 0;
 	if (enable_shadow_vmcs)
<span class="p_chunk">@@ -8494,6 +8507,7 @@</span> <span class="p_context"> static void vmx_set_virtual_x2apic_mode(struct kvm_vcpu *vcpu, bool set)</span>
 	} else {
 		sec_exec_control &amp;= ~SECONDARY_EXEC_VIRTUALIZE_X2APIC_MODE;
 		sec_exec_control |= SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES;
<span class="p_add">+		vmx_flush_tlb_ept_only(vcpu);</span>
 	}
 	vmcs_write32(SECONDARY_VM_EXEC_CONTROL, sec_exec_control);
 
<span class="p_chunk">@@ -8519,8 +8533,10 @@</span> <span class="p_context"> static void vmx_set_apic_access_page_addr(struct kvm_vcpu *vcpu, hpa_t hpa)</span>
 	 */
 	if (!is_guest_mode(vcpu) ||
 	    !nested_cpu_has2(get_vmcs12(&amp;vmx-&gt;vcpu),
<span class="p_del">-			     SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES))</span>
<span class="p_add">+			     SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {</span>
 		vmcs_write64(APIC_ACCESS_ADDR, hpa);
<span class="p_add">+		vmx_flush_tlb_ept_only(vcpu);</span>
<span class="p_add">+	}</span>
 }
 
 static void vmx_hwapic_isr_update(struct kvm_vcpu *vcpu, int max_isr)
<span class="p_chunk">@@ -10093,6 +10109,9 @@</span> <span class="p_context"> static void prepare_vmcs02(struct kvm_vcpu *vcpu, struct vmcs12 *vmcs12)</span>
 	if (nested_cpu_has_ept(vmcs12)) {
 		kvm_mmu_unload(vcpu);
 		nested_ept_init_mmu_context(vcpu);
<span class="p_add">+	} else if (nested_cpu_has2(vmcs12,</span>
<span class="p_add">+				   SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {</span>
<span class="p_add">+		vmx_flush_tlb_ept_only(vcpu);</span>
 	}
 
 	if (vmcs12-&gt;vm_entry_controls &amp; VM_ENTRY_LOAD_IA32_EFER)
<span class="p_chunk">@@ -10833,6 +10852,10 @@</span> <span class="p_context"> static void nested_vmx_vmexit(struct kvm_vcpu *vcpu, u32 exit_reason,</span>
 		vmx-&gt;nested.change_vmcs01_virtual_x2apic_mode = false;
 		vmx_set_virtual_x2apic_mode(vcpu,
 				vcpu-&gt;arch.apic_base &amp; X2APIC_ENABLE);
<span class="p_add">+	} else if (!nested_cpu_has_ept(vmcs12) &amp;&amp;</span>
<span class="p_add">+		   nested_cpu_has2(vmcs12,</span>
<span class="p_add">+				   SECONDARY_EXEC_VIRTUALIZE_APIC_ACCESSES)) {</span>
<span class="p_add">+		vmx_flush_tlb_ept_only(vcpu);</span>
 	}
 
 	/* This is needed for same reason as it was needed in prepare_vmcs02 */
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 26b580ad268f..f4d893713d54 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -8443,11 +8443,11 @@</span> <span class="p_context"> void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,</span>
 {
 	struct x86_exception fault;
 
<span class="p_del">-	trace_kvm_async_pf_ready(work-&gt;arch.token, work-&gt;gva);</span>
 	if (work-&gt;wakeup_all)
 		work-&gt;arch.token = ~0; /* broadcast wakeup */
 	else
 		kvm_del_async_pf_gfn(vcpu, work-&gt;arch.gfn);
<span class="p_add">+	trace_kvm_async_pf_ready(work-&gt;arch.token, work-&gt;gva);</span>
 
 	if ((vcpu-&gt;arch.apf.msr_val &amp; KVM_ASYNC_PF_ENABLED) &amp;&amp;
 	    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {
<span class="p_header">diff --git a/drivers/base/power/opp/core.c b/drivers/base/power/opp/core.c</span>
<span class="p_header">index 6441dfda489f..a7c5b79371a7 100644</span>
<span class="p_header">--- a/drivers/base/power/opp/core.c</span>
<span class="p_header">+++ b/drivers/base/power/opp/core.c</span>
<span class="p_chunk">@@ -331,7 +331,7 @@</span> <span class="p_context"> int dev_pm_opp_get_opp_count(struct device *dev)</span>
 	opp_table = _find_opp_table(dev);
 	if (IS_ERR(opp_table)) {
 		count = PTR_ERR(opp_table);
<span class="p_del">-		dev_err(dev, &quot;%s: OPP table not found (%d)\n&quot;,</span>
<span class="p_add">+		dev_dbg(dev, &quot;%s: OPP table not found (%d)\n&quot;,</span>
 			__func__, count);
 		goto out_unlock;
 	}
<span class="p_header">diff --git a/drivers/block/nbd.c b/drivers/block/nbd.c</span>
<span class="p_header">index 98b767d3171e..7d506cb73e54 100644</span>
<span class="p_header">--- a/drivers/block/nbd.c</span>
<span class="p_header">+++ b/drivers/block/nbd.c</span>
<span class="p_chunk">@@ -654,7 +654,10 @@</span> <span class="p_context"> static int __nbd_ioctl(struct block_device *bdev, struct nbd_device *nbd,</span>
 		return nbd_size_set(nbd, bdev, nbd-&gt;blksize, arg);
 
 	case NBD_SET_TIMEOUT:
<span class="p_del">-		nbd-&gt;tag_set.timeout = arg * HZ;</span>
<span class="p_add">+		if (arg) {</span>
<span class="p_add">+			nbd-&gt;tag_set.timeout = arg * HZ;</span>
<span class="p_add">+			blk_queue_rq_timeout(nbd-&gt;disk-&gt;queue, arg * HZ);</span>
<span class="p_add">+		}</span>
 		return 0;
 
 	case NBD_SET_FLAGS:
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 3ae950c82922..693028659ccc 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -1059,10 +1059,6 @@</span> <span class="p_context"> static int btusb_open(struct hci_dev *hdev)</span>
 	}
 
 	data-&gt;intf-&gt;needs_remote_wakeup = 1;
<span class="p_del">-	/* device specific wakeup source enabled and required for USB</span>
<span class="p_del">-	 * remote wakeup while host is suspended</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	device_wakeup_enable(&amp;data-&gt;udev-&gt;dev);</span>
 
 	if (test_and_set_bit(BTUSB_INTR_RUNNING, &amp;data-&gt;flags))
 		goto done;
<span class="p_chunk">@@ -1126,7 +1122,6 @@</span> <span class="p_context"> static int btusb_close(struct hci_dev *hdev)</span>
 		goto failed;
 
 	data-&gt;intf-&gt;needs_remote_wakeup = 0;
<span class="p_del">-	device_wakeup_disable(&amp;data-&gt;udev-&gt;dev);</span>
 	usb_autopm_put_interface(data-&gt;intf);
 
 failed:
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">index df97e25aec76..9fe0939c1273 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_chunk">@@ -608,7 +608,7 @@</span> <span class="p_context"> static SUNXI_CCU_M_WITH_MUX_GATE(hdmi_clk, &quot;hdmi&quot;, lcd_ch1_parents,</span>
 				 0x150, 0, 4, 24, 2, BIT(31),
 				 CLK_SET_RATE_PARENT);
 
<span class="p_del">-static SUNXI_CCU_GATE(hdmi_ddc_clk, &quot;hdmi-ddc&quot;, &quot;osc24M&quot;, 0x150, BIT(30), 0);</span>
<span class="p_add">+static SUNXI_CCU_GATE(hdmi_ddc_clk, &quot;ddc&quot;, &quot;osc24M&quot;, 0x150, BIT(30), 0);</span>
 
 static SUNXI_CCU_GATE(ps_clk, &quot;ps&quot;, &quot;lcd1-ch1&quot;, 0x140, BIT(31), 0);
 
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">index 530f255a898b..35e34c0e0429 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq.c</span>
<span class="p_chunk">@@ -918,11 +918,19 @@</span> <span class="p_context"> static struct kobj_type ktype_cpufreq = {</span>
 	.release	= cpufreq_sysfs_release,
 };
 
<span class="p_del">-static int add_cpu_dev_symlink(struct cpufreq_policy *policy,</span>
<span class="p_del">-			       struct device *dev)</span>
<span class="p_add">+static void add_cpu_dev_symlink(struct cpufreq_policy *policy, unsigned int cpu)</span>
 {
<span class="p_add">+	struct device *dev = get_cpu_device(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!dev)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpumask_test_and_set_cpu(cpu, policy-&gt;real_cpus))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	dev_dbg(dev, &quot;%s: Adding symlink\n&quot;, __func__);
<span class="p_del">-	return sysfs_create_link(&amp;dev-&gt;kobj, &amp;policy-&gt;kobj, &quot;cpufreq&quot;);</span>
<span class="p_add">+	if (sysfs_create_link(&amp;dev-&gt;kobj, &amp;policy-&gt;kobj, &quot;cpufreq&quot;))</span>
<span class="p_add">+		dev_err(dev, &quot;cpufreq symlink creation failed\n&quot;);</span>
 }
 
 static void remove_cpu_dev_symlink(struct cpufreq_policy *policy,
<span class="p_chunk">@@ -1184,10 +1192,10 @@</span> <span class="p_context"> static int cpufreq_online(unsigned int cpu)</span>
 		policy-&gt;user_policy.min = policy-&gt;min;
 		policy-&gt;user_policy.max = policy-&gt;max;
 
<span class="p_del">-		write_lock_irqsave(&amp;cpufreq_driver_lock, flags);</span>
<span class="p_del">-		for_each_cpu(j, policy-&gt;related_cpus)</span>
<span class="p_add">+		for_each_cpu(j, policy-&gt;related_cpus) {</span>
 			per_cpu(cpufreq_cpu_data, j) = policy;
<span class="p_del">-		write_unlock_irqrestore(&amp;cpufreq_driver_lock, flags);</span>
<span class="p_add">+			add_cpu_dev_symlink(policy, j);</span>
<span class="p_add">+		}</span>
 	} else {
 		policy-&gt;min = policy-&gt;user_policy.min;
 		policy-&gt;max = policy-&gt;user_policy.max;
<span class="p_chunk">@@ -1284,13 +1292,15 @@</span> <span class="p_context"> static int cpufreq_online(unsigned int cpu)</span>
 
 	if (cpufreq_driver-&gt;exit)
 		cpufreq_driver-&gt;exit(policy);
<span class="p_add">+</span>
<span class="p_add">+	for_each_cpu(j, policy-&gt;real_cpus)</span>
<span class="p_add">+		remove_cpu_dev_symlink(policy, get_cpu_device(j));</span>
<span class="p_add">+</span>
 out_free_policy:
 	cpufreq_policy_free(policy, !new_policy);
 	return ret;
 }
 
<span class="p_del">-static int cpufreq_offline(unsigned int cpu);</span>
<span class="p_del">-</span>
 /**
  * cpufreq_add_dev - the cpufreq interface for a CPU device.
  * @dev: CPU device.
<span class="p_chunk">@@ -1312,16 +1322,10 @@</span> <span class="p_context"> static int cpufreq_add_dev(struct device *dev, struct subsys_interface *sif)</span>
 
 	/* Create sysfs link on CPU registration */
 	policy = per_cpu(cpufreq_cpu_data, cpu);
<span class="p_del">-	if (!policy || cpumask_test_and_set_cpu(cpu, policy-&gt;real_cpus))</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (policy)</span>
<span class="p_add">+		add_cpu_dev_symlink(policy, cpu);</span>
 
<span class="p_del">-	ret = add_cpu_dev_symlink(policy, dev);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		cpumask_clear_cpu(cpu, policy-&gt;real_cpus);</span>
<span class="p_del">-		cpufreq_offline(cpu);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int cpufreq_offline(unsigned int cpu)
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle-powernv.c b/drivers/cpuidle/cpuidle-powernv.c</span>
<span class="p_header">index 7fe442ca38f4..854a56781100 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle-powernv.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle-powernv.c</span>
<span class="p_chunk">@@ -164,6 +164,24 @@</span> <span class="p_context"> static int powernv_cpuidle_driver_init(void)</span>
 		drv-&gt;state_count += 1;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On the PowerNV platform cpu_present may be less than cpu_possible in</span>
<span class="p_add">+	 * cases when firmware detects the CPU, but it is not available to the</span>
<span class="p_add">+	 * OS.  If CONFIG_HOTPLUG_CPU=n, then such CPUs are not hotplugable at</span>
<span class="p_add">+	 * run time and hence cpu_devices are not created for those CPUs by the</span>
<span class="p_add">+	 * generic topology_init().</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * drv-&gt;cpumask defaults to cpu_possible_mask in</span>
<span class="p_add">+	 * __cpuidle_driver_init().  This breaks cpuidle on PowerNV where</span>
<span class="p_add">+	 * cpu_devices are not created for CPUs in cpu_possible_mask that</span>
<span class="p_add">+	 * cannot be hot-added later at run time.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Trying cpuidle_register_device() on a CPU without a cpu_device is</span>
<span class="p_add">+	 * incorrect, so pass a correct CPU mask to the generic cpuidle driver.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	drv-&gt;cpumask = (struct cpumask *)cpu_present_mask;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">index c73207abb5a4..35237c8d5206 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle.c</span>
<span class="p_chunk">@@ -189,6 +189,7 @@</span> <span class="p_context"> int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,</span>
 			return -EBUSY;
 		}
 		target_state = &amp;drv-&gt;states[index];
<span class="p_add">+		broadcast = false;</span>
 	}
 
 	/* Take note of the planned idle state. */
<span class="p_header">diff --git a/drivers/cpuidle/sysfs.c b/drivers/cpuidle/sysfs.c</span>
<span class="p_header">index 832a2c3f01ff..9e98a5fbbc1d 100644</span>
<span class="p_header">--- a/drivers/cpuidle/sysfs.c</span>
<span class="p_header">+++ b/drivers/cpuidle/sysfs.c</span>
<span class="p_chunk">@@ -613,6 +613,18 @@</span> <span class="p_context"> int cpuidle_add_sysfs(struct cpuidle_device *dev)</span>
 	struct device *cpu_dev = get_cpu_device((unsigned long)dev-&gt;cpu);
 	int error;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Return if cpu_device is not setup for this CPU.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This could happen if the arch did not set up cpu_device</span>
<span class="p_add">+	 * since this CPU is not in cpu_present mask and the</span>
<span class="p_add">+	 * driver did not send a correct CPU mask during registration.</span>
<span class="p_add">+	 * Without this check we would end up passing bogus</span>
<span class="p_add">+	 * value for &amp;cpu_dev-&gt;kobj in kobject_init_and_add()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cpu_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	kdev = kzalloc(sizeof(*kdev), GFP_KERNEL);
 	if (!kdev)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/crypto/amcc/crypto4xx_core.h b/drivers/crypto/amcc/crypto4xx_core.h</span>
<span class="p_header">index ecfdcfe3698d..4f41d6da5acc 100644</span>
<span class="p_header">--- a/drivers/crypto/amcc/crypto4xx_core.h</span>
<span class="p_header">+++ b/drivers/crypto/amcc/crypto4xx_core.h</span>
<span class="p_chunk">@@ -34,12 +34,12 @@</span> <span class="p_context"></span>
 #define PPC405EX_CE_RESET                       0x00000008
 
 #define CRYPTO4XX_CRYPTO_PRIORITY		300
<span class="p_del">-#define PPC4XX_LAST_PD				63</span>
<span class="p_del">-#define PPC4XX_NUM_PD				64</span>
<span class="p_del">-#define PPC4XX_LAST_GD				1023</span>
<span class="p_add">+#define PPC4XX_NUM_PD				256</span>
<span class="p_add">+#define PPC4XX_LAST_PD				(PPC4XX_NUM_PD - 1)</span>
 #define PPC4XX_NUM_GD				1024
<span class="p_del">-#define PPC4XX_LAST_SD				63</span>
<span class="p_del">-#define PPC4XX_NUM_SD				64</span>
<span class="p_add">+#define PPC4XX_LAST_GD				(PPC4XX_NUM_GD - 1)</span>
<span class="p_add">+#define PPC4XX_NUM_SD				256</span>
<span class="p_add">+#define PPC4XX_LAST_SD				(PPC4XX_NUM_SD - 1)</span>
 #define PPC4XX_SD_BUFFER_SIZE			2048
 
 #define PD_ENTRY_INUSE				1
<span class="p_header">diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig</span>
<span class="p_header">index db607d51ee2b..8eed456a67be 100644</span>
<span class="p_header">--- a/drivers/hid/Kconfig</span>
<span class="p_header">+++ b/drivers/hid/Kconfig</span>
<span class="p_chunk">@@ -190,6 +190,7 @@</span> <span class="p_context"> config HID_CORSAIR</span>
 
 	Supported devices:
 	- Vengeance K90
<span class="p_add">+	- Scimitar PRO RGB</span>
 
 config HID_PRODIKEYS
 	tristate &quot;Prodikeys PC-MIDI Keyboard support&quot;
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index bdde8859e191..e32862ca5223 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -1872,6 +1872,7 @@</span> <span class="p_context"> static const struct hid_device_id hid_have_special_driver[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_AK1D) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CHICONY, USB_DEVICE_ID_CHICONY_ACER_SWITCH12) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K90) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_PRODIKEYS_PCMIDI) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CYGNAL, USB_DEVICE_ID_CYGNAL_CP2112) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CYPRESS, USB_DEVICE_ID_CYPRESS_BARCODE_1) },
<span class="p_chunk">@@ -2106,6 +2107,7 @@</span> <span class="p_context"> static const struct hid_device_id hid_have_special_driver[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_X_TENSIONS, USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_XIN_MO_DUAL_ARCADE) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_THT_2P_ARCADE) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0005) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0030) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ZYDACRON, USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL) },
<span class="p_header">diff --git a/drivers/hid/hid-corsair.c b/drivers/hid/hid-corsair.c</span>
<span class="p_header">index c0303f61c26a..9ba5d98a1180 100644</span>
<span class="p_header">--- a/drivers/hid/hid-corsair.c</span>
<span class="p_header">+++ b/drivers/hid/hid-corsair.c</span>
<span class="p_chunk">@@ -3,8 +3,10 @@</span> <span class="p_context"></span>
  *
  * Supported devices:
  *  - Vengeance K90 Keyboard
<span class="p_add">+ *  - Scimitar PRO RGB Gaming Mouse</span>
  *
  * Copyright (c) 2015 Clement Vuchener
<span class="p_add">+ * Copyright (c) 2017 Oscar Campos</span>
  */
 
 /*
<span class="p_chunk">@@ -670,10 +672,51 @@</span> <span class="p_context"> static int corsair_input_mapping(struct hid_device *dev,</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The report descriptor of Corsair Scimitar RGB Pro gaming mouse is</span>
<span class="p_add">+ * non parseable as they define two consecutive Logical Minimum for</span>
<span class="p_add">+ * the Usage Page (Consumer) in rdescs bytes 75 and 77 being 77 0x16</span>
<span class="p_add">+ * that should be obviousy 0x26 for Logical Magimum of 16 bits. This</span>
<span class="p_add">+ * prevents poper parsing of the report descriptor due Logical</span>
<span class="p_add">+ * Minimum being larger than Logical Maximum.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This driver fixes the report descriptor for:</span>
<span class="p_add">+ * - USB ID b1c:1b3e, sold as Scimitar RGB Pro Gaming mouse</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static __u8 *corsair_mouse_report_fixup(struct hid_device *hdev, __u8 *rdesc,</span>
<span class="p_add">+        unsigned int *rsize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_interface *intf = to_usb_interface(hdev-&gt;dev.parent);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber == 1) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Corsair Scimitar RGB Pro report descriptor is broken and</span>
<span class="p_add">+		 * defines two different Logical Minimum for the Consumer</span>
<span class="p_add">+		 * Application. The byte 77 should be a 0x26 defining a 16</span>
<span class="p_add">+		 * bits integer for the Logical Maximum but it is a 0x16</span>
<span class="p_add">+		 * instead (Logical Minimum)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		switch (hdev-&gt;product) {</span>
<span class="p_add">+		case USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB:</span>
<span class="p_add">+			if (*rsize &gt;= 172 &amp;&amp; rdesc[75] == 0x15 &amp;&amp; rdesc[77] == 0x16</span>
<span class="p_add">+			&amp;&amp; rdesc[78] == 0xff &amp;&amp; rdesc[79] == 0x0f) {</span>
<span class="p_add">+				hid_info(hdev, &quot;Fixing up report descriptor\n&quot;);</span>
<span class="p_add">+				rdesc[77] = 0x26;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return rdesc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static const struct hid_device_id corsair_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K90),
 		.driver_data = CORSAIR_USE_K90_MACRO |
 			       CORSAIR_USE_K90_BACKLIGHT },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_CORSAIR,</span>
<span class="p_add">+            USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB) },</span>
 	{}
 };
 
<span class="p_chunk">@@ -686,10 +729,14 @@</span> <span class="p_context"> static struct hid_driver corsair_driver = {</span>
 	.event = corsair_event,
 	.remove = corsair_remove,
 	.input_mapping = corsair_input_mapping,
<span class="p_add">+	.report_fixup = corsair_mouse_report_fixup,</span>
 };
 
 module_hid_driver(corsair_driver);
 
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_add">+/* Original K90 driver author */</span>
 MODULE_AUTHOR(&quot;Clement Vuchener&quot;);
<span class="p_add">+/* Scimitar PRO RGB driver author */</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Oscar Campos&quot;);</span>
 MODULE_DESCRIPTION(&quot;HID driver for Corsair devices&quot;);
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 433d5f675c03..244b97c1b74e 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -277,6 +277,9 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_CORSAIR_K70RGB    0x1b13
 #define USB_DEVICE_ID_CORSAIR_STRAFE    0x1b15
 #define USB_DEVICE_ID_CORSAIR_K65RGB    0x1b17
<span class="p_add">+#define USB_DEVICE_ID_CORSAIR_K70RGB_RAPIDFIRE  0x1b38</span>
<span class="p_add">+#define USB_DEVICE_ID_CORSAIR_K65RGB_RAPIDFIRE  0x1b39</span>
<span class="p_add">+#define USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB  0x1b3e</span>
 
 #define USB_VENDOR_ID_CREATIVELABS	0x041e
 #define USB_DEVICE_ID_CREATIVE_SB_OMNI_SURROUND_51	0x322c
<span class="p_chunk">@@ -1077,6 +1080,7 @@</span> <span class="p_context"></span>
 
 #define USB_VENDOR_ID_XIN_MO			0x16c0
 #define USB_DEVICE_ID_XIN_MO_DUAL_ARCADE	0x05e1
<span class="p_add">+#define USB_DEVICE_ID_THT_2P_ARCADE		0x75e1</span>
 
 #define USB_VENDOR_ID_XIROKU		0x1477
 #define USB_DEVICE_ID_XIROKU_SPX	0x1006
<span class="p_header">diff --git a/drivers/hid/hid-xinmo.c b/drivers/hid/hid-xinmo.c</span>
<span class="p_header">index 7df5227a7e61..9ad7731d2e10 100644</span>
<span class="p_header">--- a/drivers/hid/hid-xinmo.c</span>
<span class="p_header">+++ b/drivers/hid/hid-xinmo.c</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> static int xinmo_event(struct hid_device *hdev, struct hid_field *field,</span>
 
 static const struct hid_device_id xinmo_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_XIN_MO_DUAL_ARCADE) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_THT_2P_ARCADE) },</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index 2b1620797959..1916f80a692d 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -80,6 +80,9 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K70RGB, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K65RGB, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_STRAFE, HID_QUIRK_NO_INIT_REPORTS | HID_QUIRK_ALWAYS_POLL },
<span class="p_add">+	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K70RGB_RAPIDFIRE, HID_QUIRK_NO_INIT_REPORTS | HID_QUIRK_ALWAYS_POLL },</span>
<span class="p_add">+	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K65RGB_RAPIDFIRE, HID_QUIRK_NO_INIT_REPORTS | HID_QUIRK_ALWAYS_POLL },</span>
<span class="p_add">+	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB, HID_QUIRK_NO_INIT_REPORTS | HID_QUIRK_ALWAYS_POLL },</span>
 	{ USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_CREATIVE_SB_OMNI_SURROUND_51, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_DELL, USB_DEVICE_ID_DELL_PIXART_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },
 	{ USB_VENDOR_ID_DMI, USB_DEVICE_ID_DMI_ENC, HID_QUIRK_NOGET },
<span class="p_header">diff --git a/drivers/hwmon/asus_atk0110.c b/drivers/hwmon/asus_atk0110.c</span>
<span class="p_header">index cccef87963e0..975c43d446f8 100644</span>
<span class="p_header">--- a/drivers/hwmon/asus_atk0110.c</span>
<span class="p_header">+++ b/drivers/hwmon/asus_atk0110.c</span>
<span class="p_chunk">@@ -646,6 +646,9 @@</span> <span class="p_context"> static int atk_read_value(struct atk_sensor_data *sensor, u64 *value)</span>
 		else
 			err = atk_read_value_new(sensor, value);
 
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+</span>
 		sensor-&gt;is_valid = true;
 		sensor-&gt;last_updated = jiffies;
 		sensor-&gt;cached_value = *value;
<span class="p_header">diff --git a/drivers/hwmon/max31790.c b/drivers/hwmon/max31790.c</span>
<span class="p_header">index c1b9275978f9..281491cca510 100644</span>
<span class="p_header">--- a/drivers/hwmon/max31790.c</span>
<span class="p_header">+++ b/drivers/hwmon/max31790.c</span>
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> static int max31790_write_pwm(struct device *dev, u32 attr, int channel,</span>
 		data-&gt;pwm[channel] = val &lt;&lt; 8;
 		err = i2c_smbus_write_word_swapped(client,
 						   MAX31790_REG_PWMOUT(channel),
<span class="p_del">-						   val);</span>
<span class="p_add">+						   data-&gt;pwm[channel]);</span>
 		break;
 	case hwmon_pwm_enable:
 		fan_config = data-&gt;fan_config[channel];
<span class="p_header">diff --git a/drivers/infiniband/core/cq.c b/drivers/infiniband/core/cq.c</span>
<span class="p_header">index a754fc727de5..ff12b8d176ce 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cq.c</span>
<span class="p_chunk">@@ -196,7 +196,7 @@</span> <span class="p_context"> void ib_free_cq(struct ib_cq *cq)</span>
 		irq_poll_disable(&amp;cq-&gt;iop);
 		break;
 	case IB_POLL_WORKQUEUE:
<span class="p_del">-		flush_work(&amp;cq-&gt;work);</span>
<span class="p_add">+		cancel_work_sync(&amp;cq-&gt;work);</span>
 		break;
 	default:
 		WARN_ON_ONCE(1);
<span class="p_header">diff --git a/drivers/infiniband/hw/i40iw/i40iw_utils.c b/drivers/infiniband/hw/i40iw/i40iw_utils.c</span>
<span class="p_header">index 6fd043b1d714..7db2001775cb 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/i40iw/i40iw_utils.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/i40iw/i40iw_utils.c</span>
<span class="p_chunk">@@ -159,6 +159,9 @@</span> <span class="p_context"> int i40iw_inetaddr_event(struct notifier_block *notifier,</span>
 		return NOTIFY_DONE;
 
 	iwdev = &amp;hdl-&gt;device;
<span class="p_add">+	if (iwdev-&gt;init_state &lt; INET_NOTIFIER)</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
 	netdev = iwdev-&gt;ldev-&gt;netdev;
 	upper_dev = netdev_master_upper_dev_get(netdev);
 	if (netdev != event_netdev)
<span class="p_chunk">@@ -231,6 +234,9 @@</span> <span class="p_context"> int i40iw_inet6addr_event(struct notifier_block *notifier,</span>
 		return NOTIFY_DONE;
 
 	iwdev = &amp;hdl-&gt;device;
<span class="p_add">+	if (iwdev-&gt;init_state &lt; INET_NOTIFIER)</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
 	netdev = iwdev-&gt;ldev-&gt;netdev;
 	if (netdev != event_netdev)
 		return NOTIFY_DONE;
<span class="p_chunk">@@ -280,6 +286,8 @@</span> <span class="p_context"> int i40iw_net_event(struct notifier_block *notifier, unsigned long event, void *</span>
 		if (!iwhdl)
 			return NOTIFY_DONE;
 		iwdev = &amp;iwhdl-&gt;device;
<span class="p_add">+		if (iwdev-&gt;init_state &lt; INET_NOTIFIER)</span>
<span class="p_add">+			return NOTIFY_DONE;</span>
 		p = (__be32 *)neigh-&gt;primary_key;
 		i40iw_copy_ip_ntohl(local_ipaddr, p);
 		if (neigh-&gt;nud_state &amp; NUD_VALID) {
<span class="p_header">diff --git a/drivers/infiniband/sw/rdmavt/mmap.c b/drivers/infiniband/sw/rdmavt/mmap.c</span>
<span class="p_header">index e202b8142759..6b712eecbd37 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rdmavt/mmap.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rdmavt/mmap.c</span>
<span class="p_chunk">@@ -170,9 +170,9 @@</span> <span class="p_context"> struct rvt_mmap_info *rvt_create_mmap_info(struct rvt_dev_info *rdi,</span>
 
 	spin_lock_irq(&amp;rdi-&gt;mmap_offset_lock);
 	if (rdi-&gt;mmap_offset == 0)
<span class="p_del">-		rdi-&gt;mmap_offset = PAGE_SIZE;</span>
<span class="p_add">+		rdi-&gt;mmap_offset = ALIGN(PAGE_SIZE, SHMLBA);</span>
 	ip-&gt;offset = rdi-&gt;mmap_offset;
<span class="p_del">-	rdi-&gt;mmap_offset += size;</span>
<span class="p_add">+	rdi-&gt;mmap_offset += ALIGN(size, SHMLBA);</span>
 	spin_unlock_irq(&amp;rdi-&gt;mmap_offset_lock);
 
 	INIT_LIST_HEAD(&amp;ip-&gt;pending_mmaps);
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_mmap.c b/drivers/infiniband/sw/rxe/rxe_mmap.c</span>
<span class="p_header">index c572a4c09359..bd812e00988e 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_mmap.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_mmap.c</span>
<span class="p_chunk">@@ -156,10 +156,10 @@</span> <span class="p_context"> struct rxe_mmap_info *rxe_create_mmap_info(struct rxe_dev *rxe,</span>
 	spin_lock_bh(&amp;rxe-&gt;mmap_offset_lock);
 
 	if (rxe-&gt;mmap_offset == 0)
<span class="p_del">-		rxe-&gt;mmap_offset = PAGE_SIZE;</span>
<span class="p_add">+		rxe-&gt;mmap_offset = ALIGN(PAGE_SIZE, SHMLBA);</span>
 
 	ip-&gt;info.offset = rxe-&gt;mmap_offset;
<span class="p_del">-	rxe-&gt;mmap_offset += size;</span>
<span class="p_add">+	rxe-&gt;mmap_offset += ALIGN(size, SHMLBA);</span>
 
 	spin_unlock_bh(&amp;rxe-&gt;mmap_offset_lock);
 
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_pool.c b/drivers/infiniband/sw/rxe/rxe_pool.c</span>
<span class="p_header">index ee26a1b1b4ed..1c4e5b2e6835 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_pool.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_pool.c</span>
<span class="p_chunk">@@ -412,6 +412,8 @@</span> <span class="p_context"> void *rxe_alloc(struct rxe_pool *pool)</span>
 	elem = kmem_cache_zalloc(pool_cache(pool),
 				 (pool-&gt;flags &amp; RXE_POOL_ATOMIC) ?
 				 GFP_ATOMIC : GFP_KERNEL);
<span class="p_add">+	if (!elem)</span>
<span class="p_add">+		return NULL;</span>
 
 	elem-&gt;pool = pool;
 	kref_init(&amp;elem-&gt;ref_cnt);
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_req.c b/drivers/infiniband/sw/rxe/rxe_req.c</span>
<span class="p_header">index 9d084780ac91..5b0ca35c06ab 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_req.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_req.c</span>
<span class="p_chunk">@@ -726,11 +726,11 @@</span> <span class="p_context"> int rxe_requester(void *arg)</span>
 	ret = rxe_xmit_packet(to_rdev(qp-&gt;ibqp.device), qp, &amp;pkt, skb);
 	if (ret) {
 		qp-&gt;need_req_skb = 1;
<span class="p_del">-		kfree_skb(skb);</span>
 
 		rollback_state(wqe, qp, &amp;rollback_wqe, rollback_psn);
 
 		if (ret == -EAGAIN) {
<span class="p_add">+			kfree_skb(skb);</span>
 			rxe_run_task(&amp;qp-&gt;req.task, 1);
 			goto exit;
 		}
<span class="p_header">diff --git a/drivers/infiniband/sw/rxe/rxe_resp.c b/drivers/infiniband/sw/rxe/rxe_resp.c</span>
<span class="p_header">index 7705820cdac6..8c0ddd7165ae 100644</span>
<span class="p_header">--- a/drivers/infiniband/sw/rxe/rxe_resp.c</span>
<span class="p_header">+++ b/drivers/infiniband/sw/rxe/rxe_resp.c</span>
<span class="p_chunk">@@ -799,18 +799,17 @@</span> <span class="p_context"> static enum resp_states execute(struct rxe_qp *qp, struct rxe_pkt_info *pkt)</span>
 		/* Unreachable */
 		WARN_ON(1);
 
<span class="p_del">-	/* We successfully processed this new request. */</span>
<span class="p_del">-	qp-&gt;resp.msn++;</span>
<span class="p_del">-</span>
 	/* next expected psn, read handles this separately */
 	qp-&gt;resp.psn = (pkt-&gt;psn + 1) &amp; BTH_PSN_MASK;
 
 	qp-&gt;resp.opcode = pkt-&gt;opcode;
 	qp-&gt;resp.status = IB_WC_SUCCESS;
 
<span class="p_del">-	if (pkt-&gt;mask &amp; RXE_COMP_MASK)</span>
<span class="p_add">+	if (pkt-&gt;mask &amp; RXE_COMP_MASK) {</span>
<span class="p_add">+		/* We successfully processed this new request. */</span>
<span class="p_add">+		qp-&gt;resp.msn++;</span>
 		return RESPST_COMPLETE;
<span class="p_del">-	else if (qp_type(qp) == IB_QPT_RC)</span>
<span class="p_add">+	} else if (qp_type(qp) == IB_QPT_RC)</span>
 		return RESPST_ACKNOWLEDGE;
 	else
 		return RESPST_CLEANUP;
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_header">index 0be6a7c5ddb5..cb48e22afff7 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_chunk">@@ -430,6 +430,7 @@</span> <span class="p_context"> struct iser_fr_desc {</span>
 	struct list_head		  list;
 	struct iser_reg_resources	  rsc;
 	struct iser_pi_context		 *pi_ctx;
<span class="p_add">+	struct list_head                  all_list;</span>
 };
 
 /**
<span class="p_chunk">@@ -443,6 +444,7 @@</span> <span class="p_context"> struct iser_fr_pool {</span>
 	struct list_head        list;
 	spinlock_t              lock;
 	int                     size;
<span class="p_add">+	struct list_head        all_list;</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c</span>
<span class="p_header">index a4b791dfaa1d..bc6f5bb6c524 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iser_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iser_verbs.c</span>
<span class="p_chunk">@@ -362,6 +362,7 @@</span> <span class="p_context"> int iser_alloc_fastreg_pool(struct ib_conn *ib_conn,</span>
 	int i, ret;
 
 	INIT_LIST_HEAD(&amp;fr_pool-&gt;list);
<span class="p_add">+	INIT_LIST_HEAD(&amp;fr_pool-&gt;all_list);</span>
 	spin_lock_init(&amp;fr_pool-&gt;lock);
 	fr_pool-&gt;size = 0;
 	for (i = 0; i &lt; cmds_max; i++) {
<span class="p_chunk">@@ -373,6 +374,7 @@</span> <span class="p_context"> int iser_alloc_fastreg_pool(struct ib_conn *ib_conn,</span>
 		}
 
 		list_add_tail(&amp;desc-&gt;list, &amp;fr_pool-&gt;list);
<span class="p_add">+		list_add_tail(&amp;desc-&gt;all_list, &amp;fr_pool-&gt;all_list);</span>
 		fr_pool-&gt;size++;
 	}
 
<span class="p_chunk">@@ -392,13 +394,13 @@</span> <span class="p_context"> void iser_free_fastreg_pool(struct ib_conn *ib_conn)</span>
 	struct iser_fr_desc *desc, *tmp;
 	int i = 0;
 
<span class="p_del">-	if (list_empty(&amp;fr_pool-&gt;list))</span>
<span class="p_add">+	if (list_empty(&amp;fr_pool-&gt;all_list))</span>
 		return;
 
 	iser_info(&quot;freeing conn %p fr pool\n&quot;, ib_conn);
 
<span class="p_del">-	list_for_each_entry_safe(desc, tmp, &amp;fr_pool-&gt;list, list) {</span>
<span class="p_del">-		list_del(&amp;desc-&gt;list);</span>
<span class="p_add">+	list_for_each_entry_safe(desc, tmp, &amp;fr_pool-&gt;all_list, all_list) {</span>
<span class="p_add">+		list_del(&amp;desc-&gt;all_list);</span>
 		iser_free_reg_res(&amp;desc-&gt;rsc);
 		if (desc-&gt;pi_ctx)
 			iser_free_pi_ctx(desc-&gt;pi_ctx);
<span class="p_header">diff --git a/drivers/iommu/exynos-iommu.c b/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">index c7820b3ea80e..beef59eb94fa 100644</span>
<span class="p_header">--- a/drivers/iommu/exynos-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/exynos-iommu.c</span>
<span class="p_chunk">@@ -543,7 +543,10 @@</span> <span class="p_context"> static void sysmmu_tlb_invalidate_flpdcache(struct sysmmu_drvdata *data,</span>
 	if (is_sysmmu_active(data) &amp;&amp; data-&gt;version &gt;= MAKE_MMU_VER(3, 3)) {
 		clk_enable(data-&gt;clk_master);
 		if (sysmmu_block(data)) {
<span class="p_del">-			__sysmmu_tlb_invalidate_entry(data, iova, 1);</span>
<span class="p_add">+			if (data-&gt;version &gt;= MAKE_MMU_VER(5, 0))</span>
<span class="p_add">+				__sysmmu_tlb_invalidate(data);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				__sysmmu_tlb_invalidate_entry(data, iova, 1);</span>
 			sysmmu_unblock(data);
 		}
 		clk_disable(data-&gt;clk_master);
<span class="p_header">diff --git a/drivers/isdn/capi/kcapi.c b/drivers/isdn/capi/kcapi.c</span>
<span class="p_header">index 823f6985b260..dd7e38ac29bd 100644</span>
<span class="p_header">--- a/drivers/isdn/capi/kcapi.c</span>
<span class="p_header">+++ b/drivers/isdn/capi/kcapi.c</span>
<span class="p_chunk">@@ -1032,6 +1032,7 @@</span> <span class="p_context"> static int old_capi_manufacturer(unsigned int cmd, void __user *data)</span>
 						     sizeof(avmb1_carddef))))
 				return -EFAULT;
 			cdef.cardtype = AVM_CARDTYPE_B1;
<span class="p_add">+			cdef.cardnr = 0;</span>
 		} else {
 			if ((retval = copy_from_user(&amp;cdef, data,
 						     sizeof(avmb1_extcarddef))))
<span class="p_header">diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c</span>
<span class="p_header">index eef202d4399b..a5422f483ad5 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/pci.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/pci.c</span>
<span class="p_chunk">@@ -1758,6 +1758,9 @@</span> <span class="p_context"> static pci_ers_result_t cxl_vphb_error_detected(struct cxl_afu *afu,</span>
 	/* There should only be one entry, but go through the list
 	 * anyway
 	 */
<span class="p_add">+	if (afu-&gt;phb == NULL)</span>
<span class="p_add">+		return result;</span>
<span class="p_add">+</span>
 	list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 		if (!afu_dev-&gt;driver)
 			continue;
<span class="p_chunk">@@ -1801,6 +1804,11 @@</span> <span class="p_context"> static pci_ers_result_t cxl_pci_error_detected(struct pci_dev *pdev,</span>
 			/* Only participate in EEH if we are on a virtual PHB */
 			if (afu-&gt;phb == NULL)
 				return PCI_ERS_RESULT_NONE;
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Tell the AFU drivers; but we don&#39;t care what they</span>
<span class="p_add">+			 * say, we&#39;re going away.</span>
<span class="p_add">+			 */</span>
 			cxl_vphb_error_detected(afu, state);
 		}
 		return PCI_ERS_RESULT_DISCONNECT;
<span class="p_chunk">@@ -1941,6 +1949,9 @@</span> <span class="p_context"> static pci_ers_result_t cxl_pci_slot_reset(struct pci_dev *pdev)</span>
 		if (cxl_afu_select_best_mode(afu))
 			goto err;
 
<span class="p_add">+		if (afu-&gt;phb == NULL)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 			/* Reset the device context.
 			 * TODO: make this less disruptive
<span class="p_chunk">@@ -2003,6 +2014,9 @@</span> <span class="p_context"> static void cxl_pci_resume(struct pci_dev *pdev)</span>
 	for (i = 0; i &lt; adapter-&gt;slices; i++) {
 		afu = adapter-&gt;afu[i];
 
<span class="p_add">+		if (afu-&gt;phb == NULL)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 			if (afu_dev-&gt;driver &amp;&amp; afu_dev-&gt;driver-&gt;err_handler &amp;&amp;
 			    afu_dev-&gt;driver-&gt;err_handler-&gt;resume)
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">index 0b894d76aa41..bbb3641eddcb 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_chunk">@@ -2381,6 +2381,18 @@</span> <span class="p_context"> static int bnxt_init_one_rx_ring(struct bnxt *bp, int ring_nr)</span>
 	return 0;
 }
 
<span class="p_add">+static void bnxt_init_cp_rings(struct bnxt *bp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; bp-&gt;cp_nr_rings; i++) {</span>
<span class="p_add">+		struct bnxt_cp_ring_info *cpr = &amp;bp-&gt;bnapi[i]-&gt;cp_ring;</span>
<span class="p_add">+		struct bnxt_ring_struct *ring = &amp;cpr-&gt;cp_ring_struct;</span>
<span class="p_add">+</span>
<span class="p_add">+		ring-&gt;fw_ring_id = INVALID_HW_RING_ID;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bnxt_init_rx_rings(struct bnxt *bp)
 {
 	int i, rc = 0;
<span class="p_chunk">@@ -4700,6 +4712,7 @@</span> <span class="p_context"> static int bnxt_shutdown_nic(struct bnxt *bp, bool irq_re_init)</span>
 
 static int bnxt_init_nic(struct bnxt *bp, bool irq_re_init)
 {
<span class="p_add">+	bnxt_init_cp_rings(bp);</span>
 	bnxt_init_rx_rings(bp);
 	bnxt_init_tx_rings(bp);
 	bnxt_init_ring_grps(bp, irq_re_init);
<span class="p_header">diff --git a/drivers/net/ethernet/brocade/bna/bfa_ioc.c b/drivers/net/ethernet/brocade/bna/bfa_ioc.c</span>
<span class="p_header">index 9e59663a6ead..0f6811860ad5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/brocade/bna/bfa_ioc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/brocade/bna/bfa_ioc.c</span>
<span class="p_chunk">@@ -1930,13 +1930,13 @@</span> <span class="p_context"> static void</span>
 bfa_ioc_send_enable(struct bfa_ioc *ioc)
 {
 	struct bfi_ioc_ctrl_req enable_req;
<span class="p_del">-	struct timeval tv;</span>
 
 	bfi_h2i_set(enable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_ENABLE_REQ,
 		    bfa_ioc_portid(ioc));
 	enable_req.clscode = htons(ioc-&gt;clscode);
<span class="p_del">-	do_gettimeofday(&amp;tv);</span>
<span class="p_del">-	enable_req.tv_sec = ntohl(tv.tv_sec);</span>
<span class="p_add">+	enable_req.rsvd = htons(0);</span>
<span class="p_add">+	/* overflow in 2106 */</span>
<span class="p_add">+	enable_req.tv_sec = ntohl(ktime_get_real_seconds());</span>
 	bfa_ioc_mbox_send(ioc, &amp;enable_req, sizeof(struct bfi_ioc_ctrl_req));
 }
 
<span class="p_chunk">@@ -1947,6 +1947,10 @@</span> <span class="p_context"> bfa_ioc_send_disable(struct bfa_ioc *ioc)</span>
 
 	bfi_h2i_set(disable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_DISABLE_REQ,
 		    bfa_ioc_portid(ioc));
<span class="p_add">+	disable_req.clscode = htons(ioc-&gt;clscode);</span>
<span class="p_add">+	disable_req.rsvd = htons(0);</span>
<span class="p_add">+	/* overflow in 2106 */</span>
<span class="p_add">+	disable_req.tv_sec = ntohl(ktime_get_real_seconds());</span>
 	bfa_ioc_mbox_send(ioc, &amp;disable_req, sizeof(struct bfi_ioc_ctrl_req));
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/brocade/bna/bnad_debugfs.c b/drivers/net/ethernet/brocade/bna/bnad_debugfs.c</span>
<span class="p_header">index 05c1c1dd7751..cebfe3bd086e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/brocade/bna/bnad_debugfs.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/brocade/bna/bnad_debugfs.c</span>
<span class="p_chunk">@@ -325,7 +325,7 @@</span> <span class="p_context"> bnad_debugfs_write_regrd(struct file *file, const char __user *buf,</span>
 		return PTR_ERR(kern_buf);
 
 	rc = sscanf(kern_buf, &quot;%x:%x&quot;, &amp;addr, &amp;len);
<span class="p_del">-	if (rc &lt; 2) {</span>
<span class="p_add">+	if (rc &lt; 2 || len &gt; UINT_MAX &gt;&gt; 2) {</span>
 		netdev_warn(bnad-&gt;netdev, &quot;failed to read user buffer\n&quot;);
 		kfree(kern_buf);
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/fm10k/fm10k.h b/drivers/net/ethernet/intel/fm10k/fm10k.h</span>
<span class="p_header">index 4d19e46f7c55..3693ae104c2a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/fm10k/fm10k.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/fm10k/fm10k.h</span>
<span class="p_chunk">@@ -508,8 +508,8 @@</span> <span class="p_context"> s32 fm10k_iov_update_pvid(struct fm10k_intfc *interface, u16 glort, u16 pvid);</span>
 int fm10k_ndo_set_vf_mac(struct net_device *netdev, int vf_idx, u8 *mac);
 int fm10k_ndo_set_vf_vlan(struct net_device *netdev,
 			  int vf_idx, u16 vid, u8 qos, __be16 vlan_proto);
<span class="p_del">-int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx, int rate,</span>
<span class="p_del">-			int unused);</span>
<span class="p_add">+int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx,</span>
<span class="p_add">+			int __always_unused min_rate, int max_rate);</span>
 int fm10k_ndo_get_vf_config(struct net_device *netdev,
 			    int vf_idx, struct ifla_vf_info *ivi);
 
<span class="p_header">diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_iov.c b/drivers/net/ethernet/intel/fm10k/fm10k_iov.c</span>
<span class="p_header">index 5f4dac0d36ef..e72fd52bacfe 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/fm10k/fm10k_iov.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/fm10k/fm10k_iov.c</span>
<span class="p_chunk">@@ -126,6 +126,9 @@</span> <span class="p_context"> s32 fm10k_iov_mbx(struct fm10k_intfc *interface)</span>
 		struct fm10k_mbx_info *mbx = &amp;vf_info-&gt;mbx;
 		u16 glort = vf_info-&gt;glort;
 
<span class="p_add">+		/* process the SM mailbox first to drain outgoing messages */</span>
<span class="p_add">+		hw-&gt;mbx.ops.process(hw, &amp;hw-&gt;mbx);</span>
<span class="p_add">+</span>
 		/* verify port mapping is valid, if not reset port */
 		if (vf_info-&gt;vf_flags &amp;&amp; !fm10k_glort_valid_pf(hw, glort))
 			hw-&gt;iov.ops.reset_lport(hw, vf_info);
<span class="p_chunk">@@ -482,7 +485,7 @@</span> <span class="p_context"> int fm10k_ndo_set_vf_vlan(struct net_device *netdev, int vf_idx, u16 vid,</span>
 }
 
 int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx,
<span class="p_del">-			int __always_unused unused, int rate)</span>
<span class="p_add">+			int __always_unused min_rate, int max_rate)</span>
 {
 	struct fm10k_intfc *interface = netdev_priv(netdev);
 	struct fm10k_iov_data *iov_data = interface-&gt;iov_data;
<span class="p_chunk">@@ -493,14 +496,15 @@</span> <span class="p_context"> int fm10k_ndo_set_vf_bw(struct net_device *netdev, int vf_idx,</span>
 		return -EINVAL;
 
 	/* rate limit cannot be less than 10Mbs or greater than link speed */
<span class="p_del">-	if (rate &amp;&amp; ((rate &lt; FM10K_VF_TC_MIN) || rate &gt; FM10K_VF_TC_MAX))</span>
<span class="p_add">+	if (max_rate &amp;&amp;</span>
<span class="p_add">+	    (max_rate &lt; FM10K_VF_TC_MIN || max_rate &gt; FM10K_VF_TC_MAX))</span>
 		return -EINVAL;
 
 	/* store values */
<span class="p_del">-	iov_data-&gt;vf_info[vf_idx].rate = rate;</span>
<span class="p_add">+	iov_data-&gt;vf_info[vf_idx].rate = max_rate;</span>
 
 	/* update hardware configuration */
<span class="p_del">-	hw-&gt;iov.ops.configure_tc(hw, vf_idx, rate);</span>
<span class="p_add">+	hw-&gt;iov.ops.configure_tc(hw, vf_idx, max_rate);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index 2caafebb0295..becffd15c092 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -4217,8 +4217,12 @@</span> <span class="p_context"> static void i40e_napi_enable_all(struct i40e_vsi *vsi)</span>
 	if (!vsi-&gt;netdev)
 		return;
 
<span class="p_del">-	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++)</span>
<span class="p_del">-		napi_enable(&amp;vsi-&gt;q_vectors[q_idx]-&gt;napi);</span>
<span class="p_add">+	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++) {</span>
<span class="p_add">+		struct i40e_q_vector *q_vector = vsi-&gt;q_vectors[q_idx];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (q_vector-&gt;rx.ring || q_vector-&gt;tx.ring)</span>
<span class="p_add">+			napi_enable(&amp;q_vector-&gt;napi);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -4232,8 +4236,12 @@</span> <span class="p_context"> static void i40e_napi_disable_all(struct i40e_vsi *vsi)</span>
 	if (!vsi-&gt;netdev)
 		return;
 
<span class="p_del">-	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++)</span>
<span class="p_del">-		napi_disable(&amp;vsi-&gt;q_vectors[q_idx]-&gt;napi);</span>
<span class="p_add">+	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++) {</span>
<span class="p_add">+		struct i40e_q_vector *q_vector = vsi-&gt;q_vectors[q_idx];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (q_vector-&gt;rx.ring || q_vector-&gt;tx.ring)</span>
<span class="p_add">+			napi_disable(&amp;q_vector-&gt;napi);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index 16839600fb78..ca54f7684668 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -3102,6 +3102,8 @@</span> <span class="p_context"> static int igb_sw_init(struct igb_adapter *adapter)</span>
 	/* Setup and initialize a copy of the hw vlan table array */
 	adapter-&gt;shadow_vfta = kcalloc(E1000_VLAN_FILTER_TBL_SIZE, sizeof(u32),
 				       GFP_ATOMIC);
<span class="p_add">+	if (!adapter-&gt;shadow_vfta)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	/* This call may decrease the number of queues */
 	if (igb_init_interrupt_scheme(adapter, true)) {
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c</span>
<span class="p_header">index 77d3039283f6..ad3362293cbd 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c</span>
<span class="p_chunk">@@ -3696,10 +3696,10 @@</span> <span class="p_context"> s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,</span>
 	fw_cmd.ver_build = build;
 	fw_cmd.ver_sub = sub;
 	fw_cmd.hdr.checksum = 0;
<span class="p_del">-	fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&amp;fw_cmd,</span>
<span class="p_del">-				(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));</span>
 	fw_cmd.pad = 0;
 	fw_cmd.pad2 = 0;
<span class="p_add">+	fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&amp;fw_cmd,</span>
<span class="p_add">+				(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));</span>
 
 	for (i = 0; i &lt;= FW_CEM_MAX_RETRIES; i++) {
 		ret_val = ixgbe_host_interface_command(hw, &amp;fw_cmd,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c</span>
<span class="p_header">index 60f0bf779073..77a60aa5dc7e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c</span>
<span class="p_chunk">@@ -617,6 +617,8 @@</span> <span class="p_context"> static s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw,</span>
 		/* convert offset from words to bytes */
 		buffer.address = cpu_to_be32((offset + current_word) * 2);
 		buffer.length = cpu_to_be16(words_to_read * 2);
<span class="p_add">+		buffer.pad2 = 0;</span>
<span class="p_add">+		buffer.pad3 = 0;</span>
 
 		status = ixgbe_host_interface_command(hw, &amp;buffer,
 						      sizeof(buffer),
<span class="p_header">diff --git a/drivers/net/ethernet/moxa/moxart_ether.c b/drivers/net/ethernet/moxa/moxart_ether.c</span>
<span class="p_header">index 4367dd6879a2..0622fd03941b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/moxa/moxart_ether.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/moxa/moxart_ether.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/of_irq.h&gt;
 #include &lt;linux/crc32.h&gt;
 #include &lt;linux/crc32c.h&gt;
<span class="p_add">+#include &lt;linux/circ_buf.h&gt;</span>
 
 #include &quot;moxart_ether.h&quot;
 
<span class="p_chunk">@@ -278,6 +279,13 @@</span> <span class="p_context"> static int moxart_rx_poll(struct napi_struct *napi, int budget)</span>
 	return rx;
 }
 
<span class="p_add">+static int moxart_tx_queue_space(struct net_device *ndev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct moxart_mac_priv_t *priv = netdev_priv(ndev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return CIRC_SPACE(priv-&gt;tx_head, priv-&gt;tx_tail, TX_DESC_NUM);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void moxart_tx_finished(struct net_device *ndev)
 {
 	struct moxart_mac_priv_t *priv = netdev_priv(ndev);
<span class="p_chunk">@@ -297,6 +305,9 @@</span> <span class="p_context"> static void moxart_tx_finished(struct net_device *ndev)</span>
 		tx_tail = TX_NEXT(tx_tail);
 	}
 	priv-&gt;tx_tail = tx_tail;
<span class="p_add">+	if (netif_queue_stopped(ndev) &amp;&amp;</span>
<span class="p_add">+	    moxart_tx_queue_space(ndev) &gt;= TX_WAKE_THRESHOLD)</span>
<span class="p_add">+		netif_wake_queue(ndev);</span>
 }
 
 static irqreturn_t moxart_mac_interrupt(int irq, void *dev_id)
<span class="p_chunk">@@ -324,13 +335,18 @@</span> <span class="p_context"> static int moxart_mac_start_xmit(struct sk_buff *skb, struct net_device *ndev)</span>
 	struct moxart_mac_priv_t *priv = netdev_priv(ndev);
 	void *desc;
 	unsigned int len;
<span class="p_del">-	unsigned int tx_head = priv-&gt;tx_head;</span>
<span class="p_add">+	unsigned int tx_head;</span>
 	u32 txdes1;
 	int ret = NETDEV_TX_BUSY;
 
<span class="p_add">+	spin_lock_irq(&amp;priv-&gt;txlock);</span>
<span class="p_add">+</span>
<span class="p_add">+	tx_head = priv-&gt;tx_head;</span>
 	desc = priv-&gt;tx_desc_base + (TX_REG_DESC_SIZE * tx_head);
 
<span class="p_del">-	spin_lock_irq(&amp;priv-&gt;txlock);</span>
<span class="p_add">+	if (moxart_tx_queue_space(ndev) == 1)</span>
<span class="p_add">+		netif_stop_queue(ndev);</span>
<span class="p_add">+</span>
 	if (moxart_desc_read(desc + TX_REG_OFFSET_DESC0) &amp; TX_DESC0_DMA_OWN) {
 		net_dbg_ratelimited(&quot;no TX space for packet\n&quot;);
 		priv-&gt;stats.tx_dropped++;
<span class="p_header">diff --git a/drivers/net/ethernet/moxa/moxart_ether.h b/drivers/net/ethernet/moxa/moxart_ether.h</span>
<span class="p_header">index 93a9563ac7c6..afc32ec998c0 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/moxa/moxart_ether.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/moxa/moxart_ether.h</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"></span>
 #define TX_NEXT(N)		(((N) + 1) &amp; (TX_DESC_NUM_MASK))
 #define TX_BUF_SIZE		1600
 #define TX_BUF_SIZE_MAX		(TX_DESC1_BUF_SIZE_MASK+1)
<span class="p_add">+#define TX_WAKE_THRESHOLD	16</span>
 
 #define RX_DESC_NUM		64
 #define RX_DESC_NUM_MASK	(RX_DESC_NUM-1)
<span class="p_header">diff --git a/drivers/net/irda/vlsi_ir.c b/drivers/net/irda/vlsi_ir.c</span>
<span class="p_header">index a0849f49bbec..c0192f97ecc8 100644</span>
<span class="p_header">--- a/drivers/net/irda/vlsi_ir.c</span>
<span class="p_header">+++ b/drivers/net/irda/vlsi_ir.c</span>
<span class="p_chunk">@@ -418,8 +418,9 @@</span> <span class="p_context"> static struct vlsi_ring *vlsi_alloc_ring(struct pci_dev *pdev, struct ring_descr</span>
 		memset(rd, 0, sizeof(*rd));
 		rd-&gt;hw = hwmap + i;
 		rd-&gt;buf = kmalloc(len, GFP_KERNEL|GFP_DMA);
<span class="p_del">-		if (rd-&gt;buf == NULL ||</span>
<span class="p_del">-		    !(busaddr = pci_map_single(pdev, rd-&gt;buf, len, dir))) {</span>
<span class="p_add">+		if (rd-&gt;buf)</span>
<span class="p_add">+			busaddr = pci_map_single(pdev, rd-&gt;buf, len, dir);</span>
<span class="p_add">+		if (rd-&gt;buf == NULL || pci_dma_mapping_error(pdev, busaddr)) {</span>
 			if (rd-&gt;buf) {
 				net_err_ratelimited(&quot;%s: failed to create PCI-MAP for %p\n&quot;,
 						    __func__, rd-&gt;buf);
<span class="p_chunk">@@ -430,8 +431,7 @@</span> <span class="p_context"> static struct vlsi_ring *vlsi_alloc_ring(struct pci_dev *pdev, struct ring_descr</span>
 				rd = r-&gt;rd + j;
 				busaddr = rd_get_addr(rd);
 				rd_set_addr_status(rd, 0, 0);
<span class="p_del">-				if (busaddr)</span>
<span class="p_del">-					pci_unmap_single(pdev, busaddr, len, dir);</span>
<span class="p_add">+				pci_unmap_single(pdev, busaddr, len, dir);</span>
 				kfree(rd-&gt;buf);
 				rd-&gt;buf = NULL;
 			}
<span class="p_header">diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c</span>
<span class="p_header">index a52b560e428b..3603eec7217f 100644</span>
<span class="p_header">--- a/drivers/net/phy/at803x.c</span>
<span class="p_header">+++ b/drivers/net/phy/at803x.c</span>
<span class="p_chunk">@@ -166,7 +166,7 @@</span> <span class="p_context"> static int at803x_set_wol(struct phy_device *phydev,</span>
 		mac = (const u8 *) ndev-&gt;dev_addr;
 
 		if (!is_valid_ether_addr(mac))
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			return -EINVAL;</span>
 
 		for (i = 0; i &lt; 3; i++) {
 			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index 62725655d8e4..105fbfb47e3a 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -582,6 +582,10 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x69),
 		.driver_info        = (unsigned long)&amp;qmi_wwan_info,
 	},
<span class="p_add">+	{	/* Motorola Mapphone devices with MDM6600 */</span>
<span class="p_add">+		USB_VENDOR_AND_INTERFACE_INFO(0x22b8, USB_CLASS_VENDOR_SPEC, 0xfb, 0xff),</span>
<span class="p_add">+		.driver_info        = (unsigned long)&amp;qmi_wwan_info,</span>
<span class="p_add">+	},</span>
 
 	/* 2. Combined interface devices matching on class+protocol */
 	{	/* Huawei E367 and possibly others in &quot;Windows mode&quot; */
<span class="p_header">diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c</span>
<span class="p_header">index afb953a258cd..b2d7c7e32250 100644</span>
<span class="p_header">--- a/drivers/net/usb/r8152.c</span>
<span class="p_header">+++ b/drivers/net/usb/r8152.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
 #define NETNEXT_VERSION		&quot;08&quot;
 
 /* Information for net */
<span class="p_del">-#define NET_VERSION		&quot;8&quot;</span>
<span class="p_add">+#define NET_VERSION		&quot;9&quot;</span>
 
 #define DRIVER_VERSION		&quot;v1.&quot; NETNEXT_VERSION &quot;.&quot; NET_VERSION
 #define DRIVER_AUTHOR &quot;Realtek linux nic maintainers &lt;nic_swsd@realtek.com&gt;&quot;
<span class="p_chunk">@@ -501,6 +501,8 @@</span> <span class="p_context"> enum rtl_register_content {</span>
 #define RTL8153_RMS		RTL8153_MAX_PACKET
 #define RTL8152_TX_TIMEOUT	(5 * HZ)
 #define RTL8152_NAPI_WEIGHT	64
<span class="p_add">+#define rx_reserved_size(x)	((x) + VLAN_ETH_HLEN + CRC_SIZE + \</span>
<span class="p_add">+				 sizeof(struct rx_desc) + RX_ALIGN)</span>
 
 /* rtl8152 flags */
 enum rtl8152_flags {
<span class="p_chunk">@@ -1292,6 +1294,7 @@</span> <span class="p_context"> static void intr_callback(struct urb *urb)</span>
 		}
 	} else {
 		if (netif_carrier_ok(tp-&gt;netdev)) {
<span class="p_add">+			netif_stop_queue(tp-&gt;netdev);</span>
 			set_bit(RTL8152_LINK_CHG, &amp;tp-&gt;flags);
 			schedule_delayed_work(&amp;tp-&gt;schedule, 0);
 		}
<span class="p_chunk">@@ -1362,6 +1365,7 @@</span> <span class="p_context"> static int alloc_all_mem(struct r8152 *tp)</span>
 	spin_lock_init(&amp;tp-&gt;rx_lock);
 	spin_lock_init(&amp;tp-&gt;tx_lock);
 	INIT_LIST_HEAD(&amp;tp-&gt;tx_free);
<span class="p_add">+	INIT_LIST_HEAD(&amp;tp-&gt;rx_done);</span>
 	skb_queue_head_init(&amp;tp-&gt;tx_queue);
 	skb_queue_head_init(&amp;tp-&gt;rx_queue);
 
<span class="p_chunk">@@ -2252,8 +2256,7 @@</span> <span class="p_context"> static void r8153_set_rx_early_timeout(struct r8152 *tp)</span>
 
 static void r8153_set_rx_early_size(struct r8152 *tp)
 {
<span class="p_del">-	u32 mtu = tp-&gt;netdev-&gt;mtu;</span>
<span class="p_del">-	u32 ocp_data = (agg_buf_sz - mtu - VLAN_ETH_HLEN - VLAN_HLEN) / 8;</span>
<span class="p_add">+	u32 ocp_data = (agg_buf_sz - rx_reserved_size(tp-&gt;netdev-&gt;mtu)) / 4;</span>
 
 	ocp_write_word(tp, MCU_TYPE_USB, USB_RX_EARLY_SIZE, ocp_data);
 }
<span class="p_chunk">@@ -3165,6 +3168,9 @@</span> <span class="p_context"> static void set_carrier(struct r8152 *tp)</span>
 			napi_enable(&amp;tp-&gt;napi);
 			netif_wake_queue(netdev);
 			netif_info(tp, link, netdev, &quot;carrier on\n&quot;);
<span class="p_add">+		} else if (netif_queue_stopped(netdev) &amp;&amp;</span>
<span class="p_add">+			   skb_queue_len(&amp;tp-&gt;tx_queue) &lt; tp-&gt;tx_qlen) {</span>
<span class="p_add">+			netif_wake_queue(netdev);</span>
 		}
 	} else {
 		if (netif_carrier_ok(netdev)) {
<span class="p_chunk">@@ -3698,8 +3704,18 @@</span> <span class="p_context"> static int rtl8152_resume(struct usb_interface *intf)</span>
 			tp-&gt;rtl_ops.autosuspend_en(tp, false);
 			napi_disable(&amp;tp-&gt;napi);
 			set_bit(WORK_ENABLE, &amp;tp-&gt;flags);
<span class="p_del">-			if (netif_carrier_ok(tp-&gt;netdev))</span>
<span class="p_del">-				rtl_start_rx(tp);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (netif_carrier_ok(tp-&gt;netdev)) {</span>
<span class="p_add">+				if (rtl8152_get_speed(tp) &amp; LINK_STATUS) {</span>
<span class="p_add">+					rtl_start_rx(tp);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					netif_carrier_off(tp-&gt;netdev);</span>
<span class="p_add">+					tp-&gt;rtl_ops.disable(tp);</span>
<span class="p_add">+					netif_info(tp, link, tp-&gt;netdev,</span>
<span class="p_add">+						   &quot;linking down\n&quot;);</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			napi_enable(&amp;tp-&gt;napi);
 			clear_bit(SELECTIVE_SUSPEND, &amp;tp-&gt;flags);
 			smp_mb__after_atomic();
<span class="p_header">diff --git a/drivers/nvme/target/loop.c b/drivers/nvme/target/loop.c</span>
<span class="p_header">index c8e612c1c72f..e56ca3fb107e 100644</span>
<span class="p_header">--- a/drivers/nvme/target/loop.c</span>
<span class="p_header">+++ b/drivers/nvme/target/loop.c</span>
<span class="p_chunk">@@ -223,8 +223,6 @@</span> <span class="p_context"> static void nvme_loop_submit_async_event(struct nvme_ctrl *arg, int aer_idx)</span>
 static int nvme_loop_init_iod(struct nvme_loop_ctrl *ctrl,
 		struct nvme_loop_iod *iod, unsigned int queue_idx)
 {
<span class="p_del">-	BUG_ON(queue_idx &gt;= ctrl-&gt;queue_count);</span>
<span class="p_del">-</span>
 	iod-&gt;req.cmd = &amp;iod-&gt;cmd;
 	iod-&gt;req.rsp = &amp;iod-&gt;rsp;
 	iod-&gt;queue = &amp;ctrl-&gt;queues[queue_idx];
<span class="p_chunk">@@ -314,6 +312,43 @@</span> <span class="p_context"> static void nvme_loop_free_ctrl(struct nvme_ctrl *nctrl)</span>
 	kfree(ctrl);
 }
 
<span class="p_add">+static void nvme_loop_destroy_io_queues(struct nvme_loop_ctrl *ctrl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 1; i &lt; ctrl-&gt;queue_count; i++)</span>
<span class="p_add">+		nvmet_sq_destroy(&amp;ctrl-&gt;queues[i].nvme_sq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int nvme_loop_init_io_queues(struct nvme_loop_ctrl *ctrl)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nvmf_ctrl_options *opts = ctrl-&gt;ctrl.opts;</span>
<span class="p_add">+	unsigned int nr_io_queues;</span>
<span class="p_add">+	int ret, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	nr_io_queues = min(opts-&gt;nr_io_queues, num_online_cpus());</span>
<span class="p_add">+	ret = nvme_set_queue_count(&amp;ctrl-&gt;ctrl, &amp;nr_io_queues);</span>
<span class="p_add">+	if (ret || !nr_io_queues)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(ctrl-&gt;ctrl.device, &quot;creating %d I/O queues.\n&quot;, nr_io_queues);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 1; i &lt;= nr_io_queues; i++) {</span>
<span class="p_add">+		ctrl-&gt;queues[i].ctrl = ctrl;</span>
<span class="p_add">+		ret = nvmet_sq_init(&amp;ctrl-&gt;queues[i].nvme_sq);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_destroy_queues;</span>
<span class="p_add">+</span>
<span class="p_add">+		ctrl-&gt;queue_count++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out_destroy_queues:</span>
<span class="p_add">+	nvme_loop_destroy_io_queues(ctrl);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int nvme_loop_configure_admin_queue(struct nvme_loop_ctrl *ctrl)
 {
 	int error;
<span class="p_chunk">@@ -385,17 +420,13 @@</span> <span class="p_context"> static int nvme_loop_configure_admin_queue(struct nvme_loop_ctrl *ctrl)</span>
 
 static void nvme_loop_shutdown_ctrl(struct nvme_loop_ctrl *ctrl)
 {
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
 	nvme_stop_keep_alive(&amp;ctrl-&gt;ctrl);
 
 	if (ctrl-&gt;queue_count &gt; 1) {
 		nvme_stop_queues(&amp;ctrl-&gt;ctrl);
 		blk_mq_tagset_busy_iter(&amp;ctrl-&gt;tag_set,
 					nvme_cancel_request, &amp;ctrl-&gt;ctrl);
<span class="p_del">-</span>
<span class="p_del">-		for (i = 1; i &lt; ctrl-&gt;queue_count; i++)</span>
<span class="p_del">-			nvmet_sq_destroy(&amp;ctrl-&gt;queues[i].nvme_sq);</span>
<span class="p_add">+		nvme_loop_destroy_io_queues(ctrl);</span>
 	}
 
 	if (ctrl-&gt;ctrl.state == NVME_CTRL_LIVE)
<span class="p_chunk">@@ -467,19 +498,14 @@</span> <span class="p_context"> static void nvme_loop_reset_ctrl_work(struct work_struct *work)</span>
 	if (ret)
 		goto out_disable;
 
<span class="p_del">-	for (i = 1; i &lt;= ctrl-&gt;ctrl.opts-&gt;nr_io_queues; i++) {</span>
<span class="p_del">-		ctrl-&gt;queues[i].ctrl = ctrl;</span>
<span class="p_del">-		ret = nvmet_sq_init(&amp;ctrl-&gt;queues[i].nvme_sq);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			goto out_free_queues;</span>
<span class="p_del">-</span>
<span class="p_del">-		ctrl-&gt;queue_count++;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	ret = nvme_loop_init_io_queues(ctrl);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out_destroy_admin;</span>
 
<span class="p_del">-	for (i = 1; i &lt;= ctrl-&gt;ctrl.opts-&gt;nr_io_queues; i++) {</span>
<span class="p_add">+	for (i = 1; i &lt; ctrl-&gt;queue_count; i++) {</span>
 		ret = nvmf_connect_io_queue(&amp;ctrl-&gt;ctrl, i);
 		if (ret)
<span class="p_del">-			goto out_free_queues;</span>
<span class="p_add">+			goto out_destroy_io;</span>
 	}
 
 	changed = nvme_change_ctrl_state(&amp;ctrl-&gt;ctrl, NVME_CTRL_LIVE);
<span class="p_chunk">@@ -492,9 +518,9 @@</span> <span class="p_context"> static void nvme_loop_reset_ctrl_work(struct work_struct *work)</span>
 
 	return;
 
<span class="p_del">-out_free_queues:</span>
<span class="p_del">-	for (i = 1; i &lt; ctrl-&gt;queue_count; i++)</span>
<span class="p_del">-		nvmet_sq_destroy(&amp;ctrl-&gt;queues[i].nvme_sq);</span>
<span class="p_add">+out_destroy_io:</span>
<span class="p_add">+	nvme_loop_destroy_io_queues(ctrl);</span>
<span class="p_add">+out_destroy_admin:</span>
 	nvme_loop_destroy_admin_queue(ctrl);
 out_disable:
 	dev_warn(ctrl-&gt;ctrl.device, &quot;Removing after reset failure\n&quot;);
<span class="p_chunk">@@ -533,25 +559,12 @@</span> <span class="p_context"> static const struct nvme_ctrl_ops nvme_loop_ctrl_ops = {</span>
 
 static int nvme_loop_create_io_queues(struct nvme_loop_ctrl *ctrl)
 {
<span class="p_del">-	struct nvmf_ctrl_options *opts = ctrl-&gt;ctrl.opts;</span>
 	int ret, i;
 
<span class="p_del">-	ret = nvme_set_queue_count(&amp;ctrl-&gt;ctrl, &amp;opts-&gt;nr_io_queues);</span>
<span class="p_del">-	if (ret || !opts-&gt;nr_io_queues)</span>
<span class="p_add">+	ret = nvme_loop_init_io_queues(ctrl);</span>
<span class="p_add">+	if (ret)</span>
 		return ret;
 
<span class="p_del">-	dev_info(ctrl-&gt;ctrl.device, &quot;creating %d I/O queues.\n&quot;,</span>
<span class="p_del">-		opts-&gt;nr_io_queues);</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 1; i &lt;= opts-&gt;nr_io_queues; i++) {</span>
<span class="p_del">-		ctrl-&gt;queues[i].ctrl = ctrl;</span>
<span class="p_del">-		ret = nvmet_sq_init(&amp;ctrl-&gt;queues[i].nvme_sq);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			goto out_destroy_queues;</span>
<span class="p_del">-</span>
<span class="p_del">-		ctrl-&gt;queue_count++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	memset(&amp;ctrl-&gt;tag_set, 0, sizeof(ctrl-&gt;tag_set));
 	ctrl-&gt;tag_set.ops = &amp;nvme_loop_mq_ops;
 	ctrl-&gt;tag_set.queue_depth = ctrl-&gt;ctrl.opts-&gt;queue_size;
<span class="p_chunk">@@ -575,7 +588,7 @@</span> <span class="p_context"> static int nvme_loop_create_io_queues(struct nvme_loop_ctrl *ctrl)</span>
 		goto out_free_tagset;
 	}
 
<span class="p_del">-	for (i = 1; i &lt;= opts-&gt;nr_io_queues; i++) {</span>
<span class="p_add">+	for (i = 1; i &lt; ctrl-&gt;queue_count; i++) {</span>
 		ret = nvmf_connect_io_queue(&amp;ctrl-&gt;ctrl, i);
 		if (ret)
 			goto out_cleanup_connect_q;
<span class="p_chunk">@@ -588,8 +601,7 @@</span> <span class="p_context"> static int nvme_loop_create_io_queues(struct nvme_loop_ctrl *ctrl)</span>
 out_free_tagset:
 	blk_mq_free_tag_set(&amp;ctrl-&gt;tag_set);
 out_destroy_queues:
<span class="p_del">-	for (i = 1; i &lt; ctrl-&gt;queue_count; i++)</span>
<span class="p_del">-		nvmet_sq_destroy(&amp;ctrl-&gt;queues[i].nvme_sq);</span>
<span class="p_add">+	nvme_loop_destroy_io_queues(ctrl);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/pci/iov.c b/drivers/pci/iov.c</span>
<span class="p_header">index 47227820406d..1d32fe2d97aa 100644</span>
<span class="p_header">--- a/drivers/pci/iov.c</span>
<span class="p_header">+++ b/drivers/pci/iov.c</span>
<span class="p_chunk">@@ -164,7 +164,6 @@</span> <span class="p_context"> int pci_iov_add_virtfn(struct pci_dev *dev, int id, int reset)</span>
 	pci_device_add(virtfn, virtfn-&gt;bus);
 	mutex_unlock(&amp;iov-&gt;dev-&gt;sriov-&gt;lock);
 
<span class="p_del">-	pci_bus_add_device(virtfn);</span>
 	sprintf(buf, &quot;virtfn%u&quot;, id);
 	rc = sysfs_create_link(&amp;dev-&gt;dev.kobj, &amp;virtfn-&gt;dev.kobj, buf);
 	if (rc)
<span class="p_chunk">@@ -175,6 +174,8 @@</span> <span class="p_context"> int pci_iov_add_virtfn(struct pci_dev *dev, int id, int reset)</span>
 
 	kobject_uevent(&amp;virtfn-&gt;dev.kobj, KOBJ_CHANGE);
 
<span class="p_add">+	pci_bus_add_device(virtfn);</span>
<span class="p_add">+</span>
 	return 0;
 
 failed2:
<span class="p_header">diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c</span>
<span class="p_header">index e7d4048e81f2..a87c8e1aef68 100644</span>
<span class="p_header">--- a/drivers/pci/pci.c</span>
<span class="p_header">+++ b/drivers/pci/pci.c</span>
<span class="p_chunk">@@ -4214,6 +4214,10 @@</span> <span class="p_context"> static bool pci_bus_resetable(struct pci_bus *bus)</span>
 {
 	struct pci_dev *dev;
 
<span class="p_add">+</span>
<span class="p_add">+	if (bus-&gt;self &amp;&amp; (bus-&gt;self-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_BUS_RESET))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	list_for_each_entry(dev, &amp;bus-&gt;devices, bus_list) {
 		if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_BUS_RESET ||
 		    (dev-&gt;subordinate &amp;&amp; !pci_bus_resetable(dev-&gt;subordinate)))
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">index b1303b32053f..057465adf0b6 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_chunk">@@ -390,7 +390,14 @@</span> <span class="p_context"> static pci_ers_result_t broadcast_error_message(struct pci_dev *dev,</span>
 		 * If the error is reported by an end point, we think this
 		 * error is related to the upstream link of the end point.
 		 */
<span class="p_del">-		pci_walk_bus(dev-&gt;bus, cb, &amp;result_data);</span>
<span class="p_add">+		if (state == pci_channel_io_normal)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * the error is non fatal so the bus is ok, just invoke</span>
<span class="p_add">+			 * the callback for the function that logged the error.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			cb(dev, &amp;result_data);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pci_walk_bus(dev-&gt;bus, cb, &amp;result_data);</span>
 	}
 
 	return result_data.result;
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-st.c b/drivers/pinctrl/pinctrl-st.c</span>
<span class="p_header">index b7bb37167969..50c45bdf93be 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-st.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-st.c</span>
<span class="p_chunk">@@ -1285,6 +1285,22 @@</span> <span class="p_context"> static void st_gpio_irq_unmask(struct irq_data *d)</span>
 	writel(BIT(d-&gt;hwirq), bank-&gt;base + REG_PIO_SET_PMASK);
 }
 
<span class="p_add">+static int st_gpio_irq_request_resources(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+</span>
<span class="p_add">+	st_gpio_direction_input(gc, d-&gt;hwirq);</span>
<span class="p_add">+</span>
<span class="p_add">+	return gpiochip_lock_as_irq(gc, d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void st_gpio_irq_release_resources(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+</span>
<span class="p_add">+	gpiochip_unlock_as_irq(gc, d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int st_gpio_irq_set_type(struct irq_data *d, unsigned type)
 {
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
<span class="p_chunk">@@ -1438,12 +1454,14 @@</span> <span class="p_context"> static struct gpio_chip st_gpio_template = {</span>
 };
 
 static struct irq_chip st_gpio_irqchip = {
<span class="p_del">-	.name		= &quot;GPIO&quot;,</span>
<span class="p_del">-	.irq_disable	= st_gpio_irq_mask,</span>
<span class="p_del">-	.irq_mask	= st_gpio_irq_mask,</span>
<span class="p_del">-	.irq_unmask	= st_gpio_irq_unmask,</span>
<span class="p_del">-	.irq_set_type	= st_gpio_irq_set_type,</span>
<span class="p_del">-	.flags		= IRQCHIP_SKIP_SET_WAKE,</span>
<span class="p_add">+	.name			= &quot;GPIO&quot;,</span>
<span class="p_add">+	.irq_request_resources	= st_gpio_irq_request_resources,</span>
<span class="p_add">+	.irq_release_resources	= st_gpio_irq_release_resources,</span>
<span class="p_add">+	.irq_disable		= st_gpio_irq_mask,</span>
<span class="p_add">+	.irq_mask		= st_gpio_irq_mask,</span>
<span class="p_add">+	.irq_unmask		= st_gpio_irq_unmask,</span>
<span class="p_add">+	.irq_set_type		= st_gpio_irq_set_type,</span>
<span class="p_add">+	.flags			= IRQCHIP_SKIP_SET_WAKE,</span>
 };
 
 static int st_gpiolib_register_bank(struct st_pinctrl *info,
<span class="p_header">diff --git a/drivers/platform/x86/asus-wireless.c b/drivers/platform/x86/asus-wireless.c</span>
<span class="p_header">index 9f31bc1a47d0..18716025b1db 100644</span>
<span class="p_header">--- a/drivers/platform/x86/asus-wireless.c</span>
<span class="p_header">+++ b/drivers/platform/x86/asus-wireless.c</span>
<span class="p_chunk">@@ -97,6 +97,7 @@</span> <span class="p_context"> static void asus_wireless_notify(struct acpi_device *adev, u32 event)</span>
 		return;
 	}
 	input_report_key(data-&gt;idev, KEY_RFKILL, 1);
<span class="p_add">+	input_sync(data-&gt;idev);</span>
 	input_report_key(data-&gt;idev, KEY_RFKILL, 0);
 	input_sync(data-&gt;idev);
 }
<span class="p_header">diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c</span>
<span class="p_header">index 84a52db9b05f..6ebd42aad291 100644</span>
<span class="p_header">--- a/drivers/rtc/interface.c</span>
<span class="p_header">+++ b/drivers/rtc/interface.c</span>
<span class="p_chunk">@@ -772,7 +772,7 @@</span> <span class="p_context"> static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer)</span>
 	}
 
 	timerqueue_add(&amp;rtc-&gt;timerqueue, &amp;timer-&gt;node);
<span class="p_del">-	if (!next) {</span>
<span class="p_add">+	if (!next || ktime_before(timer-&gt;node.expires, next-&gt;expires)) {</span>
 		struct rtc_wkalrm alarm;
 		int err;
 		alarm.time = rtc_ktime_to_tm(timer-&gt;node.expires);
<span class="p_header">diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c</span>
<span class="p_header">index e1687e19c59f..a30f24cb6c83 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-pl031.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-pl031.c</span>
<span class="p_chunk">@@ -308,7 +308,8 @@</span> <span class="p_context"> static int pl031_remove(struct amba_device *adev)</span>
 
 	dev_pm_clear_wake_irq(&amp;adev-&gt;dev);
 	device_init_wakeup(&amp;adev-&gt;dev, false);
<span class="p_del">-	free_irq(adev-&gt;irq[0], ldata);</span>
<span class="p_add">+	if (adev-&gt;irq[0])</span>
<span class="p_add">+		free_irq(adev-&gt;irq[0], ldata);</span>
 	rtc_device_unregister(ldata-&gt;rtc);
 	iounmap(ldata-&gt;base);
 	kfree(ldata);
<span class="p_chunk">@@ -381,12 +382,13 @@</span> <span class="p_context"> static int pl031_probe(struct amba_device *adev, const struct amba_id *id)</span>
 		goto out_no_rtc;
 	}
 
<span class="p_del">-	if (request_irq(adev-&gt;irq[0], pl031_interrupt,</span>
<span class="p_del">-			vendor-&gt;irqflags, &quot;rtc-pl031&quot;, ldata)) {</span>
<span class="p_del">-		ret = -EIO;</span>
<span class="p_del">-		goto out_no_irq;</span>
<span class="p_add">+	if (adev-&gt;irq[0]) {</span>
<span class="p_add">+		ret = request_irq(adev-&gt;irq[0], pl031_interrupt,</span>
<span class="p_add">+				  vendor-&gt;irqflags, &quot;rtc-pl031&quot;, ldata);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_no_irq;</span>
<span class="p_add">+		dev_pm_set_wake_irq(&amp;adev-&gt;dev, adev-&gt;irq[0]);</span>
 	}
<span class="p_del">-	dev_pm_set_wake_irq(&amp;adev-&gt;dev, adev-&gt;irq[0]);</span>
 	return 0;
 
 out_no_irq:
<span class="p_header">diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h</span>
<span class="p_header">index e2bd2ad01b15..e72234efb648 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core.h</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core.h</span>
<span class="p_chunk">@@ -969,7 +969,8 @@</span> <span class="p_context"> int qeth_bridgeport_query_ports(struct qeth_card *card,</span>
 int qeth_bridgeport_setrole(struct qeth_card *card, enum qeth_sbp_roles role);
 int qeth_bridgeport_an_set(struct qeth_card *card, int enable);
 int qeth_get_priority_queue(struct qeth_card *, struct sk_buff *, int, int);
<span class="p_del">-int qeth_get_elements_no(struct qeth_card *, struct sk_buff *, int);</span>
<span class="p_add">+int qeth_get_elements_no(struct qeth_card *card, struct sk_buff *skb,</span>
<span class="p_add">+			 int extra_elems, int data_offset);</span>
 int qeth_get_elements_for_frags(struct sk_buff *);
 int qeth_do_send_packet_fast(struct qeth_card *, struct qeth_qdio_out_q *,
 			struct sk_buff *, struct qeth_hdr *, int, int, int);
<span class="p_header">diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">index b5fa6bb56b29..838ed6213118 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_chunk">@@ -3842,6 +3842,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(qeth_get_elements_for_frags);</span>
  * @card:			qeth card structure, to check max. elems.
  * @skb:			SKB address
  * @extra_elems:		extra elems needed, to check against max.
<span class="p_add">+ * @data_offset:		range starts at skb-&gt;data + data_offset</span>
  *
  * Returns the number of pages, and thus QDIO buffer elements, needed to cover
  * skb data, including linear part and fragments. Checks if the result plus
<span class="p_chunk">@@ -3849,10 +3850,10 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(qeth_get_elements_for_frags);</span>
  * Note: extra_elems is not included in the returned result.
  */
 int qeth_get_elements_no(struct qeth_card *card,
<span class="p_del">-		     struct sk_buff *skb, int extra_elems)</span>
<span class="p_add">+		     struct sk_buff *skb, int extra_elems, int data_offset)</span>
 {
 	int elements = qeth_get_elements_for_range(
<span class="p_del">-				(addr_t)skb-&gt;data,</span>
<span class="p_add">+				(addr_t)skb-&gt;data + data_offset,</span>
 				(addr_t)skb-&gt;data + skb_headlen(skb)) +
 			qeth_get_elements_for_frags(skb);
 
<span class="p_header">diff --git a/drivers/s390/net/qeth_l2_main.c b/drivers/s390/net/qeth_l2_main.c</span>
<span class="p_header">index ac33f6c999b1..5082dfeacb95 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l2_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l2_main.c</span>
<span class="p_chunk">@@ -865,7 +865,7 @@</span> <span class="p_context"> static int qeth_l2_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	 * chaining we can not send long frag lists
 	 */
 	if ((card-&gt;info.type != QETH_CARD_TYPE_IQD) &amp;&amp;
<span class="p_del">-	    !qeth_get_elements_no(card, new_skb, 0)) {</span>
<span class="p_add">+	    !qeth_get_elements_no(card, new_skb, 0, 0)) {</span>
 		int lin_rc = skb_linearize(new_skb);
 
 		if (card-&gt;options.performance_stats) {
<span class="p_chunk">@@ -910,7 +910,8 @@</span> <span class="p_context"> static int qeth_l2_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 		}
 	}
 
<span class="p_del">-	elements = qeth_get_elements_no(card, new_skb, elements_needed);</span>
<span class="p_add">+	elements = qeth_get_elements_no(card, new_skb, elements_needed,</span>
<span class="p_add">+					(data_offset &gt; 0) ? data_offset : 0);</span>
 	if (!elements) {
 		if (data_offset &gt;= 0)
 			kmem_cache_free(qeth_core_header_cache, hdr);
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">index 5735fc3be6c7..f91e70c369ed 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_chunk">@@ -2612,17 +2612,13 @@</span> <span class="p_context"> static void qeth_l3_fill_af_iucv_hdr(struct qeth_card *card,</span>
 	char daddr[16];
 	struct af_iucv_trans_hdr *iucv_hdr;
 
<span class="p_del">-	skb_pull(skb, 14);</span>
<span class="p_del">-	card-&gt;dev-&gt;header_ops-&gt;create(skb, card-&gt;dev, 0,</span>
<span class="p_del">-				      card-&gt;dev-&gt;dev_addr, card-&gt;dev-&gt;dev_addr,</span>
<span class="p_del">-				      card-&gt;dev-&gt;addr_len);</span>
<span class="p_del">-	skb_pull(skb, 14);</span>
<span class="p_del">-	iucv_hdr = (struct af_iucv_trans_hdr *)skb-&gt;data;</span>
 	memset(hdr, 0, sizeof(struct qeth_hdr));
 	hdr-&gt;hdr.l3.id = QETH_HEADER_TYPE_LAYER3;
 	hdr-&gt;hdr.l3.ext_flags = 0;
<span class="p_del">-	hdr-&gt;hdr.l3.length = skb-&gt;len;</span>
<span class="p_add">+	hdr-&gt;hdr.l3.length = skb-&gt;len - ETH_HLEN;</span>
 	hdr-&gt;hdr.l3.flags = QETH_HDR_IPV6 | QETH_CAST_UNICAST;
<span class="p_add">+</span>
<span class="p_add">+	iucv_hdr = (struct af_iucv_trans_hdr *) (skb-&gt;data + ETH_HLEN);</span>
 	memset(daddr, 0, sizeof(daddr));
 	daddr[0] = 0xfe;
 	daddr[1] = 0x80;
<span class="p_chunk">@@ -2826,10 +2822,7 @@</span> <span class="p_context"> static int qeth_l3_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if ((card-&gt;info.type == QETH_CARD_TYPE_IQD) &amp;&amp;
 	    !skb_is_nonlinear(skb)) {
 		new_skb = skb;
<span class="p_del">-		if (new_skb-&gt;protocol == ETH_P_AF_IUCV)</span>
<span class="p_del">-			data_offset = 0;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			data_offset = ETH_HLEN;</span>
<span class="p_add">+		data_offset = ETH_HLEN;</span>
 		hdr = kmem_cache_alloc(qeth_core_header_cache, GFP_ATOMIC);
 		if (!hdr)
 			goto tx_drop;
<span class="p_chunk">@@ -2870,7 +2863,7 @@</span> <span class="p_context"> static int qeth_l3_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	 */
 	if ((card-&gt;info.type != QETH_CARD_TYPE_IQD) &amp;&amp;
 	    ((use_tso &amp;&amp; !qeth_l3_get_elements_no_tso(card, new_skb, 1)) ||
<span class="p_del">-	     (!use_tso &amp;&amp; !qeth_get_elements_no(card, new_skb, 0)))) {</span>
<span class="p_add">+	     (!use_tso &amp;&amp; !qeth_get_elements_no(card, new_skb, 0, 0)))) {</span>
 		int lin_rc = skb_linearize(new_skb);
 
 		if (card-&gt;options.performance_stats) {
<span class="p_chunk">@@ -2912,7 +2905,8 @@</span> <span class="p_context"> static int qeth_l3_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 
 	elements = use_tso ?
 		   qeth_l3_get_elements_no_tso(card, new_skb, hdr_elements) :
<span class="p_del">-		   qeth_get_elements_no(card, new_skb, hdr_elements);</span>
<span class="p_add">+		   qeth_get_elements_no(card, new_skb, hdr_elements,</span>
<span class="p_add">+					(data_offset &gt; 0) ? data_offset : 0);</span>
 	if (!elements) {
 		if (data_offset &gt;= 0)
 			kmem_cache_free(qeth_core_header_cache, hdr);
<span class="p_header">diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c</span>
<span class="p_header">index 0039bebaa9e2..358ec32927ba 100644</span>
<span class="p_header">--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c</span>
<span class="p_header">+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c</span>
<span class="p_chunk">@@ -1347,6 +1347,7 @@</span> <span class="p_context"> static void release_offload_resources(struct cxgbi_sock *csk)</span>
 		csk, csk-&gt;state, csk-&gt;flags, csk-&gt;tid);
 
 	cxgbi_sock_free_cpl_skbs(csk);
<span class="p_add">+	cxgbi_sock_purge_write_queue(csk);</span>
 	if (csk-&gt;wr_cred != csk-&gt;wr_max_cred) {
 		cxgbi_sock_purge_wr_queue(csk);
 		cxgbi_sock_reset_wr_list(csk);
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">index 9c9563312a3d..fc7addaf24da 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_chunk">@@ -7782,7 +7782,8 @@</span> <span class="p_context"> lpfc_els_unsol_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,</span>
 			did, vport-&gt;port_state, ndlp-&gt;nlp_flag);
 
 		phba-&gt;fc_stat.elsRcvPRLI++;
<span class="p_del">-		if (vport-&gt;port_state &lt; LPFC_DISC_AUTH) {</span>
<span class="p_add">+		if ((vport-&gt;port_state &lt; LPFC_DISC_AUTH) &amp;&amp;</span>
<span class="p_add">+		    (vport-&gt;fc_flag &amp; FC_FABRIC)) {</span>
 			rjt_err = LSRJT_UNABLE_TPC;
 			rjt_exp = LSEXP_NOTHING_MORE;
 			break;
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c</span>
<span class="p_header">index ed223937798a..7d2ad633b6bc 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_hbadisc.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c</span>
<span class="p_chunk">@@ -4784,7 +4784,8 @@</span> <span class="p_context"> lpfc_nlp_remove(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)</span>
 	lpfc_cancel_retry_delay_tmo(vport, ndlp);
 	if ((ndlp-&gt;nlp_flag &amp; NLP_DEFER_RM) &amp;&amp;
 	    !(ndlp-&gt;nlp_flag &amp; NLP_REG_LOGIN_SEND) &amp;&amp;
<span class="p_del">-	    !(ndlp-&gt;nlp_flag &amp; NLP_RPI_REGISTERED)) {</span>
<span class="p_add">+	    !(ndlp-&gt;nlp_flag &amp; NLP_RPI_REGISTERED) &amp;&amp;</span>
<span class="p_add">+	    phba-&gt;sli_rev != LPFC_SLI_REV4) {</span>
 		/* For this case we need to cleanup the default rpi
 		 * allocated by the firmware.
 		 */
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_hw4.h b/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_header">index 55faa94637a9..2a436dff1589 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_chunk">@@ -3232,7 +3232,7 @@</span> <span class="p_context"> struct lpfc_mbx_get_port_name {</span>
 #define MB_CEQ_STATUS_QUEUE_FLUSHING		0x4
 #define MB_CQE_STATUS_DMA_FAILED		0x5
 
<span class="p_del">-#define LPFC_MBX_WR_CONFIG_MAX_BDE		8</span>
<span class="p_add">+#define LPFC_MBX_WR_CONFIG_MAX_BDE		1</span>
 struct lpfc_mbx_wr_object {
 	struct mbox_header header;
 	union {
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index 289374cbcb47..468acab04d3d 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -4770,6 +4770,11 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 		} else if (log_info == VIRTUAL_IO_FAILED_RETRY) {
 			scmd-&gt;result = DID_RESET &lt;&lt; 16;
 			break;
<span class="p_add">+		} else if ((scmd-&gt;device-&gt;channel == RAID_CHANNEL) &amp;&amp;</span>
<span class="p_add">+		   (scsi_state == (MPI2_SCSI_STATE_TERMINATED |</span>
<span class="p_add">+		   MPI2_SCSI_STATE_NO_SCSI_STATUS))) {</span>
<span class="p_add">+			scmd-&gt;result = DID_RESET &lt;&lt; 16;</span>
<span class="p_add">+			break;</span>
 		}
 		scmd-&gt;result = DID_SOFT_ERROR &lt;&lt; 16;
 		break;
<span class="p_header">diff --git a/drivers/staging/greybus/light.c b/drivers/staging/greybus/light.c</span>
<span class="p_header">index 8dffd8a7e762..9f01427f35f9 100644</span>
<span class="p_header">--- a/drivers/staging/greybus/light.c</span>
<span class="p_header">+++ b/drivers/staging/greybus/light.c</span>
<span class="p_chunk">@@ -924,6 +924,8 @@</span> <span class="p_context"> static void __gb_lights_led_unregister(struct gb_channel *channel)</span>
 		return;
 
 	led_classdev_unregister(cdev);
<span class="p_add">+	kfree(cdev-&gt;name);</span>
<span class="p_add">+	cdev-&gt;name = NULL;</span>
 	channel-&gt;led = NULL;
 }
 
<span class="p_header">diff --git a/drivers/thermal/hisi_thermal.c b/drivers/thermal/hisi_thermal.c</span>
<span class="p_header">index f6429666a1cf..c5285ed34fdd 100644</span>
<span class="p_header">--- a/drivers/thermal/hisi_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/hisi_thermal.c</span>
<span class="p_chunk">@@ -35,8 +35,9 @@</span> <span class="p_context"></span>
 #define TEMP0_RST_MSK			(0x1C)
 #define TEMP0_VALUE			(0x28)
 
<span class="p_del">-#define HISI_TEMP_BASE			(-60)</span>
<span class="p_add">+#define HISI_TEMP_BASE			(-60000)</span>
 #define HISI_TEMP_RESET			(100000)
<span class="p_add">+#define HISI_TEMP_STEP			(784)</span>
 
 #define HISI_MAX_SENSORS		4
 
<span class="p_chunk">@@ -61,19 +62,38 @@</span> <span class="p_context"> struct hisi_thermal_data {</span>
 	void __iomem *regs;
 };
 
<span class="p_del">-/* in millicelsius */</span>
<span class="p_del">-static inline int _step_to_temp(int step)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The temperature computation on the tsensor is as follow:</span>
<span class="p_add">+ *	Unit: millidegree Celsius</span>
<span class="p_add">+ *	Step: 255/200 (0.7843)</span>
<span class="p_add">+ *	Temperature base: -60°C</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The register is programmed in temperature steps, every step is 784</span>
<span class="p_add">+ * millidegree and begins at -60 000 m°C</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The temperature from the steps:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Temp = TempBase + (steps x 784)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * and the steps from the temperature:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	steps = (Temp - TempBase) / 784</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int hisi_thermal_step_to_temp(int step)</span>
 {
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Every step equals (1 * 200) / 255 celsius, and finally</span>
<span class="p_del">-	 * need convert to millicelsius.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	return (HISI_TEMP_BASE * 1000 + (step * 200000 / 255));</span>
<span class="p_add">+	return HISI_TEMP_BASE + (step * HISI_TEMP_STEP);</span>
 }
 
<span class="p_del">-static inline long _temp_to_step(long temp)</span>
<span class="p_add">+static inline long hisi_thermal_temp_to_step(long temp)</span>
 {
<span class="p_del">-	return ((temp - HISI_TEMP_BASE * 1000) * 255) / 200000;</span>
<span class="p_add">+	return (temp - HISI_TEMP_BASE) / HISI_TEMP_STEP;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline long hisi_thermal_round_temp(int temp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return hisi_thermal_step_to_temp(</span>
<span class="p_add">+		hisi_thermal_temp_to_step(temp));</span>
 }
 
 static long hisi_thermal_get_sensor_temp(struct hisi_thermal_data *data,
<span class="p_chunk">@@ -99,7 +119,7 @@</span> <span class="p_context"> static long hisi_thermal_get_sensor_temp(struct hisi_thermal_data *data,</span>
 	usleep_range(3000, 5000);
 
 	val = readl(data-&gt;regs + TEMP0_VALUE);
<span class="p_del">-	val = _step_to_temp(val);</span>
<span class="p_add">+	val = hisi_thermal_step_to_temp(val);</span>
 
 	mutex_unlock(&amp;data-&gt;thermal_lock);
 
<span class="p_chunk">@@ -126,10 +146,11 @@</span> <span class="p_context"> static void hisi_thermal_enable_bind_irq_sensor</span>
 	writel((sensor-&gt;id &lt;&lt; 12), data-&gt;regs + TEMP0_CFG);
 
 	/* enable for interrupt */
<span class="p_del">-	writel(_temp_to_step(sensor-&gt;thres_temp) | 0x0FFFFFF00,</span>
<span class="p_add">+	writel(hisi_thermal_temp_to_step(sensor-&gt;thres_temp) | 0x0FFFFFF00,</span>
 	       data-&gt;regs + TEMP0_TH);
 
<span class="p_del">-	writel(_temp_to_step(HISI_TEMP_RESET), data-&gt;regs + TEMP0_RST_TH);</span>
<span class="p_add">+	writel(hisi_thermal_temp_to_step(HISI_TEMP_RESET),</span>
<span class="p_add">+	       data-&gt;regs + TEMP0_RST_TH);</span>
 
 	/* enable module */
 	writel(0x1, data-&gt;regs + TEMP0_RST_MSK);
<span class="p_chunk">@@ -230,7 +251,7 @@</span> <span class="p_context"> static irqreturn_t hisi_thermal_alarm_irq_thread(int irq, void *dev)</span>
 	sensor = &amp;data-&gt;sensors[data-&gt;irq_bind_sensor];
 
 	dev_crit(&amp;data-&gt;pdev-&gt;dev, &quot;THERMAL ALARM: T &gt; %d\n&quot;,
<span class="p_del">-		 sensor-&gt;thres_temp / 1000);</span>
<span class="p_add">+		 sensor-&gt;thres_temp);</span>
 	mutex_unlock(&amp;data-&gt;thermal_lock);
 
 	for (i = 0; i &lt; HISI_MAX_SENSORS; i++) {
<span class="p_chunk">@@ -269,7 +290,7 @@</span> <span class="p_context"> static int hisi_thermal_register_sensor(struct platform_device *pdev,</span>
 
 	for (i = 0; i &lt; of_thermal_get_ntrips(sensor-&gt;tzd); i++) {
 		if (trip[i].type == THERMAL_TRIP_PASSIVE) {
<span class="p_del">-			sensor-&gt;thres_temp = trip[i].temperature;</span>
<span class="p_add">+			sensor-&gt;thres_temp = hisi_thermal_round_temp(trip[i].temperature);</span>
 			break;
 		}
 	}
<span class="p_chunk">@@ -317,15 +338,6 @@</span> <span class="p_context"> static int hisi_thermal_probe(struct platform_device *pdev)</span>
 	if (data-&gt;irq &lt; 0)
 		return data-&gt;irq;
 
<span class="p_del">-	ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, data-&gt;irq,</span>
<span class="p_del">-					hisi_thermal_alarm_irq,</span>
<span class="p_del">-					hisi_thermal_alarm_irq_thread,</span>
<span class="p_del">-					0, &quot;hisi_thermal&quot;, data);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;failed to request alarm irq: %d\n&quot;, ret);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	platform_set_drvdata(pdev, data);
 
 	data-&gt;clk = devm_clk_get(&amp;pdev-&gt;dev, &quot;thermal_clk&quot;);
<span class="p_chunk">@@ -345,8 +357,7 @@</span> <span class="p_context"> static int hisi_thermal_probe(struct platform_device *pdev)</span>
 	}
 
 	hisi_thermal_enable_bind_irq_sensor(data);
<span class="p_del">-	irq_get_irqchip_state(data-&gt;irq, IRQCHIP_STATE_MASKED,</span>
<span class="p_del">-			      &amp;data-&gt;irq_enabled);</span>
<span class="p_add">+	data-&gt;irq_enabled = true;</span>
 
 	for (i = 0; i &lt; HISI_MAX_SENSORS; ++i) {
 		ret = hisi_thermal_register_sensor(pdev, data,
<span class="p_chunk">@@ -358,6 +369,17 @@</span> <span class="p_context"> static int hisi_thermal_probe(struct platform_device *pdev)</span>
 			hisi_thermal_toggle_sensor(&amp;data-&gt;sensors[i], true);
 	}
 
<span class="p_add">+	ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, data-&gt;irq,</span>
<span class="p_add">+					hisi_thermal_alarm_irq,</span>
<span class="p_add">+					hisi_thermal_alarm_irq_thread,</span>
<span class="p_add">+					0, &quot;hisi_thermal&quot;, data);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;failed to request alarm irq: %d\n&quot;, ret);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	enable_irq(data-&gt;irq);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -397,8 +419,11 @@</span> <span class="p_context"> static int hisi_thermal_suspend(struct device *dev)</span>
 static int hisi_thermal_resume(struct device *dev)
 {
 	struct hisi_thermal_data *data = dev_get_drvdata(dev);
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	clk_prepare_enable(data-&gt;clk);</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	data-&gt;irq_enabled = true;
 	hisi_thermal_enable_bind_irq_sensor(data);
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_uvc.c b/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_header">index c7689d05356c..f8a1881609a2 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_chunk">@@ -594,6 +594,14 @@</span> <span class="p_context"> uvc_function_bind(struct usb_configuration *c, struct usb_function *f)</span>
 	opts-&gt;streaming_maxpacket = clamp(opts-&gt;streaming_maxpacket, 1U, 3072U);
 	opts-&gt;streaming_maxburst = min(opts-&gt;streaming_maxburst, 15U);
 
<span class="p_add">+	/* For SS, wMaxPacketSize has to be 1024 if bMaxBurst is not 0 */</span>
<span class="p_add">+	if (opts-&gt;streaming_maxburst &amp;&amp;</span>
<span class="p_add">+	    (opts-&gt;streaming_maxpacket % 1024) != 0) {</span>
<span class="p_add">+		opts-&gt;streaming_maxpacket = roundup(opts-&gt;streaming_maxpacket, 1024);</span>
<span class="p_add">+		INFO(cdev, &quot;overriding streaming_maxpacket to %d\n&quot;,</span>
<span class="p_add">+		     opts-&gt;streaming_maxpacket);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Fill in the FS/HS/SS Video Streaming specific descriptors from the
 	 * module parameters.
 	 *
<span class="p_header">diff --git a/drivers/usb/gadget/udc/pch_udc.c b/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_header">index a97da645c1b9..8a365aad66fe 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_chunk">@@ -1523,7 +1523,6 @@</span> <span class="p_context"> static void pch_udc_free_dma_chain(struct pch_udc_dev *dev,</span>
 		td = phys_to_virt(addr);
 		addr2 = (dma_addr_t)td-&gt;next;
 		pci_pool_free(dev-&gt;data_requests, td, addr);
<span class="p_del">-		td-&gt;next = 0x00;</span>
 		addr = addr2;
 	}
 	req-&gt;chain_len = 1;
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">index ca8b0b1ae37d..dec100811946 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.c</span>
<span class="p_chunk">@@ -335,6 +335,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(acpi, usb_xhci_acpi_match);</span>
 static struct platform_driver usb_xhci_driver = {
 	.probe	= xhci_plat_probe,
 	.remove	= xhci_plat_remove,
<span class="p_add">+	.shutdown	= usb_hcd_platform_shutdown,</span>
 	.driver	= {
 		.name = &quot;xhci-hcd&quot;,
 		.pm = DEV_PM_OPS,
<span class="p_header">diff --git a/drivers/vfio/pci/vfio_pci_config.c b/drivers/vfio/pci/vfio_pci_config.c</span>
<span class="p_header">index 65d4a3015542..9f1ec4392209 100644</span>
<span class="p_header">--- a/drivers/vfio/pci/vfio_pci_config.c</span>
<span class="p_header">+++ b/drivers/vfio/pci/vfio_pci_config.c</span>
<span class="p_chunk">@@ -851,11 +851,13 @@</span> <span class="p_context"> static int __init init_pci_cap_exp_perm(struct perm_bits *perm)</span>
 
 	/*
 	 * Allow writes to device control fields, except devctl_phantom,
<span class="p_del">-	 * which could confuse IOMMU, and the ARI bit in devctl2, which</span>
<span class="p_add">+	 * which could confuse IOMMU, MPS, which can break communication</span>
<span class="p_add">+	 * with other physical devices, and the ARI bit in devctl2, which</span>
 	 * is set at probe time.  FLR gets virtualized via our writefn.
 	 */
 	p_setw(perm, PCI_EXP_DEVCTL,
<span class="p_del">-	       PCI_EXP_DEVCTL_BCR_FLR, ~PCI_EXP_DEVCTL_PHANTOM);</span>
<span class="p_add">+	       PCI_EXP_DEVCTL_BCR_FLR | PCI_EXP_DEVCTL_PAYLOAD,</span>
<span class="p_add">+	       ~PCI_EXP_DEVCTL_PHANTOM);</span>
 	p_setw(perm, PCI_EXP_DEVCTL2, NO_VIRT, ~PCI_EXP_DEVCTL2_ARI);
 	return 0;
 }
<span class="p_header">diff --git a/drivers/vhost/vsock.c b/drivers/vhost/vsock.c</span>
<span class="p_header">index e3fad302b4fb..0ec970ca64ce 100644</span>
<span class="p_header">--- a/drivers/vhost/vsock.c</span>
<span class="p_header">+++ b/drivers/vhost/vsock.c</span>
<span class="p_chunk">@@ -218,6 +218,46 @@</span> <span class="p_context"> vhost_transport_send_pkt(struct virtio_vsock_pkt *pkt)</span>
 	return len;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+vhost_transport_cancel_pkt(struct vsock_sock *vsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vhost_vsock *vsock;</span>
<span class="p_add">+	struct virtio_vsock_pkt *pkt, *n;</span>
<span class="p_add">+	int cnt = 0;</span>
<span class="p_add">+	LIST_HEAD(freeme);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the vhost_vsock according to guest context id  */</span>
<span class="p_add">+	vsock = vhost_vsock_get(vsk-&gt;remote_addr.svm_cid);</span>
<span class="p_add">+	if (!vsock)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;vsock-&gt;send_pkt_list_lock);</span>
<span class="p_add">+	list_for_each_entry_safe(pkt, n, &amp;vsock-&gt;send_pkt_list, list) {</span>
<span class="p_add">+		if (pkt-&gt;vsk != vsk)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		list_move(&amp;pkt-&gt;list, &amp;freeme);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;vsock-&gt;send_pkt_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(pkt, n, &amp;freeme, list) {</span>
<span class="p_add">+		if (pkt-&gt;reply)</span>
<span class="p_add">+			cnt++;</span>
<span class="p_add">+		list_del(&amp;pkt-&gt;list);</span>
<span class="p_add">+		virtio_transport_free_pkt(pkt);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cnt) {</span>
<span class="p_add">+		struct vhost_virtqueue *tx_vq = &amp;vsock-&gt;vqs[VSOCK_VQ_TX];</span>
<span class="p_add">+		int new_cnt;</span>
<span class="p_add">+</span>
<span class="p_add">+		new_cnt = atomic_sub_return(cnt, &amp;vsock-&gt;queued_replies);</span>
<span class="p_add">+		if (new_cnt + cnt &gt;= tx_vq-&gt;num &amp;&amp; new_cnt &lt; tx_vq-&gt;num)</span>
<span class="p_add">+			vhost_poll_queue(&amp;tx_vq-&gt;poll);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct virtio_vsock_pkt *
 vhost_vsock_alloc_pkt(struct vhost_virtqueue *vq,
 		      unsigned int out, unsigned int in)
<span class="p_chunk">@@ -669,6 +709,7 @@</span> <span class="p_context"> static struct virtio_transport vhost_transport = {</span>
 		.release                  = virtio_transport_release,
 		.connect                  = virtio_transport_connect,
 		.shutdown                 = virtio_transport_shutdown,
<span class="p_add">+		.cancel_pkt               = vhost_transport_cancel_pkt,</span>
 
 		.dgram_enqueue            = virtio_transport_dgram_enqueue,
 		.dgram_dequeue            = virtio_transport_dgram_dequeue,
<span class="p_header">diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c</span>
<span class="p_header">index 12614006211e..d95ae092f154 100644</span>
<span class="p_header">--- a/drivers/video/backlight/pwm_bl.c</span>
<span class="p_header">+++ b/drivers/video/backlight/pwm_bl.c</span>
<span class="p_chunk">@@ -79,14 +79,17 @@</span> <span class="p_context"> static void pwm_backlight_power_off(struct pwm_bl_data *pb)</span>
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
 {
 	unsigned int lth = pb-&gt;lth_brightness;
<span class="p_del">-	int duty_cycle;</span>
<span class="p_add">+	u64 duty_cycle;</span>
 
 	if (pb-&gt;levels)
 		duty_cycle = pb-&gt;levels[brightness];
 	else
 		duty_cycle = brightness;
 
<span class="p_del">-	return (duty_cycle * (pb-&gt;period - lth) / pb-&gt;scale) + lth;</span>
<span class="p_add">+	duty_cycle *= pb-&gt;period - lth;</span>
<span class="p_add">+	do_div(duty_cycle, pb-&gt;scale);</span>
<span class="p_add">+</span>
<span class="p_add">+	return duty_cycle + lth;</span>
 }
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
<span class="p_header">diff --git a/drivers/virtio/virtio_balloon.c b/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">index 2c2e6792f7e0..a7c08cc4c1b7 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_balloon.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_balloon.c</span>
<span class="p_chunk">@@ -241,11 +241,11 @@</span> <span class="p_context"> static inline void update_stat(struct virtio_balloon *vb, int idx,</span>
 
 #define pages_to_bytes(x) ((u64)(x) &lt;&lt; PAGE_SHIFT)
 
<span class="p_del">-static void update_balloon_stats(struct virtio_balloon *vb)</span>
<span class="p_add">+static unsigned int update_balloon_stats(struct virtio_balloon *vb)</span>
 {
 	unsigned long events[NR_VM_EVENT_ITEMS];
 	struct sysinfo i;
<span class="p_del">-	int idx = 0;</span>
<span class="p_add">+	unsigned int idx = 0;</span>
 	long available;
 
 	all_vm_events(events);
<span class="p_chunk">@@ -253,18 +253,22 @@</span> <span class="p_context"> static void update_balloon_stats(struct virtio_balloon *vb)</span>
 
 	available = si_mem_available();
 
<span class="p_add">+#ifdef CONFIG_VM_EVENT_COUNTERS</span>
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_IN,
 				pages_to_bytes(events[PSWPIN]));
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_SWAP_OUT,
 				pages_to_bytes(events[PSWPOUT]));
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_MAJFLT, events[PGMAJFAULT]);
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_MINFLT, events[PGFAULT]);
<span class="p_add">+#endif</span>
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_MEMFREE,
 				pages_to_bytes(i.freeram));
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_MEMTOT,
 				pages_to_bytes(i.totalram));
 	update_stat(vb, idx++, VIRTIO_BALLOON_S_AVAIL,
 				pages_to_bytes(available));
<span class="p_add">+</span>
<span class="p_add">+	return idx;</span>
 }
 
 /*
<span class="p_chunk">@@ -290,14 +294,14 @@</span> <span class="p_context"> static void stats_handle_request(struct virtio_balloon *vb)</span>
 {
 	struct virtqueue *vq;
 	struct scatterlist sg;
<span class="p_del">-	unsigned int len;</span>
<span class="p_add">+	unsigned int len, num_stats;</span>
 
<span class="p_del">-	update_balloon_stats(vb);</span>
<span class="p_add">+	num_stats = update_balloon_stats(vb);</span>
 
 	vq = vb-&gt;stats_vq;
 	if (!virtqueue_get_buf(vq, &amp;len))
 		return;
<span class="p_del">-	sg_init_one(&amp;sg, vb-&gt;stats, sizeof(vb-&gt;stats));</span>
<span class="p_add">+	sg_init_one(&amp;sg, vb-&gt;stats, sizeof(vb-&gt;stats[0]) * num_stats);</span>
 	virtqueue_add_outbuf(vq, &amp;sg, 1, vb, GFP_KERNEL);
 	virtqueue_kick(vq);
 }
<span class="p_chunk">@@ -421,15 +425,16 @@</span> <span class="p_context"> static int init_vqs(struct virtio_balloon *vb)</span>
 	vb-&gt;deflate_vq = vqs[1];
 	if (virtio_has_feature(vb-&gt;vdev, VIRTIO_BALLOON_F_STATS_VQ)) {
 		struct scatterlist sg;
<span class="p_add">+		unsigned int num_stats;</span>
 		vb-&gt;stats_vq = vqs[2];
 
 		/*
 		 * Prime this virtqueue with one buffer so the hypervisor can
 		 * use it to signal us later (it can&#39;t be broken yet!).
 		 */
<span class="p_del">-		update_balloon_stats(vb);</span>
<span class="p_add">+		num_stats = update_balloon_stats(vb);</span>
 
<span class="p_del">-		sg_init_one(&amp;sg, vb-&gt;stats, sizeof vb-&gt;stats);</span>
<span class="p_add">+		sg_init_one(&amp;sg, vb-&gt;stats, sizeof(vb-&gt;stats[0]) * num_stats);</span>
 		if (virtqueue_add_outbuf(vb-&gt;stats_vq, &amp;sg, 1, vb, GFP_KERNEL)
 		    &lt; 0)
 			BUG();
<span class="p_header">diff --git a/fs/btrfs/send.c b/fs/btrfs/send.c</span>
<span class="p_header">index 77f9efc1f7aa..9a47b5598df7 100644</span>
<span class="p_header">--- a/fs/btrfs/send.c</span>
<span class="p_header">+++ b/fs/btrfs/send.c</span>
<span class="p_chunk">@@ -6196,8 +6196,13 @@</span> <span class="p_context"> long btrfs_ioctl_send(struct file *mnt_file, void __user *arg_)</span>
 		goto out;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check that we don&#39;t overflow at later allocations, we request</span>
<span class="p_add">+	 * clone_sources_count + 1 items, and compare to unsigned long inside</span>
<span class="p_add">+	 * access_ok.</span>
<span class="p_add">+	 */</span>
 	if (arg-&gt;clone_sources_count &gt;
<span class="p_del">-	    ULLONG_MAX / sizeof(*arg-&gt;clone_sources)) {</span>
<span class="p_add">+	    ULONG_MAX / sizeof(struct clone_root) - 1) {</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/include/linux/bpf_verifier.h b/include/linux/bpf_verifier.h</span>
<span class="p_header">index 3101141661a1..4c4e9358c146 100644</span>
<span class="p_header">--- a/include/linux/bpf_verifier.h</span>
<span class="p_header">+++ b/include/linux/bpf_verifier.h</span>
<span class="p_chunk">@@ -68,6 +68,7 @@</span> <span class="p_context"> struct bpf_verifier_state_list {</span>
 
 struct bpf_insn_aux_data {
 	enum bpf_reg_type ptr_type;	/* pointer type for load/store insns */
<span class="p_add">+	bool seen; /* this insn was processed by the verifier */</span>
 };
 
 #define MAX_USED_MAPS 64 /* max number of maps accessed by one eBPF program */
<span class="p_header">diff --git a/include/linux/virtio_vsock.h b/include/linux/virtio_vsock.h</span>
<span class="p_header">index 9638bfeb0d1f..584f9a647ad4 100644</span>
<span class="p_header">--- a/include/linux/virtio_vsock.h</span>
<span class="p_header">+++ b/include/linux/virtio_vsock.h</span>
<span class="p_chunk">@@ -48,6 +48,8 @@</span> <span class="p_context"> struct virtio_vsock_pkt {</span>
 	struct virtio_vsock_hdr	hdr;
 	struct work_struct work;
 	struct list_head list;
<span class="p_add">+	/* socket refcnt not held, only use for cancellation */</span>
<span class="p_add">+	struct vsock_sock *vsk;</span>
 	void *buf;
 	u32 len;
 	u32 off;
<span class="p_chunk">@@ -56,6 +58,7 @@</span> <span class="p_context"> struct virtio_vsock_pkt {</span>
 
 struct virtio_vsock_pkt_info {
 	u32 remote_cid, remote_port;
<span class="p_add">+	struct vsock_sock *vsk;</span>
 	struct msghdr *msg;
 	u32 pkt_len;
 	u16 type;
<span class="p_header">diff --git a/include/net/af_vsock.h b/include/net/af_vsock.h</span>
<span class="p_header">index f2758964ce6f..f32ed9ac181a 100644</span>
<span class="p_header">--- a/include/net/af_vsock.h</span>
<span class="p_header">+++ b/include/net/af_vsock.h</span>
<span class="p_chunk">@@ -100,6 +100,9 @@</span> <span class="p_context"> struct vsock_transport {</span>
 	void (*destruct)(struct vsock_sock *);
 	void (*release)(struct vsock_sock *);
 
<span class="p_add">+	/* Cancel all pending packets sent on vsock. */</span>
<span class="p_add">+	int (*cancel_pkt)(struct vsock_sock *vsk);</span>
<span class="p_add">+</span>
 	/* Connections. */
 	int (*connect)(struct vsock_sock *);
 
<span class="p_header">diff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c</span>
<span class="p_header">index 372454aa7f37..8b1ebe4c6aba 100644</span>
<span class="p_header">--- a/kernel/bpf/verifier.c</span>
<span class="p_header">+++ b/kernel/bpf/verifier.c</span>
<span class="p_chunk">@@ -1790,10 +1790,17 @@</span> <span class="p_context"> static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)</span>
 			/* case: R = imm
 			 * remember the value we stored into this reg
 			 */
<span class="p_add">+			u64 imm;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (BPF_CLASS(insn-&gt;code) == BPF_ALU64)</span>
<span class="p_add">+				imm = insn-&gt;imm;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				imm = (u32)insn-&gt;imm;</span>
<span class="p_add">+</span>
 			regs[insn-&gt;dst_reg].type = CONST_IMM;
<span class="p_del">-			regs[insn-&gt;dst_reg].imm = insn-&gt;imm;</span>
<span class="p_del">-			regs[insn-&gt;dst_reg].max_value = insn-&gt;imm;</span>
<span class="p_del">-			regs[insn-&gt;dst_reg].min_value = insn-&gt;imm;</span>
<span class="p_add">+			regs[insn-&gt;dst_reg].imm = imm;</span>
<span class="p_add">+			regs[insn-&gt;dst_reg].max_value = imm;</span>
<span class="p_add">+			regs[insn-&gt;dst_reg].min_value = imm;</span>
 		}
 
 	} else if (opcode &gt; BPF_END) {
<span class="p_chunk">@@ -1861,10 +1868,28 @@</span> <span class="p_context"> static int check_alu_op(struct bpf_verifier_env *env, struct bpf_insn *insn)</span>
 			   ((BPF_SRC(insn-&gt;code) == BPF_X &amp;&amp;
 			     regs[insn-&gt;src_reg].type == CONST_IMM) ||
 			    BPF_SRC(insn-&gt;code) == BPF_K)) {
<span class="p_del">-			if (BPF_SRC(insn-&gt;code) == BPF_X)</span>
<span class="p_add">+			if (BPF_SRC(insn-&gt;code) == BPF_X) {</span>
<span class="p_add">+				/* check in case the register contains a big</span>
<span class="p_add">+				 * 64-bit value</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (regs[insn-&gt;src_reg].imm &lt; -MAX_BPF_STACK ||</span>
<span class="p_add">+				    regs[insn-&gt;src_reg].imm &gt; MAX_BPF_STACK) {</span>
<span class="p_add">+					verbose(&quot;R%d value too big in R%d pointer arithmetic\n&quot;,</span>
<span class="p_add">+						insn-&gt;src_reg, insn-&gt;dst_reg);</span>
<span class="p_add">+					return -EACCES;</span>
<span class="p_add">+				}</span>
 				dst_reg-&gt;imm += regs[insn-&gt;src_reg].imm;
<span class="p_del">-			else</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/* safe against overflow: addition of 32-bit</span>
<span class="p_add">+				 * numbers in 64-bit representation</span>
<span class="p_add">+				 */</span>
 				dst_reg-&gt;imm += insn-&gt;imm;
<span class="p_add">+			}</span>
<span class="p_add">+			if (dst_reg-&gt;imm &gt; 0 || dst_reg-&gt;imm &lt; -MAX_BPF_STACK) {</span>
<span class="p_add">+				verbose(&quot;R%d out-of-bounds pointer arithmetic\n&quot;,</span>
<span class="p_add">+					insn-&gt;dst_reg);</span>
<span class="p_add">+				return -EACCES;</span>
<span class="p_add">+			}</span>
 			return 0;
 		} else if (opcode == BPF_ADD &amp;&amp;
 			   BPF_CLASS(insn-&gt;code) == BPF_ALU64 &amp;&amp;
<span class="p_chunk">@@ -2862,6 +2887,7 @@</span> <span class="p_context"> static int do_check(struct bpf_verifier_env *env)</span>
 		if (err)
 			return err;
 
<span class="p_add">+		env-&gt;insn_aux_data[insn_idx].seen = true;</span>
 		if (class == BPF_ALU || class == BPF_ALU64) {
 			err = check_alu_op(env, insn);
 			if (err)
<span class="p_chunk">@@ -3059,6 +3085,7 @@</span> <span class="p_context"> static int do_check(struct bpf_verifier_env *env)</span>
 					return err;
 
 				insn_idx++;
<span class="p_add">+				env-&gt;insn_aux_data[insn_idx].seen = true;</span>
 			} else {
 				verbose(&quot;invalid BPF_LD mode\n&quot;);
 				return -EINVAL;
<span class="p_chunk">@@ -3210,6 +3237,63 @@</span> <span class="p_context"> static void convert_pseudo_ld_imm64(struct bpf_verifier_env *env)</span>
 			insn-&gt;src_reg = 0;
 }
 
<span class="p_add">+/* single env-&gt;prog-&gt;insni[off] instruction was replaced with the range</span>
<span class="p_add">+ * insni[off, off + cnt).  Adjust corresponding insn_aux_data by copying</span>
<span class="p_add">+ * [0, off) and [off, end) to new locations, so the patched range stays zero</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,</span>
<span class="p_add">+				u32 off, u32 cnt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bpf_insn_aux_data *new_data, *old_data = env-&gt;insn_aux_data;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cnt == 1)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	new_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);</span>
<span class="p_add">+	if (!new_data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	memcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);</span>
<span class="p_add">+	memcpy(new_data + off + cnt - 1, old_data + off,</span>
<span class="p_add">+	       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));</span>
<span class="p_add">+	for (i = off; i &lt; off + cnt - 1; i++)</span>
<span class="p_add">+		new_data[i].seen = true;</span>
<span class="p_add">+	env-&gt;insn_aux_data = new_data;</span>
<span class="p_add">+	vfree(old_data);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct bpf_prog *bpf_patch_insn_data(struct bpf_verifier_env *env, u32 off,</span>
<span class="p_add">+					    const struct bpf_insn *patch, u32 len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bpf_prog *new_prog;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_prog = bpf_patch_insn_single(env-&gt;prog, off, patch, len);</span>
<span class="p_add">+	if (!new_prog)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	if (adjust_insn_aux_data(env, new_prog-&gt;len, off, len))</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	return new_prog;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* The verifier does more data flow analysis than llvm and will not explore</span>
<span class="p_add">+ * branches that are dead at run time. Malicious programs can have dead code</span>
<span class="p_add">+ * too. Therefore replace all dead at-run-time code with nops.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sanitize_dead_code(struct bpf_verifier_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bpf_insn_aux_data *aux_data = env-&gt;insn_aux_data;</span>
<span class="p_add">+	struct bpf_insn nop = BPF_MOV64_REG(BPF_REG_0, BPF_REG_0);</span>
<span class="p_add">+	struct bpf_insn *insn = env-&gt;prog-&gt;insnsi;</span>
<span class="p_add">+	const int insn_cnt = env-&gt;prog-&gt;len;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; insn_cnt; i++) {</span>
<span class="p_add">+		if (aux_data[i].seen)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		memcpy(insn + i, &amp;nop, sizeof(nop));</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* convert load instructions that access fields of &#39;struct __sk_buff&#39;
  * into sequence of instructions that access fields of &#39;struct sk_buff&#39;
  */
<span class="p_chunk">@@ -3229,10 +3313,10 @@</span> <span class="p_context"> static int convert_ctx_accesses(struct bpf_verifier_env *env)</span>
 			verbose(&quot;bpf verifier is misconfigured\n&quot;);
 			return -EINVAL;
 		} else if (cnt) {
<span class="p_del">-			new_prog = bpf_patch_insn_single(env-&gt;prog, 0,</span>
<span class="p_del">-							 insn_buf, cnt);</span>
<span class="p_add">+			new_prog = bpf_patch_insn_data(env, 0, insn_buf, cnt);</span>
 			if (!new_prog)
 				return -ENOMEM;
<span class="p_add">+</span>
 			env-&gt;prog = new_prog;
 			delta += cnt - 1;
 		}
<span class="p_chunk">@@ -3253,7 +3337,7 @@</span> <span class="p_context"> static int convert_ctx_accesses(struct bpf_verifier_env *env)</span>
 		else
 			continue;
 
<span class="p_del">-		if (env-&gt;insn_aux_data[i].ptr_type != PTR_TO_CTX)</span>
<span class="p_add">+		if (env-&gt;insn_aux_data[i + delta].ptr_type != PTR_TO_CTX)</span>
 			continue;
 
 		cnt = ops-&gt;convert_ctx_access(type, insn-&gt;dst_reg, insn-&gt;src_reg,
<span class="p_chunk">@@ -3263,8 +3347,7 @@</span> <span class="p_context"> static int convert_ctx_accesses(struct bpf_verifier_env *env)</span>
 			return -EINVAL;
 		}
 
<span class="p_del">-		new_prog = bpf_patch_insn_single(env-&gt;prog, i + delta, insn_buf,</span>
<span class="p_del">-						 cnt);</span>
<span class="p_add">+		new_prog = bpf_patch_insn_data(env, i + delta, insn_buf, cnt);</span>
 		if (!new_prog)
 			return -ENOMEM;
 
<span class="p_chunk">@@ -3372,6 +3455,9 @@</span> <span class="p_context"> int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)</span>
 	while (pop_stack(env, NULL) &gt;= 0);
 	free_states(env);
 
<span class="p_add">+	if (ret == 0)</span>
<span class="p_add">+		sanitize_dead_code(env);</span>
<span class="p_add">+</span>
 	if (ret == 0)
 		/* program is valid, convert *(u32*)(ctx + off) accesses */
 		ret = convert_ctx_accesses(env);
<span class="p_header">diff --git a/kernel/trace/trace_events_hist.c b/kernel/trace/trace_events_hist.c</span>
<span class="p_header">index f3a960ed75a1..0664044ade06 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_hist.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_hist.c</span>
<span class="p_chunk">@@ -449,7 +449,7 @@</span> <span class="p_context"> static int create_val_field(struct hist_trigger_data *hist_data,</span>
 	}
 
 	field = trace_find_event_field(file-&gt;event_call, field_name);
<span class="p_del">-	if (!field) {</span>
<span class="p_add">+	if (!field || !field-&gt;size) {</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> static int create_key_field(struct hist_trigger_data *hist_data,</span>
 		}
 
 		field = trace_find_event_field(file-&gt;event_call, field_name);
<span class="p_del">-		if (!field) {</span>
<span class="p_add">+		if (!field || !field-&gt;size) {</span>
 			ret = -EINVAL;
 			goto out;
 		}
<span class="p_header">diff --git a/net/core/sysctl_net_core.c b/net/core/sysctl_net_core.c</span>
<span class="p_header">index 0df2aa652530..a7f05f0130e8 100644</span>
<span class="p_header">--- a/net/core/sysctl_net_core.c</span>
<span class="p_header">+++ b/net/core/sysctl_net_core.c</span>
<span class="p_chunk">@@ -369,14 +369,16 @@</span> <span class="p_context"> static struct ctl_table net_core_table[] = {</span>
 		.data		= &amp;sysctl_net_busy_poll,
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;zero,</span>
 	},
 	{
 		.procname	= &quot;busy_read&quot;,
 		.data		= &amp;sysctl_net_busy_read,
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;zero,</span>
 	},
 #endif
 #ifdef CONFIG_NET_SCHED
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index 453db950dc9f..4bf3b8af0257 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -198,6 +198,7 @@</span> <span class="p_context"> static void ip_expire(unsigned long arg)</span>
 	qp = container_of((struct inet_frag_queue *) arg, struct ipq, q);
 	net = container_of(qp-&gt;q.net, struct net, ipv4.frags);
 
<span class="p_add">+	rcu_read_lock();</span>
 	spin_lock(&amp;qp-&gt;q.lock);
 
 	if (qp-&gt;q.flags &amp; INET_FRAG_COMPLETE)
<span class="p_chunk">@@ -207,7 +208,7 @@</span> <span class="p_context"> static void ip_expire(unsigned long arg)</span>
 	__IP_INC_STATS(net, IPSTATS_MIB_REASMFAILS);
 
 	if (!inet_frag_evicting(&amp;qp-&gt;q)) {
<span class="p_del">-		struct sk_buff *head = qp-&gt;q.fragments;</span>
<span class="p_add">+		struct sk_buff *clone, *head = qp-&gt;q.fragments;</span>
 		const struct iphdr *iph;
 		int err;
 
<span class="p_chunk">@@ -216,32 +217,40 @@</span> <span class="p_context"> static void ip_expire(unsigned long arg)</span>
 		if (!(qp-&gt;q.flags &amp; INET_FRAG_FIRST_IN) || !qp-&gt;q.fragments)
 			goto out;
 
<span class="p_del">-		rcu_read_lock();</span>
 		head-&gt;dev = dev_get_by_index_rcu(net, qp-&gt;iif);
 		if (!head-&gt;dev)
<span class="p_del">-			goto out_rcu_unlock;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 
 		/* skb has no dst, perform route lookup again */
 		iph = ip_hdr(head);
 		err = ip_route_input_noref(head, iph-&gt;daddr, iph-&gt;saddr,
 					   iph-&gt;tos, head-&gt;dev);
 		if (err)
<span class="p_del">-			goto out_rcu_unlock;</span>
<span class="p_add">+			goto out;</span>
 
 		/* Only an end host needs to send an ICMP
 		 * &quot;Fragment Reassembly Timeout&quot; message, per RFC792.
 		 */
 		if (frag_expire_skip_icmp(qp-&gt;user) &amp;&amp;
 		    (skb_rtable(head)-&gt;rt_type != RTN_LOCAL))
<span class="p_del">-			goto out_rcu_unlock;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+		clone = skb_clone(head, GFP_ATOMIC);</span>
 
 		/* Send an ICMP &quot;Fragment Reassembly Timeout&quot; message. */
<span class="p_del">-		icmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);</span>
<span class="p_del">-out_rcu_unlock:</span>
<span class="p_del">-		rcu_read_unlock();</span>
<span class="p_add">+		if (clone) {</span>
<span class="p_add">+			spin_unlock(&amp;qp-&gt;q.lock);</span>
<span class="p_add">+			icmp_send(clone, ICMP_TIME_EXCEEDED,</span>
<span class="p_add">+				  ICMP_EXC_FRAGTIME, 0);</span>
<span class="p_add">+			consume_skb(clone);</span>
<span class="p_add">+			goto out_rcu_unlock;</span>
<span class="p_add">+		}</span>
 	}
 out:
 	spin_unlock(&amp;qp-&gt;q.lock);
<span class="p_add">+out_rcu_unlock:</span>
<span class="p_add">+	rcu_read_unlock();</span>
 	ipq_put(qp);
 }
 
<span class="p_header">diff --git a/net/ipv4/ipconfig.c b/net/ipv4/ipconfig.c</span>
<span class="p_header">index 071a785c65eb..b23464d9c538 100644</span>
<span class="p_header">--- a/net/ipv4/ipconfig.c</span>
<span class="p_header">+++ b/net/ipv4/ipconfig.c</span>
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static void __init ic_close_devs(void)</span>
 	while ((d = next)) {
 		next = d-&gt;next;
 		dev = d-&gt;dev;
<span class="p_del">-		if ((!ic_dev || dev != ic_dev-&gt;dev) &amp;&amp; !netdev_uses_dsa(dev)) {</span>
<span class="p_add">+		if (d != ic_dev &amp;&amp; !netdev_uses_dsa(dev)) {</span>
 			pr_debug(&quot;IP-Config: Downing %s\n&quot;, dev-&gt;name);
 			dev_change_flags(dev, d-&gt;flags);
 		}
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">index 5a8f7c360887..53e49f5011d3 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_chunk">@@ -1260,16 +1260,6 @@</span> <span class="p_context"> static const struct nf_conntrack_expect_policy snmp_exp_policy = {</span>
 	.timeout	= 180,
 };
 
<span class="p_del">-static struct nf_conntrack_helper snmp_helper __read_mostly = {</span>
<span class="p_del">-	.me			= THIS_MODULE,</span>
<span class="p_del">-	.help			= help,</span>
<span class="p_del">-	.expect_policy		= &amp;snmp_exp_policy,</span>
<span class="p_del">-	.name			= &quot;snmp&quot;,</span>
<span class="p_del">-	.tuple.src.l3num	= AF_INET,</span>
<span class="p_del">-	.tuple.src.u.udp.port	= cpu_to_be16(SNMP_PORT),</span>
<span class="p_del">-	.tuple.dst.protonum	= IPPROTO_UDP,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static struct nf_conntrack_helper snmp_trap_helper __read_mostly = {
 	.me			= THIS_MODULE,
 	.help			= help,
<span class="p_chunk">@@ -1288,17 +1278,10 @@</span> <span class="p_context"> static struct nf_conntrack_helper snmp_trap_helper __read_mostly = {</span>
 
 static int __init nf_nat_snmp_basic_init(void)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
 	BUG_ON(nf_nat_snmp_hook != NULL);
 	RCU_INIT_POINTER(nf_nat_snmp_hook, help);
 
<span class="p_del">-	ret = nf_conntrack_helper_register(&amp;snmp_trap_helper);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		nf_conntrack_helper_unregister(&amp;snmp_helper);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return nf_conntrack_helper_register(&amp;snmp_trap_helper);</span>
 }
 
 static void __exit nf_nat_snmp_basic_fini(void)
<span class="p_header">diff --git a/net/ipv4/tcp_vegas.c b/net/ipv4/tcp_vegas.c</span>
<span class="p_header">index 4c4bac1b5eab..3ecb61ee42fb 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_vegas.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_vegas.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(tcp_vegas_cwnd_event);</span>
 
 static inline u32 tcp_vegas_ssthresh(struct tcp_sock *tp)
 {
<span class="p_del">-	return  min(tp-&gt;snd_ssthresh, tp-&gt;snd_cwnd-1);</span>
<span class="p_add">+	return  min(tp-&gt;snd_ssthresh, tp-&gt;snd_cwnd);</span>
 }
 
 static void tcp_vegas_cong_avoid(struct sock *sk, u32 ack, u32 acked)
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index a4fb90c4819f..1594d9fc9c92 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -286,10 +286,10 @@</span> <span class="p_context"> static struct ipv6_devconf ipv6_devconf_dflt __read_mostly = {</span>
 	.keep_addr_on_down	= 0,
 };
 
<span class="p_del">-/* Check if a valid qdisc is available */</span>
<span class="p_del">-static inline bool addrconf_qdisc_ok(const struct net_device *dev)</span>
<span class="p_add">+/* Check if link is ready: is it up and is a valid qdisc available */</span>
<span class="p_add">+static inline bool addrconf_link_ready(const struct net_device *dev)</span>
 {
<span class="p_del">-	return !qdisc_tx_is_noop(dev);</span>
<span class="p_add">+	return netif_oper_up(dev) &amp;&amp; !qdisc_tx_is_noop(dev);</span>
 }
 
 static void addrconf_del_rs_timer(struct inet6_dev *idev)
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> static struct inet6_dev *ipv6_add_dev(struct net_device *dev)</span>
 
 	ndev-&gt;token = in6addr_any;
 
<span class="p_del">-	if (netif_running(dev) &amp;&amp; addrconf_qdisc_ok(dev))</span>
<span class="p_add">+	if (netif_running(dev) &amp;&amp; addrconf_link_ready(dev))</span>
 		ndev-&gt;if_flags |= IF_READY;
 
 	ipv6_mc_init_dev(ndev);
<span class="p_chunk">@@ -3368,7 +3368,7 @@</span> <span class="p_context"> static int addrconf_notify(struct notifier_block *this, unsigned long event,</span>
 			/* restore routes for permanent addresses */
 			addrconf_permanent_addr(dev);
 
<span class="p_del">-			if (!addrconf_qdisc_ok(dev)) {</span>
<span class="p_add">+			if (!addrconf_link_ready(dev)) {</span>
 				/* device is not ready yet. */
 				pr_info(&quot;ADDRCONF(NETDEV_UP): %s: link is not ready\n&quot;,
 					dev-&gt;name);
<span class="p_chunk">@@ -3383,7 +3383,7 @@</span> <span class="p_context"> static int addrconf_notify(struct notifier_block *this, unsigned long event,</span>
 				run_pending = 1;
 			}
 		} else if (event == NETDEV_CHANGE) {
<span class="p_del">-			if (!addrconf_qdisc_ok(dev)) {</span>
<span class="p_add">+			if (!addrconf_link_ready(dev)) {</span>
 				/* device is still not ready. */
 				break;
 			}
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index b1fcfa08f0b4..28d065394c09 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -32,6 +32,13 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL&quot;);</span>
 MODULE_AUTHOR(&quot;Pablo Neira Ayuso &lt;pablo@netfilter.org&gt;&quot;);
 MODULE_DESCRIPTION(&quot;nfnl_cthelper: User-space connection tracking helpers&quot;);
 
<span class="p_add">+struct nfnl_cthelper {</span>
<span class="p_add">+	struct list_head		list;</span>
<span class="p_add">+	struct nf_conntrack_helper	helper;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static LIST_HEAD(nfnl_cthelper_list);</span>
<span class="p_add">+</span>
 static int
 nfnl_userspace_cthelper(struct sk_buff *skb, unsigned int protoff,
 			struct nf_conn *ct, enum ip_conntrack_info ctinfo)
<span class="p_chunk">@@ -205,18 +212,20 @@</span> <span class="p_context"> nfnl_cthelper_create(const struct nlattr * const tb[],</span>
 		     struct nf_conntrack_tuple *tuple)
 {
 	struct nf_conntrack_helper *helper;
<span class="p_add">+	struct nfnl_cthelper *nfcth;</span>
 	int ret;
 
 	if (!tb[NFCTH_TUPLE] || !tb[NFCTH_POLICY] || !tb[NFCTH_PRIV_DATA_LEN])
 		return -EINVAL;
 
<span class="p_del">-	helper = kzalloc(sizeof(struct nf_conntrack_helper), GFP_KERNEL);</span>
<span class="p_del">-	if (helper == NULL)</span>
<span class="p_add">+	nfcth = kzalloc(sizeof(*nfcth), GFP_KERNEL);</span>
<span class="p_add">+	if (nfcth == NULL)</span>
 		return -ENOMEM;
<span class="p_add">+	helper = &amp;nfcth-&gt;helper;</span>
 
 	ret = nfnl_cthelper_parse_expect_policy(helper, tb[NFCTH_POLICY]);
 	if (ret &lt; 0)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto err1;</span>
 
 	strncpy(helper-&gt;name, nla_data(tb[NFCTH_NAME]), NF_CT_HELPER_NAME_LEN);
 	helper-&gt;data_len = ntohl(nla_get_be32(tb[NFCTH_PRIV_DATA_LEN]));
<span class="p_chunk">@@ -247,14 +256,100 @@</span> <span class="p_context"> nfnl_cthelper_create(const struct nlattr * const tb[],</span>
 
 	ret = nf_conntrack_helper_register(helper);
 	if (ret &lt; 0)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto err2;</span>
 
<span class="p_add">+	list_add_tail(&amp;nfcth-&gt;list, &amp;nfnl_cthelper_list);</span>
 	return 0;
<span class="p_del">-err:</span>
<span class="p_del">-	kfree(helper);</span>
<span class="p_add">+err2:</span>
<span class="p_add">+	kfree(helper-&gt;expect_policy);</span>
<span class="p_add">+err1:</span>
<span class="p_add">+	kfree(nfcth);</span>
 	return ret;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+nfnl_cthelper_update_policy_one(const struct nf_conntrack_expect_policy *policy,</span>
<span class="p_add">+				struct nf_conntrack_expect_policy *new_policy,</span>
<span class="p_add">+				const struct nlattr *attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nlattr *tb[NFCTH_POLICY_MAX + 1];</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = nla_parse_nested(tb, NFCTH_POLICY_MAX, attr,</span>
<span class="p_add">+			       nfnl_cthelper_expect_pol);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tb[NFCTH_POLICY_NAME] ||</span>
<span class="p_add">+	    !tb[NFCTH_POLICY_EXPECT_MAX] ||</span>
<span class="p_add">+	    !tb[NFCTH_POLICY_EXPECT_TIMEOUT])</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nla_strcmp(tb[NFCTH_POLICY_NAME], policy-&gt;name))</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_policy-&gt;max_expected =</span>
<span class="p_add">+		ntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_MAX]));</span>
<span class="p_add">+	new_policy-&gt;timeout =</span>
<span class="p_add">+		ntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_TIMEOUT]));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int nfnl_cthelper_update_policy_all(struct nlattr *tb[],</span>
<span class="p_add">+					   struct nf_conntrack_helper *helper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nf_conntrack_expect_policy new_policy[helper-&gt;expect_class_max + 1];</span>
<span class="p_add">+	struct nf_conntrack_expect_policy *policy;</span>
<span class="p_add">+	int i, err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check first that all policy attributes are well-formed, so we don&#39;t</span>
<span class="p_add">+	 * leave things in inconsistent state on errors.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 0; i &lt; helper-&gt;expect_class_max + 1; i++) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!tb[NFCTH_POLICY_SET + i])</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = nfnl_cthelper_update_policy_one(&amp;helper-&gt;expect_policy[i],</span>
<span class="p_add">+						      &amp;new_policy[i],</span>
<span class="p_add">+						      tb[NFCTH_POLICY_SET + i]);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Now we can safely update them. */</span>
<span class="p_add">+	for (i = 0; i &lt; helper-&gt;expect_class_max + 1; i++) {</span>
<span class="p_add">+		policy = (struct nf_conntrack_expect_policy *)</span>
<span class="p_add">+				&amp;helper-&gt;expect_policy[i];</span>
<span class="p_add">+		policy-&gt;max_expected = new_policy-&gt;max_expected;</span>
<span class="p_add">+		policy-&gt;timeout	= new_policy-&gt;timeout;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int nfnl_cthelper_update_policy(struct nf_conntrack_helper *helper,</span>
<span class="p_add">+				       const struct nlattr *attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nlattr *tb[NFCTH_POLICY_SET_MAX + 1];</span>
<span class="p_add">+	unsigned int class_max;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = nla_parse_nested(tb, NFCTH_POLICY_SET_MAX, attr,</span>
<span class="p_add">+			       nfnl_cthelper_expect_policy_set);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tb[NFCTH_POLICY_SET_NUM])</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	class_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_add">+	if (helper-&gt;expect_class_max + 1 != class_max)</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nfnl_cthelper_update_policy_all(tb, helper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 nfnl_cthelper_update(const struct nlattr * const tb[],
 		     struct nf_conntrack_helper *helper)
<span class="p_chunk">@@ -265,8 +360,7 @@</span> <span class="p_context"> nfnl_cthelper_update(const struct nlattr * const tb[],</span>
 		return -EBUSY;
 
 	if (tb[NFCTH_POLICY]) {
<span class="p_del">-		ret = nfnl_cthelper_parse_expect_policy(helper,</span>
<span class="p_del">-							tb[NFCTH_POLICY]);</span>
<span class="p_add">+		ret = nfnl_cthelper_update_policy(helper, tb[NFCTH_POLICY]);</span>
 		if (ret &lt; 0)
 			return ret;
 	}
<span class="p_chunk">@@ -295,7 +389,8 @@</span> <span class="p_context"> static int nfnl_cthelper_new(struct net *net, struct sock *nfnl,</span>
 	const char *helper_name;
 	struct nf_conntrack_helper *cur, *helper = NULL;
 	struct nf_conntrack_tuple tuple;
<span class="p_del">-	int ret = 0, i;</span>
<span class="p_add">+	struct nfnl_cthelper *nlcth;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	if (!tb[NFCTH_NAME] || !tb[NFCTH_TUPLE])
 		return -EINVAL;
<span class="p_chunk">@@ -306,31 +401,22 @@</span> <span class="p_context"> static int nfnl_cthelper_new(struct net *net, struct sock *nfnl,</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	for (i = 0; i &lt; nf_ct_helper_hsize &amp;&amp; !helper; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_rcu(cur, &amp;nf_ct_helper_hash[i], hnode) {</span>
<span class="p_add">+	list_for_each_entry(nlcth, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
 
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (strncmp(cur-&gt;name, helper_name, NF_CT_HELPER_NAME_LEN))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if (strncmp(cur-&gt;name, helper_name,</span>
<span class="p_del">-					NF_CT_HELPER_NAME_LEN) != 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if ((tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_add">+		     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if ((tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_del">-			     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL)</span>
<span class="p_add">+			return -EEXIST;</span>
 
<span class="p_del">-			if (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) {</span>
<span class="p_del">-				ret = -EEXIST;</span>
<span class="p_del">-				goto err;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			helper = cur;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		helper = cur;</span>
<span class="p_add">+		break;</span>
 	}
<span class="p_del">-	rcu_read_unlock();</span>
 
 	if (helper == NULL)
 		ret = nfnl_cthelper_create(tb, &amp;tuple);
<span class="p_chunk">@@ -338,9 +424,6 @@</span> <span class="p_context"> static int nfnl_cthelper_new(struct net *net, struct sock *nfnl,</span>
 		ret = nfnl_cthelper_update(tb, helper);
 
 	return ret;
<span class="p_del">-err:</span>
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_del">-	return ret;</span>
 }
 
 static int
<span class="p_chunk">@@ -504,11 +587,12 @@</span> <span class="p_context"> static int nfnl_cthelper_get(struct net *net, struct sock *nfnl,</span>
 			     struct sk_buff *skb, const struct nlmsghdr *nlh,
 			     const struct nlattr * const tb[])
 {
<span class="p_del">-	int ret = -ENOENT, i;</span>
<span class="p_add">+	int ret = -ENOENT;</span>
 	struct nf_conntrack_helper *cur;
 	struct sk_buff *skb2;
 	char *helper_name = NULL;
 	struct nf_conntrack_tuple tuple;
<span class="p_add">+	struct nfnl_cthelper *nlcth;</span>
 	bool tuple_set = false;
 
 	if (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP) {
<span class="p_chunk">@@ -529,45 +613,39 @@</span> <span class="p_context"> static int nfnl_cthelper_get(struct net *net, struct sock *nfnl,</span>
 		tuple_set = true;
 	}
 
<span class="p_del">-	for (i = 0; i &lt; nf_ct_helper_hsize; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_rcu(cur, &amp;nf_ct_helper_hash[i], hnode) {</span>
<span class="p_add">+	list_for_each_entry(nlcth, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
<span class="p_add">+		if (helper_name &amp;&amp;</span>
<span class="p_add">+		    strncmp(cur-&gt;name, helper_name, NF_CT_HELPER_NAME_LEN))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (tuple_set &amp;&amp;</span>
<span class="p_add">+		    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_add">+		     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if (helper_name &amp;&amp; strncmp(cur-&gt;name, helper_name,</span>
<span class="p_del">-						NF_CT_HELPER_NAME_LEN) != 0) {</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (tuple_set &amp;&amp;</span>
<span class="p_del">-			    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_del">-			     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-</span>
<span class="p_del">-			skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);</span>
<span class="p_del">-			if (skb2 == NULL) {</span>
<span class="p_del">-				ret = -ENOMEM;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		if (skb2 == NULL) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-			ret = nfnl_cthelper_fill_info(skb2, NETLINK_CB(skb).portid,</span>
<span class="p_del">-						nlh-&gt;nlmsg_seq,</span>
<span class="p_del">-						NFNL_MSG_TYPE(nlh-&gt;nlmsg_type),</span>
<span class="p_del">-						NFNL_MSG_CTHELPER_NEW, cur);</span>
<span class="p_del">-			if (ret &lt;= 0) {</span>
<span class="p_del">-				kfree_skb(skb2);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		ret = nfnl_cthelper_fill_info(skb2, NETLINK_CB(skb).portid,</span>
<span class="p_add">+					      nlh-&gt;nlmsg_seq,</span>
<span class="p_add">+					      NFNL_MSG_TYPE(nlh-&gt;nlmsg_type),</span>
<span class="p_add">+					      NFNL_MSG_CTHELPER_NEW, cur);</span>
<span class="p_add">+		if (ret &lt;= 0) {</span>
<span class="p_add">+			kfree_skb(skb2);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-			ret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,</span>
<span class="p_del">-						MSG_DONTWAIT);</span>
<span class="p_del">-			if (ret &gt; 0)</span>
<span class="p_del">-				ret = 0;</span>
<span class="p_add">+		ret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,</span>
<span class="p_add">+				      MSG_DONTWAIT);</span>
<span class="p_add">+		if (ret &gt; 0)</span>
<span class="p_add">+			ret = 0;</span>
 
<span class="p_del">-			/* this avoids a loop in nfnetlink. */</span>
<span class="p_del">-			return ret == -EAGAIN ? -ENOBUFS : ret;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* this avoids a loop in nfnetlink. */</span>
<span class="p_add">+		return ret == -EAGAIN ? -ENOBUFS : ret;</span>
 	}
 	return ret;
 }
<span class="p_chunk">@@ -578,10 +656,10 @@</span> <span class="p_context"> static int nfnl_cthelper_del(struct net *net, struct sock *nfnl,</span>
 {
 	char *helper_name = NULL;
 	struct nf_conntrack_helper *cur;
<span class="p_del">-	struct hlist_node *tmp;</span>
 	struct nf_conntrack_tuple tuple;
 	bool tuple_set = false, found = false;
<span class="p_del">-	int i, j = 0, ret;</span>
<span class="p_add">+	struct nfnl_cthelper *nlcth, *n;</span>
<span class="p_add">+	int j = 0, ret;</span>
 
 	if (tb[NFCTH_NAME])
 		helper_name = nla_data(tb[NFCTH_NAME]);
<span class="p_chunk">@@ -594,28 +672,27 @@</span> <span class="p_context"> static int nfnl_cthelper_del(struct net *net, struct sock *nfnl,</span>
 		tuple_set = true;
 	}
 
<span class="p_del">-	for (i = 0; i &lt; nf_ct_helper_hsize; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_safe(cur, tmp, &amp;nf_ct_helper_hash[i],</span>
<span class="p_del">-								hnode) {</span>
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+	list_for_each_entry_safe(nlcth, n, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
<span class="p_add">+		j++;</span>
 
<span class="p_del">-			j++;</span>
<span class="p_add">+		if (helper_name &amp;&amp;</span>
<span class="p_add">+		    strncmp(cur-&gt;name, helper_name, NF_CT_HELPER_NAME_LEN))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if (helper_name &amp;&amp; strncmp(cur-&gt;name, helper_name,</span>
<span class="p_del">-						NF_CT_HELPER_NAME_LEN) != 0) {</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (tuple_set &amp;&amp;</span>
<span class="p_del">-			    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_del">-			     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (tuple_set &amp;&amp;</span>
<span class="p_add">+		    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_add">+		     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			found = true;</span>
<span class="p_del">-			nf_conntrack_helper_unregister(cur);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		found = true;</span>
<span class="p_add">+		nf_conntrack_helper_unregister(cur);</span>
<span class="p_add">+		kfree(cur-&gt;expect_policy);</span>
<span class="p_add">+</span>
<span class="p_add">+		list_del(&amp;nlcth-&gt;list);</span>
<span class="p_add">+		kfree(nlcth);</span>
 	}
<span class="p_add">+</span>
 	/* Make sure we return success if we flush and there is no helpers */
 	return (found || j == 0) ? 0 : -ENOENT;
 }
<span class="p_chunk">@@ -664,20 +741,16 @@</span> <span class="p_context"> static int __init nfnl_cthelper_init(void)</span>
 static void __exit nfnl_cthelper_exit(void)
 {
 	struct nf_conntrack_helper *cur;
<span class="p_del">-	struct hlist_node *tmp;</span>
<span class="p_del">-	int i;</span>
<span class="p_add">+	struct nfnl_cthelper *nlcth, *n;</span>
 
 	nfnetlink_subsys_unregister(&amp;nfnl_cthelper_subsys);
 
<span class="p_del">-	for (i=0; i&lt;nf_ct_helper_hsize; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_safe(cur, tmp, &amp;nf_ct_helper_hash[i],</span>
<span class="p_del">-									hnode) {</span>
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+	list_for_each_entry_safe(nlcth, n, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
 
<span class="p_del">-			nf_conntrack_helper_unregister(cur);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		nf_conntrack_helper_unregister(cur);</span>
<span class="p_add">+		kfree(cur-&gt;expect_policy);</span>
<span class="p_add">+		kfree(nlcth);</span>
 	}
 }
 
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c</span>
<span class="p_header">index af832c526048..5efb40291ac3 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue.c</span>
<span class="p_chunk">@@ -443,7 +443,7 @@</span> <span class="p_context"> nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,</span>
 	skb = alloc_skb(size, GFP_ATOMIC);
 	if (!skb) {
 		skb_tx_error(entskb);
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		goto nlmsg_failure;</span>
 	}
 
 	nlh = nlmsg_put(skb, 0, 0,
<span class="p_chunk">@@ -452,7 +452,7 @@</span> <span class="p_context"> nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,</span>
 	if (!nlh) {
 		skb_tx_error(entskb);
 		kfree_skb(skb);
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		goto nlmsg_failure;</span>
 	}
 	nfmsg = nlmsg_data(nlh);
 	nfmsg-&gt;nfgen_family = entry-&gt;state.pf;
<span class="p_chunk">@@ -598,12 +598,17 @@</span> <span class="p_context"> nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,</span>
 	}
 
 	nlh-&gt;nlmsg_len = skb-&gt;len;
<span class="p_add">+	if (seclen)</span>
<span class="p_add">+		security_release_secctx(secdata, seclen);</span>
 	return skb;
 
 nla_put_failure:
 	skb_tx_error(entskb);
 	kfree_skb(skb);
 	net_err_ratelimited(&quot;nf_queue: error creating packet message\n&quot;);
<span class="p_add">+nlmsg_failure:</span>
<span class="p_add">+	if (seclen)</span>
<span class="p_add">+		security_release_secctx(secdata, seclen);</span>
 	return NULL;
 }
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index c9fac08a53b1..1ff497bd9c20 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -96,6 +96,44 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nl_table);</span>
 
 static DECLARE_WAIT_QUEUE_HEAD(nl_table_wait);
 
<span class="p_add">+static struct lock_class_key nlk_cb_mutex_keys[MAX_LINKS];</span>
<span class="p_add">+</span>
<span class="p_add">+static const char *const nlk_cb_mutex_key_strings[MAX_LINKS + 1] = {</span>
<span class="p_add">+	&quot;nlk_cb_mutex-ROUTE&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-1&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-USERSOCK&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-FIREWALL&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SOCK_DIAG&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-NFLOG&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-XFRM&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SELINUX&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-ISCSI&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-AUDIT&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-FIB_LOOKUP&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-CONNECTOR&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-NETFILTER&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-IP6_FW&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-DNRTMSG&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-KOBJECT_UEVENT&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-GENERIC&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-17&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SCSITRANSPORT&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-ECRYPTFS&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-RDMA&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-CRYPTO&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SMC&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-23&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-24&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-25&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-26&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-27&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-28&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-29&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-30&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-31&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-MAX_LINKS&quot;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int netlink_dump(struct sock *sk);
 static void netlink_skb_destructor(struct sk_buff *skb);
 
<span class="p_chunk">@@ -585,6 +623,9 @@</span> <span class="p_context"> static int __netlink_create(struct net *net, struct socket *sock,</span>
 	} else {
 		nlk-&gt;cb_mutex = &amp;nlk-&gt;cb_def_mutex;
 		mutex_init(nlk-&gt;cb_mutex);
<span class="p_add">+		lockdep_set_class_and_name(nlk-&gt;cb_mutex,</span>
<span class="p_add">+					   nlk_cb_mutex_keys + protocol,</span>
<span class="p_add">+					   nlk_cb_mutex_key_strings[protocol]);</span>
 	}
 	init_waitqueue_head(&amp;nlk-&gt;wait);
 
<span class="p_header">diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c</span>
<span class="p_header">index 1308bbf460f7..b56d57984439 100644</span>
<span class="p_header">--- a/net/sched/sch_dsmark.c</span>
<span class="p_header">+++ b/net/sched/sch_dsmark.c</span>
<span class="p_chunk">@@ -200,9 +200,13 @@</span> <span class="p_context"> static int dsmark_enqueue(struct sk_buff *skb, struct Qdisc *sch,</span>
 	pr_debug(&quot;%s(skb %p,sch %p,[qdisc %p])\n&quot;, __func__, skb, sch, p);
 
 	if (p-&gt;set_tc_index) {
<span class="p_add">+		int wlen = skb_network_offset(skb);</span>
<span class="p_add">+</span>
 		switch (tc_skb_protocol(skb)) {
 		case htons(ETH_P_IP):
<span class="p_del">-			if (skb_cow_head(skb, sizeof(struct iphdr)))</span>
<span class="p_add">+			wlen += sizeof(struct iphdr);</span>
<span class="p_add">+			if (!pskb_may_pull(skb, wlen) ||</span>
<span class="p_add">+			    skb_try_make_writable(skb, wlen))</span>
 				goto drop;
 
 			skb-&gt;tc_index = ipv4_get_dsfield(ip_hdr(skb))
<span class="p_chunk">@@ -210,7 +214,9 @@</span> <span class="p_context"> static int dsmark_enqueue(struct sk_buff *skb, struct Qdisc *sch,</span>
 			break;
 
 		case htons(ETH_P_IPV6):
<span class="p_del">-			if (skb_cow_head(skb, sizeof(struct ipv6hdr)))</span>
<span class="p_add">+			wlen += sizeof(struct ipv6hdr);</span>
<span class="p_add">+			if (!pskb_may_pull(skb, wlen) ||</span>
<span class="p_add">+			    skb_try_make_writable(skb, wlen))</span>
 				goto drop;
 
 			skb-&gt;tc_index = ipv6_get_dsfield(ipv6_hdr(skb))
<span class="p_header">diff --git a/net/sctp/outqueue.c b/net/sctp/outqueue.c</span>
<span class="p_header">index 582585393d35..0994ce491e7c 100644</span>
<span class="p_header">--- a/net/sctp/outqueue.c</span>
<span class="p_header">+++ b/net/sctp/outqueue.c</span>
<span class="p_chunk">@@ -382,17 +382,18 @@</span> <span class="p_context"> static int sctp_prsctp_prune_sent(struct sctp_association *asoc,</span>
 }
 
 static int sctp_prsctp_prune_unsent(struct sctp_association *asoc,
<span class="p_del">-				    struct sctp_sndrcvinfo *sinfo,</span>
<span class="p_del">-				    struct list_head *queue, int msg_len)</span>
<span class="p_add">+				    struct sctp_sndrcvinfo *sinfo, int msg_len)</span>
 {
<span class="p_add">+	struct sctp_outq *q = &amp;asoc-&gt;outqueue;</span>
 	struct sctp_chunk *chk, *temp;
 
<span class="p_del">-	list_for_each_entry_safe(chk, temp, queue, list) {</span>
<span class="p_add">+	list_for_each_entry_safe(chk, temp, &amp;q-&gt;out_chunk_list, list) {</span>
 		if (!SCTP_PR_PRIO_ENABLED(chk-&gt;sinfo.sinfo_flags) ||
 		    chk-&gt;sinfo.sinfo_timetolive &lt;= sinfo-&gt;sinfo_timetolive)
 			continue;
 
 		list_del_init(&amp;chk-&gt;list);
<span class="p_add">+		q-&gt;out_qlen -= chk-&gt;skb-&gt;len;</span>
 		asoc-&gt;sent_cnt_removable--;
 		asoc-&gt;abandoned_unsent[SCTP_PR_INDEX(PRIO)]++;
 
<span class="p_chunk">@@ -431,9 +432,7 @@</span> <span class="p_context"> void sctp_prsctp_prune(struct sctp_association *asoc,</span>
 			return;
 	}
 
<span class="p_del">-	sctp_prsctp_prune_unsent(asoc, sinfo,</span>
<span class="p_del">-				 &amp;asoc-&gt;outqueue.out_chunk_list,</span>
<span class="p_del">-				 msg_len);</span>
<span class="p_add">+	sctp_prsctp_prune_unsent(asoc, sinfo, msg_len);</span>
 }
 
 /* Mark all the eligible packets on a transport for retransmission.  */
<span class="p_header">diff --git a/net/tipc/subscr.c b/net/tipc/subscr.c</span>
<span class="p_header">index 9d94e65d0894..271cd66e4b3b 100644</span>
<span class="p_header">--- a/net/tipc/subscr.c</span>
<span class="p_header">+++ b/net/tipc/subscr.c</span>
<span class="p_chunk">@@ -141,6 +141,11 @@</span> <span class="p_context"> void tipc_subscrp_report_overlap(struct tipc_subscription *sub, u32 found_lower,</span>
 static void tipc_subscrp_timeout(unsigned long data)
 {
 	struct tipc_subscription *sub = (struct tipc_subscription *)data;
<span class="p_add">+	struct tipc_subscriber *subscriber = sub-&gt;subscriber;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;subscriber-&gt;lock);</span>
<span class="p_add">+	tipc_nametbl_unsubscribe(sub);</span>
<span class="p_add">+	spin_unlock_bh(&amp;subscriber-&gt;lock);</span>
 
 	/* Notify subscriber of timeout */
 	tipc_subscrp_send_event(sub, sub-&gt;evt.s.seq.lower, sub-&gt;evt.s.seq.upper,
<span class="p_chunk">@@ -173,7 +178,6 @@</span> <span class="p_context"> static void tipc_subscrp_kref_release(struct kref *kref)</span>
 	struct tipc_subscriber *subscriber = sub-&gt;subscriber;
 
 	spin_lock_bh(&amp;subscriber-&gt;lock);
<span class="p_del">-	tipc_nametbl_unsubscribe(sub);</span>
 	list_del(&amp;sub-&gt;subscrp_list);
 	atomic_dec(&amp;tn-&gt;subscription_count);
 	spin_unlock_bh(&amp;subscriber-&gt;lock);
<span class="p_chunk">@@ -205,6 +209,7 @@</span> <span class="p_context"> static void tipc_subscrb_subscrp_delete(struct tipc_subscriber *subscriber,</span>
 		if (s &amp;&amp; memcmp(s, &amp;sub-&gt;evt.s, sizeof(struct tipc_subscr)))
 			continue;
 
<span class="p_add">+		tipc_nametbl_unsubscribe(sub);</span>
 		tipc_subscrp_get(sub);
 		spin_unlock_bh(&amp;subscriber-&gt;lock);
 		tipc_subscrp_delete(sub);
<span class="p_header">diff --git a/net/vmw_vsock/af_vsock.c b/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">index 2f633eec6b7a..ee12e176256c 100644</span>
<span class="p_header">--- a/net/vmw_vsock/af_vsock.c</span>
<span class="p_header">+++ b/net/vmw_vsock/af_vsock.c</span>
<span class="p_chunk">@@ -1101,10 +1101,19 @@</span> <span class="p_context"> static const struct proto_ops vsock_dgram_ops = {</span>
 	.sendpage = sock_no_sendpage,
 };
 
<span class="p_add">+static int vsock_transport_cancel_pkt(struct vsock_sock *vsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!transport-&gt;cancel_pkt)</span>
<span class="p_add">+		return -EOPNOTSUPP;</span>
<span class="p_add">+</span>
<span class="p_add">+	return transport-&gt;cancel_pkt(vsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void vsock_connect_timeout(struct work_struct *work)
 {
 	struct sock *sk;
 	struct vsock_sock *vsk;
<span class="p_add">+	int cancel = 0;</span>
 
 	vsk = container_of(work, struct vsock_sock, dwork.work);
 	sk = sk_vsock(vsk);
<span class="p_chunk">@@ -1115,8 +1124,11 @@</span> <span class="p_context"> static void vsock_connect_timeout(struct work_struct *work)</span>
 		sk-&gt;sk_state = SS_UNCONNECTED;
 		sk-&gt;sk_err = ETIMEDOUT;
 		sk-&gt;sk_error_report(sk);
<span class="p_add">+		cancel = 1;</span>
 	}
 	release_sock(sk);
<span class="p_add">+	if (cancel)</span>
<span class="p_add">+		vsock_transport_cancel_pkt(vsk);</span>
 
 	sock_put(sk);
 }
<span class="p_chunk">@@ -1223,11 +1235,13 @@</span> <span class="p_context"> static int vsock_stream_connect(struct socket *sock, struct sockaddr *addr,</span>
 			err = sock_intr_errno(timeout);
 			sk-&gt;sk_state = SS_UNCONNECTED;
 			sock-&gt;state = SS_UNCONNECTED;
<span class="p_add">+			vsock_transport_cancel_pkt(vsk);</span>
 			goto out_wait;
 		} else if (timeout == 0) {
 			err = -ETIMEDOUT;
 			sk-&gt;sk_state = SS_UNCONNECTED;
 			sock-&gt;state = SS_UNCONNECTED;
<span class="p_add">+			vsock_transport_cancel_pkt(vsk);</span>
 			goto out_wait;
 		}
 
<span class="p_header">diff --git a/net/vmw_vsock/virtio_transport_common.c b/net/vmw_vsock/virtio_transport_common.c</span>
<span class="p_header">index 62c056ea403b..9c07c76c504d 100644</span>
<span class="p_header">--- a/net/vmw_vsock/virtio_transport_common.c</span>
<span class="p_header">+++ b/net/vmw_vsock/virtio_transport_common.c</span>
<span class="p_chunk">@@ -57,6 +57,7 @@</span> <span class="p_context"> virtio_transport_alloc_pkt(struct virtio_vsock_pkt_info *info,</span>
 	pkt-&gt;len		= len;
 	pkt-&gt;hdr.len		= cpu_to_le32(len);
 	pkt-&gt;reply		= info-&gt;reply;
<span class="p_add">+	pkt-&gt;vsk		= info-&gt;vsk;</span>
 
 	if (info-&gt;msg &amp;&amp; len &gt; 0) {
 		pkt-&gt;buf = kmalloc(len, GFP_KERNEL);
<span class="p_chunk">@@ -180,6 +181,7 @@</span> <span class="p_context"> static int virtio_transport_send_credit_update(struct vsock_sock *vsk,</span>
 	struct virtio_vsock_pkt_info info = {
 		.op = VIRTIO_VSOCK_OP_CREDIT_UPDATE,
 		.type = type,
<span class="p_add">+		.vsk = vsk,</span>
 	};
 
 	return virtio_transport_send_pkt_info(vsk, &amp;info);
<span class="p_chunk">@@ -519,6 +521,7 @@</span> <span class="p_context"> int virtio_transport_connect(struct vsock_sock *vsk)</span>
 	struct virtio_vsock_pkt_info info = {
 		.op = VIRTIO_VSOCK_OP_REQUEST,
 		.type = VIRTIO_VSOCK_TYPE_STREAM,
<span class="p_add">+		.vsk = vsk,</span>
 	};
 
 	return virtio_transport_send_pkt_info(vsk, &amp;info);
<span class="p_chunk">@@ -534,6 +537,7 @@</span> <span class="p_context"> int virtio_transport_shutdown(struct vsock_sock *vsk, int mode)</span>
 			  VIRTIO_VSOCK_SHUTDOWN_RCV : 0) |
 			 (mode &amp; SEND_SHUTDOWN ?
 			  VIRTIO_VSOCK_SHUTDOWN_SEND : 0),
<span class="p_add">+		.vsk = vsk,</span>
 	};
 
 	return virtio_transport_send_pkt_info(vsk, &amp;info);
<span class="p_chunk">@@ -560,6 +564,7 @@</span> <span class="p_context"> virtio_transport_stream_enqueue(struct vsock_sock *vsk,</span>
 		.type = VIRTIO_VSOCK_TYPE_STREAM,
 		.msg = msg,
 		.pkt_len = len,
<span class="p_add">+		.vsk = vsk,</span>
 	};
 
 	return virtio_transport_send_pkt_info(vsk, &amp;info);
<span class="p_chunk">@@ -581,6 +586,7 @@</span> <span class="p_context"> static int virtio_transport_reset(struct vsock_sock *vsk,</span>
 		.op = VIRTIO_VSOCK_OP_RST,
 		.type = VIRTIO_VSOCK_TYPE_STREAM,
 		.reply = !!pkt,
<span class="p_add">+		.vsk = vsk,</span>
 	};
 
 	/* Send RST only if the original pkt is not a RST pkt */
<span class="p_chunk">@@ -826,6 +832,7 @@</span> <span class="p_context"> virtio_transport_send_response(struct vsock_sock *vsk,</span>
 		.remote_cid = le64_to_cpu(pkt-&gt;hdr.src_cid),
 		.remote_port = le32_to_cpu(pkt-&gt;hdr.src_port),
 		.reply = true,
<span class="p_add">+		.vsk = vsk,</span>
 	};
 
 	return virtio_transport_send_pkt_info(vsk, &amp;info);
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index f2e4e99ce651..2c3065c1f3fb 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> enum {</span>
 	CXT_FIXUP_HP_530,
 	CXT_FIXUP_CAP_MIX_AMP_5047,
 	CXT_FIXUP_MUTE_LED_EAPD,
<span class="p_add">+	CXT_FIXUP_HP_DOCK,</span>
 	CXT_FIXUP_HP_SPECTRE,
 	CXT_FIXUP_HP_GATE_MIC,
 };
<span class="p_chunk">@@ -778,6 +779,14 @@</span> <span class="p_context"> static const struct hda_fixup cxt_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cxt_fixup_mute_led_eapd,
 	},
<span class="p_add">+	[CXT_FIXUP_HP_DOCK] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x16, 0x21011020 }, /* line-out */</span>
<span class="p_add">+			{ 0x18, 0x2181103f }, /* line-in */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
 	[CXT_FIXUP_HP_SPECTRE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -839,6 +848,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x0543, &quot;Acer Aspire One 522&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054c, &quot;Acer Aspire 3830TG&quot;, CXT_FIXUP_ASPIRE_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054f, &quot;Acer Aspire 4830T&quot;, CXT_FIXUP_ASPIRE_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x8079, &quot;HP EliteBook 840 G3&quot;, CXT_FIXUP_HP_DOCK),</span>
 	SND_PCI_QUIRK(0x103c, 0x8174, &quot;HP Spectre x360&quot;, CXT_FIXUP_HP_SPECTRE),
 	SND_PCI_QUIRK(0x103c, 0x8115, &quot;HP Z1 Gen3&quot;, CXT_FIXUP_HP_GATE_MIC),
 	SND_PCI_QUIRK(0x1043, 0x138d, &quot;Asus&quot;, CXT_FIXUP_HEADPHONE_MIC_PIN),
<span class="p_chunk">@@ -872,6 +882,7 @@</span> <span class="p_context"> static const struct hda_model_fixup cxt5066_fixup_models[] = {</span>
 	{ .id = CXT_PINCFG_LEMOTE_A1205, .name = &quot;lemote-a1205&quot; },
 	{ .id = CXT_FIXUP_OLPC_XO, .name = &quot;olpc-xo&quot; },
 	{ .id = CXT_FIXUP_MUTE_LED_EAPD, .name = &quot;mute-led-eapd&quot; },
<span class="p_add">+	{ .id = CXT_FIXUP_HP_DOCK, .name = &quot;hp-dock&quot; },</span>
 	{}
 };
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index d7fa7373cb94..ba40596b9d92 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4854,6 +4854,7 @@</span> <span class="p_context"> enum {</span>
 	ALC286_FIXUP_HP_GPIO_LED,
 	ALC280_FIXUP_HP_GPIO2_MIC_HOTKEY,
 	ALC280_FIXUP_HP_DOCK_PINS,
<span class="p_add">+	ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED,</span>
 	ALC280_FIXUP_HP_9480M,
 	ALC288_FIXUP_DELL_HEADSET_MODE,
 	ALC288_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_chunk">@@ -5394,6 +5395,16 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC280_FIXUP_HP_GPIO4
 	},
<span class="p_add">+	[ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x1b, 0x21011020 }, /* line-out */</span>
<span class="p_add">+			{ 0x18, 0x2181103f }, /* line-in */</span>
<span class="p_add">+			{ },</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HP_GPIO_MIC1_LED</span>
<span class="p_add">+	},</span>
 	[ALC280_FIXUP_HP_9480M] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc280_fixup_hp_9480m,
<span class="p_chunk">@@ -5646,7 +5657,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x103c, 0x2256, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),
 	SND_PCI_QUIRK(0x103c, 0x2257, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),
 	SND_PCI_QUIRK(0x103c, 0x2259, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),
<span class="p_del">-	SND_PCI_QUIRK(0x103c, 0x225a, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x225a, &quot;HP&quot;, ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED),</span>
 	SND_PCI_QUIRK(0x103c, 0x2260, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC1),
 	SND_PCI_QUIRK(0x103c, 0x2263, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC1),
 	SND_PCI_QUIRK(0x103c, 0x2264, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC1),
<span class="p_chunk">@@ -5812,6 +5823,7 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{.id = ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC, .name = &quot;headset-mode-no-hp-mic&quot;},
 	{.id = ALC269_FIXUP_LENOVO_DOCK, .name = &quot;lenovo-dock&quot;},
 	{.id = ALC269_FIXUP_HP_GPIO_LED, .name = &quot;hp-gpio-led&quot;},
<span class="p_add">+	{.id = ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED, .name = &quot;hp-dock-gpio-mic1-led&quot;},</span>
 	{.id = ALC269_FIXUP_DELL1_MIC_NO_PRESENCE, .name = &quot;dell-headset-multi&quot;},
 	{.id = ALC269_FIXUP_DELL2_MIC_NO_PRESENCE, .name = &quot;dell-headset-dock&quot;},
 	{.id = ALC283_FIXUP_CHROME_BOOK, .name = &quot;alc283-dac-wcaps&quot;},
<span class="p_header">diff --git a/sound/soc/img/img-parallel-out.c b/sound/soc/img/img-parallel-out.c</span>
<span class="p_header">index c1610a054d65..3cf522d66755 100644</span>
<span class="p_header">--- a/sound/soc/img/img-parallel-out.c</span>
<span class="p_header">+++ b/sound/soc/img/img-parallel-out.c</span>
<span class="p_chunk">@@ -166,9 +166,11 @@</span> <span class="p_context"> static int img_prl_out_set_fmt(struct snd_soc_dai *dai, unsigned int fmt)</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	pm_runtime_get_sync(prl-&gt;dev);</span>
 	reg = img_prl_out_readl(prl, IMG_PRL_OUT_CTL);
 	reg = (reg &amp; ~IMG_PRL_OUT_CTL_EDGE_MASK) | control_set;
 	img_prl_out_writel(prl, reg, IMG_PRL_OUT_CTL);
<span class="p_add">+	pm_runtime_put(prl-&gt;dev);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/soc/sti/uniperif_reader.c b/sound/soc/sti/uniperif_reader.c</span>
<span class="p_header">index 0e1c3ee56675..9735b4caaed3 100644</span>
<span class="p_header">--- a/sound/soc/sti/uniperif_reader.c</span>
<span class="p_header">+++ b/sound/soc/sti/uniperif_reader.c</span>
<span class="p_chunk">@@ -364,6 +364,8 @@</span> <span class="p_context"> static int uni_reader_startup(struct snd_pcm_substream *substream,</span>
 	struct uniperif *reader = priv-&gt;dai_data.uni;
 	int ret;
 
<span class="p_add">+	reader-&gt;substream = substream;</span>
<span class="p_add">+</span>
 	if (!UNIPERIF_TYPE_IS_TDM(reader))
 		return 0;
 
<span class="p_chunk">@@ -393,6 +395,7 @@</span> <span class="p_context"> static void uni_reader_shutdown(struct snd_pcm_substream *substream,</span>
 		/* Stop the reader */
 		uni_reader_stop(reader);
 	}
<span class="p_add">+	reader-&gt;substream = NULL;</span>
 }
 
 static const struct snd_soc_dai_ops uni_reader_dai_ops = {
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 4569fdcab701..1b20768e781d 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -1060,7 +1060,7 @@</span> <span class="p_context"> int __kvm_set_memory_region(struct kvm *kvm,</span>
 	 * changes) is disallowed above, so any other attribute changes getting
 	 * here can be skipped.
 	 */
<span class="p_del">-	if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {</span>
<span class="p_add">+	if (as_id == 0 &amp;&amp; (change == KVM_MR_CREATE || change == KVM_MR_MOVE)) {</span>
 		r = kvm_iommu_map_pages(kvm, &amp;new);
 		return r;
 	}
<span class="p_chunk">@@ -3904,7 +3904,7 @@</span> <span class="p_context"> int kvm_init(void *opaque, unsigned vcpu_size, unsigned vcpu_align,</span>
 	if (!vcpu_align)
 		vcpu_align = __alignof__(struct kvm_vcpu);
 	kvm_vcpu_cache = kmem_cache_create(&quot;kvm_vcpu&quot;, vcpu_size, vcpu_align,
<span class="p_del">-					   0, NULL);</span>
<span class="p_add">+					   SLAB_ACCOUNT, NULL);</span>
 	if (!kvm_vcpu_cache) {
 		r = -ENOMEM;
 		goto out_free_3;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



