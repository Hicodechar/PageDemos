
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.2,000/107] 3.2.72-rc1 review - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.2,000/107] 3.2.72-rc1 review</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 9, 2015, 1:17 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1444353438.2956.280.camel@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7358581/mbox/"
   >mbox</a>
|
   <a href="/patch/7358581/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7358581/">/patch/7358581/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 8B34BBEEA4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Oct 2015 01:18:05 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id BA7FB205ED
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Oct 2015 01:17:56 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 695E02057E
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri,  9 Oct 2015 01:17:47 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754328AbbJIBRm (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 8 Oct 2015 21:17:42 -0400
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:36056 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751831AbbJIBRe (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 8 Oct 2015 21:17:34 -0400
Received: from deadeye.wl.decadent.org.uk ([192.168.4.247] helo=deadeye)
	by shadbolt.decadent.org.uk with esmtps
	(TLS1.2:ECDHE_RSA_AES_128_GCM_SHA256:128) (Exim 4.84)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1ZkMJL-0007VF-Uy; Fri, 09 Oct 2015 02:17:28 +0100
Received: from ben by deadeye with local (Exim 4.86)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1ZkMJG-0007Xw-O4; Fri, 09 Oct 2015 02:17:22 +0100
Message-ID: &lt;1444353438.2956.280.camel@decadent.org.uk&gt;
Subject: Re: [PATCH 3.2 000/107] 3.2.72-rc1 review
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org
Cc: torvalds@linux-foundation.org, Guenter Roeck &lt;linux@roeck-us.net&gt;,
	Phil Jensen &lt;pjensen@evernote.com&gt;, akpm@linux-foundation.org
Date: Fri, 09 Oct 2015 02:17:18 +0100
In-Reply-To: &lt;lsq.1444349547.316291576@decadent.org.uk&gt;
References: &lt;lsq.1444349547.316291576@decadent.org.uk&gt;
Content-Type: multipart/signed; micalg=&quot;pgp-sha512&quot;;
	protocol=&quot;application/pgp-signature&quot;;
	boundary=&quot;=-K/mwjj3tkTDIRBUk6VzK&quot;
X-Mailer: Evolution 3.16.5-1 
Mime-Version: 1.0
X-SA-Exim-Connect-IP: 192.168.4.247
X-SA-Exim-Mail-From: ben@decadent.org.uk
X-SA-Exim-Scanned: No (on shadbolt.decadent.org.uk);
	SAEximRunCond expanded to false
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD, T_TVD_MIME_EPI,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Oct. 9, 2015, 1:17 a.m.</div>
<pre class="content">
This is the combined diff for 3.2.72-rc1 relative to 3.2.71.

Ben.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 9d5fea7..ebb597f 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 2
<span class="p_del">-SUBLEVEL = 71</span>
<span class="p_del">-EXTRAVERSION =</span>
<span class="p_add">+SUBLEVEL = 72</span>
<span class="p_add">+EXTRAVERSION = -rc1</span>
 NAME = Saber-toothed Squirrel
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arm/Makefile b/arch/arm/Makefile</span>
<span class="p_header">index 362c7ca..4a93374 100644</span>
<span class="p_header">--- a/arch/arm/Makefile</span>
<span class="p_header">+++ b/arch/arm/Makefile</span>
<span class="p_chunk">@@ -53,6 +53,14 @@</span> <span class="p_context"> endif</span>
 
 comma = ,
 
<span class="p_add">+#</span>
<span class="p_add">+# The Scalar Replacement of Aggregates (SRA) optimization pass in GCC 4.9 and</span>
<span class="p_add">+# later may result in code being generated that handles signed short and signed</span>
<span class="p_add">+# char struct members incorrectly. So disable it.</span>
<span class="p_add">+# (https://gcc.gnu.org/bugzilla/show_bug.cgi?id=65932)</span>
<span class="p_add">+#</span>
<span class="p_add">+KBUILD_CFLAGS	+= $(call cc-option,-fno-ipa-sra)</span>
<span class="p_add">+</span>
 # This selects which instruction set is used.
 # Note that GCC does not numerically define an architecture version
 # macro, but instead defines a whole series of macros which makes
<span class="p_header">diff --git a/arch/arm/kernel/signal.c b/arch/arm/kernel/signal.c</span>
<span class="p_header">index 9e617bd..c1d9c77 100644</span>
<span class="p_header">--- a/arch/arm/kernel/signal.c</span>
<span class="p_header">+++ b/arch/arm/kernel/signal.c</span>
<span class="p_chunk">@@ -486,12 +486,23 @@</span> <span class="p_context"> setup_return(struct pt_regs *regs, struct k_sigaction *ka,</span>
 		 */
 		thumb = handler &amp; 1;
 
<span class="p_add">+#if __LINUX_ARM_ARCH__ &gt;= 6</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Clear the If-Then Thumb-2 execution state.  ARM spec</span>
<span class="p_add">+		 * requires this to be all 000s in ARM mode.  Snapdragon</span>
<span class="p_add">+		 * S4/Krait misbehaves on a Thumb=&gt;ARM signal transition</span>
<span class="p_add">+		 * without this.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We must do this whenever we are running on a Thumb-2</span>
<span class="p_add">+		 * capable CPU, which includes ARMv6T2.  However, we elect</span>
<span class="p_add">+		 * to do this whenever we&#39;re on an ARMv6 or later CPU for</span>
<span class="p_add">+		 * simplicity.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		cpsr &amp;= ~PSR_IT_MASK;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 		if (thumb) {
 			cpsr |= PSR_T_BIT;
<span class="p_del">-#if __LINUX_ARM_ARCH__ &gt;= 7</span>
<span class="p_del">-			/* clear the If-Then Thumb-2 execution state */</span>
<span class="p_del">-			cpsr &amp;= ~PSR_IT_MASK;</span>
<span class="p_del">-#endif</span>
 		} else
 			cpsr &amp;= ~PSR_T_BIT;
 	}
<span class="p_header">diff --git a/arch/mips/include/asm/pgtable.h b/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">index b2202a6..95bcedb 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -153,8 +153,39 @@</span> <span class="p_context"> static inline void set_pte(pte_t *ptep, pte_t pteval)</span>
 		 * Make sure the buddy is global too (if it&#39;s !none,
 		 * it better already be global)
 		 */
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * For SMP, multiple CPUs can race, so we need to do</span>
<span class="p_add">+		 * this atomically.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+#ifdef CONFIG_64BIT</span>
<span class="p_add">+#define LL_INSN &quot;lld&quot;</span>
<span class="p_add">+#define SC_INSN &quot;scd&quot;</span>
<span class="p_add">+#else /* CONFIG_32BIT */</span>
<span class="p_add">+#define LL_INSN &quot;ll&quot;</span>
<span class="p_add">+#define SC_INSN &quot;sc&quot;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		unsigned long page_global = _PAGE_GLOBAL;</span>
<span class="p_add">+		unsigned long tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		__asm__ __volatile__ (</span>
<span class="p_add">+			&quot;	.set	push\n&quot;</span>
<span class="p_add">+			&quot;	.set	noreorder\n&quot;</span>
<span class="p_add">+			&quot;1:	&quot; LL_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_add">+			&quot;	bnez	%[tmp], 2f\n&quot;</span>
<span class="p_add">+			&quot;	 or	%[tmp], %[tmp], %[global]\n&quot;</span>
<span class="p_add">+			&quot;	&quot; SC_INSN &quot;	%[tmp], %[buddy]\n&quot;</span>
<span class="p_add">+			&quot;	beqz	%[tmp], 1b\n&quot;</span>
<span class="p_add">+			&quot;	 nop\n&quot;</span>
<span class="p_add">+			&quot;2:\n&quot;</span>
<span class="p_add">+			&quot;	.set pop&quot;</span>
<span class="p_add">+			: [buddy] &quot;+m&quot; (buddy-&gt;pte),</span>
<span class="p_add">+			  [tmp] &quot;=&amp;r&quot; (tmp)</span>
<span class="p_add">+			: [global] &quot;r&quot; (page_global));</span>
<span class="p_add">+#else /* !CONFIG_SMP */</span>
 		if (pte_none(*buddy))
 			pte_val(*buddy) = pte_val(*buddy) | _PAGE_GLOBAL;
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 	}
 #endif
 }
<span class="p_header">diff --git a/arch/mips/kernel/mips-mt-fpaff.c b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">index 802e616..c7e2684 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-mt-fpaff.c</span>
<span class="p_chunk">@@ -154,7 +154,7 @@</span> <span class="p_context"> asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,</span>
 				      unsigned long __user *user_mask_ptr)
 {
 	unsigned int real_len;
<span class="p_del">-	cpumask_t mask;</span>
<span class="p_add">+	cpumask_t allowed, mask;</span>
 	int retval;
 	struct task_struct *p;
 
<span class="p_chunk">@@ -173,7 +173,8 @@</span> <span class="p_context"> asmlinkage long mipsmt_sys_sched_getaffinity(pid_t pid, unsigned int len,</span>
 	if (retval)
 		goto out_unlock;
 
<span class="p_del">-	cpus_and(mask, p-&gt;thread.user_cpus_allowed, cpu_possible_map);</span>
<span class="p_add">+	cpumask_or(&amp;allowed, &amp;p-&gt;thread.user_cpus_allowed, &amp;p-&gt;cpus_allowed);</span>
<span class="p_add">+	cpumask_and(&amp;mask, &amp;allowed, cpu_active_mask);</span>
 
 out_unlock:
 	read_unlock(&amp;tasklist_lock);
<span class="p_header">diff --git a/arch/parisc/kernel/irq.c b/arch/parisc/kernel/irq.c</span>
<span class="p_header">index c0b1aff..88934b3 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/irq.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/irq.c</span>
<span class="p_chunk">@@ -336,8 +336,8 @@</span> <span class="p_context"> void do_cpu_irq_mask(struct pt_regs *regs)</span>
 	struct pt_regs *old_regs;
 	unsigned long eirr_val;
 	int irq, cpu = smp_processor_id();
<span class="p_del">-#ifdef CONFIG_SMP</span>
 	struct irq_desc *desc;
<span class="p_add">+#ifdef CONFIG_SMP</span>
 	cpumask_t dest;
 #endif
 
<span class="p_chunk">@@ -350,8 +350,12 @@</span> <span class="p_context"> void do_cpu_irq_mask(struct pt_regs *regs)</span>
 		goto set_out;
 	irq = eirr_to_irq(eirr_val);
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_add">+	/* Filter out spurious interrupts, mostly from serial port at bootup */</span>
 	desc = irq_to_desc(irq);
<span class="p_add">+	if (unlikely(!desc-&gt;action))</span>
<span class="p_add">+		goto set_out;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
 	cpumask_copy(&amp;dest, desc-&gt;irq_data.affinity);
 	if (irqd_is_per_cpu(&amp;desc-&gt;irq_data) &amp;&amp;
 	    !cpu_isset(smp_processor_id(), dest)) {
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">index 85bb66d..15a05ca 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_chunk">@@ -130,6 +130,7 @@</span> <span class="p_context"> static void pnv_teardown_msi_irqs(struct pci_dev *pdev)</span>
 	struct pci_controller *hose = pci_bus_to_host(pdev-&gt;bus);
 	struct pnv_phb *phb = hose-&gt;private_data;
 	struct msi_desc *entry;
<span class="p_add">+	irq_hw_number_t hwirq;</span>
 
 	if (WARN_ON(!phb))
 		return;
<span class="p_chunk">@@ -137,9 +138,10 @@</span> <span class="p_context"> static void pnv_teardown_msi_irqs(struct pci_dev *pdev)</span>
 	list_for_each_entry(entry, &amp;pdev-&gt;msi_list, list) {
 		if (entry-&gt;irq == NO_IRQ)
 			continue;
<span class="p_add">+		hwirq = virq_to_hw(entry-&gt;irq);</span>
 		irq_set_msi_desc(entry-&gt;irq, NULL);
<span class="p_del">-		pnv_put_msi(phb, virq_to_hw(entry-&gt;irq));</span>
 		irq_dispose_mapping(entry-&gt;irq);
<span class="p_add">+		pnv_put_msi(phb, hwirq);</span>
 	}
 }
 #endif /* CONFIG_PCI_MSI */
<span class="p_header">diff --git a/arch/powerpc/sysdev/fsl_msi.c b/arch/powerpc/sysdev/fsl_msi.c</span>
<span class="p_header">index e5c344d3..8ebbdc6 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/fsl_msi.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/fsl_msi.c</span>
<span class="p_chunk">@@ -106,15 +106,16 @@</span> <span class="p_context"> static void fsl_teardown_msi_irqs(struct pci_dev *pdev)</span>
 {
 	struct msi_desc *entry;
 	struct fsl_msi *msi_data;
<span class="p_add">+	irq_hw_number_t hwirq;</span>
 
 	list_for_each_entry(entry, &amp;pdev-&gt;msi_list, list) {
 		if (entry-&gt;irq == NO_IRQ)
 			continue;
<span class="p_add">+		hwirq = virq_to_hw(entry-&gt;irq);</span>
 		msi_data = irq_get_chip_data(entry-&gt;irq);
 		irq_set_msi_desc(entry-&gt;irq, NULL);
<span class="p_del">-		msi_bitmap_free_hwirqs(&amp;msi_data-&gt;bitmap,</span>
<span class="p_del">-				       virq_to_hw(entry-&gt;irq), 1);</span>
 		irq_dispose_mapping(entry-&gt;irq);
<span class="p_add">+		msi_bitmap_free_hwirqs(&amp;msi_data-&gt;bitmap, hwirq, 1);</span>
 	}
 
 	return;
<span class="p_header">diff --git a/arch/powerpc/sysdev/mpic_pasemi_msi.c b/arch/powerpc/sysdev/mpic_pasemi_msi.c</span>
<span class="p_header">index 38e6238..e873616 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mpic_pasemi_msi.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mpic_pasemi_msi.c</span>
<span class="p_chunk">@@ -74,6 +74,7 @@</span> <span class="p_context"> static int pasemi_msi_check_device(struct pci_dev *pdev, int nvec, int type)</span>
 static void pasemi_msi_teardown_msi_irqs(struct pci_dev *pdev)
 {
 	struct msi_desc *entry;
<span class="p_add">+	irq_hw_number_t hwirq;</span>
 
 	pr_debug(&quot;pasemi_msi_teardown_msi_irqs, pdev %p\n&quot;, pdev);
 
<span class="p_chunk">@@ -81,10 +82,10 @@</span> <span class="p_context"> static void pasemi_msi_teardown_msi_irqs(struct pci_dev *pdev)</span>
 		if (entry-&gt;irq == NO_IRQ)
 			continue;
 
<span class="p_add">+		hwirq = virq_to_hw(entry-&gt;irq);</span>
 		irq_set_msi_desc(entry-&gt;irq, NULL);
<span class="p_del">-		msi_bitmap_free_hwirqs(&amp;msi_mpic-&gt;msi_bitmap,</span>
<span class="p_del">-				       virq_to_hw(entry-&gt;irq), ALLOC_CHUNK);</span>
 		irq_dispose_mapping(entry-&gt;irq);
<span class="p_add">+		msi_bitmap_free_hwirqs(&amp;msi_mpic-&gt;msi_bitmap, hwirq, ALLOC_CHUNK);</span>
 	}
 
 	return;
<span class="p_header">diff --git a/arch/powerpc/sysdev/mpic_u3msi.c b/arch/powerpc/sysdev/mpic_u3msi.c</span>
<span class="p_header">index 9a7aa0e..dfc3486 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/mpic_u3msi.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/mpic_u3msi.c</span>
<span class="p_chunk">@@ -124,15 +124,16 @@</span> <span class="p_context"> static int u3msi_msi_check_device(struct pci_dev *pdev, int nvec, int type)</span>
 static void u3msi_teardown_msi_irqs(struct pci_dev *pdev)
 {
 	struct msi_desc *entry;
<span class="p_add">+	irq_hw_number_t hwirq;</span>
 
         list_for_each_entry(entry, &amp;pdev-&gt;msi_list, list) {
 		if (entry-&gt;irq == NO_IRQ)
 			continue;
 
<span class="p_add">+		hwirq = virq_to_hw(entry-&gt;irq);</span>
 		irq_set_msi_desc(entry-&gt;irq, NULL);
<span class="p_del">-		msi_bitmap_free_hwirqs(&amp;msi_mpic-&gt;msi_bitmap,</span>
<span class="p_del">-				       virq_to_hw(entry-&gt;irq), 1);</span>
 		irq_dispose_mapping(entry-&gt;irq);
<span class="p_add">+		msi_bitmap_free_hwirqs(&amp;msi_mpic-&gt;msi_bitmap, hwirq, 1);</span>
 	}
 
 	return;
<span class="p_header">diff --git a/arch/powerpc/sysdev/ppc4xx_msi.c b/arch/powerpc/sysdev/ppc4xx_msi.c</span>
<span class="p_header">index 1c2d7af..4aae9c8 100644</span>
<span class="p_header">--- a/arch/powerpc/sysdev/ppc4xx_msi.c</span>
<span class="p_header">+++ b/arch/powerpc/sysdev/ppc4xx_msi.c</span>
<span class="p_chunk">@@ -114,16 +114,17 @@</span> <span class="p_context"> void ppc4xx_teardown_msi_irqs(struct pci_dev *dev)</span>
 {
 	struct msi_desc *entry;
 	struct ppc4xx_msi *msi_data = &amp;ppc4xx_msi;
<span class="p_add">+	irq_hw_number_t hwirq;</span>
 
 	dev_dbg(&amp;dev-&gt;dev, &quot;PCIE-MSI: tearing down msi irqs\n&quot;);
 
 	list_for_each_entry(entry, &amp;dev-&gt;msi_list, list) {
 		if (entry-&gt;irq == NO_IRQ)
 			continue;
<span class="p_add">+		hwirq = virq_to_hw(entry-&gt;irq);</span>
 		irq_set_msi_desc(entry-&gt;irq, NULL);
<span class="p_del">-		msi_bitmap_free_hwirqs(&amp;msi_data-&gt;bitmap,</span>
<span class="p_del">-				virq_to_hw(entry-&gt;irq), 1);</span>
 		irq_dispose_mapping(entry-&gt;irq);
<span class="p_add">+		msi_bitmap_free_hwirqs(&amp;msi_data-&gt;bitmap, hwirq, 1);</span>
 	}
 }
 
<span class="p_header">diff --git a/arch/s390/kernel/compat_signal.c b/arch/s390/kernel/compat_signal.c</span>
<span class="p_header">index 9fdd05d5..8831a40 100644</span>
<span class="p_header">--- a/arch/s390/kernel/compat_signal.c</span>
<span class="p_header">+++ b/arch/s390/kernel/compat_signal.c</span>
<span class="p_chunk">@@ -52,6 +52,19 @@</span> <span class="p_context"> typedef struct</span>
 	__u32 gprs_high[NUM_GPRS];
 } rt_sigframe32;
 
<span class="p_add">+static inline void sigset_to_sigset32(unsigned long *set64,</span>
<span class="p_add">+				      compat_sigset_word *set32)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set32[0] = (compat_sigset_word) set64[0];</span>
<span class="p_add">+	set32[1] = (compat_sigset_word)(set64[0] &gt;&gt; 32);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void sigset32_to_sigset(compat_sigset_word *set32,</span>
<span class="p_add">+				      unsigned long *set64)</span>
<span class="p_add">+{</span>
<span class="p_add">+	set64[0] = (unsigned long) set32[0] | ((unsigned long) set32[1] &lt;&lt; 32);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int copy_siginfo_to_user32(compat_siginfo_t __user *to, siginfo_t *from)
 {
 	int err;
<span class="p_chunk">@@ -361,12 +374,14 @@</span> <span class="p_context"> asmlinkage long sys32_sigreturn(void)</span>
 {
 	struct pt_regs *regs = task_pt_regs(current);
 	sigframe32 __user *frame = (sigframe32 __user *)regs-&gt;gprs[15];
<span class="p_add">+	compat_sigset_t cset;</span>
 	sigset_t set;
 
 	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
<span class="p_del">-	if (__copy_from_user(&amp;set.sig, &amp;frame-&gt;sc.oldmask, _SIGMASK_COPY_SIZE32))</span>
<span class="p_add">+	if (__copy_from_user(&amp;cset.sig, &amp;frame-&gt;sc.oldmask, _SIGMASK_COPY_SIZE32))</span>
 		goto badframe;
<span class="p_add">+	sigset32_to_sigset(cset.sig, set.sig);</span>
 	sigdelsetmask(&amp;set, ~_BLOCKABLE);
 	set_current_blocked(&amp;set);
 	if (restore_sigregs32(regs, &amp;frame-&gt;sregs))
<span class="p_chunk">@@ -383,6 +398,7 @@</span> <span class="p_context"> asmlinkage long sys32_rt_sigreturn(void)</span>
 {
 	struct pt_regs *regs = task_pt_regs(current);
 	rt_sigframe32 __user *frame = (rt_sigframe32 __user *)regs-&gt;gprs[15];
<span class="p_add">+	compat_sigset_t cset;</span>
 	sigset_t set;
 	stack_t st;
 	__u32 ss_sp;
<span class="p_chunk">@@ -391,8 +407,9 @@</span> <span class="p_context"> asmlinkage long sys32_rt_sigreturn(void)</span>
 
 	if (!access_ok(VERIFY_READ, frame, sizeof(*frame)))
 		goto badframe;
<span class="p_del">-	if (__copy_from_user(&amp;set, &amp;frame-&gt;uc.uc_sigmask, sizeof(set)))</span>
<span class="p_add">+	if (__copy_from_user(&amp;cset, &amp;frame-&gt;uc.uc_sigmask, sizeof(cset)))</span>
 		goto badframe;
<span class="p_add">+	sigset32_to_sigset(cset.sig, set.sig);</span>
 	sigdelsetmask(&amp;set, ~_BLOCKABLE);
 	set_current_blocked(&amp;set);
 	if (restore_sigregs32(regs, &amp;frame-&gt;uc.uc_mcontext))
<span class="p_chunk">@@ -464,13 +481,16 @@</span> <span class="p_context"> static int setup_frame32(int sig, struct k_sigaction *ka,</span>
 			sigset_t *set, struct pt_regs * regs)
 {
 	sigframe32 __user *frame = get_sigframe(ka, regs, sizeof(sigframe32));
<span class="p_add">+	compat_sigset_t cset;</span>
<span class="p_add">+</span>
 	if (!access_ok(VERIFY_WRITE, frame, sizeof(sigframe32)))
 		goto give_sigsegv;
 
 	if (frame == (void __user *) -1UL)
 		goto give_sigsegv;
 
<span class="p_del">-	if (__copy_to_user(&amp;frame-&gt;sc.oldmask, &amp;set-&gt;sig, _SIGMASK_COPY_SIZE32))</span>
<span class="p_add">+	sigset_to_sigset32(set-&gt;sig, cset.sig);</span>
<span class="p_add">+	if (__copy_to_user(&amp;frame-&gt;sc.oldmask, &amp;cset.sig, _SIGMASK_COPY_SIZE32))</span>
 		goto give_sigsegv;
 
 	if (save_sigregs32(regs, &amp;frame-&gt;sregs))
<span class="p_chunk">@@ -524,6 +544,7 @@</span> <span class="p_context"> give_sigsegv:</span>
 static int setup_rt_frame32(int sig, struct k_sigaction *ka, siginfo_t *info,
 			   sigset_t *set, struct pt_regs * regs)
 {
<span class="p_add">+	compat_sigset_t cset;</span>
 	int err = 0;
 	rt_sigframe32 __user *frame = get_sigframe(ka, regs, sizeof(rt_sigframe32));
 	if (!access_ok(VERIFY_WRITE, frame, sizeof(rt_sigframe32)))
<span class="p_chunk">@@ -536,6 +557,7 @@</span> <span class="p_context"> static int setup_rt_frame32(int sig, struct k_sigaction *ka, siginfo_t *info,</span>
 		goto give_sigsegv;
 
 	/* Create the ucontext.  */
<span class="p_add">+	sigset_to_sigset32(set-&gt;sig, cset.sig);</span>
 	err |= __put_user(UC_EXTENDED, &amp;frame-&gt;uc.uc_flags);
 	err |= __put_user(0, &amp;frame-&gt;uc.uc_link);
 	err |= __put_user(current-&gt;sas_ss_sp, &amp;frame-&gt;uc.uc_stack.ss_sp);
<span class="p_chunk">@@ -544,7 +566,7 @@</span> <span class="p_context"> static int setup_rt_frame32(int sig, struct k_sigaction *ka, siginfo_t *info,</span>
 	err |= __put_user(current-&gt;sas_ss_size, &amp;frame-&gt;uc.uc_stack.ss_size);
 	err |= save_sigregs32(regs, &amp;frame-&gt;uc.uc_mcontext);
 	err |= save_sigregs_gprs_high(regs, frame-&gt;gprs_high);
<span class="p_del">-	err |= __copy_to_user(&amp;frame-&gt;uc.uc_sigmask, set, sizeof(*set));</span>
<span class="p_add">+	err |= __copy_to_user(&amp;frame-&gt;uc.uc_sigmask, &amp;cset, sizeof(cset));</span>
 	if (err)
 		goto give_sigsegv;
 
<span class="p_header">diff --git a/arch/sparc/include/asm/visasm.h b/arch/sparc/include/asm/visasm.h</span>
<span class="p_header">index 39ca301..3a8c2af 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/visasm.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/visasm.h</span>
<span class="p_chunk">@@ -28,18 +28,12 @@</span> <span class="p_context"></span>
  * Must preserve %o5 between VISEntryHalf and VISExitHalf */
 
 #define VISEntryHalf					\
<span class="p_del">-	rd		%fprs, %o5;			\</span>
<span class="p_del">-	andcc		%o5, FPRS_FEF, %g0;		\</span>
<span class="p_del">-	be,pt		%icc, 297f;			\</span>
<span class="p_del">-	 sethi		%hi(298f), %g7;			\</span>
<span class="p_del">-	sethi		%hi(VISenterhalf), %g1;		\</span>
<span class="p_del">-	jmpl		%g1 + %lo(VISenterhalf), %g0;	\</span>
<span class="p_del">-	 or		%g7, %lo(298f), %g7;		\</span>
<span class="p_del">-	clr		%o5;				\</span>
<span class="p_del">-297:	wr		%o5, FPRS_FEF, %fprs;		\</span>
<span class="p_del">-298:</span>
<span class="p_add">+	VISEntry</span>
 
 #define VISExitHalf					\
<span class="p_add">+	VISExit</span>
<span class="p_add">+</span>
<span class="p_add">+#define VISExitHalfFast					\</span>
 	wr		%o5, 0, %fprs;
 
 #ifndef __ASSEMBLY__
<span class="p_header">diff --git a/arch/sparc/lib/VISsave.S b/arch/sparc/lib/VISsave.S</span>
<span class="p_header">index b320ae9..a063d84 100644</span>
<span class="p_header">--- a/arch/sparc/lib/VISsave.S</span>
<span class="p_header">+++ b/arch/sparc/lib/VISsave.S</span>
<span class="p_chunk">@@ -44,9 +44,8 @@</span> <span class="p_context"> vis1:	ldub		[%g6 + TI_FPSAVED], %g3</span>
 
 	 stx		%g3, [%g6 + TI_GSR]
 2:	add		%g6, %g1, %g3
<span class="p_del">-	cmp		%o5, FPRS_DU</span>
<span class="p_del">-	be,pn		%icc, 6f</span>
<span class="p_del">-	 sll		%g1, 3, %g1</span>
<span class="p_add">+	mov		FPRS_DU | FPRS_DL | FPRS_FEF, %o5</span>
<span class="p_add">+	sll		%g1, 3, %g1</span>
 	stb		%o5, [%g3 + TI_FPSAVED]
 	rd		%gsr, %g2
 	add		%g6, %g1, %g3
<span class="p_chunk">@@ -80,65 +79,3 @@</span> <span class="p_context"> vis1:	ldub		[%g6 + TI_FPSAVED], %g3</span>
 	.align		32
 80:	jmpl		%g7 + %g0, %g0
 	 nop
<span class="p_del">-</span>
<span class="p_del">-6:	ldub		[%g3 + TI_FPSAVED], %o5</span>
<span class="p_del">-	or		%o5, FPRS_DU, %o5</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0x80, %g2</span>
<span class="p_del">-	stb		%o5, [%g3 + TI_FPSAVED]</span>
<span class="p_del">-</span>
<span class="p_del">-	sll		%g1, 5, %g1</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0xc0, %g3</span>
<span class="p_del">-	wr		%g0, FPRS_FEF, %fprs</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	stda		%f32, [%g2 + %g1] ASI_BLK_P</span>
<span class="p_del">-	stda		%f48, [%g3 + %g1] ASI_BLK_P</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	ba,pt		%xcc, 80f</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-80:	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-VISenterhalf:</span>
<span class="p_del">-	ldub		[%g6 + TI_FPDEPTH], %g1</span>
<span class="p_del">-	brnz,a,pn	%g1, 1f</span>
<span class="p_del">-	 cmp		%g1, 1</span>
<span class="p_del">-	stb		%g0, [%g6 + TI_FPSAVED]</span>
<span class="p_del">-	stx		%fsr, [%g6 + TI_XFSR]</span>
<span class="p_del">-	clr		%o5</span>
<span class="p_del">-	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 wr		%g0, FPRS_FEF, %fprs</span>
<span class="p_del">-</span>
<span class="p_del">-1:	bne,pn		%icc, 2f</span>
<span class="p_del">-	 srl		%g1, 1, %g1</span>
<span class="p_del">-	ba,pt		%xcc, vis1</span>
<span class="p_del">-	 sub		%g7, 8, %g7</span>
<span class="p_del">-2:	addcc		%g6, %g1, %g3</span>
<span class="p_del">-	sll		%g1, 3, %g1</span>
<span class="p_del">-	andn		%o5, FPRS_DU, %g2</span>
<span class="p_del">-	stb		%g2, [%g3 + TI_FPSAVED]</span>
<span class="p_del">-</span>
<span class="p_del">-	rd		%gsr, %g2</span>
<span class="p_del">-	add		%g6, %g1, %g3</span>
<span class="p_del">-	stx		%g2, [%g3 + TI_GSR]</span>
<span class="p_del">-	add		%g6, %g1, %g2</span>
<span class="p_del">-	stx		%fsr, [%g2 + TI_XFSR]</span>
<span class="p_del">-	sll		%g1, 5, %g1</span>
<span class="p_del">-3:	andcc		%o5, FPRS_DL, %g0</span>
<span class="p_del">-	be,pn		%icc, 4f</span>
<span class="p_del">-	 add		%g6, TI_FPREGS, %g2</span>
<span class="p_del">-</span>
<span class="p_del">-	add		%g6, TI_FPREGS+0x40, %g3</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	stda		%f0, [%g2 + %g1] ASI_BLK_P</span>
<span class="p_del">-	stda		%f16, [%g3 + %g1] ASI_BLK_P</span>
<span class="p_del">-	membar		#Sync</span>
<span class="p_del">-	ba,pt		%xcc, 4f</span>
<span class="p_del">-	 nop</span>
<span class="p_del">-</span>
<span class="p_del">-	.align		32</span>
<span class="p_del">-4:	and		%o5, FPRS_DU, %o5</span>
<span class="p_del">-	jmpl		%g7 + %g0, %g0</span>
<span class="p_del">-	 wr		%o5, FPRS_FEF, %fprs</span>
<span class="p_header">diff --git a/arch/x86/crypto/ghash-clmulni-intel_glue.c b/arch/x86/crypto/ghash-clmulni-intel_glue.c</span>
<span class="p_header">index f781251..4827b23 100644</span>
<span class="p_header">--- a/arch/x86/crypto/ghash-clmulni-intel_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/ghash-clmulni-intel_glue.c</span>
<span class="p_chunk">@@ -291,6 +291,7 @@</span> <span class="p_context"> static struct ahash_alg ghash_async_alg = {</span>
 			.cra_name		= &quot;ghash&quot;,
 			.cra_driver_name	= &quot;ghash-clmulni&quot;,
 			.cra_priority		= 400,
<span class="p_add">+			.cra_ctxsize		= sizeof(struct ghash_async_ctx),</span>
 			.cra_flags		= CRYPTO_ALG_TYPE_AHASH | CRYPTO_ALG_ASYNC,
 			.cra_blocksize		= GHASH_BLOCK_SIZE,
 			.cra_type		= &amp;crypto_ahash_type,
<span class="p_header">diff --git a/arch/x86/include/asm/desc.h b/arch/x86/include/asm/desc.h</span>
<span class="p_header">index 3225868..382ce8a 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/desc.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/desc.h</span>
<span class="p_chunk">@@ -277,21 +277,6 @@</span> <span class="p_context"> static inline void clear_LDT(void)</span>
 	set_ldt(NULL, 0);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * load one particular LDT into the current CPU</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void load_LDT_nolock(mm_context_t *pc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	set_ldt(pc-&gt;ldt, pc-&gt;size);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void load_LDT(mm_context_t *pc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	preempt_disable();</span>
<span class="p_del">-	load_LDT_nolock(pc);</span>
<span class="p_del">-	preempt_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline unsigned long get_desc_base(const struct desc_struct *desc)
 {
 	return (unsigned)(desc-&gt;base0 | ((desc-&gt;base1) &lt;&lt; 16) | ((desc-&gt;base2) &lt;&lt; 24));
<span class="p_header">diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h</span>
<span class="p_header">index 5f55e69..926f672 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu.h</span>
<span class="p_chunk">@@ -9,8 +9,7 @@</span> <span class="p_context"></span>
  * we put the segment information here.
  */
 typedef struct {
<span class="p_del">-	void *ldt;</span>
<span class="p_del">-	int size;</span>
<span class="p_add">+	struct ldt_struct *ldt;</span>
 
 #ifdef CONFIG_X86_64
 	/* True if mm supports a task running in 32 bit compatibility mode. */
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index 6902152..ce4ea94 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -16,6 +16,51 @@</span> <span class="p_context"> static inline void paravirt_activate_mm(struct mm_struct *prev,</span>
 #endif	/* !CONFIG_PARAVIRT */
 
 /*
<span class="p_add">+ * ldt_structs can be allocated, used, and freed, but they are never</span>
<span class="p_add">+ * modified while live.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct ldt_struct {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen requires page-aligned LDTs with special permissions.  This is</span>
<span class="p_add">+	 * needed to prevent us from installing evil descriptors such as</span>
<span class="p_add">+	 * call gates.  On native, we could merge the ldt_struct and LDT</span>
<span class="p_add">+	 * allocations, but it&#39;s not worth trying to optimize.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct desc_struct *entries;</span>
<span class="p_add">+	int size;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void load_mm_ldt(struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ldt_struct *ldt;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* smp_read_barrier_depends synchronizes with barrier in install_ldt */</span>
<span class="p_add">+	ldt = ACCESS_ONCE(mm-&gt;context.ldt);</span>
<span class="p_add">+	smp_read_barrier_depends();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Any change to mm-&gt;context.ldt is followed by an IPI to all</span>
<span class="p_add">+	 * CPUs with the mm active.  The LDT will not be freed until</span>
<span class="p_add">+	 * after the IPI is handled by all such CPUs.  This means that,</span>
<span class="p_add">+	 * if the ldt_struct changes before we return, the values we see</span>
<span class="p_add">+	 * will be safe, and the new values will be loaded before we run</span>
<span class="p_add">+	 * any user code.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * NB: don&#39;t try to convert this to use RCU without extreme care.</span>
<span class="p_add">+	 * We would still need IRQs off, because we don&#39;t want to change</span>
<span class="p_add">+	 * the local LDT after an IPI loaded a newer value than the one</span>
<span class="p_add">+	 * that we can see.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unlikely(ldt))</span>
<span class="p_add">+		set_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		clear_LDT();</span>
<span class="p_add">+</span>
<span class="p_add">+	DEBUG_LOCKS_WARN_ON(preemptible());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Used for LDT copy/destruction.
  */
 int init_new_context(struct task_struct *tsk, struct mm_struct *mm);
<span class="p_chunk">@@ -52,7 +97,7 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 		 * load the LDT, if the LDT is different:
 		 */
 		if (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))
<span class="p_del">-			load_LDT_nolock(&amp;next-&gt;context);</span>
<span class="p_add">+			load_mm_ldt(next);</span>
 	}
 #ifdef CONFIG_SMP
 	else {
<span class="p_chunk">@@ -65,7 +110,7 @@</span> <span class="p_context"> static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 			 * to make sure to use no freed page tables.
 			 */
 			load_cr3(next-&gt;pgd);
<span class="p_del">-			load_LDT_nolock(&amp;next-&gt;context);</span>
<span class="p_add">+			load_mm_ldt(next);</span>
 		}
 	}
 #endif
<span class="p_header">diff --git a/arch/x86/include/asm/msr-index.h b/arch/x86/include/asm/msr-index.h</span>
<span class="p_header">index 5538b13..3d48aa4 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/msr-index.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/msr-index.h</span>
<span class="p_chunk">@@ -159,6 +159,7 @@</span> <span class="p_context"></span>
 /* C1E active bits in int pending message */
 #define K8_INTP_C1E_ACTIVE_MASK		0x18000000
 #define MSR_K8_TSEG_ADDR		0xc0010112
<span class="p_add">+#define MSR_K8_TSEG_MASK		0xc0010113</span>
 #define K8_MTRRFIXRANGE_DRAM_ENABLE	0x00040000 /* MtrrFixDramEn bit    */
 #define K8_MTRRFIXRANGE_DRAM_MODIFY	0x00080000 /* MtrrFixDramModEn bit */
 #define K8_MTRR_RDMEM_WRMEM_MASK	0x18181818 /* Mask: RdMem|WrMem    */
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 6284d6d..0cbdebf 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1225,7 +1225,7 @@</span> <span class="p_context"> void __cpuinit cpu_init(void)</span>
 	load_sp0(t, &amp;current-&gt;thread);
 	set_tss_desc(cpu, t);
 	load_TR_desc();
<span class="p_del">-	load_LDT(&amp;init_mm.context);</span>
<span class="p_add">+	load_mm_ldt(&amp;init_mm);</span>
 
 	clear_all_debug_regs();
 	dbg_restore_debug_regs();
<span class="p_chunk">@@ -1273,7 +1273,7 @@</span> <span class="p_context"> void __cpuinit cpu_init(void)</span>
 	load_sp0(t, thread);
 	set_tss_desc(cpu, t);
 	load_TR_desc();
<span class="p_del">-	load_LDT(&amp;init_mm.context);</span>
<span class="p_add">+	load_mm_ldt(&amp;init_mm);</span>
 
 	t-&gt;x86_tss.io_bitmap_base = offsetof(struct tss_struct, io_bitmap);
 
<span class="p_header">diff --git a/arch/x86/kernel/entry_64.S b/arch/x86/kernel/entry_64.S</span>
<span class="p_header">index 8d15c69..f6daf3c 100644</span>
<span class="p_header">--- a/arch/x86/kernel/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/kernel/entry_64.S</span>
<span class="p_chunk">@@ -1504,7 +1504,18 @@</span> <span class="p_context"> END(error_exit)</span>
 	/* runs on exception stack */
 ENTRY(nmi)
 	INTR_FRAME
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fix up the exception frame if we&#39;re on Xen.</span>
<span class="p_add">+	 * PARAVIRT_ADJUST_EXCEPTION_FRAME is guaranteed to push at most</span>
<span class="p_add">+	 * one value to the stack on native, so it may clobber the rdx</span>
<span class="p_add">+	 * scratch slot, but it won&#39;t clobber any of the important</span>
<span class="p_add">+	 * slots past it.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Xen is a different story, because the Xen frame itself overlaps</span>
<span class="p_add">+	 * the &quot;NMI executing&quot; variable.</span>
<span class="p_add">+	 */</span>
 	PARAVIRT_ADJUST_EXCEPTION_FRAME
<span class="p_add">+</span>
 	pushq_cfi $-1
 	subq $ORIG_RAX-R15, %rsp
 	CFI_ADJUST_CFA_OFFSET ORIG_RAX-R15
<span class="p_header">diff --git a/arch/x86/kernel/ldt.c b/arch/x86/kernel/ldt.c</span>
<span class="p_header">index 0a8e65e..1dd3230 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ldt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ldt.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/string.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/smp.h&gt;
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/uaccess.h&gt;
 
<span class="p_chunk">@@ -21,82 +22,87 @@</span> <span class="p_context"></span>
 #include &lt;asm/mmu_context.h&gt;
 #include &lt;asm/syscalls.h&gt;
 
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_add">+/* context.lock is held for us, so we don&#39;t need any locking. */</span>
 static void flush_ldt(void *current_mm)
 {
<span class="p_del">-	if (current-&gt;active_mm == current_mm)</span>
<span class="p_del">-		load_LDT(&amp;current-&gt;active_mm-&gt;context);</span>
<span class="p_add">+	mm_context_t *pc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;active_mm != current_mm)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pc = &amp;current-&gt;active_mm-&gt;context;</span>
<span class="p_add">+	set_ldt(pc-&gt;ldt-&gt;entries, pc-&gt;ldt-&gt;size);</span>
 }
<span class="p_del">-#endif</span>
 
<span class="p_del">-static int alloc_ldt(mm_context_t *pc, int mincount, int reload)</span>
<span class="p_add">+/* The caller must call finalize_ldt_struct on the result. LDT starts zeroed. */</span>
<span class="p_add">+static struct ldt_struct *alloc_ldt_struct(int size)</span>
 {
<span class="p_del">-	void *oldldt, *newldt;</span>
<span class="p_del">-	int oldsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mincount &lt;= pc-&gt;size)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	oldsize = pc-&gt;size;</span>
<span class="p_del">-	mincount = (mincount + (PAGE_SIZE / LDT_ENTRY_SIZE - 1)) &amp;</span>
<span class="p_del">-			(~(PAGE_SIZE / LDT_ENTRY_SIZE - 1));</span>
<span class="p_del">-	if (mincount * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-		newldt = vmalloc(mincount * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	struct ldt_struct *new_ldt;</span>
<span class="p_add">+	int alloc_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &gt; LDT_ENTRIES)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_ldt = kmalloc(sizeof(struct ldt_struct), GFP_KERNEL);</span>
<span class="p_add">+	if (!new_ldt)</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	BUILD_BUG_ON(LDT_ENTRY_SIZE != sizeof(struct desc_struct));</span>
<span class="p_add">+	alloc_size = size * LDT_ENTRY_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Xen is very picky: it requires a page-aligned LDT that has no</span>
<span class="p_add">+	 * trailing nonzero bytes in any page that contains LDT descriptors.</span>
<span class="p_add">+	 * Keep it simple: zero the whole allocation and never allocate less</span>
<span class="p_add">+	 * than PAGE_SIZE.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (alloc_size &gt; PAGE_SIZE)</span>
<span class="p_add">+		new_ldt-&gt;entries = vzalloc(alloc_size);</span>
 	else
<span class="p_del">-		newldt = (void *)__get_free_page(GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!newldt)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+		new_ldt-&gt;entries = kzalloc(PAGE_SIZE, GFP_KERNEL);</span>
 
<span class="p_del">-	if (oldsize)</span>
<span class="p_del">-		memcpy(newldt, pc-&gt;ldt, oldsize * LDT_ENTRY_SIZE);</span>
<span class="p_del">-	oldldt = pc-&gt;ldt;</span>
<span class="p_del">-	memset(newldt + oldsize * LDT_ENTRY_SIZE, 0,</span>
<span class="p_del">-	       (mincount - oldsize) * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	if (!new_ldt-&gt;entries) {</span>
<span class="p_add">+		kfree(new_ldt);</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	paravirt_alloc_ldt(newldt, mincount);</span>
<span class="p_add">+	new_ldt-&gt;size = size;</span>
<span class="p_add">+	return new_ldt;</span>
<span class="p_add">+}</span>
 
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	/* CHECKME: Do we really need this ? */</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	pc-&gt;ldt = newldt;</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-	pc-&gt;size = mincount;</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (reload) {</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-		preempt_disable();</span>
<span class="p_del">-		load_LDT(pc);</span>
<span class="p_del">-		if (!cpumask_equal(mm_cpumask(current-&gt;mm),</span>
<span class="p_del">-				   cpumask_of(smp_processor_id())))</span>
<span class="p_del">-			smp_call_function(flush_ldt, current-&gt;mm, 1);</span>
<span class="p_del">-		preempt_enable();</span>
<span class="p_del">-#else</span>
<span class="p_del">-		load_LDT(pc);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (oldsize) {</span>
<span class="p_del">-		paravirt_free_ldt(oldldt, oldsize);</span>
<span class="p_del">-		if (oldsize * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-			vfree(oldldt);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			put_page(virt_to_page(oldldt));</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+/* After calling this, the LDT is immutable. */</span>
<span class="p_add">+static void finalize_ldt_struct(struct ldt_struct *ldt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	paravirt_alloc_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
 }
 
<span class="p_del">-static inline int copy_ldt(mm_context_t *new, mm_context_t *old)</span>
<span class="p_add">+/* context.lock is held */</span>
<span class="p_add">+static void install_ldt(struct mm_struct *current_mm,</span>
<span class="p_add">+			struct ldt_struct *ldt)</span>
 {
<span class="p_del">-	int err = alloc_ldt(new, old-&gt;size, 0);</span>
<span class="p_del">-	int i;</span>
<span class="p_add">+	/* Synchronizes with smp_read_barrier_depends in load_mm_ldt. */</span>
<span class="p_add">+        barrier();</span>
<span class="p_add">+        ACCESS_ONCE(current_mm-&gt;context.ldt) = ldt;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Activate the LDT for all CPUs using current_mm. */</span>
<span class="p_add">+	smp_call_function_many(mm_cpumask(current_mm), flush_ldt, current_mm,</span>
<span class="p_add">+			       true);</span>
<span class="p_add">+	local_irq_disable();</span>
<span class="p_add">+	flush_ldt(current_mm);</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		return err;</span>
<span class="p_add">+static void free_ldt_struct(struct ldt_struct *ldt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (likely(!ldt))</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	for (i = 0; i &lt; old-&gt;size; i++)</span>
<span class="p_del">-		write_ldt_entry(new-&gt;ldt, i, old-&gt;ldt + i * LDT_ENTRY_SIZE);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	paravirt_free_ldt(ldt-&gt;entries, ldt-&gt;size);</span>
<span class="p_add">+	if (ldt-&gt;size * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_add">+		vfree(ldt-&gt;entries);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		kfree(ldt-&gt;entries);</span>
<span class="p_add">+	kfree(ldt);</span>
 }
 
 /*
<span class="p_chunk">@@ -105,17 +111,37 @@</span> <span class="p_context"> static inline int copy_ldt(mm_context_t *new, mm_context_t *old)</span>
  */
 int init_new_context(struct task_struct *tsk, struct mm_struct *mm)
 {
<span class="p_add">+	struct ldt_struct *new_ldt;</span>
 	struct mm_struct *old_mm;
 	int retval = 0;
 
 	mutex_init(&amp;mm-&gt;context.lock);
<span class="p_del">-	mm-&gt;context.size = 0;</span>
 	old_mm = current-&gt;mm;
<span class="p_del">-	if (old_mm &amp;&amp; old_mm-&gt;context.size &gt; 0) {</span>
<span class="p_del">-		mutex_lock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_del">-		retval = copy_ldt(&amp;mm-&gt;context, &amp;old_mm-&gt;context);</span>
<span class="p_del">-		mutex_unlock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_add">+	if (!old_mm) {</span>
<span class="p_add">+		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;old_mm-&gt;context.lock);</span>
<span class="p_add">+	if (!old_mm-&gt;context.ldt) {</span>
<span class="p_add">+		mm-&gt;context.ldt = NULL;</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	new_ldt = alloc_ldt_struct(old_mm-&gt;context.ldt-&gt;size);</span>
<span class="p_add">+	if (!new_ldt) {</span>
<span class="p_add">+		retval = -ENOMEM;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(new_ldt-&gt;entries, old_mm-&gt;context.ldt-&gt;entries,</span>
<span class="p_add">+	       new_ldt-&gt;size * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	finalize_ldt_struct(new_ldt);</span>
<span class="p_add">+</span>
<span class="p_add">+	mm-&gt;context.ldt = new_ldt;</span>
<span class="p_add">+</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;old_mm-&gt;context.lock);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -126,53 +152,47 @@</span> <span class="p_context"> int init_new_context(struct task_struct *tsk, struct mm_struct *mm)</span>
  */
 void destroy_context(struct mm_struct *mm)
 {
<span class="p_del">-	if (mm-&gt;context.size) {</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-		/* CHECKME: Can this ever happen ? */</span>
<span class="p_del">-		if (mm == current-&gt;active_mm)</span>
<span class="p_del">-			clear_LDT();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-		paravirt_free_ldt(mm-&gt;context.ldt, mm-&gt;context.size);</span>
<span class="p_del">-		if (mm-&gt;context.size * LDT_ENTRY_SIZE &gt; PAGE_SIZE)</span>
<span class="p_del">-			vfree(mm-&gt;context.ldt);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			put_page(virt_to_page(mm-&gt;context.ldt));</span>
<span class="p_del">-		mm-&gt;context.size = 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	free_ldt_struct(mm-&gt;context.ldt);</span>
<span class="p_add">+	mm-&gt;context.ldt = NULL;</span>
 }
 
 static int read_ldt(void __user *ptr, unsigned long bytecount)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int retval;</span>
 	unsigned long size;
 	struct mm_struct *mm = current-&gt;mm;
 
<span class="p_del">-	if (!mm-&gt;context.size)</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mm-&gt;context.ldt) {</span>
<span class="p_add">+		retval = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (bytecount &gt; LDT_ENTRY_SIZE * LDT_ENTRIES)
 		bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	size = mm-&gt;context.size * LDT_ENTRY_SIZE;</span>
<span class="p_add">+	size = mm-&gt;context.ldt-&gt;size * LDT_ENTRY_SIZE;</span>
 	if (size &gt; bytecount)
 		size = bytecount;
 
<span class="p_del">-	err = 0;</span>
<span class="p_del">-	if (copy_to_user(ptr, mm-&gt;context.ldt, size))</span>
<span class="p_del">-		err = -EFAULT;</span>
<span class="p_del">-	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	if (err &lt; 0)</span>
<span class="p_del">-		goto error_return;</span>
<span class="p_add">+	if (copy_to_user(ptr, mm-&gt;context.ldt-&gt;entries, size)) {</span>
<span class="p_add">+		retval = -EFAULT;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (size != bytecount) {
<span class="p_del">-		/* zero-fill the rest */</span>
<span class="p_del">-		if (clear_user(ptr + size, bytecount - size) != 0) {</span>
<span class="p_del">-			err = -EFAULT;</span>
<span class="p_del">-			goto error_return;</span>
<span class="p_add">+		/* Zero-fill the rest and pretend we read bytecount bytes. */</span>
<span class="p_add">+		if (clear_user(ptr + size, bytecount - size)) {</span>
<span class="p_add">+			retval = -EFAULT;</span>
<span class="p_add">+			goto out_unlock;</span>
 		}
 	}
<span class="p_del">-	return bytecount;</span>
<span class="p_del">-error_return:</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	retval = bytecount;</span>
<span class="p_add">+</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+	return retval;</span>
 }
 
 static int read_default_ldt(void __user *ptr, unsigned long bytecount)
<span class="p_chunk">@@ -196,6 +216,8 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 	struct desc_struct ldt;
 	int error;
 	struct user_desc ldt_info;
<span class="p_add">+	int oldsize, newsize;</span>
<span class="p_add">+	struct ldt_struct *new_ldt, *old_ldt;</span>
 
 	error = -EINVAL;
 	if (bytecount != sizeof(ldt_info))
<span class="p_chunk">@@ -214,34 +236,39 @@</span> <span class="p_context"> static int write_ldt(void __user *ptr, unsigned long bytecount, int oldmode)</span>
 			goto out;
 	}
 
<span class="p_del">-	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_del">-	if (ldt_info.entry_number &gt;= mm-&gt;context.size) {</span>
<span class="p_del">-		error = alloc_ldt(&amp;current-&gt;mm-&gt;context,</span>
<span class="p_del">-				  ldt_info.entry_number + 1, 1);</span>
<span class="p_del">-		if (error &lt; 0)</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Allow LDTs to be cleared by the user. */</span>
<span class="p_del">-	if (ldt_info.base_addr == 0 &amp;&amp; ldt_info.limit == 0) {</span>
<span class="p_del">-		if (oldmode || LDT_empty(&amp;ldt_info)) {</span>
<span class="p_del">-			memset(&amp;ldt, 0, sizeof(ldt));</span>
<span class="p_del">-			goto install;</span>
<span class="p_add">+	if ((oldmode &amp;&amp; !ldt_info.base_addr &amp;&amp; !ldt_info.limit) ||</span>
<span class="p_add">+	    LDT_empty(&amp;ldt_info)) {</span>
<span class="p_add">+		/* The user wants to clear the entry. */</span>
<span class="p_add">+		memset(&amp;ldt, 0, sizeof(ldt));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) {</span>
<span class="p_add">+			error = -EINVAL;</span>
<span class="p_add">+			goto out;</span>
 		}
<span class="p_add">+</span>
<span class="p_add">+		fill_ldt(&amp;ldt, &amp;ldt_info);</span>
<span class="p_add">+		if (oldmode)</span>
<span class="p_add">+			ldt.avl = 0;</span>
 	}
 
<span class="p_del">-	if (!IS_ENABLED(CONFIG_X86_16BIT) &amp;&amp; !ldt_info.seg_32bit) {</span>
<span class="p_del">-		error = -EINVAL;</span>
<span class="p_add">+	mutex_lock(&amp;mm-&gt;context.lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	old_ldt = mm-&gt;context.ldt;</span>
<span class="p_add">+	oldsize = old_ldt ? old_ldt-&gt;size : 0;</span>
<span class="p_add">+	newsize = max((int)(ldt_info.entry_number + 1), oldsize);</span>
<span class="p_add">+</span>
<span class="p_add">+	error = -ENOMEM;</span>
<span class="p_add">+	new_ldt = alloc_ldt_struct(newsize);</span>
<span class="p_add">+	if (!new_ldt)</span>
 		goto out_unlock;
<span class="p_del">-	}</span>
 
<span class="p_del">-	fill_ldt(&amp;ldt, &amp;ldt_info);</span>
<span class="p_del">-	if (oldmode)</span>
<span class="p_del">-		ldt.avl = 0;</span>
<span class="p_add">+	if (old_ldt)</span>
<span class="p_add">+		memcpy(new_ldt-&gt;entries, old_ldt-&gt;entries, oldsize * LDT_ENTRY_SIZE);</span>
<span class="p_add">+	new_ldt-&gt;entries[ldt_info.entry_number] = ldt;</span>
<span class="p_add">+	finalize_ldt_struct(new_ldt);</span>
 
<span class="p_del">-	/* Install the new entry ...  */</span>
<span class="p_del">-install:</span>
<span class="p_del">-	write_ldt_entry(mm-&gt;context.ldt, ldt_info.entry_number, &amp;ldt);</span>
<span class="p_add">+	install_ldt(mm, new_ldt);</span>
<span class="p_add">+	free_ldt_struct(old_ldt);</span>
 	error = 0;
 
 out_unlock:
<span class="p_header">diff --git a/arch/x86/kernel/paravirt.c b/arch/x86/kernel/paravirt.c</span>
<span class="p_header">index 84c938f..af5b675 100644</span>
<span class="p_header">--- a/arch/x86/kernel/paravirt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/paravirt.c</span>
<span class="p_chunk">@@ -38,10 +38,18 @@</span> <span class="p_context"></span>
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/timer.h&gt;
 
<span class="p_del">-/* nop stub */</span>
<span class="p_del">-void _paravirt_nop(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * nop stub, which must not clobber anything *including the stack* to</span>
<span class="p_add">+ * avoid confusing the entry prologues.</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern void _paravirt_nop(void);</span>
<span class="p_add">+asm (&quot;.pushsection .entry.text, \&quot;ax\&quot;\n&quot;</span>
<span class="p_add">+     &quot;.global _paravirt_nop\n&quot;</span>
<span class="p_add">+     &quot;_paravirt_nop:\n\t&quot;</span>
<span class="p_add">+     &quot;ret\n\t&quot;</span>
<span class="p_add">+     &quot;.size _paravirt_nop, . - _paravirt_nop\n\t&quot;</span>
<span class="p_add">+     &quot;.type _paravirt_nop, @function\n\t&quot;</span>
<span class="p_add">+     &quot;.popsection&quot;);</span>
 
 /* identity function, which can be inlined */
 u32 _paravirt_ident_32(u32 x)
<span class="p_header">diff --git a/arch/x86/kernel/process_64.c b/arch/x86/kernel/process_64.c</span>
<span class="p_header">index e361095..7e94abd 100644</span>
<span class="p_header">--- a/arch/x86/kernel/process_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/process_64.c</span>
<span class="p_chunk">@@ -218,11 +218,11 @@</span> <span class="p_context"> void __show_regs(struct pt_regs *regs, int all)</span>
 void release_thread(struct task_struct *dead_task)
 {
 	if (dead_task-&gt;mm) {
<span class="p_del">-		if (dead_task-&gt;mm-&gt;context.size) {</span>
<span class="p_add">+		if (dead_task-&gt;mm-&gt;context.ldt) {</span>
 			printk(&quot;WARNING: dead process %8s still has LDT? &lt;%p/%d&gt;\n&quot;,
 					dead_task-&gt;comm,
 					dead_task-&gt;mm-&gt;context.ldt,
<span class="p_del">-					dead_task-&gt;mm-&gt;context.size);</span>
<span class="p_add">+					dead_task-&gt;mm-&gt;context.ldt-&gt;size);</span>
 			BUG();
 		}
 	}
<span class="p_header">diff --git a/arch/x86/kernel/step.c b/arch/x86/kernel/step.c</span>
<span class="p_header">index d4f278e..bfe6a14 100644</span>
<span class="p_header">--- a/arch/x86/kernel/step.c</span>
<span class="p_header">+++ b/arch/x86/kernel/step.c</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/ptrace.h&gt;
 #include &lt;asm/desc.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *regs)
 {
<span class="p_chunk">@@ -27,13 +28,14 @@</span> <span class="p_context"> unsigned long convert_ip_to_linear(struct task_struct *child, struct pt_regs *re</span>
 		struct desc_struct *desc;
 		unsigned long base;
 
<span class="p_del">-		seg &amp;= ~7UL;</span>
<span class="p_add">+		seg &gt;&gt;= 3;</span>
 
 		mutex_lock(&amp;child-&gt;mm-&gt;context.lock);
<span class="p_del">-		if (unlikely((seg &gt;&gt; 3) &gt;= child-&gt;mm-&gt;context.size))</span>
<span class="p_add">+		if (unlikely(!child-&gt;mm-&gt;context.ldt ||</span>
<span class="p_add">+			     seg &gt;= child-&gt;mm-&gt;context.ldt-&gt;size))</span>
 			addr = -1L; /* bogus selector, access would fault */
 		else {
<span class="p_del">-			desc = child-&gt;mm-&gt;context.ldt + seg;</span>
<span class="p_add">+			desc = &amp;child-&gt;mm-&gt;context.ldt-&gt;entries[seg];</span>
 			base = get_desc_base(desc);
 
 			/* 16-bit code segment? */
<span class="p_header">diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c</span>
<span class="p_header">index 9f3706e..e8177b1 100644</span>
<span class="p_header">--- a/arch/x86/kernel/tsc.c</span>
<span class="p_header">+++ b/arch/x86/kernel/tsc.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/hypervisor.h&gt;
 #include &lt;asm/nmi.h&gt;
 #include &lt;asm/x86_init.h&gt;
<span class="p_add">+#include &lt;asm/geode.h&gt;</span>
 
 unsigned int __read_mostly cpu_khz;	/* TSC clocks / usec, not used here */
 EXPORT_SYMBOL(cpu_khz);
<span class="p_chunk">@@ -802,15 +803,17 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(mark_tsc_unstable);</span>
 
 static void __init check_system_tsc_reliable(void)
 {
<span class="p_del">-#ifdef CONFIG_MGEODE_LX</span>
<span class="p_del">-	/* RTSC counts during suspend */</span>
<span class="p_add">+#if defined(CONFIG_MGEODEGX1) || defined(CONFIG_MGEODE_LX) || defined(CONFIG_X86_GENERIC)</span>
<span class="p_add">+	if (is_geode_lx()) {</span>
<span class="p_add">+		/* RTSC counts during suspend */</span>
 #define RTSC_SUSP 0x100
<span class="p_del">-	unsigned long res_low, res_high;</span>
<span class="p_add">+		unsigned long res_low, res_high;</span>
 
<span class="p_del">-	rdmsr_safe(MSR_GEODE_BUSCONT_CONF0, &amp;res_low, &amp;res_high);</span>
<span class="p_del">-	/* Geode_LX - the OLPC CPU has a very reliable TSC */</span>
<span class="p_del">-	if (res_low &amp; RTSC_SUSP)</span>
<span class="p_del">-		tsc_clocksource_reliable = 1;</span>
<span class="p_add">+		rdmsr_safe(MSR_GEODE_BUSCONT_CONF0, &amp;res_low, &amp;res_high);</span>
<span class="p_add">+		/* Geode_LX - the OLPC CPU has a very reliable TSC */</span>
<span class="p_add">+		if (res_low &amp; RTSC_SUSP)</span>
<span class="p_add">+			tsc_clocksource_reliable = 1;</span>
<span class="p_add">+	}</span>
 #endif
 	if (boot_cpu_has(X86_FEATURE_TSC_RELIABLE))
 		tsc_clocksource_reliable = 1;
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 4a949c7..cac7b2b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -326,12 +326,6 @@</span> <span class="p_context"> static u64 __get_spte_lockless(u64 *sptep)</span>
 {
 	return ACCESS_ONCE(*sptep);
 }
<span class="p_del">-</span>
<span class="p_del">-static bool __check_direct_spte_mmio_pf(u64 spte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* It is valid if the spte is zapped. */</span>
<span class="p_del">-	return spte == 0ull;</span>
<span class="p_del">-}</span>
 #else
 union split_spte {
 	struct {
<span class="p_chunk">@@ -436,23 +430,6 @@</span> <span class="p_context"> retry:</span>
 
 	return spte.spte;
 }
<span class="p_del">-</span>
<span class="p_del">-static bool __check_direct_spte_mmio_pf(u64 spte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	union split_spte sspte = (union split_spte)spte;</span>
<span class="p_del">-	u32 high_mmio_mask = shadow_mmio_mask &gt;&gt; 32;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* It is valid if the spte is zapped. */</span>
<span class="p_del">-	if (spte == 0ull)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* It is valid if the spte is being zapped. */</span>
<span class="p_del">-	if (sspte.spte_low == 0ull &amp;&amp;</span>
<span class="p_del">-	    (sspte.spte_high &amp; high_mmio_mask) == high_mmio_mask)</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
 #endif
 
 static bool spte_has_volatile_bits(u64 spte)
<span class="p_chunk">@@ -2895,21 +2872,6 @@</span> <span class="p_context"> static bool quickly_check_mmio_pf(struct kvm_vcpu *vcpu, u64 addr, bool direct)</span>
 	return vcpu_match_mmio_gva(vcpu, addr);
 }
 
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * On direct hosts, the last spte is only allows two states</span>
<span class="p_del">- * for mmio page fault:</span>
<span class="p_del">- *   - It is the mmio spte</span>
<span class="p_del">- *   - It is zapped or it is being zapped.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This function completely checks the spte when the last spte</span>
<span class="p_del">- * is not the mmio spte.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool check_direct_spte_mmio_pf(u64 spte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __check_direct_spte_mmio_pf(spte);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static u64 walk_shadow_page_get_mmio_spte(struct kvm_vcpu *vcpu, u64 addr)
 {
 	struct kvm_shadow_walk_iterator iterator;
<span class="p_chunk">@@ -2951,13 +2913,6 @@</span> <span class="p_context"> int handle_mmio_page_fault_common(struct kvm_vcpu *vcpu, u64 addr, bool direct)</span>
 	}
 
 	/*
<span class="p_del">-	 * It&#39;s ok if the gva is remapped by other cpus on shadow guest,</span>
<span class="p_del">-	 * it&#39;s a BUG if the gfn is not a mmio page.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (direct &amp;&amp; !check_direct_spte_mmio_pf(spte))</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
 	 * If the page table is zapped by other cpus, let CPU fault again on
 	 * the address.
 	 */
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index bb179cc..0e3289b 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -1885,6 +1885,8 @@</span> <span class="p_context"> int kvm_get_msr_common(struct kvm_vcpu *vcpu, u32 msr, u64 *pdata)</span>
 	case MSR_IA32_LASTINTFROMIP:
 	case MSR_IA32_LASTINTTOIP:
 	case MSR_K8_SYSCFG:
<span class="p_add">+	case MSR_K8_TSEG_ADDR:</span>
<span class="p_add">+	case MSR_K8_TSEG_MASK:</span>
 	case MSR_K7_HWCR:
 	case MSR_VM_HSAVE_PA:
 	case MSR_P6_PERFCTR0:
<span class="p_header">diff --git a/arch/x86/math-emu/fpu_entry.c b/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_header">index 7718541..dab1f8b 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_header">+++ b/arch/x86/math-emu/fpu_entry.c</span>
<span class="p_chunk">@@ -28,7 +28,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/regset.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
 #include &lt;asm/user.h&gt;
 #include &lt;asm/i387.h&gt;
 
<span class="p_chunk">@@ -184,7 +183,7 @@</span> <span class="p_context"> void math_emulate(struct math_emu_info *info)</span>
 			math_abort(FPU_info, SIGILL);
 		}
 
<span class="p_del">-		code_descriptor = LDT_DESCRIPTOR(FPU_CS);</span>
<span class="p_add">+		code_descriptor = FPU_get_ldt_descriptor(FPU_CS);</span>
 		if (SEG_D_SIZE(code_descriptor)) {
 			/* The above test may be wrong, the book is not clear */
 			/* Segmented 32 bit protected mode */
<span class="p_header">diff --git a/arch/x86/math-emu/fpu_system.h b/arch/x86/math-emu/fpu_system.h</span>
<span class="p_header">index 2c61441..d342fce 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/fpu_system.h</span>
<span class="p_header">+++ b/arch/x86/math-emu/fpu_system.h</span>
<span class="p_chunk">@@ -16,9 +16,24 @@</span> <span class="p_context"></span>
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/mm.h&gt;
 
<span class="p_del">-/* s is always from a cpu register, and the cpu does bounds checking</span>
<span class="p_del">- * during register load --&gt; no further bounds checks needed */</span>
<span class="p_del">-#define LDT_DESCRIPTOR(s)	(((struct desc_struct *)current-&gt;mm-&gt;context.ldt)[(s) &gt;&gt; 3])</span>
<span class="p_add">+#include &lt;asm/desc.h&gt;</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct desc_struct FPU_get_ldt_descriptor(unsigned seg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static struct desc_struct zero_desc;</span>
<span class="p_add">+	struct desc_struct ret = zero_desc;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_MODIFY_LDT_SYSCALL</span>
<span class="p_add">+	seg &gt;&gt;= 3;</span>
<span class="p_add">+	mutex_lock(&amp;current-&gt;mm-&gt;context.lock);</span>
<span class="p_add">+	if (current-&gt;mm-&gt;context.ldt &amp;&amp; seg &lt; current-&gt;mm-&gt;context.ldt-&gt;size)</span>
<span class="p_add">+		ret = current-&gt;mm-&gt;context.ldt-&gt;entries[seg];</span>
<span class="p_add">+	mutex_unlock(&amp;current-&gt;mm-&gt;context.lock);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define SEG_D_SIZE(x)		((x).b &amp; (3 &lt;&lt; 21))
 #define SEG_G_BIT(x)		((x).b &amp; (1 &lt;&lt; 23))
 #define SEG_GRANULARITY(x)	(((x).b &amp; (1 &lt;&lt; 23)) ? 4096 : 1)
<span class="p_header">diff --git a/arch/x86/math-emu/get_address.c b/arch/x86/math-emu/get_address.c</span>
<span class="p_header">index 6ef5e99..8300db7 100644</span>
<span class="p_header">--- a/arch/x86/math-emu/get_address.c</span>
<span class="p_header">+++ b/arch/x86/math-emu/get_address.c</span>
<span class="p_chunk">@@ -20,7 +20,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/stddef.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
<span class="p_del">-#include &lt;asm/desc.h&gt;</span>
 
 #include &quot;fpu_system.h&quot;
 #include &quot;exception.h&quot;
<span class="p_chunk">@@ -158,7 +157,7 @@</span> <span class="p_context"> static long pm_address(u_char FPU_modrm, u_char segment,</span>
 		addr-&gt;selector = PM_REG_(segment);
 	}
 
<span class="p_del">-	descriptor = LDT_DESCRIPTOR(PM_REG_(segment));</span>
<span class="p_add">+	descriptor = FPU_get_ldt_descriptor(addr-&gt;selector);</span>
 	base_address = SEG_BASE_ADDR(descriptor);
 	address = base_address + offset;
 	limit = base_address
<span class="p_header">diff --git a/arch/x86/power/cpu.c b/arch/x86/power/cpu.c</span>
<span class="p_header">index 43c9f6a..bc21909 100644</span>
<span class="p_header">--- a/arch/x86/power/cpu.c</span>
<span class="p_header">+++ b/arch/x86/power/cpu.c</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/xcr.h&gt;
 #include &lt;asm/suspend.h&gt;
 #include &lt;asm/debugreg.h&gt;
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
 
 #ifdef CONFIG_X86_32
 static struct saved_context saved_context;
<span class="p_chunk">@@ -147,7 +148,7 @@</span> <span class="p_context"> static void fix_processor_context(void)</span>
 	syscall_init();				/* This sets MSR_*STAR and related */
 #endif
 	load_TR_desc();				/* This does ltr */
<span class="p_del">-	load_LDT(&amp;current-&gt;active_mm-&gt;context);	/* This does lldt */</span>
<span class="p_add">+	load_mm_ldt(current-&gt;active_mm);	/* This does lldt */</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/auxdisplay/ks0108.c b/drivers/auxdisplay/ks0108.c</span>
<span class="p_header">index 5b93852..0d75285 100644</span>
<span class="p_header">--- a/drivers/auxdisplay/ks0108.c</span>
<span class="p_header">+++ b/drivers/auxdisplay/ks0108.c</span>
<span class="p_chunk">@@ -139,6 +139,7 @@</span> <span class="p_context"> static int __init ks0108_init(void)</span>
 
 	ks0108_pardevice = parport_register_device(ks0108_parport, KS0108_NAME,
 		NULL, NULL, NULL, PARPORT_DEV_EXCL, NULL);
<span class="p_add">+	parport_put_port(ks0108_parport);</span>
 	if (ks0108_pardevice == NULL) {
 		printk(KERN_ERR KS0108_NAME &quot;: ERROR: &quot;
 			&quot;parport didn&#39;t register new device\n&quot;);
<span class="p_header">diff --git a/drivers/base/devres.c b/drivers/base/devres.c</span>
<span class="p_header">index 65cd748..cc956a4 100644</span>
<span class="p_header">--- a/drivers/base/devres.c</span>
<span class="p_header">+++ b/drivers/base/devres.c</span>
<span class="p_chunk">@@ -254,10 +254,10 @@</span> <span class="p_context"> void * devres_get(struct device *dev, void *new_res,</span>
 	if (!dr) {
 		add_dr(dev, &amp;new_dr-&gt;node);
 		dr = new_dr;
<span class="p_del">-		new_dr = NULL;</span>
<span class="p_add">+		new_res = NULL;</span>
 	}
 	spin_unlock_irqrestore(&amp;dev-&gt;devres_lock, flags);
<span class="p_del">-	devres_free(new_dr);</span>
<span class="p_add">+	devres_free(new_res);</span>
 
 	return dr-&gt;data;
 }
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index 7a24895..ba8f361 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -311,9 +311,7 @@</span> <span class="p_context"> int platform_device_add(struct platform_device *pdev)</span>
  failed:
 	while (--i &gt;= 0) {
 		struct resource *r = &amp;pdev-&gt;resource[i];
<span class="p_del">-		unsigned long type = resource_type(r);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (type == IORESOURCE_MEM || type == IORESOURCE_IO)</span>
<span class="p_add">+		if (r-&gt;parent)</span>
 			release_resource(r);
 	}
 
<span class="p_chunk">@@ -338,9 +336,7 @@</span> <span class="p_context"> void platform_device_del(struct platform_device *pdev)</span>
 
 		for (i = 0; i &lt; pdev-&gt;num_resources; i++) {
 			struct resource *r = &amp;pdev-&gt;resource[i];
<span class="p_del">-			unsigned long type = resource_type(r);</span>
<span class="p_del">-</span>
<span class="p_del">-			if (type == IORESOURCE_MEM || type == IORESOURCE_IO)</span>
<span class="p_add">+			if (r-&gt;parent)</span>
 				release_resource(r);
 		}
 	}
<span class="p_header">diff --git a/drivers/crypto/ixp4xx_crypto.c b/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_header">index 4c20c5b..8e9a8f0 100644</span>
<span class="p_header">--- a/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_header">+++ b/drivers/crypto/ixp4xx_crypto.c</span>
<span class="p_chunk">@@ -914,7 +914,6 @@</span> <span class="p_context"> static int ablk_perform(struct ablkcipher_request *req, int encrypt)</span>
 		crypt-&gt;mode |= NPE_OP_NOT_IN_PLACE;
 		/* This was never tested by Intel
 		 * for more than one dst buffer, I think. */
<span class="p_del">-		BUG_ON(req-&gt;dst-&gt;length &lt; nbytes);</span>
 		req_ctx-&gt;dst = NULL;
 		if (!chainup_buffers(dev, req-&gt;dst, nbytes, &amp;dst_hook,
 					flags, DMA_FROM_DEVICE))
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_execbuffer.c b/drivers/gpu/drm/i915/i915_gem_execbuffer.c</span>
<span class="p_header">index a0b69ae0..9b9f447 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_execbuffer.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_execbuffer.c</span>
<span class="p_chunk">@@ -950,13 +950,13 @@</span> <span class="p_context"> i915_gem_execbuffer_move_to_active(struct list_head *objects,</span>
 		  u32 old_write = obj-&gt;base.write_domain;
 
 
<span class="p_add">+		obj-&gt;dirty = 1; /* be paranoid  */</span>
 		obj-&gt;base.read_domains = obj-&gt;base.pending_read_domains;
 		obj-&gt;base.write_domain = obj-&gt;base.pending_write_domain;
 		obj-&gt;fenced_gpu_access = obj-&gt;pending_fenced_gpu_access;
 
 		i915_gem_object_move_to_active(obj, ring, seqno);
 		if (obj-&gt;base.write_domain) {
<span class="p_del">-			obj-&gt;dirty = 1;</span>
 			obj-&gt;pending_gpu_write = true;
 			list_move_tail(&amp;obj-&gt;gpu_write_list,
 				       &amp;ring-&gt;gpu_write_list);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">index 21e689d..87a677e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_chunk">@@ -3399,6 +3399,14 @@</span> <span class="p_context"> void radeon_combios_asic_init(struct drm_device *dev)</span>
 	    rdev-&gt;pdev-&gt;subsystem_device == 0x30ae)
 		return;
 
<span class="p_add">+	/* quirk for rs4xx HP Compaq dc5750 Small Form Factor to make it resume</span>
<span class="p_add">+	 * - it hangs on resume inside the dynclk 1 table.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rdev-&gt;family == CHIP_RS480 &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;subsystem_vendor == 0x103c &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;subsystem_device == 0x280a)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* DYN CLK 1 */
 	table = combios_get_table_offset(dev, COMBIOS_DYN_CLK_1_TABLE);
 	if (table)
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">index 683cede1..6303fc8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_connectors.c</span>
<span class="p_chunk">@@ -82,6 +82,11 @@</span> <span class="p_context"> void radeon_connector_hotplug(struct drm_connector *connector)</span>
 			if (!radeon_hpd_sense(rdev, radeon_connector-&gt;hpd.hpd)) {
 				drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
 			} else if (radeon_dp_needs_link_train(radeon_connector)) {
<span class="p_add">+				/* Don&#39;t try to start link training before we</span>
<span class="p_add">+				 * have the dpcd */</span>
<span class="p_add">+				if (!radeon_dp_getdpcd(radeon_connector))</span>
<span class="p_add">+					return;</span>
<span class="p_add">+</span>
 				/* set it to OFF so that drm_helper_connector_dpms()
 				 * won&#39;t return immediately since the current state
 				 * is ON at this point.
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs.h b/drivers/infiniband/core/uverbs.h</span>
<span class="p_header">index 5bcb2af..228af18 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs.h</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs.h</span>
<span class="p_chunk">@@ -69,7 +69,7 @@</span> <span class="p_context"></span>
  */
 
 struct ib_uverbs_device {
<span class="p_del">-	struct kref				ref;</span>
<span class="p_add">+	atomic_t				refcount;</span>
 	int					num_comp_vectors;
 	struct completion			comp;
 	struct device			       *dev;
<span class="p_chunk">@@ -78,6 +78,7 @@</span> <span class="p_context"> struct ib_uverbs_device {</span>
 	struct cdev			        cdev;
 	struct rb_root				xrcd_tree;
 	struct mutex				xrcd_tree_mutex;
<span class="p_add">+	struct kobject				kobj;</span>
 };
 
 struct ib_uverbs_event_file {
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_cmd.c b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">index a8445b8..3be21aa 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_cmd.c</span>
<span class="p_chunk">@@ -1979,6 +1979,12 @@</span> <span class="p_context"> ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,</span>
 		next-&gt;send_flags = user_wr-&gt;send_flags;
 
 		if (is_ud) {
<span class="p_add">+			if (next-&gt;opcode != IB_WR_SEND &amp;&amp;</span>
<span class="p_add">+			    next-&gt;opcode != IB_WR_SEND_WITH_IMM) {</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				goto out_put;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			next-&gt;wr.ud.ah = idr_read_ah(user_wr-&gt;wr.ud.ah,
 						     file-&gt;ucontext);
 			if (!next-&gt;wr.ud.ah) {
<span class="p_chunk">@@ -2015,9 +2021,11 @@</span> <span class="p_context"> ssize_t ib_uverbs_post_send(struct ib_uverbs_file *file,</span>
 					user_wr-&gt;wr.atomic.compare_add;
 				next-&gt;wr.atomic.swap = user_wr-&gt;wr.atomic.swap;
 				next-&gt;wr.atomic.rkey = user_wr-&gt;wr.atomic.rkey;
<span class="p_add">+			case IB_WR_SEND:</span>
 				break;
 			default:
<span class="p_del">-				break;</span>
<span class="p_add">+				ret = -EINVAL;</span>
<span class="p_add">+				goto out_put;</span>
 			}
 		}
 
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index 9379b97..f07c6e3 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -117,14 +117,18 @@</span> <span class="p_context"> static ssize_t (*uverbs_cmd_table[])(struct ib_uverbs_file *file,</span>
 static void ib_uverbs_add_one(struct ib_device *device);
 static void ib_uverbs_remove_one(struct ib_device *device);
 
<span class="p_del">-static void ib_uverbs_release_dev(struct kref *ref)</span>
<span class="p_add">+static void ib_uverbs_release_dev(struct kobject *kobj)</span>
 {
 	struct ib_uverbs_device *dev =
<span class="p_del">-		container_of(ref, struct ib_uverbs_device, ref);</span>
<span class="p_add">+		container_of(kobj, struct ib_uverbs_device, kobj);</span>
 
<span class="p_del">-	complete(&amp;dev-&gt;comp);</span>
<span class="p_add">+	kfree(dev);</span>
 }
 
<span class="p_add">+static struct kobj_type ib_uverbs_dev_ktype = {</span>
<span class="p_add">+	.release = ib_uverbs_release_dev,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static void ib_uverbs_release_event_file(struct kref *ref)
 {
 	struct ib_uverbs_event_file *file =
<span class="p_chunk">@@ -273,13 +277,19 @@</span> <span class="p_context"> static int ib_uverbs_cleanup_ucontext(struct ib_uverbs_file *file,</span>
 	return context-&gt;device-&gt;dealloc_ucontext(context);
 }
 
<span class="p_add">+static void ib_uverbs_comp_dev(struct ib_uverbs_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	complete(&amp;dev-&gt;comp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void ib_uverbs_release_file(struct kref *ref)
 {
 	struct ib_uverbs_file *file =
 		container_of(ref, struct ib_uverbs_file, ref);
 
 	module_put(file-&gt;device-&gt;ib_dev-&gt;owner);
<span class="p_del">-	kref_put(&amp;file-&gt;device-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;file-&gt;device-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(file-&gt;device);</span>
 
 	kfree(file);
 }
<span class="p_chunk">@@ -621,9 +631,7 @@</span> <span class="p_context"> static int ib_uverbs_open(struct inode *inode, struct file *filp)</span>
 	int ret;
 
 	dev = container_of(inode-&gt;i_cdev, struct ib_uverbs_device, cdev);
<span class="p_del">-	if (dev)</span>
<span class="p_del">-		kref_get(&amp;dev-&gt;ref);</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (!atomic_inc_not_zero(&amp;dev-&gt;refcount))</span>
 		return -ENXIO;
 
 	if (!try_module_get(dev-&gt;ib_dev-&gt;owner)) {
<span class="p_chunk">@@ -644,6 +652,7 @@</span> <span class="p_context"> static int ib_uverbs_open(struct inode *inode, struct file *filp)</span>
 	mutex_init(&amp;file-&gt;mutex);
 
 	filp-&gt;private_data = file;
<span class="p_add">+	kobject_get(&amp;dev-&gt;kobj);</span>
 
 	return nonseekable_open(inode, filp);
 
<span class="p_chunk">@@ -651,13 +660,16 @@</span> <span class="p_context"> err_module:</span>
 	module_put(dev-&gt;ib_dev-&gt;owner);
 
 err:
<span class="p_del">-	kref_put(&amp;dev-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;dev-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(dev);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
 static int ib_uverbs_close(struct inode *inode, struct file *filp)
 {
 	struct ib_uverbs_file *file = filp-&gt;private_data;
<span class="p_add">+	struct ib_uverbs_device *dev = file-&gt;device;</span>
 
 	ib_uverbs_cleanup_ucontext(file, file-&gt;ucontext);
 
<span class="p_chunk">@@ -665,6 +677,7 @@</span> <span class="p_context"> static int ib_uverbs_close(struct inode *inode, struct file *filp)</span>
 		kref_put(&amp;file-&gt;async_file-&gt;ref, ib_uverbs_release_event_file);
 
 	kref_put(&amp;file-&gt;ref, ib_uverbs_release_file);
<span class="p_add">+	kobject_put(&amp;dev-&gt;kobj);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -760,10 +773,11 @@</span> <span class="p_context"> static void ib_uverbs_add_one(struct ib_device *device)</span>
 	if (!uverbs_dev)
 		return;
 
<span class="p_del">-	kref_init(&amp;uverbs_dev-&gt;ref);</span>
<span class="p_add">+	atomic_set(&amp;uverbs_dev-&gt;refcount, 1);</span>
 	init_completion(&amp;uverbs_dev-&gt;comp);
 	uverbs_dev-&gt;xrcd_tree = RB_ROOT;
 	mutex_init(&amp;uverbs_dev-&gt;xrcd_tree_mutex);
<span class="p_add">+	kobject_init(&amp;uverbs_dev-&gt;kobj, &amp;ib_uverbs_dev_ktype);</span>
 
 	spin_lock(&amp;map_lock);
 	devnum = find_first_zero_bit(dev_map, IB_UVERBS_MAX_DEVICES);
<span class="p_chunk">@@ -790,6 +804,7 @@</span> <span class="p_context"> static void ib_uverbs_add_one(struct ib_device *device)</span>
 	cdev_init(&amp;uverbs_dev-&gt;cdev, NULL);
 	uverbs_dev-&gt;cdev.owner = THIS_MODULE;
 	uverbs_dev-&gt;cdev.ops = device-&gt;mmap ? &amp;uverbs_mmap_fops : &amp;uverbs_fops;
<span class="p_add">+	uverbs_dev-&gt;cdev.kobj.parent = &amp;uverbs_dev-&gt;kobj;</span>
 	kobject_set_name(&amp;uverbs_dev-&gt;cdev.kobj, &quot;uverbs%d&quot;, uverbs_dev-&gt;devnum);
 	if (cdev_add(&amp;uverbs_dev-&gt;cdev, base, 1))
 		goto err_cdev;
<span class="p_chunk">@@ -820,9 +835,10 @@</span> <span class="p_context"> err_cdev:</span>
 		clear_bit(devnum, overflow_map);
 
 err:
<span class="p_del">-	kref_put(&amp;uverbs_dev-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;uverbs_dev-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(uverbs_dev);</span>
 	wait_for_completion(&amp;uverbs_dev-&gt;comp);
<span class="p_del">-	kfree(uverbs_dev);</span>
<span class="p_add">+	kobject_put(&amp;uverbs_dev-&gt;kobj);</span>
 	return;
 }
 
<span class="p_chunk">@@ -842,9 +858,10 @@</span> <span class="p_context"> static void ib_uverbs_remove_one(struct ib_device *device)</span>
 	else
 		clear_bit(uverbs_dev-&gt;devnum - IB_UVERBS_MAX_DEVICES, overflow_map);
 
<span class="p_del">-	kref_put(&amp;uverbs_dev-&gt;ref, ib_uverbs_release_dev);</span>
<span class="p_add">+	if (atomic_dec_and_test(&amp;uverbs_dev-&gt;refcount))</span>
<span class="p_add">+		ib_uverbs_comp_dev(uverbs_dev);</span>
 	wait_for_completion(&amp;uverbs_dev-&gt;comp);
<span class="p_del">-	kfree(uverbs_dev);</span>
<span class="p_add">+	kobject_put(&amp;uverbs_dev-&gt;kobj);</span>
 }
 
 static char *uverbs_devnode(struct device *dev, mode_t *mode)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/ah.c b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">index 4b8f9c4..5426ccf 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/ah.c</span>
<span class="p_chunk">@@ -169,9 +169,13 @@</span> <span class="p_context"> int mlx4_ib_query_ah(struct ib_ah *ibah, struct ib_ah_attr *ah_attr)</span>
 	enum rdma_link_layer ll;
 
 	memset(ah_attr, 0, sizeof *ah_attr);
<span class="p_del">-	ah_attr-&gt;sl = be32_to_cpu(ah-&gt;av.ib.sl_tclass_flowlabel) &gt;&gt; 28;</span>
 	ah_attr-&gt;port_num = be32_to_cpu(ah-&gt;av.ib.port_pd) &gt;&gt; 24;
 	ll = rdma_port_get_link_layer(ibah-&gt;device, ah_attr-&gt;port_num);
<span class="p_add">+	if (ll == IB_LINK_LAYER_ETHERNET)</span>
<span class="p_add">+		ah_attr-&gt;sl = be32_to_cpu(ah-&gt;av.eth.sl_tclass_flowlabel) &gt;&gt; 29;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ah_attr-&gt;sl = be32_to_cpu(ah-&gt;av.ib.sl_tclass_flowlabel) &gt;&gt; 28;</span>
<span class="p_add">+</span>
 	ah_attr-&gt;dlid = ll == IB_LINK_LAYER_INFINIBAND ? be16_to_cpu(ah-&gt;av.ib.dlid) : 0;
 	if (ah-&gt;av.ib.stat_rate)
 		ah_attr-&gt;static_rate = ah-&gt;av.ib.stat_rate - MLX4_STAT_RATE_OFFSET;
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib.h b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">index 4c2b079..c0b72a6 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib.h</span>
<span class="p_chunk">@@ -1421,6 +1421,10 @@</span> <span class="p_context"> extern struct mutex qib_mutex;</span>
 			qib_get_unit_name((dd)-&gt;unit), ##__VA_ARGS__); \
 	} while (0)
 
<span class="p_add">+#define qib_dev_warn(dd, fmt, ...) \</span>
<span class="p_add">+	dev_warn(&amp;(dd)-&gt;pcidev-&gt;dev, &quot;%s: &quot; fmt, \</span>
<span class="p_add">+		qib_get_unit_name((dd)-&gt;unit), ##__VA_ARGS__)</span>
<span class="p_add">+</span>
 #define qib_dev_porterr(dd, port, fmt, ...) \
 	do { \
 		dev_err(&amp;(dd)-&gt;pcidev-&gt;dev, &quot;%s: IB%u:%u &quot; fmt, \
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_keys.c b/drivers/infiniband/hw/qib/qib_keys.c</span>
<span class="p_header">index 8fd19a4..ca6e6cf 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_keys.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_keys.c</span>
<span class="p_chunk">@@ -69,6 +69,10 @@</span> <span class="p_context"> int qib_alloc_lkey(struct qib_lkey_table *rkt, struct qib_mregion *mr)</span>
 	 * unrestricted LKEY.
 	 */
 	rkt-&gt;gen++;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * bits are capped in qib_verbs.c to insure enough bits</span>
<span class="p_add">+	 * for generation number</span>
<span class="p_add">+	 */</span>
 	mr-&gt;lkey = (r &lt;&lt; (32 - ib_qib_lkey_table_size)) |
 		((((1 &lt;&lt; (24 - ib_qib_lkey_table_size)) - 1) &amp; rkt-&gt;gen)
 		 &lt;&lt; 8);
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs.c b/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_header">index a894762..c51a6f9 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs.c</span>
<span class="p_chunk">@@ -40,6 +40,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/rculist.h&gt;
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/random.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
 
 #include &quot;qib.h&quot;
 #include &quot;qib_common.h&quot;
<span class="p_chunk">@@ -2035,10 +2036,16 @@</span> <span class="p_context"> int qib_register_ib_device(struct qib_devdata *dd)</span>
 	 * the LKEY).  The remaining bits act as a generation number or tag.
 	 */
 	spin_lock_init(&amp;dev-&gt;lk_table.lock);
<span class="p_add">+	/* insure generation is at least 4 bits see keys.c */</span>
<span class="p_add">+	if (ib_qib_lkey_table_size &gt; MAX_LKEY_TABLE_BITS) {</span>
<span class="p_add">+		qib_dev_warn(dd, &quot;lkey bits %u too large, reduced to %u\n&quot;,</span>
<span class="p_add">+			ib_qib_lkey_table_size, MAX_LKEY_TABLE_BITS);</span>
<span class="p_add">+		ib_qib_lkey_table_size = MAX_LKEY_TABLE_BITS;</span>
<span class="p_add">+	}</span>
 	dev-&gt;lk_table.max = 1 &lt;&lt; ib_qib_lkey_table_size;
 	lk_tab_size = dev-&gt;lk_table.max * sizeof(*dev-&gt;lk_table.table);
 	dev-&gt;lk_table.table = (struct qib_mregion **)
<span class="p_del">-		__get_free_pages(GFP_KERNEL, get_order(lk_tab_size));</span>
<span class="p_add">+		vmalloc(lk_tab_size);</span>
 	if (dev-&gt;lk_table.table == NULL) {
 		ret = -ENOMEM;
 		goto err_lk;
<span class="p_chunk">@@ -2208,7 +2215,7 @@</span> <span class="p_context"> err_tx:</span>
 					sizeof(struct qib_pio_header),
 				  dev-&gt;pio_hdrs, dev-&gt;pio_hdrs_phys);
 err_hdrs:
<span class="p_del">-	free_pages((unsigned long) dev-&gt;lk_table.table, get_order(lk_tab_size));</span>
<span class="p_add">+	vfree(dev-&gt;lk_table.table);</span>
 err_lk:
 	kfree(dev-&gt;qp_table);
 err_qpt:
<span class="p_chunk">@@ -2262,7 +2269,6 @@</span> <span class="p_context"> void qib_unregister_ib_device(struct qib_devdata *dd)</span>
 					sizeof(struct qib_pio_header),
 				  dev-&gt;pio_hdrs, dev-&gt;pio_hdrs_phys);
 	lk_tab_size = dev-&gt;lk_table.max * sizeof(*dev-&gt;lk_table.table);
<span class="p_del">-	free_pages((unsigned long) dev-&gt;lk_table.table,</span>
<span class="p_del">-		   get_order(lk_tab_size));</span>
<span class="p_add">+	vfree(dev-&gt;lk_table.table);</span>
 	kfree(dev-&gt;qp_table);
 }
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_verbs.h b/drivers/infiniband/hw/qib/qib_verbs.h</span>
<span class="p_header">index 0c19ef0..66f7f62 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_verbs.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_verbs.h</span>
<span class="p_chunk">@@ -622,6 +622,8 @@</span> <span class="p_context"> struct qib_qpn_table {</span>
 	struct qpn_map map[QPNMAP_ENTRIES];
 };
 
<span class="p_add">+#define MAX_LKEY_TABLE_BITS 23</span>
<span class="p_add">+</span>
 struct qib_lkey_table {
 	spinlock_t lock; /* protect changes in this struct */
 	u32 next;               /* next unused index (speeds search) */
<span class="p_header">diff --git a/drivers/input/evdev.c b/drivers/input/evdev.c</span>
<span class="p_header">index 4cf2534..f55a3cf 100644</span>
<span class="p_header">--- a/drivers/input/evdev.c</span>
<span class="p_header">+++ b/drivers/input/evdev.c</span>
<span class="p_chunk">@@ -126,19 +126,14 @@</span> <span class="p_context"> static int evdev_flush(struct file *file, fl_owner_t id)</span>
 {
 	struct evdev_client *client = file-&gt;private_data;
 	struct evdev *evdev = client-&gt;evdev;
<span class="p_del">-	int retval;</span>
 
<span class="p_del">-	retval = mutex_lock_interruptible(&amp;evdev-&gt;mutex);</span>
<span class="p_del">-	if (retval)</span>
<span class="p_del">-		return retval;</span>
<span class="p_add">+	mutex_lock(&amp;evdev-&gt;mutex);</span>
 
<span class="p_del">-	if (!evdev-&gt;exist)</span>
<span class="p_del">-		retval = -ENODEV;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		retval = input_flush_device(&amp;evdev-&gt;handle, file);</span>
<span class="p_add">+	if (evdev-&gt;exist)</span>
<span class="p_add">+		input_flush_device(&amp;evdev-&gt;handle, file);</span>
 
 	mutex_unlock(&amp;evdev-&gt;mutex);
<span class="p_del">-	return retval;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void evdev_free(struct device *dev)
<span class="p_header">diff --git a/drivers/macintosh/windfarm_core.c b/drivers/macintosh/windfarm_core.c</span>
<span class="p_header">index ce88979..004fa10 100644</span>
<span class="p_header">--- a/drivers/macintosh/windfarm_core.c</span>
<span class="p_header">+++ b/drivers/macintosh/windfarm_core.c</span>
<span class="p_chunk">@@ -421,7 +421,7 @@</span> <span class="p_context"> int wf_unregister_client(struct notifier_block *nb)</span>
 {
 	mutex_lock(&amp;wf_lock);
 	blocking_notifier_chain_unregister(&amp;wf_client_list, nb);
<span class="p_del">-	wf_client_count++;</span>
<span class="p_add">+	wf_client_count--;</span>
 	if (wf_client_count == 0)
 		wf_stop_thread();
 	mutex_unlock(&amp;wf_lock);
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index ea8a181..d7e9242 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -5384,9 +5384,9 @@</span> <span class="p_context"> static int get_bitmap_file(struct mddev * mddev, void __user * arg)</span>
 	int err = -ENOMEM;
 
 	if (md_allow_write(mddev))
<span class="p_del">-		file = kmalloc(sizeof(*file), GFP_NOIO);</span>
<span class="p_add">+		file = kzalloc(sizeof(*file), GFP_NOIO);</span>
 	else
<span class="p_del">-		file = kmalloc(sizeof(*file), GFP_KERNEL);</span>
<span class="p_add">+		file = kzalloc(sizeof(*file), GFP_KERNEL);</span>
 
 	if (!file)
 		goto out;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-internal.h b/drivers/md/persistent-data/dm-btree-internal.h</span>
<span class="p_header">index acba54e..f8458ca 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-internal.h</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-internal.h</span>
<span class="p_chunk">@@ -134,4 +134,10 @@</span> <span class="p_context"> int lower_bound(struct btree_node *n, uint64_t key);</span>
 
 extern struct dm_block_validator btree_node_validator;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Value type for upper levels of multi-level btrees.</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern void init_le64_type(struct dm_transaction_manager *tm,</span>
<span class="p_add">+			   struct dm_btree_value_type *vt);</span>
<span class="p_add">+</span>
 #endif	/* DM_BTREE_INTERNAL_H */
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index 6e79c11..294eb5b 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -544,14 +544,6 @@</span> <span class="p_context"> static int remove_raw(struct shadow_spine *s, struct dm_btree_info *info,</span>
 	return r;
 }
 
<span class="p_del">-static struct dm_btree_value_type le64_type = {</span>
<span class="p_del">-	.context = NULL,</span>
<span class="p_del">-	.size = sizeof(__le64),</span>
<span class="p_del">-	.inc = NULL,</span>
<span class="p_del">-	.dec = NULL,</span>
<span class="p_del">-	.equal = NULL</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 int dm_btree_remove(struct dm_btree_info *info, dm_block_t root,
 		    uint64_t *keys, dm_block_t *new_root)
 {
<span class="p_chunk">@@ -559,12 +551,14 @@</span> <span class="p_context"> int dm_btree_remove(struct dm_btree_info *info, dm_block_t root,</span>
 	int index = 0, r = 0;
 	struct shadow_spine spine;
 	struct btree_node *n;
<span class="p_add">+	struct dm_btree_value_type le64_vt;</span>
 
<span class="p_add">+	init_le64_type(info-&gt;tm, &amp;le64_vt);</span>
 	init_shadow_spine(&amp;spine, info);
 	for (level = 0; level &lt; info-&gt;levels; level++) {
 		r = remove_raw(&amp;spine, info,
 			       (level == last_level ?
<span class="p_del">-				&amp;info-&gt;value_type : &amp;le64_type),</span>
<span class="p_add">+				&amp;info-&gt;value_type : &amp;le64_vt),</span>
 			       root, keys[level], (unsigned *)&amp;index);
 		if (r &lt; 0)
 			break;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-spine.c b/drivers/md/persistent-data/dm-btree-spine.c</span>
<span class="p_header">index 2f0805c..f6cb762 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-spine.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-spine.c</span>
<span class="p_chunk">@@ -242,3 +242,40 @@</span> <span class="p_context"> int shadow_root(struct shadow_spine *s)</span>
 {
 	return s-&gt;root;
 }
<span class="p_add">+</span>
<span class="p_add">+static void le64_inc(void *context, void *value_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dm_transaction_manager *tm = context;</span>
<span class="p_add">+	__le64 v_le;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;v_le, value_le, sizeof(v_le));</span>
<span class="p_add">+	dm_tm_inc(tm, le64_to_cpu(v_le));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void le64_dec(void *context, void *value_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dm_transaction_manager *tm = context;</span>
<span class="p_add">+	__le64 v_le;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;v_le, value_le, sizeof(v_le));</span>
<span class="p_add">+	dm_tm_dec(tm, le64_to_cpu(v_le));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int le64_equal(void *context, void *value1_le, void *value2_le)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__le64 v1_le, v2_le;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy(&amp;v1_le, value1_le, sizeof(v1_le));</span>
<span class="p_add">+	memcpy(&amp;v2_le, value2_le, sizeof(v2_le));</span>
<span class="p_add">+	return v1_le == v2_le;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void init_le64_type(struct dm_transaction_manager *tm,</span>
<span class="p_add">+		    struct dm_btree_value_type *vt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vt-&gt;context = tm;</span>
<span class="p_add">+	vt-&gt;size = sizeof(__le64);</span>
<span class="p_add">+	vt-&gt;inc = le64_inc;</span>
<span class="p_add">+	vt-&gt;dec = le64_dec;</span>
<span class="p_add">+	vt-&gt;equal = le64_equal;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 18f37e0..62f297a 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -647,12 +647,7 @@</span> <span class="p_context"> static int insert(struct dm_btree_info *info, dm_block_t root,</span>
 	struct btree_node *n;
 	struct dm_btree_value_type le64_type;
 
<span class="p_del">-	le64_type.context = NULL;</span>
<span class="p_del">-	le64_type.size = sizeof(__le64);</span>
<span class="p_del">-	le64_type.inc = NULL;</span>
<span class="p_del">-	le64_type.dec = NULL;</span>
<span class="p_del">-	le64_type.equal = NULL;</span>
<span class="p_del">-</span>
<span class="p_add">+	init_le64_type(info-&gt;tm, &amp;le64_type);</span>
 	init_shadow_spine(&amp;spine, info);
 
 	for (level = 0; level &lt; (info-&gt;levels - 1); level++) {
<span class="p_header">diff --git a/drivers/md/raid1.c b/drivers/md/raid1.c</span>
<span class="p_header">index 6e7b002..a5f284d 100644</span>
<span class="p_header">--- a/drivers/md/raid1.c</span>
<span class="p_header">+++ b/drivers/md/raid1.c</span>
<span class="p_chunk">@@ -1208,6 +1208,7 @@</span> <span class="p_context"> static void error(struct mddev *mddev, struct md_rdev *rdev)</span>
 {
 	char b[BDEVNAME_SIZE];
 	struct r1conf *conf = mddev-&gt;private;
<span class="p_add">+	unsigned long flags;</span>
 
 	/*
 	 * If it is not operational, then we have already marked it as dead
<span class="p_chunk">@@ -1227,14 +1228,13 @@</span> <span class="p_context"> static void error(struct mddev *mddev, struct md_rdev *rdev)</span>
 		return;
 	}
 	set_bit(Blocked, &amp;rdev-&gt;flags);
<span class="p_add">+	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	if (test_and_clear_bit(In_sync, &amp;rdev-&gt;flags)) {
<span class="p_del">-		unsigned long flags;</span>
<span class="p_del">-		spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 		mddev-&gt;degraded++;
 		set_bit(Faulty, &amp;rdev-&gt;flags);
<span class="p_del">-		spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);</span>
 	} else
 		set_bit(Faulty, &amp;rdev-&gt;flags);
<span class="p_add">+	spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);</span>
 	/*
 	 * if recovery is running, make sure it aborts.
 	 */
<span class="p_chunk">@@ -1292,7 +1292,10 @@</span> <span class="p_context"> static int raid1_spare_active(struct mddev *mddev)</span>
 	 * Find all failed disks within the RAID1 configuration 
 	 * and mark them readable.
 	 * Called under mddev lock, so rcu protection not needed.
<span class="p_add">+	 * device_lock used to avoid races with raid1_end_read_request</span>
<span class="p_add">+	 * which expects &#39;In_sync&#39; flags and -&gt;degraded to be consistent.</span>
 	 */
<span class="p_add">+	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	for (i = 0; i &lt; conf-&gt;raid_disks; i++) {
 		struct md_rdev *rdev = conf-&gt;mirrors[i].rdev;
 		if (rdev
<span class="p_chunk">@@ -1302,7 +1305,6 @@</span> <span class="p_context"> static int raid1_spare_active(struct mddev *mddev)</span>
 			sysfs_notify_dirent_safe(rdev-&gt;sysfs_state);
 		}
 	}
<span class="p_del">-	spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);</span>
 	mddev-&gt;degraded -= count;
 	spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
 
<span class="p_header">diff --git a/drivers/media/rc/rc-main.c b/drivers/media/rc/rc-main.c</span>
<span class="p_header">index a47ba33..2be51c8 100644</span>
<span class="p_header">--- a/drivers/media/rc/rc-main.c</span>
<span class="p_header">+++ b/drivers/media/rc/rc-main.c</span>
<span class="p_chunk">@@ -945,9 +945,6 @@</span> <span class="p_context"> static int rc_dev_uevent(struct device *device, struct kobj_uevent_env *env)</span>
 {
 	struct rc_dev *dev = to_rc_dev(device);
 
<span class="p_del">-	if (!dev || !dev-&gt;input_dev)</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_del">-</span>
 	if (dev-&gt;rc_map.name)
 		ADD_HOTPLUG_VAR(&quot;NAME=%s&quot;, dev-&gt;rc_map.name);
 	if (dev-&gt;driver_name)
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index 5af2a8f..9145834c 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -861,6 +861,23 @@</span> <span class="p_context"> static void bond_mc_swap(struct bonding *bond, struct slave *new_active,</span>
 	}
 }
 
<span class="p_add">+static struct slave *bond_get_old_active(struct bonding *bond,</span>
<span class="p_add">+					 struct slave *new_active)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct slave *slave;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	bond_for_each_slave(bond, slave, i) {</span>
<span class="p_add">+		if (slave == new_active)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!compare_ether_addr(bond-&gt;dev-&gt;dev_addr, slave-&gt;dev-&gt;dev_addr))</span>
<span class="p_add">+			return slave;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * bond_do_fail_over_mac
  *
<span class="p_chunk">@@ -898,6 +915,9 @@</span> <span class="p_context"> static void bond_do_fail_over_mac(struct bonding *bond,</span>
 		write_unlock_bh(&amp;bond-&gt;curr_slave_lock);
 		read_unlock(&amp;bond-&gt;lock);
 
<span class="p_add">+		if (!old_active)</span>
<span class="p_add">+			old_active = bond_get_old_active(bond, new_active);</span>
<span class="p_add">+</span>
 		if (old_active) {
 			memcpy(tmp_mac, new_active-&gt;dev-&gt;dev_addr, ETH_ALEN);
 			memcpy(saddr.sa_data, old_active-&gt;dev-&gt;dev_addr,
<span class="p_header">diff --git a/drivers/net/virtio_net.c b/drivers/net/virtio_net.c</span>
<span class="p_header">index f13a673..715e5c4 100644</span>
<span class="p_header">--- a/drivers/net/virtio_net.c</span>
<span class="p_header">+++ b/drivers/net/virtio_net.c</span>
<span class="p_chunk">@@ -981,9 +981,9 @@</span> <span class="p_context"> static int virtnet_probe(struct virtio_device *vdev)</span>
 	/* Do we support &quot;hardware&quot; checksums? */
 	if (virtio_has_feature(vdev, VIRTIO_NET_F_CSUM)) {
 		/* This opens up the world of extra features. */
<span class="p_del">-		dev-&gt;hw_features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;</span>
<span class="p_add">+		dev-&gt;hw_features |= NETIF_F_HW_CSUM | NETIF_F_SG;</span>
 		if (csum)
<span class="p_del">-			dev-&gt;features |= NETIF_F_HW_CSUM|NETIF_F_SG|NETIF_F_FRAGLIST;</span>
<span class="p_add">+			dev-&gt;features |= NETIF_F_HW_CSUM | NETIF_F_SG;</span>
 
 		if (virtio_has_feature(vdev, VIRTIO_NET_F_GSO)) {
 			dev-&gt;hw_features |= NETIF_F_TSO | NETIF_F_UFO
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index ec347d2..e813eff 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -313,6 +313,8 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
 	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
 	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
<span class="p_add">+	{RTL_USB_DEVICE(0x0846, 0x9043, rtl92cu_hal_cfg)}, /*NG WNA1000Mv2*/</span>
<span class="p_add">+	{RTL_USB_DEVICE(0x0b05, 0x17ba, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/</span>
 	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&amp;C*/
 	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
 	{RTL_USB_DEVICE(0x0df6, 0x005c, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
<span class="p_header">diff --git a/drivers/of/address.c b/drivers/of/address.c</span>
<span class="p_header">index 53a613f..39016a0 100644</span>
<span class="p_header">--- a/drivers/of/address.c</span>
<span class="p_header">+++ b/drivers/of/address.c</span>
<span class="p_chunk">@@ -604,10 +604,10 @@</span> <span class="p_context"> struct device_node *of_find_matching_node_by_address(struct device_node *from,</span>
 	struct resource res;
 
 	while (dn) {
<span class="p_del">-		if (of_address_to_resource(dn, 0, &amp;res))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (res.start == base_address)</span>
<span class="p_add">+		if (!of_address_to_resource(dn, 0, &amp;res) &amp;&amp;</span>
<span class="p_add">+		    res.start == base_address)</span>
 			return dn;
<span class="p_add">+</span>
 		dn = of_find_matching_node(dn, matches);
 	}
 
<span class="p_header">diff --git a/drivers/pci/access.c b/drivers/pci/access.c</span>
<span class="p_header">index fdaa42a..fac01f8 100644</span>
<span class="p_header">--- a/drivers/pci/access.c</span>
<span class="p_header">+++ b/drivers/pci/access.c</span>
<span class="p_chunk">@@ -355,6 +355,56 @@</span> <span class="p_context"> static const struct pci_vpd_ops pci_vpd_pci22_ops = {</span>
 	.release = pci_vpd_pci22_release,
 };
 
<span class="p_add">+static ssize_t pci_vpd_f0_read(struct pci_dev *dev, loff_t pos, size_t count,</span>
<span class="p_add">+			       void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *tdev = pci_get_slot(dev-&gt;bus, PCI_SLOT(dev-&gt;devfn));</span>
<span class="p_add">+	ssize_t ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tdev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pci_read_vpd(tdev, pos, count, arg);</span>
<span class="p_add">+	pci_dev_put(tdev);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static ssize_t pci_vpd_f0_write(struct pci_dev *dev, loff_t pos, size_t count,</span>
<span class="p_add">+				const void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *tdev = pci_get_slot(dev-&gt;bus, PCI_SLOT(dev-&gt;devfn));</span>
<span class="p_add">+	ssize_t ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tdev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pci_write_vpd(tdev, pos, count, arg);</span>
<span class="p_add">+	pci_dev_put(tdev);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct pci_vpd_ops pci_vpd_f0_ops = {</span>
<span class="p_add">+	.read = pci_vpd_f0_read,</span>
<span class="p_add">+	.write = pci_vpd_f0_write,</span>
<span class="p_add">+	.release = pci_vpd_pci22_release,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int pci_vpd_f0_dev_check(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *tdev = pci_get_slot(dev-&gt;bus, PCI_SLOT(dev-&gt;devfn));</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tdev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	if (!tdev-&gt;vpd || !tdev-&gt;multifunction ||</span>
<span class="p_add">+	    dev-&gt;class != tdev-&gt;class || dev-&gt;vendor != tdev-&gt;vendor ||</span>
<span class="p_add">+	    dev-&gt;device != tdev-&gt;device)</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	pci_dev_put(tdev);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int pci_vpd_pci22_init(struct pci_dev *dev)
 {
 	struct pci_vpd_pci22 *vpd;
<span class="p_chunk">@@ -363,12 +413,21 @@</span> <span class="p_context"> int pci_vpd_pci22_init(struct pci_dev *dev)</span>
 	cap = pci_find_capability(dev, PCI_CAP_ID_VPD);
 	if (!cap)
 		return -ENODEV;
<span class="p_add">+	if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_VPD_REF_F0) {</span>
<span class="p_add">+		int ret = pci_vpd_f0_dev_check(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+	}</span>
 	vpd = kzalloc(sizeof(*vpd), GFP_ATOMIC);
 	if (!vpd)
 		return -ENOMEM;
 
 	vpd-&gt;base.len = PCI_VPD_PCI22_SIZE;
<span class="p_del">-	vpd-&gt;base.ops = &amp;pci_vpd_pci22_ops;</span>
<span class="p_add">+	if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_VPD_REF_F0)</span>
<span class="p_add">+		vpd-&gt;base.ops = &amp;pci_vpd_f0_ops;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		vpd-&gt;base.ops = &amp;pci_vpd_pci22_ops;</span>
 	mutex_init(&amp;vpd-&gt;lock);
 	vpd-&gt;cap = cap;
 	vpd-&gt;busy = false;
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 481b184..93be760 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -1941,6 +1941,15 @@</span> <span class="p_context"> static void __devinit quirk_netmos(struct pci_dev *dev)</span>
 }
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_NETMOS, PCI_ANY_ID, quirk_netmos);
 
<span class="p_add">+static void quirk_f0_vpd_link(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((dev-&gt;class &gt;&gt; 8) != PCI_CLASS_NETWORK_ETHERNET ||</span>
<span class="p_add">+	    !dev-&gt;multifunction || !PCI_FUNC(dev-&gt;devfn))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	dev-&gt;dev_flags |= PCI_DEV_FLAGS_VPD_REF_F0;</span>
<span class="p_add">+}</span>
<span class="p_add">+DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_INTEL, PCI_ANY_ID, quirk_f0_vpd_link);</span>
<span class="p_add">+</span>
 static void __devinit quirk_e100_interrupt(struct pci_dev *dev)
 {
 	u16 command, pmcsr;
<span class="p_chunk">@@ -2875,8 +2884,9 @@</span> <span class="p_context"> static void __devinit fixup_ti816x_class(struct pci_dev* dev)</span>
 {
 	/* TI 816x devices do not have class code set when in PCIe boot mode */
 	if (dev-&gt;class == PCI_CLASS_NOT_DEFINED) {
<span class="p_del">-		dev_info(&amp;dev-&gt;dev, &quot;Setting PCI class for 816x PCIe device\n&quot;);</span>
<span class="p_del">-		dev-&gt;class = PCI_CLASS_MULTIMEDIA_VIDEO;</span>
<span class="p_add">+		dev-&gt;class = PCI_CLASS_MULTIMEDIA_VIDEO &lt;&lt; 8;</span>
<span class="p_add">+		dev_info(&amp;dev-&gt;dev, &quot;PCI class overridden (%#08x -&gt; %#08x)\n&quot;,</span>
<span class="p_add">+			 PCI_CLASS_NOT_DEFINED, dev-&gt;class);</span>
 	}
 }
 DECLARE_PCI_FIXUP_EARLY(PCI_VENDOR_ID_TI, 0xb800, fixup_ti816x_class);
<span class="p_header">diff --git a/drivers/scsi/libfc/fc_fcp.c b/drivers/scsi/libfc/fc_fcp.c</span>
<span class="p_header">index 221875e..735b324 100644</span>
<span class="p_header">--- a/drivers/scsi/libfc/fc_fcp.c</span>
<span class="p_header">+++ b/drivers/scsi/libfc/fc_fcp.c</span>
<span class="p_chunk">@@ -1029,11 +1029,26 @@</span> <span class="p_context"> restart:</span>
 		fc_fcp_pkt_hold(fsp);
 		spin_unlock_irqrestore(&amp;si-&gt;scsi_queue_lock, flags);
 
<span class="p_del">-		if (!fc_fcp_lock_pkt(fsp)) {</span>
<span class="p_add">+		spin_lock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
<span class="p_add">+		if (!(fsp-&gt;state &amp; FC_SRB_COMPL)) {</span>
<span class="p_add">+			fsp-&gt;state |= FC_SRB_COMPL;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * TODO: dropping scsi_pkt_lock and then reacquiring</span>
<span class="p_add">+			 * again around fc_fcp_cleanup_cmd() is required,</span>
<span class="p_add">+			 * since fc_fcp_cleanup_cmd() calls into</span>
<span class="p_add">+			 * fc_seq_set_resp() and that func preempts cpu using</span>
<span class="p_add">+			 * schedule. May be schedule and related code should be</span>
<span class="p_add">+			 * removed instead of unlocking here to avoid scheduling</span>
<span class="p_add">+			 * while atomic bug.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			spin_unlock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
<span class="p_add">+</span>
 			fc_fcp_cleanup_cmd(fsp, error);
<span class="p_add">+</span>
<span class="p_add">+			spin_lock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
 			fc_io_compl(fsp);
<span class="p_del">-			fc_fcp_unlock_pkt(fsp);</span>
 		}
<span class="p_add">+		spin_unlock_bh(&amp;fsp-&gt;scsi_pkt_lock);</span>
 
 		fc_fcp_pkt_release(fsp);
 		spin_lock_irqsave(&amp;si-&gt;scsi_queue_lock, flags);
<span class="p_header">diff --git a/drivers/scsi/libiscsi.c b/drivers/scsi/libiscsi.c</span>
<span class="p_header">index 2794a30..8771c03 100644</span>
<span class="p_header">--- a/drivers/scsi/libiscsi.c</span>
<span class="p_header">+++ b/drivers/scsi/libiscsi.c</span>
<span class="p_chunk">@@ -2906,10 +2906,10 @@</span> <span class="p_context"> void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)</span>
 {
 	struct iscsi_conn *conn = cls_conn-&gt;dd_data;
 	struct iscsi_session *session = conn-&gt;session;
<span class="p_del">-	unsigned long flags;</span>
 
 	del_timer_sync(&amp;conn-&gt;transport_timer);
 
<span class="p_add">+	mutex_lock(&amp;session-&gt;eh_mutex);</span>
 	spin_lock_bh(&amp;session-&gt;lock);
 	conn-&gt;c_stage = ISCSI_CONN_CLEANUP_WAIT;
 	if (session-&gt;leadconn == conn) {
<span class="p_chunk">@@ -2921,28 +2921,6 @@</span> <span class="p_context"> void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)</span>
 	}
 	spin_unlock_bh(&amp;session-&gt;lock);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Block until all in-progress commands for this connection</span>
<span class="p_del">-	 * time out or fail.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	for (;;) {</span>
<span class="p_del">-		spin_lock_irqsave(session-&gt;host-&gt;host_lock, flags);</span>
<span class="p_del">-		if (!session-&gt;host-&gt;host_busy) { /* OK for ERL == 0 */</span>
<span class="p_del">-			spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		spin_unlock_irqrestore(session-&gt;host-&gt;host_lock, flags);</span>
<span class="p_del">-		msleep_interruptible(500);</span>
<span class="p_del">-		iscsi_conn_printk(KERN_INFO, conn, &quot;iscsi conn_destroy(): &quot;</span>
<span class="p_del">-				  &quot;host_busy %d host_failed %d\n&quot;,</span>
<span class="p_del">-				  session-&gt;host-&gt;host_busy,</span>
<span class="p_del">-				  session-&gt;host-&gt;host_failed);</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * force eh_abort() to unblock</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		wake_up(&amp;conn-&gt;ehwait);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* flush queued up work because we free the connection below */
 	iscsi_suspend_tx(conn);
 
<span class="p_chunk">@@ -2955,6 +2933,7 @@</span> <span class="p_context"> void iscsi_conn_teardown(struct iscsi_cls_conn *cls_conn)</span>
 	if (session-&gt;leadconn == conn)
 		session-&gt;leadconn = NULL;
 	spin_unlock_bh(&amp;session-&gt;lock);
<span class="p_add">+	mutex_unlock(&amp;session-&gt;eh_mutex);</span>
 
 	iscsi_destroy_conn(cls_conn);
 }
<span class="p_header">diff --git a/drivers/spi/spi-pxa2xx.c b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">index dc25bee..2ecc2d6 100644</span>
<span class="p_header">--- a/drivers/spi/spi-pxa2xx.c</span>
<span class="p_header">+++ b/drivers/spi/spi-pxa2xx.c</span>
<span class="p_chunk">@@ -799,6 +799,10 @@</span> <span class="p_context"> static irqreturn_t ssp_int(int irq, void *dev_id)</span>
 	if (!(sccr1_reg &amp; SSCR1_TIE))
 		mask &amp;= ~SSSR_TFS;
 
<span class="p_add">+	/* Ignore RX timeout interrupt if it is disabled */</span>
<span class="p_add">+	if (!(sccr1_reg &amp; SSCR1_TINTE))</span>
<span class="p_add">+		mask &amp;= ~SSSR_TINT;</span>
<span class="p_add">+</span>
 	if (!(status &amp; mask))
 		return IRQ_NONE;
 
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index 59fb984..7c33cbb 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -979,7 +979,7 @@</span> <span class="p_context"> static int iscsit_handle_scsi_cmd(</span>
 		if (cmd-&gt;targ_xfer_tag == 0xFFFFFFFF)
 			cmd-&gt;targ_xfer_tag = conn-&gt;sess-&gt;targ_xfer_tag++;
 		spin_unlock_bh(&amp;conn-&gt;sess-&gt;ttt_lock);
<span class="p_del">-	} else if (hdr-&gt;flags &amp; ISCSI_FLAG_CMD_WRITE)</span>
<span class="p_add">+	} else</span>
 		cmd-&gt;targ_xfer_tag = 0xFFFFFFFF;
 	cmd-&gt;cmd_sn		= hdr-&gt;cmdsn;
 	cmd-&gt;exp_stat_sn	= hdr-&gt;exp_statsn;
<span class="p_header">diff --git a/drivers/target/target_core_device.c b/drivers/target/target_core_device.c</span>
<span class="p_header">index 6993961..c3cf95e 100644</span>
<span class="p_header">--- a/drivers/target/target_core_device.c</span>
<span class="p_header">+++ b/drivers/target/target_core_device.c</span>
<span class="p_chunk">@@ -668,11 +668,8 @@</span> <span class="p_context"> int target_report_luns(struct se_task *se_task)</span>
 	 * coming via a target_core_mod PASSTHROUGH op, and not through
 	 * a $FABRIC_MOD.  In that case, report LUN=0 only.
 	 */
<span class="p_del">-	if (!se_sess) {</span>
<span class="p_del">-		int_to_scsilun(0, (struct scsi_lun *)&amp;buf[offset]);</span>
<span class="p_del">-		lun_count = 1;</span>
<span class="p_add">+	if (!se_sess)</span>
 		goto done;
<span class="p_del">-	}</span>
 
 	spin_lock_irq(&amp;se_sess-&gt;se_node_acl-&gt;device_list_lock);
 	for (i = 0; i &lt; TRANSPORT_MAX_LUNS_PER_TPG; i++) {
<span class="p_chunk">@@ -699,6 +696,14 @@</span> <span class="p_context"> int target_report_luns(struct se_task *se_task)</span>
 	 * See SPC3 r07, page 159.
 	 */
 done:
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If no LUNs are accessible, report virtual LUN 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (lun_count == 0) {</span>
<span class="p_add">+		int_to_scsilun(0, (struct scsi_lun *)&amp;buf[offset]);</span>
<span class="p_add">+		lun_count = 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	lun_count *= 8;
 	buf[0] = ((lun_count &gt;&gt; 24) &amp; 0xff);
 	buf[1] = ((lun_count &gt;&gt; 16) &amp; 0xff);
<span class="p_header">diff --git a/drivers/tty/serial/8250_pnp.c b/drivers/tty/serial/8250_pnp.c</span>
<span class="p_header">index a2f2365..add2096 100644</span>
<span class="p_header">--- a/drivers/tty/serial/8250_pnp.c</span>
<span class="p_header">+++ b/drivers/tty/serial/8250_pnp.c</span>
<span class="p_chunk">@@ -42,6 +42,12 @@</span> <span class="p_context"> static const struct pnp_device_id pnp_dev_table[] = {</span>
 	{	&quot;AEI1240&quot;,		0	},
 	/* Rockwell 56K ACF II Fax+Data+Voice Modem */
 	{	&quot;AKY1021&quot;,		0 /*SPCI_FL_NO_SHIRQ*/	},
<span class="p_add">+	/*</span>
<span class="p_add">+	 * ALi Fast Infrared Controller</span>
<span class="p_add">+	 * Native driver (ali-ircc) is broken so at least</span>
<span class="p_add">+	 * it can be used with irtty-sir.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{	&quot;ALI5123&quot;,		0	},</span>
 	/* AZT3005 PnP SOUND DEVICE */
 	{	&quot;AZT4001&quot;,		0	},
 	/* Best Data Products Inc. Smart One 336F PnP Modem */
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 0276db3..478d71b 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -114,7 +114,7 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 				cfgno, inum, asnum, ep-&gt;desc.bEndpointAddress);
 		ep-&gt;ss_ep_comp.bmAttributes = 16;
 	} else if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc) &amp;&amp;
<span class="p_del">-			desc-&gt;bmAttributes &gt; 2) {</span>
<span class="p_add">+		   USB_SS_MULT(desc-&gt;bmAttributes) &gt; 3) {</span>
 		dev_warn(ddev, &quot;Isoc endpoint has Mult of %d in &quot;
 				&quot;config %d interface %d altsetting %d ep %d: &quot;
 				&quot;setting to 3\n&quot;, desc-&gt;bmAttributes + 1,
<span class="p_chunk">@@ -123,7 +123,8 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 	}
 
 	if (usb_endpoint_xfer_isoc(&amp;ep-&gt;desc))
<span class="p_del">-		max_tx = (desc-&gt;bMaxBurst + 1) * (desc-&gt;bmAttributes + 1) *</span>
<span class="p_add">+		max_tx = (desc-&gt;bMaxBurst + 1) *</span>
<span class="p_add">+			(USB_SS_MULT(desc-&gt;bmAttributes)) *</span>
 			usb_endpoint_maxp(&amp;ep-&gt;desc);
 	else if (usb_endpoint_xfer_int(&amp;ep-&gt;desc))
 		max_tx = usb_endpoint_maxp(&amp;ep-&gt;desc) *
<span class="p_header">diff --git a/drivers/usb/gadget/m66592-udc.c b/drivers/usb/gadget/m66592-udc.c</span>
<span class="p_header">index 9aa1cbb..9716d61 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/m66592-udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/m66592-udc.c</span>
<span class="p_chunk">@@ -1052,7 +1052,7 @@</span> <span class="p_context"> static void set_feature(struct m66592 *m66592, struct usb_ctrlrequest *ctrl)</span>
 				tmp = m66592_read(m66592, M66592_INTSTS0) &amp;
 								M66592_CTSQ;
 				udelay(1);
<span class="p_del">-			} while (tmp != M66592_CS_IDST || timeout-- &gt; 0);</span>
<span class="p_add">+			} while (tmp != M66592_CS_IDST &amp;&amp; timeout-- &gt; 0);</span>
 
 			if (tmp == M66592_CS_IDST)
 				m66592_bset(m66592,
<span class="p_header">diff --git a/drivers/usb/host/ehci-fsl.c b/drivers/usb/host/ehci-fsl.c</span>
<span class="p_header">index da487fd..cf995d4 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-fsl.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-fsl.c</span>
<span class="p_chunk">@@ -272,6 +272,10 @@</span> <span class="p_context"> static void ehci_fsl_usb_setup(struct ehci_hcd *ehci)</span>
 	out_be32(non_ehci + FSL_SOC_USB_SNOOP2, 0x80000000 | SNOOP_SIZE_2GB);
 #endif
 
<span class="p_add">+	/* Deal with USB erratum A-005275 */</span>
<span class="p_add">+	if (pdata-&gt;has_fsl_erratum_a005275 == 1)</span>
<span class="p_add">+		ehci-&gt;has_fsl_hs_errata = 1;</span>
<span class="p_add">+</span>
 	if ((pdata-&gt;operating_mode == FSL_USB2_DR_HOST) ||
 			(pdata-&gt;operating_mode == FSL_USB2_DR_OTG))
 		ehci_fsl_setup_phy(ehci, pdata-&gt;phy_mode, 0);
<span class="p_header">diff --git a/drivers/usb/host/ehci-hub.c b/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">index 4527b90..313a47d 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hub.c</span>
<span class="p_chunk">@@ -1049,6 +1049,13 @@</span> <span class="p_context"> static int ehci_hub_control (</span>
 				 */
 				ehci-&gt;reset_done [wIndex] = jiffies
 						+ msecs_to_jiffies (50);
<span class="p_add">+</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Force full-speed connect for FSL high-speed</span>
<span class="p_add">+				 * erratum; disable HS Chirp by setting PFSC bit</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (ehci_has_fsl_hs_errata(ehci))</span>
<span class="p_add">+					temp |= (1 &lt;&lt; PORTSC_FSL_PFSC);</span>
 			}
 			ehci_writel(ehci, temp, status_reg);
 			break;
<span class="p_header">diff --git a/drivers/usb/host/ehci-sysfs.c b/drivers/usb/host/ehci-sysfs.c</span>
<span class="p_header">index 14ced00..ddaaead 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-sysfs.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-sysfs.c</span>
<span class="p_chunk">@@ -29,7 +29,7 @@</span> <span class="p_context"> static ssize_t show_companion(struct device *dev,</span>
 	int			count = PAGE_SIZE;
 	char			*ptr = buf;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	nports = HCS_N_PORTS(ehci-&gt;hcs_params);
 
 	for (index = 0; index &lt; nports; ++index) {
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> static ssize_t store_companion(struct device *dev,</span>
 	struct ehci_hcd		*ehci;
 	int			portnum, new_owner;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	new_owner = PORT_OWNER;		/* Owned by companion */
 	if (sscanf(buf, &quot;%d&quot;, &amp;portnum) != 1)
 		return -EINVAL;
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> static ssize_t show_uframe_periodic_max(struct device *dev,</span>
 	struct ehci_hcd		*ehci;
 	int			n;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	n = scnprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, ehci-&gt;uframe_periodic_max);
 	return n;
 }
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static ssize_t store_uframe_periodic_max(struct device *dev,</span>
 	unsigned long		flags;
 	ssize_t			ret;
 
<span class="p_del">-	ehci = hcd_to_ehci(bus_to_hcd(dev_get_drvdata(dev)));</span>
<span class="p_add">+	ehci = hcd_to_ehci(dev_get_drvdata(dev));</span>
 	if (kstrtouint(buf, 0, &amp;uframe_periodic_max) &lt; 0)
 		return -EINVAL;
 
<span class="p_chunk">@@ -167,6 +167,9 @@</span> <span class="p_context"> static inline int create_sysfs_files(struct ehci_hcd *ehci)</span>
 	struct device	*controller = ehci_to_hcd(ehci)-&gt;self.controller;
 	int	i = 0;
 
<span class="p_add">+	if (dev_get_drvdata(controller) != ehci_to_hcd(ehci))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/* with integrated TT there is no companion! */
 	if (!ehci_is_TDI(ehci))
 		i = device_create_file(controller, &amp;dev_attr_companion);
<span class="p_chunk">@@ -182,6 +185,9 @@</span> <span class="p_context"> static inline void remove_sysfs_files(struct ehci_hcd *ehci)</span>
 {
 	struct device	*controller = ehci_to_hcd(ehci)-&gt;self.controller;
 
<span class="p_add">+	if (dev_get_drvdata(controller) != ehci_to_hcd(ehci))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/* with integrated TT there is no companion! */
 	if (!ehci_is_TDI(ehci))
 		device_remove_file(controller, &amp;dev_attr_companion);
<span class="p_header">diff --git a/drivers/usb/host/ehci.h b/drivers/usb/host/ehci.h</span>
<span class="p_header">index b65912d..bd8adbb 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci.h</span>
<span class="p_header">+++ b/drivers/usb/host/ehci.h</span>
<span class="p_chunk">@@ -136,6 +136,7 @@</span> <span class="p_context"> struct ehci_hcd {			/* one per controller */</span>
 	/* SILICON QUIRKS */
 	unsigned		no_selective_suspend:1;
 	unsigned		has_fsl_port_bug:1; /* FreeScale */
<span class="p_add">+	unsigned		has_fsl_hs_errata:1;	/* Freescale HS quirk */</span>
 	unsigned		big_endian_mmio:1;
 	unsigned		big_endian_desc:1;
 	unsigned		big_endian_capbase:1;
<span class="p_chunk">@@ -612,6 +613,17 @@</span> <span class="p_context"> ehci_port_speed(struct ehci_hcd *ehci, unsigned int portsc)</span>
 #define	ehci_has_fsl_portno_bug(e)		(0)
 #endif
 
<span class="p_add">+#define PORTSC_FSL_PFSC	24	/* Port Force Full-Speed Connect */</span>
<span class="p_add">+</span>
<span class="p_add">+#if defined(CONFIG_PPC_85xx)</span>
<span class="p_add">+/* Some Freescale processors have an erratum (USB A-005275) in which</span>
<span class="p_add">+ * incoming packets get corrupted in HS mode</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ehci_has_fsl_hs_errata(e)	((e)-&gt;has_fsl_hs_errata)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define ehci_has_fsl_hs_errata(e)	(0)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * While most USB host controllers implement their registers in
  * little-endian format, a minority (celleb companion chip) implement
<span class="p_header">diff --git a/drivers/usb/host/fsl-mph-dr-of.c b/drivers/usb/host/fsl-mph-dr-of.c</span>
<span class="p_header">index 5a42cf0..ac19ee5 100644</span>
<span class="p_header">--- a/drivers/usb/host/fsl-mph-dr-of.c</span>
<span class="p_header">+++ b/drivers/usb/host/fsl-mph-dr-of.c</span>
<span class="p_chunk">@@ -166,6 +166,10 @@</span> <span class="p_context"> static int __devinit fsl_usb2_mph_dr_of_probe(struct platform_device *ofdev)</span>
 
 	prop = of_get_property(np, &quot;phy_type&quot;, NULL);
 	pdata-&gt;phy_mode = determine_usb_phy(prop);
<span class="p_add">+	if (of_get_property(np, &quot;fsl,usb-erratum-a005275&quot;, NULL))</span>
<span class="p_add">+		pdata-&gt;has_fsl_erratum_a005275 = 1;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		pdata-&gt;has_fsl_erratum_a005275 = 0;</span>
 
 	for (i = 0; i &lt; ARRAY_SIZE(dev_data-&gt;drivers); i++) {
 		if (!dev_data-&gt;drivers[i])
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index d5d2af5..ab023b1 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1403,10 +1403,10 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 	 * use Event Data TRBs, and we don&#39;t chain in a link TRB on short
 	 * transfers, we&#39;re basically dividing by 1.
 	 *
<span class="p_del">-	 * xHCI 1.0 specification indicates that the Average TRB Length should</span>
<span class="p_del">-	 * be set to 8 for control endpoints.</span>
<span class="p_add">+	 * xHCI 1.0 and 1.1 specification indicates that the Average TRB Length</span>
<span class="p_add">+	 * should be set to 8 for control endpoints.</span>
 	 */
<span class="p_del">-	if (usb_endpoint_xfer_control(&amp;ep-&gt;desc) &amp;&amp; xhci-&gt;hci_version == 0x100)</span>
<span class="p_add">+	if (usb_endpoint_xfer_control(&amp;ep-&gt;desc) &amp;&amp; xhci-&gt;hci_version &gt;= 0x100)</span>
 		ep_ctx-&gt;tx_info |= cpu_to_le32(AVG_TRB_LENGTH_FOR_EP(8));
 	else
 		ep_ctx-&gt;tx_info |=
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index a47e29a..dc8e5a8 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -85,7 +85,7 @@</span> <span class="p_context"> dma_addr_t xhci_trb_virt_to_dma(struct xhci_segment *seg,</span>
 		return 0;
 	/* offset in TRBs */
 	segment_offset = trb - seg-&gt;trbs;
<span class="p_del">-	if (segment_offset &gt; TRBS_PER_SEGMENT)</span>
<span class="p_add">+	if (segment_offset &gt;= TRBS_PER_SEGMENT)</span>
 		return 0;
 	return seg-&gt;dma + (segment_offset * sizeof(*trb));
 }
<span class="p_chunk">@@ -350,6 +350,15 @@</span> <span class="p_context"> static int xhci_abort_cmd_ring(struct xhci_hcd *xhci)</span>
 	ret = handshake(xhci, &amp;xhci-&gt;op_regs-&gt;cmd_ring,
 			CMD_RING_RUNNING, 0, 5 * 1000 * 1000);
 	if (ret &lt; 0) {
<span class="p_add">+		/* we are about to kill xhci, give it one more chance */</span>
<span class="p_add">+		xhci_write_64(xhci, temp_64 | CMD_RING_ABORT,</span>
<span class="p_add">+			      &amp;xhci-&gt;op_regs-&gt;cmd_ring);</span>
<span class="p_add">+		udelay(1000);</span>
<span class="p_add">+		ret = handshake(xhci, &amp;xhci-&gt;op_regs-&gt;cmd_ring,</span>
<span class="p_add">+				CMD_RING_RUNNING, 0, 3 * 1000 * 1000);</span>
<span class="p_add">+		if (ret == 0)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
 		xhci_err(xhci, &quot;Stopped the command ring failed, &quot;
 				&quot;maybe the host is dead\n&quot;);
 		xhci-&gt;xhc_state |= XHCI_STATE_DYING;
<span class="p_chunk">@@ -3423,8 +3432,8 @@</span> <span class="p_context"> int xhci_queue_ctrl_tx(struct xhci_hcd *xhci, gfp_t mem_flags,</span>
 	if (start_cycle == 0)
 		field |= 0x1;
 
<span class="p_del">-	/* xHCI 1.0 6.4.1.2.1: Transfer Type field */</span>
<span class="p_del">-	if (xhci-&gt;hci_version == 0x100) {</span>
<span class="p_add">+	/* xHCI 1.0/1.1 6.4.1.2.1: Transfer Type field */</span>
<span class="p_add">+	if (xhci-&gt;hci_version &gt;= 0x100) {</span>
 		if (urb-&gt;transfer_buffer_length &gt; 0) {
 			if (setup-&gt;bRequestType &amp; USB_DIR_IN)
 				field |= TRB_TX_TYPE(TRB_DATA_IN);
<span class="p_header">diff --git a/drivers/usb/host/xhci.c b/drivers/usb/host/xhci.c</span>
<span class="p_header">index 950a8cc..2f51dec 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.c</span>
<span class="p_chunk">@@ -141,7 +141,8 @@</span> <span class="p_context"> static int xhci_start(struct xhci_hcd *xhci)</span>
 				&quot;waited %u microseconds.\n&quot;,
 				XHCI_MAX_HALT_USEC);
 	if (!ret)
<span class="p_del">-		xhci-&gt;xhc_state &amp;= ~XHCI_STATE_HALTED;</span>
<span class="p_add">+		xhci-&gt;xhc_state &amp;= ~(XHCI_STATE_HALTED | XHCI_STATE_DYING);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 8257d3b..4ffaa9d 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -629,6 +629,10 @@</span> <span class="p_context"> static struct usb_device_id id_table_combined [] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_NT_ORIONLXM_PID),
 		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },
 	{ USB_DEVICE(FTDI_VID, FTDI_SYNAPSE_SS200_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX2WI_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_CUSTOMWARE_MINIPLEX3_PID) },</span>
 	/*
 	 * ELV devices:
 	 */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index e4a57bb..7d11642 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -568,6 +568,14 @@</span> <span class="p_context"></span>
  */
 #define FTDI_SYNAPSE_SS200_PID 0x9090 /* SS200 - SNAP Stick 200 */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * CustomWare / ShipModul NMEA multiplexers product ids (FTDI_VID)</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX_PID	0xfd48	/* MiniPlex first generation NMEA Multiplexer */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX2_PID	0xfd49	/* MiniPlex-USB and MiniPlex-2 series */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX2WI_PID	0xfd4a	/* MiniPlex-2Wi */</span>
<span class="p_add">+#define FTDI_CUSTOMWARE_MINIPLEX3_PID	0xfd4b	/* MiniPlex-3 series */</span>
<span class="p_add">+</span>
 
 /********************************/
 /** third-party VID/PID combos **/
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 64ea95d..7e6d2ec 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -276,6 +276,10 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define ZTE_PRODUCT_MF622			0x0001
 #define ZTE_PRODUCT_MF628			0x0015
 #define ZTE_PRODUCT_MF626			0x0031
<span class="p_add">+#define ZTE_PRODUCT_ZM8620_X			0x0396</span>
<span class="p_add">+#define ZTE_PRODUCT_ME3620_MBIM			0x0426</span>
<span class="p_add">+#define ZTE_PRODUCT_ME3620_X			0x1432</span>
<span class="p_add">+#define ZTE_PRODUCT_ME3620_L			0x1433</span>
 #define ZTE_PRODUCT_CDMA_TECH			0xfffe
 #define ZTE_PRODUCT_AC8710			0xfff1
 #define ZTE_PRODUCT_AC2726			0xfff5
<span class="p_chunk">@@ -547,6 +551,18 @@</span> <span class="p_context"> static const struct option_blacklist_info zte_mc2716_z_blacklist = {</span>
 	.sendsetup = BIT(1) | BIT(2) | BIT(3),
 };
 
<span class="p_add">+static const struct option_blacklist_info zte_me3620_mbim_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(2) | BIT(3) | BIT(4),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct option_blacklist_info zte_me3620_xl_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(3) | BIT(4) | BIT(5),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct option_blacklist_info zte_zm8620_x_blacklist = {</span>
<span class="p_add">+	.reserved = BIT(3) | BIT(4) | BIT(5),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info huawei_cdc12_blacklist = {
 	.reserved = BIT(1) | BIT(2),
 };
<span class="p_chunk">@@ -1578,6 +1594,14 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	 .driver_info = (kernel_ulong_t)&amp;zte_ad3812_z_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MC2716, 0xff, 0xff, 0xff),
 	 .driver_info = (kernel_ulong_t)&amp;zte_mc2716_z_blacklist },
<span class="p_add">+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ME3620_L),</span>
<span class="p_add">+	 .driver_info = (kernel_ulong_t)&amp;zte_me3620_xl_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ME3620_MBIM),</span>
<span class="p_add">+	 .driver_info = (kernel_ulong_t)&amp;zte_me3620_mbim_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ME3620_X),</span>
<span class="p_add">+	 .driver_info = (kernel_ulong_t)&amp;zte_me3620_xl_blacklist },</span>
<span class="p_add">+	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_ZM8620_X),</span>
<span class="p_add">+	 .driver_info = (kernel_ulong_t)&amp;zte_zm8620_x_blacklist },</span>
 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x02, 0x01) },
 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x02, 0x05) },
 	{ USB_VENDOR_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0xff, 0x86, 0x10) },
<span class="p_header">diff --git a/drivers/usb/serial/sierra.c b/drivers/usb/serial/sierra.c</span>
<span class="p_header">index db9e54a..f34c0dd 100644</span>
<span class="p_header">--- a/drivers/usb/serial/sierra.c</span>
<span class="p_header">+++ b/drivers/usb/serial/sierra.c</span>
<span class="p_chunk">@@ -303,6 +303,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x1199, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&amp;direct_ip_interface_blacklist
 	},
<span class="p_add">+	{ USB_DEVICE(0x1199, 0x68AB) }, /* Sierra Wireless AR8550 */</span>
 	/* AT&amp;T Direct IP LTE modems */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x0F3D, 0x68AA, 0xFF, 0xFF, 0xFF),
 	  .driver_info = (kernel_ulong_t)&amp;direct_ip_interface_blacklist
<span class="p_header">diff --git a/drivers/usb/serial/whiteheat.c b/drivers/usb/serial/whiteheat.c</span>
<span class="p_header">index 5481809..75670b5 100644</span>
<span class="p_header">--- a/drivers/usb/serial/whiteheat.c</span>
<span class="p_header">+++ b/drivers/usb/serial/whiteheat.c</span>
<span class="p_chunk">@@ -143,6 +143,8 @@</span> <span class="p_context"> static int  whiteheat_firmware_download(struct usb_serial *serial,</span>
 static int  whiteheat_firmware_attach(struct usb_serial *serial);
 
 /* function prototypes for the Connect Tech WhiteHEAT serial converter */
<span class="p_add">+static int whiteheat_probe(struct usb_serial *serial,</span>
<span class="p_add">+				const struct usb_device_id *id);</span>
 static int  whiteheat_attach(struct usb_serial *serial);
 static void whiteheat_release(struct usb_serial *serial);
 static int  whiteheat_open(struct tty_struct *tty,
<span class="p_chunk">@@ -188,6 +190,7 @@</span> <span class="p_context"> static struct usb_serial_driver whiteheat_device = {</span>
 	.usb_driver =		&amp;whiteheat_driver,
 	.id_table =		id_table_std,
 	.num_ports =		4,
<span class="p_add">+	.probe =		whiteheat_probe,</span>
 	.attach =		whiteheat_attach,
 	.release =		whiteheat_release,
 	.open =			whiteheat_open,
<span class="p_chunk">@@ -387,6 +390,34 @@</span> <span class="p_context"> static int whiteheat_firmware_attach(struct usb_serial *serial)</span>
 /*****************************************************************************
  * Connect Tech&#39;s White Heat serial driver functions
  *****************************************************************************/
<span class="p_add">+</span>
<span class="p_add">+static int whiteheat_probe(struct usb_serial *serial,</span>
<span class="p_add">+				const struct usb_device_id *id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct usb_host_interface *iface_desc;</span>
<span class="p_add">+	struct usb_endpoint_descriptor *endpoint;</span>
<span class="p_add">+	size_t num_bulk_in = 0;</span>
<span class="p_add">+	size_t num_bulk_out = 0;</span>
<span class="p_add">+	size_t min_num_bulk;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	iface_desc = serial-&gt;interface-&gt;cur_altsetting;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; iface_desc-&gt;desc.bNumEndpoints; i++) {</span>
<span class="p_add">+		endpoint = &amp;iface_desc-&gt;endpoint[i].desc;</span>
<span class="p_add">+		if (usb_endpoint_is_bulk_in(endpoint))</span>
<span class="p_add">+			++num_bulk_in;</span>
<span class="p_add">+		if (usb_endpoint_is_bulk_out(endpoint))</span>
<span class="p_add">+			++num_bulk_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	min_num_bulk = COMMAND_PORT + 1;</span>
<span class="p_add">+	if (num_bulk_in &lt; min_num_bulk || num_bulk_out &lt; min_num_bulk)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int whiteheat_attach(struct usb_serial *serial)
 {
 	struct usb_serial_port *command_port;
<span class="p_header">diff --git a/drivers/xen/gntdev.c b/drivers/xen/gntdev.c</span>
<span class="p_header">index 080b186..01d1779 100644</span>
<span class="p_header">--- a/drivers/xen/gntdev.c</span>
<span class="p_header">+++ b/drivers/xen/gntdev.c</span>
<span class="p_chunk">@@ -493,11 +493,15 @@</span> <span class="p_context"> static int gntdev_release(struct inode *inode, struct file *flip)</span>
 
 	pr_debug(&quot;priv %p\n&quot;, priv);
 
<span class="p_add">+	spin_lock(&amp;priv-&gt;lock);</span>
 	while (!list_empty(&amp;priv-&gt;maps)) {
 		map = list_entry(priv-&gt;maps.next, struct grant_map, next);
 		list_del(&amp;map-&gt;next);
<span class="p_add">+		spin_unlock(&amp;priv-&gt;lock);</span>
 		gntdev_put_map(map);
<span class="p_add">+		spin_lock(&amp;priv-&gt;lock);</span>
 	}
<span class="p_add">+	spin_unlock(&amp;priv-&gt;lock);</span>
 
 	if (use_ptemod)
 		mmu_notifier_unregister(&amp;priv-&gt;mn, priv-&gt;mm);
<span class="p_header">diff --git a/fs/btrfs/extent_io.c b/fs/btrfs/extent_io.c</span>
<span class="p_header">index 05937a8..9a837a8 100644</span>
<span class="p_header">--- a/fs/btrfs/extent_io.c</span>
<span class="p_header">+++ b/fs/btrfs/extent_io.c</span>
<span class="p_chunk">@@ -2444,7 +2444,8 @@</span> <span class="p_context"> static int submit_extent_page(int rw, struct extent_io_tree *tree,</span>
 			      bio_end_io_t end_io_func,
 			      int mirror_num,
 			      unsigned long prev_bio_flags,
<span class="p_del">-			      unsigned long bio_flags)</span>
<span class="p_add">+			      unsigned long bio_flags,</span>
<span class="p_add">+			      bool force_bio_submit)</span>
 {
 	int ret = 0;
 	struct bio *bio;
<span class="p_chunk">@@ -2463,6 +2464,7 @@</span> <span class="p_context"> static int submit_extent_page(int rw, struct extent_io_tree *tree,</span>
 				sector;
 
 		if (prev_bio_flags != bio_flags || !contig ||
<span class="p_add">+		    force_bio_submit ||</span>
 		    (tree-&gt;ops &amp;&amp; tree-&gt;ops-&gt;merge_bio_hook &amp;&amp;
 		     tree-&gt;ops-&gt;merge_bio_hook(page, offset, page_size, bio,
 					       bio_flags)) ||
<span class="p_chunk">@@ -2519,7 +2521,8 @@</span> <span class="p_context"> static int __extent_read_full_page(struct extent_io_tree *tree,</span>
 				   struct page *page,
 				   get_extent_t *get_extent,
 				   struct bio **bio, int mirror_num,
<span class="p_del">-				   unsigned long *bio_flags)</span>
<span class="p_add">+				   unsigned long *bio_flags,</span>
<span class="p_add">+				   u64 *prev_em_start)</span>
 {
 	struct inode *inode = page-&gt;mapping-&gt;host;
 	u64 start = (u64)page-&gt;index &lt;&lt; PAGE_CACHE_SHIFT;
<span class="p_chunk">@@ -2575,6 +2578,8 @@</span> <span class="p_context"> static int __extent_read_full_page(struct extent_io_tree *tree,</span>
 		}
 	}
 	while (cur &lt;= end) {
<span class="p_add">+		bool force_bio_submit = false;</span>
<span class="p_add">+</span>
 		if (cur &gt;= last_byte) {
 			char *userpage;
 			struct extent_state *cached = NULL;
<span class="p_chunk">@@ -2621,6 +2626,49 @@</span> <span class="p_context"> static int __extent_read_full_page(struct extent_io_tree *tree,</span>
 		block_start = em-&gt;block_start;
 		if (test_bit(EXTENT_FLAG_PREALLOC, &amp;em-&gt;flags))
 			block_start = EXTENT_MAP_HOLE;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we have a file range that points to a compressed extent</span>
<span class="p_add">+		 * and it&#39;s followed by a consecutive file range that points to</span>
<span class="p_add">+		 * to the same compressed extent (possibly with a different</span>
<span class="p_add">+		 * offset and/or length, so it either points to the whole extent</span>
<span class="p_add">+		 * or only part of it), we must make sure we do not submit a</span>
<span class="p_add">+		 * single bio to populate the pages for the 2 ranges because</span>
<span class="p_add">+		 * this makes the compressed extent read zero out the pages</span>
<span class="p_add">+		 * belonging to the 2nd range. Imagine the following scenario:</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 *  File layout</span>
<span class="p_add">+		 *  [0 - 8K]                     [8K - 24K]</span>
<span class="p_add">+		 *    |                               |</span>
<span class="p_add">+		 *    |                               |</span>
<span class="p_add">+		 * points to extent X,         points to extent X,</span>
<span class="p_add">+		 * offset 4K, length of 8K     offset 0, length 16K</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * [extent X, compressed length = 4K uncompressed length = 16K]</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * If the bio to read the compressed extent covers both ranges,</span>
<span class="p_add">+		 * it will decompress extent X into the pages belonging to the</span>
<span class="p_add">+		 * first range and then it will stop, zeroing out the remaining</span>
<span class="p_add">+		 * pages that belong to the other range that points to extent X.</span>
<span class="p_add">+		 * So here we make sure we submit 2 bios, one for the first</span>
<span class="p_add">+		 * range and another one for the third range. Both will target</span>
<span class="p_add">+		 * the same physical extent from disk, but we can&#39;t currently</span>
<span class="p_add">+		 * make the compressed bio endio callback populate the pages</span>
<span class="p_add">+		 * for both ranges because each compressed bio is tightly</span>
<span class="p_add">+		 * coupled with a single extent map, and each range can have</span>
<span class="p_add">+		 * an extent map with a different offset value relative to the</span>
<span class="p_add">+		 * uncompressed data of our extent and different lengths. This</span>
<span class="p_add">+		 * is a corner case so we prioritize correctness over</span>
<span class="p_add">+		 * non-optimal behavior (submitting 2 bios for the same extent).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (test_bit(EXTENT_FLAG_COMPRESSED, &amp;em-&gt;flags) &amp;&amp;</span>
<span class="p_add">+		    prev_em_start &amp;&amp; *prev_em_start != (u64)-1 &amp;&amp;</span>
<span class="p_add">+		    *prev_em_start != em-&gt;orig_start)</span>
<span class="p_add">+			force_bio_submit = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (prev_em_start)</span>
<span class="p_add">+			*prev_em_start = em-&gt;orig_start;</span>
<span class="p_add">+</span>
 		free_extent_map(em);
 		em = NULL;
 
<span class="p_chunk">@@ -2675,7 +2723,8 @@</span> <span class="p_context"> static int __extent_read_full_page(struct extent_io_tree *tree,</span>
 					 bdev, bio, pnr,
 					 end_bio_extent_readpage, mirror_num,
 					 *bio_flags,
<span class="p_del">-					 this_bio_flag);</span>
<span class="p_add">+					 this_bio_flag,</span>
<span class="p_add">+					 force_bio_submit);</span>
 			nr++;
 			*bio_flags = this_bio_flag;
 		}
<span class="p_chunk">@@ -2701,7 +2750,7 @@</span> <span class="p_context"> int extent_read_full_page(struct extent_io_tree *tree, struct page *page,</span>
 	int ret;
 
 	ret = __extent_read_full_page(tree, page, get_extent, &amp;bio, mirror_num,
<span class="p_del">-				      &amp;bio_flags);</span>
<span class="p_add">+				      &amp;bio_flags, NULL);</span>
 	if (bio)
 		ret = submit_one_bio(READ, bio, mirror_num, bio_flags);
 	return ret;
<span class="p_chunk">@@ -2960,7 +3009,7 @@</span> <span class="p_context"> static int __extent_writepage(struct page *page, struct writeback_control *wbc,</span>
 						 sector, iosize, pg_offset,
 						 bdev, &amp;epd-&gt;bio, max_nr,
 						 end_bio_extent_writepage,
<span class="p_del">-						 0, 0, 0);</span>
<span class="p_add">+						 0, 0, 0, false);</span>
 			if (ret)
 				SetPageError(page);
 		}
<span class="p_chunk">@@ -3219,6 +3268,7 @@</span> <span class="p_context"> int extent_readpages(struct extent_io_tree *tree,</span>
 	struct bio *bio = NULL;
 	unsigned page_idx;
 	unsigned long bio_flags = 0;
<span class="p_add">+	u64 prev_em_start = (u64)-1;</span>
 
 	for (page_idx = 0; page_idx &lt; nr_pages; page_idx++) {
 		struct page *page = list_entry(pages-&gt;prev, struct page, lru);
<span class="p_chunk">@@ -3228,7 +3278,8 @@</span> <span class="p_context"> int extent_readpages(struct extent_io_tree *tree,</span>
 		if (!add_to_page_cache_lru(page, mapping,
 					page-&gt;index, GFP_NOFS)) {
 			__extent_read_full_page(tree, page, get_extent,
<span class="p_del">-						&amp;bio, 0, &amp;bio_flags);</span>
<span class="p_add">+						&amp;bio, 0, &amp;bio_flags,</span>
<span class="p_add">+						&amp;prev_em_start);</span>
 		}
 		page_cache_release(page);
 	}
<span class="p_chunk">@@ -3998,6 +4049,7 @@</span> <span class="p_context"> int read_extent_buffer_pages(struct extent_io_tree *tree,</span>
 	unsigned long num_pages;
 	struct bio *bio = NULL;
 	unsigned long bio_flags = 0;
<span class="p_add">+	u64 prev_em_start = (u64)-1;</span>
 
 	if (test_bit(EXTENT_BUFFER_UPTODATE, &amp;eb-&gt;bflags))
 		return 0;
<span class="p_chunk">@@ -4053,7 +4105,8 @@</span> <span class="p_context"> int read_extent_buffer_pages(struct extent_io_tree *tree,</span>
 			ClearPageError(page);
 			err = __extent_read_full_page(tree, page,
 						      get_extent, &amp;bio,
<span class="p_del">-						      mirror_num, &amp;bio_flags);</span>
<span class="p_add">+						      mirror_num, &amp;bio_flags,</span>
<span class="p_add">+						      &amp;prev_em_start);</span>
 			if (err)
 				ret = err;
 		} else {
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index 622d322..cb10cb9 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -3518,7 +3518,8 @@</span> <span class="p_context"> void btrfs_evict_inode(struct inode *inode)</span>
 		goto no_delete;
 	}
 	/* do we really want it for -&gt;i_nlink &gt; 0 and zero btrfs_root_refs? */
<span class="p_del">-	btrfs_wait_ordered_range(inode, 0, (u64)-1);</span>
<span class="p_add">+	if (!special_file(inode-&gt;i_mode))</span>
<span class="p_add">+		btrfs_wait_ordered_range(inode, 0, (u64)-1);</span>
 
 	if (root-&gt;fs_info-&gt;log_root_recovering) {
 		BUG_ON(!list_empty(&amp;BTRFS_I(inode)-&gt;i_orphan));
<span class="p_header">diff --git a/fs/ceph/super.c b/fs/ceph/super.c</span>
<span class="p_header">index 3c981db..8bfafe5 100644</span>
<span class="p_header">--- a/fs/ceph/super.c</span>
<span class="p_header">+++ b/fs/ceph/super.c</span>
<span class="p_chunk">@@ -361,8 +361,10 @@</span> <span class="p_context"> static int ceph_show_options(struct seq_file *m, struct vfsmount *mnt)</span>
 	if (opt-&gt;flags &amp; CEPH_OPT_NOCRC)
 		seq_puts(m, &quot;,nocrc&quot;);
 
<span class="p_del">-	if (opt-&gt;name)</span>
<span class="p_del">-		seq_printf(m, &quot;,name=%s&quot;, opt-&gt;name);</span>
<span class="p_add">+	if (opt-&gt;name) {</span>
<span class="p_add">+		seq_puts(m, &quot;,name=&quot;);</span>
<span class="p_add">+		seq_escape(m, opt-&gt;name, &quot;, \t\n\\&quot;);</span>
<span class="p_add">+	}</span>
 	if (opt-&gt;key)
 		seq_puts(m, &quot;,secret=&lt;hidden&gt;&quot;);
 
<span class="p_chunk">@@ -405,7 +407,7 @@</span> <span class="p_context"> static int ceph_show_options(struct seq_file *m, struct vfsmount *mnt)</span>
 	if (fsopt-&gt;max_readdir_bytes != CEPH_MAX_READDIR_BYTES_DEFAULT)
 		seq_printf(m, &quot;,readdir_max_bytes=%d&quot;, fsopt-&gt;max_readdir_bytes);
 	if (strcmp(fsopt-&gt;snapdir_name, CEPH_SNAPDIRNAME_DEFAULT))
<span class="p_del">-		seq_printf(m, &quot;,snapdirname=%s&quot;, fsopt-&gt;snapdir_name);</span>
<span class="p_add">+		seq_show_option(m, &quot;snapdirname&quot;, fsopt-&gt;snapdir_name);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c</span>
<span class="p_header">index b4675bd..af95386 100644</span>
<span class="p_header">--- a/fs/cifs/cifsencrypt.c</span>
<span class="p_header">+++ b/fs/cifs/cifsencrypt.c</span>
<span class="p_chunk">@@ -388,6 +388,48 @@</span> <span class="p_context"> find_domain_name(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	return 0;
 }
 
<span class="p_add">+/* Server has provided av pairs/target info in the type 2 challenge</span>
<span class="p_add">+ * packet and we have plucked it and stored within smb session.</span>
<span class="p_add">+ * We parse that blob here to find the server given timestamp</span>
<span class="p_add">+ * as part of ntlmv2 authentication (or local current time as</span>
<span class="p_add">+ * default in case of failure)</span>
<span class="p_add">+ */</span>
<span class="p_add">+static __le64</span>
<span class="p_add">+find_timestamp(struct cifs_ses *ses)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int attrsize;</span>
<span class="p_add">+	unsigned int type;</span>
<span class="p_add">+	unsigned int onesize = sizeof(struct ntlmssp2_name);</span>
<span class="p_add">+	unsigned char *blobptr;</span>
<span class="p_add">+	unsigned char *blobend;</span>
<span class="p_add">+	struct ntlmssp2_name *attrptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ses-&gt;auth_key.len || !ses-&gt;auth_key.response)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	blobptr = ses-&gt;auth_key.response;</span>
<span class="p_add">+	blobend = blobptr + ses-&gt;auth_key.len;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (blobptr + onesize &lt; blobend) {</span>
<span class="p_add">+		attrptr = (struct ntlmssp2_name *) blobptr;</span>
<span class="p_add">+		type = le16_to_cpu(attrptr-&gt;type);</span>
<span class="p_add">+		if (type == NTLMSSP_AV_EOL)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		blobptr += 2; /* advance attr type */</span>
<span class="p_add">+		attrsize = le16_to_cpu(attrptr-&gt;length);</span>
<span class="p_add">+		blobptr += 2; /* advance attr size */</span>
<span class="p_add">+		if (blobptr + attrsize &gt; blobend)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		if (type == NTLMSSP_AV_TIMESTAMP) {</span>
<span class="p_add">+			if (attrsize == sizeof(u64))</span>
<span class="p_add">+				return *((__le64 *)blobptr);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		blobptr += attrsize; /* advance attr value */</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int calc_ntlmv2_hash(struct cifs_ses *ses, char *ntlmv2_hash,
 			    const struct nls_table *nls_cp)
 {
<span class="p_chunk">@@ -544,6 +586,7 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 	struct ntlmv2_resp *buf;
 	char ntlmv2_hash[16];
 	unsigned char *tiblob = NULL; /* target info blob */
<span class="p_add">+	__le64 rsp_timestamp;</span>
 
 	if (ses-&gt;server-&gt;secType == RawNTLMSSP) {
 		if (!ses-&gt;domainName) {
<span class="p_chunk">@@ -561,6 +604,12 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 		}
 	}
 
<span class="p_add">+	/* Must be within 5 minutes of the server (or in range +/-2h</span>
<span class="p_add">+	 * in case of Mac OS X), so simply carry over server timestamp</span>
<span class="p_add">+	 * (as Windows 7 does)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rsp_timestamp = find_timestamp(ses);</span>
<span class="p_add">+</span>
 	baselen = CIFS_SESS_KEY_SIZE + sizeof(struct ntlmv2_resp);
 	tilen = ses-&gt;auth_key.len;
 	tiblob = ses-&gt;auth_key.response;
<span class="p_chunk">@@ -578,7 +627,8 @@</span> <span class="p_context"> setup_ntlmv2_rsp(struct cifs_ses *ses, const struct nls_table *nls_cp)</span>
 			(ses-&gt;auth_key.response + CIFS_SESS_KEY_SIZE);
 	buf-&gt;blob_signature = cpu_to_le32(0x00000101);
 	buf-&gt;reserved = 0;
<span class="p_del">-	buf-&gt;time = cpu_to_le64(cifs_UnixTimeToNT(CURRENT_TIME));</span>
<span class="p_add">+	buf-&gt;time = rsp_timestamp;</span>
<span class="p_add">+</span>
 	get_random_bytes(&amp;buf-&gt;client_chal, sizeof(buf-&gt;client_chal));
 	buf-&gt;reserved2 = 0;
 
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 25bb97f..d955b8e 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -381,10 +381,10 @@</span> <span class="p_context"> cifs_show_options(struct seq_file *s, struct vfsmount *m)</span>
 	if (cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER)
 		seq_printf(s, &quot;,multiuser&quot;);
 	else if (tcon-&gt;ses-&gt;user_name)
<span class="p_del">-		seq_printf(s, &quot;,username=%s&quot;, tcon-&gt;ses-&gt;user_name);</span>
<span class="p_add">+		seq_show_option(s, &quot;username&quot;, tcon-&gt;ses-&gt;user_name);</span>
 
 	if (tcon-&gt;ses-&gt;domainName)
<span class="p_del">-		seq_printf(s, &quot;,domain=%s&quot;, tcon-&gt;ses-&gt;domainName);</span>
<span class="p_add">+		seq_show_option(s, &quot;domain&quot;, tcon-&gt;ses-&gt;domainName);</span>
 
 	if (srcaddr-&gt;sa_family != AF_UNSPEC) {
 		struct sockaddr_in *saddr4;
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 8a35300..46265f5 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -2452,6 +2452,8 @@</span> <span class="p_context"> static int prepend_path(const struct path *path,</span>
 {
 	struct dentry *dentry = path-&gt;dentry;
 	struct vfsmount *vfsmnt = path-&gt;mnt;
<span class="p_add">+	char *orig_buffer = *buffer;</span>
<span class="p_add">+	int orig_len = *buflen;</span>
 	bool slash = false;
 	int error = 0;
 
<span class="p_chunk">@@ -2459,6 +2461,14 @@</span> <span class="p_context"> static int prepend_path(const struct path *path,</span>
 		struct dentry * parent;
 
 		if (dentry == vfsmnt-&gt;mnt_root || IS_ROOT(dentry)) {
<span class="p_add">+			/* Escaped? */</span>
<span class="p_add">+			if (dentry != vfsmnt-&gt;mnt_root) {</span>
<span class="p_add">+				*buffer = orig_buffer;</span>
<span class="p_add">+				*buflen = orig_len;</span>
<span class="p_add">+				slash = false;</span>
<span class="p_add">+				error = 3;</span>
<span class="p_add">+				goto global_root;</span>
<span class="p_add">+			}</span>
 			/* Global root? */
 			if (vfsmnt-&gt;mnt_parent == vfsmnt) {
 				goto global_root;
<span class="p_header">diff --git a/fs/ecryptfs/dentry.c b/fs/ecryptfs/dentry.c</span>
<span class="p_header">index 534c1d4..eba8f1d 100644</span>
<span class="p_header">--- a/fs/ecryptfs/dentry.c</span>
<span class="p_header">+++ b/fs/ecryptfs/dentry.c</span>
<span class="p_chunk">@@ -55,26 +55,26 @@</span> <span class="p_context"> static int ecryptfs_d_revalidate(struct dentry *dentry, struct nameidata *nd)</span>
 
 	lower_dentry = ecryptfs_dentry_to_lower(dentry);
 	lower_mnt = ecryptfs_dentry_to_lower_mnt(dentry);
<span class="p_del">-	if (!lower_dentry-&gt;d_op || !lower_dentry-&gt;d_op-&gt;d_revalidate)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	if (nd) {</span>
<span class="p_del">-		dentry_save = nd-&gt;path.dentry;</span>
<span class="p_del">-		vfsmount_save = nd-&gt;path.mnt;</span>
<span class="p_del">-		nd-&gt;path.dentry = lower_dentry;</span>
<span class="p_del">-		nd-&gt;path.mnt = lower_mnt;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	rc = lower_dentry-&gt;d_op-&gt;d_revalidate(lower_dentry, nd);</span>
<span class="p_del">-	if (nd) {</span>
<span class="p_del">-		nd-&gt;path.dentry = dentry_save;</span>
<span class="p_del">-		nd-&gt;path.mnt = vfsmount_save;</span>
<span class="p_add">+	if (lower_dentry-&gt;d_op &amp;&amp; lower_dentry-&gt;d_op-&gt;d_revalidate) {</span>
<span class="p_add">+		if (nd) {</span>
<span class="p_add">+			dentry_save = nd-&gt;path.dentry;</span>
<span class="p_add">+			vfsmount_save = nd-&gt;path.mnt;</span>
<span class="p_add">+			nd-&gt;path.dentry = lower_dentry;</span>
<span class="p_add">+			nd-&gt;path.mnt = lower_mnt;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		rc = lower_dentry-&gt;d_op-&gt;d_revalidate(lower_dentry, nd);</span>
<span class="p_add">+		if (nd) {</span>
<span class="p_add">+			nd-&gt;path.dentry = dentry_save;</span>
<span class="p_add">+			nd-&gt;path.mnt = vfsmount_save;</span>
<span class="p_add">+		}</span>
 	}
 	if (dentry-&gt;d_inode) {
<span class="p_del">-		struct inode *lower_inode =</span>
<span class="p_del">-			ecryptfs_inode_to_lower(dentry-&gt;d_inode);</span>
<span class="p_add">+		struct inode *inode = dentry-&gt;d_inode;</span>
 
<span class="p_del">-		fsstack_copy_attr_all(dentry-&gt;d_inode, lower_inode);</span>
<span class="p_add">+		fsstack_copy_attr_all(inode, ecryptfs_inode_to_lower(inode));</span>
<span class="p_add">+		if (!inode-&gt;i_nlink)</span>
<span class="p_add">+			return 0;</span>
 	}
<span class="p_del">-out:</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index be4db0e..e2cf43b 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -1018,10 +1018,10 @@</span> <span class="p_context"> static inline void ext4_show_quota_options(struct seq_file *seq,</span>
 	}
 
 	if (sbi-&gt;s_qf_names[USRQUOTA])
<span class="p_del">-		seq_printf(seq, &quot;,usrjquota=%s&quot;, sbi-&gt;s_qf_names[USRQUOTA]);</span>
<span class="p_add">+		seq_show_option(seq, &quot;usrjquota&quot;, sbi-&gt;s_qf_names[USRQUOTA]);</span>
 
 	if (sbi-&gt;s_qf_names[GRPQUOTA])
<span class="p_del">-		seq_printf(seq, &quot;,grpjquota=%s&quot;, sbi-&gt;s_qf_names[GRPQUOTA]);</span>
<span class="p_add">+		seq_show_option(seq, &quot;grpjquota&quot;, sbi-&gt;s_qf_names[GRPQUOTA]);</span>
 
 	if (test_opt(sb, USRQUOTA))
 		seq_puts(seq, &quot;,usrquota&quot;);
<span class="p_header">diff --git a/fs/gfs2/super.c b/fs/gfs2/super.c</span>
<span class="p_header">index 71e4209..be2ece5 100644</span>
<span class="p_header">--- a/fs/gfs2/super.c</span>
<span class="p_header">+++ b/fs/gfs2/super.c</span>
<span class="p_chunk">@@ -1298,11 +1298,11 @@</span> <span class="p_context"> static int gfs2_show_options(struct seq_file *s, struct vfsmount *mnt)</span>
 	if (is_ancestor(mnt-&gt;mnt_root, sdp-&gt;sd_master_dir))
 		seq_printf(s, &quot;,meta&quot;);
 	if (args-&gt;ar_lockproto[0])
<span class="p_del">-		seq_printf(s, &quot;,lockproto=%s&quot;, args-&gt;ar_lockproto);</span>
<span class="p_add">+		seq_show_option(s, &quot;lockproto&quot;, args-&gt;ar_lockproto);</span>
 	if (args-&gt;ar_locktable[0])
<span class="p_del">-		seq_printf(s, &quot;,locktable=%s&quot;, args-&gt;ar_locktable);</span>
<span class="p_add">+		seq_show_option(s, &quot;locktable&quot;, args-&gt;ar_locktable);</span>
 	if (args-&gt;ar_hostdata[0])
<span class="p_del">-		seq_printf(s, &quot;,hostdata=%s&quot;, args-&gt;ar_hostdata);</span>
<span class="p_add">+		seq_show_option(s, &quot;hostdata&quot;, args-&gt;ar_hostdata);</span>
 	if (args-&gt;ar_spectator)
 		seq_printf(s, &quot;,spectator&quot;);
 	if (args-&gt;ar_localflocks)
<span class="p_header">diff --git a/fs/hfs/bnode.c b/fs/hfs/bnode.c</span>
<span class="p_header">index cdb41a1..8daea16 100644</span>
<span class="p_header">--- a/fs/hfs/bnode.c</span>
<span class="p_header">+++ b/fs/hfs/bnode.c</span>
<span class="p_chunk">@@ -287,7 +287,6 @@</span> <span class="p_context"> static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)</span>
 			page_cache_release(page);
 			goto fail;
 		}
<span class="p_del">-		page_cache_release(page);</span>
 		node-&gt;page[i] = page;
 	}
 
<span class="p_chunk">@@ -397,11 +396,11 @@</span> <span class="p_context"> node_error:</span>
 
 void hfs_bnode_free(struct hfs_bnode *node)
 {
<span class="p_del">-	//int i;</span>
<span class="p_add">+	int i;</span>
 
<span class="p_del">-	//for (i = 0; i &lt; node-&gt;tree-&gt;pages_per_bnode; i++)</span>
<span class="p_del">-	//	if (node-&gt;page[i])</span>
<span class="p_del">-	//		page_cache_release(node-&gt;page[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; node-&gt;tree-&gt;pages_per_bnode; i++)</span>
<span class="p_add">+		if (node-&gt;page[i])</span>
<span class="p_add">+			page_cache_release(node-&gt;page[i]);</span>
 	kfree(node);
 }
 
<span class="p_header">diff --git a/fs/hfs/brec.c b/fs/hfs/brec.c</span>
<span class="p_header">index 92fb358..db240c5 100644</span>
<span class="p_header">--- a/fs/hfs/brec.c</span>
<span class="p_header">+++ b/fs/hfs/brec.c</span>
<span class="p_chunk">@@ -132,13 +132,16 @@</span> <span class="p_context"> skip:</span>
 	hfs_bnode_write(node, entry, data_off + key_len, entry_len);
 	hfs_bnode_dump(node);
 
<span class="p_del">-	if (new_node) {</span>
<span class="p_del">-		/* update parent key if we inserted a key</span>
<span class="p_del">-		 * at the start of the first node</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (!rec &amp;&amp; new_node != node)</span>
<span class="p_del">-			hfs_brec_update_parent(fd);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * update parent key if we inserted a key</span>
<span class="p_add">+	 * at the start of the node and it is not the new node</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!rec &amp;&amp; new_node != node) {</span>
<span class="p_add">+		hfs_bnode_read_key(node, fd-&gt;search_key, data_off + size);</span>
<span class="p_add">+		hfs_brec_update_parent(fd);</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	if (new_node) {</span>
 		hfs_bnode_put(fd-&gt;bnode);
 		if (!new_node-&gt;parent) {
 			hfs_btree_inc_height(tree);
<span class="p_chunk">@@ -167,9 +170,6 @@</span> <span class="p_context"> skip:</span>
 		goto again;
 	}
 
<span class="p_del">-	if (!rec)</span>
<span class="p_del">-		hfs_brec_update_parent(fd);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -366,6 +366,8 @@</span> <span class="p_context"> again:</span>
 	if (IS_ERR(parent))
 		return PTR_ERR(parent);
 	__hfs_brec_find(parent, fd);
<span class="p_add">+	if (fd-&gt;record &lt; 0)</span>
<span class="p_add">+		return -ENOENT;</span>
 	hfs_bnode_dump(parent);
 	rec = fd-&gt;record;
 
<span class="p_header">diff --git a/fs/hfs/super.c b/fs/hfs/super.c</span>
<span class="p_header">index 1b55f70..cac813d 100644</span>
<span class="p_header">--- a/fs/hfs/super.c</span>
<span class="p_header">+++ b/fs/hfs/super.c</span>
<span class="p_chunk">@@ -138,9 +138,9 @@</span> <span class="p_context"> static int hfs_show_options(struct seq_file *seq, struct vfsmount *mnt)</span>
 	struct hfs_sb_info *sbi = HFS_SB(mnt-&gt;mnt_sb);
 
 	if (sbi-&gt;s_creator != cpu_to_be32(0x3f3f3f3f))
<span class="p_del">-		seq_printf(seq, &quot;,creator=%.4s&quot;, (char *)&amp;sbi-&gt;s_creator);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;creator&quot;, (char *)&amp;sbi-&gt;s_creator, 4);</span>
 	if (sbi-&gt;s_type != cpu_to_be32(0x3f3f3f3f))
<span class="p_del">-		seq_printf(seq, &quot;,type=%.4s&quot;, (char *)&amp;sbi-&gt;s_type);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;type&quot;, (char *)&amp;sbi-&gt;s_type, 4);</span>
 	seq_printf(seq, &quot;,uid=%u,gid=%u&quot;, sbi-&gt;s_uid, sbi-&gt;s_gid);
 	if (sbi-&gt;s_file_umask != 0133)
 		seq_printf(seq, &quot;,file_umask=%o&quot;, sbi-&gt;s_file_umask);
<span class="p_header">diff --git a/fs/hfsplus/bnode.c b/fs/hfsplus/bnode.c</span>
<span class="p_header">index 1c42cc5..a1e9109 100644</span>
<span class="p_header">--- a/fs/hfsplus/bnode.c</span>
<span class="p_header">+++ b/fs/hfsplus/bnode.c</span>
<span class="p_chunk">@@ -454,7 +454,6 @@</span> <span class="p_context"> static struct hfs_bnode *__hfs_bnode_create(struct hfs_btree *tree, u32 cnid)</span>
 			page_cache_release(page);
 			goto fail;
 		}
<span class="p_del">-		page_cache_release(page);</span>
 		node-&gt;page[i] = page;
 	}
 
<span class="p_chunk">@@ -566,13 +565,11 @@</span> <span class="p_context"> node_error:</span>
 
 void hfs_bnode_free(struct hfs_bnode *node)
 {
<span class="p_del">-#if 0</span>
 	int i;
 
 	for (i = 0; i &lt; node-&gt;tree-&gt;pages_per_bnode; i++)
 		if (node-&gt;page[i])
 			page_cache_release(node-&gt;page[i]);
<span class="p_del">-#endif</span>
 	kfree(node);
 }
 
<span class="p_header">diff --git a/fs/hfsplus/options.c b/fs/hfsplus/options.c</span>
<span class="p_header">index bb62a5882..c8d6b4f 100644</span>
<span class="p_header">--- a/fs/hfsplus/options.c</span>
<span class="p_header">+++ b/fs/hfsplus/options.c</span>
<span class="p_chunk">@@ -211,9 +211,9 @@</span> <span class="p_context"> int hfsplus_show_options(struct seq_file *seq, struct vfsmount *mnt)</span>
 	struct hfsplus_sb_info *sbi = HFSPLUS_SB(mnt-&gt;mnt_sb);
 
 	if (sbi-&gt;creator != HFSPLUS_DEF_CR_TYPE)
<span class="p_del">-		seq_printf(seq, &quot;,creator=%.4s&quot;, (char *)&amp;sbi-&gt;creator);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;creator&quot;, (char *)&amp;sbi-&gt;creator, 4);</span>
 	if (sbi-&gt;type != HFSPLUS_DEF_CR_TYPE)
<span class="p_del">-		seq_printf(seq, &quot;,type=%.4s&quot;, (char *)&amp;sbi-&gt;type);</span>
<span class="p_add">+		seq_show_option_n(seq, &quot;type&quot;, (char *)&amp;sbi-&gt;type, 4);</span>
 	seq_printf(seq, &quot;,umask=%o,uid=%u,gid=%u&quot;, sbi-&gt;umask,
 		sbi-&gt;uid, sbi-&gt;gid);
 	if (sbi-&gt;part &gt;= 0)
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 2f72da5..104e4d9 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -265,7 +265,7 @@</span> <span class="p_context"> static int hostfs_show_options(struct seq_file *seq, struct vfsmount *vfs)</span>
 	size_t offset = strlen(root_ino) + 1;
 
 	if (strlen(root_path) &gt; offset)
<span class="p_del">-		seq_printf(seq, &quot;,%s&quot;, root_path + offset);</span>
<span class="p_add">+		seq_show_option(seq, root_path + offset, NULL);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 39c7059..e84393f 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -509,14 +509,15 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
  * journal_clean_one_cp_list
  *
  * Find all the written-back checkpoint buffers in the given list and
<span class="p_del">- * release them.</span>
<span class="p_add">+ * release them. If &#39;destroy&#39; is set, clean all buffers unconditionally.</span>
  *
  * Called with the journal locked.
  * Called with j_list_lock held.
  * Returns number of bufers reaped (for debug)
  */
 
<span class="p_del">-static int journal_clean_one_cp_list(struct journal_head *jh, int *released)</span>
<span class="p_add">+static int journal_clean_one_cp_list(struct journal_head *jh, bool destroy,</span>
<span class="p_add">+				     int *released)</span>
 {
 	struct journal_head *last_jh;
 	struct journal_head *next_jh = jh;
<span class="p_chunk">@@ -532,7 +533,10 @@</span> <span class="p_context"> static int journal_clean_one_cp_list(struct journal_head *jh, int *released)</span>
 		next_jh = jh-&gt;b_cpnext;
 		/* Use trylock because of the ranking */
 		if (jbd_trylock_bh_state(jh2bh(jh))) {
<span class="p_del">-			ret = __try_to_free_cp_buf(jh);</span>
<span class="p_add">+			if (!destroy)</span>
<span class="p_add">+				ret = __try_to_free_cp_buf(jh);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				ret = __jbd2_journal_remove_checkpoint(jh) + 1;</span>
 			if (ret) {
 				freed++;
 				if (ret == 2) {
<span class="p_chunk">@@ -558,13 +562,14 @@</span> <span class="p_context"> static int journal_clean_one_cp_list(struct journal_head *jh, int *released)</span>
  * journal_clean_checkpoint_list
  *
  * Find all the written-back checkpoint buffers in the journal and release them.
<span class="p_add">+ * If &#39;destroy&#39; is set, release all buffers unconditionally.</span>
  *
  * Called with the journal locked.
  * Called with j_list_lock held.
  * Returns number of buffers reaped (for debug)
  */
 
<span class="p_del">-int __jbd2_journal_clean_checkpoint_list(journal_t *journal)</span>
<span class="p_add">+int __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy)</span>
 {
 	transaction_t *transaction, *last_transaction, *next_transaction;
 	int ret = 0;
<span class="p_chunk">@@ -580,7 +585,7 @@</span> <span class="p_context"> int __jbd2_journal_clean_checkpoint_list(journal_t *journal)</span>
 		transaction = next_transaction;
 		next_transaction = transaction-&gt;t_cpnext;
 		ret += journal_clean_one_cp_list(transaction-&gt;
<span class="p_del">-				t_checkpoint_list, &amp;released);</span>
<span class="p_add">+				t_checkpoint_list, destroy, &amp;released);</span>
 		/*
 		 * This function only frees up some memory if possible so we
 		 * dont have an obligation to finish processing. Bail out if
<span class="p_chunk">@@ -596,7 +601,7 @@</span> <span class="p_context"> int __jbd2_journal_clean_checkpoint_list(journal_t *journal)</span>
 		 * we can possibly see not yet submitted buffers on io_list
 		 */
 		ret += journal_clean_one_cp_list(transaction-&gt;
<span class="p_del">-				t_checkpoint_io_list, &amp;released);</span>
<span class="p_add">+				t_checkpoint_io_list, destroy, &amp;released);</span>
 		if (need_resched())
 			goto out;
 	} while (transaction != last_transaction);
<span class="p_chunk">@@ -605,6 +610,28 @@</span> <span class="p_context"> out:</span>
 }
 
 /*
<span class="p_add">+ * Remove buffers from all checkpoint lists as journal is aborted and we just</span>
<span class="p_add">+ * need to free memory</span>
<span class="p_add">+ */</span>
<span class="p_add">+void jbd2_journal_destroy_checkpoint(journal_t *journal)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We loop because __jbd2_journal_clean_checkpoint_list() may abort</span>
<span class="p_add">+	 * early due to a need of rescheduling.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+		spin_lock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+		if (!journal-&gt;j_checkpoint_transactions) {</span>
<span class="p_add">+			spin_unlock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		__jbd2_journal_clean_checkpoint_list(journal, true);</span>
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * journal_remove_checkpoint: called after a buffer has been committed
  * to disk (either by being write-back flushed to disk, or being
  * committed to the log).
<span class="p_header">diff --git a/fs/jbd2/commit.c b/fs/jbd2/commit.c</span>
<span class="p_header">index bccb605..45ae6ec 100644</span>
<span class="p_header">--- a/fs/jbd2/commit.c</span>
<span class="p_header">+++ b/fs/jbd2/commit.c</span>
<span class="p_chunk">@@ -340,6 +340,7 @@</span> <span class="p_context"> void jbd2_journal_commit_transaction(journal_t *journal)</span>
 	/* Do we need to erase the effects of a prior jbd2_journal_flush? */
 	if (journal-&gt;j_flags &amp; JBD2_FLUSHED) {
 		jbd_debug(3, &quot;super block updated\n&quot;);
<span class="p_add">+		mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 		/*
 		 * We hold j_checkpoint_mutex so tail cannot change under us.
 		 * We don&#39;t need any special data guarantees for writing sb
<span class="p_chunk">@@ -350,6 +351,7 @@</span> <span class="p_context"> void jbd2_journal_commit_transaction(journal_t *journal)</span>
 						journal-&gt;j_tail_sequence,
 						journal-&gt;j_tail,
 						WRITE_SYNC);
<span class="p_add">+		mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 	} else {
 		jbd_debug(3, &quot;superblock not updated\n&quot;);
 	}
<span class="p_chunk">@@ -433,7 +435,7 @@</span> <span class="p_context"> void jbd2_journal_commit_transaction(journal_t *journal)</span>
 	 * frees some memory
 	 */
 	spin_lock(&amp;journal-&gt;j_list_lock);
<span class="p_del">-	__jbd2_journal_clean_checkpoint_list(journal);</span>
<span class="p_add">+	__jbd2_journal_clean_checkpoint_list(journal, false);</span>
 	spin_unlock(&amp;journal-&gt;j_list_lock);
 
 	jbd_debug(3, &quot;JBD2: commit phase 1\n&quot;);
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index 9532dac..7b7607e 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -1242,6 +1242,8 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 			journal-&gt;j_errno);
 		journal-&gt;j_flags |= JBD2_FLUSHED;
 	} else {
<span class="p_add">+		/* Lock here to make assertions happy... */</span>
<span class="p_add">+		mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 		/*
 		 * Update log tail information. We use WRITE_FUA since new
 		 * transaction will start reusing journal space and so we
<span class="p_chunk">@@ -1252,6 +1254,7 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 						journal-&gt;j_tail_sequence,
 						journal-&gt;j_tail,
 						WRITE_FUA);
<span class="p_add">+		mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 	}
 	return jbd2_journal_start_thread(journal);
 }
<span class="p_chunk">@@ -1314,6 +1317,7 @@</span> <span class="p_context"> int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 	journal_superblock_t *sb = journal-&gt;j_superblock;
 	int ret;
 
<span class="p_add">+	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));</span>
 	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,
 		  tail_block, tail_tid);
 
<span class="p_chunk">@@ -1344,6 +1348,7 @@</span> <span class="p_context"> static void jbd2_mark_journal_empty(journal_t *journal)</span>
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
 
<span class="p_add">+	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));</span>
 	read_lock(&amp;journal-&gt;j_state_lock);
 	jbd_debug(1, &quot;JBD2: Marking journal as empty (seq %d)\n&quot;,
 		  journal-&gt;j_tail_sequence);
<span class="p_chunk">@@ -1566,8 +1571,17 @@</span> <span class="p_context"> int jbd2_journal_destroy(journal_t *journal)</span>
 	while (journal-&gt;j_checkpoint_transactions != NULL) {
 		spin_unlock(&amp;journal-&gt;j_list_lock);
 		mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-		jbd2_log_do_checkpoint(journal);</span>
<span class="p_add">+		err = jbd2_log_do_checkpoint(journal);</span>
 		mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If checkpointing failed, just free the buffers to avoid</span>
<span class="p_add">+		 * looping forever</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (err) {</span>
<span class="p_add">+			jbd2_journal_destroy_checkpoint(journal);</span>
<span class="p_add">+			spin_lock(&amp;journal-&gt;j_list_lock);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		spin_lock(&amp;journal-&gt;j_list_lock);
 	}
 
<span class="p_chunk">@@ -1577,9 +1591,11 @@</span> <span class="p_context"> int jbd2_journal_destroy(journal_t *journal)</span>
 	spin_unlock(&amp;journal-&gt;j_list_lock);
 
 	if (journal-&gt;j_sb_buffer) {
<span class="p_del">-		if (!is_journal_aborted(journal))</span>
<span class="p_add">+		if (!is_journal_aborted(journal)) {</span>
<span class="p_add">+			mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 			jbd2_mark_journal_empty(journal);
<span class="p_del">-		else</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+		} else</span>
 			err = -EIO;
 		brelse(journal-&gt;j_sb_buffer);
 	}
<span class="p_chunk">@@ -1828,10 +1844,13 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	if (is_journal_aborted(journal))
 		return -EIO;
 
<span class="p_add">+	mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 	if (!err) {
 		err = jbd2_cleanup_journal_tail(journal);
<span class="p_del">-		if (err &lt; 0)</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 			goto out;
<span class="p_add">+		}</span>
 		err = 0;
 	}
 
<span class="p_chunk">@@ -1841,6 +1860,7 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	 * commits of data to the journal will restore the current
 	 * s_start value. */
 	jbd2_mark_journal_empty(journal);
<span class="p_add">+	mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
 	J_ASSERT(!journal-&gt;j_running_transaction);
 	J_ASSERT(!journal-&gt;j_committing_transaction);
<span class="p_chunk">@@ -1882,8 +1902,12 @@</span> <span class="p_context"> int jbd2_journal_wipe(journal_t *journal, int write)</span>
 		write ? &quot;Clearing&quot; : &quot;Ignoring&quot;);
 
 	err = jbd2_journal_skip_recovery(journal);
<span class="p_del">-	if (write)</span>
<span class="p_add">+	if (write) {</span>
<span class="p_add">+		/* Lock to make assertions happy... */</span>
<span class="p_add">+		mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);</span>
 		jbd2_mark_journal_empty(journal);
<span class="p_add">+		mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+	}</span>
 
  no_recovery:
 	return err;
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index c8b13a9..2c22655 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -398,6 +398,24 @@</span> <span class="p_context"> void path_put(struct path *path)</span>
 }
 EXPORT_SYMBOL(path_put);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * path_connected - Verify that a path-&gt;dentry is below path-&gt;mnt.mnt_root</span>
<span class="p_add">+ * @path: nameidate to verify</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Rename can sometimes move a file or directory outside of a bind</span>
<span class="p_add">+ * mount, path_connected allows those cases to be detected.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool path_connected(const struct path *path)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vfsmount *mnt = path-&gt;mnt;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only bind mounts can have disconnected paths */</span>
<span class="p_add">+	if (mnt-&gt;mnt_root == mnt-&gt;mnt_sb-&gt;s_root)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return is_subdir(path-&gt;dentry, mnt-&gt;mnt_root);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Path walking has 2 modes, rcu-walk and ref-walk (see
  * Documentation/filesystems/path-lookup.txt).  In situations when we can&#39;t
<span class="p_chunk">@@ -933,6 +951,8 @@</span> <span class="p_context"> static int follow_dotdot_rcu(struct nameidata *nd)</span>
 				goto failed;
 			nd-&gt;path.dentry = parent;
 			nd-&gt;seq = seq;
<span class="p_add">+			if (unlikely(!path_connected(&amp;nd-&gt;path)))</span>
<span class="p_add">+				goto failed;</span>
 			break;
 		}
 		if (!follow_up_rcu(&amp;nd-&gt;path))
<span class="p_chunk">@@ -1027,7 +1047,7 @@</span> <span class="p_context"> static void follow_mount(struct path *path)</span>
 	}
 }
 
<span class="p_del">-static void follow_dotdot(struct nameidata *nd)</span>
<span class="p_add">+static int follow_dotdot(struct nameidata *nd)</span>
 {
 	if (!nd-&gt;root.mnt)
 		set_root(nd);
<span class="p_chunk">@@ -1043,6 +1063,10 @@</span> <span class="p_context"> static void follow_dotdot(struct nameidata *nd)</span>
 			/* rare case of legitimate dget_parent()... */
 			nd-&gt;path.dentry = dget_parent(nd-&gt;path.dentry);
 			dput(old);
<span class="p_add">+			if (unlikely(!path_connected(&amp;nd-&gt;path))) {</span>
<span class="p_add">+				path_put(&amp;nd-&gt;path);</span>
<span class="p_add">+				return -ENOENT;</span>
<span class="p_add">+			}</span>
 			break;
 		}
 		if (!follow_up(&amp;nd-&gt;path))
<span class="p_chunk">@@ -1050,6 +1074,7 @@</span> <span class="p_context"> static void follow_dotdot(struct nameidata *nd)</span>
 	}
 	follow_mount(&amp;nd-&gt;path);
 	nd-&gt;inode = nd-&gt;path.dentry-&gt;d_inode;
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -1241,7 +1266,7 @@</span> <span class="p_context"> static inline int handle_dots(struct nameidata *nd, int type)</span>
 			if (follow_dotdot_rcu(nd))
 				return -ECHILD;
 		} else
<span class="p_del">-			follow_dotdot(nd);</span>
<span class="p_add">+			return follow_dotdot(nd);</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/nfs/nfs4proc.c b/fs/nfs/nfs4proc.c</span>
<span class="p_header">index e83786f..609a951 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4proc.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4proc.c</span>
<span class="p_chunk">@@ -1793,7 +1793,7 @@</span> <span class="p_context"> static int _nfs4_do_open(struct inode *dir, struct dentry *dentry, fmode_t fmode</span>
 	if (server-&gt;caps &amp; NFS_CAP_POSIX_LOCK)
 		set_bit(NFS_STATE_POSIX_LOCKS, &amp;state-&gt;flags);
 
<span class="p_del">-	if (opendata-&gt;o_arg.open_flags &amp; O_EXCL) {</span>
<span class="p_add">+	if ((opendata-&gt;o_arg.open_flags &amp; (O_CREAT|O_EXCL)) == (O_CREAT|O_EXCL)) {</span>
 		nfs4_exclusive_attrset(opendata, sattr);
 
 		nfs_fattr_init(opendata-&gt;o_res.f_attr);
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmmaster.c b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">index 7ba6ac1..8e48ba5 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmmaster.c</span>
<span class="p_chunk">@@ -1411,6 +1411,7 @@</span> <span class="p_context"> int dlm_master_request_handler(struct o2net_msg *msg, u32 len, void *data,</span>
 	int found, ret;
 	int set_maybe;
 	int dispatch_assert = 0;
<span class="p_add">+	int dispatched = 0;</span>
 
 	if (!dlm_grab(dlm))
 		return DLM_MASTER_RESP_NO;
<span class="p_chunk">@@ -1617,13 +1618,16 @@</span> <span class="p_context"> send_response:</span>
 			mlog(ML_ERROR, &quot;failed to dispatch assert master work\n&quot;);
 			response = DLM_MASTER_RESP_ERROR;
 			dlm_lockres_put(res);
<span class="p_add">+		} else {</span>
<span class="p_add">+			dispatched = 1;</span>
 		}
 	} else {
 		if (res)
 			dlm_lockres_put(res);
 	}
 
<span class="p_del">-	dlm_put(dlm);</span>
<span class="p_add">+	if (!dispatched)</span>
<span class="p_add">+		dlm_put(dlm);</span>
 	return response;
 }
 
<span class="p_chunk">@@ -2041,7 +2045,6 @@</span> <span class="p_context"> int dlm_dispatch_assert_master(struct dlm_ctxt *dlm,</span>
 
 
 	/* queue up work for dlm_assert_master_worker */
<span class="p_del">-	dlm_grab(dlm);  /* get an extra ref for the work item */</span>
 	dlm_init_work_item(dlm, item, dlm_assert_master_worker, NULL);
 	item-&gt;u.am.lockres = res; /* already have a ref */
 	/* can optionally ignore node numbers higher than this node */
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmrecovery.c b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">index d15b071..0e5013e 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmrecovery.c</span>
<span class="p_chunk">@@ -1689,6 +1689,7 @@</span> <span class="p_context"> int dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,</span>
 	unsigned int hash;
 	int master = DLM_LOCK_RES_OWNER_UNKNOWN;
 	u32 flags = DLM_ASSERT_MASTER_REQUERY;
<span class="p_add">+	int dispatched = 0;</span>
 
 	if (!dlm_grab(dlm)) {
 		/* since the domain has gone away on this
<span class="p_chunk">@@ -1710,6 +1711,8 @@</span> <span class="p_context"> int dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,</span>
 				mlog_errno(-ENOMEM);
 				/* retry!? */
 				BUG();
<span class="p_add">+			} else {</span>
<span class="p_add">+				dispatched = 1;</span>
 			}
 		} else /* put.. incase we are not the master */
 			dlm_lockres_put(res);
<span class="p_chunk">@@ -1717,7 +1720,8 @@</span> <span class="p_context"> int dlm_master_requery_handler(struct o2net_msg *msg, u32 len, void *data,</span>
 	}
 	spin_unlock(&amp;dlm-&gt;spinlock);
 
<span class="p_del">-	dlm_put(dlm);</span>
<span class="p_add">+	if (!dispatched)</span>
<span class="p_add">+		dlm_put(dlm);</span>
 	return master;
 }
 
<span class="p_header">diff --git a/fs/ocfs2/dlmglue.c b/fs/ocfs2/dlmglue.c</span>
<span class="p_header">index 231eab2..b5e457c 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlmglue.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlmglue.c</span>
<span class="p_chunk">@@ -3968,9 +3968,13 @@</span> <span class="p_context"> static void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)</span>
 	osb-&gt;dc_work_sequence = osb-&gt;dc_wake_sequence;
 
 	processed = osb-&gt;blocked_lock_count;
<span class="p_del">-	while (processed) {</span>
<span class="p_del">-		BUG_ON(list_empty(&amp;osb-&gt;blocked_lock_list));</span>
<span class="p_del">-</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * blocked lock processing in this loop might call iput which can</span>
<span class="p_add">+	 * remove items off osb-&gt;blocked_lock_list. Downconvert up to</span>
<span class="p_add">+	 * &#39;processed&#39; number of locks, but stop short if we had some</span>
<span class="p_add">+	 * removed in ocfs2_mark_lockres_freeing when downconverting.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	while (processed &amp;&amp; !list_empty(&amp;osb-&gt;blocked_lock_list)) {</span>
 		lockres = list_entry(osb-&gt;blocked_lock_list.next,
 				     struct ocfs2_lock_res, l_blocked_list);
 		list_del_init(&amp;lockres-&gt;l_blocked_list);
<span class="p_header">diff --git a/fs/ocfs2/super.c b/fs/ocfs2/super.c</span>
<span class="p_header">index 4994f8b..5fe6b1e 100644</span>
<span class="p_header">--- a/fs/ocfs2/super.c</span>
<span class="p_header">+++ b/fs/ocfs2/super.c</span>
<span class="p_chunk">@@ -1583,8 +1583,8 @@</span> <span class="p_context"> static int ocfs2_show_options(struct seq_file *s, struct vfsmount *mnt)</span>
 		seq_printf(s, &quot;,localflocks,&quot;);
 
 	if (osb-&gt;osb_cluster_stack[0])
<span class="p_del">-		seq_printf(s, &quot;,cluster_stack=%.*s&quot;, OCFS2_STACK_LABEL_LEN,</span>
<span class="p_del">-			   osb-&gt;osb_cluster_stack);</span>
<span class="p_add">+		seq_show_option_n(s, &quot;cluster_stack&quot;, osb-&gt;osb_cluster_stack,</span>
<span class="p_add">+				  OCFS2_STACK_LABEL_LEN);</span>
 	if (opts &amp; OCFS2_MOUNT_USRQUOTA)
 		seq_printf(s, &quot;,usrquota&quot;);
 	if (opts &amp; OCFS2_MOUNT_GRPQUOTA)
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index d1bd6a9..de404f2 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/rmap.h&gt;
 #include &lt;linux/swap.h&gt;
 #include &lt;linux/swapops.h&gt;
<span class="p_add">+#include &lt;linux/security.h&gt;</span>
 
 #include &lt;asm/elf.h&gt;
 #include &lt;asm/uaccess.h&gt;
<span class="p_chunk">@@ -606,6 +607,7 @@</span> <span class="p_context"> const struct file_operations proc_clear_refs_operations = {</span>
 struct pagemapread {
 	int pos, len;		/* units: PM_ENTRY_BYTES, not bytes */
 	u64 *buffer;
<span class="p_add">+	bool show_pfn;</span>
 };
 
 #define PM_ENTRY_BYTES      sizeof(u64)
<span class="p_chunk">@@ -654,14 +656,14 @@</span> <span class="p_context"> static u64 swap_pte_to_pagemap_entry(pte_t pte)</span>
 	return swp_type(e) | (swp_offset(e) &lt;&lt; MAX_SWAPFILES_SHIFT);
 }
 
<span class="p_del">-static u64 pte_to_pagemap_entry(pte_t pte)</span>
<span class="p_add">+static u64 pte_to_pagemap_entry(struct pagemapread *pm, pte_t pte)</span>
 {
 	u64 pme = 0;
 	if (is_swap_pte(pte))
 		pme = PM_PFRAME(swap_pte_to_pagemap_entry(pte))
 			| PM_PSHIFT(PAGE_SHIFT) | PM_SWAP;
 	else if (pte_present(pte))
<span class="p_del">-		pme = PM_PFRAME(pte_pfn(pte))</span>
<span class="p_add">+		pme = (pm-&gt;show_pfn ? PM_PFRAME(pte_pfn(pte)) : 0)</span>
 			| PM_PSHIFT(PAGE_SHIFT) | PM_PRESENT;
 	return pme;
 }
<span class="p_chunk">@@ -693,7 +695,7 @@</span> <span class="p_context"> static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,</span>
 		if (vma &amp;&amp; (vma-&gt;vm_start &lt;= addr) &amp;&amp;
 		    !is_vm_hugetlb_page(vma)) {
 			pte = pte_offset_map(pmd, addr);
<span class="p_del">-			pfn = pte_to_pagemap_entry(*pte);</span>
<span class="p_add">+			pfn = pte_to_pagemap_entry(pm, *pte);</span>
 			/* unmap before userspace copy */
 			pte_unmap(pte);
 		}
<span class="p_chunk">@@ -708,11 +710,11 @@</span> <span class="p_context"> static int pagemap_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,</span>
 }
 
 #ifdef CONFIG_HUGETLB_PAGE
<span class="p_del">-static u64 huge_pte_to_pagemap_entry(pte_t pte, int offset)</span>
<span class="p_add">+static u64 huge_pte_to_pagemap_entry(struct pagemapread *pm, pte_t pte, int offset)</span>
 {
 	u64 pme = 0;
 	if (pte_present(pte))
<span class="p_del">-		pme = PM_PFRAME(pte_pfn(pte) + offset)</span>
<span class="p_add">+		pme = (pm-&gt;show_pfn ? PM_PFRAME(pte_pfn(pte) + offset) : 0)</span>
 			| PM_PSHIFT(PAGE_SHIFT) | PM_PRESENT;
 	return pme;
 }
<span class="p_chunk">@@ -728,7 +730,7 @@</span> <span class="p_context"> static int pagemap_hugetlb_range(pte_t *pte, unsigned long hmask,</span>
 
 	for (; addr != end; addr += PAGE_SIZE) {
 		int offset = (addr &amp; ~hmask) &gt;&gt; PAGE_SHIFT;
<span class="p_del">-		pfn = huge_pte_to_pagemap_entry(*pte, offset);</span>
<span class="p_add">+		pfn = huge_pte_to_pagemap_entry(pm, *pte, offset);</span>
 		err = add_to_pagemap(addr, pfn, pm);
 		if (err)
 			return err;
<span class="p_chunk">@@ -792,6 +794,10 @@</span> <span class="p_context"> static ssize_t pagemap_read(struct file *file, char __user *buf,</span>
 	if (!count)
 		goto out_task;
 
<span class="p_add">+	/* do not disclose physical addresses: attack vector */</span>
<span class="p_add">+	pm.show_pfn = !security_capable(&amp;init_user_ns, file-&gt;f_cred, </span>
<span class="p_add">+					CAP_SYS_ADMIN);</span>
<span class="p_add">+</span>
 	pm.len = (PAGEMAP_WALK_SIZE &gt;&gt; PAGE_SHIFT);
 	pm.buffer = kmalloc(pm.len * PM_ENTRY_BYTES, GFP_TEMPORARY);
 	ret = -ENOMEM;
<span class="p_chunk">@@ -864,19 +870,9 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_del">-static int pagemap_open(struct inode *inode, struct file *file)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* do not disclose physical addresses to unprivileged</span>
<span class="p_del">-	   userspace (closes a rowhammer attack vector) */</span>
<span class="p_del">-	if (!capable(CAP_SYS_ADMIN))</span>
<span class="p_del">-		return -EPERM;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 const struct file_operations proc_pagemap_operations = {
 	.llseek		= mem_lseek, /* borrow this */
 	.read		= pagemap_read,
<span class="p_del">-	.open		= pagemap_open,</span>
 };
 #endif /* CONFIG_PROC_PAGE_MONITOR */
 
<span class="p_header">diff --git a/fs/xfs/xfs_aops.c b/fs/xfs/xfs_aops.c</span>
<span class="p_header">index b367581..c2b06d4 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_aops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_aops.c</span>
<span class="p_chunk">@@ -365,7 +365,8 @@</span> <span class="p_context"> xfs_end_bio(</span>
 	xfs_ioend_t		*ioend = bio-&gt;bi_private;
 
 	ASSERT(atomic_read(&amp;bio-&gt;bi_cnt) &gt;= 1);
<span class="p_del">-	ioend-&gt;io_error = test_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags) ? 0 : error;</span>
<span class="p_add">+	if (!ioend-&gt;io_error &amp;&amp; !test_bit(BIO_UPTODATE, &amp;bio-&gt;bi_flags))</span>
<span class="p_add">+		ioend-&gt;io_error = error;</span>
 
 	/* Toss bio and pass work off to an xfsdatad thread */
 	bio-&gt;bi_private = NULL;
<span class="p_header">diff --git a/fs/xfs/xfs_attr_leaf.h b/fs/xfs/xfs_attr_leaf.h</span>
<span class="p_header">index 9c7d22f..c782906 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_leaf.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_leaf.h</span>
<span class="p_chunk">@@ -111,8 +111,15 @@</span> <span class="p_context"> typedef struct xfs_attr_leaf_name_remote {</span>
 typedef struct xfs_attr_leafblock {
 	xfs_attr_leaf_hdr_t	hdr;	/* constant-structure header block */
 	xfs_attr_leaf_entry_t	entries[1];	/* sorted on key, not name */
<span class="p_del">-	xfs_attr_leaf_name_local_t namelist;	/* grows from bottom of buf */</span>
<span class="p_del">-	xfs_attr_leaf_name_remote_t valuelist;	/* grows from bottom of buf */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The rest of the block contains the following structures after the</span>
<span class="p_add">+	 * leaf entries, growing from the bottom up. The variables are never</span>
<span class="p_add">+	 * referenced and definining them can actually make gcc optimize away</span>
<span class="p_add">+	 * accesses to the &#39;entries&#39; array above index 0 so don&#39;t do that.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * xfs_attr_leaf_name_local_t namelist;</span>
<span class="p_add">+	 * xfs_attr_leaf_name_remote_t valuelist;</span>
<span class="p_add">+	 */</span>
 } xfs_attr_leafblock_t;
 
 /*
<span class="p_header">diff --git a/fs/xfs/xfs_super.c b/fs/xfs/xfs_super.c</span>
<span class="p_header">index 8a89949..90ccd1c 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_super.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_super.c</span>
<span class="p_chunk">@@ -533,9 +533,9 @@</span> <span class="p_context"> xfs_showargs(</span>
 		seq_printf(m, &quot;,&quot; MNTOPT_LOGBSIZE &quot;=%dk&quot;, mp-&gt;m_logbsize &gt;&gt; 10);
 
 	if (mp-&gt;m_logname)
<span class="p_del">-		seq_printf(m, &quot;,&quot; MNTOPT_LOGDEV &quot;=%s&quot;, mp-&gt;m_logname);</span>
<span class="p_add">+		seq_show_option(m, MNTOPT_LOGDEV, mp-&gt;m_logname);</span>
 	if (mp-&gt;m_rtname)
<span class="p_del">-		seq_printf(m, &quot;,&quot; MNTOPT_RTDEV &quot;=%s&quot;, mp-&gt;m_rtname);</span>
<span class="p_add">+		seq_show_option(m, MNTOPT_RTDEV, mp-&gt;m_rtname);</span>
 
 	if (mp-&gt;m_dalign &gt; 0)
 		seq_printf(m, &quot;,&quot; MNTOPT_SUNIT &quot;=%d&quot;,
<span class="p_header">diff --git a/include/linux/fsl_devices.h b/include/linux/fsl_devices.h</span>
<span class="p_header">index fffdf00..2fe0d22 100644</span>
<span class="p_header">--- a/include/linux/fsl_devices.h</span>
<span class="p_header">+++ b/include/linux/fsl_devices.h</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> struct fsl_usb2_platform_data {</span>
 
 	unsigned	suspended:1;
 	unsigned	already_suspended:1;
<span class="p_add">+	unsigned        has_fsl_erratum_a005275:1;</span>
 
 	/* register save area for suspend/resume */
 	u32		pm_command;
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index 4920c55..fbfd0c4 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -980,8 +980,9 @@</span> <span class="p_context"> int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 extern void jbd2_journal_commit_transaction(journal_t *);
 
 /* Checkpoint list management */
<span class="p_del">-int __jbd2_journal_clean_checkpoint_list(journal_t *journal);</span>
<span class="p_add">+int __jbd2_journal_clean_checkpoint_list(journal_t *journal, bool destroy);</span>
 int __jbd2_journal_remove_checkpoint(struct journal_head *);
<span class="p_add">+void jbd2_journal_destroy_checkpoint(journal_t *journal);</span>
 void __jbd2_journal_insert_checkpoint(struct journal_head *, transaction_t *);
 
 
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index fe76a74..f0c4495 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -176,6 +176,8 @@</span> <span class="p_context"> enum pci_dev_flags {</span>
 	PCI_DEV_FLAGS_NO_D3 = (__force pci_dev_flags_t) 2,
 	/* Provide indication device is assigned by a Virtual Machine Manager */
 	PCI_DEV_FLAGS_ASSIGNED = (__force pci_dev_flags_t) 4,
<span class="p_add">+	/* Get VPD from function 0 VPD */</span>
<span class="p_add">+	PCI_DEV_FLAGS_VPD_REF_F0 = (__force pci_dev_flags_t) (1 &lt;&lt; 8),</span>
 };
 
 enum pci_irq_reroute_variant {
<span class="p_header">diff --git a/include/linux/seq_file.h b/include/linux/seq_file.h</span>
<span class="p_header">index 0b69a46..8803d6e 100644</span>
<span class="p_header">--- a/include/linux/seq_file.h</span>
<span class="p_header">+++ b/include/linux/seq_file.h</span>
<span class="p_chunk">@@ -122,6 +122,41 @@</span> <span class="p_context"> void *__seq_open_private(struct file *, const struct seq_operations *, int);</span>
 int seq_open_private(struct file *, const struct seq_operations *, int);
 int seq_release_private(struct inode *, struct file *);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * seq_show_options - display mount options with appropriate escapes.</span>
<span class="p_add">+ * @m: the seq_file handle</span>
<span class="p_add">+ * @name: the mount option name</span>
<span class="p_add">+ * @value: the mount option name&#39;s value, can be NULL</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void seq_show_option(struct seq_file *m, const char *name,</span>
<span class="p_add">+				   const char *value)</span>
<span class="p_add">+{</span>
<span class="p_add">+	seq_putc(m, &#39;,&#39;);</span>
<span class="p_add">+	seq_escape(m, name, &quot;,= \t\n\\&quot;);</span>
<span class="p_add">+	if (value) {</span>
<span class="p_add">+		seq_putc(m, &#39;=&#39;);</span>
<span class="p_add">+		seq_escape(m, value, &quot;, \t\n\\&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * seq_show_option_n - display mount options with appropriate escapes</span>
<span class="p_add">+ *		       where @value must be a specific length.</span>
<span class="p_add">+ * @m: the seq_file handle</span>
<span class="p_add">+ * @name: the mount option name</span>
<span class="p_add">+ * @value: the mount option name&#39;s value, cannot be NULL</span>
<span class="p_add">+ * @length: the length of @value to display</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is a macro since this uses &quot;length&quot; to define the size of the</span>
<span class="p_add">+ * stack buffer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define seq_show_option_n(m, name, value, length) {	\</span>
<span class="p_add">+	char val_buf[length + 1];			\</span>
<span class="p_add">+	strncpy(val_buf, value, length);		\</span>
<span class="p_add">+	val_buf[length] = &#39;\0&#39;;				\</span>
<span class="p_add">+	seq_show_option(m, name, val_buf);		\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define SEQ_START_TOKEN ((void *)1)
 
 /*
<span class="p_header">diff --git a/include/net/ip.h b/include/net/ip.h</span>
<span class="p_header">index 1ee535b..2c7c5a9 100644</span>
<span class="p_header">--- a/include/net/ip.h</span>
<span class="p_header">+++ b/include/net/ip.h</span>
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> static inline struct sk_buff *ip_finish_skb(struct sock *sk, struct flowi4 *fl4)</span>
 }
 
 /* datagram.c */
<span class="p_add">+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len);</span>
 extern int		ip4_datagram_connect(struct sock *sk, 
 					     struct sockaddr *uaddr, int addr_len);
 
<span class="p_header">diff --git a/include/net/ip6_fib.h b/include/net/ip6_fib.h</span>
<span class="p_header">index 5735a0f..3907358 100644</span>
<span class="p_header">--- a/include/net/ip6_fib.h</span>
<span class="p_header">+++ b/include/net/ip6_fib.h</span>
<span class="p_chunk">@@ -217,7 +217,7 @@</span> <span class="p_context"> extern void			inet6_rt_notify(int event, struct rt6_info *rt,</span>
 						struct nl_info *info);
 
 extern void			fib6_run_gc(unsigned long expires,
<span class="p_del">-					    struct net *net);</span>
<span class="p_add">+					    struct net *net, bool force);</span>
 
 extern void			fib6_gc_cleanup(void);
 
<span class="p_header">diff --git a/ipc/msg.c b/ipc/msg.c</span>
<span class="p_header">index 25f1a61..391e3e0 100644</span>
<span class="p_header">--- a/ipc/msg.c</span>
<span class="p_header">+++ b/ipc/msg.c</span>
<span class="p_chunk">@@ -198,6 +198,15 @@</span> <span class="p_context"> static int newque(struct ipc_namespace *ns, struct ipc_params *params)</span>
 		return retval;
 	}
 
<span class="p_add">+	msq-&gt;q_stime = msq-&gt;q_rtime = 0;</span>
<span class="p_add">+	msq-&gt;q_ctime = get_seconds();</span>
<span class="p_add">+	msq-&gt;q_cbytes = msq-&gt;q_qnum = 0;</span>
<span class="p_add">+	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span>
<span class="p_add">+	msq-&gt;q_lspid = msq-&gt;q_lrpid = 0;</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span>
<span class="p_add">+</span>
 	/*
 	 * ipc_addid() locks msq
 	 */
<span class="p_chunk">@@ -208,15 +217,6 @@</span> <span class="p_context"> static int newque(struct ipc_namespace *ns, struct ipc_params *params)</span>
 		return id;
 	}
 
<span class="p_del">-	msq-&gt;q_stime = msq-&gt;q_rtime = 0;</span>
<span class="p_del">-	msq-&gt;q_ctime = get_seconds();</span>
<span class="p_del">-	msq-&gt;q_cbytes = msq-&gt;q_qnum = 0;</span>
<span class="p_del">-	msq-&gt;q_qbytes = ns-&gt;msg_ctlmnb;</span>
<span class="p_del">-	msq-&gt;q_lspid = msq-&gt;q_lrpid = 0;</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;msq-&gt;q_messages);</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;msq-&gt;q_receivers);</span>
<span class="p_del">-	INIT_LIST_HEAD(&amp;msq-&gt;q_senders);</span>
<span class="p_del">-</span>
 	msg_unlock(msq);
 
 	return msq-&gt;q_perm.id;
<span class="p_header">diff --git a/ipc/sem.c b/ipc/sem.c</span>
<span class="p_header">index 5215a81..b31c3ef 100644</span>
<span class="p_header">--- a/ipc/sem.c</span>
<span class="p_header">+++ b/ipc/sem.c</span>
<span class="p_chunk">@@ -314,14 +314,6 @@</span> <span class="p_context"> static int newary(struct ipc_namespace *ns, struct ipc_params *params)</span>
 		return retval;
 	}
 
<span class="p_del">-	id = ipc_addid(&amp;sem_ids(ns), &amp;sma-&gt;sem_perm, ns-&gt;sc_semmni);</span>
<span class="p_del">-	if (id &lt; 0) {</span>
<span class="p_del">-		security_sem_free(sma);</span>
<span class="p_del">-		ipc_rcu_putref(sma);</span>
<span class="p_del">-		return id;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	ns-&gt;used_sems += nsems;</span>
<span class="p_del">-</span>
 	sma-&gt;sem_base = (struct sem *) &amp;sma[1];
 
 	for (i = 0; i &lt; nsems; i++)
<span class="p_chunk">@@ -332,6 +324,15 @@</span> <span class="p_context"> static int newary(struct ipc_namespace *ns, struct ipc_params *params)</span>
 	INIT_LIST_HEAD(&amp;sma-&gt;list_id);
 	sma-&gt;sem_nsems = nsems;
 	sma-&gt;sem_ctime = get_seconds();
<span class="p_add">+</span>
<span class="p_add">+	id = ipc_addid(&amp;sem_ids(ns), &amp;sma-&gt;sem_perm, ns-&gt;sc_semmni);</span>
<span class="p_add">+	if (id &lt; 0) {</span>
<span class="p_add">+		security_sem_free(sma);</span>
<span class="p_add">+		ipc_rcu_putref(sma);</span>
<span class="p_add">+		return id;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ns-&gt;used_sems += nsems;</span>
<span class="p_add">+</span>
 	sem_unlock(sma);
 
 	return sma-&gt;sem_perm.id;
<span class="p_chunk">@@ -1606,16 +1607,27 @@</span> <span class="p_context"> void exit_sem(struct task_struct *tsk)</span>
 		rcu_read_lock();
 		un = list_entry_rcu(ulp-&gt;list_proc.next,
 				    struct sem_undo, list_proc);
<span class="p_del">-		if (&amp;un-&gt;list_proc == &amp;ulp-&gt;list_proc)</span>
<span class="p_del">-			semid = -1;</span>
<span class="p_del">-		 else</span>
<span class="p_del">-			semid = un-&gt;semid;</span>
<span class="p_add">+		if (&amp;un-&gt;list_proc == &amp;ulp-&gt;list_proc) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We must wait for freeary() before freeing this ulp,</span>
<span class="p_add">+			 * in case we raced with last sem_undo. There is a small</span>
<span class="p_add">+			 * possibility where we exit while freeary() didn&#39;t</span>
<span class="p_add">+			 * finish unlocking sem_undo_list.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			spin_unlock_wait(&amp;ulp-&gt;lock);</span>
<span class="p_add">+			rcu_read_unlock();</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		spin_lock(&amp;ulp-&gt;lock);</span>
<span class="p_add">+		semid = un-&gt;semid;</span>
<span class="p_add">+		spin_unlock(&amp;ulp-&gt;lock);</span>
 		rcu_read_unlock();
 
<span class="p_add">+		/* exit_sem raced with IPC_RMID, nothing to do */</span>
 		if (semid == -1)
<span class="p_del">-			break;</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-		sma = sem_lock_check(tsk-&gt;nsproxy-&gt;ipc_ns, un-&gt;semid);</span>
<span class="p_add">+		sma = sem_lock_check(tsk-&gt;nsproxy-&gt;ipc_ns, semid);</span>
 
 		/* exit_sem raced with IPC_RMID, nothing to do */
 		if (IS_ERR(sma))
<span class="p_header">diff --git a/ipc/shm.c b/ipc/shm.c</span>
<span class="p_header">index 326a20b..16b1f9e 100644</span>
<span class="p_header">--- a/ipc/shm.c</span>
<span class="p_header">+++ b/ipc/shm.c</span>
<span class="p_chunk">@@ -498,12 +498,6 @@</span> <span class="p_context"> static int newseg(struct ipc_namespace *ns, struct ipc_params *params)</span>
 	if (IS_ERR(file))
 		goto no_file;
 
<span class="p_del">-	id = ipc_addid(&amp;shm_ids(ns), &amp;shp-&gt;shm_perm, ns-&gt;shm_ctlmni);</span>
<span class="p_del">-	if (id &lt; 0) {</span>
<span class="p_del">-		error = id;</span>
<span class="p_del">-		goto no_id;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	shp-&gt;shm_cprid = task_tgid_vnr(current);
 	shp-&gt;shm_lprid = 0;
 	shp-&gt;shm_atim = shp-&gt;shm_dtim = 0;
<span class="p_chunk">@@ -512,6 +506,13 @@</span> <span class="p_context"> static int newseg(struct ipc_namespace *ns, struct ipc_params *params)</span>
 	shp-&gt;shm_nattch = 0;
 	shp-&gt;shm_file = file;
 	shp-&gt;shm_creator = current;
<span class="p_add">+</span>
<span class="p_add">+	id = ipc_addid(&amp;shm_ids(ns), &amp;shp-&gt;shm_perm, ns-&gt;shm_ctlmni);</span>
<span class="p_add">+	if (id &lt; 0) {</span>
<span class="p_add">+		error = id;</span>
<span class="p_add">+		goto no_id;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * shmid gets reported as &quot;inode#&quot; in /proc/pid/maps.
 	 * proc-ps tools use this. Changing this will break them.
<span class="p_header">diff --git a/ipc/util.c b/ipc/util.c</span>
<span class="p_header">index 75261a3..e4c9377 100644</span>
<span class="p_header">--- a/ipc/util.c</span>
<span class="p_header">+++ b/ipc/util.c</span>
<span class="p_chunk">@@ -264,6 +264,10 @@</span> <span class="p_context"> int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)</span>
 	rcu_read_lock();
 	spin_lock(&amp;new-&gt;lock);
 
<span class="p_add">+	current_euid_egid(&amp;euid, &amp;egid);</span>
<span class="p_add">+	new-&gt;cuid = new-&gt;uid = euid;</span>
<span class="p_add">+	new-&gt;gid = new-&gt;cgid = egid;</span>
<span class="p_add">+</span>
 	err = idr_get_new(&amp;ids-&gt;ipcs_idr, new, &amp;id);
 	if (err) {
 		spin_unlock(&amp;new-&gt;lock);
<span class="p_chunk">@@ -273,10 +277,6 @@</span> <span class="p_context"> int ipc_addid(struct ipc_ids* ids, struct kern_ipc_perm* new, int size)</span>
 
 	ids-&gt;in_use++;
 
<span class="p_del">-	current_euid_egid(&amp;euid, &amp;egid);</span>
<span class="p_del">-	new-&gt;cuid = new-&gt;uid = euid;</span>
<span class="p_del">-	new-&gt;gid = new-&gt;cgid = egid;</span>
<span class="p_del">-</span>
 	new-&gt;seq = ids-&gt;seq++;
 	if(ids-&gt;seq &gt; ids-&gt;seq_max)
 		ids-&gt;seq = 0;
<span class="p_header">diff --git a/kernel/cgroup.c b/kernel/cgroup.c</span>
<span class="p_header">index eafb6dd..ec64a18 100644</span>
<span class="p_header">--- a/kernel/cgroup.c</span>
<span class="p_header">+++ b/kernel/cgroup.c</span>
<span class="p_chunk">@@ -1053,15 +1053,16 @@</span> <span class="p_context"> static int cgroup_show_options(struct seq_file *seq, struct vfsmount *vfs)</span>
 
 	mutex_lock(&amp;cgroup_mutex);
 	for_each_subsys(root, ss)
<span class="p_del">-		seq_printf(seq, &quot;,%s&quot;, ss-&gt;name);</span>
<span class="p_add">+		seq_show_option(seq, ss-&gt;name, NULL);</span>
 	if (test_bit(ROOT_NOPREFIX, &amp;root-&gt;flags))
 		seq_puts(seq, &quot;,noprefix&quot;);
 	if (strlen(root-&gt;release_agent_path))
<span class="p_del">-		seq_printf(seq, &quot;,release_agent=%s&quot;, root-&gt;release_agent_path);</span>
<span class="p_add">+		seq_show_option(seq, &quot;release_agent&quot;,</span>
<span class="p_add">+				root-&gt;release_agent_path);</span>
 	if (clone_children(&amp;root-&gt;top_cgroup))
 		seq_puts(seq, &quot;,clone_children&quot;);
 	if (strlen(root-&gt;name))
<span class="p_del">-		seq_printf(seq, &quot;,name=%s&quot;, root-&gt;name);</span>
<span class="p_add">+		seq_show_option(seq, &quot;name&quot;, root-&gt;name);</span>
 	mutex_unlock(&amp;cgroup_mutex);
 	return 0;
 }
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 4277095..f475286 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -3942,12 +3942,20 @@</span> <span class="p_context"> static const struct file_operations perf_fops = {</span>
  * to user-space before waking everybody up.
  */
 
<span class="p_add">+static inline struct fasync_struct **perf_event_fasync(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* only the parent has fasync state */</span>
<span class="p_add">+	if (event-&gt;parent)</span>
<span class="p_add">+		event = event-&gt;parent;</span>
<span class="p_add">+	return &amp;event-&gt;fasync;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void perf_event_wakeup(struct perf_event *event)
 {
 	ring_buffer_wakeup(event);
 
 	if (event-&gt;pending_kill) {
<span class="p_del">-		kill_fasync(&amp;event-&gt;fasync, SIGIO, event-&gt;pending_kill);</span>
<span class="p_add">+		kill_fasync(perf_event_fasync(event), SIGIO, event-&gt;pending_kill);</span>
 		event-&gt;pending_kill = 0;
 	}
 }
<span class="p_chunk">@@ -4924,7 +4932,7 @@</span> <span class="p_context"> static int __perf_event_overflow(struct perf_event *event,</span>
 	else
 		perf_event_output(event, data, regs);
 
<span class="p_del">-	if (event-&gt;fasync &amp;&amp; event-&gt;pending_kill) {</span>
<span class="p_add">+	if (*perf_event_fasync(event) &amp;&amp; event-&gt;pending_kill) {</span>
 		event-&gt;pending_wakeup = 1;
 		irq_work_queue(&amp;event-&gt;pending);
 	}
<span class="p_header">diff --git a/net/Kconfig b/net/Kconfig</span>
<span class="p_header">index a073148..946e17a 100644</span>
<span class="p_header">--- a/net/Kconfig</span>
<span class="p_header">+++ b/net/Kconfig</span>
<span class="p_chunk">@@ -250,7 +250,7 @@</span> <span class="p_context"> menu &quot;Network testing&quot;</span>
 
 config NET_PKTGEN
 	tristate &quot;Packet Generator (USE WITH CAUTION)&quot;
<span class="p_del">-	depends on PROC_FS</span>
<span class="p_add">+	depends on INET &amp;&amp; PROC_FS</span>
 	---help---
 	  This module will inject preconfigured packets, at a configurable
 	  rate, out of a given interface.  It is used for network interface
<span class="p_header">diff --git a/net/core/datagram.c b/net/core/datagram.c</span>
<span class="p_header">index 6f54d0a..a496313 100644</span>
<span class="p_header">--- a/net/core/datagram.c</span>
<span class="p_header">+++ b/net/core/datagram.c</span>
<span class="p_chunk">@@ -128,6 +128,35 @@</span> <span class="p_context"> out_noerr:</span>
 	goto out;
 }
 
<span class="p_add">+static struct sk_buff *skb_set_peeked(struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (skb-&gt;peeked)</span>
<span class="p_add">+		return skb;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We have to unshare an skb before modifying it. */</span>
<span class="p_add">+	if (!skb_shared(skb))</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
<span class="p_add">+	nskb = skb_clone(skb, GFP_ATOMIC);</span>
<span class="p_add">+	if (!nskb)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	skb-&gt;prev-&gt;next = nskb;</span>
<span class="p_add">+	skb-&gt;next-&gt;prev = nskb;</span>
<span class="p_add">+	nskb-&gt;prev = skb-&gt;prev;</span>
<span class="p_add">+	nskb-&gt;next = skb-&gt;next;</span>
<span class="p_add">+</span>
<span class="p_add">+	consume_skb(skb);</span>
<span class="p_add">+	skb = nskb;</span>
<span class="p_add">+</span>
<span class="p_add">+done:</span>
<span class="p_add">+	skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return skb;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	__skb_recv_datagram - Receive a datagram skbuff
  *	@sk: socket
<span class="p_chunk">@@ -160,7 +189,9 @@</span> <span class="p_context"> out_noerr:</span>
 struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,
 				    int *peeked, int *err)
 {
<span class="p_add">+	struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
 	struct sk_buff *skb;
<span class="p_add">+	unsigned long cpu_flags;</span>
 	long timeo;
 	/*
 	 * Caller is allowed not to check sk-&gt;sk_err before skb_recv_datagram()
<span class="p_chunk">@@ -179,15 +210,17 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,</span>
 		 * Look at current nfs client by the way...
 		 * However, this function was correct in any case. 8)
 		 */
<span class="p_del">-		unsigned long cpu_flags;</span>
<span class="p_del">-		struct sk_buff_head *queue = &amp;sk-&gt;sk_receive_queue;</span>
<span class="p_del">-</span>
 		spin_lock_irqsave(&amp;queue-&gt;lock, cpu_flags);
 		skb = skb_peek(queue);
 		if (skb) {
 			*peeked = skb-&gt;peeked;
 			if (flags &amp; MSG_PEEK) {
<span class="p_del">-				skb-&gt;peeked = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+				skb = skb_set_peeked(skb);</span>
<span class="p_add">+				error = PTR_ERR(skb);</span>
<span class="p_add">+				if (IS_ERR(skb))</span>
<span class="p_add">+					goto unlock_err;</span>
<span class="p_add">+</span>
 				atomic_inc(&amp;skb-&gt;users);
 			} else
 				__skb_unlink(skb, queue);
<span class="p_chunk">@@ -206,6 +239,8 @@</span> <span class="p_context"> struct sk_buff *__skb_recv_datagram(struct sock *sk, unsigned flags,</span>
 
 	return NULL;
 
<span class="p_add">+unlock_err:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;queue-&gt;lock, cpu_flags);</span>
 no_packet:
 	*err = error;
 	return NULL;
<span class="p_chunk">@@ -656,7 +691,8 @@</span> <span class="p_context"> __sum16 __skb_checksum_complete_head(struct sk_buff *skb, int len)</span>
 	if (likely(!sum)) {
 		if (unlikely(skb-&gt;ip_summed == CHECKSUM_COMPLETE))
 			netdev_rx_csum_fault(skb-&gt;dev);
<span class="p_del">-		skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
<span class="p_add">+		if (!skb_shared(skb))</span>
<span class="p_add">+			skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;</span>
 	}
 	return sum;
 }
<span class="p_header">diff --git a/net/core/fib_rules.c b/net/core/fib_rules.c</span>
<span class="p_header">index 6af54f2..c7caf3e 100644</span>
<span class="p_header">--- a/net/core/fib_rules.c</span>
<span class="p_header">+++ b/net/core/fib_rules.c</span>
<span class="p_chunk">@@ -594,15 +594,17 @@</span> <span class="p_context"> static int dump_rules(struct sk_buff *skb, struct netlink_callback *cb,</span>
 {
 	int idx = 0;
 	struct fib_rule *rule;
<span class="p_add">+	int err = 0;</span>
 
 	rcu_read_lock();
 	list_for_each_entry_rcu(rule, &amp;ops-&gt;rules_list, list) {
 		if (idx &lt; cb-&gt;args[1])
 			goto skip;
 
<span class="p_del">-		if (fib_nl_fill_rule(skb, rule, NETLINK_CB(cb-&gt;skb).pid,</span>
<span class="p_del">-				     cb-&gt;nlh-&gt;nlmsg_seq, RTM_NEWRULE,</span>
<span class="p_del">-				     NLM_F_MULTI, ops) &lt; 0)</span>
<span class="p_add">+		err = fib_nl_fill_rule(skb, rule, NETLINK_CB(cb-&gt;skb).pid,</span>
<span class="p_add">+				       cb-&gt;nlh-&gt;nlmsg_seq, RTM_NEWRULE,</span>
<span class="p_add">+				       NLM_F_MULTI, ops);</span>
<span class="p_add">+		if (err &lt; 0)</span>
 			break;
 skip:
 		idx++;
<span class="p_chunk">@@ -611,7 +613,7 @@</span> <span class="p_context"> skip:</span>
 	cb-&gt;args[1] = idx;
 	rules_ops_put(ops);
 
<span class="p_del">-	return skb-&gt;len;</span>
<span class="p_add">+	return err;</span>
 }
 
 static int fib_nl_dumprule(struct sk_buff *skb, struct netlink_callback *cb)
<span class="p_chunk">@@ -627,7 +629,9 @@</span> <span class="p_context"> static int fib_nl_dumprule(struct sk_buff *skb, struct netlink_callback *cb)</span>
 		if (ops == NULL)
 			return -EAFNOSUPPORT;
 
<span class="p_del">-		return dump_rules(skb, cb, ops);</span>
<span class="p_add">+		dump_rules(skb, cb, ops);</span>
<span class="p_add">+</span>
<span class="p_add">+		return skb-&gt;len;</span>
 	}
 
 	rcu_read_lock();
<span class="p_header">diff --git a/net/core/pktgen.c b/net/core/pktgen.c</span>
<span class="p_header">index 9dd65a9..7879b2f 100644</span>
<span class="p_header">--- a/net/core/pktgen.c</span>
<span class="p_header">+++ b/net/core/pktgen.c</span>
<span class="p_chunk">@@ -3481,8 +3481,10 @@</span> <span class="p_context"> static int pktgen_thread_worker(void *arg)</span>
 	pktgen_rem_thread(t);
 
 	/* Wait for kthread_stop */
<span class="p_del">-	while (!kthread_should_stop()) {</span>
<span class="p_add">+	for (;;) {</span>
 		set_current_state(TASK_INTERRUPTIBLE);
<span class="p_add">+		if (kthread_should_stop())</span>
<span class="p_add">+			break;</span>
 		schedule();
 	}
 	__set_current_state(TASK_RUNNING);
<span class="p_header">diff --git a/net/ipv4/datagram.c b/net/ipv4/datagram.c</span>
<span class="p_header">index ec07510..ffb8b6e 100644</span>
<span class="p_header">--- a/net/ipv4/datagram.c</span>
<span class="p_header">+++ b/net/ipv4/datagram.c</span>
<span class="p_chunk">@@ -20,7 +20,7 @@</span> <span class="p_context"></span>
 #include &lt;net/route.h&gt;
 #include &lt;net/tcp_states.h&gt;
 
<span class="p_del">-int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+int __ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 {
 	struct inet_sock *inet = inet_sk(sk);
 	struct sockaddr_in *usin = (struct sockaddr_in *) uaddr;
<span class="p_chunk">@@ -39,8 +39,6 @@</span> <span class="p_context"> int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 
 	sk_dst_reset(sk);
 
<span class="p_del">-	lock_sock(sk);</span>
<span class="p_del">-</span>
 	oif = sk-&gt;sk_bound_dev_if;
 	saddr = inet-&gt;inet_saddr;
 	if (ipv4_is_multicast(usin-&gt;sin_addr.s_addr)) {
<span class="p_chunk">@@ -81,7 +79,17 @@</span> <span class="p_context"> int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	sk_dst_set(sk, &amp;rt-&gt;dst);
 	err = 0;
 out:
<span class="p_del">-	release_sock(sk);</span>
 	return err;
 }
<span class="p_add">+EXPORT_SYMBOL(__ip4_datagram_connect);</span>
<span class="p_add">+</span>
<span class="p_add">+int ip4_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	res = __ip4_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(ip4_datagram_connect);
<span class="p_header">diff --git a/net/ipv6/Makefile b/net/ipv6/Makefile</span>
<span class="p_header">index 4b20d56..8b25fbb 100644</span>
<span class="p_header">--- a/net/ipv6/Makefile</span>
<span class="p_header">+++ b/net/ipv6/Makefile</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"> obj-$(CONFIG_NETFILTER)	+= netfilter/</span>
 obj-$(CONFIG_IPV6_SIT) += sit.o
 obj-$(CONFIG_IPV6_TUNNEL) += ip6_tunnel.o
 
<span class="p_del">-obj-y += addrconf_core.o exthdrs_core.o output_core.o</span>
<span class="p_add">+obj-y += addrconf_core.o exthdrs_core.o</span>
<span class="p_add">+obj-$(CONFIG_INET) += output_core.o</span>
 
 obj-$(subst m,y,$(CONFIG_IPV6)) += inet6_hashtables.o
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 3afdd78..006867d 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -4321,6 +4321,21 @@</span> <span class="p_context"> int addrconf_sysctl_forward(ctl_table *ctl, int write,</span>
 	return ret;
 }
 
<span class="p_add">+static</span>
<span class="p_add">+int addrconf_sysctl_mtu(struct ctl_table *ctl, int write,</span>
<span class="p_add">+			void __user *buffer, size_t *lenp, loff_t *ppos)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct inet6_dev *idev = ctl-&gt;extra1;</span>
<span class="p_add">+	int min_mtu = IPV6_MIN_MTU;</span>
<span class="p_add">+	struct ctl_table lctl;</span>
<span class="p_add">+</span>
<span class="p_add">+	lctl = *ctl;</span>
<span class="p_add">+	lctl.extra1 = &amp;min_mtu;</span>
<span class="p_add">+	lctl.extra2 = idev ? &amp;idev-&gt;dev-&gt;mtu : NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return proc_dointvec_minmax(&amp;lctl, write, buffer, lenp, ppos);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void dev_disable_change(struct inet6_dev *idev)
 {
 	if (!idev || !idev-&gt;dev)
<span class="p_chunk">@@ -4421,7 +4436,7 @@</span> <span class="p_context"> static struct addrconf_sysctl_table</span>
 			.data		= &amp;ipv6_devconf.mtu6,
 			.maxlen		= sizeof(int),
 			.mode		= 0644,
<span class="p_del">-			.proc_handler	= proc_dointvec,</span>
<span class="p_add">+			.proc_handler	= addrconf_sysctl_mtu,</span>
 		},
 		{
 			.procname	= &quot;accept_ra&quot;,
<span class="p_header">diff --git a/net/ipv6/datagram.c b/net/ipv6/datagram.c</span>
<span class="p_header">index 33719b7..67f3632 100644</span>
<span class="p_header">--- a/net/ipv6/datagram.c</span>
<span class="p_header">+++ b/net/ipv6/datagram.c</span>
<span class="p_chunk">@@ -38,7 +38,7 @@</span> <span class="p_context"> static inline int ipv6_mapped_addr_any(const struct in6_addr *a)</span>
 	return (ipv6_addr_v4mapped(a) &amp;&amp; (a-&gt;s6_addr32[3] == 0));
 }
 
<span class="p_del">-int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+static int __ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 {
 	struct sockaddr_in6	*usin = (struct sockaddr_in6 *) uaddr;
 	struct inet_sock      	*inet = inet_sk(sk);
<span class="p_chunk">@@ -54,7 +54,7 @@</span> <span class="p_context"> int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	if (usin-&gt;sin6_family == AF_INET) {
 		if (__ipv6_only_sock(sk))
 			return -EAFNOSUPPORT;
<span class="p_del">-		err = ip4_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+		err = __ip4_datagram_connect(sk, uaddr, addr_len);</span>
 		goto ipv4_connected;
 	}
 
<span class="p_chunk">@@ -97,9 +97,9 @@</span> <span class="p_context"> int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 		sin.sin_addr.s_addr = daddr-&gt;s6_addr32[3];
 		sin.sin_port = usin-&gt;sin6_port;
 
<span class="p_del">-		err = ip4_datagram_connect(sk,</span>
<span class="p_del">-					   (struct sockaddr*) &amp;sin,</span>
<span class="p_del">-					   sizeof(sin));</span>
<span class="p_add">+		err = __ip4_datagram_connect(sk,</span>
<span class="p_add">+					     (struct sockaddr *) &amp;sin,</span>
<span class="p_add">+					     sizeof(sin));</span>
 
 ipv4_connected:
 		if (err)
<span class="p_chunk">@@ -203,6 +203,16 @@</span> <span class="p_context"> out:</span>
 	return err;
 }
 
<span class="p_add">+int ip6_datagram_connect(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int res;</span>
<span class="p_add">+</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+	res = __ip6_datagram_connect(sk, uaddr, addr_len);</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+	return res;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void ipv6_icmp_error(struct sock *sk, struct sk_buff *skb, int err,
 		     __be16 port, u32 info, u8 *payload)
 {
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index ad62afc..785e62d 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -1473,27 +1473,28 @@</span> <span class="p_context"> static int fib6_age(struct rt6_info *rt, void *arg)</span>
 
 static DEFINE_SPINLOCK(fib6_gc_lock);
 
<span class="p_del">-void fib6_run_gc(unsigned long expires, struct net *net)</span>
<span class="p_add">+void fib6_run_gc(unsigned long expires, struct net *net, bool force)</span>
 {
<span class="p_del">-	if (expires != ~0UL) {</span>
<span class="p_add">+	unsigned long now;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (force) {</span>
 		spin_lock_bh(&amp;fib6_gc_lock);
<span class="p_del">-		gc_args.timeout = expires ? (int)expires :</span>
<span class="p_del">-			net-&gt;ipv6.sysctl.ip6_rt_gc_interval;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (!spin_trylock_bh(&amp;fib6_gc_lock)) {</span>
<span class="p_del">-			mod_timer(&amp;net-&gt;ipv6.ip6_fib_timer, jiffies + HZ);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		gc_args.timeout = net-&gt;ipv6.sysctl.ip6_rt_gc_interval;</span>
<span class="p_add">+	} else if (!spin_trylock_bh(&amp;fib6_gc_lock)) {</span>
<span class="p_add">+		mod_timer(&amp;net-&gt;ipv6.ip6_fib_timer, jiffies + HZ);</span>
<span class="p_add">+		return;</span>
 	}
<span class="p_add">+	gc_args.timeout = expires ? (int)expires :</span>
<span class="p_add">+			  net-&gt;ipv6.sysctl.ip6_rt_gc_interval;</span>
 
 	gc_args.more = icmp6_dst_gc();
 
 	fib6_clean_all(net, fib6_age, 0, NULL);
<span class="p_add">+	now = jiffies;</span>
<span class="p_add">+	net-&gt;ipv6.ip6_rt_last_gc = now;</span>
 
 	if (gc_args.more)
 		mod_timer(&amp;net-&gt;ipv6.ip6_fib_timer,
<span class="p_del">-			  round_jiffies(jiffies</span>
<span class="p_add">+			  round_jiffies(now</span>
 					+ net-&gt;ipv6.sysctl.ip6_rt_gc_interval));
 	else
 		del_timer(&amp;net-&gt;ipv6.ip6_fib_timer);
<span class="p_chunk">@@ -1502,7 +1503,7 @@</span> <span class="p_context"> void fib6_run_gc(unsigned long expires, struct net *net)</span>
 
 static void fib6_gc_timer_cb(unsigned long arg)
 {
<span class="p_del">-	fib6_run_gc(0, (struct net *)arg);</span>
<span class="p_add">+	fib6_run_gc(0, (struct net *)arg, true);</span>
 }
 
 static int __net_init fib6_net_init(struct net *net)
<span class="p_header">diff --git a/net/ipv6/ip6mr.c b/net/ipv6/ip6mr.c</span>
<span class="p_header">index f96c96f..99ee86d 100644</span>
<span class="p_header">--- a/net/ipv6/ip6mr.c</span>
<span class="p_header">+++ b/net/ipv6/ip6mr.c</span>
<span class="p_chunk">@@ -550,7 +550,7 @@</span> <span class="p_context"> static void ipmr_mfc_seq_stop(struct seq_file *seq, void *v)</span>
 
 	if (it-&gt;cache == &amp;mrt-&gt;mfc6_unres_queue)
 		spin_unlock_bh(&amp;mfc_unres_lock);
<span class="p_del">-	else if (it-&gt;cache == mrt-&gt;mfc6_cache_array)</span>
<span class="p_add">+	else if (it-&gt;cache == &amp;mrt-&gt;mfc6_cache_array[it-&gt;ct])</span>
 		read_unlock(&amp;mrt_lock);
 }
 
<span class="p_header">diff --git a/net/ipv6/ndisc.c b/net/ipv6/ndisc.c</span>
<span class="p_header">index 884d45f..39836da 100644</span>
<span class="p_header">--- a/net/ipv6/ndisc.c</span>
<span class="p_header">+++ b/net/ipv6/ndisc.c</span>
<span class="p_chunk">@@ -1743,11 +1743,11 @@</span> <span class="p_context"> static int ndisc_netdev_event(struct notifier_block *this, unsigned long event,</span>
 	switch (event) {
 	case NETDEV_CHANGEADDR:
 		neigh_changeaddr(&amp;nd_tbl, dev);
<span class="p_del">-		fib6_run_gc(~0UL, net);</span>
<span class="p_add">+		fib6_run_gc(0, net, false);</span>
 		break;
 	case NETDEV_DOWN:
 		neigh_ifdown(&amp;nd_tbl, dev);
<span class="p_del">-		fib6_run_gc(~0UL, net);</span>
<span class="p_add">+		fib6_run_gc(0, net, false);</span>
 		break;
 	case NETDEV_NOTIFY_PEERS:
 		ndisc_send_unsol_na(dev);
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index d89d1a6..3a8776d 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -1159,7 +1159,6 @@</span> <span class="p_context"> static void icmp6_clean_all(int (*func)(struct rt6_info *rt, void *arg),</span>
 
 static int ip6_dst_gc(struct dst_ops *ops)
 {
<span class="p_del">-	unsigned long now = jiffies;</span>
 	struct net *net = container_of(ops, struct net, ipv6.ip6_dst_ops);
 	int rt_min_interval = net-&gt;ipv6.sysctl.ip6_rt_gc_min_interval;
 	int rt_max_size = net-&gt;ipv6.sysctl.ip6_rt_max_size;
<span class="p_chunk">@@ -1169,13 +1168,12 @@</span> <span class="p_context"> static int ip6_dst_gc(struct dst_ops *ops)</span>
 	int entries;
 
 	entries = dst_entries_get_fast(ops);
<span class="p_del">-	if (time_after(rt_last_gc + rt_min_interval, now) &amp;&amp;</span>
<span class="p_add">+	if (time_after(rt_last_gc + rt_min_interval, jiffies) &amp;&amp;</span>
 	    entries &lt;= rt_max_size)
 		goto out;
 
 	net-&gt;ipv6.ip6_rt_gc_expire++;
<span class="p_del">-	fib6_run_gc(net-&gt;ipv6.ip6_rt_gc_expire, net);</span>
<span class="p_del">-	net-&gt;ipv6.ip6_rt_last_gc = now;</span>
<span class="p_add">+	fib6_run_gc(net-&gt;ipv6.ip6_rt_gc_expire, net, entries &gt; rt_max_size);</span>
 	entries = dst_entries_get_slow(ops);
 	if (entries &lt; ops-&gt;gc_thresh)
 		net-&gt;ipv6.ip6_rt_gc_expire = rt_gc_timeout&gt;&gt;1;
<span class="p_chunk">@@ -2726,7 +2724,7 @@</span> <span class="p_context"> int ipv6_sysctl_rtcache_flush(ctl_table *ctl, int write,</span>
 	net = (struct net *)ctl-&gt;extra1;
 	delay = net-&gt;ipv6.sysctl.flush_delay;
 	proc_dointvec(ctl, write, buffer, lenp, ppos);
<span class="p_del">-	fib6_run_gc(delay &lt;= 0 ? ~0UL : (unsigned long)delay, net);</span>
<span class="p_add">+	fib6_run_gc(delay &lt;= 0 ? 0 : (unsigned long)delay, net, delay &gt; 0);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/net/key/af_key.c b/net/key/af_key.c</span>
<span class="p_header">index dc8d7ef..8636f10 100644</span>
<span class="p_header">--- a/net/key/af_key.c</span>
<span class="p_header">+++ b/net/key/af_key.c</span>
<span class="p_chunk">@@ -220,7 +220,7 @@</span> <span class="p_context"> static int pfkey_broadcast_one(struct sk_buff *skb, struct sk_buff **skb2,</span>
 #define BROADCAST_ONE		1
 #define BROADCAST_REGISTERED	2
 #define BROADCAST_PROMISC_ONLY	4
<span class="p_del">-static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
<span class="p_add">+static int pfkey_broadcast(struct sk_buff *skb,</span>
 			   int broadcast_flags, struct sock *one_sk,
 			   struct net *net)
 {
<span class="p_chunk">@@ -246,7 +246,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 		 * socket.
 		 */
 		if (pfk-&gt;promisc)
<span class="p_del">-			pfkey_broadcast_one(skb, &amp;skb2, allocation, sk);</span>
<span class="p_add">+			pfkey_broadcast_one(skb, &amp;skb2, GFP_ATOMIC, sk);</span>
 
 		/* the exact target will be processed later */
 		if (sk == one_sk)
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 				continue;
 		}
 
<span class="p_del">-		err2 = pfkey_broadcast_one(skb, &amp;skb2, allocation, sk);</span>
<span class="p_add">+		err2 = pfkey_broadcast_one(skb, &amp;skb2, GFP_ATOMIC, sk);</span>
 
 		/* Error is cleare after succecful sending to at least one
 		 * registered KM */
<span class="p_chunk">@@ -271,7 +271,7 @@</span> <span class="p_context"> static int pfkey_broadcast(struct sk_buff *skb, gfp_t allocation,</span>
 	rcu_read_unlock();
 
 	if (one_sk != NULL)
<span class="p_del">-		err = pfkey_broadcast_one(skb, &amp;skb2, allocation, one_sk);</span>
<span class="p_add">+		err = pfkey_broadcast_one(skb, &amp;skb2, GFP_KERNEL, one_sk);</span>
 
 	kfree_skb(skb2);
 	kfree_skb(skb);
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> static int pfkey_do_dump(struct pfkey_sock *pfk)</span>
 		hdr = (struct sadb_msg *) pfk-&gt;dump.skb-&gt;data;
 		hdr-&gt;sadb_msg_seq = 0;
 		hdr-&gt;sadb_msg_errno = rc;
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 		pfk-&gt;dump.skb = NULL;
 	}
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> static int pfkey_error(const struct sadb_msg *orig, int err, struct sock *sk)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) /
 			     sizeof(uint64_t));
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1361,7 +1361,7 @@</span> <span class="p_context"> static int pfkey_getspi(struct sock *sk, struct sk_buff *skb, const struct sadb_</span>
 
 	xfrm_state_put(x);
 
<span class="p_del">-	pfkey_broadcast(resp_skb, GFP_KERNEL, BROADCAST_ONE, sk, net);</span>
<span class="p_add">+	pfkey_broadcast(resp_skb, BROADCAST_ONE, sk, net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1449,7 +1449,7 @@</span> <span class="p_context"> static int key_notify_sa(struct xfrm_state *x, const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	hdr-&gt;sadb_msg_pid = c-&gt;pid;
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, xs_net(x));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1566,7 +1566,7 @@</span> <span class="p_context"> static int pfkey_get(struct sock *sk, struct sk_buff *skb, const struct sadb_msg</span>
 	out_hdr-&gt;sadb_msg_reserved = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1667,7 +1667,7 @@</span> <span class="p_context"> static int pfkey_register(struct sock *sk, struct sk_buff *skb, const struct sad</span>
 		return -ENOBUFS;
 	}
 
<span class="p_del">-	pfkey_broadcast(supp_skb, GFP_KERNEL, BROADCAST_REGISTERED, sk, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(supp_skb, BROADCAST_REGISTERED, sk, sock_net(sk));</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1686,7 +1686,7 @@</span> <span class="p_context"> static int unicast_flush_resp(struct sock *sk, const struct sadb_msg *ihdr)</span>
 	hdr-&gt;sadb_msg_errno = (uint8_t) 0;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 
<span class="p_del">-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ONE, sk, sock_net(sk));</span>
<span class="p_add">+	return pfkey_broadcast(skb, BROADCAST_ONE, sk, sock_net(sk));</span>
 }
 
 static int key_notify_sa_flush(const struct km_event *c)
<span class="p_chunk">@@ -1707,7 +1707,7 @@</span> <span class="p_context"> static int key_notify_sa_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, c-&gt;net);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -1768,7 +1768,7 @@</span> <span class="p_context"> static int dump_sa(struct xfrm_state *x, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_pid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -1829,7 +1829,7 @@</span> <span class="p_context"> static int pfkey_promisc(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 		new_hdr-&gt;sadb_msg_errno = 0;
 	}
 
<span class="p_del">-	pfkey_broadcast(skb, GFP_KERNEL, BROADCAST_ALL, NULL, sock_net(sk));</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, sock_net(sk));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -2160,7 +2160,7 @@</span> <span class="p_context"> static int key_notify_policy(struct xfrm_policy *xp, int dir, const struct km_ev</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = c-&gt;seq;
 	out_hdr-&gt;sadb_msg_pid = c-&gt;pid;
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ALL, NULL, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_ALL, NULL, xp_net(xp));</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2386,7 +2386,7 @@</span> <span class="p_context"> static int key_pol_get_resp(struct sock *sk, struct xfrm_policy *xp, const struc</span>
 	out_hdr-&gt;sadb_msg_errno = 0;
 	out_hdr-&gt;sadb_msg_seq = hdr-&gt;sadb_msg_seq;
 	out_hdr-&gt;sadb_msg_pid = hdr-&gt;sadb_msg_pid;
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_ONE, sk, xp_net(xp));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_ONE, sk, xp_net(xp));</span>
 	err = 0;
 
 out:
<span class="p_chunk">@@ -2639,7 +2639,7 @@</span> <span class="p_context"> static int dump_sp(struct xfrm_policy *xp, int dir, int count, void *ptr)</span>
 	out_hdr-&gt;sadb_msg_pid = pfk-&gt;dump.msg_pid;
 
 	if (pfk-&gt;dump.skb)
<span class="p_del">-		pfkey_broadcast(pfk-&gt;dump.skb, GFP_ATOMIC, BROADCAST_ONE,</span>
<span class="p_add">+		pfkey_broadcast(pfk-&gt;dump.skb, BROADCAST_ONE,</span>
 				&amp;pfk-&gt;sk, sock_net(&amp;pfk-&gt;sk));
 	pfk-&gt;dump.skb = out_skb;
 
<span class="p_chunk">@@ -2690,7 +2690,7 @@</span> <span class="p_context"> static int key_notify_policy_flush(const struct km_event *c)</span>
 	hdr-&gt;sadb_msg_satype = SADB_SATYPE_UNSPEC;
 	hdr-&gt;sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));
 	hdr-&gt;sadb_msg_reserved = 0;
<span class="p_del">-	pfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c-&gt;net);</span>
<span class="p_add">+	pfkey_broadcast(skb_out, BROADCAST_ALL, NULL, c-&gt;net);</span>
 	return 0;
 
 }
<span class="p_chunk">@@ -2756,7 +2756,7 @@</span> <span class="p_context"> static int pfkey_process(struct sock *sk, struct sk_buff *skb, const struct sadb</span>
 	void *ext_hdrs[SADB_EXT_MAX];
 	int err;
 
<span class="p_del">-	pfkey_broadcast(skb_clone(skb, GFP_KERNEL), GFP_KERNEL,</span>
<span class="p_add">+	pfkey_broadcast(skb_clone(skb, GFP_KERNEL),</span>
 			BROADCAST_PROMISC_ONLY, NULL, sock_net(sk));
 
 	memset(ext_hdrs, 0, sizeof(ext_hdrs));
<span class="p_chunk">@@ -2962,7 +2962,7 @@</span> <span class="p_context"> static int key_notify_sa_expire(struct xfrm_state *x, const struct km_event *c)</span>
 	out_hdr-&gt;sadb_msg_seq = 0;
 	out_hdr-&gt;sadb_msg_pid = 0;
 
<span class="p_del">-	pfkey_broadcast(out_skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	pfkey_broadcast(out_skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -3134,7 +3134,7 @@</span> <span class="p_context"> static int pfkey_send_acquire(struct xfrm_state *x, struct xfrm_tmpl *t, struct</span>
 		       xfrm_ctx-&gt;ctx_len);
 	}
 
<span class="p_del">-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
 }
 
 static struct xfrm_policy *pfkey_compile_policy(struct sock *sk, int opt,
<span class="p_chunk">@@ -3332,7 +3332,7 @@</span> <span class="p_context"> static int pfkey_send_new_mapping(struct xfrm_state *x, xfrm_address_t *ipaddr,</span>
 	n_port-&gt;sadb_x_nat_t_port_port = sport;
 	n_port-&gt;sadb_x_nat_t_port_reserved = 0;
 
<span class="p_del">-	return pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
<span class="p_add">+	return pfkey_broadcast(skb, BROADCAST_REGISTERED, NULL, xs_net(x));</span>
 }
 
 #ifdef CONFIG_NET_KEY_MIGRATE
<span class="p_chunk">@@ -3524,7 +3524,7 @@</span> <span class="p_context"> static int pfkey_send_migrate(const struct xfrm_selector *sel, u8 dir, u8 type,</span>
 	}
 
 	/* broadcast migrate message to sockets */
<span class="p_del">-	pfkey_broadcast(skb, GFP_ATOMIC, BROADCAST_ALL, NULL, &amp;init_net);</span>
<span class="p_add">+	pfkey_broadcast(skb, BROADCAST_ALL, NULL, &amp;init_net);</span>
 
 	return 0;
 
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index 65df296..91826b6 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -278,9 +278,6 @@</span> <span class="p_context"> ieee80211_tx_h_check_assoc(struct ieee80211_tx_data *tx)</span>
 	if (tx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_WDS)
 		return TX_CONTINUE;
 
<span class="p_del">-	if (tx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_MESH_POINT)</span>
<span class="p_del">-		return TX_CONTINUE;</span>
<span class="p_del">-</span>
 	if (tx-&gt;flags &amp; IEEE80211_TX_PS_BUFFERED)
 		return TX_CONTINUE;
 
<span class="p_header">diff --git a/net/rds/connection.c b/net/rds/connection.c</span>
<span class="p_header">index 9e07c75..be3eecd 100644</span>
<span class="p_header">--- a/net/rds/connection.c</span>
<span class="p_header">+++ b/net/rds/connection.c</span>
<span class="p_chunk">@@ -178,6 +178,12 @@</span> <span class="p_context"> static struct rds_connection *__rds_conn_create(__be32 laddr, __be32 faddr,</span>
 		}
 	}
 
<span class="p_add">+	if (trans == NULL) {</span>
<span class="p_add">+		kmem_cache_free(rds_conn_slab, conn);</span>
<span class="p_add">+		conn = ERR_PTR(-ENODEV);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	conn-&gt;c_trans = trans;
 
 	ret = trans-&gt;conn_alloc(conn, gfp);
<span class="p_header">diff --git a/net/rds/info.c b/net/rds/info.c</span>
<span class="p_header">index f1c016c..a4adb39 100644</span>
<span class="p_header">--- a/net/rds/info.c</span>
<span class="p_header">+++ b/net/rds/info.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> int rds_info_getsockopt(struct socket *sock, int optname, char __user *optval,</span>
 
 	/* check for all kinds of wrapping and the like */
 	start = (unsigned long)optval;
<span class="p_del">-	if (len &lt; 0 || len + PAGE_SIZE - 1 &lt; len || start + len &lt; start) {</span>
<span class="p_add">+	if (len &lt; 0 || len &gt; INT_MAX - PAGE_SIZE + 1 || start + len &lt; start) {</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/net/sctp/output.c b/net/sctp/output.c</span>
<span class="p_header">index 6d56eec..c3b8549 100644</span>
<span class="p_header">--- a/net/sctp/output.c</span>
<span class="p_header">+++ b/net/sctp/output.c</span>
<span class="p_chunk">@@ -587,9 +587,7 @@</span> <span class="p_context"> out:</span>
 	return err;
 no_route:
 	kfree_skb(nskb);
<span class="p_del">-</span>
<span class="p_del">-	if (asoc)</span>
<span class="p_del">-		IP_INC_STATS(&amp;init_net, IPSTATS_MIB_OUTNOROUTES);</span>
<span class="p_add">+	IP_INC_STATS(&amp;init_net, IPSTATS_MIB_OUTNOROUTES);</span>
 
 	/* FIXME: Returning the &#39;err&#39; will effect all the associations
 	 * associated with a socket, although only one of the paths of the
<span class="p_header">diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c</span>
<span class="p_header">index 76388b0..581c06a 100644</span>
<span class="p_header">--- a/net/sctp/sm_sideeffect.c</span>
<span class="p_header">+++ b/net/sctp/sm_sideeffect.c</span>
<span class="p_chunk">@@ -681,7 +681,7 @@</span> <span class="p_context"> static void sctp_cmd_transport_on(sctp_cmd_seq_t *cmds,</span>
 	 * outstanding data and rely on the retransmission limit be reached
 	 * to shutdown the association.
 	 */
<span class="p_del">-	if (t-&gt;asoc-&gt;state != SCTP_STATE_SHUTDOWN_PENDING)</span>
<span class="p_add">+	if (t-&gt;asoc-&gt;state &lt; SCTP_STATE_SHUTDOWN_PENDING)</span>
 		t-&gt;asoc-&gt;overall_error_count = 0;
 
 	/* Clear the hb_sent flag to signal that we had a good
<span class="p_header">diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c</span>
<span class="p_header">index d77a4f0..3a82fec 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtsock.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtsock.c</span>
<span class="p_chunk">@@ -811,6 +811,7 @@</span> <span class="p_context"> static void xs_reset_transport(struct sock_xprt *transport)</span>
 {
 	struct socket *sock = transport-&gt;sock;
 	struct sock *sk = transport-&gt;inet;
<span class="p_add">+	struct rpc_xprt *xprt = &amp;transport-&gt;xprt;</span>
 
 	if (sk == NULL)
 		return;
<span class="p_chunk">@@ -824,6 +825,7 @@</span> <span class="p_context"> static void xs_reset_transport(struct sock_xprt *transport)</span>
 	sk-&gt;sk_user_data = NULL;
 
 	xs_restore_old_callbacks(transport, sk);
<span class="p_add">+	xprt_clear_connected(xprt);</span>
 	write_unlock_bh(&amp;sk-&gt;sk_callback_lock);
 
 	sk-&gt;sk_no_check = 0;
<span class="p_header">diff --git a/net/tipc/socket.c b/net/tipc/socket.c</span>
<span class="p_header">index 058941e..580ecf2 100644</span>
<span class="p_header">--- a/net/tipc/socket.c</span>
<span class="p_header">+++ b/net/tipc/socket.c</span>
<span class="p_chunk">@@ -1541,6 +1541,8 @@</span> <span class="p_context"> static int accept(struct socket *sock, struct socket *new_sock, int flags)</span>
 		u32 new_ref = new_tport-&gt;ref;
 		struct tipc_msg *msg = buf_msg(buf);
 
<span class="p_add">+		security_sk_clone(sock-&gt;sk, new_sock-&gt;sk);</span>
<span class="p_add">+</span>
 		lock_sock(new_sk);
 
 		/*
<span class="p_header">diff --git a/scripts/kconfig/streamline_config.pl b/scripts/kconfig/streamline_config.pl</span>
<span class="p_header">index 3346f42..4a19a7f 100644</span>
<span class="p_header">--- a/scripts/kconfig/streamline_config.pl</span>
<span class="p_header">+++ b/scripts/kconfig/streamline_config.pl</span>
<span class="p_chunk">@@ -125,7 +125,7 @@</span> <span class="p_context"> my $ksource = $ARGV[0];</span>
 my $kconfig = $ARGV[1];
 my $lsmod_file = $ENV{&#39;LSMOD&#39;};
 
<span class="p_del">-my @makefiles = `find $ksource -name Makefile 2&gt;/dev/null`;</span>
<span class="p_add">+my @makefiles = `find $ksource -name Makefile -or -name Kbuild 2&gt;/dev/null`;</span>
 chomp @makefiles;
 
 my %depends;
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index 0cd7097a..c279f2f 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -1011,7 +1011,7 @@</span> <span class="p_context"> static void selinux_write_opts(struct seq_file *m,</span>
 		seq_puts(m, prefix);
 		if (has_comma)
 			seq_putc(m, &#39;\&quot;&#39;);
<span class="p_del">-		seq_puts(m, opts-&gt;mnt_opts[i]);</span>
<span class="p_add">+		seq_escape(m, opts-&gt;mnt_opts[i], &quot;\&quot;\n\\&quot;);</span>
 		if (has_comma)
 			seq_putc(m, &#39;\&quot;&#39;);
 	}
<span class="p_header">diff --git a/sound/arm/Kconfig b/sound/arm/Kconfig</span>
<span class="p_header">index 885683a..e040621 100644</span>
<span class="p_header">--- a/sound/arm/Kconfig</span>
<span class="p_header">+++ b/sound/arm/Kconfig</span>
<span class="p_chunk">@@ -9,6 +9,14 @@</span> <span class="p_context"> menuconfig SND_ARM</span>
 	  Drivers that are implemented on ASoC can be found in
 	  &quot;ALSA for SoC audio support&quot; section.
 
<span class="p_add">+config SND_PXA2XX_LIB</span>
<span class="p_add">+	tristate</span>
<span class="p_add">+	select SND_AC97_CODEC if SND_PXA2XX_LIB_AC97</span>
<span class="p_add">+	select SND_DMAENGINE_PCM</span>
<span class="p_add">+</span>
<span class="p_add">+config SND_PXA2XX_LIB_AC97</span>
<span class="p_add">+	bool</span>
<span class="p_add">+</span>
 if SND_ARM
 
 config SND_ARMAACI
<span class="p_chunk">@@ -21,13 +29,6 @@</span> <span class="p_context"> config SND_PXA2XX_PCM</span>
 	tristate
 	select SND_PCM
 
<span class="p_del">-config SND_PXA2XX_LIB</span>
<span class="p_del">-	tristate</span>
<span class="p_del">-	select SND_AC97_CODEC if SND_PXA2XX_LIB_AC97</span>
<span class="p_del">-</span>
<span class="p_del">-config SND_PXA2XX_LIB_AC97</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
 config SND_PXA2XX_AC97
 	tristate &quot;AC97 driver for the Intel PXA2xx chip&quot;
 	depends on ARCH_PXA
<span class="p_header">diff --git a/sound/soc/pxa/Kconfig b/sound/soc/pxa/Kconfig</span>
<span class="p_header">index a0f7d3c..23deb67 100644</span>
<span class="p_header">--- a/sound/soc/pxa/Kconfig</span>
<span class="p_header">+++ b/sound/soc/pxa/Kconfig</span>
<span class="p_chunk">@@ -1,7 +1,6 @@</span> <span class="p_context"></span>
 config SND_PXA2XX_SOC
 	tristate &quot;SoC Audio for the Intel PXA2xx chip&quot;
 	depends on ARCH_PXA
<span class="p_del">-	select SND_ARM</span>
 	select SND_PXA2XX_LIB
 	help
 	  Say Y or M if you want to add support for codecs attached to
<span class="p_chunk">@@ -15,7 +14,6 @@</span> <span class="p_context"> config SND_PXA2XX_AC97</span>
 config SND_PXA2XX_SOC_AC97
 	tristate
 	select AC97_BUS
<span class="p_del">-	select SND_ARM</span>
 	select SND_PXA2XX_LIB_AC97
 	select SND_SOC_AC97_BUS
 
<span class="p_header">diff --git a/tools/perf/Makefile b/tools/perf/Makefile</span>
<span class="p_header">index e45d2b1..6c871c0 100644</span>
<span class="p_header">--- a/tools/perf/Makefile</span>
<span class="p_header">+++ b/tools/perf/Makefile</span>
<span class="p_chunk">@@ -739,10 +739,10 @@</span> <span class="p_context"> $(OUTPUT)util/rbtree.o: ../../lib/rbtree.c $(OUTPUT)PERF-CFLAGS</span>
 	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) -DETC_PERFCONFIG=&#39;&quot;$(ETC_PERFCONFIG_SQ)&quot;&#39; $&lt;
 
 $(OUTPUT)util/scripting-engines/trace-event-perl.o: util/scripting-engines/trace-event-perl.c $(OUTPUT)PERF-CFLAGS
<span class="p_del">-	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-shadow $&lt;</span>
<span class="p_add">+	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-shadow -Wno-undef -Wno-switch-default $&lt;</span>
 
 $(OUTPUT)scripts/perl/Perf-Trace-Util/Context.o: scripts/perl/Perf-Trace-Util/Context.c $(OUTPUT)PERF-CFLAGS
<span class="p_del">-	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-nested-externs $&lt;</span>
<span class="p_add">+	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PERL_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-nested-externs -Wno-undef -Wno-switch-default $&lt;</span>
 
 $(OUTPUT)util/scripting-engines/trace-event-python.o: util/scripting-engines/trace-event-python.c $(OUTPUT)PERF-CFLAGS
 	$(QUIET_CC)$(CC) -o $@ -c $(ALL_CFLAGS) $(PYTHON_EMBED_CCOPTS) -Wno-redundant-decls -Wno-strict-prototypes -Wno-unused-parameter -Wno-shadow $&lt;
<span class="p_header">diff --git a/tools/perf/util/header.c b/tools/perf/util/header.c</span>
<span class="p_header">index 2cd88c1..7a75ecb 100644</span>
<span class="p_header">--- a/tools/perf/util/header.c</span>
<span class="p_header">+++ b/tools/perf/util/header.c</span>
<span class="p_chunk">@@ -796,25 +796,19 @@</span> <span class="p_context"> static void print_cpudesc(struct perf_header *ph, int fd, FILE *fp)</span>
 static void print_nrcpus(struct perf_header *ph, int fd, FILE *fp)
 {
 	ssize_t ret;
<span class="p_del">-	u32 nr;</span>
<span class="p_add">+	u32 nr[2];</span>
 
 	ret = read(fd, &amp;nr, sizeof(nr));
 	if (ret != (ssize_t)sizeof(nr))
<span class="p_del">-		nr = -1; /* interpreted as error */</span>
<span class="p_add">+		nr[0] = nr[1] = -1; /* interpreted as error */</span>
 
<span class="p_del">-	if (ph-&gt;needs_swap)</span>
<span class="p_del">-		nr = bswap_32(nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	fprintf(fp, &quot;# nrcpus online : %u\n&quot;, nr);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = read(fd, &amp;nr, sizeof(nr));</span>
<span class="p_del">-	if (ret != (ssize_t)sizeof(nr))</span>
<span class="p_del">-		nr = -1; /* interpreted as error */</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ph-&gt;needs_swap)</span>
<span class="p_del">-		nr = bswap_32(nr);</span>
<span class="p_add">+	if (ph-&gt;needs_swap) {</span>
<span class="p_add">+		nr[0] = bswap_32(nr[0]);</span>
<span class="p_add">+		nr[1] = bswap_32(nr[1]);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	fprintf(fp, &quot;# nrcpus avail : %u\n&quot;, nr);</span>
<span class="p_add">+	fprintf(fp, &quot;# nrcpus online : %u\n&quot;, nr[1]);</span>
<span class="p_add">+	fprintf(fp, &quot;# nrcpus avail : %u\n&quot;, nr[0]);</span>
 }
 
 static void print_version(struct perf_header *ph, int fd, FILE *fp)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



