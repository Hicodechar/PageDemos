
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.91 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.91</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 8, 2017, 8:58 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171008085801.GB31281@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9991781/mbox/"
   >mbox</a>
|
   <a href="/patch/9991781/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9991781/">/patch/9991781/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	DA8DF60231 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:58:05 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B6BC228650
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:58:05 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A762528660; Sun,  8 Oct 2017 08:58:05 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id F3EFD28650
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun,  8 Oct 2017 08:58:01 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753431AbdJHI57 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 8 Oct 2017 04:57:59 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:32874 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753290AbdJHI5y (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 8 Oct 2017 04:57:54 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id D303C97;
	Sun,  8 Oct 2017 08:57:52 +0000 (UTC)
Date: Sun, 8 Oct 2017 10:58:01 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.91
Message-ID: &lt;20171008085801.GB31281@kroah.com&gt;
References: &lt;20171008085752.GA31281@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171008085752.GA31281@kroah.com&gt;
User-Agent: Mutt/1.9.1 (2017-09-22)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Oct. 8, 2017, 8:58 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt b/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt</span>
new file mode 100644
<span class="p_header">index 000000000000..6ec1a880ac18</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/display/bridge/ti,ths8135.txt</span>
<span class="p_chunk">@@ -0,0 +1,46 @@</span> <span class="p_context"></span>
<span class="p_add">+THS8135 Video DAC</span>
<span class="p_add">+-----------------</span>
<span class="p_add">+</span>
<span class="p_add">+This is the binding for Texas Instruments THS8135 Video DAC bridge.</span>
<span class="p_add">+</span>
<span class="p_add">+Required properties:</span>
<span class="p_add">+</span>
<span class="p_add">+- compatible: Must be &quot;ti,ths8135&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+Required nodes:</span>
<span class="p_add">+</span>
<span class="p_add">+This device has two video ports. Their connections are modelled using the OF</span>
<span class="p_add">+graph bindings specified in Documentation/devicetree/bindings/graph.txt.</span>
<span class="p_add">+</span>
<span class="p_add">+- Video port 0 for RGB input</span>
<span class="p_add">+- Video port 1 for VGA output</span>
<span class="p_add">+</span>
<span class="p_add">+Example</span>
<span class="p_add">+-------</span>
<span class="p_add">+</span>
<span class="p_add">+vga-bridge {</span>
<span class="p_add">+	compatible = &quot;ti,ths8135&quot;;</span>
<span class="p_add">+	#address-cells = &lt;1&gt;;</span>
<span class="p_add">+	#size-cells = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+	ports {</span>
<span class="p_add">+		#address-cells = &lt;1&gt;;</span>
<span class="p_add">+		#size-cells = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+		port@0 {</span>
<span class="p_add">+			reg = &lt;0&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+			vga_bridge_in: endpoint {</span>
<span class="p_add">+				remote-endpoint = &lt;&amp;lcdc_out_vga&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+		};</span>
<span class="p_add">+</span>
<span class="p_add">+		port@1 {</span>
<span class="p_add">+			reg = &lt;1&gt;;</span>
<span class="p_add">+</span>
<span class="p_add">+			vga_bridge_out: endpoint {</span>
<span class="p_add">+				remote-endpoint = &lt;&amp;vga_con_in&gt;;</span>
<span class="p_add">+			};</span>
<span class="p_add">+		};</span>
<span class="p_add">+	};</span>
<span class="p_add">+};</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt b/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt</span>
new file mode 100644
<span class="p_header">index 000000000000..b3629405f568</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/iio/adc/avia-hx711.txt</span>
<span class="p_chunk">@@ -0,0 +1,18 @@</span> <span class="p_context"></span>
<span class="p_add">+* AVIA HX711 ADC chip for weight cells</span>
<span class="p_add">+  Bit-banging driver</span>
<span class="p_add">+</span>
<span class="p_add">+Required properties:</span>
<span class="p_add">+ - compatible:	Should be &quot;avia,hx711&quot;</span>
<span class="p_add">+ - sck-gpios:	Definition of the GPIO for the clock</span>
<span class="p_add">+ - dout-gpios:	Definition of the GPIO for data-out</span>
<span class="p_add">+		See Documentation/devicetree/bindings/gpio/gpio.txt</span>
<span class="p_add">+ - avdd-supply:	Definition of the regulator used as analog supply</span>
<span class="p_add">+</span>
<span class="p_add">+Example:</span>
<span class="p_add">+weight@0 {</span>
<span class="p_add">+	compatible = &quot;avia,hx711&quot;;</span>
<span class="p_add">+	sck-gpios = &lt;&amp;gpio3 10 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	dout-gpios = &lt;&amp;gpio0 7 GPIO_ACTIVE_HIGH&gt;;</span>
<span class="p_add">+	avdd-suppy = &lt;&amp;avdd&gt;;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/vendor-prefixes.txt b/Documentation/devicetree/bindings/vendor-prefixes.txt</span>
<span class="p_header">index 55df1d444e9f..98dc17507a84 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/vendor-prefixes.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/vendor-prefixes.txt</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"> asahi-kasei	Asahi Kasei Corp.</span>
 atmel	Atmel Corporation
 auo	AU Optronics Corporation
 avago	Avago Technologies
<span class="p_add">+avia	avia semiconductor</span>
 avic	Shanghai AVIC Optoelectronics Co., Ltd.
 axis	Axis Communications AB
 bosch	Bosch Sensortec GmbH
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index ca5aaaf4aef7..c1db50ef7fb5 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 90</span>
<span class="p_add">+SUBLEVEL = 91</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/Kconfig-nommu b/arch/arm/Kconfig-nommu</span>
<span class="p_header">index aed66d5df7f1..b7576349528c 100644</span>
<span class="p_header">--- a/arch/arm/Kconfig-nommu</span>
<span class="p_header">+++ b/arch/arm/Kconfig-nommu</span>
<span class="p_chunk">@@ -34,8 +34,7 @@</span> <span class="p_context"> config PROCESSOR_ID</span>
 	  used instead of the auto-probing which utilizes the register.
 
 config REMAP_VECTORS_TO_RAM
<span class="p_del">-	bool &#39;Install vectors to the beginning of RAM&#39; if DRAM_BASE</span>
<span class="p_del">-	depends on DRAM_BASE</span>
<span class="p_add">+	bool &#39;Install vectors to the beginning of RAM&#39;</span>
 	help
 	  The kernel needs to change the hardware exception vectors.
 	  In nommu mode, the hardware exception vectors are normally
<span class="p_header">diff --git a/arch/arm/boot/dts/r8a7790.dtsi b/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_header">index e07ae5d45e19..7b39d8fae61e 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/r8a7790.dtsi</span>
<span class="p_chunk">@@ -1409,7 +1409,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof0: spi@e6e20000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6e20000 0 0x0064&gt;;
 		interrupts = &lt;0 156 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp0_clks R8A7790_CLK_MSIOF0&gt;;
<span class="p_chunk">@@ -1422,7 +1423,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof1: spi@e6e10000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6e10000 0 0x0064&gt;;
 		interrupts = &lt;0 157 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp2_clks R8A7790_CLK_MSIOF1&gt;;
<span class="p_chunk">@@ -1435,7 +1437,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof2: spi@e6e00000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6e00000 0 0x0064&gt;;
 		interrupts = &lt;0 158 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp2_clks R8A7790_CLK_MSIOF2&gt;;
<span class="p_chunk">@@ -1448,7 +1451,8 @@</span> <span class="p_context"></span>
 	};
 
 	msiof3: spi@e6c90000 {
<span class="p_del">-		compatible = &quot;renesas,msiof-r8a7790&quot;;</span>
<span class="p_add">+		compatible = &quot;renesas,msiof-r8a7790&quot;,</span>
<span class="p_add">+			     &quot;renesas,rcar-gen2-msiof&quot;;</span>
 		reg = &lt;0 0xe6c90000 0 0x0064&gt;;
 		interrupts = &lt;0 159 IRQ_TYPE_LEVEL_HIGH&gt;;
 		clocks = &lt;&amp;mstp2_clks R8A7790_CLK_MSIOF3&gt;;
<span class="p_header">diff --git a/arch/arm/mach-at91/pm.c b/arch/arm/mach-at91/pm.c</span>
<span class="p_header">index d687f860a2da..84eefbc2b4f9 100644</span>
<span class="p_header">--- a/arch/arm/mach-at91/pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-at91/pm.c</span>
<span class="p_chunk">@@ -332,7 +332,7 @@</span> <span class="p_context"> static void at91sam9_sdram_standby(void)</span>
 		at91_ramc_write(1, AT91_SDRAMC_LPR, saved_lpr1);
 }
 
<span class="p_del">-static const struct of_device_id const ramc_ids[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id ramc_ids[] __initconst = {</span>
 	{ .compatible = &quot;atmel,at91rm9200-sdramc&quot;, .data = at91rm9200_standby },
 	{ .compatible = &quot;atmel,at91sam9260-sdramc&quot;, .data = at91sam9_sdram_standby },
 	{ .compatible = &quot;atmel,at91sam9g45-ddramc&quot;, .data = at91_ddr_standby },
<span class="p_header">diff --git a/arch/arm/mach-bcm/bcm_kona_smc.c b/arch/arm/mach-bcm/bcm_kona_smc.c</span>
<span class="p_header">index cf3f8658f0e5..a55a7ecf146a 100644</span>
<span class="p_header">--- a/arch/arm/mach-bcm/bcm_kona_smc.c</span>
<span class="p_header">+++ b/arch/arm/mach-bcm/bcm_kona_smc.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"> struct bcm_kona_smc_data {</span>
 	unsigned result;
 };
 
<span class="p_del">-static const struct of_device_id const bcm_kona_smc_ids[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id bcm_kona_smc_ids[] __initconst = {</span>
 	{.compatible = &quot;brcm,kona-smc&quot;},
 	{.compatible = &quot;bcm,kona-smc&quot;}, /* deprecated name */
 	{},
<span class="p_header">diff --git a/arch/arm/mach-cns3xxx/core.c b/arch/arm/mach-cns3xxx/core.c</span>
<span class="p_header">index 9b1dc223d8d3..e17a0e025f62 100644</span>
<span class="p_header">--- a/arch/arm/mach-cns3xxx/core.c</span>
<span class="p_header">+++ b/arch/arm/mach-cns3xxx/core.c</span>
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static struct usb_ohci_pdata cns3xxx_usb_ohci_pdata = {</span>
 	.power_off	= csn3xxx_usb_power_off,
 };
 
<span class="p_del">-static const struct of_dev_auxdata const cns3xxx_auxdata[] __initconst = {</span>
<span class="p_add">+static const struct of_dev_auxdata cns3xxx_auxdata[] __initconst = {</span>
 	{ &quot;intel,usb-ehci&quot;, CNS3XXX_USB_BASE, &quot;ehci-platform&quot;, &amp;cns3xxx_usb_ehci_pdata },
 	{ &quot;intel,usb-ohci&quot;, CNS3XXX_USB_OHCI_BASE, &quot;ohci-platform&quot;, &amp;cns3xxx_usb_ohci_pdata },
 	{ &quot;cavium,cns3420-ahci&quot;, CNS3XXX_SATA2_BASE, &quot;ahci&quot;, NULL },
<span class="p_header">diff --git a/arch/arm/mach-omap2/prm_common.c b/arch/arm/mach-omap2/prm_common.c</span>
<span class="p_header">index 3fc2cbe52113..0ce4548ef7f0 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/prm_common.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/prm_common.c</span>
<span class="p_chunk">@@ -706,7 +706,7 @@</span> <span class="p_context"> static struct omap_prcm_init_data scrm_data __initdata = {</span>
 };
 #endif
 
<span class="p_del">-static const struct of_device_id const omap_prcm_dt_match_table[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id omap_prcm_dt_match_table[] __initconst = {</span>
 #ifdef CONFIG_SOC_AM33XX
 	{ .compatible = &quot;ti,am3-prcm&quot;, .data = &amp;am3_prm_data },
 #endif
<span class="p_header">diff --git a/arch/arm/mach-omap2/vc.c b/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">index 2028167fff31..d76b1e5eb8ba 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/vc.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/vc.c</span>
<span class="p_chunk">@@ -559,7 +559,7 @@</span> <span class="p_context"> struct i2c_init_data {</span>
 	u8 hsscll_12;
 };
 
<span class="p_del">-static const struct i2c_init_data const omap4_i2c_timing_data[] __initconst = {</span>
<span class="p_add">+static const struct i2c_init_data omap4_i2c_timing_data[] __initconst = {</span>
 	{
 		.load = 50,
 		.loadbits = 0x3,
<span class="p_header">diff --git a/arch/arm/mach-spear/time.c b/arch/arm/mach-spear/time.c</span>
<span class="p_header">index 9ccffc1d0f28..aaaa6781b9fe 100644</span>
<span class="p_header">--- a/arch/arm/mach-spear/time.c</span>
<span class="p_header">+++ b/arch/arm/mach-spear/time.c</span>
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> static void __init spear_clockevent_init(int irq)</span>
 	setup_irq(irq, &amp;spear_timer_irq);
 }
 
<span class="p_del">-static const struct of_device_id const timer_of_match[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id timer_of_match[] __initconst = {</span>
 	{ .compatible = &quot;st,spear-timer&quot;, },
 	{ },
 };
<span class="p_header">diff --git a/arch/mips/include/asm/irq.h b/arch/mips/include/asm/irq.h</span>
<span class="p_header">index ebb9efb02502..77edb22f855d 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/irq.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/irq.h</span>
<span class="p_chunk">@@ -18,9 +18,24 @@</span> <span class="p_context"></span>
 #include &lt;irq.h&gt;
 
 #define IRQ_STACK_SIZE			THREAD_SIZE
<span class="p_add">+#define IRQ_STACK_START			(IRQ_STACK_SIZE - sizeof(unsigned long))</span>
 
 extern void *irq_stack[NR_CPUS];
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The highest address on the IRQ stack contains a dummy frame put down in</span>
<span class="p_add">+ * genex.S (handle_int &amp; except_vec_vi_handler) which is structured as follows:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   top ------------</span>
<span class="p_add">+ *       | task sp  | &lt;- irq_stack[cpu] + IRQ_STACK_START</span>
<span class="p_add">+ *       ------------</span>
<span class="p_add">+ *       |          | &lt;- First frame of IRQ context</span>
<span class="p_add">+ *       ------------</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * task sp holds a copy of the task stack pointer where the struct pt_regs</span>
<span class="p_add">+ * from exception entry can be found.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
 static inline bool on_irq_stack(int cpu, unsigned long sp)
 {
 	unsigned long low = (unsigned long)irq_stack[cpu];
<span class="p_header">diff --git a/arch/mips/kernel/asm-offsets.c b/arch/mips/kernel/asm-offsets.c</span>
<span class="p_header">index ec053ce7bb38..7ab8004c1659 100644</span>
<span class="p_header">--- a/arch/mips/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/mips/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -102,6 +102,7 @@</span> <span class="p_context"> void output_thread_info_defines(void)</span>
 	DEFINE(_THREAD_SIZE, THREAD_SIZE);
 	DEFINE(_THREAD_MASK, THREAD_MASK);
 	DEFINE(_IRQ_STACK_SIZE, IRQ_STACK_SIZE);
<span class="p_add">+	DEFINE(_IRQ_STACK_START, IRQ_STACK_START);</span>
 	BLANK();
 }
 
<span class="p_header">diff --git a/arch/mips/kernel/genex.S b/arch/mips/kernel/genex.S</span>
<span class="p_header">index 619e30e2c4f0..bb72f3ce7e29 100644</span>
<span class="p_header">--- a/arch/mips/kernel/genex.S</span>
<span class="p_header">+++ b/arch/mips/kernel/genex.S</span>
<span class="p_chunk">@@ -216,9 +216,11 @@</span> <span class="p_context"> NESTED(handle_int, PT_SIZE, sp)</span>
 	beq	t0, t1, 2f
 
 	/* Switch to IRQ stack */
<span class="p_del">-	li	t1, _IRQ_STACK_SIZE</span>
<span class="p_add">+	li	t1, _IRQ_STACK_START</span>
 	PTR_ADD sp, t0, t1
 
<span class="p_add">+	/* Save task&#39;s sp on IRQ stack so that unwinding can follow it */</span>
<span class="p_add">+	LONG_S	s1, 0(sp)</span>
 2:
 	jal	plat_irq_dispatch
 
<span class="p_chunk">@@ -326,9 +328,11 @@</span> <span class="p_context"> NESTED(except_vec_vi_handler, 0, sp)</span>
 	beq	t0, t1, 2f
 
 	/* Switch to IRQ stack */
<span class="p_del">-	li	t1, _IRQ_STACK_SIZE</span>
<span class="p_add">+	li	t1, _IRQ_STACK_START</span>
 	PTR_ADD sp, t0, t1
 
<span class="p_add">+	/* Save task&#39;s sp on IRQ stack so that unwinding can follow it */</span>
<span class="p_add">+	LONG_S	s1, 0(sp)</span>
 2:
 	jalr	v0
 
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index 8c26ecac930d..477ba026c3e5 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -483,31 +483,52 @@</span> <span class="p_context"> unsigned long notrace unwind_stack_by_address(unsigned long stack_page,</span>
 					      unsigned long pc,
 					      unsigned long *ra)
 {
<span class="p_add">+	unsigned long low, high, irq_stack_high;</span>
 	struct mips_frame_info info;
 	unsigned long size, ofs;
<span class="p_add">+	struct pt_regs *regs;</span>
 	int leaf;
<span class="p_del">-	extern void ret_from_irq(void);</span>
<span class="p_del">-	extern void ret_from_exception(void);</span>
 
 	if (!stack_page)
 		return 0;
 
 	/*
<span class="p_del">-	 * If we reached the bottom of interrupt context,</span>
<span class="p_del">-	 * return saved pc in pt_regs.</span>
<span class="p_add">+	 * IRQ stacks start at IRQ_STACK_START</span>
<span class="p_add">+	 * task stacks at THREAD_SIZE - 32</span>
 	 */
<span class="p_del">-	if (pc == (unsigned long)ret_from_irq ||</span>
<span class="p_del">-	    pc == (unsigned long)ret_from_exception) {</span>
<span class="p_del">-		struct pt_regs *regs;</span>
<span class="p_del">-		if (*sp &gt;= stack_page &amp;&amp;</span>
<span class="p_del">-		    *sp + sizeof(*regs) &lt;= stack_page + THREAD_SIZE - 32) {</span>
<span class="p_del">-			regs = (struct pt_regs *)*sp;</span>
<span class="p_del">-			pc = regs-&gt;cp0_epc;</span>
<span class="p_del">-			if (!user_mode(regs) &amp;&amp; __kernel_text_address(pc)) {</span>
<span class="p_del">-				*sp = regs-&gt;regs[29];</span>
<span class="p_del">-				*ra = regs-&gt;regs[31];</span>
<span class="p_del">-				return pc;</span>
<span class="p_del">-			}</span>
<span class="p_add">+	low = stack_page;</span>
<span class="p_add">+	if (!preemptible() &amp;&amp; on_irq_stack(raw_smp_processor_id(), *sp)) {</span>
<span class="p_add">+		high = stack_page + IRQ_STACK_START;</span>
<span class="p_add">+		irq_stack_high = high;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		high = stack_page + THREAD_SIZE - 32;</span>
<span class="p_add">+		irq_stack_high = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we reached the top of the interrupt stack, start unwinding</span>
<span class="p_add">+	 * the interrupted task stack.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(*sp == irq_stack_high)) {</span>
<span class="p_add">+		unsigned long task_sp = *(unsigned long *)*sp;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check that the pointer saved in the IRQ stack head points to</span>
<span class="p_add">+		 * something within the stack of the current task</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!object_is_on_stack((void *)task_sp))</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Follow pointer to tasks kernel stack frame where interrupted</span>
<span class="p_add">+		 * state was saved.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		regs = (struct pt_regs *)task_sp;</span>
<span class="p_add">+		pc = regs-&gt;cp0_epc;</span>
<span class="p_add">+		if (!user_mode(regs) &amp;&amp; __kernel_text_address(pc)) {</span>
<span class="p_add">+			*sp = regs-&gt;regs[29];</span>
<span class="p_add">+			*ra = regs-&gt;regs[31];</span>
<span class="p_add">+			return pc;</span>
 		}
 		return 0;
 	}
<span class="p_chunk">@@ -528,8 +549,7 @@</span> <span class="p_context"> unsigned long notrace unwind_stack_by_address(unsigned long stack_page,</span>
 	if (leaf &lt; 0)
 		return 0;
 
<span class="p_del">-	if (*sp &lt; stack_page ||</span>
<span class="p_del">-	    *sp + info.frame_size &gt; stack_page + THREAD_SIZE - 32)</span>
<span class="p_add">+	if (*sp &lt; low || *sp + info.frame_size &gt; high)</span>
 		return 0;
 
 	if (leaf)
<span class="p_header">diff --git a/arch/mips/kernel/vmlinux.lds.S b/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_header">index 0a93e83cd014..2026203c41e2 100644</span>
<span class="p_header">--- a/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/mips/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -159,7 +159,7 @@</span> <span class="p_context"> SECTIONS</span>
 	 * Force .bss to 64K alignment so that .bss..swapper_pg_dir
 	 * gets that alignment.	 .sbss should be empty, so there will be
 	 * no holes after __init_end. */
<span class="p_del">-	BSS_SECTION(0, 0x10000, 0)</span>
<span class="p_add">+	BSS_SECTION(0, 0x10000, 8)</span>
 
 	_end = . ;
 
<span class="p_header">diff --git a/arch/mips/lantiq/xway/sysctrl.c b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">index daf580ce5ca2..2528181232fd 100644</span>
<span class="p_header">--- a/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_header">+++ b/arch/mips/lantiq/xway/sysctrl.c</span>
<span class="p_chunk">@@ -469,8 +469,8 @@</span> <span class="p_context"> void __init ltq_soc_init(void)</span>
 			panic(&quot;Failed to load xbar nodes from devicetree&quot;);
 		if (of_address_to_resource(np_xbar, 0, &amp;res_xbar))
 			panic(&quot;Failed to get xbar resources&quot;);
<span class="p_del">-		if (request_mem_region(res_xbar.start, resource_size(&amp;res_xbar),</span>
<span class="p_del">-			res_xbar.name) &lt; 0)</span>
<span class="p_add">+		if (!request_mem_region(res_xbar.start, resource_size(&amp;res_xbar),</span>
<span class="p_add">+			res_xbar.name))</span>
 			panic(&quot;Failed to get xbar resources&quot;);
 
 		ltq_xbar_membase = ioremap_nocache(res_xbar.start,
<span class="p_header">diff --git a/arch/mips/ralink/rt3883.c b/arch/mips/ralink/rt3883.c</span>
<span class="p_header">index 3c575093f8f1..f2a6e1b8cce0 100644</span>
<span class="p_header">--- a/arch/mips/ralink/rt3883.c</span>
<span class="p_header">+++ b/arch/mips/ralink/rt3883.c</span>
<span class="p_chunk">@@ -144,5 +144,5 @@</span> <span class="p_context"> void prom_soc_init(struct ralink_soc_info *soc_info)</span>
 
 	rt2880_pinmux_data = rt3883_pinmux_data;
 
<span class="p_del">-	ralink_soc == RT3883_SOC;</span>
<span class="p_add">+	ralink_soc = RT3883_SOC;</span>
 }
<span class="p_header">diff --git a/arch/parisc/kernel/perf.c b/arch/parisc/kernel/perf.c</span>
<span class="p_header">index 518f4f5f1f43..d63d42533133 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/perf.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/perf.c</span>
<span class="p_chunk">@@ -39,7 +39,7 @@</span> <span class="p_context"></span>
  *  the PDC INTRIGUE calls.  This is done to eliminate bugs introduced
  *  in various PDC revisions.  The code is much more maintainable
  *  and reliable this way vs having to debug on every version of PDC
<span class="p_del">- *  on every box. </span>
<span class="p_add">+ *  on every box.</span>
  */
 
 #include &lt;linux/capability.h&gt;
<span class="p_chunk">@@ -195,8 +195,8 @@</span> <span class="p_context"> static int perf_config(uint32_t *image_ptr);</span>
 static int perf_release(struct inode *inode, struct file *file);
 static int perf_open(struct inode *inode, struct file *file);
 static ssize_t perf_read(struct file *file, char __user *buf, size_t cnt, loff_t *ppos);
<span class="p_del">-static ssize_t perf_write(struct file *file, const char __user *buf, size_t count, </span>
<span class="p_del">-	loff_t *ppos);</span>
<span class="p_add">+static ssize_t perf_write(struct file *file, const char __user *buf,</span>
<span class="p_add">+	size_t count, loff_t *ppos);</span>
 static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
 static void perf_start_counters(void);
 static int perf_stop_counters(uint32_t *raddr);
<span class="p_chunk">@@ -222,7 +222,7 @@</span> <span class="p_context"> extern void perf_intrigue_disable_perf_counters (void);</span>
 /*
  * configure:
  *
<span class="p_del">- * Configure the cpu with a given data image.  First turn off the counters, </span>
<span class="p_add">+ * Configure the cpu with a given data image.  First turn off the counters,</span>
  * then download the image, then turn the counters back on.
  */
 static int perf_config(uint32_t *image_ptr)
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> static int perf_config(uint32_t *image_ptr)</span>
 	error = perf_stop_counters(raddr);
 	if (error != 0) {
 		printk(&quot;perf_config: perf_stop_counters = %ld\n&quot;, error);
<span class="p_del">-		return -EINVAL; </span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
 printk(&quot;Preparing to write image\n&quot;);
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> printk(&quot;Preparing to write image\n&quot;);</span>
 	error = perf_write_image((uint64_t *)image_ptr);
 	if (error != 0) {
 		printk(&quot;perf_config: DOWNLOAD = %ld\n&quot;, error);
<span class="p_del">-		return -EINVAL; </span>
<span class="p_add">+		return -EINVAL;</span>
 	}
 
 printk(&quot;Preparing to start counters\n&quot;);
<span class="p_chunk">@@ -254,7 +254,7 @@</span> <span class="p_context"> printk(&quot;Preparing to start counters\n&quot;);</span>
 }
 
 /*
<span class="p_del">- * Open the device and initialize all of its memory.  The device is only </span>
<span class="p_add">+ * Open the device and initialize all of its memory.  The device is only</span>
  * opened once, but can be &quot;queried&quot; by multiple processes that know its
  * file descriptor.
  */
<span class="p_chunk">@@ -298,8 +298,8 @@</span> <span class="p_context"> static ssize_t perf_read(struct file *file, char __user *buf, size_t cnt, loff_t</span>
  * called on the processor that the download should happen
  * on.
  */
<span class="p_del">-static ssize_t perf_write(struct file *file, const char __user *buf, size_t count, </span>
<span class="p_del">-	loff_t *ppos)</span>
<span class="p_add">+static ssize_t perf_write(struct file *file, const char __user *buf,</span>
<span class="p_add">+	size_t count, loff_t *ppos)</span>
 {
 	int err;
 	size_t image_size;
<span class="p_chunk">@@ -307,11 +307,11 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 	uint32_t interface_type;
 	uint32_t test;
 
<span class="p_del">-	if (perf_processor_interface == ONYX_INTF) </span>
<span class="p_add">+	if (perf_processor_interface == ONYX_INTF)</span>
 		image_size = PCXU_IMAGE_SIZE;
<span class="p_del">-	else if (perf_processor_interface == CUDA_INTF) </span>
<span class="p_add">+	else if (perf_processor_interface == CUDA_INTF)</span>
 		image_size = PCXW_IMAGE_SIZE;
<span class="p_del">-	else </span>
<span class="p_add">+	else</span>
 		return -EFAULT;
 
 	if (!capable(CAP_SYS_ADMIN))
<span class="p_chunk">@@ -331,22 +331,22 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 
 	/* First check the machine type is correct for
 	   the requested image */
<span class="p_del">-        if (((perf_processor_interface == CUDA_INTF) &amp;&amp;</span>
<span class="p_del">-		       (interface_type != CUDA_INTF)) ||</span>
<span class="p_del">-	    ((perf_processor_interface == ONYX_INTF) &amp;&amp;</span>
<span class="p_del">-	               (interface_type != ONYX_INTF))) </span>
<span class="p_add">+	if (((perf_processor_interface == CUDA_INTF) &amp;&amp;</span>
<span class="p_add">+			(interface_type != CUDA_INTF)) ||</span>
<span class="p_add">+		((perf_processor_interface == ONYX_INTF) &amp;&amp;</span>
<span class="p_add">+			(interface_type != ONYX_INTF)))</span>
 		return -EINVAL;
 
 	/* Next check to make sure the requested image
 	   is valid */
<span class="p_del">-	if (((interface_type == CUDA_INTF) &amp;&amp; </span>
<span class="p_add">+	if (((interface_type == CUDA_INTF) &amp;&amp;</span>
 		       (test &gt;= MAX_CUDA_IMAGES)) ||
<span class="p_del">-	    ((interface_type == ONYX_INTF) &amp;&amp; </span>
<span class="p_del">-		       (test &gt;= MAX_ONYX_IMAGES))) </span>
<span class="p_add">+	    ((interface_type == ONYX_INTF) &amp;&amp;</span>
<span class="p_add">+		       (test &gt;= MAX_ONYX_IMAGES)))</span>
 		return -EINVAL;
 
 	/* Copy the image into the processor */
<span class="p_del">-	if (interface_type == CUDA_INTF) </span>
<span class="p_add">+	if (interface_type == CUDA_INTF)</span>
 		return perf_config(cuda_images[test]);
 	else
 		return perf_config(onyx_images[test]);
<span class="p_chunk">@@ -360,7 +360,7 @@</span> <span class="p_context"> static ssize_t perf_write(struct file *file, const char __user *buf, size_t coun</span>
 static void perf_patch_images(void)
 {
 #if 0 /* FIXME!! */
<span class="p_del">-/* </span>
<span class="p_add">+/*</span>
  * NOTE:  this routine is VERY specific to the current TLB image.
  * If the image is changed, this routine might also need to be changed.
  */
<span class="p_chunk">@@ -368,9 +368,9 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 	extern void $i_dtlb_miss_2_0();
 	extern void PA2_0_iva();
 
<span class="p_del">-	/* </span>
<span class="p_add">+	/*</span>
 	 * We can only use the lower 32-bits, the upper 32-bits should be 0
<span class="p_del">-	 * anyway given this is in the kernel </span>
<span class="p_add">+	 * anyway given this is in the kernel</span>
 	 */
 	uint32_t itlb_addr  = (uint32_t)&amp;($i_itlb_miss_2_0);
 	uint32_t dtlb_addr  = (uint32_t)&amp;($i_dtlb_miss_2_0);
<span class="p_chunk">@@ -378,21 +378,21 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 	if (perf_processor_interface == ONYX_INTF) {
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[TLBMISS][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[TLBMISS][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[TLBMISS][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[TLBMISS][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
 		onyx_images[TLBMISS][17] = itlb_addr;
 
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[TLBHANDMISS][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[TLBHANDMISS][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[TLBHANDMISS][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[TLBHANDMISS][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
 		onyx_images[TLBHANDMISS][17] = itlb_addr;
 
 		/* clear last 2 bytes */
<span class="p_del">-		onyx_images[BIG_CPI][15] &amp;= 0xffffff00;  </span>
<span class="p_add">+		onyx_images[BIG_CPI][15] &amp;= 0xffffff00;</span>
 		/* set 2 bytes */
 		onyx_images[BIG_CPI][15] |= (0x000000ff&amp;((dtlb_addr) &gt;&gt; 24));
 		onyx_images[BIG_CPI][16] = (dtlb_addr &lt;&lt; 8)&amp;0xffffff00;
<span class="p_chunk">@@ -405,24 +405,24 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 	} else if (perf_processor_interface == CUDA_INTF) {
 		/* Cuda interface */
<span class="p_del">-		cuda_images[TLBMISS][16] =  </span>
<span class="p_add">+		cuda_images[TLBMISS][16] =</span>
 			(cuda_images[TLBMISS][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[TLBMISS][17] = </span>
<span class="p_add">+		cuda_images[TLBMISS][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[TLBMISS][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 
<span class="p_del">-		cuda_images[TLBHANDMISS][16] = </span>
<span class="p_add">+		cuda_images[TLBHANDMISS][16] =</span>
 			(cuda_images[TLBHANDMISS][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[TLBHANDMISS][17] = </span>
<span class="p_add">+		cuda_images[TLBHANDMISS][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[TLBHANDMISS][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 
<span class="p_del">-		cuda_images[BIG_CPI][16] = </span>
<span class="p_add">+		cuda_images[BIG_CPI][16] =</span>
 			(cuda_images[BIG_CPI][16]&amp;0xffff0000) |
 			((dtlb_addr &gt;&gt; 8)&amp;0x0000ffff);
<span class="p_del">-		cuda_images[BIG_CPI][17] = </span>
<span class="p_add">+		cuda_images[BIG_CPI][17] =</span>
 			((dtlb_addr &lt;&lt; 24)&amp;0xff000000) | ((itlb_addr &gt;&gt; 16)&amp;0x000000ff);
 		cuda_images[BIG_CPI][18] = (itlb_addr &lt;&lt; 16)&amp;0xffff0000;
 	} else {
<span class="p_chunk">@@ -434,7 +434,7 @@</span> <span class="p_context"> static void perf_patch_images(void)</span>
 
 /*
  * ioctl routine
<span class="p_del">- * All routines effect the processor that they are executed on.  Thus you </span>
<span class="p_add">+ * All routines effect the processor that they are executed on.  Thus you</span>
  * must be running on the processor that you wish to change.
  */
 
<span class="p_chunk">@@ -460,7 +460,7 @@</span> <span class="p_context"> static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 			}
 
 			/* copy out the Counters */
<span class="p_del">-			if (copy_to_user((void __user *)arg, raddr, </span>
<span class="p_add">+			if (copy_to_user((void __user *)arg, raddr,</span>
 					sizeof (raddr)) != 0) {
 				error =  -EFAULT;
 				break;
<span class="p_chunk">@@ -488,7 +488,7 @@</span> <span class="p_context"> static const struct file_operations perf_fops = {</span>
 	.open = perf_open,
 	.release = perf_release
 };
<span class="p_del">-	</span>
<span class="p_add">+</span>
 static struct miscdevice perf_dev = {
 	MISC_DYNAMIC_MINOR,
 	PA_PERF_DEV,
<span class="p_chunk">@@ -596,7 +596,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		/* OR sticky2 (bit 1496) to counter2 bit 32 */
 		tmp64 |= (userbuf[23] &gt;&gt; 8) &amp; 0x0000000080000000;
 		raddr[2] = (uint32_t)tmp64;
<span class="p_del">-		</span>
<span class="p_add">+</span>
 		/* Counter3 is bits 1497 to 1528 */
 		tmp64 =  (userbuf[23] &gt;&gt; 7) &amp; 0x00000000ffffffff;
 		/* OR sticky3 (bit 1529) to counter3 bit 32 */
<span class="p_chunk">@@ -618,7 +618,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		userbuf[22] = 0;
 		userbuf[23] = 0;
 
<span class="p_del">-		/* </span>
<span class="p_add">+		/*</span>
 		 * Write back the zeroed bytes + the image given
 		 * the read was destructive.
 		 */
<span class="p_chunk">@@ -626,13 +626,13 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 	} else {
 
 		/*
<span class="p_del">-		 * Read RDR-15 which contains the counters and sticky bits </span>
<span class="p_add">+		 * Read RDR-15 which contains the counters and sticky bits</span>
 		 */
 		if (!perf_rdr_read_ubuf(15, userbuf)) {
 			return -13;
 		}
 
<span class="p_del">-		/* </span>
<span class="p_add">+		/*</span>
 		 * Clear out the counters
 		 */
 		perf_rdr_clear(15);
<span class="p_chunk">@@ -645,7 +645,7 @@</span> <span class="p_context"> static int perf_stop_counters(uint32_t *raddr)</span>
 		raddr[2] = (uint32_t)((userbuf[1] &gt;&gt; 32) &amp; 0x00000000ffffffffUL);
 		raddr[3] = (uint32_t)(userbuf[1] &amp; 0x00000000ffffffffUL);
 	}
<span class="p_del">- </span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -683,7 +683,7 @@</span> <span class="p_context"> static int perf_rdr_read_ubuf(uint32_t	rdr_num, uint64_t *buffer)</span>
 	i = tentry-&gt;num_words;
 	while (i--) {
 		buffer[i] = 0;
<span class="p_del">-	}	</span>
<span class="p_add">+	}</span>
 
 	/* Check for bits an even number of 64 */
 	if ((xbits = width &amp; 0x03f) != 0) {
<span class="p_chunk">@@ -809,18 +809,22 @@</span> <span class="p_context"> static int perf_write_image(uint64_t *memaddr)</span>
 	}
 
 	runway = ioremap_nocache(cpu_device-&gt;hpa.start, 4096);
<span class="p_add">+	if (!runway) {</span>
<span class="p_add">+		pr_err(&quot;perf_write_image: ioremap failed!\n&quot;);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
 
 	/* Merge intrigue bits into Runway STATUS 0 */
 	tmp64 = __raw_readq(runway + RUNWAY_STATUS) &amp; 0xffecfffffffffffful;
<span class="p_del">-	__raw_writeq(tmp64 | (*memaddr++ &amp; 0x0013000000000000ul), </span>
<span class="p_add">+	__raw_writeq(tmp64 | (*memaddr++ &amp; 0x0013000000000000ul),</span>
 		     runway + RUNWAY_STATUS);
<span class="p_del">-	</span>
<span class="p_add">+</span>
 	/* Write RUNWAY DEBUG registers */
 	for (i = 0; i &lt; 8; i++) {
 		__raw_writeq(*memaddr++, runway + RUNWAY_DEBUG);
 	}
 
<span class="p_del">-	return 0; </span>
<span class="p_add">+	return 0;</span>
 }
 
 /*
<span class="p_chunk">@@ -844,7 +848,7 @@</span> <span class="p_context"> printk(&quot;perf_rdr_write\n&quot;);</span>
 			perf_rdr_shift_out_U(rdr_num, buffer[i]);
 		} else {
 			perf_rdr_shift_out_W(rdr_num, buffer[i]);
<span class="p_del">-		}	</span>
<span class="p_add">+		}</span>
 	}
 printk(&quot;perf_rdr_write done\n&quot;);
 }
<span class="p_header">diff --git a/block/partitions/efi.c b/block/partitions/efi.c</span>
<span class="p_header">index 26cb624ace05..d26d0d27f5fd 100644</span>
<span class="p_header">--- a/block/partitions/efi.c</span>
<span class="p_header">+++ b/block/partitions/efi.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static gpt_entry *alloc_read_gpt_entries(struct parsed_partitions *state,</span>
 	if (!gpt)
 		return NULL;
 
<span class="p_del">-	count = le32_to_cpu(gpt-&gt;num_partition_entries) *</span>
<span class="p_add">+	count = (size_t)le32_to_cpu(gpt-&gt;num_partition_entries) *</span>
                 le32_to_cpu(gpt-&gt;sizeof_partition_entry);
 	if (!count)
 		return NULL;
<span class="p_chunk">@@ -352,7 +352,7 @@</span> <span class="p_context"> static int is_gpt_valid(struct parsed_partitions *state, u64 lba,</span>
 			gpt_header **gpt, gpt_entry **ptes)
 {
 	u32 crc, origcrc;
<span class="p_del">-	u64 lastlba;</span>
<span class="p_add">+	u64 lastlba, pt_size;</span>
 
 	if (!ptes)
 		return 0;
<span class="p_chunk">@@ -434,13 +434,20 @@</span> <span class="p_context"> static int is_gpt_valid(struct parsed_partitions *state, u64 lba,</span>
 		goto fail;
 	}
 
<span class="p_add">+	/* Sanity check partition table size */</span>
<span class="p_add">+	pt_size = (u64)le32_to_cpu((*gpt)-&gt;num_partition_entries) *</span>
<span class="p_add">+		le32_to_cpu((*gpt)-&gt;sizeof_partition_entry);</span>
<span class="p_add">+	if (pt_size &gt; KMALLOC_MAX_SIZE) {</span>
<span class="p_add">+		pr_debug(&quot;GUID Partition Table is too large: %llu &gt; %lu bytes\n&quot;,</span>
<span class="p_add">+			 (unsigned long long)pt_size, KMALLOC_MAX_SIZE);</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!(*ptes = alloc_read_gpt_entries(state, *gpt)))
 		goto fail;
 
 	/* Check the GUID Partition Entry Array CRC */
<span class="p_del">-	crc = efi_crc32((const unsigned char *) (*ptes),</span>
<span class="p_del">-			le32_to_cpu((*gpt)-&gt;num_partition_entries) *</span>
<span class="p_del">-			le32_to_cpu((*gpt)-&gt;sizeof_partition_entry));</span>
<span class="p_add">+	crc = efi_crc32((const unsigned char *) (*ptes), pt_size);</span>
 
 	if (crc != le32_to_cpu((*gpt)-&gt;partition_entry_array_crc32)) {
 		pr_debug(&quot;GUID Partitition Entry Array CRC check failed.\n&quot;);
<span class="p_header">diff --git a/drivers/ata/libata-transport.c b/drivers/ata/libata-transport.c</span>
<span class="p_header">index e2d94972962d..7aa10c200ecb 100644</span>
<span class="p_header">--- a/drivers/ata/libata-transport.c</span>
<span class="p_header">+++ b/drivers/ata/libata-transport.c</span>
<span class="p_chunk">@@ -224,7 +224,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_port_class,</span>
 
 static void ata_tport_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -284,7 +283,7 @@</span> <span class="p_context"> int ata_tport_add(struct device *parent,</span>
 	device_initialize(dev);
 	dev-&gt;type = &amp;ata_port_type;
 
<span class="p_del">-	dev-&gt;parent = get_device(parent);</span>
<span class="p_add">+	dev-&gt;parent = parent;</span>
 	dev-&gt;release = ata_tport_release;
 	dev_set_name(dev, &quot;ata%d&quot;, ap-&gt;print_id);
 	transport_setup_device(dev);
<span class="p_chunk">@@ -348,7 +347,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_link_class,</span>
 
 static void ata_tlink_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -410,7 +408,7 @@</span> <span class="p_context"> int ata_tlink_add(struct ata_link *link)</span>
 	int error;
 
 	device_initialize(dev);
<span class="p_del">-	dev-&gt;parent = get_device(&amp;ap-&gt;tdev);</span>
<span class="p_add">+	dev-&gt;parent = &amp;ap-&gt;tdev;</span>
 	dev-&gt;release = ata_tlink_release;
 	if (ata_is_host_link(link))
 		dev_set_name(dev, &quot;link%d&quot;, ap-&gt;print_id);
<span class="p_chunk">@@ -588,7 +586,6 @@</span> <span class="p_context"> static DECLARE_TRANSPORT_CLASS(ata_dev_class,</span>
 
 static void ata_tdev_release(struct device *dev)
 {
<span class="p_del">-	put_device(dev-&gt;parent);</span>
 }
 
 /**
<span class="p_chunk">@@ -661,7 +658,7 @@</span> <span class="p_context"> static int ata_tdev_add(struct ata_device *ata_dev)</span>
 	int error;
 
 	device_initialize(dev);
<span class="p_del">-	dev-&gt;parent = get_device(&amp;link-&gt;tdev);</span>
<span class="p_add">+	dev-&gt;parent = &amp;link-&gt;tdev;</span>
 	dev-&gt;release = ata_tdev_release;
 	if (ata_is_host_link(link))
 		dev_set_name(dev, &quot;dev%d.%d&quot;, ap-&gt;print_id,ata_dev-&gt;devno);
<span class="p_header">diff --git a/drivers/extcon/extcon-axp288.c b/drivers/extcon/extcon-axp288.c</span>
<span class="p_header">index fd55c2f2080a..6c9d7ccebb8c 100644</span>
<span class="p_header">--- a/drivers/extcon/extcon-axp288.c</span>
<span class="p_header">+++ b/drivers/extcon/extcon-axp288.c</span>
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> static int axp288_handle_chrg_det_event(struct axp288_extcon_info *info)</span>
 		return ret;
 	}
 
<span class="p_del">-	vbus_attach = (pwr_stat &amp; PS_STAT_VBUS_PRESENT);</span>
<span class="p_add">+	vbus_attach = (pwr_stat &amp; PS_STAT_VBUS_VALID);</span>
 	if (!vbus_attach)
 		goto notify_otg;
 
<span class="p_header">diff --git a/drivers/firmware/psci.c b/drivers/firmware/psci.c</span>
<span class="p_header">index d24f35d74b27..ae70d2485ca1 100644</span>
<span class="p_header">--- a/drivers/firmware/psci.c</span>
<span class="p_header">+++ b/drivers/firmware/psci.c</span>
<span class="p_chunk">@@ -424,7 +424,7 @@</span> <span class="p_context"> out_put_node:</span>
 	return err;
 }
 
<span class="p_del">-static const struct of_device_id const psci_of_match[] __initconst = {</span>
<span class="p_add">+static const struct of_device_id psci_of_match[] __initconst = {</span>
 	{ .compatible = &quot;arm,psci&quot;,	.data = psci_0_1_init},
 	{ .compatible = &quot;arm,psci-0.2&quot;,	.data = psci_0_2_init},
 	{ .compatible = &quot;arm,psci-1.0&quot;,	.data = psci_0_2_init},
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_events.c b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">index b6e28dcaea1d..1fb1daa0b366 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdkfd/kfd_events.c</span>
<span class="p_chunk">@@ -739,8 +739,10 @@</span> <span class="p_context"> int kfd_wait_on_events(struct kfd_process *p,</span>
 		struct kfd_event_data event_data;
 
 		if (copy_from_user(&amp;event_data, &amp;events[i],
<span class="p_del">-				sizeof(struct kfd_event_data)))</span>
<span class="p_add">+				sizeof(struct kfd_event_data))) {</span>
<span class="p_add">+			ret = -EFAULT;</span>
 			goto fail;
<span class="p_add">+		}</span>
 
 		ret = init_event_waiter(p, &amp;event_waiters[i],
 				event_data.event_id, i);
<span class="p_header">diff --git a/drivers/hwmon/gl520sm.c b/drivers/hwmon/gl520sm.c</span>
<span class="p_header">index dee93ec87d02..84e0994aafdd 100644</span>
<span class="p_header">--- a/drivers/hwmon/gl520sm.c</span>
<span class="p_header">+++ b/drivers/hwmon/gl520sm.c</span>
<span class="p_chunk">@@ -208,11 +208,13 @@</span> <span class="p_context"> static ssize_t get_cpu_vid(struct device *dev, struct device_attribute *attr,</span>
 }
 static DEVICE_ATTR(cpu0_vid, S_IRUGO, get_cpu_vid, NULL);
 
<span class="p_del">-#define VDD_FROM_REG(val) (((val) * 95 + 2) / 4)</span>
<span class="p_del">-#define VDD_TO_REG(val) clamp_val((((val) * 4 + 47) / 95), 0, 255)</span>
<span class="p_add">+#define VDD_FROM_REG(val)	DIV_ROUND_CLOSEST((val) * 95, 4)</span>
<span class="p_add">+#define VDD_CLAMP(val)		clamp_val(val, 0, 255 * 95 / 4)</span>
<span class="p_add">+#define VDD_TO_REG(val)		DIV_ROUND_CLOSEST(VDD_CLAMP(val) * 4, 95)</span>
 
<span class="p_del">-#define IN_FROM_REG(val) ((val) * 19)</span>
<span class="p_del">-#define IN_TO_REG(val) clamp_val((((val) + 9) / 19), 0, 255)</span>
<span class="p_add">+#define IN_FROM_REG(val)	((val) * 19)</span>
<span class="p_add">+#define IN_CLAMP(val)		clamp_val(val, 0, 255 * 19)</span>
<span class="p_add">+#define IN_TO_REG(val)		DIV_ROUND_CLOSEST(IN_CLAMP(val), 19)</span>
 
 static ssize_t get_in_input(struct device *dev, struct device_attribute *attr,
 			    char *buf)
<span class="p_chunk">@@ -349,8 +351,13 @@</span> <span class="p_context"> static SENSOR_DEVICE_ATTR(in4_max, S_IRUGO | S_IWUSR,</span>
 
 #define DIV_FROM_REG(val) (1 &lt;&lt; (val))
 #define FAN_FROM_REG(val, div) ((val) == 0 ? 0 : (480000 / ((val) &lt;&lt; (div))))
<span class="p_del">-#define FAN_TO_REG(val, div) ((val) &lt;= 0 ? 0 : \</span>
<span class="p_del">-	clamp_val((480000 + ((val) &lt;&lt; ((div)-1))) / ((val) &lt;&lt; (div)), 1, 255))</span>
<span class="p_add">+</span>
<span class="p_add">+#define FAN_BASE(div)		(480000 &gt;&gt; (div))</span>
<span class="p_add">+#define FAN_CLAMP(val, div)	clamp_val(val, FAN_BASE(div) / 255, \</span>
<span class="p_add">+					  FAN_BASE(div))</span>
<span class="p_add">+#define FAN_TO_REG(val, div)	((val) == 0 ? 0 : \</span>
<span class="p_add">+				 DIV_ROUND_CLOSEST(480000, \</span>
<span class="p_add">+						FAN_CLAMP(val, div) &lt;&lt; (div)))</span>
 
 static ssize_t get_fan_input(struct device *dev, struct device_attribute *attr,
 			     char *buf)
<span class="p_chunk">@@ -513,9 +520,9 @@</span> <span class="p_context"> static SENSOR_DEVICE_ATTR(fan2_div, S_IRUGO | S_IWUSR,</span>
 static DEVICE_ATTR(fan1_off, S_IRUGO | S_IWUSR,
 		get_fan_off, set_fan_off);
 
<span class="p_del">-#define TEMP_FROM_REG(val) (((val) - 130) * 1000)</span>
<span class="p_del">-#define TEMP_TO_REG(val) clamp_val(((((val) &lt; 0 ? \</span>
<span class="p_del">-			(val) - 500 : (val) + 500) / 1000) + 130), 0, 255)</span>
<span class="p_add">+#define TEMP_FROM_REG(val)	(((val) - 130) * 1000)</span>
<span class="p_add">+#define TEMP_CLAMP(val)		clamp_val(val, -130000, 125000)</span>
<span class="p_add">+#define TEMP_TO_REG(val)	(DIV_ROUND_CLOSEST(TEMP_CLAMP(val), 1000) + 130)</span>
 
 static ssize_t get_temp_input(struct device *dev, struct device_attribute *attr,
 			      char *buf)
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-meson.c b/drivers/i2c/busses/i2c-meson.c</span>
<span class="p_header">index 71d3929adf54..8d65f33af5da 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-meson.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-meson.c</span>
<span class="p_chunk">@@ -175,7 +175,7 @@</span> <span class="p_context"> static void meson_i2c_put_data(struct meson_i2c *i2c, char *buf, int len)</span>
 		wdata1 |= *buf++ &lt;&lt; ((i - 4) * 8);
 
 	writel(wdata0, i2c-&gt;regs + REG_TOK_WDATA0);
<span class="p_del">-	writel(wdata0, i2c-&gt;regs + REG_TOK_WDATA1);</span>
<span class="p_add">+	writel(wdata1, i2c-&gt;regs + REG_TOK_WDATA1);</span>
 
 	dev_dbg(i2c-&gt;dev, &quot;%s: data %08x %08x len %d\n&quot;, __func__,
 		wdata0, wdata1, len);
<span class="p_header">diff --git a/drivers/iio/adc/axp288_adc.c b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">index 0c904edd6c00..f684fe31f832 100644</span>
<span class="p_header">--- a/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_chunk">@@ -28,8 +28,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/iio/driver.h&gt;
 
 #define AXP288_ADC_EN_MASK		0xF1
<span class="p_del">-#define AXP288_ADC_TS_PIN_GPADC		0xF2</span>
<span class="p_del">-#define AXP288_ADC_TS_PIN_ON		0xF3</span>
 
 enum axp288_adc_id {
 	AXP288_ADC_TS,
<span class="p_chunk">@@ -123,16 +121,6 @@</span> <span class="p_context"> static int axp288_adc_read_channel(int *val, unsigned long address,</span>
 	return IIO_VAL_INT;
 }
 
<span class="p_del">-static int axp288_adc_set_ts(struct regmap *regmap, unsigned int mode,</span>
<span class="p_del">-				unsigned long address)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* channels other than GPADC do not need to switch TS pin */</span>
<span class="p_del">-	if (address != AXP288_GP_ADC_H)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return regmap_write(regmap, AXP288_ADC_TS_PIN_CTRL, mode);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int axp288_adc_read_raw(struct iio_dev *indio_dev,
 			struct iio_chan_spec const *chan,
 			int *val, int *val2, long mask)
<span class="p_chunk">@@ -143,16 +131,7 @@</span> <span class="p_context"> static int axp288_adc_read_raw(struct iio_dev *indio_dev,</span>
 	mutex_lock(&amp;indio_dev-&gt;mlock);
 	switch (mask) {
 	case IIO_CHAN_INFO_RAW:
<span class="p_del">-		if (axp288_adc_set_ts(info-&gt;regmap, AXP288_ADC_TS_PIN_GPADC,</span>
<span class="p_del">-					chan-&gt;address)) {</span>
<span class="p_del">-			dev_err(&amp;indio_dev-&gt;dev, &quot;GPADC mode\n&quot;);</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		ret = axp288_adc_read_channel(val, chan-&gt;address, info-&gt;regmap);
<span class="p_del">-		if (axp288_adc_set_ts(info-&gt;regmap, AXP288_ADC_TS_PIN_ON,</span>
<span class="p_del">-						chan-&gt;address))</span>
<span class="p_del">-			dev_err(&amp;indio_dev-&gt;dev, &quot;TS pin restore\n&quot;);</span>
 		break;
 	default:
 		ret = -EINVAL;
<span class="p_chunk">@@ -162,15 +141,6 @@</span> <span class="p_context"> static int axp288_adc_read_raw(struct iio_dev *indio_dev,</span>
 	return ret;
 }
 
<span class="p_del">-static int axp288_adc_set_state(struct regmap *regmap)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* ADC should be always enabled for internal FG to function */</span>
<span class="p_del">-	if (regmap_write(regmap, AXP288_ADC_TS_PIN_CTRL, AXP288_ADC_TS_PIN_ON))</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	return regmap_write(regmap, AXP20X_ADC_EN1, AXP288_ADC_EN_MASK);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static const struct iio_info axp288_adc_iio_info = {
 	.read_raw = &amp;axp288_adc_read_raw,
 	.driver_module = THIS_MODULE,
<span class="p_chunk">@@ -199,7 +169,7 @@</span> <span class="p_context"> static int axp288_adc_probe(struct platform_device *pdev)</span>
 	 * Set ADC to enabled state at all time, including system suspend.
 	 * otherwise internal fuel gauge functionality may be affected.
 	 */
<span class="p_del">-	ret = axp288_adc_set_state(axp20x-&gt;regmap);</span>
<span class="p_add">+	ret = regmap_write(info-&gt;regmap, AXP20X_ADC_EN1, AXP288_ADC_EN_MASK);</span>
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;unable to enable ADC device\n&quot;);
 		return ret;
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_iba7322.c b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">index 6c8ff10101c0..77cc77ba998f 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_iba7322.c</span>
<span class="p_chunk">@@ -7097,7 +7097,7 @@</span> <span class="p_context"> static void qib_7322_txchk_change(struct qib_devdata *dd, u32 start,</span>
 	unsigned long flags;
 
 	while (wait) {
<span class="p_del">-		unsigned long shadow;</span>
<span class="p_add">+		unsigned long shadow = 0;</span>
 		int cstart, previ = -1;
 
 		/*
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_main.c b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">index 6699ecd855f0..bad76eed06b3 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_main.c</span>
<span class="p_chunk">@@ -1239,7 +1239,7 @@</span> <span class="p_context"> static void __ipoib_reap_neigh(struct ipoib_dev_priv *priv)</span>
 						   rcu_dereference_protected(neigh-&gt;hnext,
 									     lockdep_is_held(&amp;priv-&gt;lock)));
 				/* remove from path/mc list */
<span class="p_del">-				list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+				list_del_init(&amp;neigh-&gt;list);</span>
 				call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			} else {
 				np = &amp;neigh-&gt;hnext;
<span class="p_chunk">@@ -1406,7 +1406,7 @@</span> <span class="p_context"> void ipoib_neigh_free(struct ipoib_neigh *neigh)</span>
 					   rcu_dereference_protected(neigh-&gt;hnext,
 								     lockdep_is_held(&amp;priv-&gt;lock)));
 			/* remove from parent list */
<span class="p_del">-			list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+			list_del_init(&amp;neigh-&gt;list);</span>
 			call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			return;
 		} else {
<span class="p_chunk">@@ -1491,7 +1491,7 @@</span> <span class="p_context"> void ipoib_del_neighs_by_gid(struct net_device *dev, u8 *gid)</span>
 						   rcu_dereference_protected(neigh-&gt;hnext,
 									     lockdep_is_held(&amp;priv-&gt;lock)));
 				/* remove from parent list */
<span class="p_del">-				list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+				list_del_init(&amp;neigh-&gt;list);</span>
 				call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 			} else {
 				np = &amp;neigh-&gt;hnext;
<span class="p_chunk">@@ -1533,7 +1533,7 @@</span> <span class="p_context"> static void ipoib_flush_neighs(struct ipoib_dev_priv *priv)</span>
 					   rcu_dereference_protected(neigh-&gt;hnext,
 								     lockdep_is_held(&amp;priv-&gt;lock)));
 			/* remove from path/mc list */
<span class="p_del">-			list_del(&amp;neigh-&gt;list);</span>
<span class="p_add">+			list_del_init(&amp;neigh-&gt;list);</span>
 			call_rcu(&amp;neigh-&gt;rcu, ipoib_neigh_reclaim);
 		}
 	}
<span class="p_header">diff --git a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">index 57a34f87dedf..9b47a437d6c9 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/ipoib/ipoib_vlan.c</span>
<span class="p_chunk">@@ -160,11 +160,11 @@</span> <span class="p_context"> int ipoib_vlan_add(struct net_device *pdev, unsigned short pkey)</span>
 out:
 	up_write(&amp;ppriv-&gt;vlan_rwsem);
 
<span class="p_add">+	rtnl_unlock();</span>
<span class="p_add">+</span>
 	if (result)
 		free_netdev(priv-&gt;dev);
 
<span class="p_del">-	rtnl_unlock();</span>
<span class="p_del">-</span>
 	return result;
 }
 
<span class="p_chunk">@@ -185,7 +185,6 @@</span> <span class="p_context"> int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)</span>
 	list_for_each_entry_safe(priv, tpriv, &amp;ppriv-&gt;child_intfs, list) {
 		if (priv-&gt;pkey == pkey &amp;&amp;
 		    priv-&gt;child_type == IPOIB_LEGACY_CHILD) {
<span class="p_del">-			unregister_netdevice(priv-&gt;dev);</span>
 			list_del(&amp;priv-&gt;list);
 			dev = priv-&gt;dev;
 			break;
<span class="p_chunk">@@ -193,6 +192,11 @@</span> <span class="p_context"> int ipoib_vlan_delete(struct net_device *pdev, unsigned short pkey)</span>
 	}
 	up_write(&amp;ppriv-&gt;vlan_rwsem);
 
<span class="p_add">+	if (dev) {</span>
<span class="p_add">+		ipoib_dbg(ppriv, &quot;delete child vlan %s\n&quot;, dev-&gt;name);</span>
<span class="p_add">+		unregister_netdevice(dev);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rtnl_unlock();
 
 	if (dev) {
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm.c b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">index dad768caa9c5..18751b1dfd3d 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm.c</span>
<span class="p_chunk">@@ -335,8 +335,12 @@</span> <span class="p_context"> static int __arm_lpae_map(struct arm_lpae_io_pgtable *data, unsigned long iova,</span>
 		if (cfg-&gt;quirks &amp; IO_PGTABLE_QUIRK_ARM_NS)
 			pte |= ARM_LPAE_PTE_NSTABLE;
 		__arm_lpae_set_pte(ptep, pte, cfg);
<span class="p_del">-	} else {</span>
<span class="p_add">+	} else if (!iopte_leaf(pte, lvl)) {</span>
 		cptep = iopte_deref(pte, data);
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* We require an unmap first */</span>
<span class="p_add">+		WARN_ON(!selftest_running);</span>
<span class="p_add">+		return -EEXIST;</span>
 	}
 
 	/* Rinse, repeat */
<span class="p_header">diff --git a/drivers/md/raid10.c b/drivers/md/raid10.c</span>
<span class="p_header">index e5ee4e9e0ea5..a8a86d450d76 100644</span>
<span class="p_header">--- a/drivers/md/raid10.c</span>
<span class="p_header">+++ b/drivers/md/raid10.c</span>
<span class="p_chunk">@@ -1414,11 +1414,24 @@</span> <span class="p_context"> retry_write:</span>
 			mbio-&gt;bi_private = r10_bio;
 
 			atomic_inc(&amp;r10_bio-&gt;remaining);
<span class="p_add">+</span>
<span class="p_add">+			cb = blk_check_plugged(raid10_unplug, mddev,</span>
<span class="p_add">+					       sizeof(*plug));</span>
<span class="p_add">+			if (cb)</span>
<span class="p_add">+				plug = container_of(cb, struct raid10_plug_cb,</span>
<span class="p_add">+						    cb);</span>
<span class="p_add">+			else</span>
<span class="p_add">+				plug = NULL;</span>
 			spin_lock_irqsave(&amp;conf-&gt;device_lock, flags);
<span class="p_del">-			bio_list_add(&amp;conf-&gt;pending_bio_list, mbio);</span>
<span class="p_del">-			conf-&gt;pending_count++;</span>
<span class="p_add">+			if (plug) {</span>
<span class="p_add">+				bio_list_add(&amp;plug-&gt;pending, mbio);</span>
<span class="p_add">+				plug-&gt;pending_cnt++;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				bio_list_add(&amp;conf-&gt;pending_bio_list, mbio);</span>
<span class="p_add">+				conf-&gt;pending_count++;</span>
<span class="p_add">+			}</span>
 			spin_unlock_irqrestore(&amp;conf-&gt;device_lock, flags);
<span class="p_del">-			if (!mddev_check_plugged(mddev))</span>
<span class="p_add">+			if (!plug)</span>
 				md_wakeup_thread(mddev-&gt;thread);
 		}
 	}
<span class="p_header">diff --git a/drivers/media/pci/ttpci/av7110_hw.c b/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_header">index 300bd3c94738..0992bb0e207e 100644</span>
<span class="p_header">--- a/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_header">+++ b/drivers/media/pci/ttpci/av7110_hw.c</span>
<span class="p_chunk">@@ -56,11 +56,11 @@</span> <span class="p_context"></span>
    by Nathan Laredo &lt;laredo@gnu.org&gt; */
 
 int av7110_debiwrite(struct av7110 *av7110, u32 config,
<span class="p_del">-		     int addr, u32 val, int count)</span>
<span class="p_add">+		     int addr, u32 val, unsigned int count)</span>
 {
 	struct saa7146_dev *dev = av7110-&gt;dev;
 
<span class="p_del">-	if (count &lt;= 0 || count &gt; 32764) {</span>
<span class="p_add">+	if (count &gt; 32764) {</span>
 		printk(&quot;%s: invalid count %d\n&quot;, __func__, count);
 		return -1;
 	}
<span class="p_chunk">@@ -78,12 +78,12 @@</span> <span class="p_context"> int av7110_debiwrite(struct av7110 *av7110, u32 config,</span>
 	return 0;
 }
 
<span class="p_del">-u32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, int count)</span>
<span class="p_add">+u32 av7110_debiread(struct av7110 *av7110, u32 config, int addr, unsigned int count)</span>
 {
 	struct saa7146_dev *dev = av7110-&gt;dev;
 	u32 result = 0;
 
<span class="p_del">-	if (count &gt; 32764 || count &lt;= 0) {</span>
<span class="p_add">+	if (count &gt; 32764) {</span>
 		printk(&quot;%s: invalid count %d\n&quot;, __func__, count);
 		return 0;
 	}
<span class="p_header">diff --git a/drivers/media/pci/ttpci/av7110_hw.h b/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_header">index 1634aba5cb84..ccb148059406 100644</span>
<span class="p_header">--- a/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_header">+++ b/drivers/media/pci/ttpci/av7110_hw.h</span>
<span class="p_chunk">@@ -377,14 +377,14 @@</span> <span class="p_context"> extern int av7110_fw_request(struct av7110 *av7110, u16 *request_buf,</span>
 
 /* DEBI (saa7146 data extension bus interface) access */
 extern int av7110_debiwrite(struct av7110 *av7110, u32 config,
<span class="p_del">-			    int addr, u32 val, int count);</span>
<span class="p_add">+			    int addr, u32 val, unsigned int count);</span>
 extern u32 av7110_debiread(struct av7110 *av7110, u32 config,
<span class="p_del">-			   int addr, int count);</span>
<span class="p_add">+			   int addr, unsigned int count);</span>
 
 
 /* DEBI during interrupt */
 /* single word writes */
<span class="p_del">-static inline void iwdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline void iwdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	av7110_debiwrite(av7110, config, addr, val, count);
 }
<span class="p_chunk">@@ -397,7 +397,7 @@</span> <span class="p_context"> static inline void mwdebi(struct av7110 *av7110, u32 config, int addr,</span>
 	av7110_debiwrite(av7110, config, addr, 0, count);
 }
 
<span class="p_del">-static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	u32 res;
 
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> static inline u32 irdebi(struct av7110 *av7110, u32 config, int addr, u32 val, i</span>
 }
 
 /* DEBI outside interrupts, only for count &lt;= 4! */
<span class="p_del">-static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	unsigned long flags;
 
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> static inline void wdebi(struct av7110 *av7110, u32 config, int addr, u32 val, i</span>
 	spin_unlock_irqrestore(&amp;av7110-&gt;debilock, flags);
 }
 
<span class="p_del">-static inline u32 rdebi(struct av7110 *av7110, u32 config, int addr, u32 val, int count)</span>
<span class="p_add">+static inline u32 rdebi(struct av7110 *av7110, u32 config, int addr, u32 val, unsigned int count)</span>
 {
 	unsigned long flags;
 	u32 res;
<span class="p_header">diff --git a/drivers/media/platform/exynos-gsc/gsc-core.c b/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_header">index 9b9e423e4fc4..15c543d4b366 100644</span>
<span class="p_header">--- a/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_header">+++ b/drivers/media/platform/exynos-gsc/gsc-core.c</span>
<span class="p_chunk">@@ -849,9 +849,7 @@</span> <span class="p_context"> int gsc_prepare_addr(struct gsc_ctx *ctx, struct vb2_buffer *vb,</span>
 
 	if ((frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_VYUY) ||
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVYU) ||
<span class="p_del">-		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_NV61) ||</span>
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVU420) ||
<span class="p_del">-		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_NV21) ||</span>
 		(frame-&gt;fmt-&gt;pixelformat == V4L2_PIX_FMT_YVU420M))
 		swap(addr-&gt;cb, addr-&gt;cr);
 
<span class="p_header">diff --git a/drivers/mmc/core/sdio_bus.c b/drivers/mmc/core/sdio_bus.c</span>
<span class="p_header">index 7e327a6dd53d..c23bc4f331bd 100644</span>
<span class="p_header">--- a/drivers/mmc/core/sdio_bus.c</span>
<span class="p_header">+++ b/drivers/mmc/core/sdio_bus.c</span>
<span class="p_chunk">@@ -266,7 +266,7 @@</span> <span class="p_context"> static void sdio_release_func(struct device *dev)</span>
 	sdio_free_func_cis(func);
 
 	kfree(func-&gt;info);
<span class="p_del">-</span>
<span class="p_add">+	kfree(func-&gt;tmpbuf);</span>
 	kfree(func);
 }
 
<span class="p_chunk">@@ -281,6 +281,16 @@</span> <span class="p_context"> struct sdio_func *sdio_alloc_func(struct mmc_card *card)</span>
 	if (!func)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * allocate buffer separately to make sure it&#39;s properly aligned for</span>
<span class="p_add">+	 * DMA usage (incl. 64 bit DMA)</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	func-&gt;tmpbuf = kmalloc(4, GFP_KERNEL);</span>
<span class="p_add">+	if (!func-&gt;tmpbuf) {</span>
<span class="p_add">+		kfree(func);</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	func-&gt;card = card;
 
 	device_initialize(&amp;func-&gt;dev);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index fa3b4cbea23b..a481ea64e287 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -7658,6 +7658,11 @@</span> <span class="p_context"> static pci_ers_result_t igb_io_slot_reset(struct pci_dev *pdev)</span>
 		pci_enable_wake(pdev, PCI_D3hot, 0);
 		pci_enable_wake(pdev, PCI_D3cold, 0);
 
<span class="p_add">+		/* In case of PCI error, adapter lose its HW address</span>
<span class="p_add">+		 * so we should re-assign it here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		hw-&gt;hw_addr = adapter-&gt;io_addr;</span>
<span class="p_add">+</span>
 		igb_reset(adapter);
 		wr32(E1000_WUS, ~0);
 		result = PCI_ERS_RESULT_RECOVERED;
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.h b/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_header">index 72fcfc924589..0d18be0fed8e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.h</span>
<span class="p_chunk">@@ -339,7 +339,7 @@</span> <span class="p_context"> enum FELIC_MODE_BIT {</span>
 	ECMR_DPAD = 0x00200000, ECMR_RZPF = 0x00100000,
 	ECMR_ZPF = 0x00080000, ECMR_PFR = 0x00040000, ECMR_RXF = 0x00020000,
 	ECMR_TXF = 0x00010000, ECMR_MCT = 0x00002000, ECMR_PRCEF = 0x00001000,
<span class="p_del">-	ECMR_PMDE = 0x00000200, ECMR_RE = 0x00000040, ECMR_TE = 0x00000020,</span>
<span class="p_add">+	ECMR_MPDE = 0x00000200, ECMR_RE = 0x00000040, ECMR_TE = 0x00000020,</span>
 	ECMR_RTM = 0x00000010, ECMR_ILB = 0x00000008, ECMR_ELB = 0x00000004,
 	ECMR_DM = 0x00000002, ECMR_PRM = 0x00000001,
 };
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index a5f392ae30d5..61cd53838360 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -2343,8 +2343,10 @@</span> <span class="p_context"> start_again:</span>
 
 	hdr = genlmsg_put(skb, portid, seq, &amp;team_nl_family, flags | NLM_F_MULTI,
 			  TEAM_CMD_OPTIONS_GET);
<span class="p_del">-	if (!hdr)</span>
<span class="p_add">+	if (!hdr) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
 		return -EMSGSIZE;
<span class="p_add">+	}</span>
 
 	if (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team-&gt;dev-&gt;ifindex))
 		goto nla_put_failure;
<span class="p_chunk">@@ -2611,8 +2613,10 @@</span> <span class="p_context"> start_again:</span>
 
 	hdr = genlmsg_put(skb, portid, seq, &amp;team_nl_family, flags | NLM_F_MULTI,
 			  TEAM_CMD_PORT_LIST_GET);
<span class="p_del">-	if (!hdr)</span>
<span class="p_add">+	if (!hdr) {</span>
<span class="p_add">+		nlmsg_free(skb);</span>
 		return -EMSGSIZE;
<span class="p_add">+	}</span>
 
 	if (nla_put_u32(skb, TEAM_ATTR_TEAM_IFINDEX, team-&gt;dev-&gt;ifindex))
 		goto nla_put_failure;
<span class="p_header">diff --git a/drivers/net/usb/Kconfig b/drivers/net/usb/Kconfig</span>
<span class="p_header">index 7f83504dfa69..1f6893ebce16 100644</span>
<span class="p_header">--- a/drivers/net/usb/Kconfig</span>
<span class="p_header">+++ b/drivers/net/usb/Kconfig</span>
<span class="p_chunk">@@ -364,7 +364,7 @@</span> <span class="p_context"> config USB_NET_NET1080</span>
 	  optionally with LEDs that indicate traffic
 
 config USB_NET_PLUSB
<span class="p_del">-	tristate &quot;Prolific PL-2301/2302/25A1 based cables&quot;</span>
<span class="p_add">+	tristate &quot;Prolific PL-2301/2302/25A1/27A1 based cables&quot;</span>
 	# if the handshake/init/reset problems, from original &#39;plusb&#39;,
 	# are ever resolved ... then remove &quot;experimental&quot;
 	depends on USB_USBNET
<span class="p_header">diff --git a/drivers/net/usb/plusb.c b/drivers/net/usb/plusb.c</span>
<span class="p_header">index 1bfe0fcaccf5..7c02231c1a1b 100644</span>
<span class="p_header">--- a/drivers/net/usb/plusb.c</span>
<span class="p_header">+++ b/drivers/net/usb/plusb.c</span>
<span class="p_chunk">@@ -102,7 +102,7 @@</span> <span class="p_context"> static int pl_reset(struct usbnet *dev)</span>
 }
 
 static const struct driver_info	prolific_info = {
<span class="p_del">-	.description =	&quot;Prolific PL-2301/PL-2302/PL-25A1&quot;,</span>
<span class="p_add">+	.description =	&quot;Prolific PL-2301/PL-2302/PL-25A1/PL-27A1&quot;,</span>
 	.flags =	FLAG_POINTTOPOINT | FLAG_NO_SETINT,
 		/* some PL-2302 versions seem to fail usb_set_interface() */
 	.reset =	pl_reset,
<span class="p_chunk">@@ -139,6 +139,17 @@</span> <span class="p_context"> static const struct usb_device_id	products [] = {</span>
 					 * Host-to-Host Cable
 					 */
 	.driver_info =  (unsigned long) &amp;prolific_info,
<span class="p_add">+</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
<span class="p_add">+/* super speed cables */</span>
<span class="p_add">+{</span>
<span class="p_add">+	USB_DEVICE(0x067b, 0x27a1),     /* PL-27A1, no eeprom</span>
<span class="p_add">+					 * also: goobay Active USB 3.0</span>
<span class="p_add">+					 * Data Link,</span>
<span class="p_add">+					 * Unitek Y-3501</span>
<span class="p_add">+					 */</span>
<span class="p_add">+	.driver_info =  (unsigned long) &amp;prolific_info,</span>
 },
 
 	{ },		// END
<span class="p_chunk">@@ -158,5 +169,5 @@</span> <span class="p_context"> static struct usb_driver plusb_driver = {</span>
 module_usb_driver(plusb_driver);
 
 MODULE_AUTHOR(&quot;David Brownell&quot;);
<span class="p_del">-MODULE_DESCRIPTION(&quot;Prolific PL-2301/2302/25A1 USB Host to Host Link Driver&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;Prolific PL-2301/2302/25A1/27A1 USB Host to Host Link Driver&quot;);</span>
 MODULE_LICENSE(&quot;GPL&quot;);
<span class="p_header">diff --git a/drivers/tty/goldfish.c b/drivers/tty/goldfish.c</span>
<span class="p_header">index 0f82c0b146f6..e04b57f79df8 100644</span>
<span class="p_header">--- a/drivers/tty/goldfish.c</span>
<span class="p_header">+++ b/drivers/tty/goldfish.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static int goldfish_tty_probe(struct platform_device *pdev)</span>
 	return 0;
 
 err_tty_register_device_failed:
<span class="p_del">-	free_irq(irq, pdev);</span>
<span class="p_add">+	free_irq(irq, qtty);</span>
 err_request_irq_failed:
 	goldfish_tty_current_line_count--;
 	if (goldfish_tty_current_line_count == 0)
<span class="p_header">diff --git a/drivers/usb/chipidea/otg.c b/drivers/usb/chipidea/otg.c</span>
<span class="p_header">index 0cf149edddd8..f36a1ac3bfbd 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/otg.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/otg.c</span>
<span class="p_chunk">@@ -134,9 +134,9 @@</span> <span class="p_context"> void ci_handle_vbus_change(struct ci_hdrc *ci)</span>
 	if (!ci-&gt;is_otg)
 		return;
 
<span class="p_del">-	if (hw_read_otgsc(ci, OTGSC_BSV))</span>
<span class="p_add">+	if (hw_read_otgsc(ci, OTGSC_BSV) &amp;&amp; !ci-&gt;vbus_active)</span>
 		usb_gadget_vbus_connect(&amp;ci-&gt;gadget);
<span class="p_del">-	else</span>
<span class="p_add">+	else if (!hw_read_otgsc(ci, OTGSC_BSV) &amp;&amp; ci-&gt;vbus_active)</span>
 		usb_gadget_vbus_disconnect(&amp;ci-&gt;gadget);
 }
 
<span class="p_chunk">@@ -175,14 +175,21 @@</span> <span class="p_context"> static void ci_handle_id_switch(struct ci_hdrc *ci)</span>
 
 		ci_role_stop(ci);
 
<span class="p_del">-		if (role == CI_ROLE_GADGET)</span>
<span class="p_add">+		if (role == CI_ROLE_GADGET &amp;&amp;</span>
<span class="p_add">+				IS_ERR(ci-&gt;platdata-&gt;vbus_extcon.edev))</span>
 			/*
<span class="p_del">-			 * wait vbus lower than OTGSC_BSV before connecting</span>
<span class="p_del">-			 * to host</span>
<span class="p_add">+			 * Wait vbus lower than OTGSC_BSV before connecting</span>
<span class="p_add">+			 * to host. If connecting status is from an external</span>
<span class="p_add">+			 * connector instead of register, we don&#39;t need to</span>
<span class="p_add">+			 * care vbus on the board, since it will not affect</span>
<span class="p_add">+			 * external connector status.</span>
 			 */
 			hw_wait_vbus_lower_bsv(ci);
 
 		ci_role_start(ci, role);
<span class="p_add">+		/* vbus change may have already occurred */</span>
<span class="p_add">+		if (role == CI_ROLE_GADGET)</span>
<span class="p_add">+			ci_handle_vbus_change(ci);</span>
 	}
 }
 /**
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index e56cdb436de3..4581fa1dec98 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -234,11 +234,16 @@</span> <span class="p_context"> static int read_mos_reg(struct usb_serial *serial, unsigned int serial_portnum,</span>
 
 	status = usb_control_msg(usbdev, pipe, request, requesttype, value,
 				     index, buf, 1, MOS_WDR_TIMEOUT);
<span class="p_del">-	if (status == 1)</span>
<span class="p_add">+	if (status == 1) {</span>
 		*data = *buf;
<span class="p_del">-	else if (status &lt; 0)</span>
<span class="p_add">+	} else {</span>
 		dev_err(&amp;usbdev-&gt;dev,
 			&quot;mos7720: usb_control_msg() failed: %d\n&quot;, status);
<span class="p_add">+		if (status &gt;= 0)</span>
<span class="p_add">+			status = -EIO;</span>
<span class="p_add">+		*data = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(buf);
 
 	return status;
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index d17685cc00c9..ed883a7ad533 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -285,9 +285,15 @@</span> <span class="p_context"> static int mos7840_get_reg_sync(struct usb_serial_port *port, __u16 reg,</span>
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,
 			      MCS_RD_RTYPE, 0, reg, buf, VENDOR_READ_LENGTH,
 			      MOS_WDR_TIMEOUT);
<span class="p_add">+	if (ret &lt; VENDOR_READ_LENGTH) {</span>
<span class="p_add">+		if (ret &gt;= 0)</span>
<span class="p_add">+			ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	*val = buf[0];
 	dev_dbg(&amp;port-&gt;dev, &quot;%s offset is %x, return val %x\n&quot;, __func__, reg, *val);
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	kfree(buf);
 	return ret;
 }
<span class="p_chunk">@@ -353,8 +359,13 @@</span> <span class="p_context"> static int mos7840_get_uart_reg(struct usb_serial_port *port, __u16 reg,</span>
 	ret = usb_control_msg(dev, usb_rcvctrlpipe(dev, 0), MCS_RDREQ,
 			      MCS_RD_RTYPE, Wval, reg, buf, VENDOR_READ_LENGTH,
 			      MOS_WDR_TIMEOUT);
<span class="p_add">+	if (ret &lt; VENDOR_READ_LENGTH) {</span>
<span class="p_add">+		if (ret &gt;= 0)</span>
<span class="p_add">+			ret = -EIO;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	*val = buf[0];
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	kfree(buf);
 	return ret;
 }
<span class="p_chunk">@@ -1490,10 +1501,10 @@</span> <span class="p_context"> static int mos7840_tiocmget(struct tty_struct *tty)</span>
 		return -ENODEV;
 
 	status = mos7840_get_uart_reg(port, MODEM_STATUS_REGISTER, &amp;msr);
<span class="p_del">-	if (status != 1)</span>
<span class="p_add">+	if (status &lt; 0)</span>
 		return -EIO;
 	status = mos7840_get_uart_reg(port, MODEM_CONTROL_REGISTER, &amp;mcr);
<span class="p_del">-	if (status != 1)</span>
<span class="p_add">+	if (status &lt; 0)</span>
 		return -EIO;
 	result = ((mcr &amp; MCR_DTR) ? TIOCM_DTR : 0)
 	    | ((mcr &amp; MCR_RTS) ? TIOCM_RTS : 0)
<span class="p_header">diff --git a/fs/gfs2/glock.c b/fs/gfs2/glock.c</span>
<span class="p_header">index ff36f5475d7e..09a0cf5f3dd8 100644</span>
<span class="p_header">--- a/fs/gfs2/glock.c</span>
<span class="p_header">+++ b/fs/gfs2/glock.c</span>
<span class="p_chunk">@@ -1798,16 +1798,18 @@</span> <span class="p_context"> void gfs2_glock_exit(void)</span>
 
 static void gfs2_glock_iter_next(struct gfs2_glock_iter *gi)
 {
<span class="p_del">-	do {</span>
<span class="p_del">-		gi-&gt;gl = rhashtable_walk_next(&amp;gi-&gt;hti);</span>
<span class="p_add">+	while ((gi-&gt;gl = rhashtable_walk_next(&amp;gi-&gt;hti))) {</span>
 		if (IS_ERR(gi-&gt;gl)) {
 			if (PTR_ERR(gi-&gt;gl) == -EAGAIN)
 				continue;
 			gi-&gt;gl = NULL;
<span class="p_add">+			return;</span>
 		}
<span class="p_del">-	/* Skip entries for other sb and dead entries */</span>
<span class="p_del">-	} while ((gi-&gt;gl) &amp;&amp; ((gi-&gt;sdp != gi-&gt;gl-&gt;gl_name.ln_sbd) ||</span>
<span class="p_del">-			      __lockref_is_dead(&amp;gi-&gt;gl-&gt;gl_lockref)));</span>
<span class="p_add">+		/* Skip entries for other sb and dead entries */</span>
<span class="p_add">+		if (gi-&gt;sdp == gi-&gt;gl-&gt;gl_name.ln_sbd &amp;&amp;</span>
<span class="p_add">+		    !__lockref_is_dead(&amp;gi-&gt;gl-&gt;gl_lockref))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
 }
 
 static void *gfs2_glock_seq_start(struct seq_file *seq, loff_t *pos)
<span class="p_header">diff --git a/fs/xfs/kmem.c b/fs/xfs/kmem.c</span>
<span class="p_header">index 686ba6fb20dd..8067364c602f 100644</span>
<span class="p_header">--- a/fs/xfs/kmem.c</span>
<span class="p_header">+++ b/fs/xfs/kmem.c</span>
<span class="p_chunk">@@ -24,24 +24,6 @@</span> <span class="p_context"></span>
 #include &quot;kmem.h&quot;
 #include &quot;xfs_message.h&quot;
 
<span class="p_del">-/*</span>
<span class="p_del">- * Greedy allocation.  May fail and may return vmalloced memory.</span>
<span class="p_del">- */</span>
<span class="p_del">-void *</span>
<span class="p_del">-kmem_zalloc_greedy(size_t *size, size_t minsize, size_t maxsize)</span>
<span class="p_del">-{</span>
<span class="p_del">-	void		*ptr;</span>
<span class="p_del">-	size_t		kmsize = maxsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (!(ptr = vzalloc(kmsize))) {</span>
<span class="p_del">-		if ((kmsize &gt;&gt;= 1) &lt;= minsize)</span>
<span class="p_del">-			kmsize = minsize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ptr)</span>
<span class="p_del">-		*size = kmsize;</span>
<span class="p_del">-	return ptr;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void *
 kmem_alloc(size_t size, xfs_km_flags_t flags)
 {
<span class="p_header">diff --git a/fs/xfs/kmem.h b/fs/xfs/kmem.h</span>
<span class="p_header">index cc6b768fc068..ae45f77ce33b 100644</span>
<span class="p_header">--- a/fs/xfs/kmem.h</span>
<span class="p_header">+++ b/fs/xfs/kmem.h</span>
<span class="p_chunk">@@ -69,8 +69,6 @@</span> <span class="p_context"> static inline void  kmem_free(const void *ptr)</span>
 }
 
 
<span class="p_del">-extern void *kmem_zalloc_greedy(size_t *, size_t, size_t);</span>
<span class="p_del">-</span>
 static inline void *
 kmem_zalloc(size_t size, xfs_km_flags_t flags)
 {
<span class="p_header">diff --git a/fs/xfs/xfs_itable.c b/fs/xfs/xfs_itable.c</span>
<span class="p_header">index 930ebd86beba..99a4891c00ab 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_itable.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_itable.c</span>
<span class="p_chunk">@@ -351,7 +351,6 @@</span> <span class="p_context"> xfs_bulkstat(</span>
 	xfs_agino_t		agino;	/* inode # in allocation group */
 	xfs_agnumber_t		agno;	/* allocation group number */
 	xfs_btree_cur_t		*cur;	/* btree cursor for ialloc btree */
<span class="p_del">-	size_t			irbsize; /* size of irec buffer in bytes */</span>
 	xfs_inobt_rec_incore_t	*irbuf;	/* start of irec buffer */
 	int			nirbuf;	/* size of irbuf */
 	int			ubcount; /* size of user&#39;s buffer */
<span class="p_chunk">@@ -378,11 +377,10 @@</span> <span class="p_context"> xfs_bulkstat(</span>
 	*ubcountp = 0;
 	*done = 0;
 
<span class="p_del">-	irbuf = kmem_zalloc_greedy(&amp;irbsize, PAGE_SIZE, PAGE_SIZE * 4);</span>
<span class="p_add">+	irbuf = kmem_zalloc_large(PAGE_SIZE * 4, KM_SLEEP);</span>
 	if (!irbuf)
 		return -ENOMEM;
<span class="p_del">-</span>
<span class="p_del">-	nirbuf = irbsize / sizeof(*irbuf);</span>
<span class="p_add">+	nirbuf = (PAGE_SIZE * 4) / sizeof(*irbuf);</span>
 
 	/*
 	 * Loop over the allocation groups, starting from the last
<span class="p_header">diff --git a/include/linux/audit.h b/include/linux/audit.h</span>
<span class="p_header">index 20eba1eb0a3c..faac391badac 100644</span>
<span class="p_header">--- a/include/linux/audit.h</span>
<span class="p_header">+++ b/include/linux/audit.h</span>
<span class="p_chunk">@@ -281,6 +281,20 @@</span> <span class="p_context"> static inline int audit_socketcall(int nargs, unsigned long *args)</span>
 		return __audit_socketcall(nargs, args);
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int audit_socketcall_compat(int nargs, u32 *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long a[AUDITSC_ARGS];</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (audit_dummy_context())</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; nargs; i++)</span>
<span class="p_add">+		a[i] = (unsigned long)args[i];</span>
<span class="p_add">+	return __audit_socketcall(nargs, a);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int audit_sockaddr(int len, void *addr)
 {
 	if (unlikely(!audit_dummy_context()))
<span class="p_chunk">@@ -407,6 +421,12 @@</span> <span class="p_context"> static inline int audit_socketcall(int nargs, unsigned long *args)</span>
 {
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int audit_socketcall_compat(int nargs, u32 *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline void audit_fd_pair(int fd1, int fd2)
 { }
 static inline int audit_sockaddr(int len, void *addr)
<span class="p_header">diff --git a/include/linux/mmc/sdio_func.h b/include/linux/mmc/sdio_func.h</span>
<span class="p_header">index aab032a6ae61..97ca105347a6 100644</span>
<span class="p_header">--- a/include/linux/mmc/sdio_func.h</span>
<span class="p_header">+++ b/include/linux/mmc/sdio_func.h</span>
<span class="p_chunk">@@ -53,7 +53,7 @@</span> <span class="p_context"> struct sdio_func {</span>
 	unsigned int		state;		/* function state */
 #define SDIO_STATE_PRESENT	(1&lt;&lt;0)		/* present in sysfs */
 
<span class="p_del">-	u8			tmpbuf[4];	/* DMA:able scratch buffer */</span>
<span class="p_add">+	u8			*tmpbuf;	/* DMA:able scratch buffer */</span>
 
 	unsigned		num_info;	/* number of info strings */
 	const char		**info;		/* info strings */
<span class="p_header">diff --git a/include/uapi/drm/drm_fourcc.h b/include/uapi/drm/drm_fourcc.h</span>
<span class="p_header">index 0b69a7753558..f28f79966e9e 100644</span>
<span class="p_header">--- a/include/uapi/drm/drm_fourcc.h</span>
<span class="p_header">+++ b/include/uapi/drm/drm_fourcc.h</span>
<span class="p_chunk">@@ -150,6 +150,7 @@</span> <span class="p_context"></span>
 
 /* Vendor Ids: */
 #define DRM_FORMAT_MOD_NONE           0
<span class="p_add">+#define DRM_FORMAT_MOD_VENDOR_NONE    0</span>
 #define DRM_FORMAT_MOD_VENDOR_INTEL   0x01
 #define DRM_FORMAT_MOD_VENDOR_AMD     0x02
 #define DRM_FORMAT_MOD_VENDOR_NV      0x03
<span class="p_header">diff --git a/net/bridge/br_netlink.c b/net/bridge/br_netlink.c</span>
<span class="p_header">index ff8bb41d713f..a1f697ec4fc2 100644</span>
<span class="p_header">--- a/net/bridge/br_netlink.c</span>
<span class="p_header">+++ b/net/bridge/br_netlink.c</span>
<span class="p_chunk">@@ -1073,11 +1073,14 @@</span> <span class="p_context"> static int br_dev_newlink(struct net *src_net, struct net_device *dev,</span>
 		spin_unlock_bh(&amp;br-&gt;lock);
 	}
 
<span class="p_del">-	err = br_changelink(dev, tb, data);</span>
<span class="p_add">+	err = register_netdevice(dev);</span>
 	if (err)
 		return err;
 
<span class="p_del">-	return register_netdevice(dev);</span>
<span class="p_add">+	err = br_changelink(dev, tb, data);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		unregister_netdevice(dev);</span>
<span class="p_add">+	return err;</span>
 }
 
 static size_t br_get_size(const struct net_device *brdev)
<span class="p_header">diff --git a/net/compat.c b/net/compat.c</span>
<span class="p_header">index 5cfd26a0006f..0ccf3ecf6bbb 100644</span>
<span class="p_header">--- a/net/compat.c</span>
<span class="p_header">+++ b/net/compat.c</span>
<span class="p_chunk">@@ -22,6 +22,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/filter.h&gt;
 #include &lt;linux/compat.h&gt;
 #include &lt;linux/security.h&gt;
<span class="p_add">+#include &lt;linux/audit.h&gt;</span>
 #include &lt;linux/export.h&gt;
 
 #include &lt;net/scm.h&gt;
<span class="p_chunk">@@ -767,14 +768,24 @@</span> <span class="p_context"> COMPAT_SYSCALL_DEFINE5(recvmmsg, int, fd, struct compat_mmsghdr __user *, mmsg,</span>
 
 COMPAT_SYSCALL_DEFINE2(socketcall, int, call, u32 __user *, args)
 {
<span class="p_del">-	int ret;</span>
<span class="p_del">-	u32 a[6];</span>
<span class="p_add">+	u32 a[AUDITSC_ARGS];</span>
<span class="p_add">+	unsigned int len;</span>
 	u32 a0, a1;
<span class="p_add">+	int ret;</span>
 
 	if (call &lt; SYS_SOCKET || call &gt; SYS_SENDMMSG)
 		return -EINVAL;
<span class="p_del">-	if (copy_from_user(a, args, nas[call]))</span>
<span class="p_add">+	len = nas[call];</span>
<span class="p_add">+	if (len &gt; sizeof(a))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(a, args, len))</span>
 		return -EFAULT;
<span class="p_add">+</span>
<span class="p_add">+	ret = audit_socketcall_compat(len / sizeof(a[0]), a);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	a0 = a[0];
 	a1 = a[1];
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 24d243084aab..dac52fa60f25 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2338,6 +2338,9 @@</span> <span class="p_context"> void __dev_kfree_skb_irq(struct sk_buff *skb, enum skb_free_reason reason)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (unlikely(!skb))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (likely(atomic_read(&amp;skb-&gt;users) == 1)) {
 		smp_rmb();
 		atomic_set(&amp;skb-&gt;users, 0);
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">index ddb894ac1458..2689c9c4f1a0 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_chunk">@@ -1304,6 +1304,7 @@</span> <span class="p_context"> static int __init nf_nat_snmp_basic_init(void)</span>
 static void __exit nf_nat_snmp_basic_fini(void)
 {
 	RCU_INIT_POINTER(nf_nat_snmp_hook, NULL);
<span class="p_add">+	synchronize_rcu();</span>
 	nf_conntrack_helper_unregister(&amp;snmp_trap_helper);
 }
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_ecache.c b/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_header">index 4e78c57b818f..f3b92ce463b0 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_ecache.c</span>
<span class="p_chunk">@@ -200,6 +200,7 @@</span> <span class="p_context"> void nf_conntrack_unregister_notifier(struct net *net,</span>
 	BUG_ON(notify != new);
 	RCU_INIT_POINTER(net-&gt;ct.nf_conntrack_event_cb, NULL);
 	mutex_unlock(&amp;nf_ct_ecache_mutex);
<span class="p_add">+	/* synchronize_rcu() is called from ctnetlink_exit. */</span>
 }
 EXPORT_SYMBOL_GPL(nf_conntrack_unregister_notifier);
 
<span class="p_chunk">@@ -236,6 +237,7 @@</span> <span class="p_context"> void nf_ct_expect_unregister_notifier(struct net *net,</span>
 	BUG_ON(notify != new);
 	RCU_INIT_POINTER(net-&gt;ct.nf_expect_event_cb, NULL);
 	mutex_unlock(&amp;nf_ct_ecache_mutex);
<span class="p_add">+	/* synchronize_rcu() is called from ctnetlink_exit. */</span>
 }
 EXPORT_SYMBOL_GPL(nf_ct_expect_unregister_notifier);
 
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_netlink.c b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">index e565b2becb14..660939df7c94 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_netlink.c</span>
<span class="p_chunk">@@ -3415,6 +3415,7 @@</span> <span class="p_context"> static void __exit ctnetlink_exit(void)</span>
 #ifdef CONFIG_NETFILTER_NETLINK_GLUE_CT
 	RCU_INIT_POINTER(nfnl_ct_hook, NULL);
 #endif
<span class="p_add">+	synchronize_rcu();</span>
 }
 
 module_init(ctnetlink_init);
<span class="p_header">diff --git a/net/netfilter/nf_nat_core.c b/net/netfilter/nf_nat_core.c</span>
<span class="p_header">index 06a9f45771ab..44516c90118a 100644</span>
<span class="p_header">--- a/net/netfilter/nf_nat_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_nat_core.c</span>
<span class="p_chunk">@@ -892,6 +892,8 @@</span> <span class="p_context"> static void __exit nf_nat_cleanup(void)</span>
 #ifdef CONFIG_XFRM
 	RCU_INIT_POINTER(nf_nat_decode_session_hook, NULL);
 #endif
<span class="p_add">+	synchronize_rcu();</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; NFPROTO_NUMPROTO; i++)
 		kfree(nf_nat_l4protos[i]);
 	synchronize_net();
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 54330fb5efaf..6d10002d23f8 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -161,6 +161,7 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 	int i, ret;
 	struct nf_conntrack_expect_policy *expect_policy;
 	struct nlattr *tb[NFCTH_POLICY_SET_MAX+1];
<span class="p_add">+	unsigned int class_max;</span>
 
 	ret = nla_parse_nested(tb, NFCTH_POLICY_SET_MAX, attr,
 			       nfnl_cthelper_expect_policy_set);
<span class="p_chunk">@@ -170,19 +171,18 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 	if (!tb[NFCTH_POLICY_SET_NUM])
 		return -EINVAL;
 
<span class="p_del">-	helper-&gt;expect_class_max =</span>
<span class="p_del">-		ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (helper-&gt;expect_class_max != 0 &amp;&amp;</span>
<span class="p_del">-	    helper-&gt;expect_class_max &gt; NF_CT_MAX_EXPECT_CLASSES)</span>
<span class="p_add">+	class_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_add">+	if (class_max == 0)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (class_max &gt; NF_CT_MAX_EXPECT_CLASSES)</span>
 		return -EOVERFLOW;
 
 	expect_policy = kzalloc(sizeof(struct nf_conntrack_expect_policy) *
<span class="p_del">-				helper-&gt;expect_class_max, GFP_KERNEL);</span>
<span class="p_add">+				class_max, GFP_KERNEL);</span>
 	if (expect_policy == NULL)
 		return -ENOMEM;
 
<span class="p_del">-	for (i=0; i&lt;helper-&gt;expect_class_max; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; class_max; i++) {</span>
 		if (!tb[NFCTH_POLICY_SET+i])
 			goto err;
 
<span class="p_chunk">@@ -191,6 +191,8 @@</span> <span class="p_context"> nfnl_cthelper_parse_expect_policy(struct nf_conntrack_helper *helper,</span>
 		if (ret &lt; 0)
 			goto err;
 	}
<span class="p_add">+</span>
<span class="p_add">+	helper-&gt;expect_class_max = class_max - 1;</span>
 	helper-&gt;expect_policy = expect_policy;
 	return 0;
 err:
<span class="p_chunk">@@ -377,10 +379,10 @@</span> <span class="p_context"> nfnl_cthelper_dump_policy(struct sk_buff *skb,</span>
 		goto nla_put_failure;
 
 	if (nla_put_be32(skb, NFCTH_POLICY_SET_NUM,
<span class="p_del">-			 htonl(helper-&gt;expect_class_max)))</span>
<span class="p_add">+			 htonl(helper-&gt;expect_class_max + 1)))</span>
 		goto nla_put_failure;
 
<span class="p_del">-	for (i=0; i&lt;helper-&gt;expect_class_max; i++) {</span>
<span class="p_add">+	for (i = 0; i &lt; helper-&gt;expect_class_max + 1; i++) {</span>
 		nest_parms2 = nla_nest_start(skb,
 				(NFCTH_POLICY_SET+i) | NLA_F_NESTED);
 		if (nest_parms2 == NULL)
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cttimeout.c b/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_header">index c7a2d0e1c462..ed9153bd7e73 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cttimeout.c</span>
<span class="p_chunk">@@ -611,8 +611,8 @@</span> <span class="p_context"> static void __exit cttimeout_exit(void)</span>
 #ifdef CONFIG_NF_CONNTRACK_TIMEOUT
 	RCU_INIT_POINTER(nf_ct_timeout_find_get_hook, NULL);
 	RCU_INIT_POINTER(nf_ct_timeout_put_hook, NULL);
<span class="p_add">+	synchronize_rcu();</span>
 #endif /* CONFIG_NF_CONNTRACK_TIMEOUT */
<span class="p_del">-	rcu_barrier();</span>
 }
 
 module_init(cttimeout_init);
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index 148ec130d99d..b70055fc30cb 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -3802,6 +3802,8 @@</span> <span class="p_context"> static int packet_getsockopt(struct socket *sock, int level, int optname,</span>
 	case PACKET_HDRLEN:
 		if (len &gt; sizeof(int))
 			len = sizeof(int);
<span class="p_add">+		if (len &lt; sizeof(int))</span>
<span class="p_add">+			return -EINVAL;</span>
 		if (copy_from_user(&amp;val, optval, len))
 			return -EFAULT;
 		switch (val) {
<span class="p_header">diff --git a/net/rds/ib_cm.c b/net/rds/ib_cm.c</span>
<span class="p_header">index da5a7fb98c77..a6f5b3d21571 100644</span>
<span class="p_header">--- a/net/rds/ib_cm.c</span>
<span class="p_header">+++ b/net/rds/ib_cm.c</span>
<span class="p_chunk">@@ -381,7 +381,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 		ret = PTR_ERR(ic-&gt;i_send_cq);
 		ic-&gt;i_send_cq = NULL;
 		rdsdebug(&quot;ib_create_cq send failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto rds_ibdev_out;</span>
 	}
 
 	cq_attr.cqe = ic-&gt;i_recv_ring.w_nr;
<span class="p_chunk">@@ -392,19 +392,19 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 		ret = PTR_ERR(ic-&gt;i_recv_cq);
 		ic-&gt;i_recv_cq = NULL;
 		rdsdebug(&quot;ib_create_cq recv failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto send_cq_out;</span>
 	}
 
 	ret = ib_req_notify_cq(ic-&gt;i_send_cq, IB_CQ_NEXT_COMP);
 	if (ret) {
 		rdsdebug(&quot;ib_req_notify_cq send failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	ret = ib_req_notify_cq(ic-&gt;i_recv_cq, IB_CQ_SOLICITED);
 	if (ret) {
 		rdsdebug(&quot;ib_req_notify_cq recv failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	/* XXX negotiate max send/recv with remote? */
<span class="p_chunk">@@ -428,7 +428,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	ret = rdma_create_qp(ic-&gt;i_cm_id, ic-&gt;i_pd, &amp;attr);
 	if (ret) {
 		rdsdebug(&quot;rdma_create_qp failed: %d\n&quot;, ret);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_cq_out;</span>
 	}
 
 	ic-&gt;i_send_hdrs = ib_dma_alloc_coherent(dev,
<span class="p_chunk">@@ -438,7 +438,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_send_hdrs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent send failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto qp_out;</span>
 	}
 
 	ic-&gt;i_recv_hdrs = ib_dma_alloc_coherent(dev,
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_recv_hdrs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent recv failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto send_hdrs_dma_out;</span>
 	}
 
 	ic-&gt;i_ack = ib_dma_alloc_coherent(dev, sizeof(struct rds_header),
<span class="p_chunk">@@ -456,7 +456,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_ack) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;ib_dma_alloc_coherent ack failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto recv_hdrs_dma_out;</span>
 	}
 
 	ic-&gt;i_sends = vzalloc_node(ic-&gt;i_send_ring.w_nr * sizeof(struct rds_ib_send_work),
<span class="p_chunk">@@ -464,7 +464,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_sends) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;send allocation failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto ack_dma_out;</span>
 	}
 
 	ic-&gt;i_recvs = vzalloc_node(ic-&gt;i_recv_ring.w_nr * sizeof(struct rds_ib_recv_work),
<span class="p_chunk">@@ -472,7 +472,7 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	if (!ic-&gt;i_recvs) {
 		ret = -ENOMEM;
 		rdsdebug(&quot;recv allocation failed\n&quot;);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto sends_out;</span>
 	}
 
 	rds_ib_recv_init_ack(ic);
<span class="p_chunk">@@ -480,8 +480,33 @@</span> <span class="p_context"> static int rds_ib_setup_qp(struct rds_connection *conn)</span>
 	rdsdebug(&quot;conn %p pd %p cq %p %p\n&quot;, conn, ic-&gt;i_pd,
 		 ic-&gt;i_send_cq, ic-&gt;i_recv_cq);
 
<span class="p_del">-out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+sends_out:</span>
<span class="p_add">+	vfree(ic-&gt;i_sends);</span>
<span class="p_add">+ack_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, sizeof(struct rds_header),</span>
<span class="p_add">+			     ic-&gt;i_ack, ic-&gt;i_ack_dma);</span>
<span class="p_add">+recv_hdrs_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, ic-&gt;i_recv_ring.w_nr *</span>
<span class="p_add">+					sizeof(struct rds_header),</span>
<span class="p_add">+					ic-&gt;i_recv_hdrs, ic-&gt;i_recv_hdrs_dma);</span>
<span class="p_add">+send_hdrs_dma_out:</span>
<span class="p_add">+	ib_dma_free_coherent(dev, ic-&gt;i_send_ring.w_nr *</span>
<span class="p_add">+					sizeof(struct rds_header),</span>
<span class="p_add">+					ic-&gt;i_send_hdrs, ic-&gt;i_send_hdrs_dma);</span>
<span class="p_add">+qp_out:</span>
<span class="p_add">+	rdma_destroy_qp(ic-&gt;i_cm_id);</span>
<span class="p_add">+recv_cq_out:</span>
<span class="p_add">+	if (!ib_destroy_cq(ic-&gt;i_recv_cq))</span>
<span class="p_add">+		ic-&gt;i_recv_cq = NULL;</span>
<span class="p_add">+send_cq_out:</span>
<span class="p_add">+	if (!ib_destroy_cq(ic-&gt;i_send_cq))</span>
<span class="p_add">+		ic-&gt;i_send_cq = NULL;</span>
<span class="p_add">+rds_ibdev_out:</span>
<span class="p_add">+	rds_ib_remove_conn(rds_ibdev, conn);</span>
 	rds_ib_dev_put(rds_ibdev);
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/net/rds/ib_send.c b/net/rds/ib_send.c</span>
<span class="p_header">index eac30bf486d7..094e2a12860a 100644</span>
<span class="p_header">--- a/net/rds/ib_send.c</span>
<span class="p_header">+++ b/net/rds/ib_send.c</span>
<span class="p_chunk">@@ -68,16 +68,6 @@</span> <span class="p_context"> static void rds_ib_send_complete(struct rds_message *rm,</span>
 	complete(rm, notify_status);
 }
 
<span class="p_del">-static void rds_ib_send_unmap_data(struct rds_ib_connection *ic,</span>
<span class="p_del">-				   struct rm_data_op *op,</span>
<span class="p_del">-				   int wc_status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (op-&gt;op_nents)</span>
<span class="p_del">-		ib_dma_unmap_sg(ic-&gt;i_cm_id-&gt;device,</span>
<span class="p_del">-				op-&gt;op_sg, op-&gt;op_nents,</span>
<span class="p_del">-				DMA_TO_DEVICE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void rds_ib_send_unmap_rdma(struct rds_ib_connection *ic,
 				   struct rm_rdma_op *op,
 				   int wc_status)
<span class="p_chunk">@@ -138,6 +128,21 @@</span> <span class="p_context"> static void rds_ib_send_unmap_atomic(struct rds_ib_connection *ic,</span>
 		rds_ib_stats_inc(s_ib_atomic_fadd);
 }
 
<span class="p_add">+static void rds_ib_send_unmap_data(struct rds_ib_connection *ic,</span>
<span class="p_add">+				   struct rm_data_op *op,</span>
<span class="p_add">+				   int wc_status)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rds_message *rm = container_of(op, struct rds_message, data);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (op-&gt;op_nents)</span>
<span class="p_add">+		ib_dma_unmap_sg(ic-&gt;i_cm_id-&gt;device,</span>
<span class="p_add">+				op-&gt;op_sg, op-&gt;op_nents,</span>
<span class="p_add">+				DMA_TO_DEVICE);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rm-&gt;rdma.op_active &amp;&amp; rm-&gt;data.op_notify)</span>
<span class="p_add">+		rds_ib_send_unmap_rdma(ic, &amp;rm-&gt;rdma, wc_status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Unmap the resources associated with a struct send_work.
  *
<span class="p_header">diff --git a/net/rds/rdma.c b/net/rds/rdma.c</span>
<span class="p_header">index 4c93badeabf2..8d3a851a3476 100644</span>
<span class="p_header">--- a/net/rds/rdma.c</span>
<span class="p_header">+++ b/net/rds/rdma.c</span>
<span class="p_chunk">@@ -626,6 +626,16 @@</span> <span class="p_context"> int rds_cmsg_rdma_args(struct rds_sock *rs, struct rds_message *rm,</span>
 		}
 		op-&gt;op_notifier-&gt;n_user_token = args-&gt;user_token;
 		op-&gt;op_notifier-&gt;n_status = RDS_RDMA_SUCCESS;
<span class="p_add">+</span>
<span class="p_add">+		/* Enable rmda notification on data operation for composite</span>
<span class="p_add">+		 * rds messages and make sure notification is enabled only</span>
<span class="p_add">+		 * for the data operation which follows it so that application</span>
<span class="p_add">+		 * gets notified only after full message gets delivered.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (rm-&gt;data.op_sg) {</span>
<span class="p_add">+			rm-&gt;rdma.op_notify = 0;</span>
<span class="p_add">+			rm-&gt;data.op_notify = !!(args-&gt;flags &amp; RDS_RDMA_NOTIFY_ME);</span>
<span class="p_add">+		}</span>
 	}
 
 	/* The cookie contains the R_Key of the remote memory region, and
<span class="p_header">diff --git a/net/rds/rds.h b/net/rds/rds.h</span>
<span class="p_header">index 0e2797bdc316..4588860f4c3b 100644</span>
<span class="p_header">--- a/net/rds/rds.h</span>
<span class="p_header">+++ b/net/rds/rds.h</span>
<span class="p_chunk">@@ -378,6 +378,7 @@</span> <span class="p_context"> struct rds_message {</span>
 		} rdma;
 		struct rm_data_op {
 			unsigned int		op_active:1;
<span class="p_add">+			unsigned int		op_notify:1;</span>
 			unsigned int		op_nents;
 			unsigned int		op_count;
 			unsigned int		op_dmasg;
<span class="p_header">diff --git a/net/rds/send.c b/net/rds/send.c</span>
<span class="p_header">index c9cdb358ea88..6815f03324d7 100644</span>
<span class="p_header">--- a/net/rds/send.c</span>
<span class="p_header">+++ b/net/rds/send.c</span>
<span class="p_chunk">@@ -467,12 +467,14 @@</span> <span class="p_context"> void rds_rdma_send_complete(struct rds_message *rm, int status)</span>
 	struct rm_rdma_op *ro;
 	struct rds_notifier *notifier;
 	unsigned long flags;
<span class="p_add">+	unsigned int notify = 0;</span>
 
 	spin_lock_irqsave(&amp;rm-&gt;m_rs_lock, flags);
 
<span class="p_add">+	notify =  rm-&gt;rdma.op_notify | rm-&gt;data.op_notify;</span>
 	ro = &amp;rm-&gt;rdma;
 	if (test_bit(RDS_MSG_ON_SOCK, &amp;rm-&gt;m_flags) &amp;&amp;
<span class="p_del">-	    ro-&gt;op_active &amp;&amp; ro-&gt;op_notify &amp;&amp; ro-&gt;op_notifier) {</span>
<span class="p_add">+	    ro-&gt;op_active &amp;&amp; notify &amp;&amp; ro-&gt;op_notifier) {</span>
 		notifier = ro-&gt;op_notifier;
 		rs = rm-&gt;m_rs;
 		sock_hold(rds_rs_to_sk(rs));
<span class="p_header">diff --git a/sound/pci/au88x0/au88x0_core.c b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">index d3125c169684..065a69cf6118 100644</span>
<span class="p_header">--- a/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_header">+++ b/sound/pci/au88x0/au88x0_core.c</span>
<span class="p_chunk">@@ -2279,6 +2279,9 @@</span> <span class="p_context"> vortex_adb_allocroute(vortex_t *vortex, int dma, int nr_ch, int dir,</span>
 	} else {
 		int src[2], mix[2];
 
<span class="p_add">+		if (nr_ch &lt; 1)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		/* Get SRC and MIXER hardware resources. */
 		for (i = 0; i &lt; nr_ch; i++) {
 			if ((mix[i] =
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index b8a256dfed7e..6a438a361592 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -358,6 +358,10 @@</span> <span class="p_context"> static int dapm_kcontrol_data_alloc(struct snd_soc_dapm_widget *widget,</span>
 				snd_soc_dapm_new_control_unlocked(widget-&gt;dapm,
 				&amp;template);
 			kfree(name);
<span class="p_add">+			if (IS_ERR(data-&gt;widget)) {</span>
<span class="p_add">+				ret = PTR_ERR(data-&gt;widget);</span>
<span class="p_add">+				goto err_data;</span>
<span class="p_add">+			}</span>
 			if (!data-&gt;widget) {
 				ret = -ENOMEM;
 				goto err_data;
<span class="p_chunk">@@ -392,6 +396,10 @@</span> <span class="p_context"> static int dapm_kcontrol_data_alloc(struct snd_soc_dapm_widget *widget,</span>
 			data-&gt;widget = snd_soc_dapm_new_control_unlocked(
 						widget-&gt;dapm, &amp;template);
 			kfree(name);
<span class="p_add">+			if (IS_ERR(data-&gt;widget)) {</span>
<span class="p_add">+				ret = PTR_ERR(data-&gt;widget);</span>
<span class="p_add">+				goto err_data;</span>
<span class="p_add">+			}</span>
 			if (!data-&gt;widget) {
 				ret = -ENOMEM;
 				goto err_data;
<span class="p_chunk">@@ -3278,11 +3286,22 @@</span> <span class="p_context"> snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,</span>
 
 	mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_RUNTIME);
 	w = snd_soc_dapm_new_control_unlocked(dapm, widget);
<span class="p_add">+	/* Do not nag about probe deferrals */</span>
<span class="p_add">+	if (IS_ERR(w)) {</span>
<span class="p_add">+		int ret = PTR_ERR(w);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+			dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create DAPM control %s (%d)\n&quot;,</span>
<span class="p_add">+				widget-&gt;name, ret);</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
 	if (!w)
 		dev_err(dapm-&gt;dev,
 			&quot;ASoC: Failed to create DAPM control %s\n&quot;,
 			widget-&gt;name);
 
<span class="p_add">+out_unlock:</span>
 	mutex_unlock(&amp;dapm-&gt;card-&gt;dapm_mutex);
 	return w;
 }
<span class="p_chunk">@@ -3304,6 +3323,8 @@</span> <span class="p_context"> snd_soc_dapm_new_control_unlocked(struct snd_soc_dapm_context *dapm,</span>
 		w-&gt;regulator = devm_regulator_get(dapm-&gt;dev, w-&gt;name);
 		if (IS_ERR(w-&gt;regulator)) {
 			ret = PTR_ERR(w-&gt;regulator);
<span class="p_add">+			if (ret == -EPROBE_DEFER)</span>
<span class="p_add">+				return ERR_PTR(ret);</span>
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to request %s: %d\n&quot;,
 				w-&gt;name, ret);
 			return NULL;
<span class="p_chunk">@@ -3322,6 +3343,8 @@</span> <span class="p_context"> snd_soc_dapm_new_control_unlocked(struct snd_soc_dapm_context *dapm,</span>
 		w-&gt;clk = devm_clk_get(dapm-&gt;dev, w-&gt;name);
 		if (IS_ERR(w-&gt;clk)) {
 			ret = PTR_ERR(w-&gt;clk);
<span class="p_add">+			if (ret == -EPROBE_DEFER)</span>
<span class="p_add">+				return ERR_PTR(ret);</span>
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to request %s: %d\n&quot;,
 				w-&gt;name, ret);
 			return NULL;
<span class="p_chunk">@@ -3435,6 +3458,16 @@</span> <span class="p_context"> int snd_soc_dapm_new_controls(struct snd_soc_dapm_context *dapm,</span>
 	mutex_lock_nested(&amp;dapm-&gt;card-&gt;dapm_mutex, SND_SOC_DAPM_CLASS_INIT);
 	for (i = 0; i &lt; num; i++) {
 		w = snd_soc_dapm_new_control_unlocked(dapm, widget);
<span class="p_add">+		if (IS_ERR(w)) {</span>
<span class="p_add">+			ret = PTR_ERR(w);</span>
<span class="p_add">+			/* Do not nag about probe deferrals */</span>
<span class="p_add">+			if (ret == -EPROBE_DEFER)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create DAPM control %s (%d)\n&quot;,</span>
<span class="p_add">+				widget-&gt;name, ret);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 		if (!w) {
 			dev_err(dapm-&gt;dev,
 				&quot;ASoC: Failed to create DAPM control %s\n&quot;,
<span class="p_chunk">@@ -3701,6 +3734,15 @@</span> <span class="p_context"> int snd_soc_dapm_new_pcm(struct snd_soc_card *card,</span>
 	dev_dbg(card-&gt;dev, &quot;ASoC: adding %s widget\n&quot;, link_name);
 
 	w = snd_soc_dapm_new_control_unlocked(&amp;card-&gt;dapm, &amp;template);
<span class="p_add">+	if (IS_ERR(w)) {</span>
<span class="p_add">+		ret = PTR_ERR(w);</span>
<span class="p_add">+		/* Do not nag about probe deferrals */</span>
<span class="p_add">+		if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+			dev_err(card-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create %s widget (%d)\n&quot;,</span>
<span class="p_add">+				link_name, ret);</span>
<span class="p_add">+		goto outfree_kcontrol_news;</span>
<span class="p_add">+	}</span>
 	if (!w) {
 		dev_err(card-&gt;dev, &quot;ASoC: Failed to create %s widget\n&quot;,
 			link_name);
<span class="p_chunk">@@ -3752,6 +3794,16 @@</span> <span class="p_context"> int snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,</span>
 			template.name);
 
 		w = snd_soc_dapm_new_control_unlocked(dapm, &amp;template);
<span class="p_add">+		if (IS_ERR(w)) {</span>
<span class="p_add">+			int ret = PTR_ERR(w);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Do not nag about probe deferrals */</span>
<span class="p_add">+			if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+				dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create %s widget (%d)\n&quot;,</span>
<span class="p_add">+				dai-&gt;driver-&gt;playback.stream_name, ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 		if (!w) {
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to create %s widget\n&quot;,
 				dai-&gt;driver-&gt;playback.stream_name);
<span class="p_chunk">@@ -3771,6 +3823,16 @@</span> <span class="p_context"> int snd_soc_dapm_new_dai_widgets(struct snd_soc_dapm_context *dapm,</span>
 			template.name);
 
 		w = snd_soc_dapm_new_control_unlocked(dapm, &amp;template);
<span class="p_add">+		if (IS_ERR(w)) {</span>
<span class="p_add">+			int ret = PTR_ERR(w);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* Do not nag about probe deferrals */</span>
<span class="p_add">+			if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+				dev_err(dapm-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: Failed to create %s widget (%d)\n&quot;,</span>
<span class="p_add">+				dai-&gt;driver-&gt;playback.stream_name, ret);</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		}</span>
 		if (!w) {
 			dev_err(dapm-&gt;dev, &quot;ASoC: Failed to create %s widget\n&quot;,
 				dai-&gt;driver-&gt;capture.stream_name);
<span class="p_header">diff --git a/sound/soc/soc-topology.c b/sound/soc/soc-topology.c</span>
<span class="p_header">index 70396d3f6472..e3f34a86413c 100644</span>
<span class="p_header">--- a/sound/soc/soc-topology.c</span>
<span class="p_header">+++ b/sound/soc/soc-topology.c</span>
<span class="p_chunk">@@ -1481,6 +1481,15 @@</span> <span class="p_context"> widget:</span>
 		widget = snd_soc_dapm_new_control(dapm, &amp;template);
 	else
 		widget = snd_soc_dapm_new_control_unlocked(dapm, &amp;template);
<span class="p_add">+	if (IS_ERR(widget)) {</span>
<span class="p_add">+		ret = PTR_ERR(widget);</span>
<span class="p_add">+		/* Do not nag about probe deferrals */</span>
<span class="p_add">+		if (ret != -EPROBE_DEFER)</span>
<span class="p_add">+			dev_err(tplg-&gt;dev,</span>
<span class="p_add">+				&quot;ASoC: failed to create widget %s controls (%d)\n&quot;,</span>
<span class="p_add">+				w-&gt;name, ret);</span>
<span class="p_add">+		goto hdr_err;</span>
<span class="p_add">+	}</span>
 	if (widget == NULL) {
 		dev_err(tplg-&gt;dev, &quot;ASoC: failed to create widget %s controls\n&quot;,
 			w-&gt;name);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



