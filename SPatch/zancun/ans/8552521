
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[15/18] ARM: vf610: PM: initial suspend/resume support - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [15/18] ARM: vf610: PM: initial suspend/resume support</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 10, 2016, 2:16 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1457576219-7971-16-git-send-email-stefan@agner.ch&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/8552521/mbox/"
   >mbox</a>
|
   <a href="/patch/8552521/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/8552521/">/patch/8552521/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 589619F372
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 10 Mar 2016 02:17:44 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id E9CC520125
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 10 Mar 2016 02:17:41 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 545E9200BE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 10 Mar 2016 02:17:39 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934905AbcCJCRd (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 9 Mar 2016 21:17:33 -0500
Received: from mail.kmu-office.ch ([178.209.48.109]:37444 &quot;EHLO
	mail.kmu-office.ch&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S934880AbcCJCRS (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 9 Mar 2016 21:17:18 -0500
Received: from trochilidae.toradex.int
	(75-146-58-181-Washington.hfc.comcastbusiness.net [75.146.58.181])
	by mail.kmu-office.ch (Postfix) with ESMTPSA id F3A975C121C;
	Thu, 10 Mar 2016 03:16:39 +0100 (CET)
From: Stefan Agner &lt;stefan@agner.ch&gt;
To: shawnguo@kernel.org, mturquette@baylibre.com, sboyd@codeaurora.org
Cc: kernel@pengutronix.de, sergeimir@emcraft.com, tglx@linutronix.de,
	jason@lakedaemon.net, marc.zyngier@arm.com, robh+dt@kernel.org,
	pawel.moll@arm.com, mark.rutland@arm.com,
	ijc+devicetree@hellion.org.uk, galak@codeaurora.org,
	devicetree@vger.kernel.org, linux-arm-kernel@lists.infradead.org,
	linux-kernel@vger.kernel.org, linux-clk@vger.kernel.org,
	Stefan Agner &lt;stefan@agner.ch&gt;
Subject: [PATCH 15/18] ARM: vf610: PM: initial suspend/resume support
Date: Wed,  9 Mar 2016 18:16:56 -0800
Message-Id: &lt;1457576219-7971-16-git-send-email-stefan@agner.ch&gt;
X-Mailer: git-send-email 2.7.2
In-Reply-To: &lt;1457576219-7971-1-git-send-email-stefan@agner.ch&gt;
References: &lt;1457576219-7971-1-git-send-email-stefan@agner.ch&gt;
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed; d=agner.ch; s=dkim;
	t=1457576203; bh=nRstpSRD2SKM9aUMs5ByegbNacBBBDORq/fpRiJB9qQ=;
	h=From:To:Cc:Subject:Date:Message-Id:In-Reply-To:References;
	b=MojG1JUqjufLYz0hCEuJZDfu585XuPASz/+Ieznl+kOo31YmEWxyFKOBzIstoa7N9aYlDDOfbC/ONSOaMMch+tMh2YK3ta66rEmu1ovM8iPArzA886pTHHFVmdmtDtpei26DrqJpt2jz/BPKWgsHLhjXlW+QHuA7D0ADqJO06Xk=
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.0 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, RCVD_IN_DNSWL_HI, RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a> - March 10, 2016, 2:16 a.m.</div>
<pre class="content">
Add system suspend and resume support for Vybrid SoC. The standby
sleep state puts the SoC in STOP mode. The SoC can be woken through
an interrupt from GPC (Global Power Controller). The GPC can use any
interrupt as wake-up source. To save power the main PLL1 is bypassed
and uses the 24MHz on-chip oscillator. However, memory clock need to
be at full speed, hence the PLL2 needs to be on to keep the memory
clocked. The mode is completely implemented in C since we can access
the full memory at all times. The mode provides most power saving
while being able to be woken by any IRQ as wake-up source.

The mem sleep state (Suspend-to-RAM) uses Vybrid&#39;s LPSTOP2 mode. This
mode powergates most parts of the SoC expect some peripherials such as
Wake-Up controller (WKPU) or LP RTC. Parts of the internal SRAM is
retained too. The suspend code written in assembly runs from this SRAM.
The code puts the main memory (DDR3) into self-refresh mode and takes
it out of self-refresh mode on resume. Verified with Colibri VF50/VF61
V1.2A.
<span class="signed-off-by">
Signed-off-by: Stefan Agner &lt;stefan@agner.ch&gt;</span>
---
 arch/arm/mach-imx/Makefile        |   3 +
 arch/arm/mach-imx/common.h        |  10 +
 arch/arm/mach-imx/mach-vf610.c    |   8 +
 arch/arm/mach-imx/pm-vf610.c      | 634 ++++++++++++++++++++++++++++++++++++++
 arch/arm/mach-imx/suspend-vf610.S | 437 ++++++++++++++++++++++++++
 drivers/clk/imx/clk-vf610.c       |  17 +
 6 files changed, 1109 insertions(+)
 create mode 100644 arch/arm/mach-imx/pm-vf610.c
 create mode 100644 arch/arm/mach-imx/suspend-vf610.S
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=143191">kbuild test robot</a> - March 10, 2016, 9:19 p.m.</div>
<pre class="content">
Hi Stefan,

[auto build test ERROR on shawnguo/for-next]
[also build test ERROR on v4.5-rc7]
[cannot apply to next-20160310]
[if your patch is applied to the wrong git tree, please drop us a note to help improving the system]

url:    https://github.com/0day-ci/linux/commits/Stefan-Agner/ARM-vf610-Suspend-resume-with-self-refresh-mode/20160310-102621
base:   https://git.kernel.org/pub/scm/linux/kernel/git/shawnguo/linux.git for-next
config: arm-vf610m4_defconfig (attached as .config)
reproduce:
        wget https://git.kernel.org/cgit/linux/kernel/git/wfg/lkp-tests.git/plain/sbin/make.cross -O ~/bin/make.cross
        chmod +x ~/bin/make.cross
        # save the attached .config to linux build tree
        make.cross ARCH=arm 

All errors (new ones prefixed by &gt;&gt;):

   arch/arm/mach-imx/pm-vf610.c: In function &#39;vf610_suspend_finish&#39;:
<span class="quote">&gt;&gt; arch/arm/mach-imx/pm-vf610.c:348:3: error: implicit declaration of function &#39;local_flush_tlb_all&#39; [-Werror=implicit-function-declaration]</span>
      local_flush_tlb_all();
      ^
   cc1: some warnings being treated as errors

vim +/local_flush_tlb_all +348 arch/arm/mach-imx/pm-vf610.c

   342			cpu_do_idle();
   343		} else {
   344			/*
   345			 * call low level suspend function in ocram,
   346			 * as we need to float DDR IO.
   347			 */
<span class="quote"> &gt; 348			local_flush_tlb_all();</span>
   349			flush_cache_all();
   350			outer_flush_all();
   351			vf610_suspend_in_ocram_fn(suspend_ocram_base);

---
0-DAY kernel test infrastructure                Open Source Technology Center
https://lists.01.org/pipermail/kbuild-all                   Intel Corporation
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131511">Shawn Guo</a> - April 1, 2016, 2:25 a.m.</div>
<pre class="content">
On Wed, Mar 09, 2016 at 06:16:56PM -0800, Stefan Agner wrote:
<span class="quote">&gt; Add system suspend and resume support for Vybrid SoC. The standby</span>
<span class="quote">&gt; sleep state puts the SoC in STOP mode. The SoC can be woken through</span>
<span class="quote">&gt; an interrupt from GPC (Global Power Controller). The GPC can use any</span>
<span class="quote">&gt; interrupt as wake-up source. To save power the main PLL1 is bypassed</span>
<span class="quote">&gt; and uses the 24MHz on-chip oscillator. However, memory clock need to</span>
<span class="quote">&gt; be at full speed, hence the PLL2 needs to be on to keep the memory</span>
<span class="quote">&gt; clocked. The mode is completely implemented in C since we can access</span>
<span class="quote">&gt; the full memory at all times. The mode provides most power saving</span>
<span class="quote">&gt; while being able to be woken by any IRQ as wake-up source.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The mem sleep state (Suspend-to-RAM) uses Vybrid&#39;s LPSTOP2 mode. This</span>
<span class="quote">&gt; mode powergates most parts of the SoC expect some peripherials such as</span>
<span class="quote">&gt; Wake-Up controller (WKPU) or LP RTC. Parts of the internal SRAM is</span>
<span class="quote">&gt; retained too. The suspend code written in assembly runs from this SRAM.</span>
<span class="quote">&gt; The code puts the main memory (DDR3) into self-refresh mode and takes</span>
<span class="quote">&gt; it out of self-refresh mode on resume. Verified with Colibri VF50/VF61</span>
<span class="quote">&gt; V1.2A.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Stefan Agner &lt;stefan@agner.ch&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/arm/mach-imx/Makefile        |   3 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/common.h        |  10 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/mach-vf610.c    |   8 +</span>
<span class="quote">&gt;  arch/arm/mach-imx/pm-vf610.c      | 634 ++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/arm/mach-imx/suspend-vf610.S | 437 ++++++++++++++++++++++++++</span>
<span class="quote">&gt;  drivers/clk/imx/clk-vf610.c       |  17 +</span>
<span class="quote">&gt;  6 files changed, 1109 insertions(+)</span>
<span class="quote">&gt;  create mode 100644 arch/arm/mach-imx/pm-vf610.c</span>
<span class="quote">&gt;  create mode 100644 arch/arm/mach-imx/suspend-vf610.S</span>

I know this is how we implemented suspend for i.MX6.  But this is not
the direction moving forward.  When people was pushing a pile of code
adding suspend for i.MX7D, I refused to take it and asked them to push
those hardware details into firmware and use PSCI to implement suspend.
I would like to suggest the same for Vybrid.

Shawn
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=71861">Stefan Agner</a> - April 1, 2016, 6:40 a.m.</div>
<pre class="content">
On 2016-03-31 19:25, Shawn Guo wrote:
<span class="quote">&gt; On Wed, Mar 09, 2016 at 06:16:56PM -0800, Stefan Agner wrote:</span>
<span class="quote">&gt;&gt; Add system suspend and resume support for Vybrid SoC. The standby</span>
<span class="quote">&gt;&gt; sleep state puts the SoC in STOP mode. The SoC can be woken through</span>
<span class="quote">&gt;&gt; an interrupt from GPC (Global Power Controller). The GPC can use any</span>
<span class="quote">&gt;&gt; interrupt as wake-up source. To save power the main PLL1 is bypassed</span>
<span class="quote">&gt;&gt; and uses the 24MHz on-chip oscillator. However, memory clock need to</span>
<span class="quote">&gt;&gt; be at full speed, hence the PLL2 needs to be on to keep the memory</span>
<span class="quote">&gt;&gt; clocked. The mode is completely implemented in C since we can access</span>
<span class="quote">&gt;&gt; the full memory at all times. The mode provides most power saving</span>
<span class="quote">&gt;&gt; while being able to be woken by any IRQ as wake-up source.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The mem sleep state (Suspend-to-RAM) uses Vybrid&#39;s LPSTOP2 mode. This</span>
<span class="quote">&gt;&gt; mode powergates most parts of the SoC expect some peripherials such as</span>
<span class="quote">&gt;&gt; Wake-Up controller (WKPU) or LP RTC. Parts of the internal SRAM is</span>
<span class="quote">&gt;&gt; retained too. The suspend code written in assembly runs from this SRAM.</span>
<span class="quote">&gt;&gt; The code puts the main memory (DDR3) into self-refresh mode and takes</span>
<span class="quote">&gt;&gt; it out of self-refresh mode on resume. Verified with Colibri VF50/VF61</span>
<span class="quote">&gt;&gt; V1.2A.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Stefan Agner &lt;stefan@agner.ch&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;  arch/arm/mach-imx/Makefile        |   3 +</span>
<span class="quote">&gt;&gt;  arch/arm/mach-imx/common.h        |  10 +</span>
<span class="quote">&gt;&gt;  arch/arm/mach-imx/mach-vf610.c    |   8 +</span>
<span class="quote">&gt;&gt;  arch/arm/mach-imx/pm-vf610.c      | 634 ++++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  arch/arm/mach-imx/suspend-vf610.S | 437 ++++++++++++++++++++++++++</span>
<span class="quote">&gt;&gt;  drivers/clk/imx/clk-vf610.c       |  17 +</span>
<span class="quote">&gt;&gt;  6 files changed, 1109 insertions(+)</span>
<span class="quote">&gt;&gt;  create mode 100644 arch/arm/mach-imx/pm-vf610.c</span>
<span class="quote">&gt;&gt;  create mode 100644 arch/arm/mach-imx/suspend-vf610.S</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I know this is how we implemented suspend for i.MX6.  But this is not</span>
<span class="quote">&gt; the direction moving forward.  When people was pushing a pile of code</span>
<span class="quote">&gt; adding suspend for i.MX7D, I refused to take it and asked them to push</span>
<span class="quote">&gt; those hardware details into firmware and use PSCI to implement suspend.</span>
<span class="quote">&gt; I would like to suggest the same for Vybrid.</span>

Yeah I saw your comment on the i.MX7D patchset, and kind of hoped it
does not apply for Vybrid :-)

I see, need to look into PSCI closer, and see how much work it would be
to set that up and transfer the code into it...

--
Stefan
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/arm/mach-imx/Makefile b/arch/arm/mach-imx/Makefile</span>
<span class="p_header">index 9fbe624..ea2e8bd 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/Makefile</span>
<span class="p_header">+++ b/arch/arm/mach-imx/Makefile</span>
<span class="p_chunk">@@ -90,8 +90,11 @@</span> <span class="p_context"> ifeq ($(CONFIG_SUSPEND),y)</span>
 AFLAGS_suspend-imx6.o :=-Wa,-march=armv7-a
 obj-$(CONFIG_SOC_IMX6) += suspend-imx6.o
 obj-$(CONFIG_SOC_IMX53) += suspend-imx53.o
<span class="p_add">+AFLAGS_suspend-vf610.o :=-Wa,-march=armv7-a</span>
<span class="p_add">+obj-$(CONFIG_SOC_VF610) += suspend-vf610.o</span>
 endif
 obj-$(CONFIG_SOC_IMX6) += pm-imx6.o
<span class="p_add">+obj-$(CONFIG_SOC_VF610) += pm-vf610.o</span>
 
 obj-$(CONFIG_SOC_IMX50) += mach-imx50.o
 obj-$(CONFIG_SOC_IMX51) += mach-imx51.o
<span class="p_header">diff --git a/arch/arm/mach-imx/common.h b/arch/arm/mach-imx/common.h</span>
<span class="p_header">index 58a3846..737b1e4 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/common.h</span>
<span class="p_header">+++ b/arch/arm/mach-imx/common.h</span>
<span class="p_chunk">@@ -76,6 +76,13 @@</span> <span class="p_context"> enum mxc_cpu_pwr_mode {</span>
 	STOP_POWER_OFF,		/* STOP + SRPG */
 };
 
<span class="p_add">+enum vf610_cpu_pwr_mode {</span>
<span class="p_add">+	VF610_RUN,</span>
<span class="p_add">+	VF610_LP_RUN,</span>
<span class="p_add">+	VF610_STOP,</span>
<span class="p_add">+	VF610_LP_STOP,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 enum mx3_cpu_pwr_mode {
 	MX3_RUN,
 	MX3_WAIT,
<span class="p_chunk">@@ -120,11 +127,13 @@</span> <span class="p_context"> void v7_cpu_resume(void);</span>
 void imx53_suspend(void __iomem *ocram_vbase);
 extern const u32 imx53_suspend_sz;
 void imx6_suspend(void __iomem *ocram_vbase);
<span class="p_add">+void vf610_suspend(void __iomem *ocram_vbase);</span>
 #else
 static inline void v7_cpu_resume(void) {}
 static inline void imx53_suspend(void __iomem *ocram_vbase) {}
 static const u32 imx53_suspend_sz;
 static inline void imx6_suspend(void __iomem *ocram_vbase) {}
<span class="p_add">+static inline void vf610_suspend(void __iomem *ocram_vbase) {}</span>
 #endif
 
 void imx6_pm_ccm_init(const char *ccm_compat);
<span class="p_chunk">@@ -133,6 +142,7 @@</span> <span class="p_context"> void imx6dl_pm_init(void);</span>
 void imx6sl_pm_init(void);
 void imx6sx_pm_init(void);
 void imx6ul_pm_init(void);
<span class="p_add">+void vf610_pm_init(void);</span>
 
 #ifdef CONFIG_PM
 void imx51_pm_init(void);
<span class="p_header">diff --git a/arch/arm/mach-imx/mach-vf610.c b/arch/arm/mach-imx/mach-vf610.c</span>
<span class="p_header">index b20f6c1..5ba668f 100644</span>
<span class="p_header">--- a/arch/arm/mach-imx/mach-vf610.c</span>
<span class="p_header">+++ b/arch/arm/mach-imx/mach-vf610.c</span>
<span class="p_chunk">@@ -11,6 +11,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/irqchip.h&gt;
 #include &lt;asm/mach/arch.h&gt;
 #include &lt;asm/hardware/cache-l2x0.h&gt;
<span class="p_add">+#include &quot;common.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init vf610_init_machine(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	of_platform_populate(NULL, of_default_bus_match_table, NULL, NULL);</span>
<span class="p_add">+	vf610_pm_init();</span>
<span class="p_add">+}</span>
 
 static const char * const vf610_dt_compat[] __initconst = {
 	&quot;fsl,vf500&quot;,
<span class="p_chunk">@@ -24,5 +31,6 @@</span> <span class="p_context"> static const char * const vf610_dt_compat[] __initconst = {</span>
 DT_MACHINE_START(VYBRID_VF610, &quot;Freescale Vybrid VF5xx/VF6xx (Device Tree)&quot;)
 	.l2c_aux_val	= 0,
 	.l2c_aux_mask	= ~0,
<span class="p_add">+	.init_machine	= vf610_init_machine,</span>
 	.dt_compat	= vf610_dt_compat,
 MACHINE_END
<span class="p_header">diff --git a/arch/arm/mach-imx/pm-vf610.c b/arch/arm/mach-imx/pm-vf610.c</span>
new file mode 100644
<span class="p_header">index 0000000..ecc7c9c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/pm-vf610.c</span>
<span class="p_chunk">@@ -0,0 +1,634 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright 2012 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ * Copyright 2016 Toradex AG</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The code contained herein is licensed under the GNU General Public</span>
<span class="p_add">+ * License. You may obtain a copy of the GNU General Public License</span>
<span class="p_add">+ * Version 2 or later at the following locations:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * http://www.opensource.org/licenses/gpl-license.html</span>
<span class="p_add">+ * http://www.gnu.org/copyleft/gpl.html</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+#define pr_pmdebug(fmt, ...) pr_info(&quot;PM: VF610: &quot; fmt &quot;\n&quot;, ##__VA_ARGS__)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define pr_pmdebug(fmt, ...)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
<span class="p_add">+#include &lt;linux/init.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/genalloc.h&gt;</span>
<span class="p_add">+#include &lt;linux/mfd/syscon.h&gt;</span>
<span class="p_add">+#include &lt;linux/mfd/syscon/imx6q-iomuxc-gpr.h&gt;</span>
<span class="p_add">+#include &lt;linux/of.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_address.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_platform.h&gt;</span>
<span class="p_add">+#include &lt;linux/regmap.h&gt;</span>
<span class="p_add">+#include &lt;linux/suspend.h&gt;</span>
<span class="p_add">+#include &lt;linux/clk.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/fncpy.h&gt;</span>
<span class="p_add">+#include &lt;asm/proc-fns.h&gt;</span>
<span class="p_add">+#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlb.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;common.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DDRMC_PHY_OFFSET		0x400</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCR				0x0</span>
<span class="p_add">+#define BM_CCR_FIRC_EN			(0x1 &lt;&lt; 16)</span>
<span class="p_add">+#define BM_CCR_FXOSC_EN			(0x1 &lt;&lt; 12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CCSR				0x8</span>
<span class="p_add">+#define BM_CCSR_DDRC_CLK_SEL		(0x1 &lt;&lt; 6)</span>
<span class="p_add">+#define BM_CCSR_FAST_CLK_SEL		(0x1 &lt;&lt; 5)</span>
<span class="p_add">+#define BM_CCSR_SLOW_CLK_SEL		(0x1 &lt;&lt; 4)</span>
<span class="p_add">+#define BM_CCSR_SYS_CLK_SEL_MASK	(0x7 &lt;&lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CACRR				0xc</span>
<span class="p_add">+</span>
<span class="p_add">+#define CLPCR				0x2c</span>
<span class="p_add">+#define BM_CLPCR_ARM_CLK_DIS_ON_LPM	(0x1 &lt;&lt; 5)</span>
<span class="p_add">+#define BM_CLPCR_SBYOS			(0x1 &lt;&lt; 6)</span>
<span class="p_add">+#define BM_CLPCR_DIS_REF_OSC		(0x1 &lt;&lt; 7)</span>
<span class="p_add">+#define BM_CLPCR_ANADIG_STOP_MODE	(0x1 &lt;&lt; 8)</span>
<span class="p_add">+#define BM_CLPCR_FXOSC_BYPSEN		(0x1 &lt;&lt; 10)</span>
<span class="p_add">+#define BM_CLPCR_FXOSC_PWRDWN		(0x1 &lt;&lt; 11)</span>
<span class="p_add">+#define BM_CLPCR_MASK_CORE0_WFI		(0x1 &lt;&lt; 22)</span>
<span class="p_add">+#define BM_CLPCR_MASK_CORE1_WFI		(0x1 &lt;&lt; 23)</span>
<span class="p_add">+#define BM_CLPCR_MASK_SCU_IDLE		(0x1 &lt;&lt; 24)</span>
<span class="p_add">+#define BM_CLPCR_MASK_L2CC_IDLE		(0x1 &lt;&lt; 25)</span>
<span class="p_add">+</span>
<span class="p_add">+#define CGPR				0x64</span>
<span class="p_add">+#define BM_CGPR_INT_MEM_CLK_LPM		(0x1 &lt;&lt; 17)</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_PGCR			0x0</span>
<span class="p_add">+#define BM_PGCR_DS_STOP			(0x1 &lt;&lt; 7)</span>
<span class="p_add">+#define BM_PGCR_DS_LPSTOP		(0x1 &lt;&lt; 6)</span>
<span class="p_add">+#define BM_PGCR_WB_STOP			(0x1 &lt;&lt; 4)</span>
<span class="p_add">+#define BM_PGCR_HP_OFF			(0x1 &lt;&lt; 3)</span>
<span class="p_add">+#define BM_PGCR_PG_PD1			(0x1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define GPC_LPMR			0x40</span>
<span class="p_add">+#define BM_LPMR_RUN			0x0</span>
<span class="p_add">+#define BM_LPMR_STOP			0x2</span>
<span class="p_add">+</span>
<span class="p_add">+#define ANATOP_PLL1_CTRL		0x270</span>
<span class="p_add">+#define ANATOP_PLL2_CTRL		0x30</span>
<span class="p_add">+#define ANATOP_PLL2_PFD			0x100</span>
<span class="p_add">+#define BM_PLL_POWERDOWN	(0x1 &lt;&lt; 12)</span>
<span class="p_add">+#define BM_PLL_ENABLE		(0x1 &lt;&lt; 13)</span>
<span class="p_add">+#define BM_PLL_BYPASS		(0x1 &lt;&lt; 16)</span>
<span class="p_add">+#define BM_PLL_LOCK		(0x1 &lt;&lt; 31)</span>
<span class="p_add">+#define BM_PLL_PFD2_CLKGATE	(0x1 &lt;&lt; 15)</span>
<span class="p_add">+#define BM_PLL_USB_POWER	(0x1 &lt;&lt; 12)</span>
<span class="p_add">+#define BM_PLL_EN_USB_CLKS	(0x1 &lt;&lt; 6)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_DDRMC_IO_NUM		94</span>
<span class="p_add">+#define VF610_IOMUX_DDR_IO_NUM		48</span>
<span class="p_add">+#define VF610_ANATOP_IO_NUM		2</span>
<span class="p_add">+</span>
<span class="p_add">+static void __iomem *suspend_ocram_base;</span>
<span class="p_add">+static void (*vf610_suspend_in_ocram_fn)(void __iomem *ocram_vbase);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+static void __iomem *uart_membase;</span>
<span class="p_add">+static unsigned long uart_clk;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 vf610_iomuxc_ddr_io_offset[] __initconst = {</span>
<span class="p_add">+	0x220, 0x224, 0x228, 0x22c, 0x230, 0x234, 0x238, 0x23c,</span>
<span class="p_add">+	0x240, 0x244, 0x248, 0x24c, 0x250, 0x254, 0x258, 0x25c,</span>
<span class="p_add">+	0x260, 0x264, 0x268, 0x26c, 0x270, 0x274, 0x278, 0x27c,</span>
<span class="p_add">+	0x280, 0x284, 0x288, 0x28c, 0x290, 0x294, 0x298, 0x29c,</span>
<span class="p_add">+	0x2a0, 0x2a4, 0x2a8, 0x2ac, 0x2b0, 0x2b4, 0x2b8, 0x2bc,</span>
<span class="p_add">+	0x2c0, 0x2c4, 0x2c8, 0x2cc, 0x2d0, 0x2d4, 0x2d8, 0x21c,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 vf610_ddrmc_io_offset[] __initconst = {</span>
<span class="p_add">+	0x00, 0x08, 0x28, 0x2c, 0x30, 0x34, 0x38,</span>
<span class="p_add">+	0x40, 0x44, 0x48, 0x50, 0x54, 0x58, 0x5c,</span>
<span class="p_add">+	0x60, 0x64, 0x68, 0x70, 0x74, 0x78, 0x7c,</span>
<span class="p_add">+	0x84, 0x88, 0x98, 0x9c, 0xa4, 0xc0,</span>
<span class="p_add">+	0x108, 0x10c, 0x114, 0x118, 0x120, 0x124,</span>
<span class="p_add">+	0x128, 0x12c, 0x130, 0x134, 0x138, 0x13c,</span>
<span class="p_add">+	0x148, 0x15c, 0x160, 0x164, 0x16c, 0x180,</span>
<span class="p_add">+	0x184, 0x188, 0x18c, 0x198, 0x1a4, 0x1a8,</span>
<span class="p_add">+	0x1b8, 0x1d4, 0x1d8, 0x1e0, 0x1e4, 0x1e8,</span>
<span class="p_add">+	0x1ec, 0x1f0, 0x1f8, 0x210, 0x224, 0x228,</span>
<span class="p_add">+	0x22c, 0x230, 0x23c, 0x240, 0x244, 0x248,</span>
<span class="p_add">+	0x24c, 0x250, 0x25c, 0x268, 0x26c, 0x278,</span>
<span class="p_add">+	0x268</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const u32 vf610_ddrmc_phy_io_offset[] __initconst = {</span>
<span class="p_add">+	0x00, 0x04, 0x08, 0x0c, 0x10,</span>
<span class="p_add">+	0x40, 0x44, 0x48, 0x4c, 0x50,</span>
<span class="p_add">+	0x80, 0x84, 0x88, 0x8c, 0x90,</span>
<span class="p_add">+	0xc4, 0xc8, 0xd0</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * suspend ocram space layout:</span>
<span class="p_add">+ * ======================== high address ======================</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                      vf610_suspend code</span>
<span class="p_add">+ *              PM_INFO structure(vf610_cpu_pm_info)</span>
<span class="p_add">+ * ======================== low address =======================</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+struct vf610_pm_base {</span>
<span class="p_add">+	phys_addr_t pbase;</span>
<span class="p_add">+	void __iomem *vbase;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct vf610_pm_socdata {</span>
<span class="p_add">+	const char *anatop_compat;</span>
<span class="p_add">+	const char *scsc_compat;</span>
<span class="p_add">+	const char *wkpu_compat;</span>
<span class="p_add">+	const char *ccm_compat;</span>
<span class="p_add">+	const char *gpc_compat;</span>
<span class="p_add">+	const char *src_compat;</span>
<span class="p_add">+	const char *ddrmc_compat;</span>
<span class="p_add">+	const char *iomuxc_compat;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct vf610_pm_socdata vf610_pm_data __initconst = {</span>
<span class="p_add">+	.anatop_compat = &quot;fsl,vf610-anatop&quot;,</span>
<span class="p_add">+	.scsc_compat = &quot;fsl,vf610-scsc&quot;,</span>
<span class="p_add">+	.wkpu_compat = &quot;fsl,vf610-wkpu&quot;,</span>
<span class="p_add">+	.ccm_compat = &quot;fsl,vf610-ccm&quot;,</span>
<span class="p_add">+	.gpc_compat = &quot;fsl,vf610-gpc&quot;,</span>
<span class="p_add">+	.src_compat = &quot;fsl,vf610-src&quot;,</span>
<span class="p_add">+	.ddrmc_compat = &quot;fsl,vf610-ddrmc&quot;,</span>
<span class="p_add">+	.iomuxc_compat = &quot;fsl,vf610-iomuxc&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This structure is for passing necessary data for low level ocram</span>
<span class="p_add">+ * suspend code(arch/arm/mach-imx/suspend-vf610.S), if this struct</span>
<span class="p_add">+ * definition is changed, the offset definition in</span>
<span class="p_add">+ * arch/arm/mach-imx/suspend-vf610.S must be also changed accordingly,</span>
<span class="p_add">+ * otherwise, the suspend to ocram function will be broken!</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct vf610_cpu_pm_info {</span>
<span class="p_add">+	phys_addr_t pbase; /* The physical address of pm_info. */</span>
<span class="p_add">+	phys_addr_t resume_addr; /* The physical resume address for asm code */</span>
<span class="p_add">+	u32 cpu_type; /* Currently not used, leave it for alignment */</span>
<span class="p_add">+	u32 pm_info_size; /* Size of pm_info. */</span>
<span class="p_add">+	struct vf610_pm_base anatop_base;</span>
<span class="p_add">+	struct vf610_pm_base scsc_base;</span>
<span class="p_add">+	struct vf610_pm_base wkpu_base;</span>
<span class="p_add">+	struct vf610_pm_base ccm_base;</span>
<span class="p_add">+	struct vf610_pm_base gpc_base;</span>
<span class="p_add">+	struct vf610_pm_base src_base;</span>
<span class="p_add">+	struct vf610_pm_base ddrmc_base;</span>
<span class="p_add">+	struct vf610_pm_base iomuxc_base;</span>
<span class="p_add">+	struct vf610_pm_base l2_base;</span>
<span class="p_add">+	u32 ccm_cacrr;</span>
<span class="p_add">+	u32 ccm_ccsr;</span>
<span class="p_add">+	u32 ddrmc_io_num; /* Number of MMDC IOs which need saved/restored. */</span>
<span class="p_add">+	u32 ddrmc_io_val[VF610_DDRMC_IO_NUM][2]; /* To save offset and value */</span>
<span class="p_add">+	u32 iomux_ddr_io_num;</span>
<span class="p_add">+	u32 iomux_ddr_io_val[VF610_IOMUX_DDR_IO_NUM][2];</span>
<span class="p_add">+} __aligned(8);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+static void vf610_uart_reinit(unsigned long int rate, unsigned long int baud)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 tmp, c2;</span>
<span class="p_add">+	u16 sbr, brfa;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* UART_C2 */</span>
<span class="p_add">+	c2 = __raw_readb(uart_membase + 0x3);</span>
<span class="p_add">+	__raw_writeb(0, uart_membase + 0x3);</span>
<span class="p_add">+</span>
<span class="p_add">+	sbr = (u16) (rate / (baud * 16));</span>
<span class="p_add">+	brfa = (rate / baud) - (sbr * 16);</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = ((sbr &amp; 0x1f00) &gt;&gt; 8);</span>
<span class="p_add">+	__raw_writeb(tmp, uart_membase + 0x0);</span>
<span class="p_add">+	tmp = sbr &amp; 0x00ff;</span>
<span class="p_add">+	__raw_writeb(tmp, uart_membase + 0x1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* UART_C4 */</span>
<span class="p_add">+	__raw_writeb(brfa &amp; 0xf, uart_membase + 0xa);</span>
<span class="p_add">+</span>
<span class="p_add">+	__raw_writeb(c2, uart_membase + 0x3);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define vf610_uart_reinit(rate, baud)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static void vf610_set(void __iomem *pll_base, u32 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	writel(readl(pll_base) | mask, pll_base);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void vf610_clr(void __iomem *pll_base, u32 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	writel(readl(pll_base) &amp; ~mask, pll_base);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int vf610_set_lpm(enum vf610_cpu_pwr_mode mode)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vf610_cpu_pm_info *pm_info = suspend_ocram_base;</span>
<span class="p_add">+	void __iomem *ccm_base = pm_info-&gt;ccm_base.vbase;</span>
<span class="p_add">+	void __iomem *gpc_base = pm_info-&gt;gpc_base.vbase;</span>
<span class="p_add">+	void __iomem *anatop = pm_info-&gt;anatop_base.vbase;</span>
<span class="p_add">+	u32 ccr = readl_relaxed(ccm_base + CCR);</span>
<span class="p_add">+	u32 ccsr = readl_relaxed(ccm_base + CCSR);</span>
<span class="p_add">+	u32 cacrr = readl_relaxed(ccm_base + CACRR);</span>
<span class="p_add">+	u32 cclpcr = 0;</span>
<span class="p_add">+	u32 gpc_pgcr = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (mode) {</span>
<span class="p_add">+	case VF610_LP_STOP:</span>
<span class="p_add">+		/* Store clock settings */</span>
<span class="p_add">+		pm_info-&gt;ccm_ccsr = ccsr;</span>
<span class="p_add">+		pm_info-&gt;ccm_cacrr = cacrr;</span>
<span class="p_add">+</span>
<span class="p_add">+		ccr |= BM_CCR_FIRC_EN;</span>
<span class="p_add">+		writel_relaxed(ccr, ccm_base + CCR);</span>
<span class="p_add">+</span>
<span class="p_add">+		cclpcr |= BM_CLPCR_ANADIG_STOP_MODE;</span>
<span class="p_add">+		cclpcr |= BM_CLPCR_SBYOS;</span>
<span class="p_add">+</span>
<span class="p_add">+		cclpcr |= BM_CLPCR_MASK_SCU_IDLE;</span>
<span class="p_add">+		cclpcr |= BM_CLPCR_MASK_L2CC_IDLE;</span>
<span class="p_add">+		cclpcr |= BM_CLPCR_MASK_CORE1_WFI;</span>
<span class="p_add">+		writel_relaxed(cclpcr, ccm_base + CLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+		gpc_pgcr |= BM_PGCR_DS_STOP;</span>
<span class="p_add">+		gpc_pgcr |= BM_PGCR_DS_LPSTOP;</span>
<span class="p_add">+		gpc_pgcr |= BM_PGCR_WB_STOP;</span>
<span class="p_add">+		gpc_pgcr |= BM_PGCR_HP_OFF;</span>
<span class="p_add">+		gpc_pgcr |= BM_PGCR_PG_PD1;</span>
<span class="p_add">+		writel_relaxed(gpc_pgcr, gpc_base + GPC_PGCR);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case VF610_STOP:</span>
<span class="p_add">+		cclpcr &amp;= ~BM_CLPCR_ANADIG_STOP_MODE;</span>
<span class="p_add">+		cclpcr |= BM_CLPCR_ARM_CLK_DIS_ON_LPM;</span>
<span class="p_add">+		cclpcr |= BM_CLPCR_SBYOS;</span>
<span class="p_add">+		writel_relaxed(cclpcr, ccm_base + CLPCR);</span>
<span class="p_add">+</span>
<span class="p_add">+		gpc_pgcr |= BM_PGCR_DS_STOP;</span>
<span class="p_add">+		gpc_pgcr |= BM_PGCR_HP_OFF;</span>
<span class="p_add">+		writel_relaxed(gpc_pgcr, gpc_base + GPC_PGCR);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* fall-through */</span>
<span class="p_add">+	case VF610_LP_RUN:</span>
<span class="p_add">+		/* Store clock settings */</span>
<span class="p_add">+		pm_info-&gt;ccm_ccsr = ccsr;</span>
<span class="p_add">+		pm_info-&gt;ccm_cacrr = cacrr;</span>
<span class="p_add">+</span>
<span class="p_add">+		ccr |= BM_CCR_FIRC_EN;</span>
<span class="p_add">+		writel_relaxed(ccr, ccm_base + CCR);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Enable PLL2 for DDR clock */</span>
<span class="p_add">+		vf610_set(anatop + ANATOP_PLL2_CTRL, BM_PLL_ENABLE);</span>
<span class="p_add">+		vf610_clr(anatop + ANATOP_PLL2_CTRL, BM_PLL_POWERDOWN);</span>
<span class="p_add">+		vf610_clr(anatop + ANATOP_PLL2_CTRL, BM_PLL_BYPASS);</span>
<span class="p_add">+		while (!(readl(anatop + ANATOP_PLL2_CTRL) &amp; BM_PLL_LOCK));</span>
<span class="p_add">+		vf610_clr(anatop + ANATOP_PLL2_PFD, BM_PLL_PFD2_CLKGATE);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Switch internal OSC&#39;s */</span>
<span class="p_add">+		ccsr &amp;= ~BM_CCSR_FAST_CLK_SEL;</span>
<span class="p_add">+		ccsr &amp;= ~BM_CCSR_SLOW_CLK_SEL;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Select PLL2 as DDR clock */</span>
<span class="p_add">+		ccsr &amp;= ~BM_CCSR_DDRC_CLK_SEL;</span>
<span class="p_add">+		writel_relaxed(ccsr, ccm_base + CCSR);</span>
<span class="p_add">+</span>
<span class="p_add">+		ccsr &amp;= ~BM_CCSR_SYS_CLK_SEL_MASK;</span>
<span class="p_add">+		writel_relaxed(ccsr, ccm_base + CCSR);</span>
<span class="p_add">+		vf610_uart_reinit(4000000UL, 115200);</span>
<span class="p_add">+</span>
<span class="p_add">+		vf610_set(anatop + ANATOP_PLL1_CTRL, BM_PLL_BYPASS);</span>
<span class="p_add">+		writel_relaxed(BM_LPMR_STOP, gpc_base + GPC_LPMR);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case VF610_RUN:</span>
<span class="p_add">+		writel_relaxed(BM_LPMR_RUN, gpc_base + GPC_LPMR);</span>
<span class="p_add">+</span>
<span class="p_add">+		vf610_clr(anatop + ANATOP_PLL1_CTRL, BM_PLL_BYPASS);</span>
<span class="p_add">+		while (!(readl(anatop + ANATOP_PLL1_CTRL) &amp; BM_PLL_LOCK));</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Restore clock settings */</span>
<span class="p_add">+		writel(pm_info-&gt;ccm_ccsr, ccm_base + CCSR);</span>
<span class="p_add">+</span>
<span class="p_add">+		vf610_uart_reinit(uart_clk, 115200);</span>
<span class="p_add">+		pr_pmdebug(&quot;resuming, uart_reinit done&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int vf610_suspend_finish(unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!vf610_suspend_in_ocram_fn) {</span>
<span class="p_add">+		cpu_do_idle();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * call low level suspend function in ocram,</span>
<span class="p_add">+		 * as we need to float DDR IO.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		local_flush_tlb_all();</span>
<span class="p_add">+		flush_cache_all();</span>
<span class="p_add">+		outer_flush_all();</span>
<span class="p_add">+		vf610_suspend_in_ocram_fn(suspend_ocram_base);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int vf610_pm_enter(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (state) {</span>
<span class="p_add">+	case PM_SUSPEND_STANDBY:</span>
<span class="p_add">+		vf610_set_lpm(VF610_STOP);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* zzZZZzzz */</span>
<span class="p_add">+		cpu_do_idle();</span>
<span class="p_add">+</span>
<span class="p_add">+		vf610_set_lpm(VF610_RUN);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PM_SUSPEND_MEM:</span>
<span class="p_add">+		vf610_set_lpm(VF610_LP_STOP);</span>
<span class="p_add">+</span>
<span class="p_add">+		cpu_suspend(0, vf610_suspend_finish);</span>
<span class="p_add">+		outer_resume();</span>
<span class="p_add">+</span>
<span class="p_add">+		vf610_set_lpm(VF610_RUN);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int vf610_pm_valid(suspend_state_t state)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (state == PM_SUSPEND_STANDBY || state == PM_SUSPEND_MEM);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static const struct platform_suspend_ops vf610_pm_ops = {</span>
<span class="p_add">+	.enter = vf610_pm_enter,</span>
<span class="p_add">+	.valid = vf610_pm_valid,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init imx_pm_get_base(struct vf610_pm_base *base,</span>
<span class="p_add">+				const char *compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct resource res;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, compat);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = of_address_to_resource(node, 0, &amp;res);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	base-&gt;pbase = res.start;</span>
<span class="p_add">+	base-&gt;vbase = ioremap(res.start, resource_size(&amp;res));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!base-&gt;vbase)</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+static int __init vf610_uart_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *dn;</span>
<span class="p_add">+	const char *name;</span>
<span class="p_add">+	struct clk *clk;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	name = of_get_property(of_chosen, &quot;stdout-path&quot;, NULL);</span>
<span class="p_add">+	if (name == NULL)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	dn = of_find_node_by_path(name);</span>
<span class="p_add">+	if (!dn)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	clk = of_clk_get(dn, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!clk) {</span>
<span class="p_add">+		ret = PTR_ERR(clk);</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	uart_clk = clk_get_rate(clk);</span>
<span class="p_add">+</span>
<span class="p_add">+	uart_membase = of_iomap(dn, 0);</span>
<span class="p_add">+	if (!clk) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(dn);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init vf610_suspend_init(const struct vf610_pm_socdata *socdata)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t ocram_pbase;</span>
<span class="p_add">+	struct device_node *node;</span>
<span class="p_add">+	struct platform_device *pdev;</span>
<span class="p_add">+	struct vf610_cpu_pm_info *pm_info;</span>
<span class="p_add">+	struct gen_pool *ocram_pool;</span>
<span class="p_add">+	size_t ocram_size;</span>
<span class="p_add">+	unsigned long ocram_base;</span>
<span class="p_add">+	int ret = 0, reg = 0;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+	ret = vf610_uart_init();</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	suspend_set_ops(&amp;vf610_pm_ops);</span>
<span class="p_add">+</span>
<span class="p_add">+	node = of_find_compatible_node(NULL, NULL, &quot;mmio-sram&quot;);</span>
<span class="p_add">+	if (!node) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to find ocram node!\n&quot;, __func__);</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pdev = of_find_device_by_node(node);</span>
<span class="p_add">+	if (!pdev) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to find ocram device!\n&quot;, __func__);</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ocram_pool = gen_pool_get(&amp;pdev-&gt;dev, &quot;stbyram1&quot;);</span>
<span class="p_add">+	if (!ocram_pool) {</span>
<span class="p_add">+		pr_warn(&quot;%s: ocram pool unavailable!\n&quot;, __func__);</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ocram_size = gen_pool_size(ocram_pool);</span>
<span class="p_add">+	ocram_base = gen_pool_alloc(ocram_pool, ocram_size);</span>
<span class="p_add">+	if (!ocram_base) {</span>
<span class="p_add">+		pr_warn(&quot;%s: unable to alloc ocram!\n&quot;, __func__);</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ocram_pbase = gen_pool_virt_to_phys(ocram_pool, ocram_base);</span>
<span class="p_add">+</span>
<span class="p_add">+	suspend_ocram_base = __arm_ioremap_exec(ocram_pbase, ocram_size, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info = suspend_ocram_base;</span>
<span class="p_add">+	pm_info-&gt;pbase = ocram_pbase;</span>
<span class="p_add">+	pm_info-&gt;resume_addr = virt_to_phys(cpu_resume);</span>
<span class="p_add">+	pm_info-&gt;pm_info_size = sizeof(*pm_info);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;anatop_base, socdata-&gt;anatop_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get anatop base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto put_node;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;scsc_base, socdata-&gt;scsc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get scsc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto scsc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;ccm_base, socdata-&gt;ccm_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ccm base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ccm_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;gpc_base, socdata-&gt;gpc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get gpc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto gpc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;src_base, socdata-&gt;src_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get src base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto src_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;ddrmc_base, socdata-&gt;ddrmc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get ddrmc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto ddrmc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;iomuxc_base, socdata-&gt;iomuxc_compat);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get iomuxc base %d!\n&quot;, __func__, ret);</span>
<span class="p_add">+		goto iomuxc_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = imx_pm_get_base(&amp;pm_info-&gt;l2_base, &quot;arm,pl310-cache&quot;);</span>
<span class="p_add">+	if (ret == -ENODEV)</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_warn(&quot;%s: failed to get pl310-cache base %d!\n&quot;,</span>
<span class="p_add">+			__func__, ret);</span>
<span class="p_add">+		goto pl310_cache_map_failed;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pm_info-&gt;ddrmc_io_num = VF610_DDRMC_IO_NUM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Store DDRMC registers */</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(vf610_ddrmc_io_offset); i++, reg++) {</span>
<span class="p_add">+		pm_info-&gt;ddrmc_io_val[reg][0] = vf610_ddrmc_io_offset[i];</span>
<span class="p_add">+		pm_info-&gt;ddrmc_io_val[reg][1] =</span>
<span class="p_add">+			readl_relaxed(pm_info-&gt;ddrmc_base.vbase +</span>
<span class="p_add">+			vf610_ddrmc_io_offset[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Store DDRMC PHY registers */</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(vf610_ddrmc_phy_io_offset); i++, reg++) {</span>
<span class="p_add">+		pm_info-&gt;ddrmc_io_val[reg][0] = vf610_ddrmc_phy_io_offset[i] +</span>
<span class="p_add">+			DDRMC_PHY_OFFSET;</span>
<span class="p_add">+		pm_info-&gt;ddrmc_io_val[reg][1] =</span>
<span class="p_add">+			readl_relaxed(pm_info-&gt;ddrmc_base.vbase +</span>
<span class="p_add">+			DDRMC_PHY_OFFSET + vf610_ddrmc_phy_io_offset[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Store IOMUX DDR pad registers */</span>
<span class="p_add">+	pm_info-&gt;iomux_ddr_io_num = VF610_IOMUX_DDR_IO_NUM;</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(vf610_iomuxc_ddr_io_offset); i++) {</span>
<span class="p_add">+		pm_info-&gt;iomux_ddr_io_val[i][0] = vf610_iomuxc_ddr_io_offset[i];</span>
<span class="p_add">+		pm_info-&gt;iomux_ddr_io_val[i][1] =</span>
<span class="p_add">+			readl_relaxed(pm_info-&gt;iomuxc_base.vbase +</span>
<span class="p_add">+			vf610_iomuxc_ddr_io_offset[i]);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	vf610_suspend_in_ocram_fn = fncpy(</span>
<span class="p_add">+		suspend_ocram_base + sizeof(*pm_info),</span>
<span class="p_add">+		&amp;vf610_suspend, ocram_size - sizeof(*pm_info));</span>
<span class="p_add">+</span>
<span class="p_add">+	goto put_node;</span>
<span class="p_add">+</span>
<span class="p_add">+pl310_cache_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;iomuxc_base.vbase);</span>
<span class="p_add">+iomuxc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ddrmc_base.vbase);</span>
<span class="p_add">+ddrmc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;src_base.vbase);</span>
<span class="p_add">+src_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;gpc_base.vbase);</span>
<span class="p_add">+gpc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;ccm_base.vbase);</span>
<span class="p_add">+ccm_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;scsc_base.vbase);</span>
<span class="p_add">+scsc_map_failed:</span>
<span class="p_add">+	iounmap(pm_info-&gt;anatop_base.vbase);</span>
<span class="p_add">+put_node:</span>
<span class="p_add">+	of_node_put(node);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init vf610_pm_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_SUSPEND)) {</span>
<span class="p_add">+		ret = vf610_suspend_init(&amp;vf610_pm_data);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			pr_warn(&quot;%s: No DDR LPM support with suspend %d!\n&quot;,</span>
<span class="p_add">+				__func__, ret);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/arch/arm/mach-imx/suspend-vf610.S b/arch/arm/mach-imx/suspend-vf610.S</span>
new file mode 100644
<span class="p_header">index 0000000..09ad246</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm/mach-imx/suspend-vf610.S</span>
<span class="p_chunk">@@ -0,0 +1,437 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright 2014 Freescale Semiconductor, Inc.</span>
<span class="p_add">+ * Copyright 2016 Toradex AG</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The code contained herein is licensed under the GNU General Public</span>
<span class="p_add">+ * License. You may obtain a copy of the GNU General Public License</span>
<span class="p_add">+ * Version 2 or later at the following locations:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * http://www.opensource.org/licenses/gpl-license.html</span>
<span class="p_add">+ * http://www.gnu.org/copyleft/gpl.html</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/hardware/cache-l2x0.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ==================== low level suspend ====================</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Better to follow below rules to use ARM registers:</span>
<span class="p_add">+ * r0: pm_info structure address;</span>
<span class="p_add">+ * r1 ~ r4: for saving pm_info members;</span>
<span class="p_add">+ * r5 ~ r10: free registers;</span>
<span class="p_add">+ * r11: io base address.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * suspend ocram space layout:</span>
<span class="p_add">+ * ======================== high address ======================</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              .</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                              ^</span>
<span class="p_add">+ *                      vf610_suspend code</span>
<span class="p_add">+ *              PM_INFO structure(vf610_cpu_pm_info)</span>
<span class="p_add">+ * ======================== low address =======================</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Below offsets are based on struct vf610_cpu_pm_info</span>
<span class="p_add">+ * which defined in arch/arm/mach-imx/pm-vf610.c, this</span>
<span class="p_add">+ * structure contains necessary pm info for low level</span>
<span class="p_add">+ * suspend related code.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define PM_INFO_PBASE_OFFSET			0x0</span>
<span class="p_add">+#define PM_INFO_RESUME_ADDR_OFFSET		0x4</span>
<span class="p_add">+#define PM_INFO_CPU_TYPE_OFFSET			0x8</span>
<span class="p_add">+#define PM_INFO_PM_INFO_SIZE_OFFSET		0xC</span>
<span class="p_add">+#define PM_INFO_VF610_ANATOP_P_OFFSET		0x10</span>
<span class="p_add">+#define PM_INFO_VF610_ANATOP_V_OFFSET		0x14</span>
<span class="p_add">+#define PM_INFO_VF610_SCSC_P_OFFSET		0x18</span>
<span class="p_add">+#define PM_INFO_VF610_SCSC_V_OFFSET		0x1C</span>
<span class="p_add">+#define PM_INFO_VF610_WKPU_P_OFFSET		0x20</span>
<span class="p_add">+#define PM_INFO_VF610_WKPU_V_OFFSET		0x24</span>
<span class="p_add">+#define PM_INFO_VF610_CCM_P_OFFSET		0x28</span>
<span class="p_add">+#define PM_INFO_VF610_CCM_V_OFFSET		0x2C</span>
<span class="p_add">+#define PM_INFO_VF610_GPC_P_OFFSET		0x30</span>
<span class="p_add">+#define PM_INFO_VF610_GPC_V_OFFSET		0x34</span>
<span class="p_add">+#define PM_INFO_VF610_SRC_P_OFFSET		0x38</span>
<span class="p_add">+#define PM_INFO_VF610_SRC_V_OFFSET		0x3C</span>
<span class="p_add">+#define PM_INFO_VF610_DDRMC_P_OFFSET		0x40</span>
<span class="p_add">+#define PM_INFO_VF610_DDRMC_V_OFFSET		0x44</span>
<span class="p_add">+#define PM_INFO_VF610_IOMUXC_P_OFFSET		0x48</span>
<span class="p_add">+#define PM_INFO_VF610_IOMUXC_V_OFFSET		0x4c</span>
<span class="p_add">+#define PM_INFO_VF610_L2_P_OFFSET		0x50</span>
<span class="p_add">+#define PM_INFO_VF610_L2_V_OFFSET		0x54</span>
<span class="p_add">+#define PM_INFO_CCM_CACRR			0x58</span>
<span class="p_add">+#define PM_INFO_CCM_CCSR			0x5c</span>
<span class="p_add">+#define PM_INFO_DDRMC_IO_NUM_OFFSET		0x60</span>
<span class="p_add">+#define PM_INFO_DDRMC_IO_VAL_OFFSET		0x64</span>
<span class="p_add">+#define PM_INFO_IOMUXC_DDR_IO_NUM_OFFSET	(0x64 + 94 * 2 * 4)</span>
<span class="p_add">+#define PM_INFO_IOMUXC_DDR_IO_VAL_OFFSET	(0x68 + 94 * 2 * 4)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_ANADIG_PLL2_CTRL			0x30</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_ANADIG_MISC0			0x150</span>
<span class="p_add">+#define VF610_ANADIG_MISC0_CLK_24M_IRC_XTAL_SEL	(0x1 &lt; 13)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_ANADIG_PLL1_CTRL			0x270</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_ANADIG_POWERDOWN			(1 &lt;&lt; 12)</span>
<span class="p_add">+#define VF610_ANADIG_ENABLE			(1 &lt;&lt; 13)</span>
<span class="p_add">+#define VF610_ANADIG_BYPASS			(1 &lt;&lt; 16)</span>
<span class="p_add">+#define VF610_ANADIG_LOCK			(1 &lt;&lt; 31)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_SCSC_SIRC				0x0</span>
<span class="p_add">+#define VF610_SCSC_SIRC_SIRC_EN			(0x1 &lt;&lt; 0)</span>
<span class="p_add">+#define VF610_SCSC_SOSC				0x4</span>
<span class="p_add">+#define VF610_SCSC_SOSC_SOSC_EN			(0x1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_GPC_PGCR				0x0</span>
<span class="p_add">+#define VF610_GPC_LPMR				0x40</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_CCM_CCR				0x00</span>
<span class="p_add">+#define VF610_CCM_CCR_FXOSC_EN			(0x1 &lt;&lt; 12)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_CCM_CCSR				0x08</span>
<span class="p_add">+#define VF610_CCM_CCSR_DDRC_CLK_SEL		(0x1 &lt;&lt; 6)</span>
<span class="p_add">+#define VF610_CCM_CCSR_FAST_CLK_SEL		(0x1 &lt;&lt; 5)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_CCM_CACRR				0x0C</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_CCM_CLPCR				0x2C</span>
<span class="p_add">+#define VF610_CCM_CLPCR_DIS_REF_OSC		(0x1 &lt;&lt; 7)</span>
<span class="p_add">+#define VF610_CCM_CLPCR_FXOSC_PWRDWN		(0x1 &lt;&lt; 11)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_CCM_CCGR0				0x40</span>
<span class="p_add">+#define VF610_CCM_CCGR2				0x48</span>
<span class="p_add">+#define VF610_CCM_CCGR3				0x4C</span>
<span class="p_add">+#define VF610_CCM_CCGR4				0x50</span>
<span class="p_add">+#define VF610_CCM_CCGR6				0x58</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_SRC_GPR0				0x20</span>
<span class="p_add">+#define VF610_SRC_GPR1				0x24</span>
<span class="p_add">+#define VF610_SRC_MISC2				0x54</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_DDRMC_CR00			0x0</span>
<span class="p_add">+#define VF610_DDRMC_CR00_START			(0x1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_DDRMC_CR33			0x84</span>
<span class="p_add">+#define VF610_DDRMC_CR33_PWUP_SREF_EX		(0x1 &lt;&lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_DDRMC_CR34			0x88</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_DDRMC_CR35			0x8C</span>
<span class="p_add">+#define VF610_DDRMC_CR35_LP_CMD(cmd)		((cmd) &lt;&lt; 8)</span>
<span class="p_add">+</span>
<span class="p_add">+#define VF610_DDRMC_CR80			0x140</span>
<span class="p_add">+#define VF610_DDRMC_CR80_LP_COMPLETE		(0x1 &lt;&lt; 9)</span>
<span class="p_add">+#define VF610_DDRMC_CR80_INIT_COMPLETE		(0x1 &lt;&lt; 8)</span>
<span class="p_add">+#define VF610_DDRMC_CR81			0x144</span>
<span class="p_add">+</span>
<span class="p_add">+	.align 3</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Take DDR RAM out of Low-Power mode</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	.macro resume_ddrmc ddrmc_base</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear low power complete flag... */</span>
<span class="p_add">+	ldr	r6, =VF610_DDRMC_CR80_LP_COMPLETE</span>
<span class="p_add">+	str	r6, [\ddrmc_base, #VF610_DDRMC_CR81]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [\ddrmc_base, #VF610_DDRMC_CR35]</span>
<span class="p_add">+	orr	r6, r6, #VF610_DDRMC_CR35_LP_CMD(0x9)</span>
<span class="p_add">+	str	r6, [\ddrmc_base, #VF610_DDRMC_CR35]</span>
<span class="p_add">+</span>
<span class="p_add">+1:</span>
<span class="p_add">+	ldr	r5, [\ddrmc_base, #VF610_DDRMC_CR80]</span>
<span class="p_add">+	ands 	r5, r5, #VF610_DDRMC_CR80_LP_COMPLETE</span>
<span class="p_add">+	beq	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro enable_syspll pll_base</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [\pll_base]</span>
<span class="p_add">+	orr	r5, r5, #VF610_ANADIG_ENABLE</span>
<span class="p_add">+	bic	r5, r5, #VF610_ANADIG_POWERDOWN</span>
<span class="p_add">+	bic	r5, r5, #VF610_ANADIG_BYPASS</span>
<span class="p_add">+	str	r5, [\pll_base]</span>
<span class="p_add">+</span>
<span class="p_add">+1:</span>
<span class="p_add">+	ldr	r5, [\pll_base]</span>
<span class="p_add">+	tst 	r5, #VF610_ANADIG_LOCK</span>
<span class="p_add">+	beq	1b</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(vf610_suspend)</span>
<span class="p_add">+	ldr	r1, [r0, #PM_INFO_PBASE_OFFSET]</span>
<span class="p_add">+	ldr	r2, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+	ldr	r3, [r0, #PM_INFO_CPU_TYPE_OFFSET]</span>
<span class="p_add">+	ldr	r4, [r0, #PM_INFO_PM_INFO_SIZE_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure TLB contain the addr we want,</span>
<span class="p_add">+	 * as we will access them after DDRMC IO floated.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_DDRMC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, [r11, #0x0]</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, [r11, #0x0]</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_SRC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, [r11, #0x0]</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_CCM_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, [r11, #0x0]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_SRC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Disable DDR RESET */</span>
<span class="p_add">+	ldr	r6, [r11, #VF610_SRC_MISC2]</span>
<span class="p_add">+	orr	r6, r6, #0x1</span>
<span class="p_add">+	str	r6, [r11, #VF610_SRC_MISC2]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set ENTRY/ARGUMENT register */</span>
<span class="p_add">+	ldr	r6, =vf610_suspend</span>
<span class="p_add">+	ldr	r7, =resume</span>
<span class="p_add">+	sub	r7, r7, r6</span>
<span class="p_add">+	add	r8, r1, r4</span>
<span class="p_add">+	add	r9, r8, r7</span>
<span class="p_add">+	str	r9, [r11, #VF610_SRC_GPR0]</span>
<span class="p_add">+	str	r1, [r11, #VF610_SRC_GPR1]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Put memory in self refresh... */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_DDRMC_V_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, =VF610_DDRMC_CR80_LP_COMPLETE</span>
<span class="p_add">+	str	r6, [r11, #VF610_DDRMC_CR81]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r11, #VF610_DDRMC_CR35]</span>
<span class="p_add">+	orr	r6, r6, #VF610_DDRMC_CR35_LP_CMD(0xA)</span>
<span class="p_add">+	str	r6, [r11, #VF610_DDRMC_CR35]</span>
<span class="p_add">+</span>
<span class="p_add">+ddrmc_cmd_complete:</span>
<span class="p_add">+	/* Hardware without CKE/RESET fixes seems to hang at this read.... */</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_DDRMC_CR80]</span>
<span class="p_add">+	ands 	r5, r5, #VF610_DDRMC_CR80_LP_COMPLETE</span>
<span class="p_add">+	beq	ddrmc_cmd_complete</span>
<span class="p_add">+</span>
<span class="p_add">+	/* switch to internal FIRC */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_CCM_V_OFFSET]</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+	bic	r5, r5, #0x30 /* FAST_/SLOW_CLK_SEL */</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+	bic	r5, r5, #0x07 /* SYS_CLK_SEL */</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* LP-Mode: STOP */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_GPC_V_OFFSET]</span>
<span class="p_add">+	ldr	r6, =0x02</span>
<span class="p_add">+	str	r6, [r11, #VF610_GPC_LPMR]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Zzz, enter stop mode */</span>
<span class="p_add">+	wfi</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If we get here, there is already an interrupt pending. Restore... */</span>
<span class="p_add">+	ldr	r6, =0x00</span>
<span class="p_add">+	str	r6, [r11, #VF610_GPC_LPMR]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get previous CCSR/CACRR settings */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_CCM_V_OFFSET]</span>
<span class="p_add">+	ldr	r5, [r0, #PM_INFO_CCM_CCSR]</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r0, #PM_INFO_CCM_CACRR]</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CACRR]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_DDRMC_V_OFFSET]</span>
<span class="p_add">+	resume_ddrmc r11</span>
<span class="p_add">+</span>
<span class="p_add">+	ret	lr</span>
<span class="p_add">+</span>
<span class="p_add">+/* Resume path if CPU uses the SRC_GPR0 (PERSISTENT_ENTRY0) */</span>
<span class="p_add">+resume:</span>
<span class="p_add">+	/* invalidate L1 I-cache first */</span>
<span class="p_add">+	mov     r6, #0x0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 0</span>
<span class="p_add">+	mcr     p15, 0, r6, c7, c5, 6</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable the Icache and branch prediction */</span>
<span class="p_add">+	mov     r6, #0x1800</span>
<span class="p_add">+	mcr     p15, 0, r6, c1, c0, 0</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_CCM_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+	orr	r5, r5, #(1 &lt;&lt; 13)</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable IOMUX, PORT A-E */</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCGR2]</span>
<span class="p_add">+	ldr	r6, =0xfff0000</span>
<span class="p_add">+	orr	r5, r5, r6</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCGR2]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable ANADIG and SCSM */</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCGR3]</span>
<span class="p_add">+	orr	r5, r5, #0x33</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCGR3]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable GPC, CCM and WKUP */</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCGR4]</span>
<span class="p_add">+	orr	r5, r5, #0x3f00000</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCGR4]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable DDRMC */</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCGR6]</span>
<span class="p_add">+	orr	r5, r5, #0x30000000</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCGR6]</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+	/* enable UART0 */</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCGR0]</span>
<span class="p_add">+	orr	r5, r5, #0xC000</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCGR0]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Mux UART0 */</span>
<span class="p_add">+	ldr	r5,=0x1021a2</span>
<span class="p_add">+	ldr	r6,=0x40048080</span>
<span class="p_add">+	str	r5, [r6, #0x0]</span>
<span class="p_add">+	ldr	r5,=0x1021a1</span>
<span class="p_add">+	ldr	r6,=0x40048084</span>
<span class="p_add">+	str	r5, [r6, #0x0]</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set IOMUX for DDR pads */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_IOMUXC_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_IOMUXC_DDR_IO_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_IOMUXC_DDR_IO_VAL_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+</span>
<span class="p_add">+loop_iomuxc_ddr_restore:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r11, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	loop_iomuxc_ddr_restore</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable slow oscilators */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_SCSC_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_SCSC_SOSC]</span>
<span class="p_add">+	orr	r5, r5, #VF610_SCSC_SOSC_SOSC_EN</span>
<span class="p_add">+	str	r5, [r11, #VF610_SCSC_SOSC]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_SCSC_SIRC]</span>
<span class="p_add">+	orr	r5, r5, #VF610_SCSC_SIRC_SIRC_EN</span>
<span class="p_add">+	str	r5, [r11, #VF610_SCSC_SIRC]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable fast osciallator */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_CCM_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CLPCR]</span>
<span class="p_add">+	bic	r5, r5, #VF610_CCM_CLPCR_DIS_REF_OSC</span>
<span class="p_add">+	bic	r5, r5, #VF610_CCM_CLPCR_FXOSC_PWRDWN</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CLPCR]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCR]</span>
<span class="p_add">+	orr	r5, r5, #VF610_CCM_CCR_FXOSC_EN</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCR]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+	orr	r5, r5, #VF610_CCM_CCSR_FAST_CLK_SEL</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_ANATOP_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Select external FXOSC */</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_ANADIG_MISC0]</span>
<span class="p_add">+	bic	r5, r5, #VF610_ANADIG_MISC0_CLK_24M_IRC_XTAL_SEL</span>
<span class="p_add">+	str	r5, [r11, #VF610_ANADIG_MISC0]</span>
<span class="p_add">+</span>
<span class="p_add">+	add	r6, r11, #VF610_ANADIG_PLL1_CTRL</span>
<span class="p_add">+	enable_syspll r6</span>
<span class="p_add">+</span>
<span class="p_add">+	/* enable pll2 only if required for DDR */</span>
<span class="p_add">+	ldr	r5, [r0, #PM_INFO_CCM_CCSR]</span>
<span class="p_add">+	tst 	r5, #VF610_CCM_CCSR_DDRC_CLK_SEL</span>
<span class="p_add">+	bne	switch_sysclk</span>
<span class="p_add">+</span>
<span class="p_add">+	add	r6, r11, #VF610_ANADIG_PLL2_CTRL</span>
<span class="p_add">+	enable_syspll r6</span>
<span class="p_add">+</span>
<span class="p_add">+switch_sysclk:</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Enable PFD and switch to fast clock */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_CCM_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get previous CCSR/CACRR settings */</span>
<span class="p_add">+	ldr	r5, [r0, #PM_INFO_CCM_CCSR]</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CCSR]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r5, [r0, #PM_INFO_CCM_CACRR]</span>
<span class="p_add">+	str	r5, [r11, #VF610_CCM_CACRR]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore memory configuration */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_DDRMC_P_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r0, #PM_INFO_DDRMC_IO_NUM_OFFSET]</span>
<span class="p_add">+	ldr	r7, =PM_INFO_DDRMC_IO_VAL_OFFSET</span>
<span class="p_add">+	add	r7, r7, r0</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Clear start bit of first memory register, do not start yet... */</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	bic	r9, r9, #VF610_DDRMC_CR00_START</span>
<span class="p_add">+	str	r9, [r11, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+</span>
<span class="p_add">+loop_ddrmc_restore:</span>
<span class="p_add">+	ldr	r8, [r7], #0x4</span>
<span class="p_add">+	ldr	r9, [r7], #0x4</span>
<span class="p_add">+	str	r9, [r11, r8]</span>
<span class="p_add">+	subs	r6, r6, #0x1</span>
<span class="p_add">+	bne	loop_ddrmc_restore</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set PWUP_SREF_EX to avoid a full memory initialization */</span>
<span class="p_add">+	ldr	r6, [r11, #VF610_DDRMC_CR33]</span>
<span class="p_add">+	orr	r6, r6, #VF610_DDRMC_CR33_PWUP_SREF_EX</span>
<span class="p_add">+	str	r6, [r11, #VF610_DDRMC_CR33]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start initialization */</span>
<span class="p_add">+	ldr	r6, =VF610_DDRMC_CR80_INIT_COMPLETE</span>
<span class="p_add">+	str	r6, [r11, #VF610_DDRMC_CR81]</span>
<span class="p_add">+</span>
<span class="p_add">+	ldr	r6, [r11, #VF610_DDRMC_CR00]</span>
<span class="p_add">+	orr	r6, r6, #VF610_DDRMC_CR00_START</span>
<span class="p_add">+	str	r6, [r11, #VF610_DDRMC_CR00]</span>
<span class="p_add">+</span>
<span class="p_add">+ddrmc_initializing:</span>
<span class="p_add">+	ldr	r5, [r11, #VF610_DDRMC_CR80]</span>
<span class="p_add">+	ands 	r5, r5, #VF610_DDRMC_CR80_INIT_COMPLETE</span>
<span class="p_add">+	beq	ddrmc_initializing</span>
<span class="p_add">+</span>
<span class="p_add">+	resume_ddrmc r11</span>
<span class="p_add">+</span>
<span class="p_add">+	/* LP-Mode: RUN */</span>
<span class="p_add">+	ldr	r11, [r0, #PM_INFO_VF610_GPC_P_OFFSET]</span>
<span class="p_add">+	ldr	r5, =0x0</span>
<span class="p_add">+	str	r5, [r11, #VF610_GPC_LPMR]</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get physical resume address from pm_info. */</span>
<span class="p_add">+	ldr	lr, [r0, #PM_INFO_RESUME_ADDR_OFFSET]</span>
<span class="p_add">+</span>
<span class="p_add">+	ret	lr</span>
<span class="p_add">+ENDPROC(vf610_suspend)</span>
<span class="p_add">+</span>
<span class="p_header">diff --git a/drivers/clk/imx/clk-vf610.c b/drivers/clk/imx/clk-vf610.c</span>
<span class="p_header">index 170a96c..27d4cf0 100644</span>
<span class="p_header">--- a/drivers/clk/imx/clk-vf610.c</span>
<span class="p_header">+++ b/drivers/clk/imx/clk-vf610.c</span>
<span class="p_chunk">@@ -117,6 +117,11 @@</span> <span class="p_context"> static struct clk_div_table pll4_audio_div_table[] = {</span>
 static struct clk *clk[VF610_CLK_END];
 static struct clk_onecell_data clk_data;
 
<span class="p_add">+static u32 anadig_pll3_ctrl;</span>
<span class="p_add">+static u32 anadig_pll4_ctrl;</span>
<span class="p_add">+static u32 anadig_pll5_ctrl;</span>
<span class="p_add">+static u32 anadig_pll6_ctrl;</span>
<span class="p_add">+static u32 anadig_pll7_ctrl;</span>
 static u32 cscmr1;
 static u32 cscmr2;
 static u32 cscdr1;
<span class="p_chunk">@@ -147,6 +152,12 @@</span> <span class="p_context"> static int vf610_clk_suspend(void)</span>
 {
 	int i;
 
<span class="p_add">+	anadig_pll3_ctrl = readl_relaxed(PLL3_CTRL);</span>
<span class="p_add">+	anadig_pll4_ctrl = readl_relaxed(PLL4_CTRL);</span>
<span class="p_add">+	anadig_pll5_ctrl = readl_relaxed(PLL5_CTRL);</span>
<span class="p_add">+	anadig_pll6_ctrl = readl_relaxed(PLL6_CTRL);</span>
<span class="p_add">+	anadig_pll7_ctrl = readl_relaxed(PLL7_CTRL);</span>
<span class="p_add">+</span>
 	cscmr1 = readl_relaxed(CCM_CSCMR1);
 	cscmr2 = readl_relaxed(CCM_CSCMR2);
 
<span class="p_chunk">@@ -164,6 +175,12 @@</span> <span class="p_context"> static void vf610_clk_resume(void)</span>
 {
 	int i;
 
<span class="p_add">+	writel_relaxed(anadig_pll3_ctrl, PLL3_CTRL);</span>
<span class="p_add">+	writel_relaxed(anadig_pll4_ctrl, PLL4_CTRL);</span>
<span class="p_add">+	writel_relaxed(anadig_pll5_ctrl, PLL5_CTRL);</span>
<span class="p_add">+	writel_relaxed(anadig_pll6_ctrl, PLL6_CTRL);</span>
<span class="p_add">+	writel_relaxed(anadig_pll7_ctrl, PLL7_CTRL);</span>
<span class="p_add">+</span>
 	writel_relaxed(cscmr1, CCM_CSCMR1);
 	writel_relaxed(cscmr2, CCM_CSCMR2);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



