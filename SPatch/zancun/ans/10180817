
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[1/3] x86/mm/encrypt: Move sme_populate_pgd*() into separate translation unit - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [1/3] x86/mm/encrypt: Move sme_populate_pgd*() into separate translation unit</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=40781">Kirill A. Shutemov</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 23, 2018, 5:19 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180123171910.55841-2-kirill.shutemov@linux.intel.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10180817/mbox/"
   >mbox</a>
|
   <a href="/patch/10180817/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10180817/">/patch/10180817/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	8C945602B7 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Jan 2018 17:19:59 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 6D03F286D5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Jan 2018 17:19:59 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6080328731; Tue, 23 Jan 2018 17:19:59 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 68EE6286D5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 23 Jan 2018 17:19:58 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751907AbeAWRT5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 23 Jan 2018 12:19:57 -0500
Received: from mga14.intel.com ([192.55.52.115]:45659 &quot;EHLO mga14.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1751389AbeAWRTU (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 23 Jan 2018 12:19:20 -0500
X-Amp-Result: SKIPPED(no attachment in message)
X-Amp-File-Uploaded: False
Received: from orsmga008.jf.intel.com ([10.7.209.65])
	by fmsmga103.fm.intel.com with ESMTP/TLS/DHE-RSA-AES256-GCM-SHA384;
	23 Jan 2018 09:19:19 -0800
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.46,402,1511856000&quot;; d=&quot;scan&#39;208&quot;;a=&quot;12453121&quot;
Received: from black.fi.intel.com ([10.237.72.28])
	by orsmga008.jf.intel.com with ESMTP; 23 Jan 2018 09:19:16 -0800
Received: by black.fi.intel.com (Postfix, from userid 1000)
	id 5873E55; Tue, 23 Jan 2018 19:19:15 +0200 (EET)
From: &quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;
To: Ingo Molnar &lt;mingo@redhat.com&gt;, x86@kernel.org,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;,
	Borislav Petkov &lt;bp@suse.de&gt;, linux-mm@kvack.org,
	linux-kernel@vger.kernel.org,
	&quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;
Subject: [PATCH 1/3] x86/mm/encrypt: Move sme_populate_pgd*() into separate
	translation unit
Date: Tue, 23 Jan 2018 20:19:08 +0300
Message-Id: &lt;20180123171910.55841-2-kirill.shutemov@linux.intel.com&gt;
X-Mailer: git-send-email 2.15.1
In-Reply-To: &lt;20180123171910.55841-1-kirill.shutemov@linux.intel.com&gt;
References: &lt;20180123171910.55841-1-kirill.shutemov@linux.intel.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=40781">Kirill A. Shutemov</a> - Jan. 23, 2018, 5:19 p.m.</div>
<pre class="content">
sme_populate_pgd() and sme_populate_pgd_large() operate on the identity
mapping, which means they want virtual addresses to be equal to physical
one, without PAGE_OFFSET shift.

We also need to avoid paravirtualizaion call there.

Getting this done is tricky. We cannot use usual page table helpers.
It forces us to open-code a lot of things. It makes code ugly and hard
to modify.

We can get it work with the page table helpers, but it requires few
preprocessor tricks. These tricks may have side effects for the rest of
the file.

Let&#39;s isolate sme_populate_pgd() and sme_populate_pgd_large() into own
translation unit.
<span class="signed-off-by">
Signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
---
 arch/x86/mm/Makefile               |  13 ++--
 arch/x86/mm/mem_encrypt.c          | 129 -----------------------------------
 arch/x86/mm/mem_encrypt_identity.c | 134 +++++++++++++++++++++++++++++++++++++
 arch/x86/mm/mm_internal.h          |  14 ++++
 4 files changed, 156 insertions(+), 134 deletions(-)
 create mode 100644 arch/x86/mm/mem_encrypt_identity.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=80801">Tom Lendacky</a> - Jan. 24, 2018, 2:59 p.m.</div>
<pre class="content">
On 1/23/2018 11:19 AM, Kirill A. Shutemov wrote:
<span class="quote">&gt; sme_populate_pgd() and sme_populate_pgd_large() operate on the identity</span>
<span class="quote">&gt; mapping, which means they want virtual addresses to be equal to physical</span>
<span class="quote">&gt; one, without PAGE_OFFSET shift.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We also need to avoid paravirtualizaion call there.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Getting this done is tricky. We cannot use usual page table helpers.</span>
<span class="quote">&gt; It forces us to open-code a lot of things. It makes code ugly and hard</span>
<span class="quote">&gt; to modify.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We can get it work with the page table helpers, but it requires few</span>
<span class="quote">&gt; preprocessor tricks. These tricks may have side effects for the rest of</span>
<span class="quote">&gt; the file.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Let&#39;s isolate sme_populate_pgd() and sme_populate_pgd_large() into own</span>
<span class="quote">&gt; translation unit.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  arch/x86/mm/Makefile               |  13 ++--</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt.c          | 129 -----------------------------------</span>
<span class="quote">&gt;  arch/x86/mm/mem_encrypt_identity.c | 134 +++++++++++++++++++++++++++++++++++++</span>
<span class="quote">&gt;  arch/x86/mm/mm_internal.h          |  14 ++++</span>
<span class="quote">&gt;  4 files changed, 156 insertions(+), 134 deletions(-)</span>
<span class="quote">&gt;  create mode 100644 arch/x86/mm/mem_encrypt_identity.c</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="quote">&gt; index 27e9e90a8d35..51e364ef12d9 100644</span>
<span class="quote">&gt; --- a/arch/x86/mm/Makefile</span>
<span class="quote">&gt; +++ b/arch/x86/mm/Makefile</span>
<span class="quote">&gt; @@ -1,12 +1,14 @@</span>
<span class="quote">&gt;  # SPDX-License-Identifier: GPL-2.0</span>
<span class="quote">&gt; -# Kernel does not boot with instrumentation of tlb.c and mem_encrypt.c</span>
<span class="quote">&gt; -KCOV_INSTRUMENT_tlb.o		:= n</span>
<span class="quote">&gt; -KCOV_INSTRUMENT_mem_encrypt.o	:= n</span>
<span class="quote">&gt; +# Kernel does not boot with instrumentation of tlb.c and mem_encrypt*.c</span>
<span class="quote">&gt; +KCOV_INSTRUMENT_tlb.o			:= n</span>
<span class="quote">&gt; +KCOV_INSTRUMENT_mem_encrypt.o		:= n</span>
<span class="quote">&gt; +KCOV_INSTRUMENT_mem_encrypt_identity.o	:= n</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -KASAN_SANITIZE_mem_encrypt.o	:= n</span>
<span class="quote">&gt; +KASAN_SANITIZE_mem_encrypt.o		:= n</span>
<span class="quote">&gt; +KASAN_SANITIZE_mem_encrypt_identity.o	:= n</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  ifdef CONFIG_FUNCTION_TRACER</span>
<span class="quote">&gt; -CFLAGS_REMOVE_mem_encrypt.o	= -pg</span>

You found this one already.
<span class="quote">
&gt; +CFLAGS_REMOVE_mem_encrypt_identity.o	= -pg</span>
<span class="quote">&gt;  endif</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  obj-y	:=  init.o init_$(BITS).o fault.o ioremap.o extable.o pageattr.o mmap.o \</span>
<span class="quote">&gt; @@ -47,4 +49,5 @@ obj-$(CONFIG_RANDOMIZE_MEMORY)			+= kaslr.o</span>
<span class="quote">&gt;  obj-$(CONFIG_PAGE_TABLE_ISOLATION)		+= pti.o</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt.o</span>
<span class="quote">&gt; +obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_identity.o</span>
<span class="quote">&gt;  obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o</span>
<span class="quote">&gt; diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; index e1d61e8500f9..740b8a54f616 100644</span>
<span class="quote">&gt; --- a/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; +++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="quote">&gt; @@ -464,18 +464,6 @@ void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
<span class="quote">&gt;  	set_memory_decrypted((unsigned long)vaddr, size &gt;&gt; PAGE_SHIFT);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -struct sme_populate_pgd_data {</span>
<span class="quote">&gt; -	void	*pgtable_area;</span>
<span class="quote">&gt; -	pgd_t	*pgd;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pmdval_t pmd_flags;</span>
<span class="quote">&gt; -	pteval_t pte_flags;</span>
<span class="quote">&gt; -	unsigned long paddr;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	unsigned long vaddr;</span>
<span class="quote">&gt; -	unsigned long vaddr_end;</span>
<span class="quote">&gt; -};</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  static void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)</span>

If you&#39;re going to move some of the functions, did you look at moving the
sme_enable(), sme_encrypt_kernel(), etc., too?  I believe everything below
the sme_populate_pgd_data structure is used during early identity-mapped
boot time. If you move everything, then mm_internal.h doesn&#39;t need to be
updated and all of the identity-mapped early boot code ends up in one
file.

You&#39;d have to move the command line declarations and make sev_enabled
not a static, but it should be doable.

Thanks,
Tom
<span class="quote">
&gt;  {</span>
<span class="quote">&gt;  	unsigned long pgd_start, pgd_end, pgd_size;</span>
<span class="quote">&gt; @@ -491,11 +479,6 @@ static void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt;  	memset(pgd_p, 0, pgd_size);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -#define PGD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; -#define P4D_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; -#define PUD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; -#define PMD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  #define PMD_FLAGS_LARGE		(__PAGE_KERNEL_LARGE_EXEC &amp; ~_PAGE_GLOBAL)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define PMD_FLAGS_DEC		PMD_FLAGS_LARGE</span>
<span class="quote">&gt; @@ -512,118 +495,6 @@ static void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #define PTE_FLAGS_ENC		(PTE_FLAGS | _PAGE_ENC)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -static pmd_t __init *sme_prepare_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	pgd_t *pgd_p;</span>
<span class="quote">&gt; -	p4d_t *p4d_p;</span>
<span class="quote">&gt; -	pud_t *pud_p;</span>
<span class="quote">&gt; -	pmd_t *pmd_p;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pgd_p = ppd-&gt;pgd + pgd_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; -	if (native_pgd_val(*pgd_p)) {</span>
<span class="quote">&gt; -		if (IS_ENABLED(CONFIG_X86_5LEVEL))</span>
<span class="quote">&gt; -			p4d_p = (p4d_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; -		else</span>
<span class="quote">&gt; -			pud_p = (pud_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; -	} else {</span>
<span class="quote">&gt; -		pgd_t pgd;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="quote">&gt; -			p4d_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; -			memset(p4d_p, 0, sizeof(*p4d_p) * PTRS_PER_P4D);</span>
<span class="quote">&gt; -			ppd-&gt;pgtable_area += sizeof(*p4d_p) * PTRS_PER_P4D;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -			pgd = native_make_pgd((pgdval_t)p4d_p + PGD_FLAGS);</span>
<span class="quote">&gt; -		} else {</span>
<span class="quote">&gt; -			pud_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; -			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="quote">&gt; -			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -			pgd = native_make_pgd((pgdval_t)pud_p + PGD_FLAGS);</span>
<span class="quote">&gt; -		}</span>
<span class="quote">&gt; -		native_set_pgd(pgd_p, pgd);</span>
<span class="quote">&gt; -	}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="quote">&gt; -		p4d_p += p4d_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; -		if (native_p4d_val(*p4d_p)) {</span>
<span class="quote">&gt; -			pud_p = (pud_t *)(native_p4d_val(*p4d_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; -		} else {</span>
<span class="quote">&gt; -			p4d_t p4d;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -			pud_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; -			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="quote">&gt; -			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -			p4d = native_make_p4d((pudval_t)pud_p + P4D_FLAGS);</span>
<span class="quote">&gt; -			native_set_p4d(p4d_p, p4d);</span>
<span class="quote">&gt; -		}</span>
<span class="quote">&gt; -	}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pud_p += pud_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; -	if (native_pud_val(*pud_p)) {</span>
<span class="quote">&gt; -		if (native_pud_val(*pud_p) &amp; _PAGE_PSE)</span>
<span class="quote">&gt; -			return NULL;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		pmd_p = (pmd_t *)(native_pud_val(*pud_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; -	} else {</span>
<span class="quote">&gt; -		pud_t pud;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		pmd_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; -		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="quote">&gt; -		ppd-&gt;pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		pud = native_make_pud((pmdval_t)pmd_p + PUD_FLAGS);</span>
<span class="quote">&gt; -		native_set_pud(pud_p, pud);</span>
<span class="quote">&gt; -	}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	return pmd_p;</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static void __init sme_populate_pgd_large(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	pmd_t *pmd_p;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="quote">&gt; -	if (!pmd_p)</span>
<span class="quote">&gt; -		return;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; -	if (!native_pmd_val(*pmd_p) || !(native_pmd_val(*pmd_p) &amp; _PAGE_PSE))</span>
<span class="quote">&gt; -		native_set_pmd(pmd_p, native_make_pmd(ppd-&gt;paddr | ppd-&gt;pmd_flags));</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -static void __init sme_populate_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt; -{</span>
<span class="quote">&gt; -	pmd_t *pmd_p;</span>
<span class="quote">&gt; -	pte_t *pte_p;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="quote">&gt; -	if (!pmd_p)</span>
<span class="quote">&gt; -		return;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; -	if (native_pmd_val(*pmd_p)) {</span>
<span class="quote">&gt; -		if (native_pmd_val(*pmd_p) &amp; _PAGE_PSE)</span>
<span class="quote">&gt; -			return;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		pte_p = (pte_t *)(native_pmd_val(*pmd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; -	} else {</span>
<span class="quote">&gt; -		pmd_t pmd;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		pte_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; -		memset(pte_p, 0, sizeof(*pte_p) * PTRS_PER_PTE);</span>
<span class="quote">&gt; -		ppd-&gt;pgtable_area += sizeof(*pte_p) * PTRS_PER_PTE;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -		pmd = native_make_pmd((pteval_t)pte_p + PMD_FLAGS);</span>
<span class="quote">&gt; -		native_set_pmd(pmd_p, pmd);</span>
<span class="quote">&gt; -	}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	pte_p += pte_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; -	if (!native_pte_val(*pte_p))</span>
<span class="quote">&gt; -		native_set_pte(pte_p, native_make_pte(ppd-&gt;paddr | ppd-&gt;pte_flags));</span>
<span class="quote">&gt; -}</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt;  static void __init __sme_map_range_pmd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	while (ppd-&gt;vaddr &lt; ppd-&gt;vaddr_end) {</span>
<span class="quote">&gt; diff --git a/arch/x86/mm/mem_encrypt_identity.c b/arch/x86/mm/mem_encrypt_identity.c</span>
<span class="quote">&gt; new file mode 100644</span>
<span class="quote">&gt; index 000000000000..dbf7a98f657d</span>
<span class="quote">&gt; --- /dev/null</span>
<span class="quote">&gt; +++ b/arch/x86/mm/mem_encrypt_identity.c</span>
<span class="quote">&gt; @@ -0,0 +1,134 @@</span>
<span class="quote">&gt; +/*</span>
<span class="quote">&gt; + * AMD Memory Encryption Support</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Copyright (C) 2016 Advanced Micro Devices, Inc.</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="quote">&gt; + *</span>
<span class="quote">&gt; + * This program is free software; you can redistribute it and/or modify</span>
<span class="quote">&gt; + * it under the terms of the GNU General Public License version 2 as</span>
<span class="quote">&gt; + * published by the Free Software Foundation.</span>
<span class="quote">&gt; + */</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define DISABLE_BRANCH_PROFILING</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#include &lt;linux/kernel.h&gt;</span>
<span class="quote">&gt; +#include &lt;linux/mm.h&gt;</span>
<span class="quote">&gt; +#include &quot;mm_internal.h&quot;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +#define PGD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; +#define P4D_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; +#define PUD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; +#define PMD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static pmd_t __init *sme_prepare_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pgd_t *pgd_p;</span>
<span class="quote">&gt; +	p4d_t *p4d_p;</span>
<span class="quote">&gt; +	pud_t *pud_p;</span>
<span class="quote">&gt; +	pmd_t *pmd_p;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pgd_p = ppd-&gt;pgd + pgd_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; +	if (native_pgd_val(*pgd_p)) {</span>
<span class="quote">&gt; +		if (IS_ENABLED(CONFIG_X86_5LEVEL))</span>
<span class="quote">&gt; +			p4d_p = (p4d_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; +		else</span>
<span class="quote">&gt; +			pud_p = (pud_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		pgd_t pgd;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="quote">&gt; +			p4d_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; +			memset(p4d_p, 0, sizeof(*p4d_p) * PTRS_PER_P4D);</span>
<span class="quote">&gt; +			ppd-&gt;pgtable_area += sizeof(*p4d_p) * PTRS_PER_P4D;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			pgd = native_make_pgd((pgdval_t)p4d_p + PGD_FLAGS);</span>
<span class="quote">&gt; +		} else {</span>
<span class="quote">&gt; +			pud_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; +			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="quote">&gt; +			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			pgd = native_make_pgd((pgdval_t)pud_p + PGD_FLAGS);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		native_set_pgd(pgd_p, pgd);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="quote">&gt; +		p4d_p += p4d_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; +		if (native_p4d_val(*p4d_p)) {</span>
<span class="quote">&gt; +			pud_p = (pud_t *)(native_p4d_val(*p4d_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; +		} else {</span>
<span class="quote">&gt; +			p4d_t p4d;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			pud_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; +			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="quote">&gt; +			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +			p4d = native_make_p4d((pudval_t)pud_p + P4D_FLAGS);</span>
<span class="quote">&gt; +			native_set_p4d(p4d_p, p4d);</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pud_p += pud_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; +	if (native_pud_val(*pud_p)) {</span>
<span class="quote">&gt; +		if (native_pud_val(*pud_p) &amp; _PAGE_PSE)</span>
<span class="quote">&gt; +			return NULL;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pmd_p = (pmd_t *)(native_pud_val(*pud_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		pud_t pud;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pmd_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; +		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="quote">&gt; +		ppd-&gt;pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pud = native_make_pud((pmdval_t)pmd_p + PUD_FLAGS);</span>
<span class="quote">&gt; +		native_set_pud(pud_p, pud);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return pmd_p;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __init sme_populate_pgd_large(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pmd_t *pmd_p;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="quote">&gt; +	if (!pmd_p)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; +	if (!native_pmd_val(*pmd_p) || !(native_pmd_val(*pmd_p) &amp; _PAGE_PSE))</span>
<span class="quote">&gt; +		native_set_pmd(pmd_p, native_make_pmd(ppd-&gt;paddr | ppd-&gt;pmd_flags));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __init sme_populate_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	pmd_t *pmd_p;</span>
<span class="quote">&gt; +	pte_t *pte_p;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="quote">&gt; +	if (!pmd_p)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; +	if (native_pmd_val(*pmd_p)) {</span>
<span class="quote">&gt; +		if (native_pmd_val(*pmd_p) &amp; _PAGE_PSE)</span>
<span class="quote">&gt; +			return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pte_p = (pte_t *)(native_pmd_val(*pmd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		pmd_t pmd;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pte_p = ppd-&gt;pgtable_area;</span>
<span class="quote">&gt; +		memset(pte_p, 0, sizeof(*pte_p) * PTRS_PER_PTE);</span>
<span class="quote">&gt; +		ppd-&gt;pgtable_area += sizeof(*pte_p) * PTRS_PER_PTE;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +		pmd = native_make_pmd((pteval_t)pte_p + PMD_FLAGS);</span>
<span class="quote">&gt; +		native_set_pmd(pmd_p, pmd);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pte_p += pte_index(ppd-&gt;vaddr);</span>
<span class="quote">&gt; +	if (!native_pte_val(*pte_p))</span>
<span class="quote">&gt; +		native_set_pte(pte_p, native_make_pte(ppd-&gt;paddr | ppd-&gt;pte_flags));</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; diff --git a/arch/x86/mm/mm_internal.h b/arch/x86/mm/mm_internal.h</span>
<span class="quote">&gt; index 4e1f6e1b8159..b3ab82ae9b12 100644</span>
<span class="quote">&gt; --- a/arch/x86/mm/mm_internal.h</span>
<span class="quote">&gt; +++ b/arch/x86/mm/mm_internal.h</span>
<span class="quote">&gt; @@ -19,4 +19,18 @@ extern int after_bootmem;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  void update_cache_mode_entry(unsigned entry, enum page_cache_mode cache);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +struct sme_populate_pgd_data {</span>
<span class="quote">&gt; +	void	*pgtable_area;</span>
<span class="quote">&gt; +	pgd_t	*pgd;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	pmdval_t pmd_flags;</span>
<span class="quote">&gt; +	pteval_t pte_flags;</span>
<span class="quote">&gt; +	unsigned long paddr;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	unsigned long vaddr;</span>
<span class="quote">&gt; +	unsigned long vaddr_end;</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +void __init sme_populate_pgd(struct sme_populate_pgd_data *ppd);</span>
<span class="quote">&gt; +void __init sme_populate_pgd_large(struct sme_populate_pgd_data *ppd);</span>
<span class="quote">&gt;  #endif	/* __X86_MM_INTERNAL_H */</span>
<span class="quote">&gt;</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=40781">Kirill A. Shutemov</a> - Jan. 24, 2018, 3:52 p.m.</div>
<pre class="content">
On Wed, Jan 24, 2018 at 02:59:58PM +0000, Tom Lendacky wrote:
<span class="quote">&gt; &gt;  static void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you&#39;re going to move some of the functions, did you look at moving the</span>
<span class="quote">&gt; sme_enable(), sme_encrypt_kernel(), etc., too?  I believe everything below</span>
<span class="quote">&gt; the sme_populate_pgd_data structure is used during early identity-mapped</span>
<span class="quote">&gt; boot time. If you move everything, then mm_internal.h doesn&#39;t need to be</span>
<span class="quote">&gt; updated and all of the identity-mapped early boot code ends up in one</span>
<span class="quote">&gt; file.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; You&#39;d have to move the command line declarations and make sev_enabled</span>
<span class="quote">&gt; not a static, but it should be doable.</span>

I moved minimum of the code to get the trick work, but I&#39;ll look into
moving move there.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="p_header">index 27e9e90a8d35..51e364ef12d9 100644</span>
<span class="p_header">--- a/arch/x86/mm/Makefile</span>
<span class="p_header">+++ b/arch/x86/mm/Makefile</span>
<span class="p_chunk">@@ -1,12 +1,14 @@</span> <span class="p_context"></span>
 # SPDX-License-Identifier: GPL-2.0
<span class="p_del">-# Kernel does not boot with instrumentation of tlb.c and mem_encrypt.c</span>
<span class="p_del">-KCOV_INSTRUMENT_tlb.o		:= n</span>
<span class="p_del">-KCOV_INSTRUMENT_mem_encrypt.o	:= n</span>
<span class="p_add">+# Kernel does not boot with instrumentation of tlb.c and mem_encrypt*.c</span>
<span class="p_add">+KCOV_INSTRUMENT_tlb.o			:= n</span>
<span class="p_add">+KCOV_INSTRUMENT_mem_encrypt.o		:= n</span>
<span class="p_add">+KCOV_INSTRUMENT_mem_encrypt_identity.o	:= n</span>
 
<span class="p_del">-KASAN_SANITIZE_mem_encrypt.o	:= n</span>
<span class="p_add">+KASAN_SANITIZE_mem_encrypt.o		:= n</span>
<span class="p_add">+KASAN_SANITIZE_mem_encrypt_identity.o	:= n</span>
 
 ifdef CONFIG_FUNCTION_TRACER
<span class="p_del">-CFLAGS_REMOVE_mem_encrypt.o	= -pg</span>
<span class="p_add">+CFLAGS_REMOVE_mem_encrypt_identity.o	= -pg</span>
 endif
 
 obj-y	:=  init.o init_$(BITS).o fault.o ioremap.o extable.o pageattr.o mmap.o \
<span class="p_chunk">@@ -47,4 +49,5 @@</span> <span class="p_context"> obj-$(CONFIG_RANDOMIZE_MEMORY)			+= kaslr.o</span>
 obj-$(CONFIG_PAGE_TABLE_ISOLATION)		+= pti.o
 
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt.o
<span class="p_add">+obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_identity.o</span>
 obj-$(CONFIG_AMD_MEM_ENCRYPT)	+= mem_encrypt_boot.o
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt.c b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">index e1d61e8500f9..740b8a54f616 100644</span>
<span class="p_header">--- a/arch/x86/mm/mem_encrypt.c</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt.c</span>
<span class="p_chunk">@@ -464,18 +464,6 @@</span> <span class="p_context"> void swiotlb_set_mem_attributes(void *vaddr, unsigned long size)</span>
 	set_memory_decrypted((unsigned long)vaddr, size &gt;&gt; PAGE_SHIFT);
 }
 
<span class="p_del">-struct sme_populate_pgd_data {</span>
<span class="p_del">-	void	*pgtable_area;</span>
<span class="p_del">-	pgd_t	*pgd;</span>
<span class="p_del">-</span>
<span class="p_del">-	pmdval_t pmd_flags;</span>
<span class="p_del">-	pteval_t pte_flags;</span>
<span class="p_del">-	unsigned long paddr;</span>
<span class="p_del">-</span>
<span class="p_del">-	unsigned long vaddr;</span>
<span class="p_del">-	unsigned long vaddr_end;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)
 {
 	unsigned long pgd_start, pgd_end, pgd_size;
<span class="p_chunk">@@ -491,11 +479,6 @@</span> <span class="p_context"> static void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)</span>
 	memset(pgd_p, 0, pgd_size);
 }
 
<span class="p_del">-#define PGD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_del">-#define P4D_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_del">-#define PUD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_del">-#define PMD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_del">-</span>
 #define PMD_FLAGS_LARGE		(__PAGE_KERNEL_LARGE_EXEC &amp; ~_PAGE_GLOBAL)
 
 #define PMD_FLAGS_DEC		PMD_FLAGS_LARGE
<span class="p_chunk">@@ -512,118 +495,6 @@</span> <span class="p_context"> static void __init sme_clear_pgd(struct sme_populate_pgd_data *ppd)</span>
 
 #define PTE_FLAGS_ENC		(PTE_FLAGS | _PAGE_ENC)
 
<span class="p_del">-static pmd_t __init *sme_prepare_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pgd_t *pgd_p;</span>
<span class="p_del">-	p4d_t *p4d_p;</span>
<span class="p_del">-	pud_t *pud_p;</span>
<span class="p_del">-	pmd_t *pmd_p;</span>
<span class="p_del">-</span>
<span class="p_del">-	pgd_p = ppd-&gt;pgd + pgd_index(ppd-&gt;vaddr);</span>
<span class="p_del">-	if (native_pgd_val(*pgd_p)) {</span>
<span class="p_del">-		if (IS_ENABLED(CONFIG_X86_5LEVEL))</span>
<span class="p_del">-			p4d_p = (p4d_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			pud_p = (pud_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pgd_t pgd;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_del">-			p4d_p = ppd-&gt;pgtable_area;</span>
<span class="p_del">-			memset(p4d_p, 0, sizeof(*p4d_p) * PTRS_PER_P4D);</span>
<span class="p_del">-			ppd-&gt;pgtable_area += sizeof(*p4d_p) * PTRS_PER_P4D;</span>
<span class="p_del">-</span>
<span class="p_del">-			pgd = native_make_pgd((pgdval_t)p4d_p + PGD_FLAGS);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			pud_p = ppd-&gt;pgtable_area;</span>
<span class="p_del">-			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="p_del">-			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="p_del">-</span>
<span class="p_del">-			pgd = native_make_pgd((pgdval_t)pud_p + PGD_FLAGS);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		native_set_pgd(pgd_p, pgd);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_del">-		p4d_p += p4d_index(ppd-&gt;vaddr);</span>
<span class="p_del">-		if (native_p4d_val(*p4d_p)) {</span>
<span class="p_del">-			pud_p = (pud_t *)(native_p4d_val(*p4d_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			p4d_t p4d;</span>
<span class="p_del">-</span>
<span class="p_del">-			pud_p = ppd-&gt;pgtable_area;</span>
<span class="p_del">-			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="p_del">-			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="p_del">-</span>
<span class="p_del">-			p4d = native_make_p4d((pudval_t)pud_p + P4D_FLAGS);</span>
<span class="p_del">-			native_set_p4d(p4d_p, p4d);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	pud_p += pud_index(ppd-&gt;vaddr);</span>
<span class="p_del">-	if (native_pud_val(*pud_p)) {</span>
<span class="p_del">-		if (native_pud_val(*pud_p) &amp; _PAGE_PSE)</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		pmd_p = (pmd_t *)(native_pud_val(*pud_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pud_t pud;</span>
<span class="p_del">-</span>
<span class="p_del">-		pmd_p = ppd-&gt;pgtable_area;</span>
<span class="p_del">-		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="p_del">-		ppd-&gt;pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="p_del">-</span>
<span class="p_del">-		pud = native_make_pud((pmdval_t)pmd_p + PUD_FLAGS);</span>
<span class="p_del">-		native_set_pud(pud_p, pud);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return pmd_p;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init sme_populate_pgd_large(struct sme_populate_pgd_data *ppd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pmd_t *pmd_p;</span>
<span class="p_del">-</span>
<span class="p_del">-	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="p_del">-	if (!pmd_p)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="p_del">-	if (!native_pmd_val(*pmd_p) || !(native_pmd_val(*pmd_p) &amp; _PAGE_PSE))</span>
<span class="p_del">-		native_set_pmd(pmd_p, native_make_pmd(ppd-&gt;paddr | ppd-&gt;pmd_flags));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init sme_populate_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	pmd_t *pmd_p;</span>
<span class="p_del">-	pte_t *pte_p;</span>
<span class="p_del">-</span>
<span class="p_del">-	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="p_del">-	if (!pmd_p)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="p_del">-	if (native_pmd_val(*pmd_p)) {</span>
<span class="p_del">-		if (native_pmd_val(*pmd_p) &amp; _PAGE_PSE)</span>
<span class="p_del">-			return;</span>
<span class="p_del">-</span>
<span class="p_del">-		pte_p = (pte_t *)(native_pmd_val(*pmd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		pmd_t pmd;</span>
<span class="p_del">-</span>
<span class="p_del">-		pte_p = ppd-&gt;pgtable_area;</span>
<span class="p_del">-		memset(pte_p, 0, sizeof(*pte_p) * PTRS_PER_PTE);</span>
<span class="p_del">-		ppd-&gt;pgtable_area += sizeof(*pte_p) * PTRS_PER_PTE;</span>
<span class="p_del">-</span>
<span class="p_del">-		pmd = native_make_pmd((pteval_t)pte_p + PMD_FLAGS);</span>
<span class="p_del">-		native_set_pmd(pmd_p, pmd);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	pte_p += pte_index(ppd-&gt;vaddr);</span>
<span class="p_del">-	if (!native_pte_val(*pte_p))</span>
<span class="p_del">-		native_set_pte(pte_p, native_make_pte(ppd-&gt;paddr | ppd-&gt;pte_flags));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void __init __sme_map_range_pmd(struct sme_populate_pgd_data *ppd)
 {
 	while (ppd-&gt;vaddr &lt; ppd-&gt;vaddr_end) {
<span class="p_header">diff --git a/arch/x86/mm/mem_encrypt_identity.c b/arch/x86/mm/mem_encrypt_identity.c</span>
new file mode 100644
<span class="p_header">index 000000000000..dbf7a98f657d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/x86/mm/mem_encrypt_identity.c</span>
<span class="p_chunk">@@ -0,0 +1,134 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * AMD Memory Encryption Support</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Advanced Micro Devices, Inc.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Author: Tom Lendacky &lt;thomas.lendacky@amd.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define DISABLE_BRANCH_PROFILING</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &quot;mm_internal.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#define PGD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define P4D_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define PUD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_add">+#define PMD_FLAGS		_KERNPG_TABLE_NOENC</span>
<span class="p_add">+</span>
<span class="p_add">+static pmd_t __init *sme_prepare_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd_p;</span>
<span class="p_add">+	p4d_t *p4d_p;</span>
<span class="p_add">+	pud_t *pud_p;</span>
<span class="p_add">+	pmd_t *pmd_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	pgd_p = ppd-&gt;pgd + pgd_index(ppd-&gt;vaddr);</span>
<span class="p_add">+	if (native_pgd_val(*pgd_p)) {</span>
<span class="p_add">+		if (IS_ENABLED(CONFIG_X86_5LEVEL))</span>
<span class="p_add">+			p4d_p = (p4d_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pud_p = (pud_t *)(native_pgd_val(*pgd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pgd_t pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_add">+			p4d_p = ppd-&gt;pgtable_area;</span>
<span class="p_add">+			memset(p4d_p, 0, sizeof(*p4d_p) * PTRS_PER_P4D);</span>
<span class="p_add">+			ppd-&gt;pgtable_area += sizeof(*p4d_p) * PTRS_PER_P4D;</span>
<span class="p_add">+</span>
<span class="p_add">+			pgd = native_make_pgd((pgdval_t)p4d_p + PGD_FLAGS);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pud_p = ppd-&gt;pgtable_area;</span>
<span class="p_add">+			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="p_add">+			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="p_add">+</span>
<span class="p_add">+			pgd = native_make_pgd((pgdval_t)pud_p + PGD_FLAGS);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		native_set_pgd(pgd_p, pgd);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_X86_5LEVEL)) {</span>
<span class="p_add">+		p4d_p += p4d_index(ppd-&gt;vaddr);</span>
<span class="p_add">+		if (native_p4d_val(*p4d_p)) {</span>
<span class="p_add">+			pud_p = (pud_t *)(native_p4d_val(*p4d_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			p4d_t p4d;</span>
<span class="p_add">+</span>
<span class="p_add">+			pud_p = ppd-&gt;pgtable_area;</span>
<span class="p_add">+			memset(pud_p, 0, sizeof(*pud_p) * PTRS_PER_PUD);</span>
<span class="p_add">+			ppd-&gt;pgtable_area += sizeof(*pud_p) * PTRS_PER_PUD;</span>
<span class="p_add">+</span>
<span class="p_add">+			p4d = native_make_p4d((pudval_t)pud_p + P4D_FLAGS);</span>
<span class="p_add">+			native_set_p4d(p4d_p, p4d);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pud_p += pud_index(ppd-&gt;vaddr);</span>
<span class="p_add">+	if (native_pud_val(*pud_p)) {</span>
<span class="p_add">+		if (native_pud_val(*pud_p) &amp; _PAGE_PSE)</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		pmd_p = (pmd_t *)(native_pud_val(*pud_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pud_t pud;</span>
<span class="p_add">+</span>
<span class="p_add">+		pmd_p = ppd-&gt;pgtable_area;</span>
<span class="p_add">+		memset(pmd_p, 0, sizeof(*pmd_p) * PTRS_PER_PMD);</span>
<span class="p_add">+		ppd-&gt;pgtable_area += sizeof(*pmd_p) * PTRS_PER_PMD;</span>
<span class="p_add">+</span>
<span class="p_add">+		pud = native_make_pud((pmdval_t)pmd_p + PUD_FLAGS);</span>
<span class="p_add">+		native_set_pud(pud_p, pud);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return pmd_p;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init sme_populate_pgd_large(struct sme_populate_pgd_data *ppd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="p_add">+	if (!pmd_p)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="p_add">+	if (!native_pmd_val(*pmd_p) || !(native_pmd_val(*pmd_p) &amp; _PAGE_PSE))</span>
<span class="p_add">+		native_set_pmd(pmd_p, native_make_pmd(ppd-&gt;paddr | ppd-&gt;pmd_flags));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init sme_populate_pgd(struct sme_populate_pgd_data *ppd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd_p;</span>
<span class="p_add">+	pte_t *pte_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd_p = sme_prepare_pgd(ppd);</span>
<span class="p_add">+	if (!pmd_p)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd_p += pmd_index(ppd-&gt;vaddr);</span>
<span class="p_add">+	if (native_pmd_val(*pmd_p)) {</span>
<span class="p_add">+		if (native_pmd_val(*pmd_p) &amp; _PAGE_PSE)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		pte_p = (pte_t *)(native_pmd_val(*pmd_p) &amp; ~PTE_FLAGS_MASK);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		pmd_t pmd;</span>
<span class="p_add">+</span>
<span class="p_add">+		pte_p = ppd-&gt;pgtable_area;</span>
<span class="p_add">+		memset(pte_p, 0, sizeof(*pte_p) * PTRS_PER_PTE);</span>
<span class="p_add">+		ppd-&gt;pgtable_area += sizeof(*pte_p) * PTRS_PER_PTE;</span>
<span class="p_add">+</span>
<span class="p_add">+		pmd = native_make_pmd((pteval_t)pte_p + PMD_FLAGS);</span>
<span class="p_add">+		native_set_pmd(pmd_p, pmd);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pte_p += pte_index(ppd-&gt;vaddr);</span>
<span class="p_add">+	if (!native_pte_val(*pte_p))</span>
<span class="p_add">+		native_set_pte(pte_p, native_make_pte(ppd-&gt;paddr | ppd-&gt;pte_flags));</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/mm/mm_internal.h b/arch/x86/mm/mm_internal.h</span>
<span class="p_header">index 4e1f6e1b8159..b3ab82ae9b12 100644</span>
<span class="p_header">--- a/arch/x86/mm/mm_internal.h</span>
<span class="p_header">+++ b/arch/x86/mm/mm_internal.h</span>
<span class="p_chunk">@@ -19,4 +19,18 @@</span> <span class="p_context"> extern int after_bootmem;</span>
 
 void update_cache_mode_entry(unsigned entry, enum page_cache_mode cache);
 
<span class="p_add">+struct sme_populate_pgd_data {</span>
<span class="p_add">+	void	*pgtable_area;</span>
<span class="p_add">+	pgd_t	*pgd;</span>
<span class="p_add">+</span>
<span class="p_add">+	pmdval_t pmd_flags;</span>
<span class="p_add">+	pteval_t pte_flags;</span>
<span class="p_add">+	unsigned long paddr;</span>
<span class="p_add">+</span>
<span class="p_add">+	unsigned long vaddr;</span>
<span class="p_add">+	unsigned long vaddr_end;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+void __init sme_populate_pgd(struct sme_populate_pgd_data *ppd);</span>
<span class="p_add">+void __init sme_populate_pgd_large(struct sme_populate_pgd_data *ppd);</span>
 #endif	/* __X86_MM_INTERNAL_H */

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



