
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.14.20 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.14.20</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 17, 2018, 1:25 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180217132546.GB18919@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10226191/mbox/"
   >mbox</a>
|
   <a href="/patch/10226191/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10226191/">/patch/10226191/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	2A136602CB for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 17 Feb 2018 13:32:50 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A794B28B0B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 17 Feb 2018 13:32:49 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 9663E28FF8; Sat, 17 Feb 2018 13:32:49 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3228B28B0B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sat, 17 Feb 2018 13:32:34 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751322AbeBQNc0 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sat, 17 Feb 2018 08:32:26 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:47548 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751159AbeBQNcB (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sat, 17 Feb 2018 08:32:01 -0500
Received: from localhost (unknown [205.185.223.213])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id B0EF2DE8;
	Sat, 17 Feb 2018 13:31:46 +0000 (UTC)
Date: Sat, 17 Feb 2018 14:25:46 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.14.20
Message-ID: &lt;20180217132546.GB18919@kroah.com&gt;
References: &lt;20180217132540.GA18919@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180217132540.GA18919@kroah.com&gt;
User-Agent: Mutt/1.9.3 (2018-01-21)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Feb. 17, 2018, 1:25 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/arm64/silicon-errata.txt b/Documentation/arm64/silicon-errata.txt</span>
<span class="p_header">index 66e8ce14d23d..f3d0d316d5f1 100644</span>
<span class="p_header">--- a/Documentation/arm64/silicon-errata.txt</span>
<span class="p_header">+++ b/Documentation/arm64/silicon-errata.txt</span>
<span class="p_chunk">@@ -71,6 +71,7 @@</span> <span class="p_context"> stable kernels.</span>
 | Hisilicon      | Hip0{5,6,7}     | #161010101      | HISILICON_ERRATUM_161010101 |
 | Hisilicon      | Hip0{6,7}       | #161010701      | N/A                         |
 |                |                 |                 |                             |
<span class="p_del">-| Qualcomm Tech. | Falkor v1       | E1003           | QCOM_FALKOR_ERRATUM_1003    |</span>
<span class="p_add">+| Qualcomm Tech. | Kryo/Falkor v1  | E1003           | QCOM_FALKOR_ERRATUM_1003    |</span>
 | Qualcomm Tech. | Falkor v1       | E1009           | QCOM_FALKOR_ERRATUM_1009    |
 | Qualcomm Tech. | QDF2400 ITS     | E0065           | QCOM_QDF2400_ERRATUM_0065   |
<span class="p_add">+| Qualcomm Tech. | Falkor v{1,2}   | E1041           | QCOM_FALKOR_ERRATUM_1041    |</span>
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 76a0b13623f4..33176140f133 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 # SPDX-License-Identifier: GPL-2.0
 VERSION = 4
 PATCHLEVEL = 14
<span class="p_del">-SUBLEVEL = 19</span>
<span class="p_add">+SUBLEVEL = 20</span>
 EXTRAVERSION =
 NAME = Petit Gorille
 
<span class="p_chunk">@@ -416,7 +416,8 @@</span> <span class="p_context"> export MAKE AWK GENKSYMS INSTALLKERNEL PERL PYTHON UTS_MACHINE</span>
 export HOSTCXX HOSTCXXFLAGS LDFLAGS_MODULE CHECK CHECKFLAGS
 
 export KBUILD_CPPFLAGS NOSTDINC_FLAGS LINUXINCLUDE OBJCOPYFLAGS LDFLAGS
<span class="p_del">-export KBUILD_CFLAGS CFLAGS_KERNEL CFLAGS_MODULE CFLAGS_KASAN CFLAGS_UBSAN</span>
<span class="p_add">+export KBUILD_CFLAGS CFLAGS_KERNEL CFLAGS_MODULE</span>
<span class="p_add">+export CFLAGS_KASAN CFLAGS_KASAN_NOSANITIZE CFLAGS_UBSAN</span>
 export KBUILD_AFLAGS AFLAGS_KERNEL AFLAGS_MODULE
 export KBUILD_AFLAGS_MODULE KBUILD_CFLAGS_MODULE KBUILD_LDFLAGS_MODULE
 export KBUILD_AFLAGS_KERNEL KBUILD_CFLAGS_KERNEL
<span class="p_header">diff --git a/arch/alpha/include/asm/futex.h b/arch/alpha/include/asm/futex.h</span>
<span class="p_header">index d2e4da93e68c..ca3322536f72 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/futex.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/futex.h</span>
<span class="p_chunk">@@ -20,8 +20,8 @@</span> <span class="p_context"></span>
 	&quot;3:	.subsection 2\n&quot;				\
 	&quot;4:	br	1b\n&quot;					\
 	&quot;	.previous\n&quot;					\
<span class="p_del">-	EXC(1b,3b,%1,$31)					\</span>
<span class="p_del">-	EXC(2b,3b,%1,$31)					\</span>
<span class="p_add">+	EXC(1b,3b,$31,%1)					\</span>
<span class="p_add">+	EXC(2b,3b,$31,%1)					\</span>
 	:	&quot;=&amp;r&quot; (oldval), &quot;=&amp;r&quot;(ret)			\
 	:	&quot;r&quot; (uaddr), &quot;r&quot;(oparg)				\
 	:	&quot;memory&quot;)
<span class="p_chunk">@@ -82,8 +82,8 @@</span> <span class="p_context"> futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
 	&quot;3:	.subsection 2\n&quot;
 	&quot;4:	br	1b\n&quot;
 	&quot;	.previous\n&quot;
<span class="p_del">-	EXC(1b,3b,%0,$31)</span>
<span class="p_del">-	EXC(2b,3b,%0,$31)</span>
<span class="p_add">+	EXC(1b,3b,$31,%0)</span>
<span class="p_add">+	EXC(2b,3b,$31,%0)</span>
 	:	&quot;+r&quot;(ret), &quot;=&amp;r&quot;(prev), &quot;=&amp;r&quot;(cmp)
 	:	&quot;r&quot;(uaddr), &quot;r&quot;((long)(int)oldval), &quot;r&quot;(newval)
 	:	&quot;memory&quot;);
<span class="p_header">diff --git a/arch/alpha/kernel/osf_sys.c b/arch/alpha/kernel/osf_sys.c</span>
<span class="p_header">index ce3a675c0c4b..75a5c35a2067 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/osf_sys.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/osf_sys.c</span>
<span class="p_chunk">@@ -964,8 +964,8 @@</span> <span class="p_context"> static inline long</span>
 put_tv32(struct timeval32 __user *o, struct timeval *i)
 {
 	return copy_to_user(o, &amp;(struct timeval32){
<span class="p_del">-				.tv_sec = o-&gt;tv_sec,</span>
<span class="p_del">-				.tv_usec = o-&gt;tv_usec},</span>
<span class="p_add">+				.tv_sec = i-&gt;tv_sec,</span>
<span class="p_add">+				.tv_usec = i-&gt;tv_usec},</span>
 			    sizeof(struct timeval32));
 }
 
<span class="p_header">diff --git a/arch/alpha/kernel/pci_impl.h b/arch/alpha/kernel/pci_impl.h</span>
<span class="p_header">index 26231601630e..f332d88ffaff 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/pci_impl.h</span>
<span class="p_header">+++ b/arch/alpha/kernel/pci_impl.h</span>
<span class="p_chunk">@@ -144,7 +144,8 @@</span> <span class="p_context"> struct pci_iommu_arena</span>
 };
 
 #if defined(CONFIG_ALPHA_SRM) &amp;&amp; \
<span class="p_del">-    (defined(CONFIG_ALPHA_CIA) || defined(CONFIG_ALPHA_LCA))</span>
<span class="p_add">+    (defined(CONFIG_ALPHA_CIA) || defined(CONFIG_ALPHA_LCA) || \</span>
<span class="p_add">+     defined(CONFIG_ALPHA_AVANTI))</span>
 # define NEED_SRM_SAVE_RESTORE
 #else
 # undef NEED_SRM_SAVE_RESTORE
<span class="p_header">diff --git a/arch/alpha/kernel/process.c b/arch/alpha/kernel/process.c</span>
<span class="p_header">index 74bfb1f2d68e..3a885253f486 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/process.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/process.c</span>
<span class="p_chunk">@@ -269,12 +269,13 @@</span> <span class="p_context"> copy_thread(unsigned long clone_flags, unsigned long usp,</span>
 	   application calling fork.  */
 	if (clone_flags &amp; CLONE_SETTLS)
 		childti-&gt;pcb.unique = regs-&gt;r20;
<span class="p_add">+	else</span>
<span class="p_add">+		regs-&gt;r20 = 0;	/* OSF/1 has some strange fork() semantics.  */</span>
 	childti-&gt;pcb.usp = usp ?: rdusp();
 	*childregs = *regs;
 	childregs-&gt;r0 = 0;
 	childregs-&gt;r19 = 0;
 	childregs-&gt;r20 = 1;	/* OSF/1 has some strange fork() semantics.  */
<span class="p_del">-	regs-&gt;r20 = 0;</span>
 	stack = ((struct switch_stack *) regs) - 1;
 	*childstack = *stack;
 	childstack-&gt;r26 = (unsigned long) ret_from_fork;
<span class="p_header">diff --git a/arch/alpha/kernel/traps.c b/arch/alpha/kernel/traps.c</span>
<span class="p_header">index 4bd99a7b1c41..f43bd05dede2 100644</span>
<span class="p_header">--- a/arch/alpha/kernel/traps.c</span>
<span class="p_header">+++ b/arch/alpha/kernel/traps.c</span>
<span class="p_chunk">@@ -160,11 +160,16 @@</span> <span class="p_context"> void show_stack(struct task_struct *task, unsigned long *sp)</span>
 	for(i=0; i &lt; kstack_depth_to_print; i++) {
 		if (((long) stack &amp; (THREAD_SIZE-1)) == 0)
 			break;
<span class="p_del">-		if (i &amp;&amp; ((i % 4) == 0))</span>
<span class="p_del">-			printk(&quot;\n       &quot;);</span>
<span class="p_del">-		printk(&quot;%016lx &quot;, *stack++);</span>
<span class="p_add">+		if ((i % 4) == 0) {</span>
<span class="p_add">+			if (i)</span>
<span class="p_add">+				pr_cont(&quot;\n&quot;);</span>
<span class="p_add">+			printk(&quot;       &quot;);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pr_cont(&quot; &quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pr_cont(&quot;%016lx&quot;, *stack++);</span>
 	}
<span class="p_del">-	printk(&quot;\n&quot;);</span>
<span class="p_add">+	pr_cont(&quot;\n&quot;);</span>
 	dik_show_trace(sp);
 }
 
<span class="p_header">diff --git a/arch/arm/crypto/crc32-ce-glue.c b/arch/arm/crypto/crc32-ce-glue.c</span>
<span class="p_header">index 1b0e0e86ee9c..96e62ec105d0 100644</span>
<span class="p_header">--- a/arch/arm/crypto/crc32-ce-glue.c</span>
<span class="p_header">+++ b/arch/arm/crypto/crc32-ce-glue.c</span>
<span class="p_chunk">@@ -188,6 +188,7 @@</span> <span class="p_context"> static struct shash_alg crc32_pmull_algs[] = { {</span>
 	.base.cra_name		= &quot;crc32&quot;,
 	.base.cra_driver_name	= &quot;crc32-arm-ce&quot;,
 	.base.cra_priority	= 200,
<span class="p_add">+	.base.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 	.base.cra_blocksize	= 1,
 	.base.cra_module	= THIS_MODULE,
 }, {
<span class="p_chunk">@@ -203,6 +204,7 @@</span> <span class="p_context"> static struct shash_alg crc32_pmull_algs[] = { {</span>
 	.base.cra_name		= &quot;crc32c&quot;,
 	.base.cra_driver_name	= &quot;crc32c-arm-ce&quot;,
 	.base.cra_priority	= 200,
<span class="p_add">+	.base.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 	.base.cra_blocksize	= 1,
 	.base.cra_module	= THIS_MODULE,
 } };
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_host.h b/arch/arm/include/asm/kvm_host.h</span>
<span class="p_header">index 4a879f6ff13b..31fbb9285f62 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -293,4 +293,10 @@</span> <span class="p_context"> int kvm_arm_vcpu_arch_get_attr(struct kvm_vcpu *vcpu,</span>
 int kvm_arm_vcpu_arch_has_attr(struct kvm_vcpu *vcpu,
 			       struct kvm_device_attr *attr);
 
<span class="p_add">+static inline bool kvm_arm_harden_branch_predictor(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* No way to detect it yet, pretend it is not there. */</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* __ARM_KVM_HOST_H__ */
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_mmu.h b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">index fa6f2174276b..eb46fc81a440 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -221,6 +221,16 @@</span> <span class="p_context"> static inline unsigned int kvm_get_vmid_bits(void)</span>
 	return 8;
 }
 
<span class="p_add">+static inline void *kvm_get_hyp_vector(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kvm_ksym_ref(__kvm_hyp_vector);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int kvm_map_vectors(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif	/* !__ASSEMBLY__ */
 
 #endif /* __ARM_KVM_MMU_H__ */
<span class="p_header">diff --git a/arch/arm/include/asm/kvm_psci.h b/arch/arm/include/asm/kvm_psci.h</span>
deleted file mode 100644
<span class="p_header">index 6bda945d31fa..000000000000</span>
<span class="p_header">--- a/arch/arm/include/asm/kvm_psci.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,27 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2012 - ARM Ltd</span>
<span class="p_del">- * Author: Marc Zyngier &lt;marc.zyngier@arm.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_del">- * published by the Free Software Foundation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef __ARM_KVM_PSCI_H__</span>
<span class="p_del">-#define __ARM_KVM_PSCI_H__</span>
<span class="p_del">-</span>
<span class="p_del">-#define KVM_ARM_PSCI_0_1	1</span>
<span class="p_del">-#define KVM_ARM_PSCI_0_2	2</span>
<span class="p_del">-</span>
<span class="p_del">-int kvm_psci_version(struct kvm_vcpu *vcpu);</span>
<span class="p_del">-int kvm_psci_call(struct kvm_vcpu *vcpu);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* __ARM_KVM_PSCI_H__ */</span>
<span class="p_header">diff --git a/arch/arm/kvm/handle_exit.c b/arch/arm/kvm/handle_exit.c</span>
<span class="p_header">index cf8bf6bf87c4..910bd8dabb3c 100644</span>
<span class="p_header">--- a/arch/arm/kvm/handle_exit.c</span>
<span class="p_header">+++ b/arch/arm/kvm/handle_exit.c</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/kvm_emulate.h&gt;
 #include &lt;asm/kvm_coproc.h&gt;
 #include &lt;asm/kvm_mmu.h&gt;
<span class="p_del">-#include &lt;asm/kvm_psci.h&gt;</span>
<span class="p_add">+#include &lt;kvm/arm_psci.h&gt;</span>
 #include &lt;trace/events/kvm.h&gt;
 
 #include &quot;trace.h&quot;
<span class="p_chunk">@@ -36,9 +36,9 @@</span> <span class="p_context"> static int handle_hvc(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 		      kvm_vcpu_hvc_get_imm(vcpu));
 	vcpu-&gt;stat.hvc_exit_stat++;
 
<span class="p_del">-	ret = kvm_psci_call(vcpu);</span>
<span class="p_add">+	ret = kvm_hvc_call_handler(vcpu);</span>
 	if (ret &lt; 0) {
<span class="p_del">-		kvm_inject_undefined(vcpu);</span>
<span class="p_add">+		vcpu_set_reg(vcpu, 0, ~0UL);</span>
 		return 1;
 	}
 
<span class="p_chunk">@@ -47,7 +47,16 @@</span> <span class="p_context"> static int handle_hvc(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 
 static int handle_smc(struct kvm_vcpu *vcpu, struct kvm_run *run)
 {
<span class="p_del">-	kvm_inject_undefined(vcpu);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * &quot;If an SMC instruction executed at Non-secure EL1 is</span>
<span class="p_add">+	 * trapped to EL2 because HCR_EL2.TSC is 1, the exception is a</span>
<span class="p_add">+	 * Trap exception, not a Secure Monitor Call exception [...]&quot;</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We need to advance the PC after the trap, as it would</span>
<span class="p_add">+	 * otherwise return to the same address...</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vcpu_set_reg(vcpu, 0, ~0UL);</span>
<span class="p_add">+	kvm_skip_instr(vcpu, kvm_vcpu_trap_il_is32bit(vcpu));</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig</span>
<span class="p_header">index 0df64a6a56d4..c2abb4e88ff2 100644</span>
<span class="p_header">--- a/arch/arm64/Kconfig</span>
<span class="p_header">+++ b/arch/arm64/Kconfig</span>
<span class="p_chunk">@@ -504,20 +504,13 @@</span> <span class="p_context"> config CAVIUM_ERRATUM_30115</span>
 config QCOM_FALKOR_ERRATUM_1003
 	bool &quot;Falkor E1003: Incorrect translation due to ASID change&quot;
 	default y
<span class="p_del">-	select ARM64_PAN if ARM64_SW_TTBR0_PAN</span>
 	help
 	  On Falkor v1, an incorrect ASID may be cached in the TLB when ASID
<span class="p_del">-	  and BADDR are changed together in TTBRx_EL1. The workaround for this</span>
<span class="p_del">-	  issue is to use a reserved ASID in cpu_do_switch_mm() before</span>
<span class="p_del">-	  switching to the new ASID. Saying Y here selects ARM64_PAN if</span>
<span class="p_del">-	  ARM64_SW_TTBR0_PAN is selected. This is done because implementing and</span>
<span class="p_del">-	  maintaining the E1003 workaround in the software PAN emulation code</span>
<span class="p_del">-	  would be an unnecessary complication. The affected Falkor v1 CPU</span>
<span class="p_del">-	  implements ARMv8.1 hardware PAN support and using hardware PAN</span>
<span class="p_del">-	  support versus software PAN emulation is mutually exclusive at</span>
<span class="p_del">-	  runtime.</span>
<span class="p_del">-</span>
<span class="p_del">-	  If unsure, say Y.</span>
<span class="p_add">+	  and BADDR are changed together in TTBRx_EL1. Since we keep the ASID</span>
<span class="p_add">+	  in TTBR1_EL1, this situation only occurs in the entry trampoline and</span>
<span class="p_add">+	  then only for entries in the walk cache, since the leaf translation</span>
<span class="p_add">+	  is unchanged. Work around the erratum by invalidating the walk cache</span>
<span class="p_add">+	  entries for the trampoline before entering the kernel proper.</span>
 
 config QCOM_FALKOR_ERRATUM_1009
 	bool &quot;Falkor E1009: Prematurely complete a DSB after a TLBI&quot;
<span class="p_chunk">@@ -539,6 +532,16 @@</span> <span class="p_context"> config QCOM_QDF2400_ERRATUM_0065</span>
 
 	  If unsure, say Y.
 
<span class="p_add">+config QCOM_FALKOR_ERRATUM_E1041</span>
<span class="p_add">+	bool &quot;Falkor E1041: Speculative instruction fetches might cause errant memory access&quot;</span>
<span class="p_add">+	default y</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Falkor CPU may speculatively fetch instructions from an improper</span>
<span class="p_add">+	  memory location when MMU translation is changed from SCTLR_ELn[M]=1</span>
<span class="p_add">+	  to SCTLR_ELn[M]=0. Prefix an ISB instruction to fix the problem.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say Y.</span>
<span class="p_add">+</span>
 endmenu
 
 
<span class="p_chunk">@@ -803,6 +806,35 @@</span> <span class="p_context"> config FORCE_MAX_ZONEORDER</span>
 	  However for 4K, we choose a higher default value, 11 as opposed to 10, giving us
 	  4M allocations matching the default size used by generic code.
 
<span class="p_add">+config UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+	bool &quot;Unmap kernel when running in userspace (aka \&quot;KAISER\&quot;)&quot; if EXPERT</span>
<span class="p_add">+	default y</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Speculation attacks against some high-performance processors can</span>
<span class="p_add">+	  be used to bypass MMU permission checks and leak kernel data to</span>
<span class="p_add">+	  userspace. This can be defended against by unmapping the kernel</span>
<span class="p_add">+	  when running in userspace, mapping it back in on exception entry</span>
<span class="p_add">+	  via a trampoline page in the vector table.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say Y.</span>
<span class="p_add">+</span>
<span class="p_add">+config HARDEN_BRANCH_PREDICTOR</span>
<span class="p_add">+	bool &quot;Harden the branch predictor against aliasing attacks&quot; if EXPERT</span>
<span class="p_add">+	default y</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Speculation attacks against some high-performance processors rely on</span>
<span class="p_add">+	  being able to manipulate the branch predictor for a victim context by</span>
<span class="p_add">+	  executing aliasing branches in the attacker context.  Such attacks</span>
<span class="p_add">+	  can be partially mitigated against by clearing internal branch</span>
<span class="p_add">+	  predictor state and limiting the prediction logic in some situations.</span>
<span class="p_add">+</span>
<span class="p_add">+	  This config option will take CPU-specific actions to harden the</span>
<span class="p_add">+	  branch predictor against aliasing attacks and may rely on specific</span>
<span class="p_add">+	  instruction sequences or control bits being set by the system</span>
<span class="p_add">+	  firmware.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say Y.</span>
<span class="p_add">+</span>
 menuconfig ARMV8_DEPRECATED
 	bool &quot;Emulate deprecated/obsolete ARMv8 instructions&quot;
 	depends on COMPAT
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-7040-db.dts b/arch/arm64/boot/dts/marvell/armada-7040-db.dts</span>
<span class="p_header">index 9c3bdf87e543..51327645b3fb 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-7040-db.dts</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-7040-db.dts</span>
<span class="p_chunk">@@ -61,6 +61,12 @@</span> <span class="p_context"></span>
 		reg = &lt;0x0 0x0 0x0 0x80000000&gt;;
 	};
 
<span class="p_add">+	aliases {</span>
<span class="p_add">+		ethernet0 = &amp;cpm_eth0;</span>
<span class="p_add">+		ethernet1 = &amp;cpm_eth1;</span>
<span class="p_add">+		ethernet2 = &amp;cpm_eth2;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 	cpm_reg_usb3_0_vbus: cpm-usb3-0-vbus {
 		compatible = &quot;regulator-fixed&quot;;
 		regulator-name = &quot;usb3h0-vbus&quot;;
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-8040-db.dts b/arch/arm64/boot/dts/marvell/armada-8040-db.dts</span>
<span class="p_header">index 0d7b2ae46610..a4f82f1efbbc 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-8040-db.dts</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-8040-db.dts</span>
<span class="p_chunk">@@ -61,6 +61,13 @@</span> <span class="p_context"></span>
 		reg = &lt;0x0 0x0 0x0 0x80000000&gt;;
 	};
 
<span class="p_add">+	aliases {</span>
<span class="p_add">+		ethernet0 = &amp;cpm_eth0;</span>
<span class="p_add">+		ethernet1 = &amp;cpm_eth2;</span>
<span class="p_add">+		ethernet2 = &amp;cps_eth0;</span>
<span class="p_add">+		ethernet3 = &amp;cps_eth1;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 	cpm_reg_usb3_0_vbus: cpm-usb3-0-vbus {
 		compatible = &quot;regulator-fixed&quot;;
 		regulator-name = &quot;cpm-usb3h0-vbus&quot;;
<span class="p_header">diff --git a/arch/arm64/boot/dts/marvell/armada-8040-mcbin.dts b/arch/arm64/boot/dts/marvell/armada-8040-mcbin.dts</span>
<span class="p_header">index acf5c7d16d79..2b6b792dab93 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/marvell/armada-8040-mcbin.dts</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/marvell/armada-8040-mcbin.dts</span>
<span class="p_chunk">@@ -62,6 +62,12 @@</span> <span class="p_context"></span>
 		reg = &lt;0x0 0x0 0x0 0x80000000&gt;;
 	};
 
<span class="p_add">+	aliases {</span>
<span class="p_add">+		ethernet0 = &amp;cpm_eth0;</span>
<span class="p_add">+		ethernet1 = &amp;cps_eth0;</span>
<span class="p_add">+		ethernet2 = &amp;cps_eth1;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 	/* Regulator labels correspond with schematics */
 	v_3_3: regulator-3-3v {
 		compatible = &quot;regulator-fixed&quot;;
<span class="p_header">diff --git a/arch/arm64/crypto/crc32-ce-glue.c b/arch/arm64/crypto/crc32-ce-glue.c</span>
<span class="p_header">index 624f4137918c..34b4e3d46aab 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/crc32-ce-glue.c</span>
<span class="p_header">+++ b/arch/arm64/crypto/crc32-ce-glue.c</span>
<span class="p_chunk">@@ -185,6 +185,7 @@</span> <span class="p_context"> static struct shash_alg crc32_pmull_algs[] = { {</span>
 	.base.cra_name		= &quot;crc32&quot;,
 	.base.cra_driver_name	= &quot;crc32-arm64-ce&quot;,
 	.base.cra_priority	= 200,
<span class="p_add">+	.base.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 	.base.cra_blocksize	= 1,
 	.base.cra_module	= THIS_MODULE,
 }, {
<span class="p_chunk">@@ -200,6 +201,7 @@</span> <span class="p_context"> static struct shash_alg crc32_pmull_algs[] = { {</span>
 	.base.cra_name		= &quot;crc32c&quot;,
 	.base.cra_driver_name	= &quot;crc32c-arm64-ce&quot;,
 	.base.cra_priority	= 200,
<span class="p_add">+	.base.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 	.base.cra_blocksize	= 1,
 	.base.cra_module	= THIS_MODULE,
 } };
<span class="p_header">diff --git a/arch/arm64/include/asm/asm-uaccess.h b/arch/arm64/include/asm/asm-uaccess.h</span>
<span class="p_header">index b3da6c886835..dd49c3567f20 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/asm-uaccess.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/asm-uaccess.h</span>
<span class="p_chunk">@@ -4,6 +4,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/alternative.h&gt;
 #include &lt;asm/kernel-pgtable.h&gt;
<span class="p_add">+#include &lt;asm/mmu.h&gt;</span>
 #include &lt;asm/sysreg.h&gt;
 #include &lt;asm/assembler.h&gt;
 
<span class="p_chunk">@@ -13,51 +14,62 @@</span> <span class="p_context"></span>
 #ifdef CONFIG_ARM64_SW_TTBR0_PAN
 	.macro	__uaccess_ttbr0_disable, tmp1
 	mrs	\tmp1, ttbr1_el1		// swapper_pg_dir
<span class="p_add">+	bic	\tmp1, \tmp1, #TTBR_ASID_MASK</span>
 	add	\tmp1, \tmp1, #SWAPPER_DIR_SIZE	// reserved_ttbr0 at the end of swapper_pg_dir
 	msr	ttbr0_el1, \tmp1		// set reserved TTBR0_EL1
 	isb
<span class="p_add">+	sub	\tmp1, \tmp1, #SWAPPER_DIR_SIZE</span>
<span class="p_add">+	msr	ttbr1_el1, \tmp1		// set reserved ASID</span>
<span class="p_add">+	isb</span>
 	.endm
 
<span class="p_del">-	.macro	__uaccess_ttbr0_enable, tmp1</span>
<span class="p_add">+	.macro	__uaccess_ttbr0_enable, tmp1, tmp2</span>
 	get_thread_info \tmp1
 	ldr	\tmp1, [\tmp1, #TSK_TI_TTBR0]	// load saved TTBR0_EL1
<span class="p_add">+	mrs	\tmp2, ttbr1_el1</span>
<span class="p_add">+	extr    \tmp2, \tmp2, \tmp1, #48</span>
<span class="p_add">+	ror     \tmp2, \tmp2, #16</span>
<span class="p_add">+	msr	ttbr1_el1, \tmp2		// set the active ASID</span>
<span class="p_add">+	isb</span>
 	msr	ttbr0_el1, \tmp1		// set the non-PAN TTBR0_EL1
 	isb
 	.endm
 
<span class="p_del">-	.macro	uaccess_ttbr0_disable, tmp1</span>
<span class="p_add">+	.macro	uaccess_ttbr0_disable, tmp1, tmp2</span>
 alternative_if_not ARM64_HAS_PAN
<span class="p_add">+	save_and_disable_irq \tmp2		// avoid preemption</span>
 	__uaccess_ttbr0_disable \tmp1
<span class="p_add">+	restore_irq \tmp2</span>
 alternative_else_nop_endif
 	.endm
 
<span class="p_del">-	.macro	uaccess_ttbr0_enable, tmp1, tmp2</span>
<span class="p_add">+	.macro	uaccess_ttbr0_enable, tmp1, tmp2, tmp3</span>
 alternative_if_not ARM64_HAS_PAN
<span class="p_del">-	save_and_disable_irq \tmp2		// avoid preemption</span>
<span class="p_del">-	__uaccess_ttbr0_enable \tmp1</span>
<span class="p_del">-	restore_irq \tmp2</span>
<span class="p_add">+	save_and_disable_irq \tmp3		// avoid preemption</span>
<span class="p_add">+	__uaccess_ttbr0_enable \tmp1, \tmp2</span>
<span class="p_add">+	restore_irq \tmp3</span>
 alternative_else_nop_endif
 	.endm
 #else
<span class="p_del">-	.macro	uaccess_ttbr0_disable, tmp1</span>
<span class="p_add">+	.macro	uaccess_ttbr0_disable, tmp1, tmp2</span>
 	.endm
 
<span class="p_del">-	.macro	uaccess_ttbr0_enable, tmp1, tmp2</span>
<span class="p_add">+	.macro	uaccess_ttbr0_enable, tmp1, tmp2, tmp3</span>
 	.endm
 #endif
 
 /*
  * These macros are no-ops when UAO is present.
  */
<span class="p_del">-	.macro	uaccess_disable_not_uao, tmp1</span>
<span class="p_del">-	uaccess_ttbr0_disable \tmp1</span>
<span class="p_add">+	.macro	uaccess_disable_not_uao, tmp1, tmp2</span>
<span class="p_add">+	uaccess_ttbr0_disable \tmp1, \tmp2</span>
 alternative_if ARM64_ALT_PAN_NOT_UAO
 	SET_PSTATE_PAN(1)
 alternative_else_nop_endif
 	.endm
 
<span class="p_del">-	.macro	uaccess_enable_not_uao, tmp1, tmp2</span>
<span class="p_del">-	uaccess_ttbr0_enable \tmp1, \tmp2</span>
<span class="p_add">+	.macro	uaccess_enable_not_uao, tmp1, tmp2, tmp3</span>
<span class="p_add">+	uaccess_ttbr0_enable \tmp1, \tmp2, \tmp3</span>
 alternative_if ARM64_ALT_PAN_NOT_UAO
 	SET_PSTATE_PAN(0)
 alternative_else_nop_endif
<span class="p_header">diff --git a/arch/arm64/include/asm/assembler.h b/arch/arm64/include/asm/assembler.h</span>
<span class="p_header">index d58a6253c6ab..463619dcadd4 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/assembler.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/assembler.h</span>
<span class="p_chunk">@@ -25,7 +25,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/asm-offsets.h&gt;
 #include &lt;asm/cpufeature.h&gt;
<span class="p_del">-#include &lt;asm/mmu_context.h&gt;</span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable-hwdef.h&gt;
 #include &lt;asm/ptrace.h&gt;
<span class="p_chunk">@@ -96,6 +95,24 @@</span> <span class="p_context"></span>
 	dmb	\opt
 	.endm
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Value prediction barrier</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.macro	csdb</span>
<span class="p_add">+	hint	#20</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Sanitise a 64-bit bounded index wrt speculation, returning zero if out</span>
<span class="p_add">+ * of bounds.</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.macro	mask_nospec64, idx, limit, tmp</span>
<span class="p_add">+	sub	\tmp, \idx, \limit</span>
<span class="p_add">+	bic	\tmp, \tmp, \idx</span>
<span class="p_add">+	and	\idx, \idx, \tmp, asr #63</span>
<span class="p_add">+	csdb</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
 /*
  * NOP sequence
  */
<span class="p_chunk">@@ -464,39 +481,18 @@</span> <span class="p_context"> alternative_endif</span>
 	mrs	\rd, sp_el0
 	.endm
 
<span class="p_del">-/*</span>
<span class="p_del">- * Errata workaround prior to TTBR0_EL1 update</span>
<span class="p_del">- *</span>
<span class="p_del">- * 	val:	TTBR value with new BADDR, preserved</span>
<span class="p_del">- * 	tmp0:	temporary register, clobbered</span>
<span class="p_del">- * 	tmp1:	other temporary register, clobbered</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * Errata workaround prior to disable MMU. Insert an ISB immediately prior</span>
<span class="p_add">+ * to executing the MSR that will change SCTLR_ELn[M] from a value of 1 to 0.</span>
  */
<span class="p_del">-	.macro	pre_ttbr0_update_workaround, val, tmp0, tmp1</span>
<span class="p_del">-#ifdef CONFIG_QCOM_FALKOR_ERRATUM_1003</span>
<span class="p_del">-alternative_if ARM64_WORKAROUND_QCOM_FALKOR_E1003</span>
<span class="p_del">-	mrs	\tmp0, ttbr0_el1</span>
<span class="p_del">-	mov	\tmp1, #FALKOR_RESERVED_ASID</span>
<span class="p_del">-	bfi	\tmp0, \tmp1, #48, #16		// reserved ASID + old BADDR</span>
<span class="p_del">-	msr	ttbr0_el1, \tmp0</span>
<span class="p_add">+	.macro pre_disable_mmu_workaround</span>
<span class="p_add">+#ifdef CONFIG_QCOM_FALKOR_ERRATUM_E1041</span>
 	isb
<span class="p_del">-	bfi	\tmp0, \val, #0, #48		// reserved ASID + new BADDR</span>
<span class="p_del">-	msr	ttbr0_el1, \tmp0</span>
<span class="p_del">-	isb</span>
<span class="p_del">-alternative_else_nop_endif</span>
 #endif
 	.endm
 
<span class="p_del">-/*</span>
<span class="p_del">- * Errata workaround post TTBR0_EL1 update.</span>
<span class="p_del">- */</span>
<span class="p_del">-	.macro	post_ttbr0_update_workaround</span>
<span class="p_del">-#ifdef CONFIG_CAVIUM_ERRATUM_27456</span>
<span class="p_del">-alternative_if ARM64_WORKAROUND_CAVIUM_27456</span>
<span class="p_del">-	ic	iallu</span>
<span class="p_del">-	dsb	nsh</span>
<span class="p_del">-	isb</span>
<span class="p_del">-alternative_else_nop_endif</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	.macro	pte_to_phys, phys, pte</span>
<span class="p_add">+	and	\phys, \pte, #(((1 &lt;&lt; (48 - PAGE_SHIFT)) - 1) &lt;&lt; PAGE_SHIFT)</span>
 	.endm
 
 #endif	/* __ASM_ASSEMBLER_H */
<span class="p_header">diff --git a/arch/arm64/include/asm/barrier.h b/arch/arm64/include/asm/barrier.h</span>
<span class="p_header">index 0fe7e43b7fbc..0b0755c961ac 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/barrier.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/barrier.h</span>
<span class="p_chunk">@@ -31,6 +31,8 @@</span> <span class="p_context"></span>
 #define dmb(opt)	asm volatile(&quot;dmb &quot; #opt : : : &quot;memory&quot;)
 #define dsb(opt)	asm volatile(&quot;dsb &quot; #opt : : : &quot;memory&quot;)
 
<span class="p_add">+#define csdb()		asm volatile(&quot;hint #20&quot; : : : &quot;memory&quot;)</span>
<span class="p_add">+</span>
 #define mb()		dsb(sy)
 #define rmb()		dsb(ld)
 #define wmb()		dsb(st)
<span class="p_chunk">@@ -38,6 +40,27 @@</span> <span class="p_context"></span>
 #define dma_rmb()	dmb(oshld)
 #define dma_wmb()	dmb(oshst)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Generate a mask for array_index__nospec() that is ~0UL when 0 &lt;= idx &lt; sz</span>
<span class="p_add">+ * and 0 otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define array_index_mask_nospec array_index_mask_nospec</span>
<span class="p_add">+static inline unsigned long array_index_mask_nospec(unsigned long idx,</span>
<span class="p_add">+						    unsigned long sz)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	asm volatile(</span>
<span class="p_add">+	&quot;	cmp	%1, %2\n&quot;</span>
<span class="p_add">+	&quot;	sbc	%0, xzr, xzr\n&quot;</span>
<span class="p_add">+	: &quot;=r&quot; (mask)</span>
<span class="p_add">+	: &quot;r&quot; (idx), &quot;Ir&quot; (sz)</span>
<span class="p_add">+	: &quot;cc&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	csdb();</span>
<span class="p_add">+	return mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define __smp_mb()	dmb(ish)
 #define __smp_rmb()	dmb(ishld)
 #define __smp_wmb()	dmb(ishst)
<span class="p_header">diff --git a/arch/arm64/include/asm/cpucaps.h b/arch/arm64/include/asm/cpucaps.h</span>
<span class="p_header">index 8da621627d7c..2e7b236bc596 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/cpucaps.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/cpucaps.h</span>
<span class="p_chunk">@@ -40,7 +40,10 @@</span> <span class="p_context"></span>
 #define ARM64_WORKAROUND_858921			19
 #define ARM64_WORKAROUND_CAVIUM_30115		20
 #define ARM64_HAS_DCPOP				21
<span class="p_add">+#define ARM64_UNMAP_KERNEL_AT_EL0		23</span>
<span class="p_add">+#define ARM64_HARDEN_BRANCH_PREDICTOR		24</span>
<span class="p_add">+#define ARM64_HARDEN_BP_POST_GUEST_EXIT		25</span>
 
<span class="p_del">-#define ARM64_NCAPS				22</span>
<span class="p_add">+#define ARM64_NCAPS				26</span>
 
 #endif /* __ASM_CPUCAPS_H */
<span class="p_header">diff --git a/arch/arm64/include/asm/cputype.h b/arch/arm64/include/asm/cputype.h</span>
<span class="p_header">index 235e77d98261..be7bd19c87ec 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/cputype.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/cputype.h</span>
<span class="p_chunk">@@ -79,26 +79,37 @@</span> <span class="p_context"></span>
 #define ARM_CPU_PART_AEM_V8		0xD0F
 #define ARM_CPU_PART_FOUNDATION		0xD00
 #define ARM_CPU_PART_CORTEX_A57		0xD07
<span class="p_add">+#define ARM_CPU_PART_CORTEX_A72		0xD08</span>
 #define ARM_CPU_PART_CORTEX_A53		0xD03
 #define ARM_CPU_PART_CORTEX_A73		0xD09
<span class="p_add">+#define ARM_CPU_PART_CORTEX_A75		0xD0A</span>
 
 #define APM_CPU_PART_POTENZA		0x000
 
 #define CAVIUM_CPU_PART_THUNDERX	0x0A1
 #define CAVIUM_CPU_PART_THUNDERX_81XX	0x0A2
 #define CAVIUM_CPU_PART_THUNDERX_83XX	0x0A3
<span class="p_add">+#define CAVIUM_CPU_PART_THUNDERX2	0x0AF</span>
 
 #define BRCM_CPU_PART_VULCAN		0x516
 
 #define QCOM_CPU_PART_FALKOR_V1		0x800
<span class="p_add">+#define QCOM_CPU_PART_FALKOR		0xC00</span>
<span class="p_add">+#define QCOM_CPU_PART_KRYO		0x200</span>
 
 #define MIDR_CORTEX_A53 MIDR_CPU_MODEL(ARM_CPU_IMP_ARM, ARM_CPU_PART_CORTEX_A53)
 #define MIDR_CORTEX_A57 MIDR_CPU_MODEL(ARM_CPU_IMP_ARM, ARM_CPU_PART_CORTEX_A57)
<span class="p_add">+#define MIDR_CORTEX_A72 MIDR_CPU_MODEL(ARM_CPU_IMP_ARM, ARM_CPU_PART_CORTEX_A72)</span>
 #define MIDR_CORTEX_A73 MIDR_CPU_MODEL(ARM_CPU_IMP_ARM, ARM_CPU_PART_CORTEX_A73)
<span class="p_add">+#define MIDR_CORTEX_A75 MIDR_CPU_MODEL(ARM_CPU_IMP_ARM, ARM_CPU_PART_CORTEX_A75)</span>
 #define MIDR_THUNDERX	MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, CAVIUM_CPU_PART_THUNDERX)
 #define MIDR_THUNDERX_81XX MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, CAVIUM_CPU_PART_THUNDERX_81XX)
 #define MIDR_THUNDERX_83XX MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, CAVIUM_CPU_PART_THUNDERX_83XX)
<span class="p_add">+#define MIDR_CAVIUM_THUNDERX2 MIDR_CPU_MODEL(ARM_CPU_IMP_CAVIUM, CAVIUM_CPU_PART_THUNDERX2)</span>
<span class="p_add">+#define MIDR_BRCM_VULCAN MIDR_CPU_MODEL(ARM_CPU_IMP_BRCM, BRCM_CPU_PART_VULCAN)</span>
 #define MIDR_QCOM_FALKOR_V1 MIDR_CPU_MODEL(ARM_CPU_IMP_QCOM, QCOM_CPU_PART_FALKOR_V1)
<span class="p_add">+#define MIDR_QCOM_FALKOR MIDR_CPU_MODEL(ARM_CPU_IMP_QCOM, QCOM_CPU_PART_FALKOR)</span>
<span class="p_add">+#define MIDR_QCOM_KRYO MIDR_CPU_MODEL(ARM_CPU_IMP_QCOM, QCOM_CPU_PART_KRYO)</span>
 
 #ifndef __ASSEMBLY__
 
<span class="p_header">diff --git a/arch/arm64/include/asm/efi.h b/arch/arm64/include/asm/efi.h</span>
<span class="p_header">index c4cd5081d78b..8389050328bb 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/efi.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/efi.h</span>
<span class="p_chunk">@@ -121,19 +121,21 @@</span> <span class="p_context"> static inline void efi_set_pgd(struct mm_struct *mm)</span>
 		if (mm != current-&gt;active_mm) {
 			/*
 			 * Update the current thread&#39;s saved ttbr0 since it is
<span class="p_del">-			 * restored as part of a return from exception. Set</span>
<span class="p_del">-			 * the hardware TTBR0_EL1 using cpu_switch_mm()</span>
<span class="p_del">-			 * directly to enable potential errata workarounds.</span>
<span class="p_add">+			 * restored as part of a return from exception. Enable</span>
<span class="p_add">+			 * access to the valid TTBR0_EL1 and invoke the errata</span>
<span class="p_add">+			 * workaround directly since there is no return from</span>
<span class="p_add">+			 * exception when invoking the EFI run-time services.</span>
 			 */
 			update_saved_ttbr0(current, mm);
<span class="p_del">-			cpu_switch_mm(mm-&gt;pgd, mm);</span>
<span class="p_add">+			uaccess_ttbr0_enable();</span>
<span class="p_add">+			post_ttbr_update_workaround();</span>
 		} else {
 			/*
 			 * Defer the switch to the current thread&#39;s TTBR0_EL1
 			 * until uaccess_enable(). Restore the current
 			 * thread&#39;s saved ttbr0 corresponding to its active_mm
 			 */
<span class="p_del">-			cpu_set_reserved_ttbr0();</span>
<span class="p_add">+			uaccess_ttbr0_disable();</span>
 			update_saved_ttbr0(current, current-&gt;active_mm);
 		}
 	}
<span class="p_header">diff --git a/arch/arm64/include/asm/fixmap.h b/arch/arm64/include/asm/fixmap.h</span>
<span class="p_header">index 4052ec39e8db..ec1e6d6fa14c 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/fixmap.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/fixmap.h</span>
<span class="p_chunk">@@ -58,6 +58,11 @@</span> <span class="p_context"> enum fixed_addresses {</span>
 	FIX_APEI_GHES_NMI,
 #endif /* CONFIG_ACPI_APEI_GHES */
 
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+	FIX_ENTRY_TRAMP_DATA,</span>
<span class="p_add">+	FIX_ENTRY_TRAMP_TEXT,</span>
<span class="p_add">+#define TRAMP_VALIAS		(__fix_to_virt(FIX_ENTRY_TRAMP_TEXT))</span>
<span class="p_add">+#endif /* CONFIG_UNMAP_KERNEL_AT_EL0 */</span>
 	__end_of_permanent_fixed_addresses,
 
 	/*
<span class="p_header">diff --git a/arch/arm64/include/asm/futex.h b/arch/arm64/include/asm/futex.h</span>
<span class="p_header">index 5bb2fd4674e7..07fe2479d310 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/futex.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/futex.h</span>
<span class="p_chunk">@@ -48,9 +48,10 @@</span> <span class="p_context"> do {									\</span>
 } while (0)
 
 static inline int
<span class="p_del">-arch_futex_atomic_op_inuser(int op, int oparg, int *oval, u32 __user *uaddr)</span>
<span class="p_add">+arch_futex_atomic_op_inuser(int op, int oparg, int *oval, u32 __user *_uaddr)</span>
 {
 	int oldval = 0, ret, tmp;
<span class="p_add">+	u32 __user *uaddr = __uaccess_mask_ptr(_uaddr);</span>
 
 	pagefault_disable();
 
<span class="p_chunk">@@ -88,15 +89,17 @@</span> <span class="p_context"> arch_futex_atomic_op_inuser(int op, int oparg, int *oval, u32 __user *uaddr)</span>
 }
 
 static inline int
<span class="p_del">-futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
<span class="p_add">+futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *_uaddr,</span>
 			      u32 oldval, u32 newval)
 {
 	int ret = 0;
 	u32 val, tmp;
<span class="p_add">+	u32 __user *uaddr;</span>
 
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, _uaddr, sizeof(u32)))</span>
 		return -EFAULT;
 
<span class="p_add">+	uaddr = __uaccess_mask_ptr(_uaddr);</span>
 	uaccess_enable();
 	asm volatile(&quot;// futex_atomic_cmpxchg_inatomic\n&quot;
 &quot;	prfm	pstl1strm, %2\n&quot;
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_asm.h b/arch/arm64/include/asm/kvm_asm.h</span>
<span class="p_header">index 26a64d0f9ab9..a7ef5a051911 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_asm.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_asm.h</span>
<span class="p_chunk">@@ -66,6 +66,8 @@</span> <span class="p_context"> extern u32 __kvm_get_mdcr_el2(void);</span>
 
 extern u32 __init_stage2_translation(void);
 
<span class="p_add">+extern void __qcom_hyp_sanitize_btac_predictors(void);</span>
<span class="p_add">+</span>
 #endif
 
 #endif /* __ARM_KVM_ASM_H__ */
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_host.h b/arch/arm64/include/asm/kvm_host.h</span>
<span class="p_header">index e923b58606e2..8ad208cb866c 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -384,4 +384,9 @@</span> <span class="p_context"> static inline void __cpu_init_stage2(void)</span>
 		  &quot;PARange is %d bits, unsupported configuration!&quot;, parange);
 }
 
<span class="p_add">+static inline bool kvm_arm_harden_branch_predictor(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return cpus_have_const_cap(ARM64_HARDEN_BRANCH_PREDICTOR);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* __ARM64_KVM_HOST_H__ */
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_mmu.h b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">index 672c8684d5c2..2d6d4bd9de52 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_mmu.h</span>
<span class="p_chunk">@@ -309,5 +309,43 @@</span> <span class="p_context"> static inline unsigned int kvm_get_vmid_bits(void)</span>
 	return (cpuid_feature_extract_unsigned_field(reg, ID_AA64MMFR1_VMIDBITS_SHIFT) == 2) ? 16 : 8;
 }
 
<span class="p_add">+#ifdef CONFIG_HARDEN_BRANCH_PREDICTOR</span>
<span class="p_add">+#include &lt;asm/mmu.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void *kvm_get_hyp_vector(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bp_hardening_data *data = arm64_get_bp_hardening_data();</span>
<span class="p_add">+	void *vect = kvm_ksym_ref(__kvm_hyp_vector);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data-&gt;fn) {</span>
<span class="p_add">+		vect = __bp_harden_hyp_vecs_start +</span>
<span class="p_add">+		       data-&gt;hyp_vectors_slot * SZ_2K;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!has_vhe())</span>
<span class="p_add">+			vect = lm_alias(vect);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return vect;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int kvm_map_vectors(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return create_hyp_mappings(kvm_ksym_ref(__bp_harden_hyp_vecs_start),</span>
<span class="p_add">+				   kvm_ksym_ref(__bp_harden_hyp_vecs_end),</span>
<span class="p_add">+				   PAGE_HYP_EXEC);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline void *kvm_get_hyp_vector(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return kvm_ksym_ref(__kvm_hyp_vector);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int kvm_map_vectors(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* __ASSEMBLY__ */
 #endif /* __ARM64_KVM_MMU_H__ */
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_psci.h b/arch/arm64/include/asm/kvm_psci.h</span>
deleted file mode 100644
<span class="p_header">index bc39e557c56c..000000000000</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_psci.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,27 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2012,2013 - ARM Ltd</span>
<span class="p_del">- * Author: Marc Zyngier &lt;marc.zyngier@arm.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_del">- * published by the Free Software Foundation.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is distributed in the hope that it will be useful,</span>
<span class="p_del">- * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_del">- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_del">- * GNU General Public License for more details.</span>
<span class="p_del">- *</span>
<span class="p_del">- * You should have received a copy of the GNU General Public License</span>
<span class="p_del">- * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#ifndef __ARM64_KVM_PSCI_H__</span>
<span class="p_del">-#define __ARM64_KVM_PSCI_H__</span>
<span class="p_del">-</span>
<span class="p_del">-#define KVM_ARM_PSCI_0_1	1</span>
<span class="p_del">-#define KVM_ARM_PSCI_0_2	2</span>
<span class="p_del">-</span>
<span class="p_del">-int kvm_psci_version(struct kvm_vcpu *vcpu);</span>
<span class="p_del">-int kvm_psci_call(struct kvm_vcpu *vcpu);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* __ARM64_KVM_PSCI_H__ */</span>
<span class="p_header">diff --git a/arch/arm64/include/asm/memory.h b/arch/arm64/include/asm/memory.h</span>
<span class="p_header">index f7c4d2146aed..d4bae7d6e0d8 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/memory.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/memory.h</span>
<span class="p_chunk">@@ -61,8 +61,6 @@</span> <span class="p_context"></span>
  * KIMAGE_VADDR - the virtual address of the start of the kernel image
  * VA_BITS - the maximum number of bits for virtual addresses.
  * VA_START - the first kernel virtual address.
<span class="p_del">- * TASK_SIZE - the maximum size of a user space task.</span>
<span class="p_del">- * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area.</span>
  */
 #define VA_BITS			(CONFIG_ARM64_VA_BITS)
 #define VA_START		(UL(0xffffffffffffffff) - \
<span class="p_chunk">@@ -77,19 +75,6 @@</span> <span class="p_context"></span>
 #define PCI_IO_END		(VMEMMAP_START - SZ_2M)
 #define PCI_IO_START		(PCI_IO_END - PCI_IO_SIZE)
 #define FIXADDR_TOP		(PCI_IO_START - SZ_2M)
<span class="p_del">-#define TASK_SIZE_64		(UL(1) &lt;&lt; VA_BITS)</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-#define TASK_SIZE_32		UL(0x100000000)</span>
<span class="p_del">-#define TASK_SIZE		(test_thread_flag(TIF_32BIT) ? \</span>
<span class="p_del">-				TASK_SIZE_32 : TASK_SIZE_64)</span>
<span class="p_del">-#define TASK_SIZE_OF(tsk)	(test_tsk_thread_flag(tsk, TIF_32BIT) ? \</span>
<span class="p_del">-				TASK_SIZE_32 : TASK_SIZE_64)</span>
<span class="p_del">-#else</span>
<span class="p_del">-#define TASK_SIZE		TASK_SIZE_64</span>
<span class="p_del">-#endif /* CONFIG_COMPAT */</span>
<span class="p_del">-</span>
<span class="p_del">-#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 4))</span>
 
 #define KERNEL_START      _text
 #define KERNEL_END        _end
<span class="p_header">diff --git a/arch/arm64/include/asm/mmu.h b/arch/arm64/include/asm/mmu.h</span>
<span class="p_header">index 0d34bf0a89c7..6dd83d75b82a 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/mmu.h</span>
<span class="p_chunk">@@ -17,6 +17,10 @@</span> <span class="p_context"></span>
 #define __ASM_MMU_H
 
 #define MMCF_AARCH32	0x1	/* mm context flag for AArch32 executables */
<span class="p_add">+#define USER_ASID_FLAG	(UL(1) &lt;&lt; 48)</span>
<span class="p_add">+#define TTBR_ASID_MASK	(UL(0xffff) &lt;&lt; 48)</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
 
 typedef struct {
 	atomic64_t	id;
<span class="p_chunk">@@ -31,6 +35,49 @@</span> <span class="p_context"> typedef struct {</span>
  */
 #define ASID(mm)	((mm)-&gt;context.id.counter &amp; 0xffff)
 
<span class="p_add">+static inline bool arm64_kernel_unmapped_at_el0(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return IS_ENABLED(CONFIG_UNMAP_KERNEL_AT_EL0) &amp;&amp;</span>
<span class="p_add">+	       cpus_have_const_cap(ARM64_UNMAP_KERNEL_AT_EL0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+typedef void (*bp_hardening_cb_t)(void);</span>
<span class="p_add">+</span>
<span class="p_add">+struct bp_hardening_data {</span>
<span class="p_add">+	int			hyp_vectors_slot;</span>
<span class="p_add">+	bp_hardening_cb_t	fn;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HARDEN_BRANCH_PREDICTOR</span>
<span class="p_add">+extern char __bp_harden_hyp_vecs_start[], __bp_harden_hyp_vecs_end[];</span>
<span class="p_add">+</span>
<span class="p_add">+DECLARE_PER_CPU_READ_MOSTLY(struct bp_hardening_data, bp_hardening_data);</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct bp_hardening_data *arm64_get_bp_hardening_data(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return this_cpu_ptr(&amp;bp_hardening_data);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arm64_apply_bp_hardening(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct bp_hardening_data *d;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpus_have_const_cap(ARM64_HARDEN_BRANCH_PREDICTOR))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	d = arm64_get_bp_hardening_data();</span>
<span class="p_add">+	if (d-&gt;fn)</span>
<span class="p_add">+		d-&gt;fn();</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline struct bp_hardening_data *arm64_get_bp_hardening_data(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arm64_apply_bp_hardening(void)	{ }</span>
<span class="p_add">+#endif	/* CONFIG_HARDEN_BRANCH_PREDICTOR */</span>
<span class="p_add">+</span>
 extern void paging_init(void);
 extern void bootmem_init(void);
 extern void __iomem *early_io_map(phys_addr_t phys, unsigned long virt);
<span class="p_chunk">@@ -41,4 +88,5 @@</span> <span class="p_context"> extern void create_pgd_mapping(struct mm_struct *mm, phys_addr_t phys,</span>
 extern void *fixmap_remap_fdt(phys_addr_t dt_phys);
 extern void mark_linear_text_alias_ro(void);
 
<span class="p_add">+#endif	/* !__ASSEMBLY__ */</span>
 #endif
<span class="p_header">diff --git a/arch/arm64/include/asm/mmu_context.h b/arch/arm64/include/asm/mmu_context.h</span>
<span class="p_header">index 9d155fa9a507..779d7a2ec5ec 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -19,8 +19,6 @@</span> <span class="p_context"></span>
 #ifndef __ASM_MMU_CONTEXT_H
 #define __ASM_MMU_CONTEXT_H
 
<span class="p_del">-#define FALKOR_RESERVED_ASID	1</span>
<span class="p_del">-</span>
 #ifndef __ASSEMBLY__
 
 #include &lt;linux/compiler.h&gt;
<span class="p_chunk">@@ -57,6 +55,13 @@</span> <span class="p_context"> static inline void cpu_set_reserved_ttbr0(void)</span>
 	isb();
 }
 
<span class="p_add">+static inline void cpu_switch_mm(pgd_t *pgd, struct mm_struct *mm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(pgd == swapper_pg_dir);</span>
<span class="p_add">+	cpu_set_reserved_ttbr0();</span>
<span class="p_add">+	cpu_do_switch_mm(virt_to_phys(pgd),mm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * TCR.T0SZ value to use when the ID map is active. Usually equals
  * TCR_T0SZ(VA_BITS), unless system RAM is positioned very high in
<span class="p_chunk">@@ -170,7 +175,7 @@</span> <span class="p_context"> static inline void update_saved_ttbr0(struct task_struct *tsk,</span>
 	else
 		ttbr = virt_to_phys(mm-&gt;pgd) | ASID(mm) &lt;&lt; 48;
 
<span class="p_del">-	task_thread_info(tsk)-&gt;ttbr0 = ttbr;</span>
<span class="p_add">+	WRITE_ONCE(task_thread_info(tsk)-&gt;ttbr0, ttbr);</span>
 }
 #else
 static inline void update_saved_ttbr0(struct task_struct *tsk,
<span class="p_chunk">@@ -225,6 +230,7 @@</span> <span class="p_context"> switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
 #define activate_mm(prev,next)	switch_mm(prev, next, current)
 
 void verify_cpu_asid_bits(void);
<span class="p_add">+void post_ttbr_update_workaround(void);</span>
 
 #endif /* !__ASSEMBLY__ */
 
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable-hwdef.h b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">index eb0c2bd90de9..8df4cb6ac6f7 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable-hwdef.h</span>
<span class="p_chunk">@@ -272,6 +272,7 @@</span> <span class="p_context"></span>
 #define TCR_TG1_4K		(UL(2) &lt;&lt; TCR_TG1_SHIFT)
 #define TCR_TG1_64K		(UL(3) &lt;&lt; TCR_TG1_SHIFT)
 
<span class="p_add">+#define TCR_A1			(UL(1) &lt;&lt; 22)</span>
 #define TCR_ASID16		(UL(1) &lt;&lt; 36)
 #define TCR_TBI0		(UL(1) &lt;&lt; 37)
 #define TCR_HA			(UL(1) &lt;&lt; 39)
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable-prot.h b/arch/arm64/include/asm/pgtable-prot.h</span>
<span class="p_header">index 0a5635fb0ef9..2db84df5eb42 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable-prot.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable-prot.h</span>
<span class="p_chunk">@@ -34,8 +34,14 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/pgtable-types.h&gt;
 
<span class="p_del">-#define PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_SHARED)</span>
<span class="p_del">-#define PROT_SECT_DEFAULT	(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S)</span>
<span class="p_add">+#define _PROT_DEFAULT		(PTE_TYPE_PAGE | PTE_AF | PTE_SHARED)</span>
<span class="p_add">+#define _PROT_SECT_DEFAULT	(PMD_TYPE_SECT | PMD_SECT_AF | PMD_SECT_S)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PTE_MAYBE_NG		(arm64_kernel_unmapped_at_el0() ? PTE_NG : 0)</span>
<span class="p_add">+#define PMD_MAYBE_NG		(arm64_kernel_unmapped_at_el0() ? PMD_SECT_NG : 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define PROT_DEFAULT		(_PROT_DEFAULT | PTE_MAYBE_NG)</span>
<span class="p_add">+#define PROT_SECT_DEFAULT	(_PROT_SECT_DEFAULT | PMD_MAYBE_NG)</span>
 
 #define PROT_DEVICE_nGnRnE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_ATTRINDX(MT_DEVICE_nGnRnE))
 #define PROT_DEVICE_nGnRE	(PROT_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_ATTRINDX(MT_DEVICE_nGnRE))
<span class="p_chunk">@@ -47,23 +53,24 @@</span> <span class="p_context"></span>
 #define PROT_SECT_NORMAL	(PROT_SECT_DEFAULT | PMD_SECT_PXN | PMD_SECT_UXN | PMD_ATTRINDX(MT_NORMAL))
 #define PROT_SECT_NORMAL_EXEC	(PROT_SECT_DEFAULT | PMD_SECT_UXN | PMD_ATTRINDX(MT_NORMAL))
 
<span class="p_del">-#define _PAGE_DEFAULT		(PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL))</span>
<span class="p_add">+#define _PAGE_DEFAULT		(_PROT_DEFAULT | PTE_ATTRINDX(MT_NORMAL))</span>
<span class="p_add">+#define _HYP_PAGE_DEFAULT	_PAGE_DEFAULT</span>
 
<span class="p_del">-#define PAGE_KERNEL		__pgprot(_PAGE_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_WRITE)</span>
<span class="p_del">-#define PAGE_KERNEL_RO		__pgprot(_PAGE_DEFAULT | PTE_PXN | PTE_UXN | PTE_DIRTY | PTE_RDONLY)</span>
<span class="p_del">-#define PAGE_KERNEL_ROX		__pgprot(_PAGE_DEFAULT | PTE_UXN | PTE_DIRTY | PTE_RDONLY)</span>
<span class="p_del">-#define PAGE_KERNEL_EXEC	__pgprot(_PAGE_DEFAULT | PTE_UXN | PTE_DIRTY | PTE_WRITE)</span>
<span class="p_del">-#define PAGE_KERNEL_EXEC_CONT	__pgprot(_PAGE_DEFAULT | PTE_UXN | PTE_DIRTY | PTE_WRITE | PTE_CONT)</span>
<span class="p_add">+#define PAGE_KERNEL		__pgprot(PROT_NORMAL)</span>
<span class="p_add">+#define PAGE_KERNEL_RO		__pgprot((PROT_NORMAL &amp; ~PTE_WRITE) | PTE_RDONLY)</span>
<span class="p_add">+#define PAGE_KERNEL_ROX		__pgprot((PROT_NORMAL &amp; ~(PTE_WRITE | PTE_PXN)) | PTE_RDONLY)</span>
<span class="p_add">+#define PAGE_KERNEL_EXEC	__pgprot(PROT_NORMAL &amp; ~PTE_PXN)</span>
<span class="p_add">+#define PAGE_KERNEL_EXEC_CONT	__pgprot((PROT_NORMAL &amp; ~PTE_PXN) | PTE_CONT)</span>
 
<span class="p_del">-#define PAGE_HYP		__pgprot(_PAGE_DEFAULT | PTE_HYP | PTE_HYP_XN)</span>
<span class="p_del">-#define PAGE_HYP_EXEC		__pgprot(_PAGE_DEFAULT | PTE_HYP | PTE_RDONLY)</span>
<span class="p_del">-#define PAGE_HYP_RO		__pgprot(_PAGE_DEFAULT | PTE_HYP | PTE_RDONLY | PTE_HYP_XN)</span>
<span class="p_add">+#define PAGE_HYP		__pgprot(_HYP_PAGE_DEFAULT | PTE_HYP | PTE_HYP_XN)</span>
<span class="p_add">+#define PAGE_HYP_EXEC		__pgprot(_HYP_PAGE_DEFAULT | PTE_HYP | PTE_RDONLY)</span>
<span class="p_add">+#define PAGE_HYP_RO		__pgprot(_HYP_PAGE_DEFAULT | PTE_HYP | PTE_RDONLY | PTE_HYP_XN)</span>
 #define PAGE_HYP_DEVICE		__pgprot(PROT_DEVICE_nGnRE | PTE_HYP)
 
<span class="p_del">-#define PAGE_S2			__pgprot(PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY)</span>
<span class="p_del">-#define PAGE_S2_DEVICE		__pgprot(PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_DEVICE_nGnRE) | PTE_S2_RDONLY | PTE_UXN)</span>
<span class="p_add">+#define PAGE_S2			__pgprot(_PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_NORMAL) | PTE_S2_RDONLY)</span>
<span class="p_add">+#define PAGE_S2_DEVICE		__pgprot(_PROT_DEFAULT | PTE_S2_MEMATTR(MT_S2_DEVICE_nGnRE) | PTE_S2_RDONLY | PTE_UXN)</span>
 
<span class="p_del">-#define PAGE_NONE		__pgprot(((_PAGE_DEFAULT) &amp; ~PTE_VALID) | PTE_PROT_NONE | PTE_RDONLY | PTE_PXN | PTE_UXN)</span>
<span class="p_add">+#define PAGE_NONE		__pgprot(((_PAGE_DEFAULT) &amp; ~PTE_VALID) | PTE_PROT_NONE | PTE_RDONLY | PTE_NG | PTE_PXN | PTE_UXN)</span>
 #define PAGE_SHARED		__pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_PXN | PTE_UXN | PTE_WRITE)
 #define PAGE_SHARED_EXEC	__pgprot(_PAGE_DEFAULT | PTE_USER | PTE_NG | PTE_PXN | PTE_WRITE)
 #define PAGE_READONLY		__pgprot(_PAGE_DEFAULT | PTE_USER | PTE_RDONLY | PTE_NG | PTE_PXN | PTE_UXN)
<span class="p_header">diff --git a/arch/arm64/include/asm/pgtable.h b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">index 960d05c8816a..aafea648a30f 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -684,6 +684,7 @@</span> <span class="p_context"> static inline void pmdp_set_wrprotect(struct mm_struct *mm,</span>
 
 extern pgd_t swapper_pg_dir[PTRS_PER_PGD];
 extern pgd_t idmap_pg_dir[PTRS_PER_PGD];
<span class="p_add">+extern pgd_t tramp_pg_dir[PTRS_PER_PGD];</span>
 
 /*
  * Encode and decode a swap entry:
<span class="p_header">diff --git a/arch/arm64/include/asm/proc-fns.h b/arch/arm64/include/asm/proc-fns.h</span>
<span class="p_header">index 14ad6e4e87d1..16cef2e8449e 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/proc-fns.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/proc-fns.h</span>
<span class="p_chunk">@@ -35,12 +35,6 @@</span> <span class="p_context"> extern u64 cpu_do_resume(phys_addr_t ptr, u64 idmap_ttbr);</span>
 
 #include &lt;asm/memory.h&gt;
 
<span class="p_del">-#define cpu_switch_mm(pgd,mm)				\</span>
<span class="p_del">-do {							\</span>
<span class="p_del">-	BUG_ON(pgd == swapper_pg_dir);			\</span>
<span class="p_del">-	cpu_do_switch_mm(virt_to_phys(pgd),mm);		\</span>
<span class="p_del">-} while (0)</span>
<span class="p_del">-</span>
 #endif /* __ASSEMBLY__ */
 #endif /* __KERNEL__ */
 #endif /* __ASM_PROCFNS_H */
<span class="p_header">diff --git a/arch/arm64/include/asm/processor.h b/arch/arm64/include/asm/processor.h</span>
<span class="p_header">index 29adab8138c3..fda6f5812281 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/processor.h</span>
<span class="p_chunk">@@ -19,6 +19,13 @@</span> <span class="p_context"></span>
 #ifndef __ASM_PROCESSOR_H
 #define __ASM_PROCESSOR_H
 
<span class="p_add">+#define TASK_SIZE_64		(UL(1) &lt;&lt; VA_BITS)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KERNEL_DS	UL(-1)</span>
<span class="p_add">+#define USER_DS		(TASK_SIZE_64 - 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
 /*
  * Default implementation of macro that returns current
  * instruction pointer (&quot;program counter&quot;).
<span class="p_chunk">@@ -37,6 +44,22 @@</span> <span class="p_context"></span>
 #include &lt;asm/ptrace.h&gt;
 #include &lt;asm/types.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * TASK_SIZE - the maximum size of a user space task.</span>
<span class="p_add">+ * TASK_UNMAPPED_BASE - the lower boundary of the mmap VM area.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+#define TASK_SIZE_32		UL(0x100000000)</span>
<span class="p_add">+#define TASK_SIZE		(test_thread_flag(TIF_32BIT) ? \</span>
<span class="p_add">+				TASK_SIZE_32 : TASK_SIZE_64)</span>
<span class="p_add">+#define TASK_SIZE_OF(tsk)	(test_tsk_thread_flag(tsk, TIF_32BIT) ? \</span>
<span class="p_add">+				TASK_SIZE_32 : TASK_SIZE_64)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define TASK_SIZE		TASK_SIZE_64</span>
<span class="p_add">+#endif /* CONFIG_COMPAT */</span>
<span class="p_add">+</span>
<span class="p_add">+#define TASK_UNMAPPED_BASE	(PAGE_ALIGN(TASK_SIZE / 4))</span>
<span class="p_add">+</span>
 #define STACK_TOP_MAX		TASK_SIZE_64
 #ifdef CONFIG_COMPAT
 #define AARCH32_VECTORS_BASE	0xffff0000
<span class="p_chunk">@@ -194,4 +217,5 @@</span> <span class="p_context"> static inline void spin_lock_prefetch(const void *ptr)</span>
 int cpu_enable_pan(void *__unused);
 int cpu_enable_cache_maint_trap(void *__unused);
 
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
 #endif /* __ASM_PROCESSOR_H */
<span class="p_header">diff --git a/arch/arm64/include/asm/sysreg.h b/arch/arm64/include/asm/sysreg.h</span>
<span class="p_header">index f707fed5886f..ede80d47d0ef 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/sysreg.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/sysreg.h</span>
<span class="p_chunk">@@ -332,6 +332,8 @@</span> <span class="p_context"></span>
 #define ID_AA64ISAR1_DPB_SHIFT		0
 
 /* id_aa64pfr0 */
<span class="p_add">+#define ID_AA64PFR0_CSV3_SHIFT		60</span>
<span class="p_add">+#define ID_AA64PFR0_CSV2_SHIFT		56</span>
 #define ID_AA64PFR0_GIC_SHIFT		24
 #define ID_AA64PFR0_ASIMD_SHIFT		20
 #define ID_AA64PFR0_FP_SHIFT		16
<span class="p_header">diff --git a/arch/arm64/include/asm/tlbflush.h b/arch/arm64/include/asm/tlbflush.h</span>
<span class="p_header">index af1c76981911..9e82dd79c7db 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/sched.h&gt;
 #include &lt;asm/cputype.h&gt;
<span class="p_add">+#include &lt;asm/mmu.h&gt;</span>
 
 /*
  * Raw TLBI operations.
<span class="p_chunk">@@ -54,6 +55,11 @@</span> <span class="p_context"></span>
 
 #define __tlbi(op, ...)		__TLBI_N(op, ##__VA_ARGS__, 1, 0)
 
<span class="p_add">+#define __tlbi_user(op, arg) do {						\</span>
<span class="p_add">+	if (arm64_kernel_unmapped_at_el0())					\</span>
<span class="p_add">+		__tlbi(op, (arg) | USER_ASID_FLAG);				\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
 /*
  *	TLB Management
  *	==============
<span class="p_chunk">@@ -115,6 +121,7 @@</span> <span class="p_context"> static inline void flush_tlb_mm(struct mm_struct *mm)</span>
 
 	dsb(ishst);
 	__tlbi(aside1is, asid);
<span class="p_add">+	__tlbi_user(aside1is, asid);</span>
 	dsb(ish);
 }
 
<span class="p_chunk">@@ -125,6 +132,7 @@</span> <span class="p_context"> static inline void flush_tlb_page(struct vm_area_struct *vma,</span>
 
 	dsb(ishst);
 	__tlbi(vale1is, addr);
<span class="p_add">+	__tlbi_user(vale1is, addr);</span>
 	dsb(ish);
 }
 
<span class="p_chunk">@@ -151,10 +159,13 @@</span> <span class="p_context"> static inline void __flush_tlb_range(struct vm_area_struct *vma,</span>
 
 	dsb(ishst);
 	for (addr = start; addr &lt; end; addr += 1 &lt;&lt; (PAGE_SHIFT - 12)) {
<span class="p_del">-		if (last_level)</span>
<span class="p_add">+		if (last_level) {</span>
 			__tlbi(vale1is, addr);
<span class="p_del">-		else</span>
<span class="p_add">+			__tlbi_user(vale1is, addr);</span>
<span class="p_add">+		} else {</span>
 			__tlbi(vae1is, addr);
<span class="p_add">+			__tlbi_user(vae1is, addr);</span>
<span class="p_add">+		}</span>
 	}
 	dsb(ish);
 }
<span class="p_chunk">@@ -194,6 +205,7 @@</span> <span class="p_context"> static inline void __flush_tlb_pgtable(struct mm_struct *mm,</span>
 	unsigned long addr = uaddr &gt;&gt; 12 | (ASID(mm) &lt;&lt; 48);
 
 	__tlbi(vae1is, addr);
<span class="p_add">+	__tlbi_user(vae1is, addr);</span>
 	dsb(ish);
 }
 
<span class="p_header">diff --git a/arch/arm64/include/asm/uaccess.h b/arch/arm64/include/asm/uaccess.h</span>
<span class="p_header">index fc0f9eb66039..fad8c1b2ca3e 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -35,16 +35,20 @@</span> <span class="p_context"></span>
 #include &lt;asm/compiler.h&gt;
 #include &lt;asm/extable.h&gt;
 
<span class="p_del">-#define KERNEL_DS	(-1UL)</span>
 #define get_ds()	(KERNEL_DS)
<span class="p_del">-</span>
<span class="p_del">-#define USER_DS		TASK_SIZE_64</span>
 #define get_fs()	(current_thread_info()-&gt;addr_limit)
 
 static inline void set_fs(mm_segment_t fs)
 {
 	current_thread_info()-&gt;addr_limit = fs;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Prevent a mispredicted conditional call to set_fs from forwarding</span>
<span class="p_add">+	 * the wrong address limit to access_ok under speculation.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dsb(nsh);</span>
<span class="p_add">+	isb();</span>
<span class="p_add">+</span>
 	/* On user-mode return, check fs is correct */
 	set_thread_flag(TIF_FSCHECK);
 
<span class="p_chunk">@@ -66,22 +70,32 @@</span> <span class="p_context"> static inline void set_fs(mm_segment_t fs)</span>
  * Returns 1 if the range is valid, 0 otherwise.
  *
  * This is equivalent to the following test:
<span class="p_del">- * (u65)addr + (u65)size &lt;= current-&gt;addr_limit</span>
<span class="p_del">- *</span>
<span class="p_del">- * This needs 65-bit arithmetic.</span>
<span class="p_add">+ * (u65)addr + (u65)size &lt;= (u65)current-&gt;addr_limit + 1</span>
  */
<span class="p_del">-#define __range_ok(addr, size)						\</span>
<span class="p_del">-({									\</span>
<span class="p_del">-	unsigned long __addr = (unsigned long)(addr);			\</span>
<span class="p_del">-	unsigned long flag, roksum;					\</span>
<span class="p_del">-	__chk_user_ptr(addr);						\</span>
<span class="p_del">-	asm(&quot;adds %1, %1, %3; ccmp %1, %4, #2, cc; cset %0, ls&quot;		\</span>
<span class="p_del">-		: &quot;=&amp;r&quot; (flag), &quot;=&amp;r&quot; (roksum)				\</span>
<span class="p_del">-		: &quot;1&quot; (__addr), &quot;Ir&quot; (size),				\</span>
<span class="p_del">-		  &quot;r&quot; (current_thread_info()-&gt;addr_limit)		\</span>
<span class="p_del">-		: &quot;cc&quot;);						\</span>
<span class="p_del">-	flag;								\</span>
<span class="p_del">-})</span>
<span class="p_add">+static inline unsigned long __range_ok(unsigned long addr, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long limit = current_thread_info()-&gt;addr_limit;</span>
<span class="p_add">+</span>
<span class="p_add">+	__chk_user_ptr(addr);</span>
<span class="p_add">+	asm volatile(</span>
<span class="p_add">+	// A + B &lt;= C + 1 for all A,B,C, in four easy steps:</span>
<span class="p_add">+	// 1: X = A + B; X&#39; = X % 2^64</span>
<span class="p_add">+	&quot;	adds	%0, %0, %2\n&quot;</span>
<span class="p_add">+	// 2: Set C = 0 if X &gt; 2^64, to guarantee X&#39; &gt; C in step 4</span>
<span class="p_add">+	&quot;	csel	%1, xzr, %1, hi\n&quot;</span>
<span class="p_add">+	// 3: Set X&#39; = ~0 if X &gt;= 2^64. For X == 2^64, this decrements X&#39;</span>
<span class="p_add">+	//    to compensate for the carry flag being set in step 4. For</span>
<span class="p_add">+	//    X &gt; 2^64, X&#39; merely has to remain nonzero, which it does.</span>
<span class="p_add">+	&quot;	csinv	%0, %0, xzr, cc\n&quot;</span>
<span class="p_add">+	// 4: For X &lt; 2^64, this gives us X&#39; - C - 1 &lt;= 0, where the -1</span>
<span class="p_add">+	//    comes from the carry in being clear. Otherwise, we are</span>
<span class="p_add">+	//    testing X&#39; - C == 0, subject to the previous adjustments.</span>
<span class="p_add">+	&quot;	sbcs	xzr, %0, %1\n&quot;</span>
<span class="p_add">+	&quot;	cset	%0, ls\n&quot;</span>
<span class="p_add">+	: &quot;+r&quot; (addr), &quot;+r&quot; (limit) : &quot;Ir&quot; (size) : &quot;cc&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	return addr;</span>
<span class="p_add">+}</span>
 
 /*
  * When dealing with data aborts, watchpoints, or instruction traps we may end
<span class="p_chunk">@@ -90,7 +104,7 @@</span> <span class="p_context"> static inline void set_fs(mm_segment_t fs)</span>
  */
 #define untagged_addr(addr)		sign_extend64(addr, 55)
 
<span class="p_del">-#define access_ok(type, addr, size)	__range_ok(addr, size)</span>
<span class="p_add">+#define access_ok(type, addr, size)	__range_ok((unsigned long)(addr), size)</span>
 #define user_addr_max			get_fs
 
 #define _ASM_EXTABLE(from, to)						\
<span class="p_chunk">@@ -105,17 +119,23 @@</span> <span class="p_context"> static inline void set_fs(mm_segment_t fs)</span>
 #ifdef CONFIG_ARM64_SW_TTBR0_PAN
 static inline void __uaccess_ttbr0_disable(void)
 {
<span class="p_del">-	unsigned long ttbr;</span>
<span class="p_add">+	unsigned long flags, ttbr;</span>
 
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+	ttbr = read_sysreg(ttbr1_el1);</span>
<span class="p_add">+	ttbr &amp;= ~TTBR_ASID_MASK;</span>
 	/* reserved_ttbr0 placed at the end of swapper_pg_dir */
<span class="p_del">-	ttbr = read_sysreg(ttbr1_el1) + SWAPPER_DIR_SIZE;</span>
<span class="p_del">-	write_sysreg(ttbr, ttbr0_el1);</span>
<span class="p_add">+	write_sysreg(ttbr + SWAPPER_DIR_SIZE, ttbr0_el1);</span>
 	isb();
<span class="p_add">+	/* Set reserved ASID */</span>
<span class="p_add">+	write_sysreg(ttbr, ttbr1_el1);</span>
<span class="p_add">+	isb();</span>
<span class="p_add">+	local_irq_restore(flags);</span>
 }
 
 static inline void __uaccess_ttbr0_enable(void)
 {
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	unsigned long flags, ttbr0, ttbr1;</span>
 
 	/*
 	 * Disable interrupts to avoid preemption between reading the &#39;ttbr0&#39;
<span class="p_chunk">@@ -123,7 +143,17 @@</span> <span class="p_context"> static inline void __uaccess_ttbr0_enable(void)</span>
 	 * roll-over and an update of &#39;ttbr0&#39;.
 	 */
 	local_irq_save(flags);
<span class="p_del">-	write_sysreg(current_thread_info()-&gt;ttbr0, ttbr0_el1);</span>
<span class="p_add">+	ttbr0 = READ_ONCE(current_thread_info()-&gt;ttbr0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore active ASID */</span>
<span class="p_add">+	ttbr1 = read_sysreg(ttbr1_el1);</span>
<span class="p_add">+	ttbr1 &amp;= ~TTBR_ASID_MASK;		/* safety measure */</span>
<span class="p_add">+	ttbr1 |= ttbr0 &amp; TTBR_ASID_MASK;</span>
<span class="p_add">+	write_sysreg(ttbr1, ttbr1_el1);</span>
<span class="p_add">+	isb();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Restore user page table */</span>
<span class="p_add">+	write_sysreg(ttbr0, ttbr0_el1);</span>
 	isb();
 	local_irq_restore(flags);
 }
<span class="p_chunk">@@ -192,6 +222,26 @@</span> <span class="p_context"> static inline void uaccess_enable_not_uao(void)</span>
 	__uaccess_enable(ARM64_ALT_PAN_NOT_UAO);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Sanitise a uaccess pointer such that it becomes NULL if above the</span>
<span class="p_add">+ * current addr_limit.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define uaccess_mask_ptr(ptr) (__typeof__(ptr))__uaccess_mask_ptr(ptr)</span>
<span class="p_add">+static inline void __user *__uaccess_mask_ptr(const void __user *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void __user *safe_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	asm volatile(</span>
<span class="p_add">+	&quot;	bics	xzr, %1, %2\n&quot;</span>
<span class="p_add">+	&quot;	csel	%0, %1, xzr, eq\n&quot;</span>
<span class="p_add">+	: &quot;=&amp;r&quot; (safe_ptr)</span>
<span class="p_add">+	: &quot;r&quot; (ptr), &quot;r&quot; (current_thread_info()-&gt;addr_limit)</span>
<span class="p_add">+	: &quot;cc&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	csdb();</span>
<span class="p_add">+	return safe_ptr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * The &quot;__xxx&quot; versions of the user access functions do not verify the address
  * space - it must have been done previously with a separate &quot;access_ok()&quot;
<span class="p_chunk">@@ -244,28 +294,33 @@</span> <span class="p_context"> do {									\</span>
 	(x) = (__force __typeof__(*(ptr)))__gu_val;			\
 } while (0)
 
<span class="p_del">-#define __get_user(x, ptr)						\</span>
<span class="p_add">+#define __get_user_check(x, ptr, err)					\</span>
 ({									\
<span class="p_del">-	int __gu_err = 0;						\</span>
<span class="p_del">-	__get_user_err((x), (ptr), __gu_err);				\</span>
<span class="p_del">-	__gu_err;							\</span>
<span class="p_add">+	__typeof__(*(ptr)) __user *__p = (ptr);				\</span>
<span class="p_add">+	might_fault();							\</span>
<span class="p_add">+	if (access_ok(VERIFY_READ, __p, sizeof(*__p))) {		\</span>
<span class="p_add">+		__p = uaccess_mask_ptr(__p);				\</span>
<span class="p_add">+		__get_user_err((x), __p, (err));			\</span>
<span class="p_add">+	} else {							\</span>
<span class="p_add">+		(x) = 0; (err) = -EFAULT;				\</span>
<span class="p_add">+	}								\</span>
 })
 
 #define __get_user_error(x, ptr, err)					\
 ({									\
<span class="p_del">-	__get_user_err((x), (ptr), (err));				\</span>
<span class="p_add">+	__get_user_check((x), (ptr), (err));				\</span>
 	(void)0;							\
 })
 
<span class="p_del">-#define get_user(x, ptr)						\</span>
<span class="p_add">+#define __get_user(x, ptr)						\</span>
 ({									\
<span class="p_del">-	__typeof__(*(ptr)) __user *__p = (ptr);				\</span>
<span class="p_del">-	might_fault();							\</span>
<span class="p_del">-	access_ok(VERIFY_READ, __p, sizeof(*__p)) ?			\</span>
<span class="p_del">-		__get_user((x), __p) :					\</span>
<span class="p_del">-		((x) = 0, -EFAULT);					\</span>
<span class="p_add">+	int __gu_err = 0;						\</span>
<span class="p_add">+	__get_user_check((x), (ptr), __gu_err);				\</span>
<span class="p_add">+	__gu_err;							\</span>
 })
 
<span class="p_add">+#define get_user	__get_user</span>
<span class="p_add">+</span>
 #define __put_user_asm(instr, alt_instr, reg, x, addr, err, feature)	\
 	asm volatile(							\
 	&quot;1:&quot;ALTERNATIVE(instr &quot;     &quot; reg &quot;1, [%2]\n&quot;,			\
<span class="p_chunk">@@ -308,43 +363,63 @@</span> <span class="p_context"> do {									\</span>
 	uaccess_disable_not_uao();					\
 } while (0)
 
<span class="p_del">-#define __put_user(x, ptr)						\</span>
<span class="p_add">+#define __put_user_check(x, ptr, err)					\</span>
 ({									\
<span class="p_del">-	int __pu_err = 0;						\</span>
<span class="p_del">-	__put_user_err((x), (ptr), __pu_err);				\</span>
<span class="p_del">-	__pu_err;							\</span>
<span class="p_add">+	__typeof__(*(ptr)) __user *__p = (ptr);				\</span>
<span class="p_add">+	might_fault();							\</span>
<span class="p_add">+	if (access_ok(VERIFY_WRITE, __p, sizeof(*__p))) {		\</span>
<span class="p_add">+		__p = uaccess_mask_ptr(__p);				\</span>
<span class="p_add">+		__put_user_err((x), __p, (err));			\</span>
<span class="p_add">+	} else	{							\</span>
<span class="p_add">+		(err) = -EFAULT;					\</span>
<span class="p_add">+	}								\</span>
 })
 
 #define __put_user_error(x, ptr, err)					\
 ({									\
<span class="p_del">-	__put_user_err((x), (ptr), (err));				\</span>
<span class="p_add">+	__put_user_check((x), (ptr), (err));				\</span>
 	(void)0;							\
 })
 
<span class="p_del">-#define put_user(x, ptr)						\</span>
<span class="p_add">+#define __put_user(x, ptr)						\</span>
 ({									\
<span class="p_del">-	__typeof__(*(ptr)) __user *__p = (ptr);				\</span>
<span class="p_del">-	might_fault();							\</span>
<span class="p_del">-	access_ok(VERIFY_WRITE, __p, sizeof(*__p)) ?			\</span>
<span class="p_del">-		__put_user((x), __p) :					\</span>
<span class="p_del">-		-EFAULT;						\</span>
<span class="p_add">+	int __pu_err = 0;						\</span>
<span class="p_add">+	__put_user_check((x), (ptr), __pu_err);				\</span>
<span class="p_add">+	__pu_err;							\</span>
 })
 
<span class="p_add">+#define put_user	__put_user</span>
<span class="p_add">+</span>
 extern unsigned long __must_check __arch_copy_from_user(void *to, const void __user *from, unsigned long n);
<span class="p_del">-#define raw_copy_from_user __arch_copy_from_user</span>
<span class="p_add">+#define raw_copy_from_user(to, from, n)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	__arch_copy_from_user((to), __uaccess_mask_ptr(from), (n));	\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 extern unsigned long __must_check __arch_copy_to_user(void __user *to, const void *from, unsigned long n);
<span class="p_del">-#define raw_copy_to_user __arch_copy_to_user</span>
<span class="p_del">-extern unsigned long __must_check raw_copy_in_user(void __user *to, const void __user *from, unsigned long n);</span>
<span class="p_del">-extern unsigned long __must_check __clear_user(void __user *addr, unsigned long n);</span>
<span class="p_add">+#define raw_copy_to_user(to, from, n)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	__arch_copy_to_user(__uaccess_mask_ptr(to), (from), (n));	\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+extern unsigned long __must_check __arch_copy_in_user(void __user *to, const void __user *from, unsigned long n);</span>
<span class="p_add">+#define raw_copy_in_user(to, from, n)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	__arch_copy_in_user(__uaccess_mask_ptr(to),			\</span>
<span class="p_add">+			    __uaccess_mask_ptr(from), (n));		\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 #define INLINE_COPY_TO_USER
 #define INLINE_COPY_FROM_USER
 
<span class="p_del">-static inline unsigned long __must_check clear_user(void __user *to, unsigned long n)</span>
<span class="p_add">+extern unsigned long __must_check __arch_clear_user(void __user *to, unsigned long n);</span>
<span class="p_add">+static inline unsigned long __must_check __clear_user(void __user *to, unsigned long n)</span>
 {
 	if (access_ok(VERIFY_WRITE, to, n))
<span class="p_del">-		n = __clear_user(to, n);</span>
<span class="p_add">+		n = __arch_clear_user(__uaccess_mask_ptr(to), n);</span>
 	return n;
 }
<span class="p_add">+#define clear_user	__clear_user</span>
 
 extern long strncpy_from_user(char *dest, const char __user *src, long count);
 
<span class="p_chunk">@@ -358,7 +433,7 @@</span> <span class="p_context"> extern unsigned long __must_check __copy_user_flushcache(void *to, const void __</span>
 static inline int __copy_from_user_flushcache(void *dst, const void __user *src, unsigned size)
 {
 	kasan_check_write(dst, size);
<span class="p_del">-	return __copy_user_flushcache(dst, src, size);</span>
<span class="p_add">+	return __copy_user_flushcache(dst, __uaccess_mask_ptr(src), size);</span>
 }
 #endif
 
<span class="p_header">diff --git a/arch/arm64/kernel/Makefile b/arch/arm64/kernel/Makefile</span>
<span class="p_header">index 2f5ff2a65db3..def8d5623fd1 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/Makefile</span>
<span class="p_header">+++ b/arch/arm64/kernel/Makefile</span>
<span class="p_chunk">@@ -55,6 +55,10 @@</span> <span class="p_context"> arm64-obj-$(CONFIG_ARM64_RELOC_TEST)	+= arm64-reloc-test.o</span>
 arm64-reloc-test-y := reloc_test_core.o reloc_test_syms.o
 arm64-obj-$(CONFIG_CRASH_DUMP)		+= crash_dump.o
 
<span class="p_add">+ifeq ($(CONFIG_KVM),y)</span>
<span class="p_add">+arm64-obj-$(CONFIG_HARDEN_BRANCH_PREDICTOR)	+= bpi.o</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 obj-y					+= $(arm64-obj-y) vdso/ probes/
 obj-m					+= $(arm64-obj-m)
 head-y					:= head.o
<span class="p_header">diff --git a/arch/arm64/kernel/arm64ksyms.c b/arch/arm64/kernel/arm64ksyms.c</span>
<span class="p_header">index 67368c7329c0..66be504edb6c 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/arm64ksyms.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/arm64ksyms.c</span>
<span class="p_chunk">@@ -37,8 +37,8 @@</span> <span class="p_context"> EXPORT_SYMBOL(clear_page);</span>
 	/* user mem (segment) */
 EXPORT_SYMBOL(__arch_copy_from_user);
 EXPORT_SYMBOL(__arch_copy_to_user);
<span class="p_del">-EXPORT_SYMBOL(__clear_user);</span>
<span class="p_del">-EXPORT_SYMBOL(raw_copy_in_user);</span>
<span class="p_add">+EXPORT_SYMBOL(__arch_clear_user);</span>
<span class="p_add">+EXPORT_SYMBOL(__arch_copy_in_user);</span>
 
 	/* physical memory */
 EXPORT_SYMBOL(memstart_addr);
<span class="p_header">diff --git a/arch/arm64/kernel/asm-offsets.c b/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_header">index 71bf088f1e4b..af247d10252f 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -24,6 +24,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kvm_host.h&gt;
 #include &lt;linux/suspend.h&gt;
 #include &lt;asm/cpufeature.h&gt;
<span class="p_add">+#include &lt;asm/fixmap.h&gt;</span>
 #include &lt;asm/thread_info.h&gt;
 #include &lt;asm/memory.h&gt;
 #include &lt;asm/smp_plat.h&gt;
<span class="p_chunk">@@ -148,11 +149,14 @@</span> <span class="p_context"> int main(void)</span>
   DEFINE(ARM_SMCCC_RES_X2_OFFS,		offsetof(struct arm_smccc_res, a2));
   DEFINE(ARM_SMCCC_QUIRK_ID_OFFS,	offsetof(struct arm_smccc_quirk, id));
   DEFINE(ARM_SMCCC_QUIRK_STATE_OFFS,	offsetof(struct arm_smccc_quirk, state));
<span class="p_del">-</span>
   BLANK();
   DEFINE(HIBERN_PBE_ORIG,	offsetof(struct pbe, orig_address));
   DEFINE(HIBERN_PBE_ADDR,	offsetof(struct pbe, address));
   DEFINE(HIBERN_PBE_NEXT,	offsetof(struct pbe, next));
   DEFINE(ARM64_FTR_SYSVAL,	offsetof(struct arm64_ftr_reg, sys_val));
<span class="p_add">+  BLANK();</span>
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+  DEFINE(TRAMP_VALIAS,		TRAMP_VALIAS);</span>
<span class="p_add">+#endif</span>
   return 0;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/bpi.S b/arch/arm64/kernel/bpi.S</span>
new file mode 100644
<span class="p_header">index 000000000000..e5de33513b5d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/arm64/kernel/bpi.S</span>
<span class="p_chunk">@@ -0,0 +1,83 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Contains CPU specific branch predictor invalidation sequences</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2018 ARM Ltd.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;linux/arm-smccc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+.macro ventry target</span>
<span class="p_add">+	.rept 31</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+	b	\target</span>
<span class="p_add">+.endm</span>
<span class="p_add">+</span>
<span class="p_add">+.macro vectors target</span>
<span class="p_add">+	ventry \target + 0x000</span>
<span class="p_add">+	ventry \target + 0x080</span>
<span class="p_add">+	ventry \target + 0x100</span>
<span class="p_add">+	ventry \target + 0x180</span>
<span class="p_add">+</span>
<span class="p_add">+	ventry \target + 0x200</span>
<span class="p_add">+	ventry \target + 0x280</span>
<span class="p_add">+	ventry \target + 0x300</span>
<span class="p_add">+	ventry \target + 0x380</span>
<span class="p_add">+</span>
<span class="p_add">+	ventry \target + 0x400</span>
<span class="p_add">+	ventry \target + 0x480</span>
<span class="p_add">+	ventry \target + 0x500</span>
<span class="p_add">+	ventry \target + 0x580</span>
<span class="p_add">+</span>
<span class="p_add">+	ventry \target + 0x600</span>
<span class="p_add">+	ventry \target + 0x680</span>
<span class="p_add">+	ventry \target + 0x700</span>
<span class="p_add">+	ventry \target + 0x780</span>
<span class="p_add">+.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.align	11</span>
<span class="p_add">+ENTRY(__bp_harden_hyp_vecs_start)</span>
<span class="p_add">+	.rept 4</span>
<span class="p_add">+	vectors __kvm_hyp_vector</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+ENTRY(__bp_harden_hyp_vecs_end)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__qcom_hyp_sanitize_link_stack_start)</span>
<span class="p_add">+	stp     x29, x30, [sp, #-16]!</span>
<span class="p_add">+	.rept	16</span>
<span class="p_add">+	bl	. + 4</span>
<span class="p_add">+	.endr</span>
<span class="p_add">+	ldp	x29, x30, [sp], #16</span>
<span class="p_add">+ENTRY(__qcom_hyp_sanitize_link_stack_end)</span>
<span class="p_add">+</span>
<span class="p_add">+.macro smccc_workaround_1 inst</span>
<span class="p_add">+	sub	sp, sp, #(8 * 4)</span>
<span class="p_add">+	stp	x2, x3, [sp, #(8 * 0)]</span>
<span class="p_add">+	stp	x0, x1, [sp, #(8 * 2)]</span>
<span class="p_add">+	mov	w0, #ARM_SMCCC_ARCH_WORKAROUND_1</span>
<span class="p_add">+	\inst	#0</span>
<span class="p_add">+	ldp	x2, x3, [sp, #(8 * 0)]</span>
<span class="p_add">+	ldp	x0, x1, [sp, #(8 * 2)]</span>
<span class="p_add">+	add	sp, sp, #(8 * 4)</span>
<span class="p_add">+.endm</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__smccc_workaround_1_smc_start)</span>
<span class="p_add">+	smccc_workaround_1	smc</span>
<span class="p_add">+ENTRY(__smccc_workaround_1_smc_end)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__smccc_workaround_1_hvc_start)</span>
<span class="p_add">+	smccc_workaround_1	hvc</span>
<span class="p_add">+ENTRY(__smccc_workaround_1_hvc_end)</span>
<span class="p_header">diff --git a/arch/arm64/kernel/cpu-reset.S b/arch/arm64/kernel/cpu-reset.S</span>
<span class="p_header">index 65f42d257414..8021b46c9743 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpu-reset.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpu-reset.S</span>
<span class="p_chunk">@@ -16,7 +16,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/virt.h&gt;
 
 .text
<span class="p_del">-.pushsection    .idmap.text, &quot;ax&quot;</span>
<span class="p_add">+.pushsection    .idmap.text, &quot;awx&quot;</span>
 
 /*
  * __cpu_soft_restart(el2_switch, entry, arg0, arg1, arg2) - Helper for
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"> ENTRY(__cpu_soft_restart)</span>
 	mrs	x12, sctlr_el1
 	ldr	x13, =SCTLR_ELx_FLAGS
 	bic	x12, x12, x13
<span class="p_add">+	pre_disable_mmu_workaround</span>
 	msr	sctlr_el1, x12
 	isb
 
<span class="p_header">diff --git a/arch/arm64/kernel/cpu_errata.c b/arch/arm64/kernel/cpu_errata.c</span>
<span class="p_header">index 0e27f86ee709..07823595b7f0 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpu_errata.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpu_errata.c</span>
<span class="p_chunk">@@ -30,6 +30,20 @@</span> <span class="p_context"> is_affected_midr_range(const struct arm64_cpu_capabilities *entry, int scope)</span>
 				       entry-&gt;midr_range_max);
 }
 
<span class="p_add">+static bool __maybe_unused</span>
<span class="p_add">+is_kryo_midr(const struct arm64_cpu_capabilities *entry, int scope)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 model;</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON(scope != SCOPE_LOCAL_CPU || preemptible());</span>
<span class="p_add">+</span>
<span class="p_add">+	model = read_cpuid_id();</span>
<span class="p_add">+	model &amp;= MIDR_IMPLEMENTOR_MASK | (0xf00 &lt;&lt; MIDR_PARTNUM_SHIFT) |</span>
<span class="p_add">+		 MIDR_ARCHITECTURE_MASK;</span>
<span class="p_add">+</span>
<span class="p_add">+	return model == entry-&gt;midr_model;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool
 has_mismatched_cache_line_size(const struct arm64_cpu_capabilities *entry,
 				int scope)
<span class="p_chunk">@@ -46,6 +60,174 @@</span> <span class="p_context"> static int cpu_enable_trap_ctr_access(void *__unused)</span>
 	return 0;
 }
 
<span class="p_add">+#ifdef CONFIG_HARDEN_BRANCH_PREDICTOR</span>
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;asm/cacheflush.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+DEFINE_PER_CPU_READ_MOSTLY(struct bp_hardening_data, bp_hardening_data);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_KVM</span>
<span class="p_add">+extern char __qcom_hyp_sanitize_link_stack_start[];</span>
<span class="p_add">+extern char __qcom_hyp_sanitize_link_stack_end[];</span>
<span class="p_add">+extern char __smccc_workaround_1_smc_start[];</span>
<span class="p_add">+extern char __smccc_workaround_1_smc_end[];</span>
<span class="p_add">+extern char __smccc_workaround_1_hvc_start[];</span>
<span class="p_add">+extern char __smccc_workaround_1_hvc_end[];</span>
<span class="p_add">+</span>
<span class="p_add">+static void __copy_hyp_vect_bpi(int slot, const char *hyp_vecs_start,</span>
<span class="p_add">+				const char *hyp_vecs_end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *dst = lm_alias(__bp_harden_hyp_vecs_start + slot * SZ_2K);</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; SZ_2K; i += 0x80)</span>
<span class="p_add">+		memcpy(dst + i, hyp_vecs_start, hyp_vecs_end - hyp_vecs_start);</span>
<span class="p_add">+</span>
<span class="p_add">+	flush_icache_range((uintptr_t)dst, (uintptr_t)dst + SZ_2K);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __install_bp_hardening_cb(bp_hardening_cb_t fn,</span>
<span class="p_add">+				      const char *hyp_vecs_start,</span>
<span class="p_add">+				      const char *hyp_vecs_end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int last_slot = -1;</span>
<span class="p_add">+	static DEFINE_SPINLOCK(bp_lock);</span>
<span class="p_add">+	int cpu, slot = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;bp_lock);</span>
<span class="p_add">+	for_each_possible_cpu(cpu) {</span>
<span class="p_add">+		if (per_cpu(bp_hardening_data.fn, cpu) == fn) {</span>
<span class="p_add">+			slot = per_cpu(bp_hardening_data.hyp_vectors_slot, cpu);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (slot == -1) {</span>
<span class="p_add">+		last_slot++;</span>
<span class="p_add">+		BUG_ON(((__bp_harden_hyp_vecs_end - __bp_harden_hyp_vecs_start)</span>
<span class="p_add">+			/ SZ_2K) &lt;= last_slot);</span>
<span class="p_add">+		slot = last_slot;</span>
<span class="p_add">+		__copy_hyp_vect_bpi(slot, hyp_vecs_start, hyp_vecs_end);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	__this_cpu_write(bp_hardening_data.hyp_vectors_slot, slot);</span>
<span class="p_add">+	__this_cpu_write(bp_hardening_data.fn, fn);</span>
<span class="p_add">+	spin_unlock(&amp;bp_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define __qcom_hyp_sanitize_link_stack_start	NULL</span>
<span class="p_add">+#define __qcom_hyp_sanitize_link_stack_end	NULL</span>
<span class="p_add">+#define __smccc_workaround_1_smc_start		NULL</span>
<span class="p_add">+#define __smccc_workaround_1_smc_end		NULL</span>
<span class="p_add">+#define __smccc_workaround_1_hvc_start		NULL</span>
<span class="p_add">+#define __smccc_workaround_1_hvc_end		NULL</span>
<span class="p_add">+</span>
<span class="p_add">+static void __install_bp_hardening_cb(bp_hardening_cb_t fn,</span>
<span class="p_add">+				      const char *hyp_vecs_start,</span>
<span class="p_add">+				      const char *hyp_vecs_end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__this_cpu_write(bp_hardening_data.fn, fn);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif	/* CONFIG_KVM */</span>
<span class="p_add">+</span>
<span class="p_add">+static void  install_bp_hardening_cb(const struct arm64_cpu_capabilities *entry,</span>
<span class="p_add">+				     bp_hardening_cb_t fn,</span>
<span class="p_add">+				     const char *hyp_vecs_start,</span>
<span class="p_add">+				     const char *hyp_vecs_end)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 pfr0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!entry-&gt;matches(entry, SCOPE_LOCAL_CPU))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pfr0 = read_cpuid(ID_AA64PFR0_EL1);</span>
<span class="p_add">+	if (cpuid_feature_extract_unsigned_field(pfr0, ID_AA64PFR0_CSV2_SHIFT))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	__install_bp_hardening_cb(fn, hyp_vecs_start, hyp_vecs_end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;uapi/linux/psci.h&gt;</span>
<span class="p_add">+#include &lt;linux/arm-smccc.h&gt;</span>
<span class="p_add">+#include &lt;linux/psci.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static void call_smc_arch_workaround_1(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_smccc_1_1_smc(ARM_SMCCC_ARCH_WORKAROUND_1, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void call_hvc_arch_workaround_1(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	arm_smccc_1_1_hvc(ARM_SMCCC_ARCH_WORKAROUND_1, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int enable_smccc_arch_workaround_1(void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct arm64_cpu_capabilities *entry = data;</span>
<span class="p_add">+	bp_hardening_cb_t cb;</span>
<span class="p_add">+	void *smccc_start, *smccc_end;</span>
<span class="p_add">+	struct arm_smccc_res res;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!entry-&gt;matches(entry, SCOPE_LOCAL_CPU))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (psci_ops.smccc_version == SMCCC_VERSION_1_0)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (psci_ops.conduit) {</span>
<span class="p_add">+	case PSCI_CONDUIT_HVC:</span>
<span class="p_add">+		arm_smccc_1_1_hvc(ARM_SMCCC_ARCH_FEATURES_FUNC_ID,</span>
<span class="p_add">+				  ARM_SMCCC_ARCH_WORKAROUND_1, &amp;res);</span>
<span class="p_add">+		if (res.a0)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		cb = call_hvc_arch_workaround_1;</span>
<span class="p_add">+		smccc_start = __smccc_workaround_1_hvc_start;</span>
<span class="p_add">+		smccc_end = __smccc_workaround_1_hvc_end;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case PSCI_CONDUIT_SMC:</span>
<span class="p_add">+		arm_smccc_1_1_smc(ARM_SMCCC_ARCH_FEATURES_FUNC_ID,</span>
<span class="p_add">+				  ARM_SMCCC_ARCH_WORKAROUND_1, &amp;res);</span>
<span class="p_add">+		if (res.a0)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		cb = call_smc_arch_workaround_1;</span>
<span class="p_add">+		smccc_start = __smccc_workaround_1_smc_start;</span>
<span class="p_add">+		smccc_end = __smccc_workaround_1_smc_end;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	install_bp_hardening_cb(entry, cb, smccc_start, smccc_end);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void qcom_link_stack_sanitization(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	asm volatile(&quot;mov	%0, x30		\n&quot;</span>
<span class="p_add">+		     &quot;.rept	16		\n&quot;</span>
<span class="p_add">+		     &quot;bl	. + 4		\n&quot;</span>
<span class="p_add">+		     &quot;.endr			\n&quot;</span>
<span class="p_add">+		     &quot;mov	x30, %0		\n&quot;</span>
<span class="p_add">+		     : &quot;=&amp;r&quot; (tmp));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int qcom_enable_link_stack_sanitization(void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct arm64_cpu_capabilities *entry = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	install_bp_hardening_cb(entry, qcom_link_stack_sanitization,</span>
<span class="p_add">+				__qcom_hyp_sanitize_link_stack_start,</span>
<span class="p_add">+				__qcom_hyp_sanitize_link_stack_end);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif	/* CONFIG_HARDEN_BRANCH_PREDICTOR */</span>
<span class="p_add">+</span>
 #define MIDR_RANGE(model, min, max) \
 	.def_scope = SCOPE_LOCAL_CPU, \
 	.matches = is_affected_midr_range, \
<span class="p_chunk">@@ -169,6 +351,13 @@</span> <span class="p_context"> const struct arm64_cpu_capabilities arm64_errata[] = {</span>
 			   MIDR_CPU_VAR_REV(0, 0),
 			   MIDR_CPU_VAR_REV(0, 0)),
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		.desc = &quot;Qualcomm Technologies Kryo erratum 1003&quot;,</span>
<span class="p_add">+		.capability = ARM64_WORKAROUND_QCOM_FALKOR_E1003,</span>
<span class="p_add">+		.def_scope = SCOPE_LOCAL_CPU,</span>
<span class="p_add">+		.midr_model = MIDR_QCOM_KRYO,</span>
<span class="p_add">+		.matches = is_kryo_midr,</span>
<span class="p_add">+	},</span>
 #endif
 #ifdef CONFIG_QCOM_FALKOR_ERRATUM_1009
 	{
<span class="p_chunk">@@ -186,6 +375,47 @@</span> <span class="p_context"> const struct arm64_cpu_capabilities arm64_errata[] = {</span>
 		.capability = ARM64_WORKAROUND_858921,
 		MIDR_ALL_VERSIONS(MIDR_CORTEX_A73),
 	},
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_HARDEN_BRANCH_PREDICTOR</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BRANCH_PREDICTOR,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_CORTEX_A57),</span>
<span class="p_add">+		.enable = enable_smccc_arch_workaround_1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BRANCH_PREDICTOR,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_CORTEX_A72),</span>
<span class="p_add">+		.enable = enable_smccc_arch_workaround_1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BRANCH_PREDICTOR,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_CORTEX_A73),</span>
<span class="p_add">+		.enable = enable_smccc_arch_workaround_1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BRANCH_PREDICTOR,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_CORTEX_A75),</span>
<span class="p_add">+		.enable = enable_smccc_arch_workaround_1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BRANCH_PREDICTOR,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_QCOM_FALKOR_V1),</span>
<span class="p_add">+		.enable = qcom_enable_link_stack_sanitization,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BP_POST_GUEST_EXIT,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_QCOM_FALKOR_V1),</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BRANCH_PREDICTOR,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_BRCM_VULCAN),</span>
<span class="p_add">+		.enable = enable_smccc_arch_workaround_1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.capability = ARM64_HARDEN_BRANCH_PREDICTOR,</span>
<span class="p_add">+		MIDR_ALL_VERSIONS(MIDR_CAVIUM_THUNDERX2),</span>
<span class="p_add">+		.enable = enable_smccc_arch_workaround_1,</span>
<span class="p_add">+	},</span>
 #endif
 	{
 	}
<span class="p_chunk">@@ -200,15 +430,18 @@</span> <span class="p_context"> void verify_local_cpu_errata_workarounds(void)</span>
 {
 	const struct arm64_cpu_capabilities *caps = arm64_errata;
 
<span class="p_del">-	for (; caps-&gt;matches; caps++)</span>
<span class="p_del">-		if (!cpus_have_cap(caps-&gt;capability) &amp;&amp;</span>
<span class="p_del">-			caps-&gt;matches(caps, SCOPE_LOCAL_CPU)) {</span>
<span class="p_add">+	for (; caps-&gt;matches; caps++) {</span>
<span class="p_add">+		if (cpus_have_cap(caps-&gt;capability)) {</span>
<span class="p_add">+			if (caps-&gt;enable)</span>
<span class="p_add">+				caps-&gt;enable((void *)caps);</span>
<span class="p_add">+		} else if (caps-&gt;matches(caps, SCOPE_LOCAL_CPU)) {</span>
 			pr_crit(&quot;CPU%d: Requires work around for %s, not detected&quot;
 					&quot; at boot time\n&quot;,
 				smp_processor_id(),
 				caps-&gt;desc ? : &quot;an erratum&quot;);
 			cpu_die_early();
 		}
<span class="p_add">+	}</span>
 }
 
 void update_cpu_errata_workarounds(void)
<span class="p_header">diff --git a/arch/arm64/kernel/cpufeature.c b/arch/arm64/kernel/cpufeature.c</span>
<span class="p_header">index 21e2c95d24e7..582142ae92e1 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpufeature.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpufeature.c</span>
<span class="p_chunk">@@ -125,6 +125,8 @@</span> <span class="p_context"> static const struct arm64_ftr_bits ftr_id_aa64isar1[] = {</span>
 };
 
 static const struct arm64_ftr_bits ftr_id_aa64pfr0[] = {
<span class="p_add">+	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_LOWER_SAFE, ID_AA64PFR0_CSV3_SHIFT, 4, 0),</span>
<span class="p_add">+	ARM64_FTR_BITS(FTR_HIDDEN, FTR_NONSTRICT, FTR_LOWER_SAFE, ID_AA64PFR0_CSV2_SHIFT, 4, 0),</span>
 	ARM64_FTR_BITS(FTR_HIDDEN, FTR_STRICT, FTR_EXACT, ID_AA64PFR0_GIC_SHIFT, 4, 0),
 	S_ARM64_FTR_BITS(FTR_VISIBLE, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64PFR0_ASIMD_SHIFT, 4, ID_AA64PFR0_ASIMD_NI),
 	S_ARM64_FTR_BITS(FTR_VISIBLE, FTR_STRICT, FTR_LOWER_SAFE, ID_AA64PFR0_FP_SHIFT, 4, ID_AA64PFR0_FP_NI),
<span class="p_chunk">@@ -796,6 +798,86 @@</span> <span class="p_context"> static bool has_no_fpsimd(const struct arm64_cpu_capabilities *entry, int __unus</span>
 					ID_AA64PFR0_FP_SHIFT) &lt; 0;
 }
 
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+static int __kpti_forced; /* 0: not forced, &gt;0: forced on, &lt;0: forced off */</span>
<span class="p_add">+</span>
<span class="p_add">+static bool unmap_kernel_at_el0(const struct arm64_cpu_capabilities *entry,</span>
<span class="p_add">+				int __unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char const *str = &quot;command line option&quot;;</span>
<span class="p_add">+	u64 pfr0 = read_sanitised_ftr_reg(SYS_ID_AA64PFR0_EL1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For reasons that aren&#39;t entirely clear, enabling KPTI on Cavium</span>
<span class="p_add">+	 * ThunderX leads to apparent I-cache corruption of kernel text, which</span>
<span class="p_add">+	 * ends as well as you might imagine. Don&#39;t even try.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpus_have_const_cap(ARM64_WORKAROUND_CAVIUM_27456)) {</span>
<span class="p_add">+		str = &quot;ARM64_WORKAROUND_CAVIUM_27456&quot;;</span>
<span class="p_add">+		__kpti_forced = -1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Forced? */</span>
<span class="p_add">+	if (__kpti_forced) {</span>
<span class="p_add">+		pr_info_once(&quot;kernel page table isolation forced %s by %s\n&quot;,</span>
<span class="p_add">+			     __kpti_forced &gt; 0 ? &quot;ON&quot; : &quot;OFF&quot;, str);</span>
<span class="p_add">+		return __kpti_forced &gt; 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Useful for KASLR robustness */</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Don&#39;t force KPTI for CPUs that are not vulnerable */</span>
<span class="p_add">+	switch (read_cpuid_id() &amp; MIDR_CPU_MODEL_MASK) {</span>
<span class="p_add">+	case MIDR_CAVIUM_THUNDERX2:</span>
<span class="p_add">+	case MIDR_BRCM_VULCAN:</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Defer to CPU feature registers */</span>
<span class="p_add">+	return !cpuid_feature_extract_unsigned_field(pfr0,</span>
<span class="p_add">+						     ID_AA64PFR0_CSV3_SHIFT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int kpti_install_ng_mappings(void *__unused)</span>
<span class="p_add">+{</span>
<span class="p_add">+	typedef void (kpti_remap_fn)(int, int, phys_addr_t);</span>
<span class="p_add">+	extern kpti_remap_fn idmap_kpti_install_ng_mappings;</span>
<span class="p_add">+	kpti_remap_fn *remap_fn;</span>
<span class="p_add">+</span>
<span class="p_add">+	static bool kpti_applied = false;</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (kpti_applied)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	remap_fn = (void *)__pa_symbol(idmap_kpti_install_ng_mappings);</span>
<span class="p_add">+</span>
<span class="p_add">+	cpu_install_idmap();</span>
<span class="p_add">+	remap_fn(cpu, num_online_cpus(), __pa_symbol(swapper_pg_dir));</span>
<span class="p_add">+	cpu_uninstall_idmap();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!cpu)</span>
<span class="p_add">+		kpti_applied = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init parse_kpti(char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool enabled;</span>
<span class="p_add">+	int ret = strtobool(str, &amp;enabled);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	__kpti_forced = enabled ? 1 : -1;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;kpti=&quot;, parse_kpti);</span>
<span class="p_add">+#endif	/* CONFIG_UNMAP_KERNEL_AT_EL0 */</span>
<span class="p_add">+</span>
 static const struct arm64_cpu_capabilities arm64_features[] = {
 	{
 		.desc = &quot;GIC system register CPU interface&quot;,
<span class="p_chunk">@@ -882,6 +964,15 @@</span> <span class="p_context"> static const struct arm64_cpu_capabilities arm64_features[] = {</span>
 		.def_scope = SCOPE_SYSTEM,
 		.matches = hyp_offset_low,
 	},
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.desc = &quot;Kernel page table isolation (KPTI)&quot;,</span>
<span class="p_add">+		.capability = ARM64_UNMAP_KERNEL_AT_EL0,</span>
<span class="p_add">+		.def_scope = SCOPE_SYSTEM,</span>
<span class="p_add">+		.matches = unmap_kernel_at_el0,</span>
<span class="p_add">+		.enable = kpti_install_ng_mappings,</span>
<span class="p_add">+	},</span>
<span class="p_add">+#endif</span>
 	{
 		/* FP/SIMD is not implemented */
 		.capability = ARM64_HAS_NO_FPSIMD,
<span class="p_chunk">@@ -1000,6 +1091,25 @@</span> <span class="p_context"> static void __init setup_elf_hwcaps(const struct arm64_cpu_capabilities *hwcaps)</span>
 			cap_set_elf_hwcap(hwcaps);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Check if the current CPU has a given feature capability.</span>
<span class="p_add">+ * Should be called from non-preemptible context.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool __this_cpu_has_cap(const struct arm64_cpu_capabilities *cap_array,</span>
<span class="p_add">+			       unsigned int cap)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct arm64_cpu_capabilities *caps;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (WARN_ON(preemptible()))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (caps = cap_array; caps-&gt;matches; caps++)</span>
<span class="p_add">+		if (caps-&gt;capability == cap &amp;&amp;</span>
<span class="p_add">+		    caps-&gt;matches(caps, SCOPE_LOCAL_CPU))</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void update_cpu_capabilities(const struct arm64_cpu_capabilities *caps,
 			    const char *info)
 {
<span class="p_chunk">@@ -1035,7 +1145,7 @@</span> <span class="p_context"> void __init enable_cpu_capabilities(const struct arm64_cpu_capabilities *caps)</span>
 			 * uses an IPI, giving us a PSTATE that disappears when
 			 * we return.
 			 */
<span class="p_del">-			stop_machine(caps-&gt;enable, NULL, cpu_online_mask);</span>
<span class="p_add">+			stop_machine(caps-&gt;enable, (void *)caps, cpu_online_mask);</span>
 		}
 	}
 }
<span class="p_chunk">@@ -1078,8 +1188,9 @@</span> <span class="p_context"> verify_local_elf_hwcaps(const struct arm64_cpu_capabilities *caps)</span>
 }
 
 static void
<span class="p_del">-verify_local_cpu_features(const struct arm64_cpu_capabilities *caps)</span>
<span class="p_add">+verify_local_cpu_features(const struct arm64_cpu_capabilities *caps_list)</span>
 {
<span class="p_add">+	const struct arm64_cpu_capabilities *caps = caps_list;</span>
 	for (; caps-&gt;matches; caps++) {
 		if (!cpus_have_cap(caps-&gt;capability))
 			continue;
<span class="p_chunk">@@ -1087,13 +1198,13 @@</span> <span class="p_context"> verify_local_cpu_features(const struct arm64_cpu_capabilities *caps)</span>
 		 * If the new CPU misses an advertised feature, we cannot proceed
 		 * further, park the cpu.
 		 */
<span class="p_del">-		if (!caps-&gt;matches(caps, SCOPE_LOCAL_CPU)) {</span>
<span class="p_add">+		if (!__this_cpu_has_cap(caps_list, caps-&gt;capability)) {</span>
 			pr_crit(&quot;CPU%d: missing feature: %s\n&quot;,
 					smp_processor_id(), caps-&gt;desc);
 			cpu_die_early();
 		}
 		if (caps-&gt;enable)
<span class="p_del">-			caps-&gt;enable(NULL);</span>
<span class="p_add">+			caps-&gt;enable((void *)caps);</span>
 	}
 }
 
<span class="p_chunk">@@ -1148,25 +1259,6 @@</span> <span class="p_context"> static void __init mark_const_caps_ready(void)</span>
 	static_branch_enable(&amp;arm64_const_caps_ready);
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Check if the current CPU has a given feature capability.</span>
<span class="p_del">- * Should be called from non-preemptible context.</span>
<span class="p_del">- */</span>
<span class="p_del">-static bool __this_cpu_has_cap(const struct arm64_cpu_capabilities *cap_array,</span>
<span class="p_del">-			       unsigned int cap)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct arm64_cpu_capabilities *caps;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (WARN_ON(preemptible()))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (caps = cap_array; caps-&gt;desc; caps++)</span>
<span class="p_del">-		if (caps-&gt;capability == cap &amp;&amp; caps-&gt;matches)</span>
<span class="p_del">-			return caps-&gt;matches(caps, SCOPE_LOCAL_CPU);</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 extern const struct arm64_cpu_capabilities arm64_errata[];
 
 bool this_cpu_has_cap(unsigned int cap)
<span class="p_header">diff --git a/arch/arm64/kernel/efi-entry.S b/arch/arm64/kernel/efi-entry.S</span>
<span class="p_header">index 4e6ad355bd05..6b9736c3fb56 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/efi-entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/efi-entry.S</span>
<span class="p_chunk">@@ -96,6 +96,7 @@</span> <span class="p_context"> ENTRY(entry)</span>
 	mrs	x0, sctlr_el2
 	bic	x0, x0, #1 &lt;&lt; 0	// clear SCTLR.M
 	bic	x0, x0, #1 &lt;&lt; 2	// clear SCTLR.C
<span class="p_add">+	pre_disable_mmu_workaround</span>
 	msr	sctlr_el2, x0
 	isb
 	b	2f
<span class="p_chunk">@@ -103,6 +104,7 @@</span> <span class="p_context"> ENTRY(entry)</span>
 	mrs	x0, sctlr_el1
 	bic	x0, x0, #1 &lt;&lt; 0	// clear SCTLR.M
 	bic	x0, x0, #1 &lt;&lt; 2	// clear SCTLR.C
<span class="p_add">+	pre_disable_mmu_workaround</span>
 	msr	sctlr_el1, x0
 	isb
 2:
<span class="p_header">diff --git a/arch/arm64/kernel/entry.S b/arch/arm64/kernel/entry.S</span>
<span class="p_header">index e1c59d4008a8..93958d1341bb 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/entry.S</span>
<span class="p_chunk">@@ -29,6 +29,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/esr.h&gt;
 #include &lt;asm/irq.h&gt;
 #include &lt;asm/memory.h&gt;
<span class="p_add">+#include &lt;asm/mmu.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
 #include &lt;asm/ptrace.h&gt;
 #include &lt;asm/thread_info.h&gt;
 #include &lt;asm/asm-uaccess.h&gt;
<span class="p_chunk">@@ -69,8 +71,21 @@</span> <span class="p_context"></span>
 #define BAD_FIQ		2
 #define BAD_ERROR	3
 
<span class="p_del">-	.macro kernel_ventry	label</span>
<span class="p_add">+	.macro kernel_ventry, el, label, regsize = 64</span>
 	.align 7
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+alternative_if ARM64_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+	.if	\el == 0</span>
<span class="p_add">+	.if	\regsize == 64</span>
<span class="p_add">+	mrs	x30, tpidrro_el0</span>
<span class="p_add">+	msr	tpidrro_el0, xzr</span>
<span class="p_add">+	.else</span>
<span class="p_add">+	mov	x30, xzr</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+alternative_else_nop_endif</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	sub	sp, sp, #S_FRAME_SIZE
 #ifdef CONFIG_VMAP_STACK
 	/*
<span class="p_chunk">@@ -82,7 +97,7 @@</span> <span class="p_context"></span>
 	tbnz	x0, #THREAD_SHIFT, 0f
 	sub	x0, sp, x0			// x0&#39;&#39; = sp&#39; - x0&#39; = (sp + x0) - sp = x0
 	sub	sp, sp, x0			// sp&#39;&#39; = sp&#39; - x0 = (sp + x0) - x0 = sp
<span class="p_del">-	b	\label</span>
<span class="p_add">+	b	el\()\el\()_\label</span>
 
 0:
 	/*
<span class="p_chunk">@@ -114,7 +129,12 @@</span> <span class="p_context"></span>
 	sub	sp, sp, x0
 	mrs	x0, tpidrro_el0
 #endif
<span class="p_del">-	b	\label</span>
<span class="p_add">+	b	el\()\el\()_\label</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro tramp_alias, dst, sym</span>
<span class="p_add">+	mov_q	\dst, TRAMP_VALIAS</span>
<span class="p_add">+	add	\dst, \dst, #(\sym - .entry.tramp.text)</span>
 	.endm
 
 	.macro	kernel_entry, el, regsize = 64
<span class="p_chunk">@@ -147,10 +167,10 @@</span> <span class="p_context"></span>
 	.else
 	add	x21, sp, #S_FRAME_SIZE
 	get_thread_info tsk
<span class="p_del">-	/* Save the task&#39;s original addr_limit and set USER_DS (TASK_SIZE_64) */</span>
<span class="p_add">+	/* Save the task&#39;s original addr_limit and set USER_DS */</span>
 	ldr	x20, [tsk, #TSK_TI_ADDR_LIMIT]
 	str	x20, [sp, #S_ORIG_ADDR_LIMIT]
<span class="p_del">-	mov	x20, #TASK_SIZE_64</span>
<span class="p_add">+	mov	x20, #USER_DS</span>
 	str	x20, [tsk, #TSK_TI_ADDR_LIMIT]
 	/* No need to reset PSTATE.UAO, hardware&#39;s already set it to 0 for us */
 	.endif /* \el == 0 */
<span class="p_chunk">@@ -185,7 +205,7 @@</span> <span class="p_context"> alternative_else_nop_endif</span>
 
 	.if	\el != 0
 	mrs	x21, ttbr0_el1
<span class="p_del">-	tst	x21, #0xffff &lt;&lt; 48		// Check for the reserved ASID</span>
<span class="p_add">+	tst	x21, #TTBR_ASID_MASK		// Check for the reserved ASID</span>
 	orr	x23, x23, #PSR_PAN_BIT		// Set the emulated PAN in the saved SPSR
 	b.eq	1f				// TTBR0 access already disabled
 	and	x23, x23, #~PSR_PAN_BIT		// Clear the emulated PAN in the saved SPSR
<span class="p_chunk">@@ -246,7 +266,7 @@</span> <span class="p_context"> alternative_else_nop_endif</span>
 	tbnz	x22, #22, 1f			// Skip re-enabling TTBR0 access if the PSR_PAN_BIT is set
 	.endif
 
<span class="p_del">-	__uaccess_ttbr0_enable x0</span>
<span class="p_add">+	__uaccess_ttbr0_enable x0, x1</span>
 
 	.if	\el == 0
 	/*
<span class="p_chunk">@@ -255,7 +275,7 @@</span> <span class="p_context"> alternative_else_nop_endif</span>
 	 * Cavium erratum 27456 (broadcast TLBI instructions may cause I-cache
 	 * corruption).
 	 */
<span class="p_del">-	post_ttbr0_update_workaround</span>
<span class="p_add">+	bl	post_ttbr_update_workaround</span>
 	.endif
 1:
 	.if	\el != 0
<span class="p_chunk">@@ -267,18 +287,20 @@</span> <span class="p_context"> alternative_else_nop_endif</span>
 	.if	\el == 0
 	ldr	x23, [sp, #S_SP]		// load return stack pointer
 	msr	sp_el0, x23
<span class="p_add">+	tst	x22, #PSR_MODE32_BIT		// native task?</span>
<span class="p_add">+	b.eq	3f</span>
<span class="p_add">+</span>
 #ifdef CONFIG_ARM64_ERRATUM_845719
 alternative_if ARM64_WORKAROUND_845719
<span class="p_del">-	tbz	x22, #4, 1f</span>
 #ifdef CONFIG_PID_IN_CONTEXTIDR
 	mrs	x29, contextidr_el1
 	msr	contextidr_el1, x29
 #else
 	msr contextidr_el1, xzr
 #endif
<span class="p_del">-1:</span>
 alternative_else_nop_endif
 #endif
<span class="p_add">+3:</span>
 	.endif
 
 	msr	elr_el1, x21			// set up the return data
<span class="p_chunk">@@ -300,7 +322,21 @@</span> <span class="p_context"> alternative_else_nop_endif</span>
 	ldp	x28, x29, [sp, #16 * 14]
 	ldr	lr, [sp, #S_LR]
 	add	sp, sp, #S_FRAME_SIZE		// restore sp
<span class="p_del">-	eret					// return to kernel</span>
<span class="p_add">+</span>
<span class="p_add">+	.if	\el == 0</span>
<span class="p_add">+alternative_insn eret, nop, ARM64_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+	bne	4f</span>
<span class="p_add">+	msr	far_el1, x30</span>
<span class="p_add">+	tramp_alias	x30, tramp_exit_native</span>
<span class="p_add">+	br	x30</span>
<span class="p_add">+4:</span>
<span class="p_add">+	tramp_alias	x30, tramp_exit_compat</span>
<span class="p_add">+	br	x30</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	.else</span>
<span class="p_add">+	eret</span>
<span class="p_add">+	.endif</span>
 	.endm
 
 	.macro	irq_stack_entry
<span class="p_chunk">@@ -340,6 +376,7 @@</span> <span class="p_context"> alternative_else_nop_endif</span>
  * x7 is reserved for the system call number in 32-bit mode.
  */
 wsc_nr	.req	w25		// number of system calls
<span class="p_add">+xsc_nr	.req	x25		// number of system calls (zero-extended)</span>
 wscno	.req	w26		// syscall number
 xscno	.req	x26		// syscall number (zero-extended)
 stbl	.req	x27		// syscall table pointer
<span class="p_chunk">@@ -365,31 +402,31 @@</span> <span class="p_context"> tsk	.req	x28		// current thread_info</span>
 
 	.align	11
 ENTRY(vectors)
<span class="p_del">-	kernel_ventry	el1_sync_invalid		// Synchronous EL1t</span>
<span class="p_del">-	kernel_ventry	el1_irq_invalid			// IRQ EL1t</span>
<span class="p_del">-	kernel_ventry	el1_fiq_invalid			// FIQ EL1t</span>
<span class="p_del">-	kernel_ventry	el1_error_invalid		// Error EL1t</span>
<span class="p_add">+	kernel_ventry	1, sync_invalid			// Synchronous EL1t</span>
<span class="p_add">+	kernel_ventry	1, irq_invalid			// IRQ EL1t</span>
<span class="p_add">+	kernel_ventry	1, fiq_invalid			// FIQ EL1t</span>
<span class="p_add">+	kernel_ventry	1, error_invalid		// Error EL1t</span>
 
<span class="p_del">-	kernel_ventry	el1_sync			// Synchronous EL1h</span>
<span class="p_del">-	kernel_ventry	el1_irq				// IRQ EL1h</span>
<span class="p_del">-	kernel_ventry	el1_fiq_invalid			// FIQ EL1h</span>
<span class="p_del">-	kernel_ventry	el1_error_invalid		// Error EL1h</span>
<span class="p_add">+	kernel_ventry	1, sync				// Synchronous EL1h</span>
<span class="p_add">+	kernel_ventry	1, irq				// IRQ EL1h</span>
<span class="p_add">+	kernel_ventry	1, fiq_invalid			// FIQ EL1h</span>
<span class="p_add">+	kernel_ventry	1, error_invalid		// Error EL1h</span>
 
<span class="p_del">-	kernel_ventry	el0_sync			// Synchronous 64-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_irq				// IRQ 64-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_fiq_invalid			// FIQ 64-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_error_invalid		// Error 64-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, sync				// Synchronous 64-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, irq				// IRQ 64-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, fiq_invalid			// FIQ 64-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, error_invalid		// Error 64-bit EL0</span>
 
 #ifdef CONFIG_COMPAT
<span class="p_del">-	kernel_ventry	el0_sync_compat			// Synchronous 32-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_irq_compat			// IRQ 32-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_fiq_invalid_compat		// FIQ 32-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_error_invalid_compat	// Error 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, sync_compat, 32		// Synchronous 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, irq_compat, 32		// IRQ 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, fiq_invalid_compat, 32	// FIQ 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, error_invalid_compat, 32	// Error 32-bit EL0</span>
 #else
<span class="p_del">-	kernel_ventry	el0_sync_invalid		// Synchronous 32-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_irq_invalid			// IRQ 32-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_fiq_invalid			// FIQ 32-bit EL0</span>
<span class="p_del">-	kernel_ventry	el0_error_invalid		// Error 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, sync_invalid, 32		// Synchronous 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, irq_invalid, 32		// IRQ 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, fiq_invalid, 32		// FIQ 32-bit EL0</span>
<span class="p_add">+	kernel_ventry	0, error_invalid, 32		// Error 32-bit EL0</span>
 #endif
 END(vectors)
 
<span class="p_chunk">@@ -687,13 +724,15 @@</span> <span class="p_context"> el0_ia:</span>
 	 * Instruction abort handling
 	 */
 	mrs	x26, far_el1
<span class="p_del">-	// enable interrupts before calling the main handler</span>
<span class="p_del">-	enable_dbg_and_irq</span>
<span class="p_add">+	enable_dbg</span>
<span class="p_add">+#ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="p_add">+	bl	trace_hardirqs_off</span>
<span class="p_add">+#endif</span>
 	ct_user_exit
 	mov	x0, x26
 	mov	x1, x25
 	mov	x2, sp
<span class="p_del">-	bl	do_mem_abort</span>
<span class="p_add">+	bl	do_el0_ia_bp_hardening</span>
 	b	ret_to_user
 el0_fpsimd_acc:
 	/*
<span class="p_chunk">@@ -720,8 +759,10 @@</span> <span class="p_context"> el0_sp_pc:</span>
 	 * Stack or PC alignment exception handling
 	 */
 	mrs	x26, far_el1
<span class="p_del">-	// enable interrupts before calling the main handler</span>
<span class="p_del">-	enable_dbg_and_irq</span>
<span class="p_add">+	enable_dbg</span>
<span class="p_add">+#ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="p_add">+	bl	trace_hardirqs_off</span>
<span class="p_add">+#endif</span>
 	ct_user_exit
 	mov	x0, x26
 	mov	x1, x25
<span class="p_chunk">@@ -780,6 +821,11 @@</span> <span class="p_context"> el0_irq_naked:</span>
 #endif
 
 	ct_user_exit
<span class="p_add">+#ifdef CONFIG_HARDEN_BRANCH_PREDICTOR</span>
<span class="p_add">+	tbz	x22, #55, 1f</span>
<span class="p_add">+	bl	do_el0_irq_bp_hardening</span>
<span class="p_add">+1:</span>
<span class="p_add">+#endif</span>
 	irq_handler
 
 #ifdef CONFIG_TRACE_IRQFLAGS
<span class="p_chunk">@@ -848,6 +894,7 @@</span> <span class="p_context"> el0_svc_naked:					// compat entry point</span>
 	b.ne	__sys_trace
 	cmp     wscno, wsc_nr			// check upper syscall limit
 	b.hs	ni_sys
<span class="p_add">+	mask_nospec64 xscno, xsc_nr, x19	// enforce bounds for syscall number</span>
 	ldr	x16, [stbl, xscno, lsl #3]	// address in the syscall table
 	blr	x16				// call sys_* routine
 	b	ret_fast_syscall
<span class="p_chunk">@@ -895,6 +942,117 @@</span> <span class="p_context"> __ni_sys_trace:</span>
 
 	.popsection				// .entry.text
 
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Exception vectors trampoline.</span>
<span class="p_add">+ */</span>
<span class="p_add">+	.pushsection &quot;.entry.tramp.text&quot;, &quot;ax&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro tramp_map_kernel, tmp</span>
<span class="p_add">+	mrs	\tmp, ttbr1_el1</span>
<span class="p_add">+	sub	\tmp, \tmp, #(SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span>
<span class="p_add">+	bic	\tmp, \tmp, #USER_ASID_FLAG</span>
<span class="p_add">+	msr	ttbr1_el1, \tmp</span>
<span class="p_add">+#ifdef CONFIG_QCOM_FALKOR_ERRATUM_1003</span>
<span class="p_add">+alternative_if ARM64_WORKAROUND_QCOM_FALKOR_E1003</span>
<span class="p_add">+	/* ASID already in \tmp[63:48] */</span>
<span class="p_add">+	movk	\tmp, #:abs_g2_nc:(TRAMP_VALIAS &gt;&gt; 12)</span>
<span class="p_add">+	movk	\tmp, #:abs_g1_nc:(TRAMP_VALIAS &gt;&gt; 12)</span>
<span class="p_add">+	/* 2MB boundary containing the vectors, so we nobble the walk cache */</span>
<span class="p_add">+	movk	\tmp, #:abs_g0_nc:((TRAMP_VALIAS &amp; ~(SZ_2M - 1)) &gt;&gt; 12)</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	tlbi	vae1, \tmp</span>
<span class="p_add">+	dsb	nsh</span>
<span class="p_add">+alternative_else_nop_endif</span>
<span class="p_add">+#endif /* CONFIG_QCOM_FALKOR_ERRATUM_1003 */</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro tramp_unmap_kernel, tmp</span>
<span class="p_add">+	mrs	\tmp, ttbr1_el1</span>
<span class="p_add">+	add	\tmp, \tmp, #(SWAPPER_DIR_SIZE + RESERVED_TTBR0_SIZE)</span>
<span class="p_add">+	orr	\tmp, \tmp, #USER_ASID_FLAG</span>
<span class="p_add">+	msr	ttbr1_el1, \tmp</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We avoid running the post_ttbr_update_workaround here because</span>
<span class="p_add">+	 * it&#39;s only needed by Cavium ThunderX, which requires KPTI to be</span>
<span class="p_add">+	 * disabled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro tramp_ventry, regsize = 64</span>
<span class="p_add">+	.align	7</span>
<span class="p_add">+1:</span>
<span class="p_add">+	.if	\regsize == 64</span>
<span class="p_add">+	msr	tpidrro_el0, x30	// Restored in kernel_ventry</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Defend against branch aliasing attacks by pushing a dummy</span>
<span class="p_add">+	 * entry onto the return stack and using a RET instruction to</span>
<span class="p_add">+	 * enter the full-fat kernel vectors.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	bl	2f</span>
<span class="p_add">+	b	.</span>
<span class="p_add">+2:</span>
<span class="p_add">+	tramp_map_kernel	x30</span>
<span class="p_add">+#ifdef CONFIG_RANDOMIZE_BASE</span>
<span class="p_add">+	adr	x30, tramp_vectors + PAGE_SIZE</span>
<span class="p_add">+alternative_insn isb, nop, ARM64_WORKAROUND_QCOM_FALKOR_E1003</span>
<span class="p_add">+	ldr	x30, [x30]</span>
<span class="p_add">+#else</span>
<span class="p_add">+	ldr	x30, =vectors</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	prfm	plil1strm, [x30, #(1b - tramp_vectors)]</span>
<span class="p_add">+	msr	vbar_el1, x30</span>
<span class="p_add">+	add	x30, x30, #(1b - tramp_vectors)</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	ret</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro tramp_exit, regsize = 64</span>
<span class="p_add">+	adr	x30, tramp_vectors</span>
<span class="p_add">+	msr	vbar_el1, x30</span>
<span class="p_add">+	tramp_unmap_kernel	x30</span>
<span class="p_add">+	.if	\regsize == 64</span>
<span class="p_add">+	mrs	x30, far_el1</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+	eret</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.align	11</span>
<span class="p_add">+ENTRY(tramp_vectors)</span>
<span class="p_add">+	.space	0x400</span>
<span class="p_add">+</span>
<span class="p_add">+	tramp_ventry</span>
<span class="p_add">+	tramp_ventry</span>
<span class="p_add">+	tramp_ventry</span>
<span class="p_add">+	tramp_ventry</span>
<span class="p_add">+</span>
<span class="p_add">+	tramp_ventry	32</span>
<span class="p_add">+	tramp_ventry	32</span>
<span class="p_add">+	tramp_ventry	32</span>
<span class="p_add">+	tramp_ventry	32</span>
<span class="p_add">+END(tramp_vectors)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(tramp_exit_native)</span>
<span class="p_add">+	tramp_exit</span>
<span class="p_add">+END(tramp_exit_native)</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(tramp_exit_compat)</span>
<span class="p_add">+	tramp_exit	32</span>
<span class="p_add">+END(tramp_exit_compat)</span>
<span class="p_add">+</span>
<span class="p_add">+	.ltorg</span>
<span class="p_add">+	.popsection				// .entry.tramp.text</span>
<span class="p_add">+#ifdef CONFIG_RANDOMIZE_BASE</span>
<span class="p_add">+	.pushsection &quot;.rodata&quot;, &quot;a&quot;</span>
<span class="p_add">+	.align PAGE_SHIFT</span>
<span class="p_add">+	.globl	__entry_tramp_data_start</span>
<span class="p_add">+__entry_tramp_data_start:</span>
<span class="p_add">+	.quad	vectors</span>
<span class="p_add">+	.popsection				// .rodata</span>
<span class="p_add">+#endif /* CONFIG_RANDOMIZE_BASE */</span>
<span class="p_add">+#endif /* CONFIG_UNMAP_KERNEL_AT_EL0 */</span>
<span class="p_add">+</span>
 /*
  * Special system call wrappers.
  */
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 0b243ecaf7ac..261f3f88364c 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -371,7 +371,7 @@</span> <span class="p_context"> ENDPROC(__primary_switched)</span>
  * end early head section, begin head code that is also used for
  * hotplug and needs to have the same protections as the text region
  */
<span class="p_del">-	.section &quot;.idmap.text&quot;,&quot;ax&quot;</span>
<span class="p_add">+	.section &quot;.idmap.text&quot;,&quot;awx&quot;</span>
 
 ENTRY(kimage_vaddr)
 	.quad		_text - TEXT_OFFSET
<span class="p_chunk">@@ -732,6 +732,7 @@</span> <span class="p_context"> __primary_switch:</span>
 	 * to take into account by discarding the current kernel mapping and
 	 * creating a new one.
 	 */
<span class="p_add">+	pre_disable_mmu_workaround</span>
 	msr	sctlr_el1, x20			// disable the MMU
 	isb
 	bl	__create_page_tables		// recreate kernel mapping
<span class="p_header">diff --git a/arch/arm64/kernel/process.c b/arch/arm64/kernel/process.c</span>
<span class="p_header">index bcd22d7ee590..9e773732520c 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/process.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/process.c</span>
<span class="p_chunk">@@ -314,16 +314,14 @@</span> <span class="p_context"> void tls_preserve_current_state(void)</span>
 
 static void tls_thread_switch(struct task_struct *next)
 {
<span class="p_del">-	unsigned long tpidr, tpidrro;</span>
<span class="p_del">-</span>
 	tls_preserve_current_state();
 
<span class="p_del">-	tpidr = *task_user_tls(next);</span>
<span class="p_del">-	tpidrro = is_compat_thread(task_thread_info(next)) ?</span>
<span class="p_del">-		  next-&gt;thread.tp_value : 0;</span>
<span class="p_add">+	if (is_compat_thread(task_thread_info(next)))</span>
<span class="p_add">+		write_sysreg(next-&gt;thread.tp_value, tpidrro_el0);</span>
<span class="p_add">+	else if (!arm64_kernel_unmapped_at_el0())</span>
<span class="p_add">+		write_sysreg(0, tpidrro_el0);</span>
 
<span class="p_del">-	write_sysreg(tpidr, tpidr_el0);</span>
<span class="p_del">-	write_sysreg(tpidrro, tpidrro_el0);</span>
<span class="p_add">+	write_sysreg(*task_user_tls(next), tpidr_el0);</span>
 }
 
 /* Restore the UAO state depending on next&#39;s addr_limit */
<span class="p_header">diff --git a/arch/arm64/kernel/relocate_kernel.S b/arch/arm64/kernel/relocate_kernel.S</span>
<span class="p_header">index ce704a4aeadd..f407e422a720 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/relocate_kernel.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/relocate_kernel.S</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> ENTRY(arm64_relocate_new_kernel)</span>
 	mrs	x0, sctlr_el2
 	ldr	x1, =SCTLR_ELx_FLAGS
 	bic	x0, x0, x1
<span class="p_add">+	pre_disable_mmu_workaround</span>
 	msr	sctlr_el2, x0
 	isb
 1:
<span class="p_header">diff --git a/arch/arm64/kernel/sleep.S b/arch/arm64/kernel/sleep.S</span>
<span class="p_header">index 10dd16d7902d..bebec8ef9372 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/sleep.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/sleep.S</span>
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> ENTRY(__cpu_suspend_enter)</span>
 	ret
 ENDPROC(__cpu_suspend_enter)
 
<span class="p_del">-	.pushsection &quot;.idmap.text&quot;, &quot;ax&quot;</span>
<span class="p_add">+	.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span>
 ENTRY(cpu_resume)
 	bl	el2_setup		// if in EL2 drop to EL1 cleanly
 	bl	__cpu_setup
<span class="p_header">diff --git a/arch/arm64/kernel/vmlinux.lds.S b/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_header">index 7da3e5c366a0..ddfd3c0942f7 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -57,6 +57,17 @@</span> <span class="p_context"> jiffies = jiffies_64;</span>
 #define HIBERNATE_TEXT
 #endif
 
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+#define TRAMP_TEXT					\</span>
<span class="p_add">+	. = ALIGN(PAGE_SIZE);				\</span>
<span class="p_add">+	VMLINUX_SYMBOL(__entry_tramp_text_start) = .;	\</span>
<span class="p_add">+	*(.entry.tramp.text)				\</span>
<span class="p_add">+	. = ALIGN(PAGE_SIZE);				\</span>
<span class="p_add">+	VMLINUX_SYMBOL(__entry_tramp_text_end) = .;</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define TRAMP_TEXT</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * The size of the PE/COFF section that covers the kernel image, which
  * runs from stext to _edata, must be a round multiple of the PE/COFF
<span class="p_chunk">@@ -113,6 +124,7 @@</span> <span class="p_context"> SECTIONS</span>
 			HYPERVISOR_TEXT
 			IDMAP_TEXT
 			HIBERNATE_TEXT
<span class="p_add">+			TRAMP_TEXT</span>
 			*(.fixup)
 			*(.gnu.warning)
 		. = ALIGN(16);
<span class="p_chunk">@@ -214,6 +226,11 @@</span> <span class="p_context"> SECTIONS</span>
 	. += RESERVED_TTBR0_SIZE;
 #endif
 
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+	tramp_pg_dir = .;</span>
<span class="p_add">+	. += PAGE_SIZE;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	__pecoff_data_size = ABSOLUTE(. - __initdata_begin);
 	_end = .;
 
<span class="p_chunk">@@ -234,7 +251,10 @@</span> <span class="p_context"> ASSERT(__idmap_text_end - (__idmap_text_start &amp; ~(SZ_4K - 1)) &lt;= SZ_4K,</span>
 ASSERT(__hibernate_exit_text_end - (__hibernate_exit_text_start &amp; ~(SZ_4K - 1))
 	&lt;= SZ_4K, &quot;Hibernate exit text too big or misaligned&quot;)
 #endif
<span class="p_del">-</span>
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+ASSERT((__entry_tramp_text_end - __entry_tramp_text_start) == PAGE_SIZE,</span>
<span class="p_add">+	&quot;Entry trampoline text too big&quot;)</span>
<span class="p_add">+#endif</span>
 /*
  * If padding is applied before .head.text, virt&lt;-&gt;phys conversions will fail.
  */
<span class="p_header">diff --git a/arch/arm64/kvm/handle_exit.c b/arch/arm64/kvm/handle_exit.c</span>
<span class="p_header">index 380261e258ef..ab48c5ed3943 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/handle_exit.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/handle_exit.c</span>
<span class="p_chunk">@@ -22,12 +22,13 @@</span> <span class="p_context"></span>
 #include &lt;linux/kvm.h&gt;
 #include &lt;linux/kvm_host.h&gt;
 
<span class="p_add">+#include &lt;kvm/arm_psci.h&gt;</span>
<span class="p_add">+</span>
 #include &lt;asm/esr.h&gt;
 #include &lt;asm/kvm_asm.h&gt;
 #include &lt;asm/kvm_coproc.h&gt;
 #include &lt;asm/kvm_emulate.h&gt;
 #include &lt;asm/kvm_mmu.h&gt;
<span class="p_del">-#include &lt;asm/kvm_psci.h&gt;</span>
 
 #define CREATE_TRACE_POINTS
 #include &quot;trace.h&quot;
<span class="p_chunk">@@ -42,7 +43,7 @@</span> <span class="p_context"> static int handle_hvc(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 			    kvm_vcpu_hvc_get_imm(vcpu));
 	vcpu-&gt;stat.hvc_exit_stat++;
 
<span class="p_del">-	ret = kvm_psci_call(vcpu);</span>
<span class="p_add">+	ret = kvm_hvc_call_handler(vcpu);</span>
 	if (ret &lt; 0) {
 		vcpu_set_reg(vcpu, 0, ~0UL);
 		return 1;
<span class="p_chunk">@@ -53,7 +54,16 @@</span> <span class="p_context"> static int handle_hvc(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 
 static int handle_smc(struct kvm_vcpu *vcpu, struct kvm_run *run)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * &quot;If an SMC instruction executed at Non-secure EL1 is</span>
<span class="p_add">+	 * trapped to EL2 because HCR_EL2.TSC is 1, the exception is a</span>
<span class="p_add">+	 * Trap exception, not a Secure Monitor Call exception [...]&quot;</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We need to advance the PC after the trap, as it would</span>
<span class="p_add">+	 * otherwise return to the same address...</span>
<span class="p_add">+	 */</span>
 	vcpu_set_reg(vcpu, 0, ~0UL);
<span class="p_add">+	kvm_skip_instr(vcpu, kvm_vcpu_trap_il_is32bit(vcpu));</span>
 	return 1;
 }
 
<span class="p_header">diff --git a/arch/arm64/kvm/hyp-init.S b/arch/arm64/kvm/hyp-init.S</span>
<span class="p_header">index 3f9615582377..870828c364c5 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp-init.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp-init.S</span>
<span class="p_chunk">@@ -151,6 +151,7 @@</span> <span class="p_context"> reset:</span>
 	mrs	x5, sctlr_el2
 	ldr	x6, =SCTLR_ELx_FLAGS
 	bic	x5, x5, x6		// Clear SCTL_M and etc
<span class="p_add">+	pre_disable_mmu_workaround</span>
 	msr	sctlr_el2, x5
 	isb
 
<span class="p_header">diff --git a/arch/arm64/kvm/hyp/entry.S b/arch/arm64/kvm/hyp/entry.S</span>
<span class="p_header">index 12ee62d6d410..9c45c6af1f58 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp/entry.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp/entry.S</span>
<span class="p_chunk">@@ -196,3 +196,15 @@</span> <span class="p_context"> alternative_endif</span>
 
 	eret
 ENDPROC(__fpsimd_guest_restore)
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__qcom_hyp_sanitize_btac_predictors)</span>
<span class="p_add">+	/**</span>
<span class="p_add">+	 * Call SMC64 with Silicon provider serviceID 23&lt;&lt;8 (0xc2001700)</span>
<span class="p_add">+	 * 0xC2000000-0xC200FFFF: assigned to SiP Service Calls</span>
<span class="p_add">+	 * b15-b0: contains SiP functionID</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	movz    x0, #0x1700</span>
<span class="p_add">+	movk    x0, #0xc200, lsl #16</span>
<span class="p_add">+	smc     #0</span>
<span class="p_add">+	ret</span>
<span class="p_add">+ENDPROC(__qcom_hyp_sanitize_btac_predictors)</span>
<span class="p_header">diff --git a/arch/arm64/kvm/hyp/hyp-entry.S b/arch/arm64/kvm/hyp/hyp-entry.S</span>
<span class="p_header">index 5170ce1021da..f49b53331d28 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp/hyp-entry.S</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp/hyp-entry.S</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
  */
 
<span class="p_add">+#include &lt;linux/arm-smccc.h&gt;</span>
 #include &lt;linux/linkage.h&gt;
 
 #include &lt;asm/alternative.h&gt;
<span class="p_chunk">@@ -64,10 +65,11 @@</span> <span class="p_context"> alternative_endif</span>
 	lsr	x0, x1, #ESR_ELx_EC_SHIFT
 
 	cmp	x0, #ESR_ELx_EC_HVC64
<span class="p_add">+	ccmp	x0, #ESR_ELx_EC_HVC32, #4, ne</span>
 	b.ne	el1_trap
 
<span class="p_del">-	mrs	x1, vttbr_el2		// If vttbr is valid, the 64bit guest</span>
<span class="p_del">-	cbnz	x1, el1_trap		// called HVC</span>
<span class="p_add">+	mrs	x1, vttbr_el2		// If vttbr is valid, the guest</span>
<span class="p_add">+	cbnz	x1, el1_hvc_guest	// called HVC</span>
 
 	/* Here, we&#39;re pretty sure the host called HVC. */
 	ldp	x0, x1, [sp], #16
<span class="p_chunk">@@ -100,6 +102,20 @@</span> <span class="p_context"> alternative_endif</span>
 
 	eret
 
<span class="p_add">+el1_hvc_guest:</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Fastest possible path for ARM_SMCCC_ARCH_WORKAROUND_1.</span>
<span class="p_add">+	 * The workaround has already been applied on the host,</span>
<span class="p_add">+	 * so let&#39;s quickly get back to the guest. We don&#39;t bother</span>
<span class="p_add">+	 * restoring x1, as it can be clobbered anyway.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ldr	x1, [sp]				// Guest&#39;s x0</span>
<span class="p_add">+	eor	w1, w1, #ARM_SMCCC_ARCH_WORKAROUND_1</span>
<span class="p_add">+	cbnz	w1, el1_trap</span>
<span class="p_add">+	mov	x0, x1</span>
<span class="p_add">+	add	sp, sp, #16</span>
<span class="p_add">+	eret</span>
<span class="p_add">+</span>
 el1_trap:
 	/*
 	 * x0: ESR_EC
<span class="p_header">diff --git a/arch/arm64/kvm/hyp/switch.c b/arch/arm64/kvm/hyp/switch.c</span>
<span class="p_header">index 945e79c641c4..79364d3455c0 100644</span>
<span class="p_header">--- a/arch/arm64/kvm/hyp/switch.c</span>
<span class="p_header">+++ b/arch/arm64/kvm/hyp/switch.c</span>
<span class="p_chunk">@@ -17,6 +17,9 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 #include &lt;linux/jump_label.h&gt;
<span class="p_add">+#include &lt;uapi/linux/psci.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;kvm/arm_psci.h&gt;</span>
 
 #include &lt;asm/kvm_asm.h&gt;
 #include &lt;asm/kvm_emulate.h&gt;
<span class="p_chunk">@@ -51,7 +54,7 @@</span> <span class="p_context"> static void __hyp_text __activate_traps_vhe(void)</span>
 	val &amp;= ~CPACR_EL1_FPEN;
 	write_sysreg(val, cpacr_el1);
 
<span class="p_del">-	write_sysreg(__kvm_hyp_vector, vbar_el1);</span>
<span class="p_add">+	write_sysreg(kvm_get_hyp_vector(), vbar_el1);</span>
 }
 
 static void __hyp_text __activate_traps_nvhe(void)
<span class="p_chunk">@@ -364,6 +367,14 @@</span> <span class="p_context"> int __hyp_text __kvm_vcpu_run(struct kvm_vcpu *vcpu)</span>
 		/* 0 falls through to be handled out of EL2 */
 	}
 
<span class="p_add">+	if (cpus_have_const_cap(ARM64_HARDEN_BP_POST_GUEST_EXIT)) {</span>
<span class="p_add">+		u32 midr = read_cpuid_id();</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Apply BTAC predictors mitigation to all Falkor chips */</span>
<span class="p_add">+		if ((midr &amp; MIDR_CPU_MODEL_MASK) == MIDR_QCOM_FALKOR_V1)</span>
<span class="p_add">+			__qcom_hyp_sanitize_btac_predictors();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	fp_enabled = __fpsimd_enabled();
 
 	__sysreg_save_guest_state(guest_ctxt);
<span class="p_header">diff --git a/arch/arm64/lib/clear_user.S b/arch/arm64/lib/clear_user.S</span>
<span class="p_header">index e88fb99c1561..21ba0b29621b 100644</span>
<span class="p_header">--- a/arch/arm64/lib/clear_user.S</span>
<span class="p_header">+++ b/arch/arm64/lib/clear_user.S</span>
<span class="p_chunk">@@ -21,7 +21,7 @@</span> <span class="p_context"></span>
 
 	.text
 
<span class="p_del">-/* Prototype: int __clear_user(void *addr, size_t sz)</span>
<span class="p_add">+/* Prototype: int __arch_clear_user(void *addr, size_t sz)</span>
  * Purpose  : clear some user memory
  * Params   : addr - user memory address to clear
  *          : sz   - number of bytes to clear
<span class="p_chunk">@@ -29,8 +29,8 @@</span> <span class="p_context"></span>
  *
  * Alignment fixed up by hardware.
  */
<span class="p_del">-ENTRY(__clear_user)</span>
<span class="p_del">-	uaccess_enable_not_uao x2, x3</span>
<span class="p_add">+ENTRY(__arch_clear_user)</span>
<span class="p_add">+	uaccess_enable_not_uao x2, x3, x4</span>
 	mov	x2, x1			// save the size for fixup return
 	subs	x1, x1, #8
 	b.mi	2f
<span class="p_chunk">@@ -50,9 +50,9 @@</span> <span class="p_context"> uao_user_alternative 9f, strh, sttrh, wzr, x0, 2</span>
 	b.mi	5f
 uao_user_alternative 9f, strb, sttrb, wzr, x0, 0
 5:	mov	x0, #0
<span class="p_del">-	uaccess_disable_not_uao x2</span>
<span class="p_add">+	uaccess_disable_not_uao x2, x3</span>
 	ret
<span class="p_del">-ENDPROC(__clear_user)</span>
<span class="p_add">+ENDPROC(__arch_clear_user)</span>
 
 	.section .fixup,&quot;ax&quot;
 	.align	2
<span class="p_header">diff --git a/arch/arm64/lib/copy_from_user.S b/arch/arm64/lib/copy_from_user.S</span>
<span class="p_header">index 4b5d826895ff..20305d485046 100644</span>
<span class="p_header">--- a/arch/arm64/lib/copy_from_user.S</span>
<span class="p_header">+++ b/arch/arm64/lib/copy_from_user.S</span>
<span class="p_chunk">@@ -64,10 +64,10 @@</span> <span class="p_context"></span>
 
 end	.req	x5
 ENTRY(__arch_copy_from_user)
<span class="p_del">-	uaccess_enable_not_uao x3, x4</span>
<span class="p_add">+	uaccess_enable_not_uao x3, x4, x5</span>
 	add	end, x0, x2
 #include &quot;copy_template.S&quot;
<span class="p_del">-	uaccess_disable_not_uao x3</span>
<span class="p_add">+	uaccess_disable_not_uao x3, x4</span>
 	mov	x0, #0				// Nothing to copy
 	ret
 ENDPROC(__arch_copy_from_user)
<span class="p_header">diff --git a/arch/arm64/lib/copy_in_user.S b/arch/arm64/lib/copy_in_user.S</span>
<span class="p_header">index b24a830419ad..54b75deb1d16 100644</span>
<span class="p_header">--- a/arch/arm64/lib/copy_in_user.S</span>
<span class="p_header">+++ b/arch/arm64/lib/copy_in_user.S</span>
<span class="p_chunk">@@ -64,14 +64,15 @@</span> <span class="p_context"></span>
 	.endm
 
 end	.req	x5
<span class="p_del">-ENTRY(raw_copy_in_user)</span>
<span class="p_del">-	uaccess_enable_not_uao x3, x4</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(__arch_copy_in_user)</span>
<span class="p_add">+	uaccess_enable_not_uao x3, x4, x5</span>
 	add	end, x0, x2
 #include &quot;copy_template.S&quot;
<span class="p_del">-	uaccess_disable_not_uao x3</span>
<span class="p_add">+	uaccess_disable_not_uao x3, x4</span>
 	mov	x0, #0
 	ret
<span class="p_del">-ENDPROC(raw_copy_in_user)</span>
<span class="p_add">+ENDPROC(__arch_copy_in_user)</span>
 
 	.section .fixup,&quot;ax&quot;
 	.align	2
<span class="p_header">diff --git a/arch/arm64/lib/copy_to_user.S b/arch/arm64/lib/copy_to_user.S</span>
<span class="p_header">index 351f0766f7a6..fda6172d6b88 100644</span>
<span class="p_header">--- a/arch/arm64/lib/copy_to_user.S</span>
<span class="p_header">+++ b/arch/arm64/lib/copy_to_user.S</span>
<span class="p_chunk">@@ -63,10 +63,10 @@</span> <span class="p_context"></span>
 
 end	.req	x5
 ENTRY(__arch_copy_to_user)
<span class="p_del">-	uaccess_enable_not_uao x3, x4</span>
<span class="p_add">+	uaccess_enable_not_uao x3, x4, x5</span>
 	add	end, x0, x2
 #include &quot;copy_template.S&quot;
<span class="p_del">-	uaccess_disable_not_uao x3</span>
<span class="p_add">+	uaccess_disable_not_uao x3, x4</span>
 	mov	x0, #0
 	ret
 ENDPROC(__arch_copy_to_user)
<span class="p_header">diff --git a/arch/arm64/mm/cache.S b/arch/arm64/mm/cache.S</span>
<span class="p_header">index 7f1dbe962cf5..91464e7f77cc 100644</span>
<span class="p_header">--- a/arch/arm64/mm/cache.S</span>
<span class="p_header">+++ b/arch/arm64/mm/cache.S</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> ENTRY(flush_icache_range)</span>
  *	- end     - virtual end address of region
  */
 ENTRY(__flush_cache_user_range)
<span class="p_del">-	uaccess_ttbr0_enable x2, x3</span>
<span class="p_add">+	uaccess_ttbr0_enable x2, x3, x4</span>
 	dcache_line_size x2, x3
 	sub	x3, x2, #1
 	bic	x4, x0, x3
<span class="p_chunk">@@ -72,7 +72,7 @@</span> <span class="p_context"> USER(9f, ic	ivau, x4	)		// invalidate I line PoU</span>
 	isb
 	mov	x0, #0
 1:
<span class="p_del">-	uaccess_ttbr0_disable x1</span>
<span class="p_add">+	uaccess_ttbr0_disable x1, x2</span>
 	ret
 9:
 	mov	x0, #-EFAULT
<span class="p_header">diff --git a/arch/arm64/mm/context.c b/arch/arm64/mm/context.c</span>
<span class="p_header">index ab9f5f0fb2c7..9284788733d6 100644</span>
<span class="p_header">--- a/arch/arm64/mm/context.c</span>
<span class="p_header">+++ b/arch/arm64/mm/context.c</span>
<span class="p_chunk">@@ -39,7 +39,16 @@</span> <span class="p_context"> static cpumask_t tlb_flush_pending;</span>
 
 #define ASID_MASK		(~GENMASK(asid_bits - 1, 0))
 #define ASID_FIRST_VERSION	(1UL &lt;&lt; asid_bits)
<span class="p_del">-#define NUM_USER_ASIDS		ASID_FIRST_VERSION</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+#define NUM_USER_ASIDS		(ASID_FIRST_VERSION &gt;&gt; 1)</span>
<span class="p_add">+#define asid2idx(asid)		(((asid) &amp; ~ASID_MASK) &gt;&gt; 1)</span>
<span class="p_add">+#define idx2asid(idx)		(((idx) &lt;&lt; 1) &amp; ~ASID_MASK)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define NUM_USER_ASIDS		(ASID_FIRST_VERSION)</span>
<span class="p_add">+#define asid2idx(asid)		((asid) &amp; ~ASID_MASK)</span>
<span class="p_add">+#define idx2asid(idx)		asid2idx(idx)</span>
<span class="p_add">+#endif</span>
 
 /* Get the ASIDBits supported by the current CPU */
 static u32 get_cpu_asid_bits(void)
<span class="p_chunk">@@ -79,13 +88,6 @@</span> <span class="p_context"> void verify_cpu_asid_bits(void)</span>
 	}
 }
 
<span class="p_del">-static void set_reserved_asid_bits(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (IS_ENABLED(CONFIG_QCOM_FALKOR_ERRATUM_1003) &amp;&amp;</span>
<span class="p_del">-	    cpus_have_const_cap(ARM64_WORKAROUND_QCOM_FALKOR_E1003))</span>
<span class="p_del">-		__set_bit(FALKOR_RESERVED_ASID, asid_map);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void flush_context(unsigned int cpu)
 {
 	int i;
<span class="p_chunk">@@ -94,8 +96,6 @@</span> <span class="p_context"> static void flush_context(unsigned int cpu)</span>
 	/* Update the list of reserved ASIDs and the ASID bitmap. */
 	bitmap_clear(asid_map, 0, NUM_USER_ASIDS);
 
<span class="p_del">-	set_reserved_asid_bits();</span>
<span class="p_del">-</span>
 	/*
 	 * Ensure the generation bump is observed before we xchg the
 	 * active_asids.
<span class="p_chunk">@@ -113,7 +113,7 @@</span> <span class="p_context"> static void flush_context(unsigned int cpu)</span>
 		 */
 		if (asid == 0)
 			asid = per_cpu(reserved_asids, i);
<span class="p_del">-		__set_bit(asid &amp; ~ASID_MASK, asid_map);</span>
<span class="p_add">+		__set_bit(asid2idx(asid), asid_map);</span>
 		per_cpu(reserved_asids, i) = asid;
 	}
 
<span class="p_chunk">@@ -165,16 +165,16 @@</span> <span class="p_context"> static u64 new_context(struct mm_struct *mm, unsigned int cpu)</span>
 		 * We had a valid ASID in a previous life, so try to re-use
 		 * it if possible.
 		 */
<span class="p_del">-		asid &amp;= ~ASID_MASK;</span>
<span class="p_del">-		if (!__test_and_set_bit(asid, asid_map))</span>
<span class="p_add">+		if (!__test_and_set_bit(asid2idx(asid), asid_map))</span>
 			return newasid;
 	}
 
 	/*
 	 * Allocate a free ASID. If we can&#39;t find one, take a note of the
<span class="p_del">-	 * currently active ASIDs and mark the TLBs as requiring flushes.</span>
<span class="p_del">-	 * We always count from ASID #1, as we use ASID #0 when setting a</span>
<span class="p_del">-	 * reserved TTBR0 for the init_mm.</span>
<span class="p_add">+	 * currently active ASIDs and mark the TLBs as requiring flushes.  We</span>
<span class="p_add">+	 * always count from ASID #2 (index 1), as we use ASID #0 when setting</span>
<span class="p_add">+	 * a reserved TTBR0 for the init_mm and we allocate ASIDs in even/odd</span>
<span class="p_add">+	 * pairs.</span>
 	 */
 	asid = find_next_zero_bit(asid_map, NUM_USER_ASIDS, cur_idx);
 	if (asid != NUM_USER_ASIDS)
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> static u64 new_context(struct mm_struct *mm, unsigned int cpu)</span>
 set_asid:
 	__set_bit(asid, asid_map);
 	cur_idx = asid;
<span class="p_del">-	return asid | generation;</span>
<span class="p_add">+	return idx2asid(asid) | generation;</span>
 }
 
 void check_and_switch_context(struct mm_struct *mm, unsigned int cpu)
<span class="p_chunk">@@ -227,6 +227,9 @@</span> <span class="p_context"> void check_and_switch_context(struct mm_struct *mm, unsigned int cpu)</span>
 	raw_spin_unlock_irqrestore(&amp;cpu_asid_lock, flags);
 
 switch_mm_fastpath:
<span class="p_add">+</span>
<span class="p_add">+	arm64_apply_bp_hardening();</span>
<span class="p_add">+</span>
 	/*
 	 * Defer TTBR0_EL1 setting for user threads to uaccess_enable() when
 	 * emulating PAN.
<span class="p_chunk">@@ -235,6 +238,15 @@</span> <span class="p_context"> void check_and_switch_context(struct mm_struct *mm, unsigned int cpu)</span>
 		cpu_switch_mm(mm-&gt;pgd, mm);
 }
 
<span class="p_add">+/* Errata workaround post TTBRx_EL1 update. */</span>
<span class="p_add">+asmlinkage void post_ttbr_update_workaround(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	asm(ALTERNATIVE(&quot;nop; nop; nop&quot;,</span>
<span class="p_add">+			&quot;ic iallu; dsb nsh; isb&quot;,</span>
<span class="p_add">+			ARM64_WORKAROUND_CAVIUM_27456,</span>
<span class="p_add">+			CONFIG_CAVIUM_ERRATUM_27456));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int asids_init(void)
 {
 	asid_bits = get_cpu_asid_bits();
<span class="p_chunk">@@ -250,8 +262,6 @@</span> <span class="p_context"> static int asids_init(void)</span>
 		panic(&quot;Failed to allocate bitmap for %lu ASIDs\n&quot;,
 		      NUM_USER_ASIDS);
 
<span class="p_del">-	set_reserved_asid_bits();</span>
<span class="p_del">-</span>
 	pr_info(&quot;ASID allocator initialised with %lu entries\n&quot;, NUM_USER_ASIDS);
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index b64958b23a7f..5edb706aacb0 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -242,7 +242,7 @@</span> <span class="p_context"> static inline bool is_permission_fault(unsigned int esr, struct pt_regs *regs,</span>
 	if (fsc_type == ESR_ELx_FSC_PERM)
 		return true;
 
<span class="p_del">-	if (addr &lt; USER_DS &amp;&amp; system_uses_ttbr0_pan())</span>
<span class="p_add">+	if (addr &lt; TASK_SIZE &amp;&amp; system_uses_ttbr0_pan())</span>
 		return fsc_type == ESR_ELx_FSC_FAULT &amp;&amp;
 			(regs-&gt;pstate &amp; PSR_PAN_BIT);
 
<span class="p_chunk">@@ -426,7 +426,7 @@</span> <span class="p_context"> static int __kprobes do_page_fault(unsigned long addr, unsigned int esr,</span>
 		mm_flags |= FAULT_FLAG_WRITE;
 	}
 
<span class="p_del">-	if (addr &lt; USER_DS &amp;&amp; is_permission_fault(esr, regs, addr)) {</span>
<span class="p_add">+	if (addr &lt; TASK_SIZE &amp;&amp; is_permission_fault(esr, regs, addr)) {</span>
 		/* regs-&gt;orig_addr_limit may be 0 if we entered from EL0 */
 		if (regs-&gt;orig_addr_limit == KERNEL_DS)
 			die(&quot;Accessing user space memory with fs=KERNEL_DS&quot;, regs, esr);
<span class="p_chunk">@@ -751,6 +751,29 @@</span> <span class="p_context"> asmlinkage void __exception do_mem_abort(unsigned long addr, unsigned int esr,</span>
 	arm64_notify_die(&quot;&quot;, regs, &amp;info, esr);
 }
 
<span class="p_add">+asmlinkage void __exception do_el0_irq_bp_hardening(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* PC has already been checked in entry.S */</span>
<span class="p_add">+	arm64_apply_bp_hardening();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void __exception do_el0_ia_bp_hardening(unsigned long addr,</span>
<span class="p_add">+						   unsigned int esr,</span>
<span class="p_add">+						   struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We&#39;ve taken an instruction abort from userspace and not yet</span>
<span class="p_add">+	 * re-enabled IRQs. If the address is a kernel address, apply</span>
<span class="p_add">+	 * BP hardening prior to enabling IRQs and pre-emption.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (addr &gt; TASK_SIZE)</span>
<span class="p_add">+		arm64_apply_bp_hardening();</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_enable();</span>
<span class="p_add">+	do_mem_abort(addr, esr, regs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 /*
  * Handle stack alignment exceptions.
  */
<span class="p_chunk">@@ -761,6 +784,12 @@</span> <span class="p_context"> asmlinkage void __exception do_sp_pc_abort(unsigned long addr,</span>
 	struct siginfo info;
 	struct task_struct *tsk = current;
 
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		if (instruction_pointer(regs) &gt; TASK_SIZE)</span>
<span class="p_add">+			arm64_apply_bp_hardening();</span>
<span class="p_add">+		local_irq_enable();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (show_unhandled_signals &amp;&amp; unhandled_signal(tsk, SIGBUS))
 		pr_info_ratelimited(&quot;%s[%d]: %s exception: pc=%p sp=%p\n&quot;,
 				    tsk-&gt;comm, task_pid_nr(tsk),
<span class="p_chunk">@@ -820,6 +849,9 @@</span> <span class="p_context"> asmlinkage int __exception do_debug_exception(unsigned long addr,</span>
 	if (interrupts_enabled(regs))
 		trace_hardirqs_off();
 
<span class="p_add">+	if (user_mode(regs) &amp;&amp; instruction_pointer(regs) &gt; TASK_SIZE)</span>
<span class="p_add">+		arm64_apply_bp_hardening();</span>
<span class="p_add">+</span>
 	if (!inf-&gt;fn(addr, esr, regs)) {
 		rv = 1;
 	} else {
<span class="p_header">diff --git a/arch/arm64/mm/mmu.c b/arch/arm64/mm/mmu.c</span>
<span class="p_header">index f1eb15e0e864..fa20124c19d5 100644</span>
<span class="p_header">--- a/arch/arm64/mm/mmu.c</span>
<span class="p_header">+++ b/arch/arm64/mm/mmu.c</span>
<span class="p_chunk">@@ -117,6 +117,10 @@</span> <span class="p_context"> static bool pgattr_change_is_safe(u64 old, u64 new)</span>
 	if ((old | new) &amp; PTE_CONT)
 		return false;
 
<span class="p_add">+	/* Transitioning from Global to Non-Global is safe */</span>
<span class="p_add">+	if (((old ^ new) == PTE_NG) &amp;&amp; (new &amp; PTE_NG))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
 	return ((old ^ new) &amp; ~mask) == 0;
 }
 
<span class="p_chunk">@@ -525,6 +529,37 @@</span> <span class="p_context"> static int __init parse_rodata(char *arg)</span>
 }
 early_param(&quot;rodata&quot;, parse_rodata);
 
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+static int __init map_entry_trampoline(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern char __entry_tramp_text_start[];</span>
<span class="p_add">+</span>
<span class="p_add">+	pgprot_t prot = rodata_enabled ? PAGE_KERNEL_ROX : PAGE_KERNEL_EXEC;</span>
<span class="p_add">+	phys_addr_t pa_start = __pa_symbol(__entry_tramp_text_start);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The trampoline is always mapped and can therefore be global */</span>
<span class="p_add">+	pgprot_val(prot) &amp;= ~PTE_NG;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Map only the text into the trampoline page table */</span>
<span class="p_add">+	memset(tramp_pg_dir, 0, PGD_SIZE);</span>
<span class="p_add">+	__create_pgd_mapping(tramp_pg_dir, pa_start, TRAMP_VALIAS, PAGE_SIZE,</span>
<span class="p_add">+			     prot, pgd_pgtable_alloc, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Map both the text and data into the kernel page table */</span>
<span class="p_add">+	__set_fixmap(FIX_ENTRY_TRAMP_TEXT, pa_start, prot);</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_RANDOMIZE_BASE)) {</span>
<span class="p_add">+		extern char __entry_tramp_data_start[];</span>
<span class="p_add">+</span>
<span class="p_add">+		__set_fixmap(FIX_ENTRY_TRAMP_DATA,</span>
<span class="p_add">+			     __pa_symbol(__entry_tramp_data_start),</span>
<span class="p_add">+			     PAGE_KERNEL_RO);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+core_initcall(map_entry_trampoline);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  * Create fine-grained mappings for the kernel.
  */
<span class="p_header">diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S</span>
<span class="p_header">index 877d42fb0df6..27058f3fd132 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc.S</span>
<span class="p_chunk">@@ -86,7 +86,7 @@</span> <span class="p_context"> ENDPROC(cpu_do_suspend)</span>
  *
  * x0: Address of context pointer
  */
<span class="p_del">-	.pushsection &quot;.idmap.text&quot;, &quot;ax&quot;</span>
<span class="p_add">+	.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span>
 ENTRY(cpu_do_resume)
 	ldp	x2, x3, [x0]
 	ldp	x4, x5, [x0, #16]
<span class="p_chunk">@@ -138,16 +138,30 @@</span> <span class="p_context"> ENDPROC(cpu_do_resume)</span>
  *	- pgd_phys - physical address of new TTB
  */
 ENTRY(cpu_do_switch_mm)
<span class="p_del">-	pre_ttbr0_update_workaround x0, x2, x3</span>
<span class="p_add">+	mrs	x2, ttbr1_el1</span>
 	mmid	x1, x1				// get mm-&gt;context.id
<span class="p_del">-	bfi	x0, x1, #48, #16		// set the ASID</span>
<span class="p_del">-	msr	ttbr0_el1, x0			// set TTBR0</span>
<span class="p_add">+#ifdef CONFIG_ARM64_SW_TTBR0_PAN</span>
<span class="p_add">+	bfi	x0, x1, #48, #16		// set the ASID field in TTBR0</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	bfi	x2, x1, #48, #16		// set the ASID</span>
<span class="p_add">+	msr	ttbr1_el1, x2			// in TTBR1 (since TCR.A1 is set)</span>
 	isb
<span class="p_del">-	post_ttbr0_update_workaround</span>
<span class="p_del">-	ret</span>
<span class="p_add">+	msr	ttbr0_el1, x0			// now update TTBR0</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	b	post_ttbr_update_workaround	// Back to C code...</span>
 ENDPROC(cpu_do_switch_mm)
 
<span class="p_del">-	.pushsection &quot;.idmap.text&quot;, &quot;ax&quot;</span>
<span class="p_add">+	.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+.macro	__idmap_cpu_set_reserved_ttbr1, tmp1, tmp2</span>
<span class="p_add">+	adrp	\tmp1, empty_zero_page</span>
<span class="p_add">+	msr	ttbr1_el1, \tmp2</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	tlbi	vmalle1</span>
<span class="p_add">+	dsb	nsh</span>
<span class="p_add">+	isb</span>
<span class="p_add">+.endm</span>
<span class="p_add">+</span>
 /*
  * void idmap_cpu_replace_ttbr1(phys_addr_t new_pgd)
  *
<span class="p_chunk">@@ -158,13 +172,7 @@</span> <span class="p_context"> ENTRY(idmap_cpu_replace_ttbr1)</span>
 	mrs	x2, daif
 	msr	daifset, #0xf
 
<span class="p_del">-	adrp	x1, empty_zero_page</span>
<span class="p_del">-	msr	ttbr1_el1, x1</span>
<span class="p_del">-	isb</span>
<span class="p_del">-</span>
<span class="p_del">-	tlbi	vmalle1</span>
<span class="p_del">-	dsb	nsh</span>
<span class="p_del">-	isb</span>
<span class="p_add">+	__idmap_cpu_set_reserved_ttbr1 x1, x3</span>
 
 	msr	ttbr1_el1, x0
 	isb
<span class="p_chunk">@@ -175,13 +183,196 @@</span> <span class="p_context"> ENTRY(idmap_cpu_replace_ttbr1)</span>
 ENDPROC(idmap_cpu_replace_ttbr1)
 	.popsection
 
<span class="p_add">+#ifdef CONFIG_UNMAP_KERNEL_AT_EL0</span>
<span class="p_add">+	.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	__idmap_kpti_get_pgtable_ent, type</span>
<span class="p_add">+	dc	cvac, cur_\()\type\()p		// Ensure any existing dirty</span>
<span class="p_add">+	dmb	sy				// lines are written back before</span>
<span class="p_add">+	ldr	\type, [cur_\()\type\()p]	// loading the entry</span>
<span class="p_add">+	tbz	\type, #0, next_\()\type	// Skip invalid entries</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro __idmap_kpti_put_pgtable_ent_ng, type</span>
<span class="p_add">+	orr	\type, \type, #PTE_NG		// Same bit for blocks and pages</span>
<span class="p_add">+	str	\type, [cur_\()\type\()p]	// Update the entry and ensure it</span>
<span class="p_add">+	dc	civac, cur_\()\type\()p		// is visible to all CPUs.</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * void __kpti_install_ng_mappings(int cpu, int num_cpus, phys_addr_t swapper)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called exactly once from stop_machine context by each CPU found during boot.</span>
<span class="p_add">+ */</span>
<span class="p_add">+__idmap_kpti_flag:</span>
<span class="p_add">+	.long	1</span>
<span class="p_add">+ENTRY(idmap_kpti_install_ng_mappings)</span>
<span class="p_add">+	cpu		.req	w0</span>
<span class="p_add">+	num_cpus	.req	w1</span>
<span class="p_add">+	swapper_pa	.req	x2</span>
<span class="p_add">+	swapper_ttb	.req	x3</span>
<span class="p_add">+	flag_ptr	.req	x4</span>
<span class="p_add">+	cur_pgdp	.req	x5</span>
<span class="p_add">+	end_pgdp	.req	x6</span>
<span class="p_add">+	pgd		.req	x7</span>
<span class="p_add">+	cur_pudp	.req	x8</span>
<span class="p_add">+	end_pudp	.req	x9</span>
<span class="p_add">+	pud		.req	x10</span>
<span class="p_add">+	cur_pmdp	.req	x11</span>
<span class="p_add">+	end_pmdp	.req	x12</span>
<span class="p_add">+	pmd		.req	x13</span>
<span class="p_add">+	cur_ptep	.req	x14</span>
<span class="p_add">+	end_ptep	.req	x15</span>
<span class="p_add">+	pte		.req	x16</span>
<span class="p_add">+</span>
<span class="p_add">+	mrs	swapper_ttb, ttbr1_el1</span>
<span class="p_add">+	adr	flag_ptr, __idmap_kpti_flag</span>
<span class="p_add">+</span>
<span class="p_add">+	cbnz	cpu, __idmap_kpti_secondary</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We&#39;re the boot CPU. Wait for the others to catch up */</span>
<span class="p_add">+	sevl</span>
<span class="p_add">+1:	wfe</span>
<span class="p_add">+	ldaxr	w18, [flag_ptr]</span>
<span class="p_add">+	eor	w18, w18, num_cpus</span>
<span class="p_add">+	cbnz	w18, 1b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We need to walk swapper, so turn off the MMU. */</span>
<span class="p_add">+	mrs	x18, sctlr_el1</span>
<span class="p_add">+	bic	x18, x18, #SCTLR_ELx_M</span>
<span class="p_add">+	msr	sctlr_el1, x18</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Everybody is enjoying the idmap, so we can rewrite swapper. */</span>
<span class="p_add">+	/* PGD */</span>
<span class="p_add">+	mov	cur_pgdp, swapper_pa</span>
<span class="p_add">+	add	end_pgdp, cur_pgdp, #(PTRS_PER_PGD * 8)</span>
<span class="p_add">+do_pgd:	__idmap_kpti_get_pgtable_ent	pgd</span>
<span class="p_add">+	tbnz	pgd, #1, walk_puds</span>
<span class="p_add">+	__idmap_kpti_put_pgtable_ent_ng	pgd</span>
<span class="p_add">+next_pgd:</span>
<span class="p_add">+	add	cur_pgdp, cur_pgdp, #8</span>
<span class="p_add">+	cmp	cur_pgdp, end_pgdp</span>
<span class="p_add">+	b.ne	do_pgd</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Publish the updated tables and nuke all the TLBs */</span>
<span class="p_add">+	dsb	sy</span>
<span class="p_add">+	tlbi	vmalle1is</span>
<span class="p_add">+	dsb	ish</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We&#39;re done: fire up the MMU again */</span>
<span class="p_add">+	mrs	x18, sctlr_el1</span>
<span class="p_add">+	orr	x18, x18, #SCTLR_ELx_M</span>
<span class="p_add">+	msr	sctlr_el1, x18</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set the flag to zero to indicate that we&#39;re all done */</span>
<span class="p_add">+	str	wzr, [flag_ptr]</span>
<span class="p_add">+	ret</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PUD */</span>
<span class="p_add">+walk_puds:</span>
<span class="p_add">+	.if CONFIG_PGTABLE_LEVELS &gt; 3</span>
<span class="p_add">+	pte_to_phys	cur_pudp, pgd</span>
<span class="p_add">+	add	end_pudp, cur_pudp, #(PTRS_PER_PUD * 8)</span>
<span class="p_add">+do_pud:	__idmap_kpti_get_pgtable_ent	pud</span>
<span class="p_add">+	tbnz	pud, #1, walk_pmds</span>
<span class="p_add">+	__idmap_kpti_put_pgtable_ent_ng	pud</span>
<span class="p_add">+next_pud:</span>
<span class="p_add">+	add	cur_pudp, cur_pudp, 8</span>
<span class="p_add">+	cmp	cur_pudp, end_pudp</span>
<span class="p_add">+	b.ne	do_pud</span>
<span class="p_add">+	b	next_pgd</span>
<span class="p_add">+	.else /* CONFIG_PGTABLE_LEVELS &lt;= 3 */</span>
<span class="p_add">+	mov	pud, pgd</span>
<span class="p_add">+	b	walk_pmds</span>
<span class="p_add">+next_pud:</span>
<span class="p_add">+	b	next_pgd</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PMD */</span>
<span class="p_add">+walk_pmds:</span>
<span class="p_add">+	.if CONFIG_PGTABLE_LEVELS &gt; 2</span>
<span class="p_add">+	pte_to_phys	cur_pmdp, pud</span>
<span class="p_add">+	add	end_pmdp, cur_pmdp, #(PTRS_PER_PMD * 8)</span>
<span class="p_add">+do_pmd:	__idmap_kpti_get_pgtable_ent	pmd</span>
<span class="p_add">+	tbnz	pmd, #1, walk_ptes</span>
<span class="p_add">+	__idmap_kpti_put_pgtable_ent_ng	pmd</span>
<span class="p_add">+next_pmd:</span>
<span class="p_add">+	add	cur_pmdp, cur_pmdp, #8</span>
<span class="p_add">+	cmp	cur_pmdp, end_pmdp</span>
<span class="p_add">+	b.ne	do_pmd</span>
<span class="p_add">+	b	next_pud</span>
<span class="p_add">+	.else /* CONFIG_PGTABLE_LEVELS &lt;= 2 */</span>
<span class="p_add">+	mov	pmd, pud</span>
<span class="p_add">+	b	walk_ptes</span>
<span class="p_add">+next_pmd:</span>
<span class="p_add">+	b	next_pud</span>
<span class="p_add">+	.endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/* PTE */</span>
<span class="p_add">+walk_ptes:</span>
<span class="p_add">+	pte_to_phys	cur_ptep, pmd</span>
<span class="p_add">+	add	end_ptep, cur_ptep, #(PTRS_PER_PTE * 8)</span>
<span class="p_add">+do_pte:	__idmap_kpti_get_pgtable_ent	pte</span>
<span class="p_add">+	__idmap_kpti_put_pgtable_ent_ng	pte</span>
<span class="p_add">+next_pte:</span>
<span class="p_add">+	add	cur_ptep, cur_ptep, #8</span>
<span class="p_add">+	cmp	cur_ptep, end_ptep</span>
<span class="p_add">+	b.ne	do_pte</span>
<span class="p_add">+	b	next_pmd</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Secondary CPUs end up here */</span>
<span class="p_add">+__idmap_kpti_secondary:</span>
<span class="p_add">+	/* Uninstall swapper before surgery begins */</span>
<span class="p_add">+	__idmap_cpu_set_reserved_ttbr1 x18, x17</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Increment the flag to let the boot CPU we&#39;re ready */</span>
<span class="p_add">+1:	ldxr	w18, [flag_ptr]</span>
<span class="p_add">+	add	w18, w18, #1</span>
<span class="p_add">+	stxr	w17, w18, [flag_ptr]</span>
<span class="p_add">+	cbnz	w17, 1b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Wait for the boot CPU to finish messing around with swapper */</span>
<span class="p_add">+	sevl</span>
<span class="p_add">+1:	wfe</span>
<span class="p_add">+	ldxr	w18, [flag_ptr]</span>
<span class="p_add">+	cbnz	w18, 1b</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All done, act like nothing happened */</span>
<span class="p_add">+	msr	ttbr1_el1, swapper_ttb</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	ret</span>
<span class="p_add">+</span>
<span class="p_add">+	.unreq	cpu</span>
<span class="p_add">+	.unreq	num_cpus</span>
<span class="p_add">+	.unreq	swapper_pa</span>
<span class="p_add">+	.unreq	swapper_ttb</span>
<span class="p_add">+	.unreq	flag_ptr</span>
<span class="p_add">+	.unreq	cur_pgdp</span>
<span class="p_add">+	.unreq	end_pgdp</span>
<span class="p_add">+	.unreq	pgd</span>
<span class="p_add">+	.unreq	cur_pudp</span>
<span class="p_add">+	.unreq	end_pudp</span>
<span class="p_add">+	.unreq	pud</span>
<span class="p_add">+	.unreq	cur_pmdp</span>
<span class="p_add">+	.unreq	end_pmdp</span>
<span class="p_add">+	.unreq	pmd</span>
<span class="p_add">+	.unreq	cur_ptep</span>
<span class="p_add">+	.unreq	end_ptep</span>
<span class="p_add">+	.unreq	pte</span>
<span class="p_add">+ENDPROC(idmap_kpti_install_ng_mappings)</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 /*
  *	__cpu_setup
  *
  *	Initialise the processor for turning the MMU on.  Return in x0 the
  *	value of the SCTLR_EL1 register.
  */
<span class="p_del">-	.pushsection &quot;.idmap.text&quot;, &quot;ax&quot;</span>
<span class="p_add">+	.pushsection &quot;.idmap.text&quot;, &quot;awx&quot;</span>
 ENTRY(__cpu_setup)
 	tlbi	vmalle1				// Invalidate local TLB
 	dsb	nsh
<span class="p_chunk">@@ -225,7 +416,7 @@</span> <span class="p_context"> ENTRY(__cpu_setup)</span>
 	 * both user and kernel.
 	 */
 	ldr	x10, =TCR_TxSZ(VA_BITS) | TCR_CACHE_FLAGS | TCR_SMP_FLAGS | \
<span class="p_del">-			TCR_TG_FLAGS | TCR_ASID16 | TCR_TBI0</span>
<span class="p_add">+			TCR_TG_FLAGS | TCR_ASID16 | TCR_TBI0 | TCR_A1</span>
 	tcr_set_idmap_t0sz	x10, x9
 
 	/*
<span class="p_header">diff --git a/arch/arm64/xen/hypercall.S b/arch/arm64/xen/hypercall.S</span>
<span class="p_header">index 401ceb71540c..c5f05c4a4d00 100644</span>
<span class="p_header">--- a/arch/arm64/xen/hypercall.S</span>
<span class="p_header">+++ b/arch/arm64/xen/hypercall.S</span>
<span class="p_chunk">@@ -101,12 +101,12 @@</span> <span class="p_context"> ENTRY(privcmd_call)</span>
 	 * need the explicit uaccess_enable/disable if the TTBR0 PAN emulation
 	 * is enabled (it implies that hardware UAO and PAN disabled).
 	 */
<span class="p_del">-	uaccess_ttbr0_enable x6, x7</span>
<span class="p_add">+	uaccess_ttbr0_enable x6, x7, x8</span>
 	hvc XEN_IMM
 
 	/*
 	 * Disable userspace access from kernel once the hyp call completed.
 	 */
<span class="p_del">-	uaccess_ttbr0_disable x6</span>
<span class="p_add">+	uaccess_ttbr0_disable x6, x7</span>
 	ret
 ENDPROC(privcmd_call);
<span class="p_header">diff --git a/arch/mn10300/mm/misalignment.c b/arch/mn10300/mm/misalignment.c</span>
<span class="p_header">index b39a388825ae..8ace89617c1c 100644</span>
<span class="p_header">--- a/arch/mn10300/mm/misalignment.c</span>
<span class="p_header">+++ b/arch/mn10300/mm/misalignment.c</span>
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> asmlinkage void misalignment(struct pt_regs *regs, enum exception_code code)</span>
 
 	info.si_signo	= SIGSEGV;
 	info.si_errno	= 0;
<span class="p_del">-	info.si_code	= 0;</span>
<span class="p_add">+	info.si_code	= SEGV_MAPERR;</span>
 	info.si_addr	= (void *) regs-&gt;pc;
 	force_sig_info(SIGSEGV, &amp;info, current);
 	return;
<span class="p_header">diff --git a/arch/openrisc/kernel/traps.c b/arch/openrisc/kernel/traps.c</span>
<span class="p_header">index 803e9e756f77..8d8437169b5e 100644</span>
<span class="p_header">--- a/arch/openrisc/kernel/traps.c</span>
<span class="p_header">+++ b/arch/openrisc/kernel/traps.c</span>
<span class="p_chunk">@@ -306,12 +306,12 @@</span> <span class="p_context"> asmlinkage void do_unaligned_access(struct pt_regs *regs, unsigned long address)</span>
 	siginfo_t info;
 
 	if (user_mode(regs)) {
<span class="p_del">-		/* Send a SIGSEGV */</span>
<span class="p_del">-		info.si_signo = SIGSEGV;</span>
<span class="p_add">+		/* Send a SIGBUS */</span>
<span class="p_add">+		info.si_signo = SIGBUS;</span>
 		info.si_errno = 0;
<span class="p_del">-		/* info.si_code has been set above */</span>
<span class="p_del">-		info.si_addr = (void *)address;</span>
<span class="p_del">-		force_sig_info(SIGSEGV, &amp;info, current);</span>
<span class="p_add">+		info.si_code = BUS_ADRALN;</span>
<span class="p_add">+		info.si_addr = (void __user *)address;</span>
<span class="p_add">+		force_sig_info(SIGBUS, &amp;info, current);</span>
 	} else {
 		printk(&quot;KERNEL: Unaligned Access 0x%.8lx\n&quot;, address);
 		show_registers(regs);
<span class="p_header">diff --git a/arch/powerpc/crypto/crc32c-vpmsum_glue.c b/arch/powerpc/crypto/crc32c-vpmsum_glue.c</span>
<span class="p_header">index f058e0c3e4d4..fd1d6c83f0c0 100644</span>
<span class="p_header">--- a/arch/powerpc/crypto/crc32c-vpmsum_glue.c</span>
<span class="p_header">+++ b/arch/powerpc/crypto/crc32c-vpmsum_glue.c</span>
<span class="p_chunk">@@ -141,6 +141,7 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 		.cra_name		= &quot;crc32c&quot;,
 		.cra_driver_name	= &quot;crc32c-vpmsum&quot;,
 		.cra_priority		= 200,
<span class="p_add">+		.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 		.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(u32),
 		.cra_module		= THIS_MODULE,
<span class="p_header">diff --git a/arch/powerpc/include/asm/hvcall.h b/arch/powerpc/include/asm/hvcall.h</span>
<span class="p_header">index f0461618bf7b..eca3f9c68907 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/hvcall.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/hvcall.h</span>
<span class="p_chunk">@@ -353,6 +353,7 @@</span> <span class="p_context"></span>
 #define PROC_TABLE_GTSE		0x01
 
 #ifndef __ASSEMBLY__
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
 
 /**
  * plpar_hcall_norets: - Make a pseries hypervisor call with no return arguments
<span class="p_header">diff --git a/arch/powerpc/kvm/Kconfig b/arch/powerpc/kvm/Kconfig</span>
<span class="p_header">index b12b8eb39c29..648160334abf 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/Kconfig</span>
<span class="p_header">+++ b/arch/powerpc/kvm/Kconfig</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> config KVM_BOOK3S_64</span>
 	select KVM_BOOK3S_64_HANDLER
 	select KVM
 	select KVM_BOOK3S_PR_POSSIBLE if !KVM_BOOK3S_HV_POSSIBLE
<span class="p_del">-	select SPAPR_TCE_IOMMU if IOMMU_SUPPORT &amp;&amp; (PPC_SERIES || PPC_POWERNV)</span>
<span class="p_add">+	select SPAPR_TCE_IOMMU if IOMMU_SUPPORT &amp;&amp; (PPC_PSERIES || PPC_POWERNV)</span>
 	---help---
 	  Support running unmodified book3s_64 and book3s_32 guest kernels
 	  in virtual machines on book3s_64 host processors.
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 8d43cf205d34..f48e3379a18a 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -999,8 +999,6 @@</span> <span class="p_context"> static int kvmppc_emulate_doorbell_instr(struct kvm_vcpu *vcpu)</span>
 	struct kvm *kvm = vcpu-&gt;kvm;
 	struct kvm_vcpu *tvcpu;
 
<span class="p_del">-	if (!cpu_has_feature(CPU_FTR_ARCH_300))</span>
<span class="p_del">-		return EMULATE_FAIL;</span>
 	if (kvmppc_get_last_inst(vcpu, INST_GENERIC, &amp;inst) != EMULATE_DONE)
 		return RESUME_GUEST;
 	if (get_op(inst) != 31)
<span class="p_chunk">@@ -1050,6 +1048,7 @@</span> <span class="p_context"> static int kvmppc_emulate_doorbell_instr(struct kvm_vcpu *vcpu)</span>
 	return RESUME_GUEST;
 }
 
<span class="p_add">+/* Called with vcpu-&gt;arch.vcore-&gt;lock held */</span>
 static int kvmppc_handle_exit_hv(struct kvm_run *run, struct kvm_vcpu *vcpu,
 				 struct task_struct *tsk)
 {
<span class="p_chunk">@@ -1169,7 +1168,10 @@</span> <span class="p_context"> static int kvmppc_handle_exit_hv(struct kvm_run *run, struct kvm_vcpu *vcpu,</span>
 				swab32(vcpu-&gt;arch.emul_inst) :
 				vcpu-&gt;arch.emul_inst;
 		if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_USE_SW_BP) {
<span class="p_add">+			/* Need vcore unlocked to call kvmppc_get_last_inst */</span>
<span class="p_add">+			spin_unlock(&amp;vcpu-&gt;arch.vcore-&gt;lock);</span>
 			r = kvmppc_emulate_debug_inst(run, vcpu);
<span class="p_add">+			spin_lock(&amp;vcpu-&gt;arch.vcore-&gt;lock);</span>
 		} else {
 			kvmppc_core_queue_program(vcpu, SRR1_PROGILL);
 			r = RESUME_GUEST;
<span class="p_chunk">@@ -1184,8 +1186,13 @@</span> <span class="p_context"> static int kvmppc_handle_exit_hv(struct kvm_run *run, struct kvm_vcpu *vcpu,</span>
 	 */
 	case BOOK3S_INTERRUPT_H_FAC_UNAVAIL:
 		r = EMULATE_FAIL;
<span class="p_del">-		if ((vcpu-&gt;arch.hfscr &gt;&gt; 56) == FSCR_MSGP_LG)</span>
<span class="p_add">+		if (((vcpu-&gt;arch.hfscr &gt;&gt; 56) == FSCR_MSGP_LG) &amp;&amp;</span>
<span class="p_add">+		    cpu_has_feature(CPU_FTR_ARCH_300)) {</span>
<span class="p_add">+			/* Need vcore unlocked to call kvmppc_get_last_inst */</span>
<span class="p_add">+			spin_unlock(&amp;vcpu-&gt;arch.vcore-&gt;lock);</span>
 			r = kvmppc_emulate_doorbell_instr(vcpu);
<span class="p_add">+			spin_lock(&amp;vcpu-&gt;arch.vcore-&gt;lock);</span>
<span class="p_add">+		}</span>
 		if (r == EMULATE_FAIL) {
 			kvmppc_core_queue_program(vcpu, SRR1_PROGILL);
 			r = RESUME_GUEST;
<span class="p_chunk">@@ -2889,13 +2896,14 @@</span> <span class="p_context"> static noinline void kvmppc_run_core(struct kvmppc_vcore *vc)</span>
 	/* make sure updates to secondary vcpu structs are visible now */
 	smp_mb();
 
<span class="p_add">+	preempt_enable();</span>
<span class="p_add">+</span>
 	for (sub = 0; sub &lt; core_info.n_subcores; ++sub) {
 		pvc = core_info.vc[sub];
 		post_guest_process(pvc, pvc == vc);
 	}
 
 	spin_lock(&amp;vc-&gt;lock);
<span class="p_del">-	preempt_enable();</span>
 
  out:
 	vc-&gt;vcore_state = VCORE_INACTIVE;
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index c85ac5c83bd4..2b3194b9608f 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -1387,6 +1387,26 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)</span>
 	blt	deliver_guest_interrupt
 
 guest_exit_cont:		/* r9 = vcpu, r12 = trap, r13 = paca */
<span class="p_add">+	/* Save more register state  */</span>
<span class="p_add">+	mfdar	r6</span>
<span class="p_add">+	mfdsisr	r7</span>
<span class="p_add">+	std	r6, VCPU_DAR(r9)</span>
<span class="p_add">+	stw	r7, VCPU_DSISR(r9)</span>
<span class="p_add">+	/* don&#39;t overwrite fault_dar/fault_dsisr if HDSI */</span>
<span class="p_add">+	cmpwi	r12,BOOK3S_INTERRUPT_H_DATA_STORAGE</span>
<span class="p_add">+	beq	mc_cont</span>
<span class="p_add">+	std	r6, VCPU_FAULT_DAR(r9)</span>
<span class="p_add">+	stw	r7, VCPU_FAULT_DSISR(r9)</span>
<span class="p_add">+</span>
<span class="p_add">+	/* See if it is a machine check */</span>
<span class="p_add">+	cmpwi	r12, BOOK3S_INTERRUPT_MACHINE_CHECK</span>
<span class="p_add">+	beq	machine_check_realmode</span>
<span class="p_add">+mc_cont:</span>
<span class="p_add">+#ifdef CONFIG_KVM_BOOK3S_HV_EXIT_TIMING</span>
<span class="p_add">+	addi	r3, r9, VCPU_TB_RMEXIT</span>
<span class="p_add">+	mr	r4, r9</span>
<span class="p_add">+	bl	kvmhv_accumulate_time</span>
<span class="p_add">+#endif</span>
 #ifdef CONFIG_KVM_XICS
 	/* We are exiting, pull the VP from the XIVE */
 	lwz	r0, VCPU_XIVE_PUSHED(r9)
<span class="p_chunk">@@ -1424,26 +1444,6 @@</span> <span class="p_context"> guest_exit_cont:		/* r9 = vcpu, r12 = trap, r13 = paca */</span>
 	eieio
 1:
 #endif /* CONFIG_KVM_XICS */
<span class="p_del">-	/* Save more register state  */</span>
<span class="p_del">-	mfdar	r6</span>
<span class="p_del">-	mfdsisr	r7</span>
<span class="p_del">-	std	r6, VCPU_DAR(r9)</span>
<span class="p_del">-	stw	r7, VCPU_DSISR(r9)</span>
<span class="p_del">-	/* don&#39;t overwrite fault_dar/fault_dsisr if HDSI */</span>
<span class="p_del">-	cmpwi	r12,BOOK3S_INTERRUPT_H_DATA_STORAGE</span>
<span class="p_del">-	beq	mc_cont</span>
<span class="p_del">-	std	r6, VCPU_FAULT_DAR(r9)</span>
<span class="p_del">-	stw	r7, VCPU_FAULT_DSISR(r9)</span>
<span class="p_del">-</span>
<span class="p_del">-	/* See if it is a machine check */</span>
<span class="p_del">-	cmpwi	r12, BOOK3S_INTERRUPT_MACHINE_CHECK</span>
<span class="p_del">-	beq	machine_check_realmode</span>
<span class="p_del">-mc_cont:</span>
<span class="p_del">-#ifdef CONFIG_KVM_BOOK3S_HV_EXIT_TIMING</span>
<span class="p_del">-	addi	r3, r9, VCPU_TB_RMEXIT</span>
<span class="p_del">-	mr	r4, r9</span>
<span class="p_del">-	bl	kvmhv_accumulate_time</span>
<span class="p_del">-#endif</span>
 
 	mr 	r3, r12
 	/* Increment exit count, poke other threads to exit */
<span class="p_header">diff --git a/arch/s390/crypto/crc32-vx.c b/arch/s390/crypto/crc32-vx.c</span>
<span class="p_header">index 992e630c227b..6f4985f357c6 100644</span>
<span class="p_header">--- a/arch/s390/crypto/crc32-vx.c</span>
<span class="p_header">+++ b/arch/s390/crypto/crc32-vx.c</span>
<span class="p_chunk">@@ -238,6 +238,7 @@</span> <span class="p_context"> static struct shash_alg crc32_vx_algs[] = {</span>
 			.cra_name	 = &quot;crc32&quot;,
 			.cra_driver_name = &quot;crc32-vx&quot;,
 			.cra_priority	 = 200,
<span class="p_add">+			.cra_flags	 = CRYPTO_ALG_OPTIONAL_KEY,</span>
 			.cra_blocksize	 = CRC32_BLOCK_SIZE,
 			.cra_ctxsize	 = sizeof(struct crc_ctx),
 			.cra_module	 = THIS_MODULE,
<span class="p_chunk">@@ -258,6 +259,7 @@</span> <span class="p_context"> static struct shash_alg crc32_vx_algs[] = {</span>
 			.cra_name	 = &quot;crc32be&quot;,
 			.cra_driver_name = &quot;crc32be-vx&quot;,
 			.cra_priority	 = 200,
<span class="p_add">+			.cra_flags	 = CRYPTO_ALG_OPTIONAL_KEY,</span>
 			.cra_blocksize	 = CRC32_BLOCK_SIZE,
 			.cra_ctxsize	 = sizeof(struct crc_ctx),
 			.cra_module	 = THIS_MODULE,
<span class="p_chunk">@@ -278,6 +280,7 @@</span> <span class="p_context"> static struct shash_alg crc32_vx_algs[] = {</span>
 			.cra_name	 = &quot;crc32c&quot;,
 			.cra_driver_name = &quot;crc32c-vx&quot;,
 			.cra_priority	 = 200,
<span class="p_add">+			.cra_flags	 = CRYPTO_ALG_OPTIONAL_KEY,</span>
 			.cra_blocksize	 = CRC32_BLOCK_SIZE,
 			.cra_ctxsize	 = sizeof(struct crc_ctx),
 			.cra_module	 = THIS_MODULE,
<span class="p_header">diff --git a/arch/sh/kernel/traps_32.c b/arch/sh/kernel/traps_32.c</span>
<span class="p_header">index 57cff00cad17..b3770bb26211 100644</span>
<span class="p_header">--- a/arch/sh/kernel/traps_32.c</span>
<span class="p_header">+++ b/arch/sh/kernel/traps_32.c</span>
<span class="p_chunk">@@ -609,7 +609,8 @@</span> <span class="p_context"> asmlinkage void do_divide_error(unsigned long r4)</span>
 		break;
 	}
 
<span class="p_del">-	force_sig_info(SIGFPE, &amp;info, current);</span>
<span class="p_add">+	info.si_signo = SIGFPE;</span>
<span class="p_add">+	force_sig_info(info.si_signo, &amp;info, current);</span>
 }
 #endif
 
<span class="p_header">diff --git a/arch/sparc/crypto/crc32c_glue.c b/arch/sparc/crypto/crc32c_glue.c</span>
<span class="p_header">index d1064e46efe8..8aa664638c3c 100644</span>
<span class="p_header">--- a/arch/sparc/crypto/crc32c_glue.c</span>
<span class="p_header">+++ b/arch/sparc/crypto/crc32c_glue.c</span>
<span class="p_chunk">@@ -133,6 +133,7 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 		.cra_name		=	&quot;crc32c&quot;,
 		.cra_driver_name	=	&quot;crc32c-sparc64&quot;,
 		.cra_priority		=	SPARC_CR_OPCODE_PRIORITY,
<span class="p_add">+		.cra_flags		=	CRYPTO_ALG_OPTIONAL_KEY,</span>
 		.cra_blocksize		=	CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		=	sizeof(u32),
 		.cra_alignmask		=	7,
<span class="p_header">diff --git a/arch/x86/crypto/crc32-pclmul_glue.c b/arch/x86/crypto/crc32-pclmul_glue.c</span>
<span class="p_header">index 27226df3f7d8..c8d9cdacbf10 100644</span>
<span class="p_header">--- a/arch/x86/crypto/crc32-pclmul_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/crc32-pclmul_glue.c</span>
<span class="p_chunk">@@ -162,6 +162,7 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 			.cra_name		= &quot;crc32&quot;,
 			.cra_driver_name	= &quot;crc32-pclmul&quot;,
 			.cra_priority		= 200,
<span class="p_add">+			.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 			.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 			.cra_ctxsize		= sizeof(u32),
 			.cra_module		= THIS_MODULE,
<span class="p_header">diff --git a/arch/x86/crypto/crc32c-intel_glue.c b/arch/x86/crypto/crc32c-intel_glue.c</span>
<span class="p_header">index c194d5717ae5..5773e1161072 100644</span>
<span class="p_header">--- a/arch/x86/crypto/crc32c-intel_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/crc32c-intel_glue.c</span>
<span class="p_chunk">@@ -226,6 +226,7 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 		.cra_name		=	&quot;crc32c&quot;,
 		.cra_driver_name	=	&quot;crc32c-intel&quot;,
 		.cra_priority		=	200,
<span class="p_add">+		.cra_flags		=	CRYPTO_ALG_OPTIONAL_KEY,</span>
 		.cra_blocksize		=	CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		=	sizeof(u32),
 		.cra_module		=	THIS_MODULE,
<span class="p_header">diff --git a/arch/x86/crypto/poly1305_glue.c b/arch/x86/crypto/poly1305_glue.c</span>
<span class="p_header">index e32142bc071d..28c372003e44 100644</span>
<span class="p_header">--- a/arch/x86/crypto/poly1305_glue.c</span>
<span class="p_header">+++ b/arch/x86/crypto/poly1305_glue.c</span>
<span class="p_chunk">@@ -164,7 +164,6 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 	.init		= poly1305_simd_init,
 	.update		= poly1305_simd_update,
 	.final		= crypto_poly1305_final,
<span class="p_del">-	.setkey		= crypto_poly1305_setkey,</span>
 	.descsize	= sizeof(struct poly1305_simd_desc_ctx),
 	.base		= {
 		.cra_name		= &quot;poly1305&quot;,
<span class="p_header">diff --git a/arch/x86/crypto/sha512-mb/sha512_mb_mgr_init_avx2.c b/arch/x86/crypto/sha512-mb/sha512_mb_mgr_init_avx2.c</span>
<span class="p_header">index 36870b26067a..d08805032f01 100644</span>
<span class="p_header">--- a/arch/x86/crypto/sha512-mb/sha512_mb_mgr_init_avx2.c</span>
<span class="p_header">+++ b/arch/x86/crypto/sha512-mb/sha512_mb_mgr_init_avx2.c</span>
<span class="p_chunk">@@ -57,10 +57,12 @@</span> <span class="p_context"> void sha512_mb_mgr_init_avx2(struct sha512_mb_mgr *state)</span>
 {
 	unsigned int j;
 
<span class="p_del">-	state-&gt;lens[0] = 0;</span>
<span class="p_del">-	state-&gt;lens[1] = 1;</span>
<span class="p_del">-	state-&gt;lens[2] = 2;</span>
<span class="p_del">-	state-&gt;lens[3] = 3;</span>
<span class="p_add">+	/* initially all lanes are unused */</span>
<span class="p_add">+	state-&gt;lens[0] = 0xFFFFFFFF00000000;</span>
<span class="p_add">+	state-&gt;lens[1] = 0xFFFFFFFF00000001;</span>
<span class="p_add">+	state-&gt;lens[2] = 0xFFFFFFFF00000002;</span>
<span class="p_add">+	state-&gt;lens[3] = 0xFFFFFFFF00000003;</span>
<span class="p_add">+</span>
 	state-&gt;unused_lanes = 0xFF03020100;
 	for (j = 0; j &lt; 4; j++)
 		state-&gt;ldata[j].job_in_lane = NULL;
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index 0fce8d73403c..beb7f8795bc1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3784,7 +3784,8 @@</span> <span class="p_context"> static int kvm_arch_setup_async_pf(struct kvm_vcpu *vcpu, gva_t gva, gfn_t gfn)</span>
 bool kvm_can_do_async_pf(struct kvm_vcpu *vcpu)
 {
 	if (unlikely(!lapic_in_kernel(vcpu) ||
<span class="p_del">-		     kvm_event_needs_reinjection(vcpu)))</span>
<span class="p_add">+		     kvm_event_needs_reinjection(vcpu) ||</span>
<span class="p_add">+		     vcpu-&gt;arch.exception.pending))</span>
 		return false;
 
 	if (!vcpu-&gt;arch.apf.delivery_as_pf_vmexit &amp;&amp; is_guest_mode(vcpu))
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 0ae4b1a86168..0ea909ca45c2 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -5322,14 +5322,15 @@</span> <span class="p_context"> static int vmx_deliver_nested_posted_interrupt(struct kvm_vcpu *vcpu,</span>
 
 	if (is_guest_mode(vcpu) &amp;&amp;
 	    vector == vmx-&gt;nested.posted_intr_nv) {
<span class="p_del">-		/* the PIR and ON have been set by L1. */</span>
<span class="p_del">-		kvm_vcpu_trigger_posted_interrupt(vcpu, true);</span>
 		/*
 		 * If a posted intr is not recognized by hardware,
 		 * we will accomplish it in the next vmentry.
 		 */
 		vmx-&gt;nested.pi_pending = true;
 		kvm_make_request(KVM_REQ_EVENT, vcpu);
<span class="p_add">+		/* the PIR and ON have been set by L1. */</span>
<span class="p_add">+		if (!kvm_vcpu_trigger_posted_interrupt(vcpu, true))</span>
<span class="p_add">+			kvm_vcpu_kick(vcpu);</span>
 		return 0;
 	}
 	return -1;
<span class="p_chunk">@@ -11245,7 +11246,6 @@</span> <span class="p_context"> static int vmx_check_nested_events(struct kvm_vcpu *vcpu, bool external_intr)</span>
 		if (block_nested_events)
 			return -EBUSY;
 		nested_vmx_inject_exception_vmexit(vcpu, exit_qual);
<span class="p_del">-		vcpu-&gt;arch.exception.pending = false;</span>
 		return 0;
 	}
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.h b/arch/x86/kvm/x86.h</span>
<span class="p_header">index d0b95b7a90b4..6d112d8f799c 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.h</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.h</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 
 static inline void kvm_clear_exception_queue(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	vcpu-&gt;arch.exception.pending = false;</span>
 	vcpu-&gt;arch.exception.injected = false;
 }
 
<span class="p_header">diff --git a/arch/xtensa/include/asm/futex.h b/arch/xtensa/include/asm/futex.h</span>
<span class="p_header">index eaaf1ebcc7a4..5bfbc1c401d4 100644</span>
<span class="p_header">--- a/arch/xtensa/include/asm/futex.h</span>
<span class="p_header">+++ b/arch/xtensa/include/asm/futex.h</span>
<span class="p_chunk">@@ -92,7 +92,6 @@</span> <span class="p_context"> futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
 			      u32 oldval, u32 newval)
 {
 	int ret = 0;
<span class="p_del">-	u32 prev;</span>
 
 	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(u32)))
 		return -EFAULT;
<span class="p_chunk">@@ -103,26 +102,24 @@</span> <span class="p_context"> futex_atomic_cmpxchg_inatomic(u32 *uval, u32 __user *uaddr,</span>
 
 	__asm__ __volatile__ (
 	&quot;	# futex_atomic_cmpxchg_inatomic\n&quot;
<span class="p_del">-	&quot;1:	l32i	%1, %3, 0\n&quot;</span>
<span class="p_del">-	&quot;	mov	%0, %5\n&quot;</span>
<span class="p_del">-	&quot;	wsr	%1, scompare1\n&quot;</span>
<span class="p_del">-	&quot;2:	s32c1i	%0, %3, 0\n&quot;</span>
<span class="p_del">-	&quot;3:\n&quot;</span>
<span class="p_add">+	&quot;	wsr	%5, scompare1\n&quot;</span>
<span class="p_add">+	&quot;1:	s32c1i	%1, %4, 0\n&quot;</span>
<span class="p_add">+	&quot;	s32i	%1, %6, 0\n&quot;</span>
<span class="p_add">+	&quot;2:\n&quot;</span>
 	&quot;	.section .fixup,\&quot;ax\&quot;\n&quot;
 	&quot;	.align 4\n&quot;
<span class="p_del">-	&quot;4:	.long	3b\n&quot;</span>
<span class="p_del">-	&quot;5:	l32r	%1, 4b\n&quot;</span>
<span class="p_del">-	&quot;	movi	%0, %6\n&quot;</span>
<span class="p_add">+	&quot;3:	.long	2b\n&quot;</span>
<span class="p_add">+	&quot;4:	l32r	%1, 3b\n&quot;</span>
<span class="p_add">+	&quot;	movi	%0, %7\n&quot;</span>
 	&quot;	jx	%1\n&quot;
 	&quot;	.previous\n&quot;
 	&quot;	.section __ex_table,\&quot;a\&quot;\n&quot;
<span class="p_del">-	&quot;	.long 1b,5b,2b,5b\n&quot;</span>
<span class="p_add">+	&quot;	.long 1b,4b\n&quot;</span>
 	&quot;	.previous\n&quot;
<span class="p_del">-	: &quot;+r&quot; (ret), &quot;=&amp;r&quot; (prev), &quot;+m&quot; (*uaddr)</span>
<span class="p_del">-	: &quot;r&quot; (uaddr), &quot;r&quot; (oldval), &quot;r&quot; (newval), &quot;I&quot; (-EFAULT)</span>
<span class="p_add">+	: &quot;+r&quot; (ret), &quot;+r&quot; (newval), &quot;+m&quot; (*uaddr), &quot;+m&quot; (*uval)</span>
<span class="p_add">+	: &quot;r&quot; (uaddr), &quot;r&quot; (oldval), &quot;r&quot; (uval), &quot;I&quot; (-EFAULT)</span>
 	: &quot;memory&quot;);
 
<span class="p_del">-	*uval = prev;</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 7b30bf10b1d4..f3750389e351 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -660,6 +660,15 @@</span> <span class="p_context"> void blk_cleanup_queue(struct request_queue *q)</span>
 	queue_flag_set(QUEUE_FLAG_DEAD, q);
 	spin_unlock_irq(lock);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * make sure all in-progress dispatch are completed because</span>
<span class="p_add">+	 * blk_freeze_queue() can only complete all requests, and</span>
<span class="p_add">+	 * dispatch may still be in-progress since we dispatch requests</span>
<span class="p_add">+	 * from more than one contexts</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (q-&gt;mq_ops)</span>
<span class="p_add">+		blk_mq_quiesce_queue(q);</span>
<span class="p_add">+</span>
 	/* for synchronous bio-based driver finish in-flight integrity i/o */
 	blk_flush_integrity();
 
<span class="p_header">diff --git a/crypto/ahash.c b/crypto/ahash.c</span>
<span class="p_header">index 5e8666e6ccae..f75b5c1f7152 100644</span>
<span class="p_header">--- a/crypto/ahash.c</span>
<span class="p_header">+++ b/crypto/ahash.c</span>
<span class="p_chunk">@@ -193,11 +193,18 @@</span> <span class="p_context"> int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,</span>
 			unsigned int keylen)
 {
 	unsigned long alignmask = crypto_ahash_alignmask(tfm);
<span class="p_add">+	int err;</span>
 
 	if ((unsigned long)key &amp; alignmask)
<span class="p_del">-		return ahash_setkey_unaligned(tfm, key, keylen);</span>
<span class="p_add">+		err = ahash_setkey_unaligned(tfm, key, keylen);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		err = tfm-&gt;setkey(tfm, key, keylen);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_del">-	return tfm-&gt;setkey(tfm, key, keylen);</span>
<span class="p_add">+	crypto_ahash_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL_GPL(crypto_ahash_setkey);
 
<span class="p_chunk">@@ -370,7 +377,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(crypto_ahash_finup);</span>
 
 int crypto_ahash_digest(struct ahash_request *req)
 {
<span class="p_del">-	return crypto_ahash_op(req, crypto_ahash_reqtfm(req)-&gt;digest);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (crypto_ahash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_ahash_op(req, tfm-&gt;digest);</span>
 }
 EXPORT_SYMBOL_GPL(crypto_ahash_digest);
 
<span class="p_chunk">@@ -456,7 +468,6 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 	struct ahash_alg *alg = crypto_ahash_alg(hash);
 
 	hash-&gt;setkey = ahash_nosetkey;
<span class="p_del">-	hash-&gt;has_setkey = false;</span>
 	hash-&gt;export = ahash_no_export;
 	hash-&gt;import = ahash_no_import;
 
<span class="p_chunk">@@ -471,7 +482,8 @@</span> <span class="p_context"> static int crypto_ahash_init_tfm(struct crypto_tfm *tfm)</span>
 
 	if (alg-&gt;setkey) {
 		hash-&gt;setkey = alg-&gt;setkey;
<span class="p_del">-		hash-&gt;has_setkey = true;</span>
<span class="p_add">+		if (!(alg-&gt;halg.base.cra_flags &amp; CRYPTO_ALG_OPTIONAL_KEY))</span>
<span class="p_add">+			crypto_ahash_set_flags(hash, CRYPTO_TFM_NEED_KEY);</span>
 	}
 	if (alg-&gt;export)
 		hash-&gt;export = alg-&gt;export;
<span class="p_chunk">@@ -655,5 +667,16 @@</span> <span class="p_context"> struct hash_alg_common *ahash_attr_alg(struct rtattr *rta, u32 type, u32 mask)</span>
 }
 EXPORT_SYMBOL_GPL(ahash_attr_alg);
 
<span class="p_add">+bool crypto_hash_alg_has_setkey(struct hash_alg_common *halg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct crypto_alg *alg = &amp;halg-&gt;base;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (alg-&gt;cra_type != &amp;crypto_ahash_type)</span>
<span class="p_add">+		return crypto_shash_alg_has_setkey(__crypto_shash_alg(alg));</span>
<span class="p_add">+</span>
<span class="p_add">+	return __crypto_ahash_alg(alg)-&gt;setkey != NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(crypto_hash_alg_has_setkey);</span>
<span class="p_add">+</span>
 MODULE_LICENSE(&quot;GPL&quot;);
 MODULE_DESCRIPTION(&quot;Asynchronous cryptographic hash type&quot;);
<span class="p_header">diff --git a/crypto/algif_hash.c b/crypto/algif_hash.c</span>
<span class="p_header">index 5e92bd275ef3..39cebd3256bf 100644</span>
<span class="p_header">--- a/crypto/algif_hash.c</span>
<span class="p_header">+++ b/crypto/algif_hash.c</span>
<span class="p_chunk">@@ -34,11 +34,6 @@</span> <span class="p_context"> struct hash_ctx {</span>
 	struct ahash_request req;
 };
 
<span class="p_del">-struct algif_hash_tfm {</span>
<span class="p_del">-	struct crypto_ahash *hash;</span>
<span class="p_del">-	bool has_key;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static int hash_alloc_result(struct sock *sk, struct hash_ctx *ctx)
 {
 	unsigned ds;
<span class="p_chunk">@@ -309,7 +304,7 @@</span> <span class="p_context"> static int hash_check_key(struct socket *sock)</span>
 	int err = 0;
 	struct sock *psk;
 	struct alg_sock *pask;
<span class="p_del">-	struct algif_hash_tfm *tfm;</span>
<span class="p_add">+	struct crypto_ahash *tfm;</span>
 	struct sock *sk = sock-&gt;sk;
 	struct alg_sock *ask = alg_sk(sk);
 
<span class="p_chunk">@@ -323,7 +318,7 @@</span> <span class="p_context"> static int hash_check_key(struct socket *sock)</span>
 
 	err = -ENOKEY;
 	lock_sock_nested(psk, SINGLE_DEPTH_NESTING);
<span class="p_del">-	if (!tfm-&gt;has_key)</span>
<span class="p_add">+	if (crypto_ahash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
 		goto unlock;
 
 	if (!pask-&gt;refcnt++)
<span class="p_chunk">@@ -414,41 +409,17 @@</span> <span class="p_context"> static struct proto_ops algif_hash_ops_nokey = {</span>
 
 static void *hash_bind(const char *name, u32 type, u32 mask)
 {
<span class="p_del">-	struct algif_hash_tfm *tfm;</span>
<span class="p_del">-	struct crypto_ahash *hash;</span>
<span class="p_del">-</span>
<span class="p_del">-	tfm = kzalloc(sizeof(*tfm), GFP_KERNEL);</span>
<span class="p_del">-	if (!tfm)</span>
<span class="p_del">-		return ERR_PTR(-ENOMEM);</span>
<span class="p_del">-</span>
<span class="p_del">-	hash = crypto_alloc_ahash(name, type, mask);</span>
<span class="p_del">-	if (IS_ERR(hash)) {</span>
<span class="p_del">-		kfree(tfm);</span>
<span class="p_del">-		return ERR_CAST(hash);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	tfm-&gt;hash = hash;</span>
<span class="p_del">-</span>
<span class="p_del">-	return tfm;</span>
<span class="p_add">+	return crypto_alloc_ahash(name, type, mask);</span>
 }
 
 static void hash_release(void *private)
 {
<span class="p_del">-	struct algif_hash_tfm *tfm = private;</span>
<span class="p_del">-</span>
<span class="p_del">-	crypto_free_ahash(tfm-&gt;hash);</span>
<span class="p_del">-	kfree(tfm);</span>
<span class="p_add">+	crypto_free_ahash(private);</span>
 }
 
 static int hash_setkey(void *private, const u8 *key, unsigned int keylen)
 {
<span class="p_del">-	struct algif_hash_tfm *tfm = private;</span>
<span class="p_del">-	int err;</span>
<span class="p_del">-</span>
<span class="p_del">-	err = crypto_ahash_setkey(tfm-&gt;hash, key, keylen);</span>
<span class="p_del">-	tfm-&gt;has_key = !err;</span>
<span class="p_del">-</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	return crypto_ahash_setkey(private, key, keylen);</span>
 }
 
 static void hash_sock_destruct(struct sock *sk)
<span class="p_chunk">@@ -463,11 +434,10 @@</span> <span class="p_context"> static void hash_sock_destruct(struct sock *sk)</span>
 
 static int hash_accept_parent_nokey(void *private, struct sock *sk)
 {
<span class="p_del">-	struct hash_ctx *ctx;</span>
<span class="p_add">+	struct crypto_ahash *tfm = private;</span>
 	struct alg_sock *ask = alg_sk(sk);
<span class="p_del">-	struct algif_hash_tfm *tfm = private;</span>
<span class="p_del">-	struct crypto_ahash *hash = tfm-&gt;hash;</span>
<span class="p_del">-	unsigned len = sizeof(*ctx) + crypto_ahash_reqsize(hash);</span>
<span class="p_add">+	struct hash_ctx *ctx;</span>
<span class="p_add">+	unsigned int len = sizeof(*ctx) + crypto_ahash_reqsize(tfm);</span>
 
 	ctx = sock_kmalloc(sk, len, GFP_KERNEL);
 	if (!ctx)
<span class="p_chunk">@@ -480,7 +450,7 @@</span> <span class="p_context"> static int hash_accept_parent_nokey(void *private, struct sock *sk)</span>
 
 	ask-&gt;private = ctx;
 
<span class="p_del">-	ahash_request_set_tfm(&amp;ctx-&gt;req, hash);</span>
<span class="p_add">+	ahash_request_set_tfm(&amp;ctx-&gt;req, tfm);</span>
 	ahash_request_set_callback(&amp;ctx-&gt;req, CRYPTO_TFM_REQ_MAY_BACKLOG,
 				   af_alg_complete, &amp;ctx-&gt;completion);
 
<span class="p_chunk">@@ -491,9 +461,9 @@</span> <span class="p_context"> static int hash_accept_parent_nokey(void *private, struct sock *sk)</span>
 
 static int hash_accept_parent(void *private, struct sock *sk)
 {
<span class="p_del">-	struct algif_hash_tfm *tfm = private;</span>
<span class="p_add">+	struct crypto_ahash *tfm = private;</span>
 
<span class="p_del">-	if (!tfm-&gt;has_key &amp;&amp; crypto_ahash_has_setkey(tfm-&gt;hash))</span>
<span class="p_add">+	if (crypto_ahash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
 		return -ENOKEY;
 
 	return hash_accept_parent_nokey(private, sk);
<span class="p_header">diff --git a/crypto/crc32_generic.c b/crypto/crc32_generic.c</span>
<span class="p_header">index aa2a25fc7482..718cbce8d169 100644</span>
<span class="p_header">--- a/crypto/crc32_generic.c</span>
<span class="p_header">+++ b/crypto/crc32_generic.c</span>
<span class="p_chunk">@@ -133,6 +133,7 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 		.cra_name		= &quot;crc32&quot;,
 		.cra_driver_name	= &quot;crc32-generic&quot;,
 		.cra_priority		= 100,
<span class="p_add">+		.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 		.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(u32),
 		.cra_module		= THIS_MODULE,
<span class="p_header">diff --git a/crypto/crc32c_generic.c b/crypto/crc32c_generic.c</span>
<span class="p_header">index 4c0a0e271876..372320399622 100644</span>
<span class="p_header">--- a/crypto/crc32c_generic.c</span>
<span class="p_header">+++ b/crypto/crc32c_generic.c</span>
<span class="p_chunk">@@ -146,6 +146,7 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 		.cra_name		=	&quot;crc32c&quot;,
 		.cra_driver_name	=	&quot;crc32c-generic&quot;,
 		.cra_priority		=	100,
<span class="p_add">+		.cra_flags		=	CRYPTO_ALG_OPTIONAL_KEY,</span>
 		.cra_blocksize		=	CHKSUM_BLOCK_SIZE,
 		.cra_alignmask		=	3,
 		.cra_ctxsize		=	sizeof(struct chksum_ctx),
<span class="p_header">diff --git a/crypto/cryptd.c b/crypto/cryptd.c</span>
<span class="p_header">index 0508c48a45c4..248f6ba41688 100644</span>
<span class="p_header">--- a/crypto/cryptd.c</span>
<span class="p_header">+++ b/crypto/cryptd.c</span>
<span class="p_chunk">@@ -895,10 +895,9 @@</span> <span class="p_context"> static int cryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	if (err)
 		goto out_free_inst;
 
<span class="p_del">-	type = CRYPTO_ALG_ASYNC;</span>
<span class="p_del">-	if (alg-&gt;cra_flags &amp; CRYPTO_ALG_INTERNAL)</span>
<span class="p_del">-		type |= CRYPTO_ALG_INTERNAL;</span>
<span class="p_del">-	inst-&gt;alg.halg.base.cra_flags = type;</span>
<span class="p_add">+	inst-&gt;alg.halg.base.cra_flags = CRYPTO_ALG_ASYNC |</span>
<span class="p_add">+		(alg-&gt;cra_flags &amp; (CRYPTO_ALG_INTERNAL |</span>
<span class="p_add">+				   CRYPTO_ALG_OPTIONAL_KEY));</span>
 
 	inst-&gt;alg.halg.digestsize = salg-&gt;digestsize;
 	inst-&gt;alg.halg.statesize = salg-&gt;statesize;
<span class="p_chunk">@@ -913,7 +912,8 @@</span> <span class="p_context"> static int cryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	inst-&gt;alg.finup  = cryptd_hash_finup_enqueue;
 	inst-&gt;alg.export = cryptd_hash_export;
 	inst-&gt;alg.import = cryptd_hash_import;
<span class="p_del">-	inst-&gt;alg.setkey = cryptd_hash_setkey;</span>
<span class="p_add">+	if (crypto_shash_alg_has_setkey(salg))</span>
<span class="p_add">+		inst-&gt;alg.setkey = cryptd_hash_setkey;</span>
 	inst-&gt;alg.digest = cryptd_hash_digest_enqueue;
 
 	err = ahash_register_instance(tmpl, inst);
<span class="p_header">diff --git a/crypto/mcryptd.c b/crypto/mcryptd.c</span>
<span class="p_header">index eca04d3729b3..e0732d979e3b 100644</span>
<span class="p_header">--- a/crypto/mcryptd.c</span>
<span class="p_header">+++ b/crypto/mcryptd.c</span>
<span class="p_chunk">@@ -517,10 +517,9 @@</span> <span class="p_context"> static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	if (err)
 		goto out_free_inst;
 
<span class="p_del">-	type = CRYPTO_ALG_ASYNC;</span>
<span class="p_del">-	if (alg-&gt;cra_flags &amp; CRYPTO_ALG_INTERNAL)</span>
<span class="p_del">-		type |= CRYPTO_ALG_INTERNAL;</span>
<span class="p_del">-	inst-&gt;alg.halg.base.cra_flags = type;</span>
<span class="p_add">+	inst-&gt;alg.halg.base.cra_flags = CRYPTO_ALG_ASYNC |</span>
<span class="p_add">+		(alg-&gt;cra_flags &amp; (CRYPTO_ALG_INTERNAL |</span>
<span class="p_add">+				   CRYPTO_ALG_OPTIONAL_KEY));</span>
 
 	inst-&gt;alg.halg.digestsize = halg-&gt;digestsize;
 	inst-&gt;alg.halg.statesize = halg-&gt;statesize;
<span class="p_chunk">@@ -535,7 +534,8 @@</span> <span class="p_context"> static int mcryptd_create_hash(struct crypto_template *tmpl, struct rtattr **tb,</span>
 	inst-&gt;alg.finup  = mcryptd_hash_finup_enqueue;
 	inst-&gt;alg.export = mcryptd_hash_export;
 	inst-&gt;alg.import = mcryptd_hash_import;
<span class="p_del">-	inst-&gt;alg.setkey = mcryptd_hash_setkey;</span>
<span class="p_add">+	if (crypto_hash_alg_has_setkey(halg))</span>
<span class="p_add">+		inst-&gt;alg.setkey = mcryptd_hash_setkey;</span>
 	inst-&gt;alg.digest = mcryptd_hash_digest_enqueue;
 
 	err = ahash_register_instance(tmpl, inst);
<span class="p_header">diff --git a/crypto/poly1305_generic.c b/crypto/poly1305_generic.c</span>
<span class="p_header">index b1c2d57dc734..ba39eb308c79 100644</span>
<span class="p_header">--- a/crypto/poly1305_generic.c</span>
<span class="p_header">+++ b/crypto/poly1305_generic.c</span>
<span class="p_chunk">@@ -47,17 +47,6 @@</span> <span class="p_context"> int crypto_poly1305_init(struct shash_desc *desc)</span>
 }
 EXPORT_SYMBOL_GPL(crypto_poly1305_init);
 
<span class="p_del">-int crypto_poly1305_setkey(struct crypto_shash *tfm,</span>
<span class="p_del">-			   const u8 *key, unsigned int keylen)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* Poly1305 requires a unique key for each tag, which implies that</span>
<span class="p_del">-	 * we can&#39;t set it on the tfm that gets accessed by multiple users</span>
<span class="p_del">-	 * simultaneously. Instead we expect the key as the first 32 bytes in</span>
<span class="p_del">-	 * the update() call. */</span>
<span class="p_del">-	return -ENOTSUPP;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(crypto_poly1305_setkey);</span>
<span class="p_del">-</span>
 static void poly1305_setrkey(struct poly1305_desc_ctx *dctx, const u8 *key)
 {
 	/* r &amp;= 0xffffffc0ffffffc0ffffffc0fffffff */
<span class="p_chunk">@@ -76,6 +65,11 @@</span> <span class="p_context"> static void poly1305_setskey(struct poly1305_desc_ctx *dctx, const u8 *key)</span>
 	dctx-&gt;s[3] = get_unaligned_le32(key + 12);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Poly1305 requires a unique key for each tag, which implies that we can&#39;t set</span>
<span class="p_add">+ * it on the tfm that gets accessed by multiple users simultaneously. Instead we</span>
<span class="p_add">+ * expect the key as the first 32 bytes in the update() call.</span>
<span class="p_add">+ */</span>
 unsigned int crypto_poly1305_setdesckey(struct poly1305_desc_ctx *dctx,
 					const u8 *src, unsigned int srclen)
 {
<span class="p_chunk">@@ -281,7 +275,6 @@</span> <span class="p_context"> static struct shash_alg poly1305_alg = {</span>
 	.init		= crypto_poly1305_init,
 	.update		= crypto_poly1305_update,
 	.final		= crypto_poly1305_final,
<span class="p_del">-	.setkey		= crypto_poly1305_setkey,</span>
 	.descsize	= sizeof(struct poly1305_desc_ctx),
 	.base		= {
 		.cra_name		= &quot;poly1305&quot;,
<span class="p_header">diff --git a/crypto/shash.c b/crypto/shash.c</span>
<span class="p_header">index e849d3ee2e27..5d732c6bb4b2 100644</span>
<span class="p_header">--- a/crypto/shash.c</span>
<span class="p_header">+++ b/crypto/shash.c</span>
<span class="p_chunk">@@ -58,11 +58,18 @@</span> <span class="p_context"> int crypto_shash_setkey(struct crypto_shash *tfm, const u8 *key,</span>
 {
 	struct shash_alg *shash = crypto_shash_alg(tfm);
 	unsigned long alignmask = crypto_shash_alignmask(tfm);
<span class="p_add">+	int err;</span>
 
 	if ((unsigned long)key &amp; alignmask)
<span class="p_del">-		return shash_setkey_unaligned(tfm, key, keylen);</span>
<span class="p_add">+		err = shash_setkey_unaligned(tfm, key, keylen);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		err = shash-&gt;setkey(tfm, key, keylen);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_del">-	return shash-&gt;setkey(tfm, key, keylen);</span>
<span class="p_add">+	crypto_shash_clear_flags(tfm, CRYPTO_TFM_NEED_KEY);</span>
<span class="p_add">+	return 0;</span>
 }
 EXPORT_SYMBOL_GPL(crypto_shash_setkey);
 
<span class="p_chunk">@@ -181,6 +188,9 @@</span> <span class="p_context"> int crypto_shash_digest(struct shash_desc *desc, const u8 *data,</span>
 	struct shash_alg *shash = crypto_shash_alg(tfm);
 	unsigned long alignmask = crypto_shash_alignmask(tfm);
 
<span class="p_add">+	if (crypto_shash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
 	if (((unsigned long)data | (unsigned long)out) &amp; alignmask)
 		return shash_digest_unaligned(desc, data, len, out);
 
<span class="p_chunk">@@ -360,7 +370,8 @@</span> <span class="p_context"> int crypto_init_shash_ops_async(struct crypto_tfm *tfm)</span>
 	crt-&gt;digest = shash_async_digest;
 	crt-&gt;setkey = shash_async_setkey;
 
<span class="p_del">-	crt-&gt;has_setkey = alg-&gt;setkey != shash_no_setkey;</span>
<span class="p_add">+	crypto_ahash_set_flags(crt, crypto_shash_get_flags(shash) &amp;</span>
<span class="p_add">+				    CRYPTO_TFM_NEED_KEY);</span>
 
 	if (alg-&gt;export)
 		crt-&gt;export = shash_async_export;
<span class="p_chunk">@@ -375,8 +386,14 @@</span> <span class="p_context"> int crypto_init_shash_ops_async(struct crypto_tfm *tfm)</span>
 static int crypto_shash_init_tfm(struct crypto_tfm *tfm)
 {
 	struct crypto_shash *hash = __crypto_shash_cast(tfm);
<span class="p_add">+	struct shash_alg *alg = crypto_shash_alg(hash);</span>
<span class="p_add">+</span>
<span class="p_add">+	hash-&gt;descsize = alg-&gt;descsize;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (crypto_shash_alg_has_setkey(alg) &amp;&amp;</span>
<span class="p_add">+	    !(alg-&gt;base.cra_flags &amp; CRYPTO_ALG_OPTIONAL_KEY))</span>
<span class="p_add">+		crypto_shash_set_flags(hash, CRYPTO_TFM_NEED_KEY);</span>
 
<span class="p_del">-	hash-&gt;descsize = crypto_shash_alg(hash)-&gt;descsize;</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/acpi/nfit/core.c b/drivers/acpi/nfit/core.c</span>
<span class="p_header">index dea0fb3d6f64..f14b4326e855 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit/core.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit/core.c</span>
<span class="p_chunk">@@ -1618,6 +1618,9 @@</span> <span class="p_context"> static int acpi_nfit_register_dimms(struct acpi_nfit_desc *acpi_desc)</span>
 		struct kernfs_node *nfit_kernfs;
 
 		nvdimm = nfit_mem-&gt;nvdimm;
<span class="p_add">+		if (!nvdimm)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		nfit_kernfs = sysfs_get_dirent(nvdimm_kobj(nvdimm)-&gt;sd, &quot;nfit&quot;);
 		if (nfit_kernfs)
 			nfit_mem-&gt;flags_attr = sysfs_get_dirent(nfit_kernfs,
<span class="p_header">diff --git a/drivers/acpi/sbshc.c b/drivers/acpi/sbshc.c</span>
<span class="p_header">index 2fa8304171e0..7a3431018e0a 100644</span>
<span class="p_header">--- a/drivers/acpi/sbshc.c</span>
<span class="p_header">+++ b/drivers/acpi/sbshc.c</span>
<span class="p_chunk">@@ -275,8 +275,8 @@</span> <span class="p_context"> static int acpi_smbus_hc_add(struct acpi_device *device)</span>
 	device-&gt;driver_data = hc;
 
 	acpi_ec_add_query_handler(hc-&gt;ec, hc-&gt;query_bit, NULL, smbus_alarm, hc);
<span class="p_del">-	printk(KERN_INFO PREFIX &quot;SBS HC: EC = 0x%p, offset = 0x%0x, query_bit = 0x%0x\n&quot;,</span>
<span class="p_del">-		hc-&gt;ec, hc-&gt;offset, hc-&gt;query_bit);</span>
<span class="p_add">+	dev_info(&amp;device-&gt;dev, &quot;SBS HC: offset = 0x%0x, query_bit = 0x%0x\n&quot;,</span>
<span class="p_add">+		 hc-&gt;offset, hc-&gt;query_bit);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index 9f78bb03bb76..bc013f757d5d 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -267,9 +267,9 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x3b23), board_ahci }, /* PCH AHCI */
 	{ PCI_VDEVICE(INTEL, 0x3b24), board_ahci }, /* PCH RAID */
 	{ PCI_VDEVICE(INTEL, 0x3b25), board_ahci }, /* PCH RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x3b29), board_ahci }, /* PCH AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x3b29), board_ahci }, /* PCH M AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0x3b2b), board_ahci }, /* PCH RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x3b2c), board_ahci }, /* PCH RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x3b2c), board_ahci }, /* PCH M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x3b2f), board_ahci }, /* PCH AHCI */
 	{ PCI_VDEVICE(INTEL, 0x19b0), board_ahci }, /* DNV AHCI */
 	{ PCI_VDEVICE(INTEL, 0x19b1), board_ahci }, /* DNV AHCI */
<span class="p_chunk">@@ -292,9 +292,9 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x19cE), board_ahci }, /* DNV AHCI */
 	{ PCI_VDEVICE(INTEL, 0x19cF), board_ahci }, /* DNV AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1c02), board_ahci }, /* CPT AHCI */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1c03), board_ahci }, /* CPT AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1c03), board_ahci }, /* CPT M AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0x1c04), board_ahci }, /* CPT RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1c05), board_ahci }, /* CPT RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1c05), board_ahci }, /* CPT M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x1c06), board_ahci }, /* CPT RAID */
 	{ PCI_VDEVICE(INTEL, 0x1c07), board_ahci }, /* CPT RAID */
 	{ PCI_VDEVICE(INTEL, 0x1d02), board_ahci }, /* PBG AHCI */
<span class="p_chunk">@@ -303,20 +303,20 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x2826), board_ahci }, /* PBG RAID */
 	{ PCI_VDEVICE(INTEL, 0x2323), board_ahci }, /* DH89xxCC AHCI */
 	{ PCI_VDEVICE(INTEL, 0x1e02), board_ahci }, /* Panther Point AHCI */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1e03), board_ahci }, /* Panther Point AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1e03), board_ahci }, /* Panther Point M AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0x1e04), board_ahci }, /* Panther Point RAID */
 	{ PCI_VDEVICE(INTEL, 0x1e05), board_ahci }, /* Panther Point RAID */
 	{ PCI_VDEVICE(INTEL, 0x1e06), board_ahci }, /* Panther Point RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1e07), board_ahci }, /* Panther Point RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1e07), board_ahci }, /* Panther Point M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x1e0e), board_ahci }, /* Panther Point RAID */
 	{ PCI_VDEVICE(INTEL, 0x8c02), board_ahci }, /* Lynx Point AHCI */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c03), board_ahci }, /* Lynx Point AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c03), board_ahci }, /* Lynx Point M AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0x8c04), board_ahci }, /* Lynx Point RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c05), board_ahci }, /* Lynx Point RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c05), board_ahci }, /* Lynx Point M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x8c06), board_ahci }, /* Lynx Point RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c07), board_ahci }, /* Lynx Point RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c07), board_ahci }, /* Lynx Point M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x8c0e), board_ahci }, /* Lynx Point RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c0f), board_ahci }, /* Lynx Point RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c0f), board_ahci }, /* Lynx Point M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x9c02), board_ahci }, /* Lynx Point-LP AHCI */
 	{ PCI_VDEVICE(INTEL, 0x9c03), board_ahci }, /* Lynx Point-LP AHCI */
 	{ PCI_VDEVICE(INTEL, 0x9c04), board_ahci }, /* Lynx Point-LP RAID */
<span class="p_chunk">@@ -357,21 +357,21 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x9c87), board_ahci }, /* Wildcat Point-LP RAID */
 	{ PCI_VDEVICE(INTEL, 0x9c8f), board_ahci }, /* Wildcat Point-LP RAID */
 	{ PCI_VDEVICE(INTEL, 0x8c82), board_ahci }, /* 9 Series AHCI */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c83), board_ahci }, /* 9 Series AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c83), board_ahci }, /* 9 Series M AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0x8c84), board_ahci }, /* 9 Series RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c85), board_ahci }, /* 9 Series RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c85), board_ahci }, /* 9 Series M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x8c86), board_ahci }, /* 9 Series RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c87), board_ahci }, /* 9 Series RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c87), board_ahci }, /* 9 Series M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x8c8e), board_ahci }, /* 9 Series RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x8c8f), board_ahci }, /* 9 Series RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x8c8f), board_ahci }, /* 9 Series M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x9d03), board_ahci }, /* Sunrise Point-LP AHCI */
 	{ PCI_VDEVICE(INTEL, 0x9d05), board_ahci }, /* Sunrise Point-LP RAID */
 	{ PCI_VDEVICE(INTEL, 0x9d07), board_ahci }, /* Sunrise Point-LP RAID */
 	{ PCI_VDEVICE(INTEL, 0xa102), board_ahci }, /* Sunrise Point-H AHCI */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0xa103), board_ahci }, /* Sunrise Point-H AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0xa103), board_ahci }, /* Sunrise Point-H M AHCI */</span>
 	{ PCI_VDEVICE(INTEL, 0xa105), board_ahci }, /* Sunrise Point-H RAID */
 	{ PCI_VDEVICE(INTEL, 0xa106), board_ahci }, /* Sunrise Point-H RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0xa107), board_ahci }, /* Sunrise Point-H RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0xa107), board_ahci }, /* Sunrise Point-H M RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0xa10f), board_ahci }, /* Sunrise Point-H RAID */
 	{ PCI_VDEVICE(INTEL, 0x2822), board_ahci }, /* Lewisburg RAID*/
 	{ PCI_VDEVICE(INTEL, 0x2823), board_ahci }, /* Lewisburg AHCI*/
<span class="p_chunk">@@ -385,6 +385,11 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0xa206), board_ahci }, /* Lewisburg RAID*/
 	{ PCI_VDEVICE(INTEL, 0xa252), board_ahci }, /* Lewisburg RAID*/
 	{ PCI_VDEVICE(INTEL, 0xa256), board_ahci }, /* Lewisburg RAID*/
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0xa356), board_ahci }, /* Cannon Lake PCH-H RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x0f22), board_ahci }, /* Bay Trail AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x0f23), board_ahci }, /* Bay Trail AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x22a3), board_ahci }, /* Cherry Trail AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x5ae3), board_ahci }, /* Apollo Lake AHCI */</span>
 
 	/* JMicron 360/1/3/5/6, match class to avoid IDE function */
 	{ PCI_VENDOR_ID_JMICRON, PCI_ANY_ID, PCI_ANY_ID, PCI_ANY_ID,
<span class="p_header">diff --git a/drivers/block/pktcdvd.c b/drivers/block/pktcdvd.c</span>
<span class="p_header">index 67974796c350..531a0915066b 100644</span>
<span class="p_header">--- a/drivers/block/pktcdvd.c</span>
<span class="p_header">+++ b/drivers/block/pktcdvd.c</span>
<span class="p_chunk">@@ -2579,14 +2579,14 @@</span> <span class="p_context"> static int pkt_new_dev(struct pktcdvd_device *pd, dev_t dev)</span>
 	bdev = bdget(dev);
 	if (!bdev)
 		return -ENOMEM;
<span class="p_add">+	ret = blkdev_get(bdev, FMODE_READ | FMODE_NDELAY, NULL);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	if (!blk_queue_scsi_passthrough(bdev_get_queue(bdev))) {
 		WARN_ONCE(true, &quot;Attempt to register a non-SCSI queue\n&quot;);
<span class="p_del">-		bdput(bdev);</span>
<span class="p_add">+		blkdev_put(bdev, FMODE_READ | FMODE_NDELAY);</span>
 		return -EINVAL;
 	}
<span class="p_del">-	ret = blkdev_get(bdev, FMODE_READ | FMODE_NDELAY, NULL);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
 
 	/* This is safe, since we have a reference from open(). */
 	__module_get(THIS_MODULE);
<span class="p_chunk">@@ -2745,7 +2745,7 @@</span> <span class="p_context"> static int pkt_setup_dev(dev_t dev, dev_t* pkt_dev)</span>
 	pd-&gt;pkt_dev = MKDEV(pktdev_major, idx);
 	ret = pkt_new_dev(pd, dev);
 	if (ret)
<span class="p_del">-		goto out_new_dev;</span>
<span class="p_add">+		goto out_mem2;</span>
 
 	/* inherit events of the host device */
 	disk-&gt;events = pd-&gt;bdev-&gt;bd_disk-&gt;events;
<span class="p_chunk">@@ -2763,8 +2763,6 @@</span> <span class="p_context"> static int pkt_setup_dev(dev_t dev, dev_t* pkt_dev)</span>
 	mutex_unlock(&amp;ctl_mutex);
 	return 0;
 
<span class="p_del">-out_new_dev:</span>
<span class="p_del">-	blk_cleanup_queue(disk-&gt;queue);</span>
 out_mem2:
 	put_disk(disk);
 out_mem:
<span class="p_header">diff --git a/drivers/bluetooth/btsdio.c b/drivers/bluetooth/btsdio.c</span>
<span class="p_header">index c8e945d19ffe..20142bc77554 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btsdio.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btsdio.c</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/skbuff.h&gt;
 
<span class="p_add">+#include &lt;linux/mmc/host.h&gt;</span>
 #include &lt;linux/mmc/sdio_ids.h&gt;
 #include &lt;linux/mmc/sdio_func.h&gt;
 
<span class="p_chunk">@@ -292,6 +293,14 @@</span> <span class="p_context"> static int btsdio_probe(struct sdio_func *func,</span>
 		tuple = tuple-&gt;next;
 	}
 
<span class="p_add">+	/* BCM43341 devices soldered onto the PCB (non-removable) use an</span>
<span class="p_add">+	 * uart connection for bluetooth, ignore the BT SDIO interface.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (func-&gt;vendor == SDIO_VENDOR_ID_BROADCOM &amp;&amp;</span>
<span class="p_add">+	    func-&gt;device == SDIO_DEVICE_ID_BROADCOM_43341 &amp;&amp;</span>
<span class="p_add">+	    !mmc_card_is_removable(func-&gt;card-&gt;host))</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	data = devm_kzalloc(&amp;func-&gt;dev, sizeof(*data), GFP_KERNEL);
 	if (!data)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 513a7a59d421..d54c3f6f728c 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/module.h&gt;
 #include &lt;linux/usb.h&gt;
<span class="p_add">+#include &lt;linux/usb/quirks.h&gt;</span>
 #include &lt;linux/firmware.h&gt;
 #include &lt;linux/of_device.h&gt;
 #include &lt;linux/of_irq.h&gt;
<span class="p_chunk">@@ -392,9 +393,8 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 #define BTUSB_FIRMWARE_LOADED	7
 #define BTUSB_FIRMWARE_FAILED	8
 #define BTUSB_BOOTING		9
<span class="p_del">-#define BTUSB_RESET_RESUME	10</span>
<span class="p_del">-#define BTUSB_DIAG_RUNNING	11</span>
<span class="p_del">-#define BTUSB_OOB_WAKE_ENABLED	12</span>
<span class="p_add">+#define BTUSB_DIAG_RUNNING	10</span>
<span class="p_add">+#define BTUSB_OOB_WAKE_ENABLED	11</span>
 
 struct btusb_data {
 	struct hci_dev       *hdev;
<span class="p_chunk">@@ -3102,9 +3102,9 @@</span> <span class="p_context"> static int btusb_probe(struct usb_interface *intf,</span>
 
 		/* QCA Rome devices lose their updated firmware over suspend,
 		 * but the USB hub doesn&#39;t notice any status change.
<span class="p_del">-		 * Explicitly request a device reset on resume.</span>
<span class="p_add">+		 * explicitly request a device reset on resume.</span>
 		 */
<span class="p_del">-		set_bit(BTUSB_RESET_RESUME, &amp;data-&gt;flags);</span>
<span class="p_add">+		interface_to_usbdev(intf)-&gt;quirks |= USB_QUIRK_RESET_RESUME;</span>
 	}
 
 #ifdef CONFIG_BT_HCIBTUSB_RTL
<span class="p_chunk">@@ -3115,7 +3115,7 @@</span> <span class="p_context"> static int btusb_probe(struct usb_interface *intf,</span>
 		 * but the USB hub doesn&#39;t notice any status change.
 		 * Explicitly request a device reset on resume.
 		 */
<span class="p_del">-		set_bit(BTUSB_RESET_RESUME, &amp;data-&gt;flags);</span>
<span class="p_add">+		interface_to_usbdev(intf)-&gt;quirks |= USB_QUIRK_RESET_RESUME;</span>
 	}
 #endif
 
<span class="p_chunk">@@ -3280,14 +3280,6 @@</span> <span class="p_context"> static int btusb_suspend(struct usb_interface *intf, pm_message_t message)</span>
 		enable_irq(data-&gt;oob_wake_irq);
 	}
 
<span class="p_del">-	/* Optionally request a device reset on resume, but only when</span>
<span class="p_del">-	 * wakeups are disabled. If wakeups are enabled we assume the</span>
<span class="p_del">-	 * device will stay powered up throughout suspend.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (test_bit(BTUSB_RESET_RESUME, &amp;data-&gt;flags) &amp;&amp;</span>
<span class="p_del">-	    !device_may_wakeup(&amp;data-&gt;udev-&gt;dev))</span>
<span class="p_del">-		data-&gt;udev-&gt;reset_resume = 1;</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/char/ipmi/ipmi_dmi.c b/drivers/char/ipmi/ipmi_dmi.c</span>
<span class="p_header">index 2059f79d669a..c3a23ec3e76f 100644</span>
<span class="p_header">--- a/drivers/char/ipmi/ipmi_dmi.c</span>
<span class="p_header">+++ b/drivers/char/ipmi/ipmi_dmi.c</span>
<span class="p_chunk">@@ -81,7 +81,10 @@</span> <span class="p_context"> static void __init dmi_add_platform_ipmi(unsigned long base_addr,</span>
 		pr_err(&quot;ipmi:dmi: Error allocation IPMI platform device&quot;);
 		return;
 	}
<span class="p_del">-	pdev-&gt;driver_override = override;</span>
<span class="p_add">+	pdev-&gt;driver_override = kasprintf(GFP_KERNEL, &quot;%s&quot;,</span>
<span class="p_add">+					  override);</span>
<span class="p_add">+	if (!pdev-&gt;driver_override)</span>
<span class="p_add">+		goto err;</span>
 
 	if (type == IPMI_DMI_TYPE_SSIF)
 		goto add_properties;
<span class="p_header">diff --git a/drivers/clocksource/timer-stm32.c b/drivers/clocksource/timer-stm32.c</span>
<span class="p_header">index 8f2423789ba9..4bfeb9929ab2 100644</span>
<span class="p_header">--- a/drivers/clocksource/timer-stm32.c</span>
<span class="p_header">+++ b/drivers/clocksource/timer-stm32.c</span>
<span class="p_chunk">@@ -106,6 +106,10 @@</span> <span class="p_context"> static int __init stm32_clockevent_init(struct device_node *np)</span>
 	unsigned long rate, max_delta;
 	int irq, ret, bits, prescaler = 1;
 
<span class="p_add">+	data = kmemdup(&amp;clock_event_ddata, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	if (!data)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	clk = of_clk_get(np, 0);
 	if (IS_ERR(clk)) {
 		ret = PTR_ERR(clk);
<span class="p_chunk">@@ -156,8 +160,8 @@</span> <span class="p_context"> static int __init stm32_clockevent_init(struct device_node *np)</span>
 
 	writel_relaxed(prescaler - 1, data-&gt;base + TIM_PSC);
 	writel_relaxed(TIM_EGR_UG, data-&gt;base + TIM_EGR);
<span class="p_del">-	writel_relaxed(TIM_DIER_UIE, data-&gt;base + TIM_DIER);</span>
 	writel_relaxed(0, data-&gt;base + TIM_SR);
<span class="p_add">+	writel_relaxed(TIM_DIER_UIE, data-&gt;base + TIM_DIER);</span>
 
 	data-&gt;periodic_top = DIV_ROUND_CLOSEST(rate, prescaler * HZ);
 
<span class="p_chunk">@@ -184,6 +188,7 @@</span> <span class="p_context"> static int __init stm32_clockevent_init(struct device_node *np)</span>
 err_clk_enable:
 	clk_put(clk);
 err_clk_get:
<span class="p_add">+	kfree(data);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/cpufreq/cpufreq-dt-platdev.c b/drivers/cpufreq/cpufreq-dt-platdev.c</span>
<span class="p_header">index a753c50e9e41..9e0aa767bbbe 100644</span>
<span class="p_header">--- a/drivers/cpufreq/cpufreq-dt-platdev.c</span>
<span class="p_header">+++ b/drivers/cpufreq/cpufreq-dt-platdev.c</span>
<span class="p_chunk">@@ -111,6 +111,14 @@</span> <span class="p_context"> static const struct of_device_id blacklist[] __initconst = {</span>
 
 	{ .compatible = &quot;marvell,armadaxp&quot;, },
 
<span class="p_add">+	{ .compatible = &quot;mediatek,mt2701&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt2712&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt7622&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt7623&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt817x&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8173&quot;, },</span>
<span class="p_add">+	{ .compatible = &quot;mediatek,mt8176&quot;, },</span>
<span class="p_add">+</span>
 	{ .compatible = &quot;nvidia,tegra124&quot;, },
 
 	{ .compatible = &quot;st,stih407&quot;, },
<span class="p_header">diff --git a/drivers/crypto/bfin_crc.c b/drivers/crypto/bfin_crc.c</span>
<span class="p_header">index a118b9bed669..bfbf8bf77f03 100644</span>
<span class="p_header">--- a/drivers/crypto/bfin_crc.c</span>
<span class="p_header">+++ b/drivers/crypto/bfin_crc.c</span>
<span class="p_chunk">@@ -494,7 +494,8 @@</span> <span class="p_context"> static struct ahash_alg algs = {</span>
 		.cra_driver_name	= DRIVER_NAME,
 		.cra_priority		= 100,
 		.cra_flags		= CRYPTO_ALG_TYPE_AHASH |
<span class="p_del">-						CRYPTO_ALG_ASYNC,</span>
<span class="p_add">+						CRYPTO_ALG_ASYNC |</span>
<span class="p_add">+						CRYPTO_ALG_OPTIONAL_KEY,</span>
 		.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(struct bfin_crypto_crc_ctx),
 		.cra_alignmask		= 3,
<span class="p_header">diff --git a/drivers/crypto/caam/ctrl.c b/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">index 027e121c6f70..e1d4ae1153c4 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/ctrl.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/ctrl.c</span>
<span class="p_chunk">@@ -228,12 +228,16 @@</span> <span class="p_context"> static int instantiate_rng(struct device *ctrldev, int state_handle_mask,</span>
 		 * without any error (HW optimizations for later
 		 * CAAM eras), then try again.
 		 */
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		rdsta_val = rd_reg32(&amp;ctrl-&gt;r4tst[0].rdsta) &amp; RDSTA_IFMASK;
 		if ((status &amp;&amp; status != JRSTA_SSRC_JUMP_HALT_CC) ||
<span class="p_del">-		    !(rdsta_val &amp; (1 &lt;&lt; sh_idx)))</span>
<span class="p_add">+		    !(rdsta_val &amp; (1 &lt;&lt; sh_idx))) {</span>
 			ret = -EAGAIN;
<span class="p_del">-		if (ret)</span>
 			break;
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		dev_info(ctrldev, &quot;Instantiated RNG4 SH%d\n&quot;, sh_idx);
 		/* Clear the contents before recreating the descriptor */
 		memset(desc, 0x00, CAAM_CMD_SZ * 7);
<span class="p_header">diff --git a/drivers/crypto/stm32/stm32_crc32.c b/drivers/crypto/stm32/stm32_crc32.c</span>
<span class="p_header">index 090582baecfe..8f09b8430893 100644</span>
<span class="p_header">--- a/drivers/crypto/stm32/stm32_crc32.c</span>
<span class="p_header">+++ b/drivers/crypto/stm32/stm32_crc32.c</span>
<span class="p_chunk">@@ -208,6 +208,7 @@</span> <span class="p_context"> static struct shash_alg algs[] = {</span>
 			.cra_name               = &quot;crc32&quot;,
 			.cra_driver_name        = DRIVER_NAME,
 			.cra_priority           = 200,
<span class="p_add">+			.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 			.cra_blocksize          = CHKSUM_BLOCK_SIZE,
 			.cra_alignmask          = 3,
 			.cra_ctxsize            = sizeof(struct stm32_crc_ctx),
<span class="p_chunk">@@ -229,6 +230,7 @@</span> <span class="p_context"> static struct shash_alg algs[] = {</span>
 			.cra_name               = &quot;crc32c&quot;,
 			.cra_driver_name        = DRIVER_NAME,
 			.cra_priority           = 200,
<span class="p_add">+			.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 			.cra_blocksize          = CHKSUM_BLOCK_SIZE,
 			.cra_alignmask          = 3,
 			.cra_ctxsize            = sizeof(struct stm32_crc_ctx),
<span class="p_header">diff --git a/drivers/dma/dmatest.c b/drivers/dma/dmatest.c</span>
<span class="p_header">index ec5f9d2bc820..80cc2be6483c 100644</span>
<span class="p_header">--- a/drivers/dma/dmatest.c</span>
<span class="p_header">+++ b/drivers/dma/dmatest.c</span>
<span class="p_chunk">@@ -355,7 +355,7 @@</span> <span class="p_context"> static void dmatest_callback(void *arg)</span>
 {
 	struct dmatest_done *done = arg;
 	struct dmatest_thread *thread =
<span class="p_del">-		container_of(arg, struct dmatest_thread, done_wait);</span>
<span class="p_add">+		container_of(done, struct dmatest_thread, test_done);</span>
 	if (!thread-&gt;done) {
 		done-&gt;done = true;
 		wake_up_all(done-&gt;wait);
<span class="p_header">diff --git a/drivers/edac/octeon_edac-lmc.c b/drivers/edac/octeon_edac-lmc.c</span>
<span class="p_header">index 9c1ffe3e912b..aeb222ca3ed1 100644</span>
<span class="p_header">--- a/drivers/edac/octeon_edac-lmc.c</span>
<span class="p_header">+++ b/drivers/edac/octeon_edac-lmc.c</span>
<span class="p_chunk">@@ -78,6 +78,7 @@</span> <span class="p_context"> static void octeon_lmc_edac_poll_o2(struct mem_ctl_info *mci)</span>
 	if (!pvt-&gt;inject)
 		int_reg.u64 = cvmx_read_csr(CVMX_LMCX_INT(mci-&gt;mc_idx));
 	else {
<span class="p_add">+		int_reg.u64 = 0;</span>
 		if (pvt-&gt;error_type == 1)
 			int_reg.s.sec_err = 1;
 		if (pvt-&gt;error_type == 2)
<span class="p_header">diff --git a/drivers/firmware/psci.c b/drivers/firmware/psci.c</span>
<span class="p_header">index d687ca3d5049..c80ec1d03274 100644</span>
<span class="p_header">--- a/drivers/firmware/psci.c</span>
<span class="p_header">+++ b/drivers/firmware/psci.c</span>
<span class="p_chunk">@@ -59,7 +59,10 @@</span> <span class="p_context"> bool psci_tos_resident_on(int cpu)</span>
 	return cpu == resident_cpu;
 }
 
<span class="p_del">-struct psci_operations psci_ops;</span>
<span class="p_add">+struct psci_operations psci_ops = {</span>
<span class="p_add">+	.conduit = PSCI_CONDUIT_NONE,</span>
<span class="p_add">+	.smccc_version = SMCCC_VERSION_1_0,</span>
<span class="p_add">+};</span>
 
 typedef unsigned long (psci_fn)(unsigned long, unsigned long,
 				unsigned long, unsigned long);
<span class="p_chunk">@@ -210,6 +213,22 @@</span> <span class="p_context"> static unsigned long psci_migrate_info_up_cpu(void)</span>
 			      0, 0, 0);
 }
 
<span class="p_add">+static void set_conduit(enum psci_conduit conduit)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (conduit) {</span>
<span class="p_add">+	case PSCI_CONDUIT_HVC:</span>
<span class="p_add">+		invoke_psci_fn = __invoke_psci_fn_hvc;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PSCI_CONDUIT_SMC:</span>
<span class="p_add">+		invoke_psci_fn = __invoke_psci_fn_smc;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		WARN(1, &quot;Unexpected PSCI conduit %d\n&quot;, conduit);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	psci_ops.conduit = conduit;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int get_set_conduit_method(struct device_node *np)
 {
 	const char *method;
<span class="p_chunk">@@ -222,9 +241,9 @@</span> <span class="p_context"> static int get_set_conduit_method(struct device_node *np)</span>
 	}
 
 	if (!strcmp(&quot;hvc&quot;, method)) {
<span class="p_del">-		invoke_psci_fn = __invoke_psci_fn_hvc;</span>
<span class="p_add">+		set_conduit(PSCI_CONDUIT_HVC);</span>
 	} else if (!strcmp(&quot;smc&quot;, method)) {
<span class="p_del">-		invoke_psci_fn = __invoke_psci_fn_smc;</span>
<span class="p_add">+		set_conduit(PSCI_CONDUIT_SMC);</span>
 	} else {
 		pr_warn(&quot;invalid \&quot;method\&quot; property: %s\n&quot;, method);
 		return -EINVAL;
<span class="p_chunk">@@ -493,9 +512,36 @@</span> <span class="p_context"> static void __init psci_init_migrate(void)</span>
 	pr_info(&quot;Trusted OS resident on physical CPU 0x%lx\n&quot;, cpuid);
 }
 
<span class="p_add">+static void __init psci_init_smccc(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 ver = ARM_SMCCC_VERSION_1_0;</span>
<span class="p_add">+	int feature;</span>
<span class="p_add">+</span>
<span class="p_add">+	feature = psci_features(ARM_SMCCC_VERSION_FUNC_ID);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (feature != PSCI_RET_NOT_SUPPORTED) {</span>
<span class="p_add">+		u32 ret;</span>
<span class="p_add">+		ret = invoke_psci_fn(ARM_SMCCC_VERSION_FUNC_ID, 0, 0, 0);</span>
<span class="p_add">+		if (ret == ARM_SMCCC_VERSION_1_1) {</span>
<span class="p_add">+			psci_ops.smccc_version = SMCCC_VERSION_1_1;</span>
<span class="p_add">+			ver = ret;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Conveniently, the SMCCC and PSCI versions are encoded the</span>
<span class="p_add">+	 * same way. No, this isn&#39;t accidental.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pr_info(&quot;SMC Calling Convention v%d.%d\n&quot;,</span>
<span class="p_add">+		PSCI_VERSION_MAJOR(ver), PSCI_VERSION_MINOR(ver));</span>
<span class="p_add">+</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void __init psci_0_2_set_functions(void)
 {
 	pr_info(&quot;Using standard PSCI v0.2 function IDs\n&quot;);
<span class="p_add">+	psci_ops.get_version = psci_get_version;</span>
<span class="p_add">+</span>
 	psci_function_id[PSCI_FN_CPU_SUSPEND] =
 					PSCI_FN_NATIVE(0_2, CPU_SUSPEND);
 	psci_ops.cpu_suspend = psci_cpu_suspend;
<span class="p_chunk">@@ -539,6 +585,7 @@</span> <span class="p_context"> static int __init psci_probe(void)</span>
 	psci_init_migrate();
 
 	if (PSCI_VERSION_MAJOR(ver) &gt;= 1) {
<span class="p_add">+		psci_init_smccc();</span>
 		psci_init_cpu_suspend();
 		psci_init_system_suspend();
 	}
<span class="p_chunk">@@ -652,9 +699,9 @@</span> <span class="p_context"> int __init psci_acpi_init(void)</span>
 	pr_info(&quot;probing for conduit method from ACPI.\n&quot;);
 
 	if (acpi_psci_use_hvc())
<span class="p_del">-		invoke_psci_fn = __invoke_psci_fn_hvc;</span>
<span class="p_add">+		set_conduit(PSCI_CONDUIT_HVC);</span>
 	else
<span class="p_del">-		invoke_psci_fn = __invoke_psci_fn_smc;</span>
<span class="p_add">+		set_conduit(PSCI_CONDUIT_SMC);</span>
 
 	return psci_probe();
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index 095a2240af4f..46485692db48 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -1211,23 +1211,6 @@</span> <span class="p_context"> void assert_panel_unlocked(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 	     pipe_name(pipe));
 }
 
<span class="p_del">-static void assert_cursor(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-			  enum pipe pipe, bool state)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool cur_state;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (IS_I845G(dev_priv) || IS_I865G(dev_priv))</span>
<span class="p_del">-		cur_state = I915_READ(CURCNTR(PIPE_A)) &amp; CURSOR_ENABLE;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		cur_state = I915_READ(CURCNTR(pipe)) &amp; CURSOR_MODE;</span>
<span class="p_del">-</span>
<span class="p_del">-	I915_STATE_WARN(cur_state != state,</span>
<span class="p_del">-	     &quot;cursor on pipe %c assertion failure (expected %s, current %s)\n&quot;,</span>
<span class="p_del">-			pipe_name(pipe), onoff(state), onoff(cur_state));</span>
<span class="p_del">-}</span>
<span class="p_del">-#define assert_cursor_enabled(d, p) assert_cursor(d, p, true)</span>
<span class="p_del">-#define assert_cursor_disabled(d, p) assert_cursor(d, p, false)</span>
<span class="p_del">-</span>
 void assert_pipe(struct drm_i915_private *dev_priv,
 		 enum pipe pipe, bool state)
 {
<span class="p_chunk">@@ -1255,77 +1238,25 @@</span> <span class="p_context"> void assert_pipe(struct drm_i915_private *dev_priv,</span>
 			pipe_name(pipe), onoff(state), onoff(cur_state));
 }
 
<span class="p_del">-static void assert_plane(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-			 enum plane plane, bool state)</span>
<span class="p_add">+static void assert_plane(struct intel_plane *plane, bool state)</span>
 {
<span class="p_del">-	u32 val;</span>
<span class="p_del">-	bool cur_state;</span>
<span class="p_add">+	bool cur_state = plane-&gt;get_hw_state(plane);</span>
 
<span class="p_del">-	val = I915_READ(DSPCNTR(plane));</span>
<span class="p_del">-	cur_state = !!(val &amp; DISPLAY_PLANE_ENABLE);</span>
 	I915_STATE_WARN(cur_state != state,
<span class="p_del">-	     &quot;plane %c assertion failure (expected %s, current %s)\n&quot;,</span>
<span class="p_del">-			plane_name(plane), onoff(state), onoff(cur_state));</span>
<span class="p_add">+			&quot;%s assertion failure (expected %s, current %s)\n&quot;,</span>
<span class="p_add">+			plane-&gt;base.name, onoff(state), onoff(cur_state));</span>
 }
 
<span class="p_del">-#define assert_plane_enabled(d, p) assert_plane(d, p, true)</span>
<span class="p_del">-#define assert_plane_disabled(d, p) assert_plane(d, p, false)</span>
<span class="p_add">+#define assert_plane_enabled(p) assert_plane(p, true)</span>
<span class="p_add">+#define assert_plane_disabled(p) assert_plane(p, false)</span>
 
<span class="p_del">-static void assert_planes_disabled(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-				   enum pipe pipe)</span>
<span class="p_add">+static void assert_planes_disabled(struct intel_crtc *crtc)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Primary planes are fixed to pipes on gen4+ */</span>
<span class="p_del">-	if (INTEL_GEN(dev_priv) &gt;= 4) {</span>
<span class="p_del">-		u32 val = I915_READ(DSPCNTR(pipe));</span>
<span class="p_del">-		I915_STATE_WARN(val &amp; DISPLAY_PLANE_ENABLE,</span>
<span class="p_del">-		     &quot;plane %c assertion failure, should be disabled but not\n&quot;,</span>
<span class="p_del">-		     plane_name(pipe));</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Need to check both planes against the pipe */</span>
<span class="p_del">-	for_each_pipe(dev_priv, i) {</span>
<span class="p_del">-		u32 val = I915_READ(DSPCNTR(i));</span>
<span class="p_del">-		enum pipe cur_pipe = (val &amp; DISPPLANE_SEL_PIPE_MASK) &gt;&gt;</span>
<span class="p_del">-			DISPPLANE_SEL_PIPE_SHIFT;</span>
<span class="p_del">-		I915_STATE_WARN((val &amp; DISPLAY_PLANE_ENABLE) &amp;&amp; pipe == cur_pipe,</span>
<span class="p_del">-		     &quot;plane %c assertion failure, should be off on pipe %c but is still active\n&quot;,</span>
<span class="p_del">-		     plane_name(i), pipe_name(pipe));</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void assert_sprites_disabled(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-				    enum pipe pipe)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int sprite;</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(crtc-&gt;base.dev);</span>
<span class="p_add">+	struct intel_plane *plane;</span>
 
<span class="p_del">-	if (INTEL_GEN(dev_priv) &gt;= 9) {</span>
<span class="p_del">-		for_each_sprite(dev_priv, pipe, sprite) {</span>
<span class="p_del">-			u32 val = I915_READ(PLANE_CTL(pipe, sprite));</span>
<span class="p_del">-			I915_STATE_WARN(val &amp; PLANE_CTL_ENABLE,</span>
<span class="p_del">-			     &quot;plane %d assertion failure, should be off on pipe %c but is still active\n&quot;,</span>
<span class="p_del">-			     sprite, pipe_name(pipe));</span>
<span class="p_del">-		}</span>
<span class="p_del">-	} else if (IS_VALLEYVIEW(dev_priv) || IS_CHERRYVIEW(dev_priv)) {</span>
<span class="p_del">-		for_each_sprite(dev_priv, pipe, sprite) {</span>
<span class="p_del">-			u32 val = I915_READ(SPCNTR(pipe, PLANE_SPRITE0 + sprite));</span>
<span class="p_del">-			I915_STATE_WARN(val &amp; SP_ENABLE,</span>
<span class="p_del">-			     &quot;sprite %c assertion failure, should be off on pipe %c but is still active\n&quot;,</span>
<span class="p_del">-			     sprite_name(pipe, sprite), pipe_name(pipe));</span>
<span class="p_del">-		}</span>
<span class="p_del">-	} else if (INTEL_GEN(dev_priv) &gt;= 7) {</span>
<span class="p_del">-		u32 val = I915_READ(SPRCTL(pipe));</span>
<span class="p_del">-		I915_STATE_WARN(val &amp; SPRITE_ENABLE,</span>
<span class="p_del">-		     &quot;sprite %c assertion failure, should be off on pipe %c but is still active\n&quot;,</span>
<span class="p_del">-		     plane_name(pipe), pipe_name(pipe));</span>
<span class="p_del">-	} else if (INTEL_GEN(dev_priv) &gt;= 5 || IS_G4X(dev_priv)) {</span>
<span class="p_del">-		u32 val = I915_READ(DVSCNTR(pipe));</span>
<span class="p_del">-		I915_STATE_WARN(val &amp; DVS_ENABLE,</span>
<span class="p_del">-		     &quot;sprite %c assertion failure, should be off on pipe %c but is still active\n&quot;,</span>
<span class="p_del">-		     plane_name(pipe), pipe_name(pipe));</span>
<span class="p_del">-	}</span>
<span class="p_add">+	for_each_intel_plane_on_crtc(&amp;dev_priv-&gt;drm, crtc, plane)</span>
<span class="p_add">+		assert_plane_disabled(plane);</span>
 }
 
 static void assert_vblank_disabled(struct drm_crtc *crtc)
<span class="p_chunk">@@ -1926,9 +1857,7 @@</span> <span class="p_context"> static void intel_enable_pipe(struct intel_crtc *crtc)</span>
 
 	DRM_DEBUG_KMS(&quot;enabling pipe %c\n&quot;, pipe_name(pipe));
 
<span class="p_del">-	assert_planes_disabled(dev_priv, pipe);</span>
<span class="p_del">-	assert_cursor_disabled(dev_priv, pipe);</span>
<span class="p_del">-	assert_sprites_disabled(dev_priv, pipe);</span>
<span class="p_add">+	assert_planes_disabled(crtc);</span>
 
 	/*
 	 * A pipe without a PLL won&#39;t actually be able to drive bits from
<span class="p_chunk">@@ -1997,9 +1926,7 @@</span> <span class="p_context"> static void intel_disable_pipe(struct intel_crtc *crtc)</span>
 	 * Make sure planes won&#39;t keep trying to pump pixels to us,
 	 * or we might hang the display.
 	 */
<span class="p_del">-	assert_planes_disabled(dev_priv, pipe);</span>
<span class="p_del">-	assert_cursor_disabled(dev_priv, pipe);</span>
<span class="p_del">-	assert_sprites_disabled(dev_priv, pipe);</span>
<span class="p_add">+	assert_planes_disabled(crtc);</span>
 
 	reg = PIPECONF(cpu_transcoder);
 	val = I915_READ(reg);
<span class="p_chunk">@@ -2829,6 +2756,23 @@</span> <span class="p_context"> intel_set_plane_visible(struct intel_crtc_state *crtc_state,</span>
 		      crtc_state-&gt;active_planes);
 }
 
<span class="p_add">+static void intel_plane_disable_noatomic(struct intel_crtc *crtc,</span>
<span class="p_add">+					 struct intel_plane *plane)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_crtc_state *crtc_state =</span>
<span class="p_add">+		to_intel_crtc_state(crtc-&gt;base.state);</span>
<span class="p_add">+	struct intel_plane_state *plane_state =</span>
<span class="p_add">+		to_intel_plane_state(plane-&gt;base.state);</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_set_plane_visible(crtc_state, plane_state, false);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (plane-&gt;id == PLANE_PRIMARY)</span>
<span class="p_add">+		intel_pre_disable_primary_noatomic(&amp;crtc-&gt;base);</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_intel_disable_plane(&amp;plane-&gt;base, crtc);</span>
<span class="p_add">+	plane-&gt;disable_plane(plane, crtc);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void
 intel_find_initial_plane_obj(struct intel_crtc *intel_crtc,
 			     struct intel_initial_plane_config *plane_config)
<span class="p_chunk">@@ -2886,12 +2830,7 @@</span> <span class="p_context"> intel_find_initial_plane_obj(struct intel_crtc *intel_crtc,</span>
 	 * simplest solution is to just disable the primary plane now and
 	 * pretend the BIOS never had it enabled.
 	 */
<span class="p_del">-	intel_set_plane_visible(to_intel_crtc_state(crtc_state),</span>
<span class="p_del">-				to_intel_plane_state(plane_state),</span>
<span class="p_del">-				false);</span>
<span class="p_del">-	intel_pre_disable_primary_noatomic(&amp;intel_crtc-&gt;base);</span>
<span class="p_del">-	trace_intel_disable_plane(primary, intel_crtc);</span>
<span class="p_del">-	intel_plane-&gt;disable_plane(intel_plane, intel_crtc);</span>
<span class="p_add">+	intel_plane_disable_noatomic(intel_crtc, intel_plane);</span>
 
 	return;
 
<span class="p_chunk">@@ -3397,6 +3336,31 @@</span> <span class="p_context"> static void i9xx_disable_primary_plane(struct intel_plane *primary,</span>
 	spin_unlock_irqrestore(&amp;dev_priv-&gt;uncore.lock, irqflags);
 }
 
<span class="p_add">+static bool i9xx_plane_get_hw_state(struct intel_plane *primary)</span>
<span class="p_add">+{</span>
<span class="p_add">+</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(primary-&gt;base.dev);</span>
<span class="p_add">+	enum intel_display_power_domain power_domain;</span>
<span class="p_add">+	enum plane plane = primary-&gt;plane;</span>
<span class="p_add">+	enum pipe pipe = primary-&gt;pipe;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Not 100% correct for planes that can move between pipes,</span>
<span class="p_add">+	 * but that&#39;s only the case for gen2-4 which don&#39;t have any</span>
<span class="p_add">+	 * display power wells.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	power_domain = POWER_DOMAIN_PIPE(pipe);</span>
<span class="p_add">+	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = I915_READ(DSPCNTR(plane)) &amp; DISPLAY_PLANE_ENABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_display_power_put(dev_priv, power_domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32
 intel_fb_stride_alignment(const struct drm_framebuffer *fb, int plane)
 {
<span class="p_chunk">@@ -4973,7 +4937,8 @@</span> <span class="p_context"> void hsw_enable_ips(struct intel_crtc *crtc)</span>
 	 * a vblank wait.
 	 */
 
<span class="p_del">-	assert_plane_enabled(dev_priv, crtc-&gt;plane);</span>
<span class="p_add">+	assert_plane_enabled(to_intel_plane(crtc-&gt;base.primary));</span>
<span class="p_add">+</span>
 	if (IS_BROADWELL(dev_priv)) {
 		mutex_lock(&amp;dev_priv-&gt;rps.hw_lock);
 		WARN_ON(sandybridge_pcode_write(dev_priv, DISPLAY_IPS_CONTROL, 0xc0000000));
<span class="p_chunk">@@ -5005,7 +4970,8 @@</span> <span class="p_context"> void hsw_disable_ips(struct intel_crtc *crtc)</span>
 	if (!crtc-&gt;config-&gt;ips_enabled)
 		return;
 
<span class="p_del">-	assert_plane_enabled(dev_priv, crtc-&gt;plane);</span>
<span class="p_add">+	assert_plane_enabled(to_intel_plane(crtc-&gt;base.primary));</span>
<span class="p_add">+</span>
 	if (IS_BROADWELL(dev_priv)) {
 		mutex_lock(&amp;dev_priv-&gt;rps.hw_lock);
 		WARN_ON(sandybridge_pcode_write(dev_priv, DISPLAY_IPS_CONTROL, 0));
<span class="p_chunk">@@ -6000,6 +5966,7 @@</span> <span class="p_context"> static void intel_crtc_disable_noatomic(struct drm_crtc *crtc,</span>
 	struct intel_crtc *intel_crtc = to_intel_crtc(crtc);
 	struct drm_i915_private *dev_priv = to_i915(crtc-&gt;dev);
 	enum intel_display_power_domain domain;
<span class="p_add">+	struct intel_plane *plane;</span>
 	u64 domains;
 	struct drm_atomic_state *state;
 	struct intel_crtc_state *crtc_state;
<span class="p_chunk">@@ -6008,11 +5975,12 @@</span> <span class="p_context"> static void intel_crtc_disable_noatomic(struct drm_crtc *crtc,</span>
 	if (!intel_crtc-&gt;active)
 		return;
 
<span class="p_del">-	if (crtc-&gt;primary-&gt;state-&gt;visible) {</span>
<span class="p_del">-		intel_pre_disable_primary_noatomic(crtc);</span>
<span class="p_add">+	for_each_intel_plane_on_crtc(&amp;dev_priv-&gt;drm, intel_crtc, plane) {</span>
<span class="p_add">+		const struct intel_plane_state *plane_state =</span>
<span class="p_add">+			to_intel_plane_state(plane-&gt;base.state);</span>
 
<span class="p_del">-		intel_crtc_disable_planes(crtc, 1 &lt;&lt; drm_plane_index(crtc-&gt;primary));</span>
<span class="p_del">-		crtc-&gt;primary-&gt;state-&gt;visible = false;</span>
<span class="p_add">+		if (plane_state-&gt;base.visible)</span>
<span class="p_add">+			intel_plane_disable_noatomic(intel_crtc, plane);</span>
 	}
 
 	state = drm_atomic_state_alloc(crtc-&gt;dev);
<span class="p_chunk">@@ -9577,6 +9545,23 @@</span> <span class="p_context"> static void i845_disable_cursor(struct intel_plane *plane,</span>
 	i845_update_cursor(plane, NULL, NULL);
 }
 
<span class="p_add">+static bool i845_cursor_get_hw_state(struct intel_plane *plane)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(plane-&gt;base.dev);</span>
<span class="p_add">+	enum intel_display_power_domain power_domain;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	power_domain = POWER_DOMAIN_PIPE(PIPE_A);</span>
<span class="p_add">+	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = I915_READ(CURCNTR(PIPE_A)) &amp; CURSOR_ENABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_display_power_put(dev_priv, power_domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32 i9xx_cursor_ctl(const struct intel_crtc_state *crtc_state,
 			   const struct intel_plane_state *plane_state)
 {
<span class="p_chunk">@@ -9770,6 +9755,28 @@</span> <span class="p_context"> static void i9xx_disable_cursor(struct intel_plane *plane,</span>
 	i9xx_update_cursor(plane, NULL, NULL);
 }
 
<span class="p_add">+static bool i9xx_cursor_get_hw_state(struct intel_plane *plane)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(plane-&gt;base.dev);</span>
<span class="p_add">+	enum intel_display_power_domain power_domain;</span>
<span class="p_add">+	enum pipe pipe = plane-&gt;pipe;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Not 100% correct for planes that can move between pipes,</span>
<span class="p_add">+	 * but that&#39;s only the case for gen2-3 which don&#39;t have any</span>
<span class="p_add">+	 * display power wells.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	power_domain = POWER_DOMAIN_PIPE(pipe);</span>
<span class="p_add">+	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = I915_READ(CURCNTR(pipe)) &amp; CURSOR_MODE;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_display_power_put(dev_priv, power_domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 
 /* VESA 640x480x72Hz mode to set on the pipe */
 static struct drm_display_mode load_detect_mode = {
<span class="p_chunk">@@ -13240,6 +13247,7 @@</span> <span class="p_context"> intel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 
 		primary-&gt;update_plane = skylake_update_primary_plane;
 		primary-&gt;disable_plane = skylake_disable_primary_plane;
<span class="p_add">+		primary-&gt;get_hw_state = skl_plane_get_hw_state;</span>
 	} else if (INTEL_GEN(dev_priv) &gt;= 9) {
 		intel_primary_formats = skl_primary_formats;
 		num_formats = ARRAY_SIZE(skl_primary_formats);
<span class="p_chunk">@@ -13250,6 +13258,7 @@</span> <span class="p_context"> intel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 
 		primary-&gt;update_plane = skylake_update_primary_plane;
 		primary-&gt;disable_plane = skylake_disable_primary_plane;
<span class="p_add">+		primary-&gt;get_hw_state = skl_plane_get_hw_state;</span>
 	} else if (INTEL_GEN(dev_priv) &gt;= 4) {
 		intel_primary_formats = i965_primary_formats;
 		num_formats = ARRAY_SIZE(i965_primary_formats);
<span class="p_chunk">@@ -13257,6 +13266,7 @@</span> <span class="p_context"> intel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 
 		primary-&gt;update_plane = i9xx_update_primary_plane;
 		primary-&gt;disable_plane = i9xx_disable_primary_plane;
<span class="p_add">+		primary-&gt;get_hw_state = i9xx_plane_get_hw_state;</span>
 	} else {
 		intel_primary_formats = i8xx_primary_formats;
 		num_formats = ARRAY_SIZE(i8xx_primary_formats);
<span class="p_chunk">@@ -13264,6 +13274,7 @@</span> <span class="p_context"> intel_primary_plane_create(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 
 		primary-&gt;update_plane = i9xx_update_primary_plane;
 		primary-&gt;disable_plane = i9xx_disable_primary_plane;
<span class="p_add">+		primary-&gt;get_hw_state = i9xx_plane_get_hw_state;</span>
 	}
 
 	if (INTEL_GEN(dev_priv) &gt;= 9)
<span class="p_chunk">@@ -13353,10 +13364,12 @@</span> <span class="p_context"> intel_cursor_plane_create(struct drm_i915_private *dev_priv,</span>
 	if (IS_I845G(dev_priv) || IS_I865G(dev_priv)) {
 		cursor-&gt;update_plane = i845_update_cursor;
 		cursor-&gt;disable_plane = i845_disable_cursor;
<span class="p_add">+		cursor-&gt;get_hw_state = i845_cursor_get_hw_state;</span>
 		cursor-&gt;check_plane = i845_check_cursor;
 	} else {
 		cursor-&gt;update_plane = i9xx_update_cursor;
 		cursor-&gt;disable_plane = i9xx_disable_cursor;
<span class="p_add">+		cursor-&gt;get_hw_state = i9xx_cursor_get_hw_state;</span>
 		cursor-&gt;check_plane = i9xx_check_cursor;
 	}
 
<span class="p_chunk">@@ -14704,8 +14717,11 @@</span> <span class="p_context"> void i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 	DRM_DEBUG_KMS(&quot;disabling pipe %c due to force quirk\n&quot;,
 		      pipe_name(pipe));
 
<span class="p_del">-	assert_plane_disabled(dev_priv, PLANE_A);</span>
<span class="p_del">-	assert_plane_disabled(dev_priv, PLANE_B);</span>
<span class="p_add">+	WARN_ON(I915_READ(DSPCNTR(PLANE_A)) &amp; DISPLAY_PLANE_ENABLE);</span>
<span class="p_add">+	WARN_ON(I915_READ(DSPCNTR(PLANE_B)) &amp; DISPLAY_PLANE_ENABLE);</span>
<span class="p_add">+	WARN_ON(I915_READ(DSPCNTR(PLANE_C)) &amp; DISPLAY_PLANE_ENABLE);</span>
<span class="p_add">+	WARN_ON(I915_READ(CURCNTR(PIPE_A)) &amp; CURSOR_MODE);</span>
<span class="p_add">+	WARN_ON(I915_READ(CURCNTR(PIPE_B)) &amp; CURSOR_MODE);</span>
 
 	I915_WRITE(PIPECONF(pipe), 0);
 	POSTING_READ(PIPECONF(pipe));
<span class="p_chunk">@@ -14716,22 +14732,36 @@</span> <span class="p_context"> void i830_disable_pipe(struct drm_i915_private *dev_priv, enum pipe pipe)</span>
 	POSTING_READ(DPLL(pipe));
 }
 
<span class="p_del">-static bool</span>
<span class="p_del">-intel_check_plane_mapping(struct intel_crtc *crtc)</span>
<span class="p_add">+static bool intel_plane_mapping_ok(struct intel_crtc *crtc,</span>
<span class="p_add">+				   struct intel_plane *primary)</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(crtc-&gt;base.dev);
<span class="p_del">-	u32 val;</span>
<span class="p_add">+	enum plane plane = primary-&gt;plane;</span>
<span class="p_add">+	u32 val = I915_READ(DSPCNTR(plane));</span>
 
<span class="p_del">-	if (INTEL_INFO(dev_priv)-&gt;num_pipes == 1)</span>
<span class="p_del">-		return true;</span>
<span class="p_add">+	return (val &amp; DISPLAY_PLANE_ENABLE) == 0 ||</span>
<span class="p_add">+		(val &amp; DISPPLANE_SEL_PIPE_MASK) == DISPPLANE_SEL_PIPE(crtc-&gt;pipe);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	val = I915_READ(DSPCNTR(!crtc-&gt;plane));</span>
<span class="p_add">+static void</span>
<span class="p_add">+intel_sanitize_plane_mapping(struct drm_i915_private *dev_priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_crtc *crtc;</span>
 
<span class="p_del">-	if ((val &amp; DISPLAY_PLANE_ENABLE) &amp;&amp;</span>
<span class="p_del">-	    (!!(val &amp; DISPPLANE_SEL_PIPE_MASK) == crtc-&gt;pipe))</span>
<span class="p_del">-		return false;</span>
<span class="p_add">+	if (INTEL_GEN(dev_priv) &gt;= 4)</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	return true;</span>
<span class="p_add">+	for_each_intel_crtc(&amp;dev_priv-&gt;drm, crtc) {</span>
<span class="p_add">+		struct intel_plane *plane =</span>
<span class="p_add">+			to_intel_plane(crtc-&gt;base.primary);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (intel_plane_mapping_ok(crtc, plane))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		DRM_DEBUG_KMS(&quot;%s attached to the wrong pipe, disabling plane\n&quot;,</span>
<span class="p_add">+			      plane-&gt;base.name);</span>
<span class="p_add">+		intel_plane_disable_noatomic(crtc, plane);</span>
<span class="p_add">+	}</span>
 }
 
 static bool intel_crtc_has_encoders(struct intel_crtc *crtc)
<span class="p_chunk">@@ -14787,33 +14817,15 @@</span> <span class="p_context"> static void intel_sanitize_crtc(struct intel_crtc *crtc,</span>
 
 		/* Disable everything but the primary plane */
 		for_each_intel_plane_on_crtc(dev, crtc, plane) {
<span class="p_del">-			if (plane-&gt;base.type == DRM_PLANE_TYPE_PRIMARY)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			const struct intel_plane_state *plane_state =</span>
<span class="p_add">+				to_intel_plane_state(plane-&gt;base.state);</span>
 
<span class="p_del">-			trace_intel_disable_plane(&amp;plane-&gt;base, crtc);</span>
<span class="p_del">-			plane-&gt;disable_plane(plane, crtc);</span>
<span class="p_add">+			if (plane_state-&gt;base.visible &amp;&amp;</span>
<span class="p_add">+			    plane-&gt;base.type != DRM_PLANE_TYPE_PRIMARY)</span>
<span class="p_add">+				intel_plane_disable_noatomic(crtc, plane);</span>
 		}
 	}
 
<span class="p_del">-	/* We need to sanitize the plane -&gt; pipe mapping first because this will</span>
<span class="p_del">-	 * disable the crtc (and hence change the state) if it is wrong. Note</span>
<span class="p_del">-	 * that gen4+ has a fixed plane -&gt; pipe mapping.  */</span>
<span class="p_del">-	if (INTEL_GEN(dev_priv) &lt; 4 &amp;&amp; !intel_check_plane_mapping(crtc)) {</span>
<span class="p_del">-		bool plane;</span>
<span class="p_del">-</span>
<span class="p_del">-		DRM_DEBUG_KMS(&quot;[CRTC:%d:%s] wrong plane connection detected!\n&quot;,</span>
<span class="p_del">-			      crtc-&gt;base.base.id, crtc-&gt;base.name);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Pipe has the wrong plane attached and the plane is active.</span>
<span class="p_del">-		 * Temporarily change the plane mapping and disable everything</span>
<span class="p_del">-		 * ...  */</span>
<span class="p_del">-		plane = crtc-&gt;plane;</span>
<span class="p_del">-		crtc-&gt;base.primary-&gt;state-&gt;visible = true;</span>
<span class="p_del">-		crtc-&gt;plane = !plane;</span>
<span class="p_del">-		intel_crtc_disable_noatomic(&amp;crtc-&gt;base, ctx);</span>
<span class="p_del">-		crtc-&gt;plane = plane;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* Adjust the state of the output pipe according to whether we
 	 * have active connectors/encoders. */
 	if (crtc-&gt;active &amp;&amp; !intel_crtc_has_encoders(crtc))
<span class="p_chunk">@@ -14918,24 +14930,21 @@</span> <span class="p_context"> void i915_redisable_vga(struct drm_i915_private *dev_priv)</span>
 	intel_display_power_put(dev_priv, POWER_DOMAIN_VGA);
 }
 
<span class="p_del">-static bool primary_get_hw_state(struct intel_plane *plane)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct drm_i915_private *dev_priv = to_i915(plane-&gt;base.dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	return I915_READ(DSPCNTR(plane-&gt;plane)) &amp; DISPLAY_PLANE_ENABLE;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* FIXME read out full plane state for all planes */
 static void readout_plane_state(struct intel_crtc *crtc)
 {
<span class="p_del">-	struct intel_plane *primary = to_intel_plane(crtc-&gt;base.primary);</span>
<span class="p_del">-	bool visible;</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(crtc-&gt;base.dev);</span>
<span class="p_add">+	struct intel_crtc_state *crtc_state =</span>
<span class="p_add">+		to_intel_crtc_state(crtc-&gt;base.state);</span>
<span class="p_add">+	struct intel_plane *plane;</span>
 
<span class="p_del">-	visible = crtc-&gt;active &amp;&amp; primary_get_hw_state(primary);</span>
<span class="p_add">+	for_each_intel_plane_on_crtc(&amp;dev_priv-&gt;drm, crtc, plane) {</span>
<span class="p_add">+		struct intel_plane_state *plane_state =</span>
<span class="p_add">+			to_intel_plane_state(plane-&gt;base.state);</span>
<span class="p_add">+		bool visible = plane-&gt;get_hw_state(plane);</span>
 
<span class="p_del">-	intel_set_plane_visible(to_intel_crtc_state(crtc-&gt;base.state),</span>
<span class="p_del">-				to_intel_plane_state(primary-&gt;base.state),</span>
<span class="p_del">-				visible);</span>
<span class="p_add">+		intel_set_plane_visible(crtc_state, plane_state, visible);</span>
<span class="p_add">+	}</span>
 }
 
 static void intel_modeset_readout_hw_state(struct drm_device *dev)
<span class="p_chunk">@@ -15137,6 +15146,8 @@</span> <span class="p_context"> intel_modeset_setup_hw_state(struct drm_device *dev,</span>
 	/* HW state is read out, now we need to sanitize this mess. */
 	get_encoder_power_domains(dev_priv);
 
<span class="p_add">+	intel_sanitize_plane_mapping(dev_priv);</span>
<span class="p_add">+</span>
 	for_each_intel_encoder(dev, encoder) {
 		intel_sanitize_encoder(encoder);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_dp.c b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">index 09f274419eea..76cf68745870 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_dp.c</span>
<span class="p_chunk">@@ -5340,6 +5340,12 @@</span> <span class="p_context"> intel_dp_init_panel_power_sequencer(struct drm_device *dev,</span>
 	 */
 	final-&gt;t8 = 1;
 	final-&gt;t9 = 1;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * HW has only a 100msec granularity for t11_t12 so round it up</span>
<span class="p_add">+	 * accordingly.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	final-&gt;t11_t12 = roundup(final-&gt;t11_t12, 100 * 10);</span>
 }
 
 static void
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index 79fbaf78f604..10ae9681f02d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -863,6 +863,7 @@</span> <span class="p_context"> struct intel_plane {</span>
 			     const struct intel_plane_state *plane_state);
 	void (*disable_plane)(struct intel_plane *plane,
 			      struct intel_crtc *crtc);
<span class="p_add">+	bool (*get_hw_state)(struct intel_plane *plane);</span>
 	int (*check_plane)(struct intel_plane *plane,
 			   struct intel_crtc_state *crtc_state,
 			   struct intel_plane_state *state);
<span class="p_chunk">@@ -1885,6 +1886,7 @@</span> <span class="p_context"> int intel_sprite_set_colorkey(struct drm_device *dev, void *data,</span>
 			      struct drm_file *file_priv);
 void intel_pipe_update_start(struct intel_crtc *crtc);
 void intel_pipe_update_end(struct intel_crtc *crtc);
<span class="p_add">+bool skl_plane_get_hw_state(struct intel_plane *plane);</span>
 
 /* intel_tv.c */
 void intel_tv_init(struct drm_i915_private *dev_priv);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_sprite.c b/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_header">index 524933b01483..f8ebeb5ffb96 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_sprite.c</span>
<span class="p_chunk">@@ -324,6 +324,26 @@</span> <span class="p_context"> skl_disable_plane(struct intel_plane *plane, struct intel_crtc *crtc)</span>
 	spin_unlock_irqrestore(&amp;dev_priv-&gt;uncore.lock, irqflags);
 }
 
<span class="p_add">+bool</span>
<span class="p_add">+skl_plane_get_hw_state(struct intel_plane *plane)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(plane-&gt;base.dev);</span>
<span class="p_add">+	enum intel_display_power_domain power_domain;</span>
<span class="p_add">+	enum plane_id plane_id = plane-&gt;id;</span>
<span class="p_add">+	enum pipe pipe = plane-&gt;pipe;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	power_domain = POWER_DOMAIN_PIPE(pipe);</span>
<span class="p_add">+	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = I915_READ(PLANE_CTL(pipe, plane_id)) &amp; PLANE_CTL_ENABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_display_power_put(dev_priv, power_domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void
 chv_update_csc(struct intel_plane *plane, uint32_t format)
 {
<span class="p_chunk">@@ -501,6 +521,26 @@</span> <span class="p_context"> vlv_disable_plane(struct intel_plane *plane, struct intel_crtc *crtc)</span>
 	spin_unlock_irqrestore(&amp;dev_priv-&gt;uncore.lock, irqflags);
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+vlv_plane_get_hw_state(struct intel_plane *plane)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(plane-&gt;base.dev);</span>
<span class="p_add">+	enum intel_display_power_domain power_domain;</span>
<span class="p_add">+	enum plane_id plane_id = plane-&gt;id;</span>
<span class="p_add">+	enum pipe pipe = plane-&gt;pipe;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	power_domain = POWER_DOMAIN_PIPE(pipe);</span>
<span class="p_add">+	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = I915_READ(SPCNTR(pipe, plane_id)) &amp; SP_ENABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_display_power_put(dev_priv, power_domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32 ivb_sprite_ctl(const struct intel_crtc_state *crtc_state,
 			  const struct intel_plane_state *plane_state)
 {
<span class="p_chunk">@@ -641,6 +681,25 @@</span> <span class="p_context"> ivb_disable_plane(struct intel_plane *plane, struct intel_crtc *crtc)</span>
 	spin_unlock_irqrestore(&amp;dev_priv-&gt;uncore.lock, irqflags);
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+ivb_plane_get_hw_state(struct intel_plane *plane)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(plane-&gt;base.dev);</span>
<span class="p_add">+	enum intel_display_power_domain power_domain;</span>
<span class="p_add">+	enum pipe pipe = plane-&gt;pipe;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	power_domain = POWER_DOMAIN_PIPE(pipe);</span>
<span class="p_add">+	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret =  I915_READ(SPRCTL(pipe)) &amp; SPRITE_ENABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_display_power_put(dev_priv, power_domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static u32 g4x_sprite_ctl(const struct intel_crtc_state *crtc_state,
 			  const struct intel_plane_state *plane_state)
 {
<span class="p_chunk">@@ -772,6 +831,25 @@</span> <span class="p_context"> g4x_disable_plane(struct intel_plane *plane, struct intel_crtc *crtc)</span>
 	spin_unlock_irqrestore(&amp;dev_priv-&gt;uncore.lock, irqflags);
 }
 
<span class="p_add">+static bool</span>
<span class="p_add">+g4x_plane_get_hw_state(struct intel_plane *plane)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(plane-&gt;base.dev);</span>
<span class="p_add">+	enum intel_display_power_domain power_domain;</span>
<span class="p_add">+	enum pipe pipe = plane-&gt;pipe;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	power_domain = POWER_DOMAIN_PIPE(pipe);</span>
<span class="p_add">+	if (!intel_display_power_get_if_enabled(dev_priv, power_domain))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = I915_READ(DVSCNTR(pipe)) &amp; DVS_ENABLE;</span>
<span class="p_add">+</span>
<span class="p_add">+	intel_display_power_put(dev_priv, power_domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 intel_check_sprite_plane(struct intel_plane *plane,
 			 struct intel_crtc_state *crtc_state,
<span class="p_chunk">@@ -1227,6 +1305,7 @@</span> <span class="p_context"> intel_sprite_plane_create(struct drm_i915_private *dev_priv,</span>
 
 		intel_plane-&gt;update_plane = skl_update_plane;
 		intel_plane-&gt;disable_plane = skl_disable_plane;
<span class="p_add">+		intel_plane-&gt;get_hw_state = skl_plane_get_hw_state;</span>
 
 		plane_formats = skl_plane_formats;
 		num_plane_formats = ARRAY_SIZE(skl_plane_formats);
<span class="p_chunk">@@ -1237,6 +1316,7 @@</span> <span class="p_context"> intel_sprite_plane_create(struct drm_i915_private *dev_priv,</span>
 
 		intel_plane-&gt;update_plane = skl_update_plane;
 		intel_plane-&gt;disable_plane = skl_disable_plane;
<span class="p_add">+		intel_plane-&gt;get_hw_state = skl_plane_get_hw_state;</span>
 
 		plane_formats = skl_plane_formats;
 		num_plane_formats = ARRAY_SIZE(skl_plane_formats);
<span class="p_chunk">@@ -1247,6 +1327,7 @@</span> <span class="p_context"> intel_sprite_plane_create(struct drm_i915_private *dev_priv,</span>
 
 		intel_plane-&gt;update_plane = vlv_update_plane;
 		intel_plane-&gt;disable_plane = vlv_disable_plane;
<span class="p_add">+		intel_plane-&gt;get_hw_state = vlv_plane_get_hw_state;</span>
 
 		plane_formats = vlv_plane_formats;
 		num_plane_formats = ARRAY_SIZE(vlv_plane_formats);
<span class="p_chunk">@@ -1262,6 +1343,7 @@</span> <span class="p_context"> intel_sprite_plane_create(struct drm_i915_private *dev_priv,</span>
 
 		intel_plane-&gt;update_plane = ivb_update_plane;
 		intel_plane-&gt;disable_plane = ivb_disable_plane;
<span class="p_add">+		intel_plane-&gt;get_hw_state = ivb_plane_get_hw_state;</span>
 
 		plane_formats = snb_plane_formats;
 		num_plane_formats = ARRAY_SIZE(snb_plane_formats);
<span class="p_chunk">@@ -1272,6 +1354,7 @@</span> <span class="p_context"> intel_sprite_plane_create(struct drm_i915_private *dev_priv,</span>
 
 		intel_plane-&gt;update_plane = g4x_update_plane;
 		intel_plane-&gt;disable_plane = g4x_disable_plane;
<span class="p_add">+		intel_plane-&gt;get_hw_state = g4x_plane_get_hw_state;</span>
 
 		modifiers = i9xx_plane_format_modifiers;
 		if (IS_GEN6(dev_priv)) {
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index 330ca983828b..5744eb729d24 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -2638,7 +2638,6 @@</span> <span class="p_context"> static const struct hid_device_id hid_ignore_list[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_DELORME, USB_DEVICE_ID_DELORME_EARTHMATE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_DELORME, USB_DEVICE_ID_DELORME_EM_LT20) },
 	{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, 0x0400) },
<span class="p_del">-	{ HID_I2C_DEVICE(USB_VENDOR_ID_ELAN, 0x0401) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ESSENTIAL_REALITY, USB_DEVICE_ID_ESSENTIAL_REALITY_P5) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC5UH) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ETT, USB_DEVICE_ID_TC4UM) },
<span class="p_chunk">@@ -2908,6 +2907,17 @@</span> <span class="p_context"> bool hid_ignore(struct hid_device *hdev)</span>
 			strncmp(hdev-&gt;name, &quot;www.masterkit.ru MA901&quot;, 22) == 0)
 			return true;
 		break;
<span class="p_add">+	case USB_VENDOR_ID_ELAN:</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Many Elan devices have a product id of 0x0401 and are handled</span>
<span class="p_add">+		 * by the elan_i2c input driver. But the ACPI HID ELAN0800 dev</span>
<span class="p_add">+		 * is not (and cannot be) handled by that driver -&gt;</span>
<span class="p_add">+		 * Ignore all 0x0401 devs except for the ELAN0800 dev.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (hdev-&gt;product == 0x0401 &amp;&amp;</span>
<span class="p_add">+		    strncmp(hdev-&gt;name, &quot;ELAN0800&quot;, 8) != 0)</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		break;</span>
 	}
 
 	if (hdev-&gt;type == HID_TYPE_USBMOUSE &amp;&amp;
<span class="p_header">diff --git a/drivers/media/dvb-frontends/ascot2e.c b/drivers/media/dvb-frontends/ascot2e.c</span>
<span class="p_header">index 0ee0df53b91b..79d5d89bc95e 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/ascot2e.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/ascot2e.c</span>
<span class="p_chunk">@@ -155,7 +155,9 @@</span> <span class="p_context"> static int ascot2e_write_regs(struct ascot2e_priv *priv,</span>
 
 static int ascot2e_write_reg(struct ascot2e_priv *priv, u8 reg, u8 val)
 {
<span class="p_del">-	return ascot2e_write_regs(priv, reg, &amp;val, 1);</span>
<span class="p_add">+	u8 tmp = val; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return ascot2e_write_regs(priv, reg, &amp;tmp, 1);</span>
 }
 
 static int ascot2e_read_regs(struct ascot2e_priv *priv,
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cxd2841er.c b/drivers/media/dvb-frontends/cxd2841er.c</span>
<span class="p_header">index 48ee9bc00c06..ccbd84fd6428 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cxd2841er.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cxd2841er.c</span>
<span class="p_chunk">@@ -257,7 +257,9 @@</span> <span class="p_context"> static int cxd2841er_write_regs(struct cxd2841er_priv *priv,</span>
 static int cxd2841er_write_reg(struct cxd2841er_priv *priv,
 			       u8 addr, u8 reg, u8 val)
 {
<span class="p_del">-	return cxd2841er_write_regs(priv, addr, reg, &amp;val, 1);</span>
<span class="p_add">+	u8 tmp = val; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return cxd2841er_write_regs(priv, addr, reg, &amp;tmp, 1);</span>
 }
 
 static int cxd2841er_read_regs(struct cxd2841er_priv *priv,
<span class="p_header">diff --git a/drivers/media/dvb-frontends/helene.c b/drivers/media/dvb-frontends/helene.c</span>
<span class="p_header">index 4bf5a551ba40..2ab8d83e5576 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/helene.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/helene.c</span>
<span class="p_chunk">@@ -331,7 +331,9 @@</span> <span class="p_context"> static int helene_write_regs(struct helene_priv *priv,</span>
 
 static int helene_write_reg(struct helene_priv *priv, u8 reg, u8 val)
 {
<span class="p_del">-	return helene_write_regs(priv, reg, &amp;val, 1);</span>
<span class="p_add">+	u8 tmp = val; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return helene_write_regs(priv, reg, &amp;tmp, 1);</span>
 }
 
 static int helene_read_regs(struct helene_priv *priv,
<span class="p_header">diff --git a/drivers/media/dvb-frontends/horus3a.c b/drivers/media/dvb-frontends/horus3a.c</span>
<span class="p_header">index 68d759c4c52e..5c8b405f2ddc 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/horus3a.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/horus3a.c</span>
<span class="p_chunk">@@ -89,7 +89,9 @@</span> <span class="p_context"> static int horus3a_write_regs(struct horus3a_priv *priv,</span>
 
 static int horus3a_write_reg(struct horus3a_priv *priv, u8 reg, u8 val)
 {
<span class="p_del">-	return horus3a_write_regs(priv, reg, &amp;val, 1);</span>
<span class="p_add">+	u8 tmp = val; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return horus3a_write_regs(priv, reg, &amp;tmp, 1);</span>
 }
 
 static int horus3a_enter_power_save(struct horus3a_priv *priv)
<span class="p_header">diff --git a/drivers/media/dvb-frontends/itd1000.c b/drivers/media/dvb-frontends/itd1000.c</span>
<span class="p_header">index 5bb1e73a10b4..ce7c443d3eac 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/itd1000.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/itd1000.c</span>
<span class="p_chunk">@@ -95,8 +95,9 @@</span> <span class="p_context"> static int itd1000_read_reg(struct itd1000_state *state, u8 reg)</span>
 
 static inline int itd1000_write_reg(struct itd1000_state *state, u8 r, u8 v)
 {
<span class="p_del">-	int ret = itd1000_write_regs(state, r, &amp;v, 1);</span>
<span class="p_del">-	state-&gt;shadow[r] = v;</span>
<span class="p_add">+	u8 tmp = v; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+	int ret = itd1000_write_regs(state, r, &amp;tmp, 1);</span>
<span class="p_add">+	state-&gt;shadow[r] = tmp;</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/mt312.c b/drivers/media/dvb-frontends/mt312.c</span>
<span class="p_header">index 961b9a2508e0..0b23cbc021b8 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/mt312.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/mt312.c</span>
<span class="p_chunk">@@ -142,7 +142,10 @@</span> <span class="p_context"> static inline int mt312_readreg(struct mt312_state *state,</span>
 static inline int mt312_writereg(struct mt312_state *state,
 				 const enum mt312_reg_addr reg, const u8 val)
 {
<span class="p_del">-	return mt312_write(state, reg, &amp;val, 1);</span>
<span class="p_add">+	u8 tmp = val; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	return mt312_write(state, reg, &amp;tmp, 1);</span>
 }
 
 static inline u32 mt312_div(u32 a, u32 b)
<span class="p_header">diff --git a/drivers/media/dvb-frontends/stb0899_drv.c b/drivers/media/dvb-frontends/stb0899_drv.c</span>
<span class="p_header">index 02347598277a..db5dde3215f0 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/stb0899_drv.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/stb0899_drv.c</span>
<span class="p_chunk">@@ -539,7 +539,8 @@</span> <span class="p_context"> int stb0899_write_regs(struct stb0899_state *state, unsigned int reg, u8 *data,</span>
 
 int stb0899_write_reg(struct stb0899_state *state, unsigned int reg, u8 data)
 {
<span class="p_del">-	return stb0899_write_regs(state, reg, &amp;data, 1);</span>
<span class="p_add">+	u8 tmp = data;</span>
<span class="p_add">+	return stb0899_write_regs(state, reg, &amp;tmp, 1);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/media/dvb-frontends/stb6100.c b/drivers/media/dvb-frontends/stb6100.c</span>
<span class="p_header">index 17a955d0031b..75509bec66e4 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/stb6100.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/stb6100.c</span>
<span class="p_chunk">@@ -226,12 +226,14 @@</span> <span class="p_context"> static int stb6100_write_reg_range(struct stb6100_state *state, u8 buf[], int st</span>
 
 static int stb6100_write_reg(struct stb6100_state *state, u8 reg, u8 data)
 {
<span class="p_add">+	u8 tmp = data; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
 	if (unlikely(reg &gt;= STB6100_NUMREGS)) {
 		dprintk(verbose, FE_ERROR, 1, &quot;Invalid register offset 0x%x&quot;, reg);
 		return -EREMOTEIO;
 	}
<span class="p_del">-	data = (data &amp; stb6100_template[reg].mask) | stb6100_template[reg].set;</span>
<span class="p_del">-	return stb6100_write_reg_range(state, &amp;data, reg, 1);</span>
<span class="p_add">+	tmp = (tmp &amp; stb6100_template[reg].mask) | stb6100_template[reg].set;</span>
<span class="p_add">+	return stb6100_write_reg_range(state, &amp;tmp, reg, 1);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/stv0367.c b/drivers/media/dvb-frontends/stv0367.c</span>
<span class="p_header">index f3529df8211d..1a726196c126 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/stv0367.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/stv0367.c</span>
<span class="p_chunk">@@ -166,7 +166,9 @@</span> <span class="p_context"> int stv0367_writeregs(struct stv0367_state *state, u16 reg, u8 *data, int len)</span>
 
 static int stv0367_writereg(struct stv0367_state *state, u16 reg, u8 data)
 {
<span class="p_del">-	return stv0367_writeregs(state, reg, &amp;data, 1);</span>
<span class="p_add">+	u8 tmp = data; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return stv0367_writeregs(state, reg, &amp;tmp, 1);</span>
 }
 
 static u8 stv0367_readreg(struct stv0367_state *state, u16 reg)
<span class="p_header">diff --git a/drivers/media/dvb-frontends/stv090x.c b/drivers/media/dvb-frontends/stv090x.c</span>
<span class="p_header">index 7ef469c0c866..2695e1eb6d9c 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/stv090x.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/stv090x.c</span>
<span class="p_chunk">@@ -755,7 +755,9 @@</span> <span class="p_context"> static int stv090x_write_regs(struct stv090x_state *state, unsigned int reg, u8</span>
 
 static int stv090x_write_reg(struct stv090x_state *state, unsigned int reg, u8 data)
 {
<span class="p_del">-	return stv090x_write_regs(state, reg, &amp;data, 1);</span>
<span class="p_add">+	u8 tmp = data; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return stv090x_write_regs(state, reg, &amp;tmp, 1);</span>
 }
 
 static int stv090x_i2c_gate_ctrl(struct stv090x_state *state, int enable)
<span class="p_header">diff --git a/drivers/media/dvb-frontends/stv6110x.c b/drivers/media/dvb-frontends/stv6110x.c</span>
<span class="p_header">index 66eba38f1014..7e8e01389c55 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/stv6110x.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/stv6110x.c</span>
<span class="p_chunk">@@ -97,7 +97,9 @@</span> <span class="p_context"> static int stv6110x_write_regs(struct stv6110x_state *stv6110x, int start, u8 da</span>
 
 static int stv6110x_write_reg(struct stv6110x_state *stv6110x, u8 reg, u8 data)
 {
<span class="p_del">-	return stv6110x_write_regs(stv6110x, reg, &amp;data, 1);</span>
<span class="p_add">+	u8 tmp = data; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return stv6110x_write_regs(stv6110x, reg, &amp;tmp, 1);</span>
 }
 
 static int stv6110x_init(struct dvb_frontend *fe)
<span class="p_header">diff --git a/drivers/media/dvb-frontends/ts2020.c b/drivers/media/dvb-frontends/ts2020.c</span>
<span class="p_header">index 931e5c98da8a..b879e1571469 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/ts2020.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/ts2020.c</span>
<span class="p_chunk">@@ -368,7 +368,7 @@</span> <span class="p_context"> static int ts2020_read_tuner_gain(struct dvb_frontend *fe, unsigned v_agc,</span>
 		gain2 = clamp_t(long, gain2, 0, 13);
 		v_agc = clamp_t(long, v_agc, 400, 1100);
 
<span class="p_del">-		*_gain = -(gain1 * 2330 +</span>
<span class="p_add">+		*_gain = -((__s64)gain1 * 2330 +</span>
 			   gain2 * 3500 +
 			   v_agc * 24 / 10 * 10 +
 			   10000);
<span class="p_chunk">@@ -386,7 +386,7 @@</span> <span class="p_context"> static int ts2020_read_tuner_gain(struct dvb_frontend *fe, unsigned v_agc,</span>
 		gain3 = clamp_t(long, gain3, 0, 6);
 		v_agc = clamp_t(long, v_agc, 600, 1600);
 
<span class="p_del">-		*_gain = -(gain1 * 2650 +</span>
<span class="p_add">+		*_gain = -((__s64)gain1 * 2650 +</span>
 			   gain2 * 3380 +
 			   gain3 * 2850 +
 			   v_agc * 176 / 100 * 10 -
<span class="p_header">diff --git a/drivers/media/dvb-frontends/zl10039.c b/drivers/media/dvb-frontends/zl10039.c</span>
<span class="p_header">index 623355fc2666..3208b866d1cb 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/zl10039.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/zl10039.c</span>
<span class="p_chunk">@@ -134,7 +134,9 @@</span> <span class="p_context"> static inline int zl10039_writereg(struct zl10039_state *state,</span>
 				const enum zl10039_reg_addr reg,
 				const u8 val)
 {
<span class="p_del">-	return zl10039_write(state, reg, &amp;val, 1);</span>
<span class="p_add">+	const u8 tmp = val; /* see gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 */</span>
<span class="p_add">+</span>
<span class="p_add">+	return zl10039_write(state, reg, &amp;tmp, 1);</span>
 }
 
 static int zl10039_init(struct dvb_frontend *fe)
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb-v2/lmedm04.c b/drivers/media/usb/dvb-usb-v2/lmedm04.c</span>
<span class="p_header">index 5e320fa4a795..be26c029546b 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb-v2/lmedm04.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb-v2/lmedm04.c</span>
<span class="p_chunk">@@ -494,18 +494,23 @@</span> <span class="p_context"> static int lme2510_pid_filter(struct dvb_usb_adapter *adap, int index, u16 pid,</span>
 
 static int lme2510_return_status(struct dvb_usb_device *d)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_add">+	int ret;</span>
 	u8 *data;
 
<span class="p_del">-	data = kzalloc(10, GFP_KERNEL);</span>
<span class="p_add">+	data = kzalloc(6, GFP_KERNEL);</span>
 	if (!data)
 		return -ENOMEM;
 
<span class="p_del">-	ret |= usb_control_msg(d-&gt;udev, usb_rcvctrlpipe(d-&gt;udev, 0),</span>
<span class="p_del">-			0x06, 0x80, 0x0302, 0x00, data, 0x0006, 200);</span>
<span class="p_del">-	info(&quot;Firmware Status: %x (%x)&quot;, ret , data[2]);</span>
<span class="p_add">+	ret = usb_control_msg(d-&gt;udev, usb_rcvctrlpipe(d-&gt;udev, 0),</span>
<span class="p_add">+			      0x06, 0x80, 0x0302, 0x00,</span>
<span class="p_add">+			      data, 0x6, 200);</span>
<span class="p_add">+	if (ret != 6)</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = data[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	info(&quot;Firmware Status: %6ph&quot;, data);</span>
 
<span class="p_del">-	ret = (ret &lt; 0) ? -ENODEV : data[2];</span>
 	kfree(data);
 	return ret;
 }
<span class="p_chunk">@@ -1071,8 +1076,6 @@</span> <span class="p_context"> static int dm04_lme2510_frontend_attach(struct dvb_usb_adapter *adap)</span>
 
 		if (adap-&gt;fe[0]) {
 			info(&quot;FE Found M88RS2000&quot;);
<span class="p_del">-			dvb_attach(ts2020_attach, adap-&gt;fe[0], &amp;ts2020_config,</span>
<span class="p_del">-					&amp;d-&gt;i2c_adap);</span>
 			st-&gt;i2c_tuner_gate_w = 5;
 			st-&gt;i2c_tuner_gate_r = 5;
 			st-&gt;i2c_tuner_addr = 0x60;
<span class="p_chunk">@@ -1138,17 +1141,18 @@</span> <span class="p_context"> static int dm04_lme2510_tuner(struct dvb_usb_adapter *adap)</span>
 			ret = st-&gt;tuner_config;
 		break;
 	case TUNER_RS2000:
<span class="p_del">-		ret = st-&gt;tuner_config;</span>
<span class="p_add">+		if (dvb_attach(ts2020_attach, adap-&gt;fe[0],</span>
<span class="p_add">+			       &amp;ts2020_config, &amp;d-&gt;i2c_adap))</span>
<span class="p_add">+			ret = st-&gt;tuner_config;</span>
 		break;
 	default:
 		break;
 	}
 
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
 		info(&quot;TUN Found %s tuner&quot;, tun_msg[ret]);
<span class="p_del">-	else {</span>
<span class="p_del">-		info(&quot;TUN No tuner found --- resetting device&quot;);</span>
<span class="p_del">-		lme_coldreset(d);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		info(&quot;TUN No tuner found&quot;);</span>
 		return -ENODEV;
 	}
 
<span class="p_chunk">@@ -1189,6 +1193,7 @@</span> <span class="p_context"> static int lme2510_get_adapter_count(struct dvb_usb_device *d)</span>
 static int lme2510_identify_state(struct dvb_usb_device *d, const char **name)
 {
 	struct lme2510_state *st = d-&gt;priv;
<span class="p_add">+	int status;</span>
 
 	usb_reset_configuration(d-&gt;udev);
 
<span class="p_chunk">@@ -1197,12 +1202,16 @@</span> <span class="p_context"> static int lme2510_identify_state(struct dvb_usb_device *d, const char **name)</span>
 
 	st-&gt;dvb_usb_lme2510_firmware = dvb_usb_lme2510_firmware;
 
<span class="p_del">-	if (lme2510_return_status(d) == 0x44) {</span>
<span class="p_add">+	status = lme2510_return_status(d);</span>
<span class="p_add">+	if (status == 0x44) {</span>
 		*name = lme_firmware_switch(d, 0);
 		return COLD;
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	if (status != 0x47)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return WARM;</span>
 }
 
 static int lme2510_get_stream_config(struct dvb_frontend *fe, u8 *ts_type,
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/cxusb.c b/drivers/media/usb/dvb-usb/cxusb.c</span>
<span class="p_header">index 37dea0adc695..cfe86b4864b3 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/cxusb.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/cxusb.c</span>
<span class="p_chunk">@@ -677,6 +677,8 @@</span> <span class="p_context"> static int dvico_bluebird_xc2028_callback(void *ptr, int component,</span>
 	case XC2028_RESET_CLK:
 		deb_info(&quot;%s: XC2028_RESET_CLK %d\n&quot;, __func__, arg);
 		break;
<span class="p_add">+	case XC2028_I2C_FLUSH:</span>
<span class="p_add">+		break;</span>
 	default:
 		deb_info(&quot;%s: unknown command %d, arg %d\n&quot;, __func__,
 			 command, arg);
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dib0700_devices.c b/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_header">index 92098c1b78e5..9be1e658ef47 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_chunk">@@ -430,6 +430,7 @@</span> <span class="p_context"> static int stk7700ph_xc3028_callback(void *ptr, int component,</span>
 		state-&gt;dib7000p_ops.set_gpio(adap-&gt;fe_adap[0].fe, 8, 0, 1);
 		break;
 	case XC2028_RESET_CLK:
<span class="p_add">+	case XC2028_I2C_FLUSH:</span>
 		break;
 	default:
 		err(&quot;%s: unknown command %d, arg %d\n&quot;, __func__,
<span class="p_header">diff --git a/drivers/media/usb/hdpvr/hdpvr-core.c b/drivers/media/usb/hdpvr/hdpvr-core.c</span>
<span class="p_header">index dbe29c6c4d8b..1e8cbaf36896 100644</span>
<span class="p_header">--- a/drivers/media/usb/hdpvr/hdpvr-core.c</span>
<span class="p_header">+++ b/drivers/media/usb/hdpvr/hdpvr-core.c</span>
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> static int hdpvr_probe(struct usb_interface *interface,</span>
 	/* register v4l2_device early so it can be used for printks */
 	if (v4l2_device_register(&amp;interface-&gt;dev, &amp;dev-&gt;v4l2_dev)) {
 		dev_err(&amp;interface-&gt;dev, &quot;v4l2_device_register failed\n&quot;);
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error_free_dev;</span>
 	}
 
 	mutex_init(&amp;dev-&gt;io_mutex);
<span class="p_chunk">@@ -301,7 +301,7 @@</span> <span class="p_context"> static int hdpvr_probe(struct usb_interface *interface,</span>
 	dev-&gt;usbc_buf = kmalloc(64, GFP_KERNEL);
 	if (!dev-&gt;usbc_buf) {
 		v4l2_err(&amp;dev-&gt;v4l2_dev, &quot;Out of memory\n&quot;);
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error_v4l2_unregister;</span>
 	}
 
 	init_waitqueue_head(&amp;dev-&gt;wait_buffer);
<span class="p_chunk">@@ -339,13 +339,13 @@</span> <span class="p_context"> static int hdpvr_probe(struct usb_interface *interface,</span>
 	}
 	if (!dev-&gt;bulk_in_endpointAddr) {
 		v4l2_err(&amp;dev-&gt;v4l2_dev, &quot;Could not find bulk-in endpoint\n&quot;);
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error_put_usb;</span>
 	}
 
 	/* init the device */
 	if (hdpvr_device_init(dev)) {
 		v4l2_err(&amp;dev-&gt;v4l2_dev, &quot;device init failed\n&quot;);
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error_put_usb;</span>
 	}
 
 	mutex_lock(&amp;dev-&gt;io_mutex);
<span class="p_chunk">@@ -353,7 +353,7 @@</span> <span class="p_context"> static int hdpvr_probe(struct usb_interface *interface,</span>
 		mutex_unlock(&amp;dev-&gt;io_mutex);
 		v4l2_err(&amp;dev-&gt;v4l2_dev,
 			 &quot;allocating transfer buffers failed\n&quot;);
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error_put_usb;</span>
 	}
 	mutex_unlock(&amp;dev-&gt;io_mutex);
 
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static int hdpvr_probe(struct usb_interface *interface,</span>
 	retval = hdpvr_register_i2c_adapter(dev);
 	if (retval &lt; 0) {
 		v4l2_err(&amp;dev-&gt;v4l2_dev, &quot;i2c adapter register failed\n&quot;);
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto error_free_buffers;</span>
 	}
 
 	client = hdpvr_register_ir_rx_i2c(dev);
<span class="p_chunk">@@ -394,13 +394,17 @@</span> <span class="p_context"> static int hdpvr_probe(struct usb_interface *interface,</span>
 reg_fail:
 #if IS_ENABLED(CONFIG_I2C)
 	i2c_del_adapter(&amp;dev-&gt;i2c_adapter);
<span class="p_add">+error_free_buffers:</span>
 #endif
<span class="p_add">+	hdpvr_free_buffers(dev);</span>
<span class="p_add">+error_put_usb:</span>
<span class="p_add">+	usb_put_dev(dev-&gt;udev);</span>
<span class="p_add">+	kfree(dev-&gt;usbc_buf);</span>
<span class="p_add">+error_v4l2_unregister:</span>
<span class="p_add">+	v4l2_device_unregister(&amp;dev-&gt;v4l2_dev);</span>
<span class="p_add">+error_free_dev:</span>
<span class="p_add">+	kfree(dev);</span>
 error:
<span class="p_del">-	if (dev) {</span>
<span class="p_del">-		flush_work(&amp;dev-&gt;worker);</span>
<span class="p_del">-		/* this frees allocated memory */</span>
<span class="p_del">-		hdpvr_delete(dev);</span>
<span class="p_del">-	}</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">index 821f2aa299ae..cbeea8343a5c 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_chunk">@@ -18,8 +18,18 @@</span> <span class="p_context"></span>
 #include &lt;linux/videodev2.h&gt;
 #include &lt;linux/v4l2-subdev.h&gt;
 #include &lt;media/v4l2-dev.h&gt;
<span class="p_add">+#include &lt;media/v4l2-fh.h&gt;</span>
<span class="p_add">+#include &lt;media/v4l2-ctrls.h&gt;</span>
 #include &lt;media/v4l2-ioctl.h&gt;
 
<span class="p_add">+/* Use the same argument order as copy_in_user */</span>
<span class="p_add">+#define assign_in_user(to, from)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	typeof(*from) __assign_tmp;					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	get_user(__assign_tmp, from) || put_user(__assign_tmp, to);	\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 static long native_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	long ret = -ENOIOCTLCMD;
<span class="p_chunk">@@ -46,135 +56,75 @@</span> <span class="p_context"> struct v4l2_window32 {</span>
 	__u8                    global_alpha;
 };
 
<span class="p_del">-static int get_v4l2_window32(struct v4l2_window *kp, struct v4l2_window32 __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_window32)) ||</span>
<span class="p_del">-		copy_from_user(&amp;kp-&gt;w, &amp;up-&gt;w, sizeof(up-&gt;w)) ||</span>
<span class="p_del">-		get_user(kp-&gt;field, &amp;up-&gt;field) ||</span>
<span class="p_del">-		get_user(kp-&gt;chromakey, &amp;up-&gt;chromakey) ||</span>
<span class="p_del">-		get_user(kp-&gt;clipcount, &amp;up-&gt;clipcount) ||</span>
<span class="p_del">-		get_user(kp-&gt;global_alpha, &amp;up-&gt;global_alpha))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	if (kp-&gt;clipcount &gt; 2048)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	if (kp-&gt;clipcount) {</span>
<span class="p_del">-		struct v4l2_clip32 __user *uclips;</span>
<span class="p_del">-		struct v4l2_clip __user *kclips;</span>
<span class="p_del">-		int n = kp-&gt;clipcount;</span>
<span class="p_del">-		compat_caddr_t p;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (get_user(p, &amp;up-&gt;clips))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		uclips = compat_ptr(p);</span>
<span class="p_del">-		kclips = compat_alloc_user_space(n * sizeof(struct v4l2_clip));</span>
<span class="p_del">-		kp-&gt;clips = kclips;</span>
<span class="p_del">-		while (--n &gt;= 0) {</span>
<span class="p_del">-			if (copy_in_user(&amp;kclips-&gt;c, &amp;uclips-&gt;c, sizeof(uclips-&gt;c)))</span>
<span class="p_del">-				return -EFAULT;</span>
<span class="p_del">-			if (put_user(n ? kclips + 1 : NULL, &amp;kclips-&gt;next))</span>
<span class="p_del">-				return -EFAULT;</span>
<span class="p_del">-			uclips += 1;</span>
<span class="p_del">-			kclips += 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	} else</span>
<span class="p_del">-		kp-&gt;clips = NULL;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int put_v4l2_window32(struct v4l2_window *kp, struct v4l2_window32 __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_to_user(&amp;up-&gt;w, &amp;kp-&gt;w, sizeof(kp-&gt;w)) ||</span>
<span class="p_del">-		put_user(kp-&gt;field, &amp;up-&gt;field) ||</span>
<span class="p_del">-		put_user(kp-&gt;chromakey, &amp;up-&gt;chromakey) ||</span>
<span class="p_del">-		put_user(kp-&gt;clipcount, &amp;up-&gt;clipcount) ||</span>
<span class="p_del">-		put_user(kp-&gt;global_alpha, &amp;up-&gt;global_alpha))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int get_v4l2_pix_format(struct v4l2_pix_format *kp, struct v4l2_pix_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_from_user(kp, up, sizeof(struct v4l2_pix_format)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int get_v4l2_pix_format_mplane(struct v4l2_pix_format_mplane *kp,</span>
<span class="p_del">-				struct v4l2_pix_format_mplane __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_from_user(kp, up, sizeof(struct v4l2_pix_format_mplane)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int put_v4l2_pix_format(struct v4l2_pix_format *kp, struct v4l2_pix_format __user *up)</span>
<span class="p_add">+static int get_v4l2_window32(struct v4l2_window __user *kp,</span>
<span class="p_add">+			     struct v4l2_window32 __user *up,</span>
<span class="p_add">+			     void __user *aux_buf, u32 aux_space)</span>
 {
<span class="p_del">-	if (copy_to_user(up, kp, sizeof(struct v4l2_pix_format)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int put_v4l2_pix_format_mplane(struct v4l2_pix_format_mplane *kp,</span>
<span class="p_del">-				struct v4l2_pix_format_mplane __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_to_user(up, kp, sizeof(struct v4l2_pix_format_mplane)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int get_v4l2_vbi_format(struct v4l2_vbi_format *kp, struct v4l2_vbi_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_from_user(kp, up, sizeof(struct v4l2_vbi_format)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int put_v4l2_vbi_format(struct v4l2_vbi_format *kp, struct v4l2_vbi_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_to_user(up, kp, sizeof(struct v4l2_vbi_format)))</span>
<span class="p_add">+	struct v4l2_clip32 __user *uclips;</span>
<span class="p_add">+	struct v4l2_clip __user *kclips;</span>
<span class="p_add">+	compat_caddr_t p;</span>
<span class="p_add">+	u32 clipcount;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    copy_in_user(&amp;kp-&gt;w, &amp;up-&gt;w, sizeof(up-&gt;w)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;field, &amp;up-&gt;field) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;chromakey, &amp;up-&gt;chromakey) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;global_alpha, &amp;up-&gt;global_alpha) ||</span>
<span class="p_add">+	    get_user(clipcount, &amp;up-&gt;clipcount) ||</span>
<span class="p_add">+	    put_user(clipcount, &amp;kp-&gt;clipcount))</span>
 		return -EFAULT;
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+	if (clipcount &gt; 2048)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (!clipcount)</span>
<span class="p_add">+		return put_user(NULL, &amp;kp-&gt;clips);</span>
 
<span class="p_del">-static inline int get_v4l2_sliced_vbi_format(struct v4l2_sliced_vbi_format *kp, struct v4l2_sliced_vbi_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_from_user(kp, up, sizeof(struct v4l2_sliced_vbi_format)))</span>
<span class="p_add">+	if (get_user(p, &amp;up-&gt;clips))</span>
 		return -EFAULT;
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int put_v4l2_sliced_vbi_format(struct v4l2_sliced_vbi_format *kp, struct v4l2_sliced_vbi_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_to_user(up, kp, sizeof(struct v4l2_sliced_vbi_format)))</span>
<span class="p_add">+	uclips = compat_ptr(p);</span>
<span class="p_add">+	if (aux_space &lt; clipcount * sizeof(*kclips))</span>
 		return -EFAULT;
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int get_v4l2_sdr_format(struct v4l2_sdr_format *kp, struct v4l2_sdr_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_from_user(kp, up, sizeof(struct v4l2_sdr_format)))</span>
<span class="p_add">+	kclips = aux_buf;</span>
<span class="p_add">+	if (put_user(kclips, &amp;kp-&gt;clips))</span>
 		return -EFAULT;
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
 
<span class="p_del">-static inline int put_v4l2_sdr_format(struct v4l2_sdr_format *kp, struct v4l2_sdr_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_to_user(up, kp, sizeof(struct v4l2_sdr_format)))</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+	while (clipcount--) {</span>
<span class="p_add">+		if (copy_in_user(&amp;kclips-&gt;c, &amp;uclips-&gt;c, sizeof(uclips-&gt;c)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (put_user(clipcount ? kclips + 1 : NULL, &amp;kclips-&gt;next))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		uclips++;</span>
<span class="p_add">+		kclips++;</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_del">-static inline int get_v4l2_meta_format(struct v4l2_meta_format *kp, struct v4l2_meta_format __user *up)</span>
<span class="p_add">+static int put_v4l2_window32(struct v4l2_window __user *kp,</span>
<span class="p_add">+			     struct v4l2_window32 __user *up)</span>
 {
<span class="p_del">-	if (copy_from_user(kp, up, sizeof(struct v4l2_meta_format)))</span>
<span class="p_add">+	struct v4l2_clip __user *kclips = kp-&gt;clips;</span>
<span class="p_add">+	struct v4l2_clip32 __user *uclips;</span>
<span class="p_add">+	compat_caddr_t p;</span>
<span class="p_add">+	u32 clipcount;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_in_user(&amp;up-&gt;w, &amp;kp-&gt;w, sizeof(kp-&gt;w)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;field, &amp;kp-&gt;field) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;chromakey, &amp;kp-&gt;chromakey) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;global_alpha, &amp;kp-&gt;global_alpha) ||</span>
<span class="p_add">+	    get_user(clipcount, &amp;kp-&gt;clipcount) ||</span>
<span class="p_add">+	    put_user(clipcount, &amp;up-&gt;clipcount))</span>
 		return -EFAULT;
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+	if (!clipcount)</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-static inline int put_v4l2_meta_format(struct v4l2_meta_format *kp, struct v4l2_meta_format __user *up)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (copy_to_user(up, kp, sizeof(struct v4l2_meta_format)))</span>
<span class="p_add">+	if (get_user(p, &amp;up-&gt;clips))</span>
 		return -EFAULT;
<span class="p_add">+	uclips = compat_ptr(p);</span>
<span class="p_add">+	while (clipcount--) {</span>
<span class="p_add">+		if (copy_in_user(&amp;uclips-&gt;c, &amp;kclips-&gt;c, sizeof(uclips-&gt;c)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		uclips++;</span>
<span class="p_add">+		kclips++;</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -209,101 +159,164 @@</span> <span class="p_context"> struct v4l2_create_buffers32 {</span>
 	__u32			reserved[8];
 };
 
<span class="p_del">-static int __get_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)</span>
<span class="p_add">+static int __bufsize_v4l2_format(struct v4l2_format32 __user *up, u32 *size)</span>
 {
<span class="p_del">-	if (get_user(kp-&gt;type, &amp;up-&gt;type))</span>
<span class="p_add">+	u32 type;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(type, &amp;up-&gt;type))</span>
 		return -EFAULT;
 
<span class="p_del">-	switch (kp-&gt;type) {</span>
<span class="p_add">+	switch (type) {</span>
<span class="p_add">+	case V4L2_BUF_TYPE_VIDEO_OVERLAY:</span>
<span class="p_add">+	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY: {</span>
<span class="p_add">+		u32 clipcount;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (get_user(clipcount, &amp;up-&gt;fmt.win.clipcount))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (clipcount &gt; 2048)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		*size = clipcount * sizeof(struct v4l2_clip);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		*size = 0;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int bufsize_v4l2_format(struct v4l2_format32 __user *up, u32 *size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	return __bufsize_v4l2_format(up, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __get_v4l2_format32(struct v4l2_format __user *kp,</span>
<span class="p_add">+			       struct v4l2_format32 __user *up,</span>
<span class="p_add">+			       void __user *aux_buf, u32 aux_space)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 type;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(type, &amp;up-&gt;type) || put_user(type, &amp;kp-&gt;type))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (type) {</span>
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
<span class="p_del">-		return get_v4l2_pix_format(&amp;kp-&gt;fmt.pix, &amp;up-&gt;fmt.pix);</span>
<span class="p_add">+		return copy_in_user(&amp;kp-&gt;fmt.pix, &amp;up-&gt;fmt.pix,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.pix)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
<span class="p_del">-		return get_v4l2_pix_format_mplane(&amp;kp-&gt;fmt.pix_mp,</span>
<span class="p_del">-						  &amp;up-&gt;fmt.pix_mp);</span>
<span class="p_add">+		return copy_in_user(&amp;kp-&gt;fmt.pix_mp, &amp;up-&gt;fmt.pix_mp,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.pix_mp)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
<span class="p_del">-		return get_v4l2_window32(&amp;kp-&gt;fmt.win, &amp;up-&gt;fmt.win);</span>
<span class="p_add">+		return get_v4l2_window32(&amp;kp-&gt;fmt.win, &amp;up-&gt;fmt.win,</span>
<span class="p_add">+					 aux_buf, aux_space);</span>
 	case V4L2_BUF_TYPE_VBI_CAPTURE:
 	case V4L2_BUF_TYPE_VBI_OUTPUT:
<span class="p_del">-		return get_v4l2_vbi_format(&amp;kp-&gt;fmt.vbi, &amp;up-&gt;fmt.vbi);</span>
<span class="p_add">+		return copy_in_user(&amp;kp-&gt;fmt.vbi, &amp;up-&gt;fmt.vbi,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.vbi)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
 	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
<span class="p_del">-		return get_v4l2_sliced_vbi_format(&amp;kp-&gt;fmt.sliced, &amp;up-&gt;fmt.sliced);</span>
<span class="p_add">+		return copy_in_user(&amp;kp-&gt;fmt.sliced, &amp;up-&gt;fmt.sliced,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.sliced)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_SDR_CAPTURE:
 	case V4L2_BUF_TYPE_SDR_OUTPUT:
<span class="p_del">-		return get_v4l2_sdr_format(&amp;kp-&gt;fmt.sdr, &amp;up-&gt;fmt.sdr);</span>
<span class="p_add">+		return copy_in_user(&amp;kp-&gt;fmt.sdr, &amp;up-&gt;fmt.sdr,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.sdr)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_META_CAPTURE:
<span class="p_del">-		return get_v4l2_meta_format(&amp;kp-&gt;fmt.meta, &amp;up-&gt;fmt.meta);</span>
<span class="p_add">+		return copy_in_user(&amp;kp-&gt;fmt.meta, &amp;up-&gt;fmt.meta,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.meta)) ? -EFAULT : 0;</span>
 	default:
<span class="p_del">-		pr_info(&quot;compat_ioctl32: unexpected VIDIOC_FMT type %d\n&quot;,</span>
<span class="p_del">-								kp-&gt;type);</span>
 		return -EINVAL;
 	}
 }
 
<span class="p_del">-static int get_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)</span>
<span class="p_add">+static int get_v4l2_format32(struct v4l2_format __user *kp,</span>
<span class="p_add">+			     struct v4l2_format32 __user *up,</span>
<span class="p_add">+			     void __user *aux_buf, u32 aux_space)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	return __get_v4l2_format32(kp, up, aux_buf, aux_space);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int bufsize_v4l2_create(struct v4l2_create_buffers32 __user *up,</span>
<span class="p_add">+			       u32 *size)</span>
 {
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_format32)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)))</span>
 		return -EFAULT;
<span class="p_del">-	return __get_v4l2_format32(kp, up);</span>
<span class="p_add">+	return __bufsize_v4l2_format(&amp;up-&gt;format, size);</span>
 }
 
<span class="p_del">-static int get_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)</span>
<span class="p_add">+static int get_v4l2_create32(struct v4l2_create_buffers __user *kp,</span>
<span class="p_add">+			     struct v4l2_create_buffers32 __user *up,</span>
<span class="p_add">+			     void __user *aux_buf, u32 aux_space)</span>
 {
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_create_buffers32)) ||</span>
<span class="p_del">-	    copy_from_user(kp, up, offsetof(struct v4l2_create_buffers32, format)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    copy_in_user(kp, up,</span>
<span class="p_add">+			 offsetof(struct v4l2_create_buffers32, format)))</span>
 		return -EFAULT;
<span class="p_del">-	return __get_v4l2_format32(&amp;kp-&gt;format, &amp;up-&gt;format);</span>
<span class="p_add">+	return __get_v4l2_format32(&amp;kp-&gt;format, &amp;up-&gt;format,</span>
<span class="p_add">+				   aux_buf, aux_space);</span>
 }
 
<span class="p_del">-static int __put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)</span>
<span class="p_add">+static int __put_v4l2_format32(struct v4l2_format __user *kp,</span>
<span class="p_add">+			       struct v4l2_format32 __user *up)</span>
 {
<span class="p_del">-	if (put_user(kp-&gt;type, &amp;up-&gt;type))</span>
<span class="p_add">+	u32 type;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(type, &amp;kp-&gt;type))</span>
 		return -EFAULT;
 
<span class="p_del">-	switch (kp-&gt;type) {</span>
<span class="p_add">+	switch (type) {</span>
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
<span class="p_del">-		return put_v4l2_pix_format(&amp;kp-&gt;fmt.pix, &amp;up-&gt;fmt.pix);</span>
<span class="p_add">+		return copy_in_user(&amp;up-&gt;fmt.pix, &amp;kp-&gt;fmt.pix,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.pix)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
<span class="p_del">-		return put_v4l2_pix_format_mplane(&amp;kp-&gt;fmt.pix_mp,</span>
<span class="p_del">-						  &amp;up-&gt;fmt.pix_mp);</span>
<span class="p_add">+		return copy_in_user(&amp;up-&gt;fmt.pix_mp, &amp;kp-&gt;fmt.pix_mp,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.pix_mp)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
 		return put_v4l2_window32(&amp;kp-&gt;fmt.win, &amp;up-&gt;fmt.win);
 	case V4L2_BUF_TYPE_VBI_CAPTURE:
 	case V4L2_BUF_TYPE_VBI_OUTPUT:
<span class="p_del">-		return put_v4l2_vbi_format(&amp;kp-&gt;fmt.vbi, &amp;up-&gt;fmt.vbi);</span>
<span class="p_add">+		return copy_in_user(&amp;up-&gt;fmt.vbi, &amp;kp-&gt;fmt.vbi,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.vbi)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
 	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
<span class="p_del">-		return put_v4l2_sliced_vbi_format(&amp;kp-&gt;fmt.sliced, &amp;up-&gt;fmt.sliced);</span>
<span class="p_add">+		return copy_in_user(&amp;up-&gt;fmt.sliced, &amp;kp-&gt;fmt.sliced,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.sliced)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_SDR_CAPTURE:
 	case V4L2_BUF_TYPE_SDR_OUTPUT:
<span class="p_del">-		return put_v4l2_sdr_format(&amp;kp-&gt;fmt.sdr, &amp;up-&gt;fmt.sdr);</span>
<span class="p_add">+		return copy_in_user(&amp;up-&gt;fmt.sdr, &amp;kp-&gt;fmt.sdr,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.sdr)) ? -EFAULT : 0;</span>
 	case V4L2_BUF_TYPE_META_CAPTURE:
<span class="p_del">-		return put_v4l2_meta_format(&amp;kp-&gt;fmt.meta, &amp;up-&gt;fmt.meta);</span>
<span class="p_add">+		return copy_in_user(&amp;up-&gt;fmt.meta, &amp;kp-&gt;fmt.meta,</span>
<span class="p_add">+				    sizeof(kp-&gt;fmt.meta)) ? -EFAULT : 0;</span>
 	default:
<span class="p_del">-		pr_info(&quot;compat_ioctl32: unexpected VIDIOC_FMT type %d\n&quot;,</span>
<span class="p_del">-								kp-&gt;type);</span>
 		return -EINVAL;
 	}
 }
 
<span class="p_del">-static int put_v4l2_format32(struct v4l2_format *kp, struct v4l2_format32 __user *up)</span>
<span class="p_add">+static int put_v4l2_format32(struct v4l2_format __user *kp,</span>
<span class="p_add">+			     struct v4l2_format32 __user *up)</span>
 {
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_format32)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)))</span>
 		return -EFAULT;
 	return __put_v4l2_format32(kp, up);
 }
 
<span class="p_del">-static int put_v4l2_create32(struct v4l2_create_buffers *kp, struct v4l2_create_buffers32 __user *up)</span>
<span class="p_add">+static int put_v4l2_create32(struct v4l2_create_buffers __user *kp,</span>
<span class="p_add">+			     struct v4l2_create_buffers32 __user *up)</span>
 {
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_create_buffers32)) ||</span>
<span class="p_del">-	    copy_to_user(up, kp, offsetof(struct v4l2_create_buffers32, format)) ||</span>
<span class="p_del">-	    copy_to_user(up-&gt;reserved, kp-&gt;reserved, sizeof(kp-&gt;reserved)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||</span>
<span class="p_add">+	    copy_in_user(up, kp,</span>
<span class="p_add">+			 offsetof(struct v4l2_create_buffers32, format)) ||</span>
<span class="p_add">+	    copy_in_user(up-&gt;reserved, kp-&gt;reserved, sizeof(kp-&gt;reserved)))</span>
 		return -EFAULT;
 	return __put_v4l2_format32(&amp;kp-&gt;format, &amp;up-&gt;format);
 }
<span class="p_chunk">@@ -317,25 +330,28 @@</span> <span class="p_context"> struct v4l2_standard32 {</span>
 	__u32		     reserved[4];
 };
 
<span class="p_del">-static int get_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32 __user *up)</span>
<span class="p_add">+static int get_v4l2_standard32(struct v4l2_standard __user *kp,</span>
<span class="p_add">+			       struct v4l2_standard32 __user *up)</span>
 {
 	/* other fields are not set by the user, nor used by the driver */
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_standard32)) ||</span>
<span class="p_del">-		get_user(kp-&gt;index, &amp;up-&gt;index))</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;index, &amp;up-&gt;index))</span>
 		return -EFAULT;
 	return 0;
 }
 
<span class="p_del">-static int put_v4l2_standard32(struct v4l2_standard *kp, struct v4l2_standard32 __user *up)</span>
<span class="p_add">+static int put_v4l2_standard32(struct v4l2_standard __user *kp,</span>
<span class="p_add">+			       struct v4l2_standard32 __user *up)</span>
 {
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_standard32)) ||</span>
<span class="p_del">-		put_user(kp-&gt;index, &amp;up-&gt;index) ||</span>
<span class="p_del">-		put_user(kp-&gt;id, &amp;up-&gt;id) ||</span>
<span class="p_del">-		copy_to_user(up-&gt;name, kp-&gt;name, 24) ||</span>
<span class="p_del">-		copy_to_user(&amp;up-&gt;frameperiod, &amp;kp-&gt;frameperiod, sizeof(kp-&gt;frameperiod)) ||</span>
<span class="p_del">-		put_user(kp-&gt;framelines, &amp;up-&gt;framelines) ||</span>
<span class="p_del">-		copy_to_user(up-&gt;reserved, kp-&gt;reserved, 4 * sizeof(__u32)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;index, &amp;kp-&gt;index) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;id, &amp;kp-&gt;id) ||</span>
<span class="p_add">+	    copy_in_user(up-&gt;name, kp-&gt;name, sizeof(up-&gt;name)) ||</span>
<span class="p_add">+	    copy_in_user(&amp;up-&gt;frameperiod, &amp;kp-&gt;frameperiod,</span>
<span class="p_add">+			 sizeof(up-&gt;frameperiod)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;framelines, &amp;kp-&gt;framelines) ||</span>
<span class="p_add">+	    copy_in_user(up-&gt;reserved, kp-&gt;reserved, sizeof(up-&gt;reserved)))</span>
<span class="p_add">+		return -EFAULT;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -374,136 +390,186 @@</span> <span class="p_context"> struct v4l2_buffer32 {</span>
 	__u32			reserved;
 };
 
<span class="p_del">-static int get_v4l2_plane32(struct v4l2_plane __user *up, struct v4l2_plane32 __user *up32,</span>
<span class="p_del">-				enum v4l2_memory memory)</span>
<span class="p_add">+static int get_v4l2_plane32(struct v4l2_plane __user *up,</span>
<span class="p_add">+			    struct v4l2_plane32 __user *up32,</span>
<span class="p_add">+			    enum v4l2_memory memory)</span>
 {
<span class="p_del">-	void __user *up_pln;</span>
<span class="p_del">-	compat_long_t p;</span>
<span class="p_add">+	compat_ulong_t p;</span>
 
 	if (copy_in_user(up, up32, 2 * sizeof(__u32)) ||
<span class="p_del">-		copy_in_user(&amp;up-&gt;data_offset, &amp;up32-&gt;data_offset,</span>
<span class="p_del">-				sizeof(__u32)))</span>
<span class="p_add">+	    copy_in_user(&amp;up-&gt;data_offset, &amp;up32-&gt;data_offset,</span>
<span class="p_add">+			 sizeof(up-&gt;data_offset)))</span>
 		return -EFAULT;
 
<span class="p_del">-	if (memory == V4L2_MEMORY_USERPTR) {</span>
<span class="p_del">-		if (get_user(p, &amp;up32-&gt;m.userptr))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-		up_pln = compat_ptr(p);</span>
<span class="p_del">-		if (put_user((unsigned long)up_pln, &amp;up-&gt;m.userptr))</span>
<span class="p_add">+	switch (memory) {</span>
<span class="p_add">+	case V4L2_MEMORY_MMAP:</span>
<span class="p_add">+	case V4L2_MEMORY_OVERLAY:</span>
<span class="p_add">+		if (copy_in_user(&amp;up-&gt;m.mem_offset, &amp;up32-&gt;m.mem_offset,</span>
<span class="p_add">+				 sizeof(up32-&gt;m.mem_offset)))</span>
 			return -EFAULT;
<span class="p_del">-	} else if (memory == V4L2_MEMORY_DMABUF) {</span>
<span class="p_del">-		if (copy_in_user(&amp;up-&gt;m.fd, &amp;up32-&gt;m.fd, sizeof(int)))</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case V4L2_MEMORY_USERPTR:</span>
<span class="p_add">+		if (get_user(p, &amp;up32-&gt;m.userptr) ||</span>
<span class="p_add">+		    put_user((unsigned long)compat_ptr(p), &amp;up-&gt;m.userptr))</span>
 			return -EFAULT;
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (copy_in_user(&amp;up-&gt;m.mem_offset, &amp;up32-&gt;m.mem_offset,</span>
<span class="p_del">-					sizeof(__u32)))</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case V4L2_MEMORY_DMABUF:</span>
<span class="p_add">+		if (copy_in_user(&amp;up-&gt;m.fd, &amp;up32-&gt;m.fd, sizeof(up32-&gt;m.fd)))</span>
 			return -EFAULT;
<span class="p_add">+		break;</span>
 	}
 
 	return 0;
 }
 
<span class="p_del">-static int put_v4l2_plane32(struct v4l2_plane __user *up, struct v4l2_plane32 __user *up32,</span>
<span class="p_del">-				enum v4l2_memory memory)</span>
<span class="p_add">+static int put_v4l2_plane32(struct v4l2_plane __user *up,</span>
<span class="p_add">+			    struct v4l2_plane32 __user *up32,</span>
<span class="p_add">+			    enum v4l2_memory memory)</span>
 {
<span class="p_add">+	unsigned long p;</span>
<span class="p_add">+</span>
 	if (copy_in_user(up32, up, 2 * sizeof(__u32)) ||
<span class="p_del">-		copy_in_user(&amp;up32-&gt;data_offset, &amp;up-&gt;data_offset,</span>
<span class="p_del">-				sizeof(__u32)))</span>
<span class="p_add">+	    copy_in_user(&amp;up32-&gt;data_offset, &amp;up-&gt;data_offset,</span>
<span class="p_add">+			 sizeof(up-&gt;data_offset)))</span>
 		return -EFAULT;
 
<span class="p_del">-	/* For MMAP, driver might&#39;ve set up the offset, so copy it back.</span>
<span class="p_del">-	 * USERPTR stays the same (was userspace-provided), so no copying. */</span>
<span class="p_del">-	if (memory == V4L2_MEMORY_MMAP)</span>
<span class="p_add">+	switch (memory) {</span>
<span class="p_add">+	case V4L2_MEMORY_MMAP:</span>
<span class="p_add">+	case V4L2_MEMORY_OVERLAY:</span>
 		if (copy_in_user(&amp;up32-&gt;m.mem_offset, &amp;up-&gt;m.mem_offset,
<span class="p_del">-					sizeof(__u32)))</span>
<span class="p_add">+				 sizeof(up-&gt;m.mem_offset)))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case V4L2_MEMORY_USERPTR:</span>
<span class="p_add">+		if (get_user(p, &amp;up-&gt;m.userptr) ||</span>
<span class="p_add">+		    put_user((compat_ulong_t)ptr_to_compat((__force void *)p),</span>
<span class="p_add">+			     &amp;up32-&gt;m.userptr))</span>
 			return -EFAULT;
<span class="p_del">-	/* For DMABUF, driver might&#39;ve set up the fd, so copy it back. */</span>
<span class="p_del">-	if (memory == V4L2_MEMORY_DMABUF)</span>
<span class="p_del">-		if (copy_in_user(&amp;up32-&gt;m.fd, &amp;up-&gt;m.fd,</span>
<span class="p_del">-					sizeof(int)))</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case V4L2_MEMORY_DMABUF:</span>
<span class="p_add">+		if (copy_in_user(&amp;up32-&gt;m.fd, &amp;up-&gt;m.fd, sizeof(up-&gt;m.fd)))</span>
 			return -EFAULT;
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int bufsize_v4l2_buffer(struct v4l2_buffer32 __user *up, u32 *size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 type;</span>
<span class="p_add">+	u32 length;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    get_user(type, &amp;up-&gt;type) ||</span>
<span class="p_add">+	    get_user(length, &amp;up-&gt;length))</span>
<span class="p_add">+		return -EFAULT;</span>
 
<span class="p_add">+	if (V4L2_TYPE_IS_MULTIPLANAR(type)) {</span>
<span class="p_add">+		if (length &gt; VIDEO_MAX_PLANES)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We don&#39;t really care if userspace decides to kill itself</span>
<span class="p_add">+		 * by passing a very big length value</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		*size = length * sizeof(struct v4l2_plane);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		*size = 0;</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_del">-static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user *up)</span>
<span class="p_add">+static int get_v4l2_buffer32(struct v4l2_buffer __user *kp,</span>
<span class="p_add">+			     struct v4l2_buffer32 __user *up,</span>
<span class="p_add">+			     void __user *aux_buf, u32 aux_space)</span>
 {
<span class="p_add">+	u32 type;</span>
<span class="p_add">+	u32 length;</span>
<span class="p_add">+	enum v4l2_memory memory;</span>
 	struct v4l2_plane32 __user *uplane32;
 	struct v4l2_plane __user *uplane;
 	compat_caddr_t p;
 	int ret;
 
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_buffer32)) ||</span>
<span class="p_del">-		get_user(kp-&gt;index, &amp;up-&gt;index) ||</span>
<span class="p_del">-		get_user(kp-&gt;type, &amp;up-&gt;type) ||</span>
<span class="p_del">-		get_user(kp-&gt;flags, &amp;up-&gt;flags) ||</span>
<span class="p_del">-		get_user(kp-&gt;memory, &amp;up-&gt;memory) ||</span>
<span class="p_del">-		get_user(kp-&gt;length, &amp;up-&gt;length))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;index, &amp;up-&gt;index) ||</span>
<span class="p_add">+	    get_user(type, &amp;up-&gt;type) ||</span>
<span class="p_add">+	    put_user(type, &amp;kp-&gt;type) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;flags, &amp;up-&gt;flags) ||</span>
<span class="p_add">+	    get_user(memory, &amp;up-&gt;memory) ||</span>
<span class="p_add">+	    put_user(memory, &amp;kp-&gt;memory) ||</span>
<span class="p_add">+	    get_user(length, &amp;up-&gt;length) ||</span>
<span class="p_add">+	    put_user(length, &amp;kp-&gt;length))</span>
<span class="p_add">+		return -EFAULT;</span>
 
<span class="p_del">-	if (V4L2_TYPE_IS_OUTPUT(kp-&gt;type))</span>
<span class="p_del">-		if (get_user(kp-&gt;bytesused, &amp;up-&gt;bytesused) ||</span>
<span class="p_del">-			get_user(kp-&gt;field, &amp;up-&gt;field) ||</span>
<span class="p_del">-			get_user(kp-&gt;timestamp.tv_sec, &amp;up-&gt;timestamp.tv_sec) ||</span>
<span class="p_del">-			get_user(kp-&gt;timestamp.tv_usec,</span>
<span class="p_del">-					&amp;up-&gt;timestamp.tv_usec))</span>
<span class="p_add">+	if (V4L2_TYPE_IS_OUTPUT(type))</span>
<span class="p_add">+		if (assign_in_user(&amp;kp-&gt;bytesused, &amp;up-&gt;bytesused) ||</span>
<span class="p_add">+		    assign_in_user(&amp;kp-&gt;field, &amp;up-&gt;field) ||</span>
<span class="p_add">+		    assign_in_user(&amp;kp-&gt;timestamp.tv_sec,</span>
<span class="p_add">+				   &amp;up-&gt;timestamp.tv_sec) ||</span>
<span class="p_add">+		    assign_in_user(&amp;kp-&gt;timestamp.tv_usec,</span>
<span class="p_add">+				   &amp;up-&gt;timestamp.tv_usec))</span>
 			return -EFAULT;
 
<span class="p_del">-	if (V4L2_TYPE_IS_MULTIPLANAR(kp-&gt;type)) {</span>
<span class="p_del">-		unsigned int num_planes;</span>
<span class="p_add">+	if (V4L2_TYPE_IS_MULTIPLANAR(type)) {</span>
<span class="p_add">+		u32 num_planes = length;</span>
 
<span class="p_del">-		if (kp-&gt;length == 0) {</span>
<span class="p_del">-			kp-&gt;m.planes = NULL;</span>
<span class="p_del">-			/* num_planes == 0 is legal, e.g. when userspace doesn&#39;t</span>
<span class="p_del">-			 * need planes array on DQBUF*/</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-		} else if (kp-&gt;length &gt; VIDEO_MAX_PLANES) {</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+		if (num_planes == 0) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * num_planes == 0 is legal, e.g. when userspace doesn&#39;t</span>
<span class="p_add">+			 * need planes array on DQBUF</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			return put_user(NULL, &amp;kp-&gt;m.planes);</span>
 		}
<span class="p_add">+		if (num_planes &gt; VIDEO_MAX_PLANES)</span>
<span class="p_add">+			return -EINVAL;</span>
 
 		if (get_user(p, &amp;up-&gt;m.planes))
 			return -EFAULT;
 
 		uplane32 = compat_ptr(p);
 		if (!access_ok(VERIFY_READ, uplane32,
<span class="p_del">-				kp-&gt;length * sizeof(struct v4l2_plane32)))</span>
<span class="p_add">+			       num_planes * sizeof(*uplane32)))</span>
 			return -EFAULT;
 
<span class="p_del">-		/* We don&#39;t really care if userspace decides to kill itself</span>
<span class="p_del">-		 * by passing a very big num_planes value */</span>
<span class="p_del">-		uplane = compat_alloc_user_space(kp-&gt;length *</span>
<span class="p_del">-						 sizeof(struct v4l2_plane));</span>
<span class="p_del">-		kp-&gt;m.planes = (__force struct v4l2_plane *)uplane;</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We don&#39;t really care if userspace decides to kill itself</span>
<span class="p_add">+		 * by passing a very big num_planes value</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (aux_space &lt; num_planes * sizeof(*uplane))</span>
<span class="p_add">+			return -EFAULT;</span>
 
<span class="p_del">-		for (num_planes = 0; num_planes &lt; kp-&gt;length; num_planes++) {</span>
<span class="p_del">-			ret = get_v4l2_plane32(uplane, uplane32, kp-&gt;memory);</span>
<span class="p_add">+		uplane = aux_buf;</span>
<span class="p_add">+		if (put_user((__force struct v4l2_plane *)uplane,</span>
<span class="p_add">+			     &amp;kp-&gt;m.planes))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (num_planes--) {</span>
<span class="p_add">+			ret = get_v4l2_plane32(uplane, uplane32, memory);</span>
 			if (ret)
 				return ret;
<span class="p_del">-			++uplane;</span>
<span class="p_del">-			++uplane32;</span>
<span class="p_add">+			uplane++;</span>
<span class="p_add">+			uplane32++;</span>
 		}
 	} else {
<span class="p_del">-		switch (kp-&gt;memory) {</span>
<span class="p_add">+		switch (memory) {</span>
 		case V4L2_MEMORY_MMAP:
<span class="p_del">-			if (get_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
<span class="p_add">+		case V4L2_MEMORY_OVERLAY:</span>
<span class="p_add">+			if (assign_in_user(&amp;kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
 				return -EFAULT;
 			break;
<span class="p_del">-		case V4L2_MEMORY_USERPTR:</span>
<span class="p_del">-			{</span>
<span class="p_del">-			compat_long_t tmp;</span>
<span class="p_add">+		case V4L2_MEMORY_USERPTR: {</span>
<span class="p_add">+			compat_ulong_t userptr;</span>
 
<span class="p_del">-			if (get_user(tmp, &amp;up-&gt;m.userptr))</span>
<span class="p_del">-				return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-			kp-&gt;m.userptr = (unsigned long)compat_ptr(tmp);</span>
<span class="p_del">-			}</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case V4L2_MEMORY_OVERLAY:</span>
<span class="p_del">-			if (get_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
<span class="p_add">+			if (get_user(userptr, &amp;up-&gt;m.userptr) ||</span>
<span class="p_add">+			    put_user((unsigned long)compat_ptr(userptr),</span>
<span class="p_add">+				     &amp;kp-&gt;m.userptr))</span>
 				return -EFAULT;
 			break;
<span class="p_add">+		}</span>
 		case V4L2_MEMORY_DMABUF:
<span class="p_del">-			if (get_user(kp-&gt;m.fd, &amp;up-&gt;m.fd))</span>
<span class="p_add">+			if (assign_in_user(&amp;kp-&gt;m.fd, &amp;up-&gt;m.fd))</span>
 				return -EFAULT;
 			break;
 		}
<span class="p_chunk">@@ -512,65 +578,70 @@</span> <span class="p_context"> static int get_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user</span>
 	return 0;
 }
 
<span class="p_del">-static int put_v4l2_buffer32(struct v4l2_buffer *kp, struct v4l2_buffer32 __user *up)</span>
<span class="p_add">+static int put_v4l2_buffer32(struct v4l2_buffer __user *kp,</span>
<span class="p_add">+			     struct v4l2_buffer32 __user *up)</span>
 {
<span class="p_add">+	u32 type;</span>
<span class="p_add">+	u32 length;</span>
<span class="p_add">+	enum v4l2_memory memory;</span>
 	struct v4l2_plane32 __user *uplane32;
 	struct v4l2_plane __user *uplane;
 	compat_caddr_t p;
<span class="p_del">-	int num_planes;</span>
 	int ret;
 
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_buffer32)) ||</span>
<span class="p_del">-		put_user(kp-&gt;index, &amp;up-&gt;index) ||</span>
<span class="p_del">-		put_user(kp-&gt;type, &amp;up-&gt;type) ||</span>
<span class="p_del">-		put_user(kp-&gt;flags, &amp;up-&gt;flags) ||</span>
<span class="p_del">-		put_user(kp-&gt;memory, &amp;up-&gt;memory))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;index, &amp;kp-&gt;index) ||</span>
<span class="p_add">+	    get_user(type, &amp;kp-&gt;type) ||</span>
<span class="p_add">+	    put_user(type, &amp;up-&gt;type) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;flags, &amp;kp-&gt;flags) ||</span>
<span class="p_add">+	    get_user(memory, &amp;kp-&gt;memory) ||</span>
<span class="p_add">+	    put_user(memory, &amp;up-&gt;memory))</span>
<span class="p_add">+		return -EFAULT;</span>
 
<span class="p_del">-	if (put_user(kp-&gt;bytesused, &amp;up-&gt;bytesused) ||</span>
<span class="p_del">-		put_user(kp-&gt;field, &amp;up-&gt;field) ||</span>
<span class="p_del">-		put_user(kp-&gt;timestamp.tv_sec, &amp;up-&gt;timestamp.tv_sec) ||</span>
<span class="p_del">-		put_user(kp-&gt;timestamp.tv_usec, &amp;up-&gt;timestamp.tv_usec) ||</span>
<span class="p_del">-		copy_to_user(&amp;up-&gt;timecode, &amp;kp-&gt;timecode, sizeof(struct v4l2_timecode)) ||</span>
<span class="p_del">-		put_user(kp-&gt;sequence, &amp;up-&gt;sequence) ||</span>
<span class="p_del">-		put_user(kp-&gt;reserved2, &amp;up-&gt;reserved2) ||</span>
<span class="p_del">-		put_user(kp-&gt;reserved, &amp;up-&gt;reserved) ||</span>
<span class="p_del">-		put_user(kp-&gt;length, &amp;up-&gt;length))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+	if (assign_in_user(&amp;up-&gt;bytesused, &amp;kp-&gt;bytesused) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;field, &amp;kp-&gt;field) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;timestamp.tv_sec, &amp;kp-&gt;timestamp.tv_sec) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;timestamp.tv_usec, &amp;kp-&gt;timestamp.tv_usec) ||</span>
<span class="p_add">+	    copy_in_user(&amp;up-&gt;timecode, &amp;kp-&gt;timecode, sizeof(kp-&gt;timecode)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;sequence, &amp;kp-&gt;sequence) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;reserved2, &amp;kp-&gt;reserved2) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;reserved, &amp;kp-&gt;reserved) ||</span>
<span class="p_add">+	    get_user(length, &amp;kp-&gt;length) ||</span>
<span class="p_add">+	    put_user(length, &amp;up-&gt;length))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (V4L2_TYPE_IS_MULTIPLANAR(type)) {</span>
<span class="p_add">+		u32 num_planes = length;</span>
 
<span class="p_del">-	if (V4L2_TYPE_IS_MULTIPLANAR(kp-&gt;type)) {</span>
<span class="p_del">-		num_planes = kp-&gt;length;</span>
 		if (num_planes == 0)
 			return 0;
 
<span class="p_del">-		uplane = (__force struct v4l2_plane __user *)kp-&gt;m.planes;</span>
<span class="p_add">+		if (get_user(uplane, ((__force struct v4l2_plane __user **)&amp;kp-&gt;m.planes)))</span>
<span class="p_add">+			return -EFAULT;</span>
 		if (get_user(p, &amp;up-&gt;m.planes))
 			return -EFAULT;
 		uplane32 = compat_ptr(p);
 
<span class="p_del">-		while (--num_planes &gt;= 0) {</span>
<span class="p_del">-			ret = put_v4l2_plane32(uplane, uplane32, kp-&gt;memory);</span>
<span class="p_add">+		while (num_planes--) {</span>
<span class="p_add">+			ret = put_v4l2_plane32(uplane, uplane32, memory);</span>
 			if (ret)
 				return ret;
 			++uplane;
 			++uplane32;
 		}
 	} else {
<span class="p_del">-		switch (kp-&gt;memory) {</span>
<span class="p_add">+		switch (memory) {</span>
 		case V4L2_MEMORY_MMAP:
<span class="p_del">-			if (put_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
<span class="p_add">+		case V4L2_MEMORY_OVERLAY:</span>
<span class="p_add">+			if (assign_in_user(&amp;up-&gt;m.offset, &amp;kp-&gt;m.offset))</span>
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_USERPTR:
<span class="p_del">-			if (put_user(kp-&gt;m.userptr, &amp;up-&gt;m.userptr))</span>
<span class="p_del">-				return -EFAULT;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		case V4L2_MEMORY_OVERLAY:</span>
<span class="p_del">-			if (put_user(kp-&gt;m.offset, &amp;up-&gt;m.offset))</span>
<span class="p_add">+			if (assign_in_user(&amp;up-&gt;m.userptr, &amp;kp-&gt;m.userptr))</span>
 				return -EFAULT;
 			break;
 		case V4L2_MEMORY_DMABUF:
<span class="p_del">-			if (put_user(kp-&gt;m.fd, &amp;up-&gt;m.fd))</span>
<span class="p_add">+			if (assign_in_user(&amp;up-&gt;m.fd, &amp;kp-&gt;m.fd))</span>
 				return -EFAULT;
 			break;
 		}
<span class="p_chunk">@@ -595,30 +666,33 @@</span> <span class="p_context"> struct v4l2_framebuffer32 {</span>
 	} fmt;
 };
 
<span class="p_del">-static int get_v4l2_framebuffer32(struct v4l2_framebuffer *kp, struct v4l2_framebuffer32 __user *up)</span>
<span class="p_add">+static int get_v4l2_framebuffer32(struct v4l2_framebuffer __user *kp,</span>
<span class="p_add">+				  struct v4l2_framebuffer32 __user *up)</span>
 {
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_framebuffer32)) ||</span>
<span class="p_del">-		get_user(tmp, &amp;up-&gt;base) ||</span>
<span class="p_del">-		get_user(kp-&gt;capability, &amp;up-&gt;capability) ||</span>
<span class="p_del">-		get_user(kp-&gt;flags, &amp;up-&gt;flags) ||</span>
<span class="p_del">-		copy_from_user(&amp;kp-&gt;fmt, &amp;up-&gt;fmt, sizeof(up-&gt;fmt)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	kp-&gt;base = (__force void *)compat_ptr(tmp);</span>
<span class="p_add">+	compat_caddr_t tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    get_user(tmp, &amp;up-&gt;base) ||</span>
<span class="p_add">+	    put_user((__force void *)compat_ptr(tmp), &amp;kp-&gt;base) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;capability, &amp;up-&gt;capability) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;flags, &amp;up-&gt;flags) ||</span>
<span class="p_add">+	    copy_in_user(&amp;kp-&gt;fmt, &amp;up-&gt;fmt, sizeof(kp-&gt;fmt)))</span>
<span class="p_add">+		return -EFAULT;</span>
 	return 0;
 }
 
<span class="p_del">-static int put_v4l2_framebuffer32(struct v4l2_framebuffer *kp, struct v4l2_framebuffer32 __user *up)</span>
<span class="p_add">+static int put_v4l2_framebuffer32(struct v4l2_framebuffer __user *kp,</span>
<span class="p_add">+				  struct v4l2_framebuffer32 __user *up)</span>
 {
<span class="p_del">-	u32 tmp = (u32)((unsigned long)kp-&gt;base);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_framebuffer32)) ||</span>
<span class="p_del">-		put_user(tmp, &amp;up-&gt;base) ||</span>
<span class="p_del">-		put_user(kp-&gt;capability, &amp;up-&gt;capability) ||</span>
<span class="p_del">-		put_user(kp-&gt;flags, &amp;up-&gt;flags) ||</span>
<span class="p_del">-		copy_to_user(&amp;up-&gt;fmt, &amp;kp-&gt;fmt, sizeof(up-&gt;fmt)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+	void *base;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||</span>
<span class="p_add">+	    get_user(base, &amp;kp-&gt;base) ||</span>
<span class="p_add">+	    put_user(ptr_to_compat(base), &amp;up-&gt;base) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;capability, &amp;kp-&gt;capability) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;flags, &amp;kp-&gt;flags) ||</span>
<span class="p_add">+	    copy_in_user(&amp;up-&gt;fmt, &amp;kp-&gt;fmt, sizeof(kp-&gt;fmt)))</span>
<span class="p_add">+		return -EFAULT;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -634,18 +708,22 @@</span> <span class="p_context"> struct v4l2_input32 {</span>
 	__u32	     reserved[3];
 };
 
<span class="p_del">-/* The 64-bit v4l2_input struct has extra padding at the end of the struct.</span>
<span class="p_del">-   Otherwise it is identical to the 32-bit version. */</span>
<span class="p_del">-static inline int get_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The 64-bit v4l2_input struct has extra padding at the end of the struct.</span>
<span class="p_add">+ * Otherwise it is identical to the 32-bit version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int get_v4l2_input32(struct v4l2_input __user *kp,</span>
<span class="p_add">+				   struct v4l2_input32 __user *up)</span>
 {
<span class="p_del">-	if (copy_from_user(kp, up, sizeof(struct v4l2_input32)))</span>
<span class="p_add">+	if (copy_in_user(kp, up, sizeof(*up)))</span>
 		return -EFAULT;
 	return 0;
 }
 
<span class="p_del">-static inline int put_v4l2_input32(struct v4l2_input *kp, struct v4l2_input32 __user *up)</span>
<span class="p_add">+static inline int put_v4l2_input32(struct v4l2_input __user *kp,</span>
<span class="p_add">+				   struct v4l2_input32 __user *up)</span>
 {
<span class="p_del">-	if (copy_to_user(up, kp, sizeof(struct v4l2_input32)))</span>
<span class="p_add">+	if (copy_in_user(up, kp, sizeof(*up)))</span>
 		return -EFAULT;
 	return 0;
 }
<span class="p_chunk">@@ -669,60 +747,95 @@</span> <span class="p_context"> struct v4l2_ext_control32 {</span>
 	};
 } __attribute__ ((packed));
 
<span class="p_del">-/* The following function really belong in v4l2-common, but that causes</span>
<span class="p_del">-   a circular dependency between modules. We need to think about this, but</span>
<span class="p_del">-   for now this will do. */</span>
<span class="p_del">-</span>
<span class="p_del">-/* Return non-zero if this control is a pointer type. Currently only</span>
<span class="p_del">-   type STRING is a pointer type. */</span>
<span class="p_del">-static inline int ctrl_is_pointer(u32 id)</span>
<span class="p_add">+/* Return true if this control is a pointer type. */</span>
<span class="p_add">+static inline bool ctrl_is_pointer(struct file *file, u32 id)</span>
 {
<span class="p_del">-	switch (id) {</span>
<span class="p_del">-	case V4L2_CID_RDS_TX_PS_NAME:</span>
<span class="p_del">-	case V4L2_CID_RDS_TX_RADIO_TEXT:</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	struct video_device *vdev = video_devdata(file);</span>
<span class="p_add">+	struct v4l2_fh *fh = NULL;</span>
<span class="p_add">+	struct v4l2_ctrl_handler *hdl = NULL;</span>
<span class="p_add">+	struct v4l2_query_ext_ctrl qec = { id };</span>
<span class="p_add">+	const struct v4l2_ioctl_ops *ops = vdev-&gt;ioctl_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (test_bit(V4L2_FL_USES_V4L2_FH, &amp;vdev-&gt;flags))</span>
<span class="p_add">+		fh = file-&gt;private_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fh &amp;&amp; fh-&gt;ctrl_handler)</span>
<span class="p_add">+		hdl = fh-&gt;ctrl_handler;</span>
<span class="p_add">+	else if (vdev-&gt;ctrl_handler)</span>
<span class="p_add">+		hdl = vdev-&gt;ctrl_handler;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (hdl) {</span>
<span class="p_add">+		struct v4l2_ctrl *ctrl = v4l2_ctrl_find(hdl, id);</span>
<span class="p_add">+</span>
<span class="p_add">+		return ctrl &amp;&amp; ctrl-&gt;is_ptr;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!ops || !ops-&gt;vidioc_query_ext_ctrl)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return !ops-&gt;vidioc_query_ext_ctrl(file, fh, &amp;qec) &amp;&amp;</span>
<span class="p_add">+		(qec.flags &amp; V4L2_CTRL_FLAG_HAS_PAYLOAD);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int bufsize_v4l2_ext_controls(struct v4l2_ext_controls32 __user *up,</span>
<span class="p_add">+				     u32 *size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 count;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    get_user(count, &amp;up-&gt;count))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	if (count &gt; V4L2_CID_MAX_CTRLS)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	*size = count * sizeof(struct v4l2_ext_control);</span>
<span class="p_add">+	return 0;</span>
 }
 
<span class="p_del">-static int get_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext_controls32 __user *up)</span>
<span class="p_add">+static int get_v4l2_ext_controls32(struct file *file,</span>
<span class="p_add">+				   struct v4l2_ext_controls __user *kp,</span>
<span class="p_add">+				   struct v4l2_ext_controls32 __user *up,</span>
<span class="p_add">+				   void __user *aux_buf, u32 aux_space)</span>
 {
 	struct v4l2_ext_control32 __user *ucontrols;
 	struct v4l2_ext_control __user *kcontrols;
<span class="p_del">-	unsigned int n;</span>
<span class="p_add">+	u32 count;</span>
<span class="p_add">+	u32 n;</span>
 	compat_caddr_t p;
 
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_ext_controls32)) ||</span>
<span class="p_del">-		get_user(kp-&gt;which, &amp;up-&gt;which) ||</span>
<span class="p_del">-		get_user(kp-&gt;count, &amp;up-&gt;count) ||</span>
<span class="p_del">-		get_user(kp-&gt;error_idx, &amp;up-&gt;error_idx) ||</span>
<span class="p_del">-		copy_from_user(kp-&gt;reserved, up-&gt;reserved,</span>
<span class="p_del">-			       sizeof(kp-&gt;reserved)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	if (kp-&gt;count == 0) {</span>
<span class="p_del">-		kp-&gt;controls = NULL;</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	} else if (kp-&gt;count &gt; V4L2_CID_MAX_CTRLS) {</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;which, &amp;up-&gt;which) ||</span>
<span class="p_add">+	    get_user(count, &amp;up-&gt;count) ||</span>
<span class="p_add">+	    put_user(count, &amp;kp-&gt;count) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;error_idx, &amp;up-&gt;error_idx) ||</span>
<span class="p_add">+	    copy_in_user(kp-&gt;reserved, up-&gt;reserved, sizeof(kp-&gt;reserved)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (count == 0)</span>
<span class="p_add">+		return put_user(NULL, &amp;kp-&gt;controls);</span>
<span class="p_add">+	if (count &gt; V4L2_CID_MAX_CTRLS)</span>
 		return -EINVAL;
<span class="p_del">-	}</span>
 	if (get_user(p, &amp;up-&gt;controls))
 		return -EFAULT;
 	ucontrols = compat_ptr(p);
<span class="p_del">-	if (!access_ok(VERIFY_READ, ucontrols,</span>
<span class="p_del">-			kp-&gt;count * sizeof(struct v4l2_ext_control32)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, ucontrols, count * sizeof(*ucontrols)))</span>
 		return -EFAULT;
<span class="p_del">-	kcontrols = compat_alloc_user_space(kp-&gt;count *</span>
<span class="p_del">-					    sizeof(struct v4l2_ext_control));</span>
<span class="p_del">-	kp-&gt;controls = (__force struct v4l2_ext_control *)kcontrols;</span>
<span class="p_del">-	for (n = 0; n &lt; kp-&gt;count; n++) {</span>
<span class="p_add">+	if (aux_space &lt; count * sizeof(*kcontrols))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	kcontrols = aux_buf;</span>
<span class="p_add">+	if (put_user((__force struct v4l2_ext_control *)kcontrols,</span>
<span class="p_add">+		     &amp;kp-&gt;controls))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (n = 0; n &lt; count; n++) {</span>
 		u32 id;
 
 		if (copy_in_user(kcontrols, ucontrols, sizeof(*ucontrols)))
 			return -EFAULT;
<span class="p_add">+</span>
 		if (get_user(id, &amp;kcontrols-&gt;id))
 			return -EFAULT;
<span class="p_del">-		if (ctrl_is_pointer(id)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ctrl_is_pointer(file, id)) {</span>
 			void __user *s;
 
 			if (get_user(p, &amp;ucontrols-&gt;string))
<span class="p_chunk">@@ -737,43 +850,55 @@</span> <span class="p_context"> static int get_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext</span>
 	return 0;
 }
 
<span class="p_del">-static int put_v4l2_ext_controls32(struct v4l2_ext_controls *kp, struct v4l2_ext_controls32 __user *up)</span>
<span class="p_add">+static int put_v4l2_ext_controls32(struct file *file,</span>
<span class="p_add">+				   struct v4l2_ext_controls __user *kp,</span>
<span class="p_add">+				   struct v4l2_ext_controls32 __user *up)</span>
 {
 	struct v4l2_ext_control32 __user *ucontrols;
<span class="p_del">-	struct v4l2_ext_control __user *kcontrols =</span>
<span class="p_del">-		(__force struct v4l2_ext_control __user *)kp-&gt;controls;</span>
<span class="p_del">-	int n = kp-&gt;count;</span>
<span class="p_add">+	struct v4l2_ext_control __user *kcontrols;</span>
<span class="p_add">+	u32 count;</span>
<span class="p_add">+	u32 n;</span>
 	compat_caddr_t p;
 
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_ext_controls32)) ||</span>
<span class="p_del">-		put_user(kp-&gt;which, &amp;up-&gt;which) ||</span>
<span class="p_del">-		put_user(kp-&gt;count, &amp;up-&gt;count) ||</span>
<span class="p_del">-		put_user(kp-&gt;error_idx, &amp;up-&gt;error_idx) ||</span>
<span class="p_del">-		copy_to_user(up-&gt;reserved, kp-&gt;reserved, sizeof(up-&gt;reserved)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	if (!kp-&gt;count)</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;which, &amp;kp-&gt;which) ||</span>
<span class="p_add">+	    get_user(count, &amp;kp-&gt;count) ||</span>
<span class="p_add">+	    put_user(count, &amp;up-&gt;count) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;error_idx, &amp;kp-&gt;error_idx) ||</span>
<span class="p_add">+	    copy_in_user(up-&gt;reserved, kp-&gt;reserved, sizeof(up-&gt;reserved)) ||</span>
<span class="p_add">+	    get_user(kcontrols, &amp;kp-&gt;controls))</span>
<span class="p_add">+		return -EFAULT;</span>
 
<span class="p_add">+	if (!count)</span>
<span class="p_add">+		return 0;</span>
 	if (get_user(p, &amp;up-&gt;controls))
 		return -EFAULT;
 	ucontrols = compat_ptr(p);
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, ucontrols,</span>
<span class="p_del">-			n * sizeof(struct v4l2_ext_control32)))</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, ucontrols, count * sizeof(*ucontrols)))</span>
 		return -EFAULT;
 
<span class="p_del">-	while (--n &gt;= 0) {</span>
<span class="p_del">-		unsigned size = sizeof(*ucontrols);</span>
<span class="p_add">+	for (n = 0; n &lt; count; n++) {</span>
<span class="p_add">+		unsigned int size = sizeof(*ucontrols);</span>
 		u32 id;
 
<span class="p_del">-		if (get_user(id, &amp;kcontrols-&gt;id))</span>
<span class="p_add">+		if (get_user(id, &amp;kcontrols-&gt;id) ||</span>
<span class="p_add">+		    put_user(id, &amp;ucontrols-&gt;id) ||</span>
<span class="p_add">+		    assign_in_user(&amp;ucontrols-&gt;size, &amp;kcontrols-&gt;size) ||</span>
<span class="p_add">+		    copy_in_user(&amp;ucontrols-&gt;reserved2, &amp;kcontrols-&gt;reserved2,</span>
<span class="p_add">+				 sizeof(ucontrols-&gt;reserved2)))</span>
 			return -EFAULT;
<span class="p_del">-		/* Do not modify the pointer when copying a pointer control.</span>
<span class="p_del">-		   The contents of the pointer was changed, not the pointer</span>
<span class="p_del">-		   itself. */</span>
<span class="p_del">-		if (ctrl_is_pointer(id))</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Do not modify the pointer when copying a pointer control.</span>
<span class="p_add">+		 * The contents of the pointer was changed, not the pointer</span>
<span class="p_add">+		 * itself.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ctrl_is_pointer(file, id))</span>
 			size -= sizeof(ucontrols-&gt;value64);
<span class="p_add">+</span>
 		if (copy_in_user(ucontrols, kcontrols, size))
 			return -EFAULT;
<span class="p_add">+</span>
 		ucontrols++;
 		kcontrols++;
 	}
<span class="p_chunk">@@ -793,18 +918,19 @@</span> <span class="p_context"> struct v4l2_event32 {</span>
 	__u32				reserved[8];
 };
 
<span class="p_del">-static int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *up)</span>
<span class="p_add">+static int put_v4l2_event32(struct v4l2_event __user *kp,</span>
<span class="p_add">+			    struct v4l2_event32 __user *up)</span>
 {
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_event32)) ||</span>
<span class="p_del">-		put_user(kp-&gt;type, &amp;up-&gt;type) ||</span>
<span class="p_del">-		copy_to_user(&amp;up-&gt;u, &amp;kp-&gt;u, sizeof(kp-&gt;u)) ||</span>
<span class="p_del">-		put_user(kp-&gt;pending, &amp;up-&gt;pending) ||</span>
<span class="p_del">-		put_user(kp-&gt;sequence, &amp;up-&gt;sequence) ||</span>
<span class="p_del">-		put_user(kp-&gt;timestamp.tv_sec, &amp;up-&gt;timestamp.tv_sec) ||</span>
<span class="p_del">-		put_user(kp-&gt;timestamp.tv_nsec, &amp;up-&gt;timestamp.tv_nsec) ||</span>
<span class="p_del">-		put_user(kp-&gt;id, &amp;up-&gt;id) ||</span>
<span class="p_del">-		copy_to_user(up-&gt;reserved, kp-&gt;reserved, 8 * sizeof(__u32)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;type, &amp;kp-&gt;type) ||</span>
<span class="p_add">+	    copy_in_user(&amp;up-&gt;u, &amp;kp-&gt;u, sizeof(kp-&gt;u)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;pending, &amp;kp-&gt;pending) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;sequence, &amp;kp-&gt;sequence) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;timestamp.tv_sec, &amp;kp-&gt;timestamp.tv_sec) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;timestamp.tv_nsec, &amp;kp-&gt;timestamp.tv_nsec) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;id, &amp;kp-&gt;id) ||</span>
<span class="p_add">+	    copy_in_user(up-&gt;reserved, kp-&gt;reserved, sizeof(up-&gt;reserved)))</span>
<span class="p_add">+		return -EFAULT;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -816,32 +942,35 @@</span> <span class="p_context"> struct v4l2_edid32 {</span>
 	compat_caddr_t edid;
 };
 
<span class="p_del">-static int get_v4l2_edid32(struct v4l2_edid *kp, struct v4l2_edid32 __user *up)</span>
<span class="p_add">+static int get_v4l2_edid32(struct v4l2_edid __user *kp,</span>
<span class="p_add">+			   struct v4l2_edid32 __user *up)</span>
 {
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!access_ok(VERIFY_READ, up, sizeof(struct v4l2_edid32)) ||</span>
<span class="p_del">-		get_user(kp-&gt;pad, &amp;up-&gt;pad) ||</span>
<span class="p_del">-		get_user(kp-&gt;start_block, &amp;up-&gt;start_block) ||</span>
<span class="p_del">-		get_user(kp-&gt;blocks, &amp;up-&gt;blocks) ||</span>
<span class="p_del">-		get_user(tmp, &amp;up-&gt;edid) ||</span>
<span class="p_del">-		copy_from_user(kp-&gt;reserved, up-&gt;reserved, sizeof(kp-&gt;reserved)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_del">-	kp-&gt;edid = (__force u8 *)compat_ptr(tmp);</span>
<span class="p_add">+	compat_uptr_t tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_READ, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;pad, &amp;up-&gt;pad) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;start_block, &amp;up-&gt;start_block) ||</span>
<span class="p_add">+	    assign_in_user(&amp;kp-&gt;blocks, &amp;up-&gt;blocks) ||</span>
<span class="p_add">+	    get_user(tmp, &amp;up-&gt;edid) ||</span>
<span class="p_add">+	    put_user(compat_ptr(tmp), &amp;kp-&gt;edid) ||</span>
<span class="p_add">+	    copy_in_user(kp-&gt;reserved, up-&gt;reserved, sizeof(kp-&gt;reserved)))</span>
<span class="p_add">+		return -EFAULT;</span>
 	return 0;
 }
 
<span class="p_del">-static int put_v4l2_edid32(struct v4l2_edid *kp, struct v4l2_edid32 __user *up)</span>
<span class="p_add">+static int put_v4l2_edid32(struct v4l2_edid __user *kp,</span>
<span class="p_add">+			   struct v4l2_edid32 __user *up)</span>
 {
<span class="p_del">-	u32 tmp = (u32)((unsigned long)kp-&gt;edid);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!access_ok(VERIFY_WRITE, up, sizeof(struct v4l2_edid32)) ||</span>
<span class="p_del">-		put_user(kp-&gt;pad, &amp;up-&gt;pad) ||</span>
<span class="p_del">-		put_user(kp-&gt;start_block, &amp;up-&gt;start_block) ||</span>
<span class="p_del">-		put_user(kp-&gt;blocks, &amp;up-&gt;blocks) ||</span>
<span class="p_del">-		put_user(tmp, &amp;up-&gt;edid) ||</span>
<span class="p_del">-		copy_to_user(up-&gt;reserved, kp-&gt;reserved, sizeof(up-&gt;reserved)))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+	void *edid;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, up, sizeof(*up)) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;pad, &amp;kp-&gt;pad) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;start_block, &amp;kp-&gt;start_block) ||</span>
<span class="p_add">+	    assign_in_user(&amp;up-&gt;blocks, &amp;kp-&gt;blocks) ||</span>
<span class="p_add">+	    get_user(edid, &amp;kp-&gt;edid) ||</span>
<span class="p_add">+	    put_user(ptr_to_compat(edid), &amp;up-&gt;edid) ||</span>
<span class="p_add">+	    copy_in_user(up-&gt;reserved, kp-&gt;reserved, sizeof(up-&gt;reserved)))</span>
<span class="p_add">+		return -EFAULT;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -873,22 +1002,23 @@</span> <span class="p_context"> static int put_v4l2_edid32(struct v4l2_edid *kp, struct v4l2_edid32 __user *up)</span>
 #define VIDIOC_G_OUTPUT32	_IOR (&#39;V&#39;, 46, s32)
 #define VIDIOC_S_OUTPUT32	_IOWR(&#39;V&#39;, 47, s32)
 
<span class="p_add">+static int alloc_userspace(unsigned int size, u32 aux_space,</span>
<span class="p_add">+			   void __user **up_native)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*up_native = compat_alloc_user_space(size + aux_space);</span>
<span class="p_add">+	if (!*up_native)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	if (clear_user(*up_native, size))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
<span class="p_del">-	union {</span>
<span class="p_del">-		struct v4l2_format v2f;</span>
<span class="p_del">-		struct v4l2_buffer v2b;</span>
<span class="p_del">-		struct v4l2_framebuffer v2fb;</span>
<span class="p_del">-		struct v4l2_input v2i;</span>
<span class="p_del">-		struct v4l2_standard v2s;</span>
<span class="p_del">-		struct v4l2_ext_controls v2ecs;</span>
<span class="p_del">-		struct v4l2_event v2ev;</span>
<span class="p_del">-		struct v4l2_create_buffers v2crt;</span>
<span class="p_del">-		struct v4l2_edid v2edid;</span>
<span class="p_del">-		unsigned long vx;</span>
<span class="p_del">-		int vi;</span>
<span class="p_del">-	} karg;</span>
 	void __user *up = compat_ptr(arg);
<span class="p_add">+	void __user *up_native = NULL;</span>
<span class="p_add">+	void __user *aux_buf;</span>
<span class="p_add">+	u32 aux_space;</span>
 	int compatible_arg = 1;
 	long err = 0;
 
<span class="p_chunk">@@ -927,30 +1057,52 @@</span> <span class="p_context"> static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar</span>
 	case VIDIOC_STREAMOFF:
 	case VIDIOC_S_INPUT:
 	case VIDIOC_S_OUTPUT:
<span class="p_del">-		err = get_user(karg.vi, (s32 __user *)up);</span>
<span class="p_add">+		err = alloc_userspace(sizeof(unsigned int), 0, &amp;up_native);</span>
<span class="p_add">+		if (!err &amp;&amp; assign_in_user((unsigned int __user *)up_native,</span>
<span class="p_add">+					   (compat_uint_t __user *)up))</span>
<span class="p_add">+			err = -EFAULT;</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_G_INPUT:
 	case VIDIOC_G_OUTPUT:
<span class="p_add">+		err = alloc_userspace(sizeof(unsigned int), 0, &amp;up_native);</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_G_EDID:
 	case VIDIOC_S_EDID:
<span class="p_del">-		err = get_v4l2_edid32(&amp;karg.v2edid, up);</span>
<span class="p_add">+		err = alloc_userspace(sizeof(struct v4l2_edid), 0, &amp;up_native);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = get_v4l2_edid32(up_native, up);</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_G_FMT:
 	case VIDIOC_S_FMT:
 	case VIDIOC_TRY_FMT:
<span class="p_del">-		err = get_v4l2_format32(&amp;karg.v2f, up);</span>
<span class="p_add">+		err = bufsize_v4l2_format(up, &amp;aux_space);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = alloc_userspace(sizeof(struct v4l2_format),</span>
<span class="p_add">+					      aux_space, &amp;up_native);</span>
<span class="p_add">+		if (!err) {</span>
<span class="p_add">+			aux_buf = up_native + sizeof(struct v4l2_format);</span>
<span class="p_add">+			err = get_v4l2_format32(up_native, up,</span>
<span class="p_add">+						aux_buf, aux_space);</span>
<span class="p_add">+		}</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_CREATE_BUFS:
<span class="p_del">-		err = get_v4l2_create32(&amp;karg.v2crt, up);</span>
<span class="p_add">+		err = bufsize_v4l2_create(up, &amp;aux_space);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = alloc_userspace(sizeof(struct v4l2_create_buffers),</span>
<span class="p_add">+					      aux_space, &amp;up_native);</span>
<span class="p_add">+		if (!err) {</span>
<span class="p_add">+			aux_buf = up_native + sizeof(struct v4l2_create_buffers);</span>
<span class="p_add">+			err = get_v4l2_create32(up_native, up,</span>
<span class="p_add">+						aux_buf, aux_space);</span>
<span class="p_add">+		}</span>
 		compatible_arg = 0;
 		break;
 
<span class="p_chunk">@@ -958,36 +1110,63 @@</span> <span class="p_context"> static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar</span>
 	case VIDIOC_QUERYBUF:
 	case VIDIOC_QBUF:
 	case VIDIOC_DQBUF:
<span class="p_del">-		err = get_v4l2_buffer32(&amp;karg.v2b, up);</span>
<span class="p_add">+		err = bufsize_v4l2_buffer(up, &amp;aux_space);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = alloc_userspace(sizeof(struct v4l2_buffer),</span>
<span class="p_add">+					      aux_space, &amp;up_native);</span>
<span class="p_add">+		if (!err) {</span>
<span class="p_add">+			aux_buf = up_native + sizeof(struct v4l2_buffer);</span>
<span class="p_add">+			err = get_v4l2_buffer32(up_native, up,</span>
<span class="p_add">+						aux_buf, aux_space);</span>
<span class="p_add">+		}</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_S_FBUF:
<span class="p_del">-		err = get_v4l2_framebuffer32(&amp;karg.v2fb, up);</span>
<span class="p_add">+		err = alloc_userspace(sizeof(struct v4l2_framebuffer), 0,</span>
<span class="p_add">+				      &amp;up_native);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = get_v4l2_framebuffer32(up_native, up);</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_G_FBUF:
<span class="p_add">+		err = alloc_userspace(sizeof(struct v4l2_framebuffer), 0,</span>
<span class="p_add">+				      &amp;up_native);</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_ENUMSTD:
<span class="p_del">-		err = get_v4l2_standard32(&amp;karg.v2s, up);</span>
<span class="p_add">+		err = alloc_userspace(sizeof(struct v4l2_standard), 0,</span>
<span class="p_add">+				      &amp;up_native);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = get_v4l2_standard32(up_native, up);</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_ENUMINPUT:
<span class="p_del">-		err = get_v4l2_input32(&amp;karg.v2i, up);</span>
<span class="p_add">+		err = alloc_userspace(sizeof(struct v4l2_input), 0, &amp;up_native);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = get_v4l2_input32(up_native, up);</span>
 		compatible_arg = 0;
 		break;
 
 	case VIDIOC_G_EXT_CTRLS:
 	case VIDIOC_S_EXT_CTRLS:
 	case VIDIOC_TRY_EXT_CTRLS:
<span class="p_del">-		err = get_v4l2_ext_controls32(&amp;karg.v2ecs, up);</span>
<span class="p_add">+		err = bufsize_v4l2_ext_controls(up, &amp;aux_space);</span>
<span class="p_add">+		if (!err)</span>
<span class="p_add">+			err = alloc_userspace(sizeof(struct v4l2_ext_controls),</span>
<span class="p_add">+					      aux_space, &amp;up_native);</span>
<span class="p_add">+		if (!err) {</span>
<span class="p_add">+			aux_buf = up_native + sizeof(struct v4l2_ext_controls);</span>
<span class="p_add">+			err = get_v4l2_ext_controls32(file, up_native, up,</span>
<span class="p_add">+						      aux_buf, aux_space);</span>
<span class="p_add">+		}</span>
 		compatible_arg = 0;
 		break;
 	case VIDIOC_DQEVENT:
<span class="p_add">+		err = alloc_userspace(sizeof(struct v4l2_event), 0, &amp;up_native);</span>
 		compatible_arg = 0;
 		break;
 	}
<span class="p_chunk">@@ -996,26 +1175,26 @@</span> <span class="p_context"> static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar</span>
 
 	if (compatible_arg)
 		err = native_ioctl(file, cmd, (unsigned long)up);
<span class="p_del">-	else {</span>
<span class="p_del">-		mm_segment_t old_fs = get_fs();</span>
<span class="p_add">+	else</span>
<span class="p_add">+		err = native_ioctl(file, cmd, (unsigned long)up_native);</span>
 
<span class="p_del">-		set_fs(KERNEL_DS);</span>
<span class="p_del">-		err = native_ioctl(file, cmd, (unsigned long)&amp;karg);</span>
<span class="p_del">-		set_fs(old_fs);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err == -ENOTTY)</span>
<span class="p_add">+		return err;</span>
 
<span class="p_del">-	/* Special case: even after an error we need to put the</span>
<span class="p_del">-	   results back for these ioctls since the error_idx will</span>
<span class="p_del">-	   contain information on which control failed. */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Special case: even after an error we need to put the</span>
<span class="p_add">+	 * results back for these ioctls since the error_idx will</span>
<span class="p_add">+	 * contain information on which control failed.</span>
<span class="p_add">+	 */</span>
 	switch (cmd) {
 	case VIDIOC_G_EXT_CTRLS:
 	case VIDIOC_S_EXT_CTRLS:
 	case VIDIOC_TRY_EXT_CTRLS:
<span class="p_del">-		if (put_v4l2_ext_controls32(&amp;karg.v2ecs, up))</span>
<span class="p_add">+		if (put_v4l2_ext_controls32(file, up_native, up))</span>
 			err = -EFAULT;
 		break;
 	case VIDIOC_S_EDID:
<span class="p_del">-		if (put_v4l2_edid32(&amp;karg.v2edid, up))</span>
<span class="p_add">+		if (put_v4l2_edid32(up_native, up))</span>
 			err = -EFAULT;
 		break;
 	}
<span class="p_chunk">@@ -1027,43 +1206,46 @@</span> <span class="p_context"> static long do_video_ioctl(struct file *file, unsigned int cmd, unsigned long ar</span>
 	case VIDIOC_S_OUTPUT:
 	case VIDIOC_G_INPUT:
 	case VIDIOC_G_OUTPUT:
<span class="p_del">-		err = put_user(((s32)karg.vi), (s32 __user *)up);</span>
<span class="p_add">+		if (assign_in_user((compat_uint_t __user *)up,</span>
<span class="p_add">+				   ((unsigned int __user *)up_native)))</span>
<span class="p_add">+			err = -EFAULT;</span>
 		break;
 
 	case VIDIOC_G_FBUF:
<span class="p_del">-		err = put_v4l2_framebuffer32(&amp;karg.v2fb, up);</span>
<span class="p_add">+		err = put_v4l2_framebuffer32(up_native, up);</span>
 		break;
 
 	case VIDIOC_DQEVENT:
<span class="p_del">-		err = put_v4l2_event32(&amp;karg.v2ev, up);</span>
<span class="p_add">+		err = put_v4l2_event32(up_native, up);</span>
 		break;
 
 	case VIDIOC_G_EDID:
<span class="p_del">-		err = put_v4l2_edid32(&amp;karg.v2edid, up);</span>
<span class="p_add">+		err = put_v4l2_edid32(up_native, up);</span>
 		break;
 
 	case VIDIOC_G_FMT:
 	case VIDIOC_S_FMT:
 	case VIDIOC_TRY_FMT:
<span class="p_del">-		err = put_v4l2_format32(&amp;karg.v2f, up);</span>
<span class="p_add">+		err = put_v4l2_format32(up_native, up);</span>
 		break;
 
 	case VIDIOC_CREATE_BUFS:
<span class="p_del">-		err = put_v4l2_create32(&amp;karg.v2crt, up);</span>
<span class="p_add">+		err = put_v4l2_create32(up_native, up);</span>
 		break;
 
<span class="p_add">+	case VIDIOC_PREPARE_BUF:</span>
 	case VIDIOC_QUERYBUF:
 	case VIDIOC_QBUF:
 	case VIDIOC_DQBUF:
<span class="p_del">-		err = put_v4l2_buffer32(&amp;karg.v2b, up);</span>
<span class="p_add">+		err = put_v4l2_buffer32(up_native, up);</span>
 		break;
 
 	case VIDIOC_ENUMSTD:
<span class="p_del">-		err = put_v4l2_standard32(&amp;karg.v2s, up);</span>
<span class="p_add">+		err = put_v4l2_standard32(up_native, up);</span>
 		break;
 
 	case VIDIOC_ENUMINPUT:
<span class="p_del">-		err = put_v4l2_input32(&amp;karg.v2i, up);</span>
<span class="p_add">+		err = put_v4l2_input32(up_native, up);</span>
 		break;
 	}
 	return err;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-ioctl.c b/drivers/media/v4l2-core/v4l2-ioctl.c</span>
<span class="p_header">index b60a6b0841d1..d06941cc6a55 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-ioctl.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-ioctl.c</span>
<span class="p_chunk">@@ -1308,52 +1308,50 @@</span> <span class="p_context"> static int v4l_enum_fmt(const struct v4l2_ioctl_ops *ops,</span>
 				struct file *file, void *fh, void *arg)
 {
 	struct v4l2_fmtdesc *p = arg;
<span class="p_del">-	struct video_device *vfd = video_devdata(file);</span>
<span class="p_del">-	bool is_vid = vfd-&gt;vfl_type == VFL_TYPE_GRABBER;</span>
<span class="p_del">-	bool is_sdr = vfd-&gt;vfl_type == VFL_TYPE_SDR;</span>
<span class="p_del">-	bool is_tch = vfd-&gt;vfl_type == VFL_TYPE_TOUCH;</span>
<span class="p_del">-	bool is_rx = vfd-&gt;vfl_dir != VFL_DIR_TX;</span>
<span class="p_del">-	bool is_tx = vfd-&gt;vfl_dir != VFL_DIR_RX;</span>
<span class="p_del">-	int ret = -EINVAL;</span>
<span class="p_add">+	int ret = check_fmt(file, p-&gt;type);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	ret = -EINVAL;</span>
 
 	switch (p-&gt;type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || (!is_vid &amp;&amp; !is_tch) || !ops-&gt;vidioc_enum_fmt_vid_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_vid_cap))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_vid_cap(file, fh, arg);
 		break;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_enum_fmt_vid_cap_mplane))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_vid_cap_mplane))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_vid_cap_mplane(file, fh, arg);
 		break;
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_enum_fmt_vid_overlay))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_vid_overlay))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_vid_overlay(file, fh, arg);
 		break;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_enum_fmt_vid_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_vid_out))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_vid_out(file, fh, arg);
 		break;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_enum_fmt_vid_out_mplane))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_vid_out_mplane))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_vid_out_mplane(file, fh, arg);
 		break;
 	case V4L2_BUF_TYPE_SDR_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_sdr || !ops-&gt;vidioc_enum_fmt_sdr_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_sdr_cap))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_sdr_cap(file, fh, arg);
 		break;
 	case V4L2_BUF_TYPE_SDR_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_sdr || !ops-&gt;vidioc_enum_fmt_sdr_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_sdr_out))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_sdr_out(file, fh, arg);
 		break;
 	case V4L2_BUF_TYPE_META_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_enum_fmt_meta_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_enum_fmt_meta_cap))</span>
 			break;
 		ret = ops-&gt;vidioc_enum_fmt_meta_cap(file, fh, arg);
 		break;
<span class="p_chunk">@@ -1367,13 +1365,10 @@</span> <span class="p_context"> static int v4l_g_fmt(const struct v4l2_ioctl_ops *ops,</span>
 				struct file *file, void *fh, void *arg)
 {
 	struct v4l2_format *p = arg;
<span class="p_del">-	struct video_device *vfd = video_devdata(file);</span>
<span class="p_del">-	bool is_vid = vfd-&gt;vfl_type == VFL_TYPE_GRABBER;</span>
<span class="p_del">-	bool is_sdr = vfd-&gt;vfl_type == VFL_TYPE_SDR;</span>
<span class="p_del">-	bool is_tch = vfd-&gt;vfl_type == VFL_TYPE_TOUCH;</span>
<span class="p_del">-	bool is_rx = vfd-&gt;vfl_dir != VFL_DIR_TX;</span>
<span class="p_del">-	bool is_tx = vfd-&gt;vfl_dir != VFL_DIR_RX;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = check_fmt(file, p-&gt;type);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	/*
 	 * fmt can&#39;t be cleared for these overlay types due to the &#39;clips&#39;
<span class="p_chunk">@@ -1401,7 +1396,7 @@</span> <span class="p_context"> static int v4l_g_fmt(const struct v4l2_ioctl_ops *ops,</span>
 
 	switch (p-&gt;type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || (!is_vid &amp;&amp; !is_tch) || !ops-&gt;vidioc_g_fmt_vid_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_g_fmt_vid_cap))</span>
 			break;
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
 		ret = ops-&gt;vidioc_g_fmt_vid_cap(file, fh, arg);
<span class="p_chunk">@@ -1409,23 +1404,15 @@</span> <span class="p_context"> static int v4l_g_fmt(const struct v4l2_ioctl_ops *ops,</span>
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_g_fmt_vid_cap_mplane))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_vid_cap_mplane(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_g_fmt_vid_overlay))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_vid_overlay(file, fh, arg);
 	case V4L2_BUF_TYPE_VBI_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || is_vid || !ops-&gt;vidioc_g_fmt_vbi_cap))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || is_vid || !ops-&gt;vidioc_g_fmt_sliced_vbi_cap))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_sliced_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_g_fmt_vid_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_g_fmt_vid_out))</span>
 			break;
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
 		ret = ops-&gt;vidioc_g_fmt_vid_out(file, fh, arg);
<span class="p_chunk">@@ -1433,32 +1420,18 @@</span> <span class="p_context"> static int v4l_g_fmt(const struct v4l2_ioctl_ops *ops,</span>
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_g_fmt_vid_out_mplane))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_vid_out_mplane(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_g_fmt_vid_out_overlay))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_vid_out_overlay(file, fh, arg);
 	case V4L2_BUF_TYPE_VBI_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || is_vid || !ops-&gt;vidioc_g_fmt_vbi_out))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_vbi_out(file, fh, arg);
 	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || is_vid || !ops-&gt;vidioc_g_fmt_sliced_vbi_out))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_sliced_vbi_out(file, fh, arg);
 	case V4L2_BUF_TYPE_SDR_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_sdr || !ops-&gt;vidioc_g_fmt_sdr_cap))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_sdr_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_SDR_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_sdr || !ops-&gt;vidioc_g_fmt_sdr_out))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_sdr_out(file, fh, arg);
 	case V4L2_BUF_TYPE_META_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_g_fmt_meta_cap))</span>
<span class="p_del">-			break;</span>
 		return ops-&gt;vidioc_g_fmt_meta_cap(file, fh, arg);
 	}
 	return -EINVAL;
<span class="p_chunk">@@ -1484,12 +1457,10 @@</span> <span class="p_context"> static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,</span>
 {
 	struct v4l2_format *p = arg;
 	struct video_device *vfd = video_devdata(file);
<span class="p_del">-	bool is_vid = vfd-&gt;vfl_type == VFL_TYPE_GRABBER;</span>
<span class="p_del">-	bool is_sdr = vfd-&gt;vfl_type == VFL_TYPE_SDR;</span>
<span class="p_del">-	bool is_tch = vfd-&gt;vfl_type == VFL_TYPE_TOUCH;</span>
<span class="p_del">-	bool is_rx = vfd-&gt;vfl_dir != VFL_DIR_TX;</span>
<span class="p_del">-	bool is_tx = vfd-&gt;vfl_dir != VFL_DIR_RX;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = check_fmt(file, p-&gt;type);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	ret = v4l_enable_media_source(vfd);
 	if (ret)
<span class="p_chunk">@@ -1498,37 +1469,37 @@</span> <span class="p_context"> static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,</span>
 
 	switch (p-&gt;type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || (!is_vid &amp;&amp; !is_tch) || !ops-&gt;vidioc_s_fmt_vid_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vid_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix);
 		ret = ops-&gt;vidioc_s_fmt_vid_cap(file, fh, arg);
 		/* just in case the driver zeroed it again */
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
<span class="p_del">-		if (is_tch)</span>
<span class="p_add">+		if (vfd-&gt;vfl_type == VFL_TYPE_TOUCH)</span>
 			v4l_pix_format_touch(&amp;p-&gt;fmt.pix);
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_s_fmt_vid_cap_mplane))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vid_cap_mplane))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);
 		return ops-&gt;vidioc_s_fmt_vid_cap_mplane(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_s_fmt_vid_overlay))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vid_overlay))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.win);
 		return ops-&gt;vidioc_s_fmt_vid_overlay(file, fh, arg);
 	case V4L2_BUF_TYPE_VBI_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || is_vid || !ops-&gt;vidioc_s_fmt_vbi_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vbi_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.vbi);
 		return ops-&gt;vidioc_s_fmt_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || is_vid || !ops-&gt;vidioc_s_fmt_sliced_vbi_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_sliced_vbi_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sliced);
 		return ops-&gt;vidioc_s_fmt_sliced_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_s_fmt_vid_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vid_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix);
 		ret = ops-&gt;vidioc_s_fmt_vid_out(file, fh, arg);
<span class="p_chunk">@@ -1536,37 +1507,37 @@</span> <span class="p_context"> static int v4l_s_fmt(const struct v4l2_ioctl_ops *ops,</span>
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_s_fmt_vid_out_mplane))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vid_out_mplane))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);
 		return ops-&gt;vidioc_s_fmt_vid_out_mplane(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_s_fmt_vid_out_overlay))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vid_out_overlay))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.win);
 		return ops-&gt;vidioc_s_fmt_vid_out_overlay(file, fh, arg);
 	case V4L2_BUF_TYPE_VBI_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || is_vid || !ops-&gt;vidioc_s_fmt_vbi_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_vbi_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.vbi);
 		return ops-&gt;vidioc_s_fmt_vbi_out(file, fh, arg);
 	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || is_vid || !ops-&gt;vidioc_s_fmt_sliced_vbi_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_sliced_vbi_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sliced);
 		return ops-&gt;vidioc_s_fmt_sliced_vbi_out(file, fh, arg);
 	case V4L2_BUF_TYPE_SDR_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_sdr || !ops-&gt;vidioc_s_fmt_sdr_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_sdr_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sdr);
 		return ops-&gt;vidioc_s_fmt_sdr_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_SDR_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_sdr || !ops-&gt;vidioc_s_fmt_sdr_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_sdr_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sdr);
 		return ops-&gt;vidioc_s_fmt_sdr_out(file, fh, arg);
 	case V4L2_BUF_TYPE_META_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_s_fmt_meta_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_s_fmt_meta_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.meta);
 		return ops-&gt;vidioc_s_fmt_meta_cap(file, fh, arg);
<span class="p_chunk">@@ -1578,19 +1549,16 @@</span> <span class="p_context"> static int v4l_try_fmt(const struct v4l2_ioctl_ops *ops,</span>
 				struct file *file, void *fh, void *arg)
 {
 	struct v4l2_format *p = arg;
<span class="p_del">-	struct video_device *vfd = video_devdata(file);</span>
<span class="p_del">-	bool is_vid = vfd-&gt;vfl_type == VFL_TYPE_GRABBER;</span>
<span class="p_del">-	bool is_sdr = vfd-&gt;vfl_type == VFL_TYPE_SDR;</span>
<span class="p_del">-	bool is_tch = vfd-&gt;vfl_type == VFL_TYPE_TOUCH;</span>
<span class="p_del">-	bool is_rx = vfd-&gt;vfl_dir != VFL_DIR_TX;</span>
<span class="p_del">-	bool is_tx = vfd-&gt;vfl_dir != VFL_DIR_RX;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = check_fmt(file, p-&gt;type);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	v4l_sanitize_format(p);
 
 	switch (p-&gt;type) {
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || (!is_vid &amp;&amp; !is_tch) || !ops-&gt;vidioc_try_fmt_vid_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vid_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix);
 		ret = ops-&gt;vidioc_try_fmt_vid_cap(file, fh, arg);
<span class="p_chunk">@@ -1598,27 +1566,27 @@</span> <span class="p_context"> static int v4l_try_fmt(const struct v4l2_ioctl_ops *ops,</span>
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_try_fmt_vid_cap_mplane))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vid_cap_mplane))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);
 		return ops-&gt;vidioc_try_fmt_vid_cap_mplane(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OVERLAY:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_try_fmt_vid_overlay))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vid_overlay))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.win);
 		return ops-&gt;vidioc_try_fmt_vid_overlay(file, fh, arg);
 	case V4L2_BUF_TYPE_VBI_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || is_vid || !ops-&gt;vidioc_try_fmt_vbi_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vbi_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.vbi);
 		return ops-&gt;vidioc_try_fmt_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_SLICED_VBI_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || is_vid || !ops-&gt;vidioc_try_fmt_sliced_vbi_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_sliced_vbi_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sliced);
 		return ops-&gt;vidioc_try_fmt_sliced_vbi_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_try_fmt_vid_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vid_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix);
 		ret = ops-&gt;vidioc_try_fmt_vid_out(file, fh, arg);
<span class="p_chunk">@@ -1626,37 +1594,37 @@</span> <span class="p_context"> static int v4l_try_fmt(const struct v4l2_ioctl_ops *ops,</span>
 		p-&gt;fmt.pix.priv = V4L2_PIX_FMT_PRIV_MAGIC;
 		return ret;
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_try_fmt_vid_out_mplane))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vid_out_mplane))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.pix_mp.xfer_func);
 		return ops-&gt;vidioc_try_fmt_vid_out_mplane(file, fh, arg);
 	case V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY:
<span class="p_del">-		if (unlikely(!is_tx || !is_vid || !ops-&gt;vidioc_try_fmt_vid_out_overlay))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vid_out_overlay))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.win);
 		return ops-&gt;vidioc_try_fmt_vid_out_overlay(file, fh, arg);
 	case V4L2_BUF_TYPE_VBI_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || is_vid || !ops-&gt;vidioc_try_fmt_vbi_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_vbi_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.vbi);
 		return ops-&gt;vidioc_try_fmt_vbi_out(file, fh, arg);
 	case V4L2_BUF_TYPE_SLICED_VBI_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || is_vid || !ops-&gt;vidioc_try_fmt_sliced_vbi_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_sliced_vbi_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sliced);
 		return ops-&gt;vidioc_try_fmt_sliced_vbi_out(file, fh, arg);
 	case V4L2_BUF_TYPE_SDR_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_sdr || !ops-&gt;vidioc_try_fmt_sdr_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_sdr_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sdr);
 		return ops-&gt;vidioc_try_fmt_sdr_cap(file, fh, arg);
 	case V4L2_BUF_TYPE_SDR_OUTPUT:
<span class="p_del">-		if (unlikely(!is_tx || !is_sdr || !ops-&gt;vidioc_try_fmt_sdr_out))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_sdr_out))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.sdr);
 		return ops-&gt;vidioc_try_fmt_sdr_out(file, fh, arg);
 	case V4L2_BUF_TYPE_META_CAPTURE:
<span class="p_del">-		if (unlikely(!is_rx || !is_vid || !ops-&gt;vidioc_try_fmt_meta_cap))</span>
<span class="p_add">+		if (unlikely(!ops-&gt;vidioc_try_fmt_meta_cap))</span>
 			break;
 		CLEAR_AFTER_FIELD(p, fmt.meta);
 		return ops-&gt;vidioc_try_fmt_meta_cap(file, fh, arg);
<span class="p_chunk">@@ -2924,8 +2892,11 @@</span> <span class="p_context"> video_usercopy(struct file *file, unsigned int cmd, unsigned long arg,</span>
 
 	/* Handles IOCTL */
 	err = func(file, cmd, parg);
<span class="p_del">-	if (err == -ENOIOCTLCMD)</span>
<span class="p_add">+	if (err == -ENOTTY || err == -ENOIOCTLCMD) {</span>
 		err = -ENOTTY;
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (err == 0) {
 		if (cmd == VIDIOC_DQBUF)
 			trace_v4l2_dqbuf(video_devdata(file)-&gt;minor, parg);
<span class="p_header">diff --git a/drivers/mtd/nand/brcmnand/brcmnand.c b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">index e0eb51d8c012..edf24c148fa6 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/brcmnand/brcmnand.c</span>
<span class="p_chunk">@@ -2193,16 +2193,9 @@</span> <span class="p_context"> static int brcmnand_setup_dev(struct brcmnand_host *host)</span>
 	if (ctrl-&gt;nand_version &gt;= 0x0702)
 		tmp |= ACC_CONTROL_RD_ERASED;
 	tmp &amp;= ~ACC_CONTROL_FAST_PGM_RDIN;
<span class="p_del">-	if (ctrl-&gt;features &amp; BRCMNAND_HAS_PREFETCH) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * FIXME: Flash DMA + prefetch may see spurious erased-page ECC</span>
<span class="p_del">-		 * errors</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (has_flash_dma(ctrl))</span>
<span class="p_del">-			tmp &amp;= ~ACC_CONTROL_PREFETCH;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			tmp |= ACC_CONTROL_PREFETCH;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (ctrl-&gt;features &amp; BRCMNAND_HAS_PREFETCH)</span>
<span class="p_add">+		tmp &amp;= ~ACC_CONTROL_PREFETCH;</span>
<span class="p_add">+</span>
 	nand_writereg(ctrl, offs, tmp);
 
 	return 0;
<span class="p_header">diff --git a/drivers/mtd/nand/nand_base.c b/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">index 3f1d806e590a..a0b0302aea14 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/nand_base.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/nand_base.c</span>
<span class="p_chunk">@@ -2201,6 +2201,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(nand_write_oob_syndrome);</span>
 static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,
 			    struct mtd_oob_ops *ops)
 {
<span class="p_add">+	unsigned int max_bitflips = 0;</span>
 	int page, realpage, chipnr;
 	struct nand_chip *chip = mtd_to_nand(mtd);
 	struct mtd_ecc_stats stats;
<span class="p_chunk">@@ -2258,6 +2259,8 @@</span> <span class="p_context"> static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,</span>
 				nand_wait_ready(mtd);
 		}
 
<span class="p_add">+		max_bitflips = max_t(unsigned int, max_bitflips, ret);</span>
<span class="p_add">+</span>
 		readlen -= len;
 		if (!readlen)
 			break;
<span class="p_chunk">@@ -2283,7 +2286,7 @@</span> <span class="p_context"> static int nand_do_read_oob(struct mtd_info *mtd, loff_t from,</span>
 	if (mtd-&gt;ecc_stats.failed - stats.failed)
 		return -EBADMSG;
 
<span class="p_del">-	return  mtd-&gt;ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;</span>
<span class="p_add">+	return max_bitflips;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/mtd/nand/sunxi_nand.c b/drivers/mtd/nand/sunxi_nand.c</span>
<span class="p_header">index 82244be3e766..958974821582 100644</span>
<span class="p_header">--- a/drivers/mtd/nand/sunxi_nand.c</span>
<span class="p_header">+++ b/drivers/mtd/nand/sunxi_nand.c</span>
<span class="p_chunk">@@ -1853,8 +1853,14 @@</span> <span class="p_context"> static int sunxi_nand_hw_common_ecc_ctrl_init(struct mtd_info *mtd,</span>
 
 	/* Add ECC info retrieval from DT */
 	for (i = 0; i &lt; ARRAY_SIZE(strengths); i++) {
<span class="p_del">-		if (ecc-&gt;strength &lt;= strengths[i])</span>
<span class="p_add">+		if (ecc-&gt;strength &lt;= strengths[i]) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Update ecc-&gt;strength value with the actual strength</span>
<span class="p_add">+			 * that will be used by the ECC engine.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			ecc-&gt;strength = strengths[i];</span>
 			break;
<span class="p_add">+		}</span>
 	}
 
 	if (i &gt;= ARRAY_SIZE(strengths)) {
<span class="p_header">diff --git a/drivers/mtd/ubi/block.c b/drivers/mtd/ubi/block.c</span>
<span class="p_header">index b210fdb31c98..b1fc28f63882 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/block.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/block.c</span>
<span class="p_chunk">@@ -99,6 +99,8 @@</span> <span class="p_context"> struct ubiblock {</span>
 
 /* Linked list of all ubiblock instances */
 static LIST_HEAD(ubiblock_devices);
<span class="p_add">+static DEFINE_IDR(ubiblock_minor_idr);</span>
<span class="p_add">+/* Protects ubiblock_devices and ubiblock_minor_idr */</span>
 static DEFINE_MUTEX(devices_mutex);
 static int ubiblock_major;
 
<span class="p_chunk">@@ -351,8 +353,6 @@</span> <span class="p_context"> static const struct blk_mq_ops ubiblock_mq_ops = {</span>
 	.init_request	= ubiblock_init_request,
 };
 
<span class="p_del">-static DEFINE_IDR(ubiblock_minor_idr);</span>
<span class="p_del">-</span>
 int ubiblock_create(struct ubi_volume_info *vi)
 {
 	struct ubiblock *dev;
<span class="p_chunk">@@ -365,14 +365,15 @@</span> <span class="p_context"> int ubiblock_create(struct ubi_volume_info *vi)</span>
 	/* Check that the volume isn&#39;t already handled */
 	mutex_lock(&amp;devices_mutex);
 	if (find_dev_nolock(vi-&gt;ubi_num, vi-&gt;vol_id)) {
<span class="p_del">-		mutex_unlock(&amp;devices_mutex);</span>
<span class="p_del">-		return -EEXIST;</span>
<span class="p_add">+		ret = -EEXIST;</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
<span class="p_del">-	mutex_unlock(&amp;devices_mutex);</span>
 
 	dev = kzalloc(sizeof(struct ubiblock), GFP_KERNEL);
<span class="p_del">-	if (!dev)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	if (!dev) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
 
 	mutex_init(&amp;dev-&gt;dev_mutex);
 
<span class="p_chunk">@@ -437,14 +438,13 @@</span> <span class="p_context"> int ubiblock_create(struct ubi_volume_info *vi)</span>
 		goto out_free_queue;
 	}
 
<span class="p_del">-	mutex_lock(&amp;devices_mutex);</span>
 	list_add_tail(&amp;dev-&gt;list, &amp;ubiblock_devices);
<span class="p_del">-	mutex_unlock(&amp;devices_mutex);</span>
 
 	/* Must be the last step: anyone can call file ops from now on */
 	add_disk(dev-&gt;gd);
 	dev_info(disk_to_dev(dev-&gt;gd), &quot;created from ubi%d:%d(%s)&quot;,
 		 dev-&gt;ubi_num, dev-&gt;vol_id, vi-&gt;name);
<span class="p_add">+	mutex_unlock(&amp;devices_mutex);</span>
 	return 0;
 
 out_free_queue:
<span class="p_chunk">@@ -457,6 +457,8 @@</span> <span class="p_context"> int ubiblock_create(struct ubi_volume_info *vi)</span>
 	put_disk(dev-&gt;gd);
 out_free_dev:
 	kfree(dev);
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;devices_mutex);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -478,30 +480,36 @@</span> <span class="p_context"> static void ubiblock_cleanup(struct ubiblock *dev)</span>
 int ubiblock_remove(struct ubi_volume_info *vi)
 {
 	struct ubiblock *dev;
<span class="p_add">+	int ret;</span>
 
 	mutex_lock(&amp;devices_mutex);
 	dev = find_dev_nolock(vi-&gt;ubi_num, vi-&gt;vol_id);
 	if (!dev) {
<span class="p_del">-		mutex_unlock(&amp;devices_mutex);</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out_unlock;</span>
 	}
 
 	/* Found a device, let&#39;s lock it so we can check if it&#39;s busy */
 	mutex_lock(&amp;dev-&gt;dev_mutex);
 	if (dev-&gt;refcnt &gt; 0) {
<span class="p_del">-		mutex_unlock(&amp;dev-&gt;dev_mutex);</span>
<span class="p_del">-		mutex_unlock(&amp;devices_mutex);</span>
<span class="p_del">-		return -EBUSY;</span>
<span class="p_add">+		ret = -EBUSY;</span>
<span class="p_add">+		goto out_unlock_dev;</span>
 	}
 
 	/* Remove from device list */
 	list_del(&amp;dev-&gt;list);
<span class="p_del">-	mutex_unlock(&amp;devices_mutex);</span>
<span class="p_del">-</span>
 	ubiblock_cleanup(dev);
 	mutex_unlock(&amp;dev-&gt;dev_mutex);
<span class="p_add">+	mutex_unlock(&amp;devices_mutex);</span>
<span class="p_add">+</span>
 	kfree(dev);
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+out_unlock_dev:</span>
<span class="p_add">+	mutex_unlock(&amp;dev-&gt;dev_mutex);</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	mutex_unlock(&amp;devices_mutex);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int ubiblock_resize(struct ubi_volume_info *vi)
<span class="p_chunk">@@ -630,6 +638,7 @@</span> <span class="p_context"> static void ubiblock_remove_all(void)</span>
 	struct ubiblock *next;
 	struct ubiblock *dev;
 
<span class="p_add">+	mutex_lock(&amp;devices_mutex);</span>
 	list_for_each_entry_safe(dev, next, &amp;ubiblock_devices, list) {
 		/* The module is being forcefully removed */
 		WARN_ON(dev-&gt;desc);
<span class="p_chunk">@@ -638,6 +647,7 @@</span> <span class="p_context"> static void ubiblock_remove_all(void)</span>
 		ubiblock_cleanup(dev);
 		kfree(dev);
 	}
<span class="p_add">+	mutex_unlock(&amp;devices_mutex);</span>
 }
 
 int __init ubiblock_init(void)
<span class="p_header">diff --git a/drivers/mtd/ubi/vmt.c b/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">index 85237cf661f9..3fd8d7ff7a02 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/vmt.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/vmt.c</span>
<span class="p_chunk">@@ -270,6 +270,12 @@</span> <span class="p_context"> int ubi_create_volume(struct ubi_device *ubi, struct ubi_mkvol_req *req)</span>
 			vol-&gt;last_eb_bytes = vol-&gt;usable_leb_size;
 	}
 
<span class="p_add">+	/* Make volume &quot;available&quot; before it becomes accessible via sysfs */</span>
<span class="p_add">+	spin_lock(&amp;ubi-&gt;volumes_lock);</span>
<span class="p_add">+	ubi-&gt;volumes[vol_id] = vol;</span>
<span class="p_add">+	ubi-&gt;vol_count += 1;</span>
<span class="p_add">+	spin_unlock(&amp;ubi-&gt;volumes_lock);</span>
<span class="p_add">+</span>
 	/* Register character device for the volume */
 	cdev_init(&amp;vol-&gt;cdev, &amp;ubi_vol_cdev_operations);
 	vol-&gt;cdev.owner = THIS_MODULE;
<span class="p_chunk">@@ -298,11 +304,6 @@</span> <span class="p_context"> int ubi_create_volume(struct ubi_device *ubi, struct ubi_mkvol_req *req)</span>
 	if (err)
 		goto out_sysfs;
 
<span class="p_del">-	spin_lock(&amp;ubi-&gt;volumes_lock);</span>
<span class="p_del">-	ubi-&gt;volumes[vol_id] = vol;</span>
<span class="p_del">-	ubi-&gt;vol_count += 1;</span>
<span class="p_del">-	spin_unlock(&amp;ubi-&gt;volumes_lock);</span>
<span class="p_del">-</span>
 	ubi_volume_notify(ubi, vol, UBI_VOLUME_ADDED);
 	self_check_volumes(ubi);
 	return err;
<span class="p_chunk">@@ -315,6 +316,10 @@</span> <span class="p_context"> int ubi_create_volume(struct ubi_device *ubi, struct ubi_mkvol_req *req)</span>
 	 */
 	cdev_device_del(&amp;vol-&gt;cdev, &amp;vol-&gt;dev);
 out_mapping:
<span class="p_add">+	spin_lock(&amp;ubi-&gt;volumes_lock);</span>
<span class="p_add">+	ubi-&gt;volumes[vol_id] = NULL;</span>
<span class="p_add">+	ubi-&gt;vol_count -= 1;</span>
<span class="p_add">+	spin_unlock(&amp;ubi-&gt;volumes_lock);</span>
 	ubi_eba_destroy_table(eba_tbl);
 out_acc:
 	spin_lock(&amp;ubi-&gt;volumes_lock);
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index b5b8cd6f481c..668b46202507 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -1528,6 +1528,46 @@</span> <span class="p_context"> static void shutdown_work(struct ubi_device *ubi)</span>
 	}
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * erase_aeb - erase a PEB given in UBI attach info PEB</span>
<span class="p_add">+ * @ubi: UBI device description object</span>
<span class="p_add">+ * @aeb: UBI attach info PEB</span>
<span class="p_add">+ * @sync: If true, erase synchronously. Otherwise schedule for erasure</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int erase_aeb(struct ubi_device *ubi, struct ubi_ainf_peb *aeb, bool sync)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ubi_wl_entry *e;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	e = kmem_cache_alloc(ubi_wl_entry_slab, GFP_KERNEL);</span>
<span class="p_add">+	if (!e)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	e-&gt;pnum = aeb-&gt;pnum;</span>
<span class="p_add">+	e-&gt;ec = aeb-&gt;ec;</span>
<span class="p_add">+	ubi-&gt;lookuptbl[e-&gt;pnum] = e;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (sync) {</span>
<span class="p_add">+		err = sync_erase(ubi, e, false);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_free;</span>
<span class="p_add">+</span>
<span class="p_add">+		wl_tree_add(e, &amp;ubi-&gt;free);</span>
<span class="p_add">+		ubi-&gt;free_count++;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		err = schedule_erase(ubi, e, aeb-&gt;vol_id, aeb-&gt;lnum, 0, false);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_free;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out_free:</span>
<span class="p_add">+	wl_entry_destroy(ubi, e);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * ubi_wl_init - initialize the WL sub-system using attaching information.
  * @ubi: UBI device description object
<span class="p_chunk">@@ -1566,18 +1606,10 @@</span> <span class="p_context"> int ubi_wl_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 	list_for_each_entry_safe(aeb, tmp, &amp;ai-&gt;erase, u.list) {
 		cond_resched();
 
<span class="p_del">-		e = kmem_cache_alloc(ubi_wl_entry_slab, GFP_KERNEL);</span>
<span class="p_del">-		if (!e)</span>
<span class="p_add">+		err = erase_aeb(ubi, aeb, false);</span>
<span class="p_add">+		if (err)</span>
 			goto out_free;
 
<span class="p_del">-		e-&gt;pnum = aeb-&gt;pnum;</span>
<span class="p_del">-		e-&gt;ec = aeb-&gt;ec;</span>
<span class="p_del">-		ubi-&gt;lookuptbl[e-&gt;pnum] = e;</span>
<span class="p_del">-		if (schedule_erase(ubi, e, aeb-&gt;vol_id, aeb-&gt;lnum, 0, false)) {</span>
<span class="p_del">-			wl_entry_destroy(ubi, e);</span>
<span class="p_del">-			goto out_free;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
 		found_pebs++;
 	}
 
<span class="p_chunk">@@ -1635,6 +1667,8 @@</span> <span class="p_context"> int ubi_wl_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 			ubi_assert(!ubi-&gt;lookuptbl[e-&gt;pnum]);
 			ubi-&gt;lookuptbl[e-&gt;pnum] = e;
 		} else {
<span class="p_add">+			bool sync = false;</span>
<span class="p_add">+</span>
 			/*
 			 * Usually old Fastmap PEBs are scheduled for erasure
 			 * and we don&#39;t have to care about them but if we face
<span class="p_chunk">@@ -1644,18 +1678,21 @@</span> <span class="p_context"> int ubi_wl_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 			if (ubi-&gt;lookuptbl[aeb-&gt;pnum])
 				continue;
 
<span class="p_del">-			e = kmem_cache_alloc(ubi_wl_entry_slab, GFP_KERNEL);</span>
<span class="p_del">-			if (!e)</span>
<span class="p_del">-				goto out_free;</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * The fastmap update code might not find a free PEB for</span>
<span class="p_add">+			 * writing the fastmap anchor to and then reuses the</span>
<span class="p_add">+			 * current fastmap anchor PEB. When this PEB gets erased</span>
<span class="p_add">+			 * and a power cut happens before it is written again we</span>
<span class="p_add">+			 * must make sure that the fastmap attach code doesn&#39;t</span>
<span class="p_add">+			 * find any outdated fastmap anchors, hence we erase the</span>
<span class="p_add">+			 * outdated fastmap anchor PEBs synchronously here.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (aeb-&gt;vol_id == UBI_FM_SB_VOLUME_ID)</span>
<span class="p_add">+				sync = true;</span>
 
<span class="p_del">-			e-&gt;pnum = aeb-&gt;pnum;</span>
<span class="p_del">-			e-&gt;ec = aeb-&gt;ec;</span>
<span class="p_del">-			ubi_assert(!ubi-&gt;lookuptbl[e-&gt;pnum]);</span>
<span class="p_del">-			ubi-&gt;lookuptbl[e-&gt;pnum] = e;</span>
<span class="p_del">-			if (schedule_erase(ubi, e, aeb-&gt;vol_id, aeb-&gt;lnum, 0, false)) {</span>
<span class="p_del">-				wl_entry_destroy(ubi, e);</span>
<span class="p_add">+			err = erase_aeb(ubi, aeb, sync);</span>
<span class="p_add">+			if (err)</span>
 				goto out_free;
<span class="p_del">-			}</span>
 		}
 
 		found_pebs++;
<span class="p_header">diff --git a/drivers/pinctrl/intel/pinctrl-intel.c b/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_header">index 71df0f70b61f..72b4527d690f 100644</span>
<span class="p_header">--- a/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_header">+++ b/drivers/pinctrl/intel/pinctrl-intel.c</span>
<span class="p_chunk">@@ -427,6 +427,18 @@</span> <span class="p_context"> static void __intel_gpio_set_direction(void __iomem *padcfg0, bool input)</span>
 	writel(value, padcfg0);
 }
 
<span class="p_add">+static void intel_gpio_set_gpio_mode(void __iomem *padcfg0)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 value;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Put the pad into GPIO mode */</span>
<span class="p_add">+	value = readl(padcfg0) &amp; ~PADCFG0_PMODE_MASK;</span>
<span class="p_add">+	/* Disable SCI/SMI/NMI generation */</span>
<span class="p_add">+	value &amp;= ~(PADCFG0_GPIROUTIOXAPIC | PADCFG0_GPIROUTSCI);</span>
<span class="p_add">+	value &amp;= ~(PADCFG0_GPIROUTSMI | PADCFG0_GPIROUTNMI);</span>
<span class="p_add">+	writel(value, padcfg0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int intel_gpio_request_enable(struct pinctrl_dev *pctldev,
 				     struct pinctrl_gpio_range *range,
 				     unsigned pin)
<span class="p_chunk">@@ -434,7 +446,6 @@</span> <span class="p_context"> static int intel_gpio_request_enable(struct pinctrl_dev *pctldev,</span>
 	struct intel_pinctrl *pctrl = pinctrl_dev_get_drvdata(pctldev);
 	void __iomem *padcfg0;
 	unsigned long flags;
<span class="p_del">-	u32 value;</span>
 
 	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);
 
<span class="p_chunk">@@ -444,13 +455,7 @@</span> <span class="p_context"> static int intel_gpio_request_enable(struct pinctrl_dev *pctldev,</span>
 	}
 
 	padcfg0 = intel_get_padcfg(pctrl, pin, PADCFG0);
<span class="p_del">-	/* Put the pad into GPIO mode */</span>
<span class="p_del">-	value = readl(padcfg0) &amp; ~PADCFG0_PMODE_MASK;</span>
<span class="p_del">-	/* Disable SCI/SMI/NMI generation */</span>
<span class="p_del">-	value &amp;= ~(PADCFG0_GPIROUTIOXAPIC | PADCFG0_GPIROUTSCI);</span>
<span class="p_del">-	value &amp;= ~(PADCFG0_GPIROUTSMI | PADCFG0_GPIROUTNMI);</span>
<span class="p_del">-	writel(value, padcfg0);</span>
<span class="p_del">-</span>
<span class="p_add">+	intel_gpio_set_gpio_mode(padcfg0);</span>
 	/* Disable TX buffer and enable RX (this will be input) */
 	__intel_gpio_set_direction(padcfg0, true);
 
<span class="p_chunk">@@ -935,6 +940,8 @@</span> <span class="p_context"> static int intel_gpio_irq_type(struct irq_data *d, unsigned type)</span>
 
 	raw_spin_lock_irqsave(&amp;pctrl-&gt;lock, flags);
 
<span class="p_add">+	intel_gpio_set_gpio_mode(reg);</span>
<span class="p_add">+</span>
 	value = readl(reg);
 
 	value &amp;= ~(PADCFG0_RXEVCFG_MASK | PADCFG0_RXINV);
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-mcp23s08.c b/drivers/pinctrl/pinctrl-mcp23s08.c</span>
<span class="p_header">index 9c950bbf07ba..447763aad815 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-mcp23s08.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-mcp23s08.c</span>
<span class="p_chunk">@@ -891,16 +891,16 @@</span> <span class="p_context"> static int mcp23s08_probe_one(struct mcp23s08 *mcp, struct device *dev,</span>
 			goto fail;
 	}
 
<span class="p_del">-	ret = devm_gpiochip_add_data(dev, &amp;mcp-&gt;chip, mcp);</span>
<span class="p_del">-	if (ret &lt; 0)</span>
<span class="p_del">-		goto fail;</span>
<span class="p_del">-</span>
 	if (mcp-&gt;irq &amp;&amp; mcp-&gt;irq_controller) {
 		ret = mcp23s08_irq_setup(mcp);
 		if (ret)
 			goto fail;
 	}
 
<span class="p_add">+	ret = devm_gpiochip_add_data(dev, &amp;mcp-&gt;chip, mcp);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+</span>
 	mcp-&gt;pinctrl_desc.name = &quot;mcp23xxx-pinctrl&quot;;
 	mcp-&gt;pinctrl_desc.pctlops = &amp;mcp_pinctrl_ops;
 	mcp-&gt;pinctrl_desc.confops = &amp;mcp_pinconf_ops;
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-sx150x.c b/drivers/pinctrl/pinctrl-sx150x.c</span>
<span class="p_header">index 7450f5118445..70a0228f4e7f 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-sx150x.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-sx150x.c</span>
<span class="p_chunk">@@ -1144,6 +1144,27 @@</span> <span class="p_context"> static int sx150x_probe(struct i2c_client *client,</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	/* Pinctrl_desc */</span>
<span class="p_add">+	pctl-&gt;pinctrl_desc.name = &quot;sx150x-pinctrl&quot;;</span>
<span class="p_add">+	pctl-&gt;pinctrl_desc.pctlops = &amp;sx150x_pinctrl_ops;</span>
<span class="p_add">+	pctl-&gt;pinctrl_desc.confops = &amp;sx150x_pinconf_ops;</span>
<span class="p_add">+	pctl-&gt;pinctrl_desc.pins = pctl-&gt;data-&gt;pins;</span>
<span class="p_add">+	pctl-&gt;pinctrl_desc.npins = pctl-&gt;data-&gt;npins;</span>
<span class="p_add">+	pctl-&gt;pinctrl_desc.owner = THIS_MODULE;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = devm_pinctrl_register_and_init(dev, &amp;pctl-&gt;pinctrl_desc,</span>
<span class="p_add">+					     pctl, &amp;pctl-&gt;pctldev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to register pinctrl device\n&quot;);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = pinctrl_enable(pctl-&gt;pctldev);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		dev_err(dev, &quot;Failed to enable pinctrl device\n&quot;);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Register GPIO controller */
 	pctl-&gt;gpio.label = devm_kstrdup(dev, client-&gt;name, GFP_KERNEL);
 	pctl-&gt;gpio.base = -1;
<span class="p_chunk">@@ -1172,6 +1193,11 @@</span> <span class="p_context"> static int sx150x_probe(struct i2c_client *client,</span>
 	if (ret)
 		return ret;
 
<span class="p_add">+	ret = gpiochip_add_pin_range(&amp;pctl-&gt;gpio, dev_name(dev),</span>
<span class="p_add">+				     0, 0, pctl-&gt;data-&gt;npins);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	/* Add Interrupt support if an irq is specified */
 	if (client-&gt;irq &gt; 0) {
 		pctl-&gt;irq_chip.name = devm_kstrdup(dev, client-&gt;name,
<span class="p_chunk">@@ -1217,20 +1243,6 @@</span> <span class="p_context"> static int sx150x_probe(struct i2c_client *client,</span>
 					    client-&gt;irq);
 	}
 
<span class="p_del">-	/* Pinctrl_desc */</span>
<span class="p_del">-	pctl-&gt;pinctrl_desc.name = &quot;sx150x-pinctrl&quot;;</span>
<span class="p_del">-	pctl-&gt;pinctrl_desc.pctlops = &amp;sx150x_pinctrl_ops;</span>
<span class="p_del">-	pctl-&gt;pinctrl_desc.confops = &amp;sx150x_pinconf_ops;</span>
<span class="p_del">-	pctl-&gt;pinctrl_desc.pins = pctl-&gt;data-&gt;pins;</span>
<span class="p_del">-	pctl-&gt;pinctrl_desc.npins = pctl-&gt;data-&gt;npins;</span>
<span class="p_del">-	pctl-&gt;pinctrl_desc.owner = THIS_MODULE;</span>
<span class="p_del">-</span>
<span class="p_del">-	pctl-&gt;pctldev = pinctrl_register(&amp;pctl-&gt;pinctrl_desc, dev, pctl);</span>
<span class="p_del">-	if (IS_ERR(pctl-&gt;pctldev)) {</span>
<span class="p_del">-		dev_err(dev, &quot;Failed to register pinctrl device\n&quot;);</span>
<span class="p_del">-		return PTR_ERR(pctl-&gt;pctldev);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/scsi/cxlflash/main.c b/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">index 76b8b7eed0c0..0b6467206f8e 100644</span>
<span class="p_header">--- a/drivers/scsi/cxlflash/main.c</span>
<span class="p_header">+++ b/drivers/scsi/cxlflash/main.c</span>
<span class="p_chunk">@@ -620,6 +620,7 @@</span> <span class="p_context"> static int cxlflash_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scp)</span>
 	cmd-&gt;parent = afu;
 	cmd-&gt;hwq_index = hwq_index;
 
<span class="p_add">+	cmd-&gt;sa.ioasc = 0;</span>
 	cmd-&gt;rcb.ctx_id = hwq-&gt;ctx_hndl;
 	cmd-&gt;rcb.msi = SISL_MSI_RRQ_UPDATED;
 	cmd-&gt;rcb.port_sel = CHAN2PORTMASK(scp-&gt;device-&gt;channel);
<span class="p_header">diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c</span>
<span class="p_header">index fe3a0da3ec97..57bf43e34863 100644</span>
<span class="p_header">--- a/drivers/scsi/hosts.c</span>
<span class="p_header">+++ b/drivers/scsi/hosts.c</span>
<span class="p_chunk">@@ -318,6 +318,9 @@</span> <span class="p_context"> static void scsi_host_dev_release(struct device *dev)</span>
 
 	scsi_proc_hostdir_rm(shost-&gt;hostt);
 
<span class="p_add">+	/* Wait for functions invoked through call_rcu(&amp;shost-&gt;rcu, ...) */</span>
<span class="p_add">+	rcu_barrier();</span>
<span class="p_add">+</span>
 	if (shost-&gt;tmf_work_q)
 		destroy_workqueue(shost-&gt;tmf_work_q);
 	if (shost-&gt;ehandler)
<span class="p_chunk">@@ -325,6 +328,8 @@</span> <span class="p_context"> static void scsi_host_dev_release(struct device *dev)</span>
 	if (shost-&gt;work_q)
 		destroy_workqueue(shost-&gt;work_q);
 
<span class="p_add">+	destroy_rcu_head(&amp;shost-&gt;rcu);</span>
<span class="p_add">+</span>
 	if (shost-&gt;shost_state == SHOST_CREATED) {
 		/*
 		 * Free the shost_dev device name here if scsi_host_alloc()
<span class="p_chunk">@@ -399,6 +404,7 @@</span> <span class="p_context"> struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)</span>
 	INIT_LIST_HEAD(&amp;shost-&gt;starved_list);
 	init_waitqueue_head(&amp;shost-&gt;host_wait);
 	mutex_init(&amp;shost-&gt;scan_mutex);
<span class="p_add">+	init_rcu_head(&amp;shost-&gt;rcu);</span>
 
 	index = ida_simple_get(&amp;host_index_ida, 0, 0, GFP_KERNEL);
 	if (index &lt; 0)
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_init.c b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">index 6acf1bb1d320..25612ccf6ff2 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_init.c</span>
<span class="p_chunk">@@ -9413,44 +9413,62 @@</span> <span class="p_context"> lpfc_sli4_pci_mem_setup(struct lpfc_hba *phba)</span>
 		lpfc_sli4_bar0_register_memmap(phba, if_type);
 	}
 
<span class="p_del">-	if ((if_type == LPFC_SLI_INTF_IF_TYPE_0) &amp;&amp;</span>
<span class="p_del">-	    (pci_resource_start(pdev, PCI_64BIT_BAR2))) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Map SLI4 if type 0 HBA Control Register base to a kernel</span>
<span class="p_del">-		 * virtual address and setup the registers.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		phba-&gt;pci_bar1_map = pci_resource_start(pdev, PCI_64BIT_BAR2);</span>
<span class="p_del">-		bar1map_len = pci_resource_len(pdev, PCI_64BIT_BAR2);</span>
<span class="p_del">-		phba-&gt;sli4_hba.ctrl_regs_memmap_p =</span>
<span class="p_del">-				ioremap(phba-&gt;pci_bar1_map, bar1map_len);</span>
<span class="p_del">-		if (!phba-&gt;sli4_hba.ctrl_regs_memmap_p) {</span>
<span class="p_del">-			dev_printk(KERN_ERR, &amp;pdev-&gt;dev,</span>
<span class="p_del">-			   &quot;ioremap failed for SLI4 HBA control registers.\n&quot;);</span>
<span class="p_add">+	if (if_type == LPFC_SLI_INTF_IF_TYPE_0) {</span>
<span class="p_add">+		if (pci_resource_start(pdev, PCI_64BIT_BAR2)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Map SLI4 if type 0 HBA Control Register base to a</span>
<span class="p_add">+			 * kernel virtual address and setup the registers.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			phba-&gt;pci_bar1_map = pci_resource_start(pdev,</span>
<span class="p_add">+								PCI_64BIT_BAR2);</span>
<span class="p_add">+			bar1map_len = pci_resource_len(pdev, PCI_64BIT_BAR2);</span>
<span class="p_add">+			phba-&gt;sli4_hba.ctrl_regs_memmap_p =</span>
<span class="p_add">+					ioremap(phba-&gt;pci_bar1_map,</span>
<span class="p_add">+						bar1map_len);</span>
<span class="p_add">+			if (!phba-&gt;sli4_hba.ctrl_regs_memmap_p) {</span>
<span class="p_add">+				dev_err(&amp;pdev-&gt;dev,</span>
<span class="p_add">+					   &quot;ioremap failed for SLI4 HBA &quot;</span>
<span class="p_add">+					    &quot;control registers.\n&quot;);</span>
<span class="p_add">+				error = -ENOMEM;</span>
<span class="p_add">+				goto out_iounmap_conf;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			phba-&gt;pci_bar2_memmap_p =</span>
<span class="p_add">+					 phba-&gt;sli4_hba.ctrl_regs_memmap_p;</span>
<span class="p_add">+			lpfc_sli4_bar1_register_memmap(phba);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			error = -ENOMEM;</span>
 			goto out_iounmap_conf;
 		}
<span class="p_del">-		phba-&gt;pci_bar2_memmap_p = phba-&gt;sli4_hba.ctrl_regs_memmap_p;</span>
<span class="p_del">-		lpfc_sli4_bar1_register_memmap(phba);</span>
 	}
 
<span class="p_del">-	if ((if_type == LPFC_SLI_INTF_IF_TYPE_0) &amp;&amp;</span>
<span class="p_del">-	    (pci_resource_start(pdev, PCI_64BIT_BAR4))) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Map SLI4 if type 0 HBA Doorbell Register base to a kernel</span>
<span class="p_del">-		 * virtual address and setup the registers.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		phba-&gt;pci_bar2_map = pci_resource_start(pdev, PCI_64BIT_BAR4);</span>
<span class="p_del">-		bar2map_len = pci_resource_len(pdev, PCI_64BIT_BAR4);</span>
<span class="p_del">-		phba-&gt;sli4_hba.drbl_regs_memmap_p =</span>
<span class="p_del">-				ioremap(phba-&gt;pci_bar2_map, bar2map_len);</span>
<span class="p_del">-		if (!phba-&gt;sli4_hba.drbl_regs_memmap_p) {</span>
<span class="p_del">-			dev_printk(KERN_ERR, &amp;pdev-&gt;dev,</span>
<span class="p_del">-			   &quot;ioremap failed for SLI4 HBA doorbell registers.\n&quot;);</span>
<span class="p_del">-			goto out_iounmap_ctrl;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		phba-&gt;pci_bar4_memmap_p = phba-&gt;sli4_hba.drbl_regs_memmap_p;</span>
<span class="p_del">-		error = lpfc_sli4_bar2_register_memmap(phba, LPFC_VF0);</span>
<span class="p_del">-		if (error)</span>
<span class="p_add">+	if (if_type == LPFC_SLI_INTF_IF_TYPE_0) {</span>
<span class="p_add">+		if (pci_resource_start(pdev, PCI_64BIT_BAR4)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Map SLI4 if type 0 HBA Doorbell Register base to</span>
<span class="p_add">+			 * a kernel virtual address and setup the registers.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			phba-&gt;pci_bar2_map = pci_resource_start(pdev,</span>
<span class="p_add">+								PCI_64BIT_BAR4);</span>
<span class="p_add">+			bar2map_len = pci_resource_len(pdev, PCI_64BIT_BAR4);</span>
<span class="p_add">+			phba-&gt;sli4_hba.drbl_regs_memmap_p =</span>
<span class="p_add">+					ioremap(phba-&gt;pci_bar2_map,</span>
<span class="p_add">+						bar2map_len);</span>
<span class="p_add">+			if (!phba-&gt;sli4_hba.drbl_regs_memmap_p) {</span>
<span class="p_add">+				dev_err(&amp;pdev-&gt;dev,</span>
<span class="p_add">+					   &quot;ioremap failed for SLI4 HBA&quot;</span>
<span class="p_add">+					   &quot; doorbell registers.\n&quot;);</span>
<span class="p_add">+				error = -ENOMEM;</span>
<span class="p_add">+				goto out_iounmap_ctrl;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			phba-&gt;pci_bar4_memmap_p =</span>
<span class="p_add">+					phba-&gt;sli4_hba.drbl_regs_memmap_p;</span>
<span class="p_add">+			error = lpfc_sli4_bar2_register_memmap(phba, LPFC_VF0);</span>
<span class="p_add">+			if (error)</span>
<span class="p_add">+				goto out_iounmap_all;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			error = -ENOMEM;</span>
 			goto out_iounmap_all;
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/scsi/scsi_error.c b/drivers/scsi/scsi_error.c</span>
<span class="p_header">index dab876c65473..fa504ba83ade 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_error.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_error.c</span>
<span class="p_chunk">@@ -220,6 +220,17 @@</span> <span class="p_context"> static void scsi_eh_reset(struct scsi_cmnd *scmd)</span>
 	}
 }
 
<span class="p_add">+static void scsi_eh_inc_host_failed(struct rcu_head *head)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct Scsi_Host *shost = container_of(head, typeof(*shost), rcu);</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(shost-&gt;host_lock, flags);</span>
<span class="p_add">+	shost-&gt;host_failed++;</span>
<span class="p_add">+	scsi_eh_wakeup(shost);</span>
<span class="p_add">+	spin_unlock_irqrestore(shost-&gt;host_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * scsi_eh_scmd_add - add scsi cmd to error handling.
  * @scmd:	scmd to run eh on.
<span class="p_chunk">@@ -242,9 +253,12 @@</span> <span class="p_context"> void scsi_eh_scmd_add(struct scsi_cmnd *scmd)</span>
 
 	scsi_eh_reset(scmd);
 	list_add_tail(&amp;scmd-&gt;eh_entry, &amp;shost-&gt;eh_cmd_q);
<span class="p_del">-	shost-&gt;host_failed++;</span>
<span class="p_del">-	scsi_eh_wakeup(shost);</span>
 	spin_unlock_irqrestore(shost-&gt;host_lock, flags);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure that all tasks observe the host state change before the</span>
<span class="p_add">+	 * host_failed change.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	call_rcu(&amp;shost-&gt;rcu, scsi_eh_inc_host_failed);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index 635cfa1f2ace..0d3696e9dddd 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -318,22 +318,39 @@</span> <span class="p_context"> static void scsi_init_cmd_errh(struct scsi_cmnd *cmd)</span>
 		cmd-&gt;cmd_len = scsi_command_size(cmd-&gt;cmnd);
 }
 
<span class="p_del">-void scsi_device_unbusy(struct scsi_device *sdev)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Decrement the host_busy counter and wake up the error handler if necessary.</span>
<span class="p_add">+ * Avoid as follows that the error handler is not woken up if shost-&gt;host_busy</span>
<span class="p_add">+ * == shost-&gt;host_failed: use call_rcu() in scsi_eh_scmd_add() in combination</span>
<span class="p_add">+ * with an RCU read lock in this function to ensure that this function in its</span>
<span class="p_add">+ * entirety either finishes before scsi_eh_scmd_add() increases the</span>
<span class="p_add">+ * host_failed counter or that it notices the shost state change made by</span>
<span class="p_add">+ * scsi_eh_scmd_add().</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void scsi_dec_host_busy(struct Scsi_Host *shost)</span>
 {
<span class="p_del">-	struct Scsi_Host *shost = sdev-&gt;host;</span>
<span class="p_del">-	struct scsi_target *starget = scsi_target(sdev);</span>
 	unsigned long flags;
 
<span class="p_add">+	rcu_read_lock();</span>
 	atomic_dec(&amp;shost-&gt;host_busy);
<span class="p_del">-	if (starget-&gt;can_queue &gt; 0)</span>
<span class="p_del">-		atomic_dec(&amp;starget-&gt;target_busy);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (unlikely(scsi_host_in_recovery(shost) &amp;&amp;</span>
<span class="p_del">-		     (shost-&gt;host_failed || shost-&gt;host_eh_scheduled))) {</span>
<span class="p_add">+	if (unlikely(scsi_host_in_recovery(shost))) {</span>
 		spin_lock_irqsave(shost-&gt;host_lock, flags);
<span class="p_del">-		scsi_eh_wakeup(shost);</span>
<span class="p_add">+		if (shost-&gt;host_failed || shost-&gt;host_eh_scheduled)</span>
<span class="p_add">+			scsi_eh_wakeup(shost);</span>
 		spin_unlock_irqrestore(shost-&gt;host_lock, flags);
 	}
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void scsi_device_unbusy(struct scsi_device *sdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct Scsi_Host *shost = sdev-&gt;host;</span>
<span class="p_add">+	struct scsi_target *starget = scsi_target(sdev);</span>
<span class="p_add">+</span>
<span class="p_add">+	scsi_dec_host_busy(shost);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (starget-&gt;can_queue &gt; 0)</span>
<span class="p_add">+		atomic_dec(&amp;starget-&gt;target_busy);</span>
 
 	atomic_dec(&amp;sdev-&gt;device_busy);
 }
<span class="p_chunk">@@ -1532,7 +1549,7 @@</span> <span class="p_context"> static inline int scsi_host_queue_ready(struct request_queue *q,</span>
 		list_add_tail(&amp;sdev-&gt;starved_entry, &amp;shost-&gt;starved_list);
 	spin_unlock_irq(shost-&gt;host_lock);
 out_dec:
<span class="p_del">-	atomic_dec(&amp;shost-&gt;host_busy);</span>
<span class="p_add">+	scsi_dec_host_busy(shost);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1993,7 +2010,7 @@</span> <span class="p_context"> static blk_status_t scsi_queue_rq(struct blk_mq_hw_ctx *hctx,</span>
 	return BLK_STS_OK;
 
 out_dec_host_busy:
<span class="p_del">-	atomic_dec(&amp;shost-&gt;host_busy);</span>
<span class="p_add">+	scsi_dec_host_busy(shost);</span>
 out_dec_target_busy:
 	if (scsi_target(sdev)-&gt;can_queue &gt; 0)
 		atomic_dec(&amp;scsi_target(sdev)-&gt;target_busy);
<span class="p_header">diff --git a/drivers/staging/lustre/lnet/libcfs/linux/linux-crypto-adler.c b/drivers/staging/lustre/lnet/libcfs/linux/linux-crypto-adler.c</span>
<span class="p_header">index db0572733712..ab30a0f5129c 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lnet/libcfs/linux/linux-crypto-adler.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lnet/libcfs/linux/linux-crypto-adler.c</span>
<span class="p_chunk">@@ -119,6 +119,7 @@</span> <span class="p_context"> static struct shash_alg alg = {</span>
 		.cra_name		= &quot;adler32&quot;,
 		.cra_driver_name	= &quot;adler32-zlib&quot;,
 		.cra_priority		= 100,
<span class="p_add">+		.cra_flags		= CRYPTO_ALG_OPTIONAL_KEY,</span>
 		.cra_blocksize		= CHKSUM_BLOCK_SIZE,
 		.cra_ctxsize		= sizeof(u32),
 		.cra_module		= THIS_MODULE,
<span class="p_header">diff --git a/drivers/watchdog/Kconfig b/drivers/watchdog/Kconfig</span>
<span class="p_header">index c722cbfdc7e6..3ece1335ba84 100644</span>
<span class="p_header">--- a/drivers/watchdog/Kconfig</span>
<span class="p_header">+++ b/drivers/watchdog/Kconfig</span>
<span class="p_chunk">@@ -1451,7 +1451,7 @@</span> <span class="p_context"> config RC32434_WDT</span>
 
 config INDYDOG
 	tristate &quot;Indy/I2 Hardware Watchdog&quot;
<span class="p_del">-	depends on SGI_HAS_INDYDOG || (MIPS &amp;&amp; COMPILE_TEST)</span>
<span class="p_add">+	depends on SGI_HAS_INDYDOG</span>
 	help
 	  Hardware driver for the Indy&#39;s/I2&#39;s watchdog. This is a
 	  watchdog timer that will reboot the machine after a 60 second
<span class="p_header">diff --git a/drivers/watchdog/gpio_wdt.c b/drivers/watchdog/gpio_wdt.c</span>
<span class="p_header">index cb66c2f99ff1..7a6279daa8b9 100644</span>
<span class="p_header">--- a/drivers/watchdog/gpio_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/gpio_wdt.c</span>
<span class="p_chunk">@@ -80,7 +80,8 @@</span> <span class="p_context"> static int gpio_wdt_stop(struct watchdog_device *wdd)</span>
 
 	if (!priv-&gt;always_running) {
 		gpio_wdt_disable(priv);
<span class="p_del">-		clear_bit(WDOG_HW_RUNNING, &amp;wdd-&gt;status);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		set_bit(WDOG_HW_RUNNING, &amp;wdd-&gt;status);</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/drivers/watchdog/imx2_wdt.c b/drivers/watchdog/imx2_wdt.c</span>
<span class="p_header">index 4874b0f18650..518dfa1047cb 100644</span>
<span class="p_header">--- a/drivers/watchdog/imx2_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/imx2_wdt.c</span>
<span class="p_chunk">@@ -169,15 +169,21 @@</span> <span class="p_context"> static int imx2_wdt_ping(struct watchdog_device *wdog)</span>
 	return 0;
 }
 
<span class="p_del">-static int imx2_wdt_set_timeout(struct watchdog_device *wdog,</span>
<span class="p_del">-				unsigned int new_timeout)</span>
<span class="p_add">+static void __imx2_wdt_set_timeout(struct watchdog_device *wdog,</span>
<span class="p_add">+				   unsigned int new_timeout)</span>
 {
 	struct imx2_wdt_device *wdev = watchdog_get_drvdata(wdog);
 
<span class="p_del">-	wdog-&gt;timeout = new_timeout;</span>
<span class="p_del">-</span>
 	regmap_update_bits(wdev-&gt;regmap, IMX2_WDT_WCR, IMX2_WDT_WCR_WT,
 			   WDOG_SEC_TO_COUNT(new_timeout));
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int imx2_wdt_set_timeout(struct watchdog_device *wdog,</span>
<span class="p_add">+				unsigned int new_timeout)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__imx2_wdt_set_timeout(wdog, new_timeout);</span>
<span class="p_add">+</span>
<span class="p_add">+	wdog-&gt;timeout = new_timeout;</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -371,7 +377,11 @@</span> <span class="p_context"> static int imx2_wdt_suspend(struct device *dev)</span>
 
 	/* The watchdog IP block is running */
 	if (imx2_wdt_is_running(wdev)) {
<span class="p_del">-		imx2_wdt_set_timeout(wdog, IMX2_WDT_MAX_TIME);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Don&#39;t update wdog-&gt;timeout, we&#39;ll restore the current value</span>
<span class="p_add">+		 * during resume.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		__imx2_wdt_set_timeout(wdog, IMX2_WDT_MAX_TIME);</span>
 		imx2_wdt_ping(wdog);
 	}
 
<span class="p_header">diff --git a/fs/btrfs/inode.c b/fs/btrfs/inode.c</span>
<span class="p_header">index c71afd424900..5eaedff28a32 100644</span>
<span class="p_header">--- a/fs/btrfs/inode.c</span>
<span class="p_header">+++ b/fs/btrfs/inode.c</span>
<span class="p_chunk">@@ -2101,8 +2101,15 @@</span> <span class="p_context"> static void btrfs_writepage_fixup_worker(struct btrfs_work *work)</span>
 		goto out;
 	 }
 
<span class="p_del">-	btrfs_set_extent_delalloc(inode, page_start, page_end, &amp;cached_state,</span>
<span class="p_del">-				  0);</span>
<span class="p_add">+	ret = btrfs_set_extent_delalloc(inode, page_start, page_end,</span>
<span class="p_add">+					&amp;cached_state, 0);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		mapping_set_error(page-&gt;mapping, ret);</span>
<span class="p_add">+		end_extent_writepage(page, ret, page_start, page_end);</span>
<span class="p_add">+		ClearPageChecked(page);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	ClearPageChecked(page);
 	set_page_dirty(page);
 out:
<span class="p_header">diff --git a/fs/btrfs/raid56.c b/fs/btrfs/raid56.c</span>
<span class="p_header">index 24a62224b24b..6154825c30e1 100644</span>
<span class="p_header">--- a/fs/btrfs/raid56.c</span>
<span class="p_header">+++ b/fs/btrfs/raid56.c</span>
<span class="p_chunk">@@ -1432,14 +1432,13 @@</span> <span class="p_context"> static int fail_bio_stripe(struct btrfs_raid_bio *rbio,</span>
  */
 static void set_bio_pages_uptodate(struct bio *bio)
 {
<span class="p_del">-	struct bio_vec bvec;</span>
<span class="p_del">-	struct bvec_iter iter;</span>
<span class="p_add">+	struct bio_vec *bvec;</span>
<span class="p_add">+	int i;</span>
 
<span class="p_del">-	if (bio_flagged(bio, BIO_CLONED))</span>
<span class="p_del">-		bio-&gt;bi_iter = btrfs_io_bio(bio)-&gt;iter;</span>
<span class="p_add">+	ASSERT(!bio_flagged(bio, BIO_CLONED));</span>
 
<span class="p_del">-	bio_for_each_segment(bvec, bio, iter)</span>
<span class="p_del">-		SetPageUptodate(bvec.bv_page);</span>
<span class="p_add">+	bio_for_each_segment_all(bvec, bio, i)</span>
<span class="p_add">+		SetPageUptodate(bvec-&gt;bv_page);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/cifs/cifsencrypt.c b/fs/cifs/cifsencrypt.c</span>
<span class="p_header">index 68abbb0db608..f2b0a7f124da 100644</span>
<span class="p_header">--- a/fs/cifs/cifsencrypt.c</span>
<span class="p_header">+++ b/fs/cifs/cifsencrypt.c</span>
<span class="p_chunk">@@ -325,9 +325,8 @@</span> <span class="p_context"> int calc_lanman_hash(const char *password, const char *cryptkey, bool encrypt,</span>
 {
 	int i;
 	int rc;
<span class="p_del">-	char password_with_pad[CIFS_ENCPWD_SIZE];</span>
<span class="p_add">+	char password_with_pad[CIFS_ENCPWD_SIZE] = {0};</span>
 
<span class="p_del">-	memset(password_with_pad, 0, CIFS_ENCPWD_SIZE);</span>
 	if (password)
 		strncpy(password_with_pad, password, CIFS_ENCPWD_SIZE);
 
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 0bfc2280436d..f7db2fedfa8c 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -1707,7 +1707,7 @@</span> <span class="p_context"> cifs_parse_mount_options(const char *mountdata, const char *devname,</span>
 			tmp_end++;
 			if (!(tmp_end &lt; end &amp;&amp; tmp_end[1] == delim)) {
 				/* No it is not. Set the password to NULL */
<span class="p_del">-				kfree(vol-&gt;password);</span>
<span class="p_add">+				kzfree(vol-&gt;password);</span>
 				vol-&gt;password = NULL;
 				break;
 			}
<span class="p_chunk">@@ -1745,7 +1745,7 @@</span> <span class="p_context"> cifs_parse_mount_options(const char *mountdata, const char *devname,</span>
 					options = end;
 			}
 
<span class="p_del">-			kfree(vol-&gt;password);</span>
<span class="p_add">+			kzfree(vol-&gt;password);</span>
 			/* Now build new password string */
 			temp_len = strlen(value);
 			vol-&gt;password = kzalloc(temp_len+1, GFP_KERNEL);
<span class="p_chunk">@@ -4235,7 +4235,7 @@</span> <span class="p_context"> cifs_construct_tcon(struct cifs_sb_info *cifs_sb, kuid_t fsuid)</span>
 		reset_cifs_unix_caps(0, tcon, NULL, vol_info);
 out:
 	kfree(vol_info-&gt;username);
<span class="p_del">-	kfree(vol_info-&gt;password);</span>
<span class="p_add">+	kzfree(vol_info-&gt;password);</span>
 	kfree(vol_info);
 
 	return tcon;
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index 92fdf9c35de2..7d6539a04fac 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -3488,20 +3488,18 @@</span> <span class="p_context"> static const struct vm_operations_struct cifs_file_vm_ops = {</span>
 
 int cifs_file_strict_mmap(struct file *file, struct vm_area_struct *vma)
 {
<span class="p_del">-	int rc, xid;</span>
<span class="p_add">+	int xid, rc = 0;</span>
 	struct inode *inode = file_inode(file);
 
 	xid = get_xid();
 
<span class="p_del">-	if (!CIFS_CACHE_READ(CIFS_I(inode))) {</span>
<span class="p_add">+	if (!CIFS_CACHE_READ(CIFS_I(inode)))</span>
 		rc = cifs_zap_mapping(inode);
<span class="p_del">-		if (rc)</span>
<span class="p_del">-			return rc;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = generic_file_mmap(file, vma);</span>
<span class="p_del">-	if (rc == 0)</span>
<span class="p_add">+	if (!rc)</span>
<span class="p_add">+		rc = generic_file_mmap(file, vma);</span>
<span class="p_add">+	if (!rc)</span>
 		vma-&gt;vm_ops = &amp;cifs_file_vm_ops;
<span class="p_add">+</span>
 	free_xid(xid);
 	return rc;
 }
<span class="p_chunk">@@ -3511,16 +3509,16 @@</span> <span class="p_context"> int cifs_file_mmap(struct file *file, struct vm_area_struct *vma)</span>
 	int rc, xid;
 
 	xid = get_xid();
<span class="p_add">+</span>
 	rc = cifs_revalidate_file(file);
<span class="p_del">-	if (rc) {</span>
<span class="p_add">+	if (rc)</span>
 		cifs_dbg(FYI, &quot;Validation prior to mmap failed, error=%d\n&quot;,
 			 rc);
<span class="p_del">-		free_xid(xid);</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	rc = generic_file_mmap(file, vma);</span>
<span class="p_del">-	if (rc == 0)</span>
<span class="p_add">+	if (!rc)</span>
<span class="p_add">+		rc = generic_file_mmap(file, vma);</span>
<span class="p_add">+	if (!rc)</span>
 		vma-&gt;vm_ops = &amp;cifs_file_vm_ops;
<span class="p_add">+</span>
 	free_xid(xid);
 	return rc;
 }
<span class="p_header">diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c</span>
<span class="p_header">index eea93ac15ef0..a0dbced4a45c 100644</span>
<span class="p_header">--- a/fs/cifs/misc.c</span>
<span class="p_header">+++ b/fs/cifs/misc.c</span>
<span class="p_chunk">@@ -98,14 +98,11 @@</span> <span class="p_context"> sesInfoFree(struct cifs_ses *buf_to_free)</span>
 	kfree(buf_to_free-&gt;serverOS);
 	kfree(buf_to_free-&gt;serverDomain);
 	kfree(buf_to_free-&gt;serverNOS);
<span class="p_del">-	if (buf_to_free-&gt;password) {</span>
<span class="p_del">-		memset(buf_to_free-&gt;password, 0, strlen(buf_to_free-&gt;password));</span>
<span class="p_del">-		kfree(buf_to_free-&gt;password);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	kzfree(buf_to_free-&gt;password);</span>
 	kfree(buf_to_free-&gt;user_name);
 	kfree(buf_to_free-&gt;domainName);
<span class="p_del">-	kfree(buf_to_free-&gt;auth_key.response);</span>
<span class="p_del">-	kfree(buf_to_free);</span>
<span class="p_add">+	kzfree(buf_to_free-&gt;auth_key.response);</span>
<span class="p_add">+	kzfree(buf_to_free);</span>
 }
 
 struct cifs_tcon *
<span class="p_chunk">@@ -136,10 +133,7 @@</span> <span class="p_context"> tconInfoFree(struct cifs_tcon *buf_to_free)</span>
 	}
 	atomic_dec(&amp;tconInfoAllocCount);
 	kfree(buf_to_free-&gt;nativeFileSystem);
<span class="p_del">-	if (buf_to_free-&gt;password) {</span>
<span class="p_del">-		memset(buf_to_free-&gt;password, 0, strlen(buf_to_free-&gt;password));</span>
<span class="p_del">-		kfree(buf_to_free-&gt;password);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	kzfree(buf_to_free-&gt;password);</span>
 	kfree(buf_to_free);
 }
 
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index 01346b8b6edb..66af1f8a13cc 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -733,8 +733,7 @@</span> <span class="p_context"> int smb3_validate_negotiate(const unsigned int xid, struct cifs_tcon *tcon)</span>
 	}
 
 	/* check validate negotiate info response matches what we got earlier */
<span class="p_del">-	if (pneg_rsp-&gt;Dialect !=</span>
<span class="p_del">-			cpu_to_le16(tcon-&gt;ses-&gt;server-&gt;vals-&gt;protocol_id))</span>
<span class="p_add">+	if (pneg_rsp-&gt;Dialect != cpu_to_le16(tcon-&gt;ses-&gt;server-&gt;dialect))</span>
 		goto vneg_out;
 
 	if (pneg_rsp-&gt;SecurityMode != cpu_to_le16(tcon-&gt;ses-&gt;server-&gt;sec_mode))
<span class="p_header">diff --git a/fs/devpts/inode.c b/fs/devpts/inode.c</span>
<span class="p_header">index 7eae33ffa3fc..e31d6ed3ec32 100644</span>
<span class="p_header">--- a/fs/devpts/inode.c</span>
<span class="p_header">+++ b/fs/devpts/inode.c</span>
<span class="p_chunk">@@ -168,11 +168,11 @@</span> <span class="p_context"> struct vfsmount *devpts_mntget(struct file *filp, struct pts_fs_info *fsi)</span>
 	dput(path.dentry);
 	if (err) {
 		mntput(path.mnt);
<span class="p_del">-		path.mnt = ERR_PTR(err);</span>
<span class="p_add">+		return ERR_PTR(err);</span>
 	}
 	if (DEVPTS_SB(path.mnt-&gt;mnt_sb) != fsi) {
 		mntput(path.mnt);
<span class="p_del">-		path.mnt = ERR_PTR(-ENODEV);</span>
<span class="p_add">+		return ERR_PTR(-ENODEV);</span>
 	}
 	return path.mnt;
 }
<span class="p_header">diff --git a/fs/kernfs/file.c b/fs/kernfs/file.c</span>
<span class="p_header">index 9698e51656b1..d8f49c412f50 100644</span>
<span class="p_header">--- a/fs/kernfs/file.c</span>
<span class="p_header">+++ b/fs/kernfs/file.c</span>
<span class="p_chunk">@@ -275,7 +275,7 @@</span> <span class="p_context"> static ssize_t kernfs_fop_write(struct file *file, const char __user *user_buf,</span>
 {
 	struct kernfs_open_file *of = kernfs_of(file);
 	const struct kernfs_ops *ops;
<span class="p_del">-	size_t len;</span>
<span class="p_add">+	ssize_t len;</span>
 	char *buf;
 
 	if (of-&gt;atomic_write_len) {
<span class="p_header">diff --git a/fs/nfs/direct.c b/fs/nfs/direct.c</span>
<span class="p_header">index d2972d537469..8c10b0562e75 100644</span>
<span class="p_header">--- a/fs/nfs/direct.c</span>
<span class="p_header">+++ b/fs/nfs/direct.c</span>
<span class="p_chunk">@@ -775,10 +775,8 @@</span> <span class="p_context"> static void nfs_direct_write_completion(struct nfs_pgio_header *hdr)</span>
 
 	spin_lock(&amp;dreq-&gt;lock);
 
<span class="p_del">-	if (test_bit(NFS_IOHDR_ERROR, &amp;hdr-&gt;flags)) {</span>
<span class="p_del">-		dreq-&gt;flags = 0;</span>
<span class="p_add">+	if (test_bit(NFS_IOHDR_ERROR, &amp;hdr-&gt;flags))</span>
 		dreq-&gt;error = hdr-&gt;error;
<span class="p_del">-	}</span>
 	if (dreq-&gt;error == 0) {
 		nfs_direct_good_bytes(dreq, hdr);
 		if (nfs_write_need_commit(hdr)) {
<span class="p_header">diff --git a/fs/nfs/filelayout/filelayout.c b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">index 508126eb49f9..3db2b7464748 100644</span>
<span class="p_header">--- a/fs/nfs/filelayout/filelayout.c</span>
<span class="p_header">+++ b/fs/nfs/filelayout/filelayout.c</span>
<span class="p_chunk">@@ -895,9 +895,7 @@</span> <span class="p_context"> fl_pnfs_update_layout(struct inode *ino,</span>
 
 	lseg = pnfs_update_layout(ino, ctx, pos, count, iomode, strict_iomode,
 				  gfp_flags);
<span class="p_del">-	if (!lseg)</span>
<span class="p_del">-		lseg = ERR_PTR(-ENOMEM);</span>
<span class="p_del">-	if (IS_ERR(lseg))</span>
<span class="p_add">+	if (IS_ERR_OR_NULL(lseg))</span>
 		goto out;
 
 	lo = NFS_I(ino)-&gt;layout;
<span class="p_header">diff --git a/fs/nfs/io.c b/fs/nfs/io.c</span>
<span class="p_header">index 20fef85d2bb1..9034b4926909 100644</span>
<span class="p_header">--- a/fs/nfs/io.c</span>
<span class="p_header">+++ b/fs/nfs/io.c</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static void nfs_block_buffered(struct nfs_inode *nfsi, struct inode *inode)</span>
 {
 	if (!test_bit(NFS_INO_ODIRECT, &amp;nfsi-&gt;flags)) {
 		set_bit(NFS_INO_ODIRECT, &amp;nfsi-&gt;flags);
<span class="p_del">-		nfs_wb_all(inode);</span>
<span class="p_add">+		nfs_sync_mapping(inode-&gt;i_mapping);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/nfs/nfs4idmap.c b/fs/nfs/nfs4idmap.c</span>
<span class="p_header">index 30426c1a1bbd..22dc30a679a0 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4idmap.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4idmap.c</span>
<span class="p_chunk">@@ -568,9 +568,13 @@</span> <span class="p_context"> static int nfs_idmap_legacy_upcall(struct key_construction *cons,</span>
 	struct idmap_msg *im;
 	struct idmap *idmap = (struct idmap *)aux;
 	struct key *key = cons-&gt;key;
<span class="p_del">-	int ret = -ENOMEM;</span>
<span class="p_add">+	int ret = -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!aux)</span>
<span class="p_add">+		goto out1;</span>
 
 	/* msg and im are freed in idmap_pipe_destroy_msg */
<span class="p_add">+	ret = -ENOMEM;</span>
 	data = kzalloc(sizeof(*data), GFP_KERNEL);
 	if (!data)
 		goto out1;
<span class="p_header">diff --git a/fs/nfs/nfs4xdr.c b/fs/nfs/nfs4xdr.c</span>
<span class="p_header">index 14ed9791ec9c..549c916d2859 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4xdr.c</span>
<span class="p_chunk">@@ -7668,6 +7668,22 @@</span> <span class="p_context"> nfs4_stat_to_errno(int stat)</span>
 	.p_name = #proc,	\
 }
 
<span class="p_add">+#if defined(CONFIG_NFS_V4_1)</span>
<span class="p_add">+#define PROC41(proc, argtype, restype)				\</span>
<span class="p_add">+	PROC(proc, argtype, restype)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define PROC41(proc, argtype, restype)				\</span>
<span class="p_add">+	STUB(proc)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#if defined(CONFIG_NFS_V4_2)</span>
<span class="p_add">+#define PROC42(proc, argtype, restype)				\</span>
<span class="p_add">+	PROC(proc, argtype, restype)</span>
<span class="p_add">+#else</span>
<span class="p_add">+#define PROC42(proc, argtype, restype)				\</span>
<span class="p_add">+	STUB(proc)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 const struct rpc_procinfo nfs4_procedures[] = {
 	PROC(READ,		enc_read,		dec_read),
 	PROC(WRITE,		enc_write,		dec_write),
<span class="p_chunk">@@ -7688,7 +7704,6 @@</span> <span class="p_context"> const struct rpc_procinfo nfs4_procedures[] = {</span>
 	PROC(ACCESS,		enc_access,		dec_access),
 	PROC(GETATTR,		enc_getattr,		dec_getattr),
 	PROC(LOOKUP,		enc_lookup,		dec_lookup),
<span class="p_del">-	PROC(LOOKUPP,		enc_lookupp,		dec_lookupp),</span>
 	PROC(LOOKUP_ROOT,	enc_lookup_root,	dec_lookup_root),
 	PROC(REMOVE,		enc_remove,		dec_remove),
 	PROC(RENAME,		enc_rename,		dec_rename),
<span class="p_chunk">@@ -7707,33 +7722,30 @@</span> <span class="p_context"> const struct rpc_procinfo nfs4_procedures[] = {</span>
 	PROC(RELEASE_LOCKOWNER,	enc_release_lockowner,	dec_release_lockowner),
 	PROC(SECINFO,		enc_secinfo,		dec_secinfo),
 	PROC(FSID_PRESENT,	enc_fsid_present,	dec_fsid_present),
<span class="p_del">-#if defined(CONFIG_NFS_V4_1)</span>
<span class="p_del">-	PROC(EXCHANGE_ID,	enc_exchange_id,	dec_exchange_id),</span>
<span class="p_del">-	PROC(CREATE_SESSION,	enc_create_session,	dec_create_session),</span>
<span class="p_del">-	PROC(DESTROY_SESSION,	enc_destroy_session,	dec_destroy_session),</span>
<span class="p_del">-	PROC(SEQUENCE,		enc_sequence,		dec_sequence),</span>
<span class="p_del">-	PROC(GET_LEASE_TIME,	enc_get_lease_time,	dec_get_lease_time),</span>
<span class="p_del">-	PROC(RECLAIM_COMPLETE,	enc_reclaim_complete,	dec_reclaim_complete),</span>
<span class="p_del">-	PROC(GETDEVICEINFO,	enc_getdeviceinfo,	dec_getdeviceinfo),</span>
<span class="p_del">-	PROC(LAYOUTGET,		enc_layoutget,		dec_layoutget),</span>
<span class="p_del">-	PROC(LAYOUTCOMMIT,	enc_layoutcommit,	dec_layoutcommit),</span>
<span class="p_del">-	PROC(LAYOUTRETURN,	enc_layoutreturn,	dec_layoutreturn),</span>
<span class="p_del">-	PROC(SECINFO_NO_NAME,	enc_secinfo_no_name,	dec_secinfo_no_name),</span>
<span class="p_del">-	PROC(TEST_STATEID,	enc_test_stateid,	dec_test_stateid),</span>
<span class="p_del">-	PROC(FREE_STATEID,	enc_free_stateid,	dec_free_stateid),</span>
<span class="p_add">+	PROC41(EXCHANGE_ID,	enc_exchange_id,	dec_exchange_id),</span>
<span class="p_add">+	PROC41(CREATE_SESSION,	enc_create_session,	dec_create_session),</span>
<span class="p_add">+	PROC41(DESTROY_SESSION,	enc_destroy_session,	dec_destroy_session),</span>
<span class="p_add">+	PROC41(SEQUENCE,	enc_sequence,		dec_sequence),</span>
<span class="p_add">+	PROC41(GET_LEASE_TIME,	enc_get_lease_time,	dec_get_lease_time),</span>
<span class="p_add">+	PROC41(RECLAIM_COMPLETE,enc_reclaim_complete,	dec_reclaim_complete),</span>
<span class="p_add">+	PROC41(GETDEVICEINFO,	enc_getdeviceinfo,	dec_getdeviceinfo),</span>
<span class="p_add">+	PROC41(LAYOUTGET,	enc_layoutget,		dec_layoutget),</span>
<span class="p_add">+	PROC41(LAYOUTCOMMIT,	enc_layoutcommit,	dec_layoutcommit),</span>
<span class="p_add">+	PROC41(LAYOUTRETURN,	enc_layoutreturn,	dec_layoutreturn),</span>
<span class="p_add">+	PROC41(SECINFO_NO_NAME,	enc_secinfo_no_name,	dec_secinfo_no_name),</span>
<span class="p_add">+	PROC41(TEST_STATEID,	enc_test_stateid,	dec_test_stateid),</span>
<span class="p_add">+	PROC41(FREE_STATEID,	enc_free_stateid,	dec_free_stateid),</span>
 	STUB(GETDEVICELIST),
<span class="p_del">-	PROC(BIND_CONN_TO_SESSION,</span>
<span class="p_add">+	PROC41(BIND_CONN_TO_SESSION,</span>
 			enc_bind_conn_to_session, dec_bind_conn_to_session),
<span class="p_del">-	PROC(DESTROY_CLIENTID,	enc_destroy_clientid,	dec_destroy_clientid),</span>
<span class="p_del">-#endif /* CONFIG_NFS_V4_1 */</span>
<span class="p_del">-#ifdef CONFIG_NFS_V4_2</span>
<span class="p_del">-	PROC(SEEK,		enc_seek,		dec_seek),</span>
<span class="p_del">-	PROC(ALLOCATE,		enc_allocate,		dec_allocate),</span>
<span class="p_del">-	PROC(DEALLOCATE,	enc_deallocate,		dec_deallocate),</span>
<span class="p_del">-	PROC(LAYOUTSTATS,	enc_layoutstats,	dec_layoutstats),</span>
<span class="p_del">-	PROC(CLONE,		enc_clone,		dec_clone),</span>
<span class="p_del">-	PROC(COPY,		enc_copy,		dec_copy),</span>
<span class="p_del">-#endif /* CONFIG_NFS_V4_2 */</span>
<span class="p_add">+	PROC41(DESTROY_CLIENTID,enc_destroy_clientid,	dec_destroy_clientid),</span>
<span class="p_add">+	PROC42(SEEK,		enc_seek,		dec_seek),</span>
<span class="p_add">+	PROC42(ALLOCATE,	enc_allocate,		dec_allocate),</span>
<span class="p_add">+	PROC42(DEALLOCATE,	enc_deallocate,		dec_deallocate),</span>
<span class="p_add">+	PROC42(LAYOUTSTATS,	enc_layoutstats,	dec_layoutstats),</span>
<span class="p_add">+	PROC42(CLONE,		enc_clone,		dec_clone),</span>
<span class="p_add">+	PROC42(COPY,		enc_copy,		dec_copy),</span>
<span class="p_add">+	PROC(LOOKUPP,		enc_lookupp,		dec_lookupp),</span>
 };
 
 static unsigned int nfs_version4_counts[ARRAY_SIZE(nfs4_procedures)];
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 3bcd669a3152..5f2f852ef506 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -2237,7 +2237,7 @@</span> <span class="p_context"> pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_write_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	hdr-&gt;release(hdr);</span>
<span class="p_add">+	hdr-&gt;completion_ops-&gt;completion(hdr);</span>
 }
 
 static enum pnfs_try_status
<span class="p_chunk">@@ -2360,7 +2360,7 @@</span> <span class="p_context"> pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		nfs_pageio_reset_read_mds(desc);
 		mirror-&gt;pg_recoalesce = 1;
 	}
<span class="p_del">-	hdr-&gt;release(hdr);</span>
<span class="p_add">+	hdr-&gt;completion_ops-&gt;completion(hdr);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index de325804941d..76da415be39a 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -1836,6 +1836,8 @@</span> <span class="p_context"> static void nfs_commit_release_pages(struct nfs_commit_data *data)</span>
 		set_bit(NFS_CONTEXT_RESEND_WRITES, &amp;req-&gt;wb_context-&gt;flags);
 	next:
 		nfs_unlock_and_release_request(req);
<span class="p_add">+		/* Latency breaker */</span>
<span class="p_add">+		cond_resched();</span>
 	}
 	nfss = NFS_SERVER(data-&gt;inode);
 	if (atomic_long_read(&amp;nfss-&gt;writeback) &lt; NFS_CONGESTION_OFF_THRESH)
<span class="p_header">diff --git a/fs/overlayfs/readdir.c b/fs/overlayfs/readdir.c</span>
<span class="p_header">index d94a51dc4e32..7fa7d68baa6d 100644</span>
<span class="p_header">--- a/fs/overlayfs/readdir.c</span>
<span class="p_header">+++ b/fs/overlayfs/readdir.c</span>
<span class="p_chunk">@@ -575,8 +575,15 @@</span> <span class="p_context"> static struct ovl_dir_cache *ovl_cache_get_impure(struct path *path)</span>
 		return ERR_PTR(res);
 	}
 	if (list_empty(&amp;cache-&gt;entries)) {
<span class="p_del">-		/* Good oportunity to get rid of an unnecessary &quot;impure&quot; flag */</span>
<span class="p_del">-		ovl_do_removexattr(ovl_dentry_upper(dentry), OVL_XATTR_IMPURE);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * A good opportunity to get rid of an unneeded &quot;impure&quot; flag.</span>
<span class="p_add">+		 * Removing the &quot;impure&quot; xattr is best effort.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!ovl_want_write(dentry)) {</span>
<span class="p_add">+			ovl_do_removexattr(ovl_dentry_upper(dentry),</span>
<span class="p_add">+					   OVL_XATTR_IMPURE);</span>
<span class="p_add">+			ovl_drop_write(dentry);</span>
<span class="p_add">+		}</span>
 		ovl_clear_flag(OVL_IMPURE, d_inode(dentry));
 		kfree(cache);
 		return NULL;
<span class="p_chunk">@@ -751,10 +758,14 @@</span> <span class="p_context"> static int ovl_dir_fsync(struct file *file, loff_t start, loff_t end,</span>
 	struct dentry *dentry = file-&gt;f_path.dentry;
 	struct file *realfile = od-&gt;realfile;
 
<span class="p_add">+	/* Nothing to sync for lower */</span>
<span class="p_add">+	if (!OVL_TYPE_UPPER(ovl_path_type(dentry)))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/*
 	 * Need to check if we started out being a lower dir, but got copied up
 	 */
<span class="p_del">-	if (!od-&gt;is_upper &amp;&amp; OVL_TYPE_UPPER(ovl_path_type(dentry))) {</span>
<span class="p_add">+	if (!od-&gt;is_upper) {</span>
 		struct inode *inode = file_inode(file);
 
 		realfile = READ_ONCE(od-&gt;upperfile);
<span class="p_header">diff --git a/fs/pipe.c b/fs/pipe.c</span>
<span class="p_header">index f0f4ab36c444..8ef7d7bef775 100644</span>
<span class="p_header">--- a/fs/pipe.c</span>
<span class="p_header">+++ b/fs/pipe.c</span>
<span class="p_chunk">@@ -610,12 +610,17 @@</span> <span class="p_context"> static unsigned long account_pipe_buffers(struct user_struct *user,</span>
 
 static bool too_many_pipe_buffers_soft(unsigned long user_bufs)
 {
<span class="p_del">-	return pipe_user_pages_soft &amp;&amp; user_bufs &gt;= pipe_user_pages_soft;</span>
<span class="p_add">+	return pipe_user_pages_soft &amp;&amp; user_bufs &gt; pipe_user_pages_soft;</span>
 }
 
 static bool too_many_pipe_buffers_hard(unsigned long user_bufs)
 {
<span class="p_del">-	return pipe_user_pages_hard &amp;&amp; user_bufs &gt;= pipe_user_pages_hard;</span>
<span class="p_add">+	return pipe_user_pages_hard &amp;&amp; user_bufs &gt; pipe_user_pages_hard;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool is_unprivileged_user(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN);</span>
 }
 
 struct pipe_inode_info *alloc_pipe_info(void)
<span class="p_chunk">@@ -634,12 +639,12 @@</span> <span class="p_context"> struct pipe_inode_info *alloc_pipe_info(void)</span>
 
 	user_bufs = account_pipe_buffers(user, 0, pipe_bufs);
 
<span class="p_del">-	if (too_many_pipe_buffers_soft(user_bufs)) {</span>
<span class="p_add">+	if (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; is_unprivileged_user()) {</span>
 		user_bufs = account_pipe_buffers(user, pipe_bufs, 1);
 		pipe_bufs = 1;
 	}
 
<span class="p_del">-	if (too_many_pipe_buffers_hard(user_bufs))</span>
<span class="p_add">+	if (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; is_unprivileged_user())</span>
 		goto out_revert_acct;
 
 	pipe-&gt;bufs = kcalloc(pipe_bufs, sizeof(struct pipe_buffer),
<span class="p_chunk">@@ -1069,7 +1074,7 @@</span> <span class="p_context"> static long pipe_set_size(struct pipe_inode_info *pipe, unsigned long arg)</span>
 	if (nr_pages &gt; pipe-&gt;buffers &amp;&amp;
 			(too_many_pipe_buffers_hard(user_bufs) ||
 			 too_many_pipe_buffers_soft(user_bufs)) &amp;&amp;
<span class="p_del">-			!capable(CAP_SYS_RESOURCE) &amp;&amp; !capable(CAP_SYS_ADMIN)) {</span>
<span class="p_add">+			is_unprivileged_user()) {</span>
 		ret = -EPERM;
 		goto out_revert_acct;
 	}
<span class="p_header">diff --git a/fs/proc/kcore.c b/fs/proc/kcore.c</span>
<span class="p_header">index 4bc85cb8be6a..e8a93bc8285d 100644</span>
<span class="p_header">--- a/fs/proc/kcore.c</span>
<span class="p_header">+++ b/fs/proc/kcore.c</span>
<span class="p_chunk">@@ -512,23 +512,15 @@</span> <span class="p_context"> read_kcore(struct file *file, char __user *buffer, size_t buflen, loff_t *fpos)</span>
 				return -EFAULT;
 		} else {
 			if (kern_addr_valid(start)) {
<span class="p_del">-				unsigned long n;</span>
<span class="p_del">-</span>
 				/*
 				 * Using bounce buffer to bypass the
 				 * hardened user copy kernel text checks.
 				 */
<span class="p_del">-				memcpy(buf, (char *) start, tsz);</span>
<span class="p_del">-				n = copy_to_user(buffer, buf, tsz);</span>
<span class="p_del">-				/*</span>
<span class="p_del">-				 * We cannot distinguish between fault on source</span>
<span class="p_del">-				 * and fault on destination. When this happens</span>
<span class="p_del">-				 * we clear too and hope it will trigger the</span>
<span class="p_del">-				 * EFAULT again.</span>
<span class="p_del">-				 */</span>
<span class="p_del">-				if (n) { </span>
<span class="p_del">-					if (clear_user(buffer + tsz - n,</span>
<span class="p_del">-								n))</span>
<span class="p_add">+				if (probe_kernel_read(buf, (void *) start, tsz)) {</span>
<span class="p_add">+					if (clear_user(buffer, tsz))</span>
<span class="p_add">+						return -EFAULT;</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					if (copy_to_user(buffer, buf, tsz))</span>
 						return -EFAULT;
 				}
 			} else {
<span class="p_header">diff --git a/fs/ubifs/dir.c b/fs/ubifs/dir.c</span>
<span class="p_header">index 417fe0b29f23..ef820f803176 100644</span>
<span class="p_header">--- a/fs/ubifs/dir.c</span>
<span class="p_header">+++ b/fs/ubifs/dir.c</span>
<span class="p_chunk">@@ -1216,10 +1216,8 @@</span> <span class="p_context"> static int ubifs_symlink(struct inode *dir, struct dentry *dentry,</span>
 		ostr.len = disk_link.len;
 
 		err = fscrypt_fname_usr_to_disk(inode, &amp;istr, &amp;ostr);
<span class="p_del">-		if (err) {</span>
<span class="p_del">-			kfree(sd);</span>
<span class="p_add">+		if (err)</span>
 			goto out_inode;
<span class="p_del">-		}</span>
 
 		sd-&gt;len = cpu_to_le16(ostr.len);
 		disk_link.name = (char *)sd;
<span class="p_chunk">@@ -1251,11 +1249,10 @@</span> <span class="p_context"> static int ubifs_symlink(struct inode *dir, struct dentry *dentry,</span>
 		goto out_cancel;
 	mutex_unlock(&amp;dir_ui-&gt;ui_mutex);
 
<span class="p_del">-	ubifs_release_budget(c, &amp;req);</span>
 	insert_inode_hash(inode);
 	d_instantiate(dentry, inode);
<span class="p_del">-	fscrypt_free_filename(&amp;nm);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	err = 0;</span>
<span class="p_add">+	goto out_fname;</span>
 
 out_cancel:
 	dir-&gt;i_size -= sz_change;
<span class="p_chunk">@@ -1268,6 +1265,7 @@</span> <span class="p_context"> static int ubifs_symlink(struct inode *dir, struct dentry *dentry,</span>
 	fscrypt_free_filename(&amp;nm);
 out_budg:
 	ubifs_release_budget(c, &amp;req);
<span class="p_add">+	kfree(sd);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/include/crypto/hash.h b/include/crypto/hash.h</span>
<span class="p_header">index b5727bcd2336..74827781593c 100644</span>
<span class="p_header">--- a/include/crypto/hash.h</span>
<span class="p_header">+++ b/include/crypto/hash.h</span>
<span class="p_chunk">@@ -205,7 +205,6 @@</span> <span class="p_context"> struct crypto_ahash {</span>
 		      unsigned int keylen);
 
 	unsigned int reqsize;
<span class="p_del">-	bool has_setkey;</span>
 	struct crypto_tfm base;
 };
 
<span class="p_chunk">@@ -405,11 +404,6 @@</span> <span class="p_context"> static inline void *ahash_request_ctx(struct ahash_request *req)</span>
 int crypto_ahash_setkey(struct crypto_ahash *tfm, const u8 *key,
 			unsigned int keylen);
 
<span class="p_del">-static inline bool crypto_ahash_has_setkey(struct crypto_ahash *tfm)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return tfm-&gt;has_setkey;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /**
  * crypto_ahash_finup() - update and finalize message digest
  * @req: reference to the ahash_request handle that holds all information
<span class="p_chunk">@@ -481,7 +475,12 @@</span> <span class="p_context"> static inline int crypto_ahash_export(struct ahash_request *req, void *out)</span>
  */
 static inline int crypto_ahash_import(struct ahash_request *req, const void *in)
 {
<span class="p_del">-	return crypto_ahash_reqtfm(req)-&gt;import(req, in);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (crypto_ahash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm-&gt;import(req, in);</span>
 }
 
 /**
<span class="p_chunk">@@ -498,7 +497,12 @@</span> <span class="p_context"> static inline int crypto_ahash_import(struct ahash_request *req, const void *in)</span>
  */
 static inline int crypto_ahash_init(struct ahash_request *req)
 {
<span class="p_del">-	return crypto_ahash_reqtfm(req)-&gt;init(req);</span>
<span class="p_add">+	struct crypto_ahash *tfm = crypto_ahash_reqtfm(req);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (crypto_ahash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return tfm-&gt;init(req);</span>
 }
 
 /**
<span class="p_chunk">@@ -851,7 +855,12 @@</span> <span class="p_context"> static inline int crypto_shash_export(struct shash_desc *desc, void *out)</span>
  */
 static inline int crypto_shash_import(struct shash_desc *desc, const void *in)
 {
<span class="p_del">-	return crypto_shash_alg(desc-&gt;tfm)-&gt;import(desc, in);</span>
<span class="p_add">+	struct crypto_shash *tfm = desc-&gt;tfm;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (crypto_shash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_shash_alg(tfm)-&gt;import(desc, in);</span>
 }
 
 /**
<span class="p_chunk">@@ -867,7 +876,12 @@</span> <span class="p_context"> static inline int crypto_shash_import(struct shash_desc *desc, const void *in)</span>
  */
 static inline int crypto_shash_init(struct shash_desc *desc)
 {
<span class="p_del">-	return crypto_shash_alg(desc-&gt;tfm)-&gt;init(desc);</span>
<span class="p_add">+	struct crypto_shash *tfm = desc-&gt;tfm;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (crypto_shash_get_flags(tfm) &amp; CRYPTO_TFM_NEED_KEY)</span>
<span class="p_add">+		return -ENOKEY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_shash_alg(tfm)-&gt;init(desc);</span>
 }
 
 /**
<span class="p_header">diff --git a/include/crypto/internal/hash.h b/include/crypto/internal/hash.h</span>
<span class="p_header">index c2bae8da642c..27040a46d50a 100644</span>
<span class="p_header">--- a/include/crypto/internal/hash.h</span>
<span class="p_header">+++ b/include/crypto/internal/hash.h</span>
<span class="p_chunk">@@ -90,6 +90,8 @@</span> <span class="p_context"> static inline bool crypto_shash_alg_has_setkey(struct shash_alg *alg)</span>
 	return alg-&gt;setkey != shash_no_setkey;
 }
 
<span class="p_add">+bool crypto_hash_alg_has_setkey(struct hash_alg_common *halg);</span>
<span class="p_add">+</span>
 int crypto_init_ahash_spawn(struct crypto_ahash_spawn *spawn,
 			    struct hash_alg_common *alg,
 			    struct crypto_instance *inst);
<span class="p_header">diff --git a/include/crypto/poly1305.h b/include/crypto/poly1305.h</span>
<span class="p_header">index c65567d01e8e..f718a19da82f 100644</span>
<span class="p_header">--- a/include/crypto/poly1305.h</span>
<span class="p_header">+++ b/include/crypto/poly1305.h</span>
<span class="p_chunk">@@ -31,8 +31,6 @@</span> <span class="p_context"> struct poly1305_desc_ctx {</span>
 };
 
 int crypto_poly1305_init(struct shash_desc *desc);
<span class="p_del">-int crypto_poly1305_setkey(struct crypto_shash *tfm,</span>
<span class="p_del">-			   const u8 *key, unsigned int keylen);</span>
 unsigned int crypto_poly1305_setdesckey(struct poly1305_desc_ctx *dctx,
 					const u8 *src, unsigned int srclen);
 int crypto_poly1305_update(struct shash_desc *desc,
<span class="p_header">diff --git a/include/kvm/arm_psci.h b/include/kvm/arm_psci.h</span>
new file mode 100644
<span class="p_header">index 000000000000..e518e4e3dfb5</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/include/kvm/arm_psci.h</span>
<span class="p_chunk">@@ -0,0 +1,51 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright (C) 2012,2013 - ARM Ltd</span>
<span class="p_add">+ * Author: Marc Zyngier &lt;marc.zyngier@arm.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify</span>
<span class="p_add">+ * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_add">+ * published by the Free Software Foundation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is distributed in the hope that it will be useful,</span>
<span class="p_add">+ * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="p_add">+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="p_add">+ * GNU General Public License for more details.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * You should have received a copy of the GNU General Public License</span>
<span class="p_add">+ * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __KVM_ARM_PSCI_H__</span>
<span class="p_add">+#define __KVM_ARM_PSCI_H__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kvm_host.h&gt;</span>
<span class="p_add">+#include &lt;uapi/linux/psci.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_ARM_PSCI_0_1	PSCI_VERSION(0, 1)</span>
<span class="p_add">+#define KVM_ARM_PSCI_0_2	PSCI_VERSION(0, 2)</span>
<span class="p_add">+#define KVM_ARM_PSCI_1_0	PSCI_VERSION(1, 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define KVM_ARM_PSCI_LATEST	KVM_ARM_PSCI_1_0</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We need the KVM pointer independently from the vcpu as we can call</span>
<span class="p_add">+ * this from HYP, and need to apply kern_hyp_va on it...</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline int kvm_psci_version(struct kvm_vcpu *vcpu, struct kvm *kvm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Our PSCI implementation stays the same across versions from</span>
<span class="p_add">+	 * v0.2 onward, only adding the few mandatory functions (such</span>
<span class="p_add">+	 * as FEATURES with 1.0) that are required by newer</span>
<span class="p_add">+	 * revisions. It is thus safe to return the latest.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (test_bit(KVM_ARM_VCPU_PSCI_0_2, vcpu-&gt;arch.features))</span>
<span class="p_add">+		return KVM_ARM_PSCI_LATEST;</span>
<span class="p_add">+</span>
<span class="p_add">+	return KVM_ARM_PSCI_0_1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+int kvm_hvc_call_handler(struct kvm_vcpu *vcpu);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __KVM_ARM_PSCI_H__ */</span>
<span class="p_header">diff --git a/include/linux/arm-smccc.h b/include/linux/arm-smccc.h</span>
<span class="p_header">index 4c5bca38c653..a031897fca76 100644</span>
<span class="p_header">--- a/include/linux/arm-smccc.h</span>
<span class="p_header">+++ b/include/linux/arm-smccc.h</span>
<span class="p_chunk">@@ -14,14 +14,16 @@</span> <span class="p_context"></span>
 #ifndef __LINUX_ARM_SMCCC_H
 #define __LINUX_ARM_SMCCC_H
 
<span class="p_add">+#include &lt;uapi/linux/const.h&gt;</span>
<span class="p_add">+</span>
 /*
  * This file provides common defines for ARM SMC Calling Convention as
  * specified in
  * http://infocenter.arm.com/help/topic/com.arm.doc.den0028a/index.html
  */
 
<span class="p_del">-#define ARM_SMCCC_STD_CALL		0</span>
<span class="p_del">-#define ARM_SMCCC_FAST_CALL		1</span>
<span class="p_add">+#define ARM_SMCCC_STD_CALL	        _AC(0,U)</span>
<span class="p_add">+#define ARM_SMCCC_FAST_CALL	        _AC(1,U)</span>
 #define ARM_SMCCC_TYPE_SHIFT		31
 
 #define ARM_SMCCC_SMC_32		0
<span class="p_chunk">@@ -60,6 +62,24 @@</span> <span class="p_context"></span>
 #define ARM_SMCCC_QUIRK_NONE		0
 #define ARM_SMCCC_QUIRK_QCOM_A6		1 /* Save/restore register a6 */
 
<span class="p_add">+#define ARM_SMCCC_VERSION_1_0		0x10000</span>
<span class="p_add">+#define ARM_SMCCC_VERSION_1_1		0x10001</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SMCCC_VERSION_FUNC_ID					\</span>
<span class="p_add">+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,				\</span>
<span class="p_add">+			   ARM_SMCCC_SMC_32,				\</span>
<span class="p_add">+			   0, 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SMCCC_ARCH_FEATURES_FUNC_ID					\</span>
<span class="p_add">+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,				\</span>
<span class="p_add">+			   ARM_SMCCC_SMC_32,				\</span>
<span class="p_add">+			   0, 1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARM_SMCCC_ARCH_WORKAROUND_1					\</span>
<span class="p_add">+	ARM_SMCCC_CALL_VAL(ARM_SMCCC_FAST_CALL,				\</span>
<span class="p_add">+			   ARM_SMCCC_SMC_32,				\</span>
<span class="p_add">+			   0, 0x8000)</span>
<span class="p_add">+</span>
 #ifndef __ASSEMBLY__
 
 #include &lt;linux/linkage.h&gt;
<span class="p_chunk">@@ -130,5 +150,146 @@</span> <span class="p_context"> asmlinkage void __arm_smccc_hvc(unsigned long a0, unsigned long a1,</span>
 
 #define arm_smccc_hvc_quirk(...) __arm_smccc_hvc(__VA_ARGS__)
 
<span class="p_add">+/* SMCCC v1.1 implementation madness follows */</span>
<span class="p_add">+#ifdef CONFIG_ARM64</span>
<span class="p_add">+</span>
<span class="p_add">+#define SMCCC_SMC_INST	&quot;smc	#0&quot;</span>
<span class="p_add">+#define SMCCC_HVC_INST	&quot;hvc	#0&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+#elif defined(CONFIG_ARM)</span>
<span class="p_add">+#include &lt;asm/opcodes-sec.h&gt;</span>
<span class="p_add">+#include &lt;asm/opcodes-virt.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define SMCCC_SMC_INST	__SMC(0)</span>
<span class="p_add">+#define SMCCC_HVC_INST	__HVC(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define ___count_args(_0, _1, _2, _3, _4, _5, _6, _7, _8, x, ...) x</span>
<span class="p_add">+</span>
<span class="p_add">+#define __count_args(...)						\</span>
<span class="p_add">+	___count_args(__VA_ARGS__, 7, 6, 5, 4, 3, 2, 1, 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __constraint_write_0						\</span>
<span class="p_add">+	&quot;+r&quot; (r0), &quot;=&amp;r&quot; (r1), &quot;=&amp;r&quot; (r2), &quot;=&amp;r&quot; (r3)</span>
<span class="p_add">+#define __constraint_write_1						\</span>
<span class="p_add">+	&quot;+r&quot; (r0), &quot;+r&quot; (r1), &quot;=&amp;r&quot; (r2), &quot;=&amp;r&quot; (r3)</span>
<span class="p_add">+#define __constraint_write_2						\</span>
<span class="p_add">+	&quot;+r&quot; (r0), &quot;+r&quot; (r1), &quot;+r&quot; (r2), &quot;=&amp;r&quot; (r3)</span>
<span class="p_add">+#define __constraint_write_3						\</span>
<span class="p_add">+	&quot;+r&quot; (r0), &quot;+r&quot; (r1), &quot;+r&quot; (r2), &quot;+r&quot; (r3)</span>
<span class="p_add">+#define __constraint_write_4	__constraint_write_3</span>
<span class="p_add">+#define __constraint_write_5	__constraint_write_4</span>
<span class="p_add">+#define __constraint_write_6	__constraint_write_5</span>
<span class="p_add">+#define __constraint_write_7	__constraint_write_6</span>
<span class="p_add">+</span>
<span class="p_add">+#define __constraint_read_0</span>
<span class="p_add">+#define __constraint_read_1</span>
<span class="p_add">+#define __constraint_read_2</span>
<span class="p_add">+#define __constraint_read_3</span>
<span class="p_add">+#define __constraint_read_4	&quot;r&quot; (r4)</span>
<span class="p_add">+#define __constraint_read_5	__constraint_read_4, &quot;r&quot; (r5)</span>
<span class="p_add">+#define __constraint_read_6	__constraint_read_5, &quot;r&quot; (r6)</span>
<span class="p_add">+#define __constraint_read_7	__constraint_read_6, &quot;r&quot; (r7)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_0(a0, res)					\</span>
<span class="p_add">+	struct arm_smccc_res   *___res = res;				\</span>
<span class="p_add">+	register u32           r0 asm(&quot;r0&quot;) = a0;			\</span>
<span class="p_add">+	register unsigned long r1 asm(&quot;r1&quot;);				\</span>
<span class="p_add">+	register unsigned long r2 asm(&quot;r2&quot;);				\</span>
<span class="p_add">+	register unsigned long r3 asm(&quot;r3&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_1(a0, a1, res)					\</span>
<span class="p_add">+	struct arm_smccc_res   *___res = res;				\</span>
<span class="p_add">+	register u32           r0 asm(&quot;r0&quot;) = a0;			\</span>
<span class="p_add">+	register typeof(a1)    r1 asm(&quot;r1&quot;) = a1;			\</span>
<span class="p_add">+	register unsigned long r2 asm(&quot;r2&quot;);				\</span>
<span class="p_add">+	register unsigned long r3 asm(&quot;r3&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_2(a0, a1, a2, res)				\</span>
<span class="p_add">+	struct arm_smccc_res   *___res = res;				\</span>
<span class="p_add">+	register u32           r0 asm(&quot;r0&quot;) = a0;			\</span>
<span class="p_add">+	register typeof(a1)    r1 asm(&quot;r1&quot;) = a1;			\</span>
<span class="p_add">+	register typeof(a2)    r2 asm(&quot;r2&quot;) = a2;			\</span>
<span class="p_add">+	register unsigned long r3 asm(&quot;r3&quot;)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_3(a0, a1, a2, a3, res)				\</span>
<span class="p_add">+	struct arm_smccc_res   *___res = res;				\</span>
<span class="p_add">+	register u32           r0 asm(&quot;r0&quot;) = a0;			\</span>
<span class="p_add">+	register typeof(a1)    r1 asm(&quot;r1&quot;) = a1;			\</span>
<span class="p_add">+	register typeof(a2)    r2 asm(&quot;r2&quot;) = a2;			\</span>
<span class="p_add">+	register typeof(a3)    r3 asm(&quot;r3&quot;) = a3</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_4(a0, a1, a2, a3, a4, res)			\</span>
<span class="p_add">+	__declare_arg_3(a0, a1, a2, a3, res);				\</span>
<span class="p_add">+	register typeof(a4) r4 asm(&quot;r4&quot;) = a4</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_5(a0, a1, a2, a3, a4, a5, res)			\</span>
<span class="p_add">+	__declare_arg_4(a0, a1, a2, a3, a4, res);			\</span>
<span class="p_add">+	register typeof(a5) r5 asm(&quot;r5&quot;) = a5</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_6(a0, a1, a2, a3, a4, a5, a6, res)		\</span>
<span class="p_add">+	__declare_arg_5(a0, a1, a2, a3, a4, a5, res);			\</span>
<span class="p_add">+	register typeof(a6) r6 asm(&quot;r6&quot;) = a6</span>
<span class="p_add">+</span>
<span class="p_add">+#define __declare_arg_7(a0, a1, a2, a3, a4, a5, a6, a7, res)		\</span>
<span class="p_add">+	__declare_arg_6(a0, a1, a2, a3, a4, a5, a6, res);		\</span>
<span class="p_add">+	register typeof(a7) r7 asm(&quot;r7&quot;) = a7</span>
<span class="p_add">+</span>
<span class="p_add">+#define ___declare_args(count, ...) __declare_arg_ ## count(__VA_ARGS__)</span>
<span class="p_add">+#define __declare_args(count, ...)  ___declare_args(count, __VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ___constraints(count)						\</span>
<span class="p_add">+	: __constraint_write_ ## count					\</span>
<span class="p_add">+	: __constraint_read_ ## count					\</span>
<span class="p_add">+	: &quot;memory&quot;</span>
<span class="p_add">+#define __constraints(count)	___constraints(count)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * We have an output list that is not necessarily used, and GCC feels</span>
<span class="p_add">+ * entitled to optimise the whole sequence away. &quot;volatile&quot; is what</span>
<span class="p_add">+ * makes it stick.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define __arm_smccc_1_1(inst, ...)					\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		__declare_args(__count_args(__VA_ARGS__), __VA_ARGS__);	\</span>
<span class="p_add">+		asm volatile(inst &quot;\n&quot;					\</span>
<span class="p_add">+			     __constraints(__count_args(__VA_ARGS__)));	\</span>
<span class="p_add">+		if (___res)						\</span>
<span class="p_add">+			*___res = (typeof(*___res)){r0, r1, r2, r3};	\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * arm_smccc_1_1_smc() - make an SMCCC v1.1 compliant SMC call</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is a variadic macro taking one to eight source arguments, and</span>
<span class="p_add">+ * an optional return structure.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @a0-a7: arguments passed in registers 0 to 7</span>
<span class="p_add">+ * @res: result values from registers 0 to 3</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This macro is used to make SMC calls following SMC Calling Convention v1.1.</span>
<span class="p_add">+ * The content of the supplied param are copied to registers 0 to 7 prior</span>
<span class="p_add">+ * to the SMC instruction. The return values are updated with the content</span>
<span class="p_add">+ * from register 0 to 3 on return from the SMC instruction if not NULL.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define arm_smccc_1_1_smc(...)	__arm_smccc_1_1(SMCCC_SMC_INST, __VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * arm_smccc_1_1_hvc() - make an SMCCC v1.1 compliant HVC call</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This is a variadic macro taking one to eight source arguments, and</span>
<span class="p_add">+ * an optional return structure.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @a0-a7: arguments passed in registers 0 to 7</span>
<span class="p_add">+ * @res: result values from registers 0 to 3</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This macro is used to make HVC calls following SMC Calling Convention v1.1.</span>
<span class="p_add">+ * The content of the supplied param are copied to registers 0 to 7 prior</span>
<span class="p_add">+ * to the HVC instruction. The return values are updated with the content</span>
<span class="p_add">+ * from register 0 to 3 on return from the HVC instruction if not NULL.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define arm_smccc_1_1_hvc(...)	__arm_smccc_1_1(SMCCC_HVC_INST, __VA_ARGS__)</span>
<span class="p_add">+</span>
 #endif /*__ASSEMBLY__*/
 #endif /*__LINUX_ARM_SMCCC_H*/
<span class="p_header">diff --git a/include/linux/crypto.h b/include/linux/crypto.h</span>
<span class="p_header">index 84da9978e951..cc36484d29e1 100644</span>
<span class="p_header">--- a/include/linux/crypto.h</span>
<span class="p_header">+++ b/include/linux/crypto.h</span>
<span class="p_chunk">@@ -105,9 +105,17 @@</span> <span class="p_context"></span>
  */
 #define CRYPTO_ALG_INTERNAL		0x00002000
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Set if the algorithm has a -&gt;setkey() method but can be used without</span>
<span class="p_add">+ * calling it first, i.e. there is a default key.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define CRYPTO_ALG_OPTIONAL_KEY		0x00004000</span>
<span class="p_add">+</span>
 /*
  * Transform masks and values (for crt_flags).
  */
<span class="p_add">+#define CRYPTO_TFM_NEED_KEY		0x00000001</span>
<span class="p_add">+</span>
 #define CRYPTO_TFM_REQ_MASK		0x000fff00
 #define CRYPTO_TFM_RES_MASK		0xfff00000
 
<span class="p_header">diff --git a/include/linux/mtd/map.h b/include/linux/mtd/map.h</span>
<span class="p_header">index 3aa56e3104bb..b5b43f94f311 100644</span>
<span class="p_header">--- a/include/linux/mtd/map.h</span>
<span class="p_header">+++ b/include/linux/mtd/map.h</span>
<span class="p_chunk">@@ -270,75 +270,67 @@</span> <span class="p_context"> void map_destroy(struct mtd_info *mtd);</span>
 #define INVALIDATE_CACHED_RANGE(map, from, size) \
 	do { if (map-&gt;inval_cache) map-&gt;inval_cache(map, from, size); } while (0)
 
<span class="p_del">-</span>
<span class="p_del">-static inline int map_word_equal(struct map_info *map, map_word val1, map_word val2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; map_words(map); i++) {</span>
<span class="p_del">-		if (val1.x[i] != val2.x[i])</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline map_word map_word_and(struct map_info *map, map_word val1, map_word val2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	map_word r;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; map_words(map); i++)</span>
<span class="p_del">-		r.x[i] = val1.x[i] &amp; val2.x[i];</span>
<span class="p_del">-</span>
<span class="p_del">-	return r;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline map_word map_word_clr(struct map_info *map, map_word val1, map_word val2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	map_word r;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; map_words(map); i++)</span>
<span class="p_del">-		r.x[i] = val1.x[i] &amp; ~val2.x[i];</span>
<span class="p_del">-</span>
<span class="p_del">-	return r;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline map_word map_word_or(struct map_info *map, map_word val1, map_word val2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	map_word r;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; map_words(map); i++)</span>
<span class="p_del">-		r.x[i] = val1.x[i] | val2.x[i];</span>
<span class="p_del">-</span>
<span class="p_del">-	return r;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int map_word_andequal(struct map_info *map, map_word val1, map_word val2, map_word val3)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; map_words(map); i++) {</span>
<span class="p_del">-		if ((val1.x[i] &amp; val2.x[i]) != val3.x[i])</span>
<span class="p_del">-			return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline int map_word_bitsset(struct map_info *map, map_word val1, map_word val2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; map_words(map); i++) {</span>
<span class="p_del">-		if (val1.x[i] &amp; val2.x[i])</span>
<span class="p_del">-			return 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+#define map_word_equal(map, val1, val2)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	int i, ret = 1;							\</span>
<span class="p_add">+	for (i = 0; i &lt; map_words(map); i++)				\</span>
<span class="p_add">+		if ((val1).x[i] != (val2).x[i]) {			\</span>
<span class="p_add">+			ret = 0;					\</span>
<span class="p_add">+			break;						\</span>
<span class="p_add">+		}							\</span>
<span class="p_add">+	ret;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define map_word_and(map, val1, val2)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	map_word r;							\</span>
<span class="p_add">+	int i;								\</span>
<span class="p_add">+	for (i = 0; i &lt; map_words(map); i++)				\</span>
<span class="p_add">+		r.x[i] = (val1).x[i] &amp; (val2).x[i];			\</span>
<span class="p_add">+	r;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define map_word_clr(map, val1, val2)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	map_word r;							\</span>
<span class="p_add">+	int i;								\</span>
<span class="p_add">+	for (i = 0; i &lt; map_words(map); i++)				\</span>
<span class="p_add">+		r.x[i] = (val1).x[i] &amp; ~(val2).x[i];			\</span>
<span class="p_add">+	r;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define map_word_or(map, val1, val2)					\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	map_word r;							\</span>
<span class="p_add">+	int i;								\</span>
<span class="p_add">+	for (i = 0; i &lt; map_words(map); i++)				\</span>
<span class="p_add">+		r.x[i] = (val1).x[i] | (val2).x[i];			\</span>
<span class="p_add">+	r;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define map_word_andequal(map, val1, val2, val3)			\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	int i, ret = 1;							\</span>
<span class="p_add">+	for (i = 0; i &lt; map_words(map); i++) {				\</span>
<span class="p_add">+		if (((val1).x[i] &amp; (val2).x[i]) != (val2).x[i]) {	\</span>
<span class="p_add">+			ret = 0;					\</span>
<span class="p_add">+			break;						\</span>
<span class="p_add">+		}							\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+	ret;								\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define map_word_bitsset(map, val1, val2)				\</span>
<span class="p_add">+({									\</span>
<span class="p_add">+	int i, ret = 0;							\</span>
<span class="p_add">+	for (i = 0; i &lt; map_words(map); i++) {				\</span>
<span class="p_add">+		if ((val1).x[i] &amp; (val2).x[i]) {			\</span>
<span class="p_add">+			ret = 1;					\</span>
<span class="p_add">+			break;						\</span>
<span class="p_add">+		}							\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+	ret;								\</span>
<span class="p_add">+})</span>
 
 static inline map_word map_word_load(struct map_info *map, const void *ptr)
 {
<span class="p_header">diff --git a/include/linux/nfs4.h b/include/linux/nfs4.h</span>
<span class="p_header">index 47adac640191..57ffaa20d564 100644</span>
<span class="p_header">--- a/include/linux/nfs4.h</span>
<span class="p_header">+++ b/include/linux/nfs4.h</span>
<span class="p_chunk">@@ -457,7 +457,12 @@</span> <span class="p_context"> enum lock_type4 {</span>
 
 #define NFS4_DEBUG 1
 
<span class="p_del">-/* Index of predefined Linux client operations */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Index of predefined Linux client operations</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To ensure that /proc/net/rpc/nfs remains correctly ordered, please</span>
<span class="p_add">+ * append only to this enum when adding new client operations.</span>
<span class="p_add">+ */</span>
 
 enum {
 	NFSPROC4_CLNT_NULL = 0,		/* Unused */
<span class="p_chunk">@@ -480,7 +485,6 @@</span> <span class="p_context"> enum {</span>
 	NFSPROC4_CLNT_ACCESS,
 	NFSPROC4_CLNT_GETATTR,
 	NFSPROC4_CLNT_LOOKUP,
<span class="p_del">-	NFSPROC4_CLNT_LOOKUPP,</span>
 	NFSPROC4_CLNT_LOOKUP_ROOT,
 	NFSPROC4_CLNT_REMOVE,
 	NFSPROC4_CLNT_RENAME,
<span class="p_chunk">@@ -500,7 +504,6 @@</span> <span class="p_context"> enum {</span>
 	NFSPROC4_CLNT_SECINFO,
 	NFSPROC4_CLNT_FSID_PRESENT,
 
<span class="p_del">-	/* nfs41 */</span>
 	NFSPROC4_CLNT_EXCHANGE_ID,
 	NFSPROC4_CLNT_CREATE_SESSION,
 	NFSPROC4_CLNT_DESTROY_SESSION,
<span class="p_chunk">@@ -518,13 +521,14 @@</span> <span class="p_context"> enum {</span>
 	NFSPROC4_CLNT_BIND_CONN_TO_SESSION,
 	NFSPROC4_CLNT_DESTROY_CLIENTID,
 
<span class="p_del">-	/* nfs42 */</span>
 	NFSPROC4_CLNT_SEEK,
 	NFSPROC4_CLNT_ALLOCATE,
 	NFSPROC4_CLNT_DEALLOCATE,
 	NFSPROC4_CLNT_LAYOUTSTATS,
 	NFSPROC4_CLNT_CLONE,
 	NFSPROC4_CLNT_COPY,
<span class="p_add">+</span>
<span class="p_add">+	NFSPROC4_CLNT_LOOKUPP,</span>
 };
 
 /* nfs41 types */
<span class="p_header">diff --git a/include/linux/psci.h b/include/linux/psci.h</span>
<span class="p_header">index bdea1cb5e1db..347077cf19c6 100644</span>
<span class="p_header">--- a/include/linux/psci.h</span>
<span class="p_header">+++ b/include/linux/psci.h</span>
<span class="p_chunk">@@ -25,7 +25,19 @@</span> <span class="p_context"> bool psci_tos_resident_on(int cpu);</span>
 int psci_cpu_init_idle(unsigned int cpu);
 int psci_cpu_suspend_enter(unsigned long index);
 
<span class="p_add">+enum psci_conduit {</span>
<span class="p_add">+	PSCI_CONDUIT_NONE,</span>
<span class="p_add">+	PSCI_CONDUIT_SMC,</span>
<span class="p_add">+	PSCI_CONDUIT_HVC,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+enum smccc_version {</span>
<span class="p_add">+	SMCCC_VERSION_1_0,</span>
<span class="p_add">+	SMCCC_VERSION_1_1,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct psci_operations {
<span class="p_add">+	u32 (*get_version)(void);</span>
 	int (*cpu_suspend)(u32 state, unsigned long entry_point);
 	int (*cpu_off)(u32 state);
 	int (*cpu_on)(unsigned long cpuid, unsigned long entry_point);
<span class="p_chunk">@@ -33,6 +45,8 @@</span> <span class="p_context"> struct psci_operations {</span>
 	int (*affinity_info)(unsigned long target_affinity,
 			unsigned long lowest_affinity_level);
 	int (*migrate_info_type)(void);
<span class="p_add">+	enum psci_conduit conduit;</span>
<span class="p_add">+	enum smccc_version smccc_version;</span>
 };
 
 extern struct psci_operations psci_ops;
<span class="p_header">diff --git a/include/scsi/scsi_host.h b/include/scsi/scsi_host.h</span>
<span class="p_header">index a8b7bf879ced..1a1df0d21ee3 100644</span>
<span class="p_header">--- a/include/scsi/scsi_host.h</span>
<span class="p_header">+++ b/include/scsi/scsi_host.h</span>
<span class="p_chunk">@@ -571,6 +571,8 @@</span> <span class="p_context"> struct Scsi_Host {</span>
 		struct blk_mq_tag_set	tag_set;
 	};
 
<span class="p_add">+	struct rcu_head rcu;</span>
<span class="p_add">+</span>
 	atomic_t host_busy;		   /* commands actually active on low-level */
 	atomic_t host_blocked;
 
<span class="p_header">diff --git a/include/uapi/linux/psci.h b/include/uapi/linux/psci.h</span>
<span class="p_header">index 760e52a9640f..b3bcabe380da 100644</span>
<span class="p_header">--- a/include/uapi/linux/psci.h</span>
<span class="p_header">+++ b/include/uapi/linux/psci.h</span>
<span class="p_chunk">@@ -88,6 +88,9 @@</span> <span class="p_context"></span>
 		(((ver) &amp; PSCI_VERSION_MAJOR_MASK) &gt;&gt; PSCI_VERSION_MAJOR_SHIFT)
 #define PSCI_VERSION_MINOR(ver)			\
 		((ver) &amp; PSCI_VERSION_MINOR_MASK)
<span class="p_add">+#define PSCI_VERSION(maj, min)						\</span>
<span class="p_add">+	((((maj) &lt;&lt; PSCI_VERSION_MAJOR_SHIFT) &amp; PSCI_VERSION_MAJOR_MASK) | \</span>
<span class="p_add">+	 ((min) &amp; PSCI_VERSION_MINOR_MASK))</span>
 
 /* PSCI features decoding (&gt;=1.0) */
 #define PSCI_1_0_FEATURES_CPU_SUSPEND_PF_SHIFT	1
<span class="p_header">diff --git a/kernel/async.c b/kernel/async.c</span>
<span class="p_header">index 2cbd3dd5940d..a893d6170944 100644</span>
<span class="p_header">--- a/kernel/async.c</span>
<span class="p_header">+++ b/kernel/async.c</span>
<span class="p_chunk">@@ -84,20 +84,24 @@</span> <span class="p_context"> static atomic_t entry_count;</span>
 
 static async_cookie_t lowest_in_progress(struct async_domain *domain)
 {
<span class="p_del">-	struct list_head *pending;</span>
<span class="p_add">+	struct async_entry *first = NULL;</span>
 	async_cookie_t ret = ASYNC_COOKIE_MAX;
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;async_lock, flags);
 
<span class="p_del">-	if (domain)</span>
<span class="p_del">-		pending = &amp;domain-&gt;pending;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		pending = &amp;async_global_pending;</span>
<span class="p_add">+	if (domain) {</span>
<span class="p_add">+		if (!list_empty(&amp;domain-&gt;pending))</span>
<span class="p_add">+			first = list_first_entry(&amp;domain-&gt;pending,</span>
<span class="p_add">+					struct async_entry, domain_list);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!list_empty(&amp;async_global_pending))</span>
<span class="p_add">+			first = list_first_entry(&amp;async_global_pending,</span>
<span class="p_add">+					struct async_entry, global_list);</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (!list_empty(pending))</span>
<span class="p_del">-		ret = list_first_entry(pending, struct async_entry,</span>
<span class="p_del">-				       domain_list)-&gt;cookie;</span>
<span class="p_add">+	if (first)</span>
<span class="p_add">+		ret = first-&gt;cookie;</span>
 
 	spin_unlock_irqrestore(&amp;async_lock, flags);
 	return ret;
<span class="p_header">diff --git a/kernel/rcu/update.c b/kernel/rcu/update.c</span>
<span class="p_header">index 5033b66d2753..7a577bd989a4 100644</span>
<span class="p_header">--- a/kernel/rcu/update.c</span>
<span class="p_header">+++ b/kernel/rcu/update.c</span>
<span class="p_chunk">@@ -421,11 +421,13 @@</span> <span class="p_context"> void init_rcu_head(struct rcu_head *head)</span>
 {
 	debug_object_init(head, &amp;rcuhead_debug_descr);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(init_rcu_head);</span>
 
 void destroy_rcu_head(struct rcu_head *head)
 {
 	debug_object_free(head, &amp;rcuhead_debug_descr);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(destroy_rcu_head);</span>
 
 static bool rcuhead_is_static_object(void *addr)
 {
<span class="p_header">diff --git a/kernel/relay.c b/kernel/relay.c</span>
<span class="p_header">index 39a9dfc69486..55da824f4adc 100644</span>
<span class="p_header">--- a/kernel/relay.c</span>
<span class="p_header">+++ b/kernel/relay.c</span>
<span class="p_chunk">@@ -611,7 +611,6 @@</span> <span class="p_context"> struct rchan *relay_open(const char *base_filename,</span>
 
 	kref_put(&amp;chan-&gt;kref, relay_destroy_channel);
 	mutex_unlock(&amp;relay_channels_mutex);
<span class="p_del">-	kfree(chan);</span>
 	return NULL;
 }
 EXPORT_SYMBOL_GPL(relay_open);
<span class="p_header">diff --git a/kernel/sched/rt.c b/kernel/sched/rt.c</span>
<span class="p_header">index 7464c5c4de46..298f62b8662d 100644</span>
<span class="p_header">--- a/kernel/sched/rt.c</span>
<span class="p_header">+++ b/kernel/sched/rt.c</span>
<span class="p_chunk">@@ -1907,9 +1907,8 @@</span> <span class="p_context"> static void push_rt_tasks(struct rq *rq)</span>
  * the rt_loop_next will cause the iterator to perform another scan.
  *
  */
<span class="p_del">-static int rto_next_cpu(struct rq *rq)</span>
<span class="p_add">+static int rto_next_cpu(struct root_domain *rd)</span>
 {
<span class="p_del">-	struct root_domain *rd = rq-&gt;rd;</span>
 	int next;
 	int cpu;
 
<span class="p_chunk">@@ -1985,19 +1984,24 @@</span> <span class="p_context"> static void tell_cpu_to_push(struct rq *rq)</span>
 	 * Otherwise it is finishing up and an ipi needs to be sent.
 	 */
 	if (rq-&gt;rd-&gt;rto_cpu &lt; 0)
<span class="p_del">-		cpu = rto_next_cpu(rq);</span>
<span class="p_add">+		cpu = rto_next_cpu(rq-&gt;rd);</span>
 
 	raw_spin_unlock(&amp;rq-&gt;rd-&gt;rto_lock);
 
 	rto_start_unlock(&amp;rq-&gt;rd-&gt;rto_loop_start);
 
<span class="p_del">-	if (cpu &gt;= 0)</span>
<span class="p_add">+	if (cpu &gt;= 0) {</span>
<span class="p_add">+		/* Make sure the rd does not get freed while pushing */</span>
<span class="p_add">+		sched_get_rd(rq-&gt;rd);</span>
 		irq_work_queue_on(&amp;rq-&gt;rd-&gt;rto_push_work, cpu);
<span class="p_add">+	}</span>
 }
 
 /* Called from hardirq context */
 void rto_push_irq_work_func(struct irq_work *work)
 {
<span class="p_add">+	struct root_domain *rd =</span>
<span class="p_add">+		container_of(work, struct root_domain, rto_push_work);</span>
 	struct rq *rq;
 	int cpu;
 
<span class="p_chunk">@@ -2013,18 +2017,20 @@</span> <span class="p_context"> void rto_push_irq_work_func(struct irq_work *work)</span>
 		raw_spin_unlock(&amp;rq-&gt;lock);
 	}
 
<span class="p_del">-	raw_spin_lock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
<span class="p_add">+	raw_spin_lock(&amp;rd-&gt;rto_lock);</span>
 
 	/* Pass the IPI to the next rt overloaded queue */
<span class="p_del">-	cpu = rto_next_cpu(rq);</span>
<span class="p_add">+	cpu = rto_next_cpu(rd);</span>
 
<span class="p_del">-	raw_spin_unlock(&amp;rq-&gt;rd-&gt;rto_lock);</span>
<span class="p_add">+	raw_spin_unlock(&amp;rd-&gt;rto_lock);</span>
 
<span class="p_del">-	if (cpu &lt; 0)</span>
<span class="p_add">+	if (cpu &lt; 0) {</span>
<span class="p_add">+		sched_put_rd(rd);</span>
 		return;
<span class="p_add">+	}</span>
 
 	/* Try the next RT overloaded CPU */
<span class="p_del">-	irq_work_queue_on(&amp;rq-&gt;rd-&gt;rto_push_work, cpu);</span>
<span class="p_add">+	irq_work_queue_on(&amp;rd-&gt;rto_push_work, cpu);</span>
 }
 #endif /* HAVE_RT_PUSH_IPI */
 
<span class="p_header">diff --git a/kernel/sched/sched.h b/kernel/sched/sched.h</span>
<span class="p_header">index b732e779fe7d..307c35d33660 100644</span>
<span class="p_header">--- a/kernel/sched/sched.h</span>
<span class="p_header">+++ b/kernel/sched/sched.h</span>
<span class="p_chunk">@@ -661,6 +661,8 @@</span> <span class="p_context"> extern struct mutex sched_domains_mutex;</span>
 extern void init_defrootdomain(void);
 extern int sched_init_domains(const struct cpumask *cpu_map);
 extern void rq_attach_root(struct rq *rq, struct root_domain *rd);
<span class="p_add">+extern void sched_get_rd(struct root_domain *rd);</span>
<span class="p_add">+extern void sched_put_rd(struct root_domain *rd);</span>
 
 #ifdef HAVE_RT_PUSH_IPI
 extern void rto_push_irq_work_func(struct irq_work *work);
<span class="p_header">diff --git a/kernel/sched/topology.c b/kernel/sched/topology.c</span>
<span class="p_header">index 093f2ceba2e2..659e075ef70b 100644</span>
<span class="p_header">--- a/kernel/sched/topology.c</span>
<span class="p_header">+++ b/kernel/sched/topology.c</span>
<span class="p_chunk">@@ -258,6 +258,19 @@</span> <span class="p_context"> void rq_attach_root(struct rq *rq, struct root_domain *rd)</span>
 		call_rcu_sched(&amp;old_rd-&gt;rcu, free_rootdomain);
 }
 
<span class="p_add">+void sched_get_rd(struct root_domain *rd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_inc(&amp;rd-&gt;refcount);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void sched_put_rd(struct root_domain *rd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!atomic_dec_and_test(&amp;rd-&gt;refcount))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	call_rcu_sched(&amp;rd-&gt;rcu, free_rootdomain);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int init_rootdomain(struct root_domain *rd)
 {
 	if (!zalloc_cpumask_var(&amp;rd-&gt;span, GFP_KERNEL))
<span class="p_header">diff --git a/kernel/sched/wait.c b/kernel/sched/wait.c</span>
<span class="p_header">index 98feab7933c7..929ecb7d6b78 100644</span>
<span class="p_header">--- a/kernel/sched/wait.c</span>
<span class="p_header">+++ b/kernel/sched/wait.c</span>
<span class="p_chunk">@@ -27,7 +27,7 @@</span> <span class="p_context"> void add_wait_queue(struct wait_queue_head *wq_head, struct wait_queue_entry *wq</span>
 
 	wq_entry-&gt;flags &amp;= ~WQ_FLAG_EXCLUSIVE;
 	spin_lock_irqsave(&amp;wq_head-&gt;lock, flags);
<span class="p_del">-	__add_wait_queue_entry_tail(wq_head, wq_entry);</span>
<span class="p_add">+	__add_wait_queue(wq_head, wq_entry);</span>
 	spin_unlock_irqrestore(&amp;wq_head-&gt;lock, flags);
 }
 EXPORT_SYMBOL(add_wait_queue);
<span class="p_header">diff --git a/kernel/trace/ftrace.c b/kernel/trace/ftrace.c</span>
<span class="p_header">index 8319e09e15b9..7379bcf3baa0 100644</span>
<span class="p_header">--- a/kernel/trace/ftrace.c</span>
<span class="p_header">+++ b/kernel/trace/ftrace.c</span>
<span class="p_chunk">@@ -4488,7 +4488,6 @@</span> <span class="p_context"> unregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,</span>
 		func_g.type = filter_parse_regex(glob, strlen(glob),
 						 &amp;func_g.search, &amp;not);
 		func_g.len = strlen(func_g.search);
<span class="p_del">-		func_g.search = glob;</span>
 
 		/* we do not support &#39;!&#39; for function probes */
 		if (WARN_ON(not))
<span class="p_header">diff --git a/lib/Kconfig.debug b/lib/Kconfig.debug</span>
<span class="p_header">index ff21b4dbb392..00cb02daeddd 100644</span>
<span class="p_header">--- a/lib/Kconfig.debug</span>
<span class="p_header">+++ b/lib/Kconfig.debug</span>
<span class="p_chunk">@@ -217,7 +217,7 @@</span> <span class="p_context"> config ENABLE_MUST_CHECK</span>
 config FRAME_WARN
 	int &quot;Warn for stack frames larger than (needs gcc 4.4)&quot;
 	range 0 8192
<span class="p_del">-	default 0 if KASAN</span>
<span class="p_add">+	default 3072 if KASAN_EXTRA</span>
 	default 2048 if GCC_PLUGIN_LATENT_ENTROPY
 	default 1280 if (!64BIT &amp;&amp; PARISC)
 	default 1024 if (!64BIT &amp;&amp; !PARISC)
<span class="p_header">diff --git a/lib/Kconfig.kasan b/lib/Kconfig.kasan</span>
<span class="p_header">index bd38aab05929..3d35d062970d 100644</span>
<span class="p_header">--- a/lib/Kconfig.kasan</span>
<span class="p_header">+++ b/lib/Kconfig.kasan</span>
<span class="p_chunk">@@ -20,6 +20,17 @@</span> <span class="p_context"> config KASAN</span>
 	  Currently CONFIG_KASAN doesn&#39;t work with CONFIG_DEBUG_SLAB
 	  (the resulting kernel does not boot).
 
<span class="p_add">+config KASAN_EXTRA</span>
<span class="p_add">+	bool &quot;KAsan: extra checks&quot;</span>
<span class="p_add">+	depends on KASAN &amp;&amp; DEBUG_KERNEL &amp;&amp; !COMPILE_TEST</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  This enables further checks in the kernel address sanitizer, for now</span>
<span class="p_add">+	  it only includes the address-use-after-scope check that can lead</span>
<span class="p_add">+	  to excessive kernel stack usage, frame size warnings and longer</span>
<span class="p_add">+	  compile time.</span>
<span class="p_add">+	  https://gcc.gnu.org/bugzilla/show_bug.cgi?id=81715 has more</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 choice
 	prompt &quot;Instrumentation type&quot;
 	depends on KASAN
<span class="p_header">diff --git a/lib/ubsan.c b/lib/ubsan.c</span>
<span class="p_header">index fb0409df1bcf..50d1d5c25deb 100644</span>
<span class="p_header">--- a/lib/ubsan.c</span>
<span class="p_header">+++ b/lib/ubsan.c</span>
<span class="p_chunk">@@ -265,14 +265,14 @@</span> <span class="p_context"> void __ubsan_handle_divrem_overflow(struct overflow_data *data,</span>
 }
 EXPORT_SYMBOL(__ubsan_handle_divrem_overflow);
 
<span class="p_del">-static void handle_null_ptr_deref(struct type_mismatch_data *data)</span>
<span class="p_add">+static void handle_null_ptr_deref(struct type_mismatch_data_common *data)</span>
 {
 	unsigned long flags;
 
<span class="p_del">-	if (suppress_report(&amp;data-&gt;location))</span>
<span class="p_add">+	if (suppress_report(data-&gt;location))</span>
 		return;
 
<span class="p_del">-	ubsan_prologue(&amp;data-&gt;location, &amp;flags);</span>
<span class="p_add">+	ubsan_prologue(data-&gt;location, &amp;flags);</span>
 
 	pr_err(&quot;%s null pointer of type %s\n&quot;,
 		type_check_kinds[data-&gt;type_check_kind],
<span class="p_chunk">@@ -281,15 +281,15 @@</span> <span class="p_context"> static void handle_null_ptr_deref(struct type_mismatch_data *data)</span>
 	ubsan_epilogue(&amp;flags);
 }
 
<span class="p_del">-static void handle_missaligned_access(struct type_mismatch_data *data,</span>
<span class="p_add">+static void handle_misaligned_access(struct type_mismatch_data_common *data,</span>
 				unsigned long ptr)
 {
 	unsigned long flags;
 
<span class="p_del">-	if (suppress_report(&amp;data-&gt;location))</span>
<span class="p_add">+	if (suppress_report(data-&gt;location))</span>
 		return;
 
<span class="p_del">-	ubsan_prologue(&amp;data-&gt;location, &amp;flags);</span>
<span class="p_add">+	ubsan_prologue(data-&gt;location, &amp;flags);</span>
 
 	pr_err(&quot;%s misaligned address %p for type %s\n&quot;,
 		type_check_kinds[data-&gt;type_check_kind],
<span class="p_chunk">@@ -299,15 +299,15 @@</span> <span class="p_context"> static void handle_missaligned_access(struct type_mismatch_data *data,</span>
 	ubsan_epilogue(&amp;flags);
 }
 
<span class="p_del">-static void handle_object_size_mismatch(struct type_mismatch_data *data,</span>
<span class="p_add">+static void handle_object_size_mismatch(struct type_mismatch_data_common *data,</span>
 					unsigned long ptr)
 {
 	unsigned long flags;
 
<span class="p_del">-	if (suppress_report(&amp;data-&gt;location))</span>
<span class="p_add">+	if (suppress_report(data-&gt;location))</span>
 		return;
 
<span class="p_del">-	ubsan_prologue(&amp;data-&gt;location, &amp;flags);</span>
<span class="p_add">+	ubsan_prologue(data-&gt;location, &amp;flags);</span>
 	pr_err(&quot;%s address %p with insufficient space\n&quot;,
 		type_check_kinds[data-&gt;type_check_kind],
 		(void *) ptr);
<span class="p_chunk">@@ -315,19 +315,47 @@</span> <span class="p_context"> static void handle_object_size_mismatch(struct type_mismatch_data *data,</span>
 	ubsan_epilogue(&amp;flags);
 }
 
<span class="p_del">-void __ubsan_handle_type_mismatch(struct type_mismatch_data *data,</span>
<span class="p_add">+static void ubsan_type_mismatch_common(struct type_mismatch_data_common *data,</span>
 				unsigned long ptr)
 {
 
 	if (!ptr)
 		handle_null_ptr_deref(data);
 	else if (data-&gt;alignment &amp;&amp; !IS_ALIGNED(ptr, data-&gt;alignment))
<span class="p_del">-		handle_missaligned_access(data, ptr);</span>
<span class="p_add">+		handle_misaligned_access(data, ptr);</span>
 	else
 		handle_object_size_mismatch(data, ptr);
 }
<span class="p_add">+</span>
<span class="p_add">+void __ubsan_handle_type_mismatch(struct type_mismatch_data *data,</span>
<span class="p_add">+				unsigned long ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct type_mismatch_data_common common_data = {</span>
<span class="p_add">+		.location = &amp;data-&gt;location,</span>
<span class="p_add">+		.type = data-&gt;type,</span>
<span class="p_add">+		.alignment = data-&gt;alignment,</span>
<span class="p_add">+		.type_check_kind = data-&gt;type_check_kind</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	ubsan_type_mismatch_common(&amp;common_data, ptr);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(__ubsan_handle_type_mismatch);
 
<span class="p_add">+void __ubsan_handle_type_mismatch_v1(struct type_mismatch_data_v1 *data,</span>
<span class="p_add">+				unsigned long ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+</span>
<span class="p_add">+	struct type_mismatch_data_common common_data = {</span>
<span class="p_add">+		.location = &amp;data-&gt;location,</span>
<span class="p_add">+		.type = data-&gt;type,</span>
<span class="p_add">+		.alignment = 1UL &lt;&lt; data-&gt;log_alignment,</span>
<span class="p_add">+		.type_check_kind = data-&gt;type_check_kind</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	ubsan_type_mismatch_common(&amp;common_data, ptr);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(__ubsan_handle_type_mismatch_v1);</span>
<span class="p_add">+</span>
 void __ubsan_handle_nonnull_return(struct nonnull_return_data *data)
 {
 	unsigned long flags;
<span class="p_header">diff --git a/lib/ubsan.h b/lib/ubsan.h</span>
<span class="p_header">index 88f23557edbe..7e30b26497e0 100644</span>
<span class="p_header">--- a/lib/ubsan.h</span>
<span class="p_header">+++ b/lib/ubsan.h</span>
<span class="p_chunk">@@ -37,6 +37,20 @@</span> <span class="p_context"> struct type_mismatch_data {</span>
 	unsigned char type_check_kind;
 };
 
<span class="p_add">+struct type_mismatch_data_v1 {</span>
<span class="p_add">+	struct source_location location;</span>
<span class="p_add">+	struct type_descriptor *type;</span>
<span class="p_add">+	unsigned char log_alignment;</span>
<span class="p_add">+	unsigned char type_check_kind;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+struct type_mismatch_data_common {</span>
<span class="p_add">+	struct source_location *location;</span>
<span class="p_add">+	struct type_descriptor *type;</span>
<span class="p_add">+	unsigned long alignment;</span>
<span class="p_add">+	unsigned char type_check_kind;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct nonnull_arg_data {
 	struct source_location location;
 	struct source_location attr_location;
<span class="p_header">diff --git a/net/dccp/proto.c b/net/dccp/proto.c</span>
<span class="p_header">index b68168fcc06a..9d43c1f40274 100644</span>
<span class="p_header">--- a/net/dccp/proto.c</span>
<span class="p_header">+++ b/net/dccp/proto.c</span>
<span class="p_chunk">@@ -259,6 +259,7 @@</span> <span class="p_context"> int dccp_disconnect(struct sock *sk, int flags)</span>
 {
 	struct inet_connection_sock *icsk = inet_csk(sk);
 	struct inet_sock *inet = inet_sk(sk);
<span class="p_add">+	struct dccp_sock *dp = dccp_sk(sk);</span>
 	int err = 0;
 	const int old_state = sk-&gt;sk_state;
 
<span class="p_chunk">@@ -278,6 +279,10 @@</span> <span class="p_context"> int dccp_disconnect(struct sock *sk, int flags)</span>
 		sk-&gt;sk_err = ECONNRESET;
 
 	dccp_clear_xmit_timers(sk);
<span class="p_add">+	ccid_hc_rx_delete(dp-&gt;dccps_hc_rx_ccid, sk);</span>
<span class="p_add">+	ccid_hc_tx_delete(dp-&gt;dccps_hc_tx_ccid, sk);</span>
<span class="p_add">+	dp-&gt;dccps_hc_rx_ccid = NULL;</span>
<span class="p_add">+	dp-&gt;dccps_hc_tx_ccid = NULL;</span>
 
 	__skb_queue_purge(&amp;sk-&gt;sk_receive_queue);
 	__skb_queue_purge(&amp;sk-&gt;sk_write_queue);
<span class="p_header">diff --git a/scripts/Makefile.kasan b/scripts/Makefile.kasan</span>
<span class="p_header">index 1ce7115aa499..97a56c0b565a 100644</span>
<span class="p_header">--- a/scripts/Makefile.kasan</span>
<span class="p_header">+++ b/scripts/Makefile.kasan</span>
<span class="p_chunk">@@ -30,5 +30,10 @@</span> <span class="p_context"> else</span>
     endif
 endif
 
<span class="p_add">+ifdef CONFIG_KASAN_EXTRA</span>
 CFLAGS_KASAN += $(call cc-option, -fsanitize-address-use-after-scope)
 endif
<span class="p_add">+</span>
<span class="p_add">+CFLAGS_KASAN_NOSANITIZE := -fno-builtin</span>
<span class="p_add">+</span>
<span class="p_add">+endif</span>
<span class="p_header">diff --git a/scripts/Makefile.lib b/scripts/Makefile.lib</span>
<span class="p_header">index 04b5633df1cf..0b46136a91a8 100644</span>
<span class="p_header">--- a/scripts/Makefile.lib</span>
<span class="p_header">+++ b/scripts/Makefile.lib</span>
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> endif</span>
 ifeq ($(CONFIG_KASAN),y)
 _c_flags += $(if $(patsubst n%,, \
 		$(KASAN_SANITIZE_$(basetarget).o)$(KASAN_SANITIZE)y), \
<span class="p_del">-		$(CFLAGS_KASAN))</span>
<span class="p_add">+		$(CFLAGS_KASAN), $(CFLAGS_KASAN_NOSANITIZE))</span>
 endif
 
 ifeq ($(CONFIG_UBSAN),y)
<span class="p_header">diff --git a/sound/soc/intel/skylake/skl-nhlt.c b/sound/soc/intel/skylake/skl-nhlt.c</span>
<span class="p_header">index e7d766d56c8e..55859c5b456f 100644</span>
<span class="p_header">--- a/sound/soc/intel/skylake/skl-nhlt.c</span>
<span class="p_header">+++ b/sound/soc/intel/skylake/skl-nhlt.c</span>
<span class="p_chunk">@@ -41,7 +41,8 @@</span> <span class="p_context"> struct nhlt_acpi_table *skl_nhlt_init(struct device *dev)</span>
 	obj = acpi_evaluate_dsm(handle, &amp;osc_guid, 1, 1, NULL);
 	if (obj &amp;&amp; obj-&gt;type == ACPI_TYPE_BUFFER) {
 		nhlt_ptr = (struct nhlt_resource_desc  *)obj-&gt;buffer.pointer;
<span class="p_del">-		nhlt_table = (struct nhlt_acpi_table *)</span>
<span class="p_add">+		if (nhlt_ptr-&gt;length)</span>
<span class="p_add">+			nhlt_table = (struct nhlt_acpi_table *)</span>
 				memremap(nhlt_ptr-&gt;min_addr, nhlt_ptr-&gt;length,
 				MEMREMAP_WB);
 		ACPI_FREE(obj);
<span class="p_header">diff --git a/sound/soc/rockchip/rockchip_i2s.c b/sound/soc/rockchip/rockchip_i2s.c</span>
<span class="p_header">index b6590467fd14..66fc13a2396a 100644</span>
<span class="p_header">--- a/sound/soc/rockchip/rockchip_i2s.c</span>
<span class="p_header">+++ b/sound/soc/rockchip/rockchip_i2s.c</span>
<span class="p_chunk">@@ -504,6 +504,7 @@</span> <span class="p_context"> static bool rockchip_i2s_rd_reg(struct device *dev, unsigned int reg)</span>
 	case I2S_INTCR:
 	case I2S_XFER:
 	case I2S_CLR:
<span class="p_add">+	case I2S_TXDR:</span>
 	case I2S_RXDR:
 	case I2S_FIFOLR:
 	case I2S_INTSR:
<span class="p_chunk">@@ -518,6 +519,9 @@</span> <span class="p_context"> static bool rockchip_i2s_volatile_reg(struct device *dev, unsigned int reg)</span>
 	switch (reg) {
 	case I2S_INTSR:
 	case I2S_CLR:
<span class="p_add">+	case I2S_FIFOLR:</span>
<span class="p_add">+	case I2S_TXDR:</span>
<span class="p_add">+	case I2S_RXDR:</span>
 		return true;
 	default:
 		return false;
<span class="p_chunk">@@ -527,6 +531,8 @@</span> <span class="p_context"> static bool rockchip_i2s_volatile_reg(struct device *dev, unsigned int reg)</span>
 static bool rockchip_i2s_precious_reg(struct device *dev, unsigned int reg)
 {
 	switch (reg) {
<span class="p_add">+	case I2S_RXDR:</span>
<span class="p_add">+		return true;</span>
 	default:
 		return false;
 	}
<span class="p_header">diff --git a/tools/objtool/check.c b/tools/objtool/check.c</span>
<span class="p_header">index 9cd028aa1509..2e458eb45586 100644</span>
<span class="p_header">--- a/tools/objtool/check.c</span>
<span class="p_header">+++ b/tools/objtool/check.c</span>
<span class="p_chunk">@@ -851,8 +851,14 @@</span> <span class="p_context"> static int add_switch_table(struct objtool_file *file, struct symbol *func,</span>
  *    This is a fairly uncommon pattern which is new for GCC 6.  As of this
  *    writing, there are 11 occurrences of it in the allmodconfig kernel.
  *
<span class="p_add">+ *    As of GCC 7 there are quite a few more of these and the &#39;in between&#39; code</span>
<span class="p_add">+ *    is significant. Esp. with KASAN enabled some of the code between the mov</span>
<span class="p_add">+ *    and jmpq uses .rodata itself, which can confuse things.</span>
<span class="p_add">+ *</span>
  *    TODO: Once we have DWARF CFI and smarter instruction decoding logic,
  *    ensure the same register is used in the mov and jump instructions.
<span class="p_add">+ *</span>
<span class="p_add">+ *    NOTE: RETPOLINE made it harder still to decode dynamic jumps.</span>
  */
 static struct rela *find_switch_table(struct objtool_file *file,
 				      struct symbol *func,
<span class="p_chunk">@@ -874,12 +880,25 @@</span> <span class="p_context"> static struct rela *find_switch_table(struct objtool_file *file,</span>
 						text_rela-&gt;addend + 4);
 		if (!rodata_rela)
 			return NULL;
<span class="p_add">+</span>
 		file-&gt;ignore_unreachables = true;
 		return rodata_rela;
 	}
 
 	/* case 3 */
<span class="p_del">-	func_for_each_insn_continue_reverse(file, func, insn) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Backward search using the @first_jump_src links, these help avoid</span>
<span class="p_add">+	 * much of the &#39;in between&#39; code. Which avoids us getting confused by</span>
<span class="p_add">+	 * it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (insn = list_prev_entry(insn, list);</span>
<span class="p_add">+</span>
<span class="p_add">+	     &amp;insn-&gt;list != &amp;file-&gt;insn_list &amp;&amp;</span>
<span class="p_add">+	     insn-&gt;sec == func-&gt;sec &amp;&amp;</span>
<span class="p_add">+	     insn-&gt;offset &gt;= func-&gt;offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	     insn = insn-&gt;first_jump_src ?: list_prev_entry(insn, list)) {</span>
<span class="p_add">+</span>
 		if (insn-&gt;type == INSN_JUMP_DYNAMIC)
 			break;
 
<span class="p_chunk">@@ -909,14 +928,32 @@</span> <span class="p_context"> static struct rela *find_switch_table(struct objtool_file *file,</span>
 	return NULL;
 }
 
<span class="p_add">+</span>
 static int add_func_switch_tables(struct objtool_file *file,
 				  struct symbol *func)
 {
<span class="p_del">-	struct instruction *insn, *prev_jump = NULL;</span>
<span class="p_add">+	struct instruction *insn, *last = NULL, *prev_jump = NULL;</span>
 	struct rela *rela, *prev_rela = NULL;
 	int ret;
 
 	func_for_each_insn(file, func, insn) {
<span class="p_add">+		if (!last)</span>
<span class="p_add">+			last = insn;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Store back-pointers for unconditional forward jumps such</span>
<span class="p_add">+		 * that find_switch_table() can back-track using those and</span>
<span class="p_add">+		 * avoid some potentially confusing code.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (insn-&gt;type == INSN_JUMP_UNCONDITIONAL &amp;&amp; insn-&gt;jump_dest &amp;&amp;</span>
<span class="p_add">+		    insn-&gt;offset &gt; last-&gt;offset &amp;&amp;</span>
<span class="p_add">+		    insn-&gt;jump_dest-&gt;offset &gt; insn-&gt;offset &amp;&amp;</span>
<span class="p_add">+		    !insn-&gt;jump_dest-&gt;first_jump_src) {</span>
<span class="p_add">+</span>
<span class="p_add">+			insn-&gt;jump_dest-&gt;first_jump_src = insn;</span>
<span class="p_add">+			last = insn-&gt;jump_dest;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (insn-&gt;type != INSN_JUMP_DYNAMIC)
 			continue;
 
<span class="p_header">diff --git a/tools/objtool/check.h b/tools/objtool/check.h</span>
<span class="p_header">index dbadb304a410..23a1d065cae1 100644</span>
<span class="p_header">--- a/tools/objtool/check.h</span>
<span class="p_header">+++ b/tools/objtool/check.h</span>
<span class="p_chunk">@@ -47,6 +47,7 @@</span> <span class="p_context"> struct instruction {</span>
 	bool alt_group, visited, dead_end, ignore, hint, save, restore, ignore_alts;
 	struct symbol *call_dest;
 	struct instruction *jump_dest;
<span class="p_add">+	struct instruction *first_jump_src;</span>
 	struct list_head alts;
 	struct symbol *func;
 	struct stack_op stack_op;
<span class="p_header">diff --git a/virt/kvm/arm/arm.c b/virt/kvm/arm/arm.c</span>
<span class="p_header">index 9a07ee94a230..8b6c42dc1aa9 100644</span>
<span class="p_header">--- a/virt/kvm/arm/arm.c</span>
<span class="p_header">+++ b/virt/kvm/arm/arm.c</span>
<span class="p_chunk">@@ -29,6 +29,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/kvm.h&gt;
 #include &lt;trace/events/kvm.h&gt;
 #include &lt;kvm/arm_pmu.h&gt;
<span class="p_add">+#include &lt;kvm/arm_psci.h&gt;</span>
 
 #define CREATE_TRACE_POINTS
 #include &quot;trace.h&quot;
<span class="p_chunk">@@ -44,7 +45,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/kvm_mmu.h&gt;
 #include &lt;asm/kvm_emulate.h&gt;
 #include &lt;asm/kvm_coproc.h&gt;
<span class="p_del">-#include &lt;asm/kvm_psci.h&gt;</span>
 #include &lt;asm/sections.h&gt;
 
 #ifdef REQUIRES_VIRT
<span class="p_chunk">@@ -1139,7 +1139,7 @@</span> <span class="p_context"> static void cpu_init_hyp_mode(void *dummy)</span>
 	pgd_ptr = kvm_mmu_get_httbr();
 	stack_page = __this_cpu_read(kvm_arm_hyp_stack_page);
 	hyp_stack_ptr = stack_page + PAGE_SIZE;
<span class="p_del">-	vector_ptr = (unsigned long)kvm_ksym_ref(__kvm_hyp_vector);</span>
<span class="p_add">+	vector_ptr = (unsigned long)kvm_get_hyp_vector();</span>
 
 	__cpu_init_hyp_mode(pgd_ptr, hyp_stack_ptr, vector_ptr);
 	__cpu_init_stage2();
<span class="p_chunk">@@ -1220,6 +1220,7 @@</span> <span class="p_context"> static int hyp_init_cpu_pm_notifier(struct notifier_block *self,</span>
 			cpu_hyp_reset();
 
 		return NOTIFY_OK;
<span class="p_add">+	case CPU_PM_ENTER_FAILED:</span>
 	case CPU_PM_EXIT:
 		if (__this_cpu_read(kvm_arm_hardware_enabled))
 			/* The hardware was enabled before suspend. */
<span class="p_chunk">@@ -1384,6 +1385,12 @@</span> <span class="p_context"> static int init_hyp_mode(void)</span>
 		goto out_err;
 	}
 
<span class="p_add">+	err = kvm_map_vectors();</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		kvm_err(&quot;Cannot map vectors\n&quot;);</span>
<span class="p_add">+		goto out_err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Map the Hyp stack pages
 	 */
<span class="p_header">diff --git a/virt/kvm/arm/psci.c b/virt/kvm/arm/psci.c</span>
<span class="p_header">index f1e363bab5e8..6919352cbf15 100644</span>
<span class="p_header">--- a/virt/kvm/arm/psci.c</span>
<span class="p_header">+++ b/virt/kvm/arm/psci.c</span>
<span class="p_chunk">@@ -15,16 +15,16 @@</span> <span class="p_context"></span>
  * along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.
  */
 
<span class="p_add">+#include &lt;linux/arm-smccc.h&gt;</span>
 #include &lt;linux/preempt.h&gt;
 #include &lt;linux/kvm_host.h&gt;
 #include &lt;linux/wait.h&gt;
 
 #include &lt;asm/cputype.h&gt;
 #include &lt;asm/kvm_emulate.h&gt;
<span class="p_del">-#include &lt;asm/kvm_psci.h&gt;</span>
 #include &lt;asm/kvm_host.h&gt;
 
<span class="p_del">-#include &lt;uapi/linux/psci.h&gt;</span>
<span class="p_add">+#include &lt;kvm/arm_psci.h&gt;</span>
 
 /*
  * This is an implementation of the Power State Coordination Interface
<span class="p_chunk">@@ -33,6 +33,38 @@</span> <span class="p_context"></span>
 
 #define AFFINITY_MASK(level)	~((0x1UL &lt;&lt; ((level) * MPIDR_LEVEL_BITS)) - 1)
 
<span class="p_add">+static u32 smccc_get_function(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vcpu_get_reg(vcpu, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long smccc_get_arg1(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vcpu_get_reg(vcpu, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long smccc_get_arg2(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vcpu_get_reg(vcpu, 2);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static unsigned long smccc_get_arg3(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vcpu_get_reg(vcpu, 3);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void smccc_set_retval(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+			     unsigned long a0,</span>
<span class="p_add">+			     unsigned long a1,</span>
<span class="p_add">+			     unsigned long a2,</span>
<span class="p_add">+			     unsigned long a3)</span>
<span class="p_add">+{</span>
<span class="p_add">+	vcpu_set_reg(vcpu, 0, a0);</span>
<span class="p_add">+	vcpu_set_reg(vcpu, 1, a1);</span>
<span class="p_add">+	vcpu_set_reg(vcpu, 2, a2);</span>
<span class="p_add">+	vcpu_set_reg(vcpu, 3, a3);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static unsigned long psci_affinity_mask(unsigned long affinity_level)
 {
 	if (affinity_level &lt;= 3)
<span class="p_chunk">@@ -78,7 +110,7 @@</span> <span class="p_context"> static unsigned long kvm_psci_vcpu_on(struct kvm_vcpu *source_vcpu)</span>
 	unsigned long context_id;
 	phys_addr_t target_pc;
 
<span class="p_del">-	cpu_id = vcpu_get_reg(source_vcpu, 1) &amp; MPIDR_HWID_BITMASK;</span>
<span class="p_add">+	cpu_id = smccc_get_arg1(source_vcpu) &amp; MPIDR_HWID_BITMASK;</span>
 	if (vcpu_mode_is_32bit(source_vcpu))
 		cpu_id &amp;= ~((u32) 0);
 
<span class="p_chunk">@@ -91,14 +123,14 @@</span> <span class="p_context"> static unsigned long kvm_psci_vcpu_on(struct kvm_vcpu *source_vcpu)</span>
 	if (!vcpu)
 		return PSCI_RET_INVALID_PARAMS;
 	if (!vcpu-&gt;arch.power_off) {
<span class="p_del">-		if (kvm_psci_version(source_vcpu) != KVM_ARM_PSCI_0_1)</span>
<span class="p_add">+		if (kvm_psci_version(source_vcpu, kvm) != KVM_ARM_PSCI_0_1)</span>
 			return PSCI_RET_ALREADY_ON;
 		else
 			return PSCI_RET_INVALID_PARAMS;
 	}
 
<span class="p_del">-	target_pc = vcpu_get_reg(source_vcpu, 2);</span>
<span class="p_del">-	context_id = vcpu_get_reg(source_vcpu, 3);</span>
<span class="p_add">+	target_pc = smccc_get_arg2(source_vcpu);</span>
<span class="p_add">+	context_id = smccc_get_arg3(source_vcpu);</span>
 
 	kvm_reset_vcpu(vcpu);
 
<span class="p_chunk">@@ -117,7 +149,7 @@</span> <span class="p_context"> static unsigned long kvm_psci_vcpu_on(struct kvm_vcpu *source_vcpu)</span>
 	 * NOTE: We always update r0 (or x0) because for PSCI v0.1
 	 * the general puspose registers are undefined upon CPU_ON.
 	 */
<span class="p_del">-	vcpu_set_reg(vcpu, 0, context_id);</span>
<span class="p_add">+	smccc_set_retval(vcpu, context_id, 0, 0, 0);</span>
 	vcpu-&gt;arch.power_off = false;
 	smp_mb();		/* Make sure the above is visible */
 
<span class="p_chunk">@@ -137,8 +169,8 @@</span> <span class="p_context"> static unsigned long kvm_psci_vcpu_affinity_info(struct kvm_vcpu *vcpu)</span>
 	struct kvm *kvm = vcpu-&gt;kvm;
 	struct kvm_vcpu *tmp;
 
<span class="p_del">-	target_affinity = vcpu_get_reg(vcpu, 1);</span>
<span class="p_del">-	lowest_affinity_level = vcpu_get_reg(vcpu, 2);</span>
<span class="p_add">+	target_affinity = smccc_get_arg1(vcpu);</span>
<span class="p_add">+	lowest_affinity_level = smccc_get_arg2(vcpu);</span>
 
 	/* Determine target affinity mask */
 	target_affinity_mask = psci_affinity_mask(lowest_affinity_level);
<span class="p_chunk">@@ -200,18 +232,10 @@</span> <span class="p_context"> static void kvm_psci_system_reset(struct kvm_vcpu *vcpu)</span>
 	kvm_prepare_system_event(vcpu, KVM_SYSTEM_EVENT_RESET);
 }
 
<span class="p_del">-int kvm_psci_version(struct kvm_vcpu *vcpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (test_bit(KVM_ARM_VCPU_PSCI_0_2, vcpu-&gt;arch.features))</span>
<span class="p_del">-		return KVM_ARM_PSCI_0_2;</span>
<span class="p_del">-</span>
<span class="p_del">-	return KVM_ARM_PSCI_0_1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)
 {
 	struct kvm *kvm = vcpu-&gt;kvm;
<span class="p_del">-	unsigned long psci_fn = vcpu_get_reg(vcpu, 0) &amp; ~((u32) 0);</span>
<span class="p_add">+	u32 psci_fn = smccc_get_function(vcpu);</span>
 	unsigned long val;
 	int ret = 1;
 
<span class="p_chunk">@@ -221,7 +245,7 @@</span> <span class="p_context"> static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)</span>
 		 * Bits[31:16] = Major Version = 0
 		 * Bits[15:0] = Minor Version = 2
 		 */
<span class="p_del">-		val = 2;</span>
<span class="p_add">+		val = KVM_ARM_PSCI_0_2;</span>
 		break;
 	case PSCI_0_2_FN_CPU_SUSPEND:
 	case PSCI_0_2_FN64_CPU_SUSPEND:
<span class="p_chunk">@@ -278,14 +302,56 @@</span> <span class="p_context"> static int kvm_psci_0_2_call(struct kvm_vcpu *vcpu)</span>
 		break;
 	}
 
<span class="p_del">-	vcpu_set_reg(vcpu, 0, val);</span>
<span class="p_add">+	smccc_set_retval(vcpu, val, 0, 0, 0);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int kvm_psci_1_0_call(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 psci_fn = smccc_get_function(vcpu);</span>
<span class="p_add">+	u32 feature;</span>
<span class="p_add">+	unsigned long val;</span>
<span class="p_add">+	int ret = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch(psci_fn) {</span>
<span class="p_add">+	case PSCI_0_2_FN_PSCI_VERSION:</span>
<span class="p_add">+		val = KVM_ARM_PSCI_1_0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case PSCI_1_0_FN_PSCI_FEATURES:</span>
<span class="p_add">+		feature = smccc_get_arg1(vcpu);</span>
<span class="p_add">+		switch(feature) {</span>
<span class="p_add">+		case PSCI_0_2_FN_PSCI_VERSION:</span>
<span class="p_add">+		case PSCI_0_2_FN_CPU_SUSPEND:</span>
<span class="p_add">+		case PSCI_0_2_FN64_CPU_SUSPEND:</span>
<span class="p_add">+		case PSCI_0_2_FN_CPU_OFF:</span>
<span class="p_add">+		case PSCI_0_2_FN_CPU_ON:</span>
<span class="p_add">+		case PSCI_0_2_FN64_CPU_ON:</span>
<span class="p_add">+		case PSCI_0_2_FN_AFFINITY_INFO:</span>
<span class="p_add">+		case PSCI_0_2_FN64_AFFINITY_INFO:</span>
<span class="p_add">+		case PSCI_0_2_FN_MIGRATE_INFO_TYPE:</span>
<span class="p_add">+		case PSCI_0_2_FN_SYSTEM_OFF:</span>
<span class="p_add">+		case PSCI_0_2_FN_SYSTEM_RESET:</span>
<span class="p_add">+		case PSCI_1_0_FN_PSCI_FEATURES:</span>
<span class="p_add">+		case ARM_SMCCC_VERSION_FUNC_ID:</span>
<span class="p_add">+			val = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			val = PSCI_RET_NOT_SUPPORTED;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return kvm_psci_0_2_call(vcpu);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	smccc_set_retval(vcpu, val, 0, 0, 0);</span>
 	return ret;
 }
 
 static int kvm_psci_0_1_call(struct kvm_vcpu *vcpu)
 {
 	struct kvm *kvm = vcpu-&gt;kvm;
<span class="p_del">-	unsigned long psci_fn = vcpu_get_reg(vcpu, 0) &amp; ~((u32) 0);</span>
<span class="p_add">+	u32 psci_fn = smccc_get_function(vcpu);</span>
 	unsigned long val;
 
 	switch (psci_fn) {
<span class="p_chunk">@@ -303,7 +369,7 @@</span> <span class="p_context"> static int kvm_psci_0_1_call(struct kvm_vcpu *vcpu)</span>
 		break;
 	}
 
<span class="p_del">-	vcpu_set_reg(vcpu, 0, val);</span>
<span class="p_add">+	smccc_set_retval(vcpu, val, 0, 0, 0);</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -321,9 +387,11 @@</span> <span class="p_context"> static int kvm_psci_0_1_call(struct kvm_vcpu *vcpu)</span>
  * Errors:
  * -EINVAL: Unrecognized PSCI function
  */
<span class="p_del">-int kvm_psci_call(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+static int kvm_psci_call(struct kvm_vcpu *vcpu)</span>
 {
<span class="p_del">-	switch (kvm_psci_version(vcpu)) {</span>
<span class="p_add">+	switch (kvm_psci_version(vcpu, vcpu-&gt;kvm)) {</span>
<span class="p_add">+	case KVM_ARM_PSCI_1_0:</span>
<span class="p_add">+		return kvm_psci_1_0_call(vcpu);</span>
 	case KVM_ARM_PSCI_0_2:
 		return kvm_psci_0_2_call(vcpu);
 	case KVM_ARM_PSCI_0_1:
<span class="p_chunk">@@ -332,3 +400,30 @@</span> <span class="p_context"> int kvm_psci_call(struct kvm_vcpu *vcpu)</span>
 		return -EINVAL;
 	};
 }
<span class="p_add">+</span>
<span class="p_add">+int kvm_hvc_call_handler(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 func_id = smccc_get_function(vcpu);</span>
<span class="p_add">+	u32 val = PSCI_RET_NOT_SUPPORTED;</span>
<span class="p_add">+	u32 feature;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (func_id) {</span>
<span class="p_add">+	case ARM_SMCCC_VERSION_FUNC_ID:</span>
<span class="p_add">+		val = ARM_SMCCC_VERSION_1_1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case ARM_SMCCC_ARCH_FEATURES_FUNC_ID:</span>
<span class="p_add">+		feature = smccc_get_arg1(vcpu);</span>
<span class="p_add">+		switch(feature) {</span>
<span class="p_add">+		case ARM_SMCCC_ARCH_WORKAROUND_1:</span>
<span class="p_add">+			if (kvm_arm_harden_branch_predictor())</span>
<span class="p_add">+				val = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return kvm_psci_call(vcpu);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	smccc_set_retval(vcpu, val, 0, 0, 0);</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



