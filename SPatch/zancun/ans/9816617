
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.11.8 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.11.8</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 29, 2017, 12:18 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170629121817.GB12206@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9816617/mbox/"
   >mbox</a>
|
   <a href="/patch/9816617/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9816617/">/patch/9816617/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4E41C6035F for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 29 Jun 2017 12:19:08 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3651D25223
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 29 Jun 2017 12:19:08 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 2A10628703; Thu, 29 Jun 2017 12:19:08 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E15E425223
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 29 Jun 2017 12:19:03 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753113AbdF2MSx (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 29 Jun 2017 08:18:53 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:38968 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753044AbdF2MSU (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 29 Jun 2017 08:18:20 -0400
Received: from localhost (LFbn-1-12253-150.w90-92.abo.wanadoo.fr
	[90.92.67.150])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id ABF69727;
	Thu, 29 Jun 2017 12:18:18 +0000 (UTC)
Date: Thu, 29 Jun 2017 14:18:17 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.11.8
Message-ID: &lt;20170629121817.GB12206@kroah.com&gt;
References: &lt;20170629121813.GA12206@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20170629121813.GA12206@kroah.com&gt;
User-Agent: Mutt/1.8.3 (2017-05-23)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 29, 2017, 12:18 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 1b0fe238d633..8c5c94ca56d9 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 11
<span class="p_del">-SUBLEVEL = 7</span>
<span class="p_add">+SUBLEVEL = 8</span>
 EXTRAVERSION =
 NAME = Fearless Coyote
 
<span class="p_header">diff --git a/arch/arm64/kernel/vdso.c b/arch/arm64/kernel/vdso.c</span>
<span class="p_header">index 41b6e31f8f55..d0cb007fa482 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso.c</span>
<span class="p_chunk">@@ -221,10 +221,11 @@</span> <span class="p_context"> void update_vsyscall(struct timekeeper *tk)</span>
 		/* tkr_mono.cycle_last == tkr_raw.cycle_last */
 		vdso_data-&gt;cs_cycle_last	= tk-&gt;tkr_mono.cycle_last;
 		vdso_data-&gt;raw_time_sec		= tk-&gt;raw_time.tv_sec;
<span class="p_del">-		vdso_data-&gt;raw_time_nsec	= tk-&gt;raw_time.tv_nsec;</span>
<span class="p_add">+		vdso_data-&gt;raw_time_nsec	= (tk-&gt;raw_time.tv_nsec &lt;&lt;</span>
<span class="p_add">+						   tk-&gt;tkr_raw.shift) +</span>
<span class="p_add">+						  tk-&gt;tkr_raw.xtime_nsec;</span>
 		vdso_data-&gt;xtime_clock_sec	= tk-&gt;xtime_sec;
 		vdso_data-&gt;xtime_clock_nsec	= tk-&gt;tkr_mono.xtime_nsec;
<span class="p_del">-		/* tkr_raw.xtime_nsec == 0 */</span>
 		vdso_data-&gt;cs_mono_mult		= tk-&gt;tkr_mono.mult;
 		vdso_data-&gt;cs_raw_mult		= tk-&gt;tkr_raw.mult;
 		/* tkr_mono.shift == tkr_raw.shift */
<span class="p_header">diff --git a/arch/arm64/kernel/vdso/gettimeofday.S b/arch/arm64/kernel/vdso/gettimeofday.S</span>
<span class="p_header">index e00b4671bd7c..76320e920965 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/vdso/gettimeofday.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/vdso/gettimeofday.S</span>
<span class="p_chunk">@@ -256,7 +256,6 @@</span> <span class="p_context"> monotonic_raw:</span>
 	seqcnt_check fail=monotonic_raw
 
 	/* All computations are done with left-shifted nsecs. */
<span class="p_del">-	lsl	x14, x14, x12</span>
 	get_nsec_per_sec res=x9
 	lsl	x9, x9, x12
 
<span class="p_header">diff --git a/arch/mips/kvm/tlb.c b/arch/mips/kvm/tlb.c</span>
<span class="p_header">index 2819eb793345..3b5b7936345c 100644</span>
<span class="p_header">--- a/arch/mips/kvm/tlb.c</span>
<span class="p_header">+++ b/arch/mips/kvm/tlb.c</span>
<span class="p_chunk">@@ -147,7 +147,11 @@</span> <span class="p_context"> static int _kvm_mips_host_tlb_inv(unsigned long entryhi)</span>
 int kvm_mips_host_tlb_inv(struct kvm_vcpu *vcpu, unsigned long va,
 			  bool user, bool kernel)
 {
<span class="p_del">-	int idx_user, idx_kernel;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initialize idx_user and idx_kernel to workaround bogus</span>
<span class="p_add">+	 * maybe-initialized warning when using GCC 6.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	int idx_user = 0, idx_kernel = 0;</span>
 	unsigned long flags, old_entryhi;
 
 	local_irq_save(flags);
<span class="p_header">diff --git a/arch/powerpc/kernel/exceptions-64s.S b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">index 6353019966e6..a59880c81d52 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/exceptions-64s.S</span>
<span class="p_chunk">@@ -1425,10 +1425,8 @@</span> <span class="p_context"> USE_TEXT_SECTION()</span>
 	.balign	IFETCH_ALIGN_BYTES
 do_hash_page:
 #ifdef CONFIG_PPC_STD_MMU_64
<span class="p_del">-	andis.	r0,r4,0xa410		/* weird error? */</span>
<span class="p_add">+	andis.	r0,r4,0xa450		/* weird error? */</span>
 	bne-	handle_page_fault	/* if not, try to insert a HPTE */
<span class="p_del">-	andis.  r0,r4,DSISR_DABRMATCH@h</span>
<span class="p_del">-	bne-    handle_dabr_fault</span>
 	CURRENT_THREAD_INFO(r11, r1)
 	lwz	r0,TI_PREEMPT(r11)	/* If we&#39;re in an &quot;NMI&quot; */
 	andis.	r0,r0,NMI_MASK@h	/* (i.e. an irq when soft-disabled) */
<span class="p_chunk">@@ -1452,11 +1450,16 @@</span> <span class="p_context"> do_hash_page:</span>
 
 	/* Error */
 	blt-	13f
<span class="p_add">+</span>
<span class="p_add">+	/* Reload DSISR into r4 for the DABR check below */</span>
<span class="p_add">+	ld      r4,_DSISR(r1)</span>
 #endif /* CONFIG_PPC_STD_MMU_64 */
 
 /* Here we have a page fault that hash_page can&#39;t handle. */
 handle_page_fault:
<span class="p_del">-11:	ld	r4,_DAR(r1)</span>
<span class="p_add">+11:	andis.  r0,r4,DSISR_DABRMATCH@h</span>
<span class="p_add">+	bne-    handle_dabr_fault</span>
<span class="p_add">+	ld	r4,_DAR(r1)</span>
 	ld	r5,_DSISR(r1)
 	addi	r3,r1,STACK_FRAME_OVERHEAD
 	bl	do_page_fault
<span class="p_header">diff --git a/arch/powerpc/kernel/kprobes.c b/arch/powerpc/kernel/kprobes.c</span>
<span class="p_header">index fce05a38851c..49d5f193438a 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/kprobes.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/kprobes.c</span>
<span class="p_chunk">@@ -495,6 +495,15 @@</span> <span class="p_context"> int __kprobes setjmp_pre_handler(struct kprobe *p, struct pt_regs *regs)</span>
 	regs-&gt;gpr[2] = (unsigned long)(((func_descr_t *)jp-&gt;entry)-&gt;toc);
 #endif
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * jprobes use jprobe_return() which skips the normal return</span>
<span class="p_add">+	 * path of the function, and this messes up the accounting of the</span>
<span class="p_add">+	 * function graph tracer.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Pause function graph tracing while performing the jprobe function.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pause_graph_tracing();</span>
<span class="p_add">+</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -517,6 +526,8 @@</span> <span class="p_context"> int __kprobes longjmp_break_handler(struct kprobe *p, struct pt_regs *regs)</span>
 	 * saved regs...
 	 */
 	memcpy(regs, &amp;kcb-&gt;jprobe_saved_regs, sizeof(struct pt_regs));
<span class="p_add">+	/* It&#39;s OK to start function graph tracing again */</span>
<span class="p_add">+	unpause_graph_tracing();</span>
 	preempt_enable_no_resched();
 	return 1;
 }
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 1ec86d9e2a82..e6a94bd2b158 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -1481,6 +1481,14 @@</span> <span class="p_context"> static int kvmppc_set_one_reg_hv(struct kvm_vcpu *vcpu, u64 id,</span>
 		r = set_vpa(vcpu, &amp;vcpu-&gt;arch.dtl, addr, len);
 		break;
 	case KVM_REG_PPC_TB_OFFSET:
<span class="p_add">+		/*</span>
<span class="p_add">+		 * POWER9 DD1 has an erratum where writing TBU40 causes</span>
<span class="p_add">+		 * the timebase to lose ticks.  So we don&#39;t let the</span>
<span class="p_add">+		 * timebase offset be changed on P9 DD1.  (It is</span>
<span class="p_add">+		 * initialized to zero.)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (cpu_has_feature(CPU_FTR_POWER9_DD1))</span>
<span class="p_add">+			break;</span>
 		/* round up to multiple of 2^24 */
 		vcpu-&gt;arch.vcore-&gt;tb_offset =
 			ALIGN(set_reg_val(id, *val), 1UL &lt;&lt; 24);
<span class="p_chunk">@@ -2902,12 +2910,36 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 {
 	int r;
 	int srcu_idx;
<span class="p_add">+	unsigned long ebb_regs[3] = {};	/* shut up GCC */</span>
<span class="p_add">+	unsigned long user_tar = 0;</span>
<span class="p_add">+	unsigned int user_vrsave;</span>
 
 	if (!vcpu-&gt;arch.sane) {
 		run-&gt;exit_reason = KVM_EXIT_INTERNAL_ERROR;
 		return -EINVAL;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t allow entry with a suspended transaction, because</span>
<span class="p_add">+	 * the guest entry/exit code will lose it.</span>
<span class="p_add">+	 * If the guest has TM enabled, save away their TM-related SPRs</span>
<span class="p_add">+	 * (they will get restored by the TM unavailable interrupt).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+#ifdef CONFIG_PPC_TRANSACTIONAL_MEM</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_TM) &amp;&amp; current-&gt;thread.regs &amp;&amp;</span>
<span class="p_add">+	    (current-&gt;thread.regs-&gt;msr &amp; MSR_TM)) {</span>
<span class="p_add">+		if (MSR_TM_ACTIVE(current-&gt;thread.regs-&gt;msr)) {</span>
<span class="p_add">+			run-&gt;exit_reason = KVM_EXIT_FAIL_ENTRY;</span>
<span class="p_add">+			run-&gt;fail_entry.hardware_entry_failure_reason = 0;</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		current-&gt;thread.tm_tfhar = mfspr(SPRN_TFHAR);</span>
<span class="p_add">+		current-&gt;thread.tm_tfiar = mfspr(SPRN_TFIAR);</span>
<span class="p_add">+		current-&gt;thread.tm_texasr = mfspr(SPRN_TEXASR);</span>
<span class="p_add">+		current-&gt;thread.regs-&gt;msr &amp;= ~MSR_TM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 	kvmppc_core_prepare_to_enter(vcpu);
 
 	/* No need to go into the guest when all we&#39;ll do is come back out */
<span class="p_chunk">@@ -2929,6 +2961,15 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 
 	flush_all_to_thread(current);
 
<span class="p_add">+	/* Save userspace EBB and other register values */</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ARCH_207S)) {</span>
<span class="p_add">+		ebb_regs[0] = mfspr(SPRN_EBBHR);</span>
<span class="p_add">+		ebb_regs[1] = mfspr(SPRN_EBBRR);</span>
<span class="p_add">+		ebb_regs[2] = mfspr(SPRN_BESCR);</span>
<span class="p_add">+		user_tar = mfspr(SPRN_TAR);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	user_vrsave = mfspr(SPRN_VRSAVE);</span>
<span class="p_add">+</span>
 	vcpu-&gt;arch.wqp = &amp;vcpu-&gt;arch.vcore-&gt;wq;
 	vcpu-&gt;arch.pgdir = current-&gt;mm-&gt;pgd;
 	vcpu-&gt;arch.state = KVMPPC_VCPU_BUSY_IN_HOST;
<span class="p_chunk">@@ -2951,6 +2992,16 @@</span> <span class="p_context"> static int kvmppc_vcpu_run_hv(struct kvm_run *run, struct kvm_vcpu *vcpu)</span>
 			r = kvmppc_xics_rm_complete(vcpu, 0);
 	} while (is_kvmppc_resume_guest(r));
 
<span class="p_add">+	/* Restore userspace EBB and other register values */</span>
<span class="p_add">+	if (cpu_has_feature(CPU_FTR_ARCH_207S)) {</span>
<span class="p_add">+		mtspr(SPRN_EBBHR, ebb_regs[0]);</span>
<span class="p_add">+		mtspr(SPRN_EBBRR, ebb_regs[1]);</span>
<span class="p_add">+		mtspr(SPRN_BESCR, ebb_regs[2]);</span>
<span class="p_add">+		mtspr(SPRN_TAR, user_tar);</span>
<span class="p_add">+		mtspr(SPRN_FSCR, current-&gt;thread.fscr);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mtspr(SPRN_VRSAVE, user_vrsave);</span>
<span class="p_add">+</span>
  out:
 	vcpu-&gt;arch.state = KVMPPC_VCPU_NOTREADY;
 	atomic_dec(&amp;vcpu-&gt;kvm-&gt;arch.vcpus_running);
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_interrupts.S b/arch/powerpc/kvm/book3s_hv_interrupts.S</span>
<span class="p_header">index 0fdc4a28970b..404deb512844 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_interrupts.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_interrupts.S</span>
<span class="p_chunk">@@ -121,10 +121,20 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
 	 * Put whatever is in the decrementer into the
 	 * hypervisor decrementer.
 	 */
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	ld	r5, HSTATE_KVM_VCORE(r13)</span>
<span class="p_add">+	ld	r6, VCORE_KVM(r5)</span>
<span class="p_add">+	ld	r9, KVM_HOST_LPCR(r6)</span>
<span class="p_add">+	andis.	r9, r9, LPCR_LD@h</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)</span>
 	mfspr	r8,SPRN_DEC
 	mftb	r7
<span class="p_del">-	mtspr	SPRN_HDEC,r8</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	/* On POWER9, don&#39;t sign-extend if host LPCR[LD] bit is set */</span>
<span class="p_add">+	bne	32f</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)</span>
 	extsw	r8,r8
<span class="p_add">+32:	mtspr	SPRN_HDEC,r8</span>
 	add	r8,r8,r7
 	std	r8,HSTATE_DECEXP(r13)
 
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index 7c6477d1840a..9250866cc900 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -31,12 +31,29 @@</span> <span class="p_context"></span>
 #include &lt;asm/tm.h&gt;
 #include &lt;asm/opal.h&gt;
 
<span class="p_add">+/* Sign-extend HDEC if not on POWER9 */</span>
<span class="p_add">+#define EXTEND_HDEC(reg)			\</span>
<span class="p_add">+BEGIN_FTR_SECTION;				\</span>
<span class="p_add">+	extsw	reg, reg;			\</span>
<span class="p_add">+END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_300)</span>
<span class="p_add">+</span>
 #define VCPU_GPRS_TM(reg) (((reg) * ULONG_SIZE) + VCPU_GPR_TM)
 
 /* Values in HSTATE_NAPPING(r13) */
 #define NAPPING_CEDE	1
 #define NAPPING_NOVCPU	2
 
<span class="p_add">+/* Stack frame offsets for kvmppc_hv_entry */</span>
<span class="p_add">+#define SFS			144</span>
<span class="p_add">+#define STACK_SLOT_TRAP		(SFS-4)</span>
<span class="p_add">+#define STACK_SLOT_TID		(SFS-16)</span>
<span class="p_add">+#define STACK_SLOT_PSSCR	(SFS-24)</span>
<span class="p_add">+#define STACK_SLOT_PID		(SFS-32)</span>
<span class="p_add">+#define STACK_SLOT_IAMR		(SFS-40)</span>
<span class="p_add">+#define STACK_SLOT_CIABR	(SFS-48)</span>
<span class="p_add">+#define STACK_SLOT_DAWR		(SFS-56)</span>
<span class="p_add">+#define STACK_SLOT_DAWRX	(SFS-64)</span>
<span class="p_add">+</span>
 /*
  * Call kvmppc_hv_entry in real mode.
  * Must be called with interrupts hard-disabled.
<span class="p_chunk">@@ -213,6 +230,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
 kvmppc_primary_no_guest:
 	/* We handle this much like a ceded vcpu */
 	/* put the HDEC into the DEC, since HDEC interrupts don&#39;t wake us */
<span class="p_add">+	/* HDEC may be larger than DEC for arch &gt;= v3.00, but since the */</span>
<span class="p_add">+	/* HDEC value came from DEC in the first place, it will fit */</span>
 	mfspr	r3, SPRN_HDEC
 	mtspr	SPRN_DEC, r3
 	/*
<span class="p_chunk">@@ -294,8 +313,9 @@</span> <span class="p_context"> kvm_novcpu_wakeup:</span>
 
 	/* See if our timeslice has expired (HDEC is negative) */
 	mfspr	r0, SPRN_HDEC
<span class="p_add">+	EXTEND_HDEC(r0)</span>
 	li	r12, BOOK3S_INTERRUPT_HV_DECREMENTER
<span class="p_del">-	cmpwi	r0, 0</span>
<span class="p_add">+	cmpdi	r0, 0</span>
 	blt	kvm_novcpu_exit
 
 	/* Got an IPI but other vcpus aren&#39;t yet exiting, must be a latecomer */
<span class="p_chunk">@@ -318,10 +338,10 @@</span> <span class="p_context"> kvm_novcpu_exit:</span>
 	bl	kvmhv_accumulate_time
 #endif
 13:	mr	r3, r12
<span class="p_del">-	stw	r12, 112-4(r1)</span>
<span class="p_add">+	stw	r12, STACK_SLOT_TRAP(r1)</span>
 	bl	kvmhv_commence_exit
 	nop
<span class="p_del">-	lwz	r12, 112-4(r1)</span>
<span class="p_add">+	lwz	r12, STACK_SLOT_TRAP(r1)</span>
 	b	kvmhv_switch_to_host
 
 /*
<span class="p_chunk">@@ -389,8 +409,8 @@</span> <span class="p_context"> kvm_secondary_got_guest:</span>
 	lbz	r4, HSTATE_PTID(r13)
 	cmpwi	r4, 0
 	bne	63f
<span class="p_del">-	lis	r6, 0x7fff</span>
<span class="p_del">-	ori	r6, r6, 0xffff</span>
<span class="p_add">+	LOAD_REG_ADDR(r6, decrementer_max)</span>
<span class="p_add">+	ld	r6, 0(r6)</span>
 	mtspr	SPRN_HDEC, r6
 	/* and set per-LPAR registers, if doing dynamic micro-threading */
 	ld	r6, HSTATE_SPLIT_MODE(r13)
<span class="p_chunk">@@ -544,11 +564,6 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
  *                                                                            *
  *****************************************************************************/
 
<span class="p_del">-/* Stack frame offsets */</span>
<span class="p_del">-#define STACK_SLOT_TID		(112-16)</span>
<span class="p_del">-#define STACK_SLOT_PSSCR	(112-24)</span>
<span class="p_del">-#define STACK_SLOT_PID		(112-32)</span>
<span class="p_del">-</span>
 .global kvmppc_hv_entry
 kvmppc_hv_entry:
 
<span class="p_chunk">@@ -564,7 +579,7 @@</span> <span class="p_context"> kvmppc_hv_entry:</span>
 	 */
 	mflr	r0
 	std	r0, PPC_LR_STKOFF(r1)
<span class="p_del">-	stdu	r1, -112(r1)</span>
<span class="p_add">+	stdu	r1, -SFS(r1)</span>
 
 	/* Save R1 in the PACA */
 	std	r1, HSTATE_HOST_R1(r13)
<span class="p_chunk">@@ -748,10 +763,20 @@</span> <span class="p_context"> BEGIN_FTR_SECTION</span>
 	mfspr	r5, SPRN_TIDR
 	mfspr	r6, SPRN_PSSCR
 	mfspr	r7, SPRN_PID
<span class="p_add">+	mfspr	r8, SPRN_IAMR</span>
 	std	r5, STACK_SLOT_TID(r1)
 	std	r6, STACK_SLOT_PSSCR(r1)
 	std	r7, STACK_SLOT_PID(r1)
<span class="p_add">+	std	r8, STACK_SLOT_IAMR(r1)</span>
 END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)
<span class="p_add">+BEGIN_FTR_SECTION</span>
<span class="p_add">+	mfspr	r5, SPRN_CIABR</span>
<span class="p_add">+	mfspr	r6, SPRN_DAWR</span>
<span class="p_add">+	mfspr	r7, SPRN_DAWRX</span>
<span class="p_add">+	std	r5, STACK_SLOT_CIABR(r1)</span>
<span class="p_add">+	std	r6, STACK_SLOT_DAWR(r1)</span>
<span class="p_add">+	std	r7, STACK_SLOT_DAWRX(r1)</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
 
 BEGIN_FTR_SECTION
 	/* Set partition DABR */
<span class="p_chunk">@@ -967,7 +992,8 @@</span> <span class="p_context"> ALT_FTR_SECTION_END_IFCLR(CPU_FTR_ARCH_300)</span>
 
 	/* Check if HDEC expires soon */
 	mfspr	r3, SPRN_HDEC
<span class="p_del">-	cmpwi	r3, 512		/* 1 microsecond */</span>
<span class="p_add">+	EXTEND_HDEC(r3)</span>
<span class="p_add">+	cmpdi	r3, 512		/* 1 microsecond */</span>
 	blt	hdec_soon
 
 deliver_guest_interrupt:
<span class="p_chunk">@@ -1451,11 +1477,10 @@</span> <span class="p_context"> ALT_FTR_SECTION_END_IFCLR(CPU_FTR_ARCH_300)</span>
 	 * set by the guest could disrupt the host.
 	 */
 	li	r0, 0
<span class="p_del">-	mtspr	SPRN_IAMR, r0</span>
<span class="p_del">-	mtspr	SPRN_CIABR, r0</span>
<span class="p_del">-	mtspr	SPRN_DAWRX, r0</span>
<span class="p_add">+	mtspr	SPRN_PSPB, r0</span>
 	mtspr	SPRN_WORT, r0
 BEGIN_FTR_SECTION
<span class="p_add">+	mtspr	SPRN_IAMR, r0</span>
 	mtspr	SPRN_TCSCR, r0
 	/* Set MMCRS to 1&lt;&lt;31 to freeze and disable the SPMC counters */
 	li	r0, 1
<span class="p_chunk">@@ -1471,6 +1496,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_300)</span>
 	std	r6,VCPU_UAMOR(r9)
 	li	r6,0
 	mtspr	SPRN_AMR,r6
<span class="p_add">+	mtspr	SPRN_UAMOR, r6</span>
 
 	/* Switch DSCR back to host value */
 	mfspr	r8, SPRN_DSCR
<span class="p_chunk">@@ -1616,12 +1642,22 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
 
 	/* Restore host values of some registers */
 BEGIN_FTR_SECTION
<span class="p_add">+	ld	r5, STACK_SLOT_CIABR(r1)</span>
<span class="p_add">+	ld	r6, STACK_SLOT_DAWR(r1)</span>
<span class="p_add">+	ld	r7, STACK_SLOT_DAWRX(r1)</span>
<span class="p_add">+	mtspr	SPRN_CIABR, r5</span>
<span class="p_add">+	mtspr	SPRN_DAWR, r6</span>
<span class="p_add">+	mtspr	SPRN_DAWRX, r7</span>
<span class="p_add">+END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)</span>
<span class="p_add">+BEGIN_FTR_SECTION</span>
 	ld	r5, STACK_SLOT_TID(r1)
 	ld	r6, STACK_SLOT_PSSCR(r1)
 	ld	r7, STACK_SLOT_PID(r1)
<span class="p_add">+	ld	r8, STACK_SLOT_IAMR(r1)</span>
 	mtspr	SPRN_TIDR, r5
 	mtspr	SPRN_PSSCR, r6
 	mtspr	SPRN_PID, r7
<span class="p_add">+	mtspr	SPRN_IAMR, r8</span>
 END_FTR_SECTION_IFSET(CPU_FTR_ARCH_300)
 BEGIN_FTR_SECTION
 	PPC_INVALIDATE_ERAT
<span class="p_chunk">@@ -1765,8 +1801,8 @@</span> <span class="p_context"> END_MMU_FTR_SECTION_IFSET(MMU_FTR_TYPE_RADIX)</span>
 	li	r0, KVM_GUEST_MODE_NONE
 	stb	r0, HSTATE_IN_GUEST(r13)
 
<span class="p_del">-	ld	r0, 112+PPC_LR_STKOFF(r1)</span>
<span class="p_del">-	addi	r1, r1, 112</span>
<span class="p_add">+	ld	r0, SFS+PPC_LR_STKOFF(r1)</span>
<span class="p_add">+	addi	r1, r1, SFS</span>
 	mtlr	r0
 	blr
 
<span class="p_chunk">@@ -2308,12 +2344,13 @@</span> <span class="p_context"> END_FTR_SECTION_IFSET(CPU_FTR_TM)</span>
 	mfspr	r3, SPRN_DEC
 	mfspr	r4, SPRN_HDEC
 	mftb	r5
<span class="p_del">-	cmpw	r3, r4</span>
<span class="p_add">+	extsw	r3, r3</span>
<span class="p_add">+	EXTEND_HDEC(r4)</span>
<span class="p_add">+	cmpd	r3, r4</span>
 	ble	67f
 	mtspr	SPRN_DEC, r4
 67:
 	/* save expiry time of guest decrementer */
<span class="p_del">-	extsw	r3, r3</span>
 	add	r3, r3, r5
 	ld	r4, HSTATE_KVM_VCPU(r13)
 	ld	r5, HSTATE_KVM_VCORE(r13)
<span class="p_header">diff --git a/arch/powerpc/perf/perf_regs.c b/arch/powerpc/perf/perf_regs.c</span>
<span class="p_header">index cbd82fde5770..09ceea6175ba 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/perf_regs.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/perf_regs.c</span>
<span class="p_chunk">@@ -101,5 +101,6 @@</span> <span class="p_context"> void perf_get_regs_user(struct perf_regs *regs_user,</span>
 			struct pt_regs *regs_user_copy)
 {
 	regs_user-&gt;regs = task_pt_regs(current);
<span class="p_del">-	regs_user-&gt;abi  = perf_reg_abi(current);</span>
<span class="p_add">+	regs_user-&gt;abi = (regs_user-&gt;regs) ? perf_reg_abi(current) :</span>
<span class="p_add">+			 PERF_SAMPLE_REGS_ABI_NONE;</span>
 }
<span class="p_header">diff --git a/arch/s390/kvm/gaccess.c b/arch/s390/kvm/gaccess.c</span>
<span class="p_header">index ddbffb715b40..e92f5bd9d0b4 100644</span>
<span class="p_header">--- a/arch/s390/kvm/gaccess.c</span>
<span class="p_header">+++ b/arch/s390/kvm/gaccess.c</span>
<span class="p_chunk">@@ -977,11 +977,12 @@</span> <span class="p_context"> static int kvm_s390_shadow_tables(struct gmap *sg, unsigned long saddr,</span>
 	ptr = asce.origin * 4096;
 	if (asce.r) {
 		*fake = 1;
<span class="p_add">+		ptr = 0;</span>
 		asce.dt = ASCE_TYPE_REGION1;
 	}
 	switch (asce.dt) {
 	case ASCE_TYPE_REGION1:
<span class="p_del">-		if (vaddr.rfx01 &gt; asce.tl &amp;&amp; !asce.r)</span>
<span class="p_add">+		if (vaddr.rfx01 &gt; asce.tl &amp;&amp; !*fake)</span>
 			return PGM_REGION_FIRST_TRANS;
 		break;
 	case ASCE_TYPE_REGION2:
<span class="p_chunk">@@ -1009,8 +1010,7 @@</span> <span class="p_context"> static int kvm_s390_shadow_tables(struct gmap *sg, unsigned long saddr,</span>
 		union region1_table_entry rfte;
 
 		if (*fake) {
<span class="p_del">-			/* offset in 16EB guest memory block */</span>
<span class="p_del">-			ptr = ptr + ((unsigned long) vaddr.rsx &lt;&lt; 53UL);</span>
<span class="p_add">+			ptr += (unsigned long) vaddr.rfx &lt;&lt; 53;</span>
 			rfte.val = ptr;
 			goto shadow_r2t;
 		}
<span class="p_chunk">@@ -1036,8 +1036,7 @@</span> <span class="p_context"> static int kvm_s390_shadow_tables(struct gmap *sg, unsigned long saddr,</span>
 		union region2_table_entry rste;
 
 		if (*fake) {
<span class="p_del">-			/* offset in 8PB guest memory block */</span>
<span class="p_del">-			ptr = ptr + ((unsigned long) vaddr.rtx &lt;&lt; 42UL);</span>
<span class="p_add">+			ptr += (unsigned long) vaddr.rsx &lt;&lt; 42;</span>
 			rste.val = ptr;
 			goto shadow_r3t;
 		}
<span class="p_chunk">@@ -1064,8 +1063,7 @@</span> <span class="p_context"> static int kvm_s390_shadow_tables(struct gmap *sg, unsigned long saddr,</span>
 		union region3_table_entry rtte;
 
 		if (*fake) {
<span class="p_del">-			/* offset in 4TB guest memory block */</span>
<span class="p_del">-			ptr = ptr + ((unsigned long) vaddr.sx &lt;&lt; 31UL);</span>
<span class="p_add">+			ptr += (unsigned long) vaddr.rtx &lt;&lt; 31;</span>
 			rtte.val = ptr;
 			goto shadow_sgt;
 		}
<span class="p_chunk">@@ -1101,8 +1099,7 @@</span> <span class="p_context"> static int kvm_s390_shadow_tables(struct gmap *sg, unsigned long saddr,</span>
 		union segment_table_entry ste;
 
 		if (*fake) {
<span class="p_del">-			/* offset in 2G guest memory block */</span>
<span class="p_del">-			ptr = ptr + ((unsigned long) vaddr.sx &lt;&lt; 20UL);</span>
<span class="p_add">+			ptr += (unsigned long) vaddr.sx &lt;&lt; 20;</span>
 			ste.val = ptr;
 			goto shadow_pgt;
 		}
<span class="p_header">diff --git a/arch/x86/events/intel/core.c b/arch/x86/events/intel/core.c</span>
<span class="p_header">index eb1484c86bb4..65c2ca578556 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/core.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/core.c</span>
<span class="p_chunk">@@ -431,11 +431,11 @@</span> <span class="p_context"> static __initconst const u64 skl_hw_cache_event_ids</span>
  [ C(DTLB) ] = {
 	[ C(OP_READ) ] = {
 		[ C(RESULT_ACCESS) ] = 0x81d0,	/* MEM_INST_RETIRED.ALL_LOADS */
<span class="p_del">-		[ C(RESULT_MISS)   ] = 0x608,	/* DTLB_LOAD_MISSES.WALK_COMPLETED */</span>
<span class="p_add">+		[ C(RESULT_MISS)   ] = 0xe08,	/* DTLB_LOAD_MISSES.WALK_COMPLETED */</span>
 	},
 	[ C(OP_WRITE) ] = {
 		[ C(RESULT_ACCESS) ] = 0x82d0,	/* MEM_INST_RETIRED.ALL_STORES */
<span class="p_del">-		[ C(RESULT_MISS)   ] = 0x649,	/* DTLB_STORE_MISSES.WALK_COMPLETED */</span>
<span class="p_add">+		[ C(RESULT_MISS)   ] = 0xe49,	/* DTLB_STORE_MISSES.WALK_COMPLETED */</span>
 	},
 	[ C(OP_PREFETCH) ] = {
 		[ C(RESULT_ACCESS) ] = 0x0,
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_emulate.h b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">index 3e8c287090e4..d5f83cda1dea 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -294,6 +294,7 @@</span> <span class="p_context"> struct x86_emulate_ctxt {</span>
 
 	bool perm_ok; /* do not check permissions if true */
 	bool ud;	/* inject an #UD if host doesn&#39;t support insn */
<span class="p_add">+	bool tf;	/* TF value before instruction (after for syscall/sysret) */</span>
 
 	bool have_exception;
 	struct x86_exception exception;
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 45c7306c8780..ce7f80baa664 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -2742,6 +2742,7 @@</span> <span class="p_context"> static int em_syscall(struct x86_emulate_ctxt *ctxt)</span>
 		ctxt-&gt;eflags &amp;= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);
 	}
 
<span class="p_add">+	ctxt-&gt;tf = (ctxt-&gt;eflags &amp; X86_EFLAGS_TF) != 0;</span>
 	return X86EMUL_CONTINUE;
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 6557c790c8c1..dd1fe338c5f5 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -5330,6 +5330,8 @@</span> <span class="p_context"> static void init_emulate_ctxt(struct kvm_vcpu *vcpu)</span>
 	kvm_x86_ops-&gt;get_cs_db_l_bits(vcpu, &amp;cs_db, &amp;cs_l);
 
 	ctxt-&gt;eflags = kvm_get_rflags(vcpu);
<span class="p_add">+	ctxt-&gt;tf = (ctxt-&gt;eflags &amp; X86_EFLAGS_TF) != 0;</span>
<span class="p_add">+</span>
 	ctxt-&gt;eip = kvm_rip_read(vcpu);
 	ctxt-&gt;mode = (!is_protmode(vcpu))		? X86EMUL_MODE_REAL :
 		     (ctxt-&gt;eflags &amp; X86_EFLAGS_VM)	? X86EMUL_MODE_VM86 :
<span class="p_chunk">@@ -5546,36 +5548,25 @@</span> <span class="p_context"> static int kvm_vcpu_check_hw_bp(unsigned long addr, u32 type, u32 dr7,</span>
 	return dr6;
 }
 
<span class="p_del">-static void kvm_vcpu_check_singlestep(struct kvm_vcpu *vcpu, unsigned long rflags, int *r)</span>
<span class="p_add">+static void kvm_vcpu_do_singlestep(struct kvm_vcpu *vcpu, int *r)</span>
 {
 	struct kvm_run *kvm_run = vcpu-&gt;run;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * rflags is the old, &quot;raw&quot; value of the flags.  The new value has</span>
<span class="p_del">-	 * not been saved yet.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * This is correct even for TF set by the guest, because &quot;the</span>
<span class="p_del">-	 * processor will not generate this exception after the instruction</span>
<span class="p_del">-	 * that sets the TF flag&quot;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (unlikely(rflags &amp; X86_EFLAGS_TF)) {</span>
<span class="p_del">-		if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_SINGLESTEP) {</span>
<span class="p_del">-			kvm_run-&gt;debug.arch.dr6 = DR6_BS | DR6_FIXED_1 |</span>
<span class="p_del">-						  DR6_RTM;</span>
<span class="p_del">-			kvm_run-&gt;debug.arch.pc = vcpu-&gt;arch.singlestep_rip;</span>
<span class="p_del">-			kvm_run-&gt;debug.arch.exception = DB_VECTOR;</span>
<span class="p_del">-			kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;</span>
<span class="p_del">-			*r = EMULATE_USER_EXIT;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * &quot;Certain debug exceptions may clear bit 0-3.  The</span>
<span class="p_del">-			 * remaining contents of the DR6 register are never</span>
<span class="p_del">-			 * cleared by the processor&quot;.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			vcpu-&gt;arch.dr6 &amp;= ~15;</span>
<span class="p_del">-			vcpu-&gt;arch.dr6 |= DR6_BS | DR6_RTM;</span>
<span class="p_del">-			kvm_queue_exception(vcpu, DB_VECTOR);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	if (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_SINGLESTEP) {</span>
<span class="p_add">+		kvm_run-&gt;debug.arch.dr6 = DR6_BS | DR6_FIXED_1 | DR6_RTM;</span>
<span class="p_add">+		kvm_run-&gt;debug.arch.pc = vcpu-&gt;arch.singlestep_rip;</span>
<span class="p_add">+		kvm_run-&gt;debug.arch.exception = DB_VECTOR;</span>
<span class="p_add">+		kvm_run-&gt;exit_reason = KVM_EXIT_DEBUG;</span>
<span class="p_add">+		*r = EMULATE_USER_EXIT;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * &quot;Certain debug exceptions may clear bit 0-3.  The</span>
<span class="p_add">+		 * remaining contents of the DR6 register are never</span>
<span class="p_add">+		 * cleared by the processor&quot;.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		vcpu-&gt;arch.dr6 &amp;= ~15;</span>
<span class="p_add">+		vcpu-&gt;arch.dr6 |= DR6_BS | DR6_RTM;</span>
<span class="p_add">+		kvm_queue_exception(vcpu, DB_VECTOR);</span>
 	}
 }
 
<span class="p_chunk">@@ -5585,7 +5576,17 @@</span> <span class="p_context"> int kvm_skip_emulated_instruction(struct kvm_vcpu *vcpu)</span>
 	int r = EMULATE_DONE;
 
 	kvm_x86_ops-&gt;skip_emulated_instruction(vcpu);
<span class="p_del">-	kvm_vcpu_check_singlestep(vcpu, rflags, &amp;r);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * rflags is the old, &quot;raw&quot; value of the flags.  The new value has</span>
<span class="p_add">+	 * not been saved yet.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This is correct even for TF set by the guest, because &quot;the</span>
<span class="p_add">+	 * processor will not generate this exception after the instruction</span>
<span class="p_add">+	 * that sets the TF flag&quot;.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (unlikely(rflags &amp; X86_EFLAGS_TF))</span>
<span class="p_add">+		kvm_vcpu_do_singlestep(vcpu, &amp;r);</span>
 	return r == EMULATE_DONE;
 }
 EXPORT_SYMBOL_GPL(kvm_skip_emulated_instruction);
<span class="p_chunk">@@ -5746,8 +5747,9 @@</span> <span class="p_context"> int x86_emulate_instruction(struct kvm_vcpu *vcpu,</span>
 		if (vcpu-&gt;arch.hflags != ctxt-&gt;emul_flags)
 			kvm_set_hflags(vcpu, ctxt-&gt;emul_flags);
 		kvm_rip_write(vcpu, ctxt-&gt;eip);
<span class="p_del">-		if (r == EMULATE_DONE)</span>
<span class="p_del">-			kvm_vcpu_check_singlestep(vcpu, rflags, &amp;r);</span>
<span class="p_add">+		if (r == EMULATE_DONE &amp;&amp;</span>
<span class="p_add">+		    (ctxt-&gt;tf || (vcpu-&gt;guest_debug &amp; KVM_GUESTDBG_SINGLESTEP)))</span>
<span class="p_add">+			kvm_vcpu_do_singlestep(vcpu, &amp;r);</span>
 		if (!ctxt-&gt;have_exception ||
 		    exception_type(ctxt-&gt;exception.vector) == EXCPT_TRAP)
 			__kvm_set_rflags(vcpu, ctxt-&gt;eflags);
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index 2433569b02ef..bc9adb4a2fd7 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -1433,6 +1433,37 @@</span> <span class="p_context"> static void acpi_init_coherency(struct acpi_device *adev)</span>
 	adev-&gt;flags.coherent_dma = cca;
 }
 
<span class="p_add">+static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool *is_spi_i2c_slave_p = data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ares-&gt;type != ACPI_RESOURCE_TYPE_SERIAL_BUS)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * devices that are connected to UART still need to be enumerated to</span>
<span class="p_add">+	 * platform bus</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ares-&gt;data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)</span>
<span class="p_add">+		*is_spi_i2c_slave_p = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	 /* no need to do more checking */</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool acpi_is_spi_i2c_slave(struct acpi_device *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct list_head resource_list;</span>
<span class="p_add">+	bool is_spi_i2c_slave = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;resource_list);</span>
<span class="p_add">+	acpi_dev_get_resources(device, &amp;resource_list, acpi_check_spi_i2c_slave,</span>
<span class="p_add">+			       &amp;is_spi_i2c_slave);</span>
<span class="p_add">+	acpi_dev_free_resource_list(&amp;resource_list);</span>
<span class="p_add">+</span>
<span class="p_add">+	return is_spi_i2c_slave;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,
 			     int type, unsigned long long sta)
 {
<span class="p_chunk">@@ -1448,6 +1479,7 @@</span> <span class="p_context"> void acpi_init_device_object(struct acpi_device *device, acpi_handle handle,</span>
 	acpi_bus_get_flags(device);
 	device-&gt;flags.match_driver = false;
 	device-&gt;flags.initialized = true;
<span class="p_add">+	device-&gt;flags.spi_i2c_slave = acpi_is_spi_i2c_slave(device);</span>
 	acpi_device_clear_enumerated(device);
 	device_initialize(&amp;device-&gt;dev);
 	dev_set_uevent_suppress(&amp;device-&gt;dev, true);
<span class="p_chunk">@@ -1732,38 +1764,13 @@</span> <span class="p_context"> static acpi_status acpi_bus_check_add(acpi_handle handle, u32 lvl_not_used,</span>
 	return AE_OK;
 }
 
<span class="p_del">-static int acpi_check_spi_i2c_slave(struct acpi_resource *ares, void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	bool *is_spi_i2c_slave_p = data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ares-&gt;type != ACPI_RESOURCE_TYPE_SERIAL_BUS)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * devices that are connected to UART still need to be enumerated to</span>
<span class="p_del">-	 * platform bus</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (ares-&gt;data.common_serial_bus.type != ACPI_RESOURCE_SERIAL_TYPE_UART)</span>
<span class="p_del">-		*is_spi_i2c_slave_p = true;</span>
<span class="p_del">-</span>
<span class="p_del">-	 /* no need to do more checking */</span>
<span class="p_del">-	return -1;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void acpi_default_enumeration(struct acpi_device *device)
 {
<span class="p_del">-	struct list_head resource_list;</span>
<span class="p_del">-	bool is_spi_i2c_slave = false;</span>
<span class="p_del">-</span>
 	/*
 	 * Do not enumerate SPI/I2C slaves as they will be enumerated by their
 	 * respective parents.
 	 */
<span class="p_del">-	INIT_LIST_HEAD(&amp;resource_list);</span>
<span class="p_del">-	acpi_dev_get_resources(device, &amp;resource_list, acpi_check_spi_i2c_slave,</span>
<span class="p_del">-			       &amp;is_spi_i2c_slave);</span>
<span class="p_del">-	acpi_dev_free_resource_list(&amp;resource_list);</span>
<span class="p_del">-	if (!is_spi_i2c_slave) {</span>
<span class="p_add">+	if (!device-&gt;flags.spi_i2c_slave) {</span>
 		acpi_create_platform_device(device, NULL);
 		acpi_device_set_enumerated(device);
 	} else {
<span class="p_chunk">@@ -1857,7 +1864,7 @@</span> <span class="p_context"> static void acpi_bus_attach(struct acpi_device *device)</span>
 		return;
 
 	device-&gt;flags.match_driver = true;
<span class="p_del">-	if (ret &gt; 0) {</span>
<span class="p_add">+	if (ret &gt; 0 &amp;&amp; !device-&gt;flags.spi_i2c_slave) {</span>
 		acpi_device_set_enumerated(device);
 		goto ok;
 	}
<span class="p_chunk">@@ -1866,7 +1873,7 @@</span> <span class="p_context"> static void acpi_bus_attach(struct acpi_device *device)</span>
 	if (ret &lt; 0)
 		return;
 
<span class="p_del">-	if (ret &gt; 0 || !device-&gt;pnp.type.platform_id)</span>
<span class="p_add">+	if (!device-&gt;pnp.type.platform_id &amp;&amp; !device-&gt;flags.spi_i2c_slave)</span>
 		acpi_device_set_enumerated(device);
 	else
 		acpi_default_enumeration(device);
<span class="p_header">diff --git a/drivers/block/xen-blkback/blkback.c b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">index 726c32e35db9..fbe0dfdffc0d 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/blkback.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/blkback.c</span>
<span class="p_chunk">@@ -1436,34 +1436,35 @@</span> <span class="p_context"> static int dispatch_rw_block_io(struct xen_blkif_ring *ring,</span>
 static void make_response(struct xen_blkif_ring *ring, u64 id,
 			  unsigned short op, int st)
 {
<span class="p_del">-	struct blkif_response  resp;</span>
<span class="p_add">+	struct blkif_response *resp;</span>
 	unsigned long     flags;
 	union blkif_back_rings *blk_rings;
 	int notify;
 
<span class="p_del">-	resp.id        = id;</span>
<span class="p_del">-	resp.operation = op;</span>
<span class="p_del">-	resp.status    = st;</span>
<span class="p_del">-</span>
 	spin_lock_irqsave(&amp;ring-&gt;blk_ring_lock, flags);
 	blk_rings = &amp;ring-&gt;blk_rings;
 	/* Place on the response ring for the relevant domain. */
 	switch (ring-&gt;blkif-&gt;blk_protocol) {
 	case BLKIF_PROTOCOL_NATIVE:
<span class="p_del">-		memcpy(RING_GET_RESPONSE(&amp;blk_rings-&gt;native, blk_rings-&gt;native.rsp_prod_pvt),</span>
<span class="p_del">-		       &amp;resp, sizeof(resp));</span>
<span class="p_add">+		resp = RING_GET_RESPONSE(&amp;blk_rings-&gt;native,</span>
<span class="p_add">+					 blk_rings-&gt;native.rsp_prod_pvt);</span>
 		break;
 	case BLKIF_PROTOCOL_X86_32:
<span class="p_del">-		memcpy(RING_GET_RESPONSE(&amp;blk_rings-&gt;x86_32, blk_rings-&gt;x86_32.rsp_prod_pvt),</span>
<span class="p_del">-		       &amp;resp, sizeof(resp));</span>
<span class="p_add">+		resp = RING_GET_RESPONSE(&amp;blk_rings-&gt;x86_32,</span>
<span class="p_add">+					 blk_rings-&gt;x86_32.rsp_prod_pvt);</span>
 		break;
 	case BLKIF_PROTOCOL_X86_64:
<span class="p_del">-		memcpy(RING_GET_RESPONSE(&amp;blk_rings-&gt;x86_64, blk_rings-&gt;x86_64.rsp_prod_pvt),</span>
<span class="p_del">-		       &amp;resp, sizeof(resp));</span>
<span class="p_add">+		resp = RING_GET_RESPONSE(&amp;blk_rings-&gt;x86_64,</span>
<span class="p_add">+					 blk_rings-&gt;x86_64.rsp_prod_pvt);</span>
 		break;
 	default:
 		BUG();
 	}
<span class="p_add">+</span>
<span class="p_add">+	resp-&gt;id        = id;</span>
<span class="p_add">+	resp-&gt;operation = op;</span>
<span class="p_add">+	resp-&gt;status    = st;</span>
<span class="p_add">+</span>
 	blk_rings-&gt;common.rsp_prod_pvt++;
 	RING_PUSH_RESPONSES_AND_CHECK_NOTIFY(&amp;blk_rings-&gt;common, notify);
 	spin_unlock_irqrestore(&amp;ring-&gt;blk_ring_lock, flags);
<span class="p_header">diff --git a/drivers/block/xen-blkback/common.h b/drivers/block/xen-blkback/common.h</span>
<span class="p_header">index dea61f6ab8cb..ecb35fe8ca8d 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/common.h</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/common.h</span>
<span class="p_chunk">@@ -75,9 +75,8 @@</span> <span class="p_context"> extern unsigned int xenblk_max_queues;</span>
 struct blkif_common_request {
 	char dummy;
 };
<span class="p_del">-struct blkif_common_response {</span>
<span class="p_del">-	char dummy;</span>
<span class="p_del">-};</span>
<span class="p_add">+</span>
<span class="p_add">+/* i386 protocol version */</span>
 
 struct blkif_x86_32_request_rw {
 	uint8_t        nr_segments;  /* number of segments                   */
<span class="p_chunk">@@ -129,14 +128,6 @@</span> <span class="p_context"> struct blkif_x86_32_request {</span>
 	} u;
 } __attribute__((__packed__));
 
<span class="p_del">-/* i386 protocol version */</span>
<span class="p_del">-#pragma pack(push, 4)</span>
<span class="p_del">-struct blkif_x86_32_response {</span>
<span class="p_del">-	uint64_t        id;              /* copied from request */</span>
<span class="p_del">-	uint8_t         operation;       /* copied from request */</span>
<span class="p_del">-	int16_t         status;          /* BLKIF_RSP_???       */</span>
<span class="p_del">-};</span>
<span class="p_del">-#pragma pack(pop)</span>
 /* x86_64 protocol version */
 
 struct blkif_x86_64_request_rw {
<span class="p_chunk">@@ -193,18 +184,12 @@</span> <span class="p_context"> struct blkif_x86_64_request {</span>
 	} u;
 } __attribute__((__packed__));
 
<span class="p_del">-struct blkif_x86_64_response {</span>
<span class="p_del">-	uint64_t       __attribute__((__aligned__(8))) id;</span>
<span class="p_del">-	uint8_t         operation;       /* copied from request */</span>
<span class="p_del">-	int16_t         status;          /* BLKIF_RSP_???       */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 DEFINE_RING_TYPES(blkif_common, struct blkif_common_request,
<span class="p_del">-		  struct blkif_common_response);</span>
<span class="p_add">+		  struct blkif_response);</span>
 DEFINE_RING_TYPES(blkif_x86_32, struct blkif_x86_32_request,
<span class="p_del">-		  struct blkif_x86_32_response);</span>
<span class="p_add">+		  struct blkif_response __packed);</span>
 DEFINE_RING_TYPES(blkif_x86_64, struct blkif_x86_64_request,
<span class="p_del">-		  struct blkif_x86_64_response);</span>
<span class="p_add">+		  struct blkif_response);</span>
 
 union blkif_back_rings {
 	struct blkif_back_ring        native;
<span class="p_chunk">@@ -281,6 +266,7 @@</span> <span class="p_context"> struct xen_blkif_ring {</span>
 
 	wait_queue_head_t	wq;
 	atomic_t		inflight;
<span class="p_add">+	bool			active;</span>
 	/* One thread per blkif ring. */
 	struct task_struct	*xenblkd;
 	unsigned int		waiting_reqs;
<span class="p_header">diff --git a/drivers/block/xen-blkback/xenbus.c b/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_header">index 8fe61b5dc5a6..dcabf52425ff 100644</span>
<span class="p_header">--- a/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_header">+++ b/drivers/block/xen-blkback/xenbus.c</span>
<span class="p_chunk">@@ -159,7 +159,7 @@</span> <span class="p_context"> static int xen_blkif_alloc_rings(struct xen_blkif *blkif)</span>
 		init_waitqueue_head(&amp;ring-&gt;shutdown_wq);
 		ring-&gt;blkif = blkif;
 		ring-&gt;st_print = jiffies;
<span class="p_del">-		xen_blkif_get(blkif);</span>
<span class="p_add">+		ring-&gt;active = true;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -249,6 +249,9 @@</span> <span class="p_context"> static int xen_blkif_disconnect(struct xen_blkif *blkif)</span>
 		struct xen_blkif_ring *ring = &amp;blkif-&gt;rings[r];
 		unsigned int i = 0;
 
<span class="p_add">+		if (!ring-&gt;active)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		if (ring-&gt;xenblkd) {
 			kthread_stop(ring-&gt;xenblkd);
 			wake_up(&amp;ring-&gt;shutdown_wq);
<span class="p_chunk">@@ -296,7 +299,7 @@</span> <span class="p_context"> static int xen_blkif_disconnect(struct xen_blkif *blkif)</span>
 		BUG_ON(ring-&gt;free_pages_num != 0);
 		BUG_ON(ring-&gt;persistent_gnt_c != 0);
 		WARN_ON(i != (XEN_BLKIF_REQS_PER_PAGE * blkif-&gt;nr_ring_pages));
<span class="p_del">-		xen_blkif_put(blkif);</span>
<span class="p_add">+		ring-&gt;active = false;</span>
 	}
 	blkif-&gt;nr_ring_pages = 0;
 	/*
<span class="p_header">diff --git a/drivers/char/random.c b/drivers/char/random.c</span>
<span class="p_header">index 2291e6224ed3..8944a844ca95 100644</span>
<span class="p_header">--- a/drivers/char/random.c</span>
<span class="p_header">+++ b/drivers/char/random.c</span>
<span class="p_chunk">@@ -803,13 +803,13 @@</span> <span class="p_context"> static int crng_fast_load(const char *cp, size_t len)</span>
 		p[crng_init_cnt % CHACHA20_KEY_SIZE] ^= *cp;
 		cp++; crng_init_cnt++; len--;
 	}
<span class="p_add">+	spin_unlock_irqrestore(&amp;primary_crng.lock, flags);</span>
 	if (crng_init_cnt &gt;= CRNG_INIT_CNT_THRESH) {
 		invalidate_batched_entropy();
 		crng_init = 1;
 		wake_up_interruptible(&amp;crng_init_wait);
 		pr_notice(&quot;random: fast init done\n&quot;);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;primary_crng.lock, flags);</span>
 	return 1;
 }
 
<span class="p_chunk">@@ -841,6 +841,7 @@</span> <span class="p_context"> static void crng_reseed(struct crng_state *crng, struct entropy_store *r)</span>
 	}
 	memzero_explicit(&amp;buf, sizeof(buf));
 	crng-&gt;init_time = jiffies;
<span class="p_add">+	spin_unlock_irqrestore(&amp;primary_crng.lock, flags);</span>
 	if (crng == &amp;primary_crng &amp;&amp; crng_init &lt; 2) {
 		invalidate_batched_entropy();
 		crng_init = 2;
<span class="p_chunk">@@ -848,7 +849,6 @@</span> <span class="p_context"> static void crng_reseed(struct crng_state *crng, struct entropy_store *r)</span>
 		wake_up_interruptible(&amp;crng_init_wait);
 		pr_notice(&quot;random: crng init done\n&quot;);
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;primary_crng.lock, flags);</span>
 }
 
 static inline void crng_wait_ready(void)
<span class="p_chunk">@@ -2037,8 +2037,8 @@</span> <span class="p_context"> static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_u64);</span>
 u64 get_random_u64(void)
 {
 	u64 ret;
<span class="p_del">-	bool use_lock = crng_init &lt; 2;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	bool use_lock = READ_ONCE(crng_init) &lt; 2;</span>
<span class="p_add">+	unsigned long flags = 0;</span>
 	struct batched_entropy *batch;
 
 #if BITS_PER_LONG == 64
<span class="p_chunk">@@ -2069,8 +2069,8 @@</span> <span class="p_context"> static DEFINE_PER_CPU(struct batched_entropy, batched_entropy_u32);</span>
 u32 get_random_u32(void)
 {
 	u32 ret;
<span class="p_del">-	bool use_lock = crng_init &lt; 2;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_add">+	bool use_lock = READ_ONCE(crng_init) &lt; 2;</span>
<span class="p_add">+	unsigned long flags = 0;</span>
 	struct batched_entropy *batch;
 
 	if (arch_get_random_int(&amp;ret))
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun5i.c b/drivers/clk/sunxi-ng/ccu-sun5i.c</span>
<span class="p_header">index 06edaa523479..2999618e1a59 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun5i.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun5i.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static SUNXI_CCU_GATE(ahb_ss_clk,	&quot;ahb-ss&quot;,	&quot;ahb&quot;,</span>
 static SUNXI_CCU_GATE(ahb_dma_clk,	&quot;ahb-dma&quot;,	&quot;ahb&quot;,
 		      0x060, BIT(6), 0);
 static SUNXI_CCU_GATE(ahb_bist_clk,	&quot;ahb-bist&quot;,	&quot;ahb&quot;,
<span class="p_del">-		      0x060, BIT(6), 0);</span>
<span class="p_add">+		      0x060, BIT(7), 0);</span>
 static SUNXI_CCU_GATE(ahb_mmc0_clk,	&quot;ahb-mmc0&quot;,	&quot;ahb&quot;,
 		      0x060, BIT(8), 0);
 static SUNXI_CCU_GATE(ahb_mmc1_clk,	&quot;ahb-mmc1&quot;,	&quot;ahb&quot;,
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">index 89e68d29bf45..df97e25aec76 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun6i-a31.c</span>
<span class="p_chunk">@@ -556,7 +556,7 @@</span> <span class="p_context"> static SUNXI_CCU_M_WITH_MUX_GATE(lcd0_ch1_clk, &quot;lcd0-ch1&quot;, lcd_ch1_parents,</span>
 				 0x12c, 0, 4, 24, 3, BIT(31),
 				 CLK_SET_RATE_PARENT);
 static SUNXI_CCU_M_WITH_MUX_GATE(lcd1_ch1_clk, &quot;lcd1-ch1&quot;, lcd_ch1_parents,
<span class="p_del">-				 0x12c, 0, 4, 24, 3, BIT(31),</span>
<span class="p_add">+				 0x130, 0, 4, 24, 3, BIT(31),</span>
 				 CLK_SET_RATE_PARENT);
 
 static const char * const csi_sclk_parents[] = { &quot;pll-video0&quot;, &quot;pll-video1&quot;,
<span class="p_header">diff --git a/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c b/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c</span>
<span class="p_header">index e58706b40ae9..6297add857b5 100644</span>
<span class="p_header">--- a/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c</span>
<span class="p_header">+++ b/drivers/clk/sunxi-ng/ccu-sun8i-v3s.c</span>
<span class="p_chunk">@@ -537,7 +537,7 @@</span> <span class="p_context"> static struct ccu_reset_map sun8i_v3s_ccu_resets[] = {</span>
 	[RST_BUS_EMAC]		=  { 0x2c0, BIT(17) },
 	[RST_BUS_HSTIMER]	=  { 0x2c0, BIT(19) },
 	[RST_BUS_SPI0]		=  { 0x2c0, BIT(20) },
<span class="p_del">-	[RST_BUS_OTG]		=  { 0x2c0, BIT(23) },</span>
<span class="p_add">+	[RST_BUS_OTG]		=  { 0x2c0, BIT(24) },</span>
 	[RST_BUS_EHCI0]		=  { 0x2c0, BIT(26) },
 	[RST_BUS_OHCI0]		=  { 0x2c0, BIT(29) },
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index 56a86dd5789e..2de6475a684e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -693,6 +693,10 @@</span> <span class="p_context"> int amdgpu_atombios_get_clock_info(struct amdgpu_device *adev)</span>
 			DRM_INFO(&quot;Changing default dispclk from %dMhz to 600Mhz\n&quot;,
 				 adev-&gt;clock.default_dispclk / 100);
 			adev-&gt;clock.default_dispclk = 60000;
<span class="p_add">+		} else if (adev-&gt;clock.default_dispclk &lt;= 60000) {</span>
<span class="p_add">+			DRM_INFO(&quot;Changing default dispclk from %dMhz to 625Mhz\n&quot;,</span>
<span class="p_add">+				 adev-&gt;clock.default_dispclk / 100);</span>
<span class="p_add">+			adev-&gt;clock.default_dispclk = 62500;</span>
 		}
 		adev-&gt;clock.dp_extclk =
 			le16_to_cpu(firmware_info-&gt;info_21.usUniphyDPModeExtClkFreq);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c</span>
<span class="p_header">index b76cd699eb0d..b1f02277be79 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c</span>
<span class="p_chunk">@@ -422,6 +422,7 @@</span> <span class="p_context"> static const struct pci_device_id pciidlist[] = {</span>
 	{0x1002, 0x6986, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
 	{0x1002, 0x6987, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
 	{0x1002, 0x6995, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
<span class="p_add">+	{0x1002, 0x6997, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},</span>
 	{0x1002, 0x699F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_POLARIS12},
 
 	{0, 0, 0}
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_crtc.c b/drivers/gpu/drm/amd/amdgpu/atombios_crtc.c</span>
<span class="p_header">index 8c9bc75a9c2d..8a0818b23ea4 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/atombios_crtc.c</span>
<span class="p_chunk">@@ -165,7 +165,7 @@</span> <span class="p_context"> void amdgpu_atombios_crtc_powergate(struct drm_crtc *crtc, int state)</span>
 	struct drm_device *dev = crtc-&gt;dev;
 	struct amdgpu_device *adev = dev-&gt;dev_private;
 	int index = GetIndexIntoMasterTable(COMMAND, EnableDispPowerGating);
<span class="p_del">-	ENABLE_DISP_POWER_GATING_PARAMETERS_V2_1 args;</span>
<span class="p_add">+	ENABLE_DISP_POWER_GATING_PS_ALLOCATION args;</span>
 
 	memset(&amp;args, 0, sizeof(args));
 
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> void amdgpu_atombios_crtc_powergate(struct drm_crtc *crtc, int state)</span>
 void amdgpu_atombios_crtc_powergate_init(struct amdgpu_device *adev)
 {
 	int index = GetIndexIntoMasterTable(COMMAND, EnableDispPowerGating);
<span class="p_del">-	ENABLE_DISP_POWER_GATING_PARAMETERS_V2_1 args;</span>
<span class="p_add">+	ENABLE_DISP_POWER_GATING_PS_ALLOCATION args;</span>
 
 	memset(&amp;args, 0, sizeof(args));
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_connector.c b/drivers/gpu/drm/drm_connector.c</span>
<span class="p_header">index 45464c8b797d..2a6059ce3842 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_connector.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_connector.c</span>
<span class="p_chunk">@@ -1169,21 +1169,6 @@</span> <span class="p_context"> int drm_mode_getconnector(struct drm_device *dev, void *data,</span>
 	if (!connector)
 		return -ENOENT;
 
<span class="p_del">-	drm_modeset_lock(&amp;dev-&gt;mode_config.connection_mutex, NULL);</span>
<span class="p_del">-	encoder = drm_connector_get_encoder(connector);</span>
<span class="p_del">-	if (encoder)</span>
<span class="p_del">-		out_resp-&gt;encoder_id = encoder-&gt;base.id;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		out_resp-&gt;encoder_id = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = drm_mode_object_get_properties(&amp;connector-&gt;base, file_priv-&gt;atomic,</span>
<span class="p_del">-			(uint32_t __user *)(unsigned long)(out_resp-&gt;props_ptr),</span>
<span class="p_del">-			(uint64_t __user *)(unsigned long)(out_resp-&gt;prop_values_ptr),</span>
<span class="p_del">-			&amp;out_resp-&gt;count_props);</span>
<span class="p_del">-	drm_modeset_unlock(&amp;dev-&gt;mode_config.connection_mutex);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto out_unref;</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; DRM_CONNECTOR_MAX_ENCODER; i++)
 		if (connector-&gt;encoder_ids[i] != 0)
 			encoders_count++;
<span class="p_chunk">@@ -1196,7 +1181,7 @@</span> <span class="p_context"> int drm_mode_getconnector(struct drm_device *dev, void *data,</span>
 				if (put_user(connector-&gt;encoder_ids[i],
 					     encoder_ptr + copied)) {
 					ret = -EFAULT;
<span class="p_del">-					goto out_unref;</span>
<span class="p_add">+					goto out;</span>
 				}
 				copied++;
 			}
<span class="p_chunk">@@ -1240,15 +1225,32 @@</span> <span class="p_context"> int drm_mode_getconnector(struct drm_device *dev, void *data,</span>
 			if (copy_to_user(mode_ptr + copied,
 					 &amp;u_mode, sizeof(u_mode))) {
 				ret = -EFAULT;
<span class="p_add">+				mutex_unlock(&amp;dev-&gt;mode_config.mutex);</span>
<span class="p_add">+</span>
 				goto out;
 			}
 			copied++;
 		}
 	}
 	out_resp-&gt;count_modes = mode_count;
<span class="p_del">-out:</span>
 	mutex_unlock(&amp;dev-&gt;mode_config.mutex);
<span class="p_del">-out_unref:</span>
<span class="p_add">+</span>
<span class="p_add">+	drm_modeset_lock(&amp;dev-&gt;mode_config.connection_mutex, NULL);</span>
<span class="p_add">+	encoder = drm_connector_get_encoder(connector);</span>
<span class="p_add">+	if (encoder)</span>
<span class="p_add">+		out_resp-&gt;encoder_id = encoder-&gt;base.id;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		out_resp-&gt;encoder_id = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Only grab properties after probing, to make sure EDID and other</span>
<span class="p_add">+	 * properties reflect the latest status. */</span>
<span class="p_add">+	ret = drm_mode_object_get_properties(&amp;connector-&gt;base, file_priv-&gt;atomic,</span>
<span class="p_add">+			(uint32_t __user *)(unsigned long)(out_resp-&gt;props_ptr),</span>
<span class="p_add">+			(uint64_t __user *)(unsigned long)(out_resp-&gt;prop_values_ptr),</span>
<span class="p_add">+			&amp;out_resp-&gt;count_props);</span>
<span class="p_add">+	drm_modeset_unlock(&amp;dev-&gt;mode_config.connection_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	drm_connector_unreference(connector);
 
 	return ret;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_combios.c b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">index 432480ff9d22..3178ba0c537c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_combios.c</span>
<span class="p_chunk">@@ -3393,6 +3393,13 @@</span> <span class="p_context"> void radeon_combios_asic_init(struct drm_device *dev)</span>
 	    rdev-&gt;pdev-&gt;subsystem_vendor == 0x103c &amp;&amp;
 	    rdev-&gt;pdev-&gt;subsystem_device == 0x280a)
 		return;
<span class="p_add">+	/* quirk for rs4xx Toshiba Sattellite L20-183 latop to make it resume</span>
<span class="p_add">+	 * - it hangs on resume inside the dynclk 1 table.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rdev-&gt;family == CHIP_RS400 &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;subsystem_vendor == 0x1179 &amp;&amp;</span>
<span class="p_add">+	    rdev-&gt;pdev-&gt;subsystem_device == 0xff31)</span>
<span class="p_add">+	        return;</span>
 
 	/* DYN CLK 1 */
 	table = combios_get_table_offset(dev, COMBIOS_DYN_CLK_1_TABLE);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index 4b0c388be3f5..5cdc39125b42 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -136,6 +136,10 @@</span> <span class="p_context"> static struct radeon_px_quirk radeon_px_quirk_list[] = {</span>
 	 * https://bugzilla.kernel.org/show_bug.cgi?id=51381
 	 */
 	{ PCI_VENDOR_ID_ATI, 0x6840, 0x1043, 0x2122, RADEON_PX_QUIRK_DISABLE_PX },
<span class="p_add">+	/* Asus K53TK laptop with AMD A6-3420M APU and Radeon 7670m GPU</span>
<span class="p_add">+	 * https://bugs.freedesktop.org/show_bug.cgi?id=101491</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6741, 0x1043, 0x2122, RADEON_PX_QUIRK_DISABLE_PX },</span>
 	/* macbook pro 8.2 */
 	{ PCI_VENDOR_ID_ATI, 0x6741, PCI_VENDOR_ID_APPLE, 0x00e2, RADEON_PX_QUIRK_LONG_WAKEUP },
 	{ 0, 0, 0, 0, 0 },
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index b26c030926c1..d3793867adae 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -315,6 +315,9 @@</span> <span class="p_context"></span>
 #define USB_VENDOR_ID_DELCOM		0x0fc5
 #define USB_DEVICE_ID_DELCOM_VISUAL_IND	0xb080
 
<span class="p_add">+#define USB_VENDOR_ID_DELL				0x413c</span>
<span class="p_add">+#define USB_DEVICE_ID_DELL_PIXART_USB_OPTICAL_MOUSE	0x301a</span>
<span class="p_add">+</span>
 #define USB_VENDOR_ID_DELORME		0x1163
 #define USB_DEVICE_ID_DELORME_EARTHMATE	0x0100
 #define USB_DEVICE_ID_DELORME_EM_LT20	0x0200
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index a69a3c88ab29..9f9eb32ab7db 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -84,6 +84,7 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_K65RGB_RAPIDFIRE, HID_QUIRK_NO_INIT_REPORTS | HID_QUIRK_ALWAYS_POLL },
 	{ USB_VENDOR_ID_CORSAIR, USB_DEVICE_ID_CORSAIR_SCIMITAR_PRO_RGB, HID_QUIRK_NO_INIT_REPORTS | HID_QUIRK_ALWAYS_POLL },
 	{ USB_VENDOR_ID_CREATIVELABS, USB_DEVICE_ID_CREATIVE_SB_OMNI_SURROUND_51, HID_QUIRK_NOGET },
<span class="p_add">+	{ USB_VENDOR_ID_DELL, USB_DEVICE_ID_DELL_PIXART_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },</span>
 	{ USB_VENDOR_ID_DMI, USB_DEVICE_ID_DMI_ENC, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_WIIU, HID_QUIRK_MULTI_INPUT },
 	{ USB_VENDOR_ID_DRAGONRISE, USB_DEVICE_ID_DRAGONRISE_PS3, HID_QUIRK_MULTI_INPUT },
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index 09720d950686..f932a83b4990 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -723,6 +723,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_notimeout_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK U574&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Fujitsu UH554 laptop */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK UH544&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c</span>
<span class="p_header">index 012194bc92d3..1238c4ec5215 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/chelsio/cxgb4/cxgb4_main.c</span>
<span class="p_chunk">@@ -2192,9 +2192,10 @@</span> <span class="p_context"> static int cxgb_up(struct adapter *adap)</span>
 {
 	int err;
 
<span class="p_add">+	mutex_lock(&amp;uld_mutex);</span>
 	err = setup_sge_queues(adap);
 	if (err)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto rel_lock;</span>
 	err = setup_rss(adap);
 	if (err)
 		goto freeq;
<span class="p_chunk">@@ -2218,7 +2219,6 @@</span> <span class="p_context"> static int cxgb_up(struct adapter *adap)</span>
 			goto irq_err;
 	}
 
<span class="p_del">-	mutex_lock(&amp;uld_mutex);</span>
 	enable_rx(adap);
 	t4_sge_start(adap);
 	t4_intr_enable(adap);
<span class="p_chunk">@@ -2231,13 +2231,15 @@</span> <span class="p_context"> static int cxgb_up(struct adapter *adap)</span>
 #endif
 	/* Initialize hash mac addr list*/
 	INIT_LIST_HEAD(&amp;adap-&gt;mac_hlist);
<span class="p_del">- out:</span>
 	return err;
<span class="p_add">+</span>
  irq_err:
 	dev_err(adap-&gt;pdev_dev, &quot;request_irq failed, err %d\n&quot;, err);
  freeq:
 	t4_free_sge_resources(adap);
<span class="p_del">-	goto out;</span>
<span class="p_add">+ rel_lock:</span>
<span class="p_add">+	mutex_unlock(&amp;uld_mutex);</span>
<span class="p_add">+	return err;</span>
 }
 
 static void cxgb_down(struct adapter *adapter)
<span class="p_header">diff --git a/drivers/net/phy/marvell.c b/drivers/net/phy/marvell.c</span>
<span class="p_header">index 9097e42bec2e..57297ba23987 100644</span>
<span class="p_header">--- a/drivers/net/phy/marvell.c</span>
<span class="p_header">+++ b/drivers/net/phy/marvell.c</span>
<span class="p_chunk">@@ -1127,8 +1127,6 @@</span> <span class="p_context"> static int marvell_read_status_page(struct phy_device *phydev, int page)</span>
 		if (adv &lt; 0)
 			return adv;
 
<span class="p_del">-		lpa &amp;= adv;</span>
<span class="p_del">-</span>
 		if (status &amp; MII_M1011_PHY_STATUS_FULLDUPLEX)
 			phydev-&gt;duplex = DUPLEX_FULL;
 		else
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c</span>
<span class="p_header">index c7c1e9906500..d231042f19d6 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.c</span>
<span class="p_chunk">@@ -442,7 +442,7 @@</span> <span class="p_context"> struct brcmf_fw {</span>
 	const char *nvram_name;
 	u16 domain_nr;
 	u16 bus_nr;
<span class="p_del">-	void (*done)(struct device *dev, const struct firmware *fw,</span>
<span class="p_add">+	void (*done)(struct device *dev, int err, const struct firmware *fw,</span>
 		     void *nvram_image, u32 nvram_len);
 };
 
<span class="p_chunk">@@ -477,52 +477,51 @@</span> <span class="p_context"> static void brcmf_fw_request_nvram_done(const struct firmware *fw, void *ctx)</span>
 	if (!nvram &amp;&amp; !(fwctx-&gt;flags &amp; BRCMF_FW_REQ_NV_OPTIONAL))
 		goto fail;
 
<span class="p_del">-	fwctx-&gt;done(fwctx-&gt;dev, fwctx-&gt;code, nvram, nvram_length);</span>
<span class="p_add">+	fwctx-&gt;done(fwctx-&gt;dev, 0, fwctx-&gt;code, nvram, nvram_length);</span>
 	kfree(fwctx);
 	return;
 
 fail:
 	brcmf_dbg(TRACE, &quot;failed: dev=%s\n&quot;, dev_name(fwctx-&gt;dev));
 	release_firmware(fwctx-&gt;code);
<span class="p_del">-	device_release_driver(fwctx-&gt;dev);</span>
<span class="p_add">+	fwctx-&gt;done(fwctx-&gt;dev, -ENOENT, NULL, NULL, 0);</span>
 	kfree(fwctx);
 }
 
 static void brcmf_fw_request_code_done(const struct firmware *fw, void *ctx)
 {
 	struct brcmf_fw *fwctx = ctx;
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	brcmf_dbg(TRACE, &quot;enter: dev=%s\n&quot;, dev_name(fwctx-&gt;dev));
<span class="p_del">-	if (!fw)</span>
<span class="p_add">+	if (!fw) {</span>
<span class="p_add">+		ret = -ENOENT;</span>
 		goto fail;
<span class="p_del">-</span>
<span class="p_del">-	/* only requested code so done here */</span>
<span class="p_del">-	if (!(fwctx-&gt;flags &amp; BRCMF_FW_REQUEST_NVRAM)) {</span>
<span class="p_del">-		fwctx-&gt;done(fwctx-&gt;dev, fw, NULL, 0);</span>
<span class="p_del">-		kfree(fwctx);</span>
<span class="p_del">-		return;</span>
 	}
<span class="p_add">+	/* only requested code so done here */</span>
<span class="p_add">+	if (!(fwctx-&gt;flags &amp; BRCMF_FW_REQUEST_NVRAM))</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+</span>
 	fwctx-&gt;code = fw;
 	ret = request_firmware_nowait(THIS_MODULE, true, fwctx-&gt;nvram_name,
 				      fwctx-&gt;dev, GFP_KERNEL, fwctx,
 				      brcmf_fw_request_nvram_done);
 
<span class="p_del">-	if (!ret)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	brcmf_fw_request_nvram_done(NULL, fwctx);</span>
<span class="p_add">+	/* pass NULL to nvram callback for bcm47xx fallback */</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		brcmf_fw_request_nvram_done(NULL, fwctx);</span>
 	return;
 
 fail:
 	brcmf_dbg(TRACE, &quot;failed: dev=%s\n&quot;, dev_name(fwctx-&gt;dev));
<span class="p_del">-	device_release_driver(fwctx-&gt;dev);</span>
<span class="p_add">+done:</span>
<span class="p_add">+	fwctx-&gt;done(fwctx-&gt;dev, ret, fw, NULL, 0);</span>
 	kfree(fwctx);
 }
 
 int brcmf_fw_get_firmwares_pcie(struct device *dev, u16 flags,
 				const char *code, const char *nvram,
<span class="p_del">-				void (*fw_cb)(struct device *dev,</span>
<span class="p_add">+				void (*fw_cb)(struct device *dev, int err,</span>
 					      const struct firmware *fw,
 					      void *nvram_image, u32 nvram_len),
 				u16 domain_nr, u16 bus_nr)
<span class="p_chunk">@@ -555,7 +554,7 @@</span> <span class="p_context"> int brcmf_fw_get_firmwares_pcie(struct device *dev, u16 flags,</span>
 
 int brcmf_fw_get_firmwares(struct device *dev, u16 flags,
 			   const char *code, const char *nvram,
<span class="p_del">-			   void (*fw_cb)(struct device *dev,</span>
<span class="p_add">+			   void (*fw_cb)(struct device *dev, int err,</span>
 					 const struct firmware *fw,
 					 void *nvram_image, u32 nvram_len))
 {
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h</span>
<span class="p_header">index d3c9f0d52ae3..8fa4b7e1ab3d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/firmware.h</span>
<span class="p_chunk">@@ -73,13 +73,13 @@</span> <span class="p_context"> void brcmf_fw_nvram_free(void *nvram);</span>
  */
 int brcmf_fw_get_firmwares_pcie(struct device *dev, u16 flags,
 				const char *code, const char *nvram,
<span class="p_del">-				void (*fw_cb)(struct device *dev,</span>
<span class="p_add">+				void (*fw_cb)(struct device *dev, int err,</span>
 					      const struct firmware *fw,
 					      void *nvram_image, u32 nvram_len),
 				u16 domain_nr, u16 bus_nr);
 int brcmf_fw_get_firmwares(struct device *dev, u16 flags,
 			   const char *code, const char *nvram,
<span class="p_del">-			   void (*fw_cb)(struct device *dev,</span>
<span class="p_add">+			   void (*fw_cb)(struct device *dev, int err,</span>
 					 const struct firmware *fw,
 					 void *nvram_image, u32 nvram_len));
 
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c</span>
<span class="p_header">index 6fae4cf3f6ab..42c081d9fb9a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/pcie.c</span>
<span class="p_chunk">@@ -1650,16 +1650,23 @@</span> <span class="p_context"> static const struct brcmf_buscore_ops brcmf_pcie_buscore_ops = {</span>
 	.write32 = brcmf_pcie_buscore_write32,
 };
 
<span class="p_del">-static void brcmf_pcie_setup(struct device *dev, const struct firmware *fw,</span>
<span class="p_add">+static void brcmf_pcie_setup(struct device *dev, int ret,</span>
<span class="p_add">+			     const struct firmware *fw,</span>
 			     void *nvram, u32 nvram_len)
 {
<span class="p_del">-	struct brcmf_bus *bus = dev_get_drvdata(dev);</span>
<span class="p_del">-	struct brcmf_pciedev *pcie_bus_dev = bus-&gt;bus_priv.pcie;</span>
<span class="p_del">-	struct brcmf_pciedev_info *devinfo = pcie_bus_dev-&gt;devinfo;</span>
<span class="p_add">+	struct brcmf_bus *bus;</span>
<span class="p_add">+	struct brcmf_pciedev *pcie_bus_dev;</span>
<span class="p_add">+	struct brcmf_pciedev_info *devinfo;</span>
 	struct brcmf_commonring **flowrings;
<span class="p_del">-	int ret;</span>
 	u32 i;
 
<span class="p_add">+	/* check firmware loading result */</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+</span>
<span class="p_add">+	bus = dev_get_drvdata(dev);</span>
<span class="p_add">+	pcie_bus_dev = bus-&gt;bus_priv.pcie;</span>
<span class="p_add">+	devinfo = pcie_bus_dev-&gt;devinfo;</span>
 	brcmf_pcie_attach(devinfo);
 
 	/* Some of the firmwares have the size of the memory of the device
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">index 65689469c5a1..67bff5b8cd60 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/sdio.c</span>
<span class="p_chunk">@@ -3976,21 +3976,26 @@</span> <span class="p_context"> static const struct brcmf_bus_ops brcmf_sdio_bus_ops = {</span>
 	.get_memdump = brcmf_sdio_bus_get_memdump,
 };
 
<span class="p_del">-static void brcmf_sdio_firmware_callback(struct device *dev,</span>
<span class="p_add">+static void brcmf_sdio_firmware_callback(struct device *dev, int err,</span>
 					 const struct firmware *code,
 					 void *nvram, u32 nvram_len)
 {
<span class="p_del">-	struct brcmf_bus *bus_if = dev_get_drvdata(dev);</span>
<span class="p_del">-	struct brcmf_sdio_dev *sdiodev = bus_if-&gt;bus_priv.sdio;</span>
<span class="p_del">-	struct brcmf_sdio *bus = sdiodev-&gt;bus;</span>
<span class="p_del">-	int err = 0;</span>
<span class="p_add">+	struct brcmf_bus *bus_if;</span>
<span class="p_add">+	struct brcmf_sdio_dev *sdiodev;</span>
<span class="p_add">+	struct brcmf_sdio *bus;</span>
 	u8 saveclk;
 
<span class="p_del">-	brcmf_dbg(TRACE, &quot;Enter: dev=%s\n&quot;, dev_name(dev));</span>
<span class="p_add">+	brcmf_dbg(TRACE, &quot;Enter: dev=%s, err=%d\n&quot;, dev_name(dev), err);</span>
<span class="p_add">+	bus_if = dev_get_drvdata(dev);</span>
<span class="p_add">+	sdiodev = bus_if-&gt;bus_priv.sdio;</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto fail;</span>
 
 	if (!bus_if-&gt;drvr)
 		return;
 
<span class="p_add">+	bus = sdiodev-&gt;bus;</span>
<span class="p_add">+</span>
 	/* try to download image and nvram to the dongle */
 	bus-&gt;alp_only = true;
 	err = brcmf_sdio_download_firmware(bus, code, nvram, nvram_len);
<span class="p_chunk">@@ -4077,6 +4082,7 @@</span> <span class="p_context"> static void brcmf_sdio_firmware_callback(struct device *dev,</span>
 fail:
 	brcmf_dbg(TRACE, &quot;failed: dev=%s, err=%d\n&quot;, dev_name(dev), err);
 	device_release_driver(dev);
<span class="p_add">+	device_release_driver(&amp;sdiodev-&gt;func[2]-&gt;dev);</span>
 }
 
 struct brcmf_sdio *brcmf_sdio_probe(struct brcmf_sdio_dev *sdiodev)
<span class="p_header">diff --git a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c</span>
<span class="p_header">index d93ebbdc7737..1242c3f05aad 100644</span>
<span class="p_header">--- a/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/broadcom/brcm80211/brcmfmac/usb.c</span>
<span class="p_chunk">@@ -1158,17 +1158,18 @@</span> <span class="p_context"> static int brcmf_usb_bus_setup(struct brcmf_usbdev_info *devinfo)</span>
 	return ret;
 }
 
<span class="p_del">-static void brcmf_usb_probe_phase2(struct device *dev,</span>
<span class="p_add">+static void brcmf_usb_probe_phase2(struct device *dev, int ret,</span>
 				   const struct firmware *fw,
 				   void *nvram, u32 nvlen)
 {
 	struct brcmf_bus *bus = dev_get_drvdata(dev);
<span class="p_del">-	struct brcmf_usbdev_info *devinfo;</span>
<span class="p_del">-	int ret;</span>
<span class="p_add">+	struct brcmf_usbdev_info *devinfo = bus-&gt;bus_priv.usb-&gt;devinfo;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto error;</span>
 
 	brcmf_dbg(USB, &quot;Start fw downloading\n&quot;);
 
<span class="p_del">-	devinfo = bus-&gt;bus_priv.usb-&gt;devinfo;</span>
 	ret = check_file(fw-&gt;data);
 	if (ret &lt; 0) {
 		brcmf_err(&quot;invalid firmware\n&quot;);
<span class="p_header">diff --git a/drivers/spi/spi.c b/drivers/spi/spi.c</span>
<span class="p_header">index 90b5b2efafbf..b4a8bb7759b2 100644</span>
<span class="p_header">--- a/drivers/spi/spi.c</span>
<span class="p_header">+++ b/drivers/spi/spi.c</span>
<span class="p_chunk">@@ -1015,7 +1015,7 @@</span> <span class="p_context"> static int spi_transfer_one_message(struct spi_master *master,</span>
 				ret = 0;
 				ms = 8LL * 1000LL * xfer-&gt;len;
 				do_div(ms, xfer-&gt;speed_hz);
<span class="p_del">-				ms += ms + 100; /* some tolerance */</span>
<span class="p_add">+				ms += ms + 200; /* some tolerance */</span>
 
 				if (ms &gt; UINT_MAX)
 					ms = UINT_MAX;
<span class="p_header">diff --git a/drivers/target/iscsi/iscsi_target.c b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">index fd45b48480cb..86433ef7f953 100644</span>
<span class="p_header">--- a/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_header">+++ b/drivers/target/iscsi/iscsi_target.c</span>
<span class="p_chunk">@@ -1289,6 +1289,18 @@</span> <span class="p_context"> iscsit_get_immediate_data(struct iscsi_cmd *cmd, struct iscsi_scsi_req *hdr,</span>
 	 */
 	if (dump_payload)
 		goto after_immediate_data;
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Check for underflow case where both EDTL and immediate data payload</span>
<span class="p_add">+	 * exceeds what is presented by CDB&#39;s TRANSFER LENGTH, and what has</span>
<span class="p_add">+	 * already been set in target_cmd_size_check() as se_cmd-&gt;data_length.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For this special case, fail the command and dump the immediate data</span>
<span class="p_add">+	 * payload.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cmd-&gt;first_burst_len &gt; cmd-&gt;se_cmd.data_length) {</span>
<span class="p_add">+		cmd-&gt;sense_reason = TCM_INVALID_CDB_FIELD;</span>
<span class="p_add">+		goto after_immediate_data;</span>
<span class="p_add">+	}</span>
 
 	immed_ret = iscsit_handle_immediate_data(cmd, hdr,
 					cmd-&gt;first_burst_len);
<span class="p_chunk">@@ -4443,8 +4455,11 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_closesession(</span>
 	 * always sleep waiting for RX/TX thread shutdown to complete
 	 * within iscsit_close_connection().
 	 */
<span class="p_del">-	if (!conn-&gt;conn_transport-&gt;rdma_shutdown)</span>
<span class="p_add">+	if (!conn-&gt;conn_transport-&gt;rdma_shutdown) {</span>
 		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);
<span class="p_add">+		if (!sleep)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_chunk">@@ -4460,8 +4475,11 @@</span> <span class="p_context"> static void iscsit_logout_post_handler_samecid(</span>
 {
 	int sleep = 1;
 
<span class="p_del">-	if (!conn-&gt;conn_transport-&gt;rdma_shutdown)</span>
<span class="p_add">+	if (!conn-&gt;conn_transport-&gt;rdma_shutdown) {</span>
 		sleep = cmpxchg(&amp;conn-&gt;tx_thread_active, true, false);
<span class="p_add">+		if (!sleep)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
 
 	atomic_set(&amp;conn-&gt;conn_logout_remove, 0);
 	complete(&amp;conn-&gt;conn_logout_comp);
<span class="p_header">diff --git a/drivers/target/target_core_internal.h b/drivers/target/target_core_internal.h</span>
<span class="p_header">index 9ab7090f7c83..0912de7c0cf8 100644</span>
<span class="p_header">--- a/drivers/target/target_core_internal.h</span>
<span class="p_header">+++ b/drivers/target/target_core_internal.h</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> int	init_se_kmem_caches(void);</span>
 void	release_se_kmem_caches(void);
 u32	scsi_get_new_index(scsi_index_t);
 void	transport_subsystem_check_init(void);
<span class="p_del">-void	transport_cmd_finish_abort(struct se_cmd *, int);</span>
<span class="p_add">+int	transport_cmd_finish_abort(struct se_cmd *, int);</span>
 unsigned char *transport_dump_cmd_direction(struct se_cmd *);
 void	transport_dump_dev_state(struct se_device *, char *, int *);
 void	transport_dump_dev_info(struct se_device *, struct se_lun *,
<span class="p_header">diff --git a/drivers/target/target_core_tmr.c b/drivers/target/target_core_tmr.c</span>
<span class="p_header">index dce1e1b47316..13f47bf4d16b 100644</span>
<span class="p_header">--- a/drivers/target/target_core_tmr.c</span>
<span class="p_header">+++ b/drivers/target/target_core_tmr.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> void core_tmr_release_req(struct se_tmr_req *tmr)</span>
 	kfree(tmr);
 }
 
<span class="p_del">-static void core_tmr_handle_tas_abort(struct se_cmd *cmd, int tas)</span>
<span class="p_add">+static int core_tmr_handle_tas_abort(struct se_cmd *cmd, int tas)</span>
 {
 	unsigned long flags;
 	bool remove = true, send_tas;
<span class="p_chunk">@@ -91,7 +91,7 @@</span> <span class="p_context"> static void core_tmr_handle_tas_abort(struct se_cmd *cmd, int tas)</span>
 		transport_send_task_abort(cmd);
 	}
 
<span class="p_del">-	transport_cmd_finish_abort(cmd, remove);</span>
<span class="p_add">+	return transport_cmd_finish_abort(cmd, remove);</span>
 }
 
 static int target_check_cdb_and_preempt(struct list_head *list,
<span class="p_chunk">@@ -184,8 +184,8 @@</span> <span class="p_context"> void core_tmr_abort_task(</span>
 		cancel_work_sync(&amp;se_cmd-&gt;work);
 		transport_wait_for_tasks(se_cmd);
 
<span class="p_del">-		transport_cmd_finish_abort(se_cmd, true);</span>
<span class="p_del">-		target_put_sess_cmd(se_cmd);</span>
<span class="p_add">+		if (!transport_cmd_finish_abort(se_cmd, true))</span>
<span class="p_add">+			target_put_sess_cmd(se_cmd);</span>
 
 		printk(&quot;ABORT_TASK: Sending TMR_FUNCTION_COMPLETE for&quot;
 				&quot; ref_tag: %llu\n&quot;, ref_tag);
<span class="p_chunk">@@ -281,8 +281,8 @@</span> <span class="p_context"> static void core_tmr_drain_tmr_list(</span>
 		cancel_work_sync(&amp;cmd-&gt;work);
 		transport_wait_for_tasks(cmd);
 
<span class="p_del">-		transport_cmd_finish_abort(cmd, 1);</span>
<span class="p_del">-		target_put_sess_cmd(cmd);</span>
<span class="p_add">+		if (!transport_cmd_finish_abort(cmd, 1))</span>
<span class="p_add">+			target_put_sess_cmd(cmd);</span>
 	}
 }
 
<span class="p_chunk">@@ -380,8 +380,8 @@</span> <span class="p_context"> static void core_tmr_drain_state_list(</span>
 		cancel_work_sync(&amp;cmd-&gt;work);
 		transport_wait_for_tasks(cmd);
 
<span class="p_del">-		core_tmr_handle_tas_abort(cmd, tas);</span>
<span class="p_del">-		target_put_sess_cmd(cmd);</span>
<span class="p_add">+		if (!core_tmr_handle_tas_abort(cmd, tas))</span>
<span class="p_add">+			target_put_sess_cmd(cmd);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index ff26626d94ef..690c790431dd 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -651,9 +651,10 @@</span> <span class="p_context"> static void transport_lun_remove_cmd(struct se_cmd *cmd)</span>
 		percpu_ref_put(&amp;lun-&gt;lun_ref);
 }
 
<span class="p_del">-void transport_cmd_finish_abort(struct se_cmd *cmd, int remove)</span>
<span class="p_add">+int transport_cmd_finish_abort(struct se_cmd *cmd, int remove)</span>
 {
 	bool ack_kref = (cmd-&gt;se_cmd_flags &amp; SCF_ACK_KREF);
<span class="p_add">+	int ret = 0;</span>
 
 	if (cmd-&gt;se_cmd_flags &amp; SCF_SE_LUN_CMD)
 		transport_lun_remove_cmd(cmd);
<span class="p_chunk">@@ -665,9 +666,11 @@</span> <span class="p_context"> void transport_cmd_finish_abort(struct se_cmd *cmd, int remove)</span>
 		cmd-&gt;se_tfo-&gt;aborted_task(cmd);
 
 	if (transport_cmd_check_stop_to_fabric(cmd))
<span class="p_del">-		return;</span>
<span class="p_add">+		return 1;</span>
 	if (remove &amp;&amp; ack_kref)
<span class="p_del">-		transport_put_cmd(cmd);</span>
<span class="p_add">+		ret = transport_put_cmd(cmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void target_complete_failure_work(struct work_struct *work)
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index a0085571824d..4c32c96f9c90 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -1859,12 +1859,12 @@</span> <span class="p_context"> static int ffs_func_eps_enable(struct ffs_function *func)</span>
 		ep-&gt;ep-&gt;driver_data = ep;
 		ep-&gt;ep-&gt;desc = ds;
 
<span class="p_del">-		comp_desc = (struct usb_ss_ep_comp_descriptor *)(ds +</span>
<span class="p_del">-				USB_DT_ENDPOINT_SIZE);</span>
<span class="p_del">-		ep-&gt;ep-&gt;maxburst = comp_desc-&gt;bMaxBurst + 1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (needs_comp_desc)</span>
<span class="p_add">+		if (needs_comp_desc) {</span>
<span class="p_add">+			comp_desc = (struct usb_ss_ep_comp_descriptor *)(ds +</span>
<span class="p_add">+					USB_DT_ENDPOINT_SIZE);</span>
<span class="p_add">+			ep-&gt;ep-&gt;maxburst = comp_desc-&gt;bMaxBurst + 1;</span>
 			ep-&gt;ep-&gt;comp_desc = comp_desc;
<span class="p_add">+		}</span>
 
 		ret = usb_ep_enable(ep-&gt;ep);
 		if (likely(!ret)) {
<span class="p_header">diff --git a/fs/autofs4/dev-ioctl.c b/fs/autofs4/dev-ioctl.c</span>
<span class="p_header">index 734cbf8d9676..dd9f1bebb5a3 100644</span>
<span class="p_header">--- a/fs/autofs4/dev-ioctl.c</span>
<span class="p_header">+++ b/fs/autofs4/dev-ioctl.c</span>
<span class="p_chunk">@@ -344,7 +344,7 @@</span> <span class="p_context"> static int autofs_dev_ioctl_fail(struct file *fp,</span>
 	int status;
 
 	token = (autofs_wqt_t) param-&gt;fail.token;
<span class="p_del">-	status = param-&gt;fail.status ? param-&gt;fail.status : -ENOENT;</span>
<span class="p_add">+	status = param-&gt;fail.status &lt; 0 ? param-&gt;fail.status : -ENOENT;</span>
 	return autofs4_wait_release(sbi, token, status);
 }
 
<span class="p_header">diff --git a/fs/cifs/smb1ops.c b/fs/cifs/smb1ops.c</span>
<span class="p_header">index 27bc360c7ffd..a723df3e0197 100644</span>
<span class="p_header">--- a/fs/cifs/smb1ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb1ops.c</span>
<span class="p_chunk">@@ -849,8 +849,13 @@</span> <span class="p_context"> cifs_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,</span>
 		     struct cifs_fid *fid, __u16 search_flags,
 		     struct cifs_search_info *srch_inf)
 {
<span class="p_del">-	return CIFSFindFirst(xid, tcon, path, cifs_sb,</span>
<span class="p_del">-			     &amp;fid-&gt;netfid, search_flags, srch_inf, true);</span>
<span class="p_add">+	int rc;</span>
<span class="p_add">+</span>
<span class="p_add">+	rc = CIFSFindFirst(xid, tcon, path, cifs_sb,</span>
<span class="p_add">+			   &amp;fid-&gt;netfid, search_flags, srch_inf, true);</span>
<span class="p_add">+	if (rc)</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;find first failed=%d\n&quot;, rc);</span>
<span class="p_add">+	return rc;</span>
 }
 
 static int
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index c58691834eb2..7e48561abd29 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -982,7 +982,7 @@</span> <span class="p_context"> smb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,</span>
 	rc = SMB2_open(xid, &amp;oparms, utf16_path, &amp;oplock, NULL, NULL);
 	kfree(utf16_path);
 	if (rc) {
<span class="p_del">-		cifs_dbg(VFS, &quot;open dir failed\n&quot;);</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;open dir failed rc=%d\n&quot;, rc);</span>
 		return rc;
 	}
 
<span class="p_chunk">@@ -992,7 +992,7 @@</span> <span class="p_context"> smb2_query_dir_first(const unsigned int xid, struct cifs_tcon *tcon,</span>
 	rc = SMB2_query_directory(xid, tcon, fid-&gt;persistent_fid,
 				  fid-&gt;volatile_fid, 0, srch_inf);
 	if (rc) {
<span class="p_del">-		cifs_dbg(VFS, &quot;query directory failed\n&quot;);</span>
<span class="p_add">+		cifs_dbg(FYI, &quot;query directory failed rc=%d\n&quot;, rc);</span>
 		SMB2_close(xid, tcon, fid-&gt;persistent_fid, fid-&gt;volatile_fid);
 	}
 	return rc;
<span class="p_chunk">@@ -1809,7 +1809,8 @@</span> <span class="p_context"> crypt_message(struct TCP_Server_Info *server, struct smb_rqst *rqst, int enc)</span>
 
 	sg = init_sg(rqst, sign);
 	if (!sg) {
<span class="p_del">-		cifs_dbg(VFS, &quot;%s: Failed to init sg %d&quot;, __func__, rc);</span>
<span class="p_add">+		cifs_dbg(VFS, &quot;%s: Failed to init sg&quot;, __func__);</span>
<span class="p_add">+		rc = -ENOMEM;</span>
 		goto free_req;
 	}
 
<span class="p_chunk">@@ -1817,6 +1818,7 @@</span> <span class="p_context"> crypt_message(struct TCP_Server_Info *server, struct smb_rqst *rqst, int enc)</span>
 	iv = kzalloc(iv_len, GFP_KERNEL);
 	if (!iv) {
 		cifs_dbg(VFS, &quot;%s: Failed to alloc IV&quot;, __func__);
<span class="p_add">+		rc = -ENOMEM;</span>
 		goto free_sg;
 	}
 	iv[0] = 3;
<span class="p_header">diff --git a/fs/dax.c b/fs/dax.c</span>
<span class="p_header">index 285f4ab6f498..08a793c61580 100644</span>
<span class="p_header">--- a/fs/dax.c</span>
<span class="p_header">+++ b/fs/dax.c</span>
<span class="p_chunk">@@ -875,6 +875,7 @@</span> <span class="p_context"> int dax_writeback_mapping_range(struct address_space *mapping,</span>
 			if (ret &lt; 0)
 				return ret;
 		}
<span class="p_add">+		start_index = indices[pvec.nr - 1] + 1;</span>
 	}
 	return 0;
 }
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 65145a3df065..ce0901e65c40 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -220,8 +220,26 @@</span> <span class="p_context"> static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,</span>
 
 	if (write) {
 		unsigned long size = bprm-&gt;vma-&gt;vm_end - bprm-&gt;vma-&gt;vm_start;
<span class="p_add">+		unsigned long ptr_size;</span>
 		struct rlimit *rlim;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Since the stack will hold pointers to the strings, we</span>
<span class="p_add">+		 * must account for them as well.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The size calculation is the entire vma while each arg page is</span>
<span class="p_add">+		 * built, so each time we get here it&#39;s calculating how far it</span>
<span class="p_add">+		 * is currently (rather than each call being just the newly</span>
<span class="p_add">+		 * added size from the arg page).  As a result, we need to</span>
<span class="p_add">+		 * always add the entire size of the pointers, so that on the</span>
<span class="p_add">+		 * last call to get_arg_page() we&#39;ll actually have the entire</span>
<span class="p_add">+		 * correct size.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ptr_size = (bprm-&gt;argc + bprm-&gt;envc) * sizeof(void *);</span>
<span class="p_add">+		if (ptr_size &gt; ULONG_MAX - size)</span>
<span class="p_add">+			goto fail;</span>
<span class="p_add">+		size += ptr_size;</span>
<span class="p_add">+</span>
 		acct_arg_size(bprm, size / PAGE_SIZE);
 
 		/*
<span class="p_chunk">@@ -239,13 +257,15 @@</span> <span class="p_context"> static struct page *get_arg_page(struct linux_binprm *bprm, unsigned long pos,</span>
 		 *    to work from.
 		 */
 		rlim = current-&gt;signal-&gt;rlim;
<span class="p_del">-		if (size &gt; ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4) {</span>
<span class="p_del">-			put_page(page);</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (size &gt; READ_ONCE(rlim[RLIMIT_STACK].rlim_cur) / 4)</span>
<span class="p_add">+			goto fail;</span>
 	}
 
 	return page;
<span class="p_add">+</span>
<span class="p_add">+fail:</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	return NULL;</span>
 }
 
 static void put_arg_page(struct page *page)
<span class="p_header">diff --git a/include/acpi/acpi_bus.h b/include/acpi/acpi_bus.h</span>
<span class="p_header">index ef0ae8aaa567..94f18da4be87 100644</span>
<span class="p_header">--- a/include/acpi/acpi_bus.h</span>
<span class="p_header">+++ b/include/acpi/acpi_bus.h</span>
<span class="p_chunk">@@ -209,7 +209,8 @@</span> <span class="p_context"> struct acpi_device_flags {</span>
 	u32 of_compatible_ok:1;
 	u32 coherent_dma:1;
 	u32 cca_seen:1;
<span class="p_del">-	u32 reserved:20;</span>
<span class="p_add">+	u32 spi_i2c_slave:1;</span>
<span class="p_add">+	u32 reserved:19;</span>
 };
 
 /* File System */
<span class="p_header">diff --git a/include/linux/netfilter/x_tables.h b/include/linux/netfilter/x_tables.h</span>
<span class="p_header">index be378cf47fcc..b3044c2c62cb 100644</span>
<span class="p_header">--- a/include/linux/netfilter/x_tables.h</span>
<span class="p_header">+++ b/include/linux/netfilter/x_tables.h</span>
<span class="p_chunk">@@ -294,7 +294,7 @@</span> <span class="p_context"> int xt_match_to_user(const struct xt_entry_match *m,</span>
 int xt_target_to_user(const struct xt_entry_target *t,
 		      struct xt_entry_target __user *u);
 int xt_data_to_user(void __user *dst, const void *src,
<span class="p_del">-		    int usersize, int size);</span>
<span class="p_add">+		    int usersize, int size, int aligned_size);</span>
 
 void *xt_copy_counters_from_user(const void __user *user, unsigned int len,
 				 struct xt_counters_info *info, bool compat);
<span class="p_header">diff --git a/include/linux/timekeeper_internal.h b/include/linux/timekeeper_internal.h</span>
<span class="p_header">index 110f4532188c..f7043ccca81c 100644</span>
<span class="p_header">--- a/include/linux/timekeeper_internal.h</span>
<span class="p_header">+++ b/include/linux/timekeeper_internal.h</span>
<span class="p_chunk">@@ -29,7 +29,6 @@</span> <span class="p_context"></span>
  */
 struct tk_read_base {
 	struct clocksource	*clock;
<span class="p_del">-	u64			(*read)(struct clocksource *cs);</span>
 	u64			mask;
 	u64			cycle_last;
 	u32			mult;
<span class="p_chunk">@@ -58,7 +57,7 @@</span> <span class="p_context"> struct tk_read_base {</span>
  *			interval.
  * @xtime_remainder:	Shifted nano seconds left over when rounding
  *			@cycle_interval
<span class="p_del">- * @raw_interval:	Raw nano seconds accumulated per NTP interval.</span>
<span class="p_add">+ * @raw_interval:	Shifted raw nano seconds accumulated per NTP interval.</span>
  * @ntp_error:		Difference between accumulated time and NTP time in ntp
  *			shifted nano seconds.
  * @ntp_error_shift:	Shift conversion between clock shifted nano seconds and
<span class="p_chunk">@@ -100,7 +99,7 @@</span> <span class="p_context"> struct timekeeper {</span>
 	u64			cycle_interval;
 	u64			xtime_interval;
 	s64			xtime_remainder;
<span class="p_del">-	u32			raw_interval;</span>
<span class="p_add">+	u64			raw_interval;</span>
 	/* The ntp_tick_length() value currently being used.
 	 * This cached copy ensures we consistently apply the tick
 	 * length for an entire tick, as ntp_tick_length may change
<span class="p_header">diff --git a/kernel/signal.c b/kernel/signal.c</span>
<span class="p_header">index 7e59ebc2c25e..e75e9601817e 100644</span>
<span class="p_header">--- a/kernel/signal.c</span>
<span class="p_header">+++ b/kernel/signal.c</span>
<span class="p_chunk">@@ -510,7 +510,8 @@</span> <span class="p_context"> int unhandled_signal(struct task_struct *tsk, int sig)</span>
 	return !tsk-&gt;ptrace;
 }
 
<span class="p_del">-static void collect_signal(int sig, struct sigpending *list, siginfo_t *info)</span>
<span class="p_add">+static void collect_signal(int sig, struct sigpending *list, siginfo_t *info,</span>
<span class="p_add">+			   bool *resched_timer)</span>
 {
 	struct sigqueue *q, *first = NULL;
 
<span class="p_chunk">@@ -532,6 +533,12 @@</span> <span class="p_context"> static void collect_signal(int sig, struct sigpending *list, siginfo_t *info)</span>
 still_pending:
 		list_del_init(&amp;first-&gt;list);
 		copy_siginfo(info, &amp;first-&gt;info);
<span class="p_add">+</span>
<span class="p_add">+		*resched_timer =</span>
<span class="p_add">+			(first-&gt;flags &amp; SIGQUEUE_PREALLOC) &amp;&amp;</span>
<span class="p_add">+			(info-&gt;si_code == SI_TIMER) &amp;&amp;</span>
<span class="p_add">+			(info-&gt;si_sys_private);</span>
<span class="p_add">+</span>
 		__sigqueue_free(first);
 	} else {
 		/*
<span class="p_chunk">@@ -548,12 +555,12 @@</span> <span class="p_context"> static void collect_signal(int sig, struct sigpending *list, siginfo_t *info)</span>
 }
 
 static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,
<span class="p_del">-			siginfo_t *info)</span>
<span class="p_add">+			siginfo_t *info, bool *resched_timer)</span>
 {
 	int sig = next_signal(pending, mask);
 
 	if (sig)
<span class="p_del">-		collect_signal(sig, pending, info);</span>
<span class="p_add">+		collect_signal(sig, pending, info, resched_timer);</span>
 	return sig;
 }
 
<span class="p_chunk">@@ -565,15 +572,16 @@</span> <span class="p_context"> static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,</span>
  */
 int dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)
 {
<span class="p_add">+	bool resched_timer = false;</span>
 	int signr;
 
 	/* We only dequeue private signals from ourselves, we don&#39;t let
 	 * signalfd steal them
 	 */
<span class="p_del">-	signr = __dequeue_signal(&amp;tsk-&gt;pending, mask, info);</span>
<span class="p_add">+	signr = __dequeue_signal(&amp;tsk-&gt;pending, mask, info, &amp;resched_timer);</span>
 	if (!signr) {
 		signr = __dequeue_signal(&amp;tsk-&gt;signal-&gt;shared_pending,
<span class="p_del">-					 mask, info);</span>
<span class="p_add">+					 mask, info, &amp;resched_timer);</span>
 #ifdef CONFIG_POSIX_TIMERS
 		/*
 		 * itimer signal ?
<span class="p_chunk">@@ -621,7 +629,7 @@</span> <span class="p_context"> int dequeue_signal(struct task_struct *tsk, sigset_t *mask, siginfo_t *info)</span>
 		current-&gt;jobctl |= JOBCTL_STOP_DEQUEUED;
 	}
 #ifdef CONFIG_POSIX_TIMERS
<span class="p_del">-	if ((info-&gt;si_code &amp; __SI_MASK) == __SI_TIMER &amp;&amp; info-&gt;si_sys_private) {</span>
<span class="p_add">+	if (resched_timer) {</span>
 		/*
 		 * Release the siglock to ensure proper locking order
 		 * of timer locks outside of siglocks.  Note, we leave
<span class="p_header">diff --git a/kernel/time/timekeeping.c b/kernel/time/timekeeping.c</span>
<span class="p_header">index 5b63a2102c29..0eaf309aae63 100644</span>
<span class="p_header">--- a/kernel/time/timekeeping.c</span>
<span class="p_header">+++ b/kernel/time/timekeeping.c</span>
<span class="p_chunk">@@ -118,6 +118,26 @@</span> <span class="p_context"> static inline void tk_update_sleep_time(struct timekeeper *tk, ktime_t delta)</span>
 	tk-&gt;offs_boot = ktime_add(tk-&gt;offs_boot, delta);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * tk_clock_read - atomic clocksource read() helper</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This helper is necessary to use in the read paths because, while the</span>
<span class="p_add">+ * seqlock ensures we don&#39;t return a bad value while structures are updated,</span>
<span class="p_add">+ * it doesn&#39;t protect from potential crashes. There is the possibility that</span>
<span class="p_add">+ * the tkr&#39;s clocksource may change between the read reference, and the</span>
<span class="p_add">+ * clock reference passed to the read function.  This can cause crashes if</span>
<span class="p_add">+ * the wrong clocksource is passed to the wrong read function.</span>
<span class="p_add">+ * This isn&#39;t necessary to use when holding the timekeeper_lock or doing</span>
<span class="p_add">+ * a read of the fast-timekeeper tkrs (which is protected by its own locking</span>
<span class="p_add">+ * and update logic).</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline u64 tk_clock_read(struct tk_read_base *tkr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct clocksource *clock = READ_ONCE(tkr-&gt;clock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return clock-&gt;read(clock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_DEBUG_TIMEKEEPING
 #define WARNING_FREQ (HZ*300) /* 5 minute rate-limiting */
 
<span class="p_chunk">@@ -175,7 +195,7 @@</span> <span class="p_context"> static inline u64 timekeeping_get_delta(struct tk_read_base *tkr)</span>
 	 */
 	do {
 		seq = read_seqcount_begin(&amp;tk_core.seq);
<span class="p_del">-		now = tkr-&gt;read(tkr-&gt;clock);</span>
<span class="p_add">+		now = tk_clock_read(tkr);</span>
 		last = tkr-&gt;cycle_last;
 		mask = tkr-&gt;mask;
 		max = tkr-&gt;clock-&gt;max_cycles;
<span class="p_chunk">@@ -209,7 +229,7 @@</span> <span class="p_context"> static inline u64 timekeeping_get_delta(struct tk_read_base *tkr)</span>
 	u64 cycle_now, delta;
 
 	/* read clocksource */
<span class="p_del">-	cycle_now = tkr-&gt;read(tkr-&gt;clock);</span>
<span class="p_add">+	cycle_now = tk_clock_read(tkr);</span>
 
 	/* calculate the delta since the last update_wall_time */
 	delta = clocksource_delta(cycle_now, tkr-&gt;cycle_last, tkr-&gt;mask);
<span class="p_chunk">@@ -238,12 +258,10 @@</span> <span class="p_context"> static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)</span>
 	++tk-&gt;cs_was_changed_seq;
 	old_clock = tk-&gt;tkr_mono.clock;
 	tk-&gt;tkr_mono.clock = clock;
<span class="p_del">-	tk-&gt;tkr_mono.read = clock-&gt;read;</span>
 	tk-&gt;tkr_mono.mask = clock-&gt;mask;
<span class="p_del">-	tk-&gt;tkr_mono.cycle_last = tk-&gt;tkr_mono.read(clock);</span>
<span class="p_add">+	tk-&gt;tkr_mono.cycle_last = tk_clock_read(&amp;tk-&gt;tkr_mono);</span>
 
 	tk-&gt;tkr_raw.clock = clock;
<span class="p_del">-	tk-&gt;tkr_raw.read = clock-&gt;read;</span>
 	tk-&gt;tkr_raw.mask = clock-&gt;mask;
 	tk-&gt;tkr_raw.cycle_last = tk-&gt;tkr_mono.cycle_last;
 
<span class="p_chunk">@@ -262,7 +280,7 @@</span> <span class="p_context"> static void tk_setup_internals(struct timekeeper *tk, struct clocksource *clock)</span>
 	/* Go back from cycles -&gt; shifted ns */
 	tk-&gt;xtime_interval = interval * clock-&gt;mult;
 	tk-&gt;xtime_remainder = ntpinterval - tk-&gt;xtime_interval;
<span class="p_del">-	tk-&gt;raw_interval = (interval * clock-&gt;mult) &gt;&gt; clock-&gt;shift;</span>
<span class="p_add">+	tk-&gt;raw_interval = interval * clock-&gt;mult;</span>
 
 	 /* if changing clocks, convert xtime_nsec shift units */
 	if (old_clock) {
<span class="p_chunk">@@ -404,7 +422,7 @@</span> <span class="p_context"> static __always_inline u64 __ktime_get_fast_ns(struct tk_fast *tkf)</span>
 
 		now += timekeeping_delta_to_ns(tkr,
 				clocksource_delta(
<span class="p_del">-					tkr-&gt;read(tkr-&gt;clock),</span>
<span class="p_add">+					tk_clock_read(tkr),</span>
 					tkr-&gt;cycle_last,
 					tkr-&gt;mask));
 	} while (read_seqcount_retry(&amp;tkf-&gt;seq, seq));
<span class="p_chunk">@@ -461,6 +479,10 @@</span> <span class="p_context"> static u64 dummy_clock_read(struct clocksource *cs)</span>
 	return cycles_at_suspend;
 }
 
<span class="p_add">+static struct clocksource dummy_clock = {</span>
<span class="p_add">+	.read = dummy_clock_read,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /**
  * halt_fast_timekeeper - Prevent fast timekeeper from accessing clocksource.
  * @tk: Timekeeper to snapshot.
<span class="p_chunk">@@ -477,13 +499,13 @@</span> <span class="p_context"> static void halt_fast_timekeeper(struct timekeeper *tk)</span>
 	struct tk_read_base *tkr = &amp;tk-&gt;tkr_mono;
 
 	memcpy(&amp;tkr_dummy, tkr, sizeof(tkr_dummy));
<span class="p_del">-	cycles_at_suspend = tkr-&gt;read(tkr-&gt;clock);</span>
<span class="p_del">-	tkr_dummy.read = dummy_clock_read;</span>
<span class="p_add">+	cycles_at_suspend = tk_clock_read(tkr);</span>
<span class="p_add">+	tkr_dummy.clock = &amp;dummy_clock;</span>
 	update_fast_timekeeper(&amp;tkr_dummy, &amp;tk_fast_mono);
 
 	tkr = &amp;tk-&gt;tkr_raw;
 	memcpy(&amp;tkr_dummy, tkr, sizeof(tkr_dummy));
<span class="p_del">-	tkr_dummy.read = dummy_clock_read;</span>
<span class="p_add">+	tkr_dummy.clock = &amp;dummy_clock;</span>
 	update_fast_timekeeper(&amp;tkr_dummy, &amp;tk_fast_raw);
 }
 
<span class="p_chunk">@@ -649,11 +671,10 @@</span> <span class="p_context"> static void timekeeping_update(struct timekeeper *tk, unsigned int action)</span>
  */
 static void timekeeping_forward_now(struct timekeeper *tk)
 {
<span class="p_del">-	struct clocksource *clock = tk-&gt;tkr_mono.clock;</span>
 	u64 cycle_now, delta;
 	u64 nsec;
 
<span class="p_del">-	cycle_now = tk-&gt;tkr_mono.read(clock);</span>
<span class="p_add">+	cycle_now = tk_clock_read(&amp;tk-&gt;tkr_mono);</span>
 	delta = clocksource_delta(cycle_now, tk-&gt;tkr_mono.cycle_last, tk-&gt;tkr_mono.mask);
 	tk-&gt;tkr_mono.cycle_last = cycle_now;
 	tk-&gt;tkr_raw.cycle_last  = cycle_now;
<span class="p_chunk">@@ -929,8 +950,7 @@</span> <span class="p_context"> void ktime_get_snapshot(struct system_time_snapshot *systime_snapshot)</span>
 
 	do {
 		seq = read_seqcount_begin(&amp;tk_core.seq);
<span class="p_del">-</span>
<span class="p_del">-		now = tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock);</span>
<span class="p_add">+		now = tk_clock_read(&amp;tk-&gt;tkr_mono);</span>
 		systime_snapshot-&gt;cs_was_changed_seq = tk-&gt;cs_was_changed_seq;
 		systime_snapshot-&gt;clock_was_set_seq = tk-&gt;clock_was_set_seq;
 		base_real = ktime_add(tk-&gt;tkr_mono.base,
<span class="p_chunk">@@ -1109,7 +1129,7 @@</span> <span class="p_context"> int get_device_system_crosststamp(int (*get_time_fn)</span>
 		 * Check whether the system counter value provided by the
 		 * device driver is on the current timekeeping interval.
 		 */
<span class="p_del">-		now = tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock);</span>
<span class="p_add">+		now = tk_clock_read(&amp;tk-&gt;tkr_mono);</span>
 		interval_start = tk-&gt;tkr_mono.cycle_last;
 		if (!cycle_between(interval_start, cycles, now)) {
 			clock_was_set_seq = tk-&gt;clock_was_set_seq;
<span class="p_chunk">@@ -1630,7 +1650,7 @@</span> <span class="p_context"> void timekeeping_resume(void)</span>
 	 * The less preferred source will only be tried if there is no better
 	 * usable source. The rtc part is handled separately in rtc core code.
 	 */
<span class="p_del">-	cycle_now = tk-&gt;tkr_mono.read(clock);</span>
<span class="p_add">+	cycle_now = tk_clock_read(&amp;tk-&gt;tkr_mono);</span>
 	if ((clock-&gt;flags &amp; CLOCK_SOURCE_SUSPEND_NONSTOP) &amp;&amp;
 		cycle_now &gt; tk-&gt;tkr_mono.cycle_last) {
 		u64 nsec, cyc_delta;
<span class="p_chunk">@@ -1977,7 +1997,7 @@</span> <span class="p_context"> static u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,</span>
 				    u32 shift, unsigned int *clock_set)
 {
 	u64 interval = tk-&gt;cycle_interval &lt;&lt; shift;
<span class="p_del">-	u64 raw_nsecs;</span>
<span class="p_add">+	u64 snsec_per_sec;</span>
 
 	/* If the offset is smaller than a shifted interval, do nothing */
 	if (offset &lt; interval)
<span class="p_chunk">@@ -1992,14 +2012,15 @@</span> <span class="p_context"> static u64 logarithmic_accumulation(struct timekeeper *tk, u64 offset,</span>
 	*clock_set |= accumulate_nsecs_to_secs(tk);
 
 	/* Accumulate raw time */
<span class="p_del">-	raw_nsecs = (u64)tk-&gt;raw_interval &lt;&lt; shift;</span>
<span class="p_del">-	raw_nsecs += tk-&gt;raw_time.tv_nsec;</span>
<span class="p_del">-	if (raw_nsecs &gt;= NSEC_PER_SEC) {</span>
<span class="p_del">-		u64 raw_secs = raw_nsecs;</span>
<span class="p_del">-		raw_nsecs = do_div(raw_secs, NSEC_PER_SEC);</span>
<span class="p_del">-		tk-&gt;raw_time.tv_sec += raw_secs;</span>
<span class="p_add">+	tk-&gt;tkr_raw.xtime_nsec += (u64)tk-&gt;raw_time.tv_nsec &lt;&lt; tk-&gt;tkr_raw.shift;</span>
<span class="p_add">+	tk-&gt;tkr_raw.xtime_nsec += tk-&gt;raw_interval &lt;&lt; shift;</span>
<span class="p_add">+	snsec_per_sec = (u64)NSEC_PER_SEC &lt;&lt; tk-&gt;tkr_raw.shift;</span>
<span class="p_add">+	while (tk-&gt;tkr_raw.xtime_nsec &gt;= snsec_per_sec) {</span>
<span class="p_add">+		tk-&gt;tkr_raw.xtime_nsec -= snsec_per_sec;</span>
<span class="p_add">+		tk-&gt;raw_time.tv_sec++;</span>
 	}
<span class="p_del">-	tk-&gt;raw_time.tv_nsec = raw_nsecs;</span>
<span class="p_add">+	tk-&gt;raw_time.tv_nsec = tk-&gt;tkr_raw.xtime_nsec &gt;&gt; tk-&gt;tkr_raw.shift;</span>
<span class="p_add">+	tk-&gt;tkr_raw.xtime_nsec -= (u64)tk-&gt;raw_time.tv_nsec &lt;&lt; tk-&gt;tkr_raw.shift;</span>
 
 	/* Accumulate error between NTP and clock interval */
 	tk-&gt;ntp_error += tk-&gt;ntp_tick &lt;&lt; shift;
<span class="p_chunk">@@ -2031,7 +2052,7 @@</span> <span class="p_context"> void update_wall_time(void)</span>
 #ifdef CONFIG_ARCH_USES_GETTIMEOFFSET
 	offset = real_tk-&gt;cycle_interval;
 #else
<span class="p_del">-	offset = clocksource_delta(tk-&gt;tkr_mono.read(tk-&gt;tkr_mono.clock),</span>
<span class="p_add">+	offset = clocksource_delta(tk_clock_read(&amp;tk-&gt;tkr_mono),</span>
 				   tk-&gt;tkr_mono.cycle_last, tk-&gt;tkr_mono.mask);
 #endif
 
<span class="p_header">diff --git a/lib/cmdline.c b/lib/cmdline.c</span>
<span class="p_header">index 8f13cf73c2ec..79069d7938ea 100644</span>
<span class="p_header">--- a/lib/cmdline.c</span>
<span class="p_header">+++ b/lib/cmdline.c</span>
<span class="p_chunk">@@ -22,14 +22,14 @@</span> <span class="p_context"></span>
  *	the values[M, M+1, ..., N] into the ints array in get_options.
  */
 
<span class="p_del">-static int get_range(char **str, int *pint)</span>
<span class="p_add">+static int get_range(char **str, int *pint, int n)</span>
 {
 	int x, inc_counter, upper_range;
 
 	(*str)++;
 	upper_range = simple_strtol((*str), NULL, 0);
 	inc_counter = upper_range - *pint;
<span class="p_del">-	for (x = *pint; x &lt; upper_range; x++)</span>
<span class="p_add">+	for (x = *pint; n &amp;&amp; x &lt; upper_range; x++, n--)</span>
 		*pint++ = x;
 	return inc_counter;
 }
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> char *get_options(const char *str, int nints, int *ints)</span>
 			break;
 		if (res == 3) {
 			int range_nums;
<span class="p_del">-			range_nums = get_range((char **)&amp;str, ints + i);</span>
<span class="p_add">+			range_nums = get_range((char **)&amp;str, ints + i, nints - i);</span>
 			if (range_nums &lt; 0)
 				break;
 			/*
<span class="p_header">diff --git a/net/bridge/netfilter/ebtables.c b/net/bridge/netfilter/ebtables.c</span>
<span class="p_header">index 79b69917f521..656c259bcc14 100644</span>
<span class="p_header">--- a/net/bridge/netfilter/ebtables.c</span>
<span class="p_header">+++ b/net/bridge/netfilter/ebtables.c</span>
<span class="p_chunk">@@ -1358,7 +1358,8 @@</span> <span class="p_context"> static inline int ebt_obj_to_user(char __user *um, const char *_name,</span>
 	strlcpy(name, _name, sizeof(name));
 	if (copy_to_user(um, name, EBT_FUNCTION_MAXNAMELEN) ||
 	    put_user(datasize, (int __user *)(um + EBT_FUNCTION_MAXNAMELEN)) ||
<span class="p_del">-	    xt_data_to_user(um + entrysize, data, usersize, datasize))</span>
<span class="p_add">+	    xt_data_to_user(um + entrysize, data, usersize, datasize,</span>
<span class="p_add">+			    XT_ALIGN(datasize)))</span>
 		return -EFAULT;
 
 	return 0;
<span class="p_chunk">@@ -1643,7 +1644,8 @@</span> <span class="p_context"> static int compat_match_to_user(struct ebt_entry_match *m, void __user **dstptr,</span>
 		if (match-&gt;compat_to_user(cm-&gt;data, m-&gt;data))
 			return -EFAULT;
 	} else {
<span class="p_del">-		if (xt_data_to_user(cm-&gt;data, m-&gt;data, match-&gt;usersize, msize))</span>
<span class="p_add">+		if (xt_data_to_user(cm-&gt;data, m-&gt;data, match-&gt;usersize, msize,</span>
<span class="p_add">+				    COMPAT_XT_ALIGN(msize)))</span>
 			return -EFAULT;
 	}
 
<span class="p_chunk">@@ -1672,7 +1674,8 @@</span> <span class="p_context"> static int compat_target_to_user(struct ebt_entry_target *t,</span>
 		if (target-&gt;compat_to_user(cm-&gt;data, t-&gt;data))
 			return -EFAULT;
 	} else {
<span class="p_del">-		if (xt_data_to_user(cm-&gt;data, t-&gt;data, target-&gt;usersize, tsize))</span>
<span class="p_add">+		if (xt_data_to_user(cm-&gt;data, t-&gt;data, target-&gt;usersize, tsize,</span>
<span class="p_add">+				    COMPAT_XT_ALIGN(tsize)))</span>
 			return -EFAULT;
 	}
 
<span class="p_header">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span>
<span class="p_header">index 14857afc9937..32488c09cfb9 100644</span>
<span class="p_header">--- a/net/netfilter/x_tables.c</span>
<span class="p_header">+++ b/net/netfilter/x_tables.c</span>
<span class="p_chunk">@@ -283,28 +283,30 @@</span> <span class="p_context"> static int xt_obj_to_user(u16 __user *psize, u16 size,</span>
 		       &amp;U-&gt;u.user.revision, K-&gt;u.kernel.TYPE-&gt;revision)
 
 int xt_data_to_user(void __user *dst, const void *src,
<span class="p_del">-		    int usersize, int size)</span>
<span class="p_add">+		    int usersize, int size, int aligned_size)</span>
 {
 	usersize = usersize ? : size;
 	if (copy_to_user(dst, src, usersize))
 		return -EFAULT;
<span class="p_del">-	if (usersize != size &amp;&amp; clear_user(dst + usersize, size - usersize))</span>
<span class="p_add">+	if (usersize != aligned_size &amp;&amp;</span>
<span class="p_add">+	    clear_user(dst + usersize, aligned_size - usersize))</span>
 		return -EFAULT;
 
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xt_data_to_user);
 
<span class="p_del">-#define XT_DATA_TO_USER(U, K, TYPE, C_SIZE)				\</span>
<span class="p_add">+#define XT_DATA_TO_USER(U, K, TYPE)					\</span>
 	xt_data_to_user(U-&gt;data, K-&gt;data,				\
 			K-&gt;u.kernel.TYPE-&gt;usersize,			\
<span class="p_del">-			C_SIZE ? : K-&gt;u.kernel.TYPE-&gt;TYPE##size)</span>
<span class="p_add">+			K-&gt;u.kernel.TYPE-&gt;TYPE##size,			\</span>
<span class="p_add">+			XT_ALIGN(K-&gt;u.kernel.TYPE-&gt;TYPE##size))</span>
 
 int xt_match_to_user(const struct xt_entry_match *m,
 		     struct xt_entry_match __user *u)
 {
 	return XT_OBJ_TO_USER(u, m, match, 0) ||
<span class="p_del">-	       XT_DATA_TO_USER(u, m, match, 0);</span>
<span class="p_add">+	       XT_DATA_TO_USER(u, m, match);</span>
 }
 EXPORT_SYMBOL_GPL(xt_match_to_user);
 
<span class="p_chunk">@@ -312,7 +314,7 @@</span> <span class="p_context"> int xt_target_to_user(const struct xt_entry_target *t,</span>
 		      struct xt_entry_target __user *u)
 {
 	return XT_OBJ_TO_USER(u, t, target, 0) ||
<span class="p_del">-	       XT_DATA_TO_USER(u, t, target, 0);</span>
<span class="p_add">+	       XT_DATA_TO_USER(u, t, target);</span>
 }
 EXPORT_SYMBOL_GPL(xt_target_to_user);
 
<span class="p_chunk">@@ -611,6 +613,12 @@</span> <span class="p_context"> void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_from_user);
 
<span class="p_add">+#define COMPAT_XT_DATA_TO_USER(U, K, TYPE, C_SIZE)			\</span>
<span class="p_add">+	xt_data_to_user(U-&gt;data, K-&gt;data,				\</span>
<span class="p_add">+			K-&gt;u.kernel.TYPE-&gt;usersize,			\</span>
<span class="p_add">+			C_SIZE,						\</span>
<span class="p_add">+			COMPAT_XT_ALIGN(C_SIZE))</span>
<span class="p_add">+</span>
 int xt_compat_match_to_user(const struct xt_entry_match *m,
 			    void __user **dstptr, unsigned int *size)
 {
<span class="p_chunk">@@ -626,7 +634,7 @@</span> <span class="p_context"> int xt_compat_match_to_user(const struct xt_entry_match *m,</span>
 		if (match-&gt;compat_to_user((void __user *)cm-&gt;data, m-&gt;data))
 			return -EFAULT;
 	} else {
<span class="p_del">-		if (XT_DATA_TO_USER(cm, m, match, msize - sizeof(*cm)))</span>
<span class="p_add">+		if (COMPAT_XT_DATA_TO_USER(cm, m, match, msize - sizeof(*cm)))</span>
 			return -EFAULT;
 	}
 
<span class="p_chunk">@@ -981,7 +989,7 @@</span> <span class="p_context"> int xt_compat_target_to_user(const struct xt_entry_target *t,</span>
 		if (target-&gt;compat_to_user((void __user *)ct-&gt;data, t-&gt;data))
 			return -EFAULT;
 	} else {
<span class="p_del">-		if (XT_DATA_TO_USER(ct, t, target, tsize - sizeof(*ct)))</span>
<span class="p_add">+		if (COMPAT_XT_DATA_TO_USER(ct, t, target, tsize - sizeof(*ct)))</span>
 			return -EFAULT;
 	}
 
<span class="p_header">diff --git a/net/rxrpc/key.c b/net/rxrpc/key.c</span>
<span class="p_header">index 0a4e28477ad9..54369225766e 100644</span>
<span class="p_header">--- a/net/rxrpc/key.c</span>
<span class="p_header">+++ b/net/rxrpc/key.c</span>
<span class="p_chunk">@@ -217,7 +217,7 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_principal(struct krb5_principal *princ,</span>
 				       unsigned int *_toklen)
 {
 	const __be32 *xdr = *_xdr;
<span class="p_del">-	unsigned int toklen = *_toklen, n_parts, loop, tmp;</span>
<span class="p_add">+	unsigned int toklen = *_toklen, n_parts, loop, tmp, paddedlen;</span>
 
 	/* there must be at least one name, and at least #names+1 length
 	 * words */
<span class="p_chunk">@@ -247,16 +247,16 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_principal(struct krb5_principal *princ,</span>
 		toklen -= 4;
 		if (tmp &lt;= 0 || tmp &gt; AFSTOKEN_STRING_MAX)
 			return -EINVAL;
<span class="p_del">-		if (tmp &gt; toklen)</span>
<span class="p_add">+		paddedlen = (tmp + 3) &amp; ~3;</span>
<span class="p_add">+		if (paddedlen &gt; toklen)</span>
 			return -EINVAL;
 		princ-&gt;name_parts[loop] = kmalloc(tmp + 1, GFP_KERNEL);
 		if (!princ-&gt;name_parts[loop])
 			return -ENOMEM;
 		memcpy(princ-&gt;name_parts[loop], xdr, tmp);
 		princ-&gt;name_parts[loop][tmp] = 0;
<span class="p_del">-		tmp = (tmp + 3) &amp; ~3;</span>
<span class="p_del">-		toklen -= tmp;</span>
<span class="p_del">-		xdr += tmp &gt;&gt; 2;</span>
<span class="p_add">+		toklen -= paddedlen;</span>
<span class="p_add">+		xdr += paddedlen &gt;&gt; 2;</span>
 	}
 
 	if (toklen &lt; 4)
<span class="p_chunk">@@ -265,16 +265,16 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_principal(struct krb5_principal *princ,</span>
 	toklen -= 4;
 	if (tmp &lt;= 0 || tmp &gt; AFSTOKEN_K5_REALM_MAX)
 		return -EINVAL;
<span class="p_del">-	if (tmp &gt; toklen)</span>
<span class="p_add">+	paddedlen = (tmp + 3) &amp; ~3;</span>
<span class="p_add">+	if (paddedlen &gt; toklen)</span>
 		return -EINVAL;
 	princ-&gt;realm = kmalloc(tmp + 1, GFP_KERNEL);
 	if (!princ-&gt;realm)
 		return -ENOMEM;
 	memcpy(princ-&gt;realm, xdr, tmp);
 	princ-&gt;realm[tmp] = 0;
<span class="p_del">-	tmp = (tmp + 3) &amp; ~3;</span>
<span class="p_del">-	toklen -= tmp;</span>
<span class="p_del">-	xdr += tmp &gt;&gt; 2;</span>
<span class="p_add">+	toklen -= paddedlen;</span>
<span class="p_add">+	xdr += paddedlen &gt;&gt; 2;</span>
 
 	_debug(&quot;%s/...@%s&quot;, princ-&gt;name_parts[0], princ-&gt;realm);
 
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_tagged_data(struct krb5_tagged_data *td,</span>
 					 unsigned int *_toklen)
 {
 	const __be32 *xdr = *_xdr;
<span class="p_del">-	unsigned int toklen = *_toklen, len;</span>
<span class="p_add">+	unsigned int toklen = *_toklen, len, paddedlen;</span>
 
 	/* there must be at least one tag and one length word */
 	if (toklen &lt;= 8)
<span class="p_chunk">@@ -307,15 +307,17 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_tagged_data(struct krb5_tagged_data *td,</span>
 	toklen -= 8;
 	if (len &gt; max_data_size)
 		return -EINVAL;
<span class="p_add">+	paddedlen = (len + 3) &amp; ~3;</span>
<span class="p_add">+	if (paddedlen &gt; toklen)</span>
<span class="p_add">+		return -EINVAL;</span>
 	td-&gt;data_len = len;
 
 	if (len &gt; 0) {
 		td-&gt;data = kmemdup(xdr, len, GFP_KERNEL);
 		if (!td-&gt;data)
 			return -ENOMEM;
<span class="p_del">-		len = (len + 3) &amp; ~3;</span>
<span class="p_del">-		toklen -= len;</span>
<span class="p_del">-		xdr += len &gt;&gt; 2;</span>
<span class="p_add">+		toklen -= paddedlen;</span>
<span class="p_add">+		xdr += paddedlen &gt;&gt; 2;</span>
 	}
 
 	_debug(&quot;tag %x len %x&quot;, td-&gt;tag, td-&gt;data_len);
<span class="p_chunk">@@ -387,7 +389,7 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,</span>
 				    const __be32 **_xdr, unsigned int *_toklen)
 {
 	const __be32 *xdr = *_xdr;
<span class="p_del">-	unsigned int toklen = *_toklen, len;</span>
<span class="p_add">+	unsigned int toklen = *_toklen, len, paddedlen;</span>
 
 	/* there must be at least one length word */
 	if (toklen &lt;= 4)
<span class="p_chunk">@@ -399,6 +401,9 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,</span>
 	toklen -= 4;
 	if (len &gt; AFSTOKEN_K5_TIX_MAX)
 		return -EINVAL;
<span class="p_add">+	paddedlen = (len + 3) &amp; ~3;</span>
<span class="p_add">+	if (paddedlen &gt; toklen)</span>
<span class="p_add">+		return -EINVAL;</span>
 	*_tktlen = len;
 
 	_debug(&quot;ticket len %u&quot;, len);
<span class="p_chunk">@@ -407,9 +412,8 @@</span> <span class="p_context"> static int rxrpc_krb5_decode_ticket(u8 **_ticket, u16 *_tktlen,</span>
 		*_ticket = kmemdup(xdr, len, GFP_KERNEL);
 		if (!*_ticket)
 			return -ENOMEM;
<span class="p_del">-		len = (len + 3) &amp; ~3;</span>
<span class="p_del">-		toklen -= len;</span>
<span class="p_del">-		xdr += len &gt;&gt; 2;</span>
<span class="p_add">+		toklen -= paddedlen;</span>
<span class="p_add">+		xdr += paddedlen &gt;&gt; 2;</span>
 	}
 
 	*_xdr = xdr;
<span class="p_chunk">@@ -552,7 +556,7 @@</span> <span class="p_context"> static int rxrpc_preparse_xdr(struct key_preparsed_payload *prep)</span>
 {
 	const __be32 *xdr = prep-&gt;data, *token;
 	const char *cp;
<span class="p_del">-	unsigned int len, tmp, loop, ntoken, toklen, sec_ix;</span>
<span class="p_add">+	unsigned int len, paddedlen, loop, ntoken, toklen, sec_ix;</span>
 	size_t datalen = prep-&gt;datalen;
 	int ret;
 
<span class="p_chunk">@@ -578,22 +582,21 @@</span> <span class="p_context"> static int rxrpc_preparse_xdr(struct key_preparsed_payload *prep)</span>
 	if (len &lt; 1 || len &gt; AFSTOKEN_CELL_MAX)
 		goto not_xdr;
 	datalen -= 4;
<span class="p_del">-	tmp = (len + 3) &amp; ~3;</span>
<span class="p_del">-	if (tmp &gt; datalen)</span>
<span class="p_add">+	paddedlen = (len + 3) &amp; ~3;</span>
<span class="p_add">+	if (paddedlen &gt; datalen)</span>
 		goto not_xdr;
 
 	cp = (const char *) xdr;
 	for (loop = 0; loop &lt; len; loop++)
 		if (!isprint(cp[loop]))
 			goto not_xdr;
<span class="p_del">-	if (len &lt; tmp)</span>
<span class="p_del">-		for (; loop &lt; tmp; loop++)</span>
<span class="p_del">-			if (cp[loop])</span>
<span class="p_del">-				goto not_xdr;</span>
<span class="p_add">+	for (; loop &lt; paddedlen; loop++)</span>
<span class="p_add">+		if (cp[loop])</span>
<span class="p_add">+			goto not_xdr;</span>
 	_debug(&quot;cellname: [%u/%u] &#39;%*.*s&#39;&quot;,
<span class="p_del">-	       len, tmp, len, len, (const char *) xdr);</span>
<span class="p_del">-	datalen -= tmp;</span>
<span class="p_del">-	xdr += tmp &gt;&gt; 2;</span>
<span class="p_add">+	       len, paddedlen, len, len, (const char *) xdr);</span>
<span class="p_add">+	datalen -= paddedlen;</span>
<span class="p_add">+	xdr += paddedlen &gt;&gt; 2;</span>
 
 	/* get the token count */
 	if (datalen &lt; 12)
<span class="p_chunk">@@ -614,10 +617,11 @@</span> <span class="p_context"> static int rxrpc_preparse_xdr(struct key_preparsed_payload *prep)</span>
 		sec_ix = ntohl(*xdr);
 		datalen -= 4;
 		_debug(&quot;token: [%x/%zx] %x&quot;, toklen, datalen, sec_ix);
<span class="p_del">-		if (toklen &lt; 20 || toklen &gt; datalen)</span>
<span class="p_add">+		paddedlen = (toklen + 3) &amp; ~3;</span>
<span class="p_add">+		if (toklen &lt; 20 || toklen &gt; datalen || paddedlen &gt; datalen)</span>
 			goto not_xdr;
<span class="p_del">-		datalen -= (toklen + 3) &amp; ~3;</span>
<span class="p_del">-		xdr += (toklen + 3) &gt;&gt; 2;</span>
<span class="p_add">+		datalen -= paddedlen;</span>
<span class="p_add">+		xdr += paddedlen &gt;&gt; 2;</span>
 
 	} while (--loop &gt; 0);
 
<span class="p_header">diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c</span>
<span class="p_header">index 5088d4b8db22..009e6c98754e 100644</span>
<span class="p_header">--- a/sound/core/pcm_lib.c</span>
<span class="p_header">+++ b/sound/core/pcm_lib.c</span>
<span class="p_chunk">@@ -2492,7 +2492,7 @@</span> <span class="p_context"> static int pcm_chmap_ctl_get(struct snd_kcontrol *kcontrol,</span>
 	struct snd_pcm_substream *substream;
 	const struct snd_pcm_chmap_elem *map;
 
<span class="p_del">-	if (snd_BUG_ON(!info-&gt;chmap))</span>
<span class="p_add">+	if (!info-&gt;chmap)</span>
 		return -EINVAL;
 	substream = snd_pcm_chmap_substream(info, idx);
 	if (!substream)
<span class="p_chunk">@@ -2524,7 +2524,7 @@</span> <span class="p_context"> static int pcm_chmap_ctl_tlv(struct snd_kcontrol *kcontrol, int op_flag,</span>
 	unsigned int __user *dst;
 	int c, count = 0;
 
<span class="p_del">-	if (snd_BUG_ON(!info-&gt;chmap))</span>
<span class="p_add">+	if (!info-&gt;chmap)</span>
 		return -EINVAL;
 	if (size &lt; 8)
 		return -ENOMEM;
<span class="p_header">diff --git a/sound/firewire/amdtp-stream.c b/sound/firewire/amdtp-stream.c</span>
<span class="p_header">index 00060c4a9deb..9741757436be 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp-stream.c</span>
<span class="p_header">+++ b/sound/firewire/amdtp-stream.c</span>
<span class="p_chunk">@@ -606,7 +606,9 @@</span> <span class="p_context"> static void out_stream_callback(struct fw_iso_context *context, u32 tstamp,</span>
 		cycle = increment_cycle_count(cycle, 1);
 		if (handle_out_packet(s, cycle, i) &lt; 0) {
 			s-&gt;packet_index = -1;
<span class="p_del">-			amdtp_stream_pcm_abort(s);</span>
<span class="p_add">+			if (in_interrupt())</span>
<span class="p_add">+				amdtp_stream_pcm_abort(s);</span>
<span class="p_add">+			WRITE_ONCE(s-&gt;pcm_buffer_pointer, SNDRV_PCM_POS_XRUN);</span>
 			return;
 		}
 	}
<span class="p_chunk">@@ -658,7 +660,9 @@</span> <span class="p_context"> static void in_stream_callback(struct fw_iso_context *context, u32 tstamp,</span>
 	/* Queueing error or detecting invalid payload. */
 	if (i &lt; packets) {
 		s-&gt;packet_index = -1;
<span class="p_del">-		amdtp_stream_pcm_abort(s);</span>
<span class="p_add">+		if (in_interrupt())</span>
<span class="p_add">+			amdtp_stream_pcm_abort(s);</span>
<span class="p_add">+		WRITE_ONCE(s-&gt;pcm_buffer_pointer, SNDRV_PCM_POS_XRUN);</span>
 		return;
 	}
 
<span class="p_header">diff --git a/sound/firewire/amdtp-stream.h b/sound/firewire/amdtp-stream.h</span>
<span class="p_header">index c1bc7fad056e..f7c054bc9d92 100644</span>
<span class="p_header">--- a/sound/firewire/amdtp-stream.h</span>
<span class="p_header">+++ b/sound/firewire/amdtp-stream.h</span>
<span class="p_chunk">@@ -124,7 +124,7 @@</span> <span class="p_context"> struct amdtp_stream {</span>
 	/* For a PCM substream processing. */
 	struct snd_pcm_substream *pcm;
 	struct tasklet_struct period_tasklet;
<span class="p_del">-	unsigned int pcm_buffer_pointer;</span>
<span class="p_add">+	snd_pcm_uframes_t pcm_buffer_pointer;</span>
 	unsigned int pcm_period_pointer;
 
 	/* To wait for first packet. */
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 23d685636a67..69097cc96660 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -369,10 +369,12 @@</span> <span class="p_context"> enum {</span>
 #define IS_KBL_LP(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x9d71)
 #define IS_KBL_H(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa2f0)
 #define IS_BXT(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x5a98)
<span class="p_add">+#define IS_BXT_T(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x1a98)</span>
 #define IS_GLK(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x3198)
<span class="p_del">-#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci)) || \</span>
<span class="p_del">-			IS_KBL(pci) || IS_KBL_LP(pci) || IS_KBL_H(pci)	|| \</span>
<span class="p_del">-			IS_GLK(pci)</span>
<span class="p_add">+#define IS_CFL(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa348)</span>
<span class="p_add">+#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci) || \</span>
<span class="p_add">+			  IS_BXT_T(pci) || IS_KBL(pci) || IS_KBL_LP(pci) || \</span>
<span class="p_add">+			  IS_KBL_H(pci)	|| IS_GLK(pci) || IS_CFL(pci))</span>
 
 static char *driver_short_names[] = {
 	[AZX_DRIVER_ICH] = &quot;HDA Intel&quot;,
<span class="p_chunk">@@ -2251,6 +2253,9 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* Kabylake-H */
 	{ PCI_DEVICE(0x8086, 0xa2f0),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE },
<span class="p_add">+	/* Coffelake */</span>
<span class="p_add">+	{ PCI_DEVICE(0x8086, 0xa348),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE},</span>
 	/* Broxton-P(Apollolake) */
 	{ PCI_DEVICE(0x8086, 0x5a98),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BROXTON },
<span class="p_header">diff --git a/tools/perf/util/probe-event.c b/tools/perf/util/probe-event.c</span>
<span class="p_header">index 28fb62c32678..e0f9e6a20556 100644</span>
<span class="p_header">--- a/tools/perf/util/probe-event.c</span>
<span class="p_header">+++ b/tools/perf/util/probe-event.c</span>
<span class="p_chunk">@@ -615,7 +615,7 @@</span> <span class="p_context"> static int post_process_probe_trace_point(struct probe_trace_point *tp,</span>
 					   struct map *map, unsigned long offs)
 {
 	struct symbol *sym;
<span class="p_del">-	u64 addr = tp-&gt;address + tp-&gt;offset - offs;</span>
<span class="p_add">+	u64 addr = tp-&gt;address - offs;</span>
 
 	sym = map__find_symbol(map, addr);
 	if (!sym)

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



