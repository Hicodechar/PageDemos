
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v7,08/37] nds32: Exception handling - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v7,08/37] nds32: Exception handling</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=171217">Greentime Hu</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 13, 2018, 9:09 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;5d7538f6cad0763594f968d58625c7c7a99f3225.1518505384.git.greentime@andestech.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10215747/mbox/"
   >mbox</a>
|
   <a href="/patch/10215747/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10215747/">/patch/10215747/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9FACD60467 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 13 Feb 2018 10:06:17 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 79D8528A24
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 13 Feb 2018 10:06:17 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6E4E428E59; Tue, 13 Feb 2018 10:06:17 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU, FREEMAIL_FROM,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3692628A24
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 13 Feb 2018 10:06:15 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S934212AbeBMKGK (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 13 Feb 2018 05:06:10 -0500
Received: from mail-pl0-f67.google.com ([209.85.160.67]:41194 &quot;EHLO
	mail-pl0-f67.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S933995AbeBMJLT (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 13 Feb 2018 04:11:19 -0500
Received: by mail-pl0-f67.google.com with SMTP id k8so6350886pli.8;
	Tue, 13 Feb 2018 01:11:19 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=from:to:cc:subject:date:message-id:in-reply-to:references
	:in-reply-to:references;
	bh=Y9KwbKND7ndWpvMalupwbVELTJJl+Qe8jeuStL5pMOc=;
	b=X6q9wQU6Hx2q0w6CoK8mRej15HGqRPtvDK69V2nSpyaGoq5e0df0ayjhoTbDvnACkN
	pODw7VyGL+fT0Q+o+iPsgYWSdRthQ7jP0BalcCqT8Vbe6X+2+X25F+k4fYwIPMPbhXmx
	aMjcNBGAveoGQFBEe5n7sNydff3FOD5d2fOZ5hlNRzCEBKYLMnQx1dPzF0mv2LFxAneD
	+Z01/1CidaPEJeGHAA4tYHqsUCV/eOfumf+bJ8XtJYiNmtB2mTXk0RYiL4Qvf51Fb1D8
	nziEJygFiLHIAqXxwYmR8cqXX5POEMpmgpRGaF2KbSVBsYzSVpqvt2SpqOdvsq8vw6Wb
	GFbw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references:in-reply-to:references;
	bh=Y9KwbKND7ndWpvMalupwbVELTJJl+Qe8jeuStL5pMOc=;
	b=IuQm7dnpMOhdaVdtr8Wv5Vu6N9qhimkrhGmh3fz4htseu4bE6Lmf7olOT6t3ARoBbe
	m1uHSvXopmvJaQIcZansVzHw7qbM2ZPjCHGPOkw0coVUm0d9pXFOfkDIwRYz/M1ZYYYj
	fwkgP4lmqrfTggehYXvK1sAb77A7uPySPJsKCrx5Ebu0AC62W0idhHn8IIza40/gYoBu
	uiDibDpFnEzQae4TpnXTXt0Fw6Ts0JnFysmAmobzS1dGS174JY+s7eo7XNAwmLo/sn26
	4p1JaA+/4vbCCFF08mL6uNsAJr6bwyy8C/qfi2t1W4N//GlwfxdeKdI3T1ejxM0BfBUg
	pl3g==
X-Gm-Message-State: APf1xPCR7YoXGR2jiqxQEmYOqpGcfjicqcoNZ+e9gEleNIRnf7vcnRoJ
	M4HurrQKlghpEb9jAjYAWjY=
X-Google-Smtp-Source: AH8x225OQ/0VH5Lh0g7krpKYMOTd74jSv1IVIVF5MZbCSEYakmJB1bpmD/jqHKnauOsR3h+D4DsGPA==
X-Received: by 2002:a17:902:6b83:: with SMTP id
	p3-v6mr513396plk.18.1518513078303; 
	Tue, 13 Feb 2018 01:11:18 -0800 (PST)
Received: from app09.andestech.com ([118.163.51.199])
	by smtp.gmail.com with ESMTPSA id
	q20sm31434692pfh.178.2018.02.13.01.11.13
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Tue, 13 Feb 2018 01:11:17 -0800 (PST)
From: Greentime Hu &lt;green.hu@gmail.com&gt;
X-Google-Original-From: Greentime Hu &lt;greentime@andestech.com&gt;
To: greentime@andestech.com, linux-kernel@vger.kernel.org,
	arnd@arndb.de, linux-arch@vger.kernel.org, tglx@linutronix.de,
	jason@lakedaemon.net, marc.zyngier@arm.com, robh+dt@kernel.org,
	netdev@vger.kernel.org, deanbo422@gmail.com,
	devicetree@vger.kernel.org, viro@zeniv.linux.org.uk,
	dhowells@redhat.com, will.deacon@arm.com,
	daniel.lezcano@linaro.org, linux-serial@vger.kernel.org,
	geert.uytterhoeven@gmail.com, linus.walleij@linaro.org,
	mark.rutland@arm.com, greg@kroah.com, ren_guo@c-sky.com,
	rdunlap@infradead.org, davem@davemloft.net, jonas@southpole.se,
	stefan.kristiansson@saunalahti.fi, shorne@gmail.com
Cc: green.hu@gmail.com, Vincent Chen &lt;vincentc@andestech.com&gt;
Subject: [PATCH v7 08/37] nds32: Exception handling
Date: Tue, 13 Feb 2018 17:09:12 +0800
Message-Id: &lt;5d7538f6cad0763594f968d58625c7c7a99f3225.1518505384.git.greentime@andestech.com&gt;
X-Mailer: git-send-email 2.16.1
In-Reply-To: &lt;cover.1518505384.git.greentime@andestech.com&gt;
References: &lt;cover.1518505384.git.greentime@andestech.com&gt;
In-Reply-To: &lt;cover.1518505384.git.greentime@andestech.com&gt;
References: &lt;cover.1518505384.git.greentime@andestech.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=171217">Greentime Hu</a> - Feb. 13, 2018, 9:09 a.m.</div>
<pre class="content">
This patch includes the exception/interrupt entries, pt_reg structure and
related accessors.

/* Unaligned accessing handling*/
Andes processors cannot load/store information which is not naturally
aligned on the bus, i.e., loading a 4 byte data whose start address must
be divisible by 4. If unaligned data accessing is happened, data
unaligned exception will be triggered and user will get SIGSEGV or
kernel oops according to the unaligned address. In order to make user be
able to load/store data from an unaligned address, software load/store
emulation is implemented in arch/nds32/mm/alignment.c to address data
unaligned exception.

Unaligned accessing handling is disabled by default because it is not a
normal case. User can enable this feature by following steps.

A. Compile time:
    1. Enable kernel config CONFIG_ALIGNMENT_TRAP
B. Run time:
    1. Enter /proc/sys/nds32/unaligned_acess folder
    2. Write 1 to file enable_mode to enable unaligned accessing
       handling. User can disable it by writing 0 to this file.
    3. Write 1 to file debug to show which unaligned address is under
       processing. User can disable it by writing 0 to this file.

However, unaligned accessing handler cannot work if this unaligned
address is not accessible such as protection violation. On this
condition, the default behaviors for addressing data unaligned exception
still happen
<span class="signed-off-by">
Signed-off-by: Vincent Chen &lt;vincentc@andestech.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Greentime Hu &lt;greentime@andestech.com&gt;</span>
---
 arch/nds32/include/asm/ptrace.h |  77 ++++++
 arch/nds32/kernel/ex-entry.S    | 157 +++++++++++
 arch/nds32/kernel/ex-exit.S     | 184 +++++++++++++
 arch/nds32/kernel/stacktrace.c  |  47 ++++
 arch/nds32/kernel/traps.c       | 442 ++++++++++++++++++++++++++++++
 arch/nds32/mm/alignment.c       | 576 ++++++++++++++++++++++++++++++++++++++++
 6 files changed, 1483 insertions(+)
 create mode 100644 arch/nds32/include/asm/ptrace.h
 create mode 100644 arch/nds32/kernel/ex-entry.S
 create mode 100644 arch/nds32/kernel/ex-exit.S
 create mode 100644 arch/nds32/kernel/stacktrace.c
 create mode 100644 arch/nds32/kernel/traps.c
 create mode 100644 arch/nds32/mm/alignment.c
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=176">Arnd Bergmann</a> - Feb. 14, 2018, 2:31 p.m.</div>
<pre class="content">
On Tue, Feb 13, 2018 at 10:09 AM, Greentime Hu &lt;green.hu@gmail.com&gt; wrote:
<span class="quote">&gt; This patch includes the exception/interrupt entries, pt_reg structure and</span>
<span class="quote">&gt; related accessors.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; /* Unaligned accessing handling*/</span>
<span class="quote">&gt; Andes processors cannot load/store information which is not naturally</span>
<span class="quote">&gt; aligned on the bus, i.e., loading a 4 byte data whose start address must</span>
<span class="quote">&gt; be divisible by 4. If unaligned data accessing is happened, data</span>
<span class="quote">&gt; unaligned exception will be triggered and user will get SIGSEGV or</span>
<span class="quote">&gt; kernel oops according to the unaligned address. In order to make user be</span>
<span class="quote">&gt; able to load/store data from an unaligned address, software load/store</span>
<span class="quote">&gt; emulation is implemented in arch/nds32/mm/alignment.c to address data</span>
<span class="quote">&gt; unaligned exception.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Unaligned accessing handling is disabled by default because it is not a</span>
<span class="quote">&gt; normal case. User can enable this feature by following steps.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; A. Compile time:</span>
<span class="quote">&gt;     1. Enable kernel config CONFIG_ALIGNMENT_TRAP</span>
<span class="quote">&gt; B. Run time:</span>
<span class="quote">&gt;     1. Enter /proc/sys/nds32/unaligned_acess folder</span>
<span class="quote">&gt;     2. Write 1 to file enable_mode to enable unaligned accessing</span>
<span class="quote">&gt;        handling. User can disable it by writing 0 to this file.</span>
<span class="quote">&gt;     3. Write 1 to file debug to show which unaligned address is under</span>
<span class="quote">&gt;        processing. User can disable it by writing 0 to this file.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; However, unaligned accessing handler cannot work if this unaligned</span>
<span class="quote">&gt; address is not accessible such as protection violation. On this</span>
<span class="quote">&gt; condition, the default behaviors for addressing data unaligned exception</span>
<span class="quote">&gt; still happen</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Vincent Chen &lt;vincentc@andestech.com&gt;</span>
<span class="quote">&gt; Signed-off-by: Greentime Hu &lt;greentime@andestech.com&gt;</span>
<span class="acked-by">
Acked-by: Arnd Bergmann &lt;arnd@arndb.de&gt;</span>
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/nds32/include/asm/ptrace.h b/arch/nds32/include/asm/ptrace.h</span>
new file mode 100644
<span class="p_header">index 000000000000..c4538839055c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -0,0 +1,77 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+// Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASM_NDS32_PTRACE_H</span>
<span class="p_add">+#define __ASM_NDS32_PTRACE_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;uapi/asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * If pt_regs.syscallno == NO_SYSCALL, then the thread is not executing</span>
<span class="p_add">+ * a syscall -- i.e., its most recent entry into the kernel from</span>
<span class="p_add">+ * userspace was not via syscall, or otherwise a tracer cancelled the</span>
<span class="p_add">+ * syscall.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This must have the value -1, for ABI compatibility with ptrace etc.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define NO_SYSCALL (-1)</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+struct pt_regs {</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct user_pt_regs user_regs;</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			long uregs[26];</span>
<span class="p_add">+			long fp;</span>
<span class="p_add">+			long gp;</span>
<span class="p_add">+			long lp;</span>
<span class="p_add">+			long sp;</span>
<span class="p_add">+			long ipc;</span>
<span class="p_add">+#if defined(CONFIG_HWZOL)</span>
<span class="p_add">+			long lb;</span>
<span class="p_add">+			long le;</span>
<span class="p_add">+			long lc;</span>
<span class="p_add">+#else</span>
<span class="p_add">+			long dummy[3];</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			long syscallno;</span>
<span class="p_add">+		};</span>
<span class="p_add">+	};</span>
<span class="p_add">+	long orig_r0;</span>
<span class="p_add">+	long ir0;</span>
<span class="p_add">+	long ipsw;</span>
<span class="p_add">+	long pipsw;</span>
<span class="p_add">+	long pipc;</span>
<span class="p_add">+	long pp0;</span>
<span class="p_add">+	long pp1;</span>
<span class="p_add">+	long fucop_ctl;</span>
<span class="p_add">+	long osp;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool in_syscall(struct pt_regs const *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return regs-&gt;syscallno != NO_SYSCALL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void forget_syscall(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	regs-&gt;syscallno = NO_SYSCALL;</span>
<span class="p_add">+}</span>
<span class="p_add">+static inline unsigned long regs_return_value(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return regs-&gt;uregs[0];</span>
<span class="p_add">+}</span>
<span class="p_add">+extern void show_regs(struct pt_regs *);</span>
<span class="p_add">+/* Avoid circular header include via sched.h */</span>
<span class="p_add">+struct task_struct;</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_has_single_step()		(1)</span>
<span class="p_add">+#define user_mode(regs)			(((regs)-&gt;ipsw &amp; PSW_mskPOM) == 0)</span>
<span class="p_add">+#define interrupts_enabled(regs)	(!!((regs)-&gt;ipsw &amp; PSW_mskGIE))</span>
<span class="p_add">+#define user_stack_pointer(regs)	((regs)-&gt;sp)</span>
<span class="p_add">+#define instruction_pointer(regs)	((regs)-&gt;ipc)</span>
<span class="p_add">+#define profile_pc(regs) 		instruction_pointer(regs)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/nds32/kernel/ex-entry.S b/arch/nds32/kernel/ex-entry.S</span>
new file mode 100644
<span class="p_header">index 000000000000..a72e83d804f5</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/ex-entry.S</span>
<span class="p_chunk">@@ -0,0 +1,157 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+// Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/memory.h&gt;</span>
<span class="p_add">+#include &lt;asm/nds32.h&gt;</span>
<span class="p_add">+#include &lt;asm/errno.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	.macro push_zol</span>
<span class="p_add">+	mfusr	$r14, $LB</span>
<span class="p_add">+	mfusr	$r15, $LE</span>
<span class="p_add">+	mfusr	$r16, $LC</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	save_user_regs</span>
<span class="p_add">+</span>
<span class="p_add">+	smw.adm $sp, [$sp], $sp, #0x1</span>
<span class="p_add">+	/* move $SP to the bottom of pt_regs */</span>
<span class="p_add">+	addi    $sp, $sp, -OSP_OFFSET</span>
<span class="p_add">+</span>
<span class="p_add">+	/* push $r0 ~ $r25 */</span>
<span class="p_add">+	smw.bim $r0, [$sp], $r25</span>
<span class="p_add">+	/* push $fp, $gp, $lp */</span>
<span class="p_add">+	smw.bim $sp, [$sp], $sp, #0xe</span>
<span class="p_add">+</span>
<span class="p_add">+	mfsr	$r12, $SP_USR</span>
<span class="p_add">+	mfsr	$r13, $IPC</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	push_zol</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	movi	$r17, -1</span>
<span class="p_add">+	move	$r18, $r0</span>
<span class="p_add">+	mfsr	$r19, $PSW</span>
<span class="p_add">+	mfsr	$r20, $IPSW</span>
<span class="p_add">+	mfsr	$r21, $P_IPSW</span>
<span class="p_add">+	mfsr	$r22, $P_IPC</span>
<span class="p_add">+	mfsr	$r23, $P_P0</span>
<span class="p_add">+	mfsr	$r24, $P_P1</span>
<span class="p_add">+	smw.bim $r12, [$sp], $r24, #0</span>
<span class="p_add">+	addi	$sp, $sp, -FUCOP_CTL_OFFSET</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Initialize kernel space $fp */</span>
<span class="p_add">+	andi    $p0, $r20, #PSW_mskPOM</span>
<span class="p_add">+	movi    $p1, #0x0</span>
<span class="p_add">+	cmovz   $fp, $p1, $p0</span>
<span class="p_add">+</span>
<span class="p_add">+	andi	$r16, $r19, #PSW_mskINTL</span>
<span class="p_add">+	slti	$r17, $r16, #4</span>
<span class="p_add">+	bnez	$r17, 1f</span>
<span class="p_add">+	addi	$r17, $r19, #-2</span>
<span class="p_add">+	mtsr	$r17, $PSW</span>
<span class="p_add">+	isb</span>
<span class="p_add">+1:</span>
<span class="p_add">+	/* If it was superuser mode, we don&#39;t need to update $r25 */</span>
<span class="p_add">+	bnez	$p0, 2f</span>
<span class="p_add">+	la	$p0, __entry_task</span>
<span class="p_add">+	lw	$r25, [$p0]</span>
<span class="p_add">+2:</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.text</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Exception Vector</span>
<span class="p_add">+ */</span>
<span class="p_add">+exception_handlers:</span>
<span class="p_add">+	.long	unhandled_exceptions	!Reset/NMI</span>
<span class="p_add">+	.long	unhandled_exceptions	!TLB fill</span>
<span class="p_add">+	.long	do_page_fault		!PTE not present</span>
<span class="p_add">+	.long	do_dispatch_tlb_misc	!TLB misc</span>
<span class="p_add">+	.long	unhandled_exceptions	!TLB VLPT</span>
<span class="p_add">+	.long	unhandled_exceptions	!Machine Error</span>
<span class="p_add">+	.long	do_debug_trap		!Debug related</span>
<span class="p_add">+	.long	do_dispatch_general	!General exception</span>
<span class="p_add">+	.long	eh_syscall		!Syscall</span>
<span class="p_add">+	.long	asm_do_IRQ		!IRQ</span>
<span class="p_add">+</span>
<span class="p_add">+common_exception_handler:</span>
<span class="p_add">+	save_user_regs</span>
<span class="p_add">+	mfsr	$p0, $ITYPE</span>
<span class="p_add">+	andi	$p0, $p0, #ITYPE_mskVECTOR</span>
<span class="p_add">+	srli	$p0, $p0, #ITYPE_offVECTOR</span>
<span class="p_add">+	andi	$p1, $p0, #NDS32_VECTOR_mskNONEXCEPTION</span>
<span class="p_add">+	bnez	$p1, 1f</span>
<span class="p_add">+	sethi	$lp, hi20(ret_from_exception)</span>
<span class="p_add">+	ori	$lp, $lp, lo12(ret_from_exception)</span>
<span class="p_add">+	sethi	$p1, hi20(exception_handlers)</span>
<span class="p_add">+	ori	$p1, $p1, lo12(exception_handlers)</span>
<span class="p_add">+	lw	$p1, [$p1+$p0&lt;&lt;2]</span>
<span class="p_add">+	move	$r0, $p0</span>
<span class="p_add">+	mfsr	$r1, $EVA</span>
<span class="p_add">+	mfsr	$r2, $ITYPE</span>
<span class="p_add">+	move	$r3, $sp</span>
<span class="p_add">+	mfsr    $r4, $OIPC</span>
<span class="p_add">+	/* enable gie if it is enabled in IPSW. */</span>
<span class="p_add">+	mfsr	$r21, $PSW</span>
<span class="p_add">+	andi	$r20, $r20, #PSW_mskGIE	/* r20 is $IPSW*/</span>
<span class="p_add">+	or	$r21, $r21, $r20</span>
<span class="p_add">+	mtsr	$r21, $PSW</span>
<span class="p_add">+	dsb</span>
<span class="p_add">+	jr	$p1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* syscall */</span>
<span class="p_add">+1:</span>
<span class="p_add">+	addi	$p1, $p0, #-NDS32_VECTOR_offEXCEPTION</span>
<span class="p_add">+	bnez	$p1, 2f</span>
<span class="p_add">+	sethi	$lp, hi20(ret_from_exception)</span>
<span class="p_add">+	ori	$lp, $lp, lo12(ret_from_exception)</span>
<span class="p_add">+	sethi	$p1, hi20(exception_handlers)</span>
<span class="p_add">+	ori	$p1, $p1, lo12(exception_handlers)</span>
<span class="p_add">+	lwi	$p1, [$p1+#NDS32_VECTOR_offEXCEPTION&lt;&lt;2]</span>
<span class="p_add">+	jr	$p1</span>
<span class="p_add">+</span>
<span class="p_add">+	/* interrupt */</span>
<span class="p_add">+2:</span>
<span class="p_add">+#ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="p_add">+	jal     arch_trace_hardirqs_off</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	move	$r0, $sp</span>
<span class="p_add">+	sethi	$lp, hi20(ret_from_intr)</span>
<span class="p_add">+	ori	$lp, $lp, lo12(ret_from_intr)</span>
<span class="p_add">+	sethi	$p0, hi20(exception_handlers)</span>
<span class="p_add">+	ori	$p0, $p0, lo12(exception_handlers)</span>
<span class="p_add">+	lwi	$p0, [$p0+#NDS32_VECTOR_offINTERRUPT&lt;&lt;2]</span>
<span class="p_add">+	jr	$p0</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	EXCEPTION_VECTOR_DEBUG</span>
<span class="p_add">+	.align 4</span>
<span class="p_add">+	mfsr     $p0, $EDM_CTL</span>
<span class="p_add">+	andi     $p0, $p0, EDM_CTL_mskV3_EDM_MODE</span>
<span class="p_add">+	tnez     $p0, SWID_RAISE_INTERRUPT_LEVEL</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	EXCEPTION_VECTOR</span>
<span class="p_add">+	.align 4</span>
<span class="p_add">+	sethi	 $p0, hi20(common_exception_handler)</span>
<span class="p_add">+	ori	 $p0, $p0, lo12(common_exception_handler)</span>
<span class="p_add">+	jral.ton $p0, $p0</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.section	&quot;.text.init&quot;, #alloc, #execinstr</span>
<span class="p_add">+	.global	exception_vector</span>
<span class="p_add">+exception_vector:</span>
<span class="p_add">+.rept 6</span>
<span class="p_add">+	EXCEPTION_VECTOR</span>
<span class="p_add">+.endr</span>
<span class="p_add">+	EXCEPTION_VECTOR_DEBUG</span>
<span class="p_add">+.rept 121</span>
<span class="p_add">+	EXCEPTION_VECTOR</span>
<span class="p_add">+.endr</span>
<span class="p_add">+	.align 4</span>
<span class="p_add">+	.global	exception_vector_end</span>
<span class="p_add">+exception_vector_end:</span>
<span class="p_header">diff --git a/arch/nds32/kernel/ex-exit.S b/arch/nds32/kernel/ex-exit.S</span>
new file mode 100644
<span class="p_header">index 000000000000..03e4f7788a18</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/ex-exit.S</span>
<span class="p_chunk">@@ -0,0 +1,184 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+// Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+#include &lt;asm/assembler.h&gt;</span>
<span class="p_add">+#include &lt;asm/nds32.h&gt;</span>
<span class="p_add">+#include &lt;asm/asm-offsets.h&gt;</span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/current.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	.macro pop_zol</span>
<span class="p_add">+	mtusr	$r14, $LB</span>
<span class="p_add">+	mtusr	$r15, $LE</span>
<span class="p_add">+	mtusr	$r16, $LC</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	restore_user_regs_first</span>
<span class="p_add">+	setgie.d</span>
<span class="p_add">+	isb</span>
<span class="p_add">+</span>
<span class="p_add">+	addi	$sp, $sp, FUCOP_CTL_OFFSET</span>
<span class="p_add">+</span>
<span class="p_add">+	lmw.adm $r12, [$sp], $r24, #0x0</span>
<span class="p_add">+	mtsr	$r12, $SP_USR</span>
<span class="p_add">+	mtsr	$r13, $IPC</span>
<span class="p_add">+#ifdef CONFIG_HWZOL</span>
<span class="p_add">+	pop_zol</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	mtsr	$r19, $PSW</span>
<span class="p_add">+	mtsr	$r20, $IPSW</span>
<span class="p_add">+	mtsr    $r21, $P_IPSW</span>
<span class="p_add">+	mtsr	$r22, $P_IPC</span>
<span class="p_add">+	mtsr	$r23, $P_P0</span>
<span class="p_add">+	mtsr	$r24, $P_P1</span>
<span class="p_add">+	lmw.adm $sp, [$sp], $sp, #0xe</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	restore_user_regs_last</span>
<span class="p_add">+	pop	$p0</span>
<span class="p_add">+	cmovn	$sp, $p0, $p0</span>
<span class="p_add">+</span>
<span class="p_add">+	iret</span>
<span class="p_add">+	nop</span>
<span class="p_add">+</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	restore_user_regs</span>
<span class="p_add">+	restore_user_regs_first</span>
<span class="p_add">+	lmw.adm $r0, [$sp], $r25, #0x0</span>
<span class="p_add">+	addi	$sp, $sp, OSP_OFFSET</span>
<span class="p_add">+	restore_user_regs_last</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+	.macro	fast_restore_user_regs</span>
<span class="p_add">+	restore_user_regs_first</span>
<span class="p_add">+	lmw.adm $r1, [$sp], $r25, #0x0</span>
<span class="p_add">+	addi	$sp, $sp, OSP_OFFSET-4</span>
<span class="p_add">+	restore_user_regs_last</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PREEMPT</span>
<span class="p_add">+	.macro	preempt_stop</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#else</span>
<span class="p_add">+	.macro	preempt_stop</span>
<span class="p_add">+	setgie.d</span>
<span class="p_add">+	isb</span>
<span class="p_add">+	.endm</span>
<span class="p_add">+#define	resume_kernel	no_work_pending</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+ENTRY(ret_from_exception)</span>
<span class="p_add">+	preempt_stop</span>
<span class="p_add">+ENTRY(ret_from_intr)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * judge Kernel or user mode</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
<span class="p_add">+	lwi	$p0, [$sp+(#IPSW_OFFSET)]	! Check if in nested interrupt</span>
<span class="p_add">+	andi	$p0, $p0, #PSW_mskINTL</span>
<span class="p_add">+	bnez	$p0, resume_kernel		! done with iret</span>
<span class="p_add">+	j	resume_userspace</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is the fast syscall return path.  We do as little as</span>
<span class="p_add">+ * possible here, and this includes saving $r0 back into the SVC</span>
<span class="p_add">+ * stack.</span>
<span class="p_add">+ * fixed: tsk - $r25, syscall # - $r7, syscall table pointer - $r8</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(ret_fast_syscall)</span>
<span class="p_add">+	gie_disable</span>
<span class="p_add">+	lwi	$r1, [tsk+#TSK_TI_FLAGS]</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_WORK_MASK</span>
<span class="p_add">+	bnez	$p1, fast_work_pending</span>
<span class="p_add">+	fast_restore_user_regs			! iret</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Ok, we need to do extra processing,</span>
<span class="p_add">+ * enter the slow path returning from syscall, while pending work.</span>
<span class="p_add">+ */</span>
<span class="p_add">+fast_work_pending:</span>
<span class="p_add">+	swi	$r0, [$sp+(#R0_OFFSET)]		! what is different from ret_from_exception</span>
<span class="p_add">+work_pending:</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_NEED_RESCHED</span>
<span class="p_add">+	bnez	$p1, work_resched</span>
<span class="p_add">+</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_SIGPENDING|#_TIF_NOTIFY_RESUME</span>
<span class="p_add">+	beqz	$p1, no_work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	move	$r0, $sp			! &#39;regs&#39;</span>
<span class="p_add">+	gie_enable</span>
<span class="p_add">+	bal	do_notify_resume</span>
<span class="p_add">+	b       ret_slow_syscall</span>
<span class="p_add">+work_resched:</span>
<span class="p_add">+	bal	schedule			! path, return to user mode</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * &quot;slow&quot; syscall return path.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(resume_userspace)</span>
<span class="p_add">+ENTRY(ret_slow_syscall)</span>
<span class="p_add">+	gie_disable</span>
<span class="p_add">+	lwi	$p0, [$sp+(#IPSW_OFFSET)]	! Check if in nested interrupt</span>
<span class="p_add">+	andi	$p0, $p0, #PSW_mskINTL</span>
<span class="p_add">+	bnez	$p0, no_work_pending		! done with iret</span>
<span class="p_add">+	lwi	$r1, [tsk+#TSK_TI_FLAGS]</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_WORK_MASK</span>
<span class="p_add">+	bnez	$p1, work_pending		! handle work_resched, sig_pend</span>
<span class="p_add">+</span>
<span class="p_add">+no_work_pending:</span>
<span class="p_add">+#ifdef CONFIG_TRACE_IRQFLAGS</span>
<span class="p_add">+	lwi	$p0, [$sp+(#IPSW_OFFSET)]</span>
<span class="p_add">+	andi	$p0, $p0, #0x1</span>
<span class="p_add">+	la	$r10, trace_hardirqs_off</span>
<span class="p_add">+	la	$r9, trace_hardirqs_on</span>
<span class="p_add">+	cmovz	$r9, $p0, $r10</span>
<span class="p_add">+	jral	$r9</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	restore_user_regs			! return from iret</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * preemptive kernel</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifdef CONFIG_PREEMPT</span>
<span class="p_add">+resume_kernel:</span>
<span class="p_add">+	gie_disable</span>
<span class="p_add">+	lwi	$t0, [tsk+#TSK_TI_PREEMPT]</span>
<span class="p_add">+	bnez	$t0, no_work_pending</span>
<span class="p_add">+need_resched:</span>
<span class="p_add">+	lwi	$t0, [tsk+#TSK_TI_FLAGS]</span>
<span class="p_add">+	andi	$p1, $t0, #_TIF_NEED_RESCHED</span>
<span class="p_add">+	beqz	$p1, no_work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	lwi	$t0, [$sp+(#IPSW_OFFSET)]	! Interrupts off?</span>
<span class="p_add">+	andi	$t0, $t0, #1</span>
<span class="p_add">+	beqz	$t0, no_work_pending</span>
<span class="p_add">+</span>
<span class="p_add">+	jal	preempt_schedule_irq</span>
<span class="p_add">+	b	need_resched</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is how we return from a fork.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ENTRY(ret_from_fork)</span>
<span class="p_add">+	bal	schedule_tail</span>
<span class="p_add">+	beqz	$r6, 1f				! r6 stores fn for kernel thread</span>
<span class="p_add">+	move	$r0, $r7			! prepare kernel thread arg</span>
<span class="p_add">+	jral	$r6</span>
<span class="p_add">+1:</span>
<span class="p_add">+	lwi	$r1, [tsk+#TSK_TI_FLAGS]		! check for syscall tracing</span>
<span class="p_add">+	andi	$p1, $r1, #_TIF_WORK_SYSCALL_LEAVE	! are we tracing syscalls?</span>
<span class="p_add">+	beqz	$p1, ret_slow_syscall</span>
<span class="p_add">+	move    $r0, $sp</span>
<span class="p_add">+	bal	syscall_trace_leave</span>
<span class="p_add">+	b	ret_slow_syscall</span>
<span class="p_header">diff --git a/arch/nds32/kernel/stacktrace.c b/arch/nds32/kernel/stacktrace.c</span>
new file mode 100644
<span class="p_header">index 000000000000..bc70113c0e84</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/stacktrace.c</span>
<span class="p_chunk">@@ -0,0 +1,47 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+// Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/sched/debug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/stacktrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+void save_stack_trace(struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	save_stack_trace_tsk(current, trace);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void save_stack_trace_tsk(struct task_struct *tsk, struct stack_trace *trace)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *fpn;</span>
<span class="p_add">+	int skip = trace-&gt;skip;</span>
<span class="p_add">+	int savesched;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tsk == current) {</span>
<span class="p_add">+		__asm__ __volatile__(&quot;\tori\t%0, $fp, #0\n&quot;:&quot;=r&quot;(fpn));</span>
<span class="p_add">+		savesched = 1;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		fpn = (unsigned long *)thread_saved_fp(tsk);</span>
<span class="p_add">+		savesched = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!kstack_end(fpn) &amp;&amp; !((unsigned long)fpn &amp; 0x3)</span>
<span class="p_add">+	       &amp;&amp; (fpn &gt;= (unsigned long *)TASK_SIZE)) {</span>
<span class="p_add">+		unsigned long lpp, fpp;</span>
<span class="p_add">+</span>
<span class="p_add">+		lpp = fpn[-1];</span>
<span class="p_add">+		fpp = fpn[FP_OFFSET];</span>
<span class="p_add">+		if (!__kernel_text_address(lpp))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (savesched || !in_sched_functions(lpp)) {</span>
<span class="p_add">+			if (skip) {</span>
<span class="p_add">+				skip--;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				trace-&gt;entries[trace-&gt;nr_entries++] = lpp;</span>
<span class="p_add">+				if (trace-&gt;nr_entries &gt;= trace-&gt;max_entries)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		fpn = (unsigned long *)fpp;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/nds32/kernel/traps.c b/arch/nds32/kernel/traps.c</span>
new file mode 100644
<span class="p_header">index 000000000000..8828b4aeb72b</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/kernel/traps.c</span>
<span class="p_chunk">@@ -0,0 +1,442 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+// Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/personality.h&gt;</span>
<span class="p_add">+#include &lt;linux/kallsyms.h&gt;</span>
<span class="p_add">+#include &lt;linux/hardirq.h&gt;</span>
<span class="p_add">+#include &lt;linux/kdebug.h&gt;</span>
<span class="p_add">+#include &lt;linux/sched/task_stack.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/proc-fns.h&gt;</span>
<span class="p_add">+#include &lt;asm/unistd.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;nds32_intrinsic.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern void show_pte(struct mm_struct *mm, unsigned long addr);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Dump out the contents of some memory nicely...</span>
<span class="p_add">+ */</span>
<span class="p_add">+void dump_mem(const char *lvl, unsigned long bottom, unsigned long top)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long first;</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to switch to kernel mode so that we can use __get_user</span>
<span class="p_add">+	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_add">+	 * code first, just in case the backtrace kills us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fs = get_fs();</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;%s(0x%08lx to 0x%08lx)\n&quot;, lvl, bottom, top);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (first = bottom &amp; ~31; first &lt; top; first += 32) {</span>
<span class="p_add">+		unsigned long p;</span>
<span class="p_add">+		char str[sizeof(&quot; 12345678&quot;) * 8 + 1];</span>
<span class="p_add">+</span>
<span class="p_add">+		memset(str, &#39; &#39;, sizeof(str));</span>
<span class="p_add">+		str[sizeof(str) - 1] = &#39;\0&#39;;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (p = first, i = 0; i &lt; 8 &amp;&amp; p &lt; top; i++, p += 4) {</span>
<span class="p_add">+			if (p &gt;= bottom &amp;&amp; p &lt; top) {</span>
<span class="p_add">+				unsigned long val;</span>
<span class="p_add">+				if (__get_user(val, (unsigned long *)p) == 0)</span>
<span class="p_add">+					sprintf(str + i * 9, &quot; %08lx&quot;, val);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					sprintf(str + i * 9, &quot; ????????&quot;);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		pr_emerg(&quot;%s%04lx:%s\n&quot;, lvl, first &amp; 0xffff, str);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	set_fs(fs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL(dump_mem);</span>
<span class="p_add">+</span>
<span class="p_add">+static void dump_instr(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long addr = instruction_pointer(regs);</span>
<span class="p_add">+	mm_segment_t fs;</span>
<span class="p_add">+	char str[sizeof(&quot;00000000 &quot;) * 5 + 2 + 1], *p = str;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	return;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to switch to kernel mode so that we can use __get_user</span>
<span class="p_add">+	 * to safely read from kernel space.  Note that we now dump the</span>
<span class="p_add">+	 * code first, just in case the backtrace kills us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fs = get_fs();</span>
<span class="p_add">+	set_fs(KERNEL_DS);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;Code: &quot;);</span>
<span class="p_add">+	for (i = -4; i &lt; 1; i++) {</span>
<span class="p_add">+		unsigned int val, bad;</span>
<span class="p_add">+</span>
<span class="p_add">+		bad = __get_user(val, &amp;((u32 *) addr)[i]);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!bad) {</span>
<span class="p_add">+			p += sprintf(p, i == 0 ? &quot;(%08x) &quot; : &quot;%08x &quot;, val);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			p += sprintf(p, &quot;bad PC value&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pr_emerg(&quot;Code: %s\n&quot;, str);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_fs(fs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_FUNCTION_GRAPH_TRACER</span>
<span class="p_add">+#include &lt;linux/ftrace.h&gt;</span>
<span class="p_add">+static void</span>
<span class="p_add">+get_real_ret_addr(unsigned long *addr, struct task_struct *tsk, int *graph)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (*addr == (unsigned long)return_to_handler) {</span>
<span class="p_add">+		int index = tsk-&gt;curr_ret_stack;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (tsk-&gt;ret_stack &amp;&amp; index &gt;= *graph) {</span>
<span class="p_add">+			index -= *graph;</span>
<span class="p_add">+			*addr = tsk-&gt;ret_stack[index].ret;</span>
<span class="p_add">+			(*graph)++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+get_real_ret_addr(unsigned long *addr, struct task_struct *tsk, int *graph)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define LOOP_TIMES (100)</span>
<span class="p_add">+static void __dump(struct task_struct *tsk, unsigned long *base_reg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ret_addr;</span>
<span class="p_add">+	int cnt = LOOP_TIMES, graph = 0;</span>
<span class="p_add">+	pr_emerg(&quot;Call Trace:\n&quot;);</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_FRAME_POINTER)) {</span>
<span class="p_add">+		while (!kstack_end(base_reg)) {</span>
<span class="p_add">+			ret_addr = *base_reg++;</span>
<span class="p_add">+			if (__kernel_text_address(ret_addr)) {</span>
<span class="p_add">+				get_real_ret_addr(&amp;ret_addr, tsk, &amp;graph);</span>
<span class="p_add">+				print_ip_sym(ret_addr);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if (--cnt &lt; 0)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		while (!kstack_end((void *)base_reg) &amp;&amp;</span>
<span class="p_add">+		       !((unsigned long)base_reg &amp; 0x3) &amp;&amp;</span>
<span class="p_add">+		       ((unsigned long)base_reg &gt;= TASK_SIZE)) {</span>
<span class="p_add">+			unsigned long next_fp;</span>
<span class="p_add">+#if !defined(NDS32_ABI_2)</span>
<span class="p_add">+			ret_addr = base_reg[0];</span>
<span class="p_add">+			next_fp = base_reg[1];</span>
<span class="p_add">+#else</span>
<span class="p_add">+			ret_addr = base_reg[-1];</span>
<span class="p_add">+			next_fp = base_reg[FP_OFFSET];</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			if (__kernel_text_address(ret_addr)) {</span>
<span class="p_add">+				get_real_ret_addr(&amp;ret_addr, tsk, &amp;graph);</span>
<span class="p_add">+				print_ip_sym(ret_addr);</span>
<span class="p_add">+			}</span>
<span class="p_add">+			if (--cnt &lt; 0)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			base_reg = (unsigned long *)next_fp;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pr_emerg(&quot;\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void dump_stack(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *base_reg;</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_FRAME_POINTER))</span>
<span class="p_add">+		__asm__ __volatile__(&quot;\tori\t%0, $sp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		__asm__ __volatile__(&quot;\tori\t%0, $fp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	__dump(NULL, base_reg);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL(dump_stack);</span>
<span class="p_add">+</span>
<span class="p_add">+void show_stack(struct task_struct *tsk, unsigned long *sp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long *base_reg;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tsk)</span>
<span class="p_add">+		tsk = current;</span>
<span class="p_add">+	if (!IS_ENABLED(CONFIG_FRAME_POINTER)) {</span>
<span class="p_add">+		if (tsk != current)</span>
<span class="p_add">+			base_reg = (unsigned long *)(tsk-&gt;thread.cpu_context.sp);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			__asm__ __volatile__(&quot;\tori\t%0, $sp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (tsk != current)</span>
<span class="p_add">+			base_reg = (unsigned long *)(tsk-&gt;thread.cpu_context.fp);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			__asm__ __volatile__(&quot;\tori\t%0, $fp, #0\n&quot;:&quot;=r&quot;(base_reg));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	__dump(tsk, base_reg);</span>
<span class="p_add">+	barrier();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+DEFINE_SPINLOCK(die_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function is protected against re-entrancy.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void die(const char *str, struct pt_regs *regs, int err)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_struct *tsk = current;</span>
<span class="p_add">+	static int die_counter;</span>
<span class="p_add">+</span>
<span class="p_add">+	console_verbose();</span>
<span class="p_add">+	spin_lock_irq(&amp;die_lock);</span>
<span class="p_add">+	bust_spinlocks(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_emerg(&quot;Internal error: %s: %x [#%d]\n&quot;, str, err, ++die_counter);</span>
<span class="p_add">+	print_modules();</span>
<span class="p_add">+	pr_emerg(&quot;CPU: %i\n&quot;, smp_processor_id());</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	pr_emerg(&quot;Process %s (pid: %d, stack limit = 0x%p)\n&quot;,</span>
<span class="p_add">+		 tsk-&gt;comm, tsk-&gt;pid, task_thread_info(tsk) + 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!user_mode(regs) || in_interrupt()) {</span>
<span class="p_add">+		dump_mem(&quot;Stack: &quot;, regs-&gt;sp,</span>
<span class="p_add">+			 THREAD_SIZE + (unsigned long)task_thread_info(tsk));</span>
<span class="p_add">+		dump_instr(regs);</span>
<span class="p_add">+		dump_stack();</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	bust_spinlocks(0);</span>
<span class="p_add">+	spin_unlock_irq(&amp;die_lock);</span>
<span class="p_add">+	do_exit(SIGSEGV);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+EXPORT_SYMBOL(die);</span>
<span class="p_add">+</span>
<span class="p_add">+void die_if_kernel(const char *str, struct pt_regs *regs, int err)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (user_mode(regs))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	die(str, regs, err);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int bad_syscall(int n, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t info;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (current-&gt;personality != PER_LINUX) {</span>
<span class="p_add">+		send_sig(SIGSEGV, current, 1);</span>
<span class="p_add">+		return regs-&gt;uregs[0];</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	info.si_signo = SIGILL;</span>
<span class="p_add">+	info.si_errno = 0;</span>
<span class="p_add">+	info.si_code = ILL_ILLTRP;</span>
<span class="p_add">+	info.si_addr = (void __user *)instruction_pointer(regs) - 4;</span>
<span class="p_add">+</span>
<span class="p_add">+	force_sig_info(SIGILL, &amp;info, current);</span>
<span class="p_add">+	die_if_kernel(&quot;Oops - bad syscall&quot;, regs, n);</span>
<span class="p_add">+	return regs-&gt;uregs[0];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __pte_error(const char *file, int line, unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_emerg(&quot;%s:%d: bad pte %08lx.\n&quot;, file, line, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __pmd_error(const char *file, int line, unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_emerg(&quot;%s:%d: bad pmd %08lx.\n&quot;, file, line, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __pgd_error(const char *file, int line, unsigned long val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pr_emerg(&quot;%s:%d: bad pgd %08lx.\n&quot;, file, line, val);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+extern char *exception_vector, *exception_vector_end;</span>
<span class="p_add">+void __init trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init early_trap_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ivb = 0;</span>
<span class="p_add">+	unsigned long base = PAGE_OFFSET;</span>
<span class="p_add">+</span>
<span class="p_add">+	memcpy((unsigned long *)base, (unsigned long *)&amp;exception_vector,</span>
<span class="p_add">+	       ((unsigned long)&amp;exception_vector_end -</span>
<span class="p_add">+		(unsigned long)&amp;exception_vector));</span>
<span class="p_add">+	ivb = __nds32__mfsr(NDS32_SR_IVB);</span>
<span class="p_add">+	/* Check platform support. */</span>
<span class="p_add">+	if (((ivb &amp; IVB_mskNIVIC) &gt;&gt; IVB_offNIVIC) &lt; 2)</span>
<span class="p_add">+		panic</span>
<span class="p_add">+		    (&quot;IVIC mode is not allowed on the platform with interrupt controller\n&quot;);</span>
<span class="p_add">+	__nds32__mtsr((ivb &amp; ~IVB_mskESZ) | (IVB_valESZ16 &lt;&lt; IVB_offESZ) |</span>
<span class="p_add">+		      IVB_BASE, NDS32_SR_IVB);</span>
<span class="p_add">+	__nds32__mtsr(INT_MASK_INITAIAL_VAL, NDS32_SR_INT_MASK);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 0x800 = 128 vectors * 16byte.</span>
<span class="p_add">+	 * It should be enough to flush a page.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cpu_cache_wbinval_page(base, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void send_sigtrap(struct task_struct *tsk, struct pt_regs *regs,</span>
<span class="p_add">+		  int error_code, int si_code)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct siginfo info;</span>
<span class="p_add">+</span>
<span class="p_add">+	tsk-&gt;thread.trap_no = ENTRY_DEBUG_RELATED;</span>
<span class="p_add">+	tsk-&gt;thread.error_code = error_code;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(&amp;info, 0, sizeof(info));</span>
<span class="p_add">+	info.si_signo = SIGTRAP;</span>
<span class="p_add">+	info.si_code = si_code;</span>
<span class="p_add">+	info.si_addr = (void __user *)instruction_pointer(regs);</span>
<span class="p_add">+	force_sig_info(SIGTRAP, &amp;info, tsk);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_debug_trap(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+		   unsigned long type, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (notify_die(DIE_OOPS, &quot;Oops&quot;, regs, addr, type, SIGTRAP)</span>
<span class="p_add">+	    == NOTIFY_STOP)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (user_mode(regs)) {</span>
<span class="p_add">+		/* trap_signal */</span>
<span class="p_add">+		send_sigtrap(current, regs, 0, TRAP_BRKPT);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/* kernel_trap */</span>
<span class="p_add">+		if (!fixup_exception(regs))</span>
<span class="p_add">+			die(&quot;unexpected kernel_trap&quot;, regs, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void unhandled_interruption(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t si;</span>
<span class="p_add">+	pr_emerg(&quot;unhandled_interruption\n&quot;);</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		do_exit(SIGKILL);</span>
<span class="p_add">+	si.si_signo = SIGKILL;</span>
<span class="p_add">+	si.si_errno = 0;</span>
<span class="p_add">+	force_sig_info(SIGKILL, &amp;si, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void unhandled_exceptions(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			  unsigned long type, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t si;</span>
<span class="p_add">+	pr_emerg(&quot;Unhandled Exception: entry: %lx addr:%lx itype:%lx\n&quot;, entry,</span>
<span class="p_add">+		 addr, type);</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		do_exit(SIGKILL);</span>
<span class="p_add">+	si.si_signo = SIGKILL;</span>
<span class="p_add">+	si.si_errno = 0;</span>
<span class="p_add">+	si.si_addr = (void *)addr;</span>
<span class="p_add">+	force_sig_info(SIGKILL, &amp;si, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+extern int do_page_fault(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			 unsigned int error_code, struct pt_regs *regs);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * 2:DEF dispatch for TLB MISC exception handler</span>
<span class="p_add">+*/</span>
<span class="p_add">+</span>
<span class="p_add">+void do_dispatch_tlb_misc(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			  unsigned long type, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	type = type &amp; (ITYPE_mskINST | ITYPE_mskETYPE);</span>
<span class="p_add">+	if ((type &amp; ITYPE_mskETYPE) &lt; 5) {</span>
<span class="p_add">+		/* Permission exceptions */</span>
<span class="p_add">+		do_page_fault(entry, addr, type, regs);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		unhandled_exceptions(entry, addr, type, regs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void do_revinsn(struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	siginfo_t si;</span>
<span class="p_add">+	pr_emerg(&quot;Reserved Instruction\n&quot;);</span>
<span class="p_add">+	show_regs(regs);</span>
<span class="p_add">+	if (!user_mode(regs))</span>
<span class="p_add">+		do_exit(SIGILL);</span>
<span class="p_add">+	si.si_signo = SIGILL;</span>
<span class="p_add">+	si.si_errno = 0;</span>
<span class="p_add">+	force_sig_info(SIGILL, &amp;si, current);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_ALIGNMENT_TRAP</span>
<span class="p_add">+extern int unalign_access_mode;</span>
<span class="p_add">+extern int do_unaligned_access(unsigned long addr, struct pt_regs *regs);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+void do_dispatch_general(unsigned long entry, unsigned long addr,</span>
<span class="p_add">+			 unsigned long itype, struct pt_regs *regs,</span>
<span class="p_add">+			 unsigned long oipc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int swid = itype &gt;&gt; ITYPE_offSWID;</span>
<span class="p_add">+	unsigned long type = itype &amp; (ITYPE_mskINST | ITYPE_mskETYPE);</span>
<span class="p_add">+	if (type == ETYPE_ALIGNMENT_CHECK) {</span>
<span class="p_add">+#ifdef CONFIG_ALIGNMENT_TRAP</span>
<span class="p_add">+		/* Alignment check */</span>
<span class="p_add">+		if (user_mode(regs) &amp;&amp; unalign_access_mode) {</span>
<span class="p_add">+			int ret;</span>
<span class="p_add">+			ret = do_unaligned_access(addr, regs);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret == 0)</span>
<span class="p_add">+				return;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret == -EFAULT)</span>
<span class="p_add">+				pr_emerg</span>
<span class="p_add">+				    (&quot;Unhandled unaligned access exception\n&quot;);</span>
<span class="p_add">+		}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		do_page_fault(entry, addr, type, regs);</span>
<span class="p_add">+	} else if (type == ETYPE_RESERVED_INSTRUCTION) {</span>
<span class="p_add">+		/* Reserved instruction */</span>
<span class="p_add">+		do_revinsn(regs);</span>
<span class="p_add">+	} else if (type == ETYPE_TRAP &amp;&amp; swid == SWID_RAISE_INTERRUPT_LEVEL) {</span>
<span class="p_add">+		/* trap, used on v3 EDM target debugging workaround */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * DIPC(OIPC) is passed as parameter before</span>
<span class="p_add">+		 * interrupt is enabled, so the DIPC will not be corrupted</span>
<span class="p_add">+		 * even though interrupts are coming in</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * 1. update ipc</span>
<span class="p_add">+		 * 2. update pt_regs ipc with oipc</span>
<span class="p_add">+		 * 3. update pt_regs ipsw (clear DEX)</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		__asm__ volatile (&quot;mtsr %0, $IPC\n\t&quot;::&quot;r&quot; (oipc));</span>
<span class="p_add">+		regs-&gt;ipc = oipc;</span>
<span class="p_add">+		if (regs-&gt;pipsw &amp; PSW_mskDEX) {</span>
<span class="p_add">+			pr_emerg</span>
<span class="p_add">+			    (&quot;Nested Debug exception is possibly happened\n&quot;);</span>
<span class="p_add">+			pr_emerg(&quot;ipc:%08x pipc:%08x\n&quot;,</span>
<span class="p_add">+				 (unsigned int)regs-&gt;ipc,</span>
<span class="p_add">+				 (unsigned int)regs-&gt;pipc);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		do_debug_trap(entry, addr, itype, regs);</span>
<span class="p_add">+		regs-&gt;ipsw &amp;= ~PSW_mskDEX;</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		unhandled_exceptions(entry, addr, type, regs);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/nds32/mm/alignment.c b/arch/nds32/mm/alignment.c</span>
new file mode 100644
<span class="p_header">index 000000000000..b96a01b10ca7</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/nds32/mm/alignment.c</span>
<span class="p_chunk">@@ -0,0 +1,576 @@</span> <span class="p_context"></span>
<span class="p_add">+// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_add">+// Copyright (C) 2005-2017 Andes Technology Corporation</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/proc_fs.h&gt;</span>
<span class="p_add">+#include &lt;linux/uaccess.h&gt;</span>
<span class="p_add">+#include &lt;linux/sysctl.h&gt;</span>
<span class="p_add">+#include &lt;asm/unaligned.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define DEBUG(enable, tagged, ...)				\</span>
<span class="p_add">+	do{							\</span>
<span class="p_add">+		if (enable) {					\</span>
<span class="p_add">+			if (tagged)				\</span>
<span class="p_add">+			pr_warn(&quot;[ %30s() ] &quot;, __func__);	\</span>
<span class="p_add">+			pr_warn(__VA_ARGS__);			\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RT(inst)	(((inst) &gt;&gt; 20) &amp; 0x1FUL)</span>
<span class="p_add">+#define RA(inst)	(((inst) &gt;&gt; 15) &amp; 0x1FUL)</span>
<span class="p_add">+#define RB(inst)	(((inst) &gt;&gt; 10) &amp; 0x1FUL)</span>
<span class="p_add">+#define SV(inst)	(((inst) &gt;&gt; 8) &amp; 0x3UL)</span>
<span class="p_add">+#define IMM(inst)	(((inst) &gt;&gt; 0) &amp; 0x3FFFUL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RA3(inst)	(((inst) &gt;&gt; 3) &amp; 0x7UL)</span>
<span class="p_add">+#define RT3(inst)	(((inst) &gt;&gt; 6) &amp; 0x7UL)</span>
<span class="p_add">+#define IMM3U(inst)	(((inst) &gt;&gt; 0) &amp; 0x7UL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define RA5(inst)	(((inst) &gt;&gt; 0) &amp; 0x1FUL)</span>
<span class="p_add">+#define RT4(inst)	(((inst) &gt;&gt; 5) &amp; 0xFUL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __get8_data(val,addr,err)	\</span>
<span class="p_add">+	__asm__(					\</span>
<span class="p_add">+	&quot;1:	lbi.bi	%1, [%2], #1\n&quot;			\</span>
<span class="p_add">+	&quot;2:\n&quot;						\</span>
<span class="p_add">+	&quot;	.pushsection .text.fixup,\&quot;ax\&quot;\n&quot;	\</span>
<span class="p_add">+	&quot;	.align	2\n&quot;				\</span>
<span class="p_add">+	&quot;3:	movi	%0, #1\n&quot;			\</span>
<span class="p_add">+	&quot;	j	2b\n&quot;				\</span>
<span class="p_add">+	&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+	&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="p_add">+	&quot;	.align	3\n&quot;				\</span>
<span class="p_add">+	&quot;	.long	1b, 3b\n&quot;			\</span>
<span class="p_add">+	&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+	: &quot;=r&quot; (err), &quot;=&amp;r&quot; (val), &quot;=r&quot; (addr)		\</span>
<span class="p_add">+	: &quot;0&quot; (err), &quot;2&quot; (addr))</span>
<span class="p_add">+</span>
<span class="p_add">+#define get16_data(addr, val_ptr)				\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, v, a = addr;		\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr =  v &lt;&lt; 0;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 8;				\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+		*val_ptr = le16_to_cpu(*val_ptr);		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define get32_data(addr, val_ptr)				\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, v, a = addr;		\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr =  v &lt;&lt; 0;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 8;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 16;				\</span>
<span class="p_add">+		__get8_data(v,a,err);				\</span>
<span class="p_add">+		*val_ptr |= v &lt;&lt; 24;				\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+		*val_ptr = le32_to_cpu(*val_ptr);		\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define get_data(addr, val_ptr, len)				\</span>
<span class="p_add">+	if (len == 2)						\</span>
<span class="p_add">+		get16_data(addr, val_ptr);			\</span>
<span class="p_add">+	else							\</span>
<span class="p_add">+		get32_data(addr, val_ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+#define set16_data(addr, val)					\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, *ptr = addr ;		\</span>
<span class="p_add">+		val = le32_to_cpu(val);				\</span>
<span class="p_add">+		__asm__(					\</span>
<span class="p_add">+                &quot;1:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;2:	sbi	%2, [%1]\n&quot;			\</span>
<span class="p_add">+		&quot;3:\n&quot;						\</span>
<span class="p_add">+		&quot;	.pushsection .text.fixup,\&quot;ax\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	2\n&quot;				\</span>
<span class="p_add">+		&quot;4:	movi	%0, #1\n&quot;			\</span>
<span class="p_add">+		&quot;	j	3b\n&quot;				\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	3\n&quot;				\</span>
<span class="p_add">+		&quot;	.long	1b, 4b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	2b, 4b\n&quot;			\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		: &quot;=r&quot; (err), &quot;+r&quot; (ptr), &quot;+r&quot; (val)		\</span>
<span class="p_add">+		: &quot;0&quot; (err)					\</span>
<span class="p_add">+		);						\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define set32_data(addr, val)					\</span>
<span class="p_add">+	do {							\</span>
<span class="p_add">+		unsigned int err = 0, *ptr = addr ;		\</span>
<span class="p_add">+		val = le32_to_cpu(val);				\</span>
<span class="p_add">+		__asm__(					\</span>
<span class="p_add">+                &quot;1:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;2:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;3:	sbi.bi 	%2, [%1], #1\n&quot;			\</span>
<span class="p_add">+                &quot;	srli 	%2, %2, #8\n&quot;			\</span>
<span class="p_add">+                &quot;4:	sbi 	%2, [%1]\n&quot;			\</span>
<span class="p_add">+		&quot;5:\n&quot;						\</span>
<span class="p_add">+		&quot;	.pushsection .text.fixup,\&quot;ax\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	2\n&quot;				\</span>
<span class="p_add">+		&quot;6:	movi	%0, #1\n&quot;			\</span>
<span class="p_add">+		&quot;	j	5b\n&quot;				\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		&quot;	.pushsection __ex_table,\&quot;a\&quot;\n&quot;	\</span>
<span class="p_add">+		&quot;	.align	3\n&quot;				\</span>
<span class="p_add">+		&quot;	.long	1b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	2b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	3b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.long	4b, 6b\n&quot;			\</span>
<span class="p_add">+		&quot;	.popsection\n&quot;				\</span>
<span class="p_add">+		: &quot;=r&quot; (err), &quot;+r&quot; (ptr), &quot;+r&quot; (val)		\</span>
<span class="p_add">+		: &quot;0&quot; (err)					\</span>
<span class="p_add">+		);						\</span>
<span class="p_add">+		if (err)					\</span>
<span class="p_add">+			goto fault;				\</span>
<span class="p_add">+	} while(0)</span>
<span class="p_add">+#define set_data(addr, val, len)				\</span>
<span class="p_add">+	if (len == 2)						\</span>
<span class="p_add">+		set16_data(addr, val);				\</span>
<span class="p_add">+	else							\</span>
<span class="p_add">+		set32_data(addr, val);</span>
<span class="p_add">+#define NDS32_16BIT_INSTRUCTION	0x80000000</span>
<span class="p_add">+</span>
<span class="p_add">+extern pte_t va_present(struct mm_struct *mm, unsigned long addr);</span>
<span class="p_add">+extern pte_t va_kernel_present(unsigned long addr);</span>
<span class="p_add">+extern int va_readable(struct pt_regs *regs, unsigned long addr);</span>
<span class="p_add">+extern int va_writable(struct pt_regs *regs, unsigned long addr);</span>
<span class="p_add">+</span>
<span class="p_add">+int unalign_access_mode = 0, unalign_access_debug = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long *idx_to_addr(struct pt_regs *regs, int idx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* this should be consistent with ptrace.h */</span>
<span class="p_add">+	if (idx &gt;= 0 &amp;&amp; idx &lt;= 25)	/* R0-R25 */</span>
<span class="p_add">+		return &amp;regs-&gt;uregs[0] + idx;</span>
<span class="p_add">+	else if (idx &gt;= 28 &amp;&amp; idx &lt;= 30)	/* FP, GP, LP */</span>
<span class="p_add">+		return &amp;regs-&gt;fp + (idx - 28);</span>
<span class="p_add">+	else if (idx == 31)	/* SP */</span>
<span class="p_add">+		return &amp;regs-&gt;sp;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return NULL;	/* cause a segfault */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long get_inst(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return be32_to_cpu(get_unaligned((u32 *) addr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long sign_extend(unsigned long val, int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long ret = 0;</span>
<span class="p_add">+	unsigned char *s, *t;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = cpu_to_le32(val);</span>
<span class="p_add">+</span>
<span class="p_add">+	s = (void *)&amp;val;</span>
<span class="p_add">+	t = (void *)&amp;ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (i++ &lt; len)</span>
<span class="p_add">+		*t++ = *s++;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (((*(t - 1)) &amp; 0x80) &amp;&amp; (i &lt; 4)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		while (i++ &lt;= 4)</span>
<span class="p_add">+			*t++ = 0xff;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return le32_to_cpu(ret);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int do_16(unsigned long inst, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int imm, regular, load, len, addr_mode, idx_mode;</span>
<span class="p_add">+	unsigned long unaligned_addr, target_val, source_idx, target_idx,</span>
<span class="p_add">+	    shift = 0;</span>
<span class="p_add">+	switch ((inst &gt;&gt; 9) &amp; 0x3F) {</span>
<span class="p_add">+</span>
<span class="p_add">+	case 0x12:		/* LHI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x10:		/* LWI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x11:		/* LWI333.bi */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1A:		/* LWI450    */</span>
<span class="p_add">+		imm = 0;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 5;</span>
<span class="p_add">+		idx_mode = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x16:		/* SHI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x14:		/* SWI333    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x15:		/* SWI333.bi */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 3;</span>
<span class="p_add">+		idx_mode = 3;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1B:		/* SWI450    */</span>
<span class="p_add">+		imm = 0;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		addr_mode = 5;</span>
<span class="p_add">+		idx_mode = 4;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (addr_mode == 3) {</span>
<span class="p_add">+		unaligned_addr = *idx_to_addr(regs, RA3(inst));</span>
<span class="p_add">+		source_idx = RA3(inst);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		unaligned_addr = *idx_to_addr(regs, RA5(inst));</span>
<span class="p_add">+		source_idx = RA5(inst);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (idx_mode == 3)</span>
<span class="p_add">+		target_idx = RT3(inst);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		target_idx = RT4(inst);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (imm)</span>
<span class="p_add">+		shift = IMM3U(inst) * len;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regular)</span>
<span class="p_add">+		unaligned_addr += shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (load) {</span>
<span class="p_add">+		if (!access_ok(VERIFY_READ, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+</span>
<span class="p_add">+		get_data(unaligned_addr, &amp;target_val, len);</span>
<span class="p_add">+		*idx_to_addr(regs, target_idx) = target_val;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+		target_val = *idx_to_addr(regs, target_idx);</span>
<span class="p_add">+		set_data((void *)unaligned_addr, target_val, len);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!regular)</span>
<span class="p_add">+		*idx_to_addr(regs, source_idx) = unaligned_addr + shift;</span>
<span class="p_add">+	regs-&gt;ipc += 2;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+fault:</span>
<span class="p_add">+	return -EACCES;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int do_32(unsigned long inst, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int imm, regular, load, len, sign_ext;</span>
<span class="p_add">+	unsigned long unaligned_addr, target_val, shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	unaligned_addr = *idx_to_addr(regs, RA(inst));</span>
<span class="p_add">+</span>
<span class="p_add">+	switch ((inst &gt;&gt; 25) &lt;&lt; 1) {</span>
<span class="p_add">+</span>
<span class="p_add">+	case 0x02:		/* LHI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x0A:		/* LHI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x22:		/* LHSI      */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x2A:		/* LHSI.bi   */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 1;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x04:		/* LWI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x0C:		/* LWI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 1;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x12:		/* SHI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1A:		/* SHI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 2;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x14:		/* SWI       */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 1;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x1C:		/* SWI.bi    */</span>
<span class="p_add">+		imm = 1;</span>
<span class="p_add">+		regular = 0;</span>
<span class="p_add">+		load = 0;</span>
<span class="p_add">+		len = 4;</span>
<span class="p_add">+		sign_ext = 0;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		switch (inst &amp; 0xff) {</span>
<span class="p_add">+</span>
<span class="p_add">+		case 0x01:	/* LH        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x05:	/* LH.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x11:	/* LHS       */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x15:	/* LHS.bi    */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x02:	/* LW        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x06:	/* LW.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 1;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x09:	/* SH        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x0D:	/* SH.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 2;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x0A:	/* SW        */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 1;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 0x0E:	/* SW.bi     */</span>
<span class="p_add">+			imm = 0;</span>
<span class="p_add">+			regular = 0;</span>
<span class="p_add">+			load = 0;</span>
<span class="p_add">+			len = 4;</span>
<span class="p_add">+			sign_ext = 0;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (imm)</span>
<span class="p_add">+		shift = IMM(inst) * len;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		shift = *idx_to_addr(regs, RB(inst)) &lt;&lt; SV(inst);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (regular)</span>
<span class="p_add">+		unaligned_addr += shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (load) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!access_ok(VERIFY_READ, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+</span>
<span class="p_add">+		get_data(unaligned_addr, &amp;target_val, len);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sign_ext)</span>
<span class="p_add">+			*idx_to_addr(regs, RT(inst)) =</span>
<span class="p_add">+			    sign_extend(target_val, len);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			*idx_to_addr(regs, RT(inst)) = target_val;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!access_ok(VERIFY_WRITE, (void *)unaligned_addr, len))</span>
<span class="p_add">+			return -EACCES;</span>
<span class="p_add">+</span>
<span class="p_add">+		target_val = *idx_to_addr(regs, RT(inst));</span>
<span class="p_add">+		set_data((void *)unaligned_addr, target_val, len);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!regular)</span>
<span class="p_add">+		*idx_to_addr(regs, RA(inst)) = unaligned_addr + shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	regs-&gt;ipc += 4;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+fault:</span>
<span class="p_add">+	return -EACCES;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int do_unaligned_access(unsigned long addr, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long inst;</span>
<span class="p_add">+	int ret = -EFAULT;</span>
<span class="p_add">+	mm_segment_t seg = get_fs();</span>
<span class="p_add">+</span>
<span class="p_add">+	inst = get_inst(regs-&gt;ipc);</span>
<span class="p_add">+</span>
<span class="p_add">+	DEBUG((unalign_access_debug &gt; 0), 1,</span>
<span class="p_add">+	      &quot;Faulting addr: 0x%08lx, pc: 0x%08lx [inst: 0x%08lx ]\n&quot;, addr,</span>
<span class="p_add">+	      regs-&gt;ipc, inst);</span>
<span class="p_add">+</span>
<span class="p_add">+	set_fs(USER_DS);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (inst &amp; NDS32_16BIT_INSTRUCTION)</span>
<span class="p_add">+		ret = do_16((inst &gt;&gt; 16) &amp; 0xffff, regs);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = do_32(inst, regs);</span>
<span class="p_add">+	set_fs(seg);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_PROC_FS</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ctl_table alignment_tbl[3] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 .procname = &quot;enable&quot;,</span>
<span class="p_add">+	 .data = &amp;unalign_access_mode,</span>
<span class="p_add">+	 .maxlen = sizeof(unalign_access_mode),</span>
<span class="p_add">+	 .mode = 0666,</span>
<span class="p_add">+	 .proc_handler = &amp;proc_dointvec</span>
<span class="p_add">+	}</span>
<span class="p_add">+	,</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 .procname = &quot;debug_info&quot;,</span>
<span class="p_add">+	 .data = &amp;unalign_access_debug,</span>
<span class="p_add">+	 .maxlen = sizeof(unalign_access_debug),</span>
<span class="p_add">+	 .mode = 0644,</span>
<span class="p_add">+	 .proc_handler = &amp;proc_dointvec</span>
<span class="p_add">+	}</span>
<span class="p_add">+	,</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ctl_table nds32_sysctl_table[2] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+	 .procname = &quot;unaligned_acess&quot;,</span>
<span class="p_add">+	 .mode = 0555,</span>
<span class="p_add">+	 .child = alignment_tbl},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ctl_path nds32_path[2] = {</span>
<span class="p_add">+	{.procname = &quot;nds32&quot;},</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Initialize nds32 alignment-correction interface</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int __init nds32_sysctl_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	register_sysctl_paths(nds32_path, nds32_sysctl_table);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+__initcall(nds32_sysctl_init);</span>
<span class="p_add">+#endif /* CONFIG_PROC_FS */</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



