
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v4,15/27] fs: retrofit old error reporting API onto new infrastructure - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v4,15/27] fs: retrofit old error reporting API onto new infrastructure</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=440">Jeff Layton</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 9, 2017, 3:49 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170509154930.29524-16-jlayton@redhat.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9718203/mbox/"
   >mbox</a>
|
   <a href="/patch/9718203/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9718203/">/patch/9718203/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	4230760236 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 May 2017 15:50:50 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3C3BA1FF61
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 May 2017 15:50:50 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 2FBE6205FB; Tue,  9 May 2017 15:50:50 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 1500B1FF61
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  9 May 2017 15:50:49 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1755267AbdEIPul (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 9 May 2017 11:50:41 -0400
Received: from mx1.redhat.com ([209.132.183.28]:58948 &quot;EHLO mx1.redhat.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1755185AbdEIPue (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 9 May 2017 11:50:34 -0400
Received: from smtp.corp.redhat.com
	(int-mx05.intmail.prod.int.phx2.redhat.com [10.5.11.15])
	(using TLSv1.2 with cipher AECDH-AES256-SHA (256/256 bits))
	(No client certificate requested)
	by mx1.redhat.com (Postfix) with ESMTPS id 797858048C;
	Tue,  9 May 2017 15:50:23 +0000 (UTC)
DMARC-Filter: OpenDMARC Filter v1.3.2 mx1.redhat.com 797858048C
Authentication-Results: ext-mx04.extmail.prod.ext.phx2.redhat.com;
	dmarc=none (p=none dis=none) header.from=redhat.com
Authentication-Results: ext-mx04.extmail.prod.ext.phx2.redhat.com;
	spf=pass smtp.mailfrom=jlayton@redhat.com
DKIM-Filter: OpenDKIM Filter v2.11.0 mx1.redhat.com 797858048C
Received: from tleilax.poochiereds.net (ovpn-121-66.rdu2.redhat.com
	[10.10.121.66])
	by smtp.corp.redhat.com (Postfix) with ESMTP id 3CC5C88522;
	Tue,  9 May 2017 15:50:20 +0000 (UTC)
From: Jeff Layton &lt;jlayton@redhat.com&gt;
To: linux-fsdevel@vger.kernel.org, linux-kernel@vger.kernel.org,
	linux-btrfs@vger.kernel.org, linux-ext4@vger.kernel.org,
	linux-cifs@vger.kernel.org, linux-nfs@vger.kernel.org,
	linux-mm@kvack.org, jfs-discussion@lists.sourceforge.net,
	linux-xfs@vger.kernel.org, cluster-devel@redhat.com,
	linux-f2fs-devel@lists.sourceforge.net,
	v9fs-developer@lists.sourceforge.net, linux-nilfs@vger.kernel.org,
	linux-block@vger.kernel.org
Cc: dhowells@redhat.com, akpm@linux-foundation.org, hch@infradead.org,
	ross.zwisler@linux.intel.com, mawilcox@microsoft.com,
	jack@suse.com, viro@zeniv.linux.org.uk, corbet@lwn.net,
	neilb@suse.de, clm@fb.com, tytso@mit.edu, axboe@kernel.dk,
	josef@toxicpanda.com, hubcap@omnibond.com, rpeterso@redhat.com,
	bo.li.liu@oracle.com
Subject: [PATCH v4 15/27] fs: retrofit old error reporting API onto new
	infrastructure
Date: Tue,  9 May 2017 11:49:18 -0400
Message-Id: &lt;20170509154930.29524-16-jlayton@redhat.com&gt;
In-Reply-To: &lt;20170509154930.29524-1-jlayton@redhat.com&gt;
References: &lt;20170509154930.29524-1-jlayton@redhat.com&gt;
X-Scanned-By: MIMEDefang 2.79 on 10.5.11.15
X-Greylist: Sender IP whitelisted, not delayed by milter-greylist-4.5.16
	(mx1.redhat.com [10.5.110.28]);
	Tue, 09 May 2017 15:50:24 +0000 (UTC)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=440">Jeff Layton</a> - May 9, 2017, 3:49 p.m.</div>
<pre class="content">
Now that we have a better way to store and report errors that occur
during writeback, we need to convert the existing codebase to use it. We
could just adapt all of the filesystem code and related infrastructure
to the new API, but that&#39;s a lot of churn.

When it comes to setting errors in the mapping, filemap_set_wb_error is
a drop-in replacement for mapping_set_error. Turn that function into a
simple wrapper around the new one.

Because we want to ensure that writeback errors are always reported at
fsync time, inject filemap_report_wb_error calls much closer to the
syscall boundary, in call_fsync.

For fsync calls (and things like the nfsd equivalent), we either return
the error that the fsync operation returns, or the one returned by
filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to
the latest value. This allows us to provide new fsync semantics that
will return errors that may have occurred previously and been viewed
via other file descriptors.

The final piece of the puzzle is what to do about filemap_check_errors
calls that are being called directly or via filemap_* functions. Here,
we must take a little &quot;creative license&quot;.

Since we now handle advancing the file-&gt;f_wb_err value at the generic
filesystem layer, we no longer need those callers to clear errors out
of the mapping or advance an errseq_t.

A lot of the existing codebase relies on being getting an error back
from those functions when there is a writeback problem, so we do still
want to have them report writeback errors somehow.

When reporting writeback errors, we will always report errors that have
occurred since a particular point in time. With the old writeback error
reporting, the time we used was &quot;since it was last tested/cleared&quot; which
is entirely arbitrary and potentially racy. Now, we can at least report
the latest error that has occurred since an arbitrary point in time
(represented as a sampled errseq_t value).

In the case where we don&#39;t have a struct file to work with, this patch
just has the wrappers sample the current mapping-&gt;wb_err value, and use
that as an arbitrary point from which to check for errors.

That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of
something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than
what we already have, and this gives us a basis from which to work.

A lot of those callers will likely want to change to a model where they
sample the errseq_t much earlier (perhaps when starting a transaction),
store it in an appropriate place and then use that value later when
checking to see if an error occurred.

That will almost certainly take some involvement from other subsystem
maintainers. I&#39;m quite open to adding new API functions to help enable
this if that would be helpful, but I don&#39;t really want to do that until
I better understand what&#39;s needed.
<span class="signed-off-by">
Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>
---
 Documentation/filesystems/vfs.txt |  9 +++----
 fs/btrfs/file.c                   | 10 ++------
 fs/btrfs/tree-log.c               |  9 ++-----
 fs/f2fs/file.c                    |  3 +++
 fs/f2fs/node.c                    |  6 +----
 fs/fuse/file.c                    |  7 ++++--
 fs/libfs.c                        |  6 +++--
 include/linux/fs.h                | 19 +++++++++------
 include/linux/pagemap.h           |  8 ++----
 mm/filemap.c                      | 51 +++++++++++++++++----------------------
 10 files changed, 57 insertions(+), 71 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=305">Jan Kara</a> - May 15, 2017, 10:42 a.m.</div>
<pre class="content">
On Tue 09-05-17 11:49:18, Jeff Layton wrote:
<span class="quote">&gt; Now that we have a better way to store and report errors that occur</span>
<span class="quote">&gt; during writeback, we need to convert the existing codebase to use it. We</span>
<span class="quote">&gt; could just adapt all of the filesystem code and related infrastructure</span>
<span class="quote">&gt; to the new API, but that&#39;s a lot of churn.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When it comes to setting errors in the mapping, filemap_set_wb_error is</span>
<span class="quote">&gt; a drop-in replacement for mapping_set_error. Turn that function into a</span>
<span class="quote">&gt; simple wrapper around the new one.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Because we want to ensure that writeback errors are always reported at</span>
<span class="quote">&gt; fsync time, inject filemap_report_wb_error calls much closer to the</span>
<span class="quote">&gt; syscall boundary, in call_fsync.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; For fsync calls (and things like the nfsd equivalent), we either return</span>
<span class="quote">&gt; the error that the fsync operation returns, or the one returned by</span>
<span class="quote">&gt; filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to</span>
<span class="quote">&gt; the latest value. This allows us to provide new fsync semantics that</span>
<span class="quote">&gt; will return errors that may have occurred previously and been viewed</span>
<span class="quote">&gt; via other file descriptors.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The final piece of the puzzle is what to do about filemap_check_errors</span>
<span class="quote">&gt; calls that are being called directly or via filemap_* functions. Here,</span>
<span class="quote">&gt; we must take a little &quot;creative license&quot;.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Since we now handle advancing the file-&gt;f_wb_err value at the generic</span>
<span class="quote">&gt; filesystem layer, we no longer need those callers to clear errors out</span>
<span class="quote">&gt; of the mapping or advance an errseq_t.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A lot of the existing codebase relies on being getting an error back</span>
<span class="quote">&gt; from those functions when there is a writeback problem, so we do still</span>
<span class="quote">&gt; want to have them report writeback errors somehow.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; When reporting writeback errors, we will always report errors that have</span>
<span class="quote">&gt; occurred since a particular point in time. With the old writeback error</span>
<span class="quote">&gt; reporting, the time we used was &quot;since it was last tested/cleared&quot; which</span>
<span class="quote">&gt; is entirely arbitrary and potentially racy. Now, we can at least report</span>
<span class="quote">&gt; the latest error that has occurred since an arbitrary point in time</span>
<span class="quote">&gt; (represented as a sampled errseq_t value).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In the case where we don&#39;t have a struct file to work with, this patch</span>
<span class="quote">&gt; just has the wrappers sample the current mapping-&gt;wb_err value, and use</span>
<span class="quote">&gt; that as an arbitrary point from which to check for errors.</span>

I think this is really dangerous and we shouldn&#39;t do this. You are quite
likely to lose IO errors in such calls because you will ignore all errors
that happened during previous background writeback or even for IO that
managed to complete before we called filemap_fdatawait(). Maybe we need to
keep the original set-clear-bit IO error reporting for these cases, until
we can convert them to fdatawait_range_since()?
<span class="quote">
&gt; That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of</span>
<span class="quote">&gt; something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than</span>
<span class="quote">&gt; what we already have, and this gives us a basis from which to work.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; A lot of those callers will likely want to change to a model where they</span>
<span class="quote">&gt; sample the errseq_t much earlier (perhaps when starting a transaction),</span>
<span class="quote">&gt; store it in an appropriate place and then use that value later when</span>
<span class="quote">&gt; checking to see if an error occurred.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That will almost certainly take some involvement from other subsystem</span>
<span class="quote">&gt; maintainers. I&#39;m quite open to adding new API functions to help enable</span>
<span class="quote">&gt; this if that would be helpful, but I don&#39;t really want to do that until</span>
<span class="quote">&gt; I better understand what&#39;s needed.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>

...
<span class="quote">
&gt; diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="quote">&gt; index 5f7317875a67..7ce13281925f 100644</span>
<span class="quote">&gt; --- a/fs/f2fs/file.c</span>
<span class="quote">&gt; +++ b/fs/f2fs/file.c</span>
<span class="quote">&gt; @@ -187,6 +187,7 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt;  		.nr_to_write = LONG_MAX,</span>
<span class="quote">&gt;  		.for_reclaim = 0,</span>
<span class="quote">&gt;  	};</span>
<span class="quote">&gt; +	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))</span>
<span class="quote">&gt;  		return 0;</span>
<span class="quote">&gt; @@ -265,6 +266,8 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	ret = wait_on_node_pages_writeback(sbi, ino);</span>
<span class="quote">&gt; +	if (ret == 0)</span>
<span class="quote">&gt; +		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
<span class="quote">&gt;  	if (ret)</span>
<span class="quote">&gt;  		goto out;</span>

So this conversion looks wrong and actually points to a larger issue with
the scheme. The problem is there are two mappings that come into play here
- file_inode(file)-&gt;i_mapping which is the data mapping and
NODE_MAPPING(sbi) which is the metadata mapping (and this is not a problem
specific to f2fs. For example ext2 also uses this scheme where block
devices&#39; mapping is the metadata mapping). And we need to merge error
information from these two mappings so for the stamping scheme to work,
we&#39;d need two stamps stored in struct file. One for data mapping and one
for metadata mapping. Or maybe there&#39;s some more clever scheme but for now
I don&#39;t see one...

								Honza
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=440">Jeff Layton</a> - May 15, 2017, 5:58 p.m.</div>
<pre class="content">
On Mon, 2017-05-15 at 12:42 +0200, Jan Kara wrote:
<span class="quote">&gt; On Tue 09-05-17 11:49:18, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; Now that we have a better way to store and report errors that occur</span>
<span class="quote">&gt; &gt; during writeback, we need to convert the existing codebase to use it. We</span>
<span class="quote">&gt; &gt; could just adapt all of the filesystem code and related infrastructure</span>
<span class="quote">&gt; &gt; to the new API, but that&#39;s a lot of churn.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; When it comes to setting errors in the mapping, filemap_set_wb_error is</span>
<span class="quote">&gt; &gt; a drop-in replacement for mapping_set_error. Turn that function into a</span>
<span class="quote">&gt; &gt; simple wrapper around the new one.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Because we want to ensure that writeback errors are always reported at</span>
<span class="quote">&gt; &gt; fsync time, inject filemap_report_wb_error calls much closer to the</span>
<span class="quote">&gt; &gt; syscall boundary, in call_fsync.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; For fsync calls (and things like the nfsd equivalent), we either return</span>
<span class="quote">&gt; &gt; the error that the fsync operation returns, or the one returned by</span>
<span class="quote">&gt; &gt; filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to</span>
<span class="quote">&gt; &gt; the latest value. This allows us to provide new fsync semantics that</span>
<span class="quote">&gt; &gt; will return errors that may have occurred previously and been viewed</span>
<span class="quote">&gt; &gt; via other file descriptors.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The final piece of the puzzle is what to do about filemap_check_errors</span>
<span class="quote">&gt; &gt; calls that are being called directly or via filemap_* functions. Here,</span>
<span class="quote">&gt; &gt; we must take a little &quot;creative license&quot;.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Since we now handle advancing the file-&gt;f_wb_err value at the generic</span>
<span class="quote">&gt; &gt; filesystem layer, we no longer need those callers to clear errors out</span>
<span class="quote">&gt; &gt; of the mapping or advance an errseq_t.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; A lot of the existing codebase relies on being getting an error back</span>
<span class="quote">&gt; &gt; from those functions when there is a writeback problem, so we do still</span>
<span class="quote">&gt; &gt; want to have them report writeback errors somehow.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; When reporting writeback errors, we will always report errors that have</span>
<span class="quote">&gt; &gt; occurred since a particular point in time. With the old writeback error</span>
<span class="quote">&gt; &gt; reporting, the time we used was &quot;since it was last tested/cleared&quot; which</span>
<span class="quote">&gt; &gt; is entirely arbitrary and potentially racy. Now, we can at least report</span>
<span class="quote">&gt; &gt; the latest error that has occurred since an arbitrary point in time</span>
<span class="quote">&gt; &gt; (represented as a sampled errseq_t value).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; In the case where we don&#39;t have a struct file to work with, this patch</span>
<span class="quote">&gt; &gt; just has the wrappers sample the current mapping-&gt;wb_err value, and use</span>
<span class="quote">&gt; &gt; that as an arbitrary point from which to check for errors.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think this is really dangerous and we shouldn&#39;t do this. You are quite</span>
<span class="quote">&gt; likely to lose IO errors in such calls because you will ignore all errors</span>
<span class="quote">&gt; that happened during previous background writeback or even for IO that</span>
<span class="quote">&gt; managed to complete before we called filemap_fdatawait(). Maybe we need to</span>
<span class="quote">&gt; keep the original set-clear-bit IO error reporting for these cases, until</span>
<span class="quote">&gt; we can convert them to fdatawait_range_since()?</span>
<span class="quote">&gt; </span>

Yes that is a danger.

In fact, late last week I was finally able to make my xfstest work with
btrfs, and started hitting oopses with it because of the way the error
reporting changed. I rolled up a patch to fix that (and it simplifies
the code some, IMO), but other callers of filemap_fdatawait may have
similar problems here.

I&#39;ll pick up working on this again in a more piecemeal way. I had
originally looked at doing that, but there are some problematic places
(e.g. buffer.c), where the code is shared by a bunch of different
filesystems that makes it difficult.

We may end up needing some sort of FS_WB_ERRSEQ flag to do this
correctly, at least until the transition to errseq_t is done.
<span class="quote">
&gt; &gt; That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of</span>
<span class="quote">&gt; &gt; something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than</span>
<span class="quote">&gt; &gt; what we already have, and this gives us a basis from which to work.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; A lot of those callers will likely want to change to a model where they</span>
<span class="quote">&gt; &gt; sample the errseq_t much earlier (perhaps when starting a transaction),</span>
<span class="quote">&gt; &gt; store it in an appropriate place and then use that value later when</span>
<span class="quote">&gt; &gt; checking to see if an error occurred.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; That will almost certainly take some involvement from other subsystem</span>
<span class="quote">&gt; &gt; maintainers. I&#39;m quite open to adding new API functions to help enable</span>
<span class="quote">&gt; &gt; this if that would be helpful, but I don&#39;t really want to do that until</span>
<span class="quote">&gt; &gt; I better understand what&#39;s needed.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; index 5f7317875a67..7ce13281925f 100644</span>
<span class="quote">&gt; &gt; --- a/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; +++ b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; @@ -187,6 +187,7 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt;  		.nr_to_write = LONG_MAX,</span>
<span class="quote">&gt; &gt;  		.for_reclaim = 0,</span>
<span class="quote">&gt; &gt;  	};</span>
<span class="quote">&gt; &gt; +	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))</span>
<span class="quote">&gt; &gt;  		return 0;</span>
<span class="quote">&gt; &gt; @@ -265,6 +266,8 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	ret = wait_on_node_pages_writeback(sbi, ino);</span>
<span class="quote">&gt; &gt; +	if (ret == 0)</span>
<span class="quote">&gt; &gt; +		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
<span class="quote">&gt; &gt;  	if (ret)</span>
<span class="quote">&gt; &gt;  		goto out;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So this conversion looks wrong and actually points to a larger issue with</span>
<span class="quote">&gt; the scheme. The problem is there are two mappings that come into play here</span>
<span class="quote">&gt; - file_inode(file)-&gt;i_mapping which is the data mapping and</span>
<span class="quote">&gt; NODE_MAPPING(sbi) which is the metadata mapping (and this is not a problem</span>
<span class="quote">&gt; specific to f2fs. For example ext2 also uses this scheme where block</span>
<span class="quote">&gt; devices&#39; mapping is the metadata mapping). And we need to merge error</span>
<span class="quote">&gt; information from these two mappings so for the stamping scheme to work,</span>
<span class="quote">&gt; we&#39;d need two stamps stored in struct file. One for data mapping and one</span>
<span class="quote">&gt; for metadata mapping. Or maybe there&#39;s some more clever scheme but for now</span>
<span class="quote">&gt; I don&#39;t see one...</span>
<span class="quote">&gt; </span>

Got it -- since there are two mappings, there are two errseq_t&#39;s and
you&#39;d need a since cursor for each. I don&#39;t really like having to add a
second 32-bit word to struct file, but I also don&#39;t see a real
alternative right offhand. May be able to stash it in file-&gt;private_data 
for some of these filesystems.

In any case, I&#39;ll ponder how to do this in a more piecemeal way.

Thanks for all of the review so far!
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=440">Jeff Layton</a> - May 19, 2017, 7:20 p.m.</div>
<pre class="content">
On Mon, 2017-05-15 at 12:42 +0200, Jan Kara wrote:
<span class="quote">&gt; On Tue 09-05-17 11:49:18, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; Now that we have a better way to store and report errors that occur</span>
<span class="quote">&gt; &gt; during writeback, we need to convert the existing codebase to use it. We</span>
<span class="quote">&gt; &gt; could just adapt all of the filesystem code and related infrastructure</span>
<span class="quote">&gt; &gt; to the new API, but that&#39;s a lot of churn.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; When it comes to setting errors in the mapping, filemap_set_wb_error is</span>
<span class="quote">&gt; &gt; a drop-in replacement for mapping_set_error. Turn that function into a</span>
<span class="quote">&gt; &gt; simple wrapper around the new one.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Because we want to ensure that writeback errors are always reported at</span>
<span class="quote">&gt; &gt; fsync time, inject filemap_report_wb_error calls much closer to the</span>
<span class="quote">&gt; &gt; syscall boundary, in call_fsync.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; For fsync calls (and things like the nfsd equivalent), we either return</span>
<span class="quote">&gt; &gt; the error that the fsync operation returns, or the one returned by</span>
<span class="quote">&gt; &gt; filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to</span>
<span class="quote">&gt; &gt; the latest value. This allows us to provide new fsync semantics that</span>
<span class="quote">&gt; &gt; will return errors that may have occurred previously and been viewed</span>
<span class="quote">&gt; &gt; via other file descriptors.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The final piece of the puzzle is what to do about filemap_check_errors</span>
<span class="quote">&gt; &gt; calls that are being called directly or via filemap_* functions. Here,</span>
<span class="quote">&gt; &gt; we must take a little &quot;creative license&quot;.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Since we now handle advancing the file-&gt;f_wb_err value at the generic</span>
<span class="quote">&gt; &gt; filesystem layer, we no longer need those callers to clear errors out</span>
<span class="quote">&gt; &gt; of the mapping or advance an errseq_t.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; A lot of the existing codebase relies on being getting an error back</span>
<span class="quote">&gt; &gt; from those functions when there is a writeback problem, so we do still</span>
<span class="quote">&gt; &gt; want to have them report writeback errors somehow.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; When reporting writeback errors, we will always report errors that have</span>
<span class="quote">&gt; &gt; occurred since a particular point in time. With the old writeback error</span>
<span class="quote">&gt; &gt; reporting, the time we used was &quot;since it was last tested/cleared&quot; which</span>
<span class="quote">&gt; &gt; is entirely arbitrary and potentially racy. Now, we can at least report</span>
<span class="quote">&gt; &gt; the latest error that has occurred since an arbitrary point in time</span>
<span class="quote">&gt; &gt; (represented as a sampled errseq_t value).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; In the case where we don&#39;t have a struct file to work with, this patch</span>
<span class="quote">&gt; &gt; just has the wrappers sample the current mapping-&gt;wb_err value, and use</span>
<span class="quote">&gt; &gt; that as an arbitrary point from which to check for errors.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think this is really dangerous and we shouldn&#39;t do this. You are quite</span>
<span class="quote">&gt; likely to lose IO errors in such calls because you will ignore all errors</span>
<span class="quote">&gt; that happened during previous background writeback or even for IO that</span>
<span class="quote">&gt; managed to complete before we called filemap_fdatawait(). Maybe we need to</span>
<span class="quote">&gt; keep the original set-clear-bit IO error reporting for these cases, until</span>
<span class="quote">&gt; we can convert them to fdatawait_range_since()?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of</span>
<span class="quote">&gt; &gt; something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than</span>
<span class="quote">&gt; &gt; what we already have, and this gives us a basis from which to work.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; A lot of those callers will likely want to change to a model where they</span>
<span class="quote">&gt; &gt; sample the errseq_t much earlier (perhaps when starting a transaction),</span>
<span class="quote">&gt; &gt; store it in an appropriate place and then use that value later when</span>
<span class="quote">&gt; &gt; checking to see if an error occurred.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; That will almost certainly take some involvement from other subsystem</span>
<span class="quote">&gt; &gt; maintainers. I&#39;m quite open to adding new API functions to help enable</span>
<span class="quote">&gt; &gt; this if that would be helpful, but I don&#39;t really want to do that until</span>
<span class="quote">&gt; &gt; I better understand what&#39;s needed.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; ...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; index 5f7317875a67..7ce13281925f 100644</span>
<span class="quote">&gt; &gt; --- a/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; +++ b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; @@ -187,6 +187,7 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt;  		.nr_to_write = LONG_MAX,</span>
<span class="quote">&gt; &gt;  		.for_reclaim = 0,</span>
<span class="quote">&gt; &gt;  	};</span>
<span class="quote">&gt; &gt; +	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))</span>
<span class="quote">&gt; &gt;  		return 0;</span>
<span class="quote">&gt; &gt; @@ -265,6 +266,8 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt;  	}</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	ret = wait_on_node_pages_writeback(sbi, ino);</span>
<span class="quote">&gt; &gt; +	if (ret == 0)</span>
<span class="quote">&gt; &gt; +		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
<span class="quote">&gt; &gt;  	if (ret)</span>
<span class="quote">&gt; &gt;  		goto out;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So this conversion looks wrong and actually points to a larger issue with</span>
<span class="quote">&gt; the scheme. The problem is there are two mappings that come into play here</span>
<span class="quote">&gt; - file_inode(file)-&gt;i_mapping which is the data mapping and</span>
<span class="quote">&gt; NODE_MAPPING(sbi) which is the metadata mapping (and this is not a problem</span>
<span class="quote">&gt; specific to f2fs. For example ext2 also uses this scheme where block</span>
<span class="quote">&gt; devices&#39; mapping is the metadata mapping). And we need to merge error</span>
<span class="quote">&gt; information from these two mappings so for the stamping scheme to work,</span>
<span class="quote">&gt; we&#39;d need two stamps stored in struct file. One for data mapping and one</span>
<span class="quote">&gt; for metadata mapping. Or maybe there&#39;s some more clever scheme but for now</span>
<span class="quote">&gt; I don&#39;t see one...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 								Honza</span>

In the case of something like ext2, could we instead get away with just
marking the data mapping of the inode with an error if the metadata
writeout fails?

Then we could just have write_inode operations call mapping_set_error on
inode-&gt;i_mapping when they&#39;re going to return an error. That should be
functionally equivalent, I&#39;d think.

The catch there is that that requires a 1:1 data:metadata mapping, and
I&#39;m not sure that that is the case (or will always be, even if it is
now).
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=305">Jan Kara</a> - May 22, 2017, 1:38 p.m.</div>
<pre class="content">
On Fri 19-05-17 15:20:52, Jeff Layton wrote:
<span class="quote">&gt; On Mon, 2017-05-15 at 12:42 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; On Tue 09-05-17 11:49:18, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; &gt; Now that we have a better way to store and report errors that occur</span>
<span class="quote">&gt; &gt; &gt; during writeback, we need to convert the existing codebase to use it. We</span>
<span class="quote">&gt; &gt; &gt; could just adapt all of the filesystem code and related infrastructure</span>
<span class="quote">&gt; &gt; &gt; to the new API, but that&#39;s a lot of churn.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; When it comes to setting errors in the mapping, filemap_set_wb_error is</span>
<span class="quote">&gt; &gt; &gt; a drop-in replacement for mapping_set_error. Turn that function into a</span>
<span class="quote">&gt; &gt; &gt; simple wrapper around the new one.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Because we want to ensure that writeback errors are always reported at</span>
<span class="quote">&gt; &gt; &gt; fsync time, inject filemap_report_wb_error calls much closer to the</span>
<span class="quote">&gt; &gt; &gt; syscall boundary, in call_fsync.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; For fsync calls (and things like the nfsd equivalent), we either return</span>
<span class="quote">&gt; &gt; &gt; the error that the fsync operation returns, or the one returned by</span>
<span class="quote">&gt; &gt; &gt; filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to</span>
<span class="quote">&gt; &gt; &gt; the latest value. This allows us to provide new fsync semantics that</span>
<span class="quote">&gt; &gt; &gt; will return errors that may have occurred previously and been viewed</span>
<span class="quote">&gt; &gt; &gt; via other file descriptors.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The final piece of the puzzle is what to do about filemap_check_errors</span>
<span class="quote">&gt; &gt; &gt; calls that are being called directly or via filemap_* functions. Here,</span>
<span class="quote">&gt; &gt; &gt; we must take a little &quot;creative license&quot;.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Since we now handle advancing the file-&gt;f_wb_err value at the generic</span>
<span class="quote">&gt; &gt; &gt; filesystem layer, we no longer need those callers to clear errors out</span>
<span class="quote">&gt; &gt; &gt; of the mapping or advance an errseq_t.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; A lot of the existing codebase relies on being getting an error back</span>
<span class="quote">&gt; &gt; &gt; from those functions when there is a writeback problem, so we do still</span>
<span class="quote">&gt; &gt; &gt; want to have them report writeback errors somehow.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; When reporting writeback errors, we will always report errors that have</span>
<span class="quote">&gt; &gt; &gt; occurred since a particular point in time. With the old writeback error</span>
<span class="quote">&gt; &gt; &gt; reporting, the time we used was &quot;since it was last tested/cleared&quot; which</span>
<span class="quote">&gt; &gt; &gt; is entirely arbitrary and potentially racy. Now, we can at least report</span>
<span class="quote">&gt; &gt; &gt; the latest error that has occurred since an arbitrary point in time</span>
<span class="quote">&gt; &gt; &gt; (represented as a sampled errseq_t value).</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; In the case where we don&#39;t have a struct file to work with, this patch</span>
<span class="quote">&gt; &gt; &gt; just has the wrappers sample the current mapping-&gt;wb_err value, and use</span>
<span class="quote">&gt; &gt; &gt; that as an arbitrary point from which to check for errors.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I think this is really dangerous and we shouldn&#39;t do this. You are quite</span>
<span class="quote">&gt; &gt; likely to lose IO errors in such calls because you will ignore all errors</span>
<span class="quote">&gt; &gt; that happened during previous background writeback or even for IO that</span>
<span class="quote">&gt; &gt; managed to complete before we called filemap_fdatawait(). Maybe we need to</span>
<span class="quote">&gt; &gt; keep the original set-clear-bit IO error reporting for these cases, until</span>
<span class="quote">&gt; &gt; we can convert them to fdatawait_range_since()?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of</span>
<span class="quote">&gt; &gt; &gt; something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than</span>
<span class="quote">&gt; &gt; &gt; what we already have, and this gives us a basis from which to work.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; A lot of those callers will likely want to change to a model where they</span>
<span class="quote">&gt; &gt; &gt; sample the errseq_t much earlier (perhaps when starting a transaction),</span>
<span class="quote">&gt; &gt; &gt; store it in an appropriate place and then use that value later when</span>
<span class="quote">&gt; &gt; &gt; checking to see if an error occurred.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; That will almost certainly take some involvement from other subsystem</span>
<span class="quote">&gt; &gt; &gt; maintainers. I&#39;m quite open to adding new API functions to help enable</span>
<span class="quote">&gt; &gt; &gt; this if that would be helpful, but I don&#39;t really want to do that until</span>
<span class="quote">&gt; &gt; &gt; I better understand what&#39;s needed.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; ...</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; index 5f7317875a67..7ce13281925f 100644</span>
<span class="quote">&gt; &gt; &gt; --- a/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; +++ b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; @@ -187,6 +187,7 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt;  		.nr_to_write = LONG_MAX,</span>
<span class="quote">&gt; &gt; &gt;  		.for_reclaim = 0,</span>
<span class="quote">&gt; &gt; &gt;  	};</span>
<span class="quote">&gt; &gt; &gt; +	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))</span>
<span class="quote">&gt; &gt; &gt;  		return 0;</span>
<span class="quote">&gt; &gt; &gt; @@ -265,6 +266,8 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt;  	}</span>
<span class="quote">&gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt;  	ret = wait_on_node_pages_writeback(sbi, ino);</span>
<span class="quote">&gt; &gt; &gt; +	if (ret == 0)</span>
<span class="quote">&gt; &gt; &gt; +		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
<span class="quote">&gt; &gt; &gt;  	if (ret)</span>
<span class="quote">&gt; &gt; &gt;  		goto out;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So this conversion looks wrong and actually points to a larger issue with</span>
<span class="quote">&gt; &gt; the scheme. The problem is there are two mappings that come into play here</span>
<span class="quote">&gt; &gt; - file_inode(file)-&gt;i_mapping which is the data mapping and</span>
<span class="quote">&gt; &gt; NODE_MAPPING(sbi) which is the metadata mapping (and this is not a problem</span>
<span class="quote">&gt; &gt; specific to f2fs. For example ext2 also uses this scheme where block</span>
<span class="quote">&gt; &gt; devices&#39; mapping is the metadata mapping). And we need to merge error</span>
<span class="quote">&gt; &gt; information from these two mappings so for the stamping scheme to work,</span>
<span class="quote">&gt; &gt; we&#39;d need two stamps stored in struct file. One for data mapping and one</span>
<span class="quote">&gt; &gt; for metadata mapping. Or maybe there&#39;s some more clever scheme but for now</span>
<span class="quote">&gt; &gt; I don&#39;t see one...</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 								Honza</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; In the case of something like ext2, could we instead get away with just</span>
<span class="quote">&gt; marking the data mapping of the inode with an error if the metadata</span>
<span class="quote">&gt; writeout fails?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Then we could just have write_inode operations call mapping_set_error on</span>
<span class="quote">&gt; inode-&gt;i_mapping when they&#39;re going to return an error. That should be</span>
<span class="quote">&gt; functionally equivalent, I&#39;d think.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The catch there is that that requires a 1:1 data:metadata mapping, and</span>
<span class="quote">&gt; I&#39;m not sure that that is the case (or will always be, even if it is</span>
<span class="quote">&gt; now).</span>

So for ext2 / ext4 in nojournal mode this should work - we track all
relevant metadata in mapping-&gt;private_list. But I cannot really comment
on other filesystems like f2fs...

								Honza
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=440">Jeff Layton</a> - May 22, 2017, 1:53 p.m.</div>
<pre class="content">
On Mon, 2017-05-22 at 15:38 +0200, Jan Kara wrote:
<span class="quote">&gt; On Fri 19-05-17 15:20:52, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; On Mon, 2017-05-15 at 12:42 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; &gt; On Tue 09-05-17 11:49:18, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; Now that we have a better way to store and report errors that occur</span>
<span class="quote">&gt; &gt; &gt; &gt; during writeback, we need to convert the existing codebase to use it. We</span>
<span class="quote">&gt; &gt; &gt; &gt; could just adapt all of the filesystem code and related infrastructure</span>
<span class="quote">&gt; &gt; &gt; &gt; to the new API, but that&#39;s a lot of churn.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; When it comes to setting errors in the mapping, filemap_set_wb_error is</span>
<span class="quote">&gt; &gt; &gt; &gt; a drop-in replacement for mapping_set_error. Turn that function into a</span>
<span class="quote">&gt; &gt; &gt; &gt; simple wrapper around the new one.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Because we want to ensure that writeback errors are always reported at</span>
<span class="quote">&gt; &gt; &gt; &gt; fsync time, inject filemap_report_wb_error calls much closer to the</span>
<span class="quote">&gt; &gt; &gt; &gt; syscall boundary, in call_fsync.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; For fsync calls (and things like the nfsd equivalent), we either return</span>
<span class="quote">&gt; &gt; &gt; &gt; the error that the fsync operation returns, or the one returned by</span>
<span class="quote">&gt; &gt; &gt; &gt; filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to</span>
<span class="quote">&gt; &gt; &gt; &gt; the latest value. This allows us to provide new fsync semantics that</span>
<span class="quote">&gt; &gt; &gt; &gt; will return errors that may have occurred previously and been viewed</span>
<span class="quote">&gt; &gt; &gt; &gt; via other file descriptors.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; The final piece of the puzzle is what to do about filemap_check_errors</span>
<span class="quote">&gt; &gt; &gt; &gt; calls that are being called directly or via filemap_* functions. Here,</span>
<span class="quote">&gt; &gt; &gt; &gt; we must take a little &quot;creative license&quot;.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Since we now handle advancing the file-&gt;f_wb_err value at the generic</span>
<span class="quote">&gt; &gt; &gt; &gt; filesystem layer, we no longer need those callers to clear errors out</span>
<span class="quote">&gt; &gt; &gt; &gt; of the mapping or advance an errseq_t.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; A lot of the existing codebase relies on being getting an error back</span>
<span class="quote">&gt; &gt; &gt; &gt; from those functions when there is a writeback problem, so we do still</span>
<span class="quote">&gt; &gt; &gt; &gt; want to have them report writeback errors somehow.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; When reporting writeback errors, we will always report errors that have</span>
<span class="quote">&gt; &gt; &gt; &gt; occurred since a particular point in time. With the old writeback error</span>
<span class="quote">&gt; &gt; &gt; &gt; reporting, the time we used was &quot;since it was last tested/cleared&quot; which</span>
<span class="quote">&gt; &gt; &gt; &gt; is entirely arbitrary and potentially racy. Now, we can at least report</span>
<span class="quote">&gt; &gt; &gt; &gt; the latest error that has occurred since an arbitrary point in time</span>
<span class="quote">&gt; &gt; &gt; &gt; (represented as a sampled errseq_t value).</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; In the case where we don&#39;t have a struct file to work with, this patch</span>
<span class="quote">&gt; &gt; &gt; &gt; just has the wrappers sample the current mapping-&gt;wb_err value, and use</span>
<span class="quote">&gt; &gt; &gt; &gt; that as an arbitrary point from which to check for errors.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I think this is really dangerous and we shouldn&#39;t do this. You are quite</span>
<span class="quote">&gt; &gt; &gt; likely to lose IO errors in such calls because you will ignore all errors</span>
<span class="quote">&gt; &gt; &gt; that happened during previous background writeback or even for IO that</span>
<span class="quote">&gt; &gt; &gt; managed to complete before we called filemap_fdatawait(). Maybe we need to</span>
<span class="quote">&gt; &gt; &gt; keep the original set-clear-bit IO error reporting for these cases, until</span>
<span class="quote">&gt; &gt; &gt; we can convert them to fdatawait_range_since()?</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of</span>
<span class="quote">&gt; &gt; &gt; &gt; something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than</span>
<span class="quote">&gt; &gt; &gt; &gt; what we already have, and this gives us a basis from which to work.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; A lot of those callers will likely want to change to a model where they</span>
<span class="quote">&gt; &gt; &gt; &gt; sample the errseq_t much earlier (perhaps when starting a transaction),</span>
<span class="quote">&gt; &gt; &gt; &gt; store it in an appropriate place and then use that value later when</span>
<span class="quote">&gt; &gt; &gt; &gt; checking to see if an error occurred.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; That will almost certainly take some involvement from other subsystem</span>
<span class="quote">&gt; &gt; &gt; &gt; maintainers. I&#39;m quite open to adding new API functions to help enable</span>
<span class="quote">&gt; &gt; &gt; &gt; this if that would be helpful, but I don&#39;t really want to do that until</span>
<span class="quote">&gt; &gt; &gt; &gt; I better understand what&#39;s needed.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; ...</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; index 5f7317875a67..7ce13281925f 100644</span>
<span class="quote">&gt; &gt; &gt; &gt; --- a/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; +++ b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; @@ -187,6 +187,7 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt; &gt;  		.nr_to_write = LONG_MAX,</span>
<span class="quote">&gt; &gt; &gt; &gt;  		.for_reclaim = 0,</span>
<span class="quote">&gt; &gt; &gt; &gt;  	};</span>
<span class="quote">&gt; &gt; &gt; &gt; +	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
<span class="quote">&gt; &gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; &gt;  	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))</span>
<span class="quote">&gt; &gt; &gt; &gt;  		return 0;</span>
<span class="quote">&gt; &gt; &gt; &gt; @@ -265,6 +266,8 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt; &gt;  	}</span>
<span class="quote">&gt; &gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; &gt;  	ret = wait_on_node_pages_writeback(sbi, ino);</span>
<span class="quote">&gt; &gt; &gt; &gt; +	if (ret == 0)</span>
<span class="quote">&gt; &gt; &gt; &gt; +		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
<span class="quote">&gt; &gt; &gt; &gt;  	if (ret)</span>
<span class="quote">&gt; &gt; &gt; &gt;  		goto out;</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; So this conversion looks wrong and actually points to a larger issue with</span>
<span class="quote">&gt; &gt; &gt; the scheme. The problem is there are two mappings that come into play here</span>
<span class="quote">&gt; &gt; &gt; - file_inode(file)-&gt;i_mapping which is the data mapping and</span>
<span class="quote">&gt; &gt; &gt; NODE_MAPPING(sbi) which is the metadata mapping (and this is not a problem</span>
<span class="quote">&gt; &gt; &gt; specific to f2fs. For example ext2 also uses this scheme where block</span>
<span class="quote">&gt; &gt; &gt; devices&#39; mapping is the metadata mapping). And we need to merge error</span>
<span class="quote">&gt; &gt; &gt; information from these two mappings so for the stamping scheme to work,</span>
<span class="quote">&gt; &gt; &gt; we&#39;d need two stamps stored in struct file. One for data mapping and one</span>
<span class="quote">&gt; &gt; &gt; for metadata mapping. Or maybe there&#39;s some more clever scheme but for now</span>
<span class="quote">&gt; &gt; &gt; I don&#39;t see one...</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; 								Honza</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; In the case of something like ext2, could we instead get away with just</span>
<span class="quote">&gt; &gt; marking the data mapping of the inode with an error if the metadata</span>
<span class="quote">&gt; &gt; writeout fails?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Then we could just have write_inode operations call mapping_set_error on</span>
<span class="quote">&gt; &gt; inode-&gt;i_mapping when they&#39;re going to return an error. That should be</span>
<span class="quote">&gt; &gt; functionally equivalent, I&#39;d think.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; The catch there is that that requires a 1:1 data:metadata mapping, and</span>
<span class="quote">&gt; &gt; I&#39;m not sure that that is the case (or will always be, even if it is</span>
<span class="quote">&gt; &gt; now).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; So for ext2 / ext4 in nojournal mode this should work - we track all</span>
<span class="quote">&gt; relevant metadata in mapping-&gt;private_list. But I cannot really comment</span>
<span class="quote">&gt; on other filesystems like f2fs...</span>
<span class="quote">&gt; </span>

Actually, I think that may be problematic...

We could end up calling ext2_write_inode with sync_mode != WB_SYNC_ALL,
which just dirties the buffer without starting writeback. Then, have VM
subsystem write back the buffer due to memory pressure and have that
fail. Trying to set the error in write_inode would miss that situation.

I think we&#39;ll have to track two errseq_t&#39;s for those filesystems, like
you had originally suggested. The main question is where to put the
second errseq_t

For ext2, I stored it in file-&gt;private_data pointer since it wasn&#39;t
being used. For those filesystems that are already using private_data,
I&#39;ll just plan to add a field to whatever structure they&#39;re using.

(Maybe I could make private_data a union with an errseq_t for those that
don&#39;t use that field? That might be cleaner than the casting I&#39;m doing
now)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=305">Jan Kara</a> - May 22, 2017, 5:53 p.m.</div>
<pre class="content">
On Mon 22-05-17 09:53:21, Jeff Layton wrote:
<span class="quote">&gt; On Mon, 2017-05-22 at 15:38 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; On Fri 19-05-17 15:20:52, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; &gt; On Mon, 2017-05-15 at 12:42 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On Tue 09-05-17 11:49:18, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Now that we have a better way to store and report errors that occur</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; during writeback, we need to convert the existing codebase to use it. We</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; could just adapt all of the filesystem code and related infrastructure</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; to the new API, but that&#39;s a lot of churn.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; When it comes to setting errors in the mapping, filemap_set_wb_error is</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; a drop-in replacement for mapping_set_error. Turn that function into a</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; simple wrapper around the new one.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Because we want to ensure that writeback errors are always reported at</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; fsync time, inject filemap_report_wb_error calls much closer to the</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; syscall boundary, in call_fsync.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; For fsync calls (and things like the nfsd equivalent), we either return</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; the error that the fsync operation returns, or the one returned by</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; the latest value. This allows us to provide new fsync semantics that</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; will return errors that may have occurred previously and been viewed</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; via other file descriptors.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; The final piece of the puzzle is what to do about filemap_check_errors</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; calls that are being called directly or via filemap_* functions. Here,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; we must take a little &quot;creative license&quot;.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Since we now handle advancing the file-&gt;f_wb_err value at the generic</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; filesystem layer, we no longer need those callers to clear errors out</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; of the mapping or advance an errseq_t.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; A lot of the existing codebase relies on being getting an error back</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; from those functions when there is a writeback problem, so we do still</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; want to have them report writeback errors somehow.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; When reporting writeback errors, we will always report errors that have</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; occurred since a particular point in time. With the old writeback error</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; reporting, the time we used was &quot;since it was last tested/cleared&quot; which</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; is entirely arbitrary and potentially racy. Now, we can at least report</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; the latest error that has occurred since an arbitrary point in time</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; (represented as a sampled errseq_t value).</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; In the case where we don&#39;t have a struct file to work with, this patch</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; just has the wrappers sample the current mapping-&gt;wb_err value, and use</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; that as an arbitrary point from which to check for errors.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; I think this is really dangerous and we shouldn&#39;t do this. You are quite</span>
<span class="quote">&gt; &gt; &gt; &gt; likely to lose IO errors in such calls because you will ignore all errors</span>
<span class="quote">&gt; &gt; &gt; &gt; that happened during previous background writeback or even for IO that</span>
<span class="quote">&gt; &gt; &gt; &gt; managed to complete before we called filemap_fdatawait(). Maybe we need to</span>
<span class="quote">&gt; &gt; &gt; &gt; keep the original set-clear-bit IO error reporting for these cases, until</span>
<span class="quote">&gt; &gt; &gt; &gt; we can convert them to fdatawait_range_since()?</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; what we already have, and this gives us a basis from which to work.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; A lot of those callers will likely want to change to a model where they</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; sample the errseq_t much earlier (perhaps when starting a transaction),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; store it in an appropriate place and then use that value later when</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; checking to see if an error occurred.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; That will almost certainly take some involvement from other subsystem</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; maintainers. I&#39;m quite open to adding new API functions to help enable</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; this if that would be helpful, but I don&#39;t really want to do that until</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; I better understand what&#39;s needed.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; ...</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; index 5f7317875a67..7ce13281925f 100644</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; --- a/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +++ b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; @@ -187,6 +187,7 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  		.nr_to_write = LONG_MAX,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  		.for_reclaim = 0,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  	};</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  		return 0;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; @@ -265,6 +266,8 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  	}</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  	ret = wait_on_node_pages_writeback(sbi, ino);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +	if (ret == 0)</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  	if (ret)</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  		goto out;</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; So this conversion looks wrong and actually points to a larger issue with</span>
<span class="quote">&gt; &gt; &gt; &gt; the scheme. The problem is there are two mappings that come into play here</span>
<span class="quote">&gt; &gt; &gt; &gt; - file_inode(file)-&gt;i_mapping which is the data mapping and</span>
<span class="quote">&gt; &gt; &gt; &gt; NODE_MAPPING(sbi) which is the metadata mapping (and this is not a problem</span>
<span class="quote">&gt; &gt; &gt; &gt; specific to f2fs. For example ext2 also uses this scheme where block</span>
<span class="quote">&gt; &gt; &gt; &gt; devices&#39; mapping is the metadata mapping). And we need to merge error</span>
<span class="quote">&gt; &gt; &gt; &gt; information from these two mappings so for the stamping scheme to work,</span>
<span class="quote">&gt; &gt; &gt; &gt; we&#39;d need two stamps stored in struct file. One for data mapping and one</span>
<span class="quote">&gt; &gt; &gt; &gt; for metadata mapping. Or maybe there&#39;s some more clever scheme but for now</span>
<span class="quote">&gt; &gt; &gt; &gt; I don&#39;t see one...</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; 								Honza</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; In the case of something like ext2, could we instead get away with just</span>
<span class="quote">&gt; &gt; &gt; marking the data mapping of the inode with an error if the metadata</span>
<span class="quote">&gt; &gt; &gt; writeout fails?</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Then we could just have write_inode operations call mapping_set_error on</span>
<span class="quote">&gt; &gt; &gt; inode-&gt;i_mapping when they&#39;re going to return an error. That should be</span>
<span class="quote">&gt; &gt; &gt; functionally equivalent, I&#39;d think.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; The catch there is that that requires a 1:1 data:metadata mapping, and</span>
<span class="quote">&gt; &gt; &gt; I&#39;m not sure that that is the case (or will always be, even if it is</span>
<span class="quote">&gt; &gt; &gt; now).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; So for ext2 / ext4 in nojournal mode this should work - we track all</span>
<span class="quote">&gt; &gt; relevant metadata in mapping-&gt;private_list. But I cannot really comment</span>
<span class="quote">&gt; &gt; on other filesystems like f2fs...</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Actually, I think that may be problematic...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We could end up calling ext2_write_inode with sync_mode != WB_SYNC_ALL,</span>
<span class="quote">&gt; which just dirties the buffer without starting writeback. Then, have VM</span>
<span class="quote">&gt; subsystem write back the buffer due to memory pressure and have that</span>
<span class="quote">&gt; fail. Trying to set the error in write_inode would miss that situation.</span>

Two notes here:

1) Inode is a bad example because there isn&#39;t 1:1 mapping between buffers
containing inodes and mappings - one buffer contains several inodes.
I wanted to add that for inodes specifically it does not matter as they get
special handling but actually fsync seems to be currently unreliable for
them - if we first wrote them in WB_SYNC_NONE mode, they will be just
written in bdev&#39;s page cache, but following fsync(2) will do nothing as
they will be clean. Anyway, this is unrelated problem.

2) For metadata like indirect blocks where you indeed have 1:1 mapping, you
can do the error setting in -&gt;end_io handler based on bh-&gt;b_assoc_map and
that should do what you need, shouldn&#39;t it?

If I&#39;m indeed right, then for buffers which have 1:1 mapping we are fine
and if we find a solution for inodes, we could avoid the second errseq_t.

								Honza
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=440">Jeff Layton</a> - May 22, 2017, 7:09 p.m.</div>
<pre class="content">
On Mon, 2017-05-22 at 19:53 +0200, Jan Kara wrote:
<span class="quote">&gt; On Mon 22-05-17 09:53:21, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; On Mon, 2017-05-22 at 15:38 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; &gt; On Fri 19-05-17 15:20:52, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On Mon, 2017-05-15 at 12:42 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; On Tue 09-05-17 11:49:18, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; Now that we have a better way to store and report errors that occur</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; during writeback, we need to convert the existing codebase to use it. We</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; could just adapt all of the filesystem code and related infrastructure</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; to the new API, but that&#39;s a lot of churn.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; When it comes to setting errors in the mapping, filemap_set_wb_error is</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; a drop-in replacement for mapping_set_error. Turn that function into a</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; simple wrapper around the new one.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; Because we want to ensure that writeback errors are always reported at</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; fsync time, inject filemap_report_wb_error calls much closer to the</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; syscall boundary, in call_fsync.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; For fsync calls (and things like the nfsd equivalent), we either return</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; the error that the fsync operation returns, or the one returned by</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; filemap_report_wb_error. In both cases, we advance the file-&gt;f_wb_err to</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; the latest value. This allows us to provide new fsync semantics that</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; will return errors that may have occurred previously and been viewed</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; via other file descriptors.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; The final piece of the puzzle is what to do about filemap_check_errors</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; calls that are being called directly or via filemap_* functions. Here,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; we must take a little &quot;creative license&quot;.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; Since we now handle advancing the file-&gt;f_wb_err value at the generic</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; filesystem layer, we no longer need those callers to clear errors out</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; of the mapping or advance an errseq_t.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; A lot of the existing codebase relies on being getting an error back</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; from those functions when there is a writeback problem, so we do still</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; want to have them report writeback errors somehow.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; When reporting writeback errors, we will always report errors that have</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; occurred since a particular point in time. With the old writeback error</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; reporting, the time we used was &quot;since it was last tested/cleared&quot; which</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; is entirely arbitrary and potentially racy. Now, we can at least report</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; the latest error that has occurred since an arbitrary point in time</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; (represented as a sampled errseq_t value).</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; In the case where we don&#39;t have a struct file to work with, this patch</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; just has the wrappers sample the current mapping-&gt;wb_err value, and use</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; that as an arbitrary point from which to check for errors.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; I think this is really dangerous and we shouldn&#39;t do this. You are quite</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; likely to lose IO errors in such calls because you will ignore all errors</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; that happened during previous background writeback or even for IO that</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; managed to complete before we called filemap_fdatawait(). Maybe we need to</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; keep the original set-clear-bit IO error reporting for these cases, until</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; we can convert them to fdatawait_range_since()?</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; That&#39;s probably not &quot;correct&quot; in all cases, particularly in the case of</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; something like filemap_fdatawait, but I&#39;m not sure it&#39;s any worse than</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; what we already have, and this gives us a basis from which to work.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; A lot of those callers will likely want to change to a model where they</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; sample the errseq_t much earlier (perhaps when starting a transaction),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; store it in an appropriate place and then use that value later when</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; checking to see if an error occurred.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; That will almost certainly take some involvement from other subsystem</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; maintainers. I&#39;m quite open to adding new API functions to help enable</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; this if that would be helpful, but I don&#39;t really want to do that until</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; I better understand what&#39;s needed.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; Signed-off-by: Jeff Layton &lt;jlayton@redhat.com&gt;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; ...</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; index 5f7317875a67..7ce13281925f 100644</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; --- a/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; +++ b/fs/f2fs/file.c</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; @@ -187,6 +187,7 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  		.nr_to_write = LONG_MAX,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  		.for_reclaim = 0,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  	};</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; +	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  		return 0;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; @@ -265,6 +266,8 @@ static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  	}</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  	ret = wait_on_node_pages_writeback(sbi, ino);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; +	if (ret == 0)</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; +		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  	if (ret)</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  		goto out;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; So this conversion looks wrong and actually points to a larger issue with</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; the scheme. The problem is there are two mappings that come into play here</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; - file_inode(file)-&gt;i_mapping which is the data mapping and</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; NODE_MAPPING(sbi) which is the metadata mapping (and this is not a problem</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; specific to f2fs. For example ext2 also uses this scheme where block</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; devices&#39; mapping is the metadata mapping). And we need to merge error</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; information from these two mappings so for the stamping scheme to work,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; we&#39;d need two stamps stored in struct file. One for data mapping and one</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; for metadata mapping. Or maybe there&#39;s some more clever scheme but for now</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; I don&#39;t see one...</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; 								Honza</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; In the case of something like ext2, could we instead get away with just</span>
<span class="quote">&gt; &gt; &gt; &gt; marking the data mapping of the inode with an error if the metadata</span>
<span class="quote">&gt; &gt; &gt; &gt; writeout fails?</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Then we could just have write_inode operations call mapping_set_error on</span>
<span class="quote">&gt; &gt; &gt; &gt; inode-&gt;i_mapping when they&#39;re going to return an error. That should be</span>
<span class="quote">&gt; &gt; &gt; &gt; functionally equivalent, I&#39;d think.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; The catch there is that that requires a 1:1 data:metadata mapping, and</span>
<span class="quote">&gt; &gt; &gt; &gt; I&#39;m not sure that that is the case (or will always be, even if it is</span>
<span class="quote">&gt; &gt; &gt; &gt; now).</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; So for ext2 / ext4 in nojournal mode this should work - we track all</span>
<span class="quote">&gt; &gt; &gt; relevant metadata in mapping-&gt;private_list. But I cannot really comment</span>
<span class="quote">&gt; &gt; &gt; on other filesystems like f2fs...</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Actually, I think that may be problematic...</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; We could end up calling ext2_write_inode with sync_mode != WB_SYNC_ALL,</span>
<span class="quote">&gt; &gt; which just dirties the buffer without starting writeback. Then, have VM</span>
<span class="quote">&gt; &gt; subsystem write back the buffer due to memory pressure and have that</span>
<span class="quote">&gt; &gt; fail. Trying to set the error in write_inode would miss that situation.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Two notes here:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 1) Inode is a bad example because there isn&#39;t 1:1 mapping between buffers</span>
<span class="quote">&gt; containing inodes and mappings - one buffer contains several inodes.</span>
<span class="quote">&gt; I wanted to add that for inodes specifically it does not matter as they get</span>
<span class="quote">&gt; special handling but actually fsync seems to be currently unreliable for</span>
<span class="quote">&gt; them - if we first wrote them in WB_SYNC_NONE mode, they will be just</span>
<span class="quote">&gt; written in bdev&#39;s page cache, but following fsync(2) will do nothing as</span>
<span class="quote">&gt; they will be clean. Anyway, this is unrelated problem.</span>
<span class="quote">&gt; </span>

Yes, that&#39;s what I was trying to articulate above. I&#39;m not sure it&#39;s
unrelated though. Moving to errseq_t based handling there based on the
blockdev mapping seems like it&#39;d solve that. That does require an extra
errseq_t though.

(I assume that on ext2 inode writeback, bh-&gt;b_page-&gt;mapping-&gt;host points
to the bdev inode?)
<span class="quote">
&gt; 2) For metadata like indirect blocks where you indeed have 1:1 mapping, you</span>
<span class="quote">&gt; can do the error setting in -&gt;end_io handler based on bh-&gt;b_assoc_map and</span>
<span class="quote">&gt; that should do what you need, shouldn&#39;t it?</span>
<span class="quote">&gt; </span>

That would probably work, and I think the mark_buffer_write_io_error
function that I was adding should already be doing the right thing
there.
<span class="quote">
&gt; If I&#39;m indeed right, then for buffers which have 1:1 mapping we are fine</span>
<span class="quote">&gt; and if we find a solution for inodes, we could avoid the second errseq_t.</span>
<span class="quote">&gt; </span>

Yeah, I&#39;m just still not seeing a good way to track error in inode
metadata writeback without an extra errseq_t though. I don&#39;t suppose
that a buffer holding inode metadata has a list of those inodes, does
it? Then we could walk the list and flag each one with the error.
Without something like that, I think we&#39;re stuck with an extra errseq_t.

BTW, thanks for the help so far. I haven&#39;t spent much time in local fs
metadata handling up until now, so this has been very helpful.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=305">Jan Kara</a> - May 23, 2017, 9:05 a.m.</div>
<pre class="content">
On Mon 22-05-17 15:09:33, Jeff Layton wrote:
<span class="quote">&gt; On Mon, 2017-05-22 at 19:53 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; On Mon 22-05-17 09:53:21, Jeff Layton wrote:</span>
<span class="quote">&gt; &gt; &gt; On Mon, 2017-05-22 at 15:38 +0200, Jan Kara wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; In the case of something like ext2, could we instead get away with just</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; marking the data mapping of the inode with an error if the metadata</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; writeout fails?</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Then we could just have write_inode operations call mapping_set_error on</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; inode-&gt;i_mapping when they&#39;re going to return an error. That should be</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; functionally equivalent, I&#39;d think.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; The catch there is that that requires a 1:1 data:metadata mapping, and</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; I&#39;m not sure that that is the case (or will always be, even if it is</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; now).</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; So for ext2 / ext4 in nojournal mode this should work - we track all</span>
<span class="quote">&gt; &gt; &gt; &gt; relevant metadata in mapping-&gt;private_list. But I cannot really comment</span>
<span class="quote">&gt; &gt; &gt; &gt; on other filesystems like f2fs...</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Actually, I think that may be problematic...</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; We could end up calling ext2_write_inode with sync_mode != WB_SYNC_ALL,</span>
<span class="quote">&gt; &gt; &gt; which just dirties the buffer without starting writeback. Then, have VM</span>
<span class="quote">&gt; &gt; &gt; subsystem write back the buffer due to memory pressure and have that</span>
<span class="quote">&gt; &gt; &gt; fail. Trying to set the error in write_inode would miss that situation.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Two notes here:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 1) Inode is a bad example because there isn&#39;t 1:1 mapping between buffers</span>
<span class="quote">&gt; &gt; containing inodes and mappings - one buffer contains several inodes.</span>
<span class="quote">&gt; &gt; I wanted to add that for inodes specifically it does not matter as they get</span>
<span class="quote">&gt; &gt; special handling but actually fsync seems to be currently unreliable for</span>
<span class="quote">&gt; &gt; them - if we first wrote them in WB_SYNC_NONE mode, they will be just</span>
<span class="quote">&gt; &gt; written in bdev&#39;s page cache, but following fsync(2) will do nothing as</span>
<span class="quote">&gt; &gt; they will be clean. Anyway, this is unrelated problem.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yes, that&#39;s what I was trying to articulate above. I&#39;m not sure it&#39;s</span>
<span class="quote">&gt; unrelated though. Moving to errseq_t based handling there based on the</span>
<span class="quote">&gt; blockdev mapping seems like it&#39;d solve that. That does require an extra</span>
<span class="quote">&gt; errseq_t though.</span>

Well, it might help solving the error handling case but it doesn&#39;t solve
the fundamental problem that the inode buffer even doesn&#39;t have to be
written to disk by the time fsync(2) returns.
<span class="quote">
&gt; (I assume that on ext2 inode writeback, bh-&gt;b_page-&gt;mapping-&gt;host points</span>
<span class="quote">&gt; to the bdev inode?)</span>

Yes, it does.
<span class="quote">
&gt; &gt; 2) For metadata like indirect blocks where you indeed have 1:1 mapping, you</span>
<span class="quote">&gt; &gt; can do the error setting in -&gt;end_io handler based on bh-&gt;b_assoc_map and</span>
<span class="quote">&gt; &gt; that should do what you need, shouldn&#39;t it?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That would probably work, and I think the mark_buffer_write_io_error</span>
<span class="quote">&gt; function that I was adding should already be doing the right thing</span>
<span class="quote">&gt; there.</span>

Agreed.
<span class="quote">
&gt; &gt; If I&#39;m indeed right, then for buffers which have 1:1 mapping we are fine</span>
<span class="quote">&gt; &gt; and if we find a solution for inodes, we could avoid the second errseq_t.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Yeah, I&#39;m just still not seeing a good way to track error in inode</span>
<span class="quote">&gt; metadata writeback without an extra errseq_t though. I don&#39;t suppose</span>
<span class="quote">&gt; that a buffer holding inode metadata has a list of those inodes, does</span>
<span class="quote">&gt; it? Then we could walk the list and flag each one with the error.</span>
<span class="quote">&gt; Without something like that, I think we&#39;re stuck with an extra errseq_t.</span>

No, the buffer doesn&#39;t have a list of associated inodes. For ext2/4 it is
doable to actually track down all the inodes but I don&#39;t think we want to
complicate this series by implementing such mechanism for each filesystem
that needs this. So let&#39;s start with a generic solution that uses second
errseq_t for the metadata mapping. It is somewhat rough (error in writeback
of any metadata block will fail fsync(2) for all open files) but we can later
improve on this for each fs which cares enough about better error reporting.

								Honza
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/filesystems/vfs.txt b/Documentation/filesystems/vfs.txt</span>
<span class="p_header">index ed06fb39822b..f201a77873f7 100644</span>
<span class="p_header">--- a/Documentation/filesystems/vfs.txt</span>
<span class="p_header">+++ b/Documentation/filesystems/vfs.txt</span>
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> written at any point after PG_Dirty is clear.  Once it is known to be</span>
 safe, PG_Writeback is cleared.
 
 If there is an error during writeback, then the address_space should be
<span class="p_del">-marked with an error (typically using filemap_set_wb_error), in order to</span>
<span class="p_add">+marked with an error (typically using mapping_set_error), in order to</span>
 ensure that the error can later be reported to the application when an
 fsync is issued.
 
<span class="p_chunk">@@ -893,10 +893,9 @@</span> <span class="p_context"> otherwise noted.</span>
 
   release: called when the last reference to an open file is closed
 
<span class="p_del">-  fsync: called by the fsync(2) system call. Filesystems that use the</span>
<span class="p_del">-	pagecache should call filemap_report_wb_error before returning</span>
<span class="p_del">-	to ensure that any errors that occurred during writeback are</span>
<span class="p_del">-	reported and the file&#39;s error sequence advanced.</span>
<span class="p_add">+  fsync: called by the fsync(2) system call. Errors that were previously</span>
<span class="p_add">+	 recorded using mapping_set_error will automatically be returned to</span>
<span class="p_add">+	 the application and the file&#39;s error sequence advanced.</span>
 
   fasync: called by the fcntl(2) system call when asynchronous
 	(non-blocking) mode is enabled for a file
<span class="p_header">diff --git a/fs/btrfs/file.c b/fs/btrfs/file.c</span>
<span class="p_header">index 520cb7230b2d..e15faf240b51 100644</span>
<span class="p_header">--- a/fs/btrfs/file.c</span>
<span class="p_header">+++ b/fs/btrfs/file.c</span>
<span class="p_chunk">@@ -1962,6 +1962,7 @@</span> <span class="p_context"> int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)</span>
 	int ret = 0;
 	bool full_sync = 0;
 	u64 len;
<span class="p_add">+	errseq_t wb_since = READ_ONCE(file-&gt;f_wb_err);</span>
 
 	/*
 	 * The range length can be represented by u64, we have to do the typecasts
<span class="p_chunk">@@ -2079,14 +2080,7 @@</span> <span class="p_context"> int btrfs_sync_file(struct file *file, loff_t start, loff_t end, int datasync)</span>
 		 */
 		clear_bit(BTRFS_INODE_NEEDS_FULL_SYNC,
 			  &amp;BTRFS_I(inode)-&gt;runtime_flags);
<span class="p_del">-		/*</span>
<span class="p_del">-		 * An ordered extent might have started before and completed</span>
<span class="p_del">-		 * already with io errors, in which case the inode was not</span>
<span class="p_del">-		 * updated and we end up here. So check the inode&#39;s mapping</span>
<span class="p_del">-		 * flags for any errors that might have happened while doing</span>
<span class="p_del">-		 * writeback of file data.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		ret = filemap_check_errors(inode-&gt;i_mapping);</span>
<span class="p_add">+		ret = filemap_check_wb_error(inode-&gt;i_mapping, wb_since);</span>
 		inode_unlock(inode);
 		goto out;
 	}
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index a59674c3e69e..d0a123dbb199 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -3972,12 +3972,6 @@</span> <span class="p_context"> static int wait_ordered_extents(struct btrfs_trans_handle *trans,</span>
 			    test_bit(BTRFS_ORDERED_IOERR, &amp;ordered-&gt;flags)));
 
 		if (test_bit(BTRFS_ORDERED_IOERR, &amp;ordered-&gt;flags)) {
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Clear the AS_EIO/AS_ENOSPC flags from the inode&#39;s</span>
<span class="p_del">-			 * i_mapping flags, so that the next fsync won&#39;t get</span>
<span class="p_del">-			 * an outdated io error too.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			filemap_check_errors(inode-&gt;i_mapping);</span>
 			*ordered_io_error = true;
 			break;
 		}
<span class="p_chunk">@@ -4171,6 +4165,7 @@</span> <span class="p_context"> static int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,</span>
 	u64 test_gen;
 	int ret = 0;
 	int num = 0;
<span class="p_add">+	errseq_t since = filemap_sample_wb_error(inode-&gt;vfs_inode.i_mapping);</span>
 
 	INIT_LIST_HEAD(&amp;extents);
 
<span class="p_chunk">@@ -4214,7 +4209,7 @@</span> <span class="p_context"> static int btrfs_log_changed_extents(struct btrfs_trans_handle *trans,</span>
 	 * without writing to the log tree and the fsync must report the
 	 * file data write error and not commit the current transaction.
 	 */
<span class="p_del">-	ret = filemap_check_errors(inode-&gt;vfs_inode.i_mapping);</span>
<span class="p_add">+	ret = filemap_check_wb_error(inode-&gt;vfs_inode.i_mapping, since);</span>
 	if (ret)
 		ctx-&gt;io_err = ret;
 process:
<span class="p_header">diff --git a/fs/f2fs/file.c b/fs/f2fs/file.c</span>
<span class="p_header">index 5f7317875a67..7ce13281925f 100644</span>
<span class="p_header">--- a/fs/f2fs/file.c</span>
<span class="p_header">+++ b/fs/f2fs/file.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
 		.nr_to_write = LONG_MAX,
 		.for_reclaim = 0,
 	};
<span class="p_add">+	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
 
 	if (unlikely(f2fs_readonly(inode-&gt;i_sb)))
 		return 0;
<span class="p_chunk">@@ -265,6 +266,8 @@</span> <span class="p_context"> static int f2fs_do_sync_file(struct file *file, loff_t start, loff_t end,</span>
 	}
 
 	ret = wait_on_node_pages_writeback(sbi, ino);
<span class="p_add">+	if (ret == 0)</span>
<span class="p_add">+		ret = filemap_check_wb_error(NODE_MAPPING(sbi), since);</span>
 	if (ret)
 		goto out;
 
<span class="p_header">diff --git a/fs/f2fs/node.c b/fs/f2fs/node.c</span>
<span class="p_header">index 481aa8dc79f4..b3ef9504fd8b 100644</span>
<span class="p_header">--- a/fs/f2fs/node.c</span>
<span class="p_header">+++ b/fs/f2fs/node.c</span>
<span class="p_chunk">@@ -1630,7 +1630,7 @@</span> <span class="p_context"> int wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)</span>
 {
 	pgoff_t index = 0, end = ULONG_MAX;
 	struct pagevec pvec;
<span class="p_del">-	int ret2, ret = 0;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	pagevec_init(&amp;pvec, 0);
 
<span class="p_chunk">@@ -1658,10 +1658,6 @@</span> <span class="p_context"> int wait_on_node_pages_writeback(struct f2fs_sb_info *sbi, nid_t ino)</span>
 		pagevec_release(&amp;pvec);
 		cond_resched();
 	}
<span class="p_del">-</span>
<span class="p_del">-	ret2 = filemap_check_errors(NODE_MAPPING(sbi));</span>
<span class="p_del">-	if (!ret)</span>
<span class="p_del">-		ret = ret2;</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index 07d0efcb050c..e1ced9cfb090 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -398,6 +398,7 @@</span> <span class="p_context"> static int fuse_flush(struct file *file, fl_owner_t id)</span>
 	struct fuse_req *req;
 	struct fuse_flush_in inarg;
 	int err;
<span class="p_add">+	errseq_t since = READ_ONCE(file-&gt;f_wb_err);</span>
 
 	if (is_bad_inode(inode))
 		return -EIO;
<span class="p_chunk">@@ -413,7 +414,7 @@</span> <span class="p_context"> static int fuse_flush(struct file *file, fl_owner_t id)</span>
 	fuse_sync_writes(inode);
 	inode_unlock(inode);
 
<span class="p_del">-	err = filemap_check_errors(file-&gt;f_mapping);</span>
<span class="p_add">+	err = filemap_check_wb_error(file-&gt;f_mapping, since);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -446,6 +447,7 @@</span> <span class="p_context"> int fuse_fsync_common(struct file *file, loff_t start, loff_t end,</span>
 	FUSE_ARGS(args);
 	struct fuse_fsync_in inarg;
 	int err;
<span class="p_add">+	errseq_t since;</span>
 
 	if (is_bad_inode(inode))
 		return -EIO;
<span class="p_chunk">@@ -461,6 +463,7 @@</span> <span class="p_context"> int fuse_fsync_common(struct file *file, loff_t start, loff_t end,</span>
 	if (err)
 		goto out;
 
<span class="p_add">+	since = READ_ONCE(file-&gt;f_wb_err);</span>
 	fuse_sync_writes(inode);
 
 	/*
<span class="p_chunk">@@ -468,7 +471,7 @@</span> <span class="p_context"> int fuse_fsync_common(struct file *file, loff_t start, loff_t end,</span>
 	 * filemap_write_and_wait_range() does not catch errors.
 	 * We have to do this directly after fuse_sync_writes()
 	 */
<span class="p_del">-	err = filemap_check_errors(file-&gt;f_mapping);</span>
<span class="p_add">+	err = filemap_check_wb_error(file-&gt;f_mapping, since);</span>
 	if (err)
 		goto out;
 
<span class="p_header">diff --git a/fs/libfs.c b/fs/libfs.c</span>
<span class="p_header">index efd23040ab25..23319d74fa42 100644</span>
<span class="p_header">--- a/fs/libfs.c</span>
<span class="p_header">+++ b/fs/libfs.c</span>
<span class="p_chunk">@@ -991,8 +991,10 @@</span> <span class="p_context"> int __generic_file_fsync(struct file *file, loff_t start, loff_t end,</span>
 
 out:
 	inode_unlock(inode);
<span class="p_del">-	err = filemap_check_errors(inode-&gt;i_mapping);</span>
<span class="p_del">-	return ret ? ret : err;</span>
<span class="p_add">+	if (!ret)</span>
<span class="p_add">+		ret = filemap_check_wb_error(inode-&gt;i_mapping,</span>
<span class="p_add">+						READ_ONCE(file-&gt;f_wb_err));</span>
<span class="p_add">+	return ret;</span>
 }
 EXPORT_SYMBOL(__generic_file_fsync);
 
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index bab3333e8671..e3068f3f69be 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -1739,12 +1739,6 @@</span> <span class="p_context"> static inline int call_mmap(struct file *file, struct vm_area_struct *vma)</span>
 	return file-&gt;f_op-&gt;mmap(file, vma);
 }
 
<span class="p_del">-static inline int call_fsync(struct file *file, loff_t start, loff_t end,</span>
<span class="p_del">-			     int datasync)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return file-&gt;f_op-&gt;fsync(file, start, end, datasync);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 ssize_t rw_copy_check_uvector(int type, const struct iovec __user * uvector,
 			      unsigned long nr_segs, unsigned long fast_segs,
 			      struct iovec *fast_pointer,
<span class="p_chunk">@@ -2512,6 +2506,8 @@</span> <span class="p_context"> extern int filemap_fdatawrite(struct address_space *);</span>
 extern int filemap_flush(struct address_space *);
 extern int filemap_fdatawait(struct address_space *);
 extern void filemap_fdatawait_keep_errors(struct address_space *);
<span class="p_add">+extern int filemap_fdatawait_range_since(struct address_space *, loff_t lstart,</span>
<span class="p_add">+				   loff_t lend, errseq_t since);</span>
 extern int filemap_fdatawait_range(struct address_space *, loff_t lstart,
 				   loff_t lend);
 extern int filemap_write_and_wait(struct address_space *mapping);
<span class="p_chunk">@@ -2521,7 +2517,6 @@</span> <span class="p_context"> extern int __filemap_fdatawrite_range(struct address_space *mapping,</span>
 				loff_t start, loff_t end, int sync_mode);
 extern int filemap_fdatawrite_range(struct address_space *mapping,
 				loff_t start, loff_t end);
<span class="p_del">-extern int filemap_check_errors(struct address_space *mapping);</span>
 extern int __must_check filemap_report_wb_error(struct file *file);
 
 /**
<span class="p_chunk">@@ -2544,6 +2539,16 @@</span> <span class="p_context"> static inline errseq_t filemap_sample_wb_error(struct address_space *mapping)</span>
 	return errseq_sample(&amp;mapping-&gt;wb_err);
 }
 
<span class="p_add">+static inline int call_fsync(struct file *file, loff_t start, loff_t end,</span>
<span class="p_add">+			     int datasync)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret, ret2;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = file-&gt;f_op-&gt;fsync(file, start, end, datasync);</span>
<span class="p_add">+	ret2 = filemap_report_wb_error(file);</span>
<span class="p_add">+	return ret ? ret : ret2;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern int vfs_fsync_range(struct file *file, loff_t start, loff_t end,
 			   int datasync);
 extern int vfs_fsync(struct file *file, int datasync);
<span class="p_header">diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h</span>
<span class="p_header">index 84943e8057ef..32512ffc15fa 100644</span>
<span class="p_header">--- a/include/linux/pagemap.h</span>
<span class="p_header">+++ b/include/linux/pagemap.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/hardirq.h&gt; /* for in_interrupt() */
 #include &lt;linux/hugetlb_inline.h&gt;
<span class="p_add">+#include &lt;linux/errseq.h&gt;</span>
 
 /*
  * Bits in mapping-&gt;flags.
<span class="p_chunk">@@ -30,12 +31,7 @@</span> <span class="p_context"> enum mapping_flags {</span>
 
 static inline void mapping_set_error(struct address_space *mapping, int error)
 {
<span class="p_del">-	if (unlikely(error)) {</span>
<span class="p_del">-		if (error == -ENOSPC)</span>
<span class="p_del">-			set_bit(AS_ENOSPC, &amp;mapping-&gt;flags);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			set_bit(AS_EIO, &amp;mapping-&gt;flags);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	return errseq_set(&amp;mapping-&gt;wb_err, error);</span>
 }
 
 static inline void mapping_set_unevictable(struct address_space *mapping)
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index ee1a798acfc1..eaec849ec8e5 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/memcontrol.h&gt;
 #include &lt;linux/cleancache.h&gt;
 #include &lt;linux/rmap.h&gt;
<span class="p_add">+#include &lt;linux/errseq.h&gt;</span>
 #include &quot;internal.h&quot;
 
 #define CREATE_TRACE_POINTS
<span class="p_chunk">@@ -295,20 +296,6 @@</span> <span class="p_context"> void delete_from_page_cache(struct page *page)</span>
 }
 EXPORT_SYMBOL(delete_from_page_cache);
 
<span class="p_del">-int filemap_check_errors(struct address_space *mapping)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	/* Check for outstanding write errors */</span>
<span class="p_del">-	if (test_bit(AS_ENOSPC, &amp;mapping-&gt;flags) &amp;&amp;</span>
<span class="p_del">-	    test_and_clear_bit(AS_ENOSPC, &amp;mapping-&gt;flags))</span>
<span class="p_del">-		ret = -ENOSPC;</span>
<span class="p_del">-	if (test_bit(AS_EIO, &amp;mapping-&gt;flags) &amp;&amp;</span>
<span class="p_del">-	    test_and_clear_bit(AS_EIO, &amp;mapping-&gt;flags))</span>
<span class="p_del">-		ret = -EIO;</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(filemap_check_errors);</span>
<span class="p_del">-</span>
 /**
  * __filemap_fdatawrite_range - start writeback on mapping dirty pages in range
  * @mapping:	address space structure to write
<span class="p_chunk">@@ -418,27 +405,32 @@</span> <span class="p_context"> static int __filemap_fdatawait_range(struct address_space *mapping,</span>
  * @mapping:		address space structure to wait for
  * @start_byte:		offset in bytes where the range starts
  * @end_byte:		offset in bytes where the range ends (inclusive)
<span class="p_add">+ * @since:		check for errors since this errseq_t</span>
  *
  * Walk the list of under-writeback pages of the given address space
  * in the given range and wait for all of them.  Check error status of
<span class="p_del">- * the address space and return it.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Since the error status of the address space is cleared by this function,</span>
<span class="p_del">- * callers are responsible for checking the return value and handling and/or</span>
<span class="p_del">- * reporting the error.</span>
<span class="p_add">+ * the address space vs. the since value and return it.</span>
  */
<span class="p_del">-int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,</span>
<span class="p_del">-			    loff_t end_byte)</span>
<span class="p_add">+int filemap_fdatawait_range_since(struct address_space *mapping,</span>
<span class="p_add">+		loff_t start_byte, loff_t end_byte, errseq_t since)</span>
 {
 	int ret, ret2;
 
 	ret = __filemap_fdatawait_range(mapping, start_byte, end_byte);
<span class="p_del">-	ret2 = filemap_check_errors(mapping);</span>
<span class="p_add">+	ret2 = filemap_check_wb_error(mapping, since);</span>
 	if (!ret)
 		ret = ret2;
 
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL(filemap_fdatawait_range_since);</span>
<span class="p_add">+</span>
<span class="p_add">+int filemap_fdatawait_range(struct address_space *mapping, loff_t start_byte,</span>
<span class="p_add">+			    loff_t end_byte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return filemap_fdatawait_range_since(mapping, start_byte, end_byte,</span>
<span class="p_add">+			filemap_sample_wb_error(mapping));</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(filemap_fdatawait_range);
 
 /**
<span class="p_chunk">@@ -489,6 +481,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(filemap_fdatawait);</span>
 int filemap_write_and_wait(struct address_space *mapping)
 {
 	int err = 0;
<span class="p_add">+	errseq_t since = filemap_sample_wb_error(mapping);</span>
 
 	if ((!dax_mapping(mapping) &amp;&amp; mapping-&gt;nrpages) ||
 	    (dax_mapping(mapping) &amp;&amp; mapping-&gt;nrexceptional)) {
<span class="p_chunk">@@ -500,12 +493,12 @@</span> <span class="p_context"> int filemap_write_and_wait(struct address_space *mapping)</span>
 		 * thing (e.g. bug) happened, so we avoid waiting for it.
 		 */
 		if (err != -EIO) {
<span class="p_del">-			int err2 = filemap_fdatawait(mapping);</span>
<span class="p_add">+			filemap_fdatawait_keep_errors(mapping);</span>
 			if (!err)
<span class="p_del">-				err = err2;</span>
<span class="p_add">+				err = filemap_check_wb_error(mapping, since);</span>
 		}
 	} else {
<span class="p_del">-		err = filemap_check_errors(mapping);</span>
<span class="p_add">+		err = filemap_check_wb_error(mapping, since);</span>
 	}
 	return err;
 }
<span class="p_chunk">@@ -526,6 +519,7 @@</span> <span class="p_context"> int filemap_write_and_wait_range(struct address_space *mapping,</span>
 				 loff_t lstart, loff_t lend)
 {
 	int err = 0;
<span class="p_add">+	errseq_t since = filemap_sample_wb_error(mapping);</span>
 
 	if ((!dax_mapping(mapping) &amp;&amp; mapping-&gt;nrpages) ||
 	    (dax_mapping(mapping) &amp;&amp; mapping-&gt;nrexceptional)) {
<span class="p_chunk">@@ -533,13 +527,12 @@</span> <span class="p_context"> int filemap_write_and_wait_range(struct address_space *mapping,</span>
 						 WB_SYNC_ALL);
 		/* See comment of filemap_write_and_wait() */
 		if (err != -EIO) {
<span class="p_del">-			int err2 = filemap_fdatawait_range(mapping,</span>
<span class="p_del">-						lstart, lend);</span>
<span class="p_add">+			__filemap_fdatawait_range(mapping, lstart, lend);</span>
 			if (!err)
<span class="p_del">-				err = err2;</span>
<span class="p_add">+				err = filemap_check_wb_error(mapping, since);</span>
 		}
 	} else {
<span class="p_del">-		err = filemap_check_errors(mapping);</span>
<span class="p_add">+		err = filemap_check_wb_error(mapping, since);</span>
 	}
 	return err;
 }

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



