
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[1/3] mm: page_alloc: Reduce object size by neatening printks - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [1/3] mm: page_alloc: Reduce object size by neatening printks</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=325">Joe Perches</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 16, 2017, 1:43 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;880b3172b67d806082284d80945e4a231a5574bb.1489628459.git.joe@perches.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9626893/mbox/"
   >mbox</a>
|
   <a href="/patch/9626893/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9626893/">/patch/9626893/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	9A71860244 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Mar 2017 01:44:42 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 8C10C28511
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Mar 2017 01:44:42 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 800E528616; Thu, 16 Mar 2017 01:44:42 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 84F4D28511
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 16 Mar 2017 01:44:41 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751302AbdCPBoZ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 15 Mar 2017 21:44:25 -0400
Received: from smtprelay0136.hostedemail.com ([216.40.44.136]:57163 &quot;EHLO
	smtprelay.hostedemail.com&quot; rhost-flags-OK-OK-OK-FAIL)
	by vger.kernel.org with ESMTP id S1750909AbdCPBnn (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 15 Mar 2017 21:43:43 -0400
Received: from filter.hostedemail.com (clb03-v110.bra.tucows.net
	[216.40.38.60])
	by smtprelay06.hostedemail.com (Postfix) with ESMTP id 85E7B9EA11;
	Thu, 16 Mar 2017 01:43:35 +0000 (UTC)
X-Session-Marker: 6A6F6540706572636865732E636F6D
X-HE-Tag: fowl70_591535b4e8a62
X-Filterd-Recvd-Size: 13539
Received: from joe-laptop.perches.com (unknown [172.56.13.115])
	(Authenticated sender: joe@perches.com)
	by omf05.hostedemail.com (Postfix) with ESMTPA;
	Thu, 16 Mar 2017 01:43:31 +0000 (UTC)
From: Joe Perches &lt;joe@perches.com&gt;
To: Andrew Morton &lt;akpm@linux-foundation.org&gt;, linux-kernel@vger.kernel.org
Cc: linux-mm@kvack.org
Subject: [PATCH 1/3] mm: page_alloc: Reduce object size by neatening printks
Date: Wed, 15 Mar 2017 18:43:13 -0700
Message-Id: &lt;880b3172b67d806082284d80945e4a231a5574bb.1489628459.git.joe@perches.com&gt;
X-Mailer: git-send-email 2.10.0.rc2.1.g053435c
In-Reply-To: &lt;cover.1489628459.git.joe@perches.com&gt;
References: &lt;cover.1489628459.git.joe@perches.com&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=325">Joe Perches</a> - March 16, 2017, 1:43 a.m.</div>
<pre class="content">
Function calls with large argument counts cause x86-64 register
spilling.  Reducing the number of arguments in a multi-line printk
by converting to multiple printks which saves some object code size.

$ size mm/page_alloc.o* (defconfig)
   text    data     bss     dec     hex filename
  35914	   1699	    628	  38241	   9561	mm/page_alloc.o.new
  36018    1699     628   38345    95c9 mm/page_alloc.o.old

Miscellanea:

o Remove line leading spaces from the formerly multi-line printks
  commit a25700a53f71 (&quot;mm: show bounce pages in oom killer output&quot;)
  back in 2007 started the leading space when a single long line
  was split into multiple lines but the leading space was likely
  mistakenly kept and subsequent commits followed suit.
o Align arguments in a few more printks
<span class="signed-off-by">
Signed-off-by: Joe Perches &lt;joe@perches.com&gt;</span>
---
 mm/page_alloc.c | 237 ++++++++++++++++++++++++++++----------------------------
 1 file changed, 118 insertions(+), 119 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - March 16, 2017, 10:56 a.m.</div>
<pre class="content">
On Wed 15-03-17 18:43:13, Joe Perches wrote:
<span class="quote">&gt; Function calls with large argument counts cause x86-64 register</span>
<span class="quote">&gt; spilling.  Reducing the number of arguments in a multi-line printk</span>
<span class="quote">&gt; by converting to multiple printks which saves some object code size.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; $ size mm/page_alloc.o* (defconfig)</span>
<span class="quote">&gt;    text    data     bss     dec     hex filename</span>
<span class="quote">&gt;   35914	   1699	    628	  38241	   9561	mm/page_alloc.o.new</span>
<span class="quote">&gt;   36018    1699     628   38345    95c9 mm/page_alloc.o.old</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Miscellanea:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; o Remove line leading spaces from the formerly multi-line printks</span>
<span class="quote">&gt;   commit a25700a53f71 (&quot;mm: show bounce pages in oom killer output&quot;)</span>
<span class="quote">&gt;   back in 2007 started the leading space when a single long line</span>
<span class="quote">&gt;   was split into multiple lines but the leading space was likely</span>
<span class="quote">&gt;   mistakenly kept and subsequent commits followed suit.</span>
<span class="quote">&gt; o Align arguments in a few more printks</span>

This is really hard to review. Could you just drop all the whitespace
changes please?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=121341">Sergey Senozhatsky</a> - March 16, 2017, 11:30 a.m.</div>
<pre class="content">
On (03/15/17 18:43), Joe Perches wrote:
[..]
<span class="quote">&gt; -	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;</span>
<span class="quote">&gt; -		&quot; active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;</span>
<span class="quote">&gt; -		&quot; unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;</span>
<span class="quote">&gt; -		&quot; slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;</span>
<span class="quote">&gt; -		&quot; mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;</span>
<span class="quote">&gt; -		&quot; free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; -		global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; -		global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; -		global_node_page_state(NR_ISOLATED_ANON),</span>
<span class="quote">&gt; -		global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; -		global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; -		global_node_page_state(NR_ISOLATED_FILE),</span>
<span class="quote">&gt; -		global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; -		global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; -		global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; -		global_node_page_state(NR_UNSTABLE_NFS),</span>
<span class="quote">&gt; -		global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; -		global_page_state(NR_SLAB_UNRECLAIMABLE),</span>
<span class="quote">&gt; -		global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; -		global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; -		global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; -		global_page_state(NR_BOUNCE),</span>
<span class="quote">&gt; -		global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; -		free_pcp,</span>
<span class="quote">&gt; -		global_page_state(NR_FREE_CMA_PAGES));</span>
<span class="quote">&gt; +	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;,</span>
<span class="quote">&gt; +	       global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_ISOLATED_ANON));</span>
<span class="quote">&gt; +	printk(&quot;active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;,</span>
<span class="quote">&gt; +	       global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_ISOLATED_FILE));</span>
<span class="quote">&gt; +	printk(&quot;unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;,</span>
<span class="quote">&gt; +	       global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_UNSTABLE_NFS));</span>
<span class="quote">&gt; +	printk(&quot;slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;,</span>
<span class="quote">&gt; +	       global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; +	       global_page_state(NR_SLAB_UNRECLAIMABLE));</span>
<span class="quote">&gt; +	printk(&quot;mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;,</span>
<span class="quote">&gt; +	       global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; +	       global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; +	       global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; +	       global_page_state(NR_BOUNCE));</span>
<span class="quote">&gt; +	printk(&quot;free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; +	       global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; +	       free_pcp,</span>
<span class="quote">&gt; +	       global_page_state(NR_FREE_CMA_PAGES));</span>

a side note:

this can make it harder to read, in _the worst case_. one printk()
guaranteed that we would see a single line in the serial log/etc.
the sort of a problem with multiple printks is that printks coming
from other CPUs will split that &quot;previously single&quot; line.

just a notice. up to MM people to decide.

	-ss
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=325">Joe Perches</a> - March 16, 2017, 6:37 p.m.</div>
<pre class="content">
On Thu, 2017-03-16 at 20:30 +0900, Sergey Senozhatsky wrote:
<span class="quote">&gt; On (03/15/17 18:43), Joe Perches wrote:</span>
<span class="quote">&gt; [..]</span>
<span class="quote">&gt; &gt; -	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;</span>
<span class="quote">&gt; &gt; -		&quot; active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;</span>
<span class="quote">&gt; &gt; -		&quot; unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; -		&quot; slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; -		&quot; mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;</span>
<span class="quote">&gt; &gt; -		&quot; free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_ISOLATED_ANON),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_ISOLATED_FILE),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_UNSTABLE_NFS),</span>
<span class="quote">&gt; &gt; -		global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; &gt; -		global_page_state(NR_SLAB_UNRECLAIMABLE),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; &gt; -		global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; &gt; -		global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; &gt; -		global_page_state(NR_BOUNCE),</span>
<span class="quote">&gt; &gt; -		global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; &gt; -		free_pcp,</span>
<span class="quote">&gt; &gt; -		global_page_state(NR_FREE_CMA_PAGES));</span>
<span class="quote">&gt; &gt; +	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_ISOLATED_ANON));</span>
<span class="quote">&gt; &gt; +	printk(&quot;active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_ISOLATED_FILE));</span>
<span class="quote">&gt; &gt; +	printk(&quot;unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_UNSTABLE_NFS));</span>
<span class="quote">&gt; &gt; +	printk(&quot;slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; +	       global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; &gt; +	       global_page_state(NR_SLAB_UNRECLAIMABLE));</span>
<span class="quote">&gt; &gt; +	printk(&quot;mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; &gt; +	       global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; &gt; +	       global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; &gt; +	       global_page_state(NR_BOUNCE));</span>
<span class="quote">&gt; &gt; +	printk(&quot;free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; +	       global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; &gt; +	       free_pcp,</span>
<span class="quote">&gt; &gt; +	       global_page_state(NR_FREE_CMA_PAGES));</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; a side note:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; this can make it harder to read, in _the worst case_. one printk()</span>
<span class="quote">&gt; guaranteed that we would see a single line in the serial log/etc.</span>
<span class="quote">&gt; the sort of a problem with multiple printks is that printks coming</span>
<span class="quote">&gt; from other CPUs will split that &quot;previously single&quot; line.</span>

Not true.  Note the multiple \n uses in the original code.
<span class="quote">
&gt; just a notice. up to MM people to decide.</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=325">Joe Perches</a> - March 16, 2017, 8:32 p.m.</div>
<pre class="content">
On Thu, 2017-03-16 at 11:56 +0100, Michal Hocko wrote:
<span class="quote">&gt; On Wed 15-03-17 18:43:13, Joe Perches wrote:</span>
<span class="quote">&gt; &gt; Function calls with large argument counts cause x86-64 register</span>
<span class="quote">&gt; &gt; spilling.  Reducing the number of arguments in a multi-line printk</span>
<span class="quote">&gt; &gt; by converting to multiple printks which saves some object code size.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; $ size mm/page_alloc.o* (defconfig)</span>
<span class="quote">&gt; &gt;    text    data     bss     dec     hex filename</span>
<span class="quote">&gt; &gt;   35914	   1699	    628	  38241	   9561	mm/page_alloc.o.new</span>
<span class="quote">&gt; &gt;   36018    1699     628   38345    95c9 mm/page_alloc.o.old</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Miscellanea:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; o Remove line leading spaces from the formerly multi-line printks</span>
<span class="quote">&gt; &gt;   commit a25700a53f71 (&quot;mm: show bounce pages in oom killer output&quot;)</span>
<span class="quote">&gt; &gt;   back in 2007 started the leading space when a single long line</span>
<span class="quote">&gt; &gt;   was split into multiple lines but the leading space was likely</span>
<span class="quote">&gt; &gt;   mistakenly kept and subsequent commits followed suit.</span>
<span class="quote">&gt; &gt; o Align arguments in a few more printks</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is really hard to review. Could you just drop all the whitespace</span>
<span class="quote">&gt; changes please?</span>

It&#39;s a single, simple change.  It&#39;s IMO trivial to review.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=41">Andrew Morton</a> - March 16, 2017, 10:53 p.m.</div>
<pre class="content">
On Thu, 16 Mar 2017 11:37:56 -0700 Joe Perches &lt;joe@perches.com&gt; wrote:
<span class="quote">
&gt; &gt; this can make it harder to read, in _the worst case_. one printk()</span>
<span class="quote">&gt; &gt; guaranteed that we would see a single line in the serial log/etc.</span>
<span class="quote">&gt; &gt; the sort of a problem with multiple printks is that printks coming</span>
<span class="quote">&gt; &gt; from other CPUs will split that &quot;previously single&quot; line.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Not true.  Note the multiple \n uses in the original code.</span>

hm?  Won&#39;t printk(&quot;a\na&quot;) atomically emit all three chars into the log
buffer?
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=121341">Sergey Senozhatsky</a> - March 17, 2017, 1:56 a.m.</div>
<pre class="content">
On (03/16/17 11:37), Joe Perches wrote:
<span class="quote">&gt; On Thu, 2017-03-16 at 20:30 +0900, Sergey Senozhatsky wrote:</span>
<span class="quote">&gt; &gt; On (03/15/17 18:43), Joe Perches wrote:</span>
<span class="quote">&gt; &gt; [..]</span>
<span class="quote">&gt; &gt; &gt; -	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; -		&quot; active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; -		&quot; unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; -		&quot; slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; -		&quot; mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; -		&quot; free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_ISOLATED_ANON),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_ISOLATED_FILE),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_UNSTABLE_NFS),</span>
<span class="quote">&gt; &gt; &gt; -		global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; &gt; &gt; -		global_page_state(NR_SLAB_UNRECLAIMABLE),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; &gt; &gt; -		global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; &gt; &gt; -		global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; &gt; &gt; -		global_page_state(NR_BOUNCE),</span>
<span class="quote">&gt; &gt; &gt; -		global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; &gt; &gt; -		free_pcp,</span>
<span class="quote">&gt; &gt; &gt; -		global_page_state(NR_FREE_CMA_PAGES));</span>
<span class="quote">&gt; &gt; &gt; +	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_ISOLATED_ANON));</span>
<span class="quote">&gt; &gt; &gt; +	printk(&quot;active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_ISOLATED_FILE));</span>
<span class="quote">&gt; &gt; &gt; +	printk(&quot;unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_UNSTABLE_NFS));</span>
<span class="quote">&gt; &gt; &gt; +	printk(&quot;slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; +	       global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; &gt; &gt; +	       global_page_state(NR_SLAB_UNRECLAIMABLE));</span>
<span class="quote">&gt; &gt; &gt; +	printk(&quot;mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; &gt; &gt; +	       global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; &gt; &gt; +	       global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; &gt; &gt; +	       global_page_state(NR_BOUNCE));</span>
<span class="quote">&gt; &gt; &gt; +	printk(&quot;free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; +	       global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; &gt; &gt; +	       free_pcp,</span>
<span class="quote">&gt; &gt; &gt; +	       global_page_state(NR_FREE_CMA_PAGES));</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; a side note:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; this can make it harder to read, in _the worst case_. one printk()</span>
<span class="quote">&gt; &gt; guaranteed that we would see a single line in the serial log/etc.</span>
<span class="quote">&gt; &gt; the sort of a problem with multiple printks is that printks coming</span>
<span class="quote">&gt; &gt; from other CPUs will split that &quot;previously single&quot; line.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Not true.  Note the multiple \n uses in the original code.</span>

one printk call ends up in logbuf as a single entry and, thus, we print
it to the serial console in one shot (what is the correct english word
to use here?). multiple printks result in multiple logbuf entries, and
printks from other CPUs can mix in.

so the difference is:


	CPU0						CPU1
							printk(foo\n)
printk(..isolated_anon\n...isolated_file\n...)
							printk(bar\n)

vs

	CPU0						CPU1
printk(..isolated_anon\n)
							printk(foo\n)
printk(...isolated_file\n)
							printk(bar\n)
printk(...\n)

not the same thing.

and the slower the serial console is the more messages potentially
can appear between &quot;..isolated_anon\n&quot; and &quot;...isolated_file\n&quot;.

	-ss
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - March 17, 2017, 7:39 a.m.</div>
<pre class="content">
On Thu 16-03-17 13:32:23, Joe Perches wrote:
<span class="quote">&gt; On Thu, 2017-03-16 at 11:56 +0100, Michal Hocko wrote:</span>
<span class="quote">&gt; &gt; On Wed 15-03-17 18:43:13, Joe Perches wrote:</span>
<span class="quote">&gt; &gt; &gt; Function calls with large argument counts cause x86-64 register</span>
<span class="quote">&gt; &gt; &gt; spilling.  Reducing the number of arguments in a multi-line printk</span>
<span class="quote">&gt; &gt; &gt; by converting to multiple printks which saves some object code size.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; $ size mm/page_alloc.o* (defconfig)</span>
<span class="quote">&gt; &gt; &gt;    text    data     bss     dec     hex filename</span>
<span class="quote">&gt; &gt; &gt;   35914	   1699	    628	  38241	   9561	mm/page_alloc.o.new</span>
<span class="quote">&gt; &gt; &gt;   36018    1699     628   38345    95c9 mm/page_alloc.o.old</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Miscellanea:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; o Remove line leading spaces from the formerly multi-line printks</span>
<span class="quote">&gt; &gt; &gt;   commit a25700a53f71 (&quot;mm: show bounce pages in oom killer output&quot;)</span>
<span class="quote">&gt; &gt; &gt;   back in 2007 started the leading space when a single long line</span>
<span class="quote">&gt; &gt; &gt;   was split into multiple lines but the leading space was likely</span>
<span class="quote">&gt; &gt; &gt;   mistakenly kept and subsequent commits followed suit.</span>
<span class="quote">&gt; &gt; &gt; o Align arguments in a few more printks</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; This is really hard to review. Could you just drop all the whitespace</span>
<span class="quote">&gt; &gt; changes please?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s a single, simple change. </span>

no it adds a lot of whitespace noise to an actual change. It takes to
check every single line to see whether some typo or unintended change
has been made.
<span class="quote">
&gt; It&#39;s IMO trivial to review.</span>

it&#39;s not IMNSHO.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=325">Joe Perches</a> - March 18, 2017, 7:31 p.m.</div>
<pre class="content">
(adding Petr and Steven to cc&#39;s)

On Fri, 2017-03-17 at 10:56 +0900, Sergey Senozhatsky wrote:
<span class="quote">&gt; On (03/16/17 11:37), Joe Perches wrote:</span>
<span class="quote">&gt; &gt; On Thu, 2017-03-16 at 20:30 +0900, Sergey Senozhatsky wrote:</span>
<span class="quote">&gt; &gt; &gt; On (03/15/17 18:43), Joe Perches wrote:</span>
<span class="quote">&gt; &gt; &gt; [..]</span>
<span class="quote">&gt; &gt; &gt; &gt; -	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; -		&quot; active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; -		&quot; unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; -		&quot; slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; -		&quot; mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; -		&quot; free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_ISOLATED_ANON),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_ISOLATED_FILE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_UNSTABLE_NFS),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_page_state(NR_SLAB_UNRECLAIMABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_page_state(NR_BOUNCE),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; &gt; &gt; &gt; -		free_pcp,</span>
<span class="quote">&gt; &gt; &gt; &gt; -		global_page_state(NR_FREE_CMA_PAGES));</span>
[]
<span class="quote">&gt; &gt; &gt; &gt; a side note:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; this can make it harder to read, in _the worst case_. one printk()</span>
<span class="quote">&gt; &gt; &gt; guaranteed that we would see a single line in the serial log/etc.</span>
<span class="quote">&gt; &gt; &gt; the sort of a problem with multiple printks is that printks coming</span>
<span class="quote">&gt; &gt; &gt; from other CPUs will split that &quot;previously single&quot; line.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Not true.  Note the multiple \n uses in the original code.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; one printk call ends up in logbuf as a single entry and, thus, we print</span>
<span class="quote">&gt; it to the serial console in one shot (what is the correct english word</span>
<span class="quote">&gt; to use here?). multiple printks result in multiple logbuf entries, and</span>
<span class="quote">&gt; printks from other CPUs can mix in.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; so the difference is:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	CPU0						CPU1</span>
<span class="quote">&gt; 							printk(foo\n)</span>
<span class="quote">&gt; printk(..isolated_anon\n...isolated_file\n...)</span>
<span class="quote">&gt; 							printk(bar\n)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; vs</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; 	CPU0						CPU1</span>
<span class="quote">&gt; printk(..isolated_anon\n)</span>
<span class="quote">&gt; 							printk(foo\n)</span>
<span class="quote">&gt; printk(...isolated_file\n)</span>
<span class="quote">&gt; 							printk(bar\n)</span>
<span class="quote">&gt; printk(...\n)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; not the same thing.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; and the slower the serial console is the more messages potentially</span>
<span class="quote">&gt; can appear between &quot;..isolated_anon\n&quot; and &quot;...isolated_file\n&quot;.</span>

Right.  For the definition of &quot;single line&quot;, meaning &quot;contiguous
block&quot; and not single line.

Perhaps there would be some value in having a generic mechanism
for the dump_stack use of &quot;atomic_t dump_lock&quot;, where a thread
can grab exclusive use of the printk subsystem for a short period
to keep messages from being interleaved by other processes.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=136541">Petr Mladek</a> - March 20, 2017, 1 p.m.</div>
<pre class="content">
On Sat 2017-03-18 12:31:35, Joe Perches wrote:
<span class="quote">&gt; (adding Petr and Steven to cc&#39;s)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Fri, 2017-03-17 at 10:56 +0900, Sergey Senozhatsky wrote:</span>
<span class="quote">&gt; &gt; On (03/16/17 11:37), Joe Perches wrote:</span>
<span class="quote">&gt; &gt; &gt; On Thu, 2017-03-16 at 20:30 +0900, Sergey Senozhatsky wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On (03/15/17 18:43), Joe Perches wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; [..]</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		&quot; active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		&quot; unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		&quot; slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		&quot; mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		&quot; free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_ISOLATED_ANON),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_ISOLATED_FILE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_UNEVICTABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_FILE_DIRTY),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_WRITEBACK),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_UNSTABLE_NFS),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_page_state(NR_SLAB_UNRECLAIMABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_FILE_MAPPED),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_node_page_state(NR_SHMEM),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_page_state(NR_PAGETABLE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_page_state(NR_BOUNCE),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_page_state(NR_FREE_PAGES),</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		free_pcp,</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; -		global_page_state(NR_FREE_CMA_PAGES));</span>
<span class="quote">&gt; []</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; a side note:</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; this can make it harder to read, in _the worst case_. one printk()</span>
<span class="quote">&gt; &gt; &gt; &gt; guaranteed that we would see a single line in the serial log/etc.</span>
<span class="quote">&gt; &gt; &gt; &gt; the sort of a problem with multiple printks is that printks coming</span>
<span class="quote">&gt; &gt; &gt; &gt; from other CPUs will split that &quot;previously single&quot; line.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Not true.  Note the multiple \n uses in the original code.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; one printk call ends up in logbuf as a single entry and, thus, we print</span>
<span class="quote">&gt; &gt; it to the serial console in one shot (what is the correct english word</span>
<span class="quote">&gt; &gt; to use here?). multiple printks result in multiple logbuf entries, and</span>
<span class="quote">&gt; &gt; printks from other CPUs can mix in.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; so the difference is:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 	CPU0						CPU1</span>
<span class="quote">&gt; &gt; 							printk(foo\n)</span>
<span class="quote">&gt; &gt; printk(..isolated_anon\n...isolated_file\n...)</span>
<span class="quote">&gt; &gt; 							printk(bar\n)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; vs</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; 	CPU0						CPU1</span>
<span class="quote">&gt; &gt; printk(..isolated_anon\n)</span>
<span class="quote">&gt; &gt; 							printk(foo\n)</span>
<span class="quote">&gt; &gt; printk(...isolated_file\n)</span>
<span class="quote">&gt; &gt; 							printk(bar\n)</span>
<span class="quote">&gt; &gt; printk(...\n)</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; not the same thing.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; and the slower the serial console is the more messages potentially</span>
<span class="quote">&gt; &gt; can appear between &quot;..isolated_anon\n&quot; and &quot;...isolated_file\n&quot;.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Right.  For the definition of &quot;single line&quot;, meaning &quot;contiguous</span>
<span class="quote">&gt; block&quot; and not single line.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Perhaps there would be some value in having a generic mechanism</span>
<span class="quote">&gt; for the dump_stack use of &quot;atomic_t dump_lock&quot;, where a thread</span>
<span class="quote">&gt; can grab exclusive use of the printk subsystem for a short period</span>
<span class="quote">&gt; to keep messages from being interleaved by other processes.</span>

This sounds a bit scary to me. A globally blocking chain of
printk() calls might open another can of deadlocks. Also, IMHO,
dumping stack is a non-trivial operation, especially when
we need to read debuginfo.

Another solution would be to somehow reuse the per-CPU buffers
used by vprintk_safe(). An API for buffering printk messages
would be useful also for continuous lines. But this need to
be well designed.

Anyway, this should probably be discussed separately. We are too
far from the original problem. The fact is that printk() does
not prevent interleaving lines from different CPUs and probably
won&#39;t be in a near future. I am not sure in which situations
the affected messages are printed and if such an interleaving
is probable or not.

Best Regards,
Petr
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/mm/page_alloc.c b/mm/page_alloc.c</span>
<span class="p_header">index f749b7ff7c50..5db9710cb932 100644</span>
<span class="p_header">--- a/mm/page_alloc.c</span>
<span class="p_header">+++ b/mm/page_alloc.c</span>
<span class="p_chunk">@@ -4505,79 +4505,79 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
 			free_pcp += per_cpu_ptr(zone-&gt;pageset, cpu)-&gt;pcp.count;
 	}
 
<span class="p_del">-	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;</span>
<span class="p_del">-		&quot; active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;</span>
<span class="p_del">-		&quot; unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;</span>
<span class="p_del">-		&quot; slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;</span>
<span class="p_del">-		&quot; mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;</span>
<span class="p_del">-		&quot; free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="p_del">-		global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="p_del">-		global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="p_del">-		global_node_page_state(NR_ISOLATED_ANON),</span>
<span class="p_del">-		global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="p_del">-		global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="p_del">-		global_node_page_state(NR_ISOLATED_FILE),</span>
<span class="p_del">-		global_node_page_state(NR_UNEVICTABLE),</span>
<span class="p_del">-		global_node_page_state(NR_FILE_DIRTY),</span>
<span class="p_del">-		global_node_page_state(NR_WRITEBACK),</span>
<span class="p_del">-		global_node_page_state(NR_UNSTABLE_NFS),</span>
<span class="p_del">-		global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="p_del">-		global_page_state(NR_SLAB_UNRECLAIMABLE),</span>
<span class="p_del">-		global_node_page_state(NR_FILE_MAPPED),</span>
<span class="p_del">-		global_node_page_state(NR_SHMEM),</span>
<span class="p_del">-		global_page_state(NR_PAGETABLE),</span>
<span class="p_del">-		global_page_state(NR_BOUNCE),</span>
<span class="p_del">-		global_page_state(NR_FREE_PAGES),</span>
<span class="p_del">-		free_pcp,</span>
<span class="p_del">-		global_page_state(NR_FREE_CMA_PAGES));</span>
<span class="p_add">+	printk(&quot;active_anon:%lu inactive_anon:%lu isolated_anon:%lu\n&quot;,</span>
<span class="p_add">+	       global_node_page_state(NR_ACTIVE_ANON),</span>
<span class="p_add">+	       global_node_page_state(NR_INACTIVE_ANON),</span>
<span class="p_add">+	       global_node_page_state(NR_ISOLATED_ANON));</span>
<span class="p_add">+	printk(&quot;active_file:%lu inactive_file:%lu isolated_file:%lu\n&quot;,</span>
<span class="p_add">+	       global_node_page_state(NR_ACTIVE_FILE),</span>
<span class="p_add">+	       global_node_page_state(NR_INACTIVE_FILE),</span>
<span class="p_add">+	       global_node_page_state(NR_ISOLATED_FILE));</span>
<span class="p_add">+	printk(&quot;unevictable:%lu dirty:%lu writeback:%lu unstable:%lu\n&quot;,</span>
<span class="p_add">+	       global_node_page_state(NR_UNEVICTABLE),</span>
<span class="p_add">+	       global_node_page_state(NR_FILE_DIRTY),</span>
<span class="p_add">+	       global_node_page_state(NR_WRITEBACK),</span>
<span class="p_add">+	       global_node_page_state(NR_UNSTABLE_NFS));</span>
<span class="p_add">+	printk(&quot;slab_reclaimable:%lu slab_unreclaimable:%lu\n&quot;,</span>
<span class="p_add">+	       global_page_state(NR_SLAB_RECLAIMABLE),</span>
<span class="p_add">+	       global_page_state(NR_SLAB_UNRECLAIMABLE));</span>
<span class="p_add">+	printk(&quot;mapped:%lu shmem:%lu pagetables:%lu bounce:%lu\n&quot;,</span>
<span class="p_add">+	       global_node_page_state(NR_FILE_MAPPED),</span>
<span class="p_add">+	       global_node_page_state(NR_SHMEM),</span>
<span class="p_add">+	       global_page_state(NR_PAGETABLE),</span>
<span class="p_add">+	       global_page_state(NR_BOUNCE));</span>
<span class="p_add">+	printk(&quot;free:%lu free_pcp:%lu free_cma:%lu\n&quot;,</span>
<span class="p_add">+	       global_page_state(NR_FREE_PAGES),</span>
<span class="p_add">+	       free_pcp,</span>
<span class="p_add">+	       global_page_state(NR_FREE_CMA_PAGES));</span>
 
 	for_each_online_pgdat(pgdat) {
 		if (show_mem_node_skip(filter, pgdat-&gt;node_id, nodemask))
 			continue;
 
 		printk(&quot;Node %d&quot;
<span class="p_del">-			&quot; active_anon:%lukB&quot;</span>
<span class="p_del">-			&quot; inactive_anon:%lukB&quot;</span>
<span class="p_del">-			&quot; active_file:%lukB&quot;</span>
<span class="p_del">-			&quot; inactive_file:%lukB&quot;</span>
<span class="p_del">-			&quot; unevictable:%lukB&quot;</span>
<span class="p_del">-			&quot; isolated(anon):%lukB&quot;</span>
<span class="p_del">-			&quot; isolated(file):%lukB&quot;</span>
<span class="p_del">-			&quot; mapped:%lukB&quot;</span>
<span class="p_del">-			&quot; dirty:%lukB&quot;</span>
<span class="p_del">-			&quot; writeback:%lukB&quot;</span>
<span class="p_del">-			&quot; shmem:%lukB&quot;</span>
<span class="p_add">+		       &quot; active_anon:%lukB&quot;</span>
<span class="p_add">+		       &quot; inactive_anon:%lukB&quot;</span>
<span class="p_add">+		       &quot; active_file:%lukB&quot;</span>
<span class="p_add">+		       &quot; inactive_file:%lukB&quot;</span>
<span class="p_add">+		       &quot; unevictable:%lukB&quot;</span>
<span class="p_add">+		       &quot; isolated(anon):%lukB&quot;</span>
<span class="p_add">+		       &quot; isolated(file):%lukB&quot;</span>
<span class="p_add">+		       &quot; mapped:%lukB&quot;</span>
<span class="p_add">+		       &quot; dirty:%lukB&quot;</span>
<span class="p_add">+		       &quot; writeback:%lukB&quot;</span>
<span class="p_add">+		       &quot; shmem:%lukB&quot;</span>
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_del">-			&quot; shmem_thp: %lukB&quot;</span>
<span class="p_del">-			&quot; shmem_pmdmapped: %lukB&quot;</span>
<span class="p_del">-			&quot; anon_thp: %lukB&quot;</span>
<span class="p_add">+		       &quot; shmem_thp: %lukB&quot;</span>
<span class="p_add">+		       &quot; shmem_pmdmapped: %lukB&quot;</span>
<span class="p_add">+		       &quot; anon_thp: %lukB&quot;</span>
 #endif
<span class="p_del">-			&quot; writeback_tmp:%lukB&quot;</span>
<span class="p_del">-			&quot; unstable:%lukB&quot;</span>
<span class="p_del">-			&quot; all_unreclaimable? %s&quot;</span>
<span class="p_del">-			&quot;\n&quot;,</span>
<span class="p_del">-			pgdat-&gt;node_id,</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ISOLATED_ANON)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ISOLATED_FILE)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_WRITEBACK)),</span>
<span class="p_add">+		       &quot; writeback_tmp:%lukB&quot;</span>
<span class="p_add">+		       &quot; unstable:%lukB&quot;</span>
<span class="p_add">+		       &quot; all_unreclaimable? %s&quot;</span>
<span class="p_add">+		       &quot;\n&quot;,</span>
<span class="p_add">+		       pgdat-&gt;node_id,</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_ACTIVE_ANON)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_INACTIVE_ANON)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_ACTIVE_FILE)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_INACTIVE_FILE)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_UNEVICTABLE)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_ISOLATED_ANON)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_ISOLATED_FILE)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_FILE_MAPPED)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_FILE_DIRTY)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_WRITEBACK)),</span>
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_del">-			K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)</span>
<span class="p_del">-					* HPAGE_PMD_NR),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_SHMEM_THPS) * HPAGE_PMD_NR),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_SHMEM_PMDMAPPED)</span>
<span class="p_add">+			 * HPAGE_PMD_NR),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_ANON_THPS) * HPAGE_PMD_NR),</span>
 #endif
<span class="p_del">-			K(node_page_state(pgdat, NR_SHMEM)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="p_del">-			K(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="p_del">-			pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES ?</span>
<span class="p_del">-				&quot;yes&quot; : &quot;no&quot;);</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_SHMEM)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_WRITEBACK_TEMP)),</span>
<span class="p_add">+		       K(node_page_state(pgdat, NR_UNSTABLE_NFS)),</span>
<span class="p_add">+		       pgdat-&gt;kswapd_failures &gt;= MAX_RECLAIM_RETRIES ?</span>
<span class="p_add">+		       &quot;yes&quot; : &quot;no&quot;);</span>
 	}
 
 	for_each_populated_zone(zone) {
<span class="p_chunk">@@ -4592,51 +4592,51 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
 
 		show_node(zone);
 		printk(KERN_CONT
<span class="p_del">-			&quot;%s&quot;</span>
<span class="p_del">-			&quot; free:%lukB&quot;</span>
<span class="p_del">-			&quot; min:%lukB&quot;</span>
<span class="p_del">-			&quot; low:%lukB&quot;</span>
<span class="p_del">-			&quot; high:%lukB&quot;</span>
<span class="p_del">-			&quot; active_anon:%lukB&quot;</span>
<span class="p_del">-			&quot; inactive_anon:%lukB&quot;</span>
<span class="p_del">-			&quot; active_file:%lukB&quot;</span>
<span class="p_del">-			&quot; inactive_file:%lukB&quot;</span>
<span class="p_del">-			&quot; unevictable:%lukB&quot;</span>
<span class="p_del">-			&quot; writepending:%lukB&quot;</span>
<span class="p_del">-			&quot; present:%lukB&quot;</span>
<span class="p_del">-			&quot; managed:%lukB&quot;</span>
<span class="p_del">-			&quot; mlocked:%lukB&quot;</span>
<span class="p_del">-			&quot; slab_reclaimable:%lukB&quot;</span>
<span class="p_del">-			&quot; slab_unreclaimable:%lukB&quot;</span>
<span class="p_del">-			&quot; kernel_stack:%lukB&quot;</span>
<span class="p_del">-			&quot; pagetables:%lukB&quot;</span>
<span class="p_del">-			&quot; bounce:%lukB&quot;</span>
<span class="p_del">-			&quot; free_pcp:%lukB&quot;</span>
<span class="p_del">-			&quot; local_pcp:%ukB&quot;</span>
<span class="p_del">-			&quot; free_cma:%lukB&quot;</span>
<span class="p_del">-			&quot;\n&quot;,</span>
<span class="p_del">-			zone-&gt;name,</span>
<span class="p_del">-			K(zone_page_state(zone, NR_FREE_PAGES)),</span>
<span class="p_del">-			K(min_wmark_pages(zone)),</span>
<span class="p_del">-			K(low_wmark_pages(zone)),</span>
<span class="p_del">-			K(high_wmark_pages(zone)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),</span>
<span class="p_del">-			K(zone-&gt;present_pages),</span>
<span class="p_del">-			K(zone-&gt;managed_pages),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_MLOCK)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_SLAB_RECLAIMABLE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="p_del">-			zone_page_state(zone, NR_KERNEL_STACK_KB),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_PAGETABLE)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_BOUNCE)),</span>
<span class="p_del">-			K(free_pcp),</span>
<span class="p_del">-			K(this_cpu_read(zone-&gt;pageset-&gt;pcp.count)),</span>
<span class="p_del">-			K(zone_page_state(zone, NR_FREE_CMA_PAGES)));</span>
<span class="p_add">+		       &quot;%s&quot;</span>
<span class="p_add">+		       &quot; free:%lukB&quot;</span>
<span class="p_add">+		       &quot; min:%lukB&quot;</span>
<span class="p_add">+		       &quot; low:%lukB&quot;</span>
<span class="p_add">+		       &quot; high:%lukB&quot;</span>
<span class="p_add">+		       &quot; active_anon:%lukB&quot;</span>
<span class="p_add">+		       &quot; inactive_anon:%lukB&quot;</span>
<span class="p_add">+		       &quot; active_file:%lukB&quot;</span>
<span class="p_add">+		       &quot; inactive_file:%lukB&quot;</span>
<span class="p_add">+		       &quot; unevictable:%lukB&quot;</span>
<span class="p_add">+		       &quot; writepending:%lukB&quot;</span>
<span class="p_add">+		       &quot; present:%lukB&quot;</span>
<span class="p_add">+		       &quot; managed:%lukB&quot;</span>
<span class="p_add">+		       &quot; mlocked:%lukB&quot;</span>
<span class="p_add">+		       &quot; slab_reclaimable:%lukB&quot;</span>
<span class="p_add">+		       &quot; slab_unreclaimable:%lukB&quot;</span>
<span class="p_add">+		       &quot; kernel_stack:%lukB&quot;</span>
<span class="p_add">+		       &quot; pagetables:%lukB&quot;</span>
<span class="p_add">+		       &quot; bounce:%lukB&quot;</span>
<span class="p_add">+		       &quot; free_pcp:%lukB&quot;</span>
<span class="p_add">+		       &quot; local_pcp:%ukB&quot;</span>
<span class="p_add">+		       &quot; free_cma:%lukB&quot;</span>
<span class="p_add">+		       &quot;\n&quot;,</span>
<span class="p_add">+		       zone-&gt;name,</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_FREE_PAGES)),</span>
<span class="p_add">+		       K(min_wmark_pages(zone)),</span>
<span class="p_add">+		       K(low_wmark_pages(zone)),</span>
<span class="p_add">+		       K(high_wmark_pages(zone)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_ZONE_ACTIVE_ANON)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_ZONE_INACTIVE_ANON)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_ZONE_ACTIVE_FILE)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_ZONE_INACTIVE_FILE)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_ZONE_UNEVICTABLE)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_ZONE_WRITE_PENDING)),</span>
<span class="p_add">+		       K(zone-&gt;present_pages),</span>
<span class="p_add">+		       K(zone-&gt;managed_pages),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_MLOCK)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_SLAB_RECLAIMABLE)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_SLAB_UNRECLAIMABLE)),</span>
<span class="p_add">+		       zone_page_state(zone, NR_KERNEL_STACK_KB),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_PAGETABLE)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_BOUNCE)),</span>
<span class="p_add">+		       K(free_pcp),</span>
<span class="p_add">+		       K(this_cpu_read(zone-&gt;pageset-&gt;pcp.count)),</span>
<span class="p_add">+		       K(zone_page_state(zone, NR_FREE_CMA_PAGES)));</span>
 		printk(&quot;lowmem_reserve[]:&quot;);
 		for (i = 0; i &lt; MAX_NR_ZONES; i++)
 			printk(KERN_CONT &quot; %ld&quot;, zone-&gt;lowmem_reserve[i]);
<span class="p_chunk">@@ -4679,7 +4679,8 @@</span> <span class="p_context"> void show_free_areas(unsigned int filter, nodemask_t *nodemask)</span>
 
 	hugetlb_show_meminfo();
 
<span class="p_del">-	printk(&quot;%ld total pagecache pages\n&quot;, global_node_page_state(NR_FILE_PAGES));</span>
<span class="p_add">+	printk(&quot;%ld total pagecache pages\n&quot;,</span>
<span class="p_add">+	       global_node_page_state(NR_FILE_PAGES));</span>
 
 	show_swap_cache_info();
 }
<span class="p_chunk">@@ -5516,8 +5517,7 @@</span> <span class="p_context"> static __meminit void zone_pcp_init(struct zone *zone)</span>
 
 	if (populated_zone(zone))
 		printk(KERN_DEBUG &quot;  %s zone: %lu pages, LIFO batch:%u\n&quot;,
<span class="p_del">-			zone-&gt;name, zone-&gt;present_pages,</span>
<span class="p_del">-					 zone_batchsize(zone));</span>
<span class="p_add">+		       zone-&gt;name, zone-&gt;present_pages, zone_batchsize(zone));</span>
 }
 
 int __meminit init_currently_empty_zone(struct zone *zone,
<span class="p_chunk">@@ -5891,8 +5891,8 @@</span> <span class="p_context"> static void __meminit calculate_node_totalpages(struct pglist_data *pgdat,</span>
 
 	pgdat-&gt;node_spanned_pages = totalpages;
 	pgdat-&gt;node_present_pages = realtotalpages;
<span class="p_del">-	printk(KERN_DEBUG &quot;On node %d totalpages: %lu\n&quot;, pgdat-&gt;node_id,</span>
<span class="p_del">-							realtotalpages);</span>
<span class="p_add">+	printk(KERN_DEBUG &quot;On node %d totalpages: %lu\n&quot;,</span>
<span class="p_add">+	       pgdat-&gt;node_id, realtotalpages);</span>
 }
 
 #ifndef CONFIG_SPARSEMEM
<span class="p_chunk">@@ -6042,8 +6042,7 @@</span> <span class="p_context"> static void __paginginit free_area_init_core(struct pglist_data *pgdat)</span>
 			if (freesize &gt;= memmap_pages) {
 				freesize -= memmap_pages;
 				if (memmap_pages)
<span class="p_del">-					printk(KERN_DEBUG</span>
<span class="p_del">-					       &quot;  %s zone: %lu pages used for memmap\n&quot;,</span>
<span class="p_add">+					printk(KERN_DEBUG &quot;  %s zone: %lu pages used for memmap\n&quot;,</span>
 					       zone_names[j], memmap_pages);
 			} else
 				pr_warn(&quot;  %s zone: %lu pages exceeds freesize %lu\n&quot;,
<span class="p_chunk">@@ -6054,7 +6053,7 @@</span> <span class="p_context"> static void __paginginit free_area_init_core(struct pglist_data *pgdat)</span>
 		if (j == 0 &amp;&amp; freesize &gt; dma_reserve) {
 			freesize -= dma_reserve;
 			printk(KERN_DEBUG &quot;  %s zone: %lu pages reserved\n&quot;,
<span class="p_del">-					zone_names[0], dma_reserve);</span>
<span class="p_add">+			       zone_names[0], dma_reserve);</span>
 		}
 
 		if (!is_highmem_idx(j))
<span class="p_chunk">@@ -6163,9 +6162,9 @@</span> <span class="p_context"> void __paginginit free_area_init_node(int nid, unsigned long *zones_size,</span>
 
 	alloc_node_mem_map(pgdat);
 #ifdef CONFIG_FLAT_NODE_MEM_MAP
<span class="p_del">-	printk(KERN_DEBUG &quot;free_area_init_node: node %d, pgdat %08lx, node_mem_map %08lx\n&quot;,</span>
<span class="p_del">-		nid, (unsigned long)pgdat,</span>
<span class="p_del">-		(unsigned long)pgdat-&gt;node_mem_map);</span>
<span class="p_add">+	printk(KERN_DEBUG &quot;%s: node %d, pgdat %08lx, node_mem_map %08lx\n&quot;,</span>
<span class="p_add">+	       __func__, nid, (unsigned long)pgdat,</span>
<span class="p_add">+	       (unsigned long)pgdat-&gt;node_mem_map);</span>
 #endif
 
 	free_area_init_core(pgdat);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



