
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v10,06/19] h8300: Assembly headers. - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v10,06/19] h8300: Assembly headers.</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=1972">Yoshinori Sato</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 4, 2015, 10:41 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1430736122-20929-8-git-send-email-ysato@users.sourceforge.jp&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6325201/mbox/"
   >mbox</a>
|
   <a href="/patch/6325201/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6325201/">/patch/6325201/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 9CFD3BEEE1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  4 May 2015 10:47:17 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id D776920270
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  4 May 2015 10:47:13 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id CF5AE202C8
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  4 May 2015 10:47:09 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753242AbbEDKq6 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 4 May 2015 06:46:58 -0400
Received: from mail2.asahi-net.or.jp ([202.224.39.198]:56221 &quot;EHLO
	mail2.asahi-net.or.jp&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752676AbbEDKms (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 4 May 2015 06:42:48 -0400
Received: from sa76r4 (y081184.ppp.asahi-net.or.jp [118.243.81.184])
	by mail2.asahi-net.or.jp (Postfix) with ESMTP id 077F79D9C;
	Mon,  4 May 2015 19:42:46 +0900 (JST)
Received: from localhost (localhost [127.0.0.1])
	by sa76r4 (Postfix) with ESMTP id B77523E1E;
	Mon,  4 May 2015 19:42:45 +0900 (JST)
X-Virus-Scanned: Debian amavisd-new at sa76r4.localdomain
Received: from sa76r4 ([127.0.0.1])
	by localhost (sa76r4.localdomain [127.0.0.1]) (amavisd-new,
	port 10024)
	with ESMTP id id7SNeCBQAjm; Mon,  4 May 2015 19:42:45 +0900 (JST)
Received: by sa76r4 (Postfix, from userid 1000)
	id 903E3C129; Mon,  4 May 2015 19:42:45 +0900 (JST)
From: Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;
To: linux-kernel@vger.kernel.org, linux-arch@vger.kernel.org
Cc: Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;
Subject: [PATCH v10 06/19] h8300: Assembly headers.
Date: Mon,  4 May 2015 19:41:49 +0900
Message-Id: &lt;1430736122-20929-8-git-send-email-ysato@users.sourceforge.jp&gt;
X-Mailer: git-send-email 2.1.4
In-Reply-To: &lt;1430736122-20929-2-git-send-email-ysato@users.sourceforge.jp&gt;
References: &lt;1430736122-20929-2-git-send-email-ysato@users.sourceforge.jp&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=1972">Yoshinori Sato</a> - May 4, 2015, 10:41 a.m.</div>
<pre class="content">
<span class="signed-off-by">Signed-off-by: Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;</span>
---
 arch/h8300/include/asm/Kbuild        |  72 ++++++++++++++
 arch/h8300/include/asm/atomic.h      | 159 ++++++++++++++++++++++++++++++
 arch/h8300/include/asm/bitops.h      | 185 +++++++++++++++++++++++++++++++++++
 arch/h8300/include/asm/bitsperlong.h |  14 +++
 arch/h8300/include/asm/bootparams.h  |  17 ++++
 arch/h8300/include/asm/bug.h         |  12 +++
 arch/h8300/include/asm/cache.h       |  11 +++
 arch/h8300/include/asm/checksum.h    | 102 +++++++++++++++++++
 arch/h8300/include/asm/cmpxchg.h     |  65 ++++++++++++
 arch/h8300/include/asm/dma-mapping.h |  57 +++++++++++
 arch/h8300/include/asm/elf.h         | 101 +++++++++++++++++++
 arch/h8300/include/asm/flat.h        |  28 ++++++
 arch/h8300/include/asm/io.h          |  57 +++++++++++
 arch/h8300/include/asm/irq.h         |  26 +++++
 arch/h8300/include/asm/irqflags.h    |  96 ++++++++++++++++++
 arch/h8300/include/asm/mc146818rtc.h |   9 ++
 arch/h8300/include/asm/mutex.h       |   9 ++
 arch/h8300/include/asm/page.h        |  11 +++
 arch/h8300/include/asm/page_offset.h |   2 +
 arch/h8300/include/asm/pci.h         |  19 ++++
 arch/h8300/include/asm/pgtable.h     |  49 ++++++++++
 arch/h8300/include/asm/processor.h   | 144 +++++++++++++++++++++++++++
 arch/h8300/include/asm/ptrace.h      |  36 +++++++
 arch/h8300/include/asm/segment.h     |  49 ++++++++++
 arch/h8300/include/asm/signal.h      |  22 +++++
 arch/h8300/include/asm/smp.h         |   1 +
 arch/h8300/include/asm/string.h      |  17 ++++
 arch/h8300/include/asm/switch_to.h   |  51 ++++++++++
 arch/h8300/include/asm/syscall.h     |  56 +++++++++++
 arch/h8300/include/asm/thread_info.h | 108 ++++++++++++++++++++
 arch/h8300/include/asm/tlb.h         |   8 ++
 arch/h8300/include/asm/traps.h       |  41 ++++++++
 arch/h8300/include/asm/uaccess.h     | 131 +++++++++++++++++++++++++
 arch/h8300/include/asm/unaligned.h   |  11 +++
 arch/h8300/include/asm/user.h        |  74 ++++++++++++++
 35 files changed, 1850 insertions(+)
 create mode 100644 arch/h8300/include/asm/Kbuild
 create mode 100644 arch/h8300/include/asm/atomic.h
 create mode 100644 arch/h8300/include/asm/bitops.h
 create mode 100644 arch/h8300/include/asm/bitsperlong.h
 create mode 100644 arch/h8300/include/asm/bootparams.h
 create mode 100644 arch/h8300/include/asm/bug.h
 create mode 100644 arch/h8300/include/asm/cache.h
 create mode 100644 arch/h8300/include/asm/checksum.h
 create mode 100644 arch/h8300/include/asm/cmpxchg.h
 create mode 100644 arch/h8300/include/asm/dma-mapping.h
 create mode 100644 arch/h8300/include/asm/elf.h
 create mode 100644 arch/h8300/include/asm/flat.h
 create mode 100644 arch/h8300/include/asm/io.h
 create mode 100644 arch/h8300/include/asm/irq.h
 create mode 100644 arch/h8300/include/asm/irqflags.h
 create mode 100644 arch/h8300/include/asm/mc146818rtc.h
 create mode 100644 arch/h8300/include/asm/mutex.h
 create mode 100644 arch/h8300/include/asm/page.h
 create mode 100644 arch/h8300/include/asm/page_offset.h
 create mode 100644 arch/h8300/include/asm/pci.h
 create mode 100644 arch/h8300/include/asm/pgtable.h
 create mode 100644 arch/h8300/include/asm/processor.h
 create mode 100644 arch/h8300/include/asm/ptrace.h
 create mode 100644 arch/h8300/include/asm/segment.h
 create mode 100644 arch/h8300/include/asm/signal.h
 create mode 100644 arch/h8300/include/asm/smp.h
 create mode 100644 arch/h8300/include/asm/string.h
 create mode 100644 arch/h8300/include/asm/switch_to.h
 create mode 100644 arch/h8300/include/asm/syscall.h
 create mode 100644 arch/h8300/include/asm/thread_info.h
 create mode 100644 arch/h8300/include/asm/tlb.h
 create mode 100644 arch/h8300/include/asm/traps.h
 create mode 100644 arch/h8300/include/asm/uaccess.h
 create mode 100644 arch/h8300/include/asm/unaligned.h
 create mode 100644 arch/h8300/include/asm/user.h
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/h8300/include/asm/Kbuild b/arch/h8300/include/asm/Kbuild</span>
new file mode 100644
<span class="p_header">index 0000000..3a0df64</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/Kbuild</span>
<span class="p_chunk">@@ -0,0 +1,72 @@</span> <span class="p_context"></span>
<span class="p_add">+generic-y += asm-offsets.h</span>
<span class="p_add">+generic-y += auxvec.h</span>
<span class="p_add">+generic-y += barrier.h</span>
<span class="p_add">+generic-y += bugs.h</span>
<span class="p_add">+generic-y += cacheflush.h</span>
<span class="p_add">+generic-y += clkdev.h</span>
<span class="p_add">+generic-y += cputime.h</span>
<span class="p_add">+generic-y += current.h</span>
<span class="p_add">+generic-y += delay.h</span>
<span class="p_add">+generic-y += device.h</span>
<span class="p_add">+generic-y += div64.h</span>
<span class="p_add">+generic-y += dma.h</span>
<span class="p_add">+generic-y += emergency-restart.h</span>
<span class="p_add">+generic-y += errno.h</span>
<span class="p_add">+generic-y += exec.h</span>
<span class="p_add">+generic-y += fb.h</span>
<span class="p_add">+generic-y += fcntl.h</span>
<span class="p_add">+generic-y += ftrace.h</span>
<span class="p_add">+generic-y += futex.h</span>
<span class="p_add">+generic-y += hardirq.h</span>
<span class="p_add">+generic-y += hash.h</span>
<span class="p_add">+generic-y += hw_irq.h</span>
<span class="p_add">+generic-y += ioctl.h</span>
<span class="p_add">+generic-y += ioctls.h</span>
<span class="p_add">+generic-y += ipcbuf.h</span>
<span class="p_add">+generic-y += irq_regs.h</span>
<span class="p_add">+generic-y += irq_work.h</span>
<span class="p_add">+generic-y += kdebug.h</span>
<span class="p_add">+generic-y += kmap_types.h</span>
<span class="p_add">+generic-y += kvm_para.h</span>
<span class="p_add">+generic-y += linkage.h</span>
<span class="p_add">+generic-y += local.h</span>
<span class="p_add">+generic-y += local64.h</span>
<span class="p_add">+generic-y += mcs_spinlock.h</span>
<span class="p_add">+generic-y += mman.h</span>
<span class="p_add">+generic-y += mmu.h</span>
<span class="p_add">+generic-y += mmu_context.h</span>
<span class="p_add">+generic-y += module.h</span>
<span class="p_add">+generic-y += msgbuf.h</span>
<span class="p_add">+generic-y += param.h</span>
<span class="p_add">+generic-y += parport.h</span>
<span class="p_add">+generic-y += percpu.h</span>
<span class="p_add">+generic-y += pgalloc.h</span>
<span class="p_add">+generic-y += poll.h</span>
<span class="p_add">+generic-y += posix_types.h</span>
<span class="p_add">+generic-y += preempt.h</span>
<span class="p_add">+generic-y += resource.h</span>
<span class="p_add">+generic-y += scatterlist.h</span>
<span class="p_add">+generic-y += sections.h</span>
<span class="p_add">+generic-y += sembuf.h</span>
<span class="p_add">+generic-y += serial.h</span>
<span class="p_add">+generic-y += setup.h</span>
<span class="p_add">+generic-y += shmbuf.h</span>
<span class="p_add">+generic-y += shmparam.h</span>
<span class="p_add">+generic-y += siginfo.h</span>
<span class="p_add">+generic-y += sizes.h</span>
<span class="p_add">+generic-y += socket.h</span>
<span class="p_add">+generic-y += sockios.h</span>
<span class="p_add">+generic-y += spinlock.h</span>
<span class="p_add">+generic-y += stat.h</span>
<span class="p_add">+generic-y += statfs.h</span>
<span class="p_add">+generic-y += swab.h</span>
<span class="p_add">+generic-y += termbits.h</span>
<span class="p_add">+generic-y += termios.h</span>
<span class="p_add">+generic-y += timex.h</span>
<span class="p_add">+generic-y += tlbflush.h</span>
<span class="p_add">+generic-y += trace_clock.h</span>
<span class="p_add">+generic-y += topology.h</span>
<span class="p_add">+generic-y += types.h</span>
<span class="p_add">+generic-y += ucontext.h</span>
<span class="p_add">+generic-y += vga.h</span>
<span class="p_add">+generic-y += xor.h</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/atomic.h b/arch/h8300/include/asm/atomic.h</span>
new file mode 100644
<span class="p_header">index 0000000..7ca73f8</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/atomic.h</span>
<span class="p_chunk">@@ -0,0 +1,159 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __ARCH_H8300_ATOMIC__</span>
<span class="p_add">+#define __ARCH_H8300_ATOMIC__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;asm/cmpxchg.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Atomic operations that C can&#39;t guarantee us.  Useful for</span>
<span class="p_add">+ * resource counting etc..</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define ATOMIC_INIT(i)	{ (i) }</span>
<span class="p_add">+</span>
<span class="p_add">+#define atomic_read(v)		ACCESS_ONCE((v)-&gt;counter)</span>
<span class="p_add">+#define atomic_set(v, i)	(((v)-&gt;counter) = i)</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int atomic_add_return(int i, atomic_t *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = arch_local_irq_save();</span>
<span class="p_add">+	ret = v-&gt;counter += i;</span>
<span class="p_add">+	arch_local_irq_restore(flags);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define atomic_add(i, v) atomic_add_return(i, v)</span>
<span class="p_add">+#define atomic_add_negative(a, v)	(atomic_add_return((a), (v)) &lt; 0)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int atomic_sub_return(int i, atomic_t *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = arch_local_irq_save();</span>
<span class="p_add">+	ret = v-&gt;counter -= i;</span>
<span class="p_add">+	arch_local_irq_restore(flags);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define atomic_sub(i, v) atomic_sub_return(i, v)</span>
<span class="p_add">+#define atomic_sub_and_test(i, v) (atomic_sub_return(i, v) == 0)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int atomic_inc_return(atomic_t *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = arch_local_irq_save();</span>
<span class="p_add">+	v-&gt;counter++;</span>
<span class="p_add">+	ret = v-&gt;counter;</span>
<span class="p_add">+	arch_local_irq_restore(flags);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define atomic_inc(v) atomic_inc_return(v)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * atomic_inc_and_test - increment and test</span>
<span class="p_add">+ * @v: pointer of type atomic_t</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Atomically increments @v by 1</span>
<span class="p_add">+ * and returns true if the result is zero, or false for all</span>
<span class="p_add">+ * other cases.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define atomic_inc_and_test(v) (atomic_inc_return(v) == 0)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int atomic_dec_return(atomic_t *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = arch_local_irq_save();</span>
<span class="p_add">+	--v-&gt;counter;</span>
<span class="p_add">+	ret = v-&gt;counter;</span>
<span class="p_add">+	arch_local_irq_restore(flags);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define atomic_dec(v) atomic_dec_return(v)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int atomic_dec_and_test(atomic_t *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = arch_local_irq_save();</span>
<span class="p_add">+	--v-&gt;counter;</span>
<span class="p_add">+	ret = v-&gt;counter;</span>
<span class="p_add">+	arch_local_irq_restore(flags);</span>
<span class="p_add">+	return ret == 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int atomic_cmpxchg(atomic_t *v, int old, int new)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = arch_local_irq_save();</span>
<span class="p_add">+	ret = v-&gt;counter;</span>
<span class="p_add">+	if (likely(ret == old))</span>
<span class="p_add">+		v-&gt;counter = new;</span>
<span class="p_add">+	arch_local_irq_restore(flags);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int __atomic_add_unless(atomic_t *v, int a, int u)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	flags = arch_local_irq_save();</span>
<span class="p_add">+	ret = v-&gt;counter;</span>
<span class="p_add">+	if (ret != u)</span>
<span class="p_add">+		v-&gt;counter += a;</span>
<span class="p_add">+	arch_local_irq_restore(flags);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void atomic_clear_mask(unsigned long mask, unsigned long *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char ccr;</span>
<span class="p_add">+	unsigned long tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ __volatile__(&quot;stc ccr,%w3\n\t&quot;</span>
<span class="p_add">+			     &quot;orc #0x80,ccr\n\t&quot;</span>
<span class="p_add">+			     &quot;mov.l %0,%1\n\t&quot;</span>
<span class="p_add">+			     &quot;and.l %2,%1\n\t&quot;</span>
<span class="p_add">+			     &quot;mov.l %1,%0\n\t&quot;</span>
<span class="p_add">+			     &quot;ldc %w3,ccr&quot;</span>
<span class="p_add">+			     : &quot;=m&quot;(*v), &quot;=r&quot;(tmp)</span>
<span class="p_add">+			     : &quot;g&quot;(~(mask)), &quot;r&quot;(ccr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void atomic_set_mask(unsigned long mask, unsigned long *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned char ccr;</span>
<span class="p_add">+	unsigned long tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ __volatile__(&quot;stc ccr,%w3\n\t&quot;</span>
<span class="p_add">+			     &quot;orc #0x80,ccr\n\t&quot;</span>
<span class="p_add">+			     &quot;mov.l %0,%1\n\t&quot;</span>
<span class="p_add">+			     &quot;or.l %2,%1\n\t&quot;</span>
<span class="p_add">+			     &quot;mov.l %1,%0\n\t&quot;</span>
<span class="p_add">+			     &quot;ldc %w3,ccr&quot;</span>
<span class="p_add">+			     : &quot;=m&quot;(*v), &quot;=r&quot;(tmp)</span>
<span class="p_add">+			     : &quot;g&quot;(~(mask)), &quot;r&quot;(ccr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Atomic operations are already serializing */</span>
<span class="p_add">+#define smp_mb__before_atomic_dec()    barrier()</span>
<span class="p_add">+#define smp_mb__after_atomic_dec() barrier()</span>
<span class="p_add">+#define smp_mb__before_atomic_inc()    barrier()</span>
<span class="p_add">+#define smp_mb__after_atomic_inc() barrier()</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ARCH_H8300_ATOMIC __ */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/bitops.h b/arch/h8300/include/asm/bitops.h</span>
new file mode 100644
<span class="p_header">index 0000000..05999ab</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/bitops.h</span>
<span class="p_chunk">@@ -0,0 +1,185 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_BITOPS_H</span>
<span class="p_add">+#define _H8300_BITOPS_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Copyright 1992, Linus Torvalds.</span>
<span class="p_add">+ * Copyright 2002, Yoshinori Sato</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _LINUX_BITOPS_H</span>
<span class="p_add">+#error only &lt;linux/bitops.h&gt; can be included directly</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Function prototypes to keep gcc -Wall happy</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ffz = Find First Zero in word. Undefined if no zero exists,</span>
<span class="p_add">+ * so code should check against ~0UL first..</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline unsigned long ffz(unsigned long word)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long result;</span>
<span class="p_add">+</span>
<span class="p_add">+	result = -1;</span>
<span class="p_add">+	__asm__(&quot;1:\n\t&quot;</span>
<span class="p_add">+		&quot;shlr.l %2\n\t&quot;</span>
<span class="p_add">+		&quot;adds #1,%0\n\t&quot;</span>
<span class="p_add">+		&quot;bcs 1b&quot;</span>
<span class="p_add">+		: &quot;=r&quot;(result)</span>
<span class="p_add">+		: &quot;0&quot;(result), &quot;r&quot;(word));</span>
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define H8300_GEN_BITOP(FNAME, OP)				\</span>
<span class="p_add">+static inline void FNAME(int nr, volatile unsigned long *addr)	\</span>
<span class="p_add">+{								\</span>
<span class="p_add">+	unsigned char *b_addr;					\</span>
<span class="p_add">+	unsigned char bit = nr &amp; 7;				\</span>
<span class="p_add">+								\</span>
<span class="p_add">+	b_addr = (unsigned char *)addr + ((nr &gt;&gt; 3) ^ 3);	\</span>
<span class="p_add">+	if (__builtin_constant_p(nr)) {				\</span>
<span class="p_add">+		__asm__(OP &quot; %1,%0&quot; : &quot;+WU&quot;(*b_addr) : &quot;i&quot;(nr &amp; 7));	\</span>
<span class="p_add">+	} else {						\</span>
<span class="p_add">+		__asm__(OP &quot; %s1,%0&quot; : &quot;+WU&quot;(*b_addr) : &quot;r&quot;(bit));	\</span>
<span class="p_add">+	}							\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * clear_bit() doesn&#39;t provide any barrier for the compiler.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define smp_mb__before_clear_bit()	barrier()</span>
<span class="p_add">+#define smp_mb__after_clear_bit()	barrier()</span>
<span class="p_add">+</span>
<span class="p_add">+H8300_GEN_BITOP(set_bit,    &quot;bset&quot;)</span>
<span class="p_add">+H8300_GEN_BITOP(clear_bit,  &quot;bclr&quot;)</span>
<span class="p_add">+H8300_GEN_BITOP(change_bit, &quot;bnot&quot;)</span>
<span class="p_add">+#define __set_bit(nr, addr)    set_bit((nr), (addr))</span>
<span class="p_add">+#define __clear_bit(nr, addr)  clear_bit((nr), (addr))</span>
<span class="p_add">+#define __change_bit(nr, addr) change_bit((nr), (addr))</span>
<span class="p_add">+</span>
<span class="p_add">+#undef H8300_GEN_BITOP</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int test_bit(int nr, const unsigned long *addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	unsigned char *b_addr;</span>
<span class="p_add">+	unsigned char bit = nr &amp; 7;</span>
<span class="p_add">+</span>
<span class="p_add">+	b_addr = (unsigned char *)addr + ((nr &gt;&gt; 3) ^ 3);</span>
<span class="p_add">+	if (__builtin_constant_p(nr)) {</span>
<span class="p_add">+		__asm__(&quot;bld %Z2,%1\n\t&quot;</span>
<span class="p_add">+			&quot;rotxl %0\n\t&quot;</span>
<span class="p_add">+			: &quot;=r&quot;(ret)</span>
<span class="p_add">+			: &quot;WU&quot;(*b_addr), &quot;i&quot;(nr &amp; 7), &quot;0&quot;(ret) : &quot;cc&quot;);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		__asm__(&quot;btst %w2,%1\n\t&quot;</span>
<span class="p_add">+			&quot;beq 1f\n\t&quot;</span>
<span class="p_add">+			&quot;inc.l #1,%0\n&quot;</span>
<span class="p_add">+			&quot;1:&quot;</span>
<span class="p_add">+			: &quot;=r&quot;(ret)</span>
<span class="p_add">+			: &quot;WU&quot;(*b_addr), &quot;r&quot;(bit), &quot;0&quot;(ret) : &quot;cc&quot;);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define __test_bit(nr, addr) test_bit(nr, addr)</span>
<span class="p_add">+</span>
<span class="p_add">+#define H8300_GEN_TEST_BITOP(FNNAME, OP)				\</span>
<span class="p_add">+static inline int FNNAME(int nr, void *addr)				\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	int retval = 0;							\</span>
<span class="p_add">+	char ccrsave;							\</span>
<span class="p_add">+	unsigned char *b_addr;						\</span>
<span class="p_add">+	unsigned char bit = nr &amp; 7;					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	b_addr = (unsigned char *)addr + ((nr &gt;&gt; 3) ^ 3);		\</span>
<span class="p_add">+	if (__builtin_constant_p(nr)) {					\</span>
<span class="p_add">+		__asm__(&quot;stc ccr,%s2\n\t&quot;				\</span>
<span class="p_add">+			&quot;orc #0x80,ccr\n\t&quot;				\</span>
<span class="p_add">+			&quot;bld %4,%1\n\t&quot;					\</span>
<span class="p_add">+			OP &quot; %4,%1\n\t&quot;					\</span>
<span class="p_add">+			&quot;rotxl.l %0\n\t&quot;				\</span>
<span class="p_add">+			&quot;ldc %s2,ccr&quot;					\</span>
<span class="p_add">+			: &quot;=r&quot;(retval), &quot;+WU&quot; (*b_addr), &quot;=&amp;r&quot;(ccrsave)	\</span>
<span class="p_add">+			: &quot;0&quot;(retval), &quot;i&quot;(nr &amp; 7) : &quot;cc&quot;);		\</span>
<span class="p_add">+	} else {							\</span>
<span class="p_add">+		__asm__(&quot;stc ccr,%t3\n\t&quot;				\</span>
<span class="p_add">+			&quot;orc #0x80,ccr\n\t&quot;				\</span>
<span class="p_add">+			&quot;btst %s3,%1\n\t&quot;				\</span>
<span class="p_add">+			OP &quot; %s3,%1\n\t&quot;				\</span>
<span class="p_add">+			&quot;beq 1f\n\t&quot;					\</span>
<span class="p_add">+			&quot;inc.l #1,%0\n\t&quot;				\</span>
<span class="p_add">+			&quot;1:\n&quot;						\</span>
<span class="p_add">+			&quot;ldc %t3,ccr&quot;					\</span>
<span class="p_add">+			: &quot;=r&quot;(retval), &quot;+WU&quot; (*b_addr)			\</span>
<span class="p_add">+			: &quot;0&quot; (retval), &quot;r&quot;(bit) : &quot;cc&quot;);		\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+	return retval;							\</span>
<span class="p_add">+}									\</span>
<span class="p_add">+									\</span>
<span class="p_add">+static inline int __ ## FNNAME(int nr, void *addr)			\</span>
<span class="p_add">+{									\</span>
<span class="p_add">+	int retval = 0;							\</span>
<span class="p_add">+	unsigned char *b_addr;						\</span>
<span class="p_add">+	unsigned char bit = nr &amp; 7;					\</span>
<span class="p_add">+									\</span>
<span class="p_add">+	b_addr = (unsigned char *)addr + ((nr &gt;&gt; 3) ^ 3);		\</span>
<span class="p_add">+	if (__builtin_constant_p(nr)) {					\</span>
<span class="p_add">+		__asm__(&quot;bld %3,%1\n\t&quot;					\</span>
<span class="p_add">+			OP &quot; %3,%1\n\t&quot;					\</span>
<span class="p_add">+			&quot;rotxl.l %0\n\t&quot;				\</span>
<span class="p_add">+			: &quot;=r&quot;(retval), &quot;+WU&quot;(*b_addr)			\</span>
<span class="p_add">+			: &quot;0&quot; (retval), &quot;i&quot;(nr &amp; 7));			\</span>
<span class="p_add">+	} else {							\</span>
<span class="p_add">+		__asm__(&quot;btst %s3,%1\n\t&quot;				\</span>
<span class="p_add">+			OP &quot; %s3,%1\n\t&quot;				\</span>
<span class="p_add">+			&quot;beq 1f\n\t&quot;					\</span>
<span class="p_add">+			&quot;inc.l #1,%0\n\t&quot;				\</span>
<span class="p_add">+			&quot;1:&quot;						\</span>
<span class="p_add">+			: &quot;=r&quot;(retval), &quot;+WU&quot;(*b_addr)			\</span>
<span class="p_add">+			: &quot;0&quot; (retval), &quot;r&quot;(bit));			\</span>
<span class="p_add">+	}								\</span>
<span class="p_add">+	return retval;							\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+H8300_GEN_TEST_BITOP(test_and_set_bit,	  &quot;bset&quot;)</span>
<span class="p_add">+H8300_GEN_TEST_BITOP(test_and_clear_bit,  &quot;bclr&quot;)</span>
<span class="p_add">+H8300_GEN_TEST_BITOP(test_and_change_bit, &quot;bnot&quot;)</span>
<span class="p_add">+#undef H8300_GEN_TEST_BITOP</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/bitops/ffs.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long __ffs(unsigned long word)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long result;</span>
<span class="p_add">+</span>
<span class="p_add">+	result = -1;</span>
<span class="p_add">+	__asm__(&quot;1:\n\t&quot;</span>
<span class="p_add">+		&quot;shlr.l %2\n\t&quot;</span>
<span class="p_add">+		&quot;adds #1,%0\n\t&quot;</span>
<span class="p_add">+		&quot;bcc 1b&quot;</span>
<span class="p_add">+		: &quot;=r&quot; (result)</span>
<span class="p_add">+		: &quot;0&quot;(result), &quot;r&quot;(word));</span>
<span class="p_add">+	return result;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/bitops/find.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/bitops/sched.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/bitops/hweight.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/bitops/lock.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/bitops/le.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/bitops/ext2-atomic.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __KERNEL__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/bitops/fls.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/bitops/__fls.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/bitops/fls64.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_BITOPS_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/bitsperlong.h b/arch/h8300/include/asm/bitsperlong.h</span>
new file mode 100644
<span class="p_header">index 0000000..e140e46</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/bitsperlong.h</span>
<span class="p_chunk">@@ -0,0 +1,14 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __ASM_H8300_BITS_PER_LONG</span>
<span class="p_add">+#define __ASM_H8300_BITS_PER_LONG</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/bitsperlong.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#if !defined(__ASSEMBLY__)</span>
<span class="p_add">+/* h8300-unknown-linux required long */</span>
<span class="p_add">+#define __kernel_size_t __kernel_size_t</span>
<span class="p_add">+typedef unsigned long	__kernel_size_t;</span>
<span class="p_add">+typedef long		__kernel_ssize_t;</span>
<span class="p_add">+typedef long		__kernel_ptrdiff_t;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASM_H8300_BITS_PER_LONG */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/bootparams.h b/arch/h8300/include/asm/bootparams.h</span>
new file mode 100644
<span class="p_header">index 0000000..6c0b145</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/bootparams.h</span>
<span class="p_chunk">@@ -0,0 +1,17 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+H8/300 kernel boot parameters</span>
<span class="p_add">+*/</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASM_H8300_BOOTPARAMS__</span>
<span class="p_add">+#define __ASM_H8300_BOOTPARAMS__</span>
<span class="p_add">+</span>
<span class="p_add">+struct bootparams {</span>
<span class="p_add">+	short size;</span>
<span class="p_add">+	unsigned char gpio_ddr[24];</span>
<span class="p_add">+	unsigned char gpio_use[24];</span>
<span class="p_add">+	unsigned int clock_freq;</span>
<span class="p_add">+	unsigned int ram_end;</span>
<span class="p_add">+	unsigned char *command_line;</span>
<span class="p_add">+} __packed __aligned(2);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/bug.h b/arch/h8300/include/asm/bug.h</span>
new file mode 100644
<span class="p_header">index 0000000..1e1be81</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/bug.h</span>
<span class="p_chunk">@@ -0,0 +1,12 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_BUG_H</span>
<span class="p_add">+#define _H8300_BUG_H</span>
<span class="p_add">+</span>
<span class="p_add">+/* always true */</span>
<span class="p_add">+#define is_valid_bugaddr(addr) (1)</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/bug.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+struct pt_regs;</span>
<span class="p_add">+extern void die(const char *str, struct pt_regs *fp, unsigned long err);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/cache.h b/arch/h8300/include/asm/cache.h</span>
new file mode 100644
<span class="p_header">index 0000000..0ef1edc</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/cache.h</span>
<span class="p_chunk">@@ -0,0 +1,11 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __ARCH_H8300_CACHE_H</span>
<span class="p_add">+#define __ARCH_H8300_CACHE_H</span>
<span class="p_add">+</span>
<span class="p_add">+/* bytes per L1 cache line */</span>
<span class="p_add">+#define        L1_CACHE_SHIFT  2</span>
<span class="p_add">+#define        L1_CACHE_BYTES  (1 &lt;&lt; L1_CACHE_SHIFT)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __cacheline_aligned</span>
<span class="p_add">+#define ____cacheline_aligned</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/checksum.h b/arch/h8300/include/asm/checksum.h</span>
new file mode 100644
<span class="p_header">index 0000000..59e2adc9</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/checksum.h</span>
<span class="p_chunk">@@ -0,0 +1,102 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_CHECKSUM_H</span>
<span class="p_add">+#define _H8300_CHECKSUM_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * computes the checksum of a memory block at buff, length len,</span>
<span class="p_add">+ * and adds in &quot;sum&quot; (32-bit)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * returns a 32-bit number suitable for feeding into itself</span>
<span class="p_add">+ * or csum_tcpudp_magic</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * this function must be called with even lengths, except</span>
<span class="p_add">+ * for the last fragment, which may be odd</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * it&#39;s best to have buff aligned on a 32-bit boundary</span>
<span class="p_add">+ */</span>
<span class="p_add">+__wsum csum_partial(const void *buff, int len, __wsum sum);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * the same as csum_partial, but copies from src while it</span>
<span class="p_add">+ * checksums</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * here even more important to align src and dst on a 32-bit (or even</span>
<span class="p_add">+ * better 64-bit) boundary</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+__wsum csum_partial_copy_nocheck(const void *src, void *dst,</span>
<span class="p_add">+				 int len, __wsum sum);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * the same as csum_partial_copy, but copies from user space.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * here even more important to align src and dst on a 32-bit (or even</span>
<span class="p_add">+ * better 64-bit) boundary</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+extern __wsum csum_partial_copy_from_user(const void __user *src, void *dst,</span>
<span class="p_add">+					  int len, __wsum sum, int *csum_err);</span>
<span class="p_add">+</span>
<span class="p_add">+__sum16 ip_fast_csum(const void *iph, unsigned int ihl);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ *	Fold a partial checksum</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static inline __sum16 csum_fold(__wsum sum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__asm__(&quot;add.w %e0,%f0\n\t&quot;</span>
<span class="p_add">+		&quot;xor.w %e0,%e0\n\t&quot;</span>
<span class="p_add">+		&quot;rotxl.w %e0\n\t&quot;</span>
<span class="p_add">+		&quot;add.w %e0,%f0\n\t&quot;</span>
<span class="p_add">+		&quot;sub.w %e0,%e0\n\t&quot;</span>
<span class="p_add">+		: &quot;=r&quot;(sum)</span>
<span class="p_add">+		: &quot;0&quot;(sum));</span>
<span class="p_add">+	return (__force __sum16)~sum;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * computes the checksum of the TCP/UDP pseudo-header</span>
<span class="p_add">+ * returns a 16-bit checksum, already complemented</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static inline __wsum</span>
<span class="p_add">+csum_tcpudp_nofold(__be32 saddr, __be32 daddr, unsigned short len,</span>
<span class="p_add">+		  unsigned short proto, __wsum sum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ (&quot;sub.l %1,%1\n\t&quot;</span>
<span class="p_add">+		 &quot;add.l %3,%0\n\t&quot;</span>
<span class="p_add">+		 &quot;addx	#0,%w1\n\t&quot;</span>
<span class="p_add">+		 &quot;add.l	%4,%0\n\t&quot;</span>
<span class="p_add">+		 &quot;addx	#0,%w1\n\t&quot;</span>
<span class="p_add">+		 &quot;add.l %5,%0\n\t&quot;</span>
<span class="p_add">+		 &quot;addx	#0,%w1\n\t&quot;</span>
<span class="p_add">+		 &quot;add.l	%1,%0\n\t&quot;</span>
<span class="p_add">+		 &quot;bcc	1f\n\t&quot;</span>
<span class="p_add">+		 &quot;inc.l	#1,%0\n&quot;</span>
<span class="p_add">+		 &quot;1:&quot;</span>
<span class="p_add">+		 : &quot;=&amp;r&quot; (sum), &quot;=&amp;r&quot;(tmp)</span>
<span class="p_add">+		 : &quot;0&quot; (sum), &quot;1&quot; (daddr),</span>
<span class="p_add">+		   &quot;r&quot; (saddr), &quot;r&quot; (len + proto));</span>
<span class="p_add">+	return sum;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline __sum16</span>
<span class="p_add">+csum_tcpudp_magic(__be32 saddr, __be32 daddr, unsigned short len,</span>
<span class="p_add">+		  unsigned short proto, __wsum sum)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return csum_fold(csum_tcpudp_nofold(saddr, daddr, len, proto, sum));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * this routine is used for miscellaneous IP-like checksums, mainly</span>
<span class="p_add">+ * in icmp.c</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+extern __sum16 ip_compute_csum(const void *buff, int len);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_CHECKSUM_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/cmpxchg.h b/arch/h8300/include/asm/cmpxchg.h</span>
new file mode 100644
<span class="p_header">index 0000000..95fec4c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/cmpxchg.h</span>
<span class="p_chunk">@@ -0,0 +1,65 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __ARCH_H8300_CMPXCHG__</span>
<span class="p_add">+#define __ARCH_H8300_CMPXCHG__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/irqflags.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define xchg(ptr, x) \</span>
<span class="p_add">+	((__typeof__(*(ptr)))__xchg((unsigned long)(x), (ptr), \</span>
<span class="p_add">+				    sizeof(*(ptr))))</span>
<span class="p_add">+</span>
<span class="p_add">+struct __xchg_dummy { unsigned long a[100]; };</span>
<span class="p_add">+#define __xg(x) ((volatile struct __xchg_dummy *)(x))</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long __xchg(unsigned long x,</span>
<span class="p_add">+				   volatile void *ptr, int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long tmp, flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (size) {</span>
<span class="p_add">+	case 1:</span>
<span class="p_add">+		__asm__ __volatile__</span>
<span class="p_add">+			(&quot;mov.b %2,%0\n\t&quot;</span>
<span class="p_add">+			 &quot;mov.b %1,%2&quot;</span>
<span class="p_add">+			 : &quot;=&amp;r&quot; (tmp) : &quot;r&quot; (x), &quot;m&quot; (*__xg(ptr)));</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 2:</span>
<span class="p_add">+		__asm__ __volatile__</span>
<span class="p_add">+			(&quot;mov.w %2,%0\n\t&quot;</span>
<span class="p_add">+			 &quot;mov.w %1,%2&quot;</span>
<span class="p_add">+			 : &quot;=&amp;r&quot; (tmp) : &quot;r&quot; (x), &quot;m&quot; (*__xg(ptr)));</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 4:</span>
<span class="p_add">+		__asm__ __volatile__</span>
<span class="p_add">+			(&quot;mov.l %2,%0\n\t&quot;</span>
<span class="p_add">+			 &quot;mov.l %1,%2&quot;</span>
<span class="p_add">+			 : &quot;=&amp;r&quot; (tmp) : &quot;r&quot; (x), &quot;m&quot; (*__xg(ptr)));</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		tmp = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+	return tmp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/cmpxchg-local.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * cmpxchg_local and cmpxchg64_local are atomic wrt current CPU. Always make</span>
<span class="p_add">+ * them available.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define cmpxchg_local(ptr, o, n)					 \</span>
<span class="p_add">+	((__typeof__(*(ptr)))__cmpxchg_local_generic((ptr),		 \</span>
<span class="p_add">+						     (unsigned long)(o), \</span>
<span class="p_add">+						     (unsigned long)(n), \</span>
<span class="p_add">+						     sizeof(*(ptr))))</span>
<span class="p_add">+#define cmpxchg64_local(ptr, o, n) __cmpxchg64_local_generic((ptr), (o), (n))</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef CONFIG_SMP</span>
<span class="p_add">+#include &lt;asm-generic/cmpxchg.h&gt;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define atomic_xchg(v, new) (xchg(&amp;((v)-&gt;counter), new))</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ARCH_H8300_CMPXCHG__ */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/dma-mapping.h b/arch/h8300/include/asm/dma-mapping.h</span>
new file mode 100644
<span class="p_header">index 0000000..6e67a909</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/dma-mapping.h</span>
<span class="p_chunk">@@ -0,0 +1,57 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_DMA_MAPPING_H</span>
<span class="p_add">+#define _H8300_DMA_MAPPING_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/dma-coherent.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct dma_map_ops h8300_dma_map_ops;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct dma_map_ops *get_dma_ops(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;h8300_dma_map_ops;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/dma-mapping-common.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int dma_supported(struct device *dev, u64 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int dma_set_mask(struct device *dev, u64 mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define dma_alloc_noncoherent(d, s, h, f) dma_alloc_coherent(d, s, h, f)</span>
<span class="p_add">+#define dma_free_noncoherent(d, s, v, h) dma_free_coherent(d, s, v, h)</span>
<span class="p_add">+</span>
<span class="p_add">+#define dma_alloc_coherent(d, s, h, f) dma_alloc_attrs(d, s, h, f, NULL)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void *dma_alloc_attrs(struct device *dev, size_t size,</span>
<span class="p_add">+				    dma_addr_t *dma_handle, gfp_t flag,</span>
<span class="p_add">+				    struct dma_attrs *attrs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dma_map_ops *ops = get_dma_ops(dev);</span>
<span class="p_add">+	void *memory;</span>
<span class="p_add">+</span>
<span class="p_add">+	memory = ops-&gt;alloc(dev, size, dma_handle, flag, attrs);</span>
<span class="p_add">+	return memory;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define dma_free_coherent(d, s, c, h) dma_free_attrs(d, s, c, h, NULL)</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void dma_free_attrs(struct device *dev, size_t size,</span>
<span class="p_add">+				  void *cpu_addr, dma_addr_t dma_handle,</span>
<span class="p_add">+				  struct dma_attrs *attrs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct dma_map_ops *ops = get_dma_ops(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	ops-&gt;free(dev, size, cpu_addr, dma_handle, attrs);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int dma_mapping_error(struct device *dev, dma_addr_t dma_addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/elf.h b/arch/h8300/include/asm/elf.h</span>
new file mode 100644
<span class="p_header">index 0000000..09031d0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/elf.h</span>
<span class="p_chunk">@@ -0,0 +1,101 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __ASM_H8300_ELF_H</span>
<span class="p_add">+#define __ASM_H8300_ELF_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ELF register definitions..</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/user.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+typedef unsigned long elf_greg_t;</span>
<span class="p_add">+</span>
<span class="p_add">+#define ELF_NGREG (sizeof(struct user_regs_struct) / sizeof(elf_greg_t))</span>
<span class="p_add">+typedef elf_greg_t elf_gregset_t[ELF_NGREG];</span>
<span class="p_add">+typedef unsigned long elf_fpregset_t;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is used to ensure we don&#39;t load something for the wrong architecture.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define elf_check_arch(x) ((x)-&gt;e_machine == EM_H8_300)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * These are used to set parameters in the core dumps.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ELF_CLASS	ELFCLASS32</span>
<span class="p_add">+#define ELF_DATA	ELFDATA2MSB</span>
<span class="p_add">+#define ELF_ARCH	EM_H8_300</span>
<span class="p_add">+#if defined(CONFIG_CPU_H8300H)</span>
<span class="p_add">+#define ELF_CORE_EFLAGS 0x810000</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#if defined(CONFIG_CPU_H8S)</span>
<span class="p_add">+#define ELF_CORE_EFLAGS 0x820000</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define ELF_PLAT_INIT(_r) do { (_r)-&gt;er1 = 0; } while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define ELF_EXEC_PAGESIZE	4096</span>
<span class="p_add">+</span>
<span class="p_add">+/* This is the location that an ET_DYN program is loaded if exec&#39;ed.  Typical</span>
<span class="p_add">+   use of this is to invoke &quot;./ld.so someprog&quot; to test out a new version of</span>
<span class="p_add">+   the loader.  We need to make sure that it is out of the way of the program</span>
<span class="p_add">+   that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */</span>
<span class="p_add">+</span>
<span class="p_add">+#define ELF_ET_DYN_BASE         0xD0000000UL</span>
<span class="p_add">+</span>
<span class="p_add">+/* This yields a mask that user programs can use to figure out what</span>
<span class="p_add">+   instruction set this cpu supports.  */</span>
<span class="p_add">+</span>
<span class="p_add">+#define ELF_HWCAP	(0)</span>
<span class="p_add">+</span>
<span class="p_add">+/* This yields a string that ld.so will use to load implementation</span>
<span class="p_add">+   specific libraries for optimization.  This is more specific in</span>
<span class="p_add">+   intent than poking at uname or /proc/cpuinfo.  */</span>
<span class="p_add">+</span>
<span class="p_add">+#define ELF_PLATFORM  (NULL)</span>
<span class="p_add">+</span>
<span class="p_add">+#define R_H8_NONE       0</span>
<span class="p_add">+#define R_H8_DIR32      1</span>
<span class="p_add">+#define R_H8_DIR32_28   2</span>
<span class="p_add">+#define R_H8_DIR32_24   3</span>
<span class="p_add">+#define R_H8_DIR32_16   4</span>
<span class="p_add">+#define R_H8_DIR32U     6</span>
<span class="p_add">+#define R_H8_DIR32U_28  7</span>
<span class="p_add">+#define R_H8_DIR32U_24  8</span>
<span class="p_add">+#define R_H8_DIR32U_20  9</span>
<span class="p_add">+#define R_H8_DIR32U_16 10</span>
<span class="p_add">+#define R_H8_DIR24     11</span>
<span class="p_add">+#define R_H8_DIR24_20  12</span>
<span class="p_add">+#define R_H8_DIR24_16  13</span>
<span class="p_add">+#define R_H8_DIR24U    14</span>
<span class="p_add">+#define R_H8_DIR24U_20 15</span>
<span class="p_add">+#define R_H8_DIR24U_16 16</span>
<span class="p_add">+#define R_H8_DIR16     17</span>
<span class="p_add">+#define R_H8_DIR16U    18</span>
<span class="p_add">+#define R_H8_DIR16S_32 19</span>
<span class="p_add">+#define R_H8_DIR16S_28 20</span>
<span class="p_add">+#define R_H8_DIR16S_24 21</span>
<span class="p_add">+#define R_H8_DIR16S_20 22</span>
<span class="p_add">+#define R_H8_DIR16S    23</span>
<span class="p_add">+#define R_H8_DIR8      24</span>
<span class="p_add">+#define R_H8_DIR8U     25</span>
<span class="p_add">+#define R_H8_DIR8Z_32  26</span>
<span class="p_add">+#define R_H8_DIR8Z_28  27</span>
<span class="p_add">+#define R_H8_DIR8Z_24  28</span>
<span class="p_add">+#define R_H8_DIR8Z_20  29</span>
<span class="p_add">+#define R_H8_DIR8Z_16  30</span>
<span class="p_add">+#define R_H8_PCREL16   31</span>
<span class="p_add">+#define R_H8_PCREL8    32</span>
<span class="p_add">+#define R_H8_BPOS      33</span>
<span class="p_add">+#define R_H8_PCREL32   34</span>
<span class="p_add">+#define R_H8_GOT32O    35</span>
<span class="p_add">+#define R_H8_GOT16O    36</span>
<span class="p_add">+#define R_H8_DIR16A8   59</span>
<span class="p_add">+#define R_H8_DIR16R8   60</span>
<span class="p_add">+#define R_H8_DIR24A8   61</span>
<span class="p_add">+#define R_H8_DIR24R8   62</span>
<span class="p_add">+#define R_H8_DIR32A16  63</span>
<span class="p_add">+#define R_H8_ABS32     65</span>
<span class="p_add">+#define R_H8_ABS32A16 127</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/flat.h b/arch/h8300/include/asm/flat.h</span>
new file mode 100644
<span class="p_header">index 0000000..a4898ec</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/flat.h</span>
<span class="p_chunk">@@ -0,0 +1,28 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * arch/h8300/asm/include/flat.h -- uClinux flat-format executables</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __H8300_FLAT_H__</span>
<span class="p_add">+#define __H8300_FLAT_H__</span>
<span class="p_add">+</span>
<span class="p_add">+#define	flat_argvp_envp_on_stack()		1</span>
<span class="p_add">+#define	flat_old_ram_flag(flags)		1</span>
<span class="p_add">+#define	flat_reloc_valid(reloc, size)		((reloc) &lt;= (size))</span>
<span class="p_add">+#define	flat_set_persistent(relval, p)		0</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * on the H8 a couple of the relocations have an instruction in the</span>
<span class="p_add">+ * top byte.  As there can only be 24bits of address space,  we just</span>
<span class="p_add">+ * always preserve that 8bits at the top,  when it isn&#39;t an instruction</span>
<span class="p_add">+ * is is 0 (davidm@snapgear.com)</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define	flat_get_relocate_addr(rel)		(rel &amp; ~0x00000001)</span>
<span class="p_add">+#define flat_get_addr_from_rp(rp, relval, flags, persistent) \</span>
<span class="p_add">+	({(void)persistent; \</span>
<span class="p_add">+		get_unaligned(rp) &amp; (((flags) &amp; FLAT_FLAG_GOTPIC) ?	\</span>
<span class="p_add">+				     0xffffffff : 0x00ffffff); })</span>
<span class="p_add">+#define flat_put_addr_at_rp(rp, addr, rel) \</span>
<span class="p_add">+	put_unaligned(((*(char *)(rp)) &lt;&lt; 24) | ((addr) &amp; 0x00ffffff), (rp))</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __H8300_FLAT_H__ */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/io.h b/arch/h8300/include/asm/io.h</span>
new file mode 100644
<span class="p_header">index 0000000..1d09b2f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/io.h</span>
<span class="p_chunk">@@ -0,0 +1,57 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_IO_H</span>
<span class="p_add">+#define _H8300_IO_H</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/io.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* H8/300 internal I/O functions */</span>
<span class="p_add">+static inline unsigned char ctrl_inb(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return *(volatile unsigned char *)addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned short ctrl_inw(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return *(volatile unsigned short *)addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long ctrl_inl(unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return *(volatile unsigned long *)addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void ctrl_outb(unsigned char b, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*(volatile unsigned char *)addr = b;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void ctrl_outw(unsigned short b, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*(volatile unsigned short *)addr = b;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void ctrl_outl(unsigned long b, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	*(volatile unsigned long *)addr = b;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void ctrl_bclr(int b, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (__builtin_constant_p(b))</span>
<span class="p_add">+		__asm__(&quot;bclr %1,%0&quot; : : &quot;WU&quot;(addr), &quot;i&quot;(b));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		__asm__(&quot;bclr %w1,%0&quot; : : &quot;WU&quot;(addr), &quot;r&quot;(b));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void ctrl_bset(int b, unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (__builtin_constant_p(b))</span>
<span class="p_add">+		__asm__(&quot;bset %1,%0&quot; : : &quot;WU&quot;(addr), &quot;i&quot;(b));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		__asm__(&quot;bset %w1,%0&quot; : : &quot;WU&quot;(addr), &quot;r&quot;(b));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __KERNEL__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_IO_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/irq.h b/arch/h8300/include/asm/irq.h</span>
new file mode 100644
<span class="p_header">index 0000000..69f23f0</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/irq.h</span>
<span class="p_chunk">@@ -0,0 +1,26 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_IRQ_H_</span>
<span class="p_add">+#define _H8300_IRQ_H_</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/irqchip.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#if defined(CONFIG_CPU_H8300H)</span>
<span class="p_add">+#define NR_IRQS 64</span>
<span class="p_add">+#define IRQ_CHIP h8300h_irq_chip</span>
<span class="p_add">+#define EXT_IRQ0 12</span>
<span class="p_add">+#define EXT_IRQS 6</span>
<span class="p_add">+#elif defined(CONFIG_CPU_H8S)</span>
<span class="p_add">+#define NR_IRQS 128</span>
<span class="p_add">+#define IRQ_CHIP h8s_irq_chip</span>
<span class="p_add">+#define EXT_IRQ0 16</span>
<span class="p_add">+#define EXT_IRQS 16</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int irq_canonicalize(int irq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return irq;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void h8300_init_ipr(void);</span>
<span class="p_add">+extern struct irq_chip h8300h_irq_chip;</span>
<span class="p_add">+extern struct irq_chip h8s_irq_chip;</span>
<span class="p_add">+#endif /* _H8300_IRQ_H_ */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/irqflags.h b/arch/h8300/include/asm/irqflags.h</span>
new file mode 100644
<span class="p_header">index 0000000..5e1e324</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/irqflags.h</span>
<span class="p_chunk">@@ -0,0 +1,96 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_IRQFLAGS_H</span>
<span class="p_add">+#define _H8300_IRQFLAGS_H</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_CPU_H8300H</span>
<span class="p_add">+typedef unsigned char h8300flags;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline h8300flags arch_local_save_flags(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ volatile (&quot;stc ccr,%w0&quot; : &quot;=r&quot; (flags));</span>
<span class="p_add">+	return flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arch_local_irq_disable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__asm__ volatile (&quot;orc  #0xc0,ccr&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arch_local_irq_enable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__asm__ volatile (&quot;andc #0x3f,ccr&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline h8300flags arch_local_irq_save(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ volatile (&quot;stc ccr,%w0\n\t&quot;</span>
<span class="p_add">+		      &quot;orc  #0xc0,ccr&quot; : &quot;=r&quot; (flags));</span>
<span class="p_add">+	return flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arch_local_irq_restore(h8300flags flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__asm__ volatile (&quot;ldc %w0,ccr&quot; : : &quot;r&quot; (flags) : &quot;cc&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int arch_irqs_disabled_flags(unsigned long flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (flags &amp; 0xc0) == 0xc0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#ifdef CONFIG_CPU_H8S</span>
<span class="p_add">+typedef unsigned short h8300flags;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline h8300flags arch_local_save_flags(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ volatile (&quot;stc ccr,%w0\n\tstc exr,%x0&quot; : &quot;=r&quot; (flags));</span>
<span class="p_add">+	return flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arch_local_irq_disable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__asm__ volatile (&quot;orc #0x80,ccr\n\t&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arch_local_irq_enable(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__asm__ volatile (&quot;andc #0x7f,ccr\n\t&quot;</span>
<span class="p_add">+		      &quot;andc #0xf0,exr\n\t&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline h8300flags arch_local_irq_save(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	h8300flags flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__ volatile (&quot;stc ccr,%w0\n\t&quot;</span>
<span class="p_add">+		      &quot;stc exr,%x0\n\t&quot;</span>
<span class="p_add">+		      &quot;orc  #0x80,ccr\n\t&quot;</span>
<span class="p_add">+		      : &quot;=r&quot; (flags));</span>
<span class="p_add">+	return flags;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arch_local_irq_restore(h8300flags flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__asm__ volatile (&quot;ldc %w0,ccr\n\t&quot;</span>
<span class="p_add">+		      &quot;ldc %x0,exr&quot;</span>
<span class="p_add">+		      : : &quot;r&quot; (flags) : &quot;cc&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int arch_irqs_disabled_flags(h8300flags flags)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (flags &amp; 0x0080) == 0x0080;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int arch_irqs_disabled(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return arch_irqs_disabled_flags(arch_local_save_flags());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_IRQFLAGS_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/mc146818rtc.h b/arch/h8300/include/asm/mc146818rtc.h</span>
new file mode 100644
<span class="p_header">index 0000000..ab9d964</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/mc146818rtc.h</span>
<span class="p_chunk">@@ -0,0 +1,9 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Machine dependent access functions for RTC registers.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifndef _H8300_MC146818RTC_H</span>
<span class="p_add">+#define _H8300_MC146818RTC_H</span>
<span class="p_add">+</span>
<span class="p_add">+/* empty include file to satisfy the include in genrtc.c/ide-geometry.c */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_MC146818RTC_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/mutex.h b/arch/h8300/include/asm/mutex.h</span>
new file mode 100644
<span class="p_header">index 0000000..458c1f7</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/mutex.h</span>
<span class="p_chunk">@@ -0,0 +1,9 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Pull in the generic implementation for the mutex fastpath.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * TODO: implement optimized primitives instead, or leave the generic</span>
<span class="p_add">+ * implementation in place, or pick the atomic_xchg() based generic</span>
<span class="p_add">+ * implementation. (see asm-generic/mutex-xchg.h for details)</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/mutex-dec.h&gt;</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/page.h b/arch/h8300/include/asm/page.h</span>
new file mode 100644
<span class="p_header">index 0000000..ee2f07c</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/page.h</span>
<span class="p_chunk">@@ -0,0 +1,11 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_PAGE_H</span>
<span class="p_add">+#define _H8300_PAGE_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/page.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAP_NR(addr) (((uintptr_t)(addr)-PAGE_OFFSET) &gt;&gt; PAGE_SHIFT)</span>
<span class="p_add">+#define VM_DATA_DEFAULT_FLAGS	(VM_READ | VM_WRITE | VM_EXEC | \</span>
<span class="p_add">+				 VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/page_offset.h b/arch/h8300/include/asm/page_offset.h</span>
new file mode 100644
<span class="p_header">index 0000000..888576d</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/page_offset.h</span>
<span class="p_chunk">@@ -0,0 +1,2 @@</span> <span class="p_context"></span>
<span class="p_add">+</span>
<span class="p_add">+#define PAGE_OFFSET_RAW		0x00000000</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/pci.h b/arch/h8300/include/asm/pci.h</span>
new file mode 100644
<span class="p_header">index 0000000..0b2acaa</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/pci.h</span>
<span class="p_chunk">@@ -0,0 +1,19 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_H8300_PCI_H</span>
<span class="p_add">+#define _ASM_H8300_PCI_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * asm-h8300/pci.h - H8/300 specific PCI declarations.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define pcibios_assign_all_busses()	0</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void pcibios_penalize_isa_irq(int irq, int active)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* We don&#39;t do dynamic PCI IRQ allocation */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define PCI_DMA_BUS_IS_PHYS	(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_H8300_PCI_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/pgtable.h b/arch/h8300/include/asm/pgtable.h</span>
new file mode 100644
<span class="p_header">index 0000000..8341db6</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -0,0 +1,49 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_PGTABLE_H</span>
<span class="p_add">+#define _H8300_PGTABLE_H</span>
<span class="p_add">+#include &lt;asm-generic/pgtable-nopud.h&gt;</span>
<span class="p_add">+#include &lt;asm-generic/pgtable.h&gt;</span>
<span class="p_add">+#define pgtable_cache_init()   do { } while (0)</span>
<span class="p_add">+extern void paging_init(void);</span>
<span class="p_add">+#define PAGE_NONE		__pgprot(0)    /* these mean nothing to NO_MM */</span>
<span class="p_add">+#define PAGE_SHARED		__pgprot(0)    /* these mean nothing to NO_MM */</span>
<span class="p_add">+#define PAGE_COPY		__pgprot(0)    /* these mean nothing to NO_MM */</span>
<span class="p_add">+#define PAGE_READONLY	__pgprot(0)    /* these mean nothing to NO_MM */</span>
<span class="p_add">+#define PAGE_KERNEL		__pgprot(0)    /* these mean nothing to NO_MM */</span>
<span class="p_add">+#define __swp_type(x)		(0)</span>
<span class="p_add">+#define __swp_offset(x)		(0)</span>
<span class="p_add">+#define __swp_entry(typ, off)	((swp_entry_t) { ((typ) | ((off) &lt;&lt; 7)) })</span>
<span class="p_add">+#define __pte_to_swp_entry(pte)	((swp_entry_t) { pte_val(pte) })</span>
<span class="p_add">+#define __swp_entry_to_pte(x)	((pte_t) { (x).val })</span>
<span class="p_add">+#define kern_addr_valid(addr)	(1)</span>
<span class="p_add">+#define pgprot_writecombine(prot)  (prot)</span>
<span class="p_add">+#define pgprot_noncached pgprot_writecombine</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int pte_file(pte_t pte) { return 0; }</span>
<span class="p_add">+#define swapper_pg_dir ((pgd_t *) 0)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * ZERO_PAGE is a global shared page that is always zero: used</span>
<span class="p_add">+ * for zero-mapped memory areas etc..</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define ZERO_PAGE(vaddr)	(virt_to_page(0))</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * These would be in other places but having them here reduces the diffs.</span>
<span class="p_add">+ */</span>
<span class="p_add">+extern unsigned int kobjsize(const void *objp);</span>
<span class="p_add">+extern int is_in_rom(unsigned long);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * No page table caches to initialise</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define pgtable_cache_init()   do { } while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * All 32bit addresses are effectively valid for vmalloc...</span>
<span class="p_add">+ * Sort of meaningless for non-VM targets.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define	VMALLOC_START	0</span>
<span class="p_add">+#define	VMALLOC_END	0xffffffff</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_enter_lazy_cpu_mode()    do {} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_PGTABLE_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/processor.h b/arch/h8300/include/asm/processor.h</span>
new file mode 100644
<span class="p_header">index 0000000..54e3fd8</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/processor.h</span>
<span class="p_chunk">@@ -0,0 +1,144 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * include/asm-h8300/processor.h</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2002 Yoshinori Sato</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Based on: linux/asm-m68nommu/processor.h</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 1995 Hamish Macdonald</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASM_H8300_PROCESSOR_H</span>
<span class="p_add">+#define __ASM_H8300_PROCESSOR_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Default implementation of macro that returns current</span>
<span class="p_add">+ * instruction pointer (&quot;program counter&quot;).</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define current_text_addr() ({ __label__ _l; _l: &amp;&amp;_l; })</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+#include &lt;asm/segment.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/current.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline unsigned long rdusp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern unsigned int	_sw_usp;</span>
<span class="p_add">+</span>
<span class="p_add">+	return _sw_usp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void wrusp(unsigned long usp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	extern unsigned int	_sw_usp;</span>
<span class="p_add">+</span>
<span class="p_add">+	_sw_usp = usp;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * User space process size: 3.75GB. This is hardcoded into a few places,</span>
<span class="p_add">+ * so don&#39;t change it unless you know what you are doing.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define TASK_SIZE	(0xFFFFFFFFUL)</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__</span>
<span class="p_add">+#define STACK_TOP	TASK_SIZE</span>
<span class="p_add">+#define STACK_TOP_MAX	STACK_TOP</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This decides where the kernel will search for a free chunk of vm</span>
<span class="p_add">+ * space during mmap&#39;s. We won&#39;t be using it</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define TASK_UNMAPPED_BASE	0</span>
<span class="p_add">+</span>
<span class="p_add">+struct thread_struct {</span>
<span class="p_add">+	unsigned long  ksp;		/* kernel stack pointer */</span>
<span class="p_add">+	unsigned long  usp;		/* user stack pointer */</span>
<span class="p_add">+	unsigned long  ccr;		/* saved status register */</span>
<span class="p_add">+	unsigned long  esp0;            /* points to SR of stack frame */</span>
<span class="p_add">+	struct {</span>
<span class="p_add">+		unsigned short *addr;</span>
<span class="p_add">+		unsigned short inst;</span>
<span class="p_add">+	} breakinfo;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define INIT_THREAD  {						\</span>
<span class="p_add">+	.ksp  = sizeof(init_stack) + (unsigned long)init_stack, \</span>
<span class="p_add">+	.usp  = 0,						\</span>
<span class="p_add">+	.ccr  = PS_S,						\</span>
<span class="p_add">+	.esp0 = 0,						\</span>
<span class="p_add">+	.breakinfo = {						\</span>
<span class="p_add">+		.addr = (unsigned short *)-1,			\</span>
<span class="p_add">+		.inst = 0					\</span>
<span class="p_add">+	}							\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Do necessary setup to start up a newly executed thread.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * pass the data segment into user programs if it exists,</span>
<span class="p_add">+ * it can&#39;t hurt anything as far as I can tell</span>
<span class="p_add">+ */</span>
<span class="p_add">+#if defined(CONFIG_CPU_H8300H)</span>
<span class="p_add">+#define start_thread(_regs, _pc, _usp)				\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	(_regs)-&gt;pc = (_pc);					\</span>
<span class="p_add">+	(_regs)-&gt;ccr = 0x00;	   /* clear all flags */	\</span>
<span class="p_add">+	(_regs)-&gt;er5 = current-&gt;mm-&gt;start_data;	/* GOT base */	\</span>
<span class="p_add">+	(_regs)-&gt;sp = ((unsigned long)(_usp)) - sizeof(unsigned long) * 3; \</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#if defined(CONFIG_CPU_H8S)</span>
<span class="p_add">+#define start_thread(_regs, _pc, _usp)				\</span>
<span class="p_add">+do {								\</span>
<span class="p_add">+	(_regs)-&gt;pc = (_pc);					\</span>
<span class="p_add">+	(_regs)-&gt;ccr = 0x00;	   /* clear kernel flag */	\</span>
<span class="p_add">+	(_regs)-&gt;exr = 0x78;	   /* enable all interrupts */	\</span>
<span class="p_add">+	(_regs)-&gt;er5 = current-&gt;mm-&gt;start_data;	/* GOT base */	\</span>
<span class="p_add">+	/* 14 = space for retaddr(4), vector(4), er0(4) and exr(2) on stack */ \</span>
<span class="p_add">+	(_regs)-&gt;sp = ((unsigned long)(_usp)) - 14;		\</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+/* Forward declaration, a strange C thing */</span>
<span class="p_add">+struct task_struct;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Free all resources held by a thread. */</span>
<span class="p_add">+static inline void release_thread(struct task_struct *dead_task)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Free current thread data structures etc..</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void exit_thread(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Return saved PC of a blocked thread.</span>
<span class="p_add">+ */</span>
<span class="p_add">+unsigned long thread_saved_pc(struct task_struct *tsk);</span>
<span class="p_add">+unsigned long get_wchan(struct task_struct *p);</span>
<span class="p_add">+</span>
<span class="p_add">+#define	KSTK_EIP(tsk)	\</span>
<span class="p_add">+	({			 \</span>
<span class="p_add">+		unsigned long eip = 0;	      \</span>
<span class="p_add">+		if ((tsk)-&gt;thread.esp0 &gt; PAGE_SIZE &amp;&amp;	\</span>
<span class="p_add">+		    MAP_NR((tsk)-&gt;thread.esp0) &lt; max_mapnr)	 \</span>
<span class="p_add">+			eip = ((struct pt_regs *) (tsk)-&gt;thread.esp0)-&gt;pc; \</span>
<span class="p_add">+		eip; })</span>
<span class="p_add">+</span>
<span class="p_add">+#define	KSTK_ESP(tsk)	((tsk) == current ? rdusp() : (tsk)-&gt;thread.usp)</span>
<span class="p_add">+</span>
<span class="p_add">+#define cpu_relax()    barrier()</span>
<span class="p_add">+#define cpu_relax_lowlatency()	cpu_relax()</span>
<span class="p_add">+</span>
<span class="p_add">+#define HARD_RESET_NOW() ({		\</span>
<span class="p_add">+	local_irq_disable();		\</span>
<span class="p_add">+	asm(&quot;jmp @@0&quot;);			\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/ptrace.h b/arch/h8300/include/asm/ptrace.h</span>
new file mode 100644
<span class="p_header">index 0000000..e693fb4</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -0,0 +1,36 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_PTRACE_H</span>
<span class="p_add">+#define _H8300_PTRACE_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;uapi/asm/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+#ifndef PS_S</span>
<span class="p_add">+#define PS_S  (0x10)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#if defined(CONFIG_CPU_H8300H)</span>
<span class="p_add">+#define H8300_REGS_NO 11</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#if defined(CONFIG_CPU_H8S)</span>
<span class="p_add">+#define H8300_REGS_NO 12</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+#define arch_has_single_step()	(1)</span>
<span class="p_add">+</span>
<span class="p_add">+#define user_mode(regs) (!((regs)-&gt;ccr &amp; PS_S))</span>
<span class="p_add">+#define instruction_pointer(regs) ((regs)-&gt;pc)</span>
<span class="p_add">+#define profile_pc(regs) instruction_pointer(regs)</span>
<span class="p_add">+#define user_stack_pointer(regs) ((regs)-&gt;sp)</span>
<span class="p_add">+#define current_pt_regs() ((struct pt_regs *) \</span>
<span class="p_add">+	(THREAD_SIZE + (unsigned long)current_thread_info()) - 1)</span>
<span class="p_add">+#define signal_pt_regs() ((struct pt_regs *)current-&gt;thread.esp0)</span>
<span class="p_add">+#define current_user_stack_pointer() rdusp()</span>
<span class="p_add">+#define task_pt_regs(task) \</span>
<span class="p_add">+	((struct pt_regs *) (task_stack_page(task) + THREAD_SIZE) - 1)</span>
<span class="p_add">+</span>
<span class="p_add">+extern long h8300_get_reg(struct task_struct *task, int regno);</span>
<span class="p_add">+extern int h8300_put_reg(struct task_struct *task, int regno,</span>
<span class="p_add">+			 unsigned long data);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
<span class="p_add">+#endif /* _H8300_PTRACE_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/segment.h b/arch/h8300/include/asm/segment.h</span>
new file mode 100644
<span class="p_header">index 0000000..c8bc68e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/segment.h</span>
<span class="p_chunk">@@ -0,0 +1,49 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_SEGMENT_H</span>
<span class="p_add">+#define _H8300_SEGMENT_H</span>
<span class="p_add">+</span>
<span class="p_add">+/* define constants */</span>
<span class="p_add">+#define USER_DATA     (1)</span>
<span class="p_add">+#ifndef __USER_DS</span>
<span class="p_add">+#define __USER_DS     (USER_DATA)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#define USER_PROGRAM  (2)</span>
<span class="p_add">+#define SUPER_DATA    (3)</span>
<span class="p_add">+#ifndef __KERNEL_DS</span>
<span class="p_add">+#define __KERNEL_DS   (SUPER_DATA)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+#define SUPER_PROGRAM (4)</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+typedef struct {</span>
<span class="p_add">+	unsigned long seg;</span>
<span class="p_add">+} mm_segment_t;</span>
<span class="p_add">+</span>
<span class="p_add">+#define MAKE_MM_SEG(s)	((mm_segment_t) { (s) })</span>
<span class="p_add">+#define USER_DS		MAKE_MM_SEG(__USER_DS)</span>
<span class="p_add">+#define KERNEL_DS	MAKE_MM_SEG(__KERNEL_DS)</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Get/set the SFC/DFC registers for MOVES instructions</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static inline mm_segment_t get_fs(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return USER_DS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline mm_segment_t get_ds(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* return the supervisor data space code */</span>
<span class="p_add">+	return KERNEL_DS;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void set_fs(mm_segment_t val)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define segment_eq(a, b)	((a).seg == (b).seg)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_SEGMENT_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/signal.h b/arch/h8300/include/asm/signal.h</span>
new file mode 100644
<span class="p_header">index 0000000..5870835</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/signal.h</span>
<span class="p_chunk">@@ -0,0 +1,22 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_SIGNAL_H</span>
<span class="p_add">+#define _H8300_SIGNAL_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;uapi/asm/signal.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Most things should be clean enough to redefine this at will, if care</span>
<span class="p_add">+   is taken to make libc match.  */</span>
<span class="p_add">+</span>
<span class="p_add">+#define _NSIG		64</span>
<span class="p_add">+#define _NSIG_BPW	32</span>
<span class="p_add">+#define _NSIG_WORDS	(_NSIG / _NSIG_BPW)</span>
<span class="p_add">+</span>
<span class="p_add">+typedef unsigned long old_sigset_t;		/* at least 32 bits */</span>
<span class="p_add">+</span>
<span class="p_add">+typedef struct {</span>
<span class="p_add">+	unsigned long sig[_NSIG_WORDS];</span>
<span class="p_add">+} sigset_t;</span>
<span class="p_add">+</span>
<span class="p_add">+#define __ARCH_HAS_SA_RESTORER</span>
<span class="p_add">+#include &lt;asm/sigcontext.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_SIGNAL_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/smp.h b/arch/h8300/include/asm/smp.h</span>
new file mode 100644
<span class="p_header">index 0000000..9e9bd7e</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/smp.h</span>
<span class="p_chunk">@@ -0,0 +1 @@</span> <span class="p_context"></span>
<span class="p_add">+/* nothing required here yet */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/string.h b/arch/h8300/include/asm/string.h</span>
new file mode 100644
<span class="p_header">index 0000000..5dc5a8a</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/string.h</span>
<span class="p_chunk">@@ -0,0 +1,17 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_STRING_H_</span>
<span class="p_add">+#define _H8300_STRING_H_</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__ /* only set these up for kernel code */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define __HAVE_ARCH_MEMSET</span>
<span class="p_add">+extern void *memset(void *s, int c, size_t count);</span>
<span class="p_add">+</span>
<span class="p_add">+#define __HAVE_ARCH_MEMCPY</span>
<span class="p_add">+extern void *memcpy(void *d, const void *s, size_t count);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* KERNEL */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/switch_to.h b/arch/h8300/include/asm/switch_to.h</span>
new file mode 100644
<span class="p_header">index 0000000..7ad1bf9</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -0,0 +1,51 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_SWITCH_TO_H</span>
<span class="p_add">+#define _H8300_SWITCH_TO_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * switch_to(n) should switch tasks to task ptr, first checking that</span>
<span class="p_add">+ * ptr isn&#39;t the current task, in which case it does nothing.  This</span>
<span class="p_add">+ * also clears the TS-flag if the task we switched to has used the</span>
<span class="p_add">+ * math co-processor latest.</span>
<span class="p_add">+ */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * switch_to() saves the extra registers, that are not saved</span>
<span class="p_add">+ * automatically by SAVE_SWITCH_STACK in resume(), ie. d0-d5 and</span>
<span class="p_add">+ * a0-a1. Some of these are used by schedule() and its predecessors</span>
<span class="p_add">+ * and so we might get see unexpected behaviors when a task returns</span>
<span class="p_add">+ * with unexpected register values.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * syscall stores these registers itself and none of them are used</span>
<span class="p_add">+ * by syscall after the function in the syscall has been called.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Beware that resume now expects *next to be in d1 and the offset of</span>
<span class="p_add">+ * tss to be in a1. This saves a few instructions as we no longer have</span>
<span class="p_add">+ * to push them onto the stack and read them back right after.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * 02/17/96 - Jes Sorensen (jds@kom.auc.dk)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Changed 96/09/19 by Andreas Schwab</span>
<span class="p_add">+ * pass prev in a0, next in a1, offset of tss in d1, and whether</span>
<span class="p_add">+ * the mm structures are shared in d2 (to avoid atc flushing).</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * H8/300 Porting 2002/09/04 Yoshinori Sato</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+asmlinkage void resume(void);</span>
<span class="p_add">+#define switch_to(prev, next, last) \</span>
<span class="p_add">+do {			     \</span>
<span class="p_add">+	void *_last;					    \</span>
<span class="p_add">+	__asm__ __volatile__(				    \</span>
<span class="p_add">+		&quot;mov.l	%1, er0\n\t&quot;			    \</span>
<span class="p_add">+		&quot;mov.l	%2, er1\n\t&quot;			    \</span>
<span class="p_add">+		&quot;mov.l	%3, er2\n\t&quot;			    \</span>
<span class="p_add">+		&quot;jsr @_resume\n\t&quot;			    \</span>
<span class="p_add">+		&quot;mov.l	er2,%0\n\t&quot;			    \</span>
<span class="p_add">+		: &quot;=r&quot; (_last)				    \</span>
<span class="p_add">+		: &quot;r&quot; (&amp;(prev-&gt;thread)),		    \</span>
<span class="p_add">+		  &quot;r&quot; (&amp;(next-&gt;thread)),		    \</span>
<span class="p_add">+		  &quot;g&quot; (prev)				    \</span>
<span class="p_add">+		: &quot;cc&quot;, &quot;er0&quot;, &quot;er1&quot;, &quot;er2&quot;, &quot;er3&quot;);	    \</span>
<span class="p_add">+	(last) = _last;					    \</span>
<span class="p_add">+} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_SWITCH_TO_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/syscall.h b/arch/h8300/include/asm/syscall.h</span>
new file mode 100644
<span class="p_header">index 0000000..b41f688</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/syscall.h</span>
<span class="p_chunk">@@ -0,0 +1,56 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __ASM_H8300_SYSCALLS_32_H</span>
<span class="p_add">+#define __ASM_H8300_SYSCALLS_32_H</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+#include &lt;linux/linkage.h&gt;</span>
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline int</span>
<span class="p_add">+syscall_get_nr(struct task_struct *task, struct pt_regs *regs)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return regs-&gt;orig_er0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+syscall_get_arguments(struct task_struct *task, struct pt_regs *regs,</span>
<span class="p_add">+		      unsigned int i, unsigned int n, unsigned long *args)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(i + n &gt; 6);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (n &gt; 0) {</span>
<span class="p_add">+		switch (i) {</span>
<span class="p_add">+		case 0:</span>
<span class="p_add">+			*args++ = regs-&gt;er1;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 1:</span>
<span class="p_add">+			*args++ = regs-&gt;er2;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 2:</span>
<span class="p_add">+			*args++ = regs-&gt;er3;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 3:</span>
<span class="p_add">+			*args++ = regs-&gt;er4;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 4:</span>
<span class="p_add">+			*args++ = regs-&gt;er5;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 5:</span>
<span class="p_add">+			*args++ = regs-&gt;er6;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		i++;</span>
<span class="p_add">+		n--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/* Misc syscall related bits */</span>
<span class="p_add">+asmlinkage long do_syscall_trace_enter(struct pt_regs *regs);</span>
<span class="p_add">+asmlinkage void do_syscall_trace_leave(struct pt_regs *regs);</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __KERNEL__ */</span>
<span class="p_add">+#endif /* __ASM_H8300_SYSCALLS_32_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/thread_info.h b/arch/h8300/include/asm/thread_info.h</span>
new file mode 100644
<span class="p_header">index 0000000..a536241</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/thread_info.h</span>
<span class="p_chunk">@@ -0,0 +1,108 @@</span> <span class="p_context"></span>
<span class="p_add">+/* thread_info.h: h8300 low-level thread information</span>
<span class="p_add">+ * adapted from the i386 and PPC versions by Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2002  David Howells (dhowells@redhat.com)</span>
<span class="p_add">+ * - Incorporating suggestions made by Linus Torvalds and Dave Miller</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _ASM_THREAD_INFO_H</span>
<span class="p_add">+#define _ASM_THREAD_INFO_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef __KERNEL__</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef __ASSEMBLY__</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * low level task data.</span>
<span class="p_add">+ * If you change this, change the TI_* offsets below to match.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct thread_info {</span>
<span class="p_add">+	struct task_struct *task;		/* main task structure */</span>
<span class="p_add">+	unsigned long	   flags;		/* low level flags */</span>
<span class="p_add">+	int		   cpu;			/* cpu we&#39;re on */</span>
<span class="p_add">+	int		   preempt_count;	/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span>
<span class="p_add">+	struct restart_block restart_block;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * macros/functions for gaining access to the thread information structure</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define INIT_THREAD_INFO(tsk)			\</span>
<span class="p_add">+{						\</span>
<span class="p_add">+	.task =		&amp;tsk,			\</span>
<span class="p_add">+	.flags =	0,			\</span>
<span class="p_add">+	.cpu =		0,			\</span>
<span class="p_add">+	.preempt_count = INIT_PREEMPT_COUNT,	\</span>
<span class="p_add">+	.restart_block	= {			\</span>
<span class="p_add">+		.fn = do_no_restart_syscall,	\</span>
<span class="p_add">+	},					\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define init_thread_info	(init_thread_union.thread_info)</span>
<span class="p_add">+#define init_stack		(init_thread_union.stack)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Size of kernel stack for each process. This must be a power of 2...</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define THREAD_SIZE_ORDER	1</span>
<span class="p_add">+#define THREAD_SIZE		8192	/* 2 pages */</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/* how to get the thread information struct from C */</span>
<span class="p_add">+static inline struct thread_info *current_thread_info(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct thread_info *ti;</span>
<span class="p_add">+</span>
<span class="p_add">+	__asm__(&quot;mov.l	sp, %0\n\t&quot;</span>
<span class="p_add">+		&quot;and.w	%1, %T0&quot;</span>
<span class="p_add">+		: &quot;=&amp;r&quot;(ti)</span>
<span class="p_add">+		: &quot;i&quot; (~(THREAD_SIZE-1) &amp; 0xffff));</span>
<span class="p_add">+	return ti;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __ASSEMBLY__ */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * thread information flag bit numbers</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define TIF_SYSCALL_TRACE	0	/* syscall trace active */</span>
<span class="p_add">+#define TIF_SIGPENDING		1	/* signal pending */</span>
<span class="p_add">+#define TIF_NEED_RESCHED	2	/* rescheduling necessary */</span>
<span class="p_add">+#define TIF_SINGLESTEP		3	/* singlestepping active */</span>
<span class="p_add">+#define TIF_MEMDIE		4	/* is terminating due to OOM killer */</span>
<span class="p_add">+#define TIF_RESTORE_SIGMASK	5	/* restore signal mask in do_signal() */</span>
<span class="p_add">+#define TIF_NOTIFY_RESUME	6	/* callback before returning to user */</span>
<span class="p_add">+#define TIF_SYSCALL_AUDIT	7	/* syscall auditing active */</span>
<span class="p_add">+#define TIF_SYSCALL_TRACEPOINT	8	/* for ftrace syscall instrumentation */</span>
<span class="p_add">+#define TIF_POLLING_NRFLAG	9	/* true if poll_idle() is polling TIF_NEED_RESCHED */</span>
<span class="p_add">+</span>
<span class="p_add">+/* as above, but as bit values */</span>
<span class="p_add">+#define _TIF_SYSCALL_TRACE	(1 &lt;&lt; TIF_SYSCALL_TRACE)</span>
<span class="p_add">+#define _TIF_SIGPENDING		(1 &lt;&lt; TIF_SIGPENDING)</span>
<span class="p_add">+#define _TIF_NEED_RESCHED	(1 &lt;&lt; TIF_NEED_RESCHED)</span>
<span class="p_add">+#define _TIF_NOTIFY_RESUME	(1 &lt;&lt; TIF_NOTIFY_RESUME)</span>
<span class="p_add">+#define _TIF_SINGLESTEP		(1 &lt;&lt; TIF_SINGLESTEP)</span>
<span class="p_add">+#define _TIF_SYSCALL_AUDIT	(1 &lt;&lt; TIF_SYSCALL_AUDIT)</span>
<span class="p_add">+#define _TIF_SYSCALL_TRACEPOINT	(1 &lt;&lt; TIF_SYSCALL_TRACEPOINT)</span>
<span class="p_add">+#define _TIF_POLLING_NRFLAG	(1 &lt;&lt; TIF_POLLING_NRFLAG)</span>
<span class="p_add">+</span>
<span class="p_add">+/* work to do in syscall trace */</span>
<span class="p_add">+#define _TIF_WORK_SYSCALL_MASK	(_TIF_SYSCALL_TRACE | _TIF_SINGLESTEP | \</span>
<span class="p_add">+				 _TIF_SYSCALL_AUDIT | _TIF_SYSCALL_TRACEPOINT)</span>
<span class="p_add">+</span>
<span class="p_add">+/* work to do on any return to u-space */</span>
<span class="p_add">+#define _TIF_ALLWORK_MASK	(_TIF_SYSCALL_TRACE | _TIF_SIGPENDING      | \</span>
<span class="p_add">+				 _TIF_NEED_RESCHED  | _TIF_SYSCALL_AUDIT   | \</span>
<span class="p_add">+				 _TIF_SINGLESTEP    | _TIF_NOTIFY_RESUME   | \</span>
<span class="p_add">+				 _TIF_SYSCALL_TRACEPOINT)</span>
<span class="p_add">+</span>
<span class="p_add">+/* work to do on interrupt/exception return */</span>
<span class="p_add">+#define _TIF_WORK_MASK		(_TIF_ALLWORK_MASK &amp; ~(_TIF_SYSCALL_TRACE | \</span>
<span class="p_add">+				 _TIF_SYSCALL_AUDIT | _TIF_SINGLESTEP))</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* __KERNEL__ */</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_THREAD_INFO_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/tlb.h b/arch/h8300/include/asm/tlb.h</span>
new file mode 100644
<span class="p_header">index 0000000..2c6fa4ee</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/tlb.h</span>
<span class="p_chunk">@@ -0,0 +1,8 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __H8300_TLB_H__</span>
<span class="p_add">+#define __H8300_TLB_H__</span>
<span class="p_add">+</span>
<span class="p_add">+#define tlb_flush(tlb)	do { } while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm-generic/tlb.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/traps.h b/arch/h8300/include/asm/traps.h</span>
new file mode 100644
<span class="p_header">index 0000000..aa34e75</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/traps.h</span>
<span class="p_chunk">@@ -0,0 +1,41 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ *  linux/include/asm-h8300/traps.h</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  Copyright (C) 2003 Yoshinori Sato &lt;ysato@users.sourceforge.jp&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This file is subject to the terms and conditions of the GNU General Public</span>
<span class="p_add">+ * License.  See the file COPYING in the main directory of this archive</span>
<span class="p_add">+ * for more details.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#ifndef _H8300_TRAPS_H</span>
<span class="p_add">+#define _H8300_TRAPS_H</span>
<span class="p_add">+</span>
<span class="p_add">+extern void _system_call(void);</span>
<span class="p_add">+extern void _interrupt_entry(void);</span>
<span class="p_add">+extern void _trace_break(void);</span>
<span class="p_add">+extern void _nmi(void);</span>
<span class="p_add">+extern void _interrupt_entry(void);</span>
<span class="p_add">+</span>
<span class="p_add">+extern unsigned long *_interrupt_redirect_table;</span>
<span class="p_add">+</span>
<span class="p_add">+#define JMP_OP 0x5a000000</span>
<span class="p_add">+#define JSR_OP 0x5e000000</span>
<span class="p_add">+#define VECTOR(address) ((JMP_OP)|((unsigned long)address))</span>
<span class="p_add">+#define REDIRECT(address) ((JSR_OP)|((unsigned long)address))</span>
<span class="p_add">+#define CPU_VECTOR ((unsigned long *)0x000000)</span>
<span class="p_add">+#define ADDR_MASK (0xffffff)</span>
<span class="p_add">+</span>
<span class="p_add">+#define TRACE_VEC 5</span>
<span class="p_add">+</span>
<span class="p_add">+#define TRAP0_VEC 8</span>
<span class="p_add">+#define TRAP1_VEC 9</span>
<span class="p_add">+#define TRAP2_VEC 10</span>
<span class="p_add">+#define TRAP3_VEC 11</span>
<span class="p_add">+</span>
<span class="p_add">+extern char _start, _etext;</span>
<span class="p_add">+#define check_kernel_text(addr) \</span>
<span class="p_add">+	((addr &gt;= (unsigned long)(&amp;_start)) &amp;&amp; \</span>
<span class="p_add">+	 (addr &lt;  (unsigned long)(&amp;_etext)))</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_TRAPS_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/uaccess.h b/arch/h8300/include/asm/uaccess.h</span>
new file mode 100644
<span class="p_header">index 0000000..582af79</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -0,0 +1,131 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef __H8300_UACCESS_H</span>
<span class="p_add">+#define __H8300_UACCESS_H</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * User space memory access functions</span>
<span class="p_add">+ */</span>
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
<span class="p_add">+#include &lt;linux/string.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/segment.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define VERIFY_READ	0</span>
<span class="p_add">+#define VERIFY_WRITE	1</span>
<span class="p_add">+</span>
<span class="p_add">+/* We let the MMU do all checking */</span>
<span class="p_add">+#define access_ok(type, addr, size) __access_ok((unsigned long)addr, size)</span>
<span class="p_add">+static inline int __access_ok(unsigned long addr, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * The exception table consists of pairs of addresses: the first is the</span>
<span class="p_add">+ * address of an instruction that is allowed to fault, and the second is</span>
<span class="p_add">+ * the address at which the program should continue.  No registers are</span>
<span class="p_add">+ * modified, so it is entirely up to the continuation code to figure out</span>
<span class="p_add">+ * what to do.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * All the routines below use bits of fixup code that are out of line</span>
<span class="p_add">+ * with the main instruction path.  This means when everything is well,</span>
<span class="p_add">+ * we don&#39;t even have to jump over them.  Further, they do not intrude</span>
<span class="p_add">+ * on our cache or tlb entries.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+struct exception_table_entry {</span>
<span class="p_add">+	unsigned long insn, fixup;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Returns 0 if exception not found and fixup otherwise.  */</span>
<span class="p_add">+extern unsigned long search_exception_table(unsigned long);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * These are the main single-value transfer routines.  They automatically</span>
<span class="p_add">+ * use the right size if we just have the right pointer type.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define put_user(x, ptr)				\</span>
<span class="p_add">+({							\</span>
<span class="p_add">+	int __pu_err = 0;				\</span>
<span class="p_add">+	typeof(*(ptr)) __pu_val = (x);			\</span>
<span class="p_add">+	switch (sizeof(*(ptr))) {			\</span>
<span class="p_add">+	case 1:						\</span>
<span class="p_add">+	/* falll through */ \</span>
<span class="p_add">+	case 2:						\</span>
<span class="p_add">+	/* fall through */ \</span>
<span class="p_add">+	case 4:						\</span>
<span class="p_add">+		*(ptr) = x;				\</span>
<span class="p_add">+		break;					\</span>
<span class="p_add">+	case 8:						\</span>
<span class="p_add">+		memcpy(ptr, &amp;__pu_val, sizeof(*(ptr))); \</span>
<span class="p_add">+		break;					\</span>
<span class="p_add">+	default:					\</span>
<span class="p_add">+		__pu_err = __put_user_bad();		\</span>
<span class="p_add">+		break;					\</span>
<span class="p_add">+	}						\</span>
<span class="p_add">+	__pu_err;					\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
<span class="p_add">+#define __put_user(x, ptr) put_user(x, ptr)</span>
<span class="p_add">+</span>
<span class="p_add">+extern int __put_user_bad(void);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Tell gcc we read from memory instead of writing: this is because</span>
<span class="p_add">+ * we do not write to any memory gcc knows about, so there are no</span>
<span class="p_add">+ * aliasing issues.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define __ptr(x) ((unsigned long *)(x))</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Tell gcc we read from memory instead of writing: this is because</span>
<span class="p_add">+ * we do not write to any memory gcc knows about, so there are no</span>
<span class="p_add">+ * aliasing issues.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#define get_user(x, ptr)					\</span>
<span class="p_add">+({								\</span>
<span class="p_add">+	typeof(*(ptr)) __gu_val;				\</span>
<span class="p_add">+	int __gu_err = 0;					\</span>
<span class="p_add">+	switch (sizeof(*(ptr))) {				\</span>
<span class="p_add">+	case 1:							\</span>
<span class="p_add">+		*(u8 *)&amp;__gu_val = *((u8 *)(ptr));		\</span>
<span class="p_add">+		break;						\</span>
<span class="p_add">+	case 2:							\</span>
<span class="p_add">+		*(u16 *)&amp;__gu_val = *((u16 *)ptr);		\</span>
<span class="p_add">+		break;						\</span>
<span class="p_add">+	case 4:							\</span>
<span class="p_add">+		*(u32 *)&amp;__gu_val = *((u32 *)ptr);		\</span>
<span class="p_add">+		break;						\</span>
<span class="p_add">+	case 8:							\</span>
<span class="p_add">+		memcpy((void *)&amp;__gu_val, ptr, sizeof(*(ptr)));	\</span>
<span class="p_add">+		break;						\</span>
<span class="p_add">+	default:						\</span>
<span class="p_add">+		__gu_err = __get_user_bad();			\</span>
<span class="p_add">+		break;						\</span>
<span class="p_add">+	}							\</span>
<span class="p_add">+	(x) = (typeof(*(ptr)))__gu_val;				\</span>
<span class="p_add">+	__gu_err;						\</span>
<span class="p_add">+})</span>
<span class="p_add">+#define __get_user(x, ptr) get_user(x, ptr)</span>
<span class="p_add">+</span>
<span class="p_add">+extern int __get_user_bad(void);</span>
<span class="p_add">+</span>
<span class="p_add">+#define copy_from_user(to, from, n)		(memcpy(to, from, n), 0)</span>
<span class="p_add">+#define copy_to_user(to, from, n)		(memcpy(to, from, n), 0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define __copy_from_user(to, from, n) copy_from_user(to, from, n)</span>
<span class="p_add">+#define __copy_to_user(to, from, n) copy_to_user(to, from, n)</span>
<span class="p_add">+#define __copy_to_user_inatomic __copy_to_user</span>
<span class="p_add">+#define __copy_from_user_inatomic __copy_from_user</span>
<span class="p_add">+</span>
<span class="p_add">+unsigned long clear_user(void __user *addr, unsigned long size);</span>
<span class="p_add">+#define strnlen_user(s, n) (strnlen(s, n) + 1)</span>
<span class="p_add">+long strncpy_from_user(char *d, const char *s, long n);</span>
<span class="p_add">+</span>
<span class="p_add">+#define __clear_user	clear_user</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _H8300_UACCESS_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/unaligned.h b/arch/h8300/include/asm/unaligned.h</span>
new file mode 100644
<span class="p_header">index 0000000..b8d06c7</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/unaligned.h</span>
<span class="p_chunk">@@ -0,0 +1,11 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _ASM_H8300_UNALIGNED_H</span>
<span class="p_add">+#define _ASM_H8300_UNALIGNED_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/unaligned/be_memmove.h&gt;</span>
<span class="p_add">+#include &lt;linux/unaligned/le_byteshift.h&gt;</span>
<span class="p_add">+#include &lt;linux/unaligned/generic.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define get_unaligned	__get_unaligned_be</span>
<span class="p_add">+#define put_unaligned	__put_unaligned_be</span>
<span class="p_add">+</span>
<span class="p_add">+#endif /* _ASM_H8300_UNALIGNED_H */</span>
<span class="p_header">diff --git a/arch/h8300/include/asm/user.h b/arch/h8300/include/asm/user.h</span>
new file mode 100644
<span class="p_header">index 0000000..2e3555f</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/h8300/include/asm/user.h</span>
<span class="p_chunk">@@ -0,0 +1,74 @@</span> <span class="p_context"></span>
<span class="p_add">+#ifndef _H8300_USER_H</span>
<span class="p_add">+#define _H8300_USER_H</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/page.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+/* Core file format: The core file is written in such a way that gdb</span>
<span class="p_add">+   can understand it and provide useful information to the user (under</span>
<span class="p_add">+   linux we use the &#39;trad-core&#39; bfd).  There are quite a number of</span>
<span class="p_add">+   obstacles to being able to view the contents of the floating point</span>
<span class="p_add">+   registers, and until these are solved you will not be able to view the</span>
<span class="p_add">+   contents of them.  Actually, you can read in the core file and look at</span>
<span class="p_add">+   the contents of the user struct to find out what the floating point</span>
<span class="p_add">+   registers contain.</span>
<span class="p_add">+   The actual file contents are as follows:</span>
<span class="p_add">+   UPAGE: 1 page consisting of a user struct that tells gdb what is present</span>
<span class="p_add">+   in the file.  Directly after this is a copy of the task_struct, which</span>
<span class="p_add">+   is currently not used by gdb, but it may come in useful at some point.</span>
<span class="p_add">+   All of the registers are stored as part of the upage.  The upage should</span>
<span class="p_add">+   always be only one page.</span>
<span class="p_add">+   DATA: The data area is stored.  We use current-&gt;end_text to</span>
<span class="p_add">+   current-&gt;brk to pick up all of the user variables, plus any memory</span>
<span class="p_add">+   that may have been malloced.  No attempt is made to determine if a page</span>
<span class="p_add">+   is demand-zero or if a page is totally unused, we just cover the entire</span>
<span class="p_add">+   range.  All of the addresses are rounded in such a way that an integral</span>
<span class="p_add">+   number of pages is written.</span>
<span class="p_add">+   STACK: We need the stack information in order to get a meaningful</span>
<span class="p_add">+   backtrace.  We need to write the data from (esp) to</span>
<span class="p_add">+   current-&gt;start_stack, so we round each of these off in order to be able</span>
<span class="p_add">+   to write an integer number of pages.</span>
<span class="p_add">+   The minimum core file size is 3 pages, or 12288 bytes.</span>
<span class="p_add">+*/</span>
<span class="p_add">+</span>
<span class="p_add">+/* This is the old layout of &quot;struct pt_regs&quot; as of Linux 1.x, and</span>
<span class="p_add">+   is still the layout used by user (the new pt_regs doesn&#39;t have</span>
<span class="p_add">+   all registers). */</span>
<span class="p_add">+struct user_regs_struct {</span>
<span class="p_add">+	long er1, er2, er3, er4, er5, er6;</span>
<span class="p_add">+	long er0;</span>
<span class="p_add">+	long usp;</span>
<span class="p_add">+	long orig_er0;</span>
<span class="p_add">+	long ccr;</span>
<span class="p_add">+	long pc;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* When the kernel dumps core, it starts by dumping the user struct -</span>
<span class="p_add">+   this will be used by gdb to figure out where the data and stack segments</span>
<span class="p_add">+   are within the file, and what virtual addresses to use. */</span>
<span class="p_add">+struct user {</span>
<span class="p_add">+/* We start with the registers, to mimic the way that &quot;memory&quot; is returned</span>
<span class="p_add">+   from the ptrace(3,...) function.  */</span>
<span class="p_add">+	struct user_regs_struct regs;	/* Where the registers are actually stored */</span>
<span class="p_add">+/* ptrace does not yet supply these.  Someday.... */</span>
<span class="p_add">+/* The rest of this junk is to help gdb figure out what goes where */</span>
<span class="p_add">+	unsigned long int u_tsize;	/* Text segment size (pages). */</span>
<span class="p_add">+	unsigned long int u_dsize;	/* Data segment size (pages). */</span>
<span class="p_add">+	unsigned long int u_ssize;	/* Stack segment size (pages). */</span>
<span class="p_add">+	unsigned long start_code;     /* Starting virtual address of text. */</span>
<span class="p_add">+	unsigned long start_stack;	/* Starting virtual address of stack area.</span>
<span class="p_add">+					   This is actually the bottom of the stack,</span>
<span class="p_add">+					   the top of the stack is always found in the</span>
<span class="p_add">+					   esp register.  */</span>
<span class="p_add">+	long int signal;		/* Signal that caused the core dump. */</span>
<span class="p_add">+	int reserved;			/* No longer used */</span>
<span class="p_add">+	unsigned long u_ar0;		/* Used by gdb to help find the values for */</span>
<span class="p_add">+	/* the registers. */</span>
<span class="p_add">+	unsigned long magic;		/* To uniquely identify a core file */</span>
<span class="p_add">+	char u_comm[32];		/* User command that was responsible */</span>
<span class="p_add">+};</span>
<span class="p_add">+#define NBPG PAGE_SIZE</span>
<span class="p_add">+#define UPAGES 1</span>
<span class="p_add">+#define HOST_TEXT_START_ADDR (u.start_code)</span>
<span class="p_add">+#define HOST_STACK_END_ADDR (u.start_stack + u.u_ssize * NBPG)</span>
<span class="p_add">+</span>
<span class="p_add">+#endif</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



