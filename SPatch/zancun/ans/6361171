
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.10.77 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.10.77</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>May 7, 2015, 11:10 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150507231004.GB5083@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6361171/mbox/"
   >mbox</a>
|
   <a href="/patch/6361171/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6361171/">/patch/6361171/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id B2395BEEE1
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:10:41 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 916A5203B5
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:10:37 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 48F7A2038F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu,  7 May 2015 23:10:33 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751818AbbEGXKQ (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 7 May 2015 19:10:16 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:46078 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751638AbbEGXKJ (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 7 May 2015 19:10:09 -0400
Received: from localhost (gob75-2-82-67-192-59.fbx.proxad.net [82.67.192.59])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id CE2FBAC1;
	Thu,  7 May 2015 23:10:06 +0000 (UTC)
Date: Fri, 8 May 2015 01:10:04 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 3.10.77
Message-ID: &lt;20150507231004.GB5083@kroah.com&gt;
References: &lt;20150507230957.GA5083@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150507230957.GA5083@kroah.com&gt;
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.9 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	T_RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - May 7, 2015, 11:10 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 019a6a4b386d..923ad8a64e3b 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 10
<span class="p_del">-SUBLEVEL = 76</span>
<span class="p_add">+SUBLEVEL = 77</span>
 EXTRAVERSION =
 NAME = TOSSUG Baby Fish
 
<span class="p_header">diff --git a/arch/arm/include/asm/elf.h b/arch/arm/include/asm/elf.h</span>
<span class="p_header">index 56211f2084ef..ce6e30628cc1 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/elf.h</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> int dump_task_regs(struct task_struct *t, elf_gregset_t *elfregs);</span>
    the loader.  We need to make sure that it is out of the way of the program
    that it will &quot;exec&quot;, and that there is sufficient room for the brk.  */
 
<span class="p_del">-#define ELF_ET_DYN_BASE	(2 * TASK_SIZE / 3)</span>
<span class="p_add">+#define ELF_ET_DYN_BASE	(TASK_SIZE / 3 * 2)</span>
 
 /* When the program starts, a1 contains a pointer to a function to be 
    registered with atexit, as per the SVR4 ABI.  A value of 0 means we 
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/crag6410.h b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">index 4c3c9994fc2c..81dc722ced57 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/crag6410.h</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/gpio.h&gt;
 
 #define GLENFARCLAS_PMIC_IRQ_BASE	IRQ_BOARD_START
<span class="p_add">+#define BANFF_PMIC_IRQ_BASE		(IRQ_BOARD_START + 64)</span>
 
 #define PCA935X_GPIO_BASE		GPIO_BOARD_START
 #define CODEC_GPIO_BASE			(GPIO_BOARD_START + 8)
<span class="p_header">diff --git a/arch/arm/mach-s3c64xx/mach-crag6410.c b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">index 8ad88ace795a..5fa9ac9104e1 100644</span>
<span class="p_header">--- a/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_header">+++ b/arch/arm/mach-s3c64xx/mach-crag6410.c</span>
<span class="p_chunk">@@ -558,6 +558,7 @@</span> <span class="p_context"> static struct wm831x_touch_pdata touch_pdata = {</span>
 
 static struct wm831x_pdata crag_pmic_pdata = {
 	.wm831x_num = 1,
<span class="p_add">+	.irq_base = BANFF_PMIC_IRQ_BASE,</span>
 	.gpio_base = BANFF_PMIC_GPIO_BASE,
 	.soft_shutdown = true,
 
<span class="p_header">diff --git a/arch/arm64/include/asm/timex.h b/arch/arm64/include/asm/timex.h</span>
<span class="p_header">index b24a31a7e2c9..81a076eb37fa 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/timex.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/timex.h</span>
<span class="p_chunk">@@ -16,14 +16,14 @@</span> <span class="p_context"></span>
 #ifndef __ASM_TIMEX_H
 #define __ASM_TIMEX_H
 
<span class="p_add">+#include &lt;asm/arch_timer.h&gt;</span>
<span class="p_add">+</span>
 /*
  * Use the current timer as a cycle counter since this is what we use for
  * the delay loop.
  */
<span class="p_del">-#define get_cycles()	({ cycles_t c; read_current_timer(&amp;c); c; })</span>
<span class="p_add">+#define get_cycles()	arch_counter_get_cntvct()</span>
 
 #include &lt;asm-generic/timex.h&gt;
 
<span class="p_del">-#define ARCH_HAS_READ_CURRENT_TIMER</span>
<span class="p_del">-</span>
 #endif
<span class="p_header">diff --git a/arch/arm64/kernel/time.c b/arch/arm64/kernel/time.c</span>
<span class="p_header">index a551f88ae2c1..03dc3718eb13 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/time.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/time.c</span>
<span class="p_chunk">@@ -68,12 +68,6 @@</span> <span class="p_context"> unsigned long long notrace sched_clock(void)</span>
 	return arch_timer_read_counter() * sched_clock_mult;
 }
 
<span class="p_del">-int read_current_timer(unsigned long *timer_value)</span>
<span class="p_del">-{</span>
<span class="p_del">-	*timer_value = arch_timer_read_counter();</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void __init time_init(void)
 {
 	u32 arch_timer_rate;
<span class="p_header">diff --git a/arch/c6x/kernel/time.c b/arch/c6x/kernel/time.c</span>
<span class="p_header">index 356ee84cad95..04845aaf5985 100644</span>
<span class="p_header">--- a/arch/c6x/kernel/time.c</span>
<span class="p_header">+++ b/arch/c6x/kernel/time.c</span>
<span class="p_chunk">@@ -49,7 +49,7 @@</span> <span class="p_context"> u64 sched_clock(void)</span>
 	return (tsc * sched_clock_multiplier) &gt;&gt; SCHED_CLOCK_SHIFT;
 }
 
<span class="p_del">-void time_init(void)</span>
<span class="p_add">+void __init time_init(void)</span>
 {
 	u64 tmp = (u64)NSEC_PER_SEC &lt;&lt; SCHED_CLOCK_SHIFT;
 
<span class="p_header">diff --git a/arch/mips/include/asm/suspend.h b/arch/mips/include/asm/suspend.h</span>
deleted file mode 100644
<span class="p_header">index 3adac3b53d19..000000000000</span>
<span class="p_header">--- a/arch/mips/include/asm/suspend.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,7 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-#ifndef __ASM_SUSPEND_H</span>
<span class="p_del">-#define __ASM_SUSPEND_H</span>
<span class="p_del">-</span>
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* __ASM_SUSPEND_H */</span>
<span class="p_header">diff --git a/arch/mips/power/cpu.c b/arch/mips/power/cpu.c</span>
<span class="p_header">index 521e5963df05..2129e67723ff 100644</span>
<span class="p_header">--- a/arch/mips/power/cpu.c</span>
<span class="p_header">+++ b/arch/mips/power/cpu.c</span>
<span class="p_chunk">@@ -7,7 +7,7 @@</span> <span class="p_context"></span>
  * Author: Hu Hongbing &lt;huhb@lemote.com&gt;
  *	   Wu Zhangjin &lt;wuzhangjin@gmail.com&gt;
  */
<span class="p_del">-#include &lt;asm/suspend.h&gt;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/fpu.h&gt;
 #include &lt;asm/dsp.h&gt;
 
<span class="p_header">diff --git a/arch/mips/power/hibernate.S b/arch/mips/power/hibernate.S</span>
<span class="p_header">index 32a7c828f073..e7567c8a9e79 100644</span>
<span class="p_header">--- a/arch/mips/power/hibernate.S</span>
<span class="p_header">+++ b/arch/mips/power/hibernate.S</span>
<span class="p_chunk">@@ -30,6 +30,8 @@</span> <span class="p_context"> LEAF(swsusp_arch_suspend)</span>
 END(swsusp_arch_suspend)
 
 LEAF(swsusp_arch_resume)
<span class="p_add">+	/* Avoid TLB mismatch during and after kernel resume */</span>
<span class="p_add">+	jal local_flush_tlb_all</span>
 	PTR_L t0, restore_pblist
 0:
 	PTR_L t1, PBE_ADDRESS(t0)   /* source */
<span class="p_chunk">@@ -43,7 +45,6 @@</span> <span class="p_context"> LEAF(swsusp_arch_resume)</span>
 	bne t1, t3, 1b
 	PTR_L t0, PBE_NEXT(t0)
 	bnez t0, 0b
<span class="p_del">-	jal local_flush_tlb_all /* Avoid TLB mismatch after kernel resume */</span>
 	PTR_LA t0, saved_regs
 	PTR_L ra, PT_R31(t0)
 	PTR_L sp, PT_R29(t0)
<span class="p_header">diff --git a/arch/powerpc/kernel/suspend.c b/arch/powerpc/kernel/suspend.c</span>
<span class="p_header">index 0167d53da30c..a531154cc0f3 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/suspend.c</span>
<span class="p_chunk">@@ -9,9 +9,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/mm.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_del">-</span>
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /*
  *	pfn_is_nosave - check if given pfn is in the &#39;nosave&#39; section
<span class="p_header">diff --git a/arch/powerpc/perf/callchain.c b/arch/powerpc/perf/callchain.c</span>
<span class="p_header">index 2396dda282cd..ead55351b254 100644</span>
<span class="p_header">--- a/arch/powerpc/perf/callchain.c</span>
<span class="p_header">+++ b/arch/powerpc/perf/callchain.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static void perf_callchain_user_64(struct perf_callchain_entry *entry,</span>
 	sp = regs-&gt;gpr[1];
 	perf_callchain_store(entry, next_ip);
 
<span class="p_del">-	for (;;) {</span>
<span class="p_add">+	while (entry-&gt;nr &lt; PERF_MAX_STACK_DEPTH) {</span>
 		fp = (unsigned long __user *) sp;
 		if (!valid_user_sp(sp, 1) || read_user_stack_64(fp, &amp;next_sp))
 			return;
<span class="p_header">diff --git a/arch/s390/kernel/suspend.c b/arch/s390/kernel/suspend.c</span>
<span class="p_header">index c479d2f9605b..58cbb75e89e9 100644</span>
<span class="p_header">--- a/arch/s390/kernel/suspend.c</span>
<span class="p_header">+++ b/arch/s390/kernel/suspend.c</span>
<span class="p_chunk">@@ -9,12 +9,9 @@</span> <span class="p_context"></span>
 #include &lt;linux/pfn.h&gt;
 #include &lt;linux/suspend.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/ctl_reg.h&gt;
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * References to section boundaries</span>
<span class="p_del">- */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+#include &lt;asm/ipl.h&gt;</span>
 
 /*
  * The restore of the saved pages in an hibernation image will set
<span class="p_chunk">@@ -138,6 +135,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 {
 	unsigned long nosave_begin_pfn = PFN_DOWN(__pa(&amp;__nosave_begin));
 	unsigned long nosave_end_pfn = PFN_DOWN(__pa(&amp;__nosave_end));
<span class="p_add">+	unsigned long eshared_pfn = PFN_DOWN(__pa(&amp;_eshared)) - 1;</span>
<span class="p_add">+	unsigned long stext_pfn = PFN_DOWN(__pa(&amp;_stext));</span>
 
 	/* Always save lowcore pages (LC protection might be enabled). */
 	if (pfn &lt;= LC_PAGES)
<span class="p_chunk">@@ -145,6 +144,8 @@</span> <span class="p_context"> int pfn_is_nosave(unsigned long pfn)</span>
 	if (pfn &gt;= nosave_begin_pfn &amp;&amp; pfn &lt; nosave_end_pfn)
 		return 1;
 	/* Skip memory holes and read-only pages (NSS, DCSS, ...). */
<span class="p_add">+	if (pfn &gt;= stext_pfn &amp;&amp; pfn &lt;= eshared_pfn)</span>
<span class="p_add">+		return ipl_info.type == IPL_TYPE_NSS ? 1 : 0;</span>
 	if (tprot(PFN_PHYS(pfn)))
 		return 1;
 	return 0;
<span class="p_header">diff --git a/arch/s390/kvm/priv.c b/arch/s390/kvm/priv.c</span>
<span class="p_header">index 6bbd7b5a0bbe..0220c2ba7590 100644</span>
<span class="p_header">--- a/arch/s390/kvm/priv.c</span>
<span class="p_header">+++ b/arch/s390/kvm/priv.c</span>
<span class="p_chunk">@@ -328,6 +328,7 @@</span> <span class="p_context"> static void handle_stsi_3_2_2(struct kvm_vcpu *vcpu, struct sysinfo_3_2_2 *mem)</span>
 	for (n = mem-&gt;count - 1; n &gt; 0 ; n--)
 		memcpy(&amp;mem-&gt;vm[n], &amp;mem-&gt;vm[n - 1], sizeof(mem-&gt;vm[0]));
 
<span class="p_add">+	memset(&amp;mem-&gt;vm[0], 0, sizeof(mem-&gt;vm[0]));</span>
 	mem-&gt;vm[0].cpus_total = cpus;
 	mem-&gt;vm[0].cpus_configured = cpus;
 	mem-&gt;vm[0].cpus_standby = 0;
<span class="p_header">diff --git a/arch/sh/include/asm/sections.h b/arch/sh/include/asm/sections.h</span>
<span class="p_header">index 1b6199740e98..7a99e6af6372 100644</span>
<span class="p_header">--- a/arch/sh/include/asm/sections.h</span>
<span class="p_header">+++ b/arch/sh/include/asm/sections.h</span>
<span class="p_chunk">@@ -3,7 +3,6 @@</span> <span class="p_context"></span>
 
 #include &lt;asm-generic/sections.h&gt;
 
<span class="p_del">-extern long __nosave_begin, __nosave_end;</span>
 extern long __machvec_start, __machvec_end;
 extern char __uncached_start, __uncached_end;
 extern char __start_eh_frame[], __stop_eh_frame[];
<span class="p_header">diff --git a/arch/sparc/power/hibernate.c b/arch/sparc/power/hibernate.c</span>
<span class="p_header">index 42b0b8ce699a..17bd2e167e07 100644</span>
<span class="p_header">--- a/arch/sparc/power/hibernate.c</span>
<span class="p_header">+++ b/arch/sparc/power/hibernate.c</span>
<span class="p_chunk">@@ -9,11 +9,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/hibernate.h&gt;
 #include &lt;asm/visasm.h&gt;
 #include &lt;asm/page.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/tlb.h&gt;
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 struct saved_context saved_context;
 
 /*
<span class="p_header">diff --git a/arch/unicore32/include/mach/pm.h b/arch/unicore32/include/mach/pm.h</span>
<span class="p_header">index 4dcd34ae194c..77b522694e74 100644</span>
<span class="p_header">--- a/arch/unicore32/include/mach/pm.h</span>
<span class="p_header">+++ b/arch/unicore32/include/mach/pm.h</span>
<span class="p_chunk">@@ -36,8 +36,5 @@</span> <span class="p_context"> extern int puv3_pm_enter(suspend_state_t state);</span>
 /* Defined in hibernate_asm.S */
 extern int restore_image(pgd_t *resume_pg_dir, struct pbe *restore_pblist);
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 extern struct pbe *restore_pblist;
 #endif
<span class="p_header">diff --git a/arch/unicore32/kernel/hibernate.c b/arch/unicore32/kernel/hibernate.c</span>
<span class="p_header">index d75ef8b6cb56..9969ec374abb 100644</span>
<span class="p_header">--- a/arch/unicore32/kernel/hibernate.c</span>
<span class="p_header">+++ b/arch/unicore32/kernel/hibernate.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/pgalloc.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/suspend.h&gt;
 
 #include &quot;mach/pm.h&quot;
<span class="p_header">diff --git a/arch/x86/power/hibernate_32.c b/arch/x86/power/hibernate_32.c</span>
<span class="p_header">index 7d28c885d238..291226b952a9 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_32.c</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_32.c</span>
<span class="p_chunk">@@ -13,13 +13,11 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mmzone.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 
 /* Defined in hibernate_asm_32.S */
 extern int restore_image(void);
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 /* Pointer to the temporary resume page tables */
 pgd_t *resume_pg_dir;
 
<span class="p_header">diff --git a/arch/x86/power/hibernate_64.c b/arch/x86/power/hibernate_64.c</span>
<span class="p_header">index a0fde91c16cf..8ecaed127634 100644</span>
<span class="p_header">--- a/arch/x86/power/hibernate_64.c</span>
<span class="p_header">+++ b/arch/x86/power/hibernate_64.c</span>
<span class="p_chunk">@@ -17,11 +17,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/page.h&gt;
 #include &lt;asm/pgtable.h&gt;
 #include &lt;asm/mtrr.h&gt;
<span class="p_add">+#include &lt;asm/sections.h&gt;</span>
 #include &lt;asm/suspend.h&gt;
 
<span class="p_del">-/* References to section boundaries */</span>
<span class="p_del">-extern const void __nosave_begin, __nosave_end;</span>
<span class="p_del">-</span>
 /* Defined in hibernate_asm_64.S */
 extern int restore_image(void);
 
<span class="p_header">diff --git a/arch/xtensa/Kconfig b/arch/xtensa/Kconfig</span>
<span class="p_header">index 0a1b95f81a32..2b086a6ae6c7 100644</span>
<span class="p_header">--- a/arch/xtensa/Kconfig</span>
<span class="p_header">+++ b/arch/xtensa/Kconfig</span>
<span class="p_chunk">@@ -287,6 +287,36 @@</span> <span class="p_context"> menu &quot;Executable file formats&quot;</span>
 
 source &quot;fs/Kconfig.binfmt&quot;
 
<span class="p_add">+config XTFPGA_LCD</span>
<span class="p_add">+	bool &quot;Enable XTFPGA LCD driver&quot;</span>
<span class="p_add">+	depends on XTENSA_PLATFORM_XTFPGA</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  There&#39;s a 2x16 LCD on most of XTFPGA boards, kernel may output</span>
<span class="p_add">+	  progress messages there during bootup/shutdown. It may be useful</span>
<span class="p_add">+	  during board bringup.</span>
<span class="p_add">+</span>
<span class="p_add">+	  If unsure, say N.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_BASE_ADDR</span>
<span class="p_add">+	hex &quot;XTFPGA LCD base address&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default &quot;0x0d0c0000&quot;</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Base address of the LCD controller inside KIO region.</span>
<span class="p_add">+	  Different boards from XTFPGA family have LCD controller at different</span>
<span class="p_add">+	  addresses. Please consult prototyping user guide for your board for</span>
<span class="p_add">+	  the correct address. Wrong address here may lead to hardware lockup.</span>
<span class="p_add">+</span>
<span class="p_add">+config XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	bool &quot;Use 8-bit access to XTFPGA LCD&quot;</span>
<span class="p_add">+	depends on XTFPGA_LCD</span>
<span class="p_add">+	default n</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  LCD may be connected with 4- or 8-bit interface, 8-bit access may</span>
<span class="p_add">+	  only be used with 8-bit interface. Please consult prototyping user</span>
<span class="p_add">+	  guide for your board for the correct interface width.</span>
<span class="p_add">+</span>
 endmenu
 
 source &quot;net/Kconfig&quot;
<span class="p_header">diff --git a/arch/xtensa/include/uapi/asm/unistd.h b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">index 513effd48060..d07c1886bc8f 100644</span>
<span class="p_header">--- a/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_header">+++ b/arch/xtensa/include/uapi/asm/unistd.h</span>
<span class="p_chunk">@@ -715,7 +715,7 @@</span> <span class="p_context"> __SYSCALL(323, sys_process_vm_writev, 6)</span>
 __SYSCALL(324, sys_name_to_handle_at, 5)
 #define __NR_open_by_handle_at			325
 __SYSCALL(325, sys_open_by_handle_at, 3)
<span class="p_del">-#define __NR_sync_file_range			326</span>
<span class="p_add">+#define __NR_sync_file_range2			326</span>
 __SYSCALL(326, sys_sync_file_range2, 6)
 #define __NR_perf_event_open			327
 __SYSCALL(327, sys_perf_event_open, 5)
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/Makefile b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">index b9ae206340cd..7839d38b2337 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/Makefile</span>
<span class="p_chunk">@@ -6,4 +6,5 @@</span> <span class="p_context"></span>
 #
 # Note 2! The CFLAGS definitions are in the main makefile...
 
<span class="p_del">-obj-y			= setup.o lcd.o</span>
<span class="p_add">+obj-y			+= setup.o</span>
<span class="p_add">+obj-$(CONFIG_XTFPGA_LCD) += lcd.o</span>
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">index 4416773cbde5..b39fbcf5c611 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/hardware.h</span>
<span class="p_chunk">@@ -44,9 +44,6 @@</span> <span class="p_context"></span>
 
 /* UART */
 #define DUART16552_PADDR	(XCHAL_KIO_PADDR + 0x0D050020)
<span class="p_del">-/* LCD instruction and data addresses. */</span>
<span class="p_del">-#define LCD_INSTR_ADDR		((char *)IOADDR(0x0D040000))</span>
<span class="p_del">-#define LCD_DATA_ADDR		((char *)IOADDR(0x0D040004))</span>
 
 /* Misc. */
 #define XTFPGA_FPGAREGS_VADDR	IOADDR(0x0D020000)
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">index 0e435645af5a..4c8541ed1139 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/include/platform/lcd.h</span>
<span class="p_chunk">@@ -11,10 +11,25 @@</span> <span class="p_context"></span>
 #ifndef __XTENSA_XTAVNET_LCD_H
 #define __XTENSA_XTAVNET_LCD_H
 
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD</span>
 /* Display string STR at position POS on the LCD. */
 void lcd_disp_at_pos(char *str, unsigned char pos);
 
 /* Shift the contents of the LCD display left or right. */
 void lcd_shiftleft(void);
 void lcd_shiftright(void);
<span class="p_add">+#else</span>
<span class="p_add">+static inline void lcd_disp_at_pos(char *str, unsigned char pos)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftleft(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void lcd_shiftright(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/xtensa/platforms/xtfpga/lcd.c b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">index 2872301598df..4dc0c1b43f4b 100644</span>
<span class="p_header">--- a/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_header">+++ b/arch/xtensa/platforms/xtfpga/lcd.c</span>
<span class="p_chunk">@@ -1,50 +1,63 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Driver for the LCD display on the Tensilica LX60 Board.</span>
<span class="p_add">+ * Driver for the LCD display on the Tensilica XTFPGA board family.</span>
<span class="p_add">+ * http://www.mytechcorp.com/cfdata/productFile/File1/MOC-16216B-B-A0A04.pdf</span>
  *
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file &quot;COPYING&quot; in the main directory of this archive
  * for more details.
  *
  * Copyright (C) 2001, 2006 Tensilica Inc.
<span class="p_add">+ * Copyright (C) 2015 Cadence Design Systems Inc.</span>
  */
 
<span class="p_del">-/*</span>
<span class="p_del">- *</span>
<span class="p_del">- * FIXME: this code is from the examples from the LX60 user guide.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The lcd_pause function does busy waiting, which is probably not</span>
<span class="p_del">- * great. Maybe the code could be changed to use kernel timers, or</span>
<span class="p_del">- * change the hardware to not need to wait.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/delay.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/io.h&gt;
 
 #include &lt;platform/hardware.h&gt;
 #include &lt;platform/lcd.h&gt;
<span class="p_del">-#include &lt;linux/delay.h&gt;</span>
 
<span class="p_del">-#define LCD_PAUSE_ITERATIONS	4000</span>
<span class="p_add">+/* LCD instruction and data addresses. */</span>
<span class="p_add">+#define LCD_INSTR_ADDR		((char *)IOADDR(CONFIG_XTFPGA_LCD_BASE_ADDR))</span>
<span class="p_add">+#define LCD_DATA_ADDR		(LCD_INSTR_ADDR + 4)</span>
<span class="p_add">+</span>
 #define LCD_CLEAR		0x1
 #define LCD_DISPLAY_ON		0xc
 
 /* 8bit and 2 lines display */
 #define LCD_DISPLAY_MODE8BIT	0x38
<span class="p_add">+#define LCD_DISPLAY_MODE4BIT	0x28</span>
 #define LCD_DISPLAY_POS		0x80
 #define LCD_SHIFT_LEFT		0x18
 #define LCD_SHIFT_RIGHT		0x1c
 
<span class="p_add">+static void lcd_put_byte(u8 *addr, u8 data)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = data &amp; 0xf0;</span>
<span class="p_add">+	ACCESS_ONCE(*addr) = (data &lt;&lt; 4) &amp; 0xf0;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init lcd_init(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	mdelay(5);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
 	udelay(200);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE8BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+#ifndef CONFIG_XTFPGA_LCD_8BIT_ACCESS</span>
<span class="p_add">+	ACCESS_ONCE(*LCD_INSTR_ADDR) = LCD_DISPLAY_MODE4BIT;</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_MODE4BIT);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_ON;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_ON);</span>
 	udelay(50);
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_CLEAR;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_CLEAR);</span>
 	mdelay(10);
 	lcd_disp_at_pos(&quot;XTENSA LINUX&quot;, 0);
 	return 0;
<span class="p_chunk">@@ -52,10 +65,10 @@</span> <span class="p_context"> static int __init lcd_init(void)</span>
 
 void lcd_disp_at_pos(char *str, unsigned char pos)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_DISPLAY_POS | pos;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_DISPLAY_POS | pos);</span>
 	udelay(100);
 	while (*str != 0) {
<span class="p_del">-		*LCD_DATA_ADDR = *str;</span>
<span class="p_add">+		lcd_put_byte(LCD_DATA_ADDR, *str);</span>
 		udelay(200);
 		str++;
 	}
<span class="p_chunk">@@ -63,13 +76,13 @@</span> <span class="p_context"> void lcd_disp_at_pos(char *str, unsigned char pos)</span>
 
 void lcd_shiftleft(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_LEFT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_LEFT);</span>
 	udelay(50);
 }
 
 void lcd_shiftright(void)
 {
<span class="p_del">-	*LCD_INSTR_ADDR = LCD_SHIFT_RIGHT;</span>
<span class="p_add">+	lcd_put_byte(LCD_INSTR_ADDR, LCD_SHIFT_RIGHT);</span>
 	udelay(50);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 7695b5dd9d2d..35287ab445cd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -909,6 +909,7 @@</span> <span class="p_context"></span>
 #define   GMBUS_CYCLE_INDEX	(2&lt;&lt;25)
 #define   GMBUS_CYCLE_STOP	(4&lt;&lt;25)
 #define   GMBUS_BYTE_COUNT_SHIFT 16
<span class="p_add">+#define   GMBUS_BYTE_COUNT_MAX   256U</span>
 #define   GMBUS_SLAVE_INDEX_SHIFT 8
 #define   GMBUS_SLAVE_ADDR_SHIFT 1
 #define   GMBUS_SLAVE_READ	(1&lt;&lt;0)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_i2c.c b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">index 639fe192997c..4a21e13cc58c 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_i2c.c</span>
<span class="p_chunk">@@ -276,18 +276,17 @@</span> <span class="p_context"> gmbus_wait_idle(struct drm_i915_private *dev_priv)</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_del">-		u32 gmbus1_index)</span>
<span class="p_add">+gmbus_xfer_read_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		      unsigned short addr, u8 *buf, unsigned int len,</span>
<span class="p_add">+		      u32 gmbus1_index)</span>
 {
 	int reg_offset = dev_priv-&gt;gpio_mmio_base;
<span class="p_del">-	u16 len = msg-&gt;len;</span>
<span class="p_del">-	u8 *buf = msg-&gt;buf;</span>
 
 	I915_WRITE(GMBUS1 + reg_offset,
 		   gmbus1_index |
 		   GMBUS_CYCLE_WAIT |
 		   (len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_READ | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -309,11 +308,35 @@</span> <span class="p_context"> gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
 }
 
 static int
<span class="p_del">-gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+gmbus_xfer_read(struct drm_i915_private *dev_priv, struct i2c_msg *msg,</span>
<span class="p_add">+		u32 gmbus1_index)</span>
 {
<span class="p_del">-	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_del">-	u16 len = msg-&gt;len;</span>
 	u8 *buf = msg-&gt;buf;
<span class="p_add">+	unsigned int rx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(rx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_read_chunk(dev_priv, msg-&gt;addr,</span>
<span class="p_add">+					    buf, len, gmbus1_index);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		rx_size -= len;</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+	} while (rx_size != 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write_chunk(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+		       unsigned short addr, u8 *buf, unsigned int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int reg_offset = dev_priv-&gt;gpio_mmio_base;</span>
<span class="p_add">+	unsigned int chunk_size = len;</span>
 	u32 val, loop;
 
 	val = loop = 0;
<span class="p_chunk">@@ -325,8 +348,8 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 	I915_WRITE(GMBUS3 + reg_offset, val);
 	I915_WRITE(GMBUS1 + reg_offset,
 		   GMBUS_CYCLE_WAIT |
<span class="p_del">-		   (msg-&gt;len &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_del">-		   (msg-&gt;addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
<span class="p_add">+		   (chunk_size &lt;&lt; GMBUS_BYTE_COUNT_SHIFT) |</span>
<span class="p_add">+		   (addr &lt;&lt; GMBUS_SLAVE_ADDR_SHIFT) |</span>
 		   GMBUS_SLAVE_WRITE | GMBUS_SW_RDY);
 	while (len) {
 		int ret;
<span class="p_chunk">@@ -343,6 +366,29 @@</span> <span class="p_context"> gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
 		if (ret)
 			return ret;
 	}
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+gmbus_xfer_write(struct drm_i915_private *dev_priv, struct i2c_msg *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *buf = msg-&gt;buf;</span>
<span class="p_add">+	unsigned int tx_size = msg-&gt;len;</span>
<span class="p_add">+	unsigned int len;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		len = min(tx_size, GMBUS_BYTE_COUNT_MAX);</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = gmbus_xfer_write_chunk(dev_priv, msg-&gt;addr, buf, len);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		buf += len;</span>
<span class="p_add">+		tx_size -= len;</span>
<span class="p_add">+	} while (tx_size != 0);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_crtc.c b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">index 971dd8795b68..8ac333094991 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_crtc.c</span>
<span class="p_chunk">@@ -312,8 +312,10 @@</span> <span class="p_context"> atombios_set_crtc_dtd_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_chunk">@@ -356,8 +358,10 @@</span> <span class="p_context"> static void atombios_crtc_set_timing(struct drm_crtc *crtc,</span>
 		misc |= ATOM_COMPOSITESYNC;
 	if (mode-&gt;flags &amp; DRM_MODE_FLAG_INTERLACE)
 		misc |= ATOM_INTERLACE;
<span class="p_del">-	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLCLK)</span>
 		misc |= ATOM_DOUBLE_CLOCK_MODE;
<span class="p_add">+	if (mode-&gt;flags &amp; DRM_MODE_FLAG_DBLSCAN)</span>
<span class="p_add">+		misc |= ATOM_H_REPLICATIONBY2 | ATOM_V_REPLICATIONBY2;</span>
 
 	args.susModeMiscInfo.usAccess = cpu_to_le16(misc);
 	args.ucCRTC = radeon_crtc-&gt;crtc_id;
<span class="p_header">diff --git a/drivers/hv/channel.c b/drivers/hv/channel.c</span>
<span class="p_header">index 92f34de7aee9..05e6a7d13d4e 100644</span>
<span class="p_header">--- a/drivers/hv/channel.c</span>
<span class="p_header">+++ b/drivers/hv/channel.c</span>
<span class="p_chunk">@@ -169,7 +169,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 			   GFP_KERNEL);
 	if (!open_info) {
 		err = -ENOMEM;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	init_completion(&amp;open_info-&gt;waitevent);
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> int vmbus_open(struct vmbus_channel *newchannel, u32 send_ringbuffer_size,</span>
 
 	if (userdatalen &gt; MAX_USER_DEFINED_BYTES) {
 		err = -EINVAL;
<span class="p_del">-		goto error0;</span>
<span class="p_add">+		goto error_gpadl;</span>
 	}
 
 	if (userdatalen)
<span class="p_chunk">@@ -226,6 +226,9 @@</span> <span class="p_context"> error1:</span>
 	list_del(&amp;open_info-&gt;msglistentry);
 	spin_unlock_irqrestore(&amp;vmbus_connection.channelmsg_lock, flags);
 
<span class="p_add">+error_gpadl:</span>
<span class="p_add">+	vmbus_teardown_gpadl(newchannel, newchannel-&gt;ringbuffer_gpadlhandle);</span>
<span class="p_add">+</span>
 error0:
 	free_pages((unsigned long)out,
 		get_order(send_ringbuffer_size + recv_ringbuffer_size));
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index 48e31ed69dbf..9d539cbfc833 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -206,6 +206,7 @@</span> <span class="p_context"> int i2c_generic_scl_recovery(struct i2c_adapter *adap)</span>
 	adap-&gt;bus_recovery_info-&gt;set_scl(adap, 1);
 	return i2c_generic_recovery(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_scl_recovery);</span>
 
 int i2c_generic_gpio_recovery(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -220,6 +221,7 @@</span> <span class="p_context"> int i2c_generic_gpio_recovery(struct i2c_adapter *adap)</span>
 
 	return ret;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_generic_gpio_recovery);</span>
 
 int i2c_recover_bus(struct i2c_adapter *adap)
 {
<span class="p_chunk">@@ -229,6 +231,7 @@</span> <span class="p_context"> int i2c_recover_bus(struct i2c_adapter *adap)</span>
 	dev_dbg(&amp;adap-&gt;dev, &quot;Trying i2c bus recovery\n&quot;);
 	return adap-&gt;bus_recovery_info-&gt;recover_bus(adap);
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(i2c_recover_bus);</span>
 
 static int i2c_device_probe(struct device *dev)
 {
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index 055ebebc07dd..c1fef27010d4 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -94,12 +94,15 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 	if (dmasync)
 		dma_set_attr(DMA_ATTR_WRITE_BARRIER, &amp;attrs);
 
<span class="p_add">+	if (!size)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
 	/*
 	 * If the combination of the addr and size requested for this memory
 	 * region causes an integer overflow, return error.
 	 */
<span class="p_del">-	if ((PAGE_ALIGN(addr + size) &lt;= size) ||</span>
<span class="p_del">-	    (PAGE_ALIGN(addr + size) &lt;= addr))</span>
<span class="p_add">+	if (((addr + size) &lt; addr) ||</span>
<span class="p_add">+	    PAGE_ALIGN(addr + size) &lt; (addr + size))</span>
 		return ERR_PTR(-EINVAL);
 
 	if (!can_do_mlock())
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/qp.c b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">index 4f10af2905b5..262a18437ceb 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/qp.c</span>
<span class="p_chunk">@@ -2174,8 +2174,7 @@</span> <span class="p_context"> static int build_lso_seg(struct mlx4_wqe_lso_seg *wqe, struct ib_send_wr *wr,</span>
 
 	memcpy(wqe-&gt;header, wr-&gt;wr.ud.header, wr-&gt;wr.ud.hlen);
 
<span class="p_del">-	*lso_hdr_sz  = cpu_to_be32((wr-&gt;wr.ud.mss - wr-&gt;wr.ud.hlen) &lt;&lt; 16 |</span>
<span class="p_del">-				   wr-&gt;wr.ud.hlen);</span>
<span class="p_add">+	*lso_hdr_sz  = cpu_to_be32(wr-&gt;wr.ud.mss &lt;&lt; 16 | wr-&gt;wr.ud.hlen);</span>
 	*lso_seg_len = halign;
 	return 0;
 }
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 85e75239c814..1af7df263368 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -784,6 +784,21 @@</span> <span class="p_context"> static psmouse_ret_t elantech_process_byte(struct psmouse *psmouse)</span>
 }
 
 /*
<span class="p_add">+ * This writes the reg_07 value again to the hardware at the end of every</span>
<span class="p_add">+ * set_rate call because the register loses its value. reg_07 allows setting</span>
<span class="p_add">+ * absolute mode on v4 hardware</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void elantech_set_rate_restore_reg_07(struct psmouse *psmouse,</span>
<span class="p_add">+		unsigned int rate)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct elantech_data *etd = psmouse-&gt;private;</span>
<span class="p_add">+</span>
<span class="p_add">+	etd-&gt;original_set_rate(psmouse, rate);</span>
<span class="p_add">+	if (elantech_write_reg(psmouse, 0x07, etd-&gt;reg_07))</span>
<span class="p_add">+		psmouse_err(psmouse, &quot;restoring reg_07 failed\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Put the touchpad into absolute mode
  */
 static int elantech_set_absolute_mode(struct psmouse *psmouse)
<span class="p_chunk">@@ -985,6 +1000,8 @@</span> <span class="p_context"> static int elantech_get_resolution_v4(struct psmouse *psmouse,</span>
  * Asus K53SV              0x450f01        78, 15, 0c      2 hw buttons
  * Asus G46VW              0x460f02        00, 18, 0c      2 hw buttons
  * Asus G750JX             0x360f00        00, 16, 0c      2 hw buttons
<span class="p_add">+ * Asus TP500LN            0x381f17        10, 14, 0e      clickpad</span>
<span class="p_add">+ * Asus X750JN             0x381f17        10, 14, 0e      clickpad</span>
  * Asus UX31               0x361f00        20, 15, 0e      clickpad
  * Asus UX32VD             0x361f02        00, 15, 0e      clickpad
  * Avatar AVIU-145A2       0x361f00        ?               clickpad
<span class="p_chunk">@@ -1452,6 +1469,11 @@</span> <span class="p_context"> int elantech_init(struct psmouse *psmouse)</span>
 		goto init_fail;
 	}
 
<span class="p_add">+	if (etd-&gt;fw_version == 0x381f17) {</span>
<span class="p_add">+		etd-&gt;original_set_rate = psmouse-&gt;set_rate;</span>
<span class="p_add">+		psmouse-&gt;set_rate = elantech_set_rate_restore_reg_07;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (elantech_set_input_params(psmouse)) {
 		psmouse_err(psmouse, &quot;failed to query touchpad range.\n&quot;);
 		goto init_fail;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.h b/drivers/input/mouse/elantech.h</span>
<span class="p_header">index c1c15ab6872d..13a12ccbff51 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.h</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.h</span>
<span class="p_chunk">@@ -138,6 +138,7 @@</span> <span class="p_context"> struct elantech_data {</span>
 	struct finger_pos mt[ETP_MAX_FINGERS];
 	unsigned char parity[256];
 	int (*send_cmd)(struct psmouse *psmouse, unsigned char c, unsigned char *param);
<span class="p_add">+	void (*original_set_rate)(struct psmouse *psmouse, unsigned int rate);</span>
 };
 
 #ifdef CONFIG_MOUSE_PS2_ELANTECH
<span class="p_header">diff --git a/drivers/media/usb/stk1160/stk1160-v4l.c b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">index a59153d2f8bf..518a5299ff0b 100644</span>
<span class="p_header">--- a/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_header">+++ b/drivers/media/usb/stk1160/stk1160-v4l.c</span>
<span class="p_chunk">@@ -245,6 +245,11 @@</span> <span class="p_context"> static int stk1160_stop_streaming(struct stk1160 *dev)</span>
 	if (mutex_lock_interruptible(&amp;dev-&gt;v4l_lock))
 		return -ERESTARTSYS;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Once URBs are cancelled, the URB complete handler</span>
<span class="p_add">+	 * won&#39;t be running. This is required to safely release the</span>
<span class="p_add">+	 * current buffer (dev-&gt;isoc_ctl.buf).</span>
<span class="p_add">+	 */</span>
 	stk1160_cancel_isoc(dev);
 
 	/*
<span class="p_chunk">@@ -665,8 +670,16 @@</span> <span class="p_context"> void stk1160_clear_queue(struct stk1160 *dev)</span>
 		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,
 				buf, buf-&gt;vb.v4l2_buf.index);
 	}
<span class="p_del">-	/* It&#39;s important to clear current buffer */</span>
<span class="p_del">-	dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* It&#39;s important to release the current buffer */</span>
<span class="p_add">+	if (dev-&gt;isoc_ctl.buf) {</span>
<span class="p_add">+		buf = dev-&gt;isoc_ctl.buf;</span>
<span class="p_add">+		dev-&gt;isoc_ctl.buf = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+		vb2_buffer_done(&amp;buf-&gt;vb, VB2_BUF_STATE_ERROR);</span>
<span class="p_add">+		stk1160_info(&quot;buffer [%p/%d] aborted\n&quot;,</span>
<span class="p_add">+				buf, buf-&gt;vb.v4l2_buf.index);</span>
<span class="p_add">+	}</span>
 	spin_unlock_irqrestore(&amp;dev-&gt;buf_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/memstick/core/mspro_block.c b/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">index f4176ca3a794..cdd61ab5c2b5 100644</span>
<span class="p_header">--- a/drivers/memstick/core/mspro_block.c</span>
<span class="p_header">+++ b/drivers/memstick/core/mspro_block.c</span>
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 
 		if (error || (card-&gt;current_mrq.tpc == MSPRO_CMD_STOP)) {
 			if (msb-&gt;data_dir == READ) {
<span class="p_del">-				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++)</span>
<span class="p_add">+				for (cnt = 0; cnt &lt; msb-&gt;current_seg; cnt++) {</span>
 					t_len += msb-&gt;req_sg[cnt].length
 						 / msb-&gt;page_size;
 
<span class="p_chunk">@@ -766,6 +766,7 @@</span> <span class="p_context"> static int mspro_block_complete_req(struct memstick_dev *card, int error)</span>
 						t_len += msb-&gt;current_page - 1;
 
 					t_len *= msb-&gt;page_size;
<span class="p_add">+				}</span>
 			}
 		} else
 			t_len = blk_rq_bytes(msb-&gt;block_req);
<span class="p_header">diff --git a/drivers/mtd/ubi/attach.c b/drivers/mtd/ubi/attach.c</span>
<span class="p_header">index c071d410488f..79d69bd26dd2 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/attach.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/attach.c</span>
<span class="p_chunk">@@ -408,7 +408,7 @@</span> <span class="p_context"> int ubi_compare_lebs(struct ubi_device *ubi, const struct ubi_ainf_peb *aeb,</span>
 		second_is_newer = !second_is_newer;
 	} else {
 		dbg_bld(&quot;PEB %d CRC is OK&quot;, pnum);
<span class="p_del">-		bitflips = !!err;</span>
<span class="p_add">+		bitflips |= !!err;</span>
 	}
 	mutex_unlock(&amp;ubi-&gt;buf_mutex);
 
<span class="p_header">diff --git a/drivers/mtd/ubi/cdev.c b/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">index 4f02848bb2bc..fc764e7976bd 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/cdev.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/cdev.c</span>
<span class="p_chunk">@@ -475,7 +475,7 @@</span> <span class="p_context"> static long vol_cdev_ioctl(struct file *file, unsigned int cmd,</span>
 		/* Validate the request */
 		err = -EINVAL;
 		if (req.lnum &lt; 0 || req.lnum &gt;= vol-&gt;reserved_pebs ||
<span class="p_del">-		    req.bytes &lt; 0 || req.lnum &gt;= vol-&gt;usable_leb_size)</span>
<span class="p_add">+		    req.bytes &lt; 0 || req.bytes &gt; vol-&gt;usable_leb_size)</span>
 			break;
 
 		err = get_exclusive(desc);
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 0e11671dadc4..930cf2c77abb 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1362,7 +1362,8 @@</span> <span class="p_context"> int ubi_eba_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 				 * during re-size.
 				 */
 				ubi_move_aeb_to_list(av, aeb, &amp;ai-&gt;erase);
<span class="p_del">-			vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				vol-&gt;eba_tbl[aeb-&gt;lnum] = aeb-&gt;pnum;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index 49e570abe58b..c08254016fe8 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -999,7 +999,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, uninitialized_var(lnum);</span>
<span class="p_add">+	int vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000/e1000_main.c b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">index 59ad007dd5aa..a978fc82ceb5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000/e1000_main.c</span>
<span class="p_chunk">@@ -144,6 +144,11 @@</span> <span class="p_context"> static bool e1000_clean_rx_irq(struct e1000_adapter *adapter,</span>
 static bool e1000_clean_jumbo_rx_irq(struct e1000_adapter *adapter,
 				     struct e1000_rx_ring *rx_ring,
 				     int *work_done, int work_to_do);
<span class="p_add">+static void e1000_alloc_dummy_rx_buffers(struct e1000_adapter *adapter,</span>
<span class="p_add">+					 struct e1000_rx_ring *rx_ring,</span>
<span class="p_add">+					 int cleaned_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 static void e1000_alloc_rx_buffers(struct e1000_adapter *adapter,
 				   struct e1000_rx_ring *rx_ring,
 				   int cleaned_count);
<span class="p_chunk">@@ -3555,8 +3560,11 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		msleep(1);
 	/* e1000_down has a dependency on max_frame_size */
 	hw-&gt;max_frame_size = max_frame;
<span class="p_del">-	if (netif_running(netdev))</span>
<span class="p_add">+	if (netif_running(netdev)) {</span>
<span class="p_add">+		/* prevent buffers from being reallocated */</span>
<span class="p_add">+		adapter-&gt;alloc_rx_buf = e1000_alloc_dummy_rx_buffers;</span>
 		e1000_down(adapter);
<span class="p_add">+	}</span>
 
 	/* NOTE: netdev_alloc_skb reserves 16 bytes, and typically NET_IP_ALIGN
 	 * means we reserve 2 more, this pushes us to allocate from the next
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">index e7a2af3ad05a..7555095e0b74 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192cu/sw.c</span>
<span class="p_chunk">@@ -313,6 +313,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x07b8, 0x8188, rtl92cu_hal_cfg)}, /*Abocom - Abocom*/
 	{RTL_USB_DEVICE(0x07b8, 0x8189, rtl92cu_hal_cfg)}, /*Funai - Abocom*/
 	{RTL_USB_DEVICE(0x0846, 0x9041, rtl92cu_hal_cfg)}, /*NetGear WNA1000M*/
<span class="p_add">+	{RTL_USB_DEVICE(0x0b05, 0x17ba, rtl92cu_hal_cfg)}, /*ASUS-Edimax*/</span>
 	{RTL_USB_DEVICE(0x0bda, 0x5088, rtl92cu_hal_cfg)}, /*Thinkware-CC&amp;C*/
 	{RTL_USB_DEVICE(0x0df6, 0x0052, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
 	{RTL_USB_DEVICE(0x0df6, 0x005c, rtl92cu_hal_cfg)}, /*Sitecom - Edimax*/
<span class="p_chunk">@@ -369,6 +370,7 @@</span> <span class="p_context"> static struct usb_device_id rtl8192c_usb_ids[] = {</span>
 	{RTL_USB_DEVICE(0x2001, 0x3307, rtl92cu_hal_cfg)}, /*D-Link-Cameo*/
 	{RTL_USB_DEVICE(0x2001, 0x3309, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
 	{RTL_USB_DEVICE(0x2001, 0x330a, rtl92cu_hal_cfg)}, /*D-Link-Alpha*/
<span class="p_add">+	{RTL_USB_DEVICE(0x2001, 0x330d, rtl92cu_hal_cfg)}, /*D-Link DWA-131 */</span>
 	{RTL_USB_DEVICE(0x2019, 0xab2b, rtl92cu_hal_cfg)}, /*Planex -Abocom*/
 	{RTL_USB_DEVICE(0x20f4, 0x624d, rtl92cu_hal_cfg)}, /*TRENDNet*/
 	{RTL_USB_DEVICE(0x2357, 0x0100, rtl92cu_hal_cfg)}, /*TP-Link WN8200ND*/
<span class="p_header">diff --git a/drivers/net/wireless/ti/wl18xx/debugfs.c b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">index 7f1669cdea09..779dc2b2ca75 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wl18xx/debugfs.c</span>
<span class="p_chunk">@@ -136,7 +136,7 @@</span> <span class="p_context"> WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, protection_filter, &quot;%u&quot;);</span>
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, accum_arp_pend_requests, &quot;%u&quot;);
 WL18XX_DEBUGFS_FWSTATS_FILE(rx_filter, max_arp_queue_dep, &quot;%u&quot;);
 
<span class="p_del">-WL18XX_DEBUGFS_FWSTATS_FILE(rx_rate, rx_frames_per_rates, &quot;%u&quot;);</span>
<span class="p_add">+WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(rx_rate, rx_frames_per_rates, 50);</span>
 
 WL18XX_DEBUGFS_FWSTATS_FILE_ARRAY(aggr_size, tx_agg_vs_rate,
 				  AGGR_STATS_TX_AGG*AGGR_STATS_TX_RATE);
<span class="p_header">diff --git a/drivers/net/wireless/ti/wlcore/debugfs.h b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">index f7381dd69009..1bce4325e86b 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ti/wlcore/debugfs.h</span>
<span class="p_chunk">@@ -26,8 +26,8 @@</span> <span class="p_context"></span>
 
 #include &quot;wlcore.h&quot;
 
<span class="p_del">-int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_del">-			 loff_t *ppos, char *fmt, ...);</span>
<span class="p_add">+__printf(4, 5) int wl1271_format_buffer(char __user *userbuf, size_t count,</span>
<span class="p_add">+					loff_t *ppos, char *fmt, ...);</span>
 
 int wl1271_debugfs_init(struct wl1271 *wl);
 void wl1271_debugfs_exit(struct wl1271 *wl);
<span class="p_header">diff --git a/drivers/parport/Kconfig b/drivers/parport/Kconfig</span>
<span class="p_header">index a50576081b34..46d2de24bf3e 100644</span>
<span class="p_header">--- a/drivers/parport/Kconfig</span>
<span class="p_header">+++ b/drivers/parport/Kconfig</span>
<span class="p_chunk">@@ -36,7 +36,9 @@</span> <span class="p_context"> if PARPORT</span>
 config PARPORT_PC
 	tristate &quot;PC-style hardware&quot;
 	depends on (!SPARC64 || PCI) &amp;&amp; !SPARC32 &amp;&amp; !M32R &amp;&amp; !FRV &amp;&amp; !S390 &amp;&amp; \
<span class="p_del">-		(!M68K || ISA) &amp;&amp; !MN10300 &amp;&amp; !AVR32 &amp;&amp; !BLACKFIN &amp;&amp; !XTENSA</span>
<span class="p_add">+		(!M68K || ISA) &amp;&amp; !MN10300 &amp;&amp; !AVR32 &amp;&amp; !BLACKFIN &amp;&amp; \</span>
<span class="p_add">+		!XTENSA &amp;&amp; !CRIS &amp;&amp; !H8300 &amp;&amp; !ARM64</span>
<span class="p_add">+</span>
 	---help---
 	  You should say Y here if you have a PC-style parallel port. All
 	  IBM PC compatible computers and some Alphas have PC-style
<span class="p_header">diff --git a/drivers/power/lp8788-charger.c b/drivers/power/lp8788-charger.c</span>
<span class="p_header">index ed49b50b220b..72da2a6c22db 100644</span>
<span class="p_header">--- a/drivers/power/lp8788-charger.c</span>
<span class="p_header">+++ b/drivers/power/lp8788-charger.c</span>
<span class="p_chunk">@@ -417,8 +417,10 @@</span> <span class="p_context"> static int lp8788_psy_register(struct platform_device *pdev,</span>
 	pchg-&gt;battery.num_properties = ARRAY_SIZE(lp8788_battery_prop);
 	pchg-&gt;battery.get_property = lp8788_battery_get_property;
 
<span class="p_del">-	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery))</span>
<span class="p_add">+	if (power_supply_register(&amp;pdev-&gt;dev, &amp;pchg-&gt;battery)) {</span>
<span class="p_add">+		power_supply_unregister(&amp;pchg-&gt;charger);</span>
 		return -EPERM;
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/scsi/mvsas/mv_sas.c b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">index c9e244984e30..fa50c7dc3d3e 100644</span>
<span class="p_header">--- a/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_header">+++ b/drivers/scsi/mvsas/mv_sas.c</span>
<span class="p_chunk">@@ -441,14 +441,11 @@</span> <span class="p_context"> static u32 mvs_get_ncq_tag(struct sas_task *task, u32 *tag)</span>
 static int mvs_task_prep_ata(struct mvs_info *mvi,
 			     struct mvs_task_exec_info *tei)
 {
<span class="p_del">-	struct sas_ha_struct *sha = mvi-&gt;sas;</span>
 	struct sas_task *task = tei-&gt;task;
 	struct domain_device *dev = task-&gt;dev;
 	struct mvs_device *mvi_dev = dev-&gt;lldd_dev;
 	struct mvs_cmd_hdr *hdr = tei-&gt;hdr;
 	struct asd_sas_port *sas_port = dev-&gt;port;
<span class="p_del">-	struct sas_phy *sphy = dev-&gt;phy;</span>
<span class="p_del">-	struct asd_sas_phy *sas_phy = sha-&gt;sas_phy[sphy-&gt;number];</span>
 	struct mvs_slot_info *slot;
 	void *buf_prd;
 	u32 tag = tei-&gt;tag, hdr_tag;
<span class="p_chunk">@@ -468,7 +465,7 @@</span> <span class="p_context"> static int mvs_task_prep_ata(struct mvs_info *mvi,</span>
 	slot-&gt;tx = mvi-&gt;tx_prod;
 	del_q = TXQ_MODE_I | tag |
 		(TXQ_CMD_STP &lt;&lt; TXQ_CMD_SHIFT) |
<span class="p_del">-		(MVS_PHY_ID &lt;&lt; TXQ_PHY_SHIFT) |</span>
<span class="p_add">+		((sas_port-&gt;phy_mask &amp; TXQ_PHY_MASK) &lt;&lt; TXQ_PHY_SHIFT) |</span>
 		(mvi_dev-&gt;taskfileset &lt;&lt; TXQ_SRS_SHIFT);
 	mvi-&gt;tx[mvi-&gt;tx_prod] = cpu_to_le32(del_q);
 
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index a8990783ba66..913b91c78a22 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -631,21 +631,22 @@</span> <span class="p_context"> static unsigned int copy_to_bounce_buffer(struct scatterlist *orig_sgl,</span>
 			if (bounce_sgl[j].length == PAGE_SIZE) {
 				/* full..move to next entry */
 				sg_kunmap_atomic(bounce_addr);
<span class="p_add">+				bounce_addr = 0;</span>
 				j++;
<span class="p_add">+			}</span>
 
<span class="p_del">-				/* if we need to use another bounce buffer */</span>
<span class="p_del">-				if (srclen || i != orig_sgl_count - 1)</span>
<span class="p_del">-					bounce_addr = sg_kmap_atomic(bounce_sgl,j);</span>
<span class="p_add">+			/* if we need to use another bounce buffer */</span>
<span class="p_add">+			if (srclen &amp;&amp; bounce_addr == 0)</span>
<span class="p_add">+				bounce_addr = sg_kmap_atomic(bounce_sgl, j);</span>
 
<span class="p_del">-			} else if (srclen == 0 &amp;&amp; i == orig_sgl_count - 1) {</span>
<span class="p_del">-				/* unmap the last bounce that is &lt; PAGE_SIZE */</span>
<span class="p_del">-				sg_kunmap_atomic(bounce_addr);</span>
<span class="p_del">-			}</span>
 		}
 
 		sg_kunmap_atomic(src_addr - orig_sgl[i].offset);
 	}
 
<span class="p_add">+	if (bounce_addr)</span>
<span class="p_add">+		sg_kunmap_atomic(bounce_addr);</span>
<span class="p_add">+</span>
 	local_irq_restore(flags);
 
 	return total_copied;
<span class="p_header">diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c</span>
<span class="p_header">index 911e9e0711d2..a08f923b9925 100644</span>
<span class="p_header">--- a/drivers/spi/spidev.c</span>
<span class="p_header">+++ b/drivers/spi/spidev.c</span>
<span class="p_chunk">@@ -243,7 +243,10 @@</span> <span class="p_context"> static int spidev_message(struct spidev_data *spidev,</span>
 		k_tmp-&gt;len = u_tmp-&gt;len;
 
 		total += k_tmp-&gt;len;
<span class="p_del">-		if (total &gt; bufsiz) {</span>
<span class="p_add">+		/* Check total length of transfers.  Also check each</span>
<span class="p_add">+		 * transfer length to avoid arithmetic overflow.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (total &gt; bufsiz || k_tmp-&gt;len &gt; bufsiz) {</span>
 			status = -EMSGSIZE;
 			goto done;
 		}
<span class="p_header">diff --git a/drivers/usb/class/cdc-wdm.c b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">index 6463ca3bcfba..07133d0c971b 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-wdm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-wdm.c</span>
<span class="p_chunk">@@ -244,7 +244,7 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 	case USB_CDC_NOTIFY_RESPONSE_AVAILABLE:
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev,
 			&quot;NOTIFY_RESPONSE_AVAILABLE received: index %d len %d&quot;,
<span class="p_del">-			dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex), le16_to_cpu(dr-&gt;wLength));</span>
 		break;
 
 	case USB_CDC_NOTIFY_NETWORK_CONNECTION:
<span class="p_chunk">@@ -257,7 +257,9 @@</span> <span class="p_context"> static void wdm_int_callback(struct urb *urb)</span>
 		clear_bit(WDM_POLL_RUNNING, &amp;desc-&gt;flags);
 		dev_err(&amp;desc-&gt;intf-&gt;dev,
 			&quot;unknown notification %d received: index %d len %d\n&quot;,
<span class="p_del">-			dr-&gt;bNotificationType, dr-&gt;wIndex, dr-&gt;wLength);</span>
<span class="p_add">+			dr-&gt;bNotificationType,</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wIndex),</span>
<span class="p_add">+			le16_to_cpu(dr-&gt;wLength));</span>
 		goto exit;
 	}
 
<span class="p_chunk">@@ -403,7 +405,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 			     USB_RECIP_INTERFACE);
 	req-&gt;bRequest = USB_CDC_SEND_ENCAPSULATED_COMMAND;
 	req-&gt;wValue = 0;
<span class="p_del">-	req-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	req-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	req-&gt;wLength = cpu_to_le16(count);
 	set_bit(WDM_IN_USE, &amp;desc-&gt;flags);
 	desc-&gt;outbuf = buf;
<span class="p_chunk">@@ -417,7 +419,7 @@</span> <span class="p_context"> static ssize_t wdm_write</span>
 		rv = usb_translate_errors(rv);
 	} else {
 		dev_dbg(&amp;desc-&gt;intf-&gt;dev, &quot;Tx URB has been submitted index=%d&quot;,
<span class="p_del">-			req-&gt;wIndex);</span>
<span class="p_add">+			le16_to_cpu(req-&gt;wIndex));</span>
 	}
 out:
 	usb_autopm_put_interface(desc-&gt;intf);
<span class="p_chunk">@@ -780,7 +782,7 @@</span> <span class="p_context"> static int wdm_create(struct usb_interface *intf, struct usb_endpoint_descriptor</span>
 	desc-&gt;irq-&gt;bRequestType = (USB_DIR_IN | USB_TYPE_CLASS | USB_RECIP_INTERFACE);
 	desc-&gt;irq-&gt;bRequest = USB_CDC_GET_ENCAPSULATED_RESPONSE;
 	desc-&gt;irq-&gt;wValue = 0;
<span class="p_del">-	desc-&gt;irq-&gt;wIndex = desc-&gt;inum;</span>
<span class="p_add">+	desc-&gt;irq-&gt;wIndex = desc-&gt;inum; /* already converted */</span>
 	desc-&gt;irq-&gt;wLength = cpu_to_le16(desc-&gt;wMaxCommand);
 
 	usb_fill_control_urb(
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index c9f56ffdba9a..11a073cda1d6 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -3282,10 +3282,10 @@</span> <span class="p_context"> int usb_port_resume(struct usb_device *udev, pm_message_t msg)</span>
 		dev_dbg(hub-&gt;intfdev, &quot;can&#39;t resume port %d, status %d\n&quot;,
 				port1, status);
 	} else {
<span class="p_del">-		/* drive resume for at least 20 msec */</span>
<span class="p_add">+		/* drive resume for USB_RESUME_TIMEOUT msec */</span>
 		dev_dbg(&amp;udev-&gt;dev, &quot;usb %sresume\n&quot;,
 				(PMSG_IS_AUTO(msg) ? &quot;auto-&quot; : &quot;&quot;));
<span class="p_del">-		msleep(25);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 
 		/* Virtual root hubs can trigger on GET_PORT_STATUS to
 		 * stop resume signaling.  Then finish the resume
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index 44a292b75012..a660716f9331 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -528,7 +528,7 @@</span> <span class="p_context"> static int bos_desc(struct usb_composite_dev *cdev)</span>
 	usb_ext-&gt;bLength = USB_DT_USB_EXT_CAP_SIZE;
 	usb_ext-&gt;bDescriptorType = USB_DT_DEVICE_CAPABILITY;
 	usb_ext-&gt;bDevCapabilityType = USB_CAP_TYPE_EXT;
<span class="p_del">-	usb_ext-&gt;bmAttributes = cpu_to_le32(USB_LPM_SUPPORT);</span>
<span class="p_add">+	usb_ext-&gt;bmAttributes = cpu_to_le32(USB_LPM_SUPPORT | USB_BESL_SUPPORT);</span>
 
 	/*
 	 * The Superspeed USB Capability descriptor shall be implemented by all
<span class="p_header">diff --git a/drivers/usb/host/isp116x-hcd.c b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">index b64e661618bb..baf2807934c1 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp116x-hcd.c</span>
<span class="p_chunk">@@ -1488,7 +1488,7 @@</span> <span class="p_context"> static int isp116x_bus_resume(struct usb_hcd *hcd)</span>
 	spin_unlock_irq(&amp;isp116x-&gt;lock);
 
 	hcd-&gt;state = HC_STATE_RESUMING;
<span class="p_del">-	msleep(20);</span>
<span class="p_add">+	msleep(USB_RESUME_TIMEOUT);</span>
 
 	/* Go operational */
 	spin_lock_irq(&amp;isp116x-&gt;lock);
<span class="p_header">diff --git a/drivers/usb/host/r8a66597-hcd.c b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">index a6fd8f5371df..6656dfda5665 100644</span>
<span class="p_header">--- a/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/r8a66597-hcd.c</span>
<span class="p_chunk">@@ -2301,7 +2301,7 @@</span> <span class="p_context"> static int r8a66597_bus_resume(struct usb_hcd *hcd)</span>
 		rh-&gt;port &amp;= ~USB_PORT_STAT_SUSPEND;
 		rh-&gt;port |= USB_PORT_STAT_C_SUSPEND &lt;&lt; 16;
 		r8a66597_mdfy(r8a66597, RESUME, RESUME | UACT, dvstctr_reg);
<span class="p_del">-		msleep(50);</span>
<span class="p_add">+		msleep(USB_RESUME_TIMEOUT);</span>
 		r8a66597_mdfy(r8a66597, UACT, RESUME | UACT, dvstctr_reg);
 	}
 
<span class="p_header">diff --git a/drivers/usb/host/sl811-hcd.c b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">index b2ec7fe758dd..b4cad9346035 100644</span>
<span class="p_header">--- a/drivers/usb/host/sl811-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/sl811-hcd.c</span>
<span class="p_chunk">@@ -1251,7 +1251,7 @@</span> <span class="p_context"> sl811h_hub_control(</span>
 			sl811_write(sl811, SL11H_CTLREG1, sl811-&gt;ctrl1);
 
 			mod_timer(&amp;sl811-&gt;timer, jiffies
<span class="p_del">-					+ msecs_to_jiffies(20));</span>
<span class="p_add">+					+ msecs_to_jiffies(USB_RESUME_TIMEOUT));</span>
 			break;
 		case USB_PORT_FEAT_POWER:
 			port_power(sl811, 0);
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 9948890ef93e..bc7a886e3c36 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1697,7 +1697,7 @@</span> <span class="p_context"> static void handle_port_status(struct xhci_hcd *xhci,</span>
 		} else {
 			xhci_dbg(xhci, &quot;resume HS port %d\n&quot;, port_id);
 			bus_state-&gt;resume_done[faked_port_index] = jiffies +
<span class="p_del">-				msecs_to_jiffies(20);</span>
<span class="p_add">+				msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			set_bit(faked_port_index, &amp;bus_state-&gt;resuming_ports);
 			mod_timer(&amp;hcd-&gt;rh_timer,
 				  bus_state-&gt;resume_done[faked_port_index]);
<span class="p_header">diff --git a/drivers/usb/phy/phy.c b/drivers/usb/phy/phy.c</span>
<span class="p_header">index a9984c700d2c..5f79d8e2caab 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy.c</span>
<span class="p_chunk">@@ -78,7 +78,9 @@</span> <span class="p_context"> static void devm_usb_phy_release(struct device *dev, void *res)</span>
 
 static int devm_usb_phy_match(struct device *dev, void *res, void *match_data)
 {
<span class="p_del">-	return res == match_data;</span>
<span class="p_add">+	struct usb_phy **phy = res;</span>
<span class="p_add">+</span>
<span class="p_add">+	return *phy == match_data;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/video/console/Kconfig b/drivers/video/console/Kconfig</span>
<span class="p_header">index bc922c47d046..37e62c7b3273 100644</span>
<span class="p_header">--- a/drivers/video/console/Kconfig</span>
<span class="p_header">+++ b/drivers/video/console/Kconfig</span>
<span class="p_chunk">@@ -6,7 +6,10 @@</span> <span class="p_context"> menu &quot;Console display driver support&quot;</span>
 
 config VGA_CONSOLE
 	bool &quot;VGA text console&quot; if EXPERT || !X86
<span class="p_del">-	depends on !4xx &amp;&amp; !8xx &amp;&amp; !SPARC &amp;&amp; !M68K &amp;&amp; !PARISC &amp;&amp; !FRV &amp;&amp; !SUPERH &amp;&amp; !BLACKFIN &amp;&amp; !AVR32 &amp;&amp; !MN10300 &amp;&amp; (!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER)</span>
<span class="p_add">+	depends on !4xx &amp;&amp; !8xx &amp;&amp; !SPARC &amp;&amp; !M68K &amp;&amp; !PARISC &amp;&amp; !FRV &amp;&amp; \</span>
<span class="p_add">+		!SUPERH &amp;&amp; !BLACKFIN &amp;&amp; !AVR32 &amp;&amp; !MN10300 &amp;&amp; !CRIS &amp;&amp; \</span>
<span class="p_add">+		(!ARM || ARCH_FOOTBRIDGE || ARCH_INTEGRATOR || ARCH_NETWINDER) &amp;&amp; \</span>
<span class="p_add">+		!ARM64</span>
 	default y
 	help
 	  Saying Y here will allow you to use Linux in text mode through a
<span class="p_header">diff --git a/fs/binfmt_elf.c b/fs/binfmt_elf.c</span>
<span class="p_header">index 3c4d8797ea9a..53f620a4350e 100644</span>
<span class="p_header">--- a/fs/binfmt_elf.c</span>
<span class="p_header">+++ b/fs/binfmt_elf.c</span>
<span class="p_chunk">@@ -756,6 +756,7 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 	    i &lt; loc-&gt;elf_ex.e_phnum; i++, elf_ppnt++) {
 		int elf_prot = 0, elf_flags;
 		unsigned long k, vaddr;
<span class="p_add">+		unsigned long total_size = 0;</span>
 
 		if (elf_ppnt-&gt;p_type != PT_LOAD)
 			continue;
<span class="p_chunk">@@ -820,10 +821,16 @@</span> <span class="p_context"> static int load_elf_binary(struct linux_binprm *bprm)</span>
 #else
 			load_bias = ELF_PAGESTART(ELF_ET_DYN_BASE - vaddr);
 #endif
<span class="p_add">+			total_size = total_mapping_size(elf_phdata,</span>
<span class="p_add">+							loc-&gt;elf_ex.e_phnum);</span>
<span class="p_add">+			if (!total_size) {</span>
<span class="p_add">+				error = -EINVAL;</span>
<span class="p_add">+				goto out_free_dentry;</span>
<span class="p_add">+			}</span>
 		}
 
 		error = elf_map(bprm-&gt;file, load_bias + vaddr, elf_ppnt,
<span class="p_del">-				elf_prot, elf_flags, 0);</span>
<span class="p_add">+				elf_prot, elf_flags, total_size);</span>
 		if (BAD_ADDR(error)) {
 			send_sig(SIGKILL, current, 0);
 			retval = IS_ERR((void *)error) ?
<span class="p_header">diff --git a/fs/btrfs/extent-tree.c b/fs/btrfs/extent-tree.c</span>
<span class="p_header">index f99c71e40f8b..07f167a1d271 100644</span>
<span class="p_header">--- a/fs/btrfs/extent-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/extent-tree.c</span>
<span class="p_chunk">@@ -6363,12 +6363,11 @@</span> <span class="p_context"> static int __btrfs_free_reserved_extent(struct btrfs_root *root,</span>
 		return -ENOSPC;
 	}
 
<span class="p_del">-	if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_del">-		ret = btrfs_discard_extent(root, start, len, NULL);</span>
<span class="p_del">-</span>
 	if (pin)
 		pin_down_extent(root, cache, start, len, 1);
 	else {
<span class="p_add">+		if (btrfs_test_opt(root, DISCARD))</span>
<span class="p_add">+			ret = btrfs_discard_extent(root, start, len, NULL);</span>
 		btrfs_add_free_space(cache, start, len);
 		btrfs_update_reserved_bytes(cache, len, RESERVE_FREE);
 	}
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 783906c687b5..dbefa6c609f4 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2572,6 +2572,11 @@</span> <span class="p_context"> static noinline long btrfs_ioctl_clone(struct file *file, unsigned long srcfd,</span>
 	if (off + len == src-&gt;i_size)
 		len = ALIGN(src-&gt;i_size, bs) - off;
 
<span class="p_add">+	if (len == 0) {</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* verify the end result is block aligned */
 	if (!IS_ALIGNED(off, bs) || !IS_ALIGNED(off + len, bs) ||
 	    !IS_ALIGNED(destoff, bs))
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index f1312173fa90..facf8590b714 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1880,7 +1880,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			  struct inode *inode)
 {
 	struct inode *dir = dentry-&gt;d_parent-&gt;d_inode;
<span class="p_del">-	struct buffer_head *bh;</span>
<span class="p_add">+	struct buffer_head *bh = NULL;</span>
 	struct ext4_dir_entry_2 *de;
 	struct ext4_dir_entry_tail *t;
 	struct super_block *sb;
<span class="p_chunk">@@ -1905,14 +1905,14 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return retval;
 		if (retval == 1) {
 			retval = 0;
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		}
 	}
 
 	if (is_dx(dir)) {
 		retval = ext4_dx_add_entry(handle, dentry, inode);
 		if (!retval || (retval != ERR_BAD_DX_DIR))
<span class="p_del">-			return retval;</span>
<span class="p_add">+			goto out;</span>
 		ext4_clear_inode_flag(dir, EXT4_INODE_INDEX);
 		dx_fallback++;
 		ext4_mark_inode_dirty(handle, dir);
<span class="p_chunk">@@ -1924,14 +1924,15 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 			return PTR_ERR(bh);
 
 		retval = add_dirent_to_buf(handle, dentry, inode, NULL, bh);
<span class="p_del">-		if (retval != -ENOSPC) {</span>
<span class="p_del">-			brelse(bh);</span>
<span class="p_del">-			return retval;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (retval != -ENOSPC)</span>
<span class="p_add">+			goto out;</span>
 
 		if (blocks == 1 &amp;&amp; !dx_fallback &amp;&amp;
<span class="p_del">-		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX))</span>
<span class="p_del">-			return make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+		    EXT4_HAS_COMPAT_FEATURE(sb, EXT4_FEATURE_COMPAT_DIR_INDEX)) {</span>
<span class="p_add">+			retval = make_indexed_dir(handle, dentry, inode, bh);</span>
<span class="p_add">+			bh = NULL; /* make_indexed_dir releases bh */</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
 		brelse(bh);
 	}
 	bh = ext4_append(handle, dir, &amp;block);
<span class="p_chunk">@@ -1947,6 +1948,7 @@</span> <span class="p_context"> static int ext4_add_entry(handle_t *handle, struct dentry *dentry,</span>
 	}
 
 	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);
<span class="p_add">+out:</span>
 	brelse(bh);
 	if (retval == 0)
 		ext4_set_inode_state(inode, EXT4_STATE_NEWENTRY);
<span class="p_header">diff --git a/fs/namei.c b/fs/namei.c</span>
<span class="p_header">index f7c4393f8535..036c21246d6a 100644</span>
<span class="p_header">--- a/fs/namei.c</span>
<span class="p_header">+++ b/fs/namei.c</span>
<span class="p_chunk">@@ -1542,7 +1542,8 @@</span> <span class="p_context"> static inline int walk_component(struct nameidata *nd, struct path *path,</span>
 
 	if (should_follow_link(inode, follow)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				err = -ECHILD;
 				goto out_err;
 			}
<span class="p_chunk">@@ -2824,7 +2825,8 @@</span> <span class="p_context"> finish_lookup:</span>
 
 	if (should_follow_link(inode, !symlink_ok)) {
 		if (nd-&gt;flags &amp; LOOKUP_RCU) {
<span class="p_del">-			if (unlikely(unlazy_walk(nd, path-&gt;dentry))) {</span>
<span class="p_add">+			if (unlikely(nd-&gt;path.mnt != path-&gt;mnt ||</span>
<span class="p_add">+				     unlazy_walk(nd, path-&gt;dentry))) {</span>
 				error = -ECHILD;
 				goto out;
 			}
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index a64adcc29ae5..f819e813c8ac 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -198,9 +198,29 @@</span> <span class="p_context"> typedef int INT32;</span>
 typedef s32 acpi_native_int;
 
 typedef u32 acpi_size;
<span class="p_add">+</span>
<span class="p_add">+#ifdef ACPI_32BIT_PHYSICAL_ADDRESS</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * OSPMs can define this to shrink the size of the structures for 32-bit</span>
<span class="p_add">+ * none PAE environment. ASL compiler may always define this to generate</span>
<span class="p_add">+ * 32-bit OSPM compliant tables.</span>
<span class="p_add">+ */</span>
 typedef u32 acpi_io_address;
 typedef u32 acpi_physical_address;
 
<span class="p_add">+#else				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * It is reported that, after some calculations, the physical addresses can</span>
<span class="p_add">+ * wrap over the 32-bit boundary on 32-bit PAE environment.</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=87971</span>
<span class="p_add">+ */</span>
<span class="p_add">+typedef u64 acpi_io_address;</span>
<span class="p_add">+typedef u64 acpi_physical_address;</span>
<span class="p_add">+</span>
<span class="p_add">+#endif				/* ACPI_32BIT_PHYSICAL_ADDRESS */</span>
<span class="p_add">+</span>
 #define ACPI_MAX_PTR                    ACPI_UINT32_MAX
 #define ACPI_SIZE_MAX                   ACPI_UINT32_MAX
 
<span class="p_header">diff --git a/include/acpi/platform/acenv.h b/include/acpi/platform/acenv.h</span>
<span class="p_header">index ef04b36ca6ed..f7db107abb04 100644</span>
<span class="p_header">--- a/include/acpi/platform/acenv.h</span>
<span class="p_header">+++ b/include/acpi/platform/acenv.h</span>
<span class="p_chunk">@@ -76,6 +76,7 @@</span> <span class="p_context"></span>
 #define ACPI_LARGE_NAMESPACE_NODE
 #define ACPI_DATA_TABLE_DISASSEMBLY
 #define ACPI_SINGLE_THREADED
<span class="p_add">+#define ACPI_32BIT_PHYSICAL_ADDRESS</span>
 #endif
 
 /* acpi_exec configuration. Multithreaded with full AML debugger */
<span class="p_header">diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h</span>
<span class="p_header">index c1a1216e29ce..87b27263f5e2 100644</span>
<span class="p_header">--- a/include/asm-generic/sections.h</span>
<span class="p_header">+++ b/include/asm-generic/sections.h</span>
<span class="p_chunk">@@ -3,6 +3,8 @@</span> <span class="p_context"></span>
 
 /* References to section boundaries */
 
<span class="p_add">+#include &lt;linux/compiler.h&gt;</span>
<span class="p_add">+</span>
 extern char _text[], _stext[], _etext[];
 extern char _data[], _sdata[], _edata[];
 extern char __bss_start[], __bss_stop[];
<span class="p_chunk">@@ -18,6 +20,8 @@</span> <span class="p_context"> extern char __start_rodata[], __end_rodata[];</span>
 /* Start and end of .ctors section - used for constructor calls. */
 extern char __ctors_start[], __ctors_end[];
 
<span class="p_add">+extern __visible const void __nosave_begin, __nosave_end;</span>
<span class="p_add">+</span>
 /* function descriptor handling (if any).  Override
  * in asm/sections.h */
 #ifndef dereference_function_descriptor
<span class="p_header">diff --git a/include/linux/usb.h b/include/linux/usb.h</span>
<span class="p_header">index a0bee5a28d1a..28bd3a898cba 100644</span>
<span class="p_header">--- a/include/linux/usb.h</span>
<span class="p_header">+++ b/include/linux/usb.h</span>
<span class="p_chunk">@@ -206,6 +206,32 @@</span> <span class="p_context"> void usb_put_intf(struct usb_interface *intf);</span>
 #define USB_MAXINTERFACES	32
 #define USB_MAXIADS		(USB_MAXINTERFACES/2)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * USB Resume Timer: Every Host controller driver should drive the resume</span>
<span class="p_add">+ * signalling on the bus for the amount of time defined by this macro.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * That way we will have a &#39;stable&#39; behavior among all HCDs supported by Linux.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note that the USB Specification states we should drive resume for *at least*</span>
<span class="p_add">+ * 20 ms, but it doesn&#39;t give an upper bound. This creates two possible</span>
<span class="p_add">+ * situations which we want to avoid:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (a) sometimes an msleep(20) might expire slightly before 20 ms, which causes</span>
<span class="p_add">+ * us to fail USB Electrical Tests, thus failing Certification</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * (b) Some (many) devices actually need more than 20 ms of resume signalling,</span>
<span class="p_add">+ * and while we can argue that&#39;s against the USB Specification, we don&#39;t have</span>
<span class="p_add">+ * control over which devices a certification laboratory will be using for</span>
<span class="p_add">+ * certification. If CertLab uses a device which was tested against Windows and</span>
<span class="p_add">+ * that happens to have relaxed resume signalling rules, we might fall into</span>
<span class="p_add">+ * situations where we fail interoperability and electrical tests.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * In order to avoid both conditions, we&#39;re using a 40 ms resume timeout, which</span>
<span class="p_add">+ * should cope with both LPJ calibration errors and devices not following every</span>
<span class="p_add">+ * detail of the USB Specification.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define USB_RESUME_TIMEOUT	40 /* ms */</span>
<span class="p_add">+</span>
 /**
  * struct usb_interface_cache - long-term representation of a device interface
  * @num_altsetting: number of altsettings defined.
<span class="p_header">diff --git a/kernel/ptrace.c b/kernel/ptrace.c</span>
<span class="p_header">index afadcf7b4a22..118323bc8529 100644</span>
<span class="p_header">--- a/kernel/ptrace.c</span>
<span class="p_header">+++ b/kernel/ptrace.c</span>
<span class="p_chunk">@@ -720,6 +720,8 @@</span> <span class="p_context"> static int ptrace_peek_siginfo(struct task_struct *child,</span>
 static int ptrace_resume(struct task_struct *child, long request,
 			 unsigned long data)
 {
<span class="p_add">+	bool need_siglock;</span>
<span class="p_add">+</span>
 	if (!valid_signal(data))
 		return -EIO;
 
<span class="p_chunk">@@ -747,8 +749,26 @@</span> <span class="p_context"> static int ptrace_resume(struct task_struct *child, long request,</span>
 		user_disable_single_step(child);
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Change -&gt;exit_code and -&gt;state under siglock to avoid the race</span>
<span class="p_add">+	 * with wait_task_stopped() in between; a non-zero -&gt;exit_code will</span>
<span class="p_add">+	 * wrongly look like another report from tracee.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Note that we need siglock even if -&gt;exit_code == data and/or this</span>
<span class="p_add">+	 * status was not reported yet, the new status must not be cleared by</span>
<span class="p_add">+	 * wait_task_stopped() after resume.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * If data == 0 we do not care if wait_task_stopped() reports the old</span>
<span class="p_add">+	 * status and clears the code too; this can&#39;t race with the tracee, it</span>
<span class="p_add">+	 * takes siglock after resume.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	need_siglock = data &amp;&amp; !thread_group_empty(current);</span>
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_lock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 	child-&gt;exit_code = data;
 	wake_up_state(child, __TASK_TRACED);
<span class="p_add">+	if (need_siglock)</span>
<span class="p_add">+		spin_unlock_irq(&amp;child-&gt;sighand-&gt;siglock);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/kernel/softirq.c b/kernel/softirq.c</span>
<span class="p_header">index 787b3a032429..21956f00cb51 100644</span>
<span class="p_header">--- a/kernel/softirq.c</span>
<span class="p_header">+++ b/kernel/softirq.c</span>
<span class="p_chunk">@@ -774,9 +774,13 @@</span> <span class="p_context"> static void run_ksoftirqd(unsigned int cpu)</span>
 	local_irq_disable();
 	if (local_softirq_pending()) {
 		__do_softirq();
<span class="p_del">-		rcu_note_context_switch(cpu);</span>
 		local_irq_enable();
 		cond_resched();
<span class="p_add">+</span>
<span class="p_add">+		preempt_disable();</span>
<span class="p_add">+		rcu_note_context_switch(cpu);</span>
<span class="p_add">+		preempt_enable();</span>
<span class="p_add">+</span>
 		return;
 	}
 	local_irq_enable();
<span class="p_header">diff --git a/kernel/trace/ring_buffer.c b/kernel/trace/ring_buffer.c</span>
<span class="p_header">index 3d9fee3a80b3..ab21b8c66535 100644</span>
<span class="p_header">--- a/kernel/trace/ring_buffer.c</span>
<span class="p_header">+++ b/kernel/trace/ring_buffer.c</span>
<span class="p_chunk">@@ -2650,7 +2650,7 @@</span> <span class="p_context"> static DEFINE_PER_CPU(unsigned int, current_context);</span>
 
 static __always_inline int trace_recursive_lock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 	int bit;
 
 	if (in_interrupt()) {
<span class="p_chunk">@@ -2667,18 +2667,17 @@</span> <span class="p_context"> static __always_inline int trace_recursive_lock(void)</span>
 		return 1;
 
 	val |= (1 &lt;&lt; bit);
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 
 	return 0;
 }
 
 static __always_inline void trace_recursive_unlock(void)
 {
<span class="p_del">-	unsigned int val = this_cpu_read(current_context);</span>
<span class="p_add">+	unsigned int val = __this_cpu_read(current_context);</span>
 
<span class="p_del">-	val--;</span>
<span class="p_del">-	val &amp;= this_cpu_read(current_context);</span>
<span class="p_del">-	this_cpu_write(current_context, val);</span>
<span class="p_add">+	val &amp;= val &amp; (val - 1);</span>
<span class="p_add">+	__this_cpu_write(current_context, val);</span>
 }
 
 #else
<span class="p_header">diff --git a/lib/string.c b/lib/string.c</span>
<span class="p_header">index 43d0781daf47..cb9ea2181557 100644</span>
<span class="p_header">--- a/lib/string.c</span>
<span class="p_header">+++ b/lib/string.c</span>
<span class="p_chunk">@@ -598,7 +598,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(memset);</span>
 void memzero_explicit(void *s, size_t count)
 {
 	memset(s, 0, count);
<span class="p_del">-	OPTIMIZER_HIDE_VAR(s);</span>
<span class="p_add">+	barrier();</span>
 }
 EXPORT_SYMBOL(memzero_explicit);
 
<span class="p_header">diff --git a/net/ipv4/ip_forward.c b/net/ipv4/ip_forward.c</span>
<span class="p_header">index 31ee5c6033df..479e8a63125a 100644</span>
<span class="p_header">--- a/net/ipv4/ip_forward.c</span>
<span class="p_header">+++ b/net/ipv4/ip_forward.c</span>
<span class="p_chunk">@@ -126,6 +126,9 @@</span> <span class="p_context"> int ip_forward(struct sk_buff *skb)</span>
 	struct rtable *rt;	/* Route we use */
 	struct ip_options *opt	= &amp;(IPCB(skb)-&gt;opt);
 
<span class="p_add">+	if (unlikely(skb-&gt;sk))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+</span>
 	if (skb_warn_if_lro(skb))
 		goto drop;
 
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 7681a1bbd97f..76c80b59e80f 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -2571,39 +2571,65 @@</span> <span class="p_context"> begin_fwd:</span>
 	}
 }
 
<span class="p_del">-/* Send a fin.  The caller locks the socket for us.  This cannot be</span>
<span class="p_del">- * allowed to fail queueing a FIN frame under any circumstances.</span>
<span class="p_add">+/* We allow to exceed memory limits for FIN packets to expedite</span>
<span class="p_add">+ * connection tear down and (memory) recovery.</span>
<span class="p_add">+ * Otherwise tcp_send_fin() could be tempted to either delay FIN</span>
<span class="p_add">+ * or even be forced to close flow without any FIN.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void sk_forced_wmem_schedule(struct sock *sk, int size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int amt, status;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size &lt;= sk-&gt;sk_forward_alloc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	amt = sk_mem_pages(size);</span>
<span class="p_add">+	sk-&gt;sk_forward_alloc += amt * SK_MEM_QUANTUM;</span>
<span class="p_add">+	sk_memory_allocated_add(sk, amt, &amp;status);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Send a FIN. The caller locks the socket for us.</span>
<span class="p_add">+ * We should try to send a FIN packet really hard, but eventually give up.</span>
  */
 void tcp_send_fin(struct sock *sk)
 {
<span class="p_add">+	struct sk_buff *skb, *tskb = tcp_write_queue_tail(sk);</span>
 	struct tcp_sock *tp = tcp_sk(sk);
<span class="p_del">-	struct sk_buff *skb = tcp_write_queue_tail(sk);</span>
<span class="p_del">-	int mss_now;</span>
 
<span class="p_del">-	/* Optimization, tack on the FIN if we have a queue of</span>
<span class="p_del">-	 * unsent frames.  But be careful about outgoing SACKS</span>
<span class="p_del">-	 * and IP options.</span>
<span class="p_add">+	/* Optimization, tack on the FIN if we have one skb in write queue and</span>
<span class="p_add">+	 * this skb was not yet sent, or we are under memory pressure.</span>
<span class="p_add">+	 * Note: in the latter case, FIN packet will be sent after a timeout,</span>
<span class="p_add">+	 * as TCP stack thinks it has already been transmitted.</span>
 	 */
<span class="p_del">-	mss_now = tcp_current_mss(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tcp_send_head(sk) != NULL) {</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_del">-		TCP_SKB_CB(skb)-&gt;end_seq++;</span>
<span class="p_add">+	if (tskb &amp;&amp; (tcp_send_head(sk) || sk_under_memory_pressure(sk))) {</span>
<span class="p_add">+coalesce:</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;tcp_flags |= TCPHDR_FIN;</span>
<span class="p_add">+		TCP_SKB_CB(tskb)-&gt;end_seq++;</span>
 		tp-&gt;write_seq++;
<span class="p_add">+		if (!tcp_send_head(sk)) {</span>
<span class="p_add">+			/* This means tskb was already sent.</span>
<span class="p_add">+			 * Pretend we included the FIN on previous transmit.</span>
<span class="p_add">+			 * We need to set tp-&gt;snd_nxt to the value it would have</span>
<span class="p_add">+			 * if FIN had been sent. This is because retransmit path</span>
<span class="p_add">+			 * does not change tp-&gt;snd_nxt.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			tp-&gt;snd_nxt++;</span>
<span class="p_add">+			return;</span>
<span class="p_add">+		}</span>
 	} else {
<span class="p_del">-		/* Socket is locked, keep trying until memory is available. */</span>
<span class="p_del">-		for (;;) {</span>
<span class="p_del">-			skb = sk_stream_alloc_skb(sk, 0, sk-&gt;sk_allocation);</span>
<span class="p_del">-			if (skb)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			yield();</span>
<span class="p_add">+		skb = alloc_skb_fclone(MAX_TCP_HEADER, sk-&gt;sk_allocation);</span>
<span class="p_add">+		if (unlikely(!skb)) {</span>
<span class="p_add">+			if (tskb)</span>
<span class="p_add">+				goto coalesce;</span>
<span class="p_add">+			return;</span>
 		}
<span class="p_add">+		skb_reserve(skb, MAX_TCP_HEADER);</span>
<span class="p_add">+		sk_forced_wmem_schedule(sk, skb-&gt;truesize);</span>
 		/* FIN eats a sequence byte, write_seq advanced by tcp_queue_skb(). */
 		tcp_init_nondata_skb(skb, tp-&gt;write_seq,
 				     TCPHDR_ACK | TCPHDR_FIN);
 		tcp_queue_skb(sk, skb);
 	}
<span class="p_del">-	__tcp_push_pending_frames(sk, mss_now, TCP_NAGLE_OFF);</span>
<span class="p_add">+	__tcp_push_pending_frames(sk, tcp_current_mss(sk), TCP_NAGLE_OFF);</span>
 }
 
 /* We get here when a process closes a file descriptor (either due to
<span class="p_header">diff --git a/sound/pci/emu10k1/emuproc.c b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">index 2ca9f2e93139..53745f4c2bf5 100644</span>
<span class="p_header">--- a/sound/pci/emu10k1/emuproc.c</span>
<span class="p_header">+++ b/sound/pci/emu10k1/emuproc.c</span>
<span class="p_chunk">@@ -241,31 +241,22 @@</span> <span class="p_context"> static void snd_emu10k1_proc_spdif_read(struct snd_info_entry *entry,</span>
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
 	u32 value2;
<span class="p_del">-	unsigned long flags;</span>
 	u32 rate;
 
 	if (emu-&gt;card_capabilities-&gt;emu_model) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x38, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x1) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x2a, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x2b, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;ADAT Locked : %u\n&quot;, rate);
 		} else {
 			snd_iprintf(buffer, &quot;ADAT Unlocked\n&quot;);
 		}
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, 0x20, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		if ((value &amp; 0x4) == 0) {
<span class="p_del">-			spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 			snd_emu1010_fpga_read(emu, 0x28, &amp;value);
 			snd_emu1010_fpga_read(emu, 0x29, &amp;value2);
<span class="p_del">-			spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 			rate = 0x1770000 / (((value &lt;&lt; 5) | value2)+1);	
 			snd_iprintf(buffer, &quot;SPDIF Locked : %d\n&quot;, rate);
 		} else {
<span class="p_chunk">@@ -410,14 +401,11 @@</span> <span class="p_context"> static void snd_emu_proc_emu1010_reg_read(struct snd_info_entry *entry,</span>
 {
 	struct snd_emu10k1 *emu = entry-&gt;private_data;
 	u32 value;
<span class="p_del">-	unsigned long flags;</span>
 	int i;
 	snd_iprintf(buffer, &quot;EMU1010 Registers:\n\n&quot;);
 
 	for(i = 0; i &lt; 0x40; i+=1) {
<span class="p_del">-		spin_lock_irqsave(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_emu1010_fpga_read(emu, i, &amp;value);
<span class="p_del">-		spin_unlock_irqrestore(&amp;emu-&gt;emu_lock, flags);</span>
 		snd_iprintf(buffer, &quot;%02X: %08X, %02X\n&quot;, i, value, (value &gt;&gt; 8) &amp; 0x7f);
 	}
 }
<span class="p_header">diff --git a/tools/power/x86/turbostat/Makefile b/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">index d1b3a361e526..4039854560d0 100644</span>
<span class="p_header">--- a/tools/power/x86/turbostat/Makefile</span>
<span class="p_header">+++ b/tools/power/x86/turbostat/Makefile</span>
<span class="p_chunk">@@ -1,8 +1,12 @@</span> <span class="p_context"></span>
 CC		= $(CROSS_COMPILE)gcc
<span class="p_del">-BUILD_OUTPUT	:= $(PWD)</span>
<span class="p_add">+BUILD_OUTPUT	:= $(CURDIR)</span>
 PREFIX		:= /usr
 DESTDIR		:=
 
<span class="p_add">+ifeq (&quot;$(origin O)&quot;, &quot;command line&quot;)</span>
<span class="p_add">+	BUILD_OUTPUT := $(O)</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 turbostat : turbostat.c
 CFLAGS +=	-Wall
 CFLAGS +=	-DMSRHEADER=&#39;&quot;../../../../arch/x86/include/uapi/asm/msr-index.h&quot;&#39;
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index a17f190be58e..1d4b8bed4e48 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -1549,8 +1549,8 @@</span> <span class="p_context"> int kvm_gfn_to_hva_cache_init(struct kvm *kvm, struct gfn_to_hva_cache *ghc,</span>
 	ghc-&gt;generation = slots-&gt;generation;
 	ghc-&gt;len = len;
 	ghc-&gt;memslot = gfn_to_memslot(kvm, start_gfn);
<span class="p_del">-	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, &amp;nr_pages_avail);</span>
<span class="p_del">-	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_avail &gt;= nr_pages_needed) {</span>
<span class="p_add">+	ghc-&gt;hva = gfn_to_hva_many(ghc-&gt;memslot, start_gfn, NULL);</span>
<span class="p_add">+	if (!kvm_is_error_hva(ghc-&gt;hva) &amp;&amp; nr_pages_needed &lt;= 1) {</span>
 		ghc-&gt;hva += offset;
 	} else {
 		/*

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



