
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.1.4 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.1.4</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 3, 2015, 6:05 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20150803180505.GB4687@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6932391/mbox/"
   >mbox</a>
|
   <a href="/patch/6932391/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6932391/">/patch/6932391/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 4691CC05AC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:06:30 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id DD83A20641
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:06:10 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id CC5A920638
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon,  3 Aug 2015 18:05:48 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932201AbbHCSF1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 3 Aug 2015 14:05:27 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:37305 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1753685AbbHCSFI (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 3 Aug 2015 14:05:08 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 242E67AD;
	Mon,  3 Aug 2015 18:05:06 +0000 (UTC)
Date: Mon, 3 Aug 2015 11:05:05 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.1.4
Message-ID: &lt;20150803180505.GB4687@kroah.com&gt;
References: &lt;20150803180455.GA4687@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20150803180455.GA4687@kroah.com&gt;
User-Agent: Mutt/1.5.23+102 (2ca89bed6448) (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-7.1 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 3, 2015, 6:05 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/ABI/testing/ima_policy b/Documentation/ABI/testing/ima_policy</span>
<span class="p_header">index d0d0c578324c..0a378a88217a 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/ima_policy</span>
<span class="p_header">+++ b/Documentation/ABI/testing/ima_policy</span>
<span class="p_chunk">@@ -20,17 +20,19 @@</span> <span class="p_context"> Description:</span>
 		action: measure | dont_measure | appraise | dont_appraise | audit
 		condition:= base | lsm  [option]
 			base:	[[func=] [mask=] [fsmagic=] [fsuuid=] [uid=]
<span class="p_del">-				 [fowner]]</span>
<span class="p_add">+				[euid=] [fowner=]]</span>
 			lsm:	[[subj_user=] [subj_role=] [subj_type=]
 				 [obj_user=] [obj_role=] [obj_type=]]
 			option:	[[appraise_type=]] [permit_directio]
 
 		base: 	func:= [BPRM_CHECK][MMAP_CHECK][FILE_CHECK][MODULE_CHECK]
 				[FIRMWARE_CHECK]
<span class="p_del">-			mask:= [MAY_READ] [MAY_WRITE] [MAY_APPEND] [MAY_EXEC]</span>
<span class="p_add">+			mask:= [[^]MAY_READ] [[^]MAY_WRITE] [[^]MAY_APPEND]</span>
<span class="p_add">+			       [[^]MAY_EXEC]</span>
 			fsmagic:= hex value
 			fsuuid:= file system UUID (e.g 8bcbe394-4f13-4144-be8e-5aa9ea2ce2f6)
 			uid:= decimal value
<span class="p_add">+			euid:= decimal value</span>
 			fowner:=decimal value
 		lsm:  	are LSM specific
 		option:	appraise_type:= [imasig]
<span class="p_chunk">@@ -49,11 +51,25 @@</span> <span class="p_context"> Description:</span>
 			dont_measure fsmagic=0x01021994
 			dont_appraise fsmagic=0x01021994
 			# RAMFS_MAGIC
<span class="p_del">-			dont_measure fsmagic=0x858458f6</span>
 			dont_appraise fsmagic=0x858458f6
<span class="p_add">+			# DEVPTS_SUPER_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x1cd1</span>
<span class="p_add">+			dont_appraise fsmagic=0x1cd1</span>
<span class="p_add">+			# BINFMTFS_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x42494e4d</span>
<span class="p_add">+			dont_appraise fsmagic=0x42494e4d</span>
 			# SECURITYFS_MAGIC
 			dont_measure fsmagic=0x73636673
 			dont_appraise fsmagic=0x73636673
<span class="p_add">+			# SELINUX_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0xf97cff8c</span>
<span class="p_add">+			dont_appraise fsmagic=0xf97cff8c</span>
<span class="p_add">+			# CGROUP_SUPER_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x27e0eb</span>
<span class="p_add">+			dont_appraise fsmagic=0x27e0eb</span>
<span class="p_add">+			# NSFS_MAGIC</span>
<span class="p_add">+			dont_measure fsmagic=0x6e736673</span>
<span class="p_add">+			dont_appraise fsmagic=0x6e736673</span>
 
 			measure func=BPRM_CHECK
 			measure func=FILE_MMAP mask=MAY_EXEC
<span class="p_chunk">@@ -70,10 +86,6 @@</span> <span class="p_context"> Description:</span>
 		Examples of LSM specific definitions:
 
 		SELinux:
<span class="p_del">-			# SELINUX_MAGIC</span>
<span class="p_del">-			dont_measure fsmagic=0xf97cff8c</span>
<span class="p_del">-			dont_appraise fsmagic=0xf97cff8c</span>
<span class="p_del">-</span>
 			dont_measure obj_type=var_log_t
 			dont_appraise obj_type=var_log_t
 			dont_measure obj_type=auditd_log_t
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-ata b/Documentation/ABI/testing/sysfs-ata</span>
<span class="p_header">index 0a932155cbba..9231daef3813 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/sysfs-ata</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-ata</span>
<span class="p_chunk">@@ -90,6 +90,17 @@</span> <span class="p_context"> gscr</span>
 	130:	SATA_PMP_GSCR_SII_GPIO
 	Only valid if the device is a PM.
 
<span class="p_add">+trim</span>
<span class="p_add">+</span>
<span class="p_add">+	Shows the DSM TRIM mode currently used by the device. Valid</span>
<span class="p_add">+	values are:</span>
<span class="p_add">+	unsupported:		Drive does not support DSM TRIM</span>
<span class="p_add">+	unqueued:		Drive supports unqueued DSM TRIM only</span>
<span class="p_add">+	queued:			Drive supports queued DSM TRIM</span>
<span class="p_add">+	forced_unqueued:	Drive&#39;s unqueued DSM support is known to be</span>
<span class="p_add">+				buggy and only unqueued TRIM commands</span>
<span class="p_add">+				are sent</span>
<span class="p_add">+</span>
 spdn_cnt
 
 	Number of time libata decided to lower the speed of link due to errors.
<span class="p_header">diff --git a/Documentation/ABI/testing/sysfs-bus-iio b/Documentation/ABI/testing/sysfs-bus-iio</span>
<span class="p_header">index 3befcb19f414..1fbdd79d1624 100644</span>
<span class="p_header">--- a/Documentation/ABI/testing/sysfs-bus-iio</span>
<span class="p_header">+++ b/Documentation/ABI/testing/sysfs-bus-iio</span>
<span class="p_chunk">@@ -1165,10 +1165,8 @@</span> <span class="p_context"> Description:</span>
 		object is near the sensor, usually be observing
 		reflectivity of infrared or ultrasound emitted.
 		Often these sensors are unit less and as such conversion
<span class="p_del">-		to SI units is not possible.  Where it is, the units should</span>
<span class="p_del">-		be meters.  If such a conversion is not possible, the reported</span>
<span class="p_del">-		values should behave in the same way as a distance, i.e. lower</span>
<span class="p_del">-		values indicate something is closer to the sensor.</span>
<span class="p_add">+		to SI units is not possible. Higher proximity measurements</span>
<span class="p_add">+		indicate closer objects, and vice versa.</span>
 
 What:		/sys/.../iio:deviceX/in_illuminance_input
 What:		/sys/.../iio:deviceX/in_illuminance_raw
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">index adda2a8d1d52..e357b020861d 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-370-pinctrl.txt</span>
<span class="p_chunk">@@ -92,5 +92,5 @@</span> <span class="p_context"> mpp61         61       gpo, dev(wen1), uart1(txd), audio(rclk)</span>
 mpp62         62       gpio, dev(a2), uart1(cts), tdm(drx), pcie(clkreq0),
                        audio(mclk), uart0(cts)
 mpp63         63       gpo, spi0(sck), tclk
<span class="p_del">-mpp64         64       gpio, spi0(miso), spi0-1(cs1)</span>
<span class="p_del">-mpp65         65       gpio, spi0(mosi), spi0-1(cs2)</span>
<span class="p_add">+mpp64         64       gpio, spi0(miso), spi0(cs1)</span>
<span class="p_add">+mpp65         65       gpio, spi0(mosi), spi0(cs2)</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_header">index 7de0cda4a379..bedbe42c8c0a 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-375-pinctrl.txt</span>
<span class="p_chunk">@@ -22,8 +22,8 @@</span> <span class="p_context"> mpp5          5        gpio, dev(ad7), spi0(cs2), spi1(cs2)</span>
 mpp6          6        gpio, dev(ad0), led(p1), audio(rclk)
 mpp7          7        gpio, dev(ad1), ptp(clk), led(p2), audio(extclk)
 mpp8          8        gpio, dev (bootcs), spi0(cs0), spi1(cs0)
<span class="p_del">-mpp9          9        gpio, nf(wen), spi0(sck), spi1(sck)</span>
<span class="p_del">-mpp10        10        gpio, nf(ren), dram(vttctrl), led(c1)</span>
<span class="p_add">+mpp9          9        gpio, spi0(sck), spi1(sck), nand(we)</span>
<span class="p_add">+mpp10        10        gpio, dram(vttctrl), led(c1), nand(re)</span>
 mpp11        11        gpio, dev(a0), led(c2), audio(sdo)
 mpp12        12        gpio, dev(a1), audio(bclk)
 mpp13        13        gpio, dev(readyn), pcie0(rstoutn), pcie1(rstoutn)
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_header">index b17c96849fc9..4ac138aaaf87 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-38x-pinctrl.txt</span>
<span class="p_chunk">@@ -27,15 +27,15 @@</span> <span class="p_context"> mpp8          8        gpio, ge0(txd1), dev(ad10)</span>
 mpp9          9        gpio, ge0(txd2), dev(ad11)
 mpp10         10       gpio, ge0(txd3), dev(ad12)
 mpp11         11       gpio, ge0(txctl), dev(ad13)
<span class="p_del">-mpp12         12       gpio, ge0(rxd0), pcie0(rstout), pcie1(rstout) [1], spi0(cs1), dev(ad14)</span>
<span class="p_del">-mpp13         13       gpio, ge0(rxd1), pcie0(clkreq), pcie1(clkreq) [1], spi0(cs2), dev(ad15)</span>
<span class="p_del">-mpp14         14       gpio, ge0(rxd2), ptp(clk), m(vtt_ctrl), spi0(cs3), dev(wen1)</span>
<span class="p_del">-mpp15         15       gpio, ge0(rxd3), ge(mdc slave), pcie0(rstout), spi0(mosi), pcie1(rstout) [1]</span>
<span class="p_del">-mpp16         16       gpio, ge0(rxctl), ge(mdio slave), m(decc_err), spi0(miso), pcie0(clkreq)</span>
<span class="p_add">+mpp12         12       gpio, ge0(rxd0), pcie0(rstout), spi0(cs1), dev(ad14), pcie3(clkreq)</span>
<span class="p_add">+mpp13         13       gpio, ge0(rxd1), pcie0(clkreq), pcie1(clkreq) [1], spi0(cs2), dev(ad15), pcie2(clkreq)</span>
<span class="p_add">+mpp14         14       gpio, ge0(rxd2), ptp(clk), m(vtt_ctrl), spi0(cs3), dev(wen1), pcie3(clkreq)</span>
<span class="p_add">+mpp15         15       gpio, ge0(rxd3), ge(mdc slave), pcie0(rstout), spi0(mosi)</span>
<span class="p_add">+mpp16         16       gpio, ge0(rxctl), ge(mdio slave), m(decc_err), spi0(miso), pcie0(clkreq), pcie1(clkreq) [1]</span>
 mpp17         17       gpio, ge0(rxclk), ptp(clk), ua1(rxd), spi0(sck), sata1(prsnt)
<span class="p_del">-mpp18         18       gpio, ge0(rxerr), ptp(trig_gen), ua1(txd), spi0(cs0), pcie1(rstout) [1]</span>
<span class="p_del">-mpp19         19       gpio, ge0(col), ptp(event_req), pcie0(clkreq), sata1(prsnt), ua0(cts)</span>
<span class="p_del">-mpp20         20       gpio, ge0(txclk), ptp(clk), pcie1(rstout) [1], sata0(prsnt), ua0(rts)</span>
<span class="p_add">+mpp18         18       gpio, ge0(rxerr), ptp(trig_gen), ua1(txd), spi0(cs0)</span>
<span class="p_add">+mpp19         19       gpio, ge0(col), ptp(event_req), ge0(txerr), sata1(prsnt), ua0(cts)</span>
<span class="p_add">+mpp20         20       gpio, ge0(txclk), ptp(clk), sata0(prsnt), ua0(rts)</span>
 mpp21         21       gpio, spi0(cs1), ge1(rxd0), sata0(prsnt), sd0(cmd), dev(bootcs)
 mpp22         22       gpio, spi0(mosi), dev(ad0)
 mpp23         23       gpio, spi0(sck), dev(ad2)
<span class="p_chunk">@@ -58,23 +58,23 @@</span> <span class="p_context"> mpp39         39       gpio, i2c1(sck), ge1(rxd2), ua0(cts), sd0(d1), dev(a2)</span>
 mpp40         40       gpio, i2c1(sda), ge1(rxd3), ua0(rts), sd0(d2), dev(ad6)
 mpp41         41       gpio, ua1(rxd), ge1(rxctl), ua0(cts), spi1(cs3), dev(burst/last)
 mpp42         42       gpio, ua1(txd), ua0(rts), dev(ad7)
<span class="p_del">-mpp43         43       gpio, pcie0(clkreq), m(vtt_ctrl), m(decc_err), pcie0(rstout), dev(clkout)</span>
<span class="p_del">-mpp44         44       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [3], pcie0(rstout)</span>
<span class="p_del">-mpp45         45       gpio, ref(clk_out0), pcie0(rstout), pcie1(rstout) [1], pcie2(rstout), pcie3(rstout)</span>
<span class="p_del">-mpp46         46       gpio, ref(clk_out1), pcie0(rstout), pcie1(rstout) [1], pcie2(rstout), pcie3(rstout)</span>
<span class="p_del">-mpp47         47       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], spi1(cs2), sata3(prsnt) [2]</span>
<span class="p_del">-mpp48         48       gpio, sata0(prsnt), m(vtt_ctrl), tdm2c(pclk), audio(mclk), sd0(d4)</span>
<span class="p_del">-mpp49         49       gpio, sata2(prsnt) [2], sata3(prsnt) [2], tdm2c(fsync), audio(lrclk), sd0(d5)</span>
<span class="p_del">-mpp50         50       gpio, pcie0(rstout), pcie1(rstout) [1], tdm2c(drx), audio(extclk), sd0(cmd)</span>
<span class="p_add">+mpp43         43       gpio, pcie0(clkreq), m(vtt_ctrl), m(decc_err), spi1(cs2), dev(clkout)</span>
<span class="p_add">+mpp44         44       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [3]</span>
<span class="p_add">+mpp45         45       gpio, ref(clk_out0), pcie0(rstout)</span>
<span class="p_add">+mpp46         46       gpio, ref(clk_out1), pcie0(rstout)</span>
<span class="p_add">+mpp47         47       gpio, sata0(prsnt), sata1(prsnt), sata2(prsnt) [2], sata3(prsnt) [2]</span>
<span class="p_add">+mpp48         48       gpio, sata0(prsnt), m(vtt_ctrl), tdm2c(pclk), audio(mclk), sd0(d4), pcie0(clkreq)</span>
<span class="p_add">+mpp49         49       gpio, sata2(prsnt) [2], sata3(prsnt) [2], tdm2c(fsync), audio(lrclk), sd0(d5), pcie1(clkreq)</span>
<span class="p_add">+mpp50         50       gpio, pcie0(rstout), tdm2c(drx), audio(extclk), sd0(cmd)</span>
 mpp51         51       gpio, tdm2c(dtx), audio(sdo), m(decc_err)
<span class="p_del">-mpp52         52       gpio, pcie0(rstout), pcie1(rstout) [1], tdm2c(intn), audio(sdi), sd0(d6)</span>
<span class="p_add">+mpp52         52       gpio, pcie0(rstout), tdm2c(intn), audio(sdi), sd0(d6)</span>
 mpp53         53       gpio, sata1(prsnt), sata0(prsnt), tdm2c(rstn), audio(bclk), sd0(d7)
<span class="p_del">-mpp54         54       gpio, sata0(prsnt), sata1(prsnt), pcie0(rstout), pcie1(rstout) [1], sd0(d3)</span>
<span class="p_add">+mpp54         54       gpio, sata0(prsnt), sata1(prsnt), pcie0(rstout), ge0(txerr), sd0(d3)</span>
 mpp55         55       gpio, ua1(cts), ge(mdio), pcie1(clkreq) [1], spi1(cs1), sd0(d0)
 mpp56         56       gpio, ua1(rts), ge(mdc), m(decc_err), spi1(mosi)
 mpp57         57       gpio, spi1(sck), sd0(clk)
 mpp58         58       gpio, pcie1(clkreq) [1], i2c1(sck), pcie2(clkreq), spi1(miso), sd0(d1)
<span class="p_del">-mpp59         59       gpio, pcie0(rstout), i2c1(sda), pcie1(rstout) [1], spi1(cs0), sd0(d2)</span>
<span class="p_add">+mpp59         59       gpio, pcie0(rstout), i2c1(sda), spi1(cs0), sd0(d2)</span>
 
 [1]: only available on 88F6820 and 88F6828
 [2]: only available on 88F6828
<span class="p_header">diff --git a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">index 373dbccd7ab0..96e7744cab84 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/pinctrl/marvell,armada-xp-pinctrl.txt</span>
<span class="p_chunk">@@ -42,15 +42,15 @@</span> <span class="p_context"> mpp20         20       gpio, ge0(rxd4), ge1(rxd2), lcd(d20), ptp(clk)</span>
 mpp21         21       gpio, ge0(rxd5), ge1(rxd3), lcd(d21), mem(bat)
 mpp22         22       gpio, ge0(rxd6), ge1(rxctl), lcd(d22), sata0(prsnt)
 mpp23         23       gpio, ge0(rxd7), ge1(rxclk), lcd(d23), sata1(prsnt)
<span class="p_del">-mpp24         24       gpio, lcd(hsync), sata1(prsnt), nf(bootcs-re), tdm(rst)</span>
<span class="p_del">-mpp25         25       gpio, lcd(vsync), sata0(prsnt), nf(bootcs-we), tdm(pclk)</span>
<span class="p_del">-mpp26         26       gpio, lcd(clk), tdm(fsync), vdd(cpu1-pd)</span>
<span class="p_add">+mpp24         24       gpio, lcd(hsync), sata1(prsnt), tdm(rst)</span>
<span class="p_add">+mpp25         25       gpio, lcd(vsync), sata0(prsnt), tdm(pclk)</span>
<span class="p_add">+mpp26         26       gpio, lcd(clk), tdm(fsync)</span>
 mpp27         27       gpio, lcd(e), tdm(dtx), ptp(trig)
 mpp28         28       gpio, lcd(pwm), tdm(drx), ptp(evreq)
<span class="p_del">-mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk), vdd(cpu0-pd)</span>
<span class="p_add">+mpp29         29       gpio, lcd(ref-clk), tdm(int0), ptp(clk)</span>
 mpp30         30       gpio, tdm(int1), sd0(clk)
<span class="p_del">-mpp31         31       gpio, tdm(int2), sd0(cmd), vdd(cpu0-pd)</span>
<span class="p_del">-mpp32         32       gpio, tdm(int3), sd0(d0), vdd(cpu1-pd)</span>
<span class="p_add">+mpp31         31       gpio, tdm(int2), sd0(cmd)</span>
<span class="p_add">+mpp32         32       gpio, tdm(int3), sd0(d0)</span>
 mpp33         33       gpio, tdm(int4), sd0(d1), mem(bat)
 mpp34         34       gpio, tdm(int5), sd0(d2), sata0(prsnt)
 mpp35         35       gpio, tdm(int6), sd0(d3), sata1(prsnt)
<span class="p_chunk">@@ -58,21 +58,18 @@</span> <span class="p_context"> mpp36         36       gpio, spi(mosi)</span>
 mpp37         37       gpio, spi(miso)
 mpp38         38       gpio, spi(sck)
 mpp39         39       gpio, spi(cs0)
<span class="p_del">-mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), vdd(cpu1-pd),</span>
<span class="p_del">-                       pcie(clkreq0)</span>
<span class="p_add">+mpp40         40       gpio, spi(cs1), uart2(cts), lcd(vga-hsync), pcie(clkreq0)</span>
 mpp41         41       gpio, spi(cs2), uart2(rts), lcd(vga-vsync), sata1(prsnt),
                        pcie(clkreq1)
<span class="p_del">-mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer),</span>
<span class="p_del">-                       vdd(cpu0-pd)</span>
<span class="p_del">-mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout),</span>
<span class="p_del">-                       vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp42         42       gpio, uart2(rxd), uart0(cts), tdm(int7), tdm-1(timer)</span>
<span class="p_add">+mpp43         43       gpio, uart2(txd), uart0(rts), spi(cs3), pcie(rstout)</span>
 mpp44         44       gpio, uart2(cts), uart3(rxd), spi(cs4), pcie(clkreq2),
                        mem(bat)
 mpp45         45       gpio, uart2(rts), uart3(txd), spi(cs5), sata1(prsnt)
 mpp46         46       gpio, uart3(rts), uart1(rts), spi(cs6), sata0(prsnt)
 mpp47         47       gpio, uart3(cts), uart1(cts), spi(cs7), pcie(clkreq3),
                        ref(clkout)
<span class="p_del">-mpp48         48       gpio, tclk, dev(burst/last)</span>
<span class="p_add">+mpp48         48       gpio, dev(clkout), dev(burst/last)</span>
 
 * Marvell Armada XP (mv78260 and mv78460 only)
 
<span class="p_chunk">@@ -84,9 +81,9 @@</span> <span class="p_context"> mpp51         51       gpio, dev(ad16)</span>
 mpp52         52       gpio, dev(ad17)
 mpp53         53       gpio, dev(ad18)
 mpp54         54       gpio, dev(ad19)
<span class="p_del">-mpp55         55       gpio, dev(ad20), vdd(cpu0-pd)</span>
<span class="p_del">-mpp56         56       gpio, dev(ad21), vdd(cpu1-pd)</span>
<span class="p_del">-mpp57         57       gpio, dev(ad22), vdd(cpu2-3-pd){1}</span>
<span class="p_add">+mpp55         55       gpio, dev(ad20)</span>
<span class="p_add">+mpp56         56       gpio, dev(ad21)</span>
<span class="p_add">+mpp57         57       gpio, dev(ad22)</span>
 mpp58         58       gpio, dev(ad23)
 mpp59         59       gpio, dev(ad24)
 mpp60         60       gpio, dev(ad25)
<span class="p_chunk">@@ -96,6 +93,3 @@</span> <span class="p_context"> mpp63         63       gpio, dev(ad28)</span>
 mpp64         64       gpio, dev(ad29)
 mpp65         65       gpio, dev(ad30)
 mpp66         66       gpio, dev(ad31)
<span class="p_del">-</span>
<span class="p_del">-Notes:</span>
<span class="p_del">-* {1} vdd(cpu2-3-pd) only available on mv78460.</span>
<span class="p_header">diff --git a/Documentation/devicetree/bindings/usb/atmel-usb.txt b/Documentation/devicetree/bindings/usb/atmel-usb.txt</span>
<span class="p_header">index e180d56c75db..de773a00e2d4 100644</span>
<span class="p_header">--- a/Documentation/devicetree/bindings/usb/atmel-usb.txt</span>
<span class="p_header">+++ b/Documentation/devicetree/bindings/usb/atmel-usb.txt</span>
<span class="p_chunk">@@ -60,9 +60,9 @@</span> <span class="p_context"> Atmel High-Speed USB device controller</span>
 
 Required properties:
  - compatible: Should be one of the following
<span class="p_del">-	       &quot;at91sam9rl-udc&quot;</span>
<span class="p_del">-	       &quot;at91sam9g45-udc&quot;</span>
<span class="p_del">-	       &quot;sama5d3-udc&quot;</span>
<span class="p_add">+	       &quot;atmel,at91sam9rl-udc&quot;</span>
<span class="p_add">+	       &quot;atmel,at91sam9g45-udc&quot;</span>
<span class="p_add">+	       &quot;atmel,sama5d3-udc&quot;</span>
  - reg: Address and length of the register set for the device
  - interrupts: Should contain usba interrupt
  - ep childnode: To specify the number of endpoints and their properties.
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 6726139bd289..cd03a0faca8f 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -1398,7 +1398,15 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 			The list of supported hash algorithms is defined
 			in crypto/hash_info.h.
 
<span class="p_del">-	ima_tcb		[IMA]</span>
<span class="p_add">+	ima_policy=	[IMA]</span>
<span class="p_add">+			The builtin measurement policy to load during IMA</span>
<span class="p_add">+			setup.  Specyfing &quot;tcb&quot; as the value, measures all</span>
<span class="p_add">+			programs exec&#39;d, files mmap&#39;d for exec, and all files</span>
<span class="p_add">+			opened with the read mode bit set by either the</span>
<span class="p_add">+			effective uid (euid=0) or uid=0.</span>
<span class="p_add">+			Format: &quot;tcb&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+	ima_tcb		[IMA] Deprecated.  Use ima_policy= instead.</span>
 			Load a policy which meets the needs of the Trusted
 			Computing Base.  This means IMA will measure all
 			programs exec&#39;d, files mmap&#39;d for exec, and all files
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index e3cdec4898be..36f3225cdf1f 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 1
<span class="p_del">-SUBLEVEL = 3</span>
<span class="p_add">+SUBLEVEL = 4</span>
 EXTRAVERSION =
 NAME = Series 4800
 
<span class="p_header">diff --git a/arch/arm/boot/dts/at91-sama5d4ek.dts b/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_header">index 89ef4a540db5..45e7761b7a29 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91-sama5d4ek.dts</span>
<span class="p_chunk">@@ -108,8 +108,8 @@</span> <span class="p_context"></span>
 			mmc0: mmc@f8000000 {
 				pinctrl-names = &quot;default&quot;;
 				pinctrl-0 = &lt;&amp;pinctrl_mmc0_clk_cmd_dat0 &amp;pinctrl_mmc0_dat1_3 &amp;pinctrl_mmc0_cd&gt;;
<span class="p_del">-				slot@1 {</span>
<span class="p_del">-					reg = &lt;1&gt;;</span>
<span class="p_add">+				slot@0 {</span>
<span class="p_add">+					reg = &lt;0&gt;;</span>
 					bus-width = &lt;4&gt;;
 					cd-gpios = &lt;&amp;pioE 5 0&gt;;
 				};
<span class="p_header">diff --git a/arch/arm/boot/dts/at91sam9g45.dtsi b/arch/arm/boot/dts/at91sam9g45.dtsi</span>
<span class="p_header">index 70e59c5ceb2f..e54421176af8 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91sam9g45.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91sam9g45.dtsi</span>
<span class="p_chunk">@@ -1148,7 +1148,7 @@</span> <span class="p_context"></span>
 			usb2: gadget@fff78000 {
 				#address-cells = &lt;1&gt;;
 				#size-cells = &lt;0&gt;;
<span class="p_del">-				compatible = &quot;atmel,at91sam9rl-udc&quot;;</span>
<span class="p_add">+				compatible = &quot;atmel,at91sam9g45-udc&quot;;</span>
 				reg = &lt;0x00600000 0x80000
 				       0xfff78000 0x400&gt;;
 				interrupts = &lt;27 IRQ_TYPE_LEVEL_HIGH 0&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/at91sam9x5.dtsi b/arch/arm/boot/dts/at91sam9x5.dtsi</span>
<span class="p_header">index 3aa56ae3410a..3314a7303754 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/at91sam9x5.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/at91sam9x5.dtsi</span>
<span class="p_chunk">@@ -1062,7 +1062,7 @@</span> <span class="p_context"></span>
 			usb2: gadget@f803c000 {
 				#address-cells = &lt;1&gt;;
 				#size-cells = &lt;0&gt;;
<span class="p_del">-				compatible = &quot;atmel,at91sam9rl-udc&quot;;</span>
<span class="p_add">+				compatible = &quot;atmel,at91sam9g45-udc&quot;;</span>
 				reg = &lt;0x00500000 0x80000
 				       0xf803c000 0x400&gt;;
 				interrupts = &lt;23 IRQ_TYPE_LEVEL_HIGH 0&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/imx23.dtsi b/arch/arm/boot/dts/imx23.dtsi</span>
<span class="p_header">index bbcfb5a19c77..0cb8b0b11c3f 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/imx23.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/imx23.dtsi</span>
<span class="p_chunk">@@ -435,6 +435,7 @@</span> <span class="p_context"></span>
 				interrupts = &lt;36 37 38 39 40 41 42 43 44&gt;;
 				status = &quot;disabled&quot;;
 				clocks = &lt;&amp;clks 26&gt;;
<span class="p_add">+				#io-channel-cells = &lt;1&gt;;</span>
 			};
 
 			spdif@80054000 {
<span class="p_header">diff --git a/arch/arm/boot/dts/sama5d3.dtsi b/arch/arm/boot/dts/sama5d3.dtsi</span>
<span class="p_header">index 57ab8587f7b9..37e6182f1470 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sama5d3.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sama5d3.dtsi</span>
<span class="p_chunk">@@ -1321,7 +1321,7 @@</span> <span class="p_context"></span>
 		usb0: gadget@00500000 {
 			#address-cells = &lt;1&gt;;
 			#size-cells = &lt;0&gt;;
<span class="p_del">-			compatible = &quot;atmel,at91sam9rl-udc&quot;;</span>
<span class="p_add">+			compatible = &quot;atmel,sama5d3-udc&quot;;</span>
 			reg = &lt;0x00500000 0x100000
 			       0xf8030000 0x4000&gt;;
 			interrupts = &lt;33 IRQ_TYPE_LEVEL_HIGH 2&gt;;
<span class="p_header">diff --git a/arch/arm/boot/dts/sama5d4.dtsi b/arch/arm/boot/dts/sama5d4.dtsi</span>
<span class="p_header">index 6b1bb58f9c0b..a5f5f4090af6 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/sama5d4.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/sama5d4.dtsi</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"></span>
 		usb0: gadget@00400000 {
 			#address-cells = &lt;1&gt;;
 			#size-cells = &lt;0&gt;;
<span class="p_del">-			compatible = &quot;atmel,at91sam9rl-udc&quot;;</span>
<span class="p_add">+			compatible = &quot;atmel,sama5d3-udc&quot;;</span>
 			reg = &lt;0x00400000 0x100000
 			       0xfc02c000 0x4000&gt;;
 			interrupts = &lt;47 IRQ_TYPE_LEVEL_HIGH 2&gt;;
<span class="p_chunk">@@ -1125,10 +1125,10 @@</span> <span class="p_context"></span>
 				compatible = &quot;atmel,at91sam9g46-aes&quot;;
 				reg = &lt;0xfc044000 0x100&gt;;
 				interrupts = &lt;12 IRQ_TYPE_LEVEL_HIGH 0&gt;;
<span class="p_del">-				dmas = &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1))</span>
<span class="p_del">-					AT91_XDMAC_DT_PERID(41)&gt;,</span>
<span class="p_del">-				       &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1))</span>
<span class="p_del">-					AT91_XDMAC_DT_PERID(40)&gt;;</span>
<span class="p_add">+				dmas = &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1)</span>
<span class="p_add">+					| AT91_XDMAC_DT_PERID(41))&gt;,</span>
<span class="p_add">+				       &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1)</span>
<span class="p_add">+					| AT91_XDMAC_DT_PERID(40))&gt;;</span>
 				dma-names = &quot;tx&quot;, &quot;rx&quot;;
 				clocks = &lt;&amp;aes_clk&gt;;
 				clock-names = &quot;aes_clk&quot;;
<span class="p_chunk">@@ -1139,10 +1139,10 @@</span> <span class="p_context"></span>
 				compatible = &quot;atmel,at91sam9g46-tdes&quot;;
 				reg = &lt;0xfc04c000 0x100&gt;;
 				interrupts = &lt;14 IRQ_TYPE_LEVEL_HIGH 0&gt;;
<span class="p_del">-				dmas = &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1))</span>
<span class="p_del">-					AT91_XDMAC_DT_PERID(42)&gt;,</span>
<span class="p_del">-				       &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1))</span>
<span class="p_del">-					AT91_XDMAC_DT_PERID(43)&gt;;</span>
<span class="p_add">+				dmas = &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1)</span>
<span class="p_add">+					| AT91_XDMAC_DT_PERID(42))&gt;,</span>
<span class="p_add">+				       &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1)</span>
<span class="p_add">+					| AT91_XDMAC_DT_PERID(43))&gt;;</span>
 				dma-names = &quot;tx&quot;, &quot;rx&quot;;
 				clocks = &lt;&amp;tdes_clk&gt;;
 				clock-names = &quot;tdes_clk&quot;;
<span class="p_chunk">@@ -1153,8 +1153,8 @@</span> <span class="p_context"></span>
 				compatible = &quot;atmel,at91sam9g46-sha&quot;;
 				reg = &lt;0xfc050000 0x100&gt;;
 				interrupts = &lt;15 IRQ_TYPE_LEVEL_HIGH 0&gt;;
<span class="p_del">-				dmas = &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1))</span>
<span class="p_del">-					AT91_XDMAC_DT_PERID(44)&gt;;</span>
<span class="p_add">+				dmas = &lt;&amp;dma0 (AT91_XDMAC_DT_MEM_IF(0) | AT91_XDMAC_DT_PER_IF(1)</span>
<span class="p_add">+					| AT91_XDMAC_DT_PERID(44))&gt;;</span>
 				dma-names = &quot;tx&quot;;
 				clocks = &lt;&amp;sha_clk&gt;;
 				clock-names = &quot;sha_clk&quot;;
<span class="p_header">diff --git a/arch/arm/kernel/smp.c b/arch/arm/kernel/smp.c</span>
<span class="p_header">index cca5b8758185..f11d82527076 100644</span>
<span class="p_header">--- a/arch/arm/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm/kernel/smp.c</span>
<span class="p_chunk">@@ -576,7 +576,7 @@</span> <span class="p_context"> void handle_IPI(int ipinr, struct pt_regs *regs)</span>
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	if ((unsigned)ipinr &lt; NR_IPI) {
<span class="p_del">-		trace_ipi_entry(ipi_types[ipinr]);</span>
<span class="p_add">+		trace_ipi_entry_rcuidle(ipi_types[ipinr]);</span>
 		__inc_irq_stat(cpu, ipi_irqs[ipinr]);
 	}
 
<span class="p_chunk">@@ -635,7 +635,7 @@</span> <span class="p_context"> void handle_IPI(int ipinr, struct pt_regs *regs)</span>
 	}
 
 	if ((unsigned)ipinr &lt; NR_IPI)
<span class="p_del">-		trace_ipi_exit(ipi_types[ipinr]);</span>
<span class="p_add">+		trace_ipi_exit_rcuidle(ipi_types[ipinr]);</span>
 	set_irq_regs(old_regs);
 }
 
<span class="p_header">diff --git a/arch/arm/mach-dove/include/mach/irqs.h b/arch/arm/mach-dove/include/mach/irqs.h</span>
<span class="p_header">index 03d401d20453..3f29e6bca058 100644</span>
<span class="p_header">--- a/arch/arm/mach-dove/include/mach/irqs.h</span>
<span class="p_header">+++ b/arch/arm/mach-dove/include/mach/irqs.h</span>
<span class="p_chunk">@@ -14,73 +14,73 @@</span> <span class="p_context"></span>
 /*
  * Dove Low Interrupt Controller
  */
<span class="p_del">-#define IRQ_DOVE_BRIDGE		0</span>
<span class="p_del">-#define IRQ_DOVE_H2C		1</span>
<span class="p_del">-#define IRQ_DOVE_C2H		2</span>
<span class="p_del">-#define IRQ_DOVE_NAND		3</span>
<span class="p_del">-#define IRQ_DOVE_PDMA		4</span>
<span class="p_del">-#define IRQ_DOVE_SPI1		5</span>
<span class="p_del">-#define IRQ_DOVE_SPI0		6</span>
<span class="p_del">-#define IRQ_DOVE_UART_0		7</span>
<span class="p_del">-#define IRQ_DOVE_UART_1		8</span>
<span class="p_del">-#define IRQ_DOVE_UART_2		9</span>
<span class="p_del">-#define IRQ_DOVE_UART_3		10</span>
<span class="p_del">-#define IRQ_DOVE_I2C		11</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_0_7	12</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_8_15	13</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_16_23	14</span>
<span class="p_del">-#define IRQ_DOVE_PCIE0_ERR	15</span>
<span class="p_del">-#define IRQ_DOVE_PCIE0		16</span>
<span class="p_del">-#define IRQ_DOVE_PCIE1_ERR	17</span>
<span class="p_del">-#define IRQ_DOVE_PCIE1		18</span>
<span class="p_del">-#define IRQ_DOVE_I2S0		19</span>
<span class="p_del">-#define IRQ_DOVE_I2S0_ERR	20</span>
<span class="p_del">-#define IRQ_DOVE_I2S1		21</span>
<span class="p_del">-#define IRQ_DOVE_I2S1_ERR	22</span>
<span class="p_del">-#define IRQ_DOVE_USB_ERR	23</span>
<span class="p_del">-#define IRQ_DOVE_USB0		24</span>
<span class="p_del">-#define IRQ_DOVE_USB1		25</span>
<span class="p_del">-#define IRQ_DOVE_GE00_RX	26</span>
<span class="p_del">-#define IRQ_DOVE_GE00_TX	27</span>
<span class="p_del">-#define IRQ_DOVE_GE00_MISC	28</span>
<span class="p_del">-#define IRQ_DOVE_GE00_SUM	29</span>
<span class="p_del">-#define IRQ_DOVE_GE00_ERR	30</span>
<span class="p_del">-#define IRQ_DOVE_CRYPTO		31</span>
<span class="p_add">+#define IRQ_DOVE_BRIDGE		(1 + 0)</span>
<span class="p_add">+#define IRQ_DOVE_H2C		(1 + 1)</span>
<span class="p_add">+#define IRQ_DOVE_C2H		(1 + 2)</span>
<span class="p_add">+#define IRQ_DOVE_NAND		(1 + 3)</span>
<span class="p_add">+#define IRQ_DOVE_PDMA		(1 + 4)</span>
<span class="p_add">+#define IRQ_DOVE_SPI1		(1 + 5)</span>
<span class="p_add">+#define IRQ_DOVE_SPI0		(1 + 6)</span>
<span class="p_add">+#define IRQ_DOVE_UART_0		(1 + 7)</span>
<span class="p_add">+#define IRQ_DOVE_UART_1		(1 + 8)</span>
<span class="p_add">+#define IRQ_DOVE_UART_2		(1 + 9)</span>
<span class="p_add">+#define IRQ_DOVE_UART_3		(1 + 10)</span>
<span class="p_add">+#define IRQ_DOVE_I2C		(1 + 11)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_0_7	(1 + 12)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_8_15	(1 + 13)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_16_23	(1 + 14)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE0_ERR	(1 + 15)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE0		(1 + 16)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE1_ERR	(1 + 17)</span>
<span class="p_add">+#define IRQ_DOVE_PCIE1		(1 + 18)</span>
<span class="p_add">+#define IRQ_DOVE_I2S0		(1 + 19)</span>
<span class="p_add">+#define IRQ_DOVE_I2S0_ERR	(1 + 20)</span>
<span class="p_add">+#define IRQ_DOVE_I2S1		(1 + 21)</span>
<span class="p_add">+#define IRQ_DOVE_I2S1_ERR	(1 + 22)</span>
<span class="p_add">+#define IRQ_DOVE_USB_ERR	(1 + 23)</span>
<span class="p_add">+#define IRQ_DOVE_USB0		(1 + 24)</span>
<span class="p_add">+#define IRQ_DOVE_USB1		(1 + 25)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_RX	(1 + 26)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_TX	(1 + 27)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_MISC	(1 + 28)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_SUM	(1 + 29)</span>
<span class="p_add">+#define IRQ_DOVE_GE00_ERR	(1 + 30)</span>
<span class="p_add">+#define IRQ_DOVE_CRYPTO		(1 + 31)</span>
 
 /*
  * Dove High Interrupt Controller
  */
<span class="p_del">-#define IRQ_DOVE_AC97		32</span>
<span class="p_del">-#define IRQ_DOVE_PMU		33</span>
<span class="p_del">-#define IRQ_DOVE_CAM		34</span>
<span class="p_del">-#define IRQ_DOVE_SDIO0		35</span>
<span class="p_del">-#define IRQ_DOVE_SDIO1		36</span>
<span class="p_del">-#define IRQ_DOVE_SDIO0_WAKEUP	37</span>
<span class="p_del">-#define IRQ_DOVE_SDIO1_WAKEUP	38</span>
<span class="p_del">-#define IRQ_DOVE_XOR_00		39</span>
<span class="p_del">-#define IRQ_DOVE_XOR_01		40</span>
<span class="p_del">-#define IRQ_DOVE_XOR0_ERR	41</span>
<span class="p_del">-#define IRQ_DOVE_XOR_10		42</span>
<span class="p_del">-#define IRQ_DOVE_XOR_11		43</span>
<span class="p_del">-#define IRQ_DOVE_XOR1_ERR	44</span>
<span class="p_del">-#define IRQ_DOVE_LCD_DCON	45</span>
<span class="p_del">-#define IRQ_DOVE_LCD1		46</span>
<span class="p_del">-#define IRQ_DOVE_LCD0		47</span>
<span class="p_del">-#define IRQ_DOVE_GPU		48</span>
<span class="p_del">-#define IRQ_DOVE_PERFORM_MNTR	49</span>
<span class="p_del">-#define IRQ_DOVE_VPRO_DMA1	51</span>
<span class="p_del">-#define IRQ_DOVE_SSP_TIMER	54</span>
<span class="p_del">-#define IRQ_DOVE_SSP		55</span>
<span class="p_del">-#define IRQ_DOVE_MC_L2_ERR	56</span>
<span class="p_del">-#define IRQ_DOVE_CRYPTO_ERR	59</span>
<span class="p_del">-#define IRQ_DOVE_GPIO_24_31	60</span>
<span class="p_del">-#define IRQ_DOVE_HIGH_GPIO	61</span>
<span class="p_del">-#define IRQ_DOVE_SATA		62</span>
<span class="p_add">+#define IRQ_DOVE_AC97		(1 + 32)</span>
<span class="p_add">+#define IRQ_DOVE_PMU		(1 + 33)</span>
<span class="p_add">+#define IRQ_DOVE_CAM		(1 + 34)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO0		(1 + 35)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO1		(1 + 36)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO0_WAKEUP	(1 + 37)</span>
<span class="p_add">+#define IRQ_DOVE_SDIO1_WAKEUP	(1 + 38)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_00		(1 + 39)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_01		(1 + 40)</span>
<span class="p_add">+#define IRQ_DOVE_XOR0_ERR	(1 + 41)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_10		(1 + 42)</span>
<span class="p_add">+#define IRQ_DOVE_XOR_11		(1 + 43)</span>
<span class="p_add">+#define IRQ_DOVE_XOR1_ERR	(1 + 44)</span>
<span class="p_add">+#define IRQ_DOVE_LCD_DCON	(1 + 45)</span>
<span class="p_add">+#define IRQ_DOVE_LCD1		(1 + 46)</span>
<span class="p_add">+#define IRQ_DOVE_LCD0		(1 + 47)</span>
<span class="p_add">+#define IRQ_DOVE_GPU		(1 + 48)</span>
<span class="p_add">+#define IRQ_DOVE_PERFORM_MNTR	(1 + 49)</span>
<span class="p_add">+#define IRQ_DOVE_VPRO_DMA1	(1 + 51)</span>
<span class="p_add">+#define IRQ_DOVE_SSP_TIMER	(1 + 54)</span>
<span class="p_add">+#define IRQ_DOVE_SSP		(1 + 55)</span>
<span class="p_add">+#define IRQ_DOVE_MC_L2_ERR	(1 + 56)</span>
<span class="p_add">+#define IRQ_DOVE_CRYPTO_ERR	(1 + 59)</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_24_31	(1 + 60)</span>
<span class="p_add">+#define IRQ_DOVE_HIGH_GPIO	(1 + 61)</span>
<span class="p_add">+#define IRQ_DOVE_SATA		(1 + 62)</span>
 
 /*
  * DOVE General Purpose Pins
  */
<span class="p_del">-#define IRQ_DOVE_GPIO_START	64</span>
<span class="p_add">+#define IRQ_DOVE_GPIO_START	65</span>
 #define NR_GPIO_IRQS		64
 
 /*
<span class="p_header">diff --git a/arch/arm/mach-dove/irq.c b/arch/arm/mach-dove/irq.c</span>
<span class="p_header">index 4a5a7aedcb76..df0223f76fa9 100644</span>
<span class="p_header">--- a/arch/arm/mach-dove/irq.c</span>
<span class="p_header">+++ b/arch/arm/mach-dove/irq.c</span>
<span class="p_chunk">@@ -126,14 +126,14 @@</span> <span class="p_context"> __exception_irq_entry dove_legacy_handle_irq(struct pt_regs *regs)</span>
 	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_LOW_OFF);
 	stat &amp;= readl_relaxed(dove_irq_base + IRQ_MASK_LOW_OFF);
 	if (stat) {
<span class="p_del">-		unsigned int hwirq = __fls(stat);</span>
<span class="p_add">+		unsigned int hwirq = 1 + __fls(stat);</span>
 		handle_IRQ(hwirq, regs);
 		return;
 	}
 	stat = readl_relaxed(dove_irq_base + IRQ_CAUSE_HIGH_OFF);
 	stat &amp;= readl_relaxed(dove_irq_base + IRQ_MASK_HIGH_OFF);
 	if (stat) {
<span class="p_del">-		unsigned int hwirq = 32 + __fls(stat);</span>
<span class="p_add">+		unsigned int hwirq = 33 + __fls(stat);</span>
 		handle_IRQ(hwirq, regs);
 		return;
 	}
<span class="p_chunk">@@ -144,8 +144,8 @@</span> <span class="p_context"> void __init dove_init_irq(void)</span>
 {
 	int i;
 
<span class="p_del">-	orion_irq_init(0, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);</span>
<span class="p_del">-	orion_irq_init(32, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);</span>
<span class="p_add">+	orion_irq_init(1, IRQ_VIRT_BASE + IRQ_MASK_LOW_OFF);</span>
<span class="p_add">+	orion_irq_init(33, IRQ_VIRT_BASE + IRQ_MASK_HIGH_OFF);</span>
 
 #ifdef CONFIG_MULTI_IRQ_HANDLER
 	set_handle_irq(dove_legacy_handle_irq);
<span class="p_header">diff --git a/arch/arm/vdso/vdsomunge.c b/arch/arm/vdso/vdsomunge.c</span>
<span class="p_header">index 9005b07296c8..aedec81d1198 100644</span>
<span class="p_header">--- a/arch/arm/vdso/vdsomunge.c</span>
<span class="p_header">+++ b/arch/arm/vdso/vdsomunge.c</span>
<span class="p_chunk">@@ -45,13 +45,11 @@</span> <span class="p_context"></span>
  * it does.
  */
 
<span class="p_del">-#define _GNU_SOURCE</span>
<span class="p_del">-</span>
 #include &lt;byteswap.h&gt;
 #include &lt;elf.h&gt;
 #include &lt;errno.h&gt;
<span class="p_del">-#include &lt;error.h&gt;</span>
 #include &lt;fcntl.h&gt;
<span class="p_add">+#include &lt;stdarg.h&gt;</span>
 #include &lt;stdbool.h&gt;
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
<span class="p_chunk">@@ -82,11 +80,25 @@</span> <span class="p_context"></span>
 #define EF_ARM_ABI_FLOAT_HARD 0x400
 #endif
 
<span class="p_add">+static int failed;</span>
<span class="p_add">+static const char *argv0;</span>
 static const char *outfile;
 
<span class="p_add">+static void fail(const char *fmt, ...)</span>
<span class="p_add">+{</span>
<span class="p_add">+	va_list ap;</span>
<span class="p_add">+</span>
<span class="p_add">+	failed = 1;</span>
<span class="p_add">+	fprintf(stderr, &quot;%s: &quot;, argv0);</span>
<span class="p_add">+	va_start(ap, fmt);</span>
<span class="p_add">+	vfprintf(stderr, fmt, ap);</span>
<span class="p_add">+	va_end(ap);</span>
<span class="p_add">+	exit(EXIT_FAILURE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void cleanup(void)
 {
<span class="p_del">-	if (error_message_count &gt; 0 &amp;&amp; outfile != NULL)</span>
<span class="p_add">+	if (failed &amp;&amp; outfile != NULL)</span>
 		unlink(outfile);
 }
 
<span class="p_chunk">@@ -119,68 +131,66 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 	int infd;
 
 	atexit(cleanup);
<span class="p_add">+	argv0 = argv[0];</span>
 
 	if (argc != 3)
<span class="p_del">-		error(EXIT_FAILURE, 0, &quot;Usage: %s [infile] [outfile]&quot;, argv[0]);</span>
<span class="p_add">+		fail(&quot;Usage: %s [infile] [outfile]\n&quot;, argv[0]);</span>
 
 	infile = argv[1];
 	outfile = argv[2];
 
 	infd = open(infile, O_RDONLY);
 	if (infd &lt; 0)
<span class="p_del">-		error(EXIT_FAILURE, errno, &quot;Cannot open %s&quot;, infile);</span>
<span class="p_add">+		fail(&quot;Cannot open %s: %s\n&quot;, infile, strerror(errno));</span>
 
 	if (fstat(infd, &amp;stat) != 0)
<span class="p_del">-		error(EXIT_FAILURE, errno, &quot;Failed stat for %s&quot;, infile);</span>
<span class="p_add">+		fail(&quot;Failed stat for %s: %s\n&quot;, infile, strerror(errno));</span>
 
 	inbuf = mmap(NULL, stat.st_size, PROT_READ, MAP_PRIVATE, infd, 0);
 	if (inbuf == MAP_FAILED)
<span class="p_del">-		error(EXIT_FAILURE, errno, &quot;Failed to map %s&quot;, infile);</span>
<span class="p_add">+		fail(&quot;Failed to map %s: %s\n&quot;, infile, strerror(errno));</span>
 
 	close(infd);
 
 	inhdr = inbuf;
 
 	if (memcmp(&amp;inhdr-&gt;e_ident, ELFMAG, SELFMAG) != 0)
<span class="p_del">-		error(EXIT_FAILURE, 0, &quot;Not an ELF file&quot;);</span>
<span class="p_add">+		fail(&quot;Not an ELF file\n&quot;);</span>
 
 	if (inhdr-&gt;e_ident[EI_CLASS] != ELFCLASS32)
<span class="p_del">-		error(EXIT_FAILURE, 0, &quot;Unsupported ELF class&quot;);</span>
<span class="p_add">+		fail(&quot;Unsupported ELF class\n&quot;);</span>
 
 	swap = inhdr-&gt;e_ident[EI_DATA] != HOST_ORDER;
 
 	if (read_elf_half(inhdr-&gt;e_type, swap) != ET_DYN)
<span class="p_del">-		error(EXIT_FAILURE, 0, &quot;Not a shared object&quot;);</span>
<span class="p_add">+		fail(&quot;Not a shared object\n&quot;);</span>
 
<span class="p_del">-	if (read_elf_half(inhdr-&gt;e_machine, swap) != EM_ARM) {</span>
<span class="p_del">-		error(EXIT_FAILURE, 0, &quot;Unsupported architecture %#x&quot;,</span>
<span class="p_del">-		      inhdr-&gt;e_machine);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (read_elf_half(inhdr-&gt;e_machine, swap) != EM_ARM)</span>
<span class="p_add">+		fail(&quot;Unsupported architecture %#x\n&quot;, inhdr-&gt;e_machine);</span>
 
 	e_flags = read_elf_word(inhdr-&gt;e_flags, swap);
 
 	if (EF_ARM_EABI_VERSION(e_flags) != EF_ARM_EABI_VER5) {
<span class="p_del">-		error(EXIT_FAILURE, 0, &quot;Unsupported EABI version %#x&quot;,</span>
<span class="p_del">-		      EF_ARM_EABI_VERSION(e_flags));</span>
<span class="p_add">+		fail(&quot;Unsupported EABI version %#x\n&quot;,</span>
<span class="p_add">+		     EF_ARM_EABI_VERSION(e_flags));</span>
 	}
 
 	if (e_flags &amp; EF_ARM_ABI_FLOAT_HARD)
<span class="p_del">-		error(EXIT_FAILURE, 0,</span>
<span class="p_del">-		      &quot;Unexpected hard-float flag set in e_flags&quot;);</span>
<span class="p_add">+		fail(&quot;Unexpected hard-float flag set in e_flags\n&quot;);</span>
 
 	clear_soft_float = !!(e_flags &amp; EF_ARM_ABI_FLOAT_SOFT);
 
 	outfd = open(outfile, O_RDWR | O_CREAT | O_TRUNC, S_IRUSR | S_IWUSR);
 	if (outfd &lt; 0)
<span class="p_del">-		error(EXIT_FAILURE, errno, &quot;Cannot open %s&quot;, outfile);</span>
<span class="p_add">+		fail(&quot;Cannot open %s: %s\n&quot;, outfile, strerror(errno));</span>
 
 	if (ftruncate(outfd, stat.st_size) != 0)
<span class="p_del">-		error(EXIT_FAILURE, errno, &quot;Cannot truncate %s&quot;, outfile);</span>
<span class="p_add">+		fail(&quot;Cannot truncate %s: %s\n&quot;, outfile, strerror(errno));</span>
 
 	outbuf = mmap(NULL, stat.st_size, PROT_READ | PROT_WRITE, MAP_SHARED,
 		      outfd, 0);
 	if (outbuf == MAP_FAILED)
<span class="p_del">-		error(EXIT_FAILURE, errno, &quot;Failed to map %s&quot;, outfile);</span>
<span class="p_add">+		fail(&quot;Failed to map %s: %s\n&quot;, outfile, strerror(errno));</span>
 
 	close(outfd);
 
<span class="p_chunk">@@ -195,7 +205,7 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 	}
 
 	if (msync(outbuf, stat.st_size, MS_SYNC) != 0)
<span class="p_del">-		error(EXIT_FAILURE, errno, &quot;Failed to sync %s&quot;, outfile);</span>
<span class="p_add">+		fail(&quot;Failed to sync %s: %s\n&quot;, outfile, strerror(errno));</span>
 
 	return EXIT_SUCCESS;
 }
<span class="p_header">diff --git a/arch/arm64/kernel/smp.c b/arch/arm64/kernel/smp.c</span>
<span class="p_header">index 2cb008177252..d3a202b85ba6 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/smp.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/smp.c</span>
<span class="p_chunk">@@ -569,7 +569,7 @@</span> <span class="p_context"> void handle_IPI(int ipinr, struct pt_regs *regs)</span>
 	struct pt_regs *old_regs = set_irq_regs(regs);
 
 	if ((unsigned)ipinr &lt; NR_IPI) {
<span class="p_del">-		trace_ipi_entry(ipi_types[ipinr]);</span>
<span class="p_add">+		trace_ipi_entry_rcuidle(ipi_types[ipinr]);</span>
 		__inc_irq_stat(cpu, ipi_irqs[ipinr]);
 	}
 
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> void handle_IPI(int ipinr, struct pt_regs *regs)</span>
 	}
 
 	if ((unsigned)ipinr &lt; NR_IPI)
<span class="p_del">-		trace_ipi_exit(ipi_types[ipinr]);</span>
<span class="p_add">+		trace_ipi_exit_rcuidle(ipi_types[ipinr]);</span>
 	set_irq_regs(old_regs);
 }
 
<span class="p_header">diff --git a/arch/arm64/mm/hugetlbpage.c b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">index 2de9d2e59d96..0eeb4f0930a0 100644</span>
<span class="p_header">--- a/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/arm64/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -40,13 +40,13 @@</span> <span class="p_context"> int huge_pmd_unshare(struct mm_struct *mm, unsigned long *addr, pte_t *ptep)</span>
 
 int pmd_huge(pmd_t pmd)
 {
<span class="p_del">-	return !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
<span class="p_add">+	return pmd_val(pmd) &amp;&amp; !(pmd_val(pmd) &amp; PMD_TABLE_BIT);</span>
 }
 
 int pud_huge(pud_t pud)
 {
 #ifndef __PAGETABLE_PMD_FOLDED
<span class="p_del">-	return !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
<span class="p_add">+	return pud_val(pud) &amp;&amp; !(pud_val(pud) &amp; PUD_TABLE_BIT);</span>
 #else
 	return 0;
 #endif
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit.h b/arch/arm64/net/bpf_jit.h</span>
<span class="p_header">index de0a81a539a0..98a26ce82d26 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit.h</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit.h</span>
<span class="p_chunk">@@ -110,6 +110,10 @@</span> <span class="p_context"></span>
 /* Rd = Rn &gt;&gt; shift; signed */
 #define A64_ASR(sf, Rd, Rn, shift) A64_SBFM(sf, Rd, Rn, shift, (sf) ? 63 : 31)
 
<span class="p_add">+/* Zero extend */</span>
<span class="p_add">+#define A64_UXTH(sf, Rd, Rn) A64_UBFM(sf, Rd, Rn, 0, 15)</span>
<span class="p_add">+#define A64_UXTW(sf, Rd, Rn) A64_UBFM(sf, Rd, Rn, 0, 31)</span>
<span class="p_add">+</span>
 /* Move wide (immediate) */
 #define A64_MOVEW(sf, Rd, imm16, shift, type) \
 	aarch64_insn_gen_movewide(Rd, imm16, shift, \
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit_comp.c b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">index dc6a4842683a..c047598b09e0 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -113,9 +113,9 @@</span> <span class="p_context"> static inline void emit_a64_mov_i(const int is64, const int reg,</span>
 static inline int bpf2a64_offset(int bpf_to, int bpf_from,
 				 const struct jit_ctx *ctx)
 {
<span class="p_del">-	int to = ctx-&gt;offset[bpf_to + 1];</span>
<span class="p_add">+	int to = ctx-&gt;offset[bpf_to];</span>
 	/* -1 to account for the Branch instruction */
<span class="p_del">-	int from = ctx-&gt;offset[bpf_from + 1] - 1;</span>
<span class="p_add">+	int from = ctx-&gt;offset[bpf_from] - 1;</span>
 
 	return to - from;
 }
<span class="p_chunk">@@ -289,23 +289,41 @@</span> <span class="p_context"> static int build_insn(const struct bpf_insn *insn, struct jit_ctx *ctx)</span>
 	case BPF_ALU | BPF_END | BPF_FROM_BE:
 #ifdef CONFIG_CPU_BIG_ENDIAN
 		if (BPF_SRC(code) == BPF_FROM_BE)
<span class="p_del">-			break;</span>
<span class="p_add">+			goto emit_bswap_uxt;</span>
 #else /* !CONFIG_CPU_BIG_ENDIAN */
 		if (BPF_SRC(code) == BPF_FROM_LE)
<span class="p_del">-			break;</span>
<span class="p_add">+			goto emit_bswap_uxt;</span>
 #endif
 		switch (imm) {
 		case 16:
 			emit(A64_REV16(is64, dst, dst), ctx);
<span class="p_add">+			/* zero-extend 16 bits into 64 bits */</span>
<span class="p_add">+			emit(A64_UXTH(is64, dst, dst), ctx);</span>
 			break;
 		case 32:
 			emit(A64_REV32(is64, dst, dst), ctx);
<span class="p_add">+			/* upper 32 bits already cleared */</span>
 			break;
 		case 64:
 			emit(A64_REV64(dst, dst), ctx);
 			break;
 		}
 		break;
<span class="p_add">+emit_bswap_uxt:</span>
<span class="p_add">+		switch (imm) {</span>
<span class="p_add">+		case 16:</span>
<span class="p_add">+			/* zero-extend 16 bits into 64 bits */</span>
<span class="p_add">+			emit(A64_UXTH(is64, dst, dst), ctx);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 32:</span>
<span class="p_add">+			/* zero-extend 32 bits into 64 bits */</span>
<span class="p_add">+			emit(A64_UXTW(is64, dst, dst), ctx);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case 64:</span>
<span class="p_add">+			/* nop */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
 	/* dst = imm */
 	case BPF_ALU | BPF_MOV | BPF_K:
 	case BPF_ALU64 | BPF_MOV | BPF_K:
<span class="p_chunk">@@ -640,10 +658,11 @@</span> <span class="p_context"> static int build_body(struct jit_ctx *ctx)</span>
 		const struct bpf_insn *insn = &amp;prog-&gt;insnsi[i];
 		int ret;
 
<span class="p_add">+		ret = build_insn(insn, ctx);</span>
<span class="p_add">+</span>
 		if (ctx-&gt;image == NULL)
 			ctx-&gt;offset[i] = ctx-&gt;idx;
 
<span class="p_del">-		ret = build_insn(insn, ctx);</span>
 		if (ret &gt; 0) {
 			i++;
 			continue;
<span class="p_header">diff --git a/arch/m68k/Kconfig.cpu b/arch/m68k/Kconfig.cpu</span>
<span class="p_header">index 33013dfcd3e1..5c68c85d5dbe 100644</span>
<span class="p_header">--- a/arch/m68k/Kconfig.cpu</span>
<span class="p_header">+++ b/arch/m68k/Kconfig.cpu</span>
<span class="p_chunk">@@ -125,6 +125,13 @@</span> <span class="p_context"> endif # M68KCLASSIC</span>
 
 if COLDFIRE
 
<span class="p_add">+choice</span>
<span class="p_add">+	prompt &quot;ColdFire SoC type&quot;</span>
<span class="p_add">+	default M520x</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Select the type of ColdFire System-on-Chip (SoC) that you want</span>
<span class="p_add">+	  to build for.</span>
<span class="p_add">+</span>
 config M5206
 	bool &quot;MCF5206&quot;
 	depends on !MMU
<span class="p_chunk">@@ -174,9 +181,6 @@</span> <span class="p_context"> config M525x</span>
 	help
 	  Freescale (Motorola) Coldfire 5251/5253 processor support.
 
<span class="p_del">-config M527x</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
 config M5271
 	bool &quot;MCF5271&quot;
 	depends on !MMU
<span class="p_chunk">@@ -223,9 +227,6 @@</span> <span class="p_context"> config M5307</span>
 	help
 	  Motorola ColdFire 5307 processor support.
 
<span class="p_del">-config M53xx</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
 config M532x
 	bool &quot;MCF532x&quot;
 	depends on !MMU
<span class="p_chunk">@@ -251,9 +252,6 @@</span> <span class="p_context"> config M5407</span>
 	help
 	  Motorola ColdFire 5407 processor support.
 
<span class="p_del">-config M54xx</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
 config M547x
 	bool &quot;MCF547x&quot;
 	select M54xx
<span class="p_chunk">@@ -280,6 +278,17 @@</span> <span class="p_context"> config M5441x</span>
 	help
 	  Freescale Coldfire 54410/54415/54416/54417/54418 processor support.
 
<span class="p_add">+endchoice</span>
<span class="p_add">+</span>
<span class="p_add">+config M527x</span>
<span class="p_add">+	bool</span>
<span class="p_add">+</span>
<span class="p_add">+config M53xx</span>
<span class="p_add">+	bool</span>
<span class="p_add">+</span>
<span class="p_add">+config M54xx</span>
<span class="p_add">+	bool</span>
<span class="p_add">+</span>
 endif # COLDFIRE
 
 
<span class="p_chunk">@@ -416,22 +425,10 @@</span> <span class="p_context"> config HAVE_MBAR</span>
 config HAVE_IPSBAR
 	bool
 
<span class="p_del">-config CLOCK_SET</span>
<span class="p_del">-	bool &quot;Enable setting the CPU clock frequency&quot;</span>
<span class="p_del">-	depends on COLDFIRE</span>
<span class="p_del">-	default n</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  On some CPU&#39;s you do not need to know what the core CPU clock</span>
<span class="p_del">-	  frequency is. On these you can disable clock setting. On some</span>
<span class="p_del">-	  traditional 68K parts, and on all ColdFire parts you need to set</span>
<span class="p_del">-	  the appropriate CPU clock frequency. On these devices many of the</span>
<span class="p_del">-	  onboard peripherals derive their timing from the master CPU clock</span>
<span class="p_del">-	  frequency.</span>
<span class="p_del">-</span>
 config CLOCK_FREQ
 	int &quot;Set the core clock frequency&quot;
 	default &quot;66666666&quot;
<span class="p_del">-	depends on CLOCK_SET</span>
<span class="p_add">+	depends on COLDFIRE</span>
 	help
 	  Define the CPU clock frequency in use. This is the core clock
 	  frequency, it may or may not be the same as the external clock
<span class="p_header">diff --git a/arch/m68k/include/asm/coldfire.h b/arch/m68k/include/asm/coldfire.h</span>
<span class="p_header">index c94557b91448..50aa4dac9ca2 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/coldfire.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/coldfire.h</span>
<span class="p_chunk">@@ -19,7 +19,7 @@</span> <span class="p_context"></span>
  *	in any case new boards come along from time to time that have yet
  *	another different clocking frequency.
  */
<span class="p_del">-#ifdef CONFIG_CLOCK_SET</span>
<span class="p_add">+#ifdef CONFIG_CLOCK_FREQ</span>
 #define	MCF_CLK		CONFIG_CLOCK_FREQ
 #else
 #error &quot;Don&#39;t know what your ColdFire CPU clock frequency is??&quot;
<span class="p_header">diff --git a/arch/openrisc/Kconfig b/arch/openrisc/Kconfig</span>
<span class="p_header">index e5a693b16da2..443f44de1020 100644</span>
<span class="p_header">--- a/arch/openrisc/Kconfig</span>
<span class="p_header">+++ b/arch/openrisc/Kconfig</span>
<span class="p_chunk">@@ -17,6 +17,7 @@</span> <span class="p_context"> config OPENRISC</span>
 	select GENERIC_IRQ_SHOW
 	select GENERIC_IOMAP
 	select GENERIC_CPU_DEVICES
<span class="p_add">+	select HAVE_UID16</span>
 	select GENERIC_ATOMIC64
 	select GENERIC_CLOCKEVENTS
 	select GENERIC_STRNCPY_FROM_USER
<span class="p_chunk">@@ -31,9 +32,6 @@</span> <span class="p_context"> config MMU</span>
 config HAVE_DMA_ATTRS
 	def_bool y
 
<span class="p_del">-config UID16</span>
<span class="p_del">-	def_bool y</span>
<span class="p_del">-</span>
 config RWSEM_GENERIC_SPINLOCK
 	def_bool y
 
<span class="p_header">diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c</span>
<span class="p_header">index 9d518d693b4b..844b06d67df4 100644</span>
<span class="p_header">--- a/arch/x86/mm/mmap.c</span>
<span class="p_header">+++ b/arch/x86/mm/mmap.c</span>
<span class="p_chunk">@@ -126,3 +126,10 @@</span> <span class="p_context"> void arch_pick_mmap_layout(struct mm_struct *mm)</span>
 		mm-&gt;get_unmapped_area = arch_get_unmapped_area_topdown;
 	}
 }
<span class="p_add">+</span>
<span class="p_add">+const char *arch_vma_name(struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_MPX)</span>
<span class="p_add">+		return &quot;[mpx]&quot;;</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index c439ec478216..4d1c11c07fe1 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -18,26 +18,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/fpu-internal.h&gt;
 
<span class="p_del">-static const char *mpx_mapping_name(struct vm_area_struct *vma)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return &quot;[mpx]&quot;;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct vm_operations_struct mpx_vma_ops = {</span>
<span class="p_del">-	.name = mpx_mapping_name,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int is_mpx_vma(struct vm_area_struct *vma)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return (vma-&gt;vm_ops == &amp;mpx_vma_ops);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * This is really a simplified &quot;vm_mmap&quot;. it only handles MPX
  * bounds tables (the bounds directory is user-allocated).
<span class="p_del">- *</span>
<span class="p_del">- * Later on, we use the vma-&gt;vm_ops to uniquely identify these</span>
<span class="p_del">- * VMAs.</span>
  */
 static unsigned long mpx_mmap(unsigned long len)
 {
<span class="p_chunk">@@ -83,7 +66,6 @@</span> <span class="p_context"> static unsigned long mpx_mmap(unsigned long len)</span>
 		ret = -ENOMEM;
 		goto out;
 	}
<span class="p_del">-	vma-&gt;vm_ops = &amp;mpx_vma_ops;</span>
 
 	if (vm_flags &amp; VM_LOCKED) {
 		up_write(&amp;mm-&gt;mmap_sem);
<span class="p_chunk">@@ -661,7 +643,7 @@</span> <span class="p_context"> static int zap_bt_entries(struct mm_struct *mm,</span>
 		 * so stop immediately and return an error.  This
 		 * probably results in a SIGSEGV.
 		 */
<span class="p_del">-		if (!is_mpx_vma(vma))</span>
<span class="p_add">+		if (!(vma-&gt;vm_flags &amp; VM_MPX))</span>
 			return -EINVAL;
 
 		len = min(vma-&gt;vm_end, end) - addr;
<span class="p_header">diff --git a/block/bio.c b/block/bio.c</span>
<span class="p_header">index f66a4eae16ee..4441522ca339 100644</span>
<span class="p_header">--- a/block/bio.c</span>
<span class="p_header">+++ b/block/bio.c</span>
<span class="p_chunk">@@ -1814,8 +1814,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(bio_endio_nodec);</span>
  * Allocates and returns a new bio which represents @sectors from the start of
  * @bio, and updates @bio to represent the remaining sectors.
  *
<span class="p_del">- * The newly allocated bio will point to @bio&#39;s bi_io_vec; it is the caller&#39;s</span>
<span class="p_del">- * responsibility to ensure that @bio is not freed before the split.</span>
<span class="p_add">+ * Unless this is a discard request the newly allocated bio will point</span>
<span class="p_add">+ * to @bio&#39;s bi_io_vec; it is the caller&#39;s responsibility to ensure that</span>
<span class="p_add">+ * @bio is not freed before the split.</span>
  */
 struct bio *bio_split(struct bio *bio, int sectors,
 		      gfp_t gfp, struct bio_set *bs)
<span class="p_chunk">@@ -1825,7 +1826,15 @@</span> <span class="p_context"> struct bio *bio_split(struct bio *bio, int sectors,</span>
 	BUG_ON(sectors &lt;= 0);
 	BUG_ON(sectors &gt;= bio_sectors(bio));
 
<span class="p_del">-	split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Discards need a mutable bio_vec to accommodate the payload</span>
<span class="p_add">+	 * required by the DSM TRIM and UNMAP commands.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (bio-&gt;bi_rw &amp; REQ_DISCARD)</span>
<span class="p_add">+		split = bio_clone_bioset(bio, gfp, bs);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		split = bio_clone_fast(bio, gfp, bs);</span>
<span class="p_add">+</span>
 	if (!split)
 		return NULL;
 
<span class="p_header">diff --git a/crypto/asymmetric_keys/asymmetric_keys.h b/crypto/asymmetric_keys/asymmetric_keys.h</span>
<span class="p_header">index f97330886d58..3f5b537ab33e 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/asymmetric_keys.h</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/asymmetric_keys.h</span>
<span class="p_chunk">@@ -11,6 +11,9 @@</span> <span class="p_context"></span>
 
 extern struct asymmetric_key_id *asymmetric_key_hex_to_key_id(const char *id);
 
<span class="p_add">+extern int __asymmetric_key_hex_to_key_id(const char *id,</span>
<span class="p_add">+					  struct asymmetric_key_id *match_id,</span>
<span class="p_add">+					  size_t hexlen);</span>
 static inline
 const struct asymmetric_key_ids *asymmetric_key_ids(const struct key *key)
 {
<span class="p_header">diff --git a/crypto/asymmetric_keys/asymmetric_type.c b/crypto/asymmetric_keys/asymmetric_type.c</span>
<span class="p_header">index bcbbbd794e1d..b0e4ed23d668 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/asymmetric_type.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/asymmetric_type.c</span>
<span class="p_chunk">@@ -104,6 +104,15 @@</span> <span class="p_context"> static bool asymmetric_match_key_ids(</span>
 	return false;
 }
 
<span class="p_add">+/* helper function can be called directly with pre-allocated memory */</span>
<span class="p_add">+inline int __asymmetric_key_hex_to_key_id(const char *id,</span>
<span class="p_add">+				   struct asymmetric_key_id *match_id,</span>
<span class="p_add">+				   size_t hexlen)</span>
<span class="p_add">+{</span>
<span class="p_add">+	match_id-&gt;len = hexlen;</span>
<span class="p_add">+	return hex2bin(match_id-&gt;data, id, hexlen);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * asymmetric_key_hex_to_key_id - Convert a hex string into a key ID.
  * @id: The ID as a hex string.
<span class="p_chunk">@@ -111,21 +120,20 @@</span> <span class="p_context"> static bool asymmetric_match_key_ids(</span>
 struct asymmetric_key_id *asymmetric_key_hex_to_key_id(const char *id)
 {
 	struct asymmetric_key_id *match_id;
<span class="p_del">-	size_t hexlen;</span>
<span class="p_add">+	size_t asciihexlen;</span>
 	int ret;
 
 	if (!*id)
 		return ERR_PTR(-EINVAL);
<span class="p_del">-	hexlen = strlen(id);</span>
<span class="p_del">-	if (hexlen &amp; 1)</span>
<span class="p_add">+	asciihexlen = strlen(id);</span>
<span class="p_add">+	if (asciihexlen &amp; 1)</span>
 		return ERR_PTR(-EINVAL);
 
<span class="p_del">-	match_id = kmalloc(sizeof(struct asymmetric_key_id) + hexlen / 2,</span>
<span class="p_add">+	match_id = kmalloc(sizeof(struct asymmetric_key_id) + asciihexlen / 2,</span>
 			   GFP_KERNEL);
 	if (!match_id)
 		return ERR_PTR(-ENOMEM);
<span class="p_del">-	match_id-&gt;len = hexlen / 2;</span>
<span class="p_del">-	ret = hex2bin(match_id-&gt;data, id, hexlen / 2);</span>
<span class="p_add">+	ret = __asymmetric_key_hex_to_key_id(id, match_id, asciihexlen / 2);</span>
 	if (ret &lt; 0) {
 		kfree(match_id);
 		return ERR_PTR(-EINVAL);
<span class="p_header">diff --git a/crypto/asymmetric_keys/x509_public_key.c b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">index a6c42031628e..24f17e6c5904 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/x509_public_key.c</span>
<span class="p_chunk">@@ -28,17 +28,30 @@</span> <span class="p_context"> static bool use_builtin_keys;</span>
 static struct asymmetric_key_id *ca_keyid;
 
 #ifndef MODULE
<span class="p_add">+static struct {</span>
<span class="p_add">+	struct asymmetric_key_id id;</span>
<span class="p_add">+	unsigned char data[10];</span>
<span class="p_add">+} cakey;</span>
<span class="p_add">+</span>
 static int __init ca_keys_setup(char *str)
 {
 	if (!str)		/* default system keyring */
 		return 1;
 
 	if (strncmp(str, &quot;id:&quot;, 3) == 0) {
<span class="p_del">-		struct asymmetric_key_id *p;</span>
<span class="p_del">-		p = asymmetric_key_hex_to_key_id(str + 3);</span>
<span class="p_del">-		if (p == ERR_PTR(-EINVAL))</span>
<span class="p_del">-			pr_err(&quot;Unparsable hex string in ca_keys\n&quot;);</span>
<span class="p_del">-		else if (!IS_ERR(p))</span>
<span class="p_add">+		struct asymmetric_key_id *p = &amp;cakey.id;</span>
<span class="p_add">+		size_t hexlen = (strlen(str) - 3) / 2;</span>
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (hexlen == 0 || hexlen &gt; sizeof(cakey.data)) {</span>
<span class="p_add">+			pr_err(&quot;Missing or invalid ca_keys id\n&quot;);</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = __asymmetric_key_hex_to_key_id(str + 3, p, hexlen);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			pr_err(&quot;Unparsable ca_keys id hex string\n&quot;);</span>
<span class="p_add">+		else</span>
 			ca_keyid = p;	/* owner key &#39;id:xxxxxx&#39; */
 	} else if (strcmp(str, &quot;builtin&quot;) == 0) {
 		use_builtin_keys = true;
<span class="p_header">diff --git a/drivers/acpi/acpi_lpss.c b/drivers/acpi/acpi_lpss.c</span>
<span class="p_header">index 37fb19047603..73f056a597a9 100644</span>
<span class="p_header">--- a/drivers/acpi/acpi_lpss.c</span>
<span class="p_header">+++ b/drivers/acpi/acpi_lpss.c</span>
<span class="p_chunk">@@ -352,13 +352,16 @@</span> <span class="p_context"> static int acpi_lpss_create_device(struct acpi_device *adev,</span>
 				pdata-&gt;mmio_size = resource_size(rentry-&gt;res);
 			pdata-&gt;mmio_base = ioremap(rentry-&gt;res-&gt;start,
 						   pdata-&gt;mmio_size);
<span class="p_del">-			if (!pdata-&gt;mmio_base)</span>
<span class="p_del">-				goto err_out;</span>
 			break;
 		}
 
 	acpi_dev_free_resource_list(&amp;resource_list);
 
<span class="p_add">+	if (!pdata-&gt;mmio_base) {</span>
<span class="p_add">+		ret = -ENOMEM;</span>
<span class="p_add">+		goto err_out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pdata-&gt;dev_desc = dev_desc;
 
 	if (dev_desc-&gt;setup)
<span class="p_header">diff --git a/drivers/acpi/acpica/aclocal.h b/drivers/acpi/acpica/aclocal.h</span>
<span class="p_header">index 87b27521fcac..7f50dd9eb1d0 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/aclocal.h</span>
<span class="p_header">+++ b/drivers/acpi/acpica/aclocal.h</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> struct acpi_table_list {</span>
 
 #define ACPI_TABLE_INDEX_DSDT           (0)
 #define ACPI_TABLE_INDEX_FACS           (1)
<span class="p_add">+#define ACPI_TABLE_INDEX_X_FACS         (2)</span>
 
 struct acpi_find_context {
 	char *search_for;
<span class="p_header">diff --git a/drivers/acpi/acpica/tbfadt.c b/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_header">index 7d2486005e3f..05be59c772c7 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbfadt.c</span>
<span class="p_chunk">@@ -350,9 +350,18 @@</span> <span class="p_context"> void acpi_tb_parse_fadt(u32 table_index)</span>
 	/* If Hardware Reduced flag is set, there is no FACS */
 
 	if (!acpi_gbl_reduced_hardware) {
<span class="p_del">-		acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_del">-					    acpi_gbl_FADT.Xfacs, ACPI_SIG_FACS,</span>
<span class="p_del">-					    ACPI_TABLE_INDEX_FACS);</span>
<span class="p_add">+		if (acpi_gbl_FADT.facs) {</span>
<span class="p_add">+			acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_add">+						    acpi_gbl_FADT.facs,</span>
<span class="p_add">+						    ACPI_SIG_FACS,</span>
<span class="p_add">+						    ACPI_TABLE_INDEX_FACS);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if (acpi_gbl_FADT.Xfacs) {</span>
<span class="p_add">+			acpi_tb_install_fixed_table((acpi_physical_address)</span>
<span class="p_add">+						    acpi_gbl_FADT.Xfacs,</span>
<span class="p_add">+						    ACPI_SIG_FACS,</span>
<span class="p_add">+						    ACPI_TABLE_INDEX_X_FACS);</span>
<span class="p_add">+		}</span>
 	}
 }
 
<span class="p_chunk">@@ -491,13 +500,9 @@</span> <span class="p_context"> static void acpi_tb_convert_fadt(void)</span>
 	acpi_gbl_FADT.header.length = sizeof(struct acpi_table_fadt);
 
 	/*
<span class="p_del">-	 * Expand the 32-bit FACS and DSDT addresses to 64-bit as necessary.</span>
<span class="p_add">+	 * Expand the 32-bit DSDT addresses to 64-bit as necessary.</span>
 	 * Later ACPICA code will always use the X 64-bit field.
 	 */
<span class="p_del">-	acpi_gbl_FADT.Xfacs = acpi_tb_select_address(&quot;FACS&quot;,</span>
<span class="p_del">-						     acpi_gbl_FADT.facs,</span>
<span class="p_del">-						     acpi_gbl_FADT.Xfacs);</span>
<span class="p_del">-</span>
 	acpi_gbl_FADT.Xdsdt = acpi_tb_select_address(&quot;DSDT&quot;,
 						     acpi_gbl_FADT.dsdt,
 						     acpi_gbl_FADT.Xdsdt);
<span class="p_header">diff --git a/drivers/acpi/acpica/tbutils.c b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">index 6559a58439c5..2fb1afaacc6d 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbutils.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbutils.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> acpi_tb_get_root_table_entry(u8 *table_entry, u32 table_entry_size);</span>
 
 acpi_status acpi_tb_initialize_facs(void)
 {
<span class="p_del">-	acpi_status status;</span>
<span class="p_add">+	struct acpi_table_facs *facs32;</span>
<span class="p_add">+	struct acpi_table_facs *facs64;</span>
 
 	/* If Hardware Reduced flag is set, there is no FACS */
 
<span class="p_chunk">@@ -77,11 +78,22 @@</span> <span class="p_context"> acpi_status acpi_tb_initialize_facs(void)</span>
 		return (AE_OK);
 	}
 
<span class="p_del">-	status = acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,</span>
<span class="p_del">-					 ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_del">-								acpi_table_header,</span>
<span class="p_del">-								&amp;acpi_gbl_FACS));</span>
<span class="p_del">-	return (status);</span>
<span class="p_add">+	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_FACS,</span>
<span class="p_add">+				      ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_add">+							     acpi_table_header,</span>
<span class="p_add">+							     &amp;facs32));</span>
<span class="p_add">+	(void)acpi_get_table_by_index(ACPI_TABLE_INDEX_X_FACS,</span>
<span class="p_add">+				      ACPI_CAST_INDIRECT_PTR(struct</span>
<span class="p_add">+							     acpi_table_header,</span>
<span class="p_add">+							     &amp;facs64));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (acpi_gbl_use32_bit_facs_addresses) {</span>
<span class="p_add">+		acpi_gbl_FACS = facs32 ? facs32 : facs64;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		acpi_gbl_FACS = facs64 ? facs64 : facs32;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return (AE_OK);</span>
 }
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_chunk">@@ -101,7 +113,7 @@</span> <span class="p_context"> acpi_status acpi_tb_initialize_facs(void)</span>
 u8 acpi_tb_tables_loaded(void)
 {
 
<span class="p_del">-	if (acpi_gbl_root_table_list.current_table_count &gt;= 3) {</span>
<span class="p_add">+	if (acpi_gbl_root_table_list.current_table_count &gt;= 4) {</span>
 		return (TRUE);
 	}
 
<span class="p_chunk">@@ -357,11 +369,11 @@</span> <span class="p_context"> acpi_status __init acpi_tb_parse_root_table(acpi_physical_address rsdp_address)</span>
 	table_entry = ACPI_ADD_PTR(u8, table, sizeof(struct acpi_table_header));
 
 	/*
<span class="p_del">-	 * First two entries in the table array are reserved for the DSDT</span>
<span class="p_del">-	 * and FACS, which are not actually present in the RSDT/XSDT - they</span>
<span class="p_del">-	 * come from the FADT</span>
<span class="p_add">+	 * First three entries in the table array are reserved for the DSDT</span>
<span class="p_add">+	 * and 32bit/64bit FACS, which are not actually present in the</span>
<span class="p_add">+	 * RSDT/XSDT - they come from the FADT</span>
 	 */
<span class="p_del">-	acpi_gbl_root_table_list.current_table_count = 2;</span>
<span class="p_add">+	acpi_gbl_root_table_list.current_table_count = 3;</span>
 
 	/* Initialize the root table array from the RSDT/XSDT */
 
<span class="p_header">diff --git a/drivers/acpi/acpica/tbxfload.c b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">index aadb3002a2dd..b63e35d6d1bf 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/tbxfload.c</span>
<span class="p_chunk">@@ -166,7 +166,8 @@</span> <span class="p_context"> static acpi_status acpi_tb_load_namespace(void)</span>
 
 	(void)acpi_ut_acquire_mutex(ACPI_MTX_TABLES);
 	for (i = 0; i &lt; acpi_gbl_root_table_list.current_table_count; ++i) {
<span class="p_del">-		if ((!ACPI_COMPARE_NAME</span>
<span class="p_add">+		if (!acpi_gbl_root_table_list.tables[i].address ||</span>
<span class="p_add">+		    (!ACPI_COMPARE_NAME</span>
 		     (&amp;(acpi_gbl_root_table_list.tables[i].signature),
 		      ACPI_SIG_SSDT)
 		     &amp;&amp;
<span class="p_header">diff --git a/drivers/acpi/acpica/utxfinit.c b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">index 083a76891889..42a32a66ef22 100644</span>
<span class="p_header">--- a/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_header">+++ b/drivers/acpi/acpica/utxfinit.c</span>
<span class="p_chunk">@@ -179,10 +179,12 @@</span> <span class="p_context"> acpi_status __init acpi_enable_subsystem(u32 flags)</span>
 	 * Obtain a permanent mapping for the FACS. This is required for the
 	 * Global Lock and the Firmware Waking Vector
 	 */
<span class="p_del">-	status = acpi_tb_initialize_facs();</span>
<span class="p_del">-	if (ACPI_FAILURE(status)) {</span>
<span class="p_del">-		ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_del">-		return_ACPI_STATUS(status);</span>
<span class="p_add">+	if (!(flags &amp; ACPI_NO_FACS_INIT)) {</span>
<span class="p_add">+		status = acpi_tb_initialize_facs();</span>
<span class="p_add">+		if (ACPI_FAILURE(status)) {</span>
<span class="p_add">+			ACPI_WARNING((AE_INFO, &quot;Could not map the FACS table&quot;));</span>
<span class="p_add">+			return_ACPI_STATUS(status);</span>
<span class="p_add">+		}</span>
 	}
 #endif				/* !ACPI_REDUCED_HARDWARE */
 
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index 5226a8b921ae..98f5316aad72 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -175,10 +175,14 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *gas,</span>
 	if (!addr || !length)
 		return;
 
<span class="p_del">-	acpi_reserve_region(addr, length, gas-&gt;space_id, 0, desc);</span>
<span class="p_add">+	/* Resources are never freed */</span>
<span class="p_add">+	if (gas-&gt;space_id == ACPI_ADR_SPACE_SYSTEM_IO)</span>
<span class="p_add">+		request_region(addr, length, desc);</span>
<span class="p_add">+	else if (gas-&gt;space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)</span>
<span class="p_add">+		request_mem_region(addr, length, desc);</span>
 }
 
<span class="p_del">-static void __init acpi_reserve_resources(void)</span>
<span class="p_add">+static int __init acpi_reserve_resources(void)</span>
 {
 	acpi_request_region(&amp;acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		&quot;ACPI PM1a_EVT_BLK&quot;);
<span class="p_chunk">@@ -207,7 +211,10 @@</span> <span class="p_context"> static void __init acpi_reserve_resources(void)</span>
 	if (!(acpi_gbl_FADT.gpe1_block_length &amp; 0x1))
 		acpi_request_region(&amp;acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, &quot;ACPI GPE1_BLK&quot;);
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
<span class="p_add">+fs_initcall_sync(acpi_reserve_resources);</span>
 
 void acpi_os_printf(const char *fmt, ...)
 {
<span class="p_chunk">@@ -1838,7 +1845,6 @@</span> <span class="p_context"> acpi_status __init acpi_os_initialize(void)</span>
 
 acpi_status __init acpi_os_initialize1(void)
 {
<span class="p_del">-	acpi_reserve_resources();</span>
 	kacpid_wq = alloc_workqueue(&quot;kacpid&quot;, 0, 1);
 	kacpi_notify_wq = alloc_workqueue(&quot;kacpi_notify&quot;, 0, 1);
 	kacpi_hotplug_wq = alloc_ordered_workqueue(&quot;kacpi_hotplug&quot;, 0);
<span class="p_header">diff --git a/drivers/acpi/resource.c b/drivers/acpi/resource.c</span>
<span class="p_header">index fcb7807ea8b7..f1c966e05078 100644</span>
<span class="p_header">--- a/drivers/acpi/resource.c</span>
<span class="p_header">+++ b/drivers/acpi/resource.c</span>
<span class="p_chunk">@@ -26,7 +26,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/device.h&gt;
 #include &lt;linux/export.h&gt;
 #include &lt;linux/ioport.h&gt;
<span class="p_del">-#include &lt;linux/list.h&gt;</span>
 #include &lt;linux/slab.h&gt;
 
 #ifdef CONFIG_X86
<span class="p_chunk">@@ -194,6 +193,7 @@</span> <span class="p_context"> static bool acpi_decode_space(struct resource_win *win,</span>
 	u8 iodec = attr-&gt;granularity == 0xfff ? ACPI_DECODE_10 : ACPI_DECODE_16;
 	bool wp = addr-&gt;info.mem.write_protect;
 	u64 len = attr-&gt;address_length;
<span class="p_add">+	u64 start, end, offset = 0;</span>
 	struct resource *res = &amp;win-&gt;res;
 
 	/*
<span class="p_chunk">@@ -205,9 +205,6 @@</span> <span class="p_context"> static bool acpi_decode_space(struct resource_win *win,</span>
 		pr_debug(&quot;ACPI: Invalid address space min_addr_fix %d, max_addr_fix %d, len %llx\n&quot;,
 			 addr-&gt;min_address_fixed, addr-&gt;max_address_fixed, len);
 
<span class="p_del">-	res-&gt;start = attr-&gt;minimum;</span>
<span class="p_del">-	res-&gt;end = attr-&gt;maximum;</span>
<span class="p_del">-</span>
 	/*
 	 * For bridges that translate addresses across the bridge,
 	 * translation_offset is the offset that must be added to the
<span class="p_chunk">@@ -215,12 +212,22 @@</span> <span class="p_context"> static bool acpi_decode_space(struct resource_win *win,</span>
 	 * primary side. Non-bridge devices must list 0 for all Address
 	 * Translation offset bits.
 	 */
<span class="p_del">-	if (addr-&gt;producer_consumer == ACPI_PRODUCER) {</span>
<span class="p_del">-		res-&gt;start += attr-&gt;translation_offset;</span>
<span class="p_del">-		res-&gt;end += attr-&gt;translation_offset;</span>
<span class="p_del">-	} else if (attr-&gt;translation_offset) {</span>
<span class="p_add">+	if (addr-&gt;producer_consumer == ACPI_PRODUCER)</span>
<span class="p_add">+		offset = attr-&gt;translation_offset;</span>
<span class="p_add">+	else if (attr-&gt;translation_offset)</span>
 		pr_debug(&quot;ACPI: translation_offset(%lld) is invalid for non-bridge device.\n&quot;,
 			 attr-&gt;translation_offset);
<span class="p_add">+	start = attr-&gt;minimum + offset;</span>
<span class="p_add">+	end = attr-&gt;maximum + offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	win-&gt;offset = offset;</span>
<span class="p_add">+	res-&gt;start = start;</span>
<span class="p_add">+	res-&gt;end = end;</span>
<span class="p_add">+	if (sizeof(resource_size_t) &lt; sizeof(u64) &amp;&amp;</span>
<span class="p_add">+	    (offset != win-&gt;offset || start != res-&gt;start || end != res-&gt;end)) {</span>
<span class="p_add">+		pr_warn(&quot;acpi resource window ([%#llx-%#llx] ignored, not CPU addressable)\n&quot;,</span>
<span class="p_add">+			attr-&gt;minimum, attr-&gt;maximum);</span>
<span class="p_add">+		return false;</span>
 	}
 
 	switch (addr-&gt;resource_type) {
<span class="p_chunk">@@ -237,8 +244,6 @@</span> <span class="p_context"> static bool acpi_decode_space(struct resource_win *win,</span>
 		return false;
 	}
 
<span class="p_del">-	win-&gt;offset = attr-&gt;translation_offset;</span>
<span class="p_del">-</span>
 	if (addr-&gt;producer_consumer == ACPI_PRODUCER)
 		res-&gt;flags |= IORESOURCE_WINDOW;
 
<span class="p_chunk">@@ -622,162 +627,3 @@</span> <span class="p_context"> int acpi_dev_filter_resource_type(struct acpi_resource *ares,</span>
 	return (type &amp; types) ? 0 : 1;
 }
 EXPORT_SYMBOL_GPL(acpi_dev_filter_resource_type);
<span class="p_del">-</span>
<span class="p_del">-struct reserved_region {</span>
<span class="p_del">-	struct list_head node;</span>
<span class="p_del">-	u64 start;</span>
<span class="p_del">-	u64 end;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static LIST_HEAD(reserved_io_regions);</span>
<span class="p_del">-static LIST_HEAD(reserved_mem_regions);</span>
<span class="p_del">-</span>
<span class="p_del">-static int request_range(u64 start, u64 end, u8 space_id, unsigned long flags,</span>
<span class="p_del">-			 char *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int length = end - start + 1;</span>
<span class="p_del">-	struct resource *res;</span>
<span class="p_del">-</span>
<span class="p_del">-	res = space_id == ACPI_ADR_SPACE_SYSTEM_IO ?</span>
<span class="p_del">-		request_region(start, length, desc) :</span>
<span class="p_del">-		request_mem_region(start, length, desc);</span>
<span class="p_del">-	if (!res)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
<span class="p_del">-	res-&gt;flags &amp;= ~flags;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int add_region_before(u64 start, u64 end, u8 space_id,</span>
<span class="p_del">-			     unsigned long flags, char *desc,</span>
<span class="p_del">-			     struct list_head *head)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct reserved_region *reg;</span>
<span class="p_del">-	int error;</span>
<span class="p_del">-</span>
<span class="p_del">-	reg = kmalloc(sizeof(*reg), GFP_KERNEL);</span>
<span class="p_del">-	if (!reg)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	error = request_range(start, end, space_id, flags, desc);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
<span class="p_del">-	reg-&gt;start = start;</span>
<span class="p_del">-	reg-&gt;end = end;</span>
<span class="p_del">-	list_add_tail(&amp;reg-&gt;node, head);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * acpi_reserve_region - Reserve an I/O or memory region as a system resource.</span>
<span class="p_del">- * @start: Starting address of the region.</span>
<span class="p_del">- * @length: Length of the region.</span>
<span class="p_del">- * @space_id: Identifier of address space to reserve the region from.</span>
<span class="p_del">- * @flags: Resource flags to clear for the region after requesting it.</span>
<span class="p_del">- * @desc: Region description (for messages).</span>
<span class="p_del">- *</span>
<span class="p_del">- * Reserve an I/O or memory region as a system resource to prevent others from</span>
<span class="p_del">- * using it.  If the new region overlaps with one of the regions (in the given</span>
<span class="p_del">- * address space) already reserved by this routine, only the non-overlapping</span>
<span class="p_del">- * parts of it will be reserved.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Returned is either 0 (success) or a negative error code indicating a resource</span>
<span class="p_del">- * reservation problem.  It is the code of the first encountered error, but the</span>
<span class="p_del">- * routine doesn&#39;t abort until it has attempted to request all of the parts of</span>
<span class="p_del">- * the new region that don&#39;t overlap with other regions reserved previously.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The resources requested by this routine are never released.</span>
<span class="p_del">- */</span>
<span class="p_del">-int acpi_reserve_region(u64 start, unsigned int length, u8 space_id,</span>
<span class="p_del">-			unsigned long flags, char *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct list_head *regions;</span>
<span class="p_del">-	struct reserved_region *reg;</span>
<span class="p_del">-	u64 end = start + length - 1;</span>
<span class="p_del">-	int ret = 0, error = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (space_id == ACPI_ADR_SPACE_SYSTEM_IO)</span>
<span class="p_del">-		regions = &amp;reserved_io_regions;</span>
<span class="p_del">-	else if (space_id == ACPI_ADR_SPACE_SYSTEM_MEMORY)</span>
<span class="p_del">-		regions = &amp;reserved_mem_regions;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (list_empty(regions))</span>
<span class="p_del">-		return add_region_before(start, end, space_id, flags, desc, regions);</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(reg, regions, node)</span>
<span class="p_del">-		if (reg-&gt;start == end + 1) {</span>
<span class="p_del">-			/* The new region can be prepended to this one. */</span>
<span class="p_del">-			ret = request_range(start, end, space_id, flags, desc);</span>
<span class="p_del">-			if (!ret)</span>
<span class="p_del">-				reg-&gt;start = start;</span>
<span class="p_del">-</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-		} else if (reg-&gt;start &gt; end) {</span>
<span class="p_del">-			/* No overlap.  Add the new region here and get out. */</span>
<span class="p_del">-			return add_region_before(start, end, space_id, flags,</span>
<span class="p_del">-						 desc, &amp;reg-&gt;node);</span>
<span class="p_del">-		} else if (reg-&gt;end == start - 1) {</span>
<span class="p_del">-			goto combine;</span>
<span class="p_del">-		} else if (reg-&gt;end &gt;= start) {</span>
<span class="p_del">-			goto overlap;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The new region goes after the last existing one. */</span>
<span class="p_del">-	return add_region_before(start, end, space_id, flags, desc, regions);</span>
<span class="p_del">-</span>
<span class="p_del">- overlap:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The new region overlaps an existing one.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * The head part of the new region immediately preceding the existing</span>
<span class="p_del">-	 * overlapping one can be combined with it right away.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (reg-&gt;start &gt; start) {</span>
<span class="p_del">-		error = request_range(start, reg-&gt;start - 1, space_id, flags, desc);</span>
<span class="p_del">-		if (error)</span>
<span class="p_del">-			ret = error;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			reg-&gt;start = start;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">- combine:</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * The new region is adjacent to an existing one.  If it extends beyond</span>
<span class="p_del">-	 * that region all the way to the next one, it is possible to combine</span>
<span class="p_del">-	 * all three of them.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	while (reg-&gt;end &lt; end) {</span>
<span class="p_del">-		struct reserved_region *next = NULL;</span>
<span class="p_del">-		u64 a = reg-&gt;end + 1, b = end;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!list_is_last(&amp;reg-&gt;node, regions)) {</span>
<span class="p_del">-			next = list_next_entry(reg, node);</span>
<span class="p_del">-			if (next-&gt;start &lt;= end)</span>
<span class="p_del">-				b = next-&gt;start - 1;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		error = request_range(a, b, space_id, flags, desc);</span>
<span class="p_del">-		if (!error) {</span>
<span class="p_del">-			if (next &amp;&amp; next-&gt;start == b + 1) {</span>
<span class="p_del">-				reg-&gt;end = next-&gt;end;</span>
<span class="p_del">-				list_del(&amp;next-&gt;node);</span>
<span class="p_del">-				kfree(next);</span>
<span class="p_del">-			} else {</span>
<span class="p_del">-				reg-&gt;end = end;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-		} else if (next) {</span>
<span class="p_del">-			if (!ret)</span>
<span class="p_del">-				ret = error;</span>
<span class="p_del">-</span>
<span class="p_del">-			reg = next;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret ? ret : error;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(acpi_reserve_region);</span>
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 577849c6611a..41c99be9bd41 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -2478,6 +2478,10 @@</span> <span class="p_context"> int ata_dev_configure(struct ata_device *dev)</span>
 		dev-&gt;max_sectors = min_t(unsigned int, ATA_MAX_SECTORS_128,
 					 dev-&gt;max_sectors);
 
<span class="p_add">+	if (dev-&gt;horkage &amp; ATA_HORKAGE_MAX_SEC_1024)</span>
<span class="p_add">+		dev-&gt;max_sectors = min_t(unsigned int, ATA_MAX_SECTORS_1024,</span>
<span class="p_add">+					 dev-&gt;max_sectors);</span>
<span class="p_add">+</span>
 	if (dev-&gt;horkage &amp; ATA_HORKAGE_MAX_SEC_LBA48)
 		dev-&gt;max_sectors = ATA_MAX_SECTORS_LBA48;
 
<span class="p_chunk">@@ -4146,6 +4150,12 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;Slimtype DVD A  DS8A8SH&quot;, NULL,	ATA_HORKAGE_MAX_SEC_LBA48 },
 	{ &quot;Slimtype DVD A  DS8A9SH&quot;, NULL,	ATA_HORKAGE_MAX_SEC_LBA48 },
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Causes silent data corruption with higher max sects.</span>
<span class="p_add">+	 * http://lkml.kernel.org/g/x49wpy40ysk.fsf@segfault.boston.devel.redhat.com</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	{ &quot;ST380013AS&quot;,		&quot;3.20&quot;,		ATA_HORKAGE_MAX_SEC_1024 },</span>
<span class="p_add">+</span>
 	/* Devices we expect to fail diagnostics */
 
 	/* Devices where NCQ should be avoided */
<span class="p_chunk">@@ -4174,9 +4184,10 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;ST3320[68]13AS&quot;,	&quot;SD1[5-9]&quot;,	ATA_HORKAGE_NONCQ |
 						ATA_HORKAGE_FIRMWARE_WARN },
 
<span class="p_del">-	/* Seagate Momentus SpinPoint M8 seem to have FPMDA_AA issues */</span>
<span class="p_add">+	/* drives which fail FPDMA_AA activation (some may freeze afterwards) */</span>
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2AR10001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
 	{ &quot;ST1000LM024 HN-M101MBB&quot;, &quot;2BA30001&quot;,	ATA_HORKAGE_BROKEN_FPDMA_AA },
<span class="p_add">+	{ &quot;VB0250EAVER&quot;,	&quot;HPG7&quot;,		ATA_HORKAGE_BROKEN_FPDMA_AA },</span>
 
 	/* Blacklist entries taken from Silicon Image 3124/3132
 	   Windows driver .inf file - also several Linux problem reports */
<span class="p_chunk">@@ -4225,11 +4236,11 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;PIONEER DVD-RW  DVR-216D&quot;,	NULL,	ATA_HORKAGE_NOSETXFER },
 
 	/* devices that don&#39;t properly handle queued TRIM commands */
<span class="p_del">-	{ &quot;Micron_M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
<span class="p_add">+	{ &quot;Micron_M500_*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 	{ &quot;Crucial_CT*M500*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
<span class="p_del">-	{ &quot;Micron_M5[15]0*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
<span class="p_add">+	{ &quot;Micron_M5[15]0_*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 	{ &quot;Crucial_CT*M550*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
<span class="p_chunk">@@ -4238,6 +4249,9 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 	{ &quot;Samsung SSD 8*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 
<span class="p_add">+	/* devices that don&#39;t properly handle TRIM commands */</span>
<span class="p_add">+	{ &quot;SuperSSpeed S238*&quot;,		NULL,	ATA_HORKAGE_NOTRIM, },</span>
<span class="p_add">+</span>
 	/*
 	 * As defined, the DRAT (Deterministic Read After Trim) and RZAT
 	 * (Return Zero After Trim) flags in the ATA Command Set are
<span class="p_chunk">@@ -4501,7 +4515,8 @@</span> <span class="p_context"> static unsigned int ata_dev_set_xfermode(struct ata_device *dev)</span>
 	else /* In the ancient relic department - skip all of this */
 		return 0;
 
<span class="p_del">-	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 0);</span>
<span class="p_add">+	/* On some disks, this command causes spin-up, so we need longer timeout */</span>
<span class="p_add">+	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_NONE, NULL, 0, 15000);</span>
 
 	DPRINTK(&quot;EXIT, err_mask=%x\n&quot;, err_mask);
 	return err_mask;
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index cf0022ec07f2..7465031a893c 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -1507,16 +1507,21 @@</span> <span class="p_context"> unsigned int ata_read_log_page(struct ata_device *dev, u8 log,</span>
 {
 	struct ata_taskfile tf;
 	unsigned int err_mask;
<span class="p_add">+	bool dma = false;</span>
 
 	DPRINTK(&quot;read log page - log 0x%x, page 0x%x\n&quot;, log, page);
 
<span class="p_add">+retry:</span>
 	ata_tf_init(dev, &amp;tf);
<span class="p_del">-	if (dev-&gt;dma_mode &amp;&amp; ata_id_has_read_log_dma_ext(dev-&gt;id)) {</span>
<span class="p_add">+	if (dev-&gt;dma_mode &amp;&amp; ata_id_has_read_log_dma_ext(dev-&gt;id) &amp;&amp;</span>
<span class="p_add">+	    !(dev-&gt;horkage &amp; ATA_HORKAGE_NO_NCQ_LOG)) {</span>
 		tf.command = ATA_CMD_READ_LOG_DMA_EXT;
 		tf.protocol = ATA_PROT_DMA;
<span class="p_add">+		dma = true;</span>
 	} else {
 		tf.command = ATA_CMD_READ_LOG_EXT;
 		tf.protocol = ATA_PROT_PIO;
<span class="p_add">+		dma = false;</span>
 	}
 	tf.lbal = log;
 	tf.lbam = page;
<span class="p_chunk">@@ -1527,6 +1532,12 @@</span> <span class="p_context"> unsigned int ata_read_log_page(struct ata_device *dev, u8 log,</span>
 	err_mask = ata_exec_internal(dev, &amp;tf, NULL, DMA_FROM_DEVICE,
 				     buf, sectors * ATA_SECT_SIZE, 0);
 
<span class="p_add">+	if (err_mask &amp;&amp; dma) {</span>
<span class="p_add">+		dev-&gt;horkage |= ATA_HORKAGE_NO_NCQ_LOG;</span>
<span class="p_add">+		ata_dev_warn(dev, &quot;READ LOG DMA EXT failed, trying unqueued\n&quot;);</span>
<span class="p_add">+		goto retry;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	DPRINTK(&quot;EXIT, err_mask=%x\n&quot;, err_mask);
 	return err_mask;
 }
<span class="p_header">diff --git a/drivers/ata/libata-scsi.c b/drivers/ata/libata-scsi.c</span>
<span class="p_header">index 3131adcc1f87..641a61a59e89 100644</span>
<span class="p_header">--- a/drivers/ata/libata-scsi.c</span>
<span class="p_header">+++ b/drivers/ata/libata-scsi.c</span>
<span class="p_chunk">@@ -2568,7 +2568,8 @@</span> <span class="p_context"> static unsigned int ata_scsiop_read_cap(struct ata_scsi_args *args, u8 *rbuf)</span>
 		rbuf[14] = (lowest_aligned &gt;&gt; 8) &amp; 0x3f;
 		rbuf[15] = lowest_aligned;
 
<span class="p_del">-		if (ata_id_has_trim(args-&gt;id)) {</span>
<span class="p_add">+		if (ata_id_has_trim(args-&gt;id) &amp;&amp;</span>
<span class="p_add">+		    !(dev-&gt;horkage &amp; ATA_HORKAGE_NOTRIM)) {</span>
 			rbuf[14] |= 0x80; /* LBPME */
 
 			if (ata_id_has_zero_after_trim(args-&gt;id) &amp;&amp;
<span class="p_header">diff --git a/drivers/ata/libata-transport.c b/drivers/ata/libata-transport.c</span>
<span class="p_header">index 3227b7c8a05f..e2d94972962d 100644</span>
<span class="p_header">--- a/drivers/ata/libata-transport.c</span>
<span class="p_header">+++ b/drivers/ata/libata-transport.c</span>
<span class="p_chunk">@@ -560,6 +560,29 @@</span> <span class="p_context"> show_ata_dev_gscr(struct device *dev,</span>
 
 static DEVICE_ATTR(gscr, S_IRUGO, show_ata_dev_gscr, NULL);
 
<span class="p_add">+static ssize_t</span>
<span class="p_add">+show_ata_dev_trim(struct device *dev,</span>
<span class="p_add">+		  struct device_attribute *attr, char *buf)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ata_device *ata_dev = transport_class_to_dev(dev);</span>
<span class="p_add">+	unsigned char *mode;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ata_id_has_trim(ata_dev-&gt;id))</span>
<span class="p_add">+		mode = &quot;unsupported&quot;;</span>
<span class="p_add">+	else if (ata_dev-&gt;horkage &amp; ATA_HORKAGE_NOTRIM)</span>
<span class="p_add">+		mode = &quot;forced_unsupported&quot;;</span>
<span class="p_add">+	else if (ata_dev-&gt;horkage &amp; ATA_HORKAGE_NO_NCQ_TRIM)</span>
<span class="p_add">+			mode = &quot;forced_unqueued&quot;;</span>
<span class="p_add">+	else if (ata_fpdma_dsm_supported(ata_dev))</span>
<span class="p_add">+		mode = &quot;queued&quot;;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mode = &quot;unqueued&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	return snprintf(buf, 20, &quot;%s\n&quot;, mode);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static DEVICE_ATTR(trim, S_IRUGO, show_ata_dev_trim, NULL);</span>
<span class="p_add">+</span>
 static DECLARE_TRANSPORT_CLASS(ata_dev_class,
 			       &quot;ata_device&quot;, NULL, NULL, NULL);
 
<span class="p_chunk">@@ -733,6 +756,7 @@</span> <span class="p_context"> struct scsi_transport_template *ata_attach_transport(void)</span>
 	SETUP_DEV_ATTRIBUTE(ering);
 	SETUP_DEV_ATTRIBUTE(id);
 	SETUP_DEV_ATTRIBUTE(gscr);
<span class="p_add">+	SETUP_DEV_ATTRIBUTE(trim);</span>
 	BUG_ON(count &gt; ATA_DEV_ATTRS);
 	i-&gt;dev_attrs[count] = NULL;
 
<span class="p_header">diff --git a/drivers/base/firmware_class.c b/drivers/base/firmware_class.c</span>
<span class="p_header">index 171841ad1008..4d1d9de4f9bf 100644</span>
<span class="p_header">--- a/drivers/base/firmware_class.c</span>
<span class="p_header">+++ b/drivers/base/firmware_class.c</span>
<span class="p_chunk">@@ -544,10 +544,8 @@</span> <span class="p_context"> static void fw_dev_release(struct device *dev)</span>
 	kfree(fw_priv);
 }
 
<span class="p_del">-static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+static int do_firmware_uevent(struct firmware_priv *fw_priv, struct kobj_uevent_env *env)</span>
 {
<span class="p_del">-	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_del">-</span>
 	if (add_uevent_var(env, &quot;FIRMWARE=%s&quot;, fw_priv-&gt;buf-&gt;fw_id))
 		return -ENOMEM;
 	if (add_uevent_var(env, &quot;TIMEOUT=%i&quot;, loading_timeout))
<span class="p_chunk">@@ -558,6 +556,18 @@</span> <span class="p_context"> static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
 	return 0;
 }
 
<span class="p_add">+static int firmware_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct firmware_priv *fw_priv = to_firmware_priv(dev);</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;fw_lock);</span>
<span class="p_add">+	if (fw_priv-&gt;buf)</span>
<span class="p_add">+		err = do_firmware_uevent(fw_priv, env);</span>
<span class="p_add">+	mutex_unlock(&amp;fw_lock);</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct class firmware_class = {
 	.name		= &quot;firmware&quot;,
 	.class_attrs	= firmware_class_attrs,
<span class="p_header">diff --git a/drivers/base/power/clock_ops.c b/drivers/base/power/clock_ops.c</span>
<span class="p_header">index 7fdd0172605a..c7b0fcebf168 100644</span>
<span class="p_header">--- a/drivers/base/power/clock_ops.c</span>
<span class="p_header">+++ b/drivers/base/power/clock_ops.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> static int __pm_clk_add(struct device *dev, const char *con_id,</span>
 			return -ENOMEM;
 		}
 	} else {
<span class="p_del">-		if (IS_ERR(ce-&gt;clk) || !__clk_get(clk)) {</span>
<span class="p_add">+		if (IS_ERR(clk) || !__clk_get(clk)) {</span>
 			kfree(ce);
 			return -ENOENT;
 		}
<span class="p_header">diff --git a/drivers/block/loop.c b/drivers/block/loop.c</span>
<span class="p_header">index d7173cb1ea76..cef6fa83a274 100644</span>
<span class="p_header">--- a/drivers/block/loop.c</span>
<span class="p_header">+++ b/drivers/block/loop.c</span>
<span class="p_chunk">@@ -86,8 +86,6 @@</span> <span class="p_context"> static DEFINE_MUTEX(loop_index_mutex);</span>
 static int max_part;
 static int part_shift;
 
<span class="p_del">-static struct workqueue_struct *loop_wq;</span>
<span class="p_del">-</span>
 static int transfer_xor(struct loop_device *lo, int cmd,
 			struct page *raw_page, unsigned raw_off,
 			struct page *loop_page, unsigned loop_off,
<span class="p_chunk">@@ -725,6 +723,12 @@</span> <span class="p_context"> static int loop_set_fd(struct loop_device *lo, fmode_t mode,</span>
 	size = get_loop_size(lo, file);
 	if ((loff_t)(sector_t)size != size)
 		goto out_putf;
<span class="p_add">+	error = -ENOMEM;</span>
<span class="p_add">+	lo-&gt;wq = alloc_workqueue(&quot;kloopd%d&quot;,</span>
<span class="p_add">+			WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_UNBOUND, 16,</span>
<span class="p_add">+			lo-&gt;lo_number);</span>
<span class="p_add">+	if (!lo-&gt;wq)</span>
<span class="p_add">+		goto out_putf;</span>
 
 	error = 0;
 
<span class="p_chunk">@@ -872,6 +876,8 @@</span> <span class="p_context"> static int loop_clr_fd(struct loop_device *lo)</span>
 	lo-&gt;lo_flags = 0;
 	if (!part_shift)
 		lo-&gt;lo_disk-&gt;flags |= GENHD_FL_NO_PART_SCAN;
<span class="p_add">+	destroy_workqueue(lo-&gt;wq);</span>
<span class="p_add">+	lo-&gt;wq = NULL;</span>
 	mutex_unlock(&amp;lo-&gt;lo_ctl_mutex);
 	/*
 	 * Need not hold lo_ctl_mutex to fput backing file.
<span class="p_chunk">@@ -1425,9 +1431,13 @@</span> <span class="p_context"> static int loop_queue_rq(struct blk_mq_hw_ctx *hctx,</span>
 		const struct blk_mq_queue_data *bd)
 {
 	struct loop_cmd *cmd = blk_mq_rq_to_pdu(bd-&gt;rq);
<span class="p_add">+	struct loop_device *lo = cmd-&gt;rq-&gt;q-&gt;queuedata;</span>
 
 	blk_mq_start_request(bd-&gt;rq);
 
<span class="p_add">+	if (lo-&gt;lo_state != Lo_bound)</span>
<span class="p_add">+		return -EIO;</span>
<span class="p_add">+</span>
 	if (cmd-&gt;rq-&gt;cmd_flags &amp; REQ_WRITE) {
 		struct loop_device *lo = cmd-&gt;rq-&gt;q-&gt;queuedata;
 		bool need_sched = true;
<span class="p_chunk">@@ -1441,9 +1451,9 @@</span> <span class="p_context"> static int loop_queue_rq(struct blk_mq_hw_ctx *hctx,</span>
 		spin_unlock_irq(&amp;lo-&gt;lo_lock);
 
 		if (need_sched)
<span class="p_del">-			queue_work(loop_wq, &amp;lo-&gt;write_work);</span>
<span class="p_add">+			queue_work(lo-&gt;wq, &amp;lo-&gt;write_work);</span>
 	} else {
<span class="p_del">-		queue_work(loop_wq, &amp;cmd-&gt;read_work);</span>
<span class="p_add">+		queue_work(lo-&gt;wq, &amp;cmd-&gt;read_work);</span>
 	}
 
 	return BLK_MQ_RQ_QUEUE_OK;
<span class="p_chunk">@@ -1455,9 +1465,6 @@</span> <span class="p_context"> static void loop_handle_cmd(struct loop_cmd *cmd)</span>
 	struct loop_device *lo = cmd-&gt;rq-&gt;q-&gt;queuedata;
 	int ret = -EIO;
 
<span class="p_del">-	if (lo-&gt;lo_state != Lo_bound)</span>
<span class="p_del">-		goto failed;</span>
<span class="p_del">-</span>
 	if (write &amp;&amp; (lo-&gt;lo_flags &amp; LO_FLAGS_READ_ONLY))
 		goto failed;
 
<span class="p_chunk">@@ -1806,13 +1813,6 @@</span> <span class="p_context"> static int __init loop_init(void)</span>
 		goto misc_out;
 	}
 
<span class="p_del">-	loop_wq = alloc_workqueue(&quot;kloopd&quot;,</span>
<span class="p_del">-			WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_UNBOUND, 0);</span>
<span class="p_del">-	if (!loop_wq) {</span>
<span class="p_del">-		err = -ENOMEM;</span>
<span class="p_del">-		goto misc_out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	blk_register_region(MKDEV(LOOP_MAJOR, 0), range,
 				  THIS_MODULE, loop_probe, NULL, NULL);
 
<span class="p_chunk">@@ -1850,8 +1850,6 @@</span> <span class="p_context"> static void __exit loop_exit(void)</span>
 	blk_unregister_region(MKDEV(LOOP_MAJOR, 0), range);
 	unregister_blkdev(LOOP_MAJOR, &quot;loop&quot;);
 
<span class="p_del">-	destroy_workqueue(loop_wq);</span>
<span class="p_del">-</span>
 	misc_deregister(&amp;loop_misc);
 }
 
<span class="p_header">diff --git a/drivers/block/loop.h b/drivers/block/loop.h</span>
<span class="p_header">index 301c27f8323f..49564edf5581 100644</span>
<span class="p_header">--- a/drivers/block/loop.h</span>
<span class="p_header">+++ b/drivers/block/loop.h</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"> struct loop_device {</span>
 	gfp_t		old_gfp_mask;
 
 	spinlock_t		lo_lock;
<span class="p_add">+	struct workqueue_struct *wq;</span>
 	struct list_head	write_cmd_head;
 	struct work_struct	write_work;
 	bool			write_started;
<span class="p_header">diff --git a/drivers/block/rbd.c b/drivers/block/rbd.c</span>
<span class="p_header">index ec6c5c6e1ac9..53f253574abe 100644</span>
<span class="p_header">--- a/drivers/block/rbd.c</span>
<span class="p_header">+++ b/drivers/block/rbd.c</span>
<span class="p_chunk">@@ -2001,11 +2001,11 @@</span> <span class="p_context"> static struct rbd_obj_request *rbd_obj_request_create(const char *object_name,</span>
 	rbd_assert(obj_request_type_valid(type));
 
 	size = strlen(object_name) + 1;
<span class="p_del">-	name = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	name = kmalloc(size, GFP_NOIO);</span>
 	if (!name)
 		return NULL;
 
<span class="p_del">-	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_KERNEL);</span>
<span class="p_add">+	obj_request = kmem_cache_zalloc(rbd_obj_request_cache, GFP_NOIO);</span>
 	if (!obj_request) {
 		kfree(name);
 		return NULL;
<span class="p_header">diff --git a/drivers/bluetooth/btbcm.c b/drivers/bluetooth/btbcm.c</span>
<span class="p_header">index 4bba86677adc..3f146c9911c1 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btbcm.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btbcm.c</span>
<span class="p_chunk">@@ -378,12 +378,11 @@</span> <span class="p_context"> int btbcm_setup_apple(struct hci_dev *hdev)</span>
 
 	/* Read Verbose Config Version Info */
 	skb = btbcm_read_verbose_config(hdev);
<span class="p_del">-	if (IS_ERR(skb))</span>
<span class="p_del">-		return PTR_ERR(skb);</span>
<span class="p_del">-</span>
<span class="p_del">-	BT_INFO(&quot;%s: BCM: chip id %u build %4.4u&quot;, hdev-&gt;name, skb-&gt;data[1],</span>
<span class="p_del">-		get_unaligned_le16(skb-&gt;data + 5));</span>
<span class="p_del">-	kfree_skb(skb);</span>
<span class="p_add">+	if (!IS_ERR(skb)) {</span>
<span class="p_add">+		BT_INFO(&quot;%s: BCM: chip id %u build %4.4u&quot;, hdev-&gt;name, skb-&gt;data[1],</span>
<span class="p_add">+			get_unaligned_le16(skb-&gt;data + 5));</span>
<span class="p_add">+		kfree_skb(skb);</span>
<span class="p_add">+	}</span>
 
 	set_bit(HCI_QUIRK_STRICT_DUPLICATE_FILTER, &amp;hdev-&gt;quirks);
 
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index 420cc9f3eb76..c65501539224 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> static const struct usb_device_id blacklist_table[] = {</span>
 	{ USB_DEVICE(0x0e5e, 0x6622), .driver_info = BTUSB_BROKEN_ISOC },
 
 	/* Roper Class 1 Bluetooth Dongle (Silicon Wave based) */
<span class="p_del">-	{ USB_DEVICE(0x1300, 0x0001), .driver_info = BTUSB_SWAVE },</span>
<span class="p_add">+	{ USB_DEVICE(0x1310, 0x0001), .driver_info = BTUSB_SWAVE },</span>
 
 	/* Digianswer devices */
 	{ USB_DEVICE(0x08fd, 0x0001), .driver_info = BTUSB_DIGIANSWER },
<span class="p_chunk">@@ -1993,6 +1993,8 @@</span> <span class="p_context"> static int btusb_setup_intel(struct hci_dev *hdev)</span>
 	}
 	fw_ptr = fw-&gt;data;
 
<span class="p_add">+	kfree_skb(skb);</span>
<span class="p_add">+</span>
 	/* This Intel specific command enables the manufacturer mode of the
 	 * controller.
 	 *
<span class="p_chunk">@@ -2334,6 +2336,7 @@</span> <span class="p_context"> static int btusb_setup_intel_new(struct hci_dev *hdev)</span>
 	struct intel_boot_params *params;
 	const struct firmware *fw;
 	const u8 *fw_ptr;
<span class="p_add">+	u32 frag_len;</span>
 	char fwname[64];
 	ktime_t calltime, delta, rettime;
 	unsigned long long duration;
<span class="p_chunk">@@ -2540,24 +2543,33 @@</span> <span class="p_context"> static int btusb_setup_intel_new(struct hci_dev *hdev)</span>
 	}
 
 	fw_ptr = fw-&gt;data + 644;
<span class="p_add">+	frag_len = 0;</span>
 
 	while (fw_ptr - fw-&gt;data &lt; fw-&gt;size) {
<span class="p_del">-		struct hci_command_hdr *cmd = (void *)fw_ptr;</span>
<span class="p_del">-		u8 cmd_len;</span>
<span class="p_add">+		struct hci_command_hdr *cmd = (void *)(fw_ptr + frag_len);</span>
 
<span class="p_del">-		cmd_len = sizeof(*cmd) + cmd-&gt;plen;</span>
<span class="p_add">+		frag_len += sizeof(*cmd) + cmd-&gt;plen;</span>
 
<span class="p_del">-		/* Send each command from the firmware data buffer as</span>
<span class="p_del">-		 * a single Data fragment.</span>
<span class="p_add">+		/* The paramter length of the secure send command requires</span>
<span class="p_add">+		 * a 4 byte alignment. It happens so that the firmware file</span>
<span class="p_add">+		 * contains proper Intel_NOP commands to align the fragments</span>
<span class="p_add">+		 * as needed.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Send set of commands with 4 byte alignment from the</span>
<span class="p_add">+		 * firmware data buffer as a single Data fragement.</span>
 		 */
<span class="p_del">-		err = btusb_intel_secure_send(hdev, 0x01, cmd_len, fw_ptr);</span>
<span class="p_del">-		if (err &lt; 0) {</span>
<span class="p_del">-			BT_ERR(&quot;%s: Failed to send firmware data (%d)&quot;,</span>
<span class="p_del">-			       hdev-&gt;name, err);</span>
<span class="p_del">-			goto done;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (!(frag_len % 4)) {</span>
<span class="p_add">+			err = btusb_intel_secure_send(hdev, 0x01, frag_len,</span>
<span class="p_add">+						      fw_ptr);</span>
<span class="p_add">+			if (err &lt; 0) {</span>
<span class="p_add">+				BT_ERR(&quot;%s: Failed to send firmware data (%d)&quot;,</span>
<span class="p_add">+				       hdev-&gt;name, err);</span>
<span class="p_add">+				goto done;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		fw_ptr += cmd_len;</span>
<span class="p_add">+			fw_ptr += frag_len;</span>
<span class="p_add">+			frag_len = 0;</span>
<span class="p_add">+		}</span>
 	}
 
 	set_bit(BTUSB_FIRMWARE_LOADED, &amp;data-&gt;flags);
<span class="p_header">diff --git a/drivers/bus/arm-ccn.c b/drivers/bus/arm-ccn.c</span>
<span class="p_header">index aaa0f2a87118..60397ec77ff7 100644</span>
<span class="p_header">--- a/drivers/bus/arm-ccn.c</span>
<span class="p_header">+++ b/drivers/bus/arm-ccn.c</span>
<span class="p_chunk">@@ -212,7 +212,7 @@</span> <span class="p_context"> static int arm_ccn_node_to_xp_port(int node)</span>
 
 static void arm_ccn_pmu_config_set(u64 *config, u32 node_xp, u32 type, u32 port)
 {
<span class="p_del">-	*config &amp;= ~((0xff &lt;&lt; 0) | (0xff &lt;&lt; 8) | (0xff &lt;&lt; 24));</span>
<span class="p_add">+	*config &amp;= ~((0xff &lt;&lt; 0) | (0xff &lt;&lt; 8) | (0x3 &lt;&lt; 24));</span>
 	*config |= (node_xp &lt;&lt; 0) | (type &lt;&lt; 8) | (port &lt;&lt; 24);
 }
 
<span class="p_header">diff --git a/drivers/char/agp/intel-gtt.c b/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">index 0b4188b9af7c..c6dea3f6917b 100644</span>
<span class="p_header">--- a/drivers/char/agp/intel-gtt.c</span>
<span class="p_header">+++ b/drivers/char/agp/intel-gtt.c</span>
<span class="p_chunk">@@ -581,7 +581,7 @@</span> <span class="p_context"> static inline int needs_ilk_vtd_wa(void)</span>
 	/* Query intel_iommu to see if we need the workaround. Presumably that
 	 * was loaded first.
 	 */
<span class="p_del">-	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_HB ||</span>
<span class="p_add">+	if ((gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_D_IG ||</span>
 	     gpu_devid == PCI_DEVICE_ID_INTEL_IRONLAKE_M_IG) &amp;&amp;
 	     intel_iommu_gfx_mapped)
 		return 1;
<span class="p_header">diff --git a/drivers/char/tpm/tpm-chip.c b/drivers/char/tpm/tpm-chip.c</span>
<span class="p_header">index 283f00a7f036..1082d4bb016a 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-chip.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-chip.c</span>
<span class="p_chunk">@@ -129,8 +129,9 @@</span> <span class="p_context"> struct tpm_chip *tpmm_chip_alloc(struct device *dev,</span>
 
 	device_initialize(&amp;chip-&gt;dev);
 
<span class="p_del">-	chip-&gt;cdev.owner = chip-&gt;pdev-&gt;driver-&gt;owner;</span>
 	cdev_init(&amp;chip-&gt;cdev, &amp;tpm_fops);
<span class="p_add">+	chip-&gt;cdev.owner = chip-&gt;pdev-&gt;driver-&gt;owner;</span>
<span class="p_add">+	chip-&gt;cdev.kobj.parent = &amp;chip-&gt;dev.kobj;</span>
 
 	return chip;
 }
<span class="p_header">diff --git a/drivers/char/tpm/tpm_crb.c b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">index b26ceee3585e..1267322595da 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_crb.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_crb.c</span>
<span class="p_chunk">@@ -233,6 +233,14 @@</span> <span class="p_context"> static int crb_acpi_add(struct acpi_device *device)</span>
 		return -ENODEV;
 	}
 
<span class="p_add">+	/* At least some versions of AMI BIOS have a bug that TPM2 table has</span>
<span class="p_add">+	 * zero address for the control area and therefore we must fail.</span>
<span class="p_add">+	*/</span>
<span class="p_add">+	if (!buf-&gt;control_area_pa) {</span>
<span class="p_add">+		dev_err(dev, &quot;TPM2 ACPI table has a zero address for the control area\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (buf-&gt;hdr.length &lt; sizeof(struct acpi_tpm2)) {
 		dev_err(dev, &quot;TPM2 ACPI table has wrong size&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -267,7 +275,7 @@</span> <span class="p_context"> static int crb_acpi_add(struct acpi_device *device)</span>
 
 	memcpy_fromio(&amp;pa, &amp;priv-&gt;cca-&gt;cmd_pa, 8);
 	pa = le64_to_cpu(pa);
<span class="p_del">-	priv-&gt;cmd = devm_ioremap_nocache(dev, le64_to_cpu(pa),</span>
<span class="p_add">+	priv-&gt;cmd = devm_ioremap_nocache(dev, pa,</span>
 					 ioread32(&amp;priv-&gt;cca-&gt;cmd_size));
 	if (!priv-&gt;cmd) {
 		dev_err(dev, &quot;ioremap of the command buffer failed\n&quot;);
<span class="p_chunk">@@ -276,7 +284,7 @@</span> <span class="p_context"> static int crb_acpi_add(struct acpi_device *device)</span>
 
 	memcpy_fromio(&amp;pa, &amp;priv-&gt;cca-&gt;rsp_pa, 8);
 	pa = le64_to_cpu(pa);
<span class="p_del">-	priv-&gt;rsp = devm_ioremap_nocache(dev, le64_to_cpu(pa),</span>
<span class="p_add">+	priv-&gt;rsp = devm_ioremap_nocache(dev, pa,</span>
 					 ioread32(&amp;priv-&gt;cca-&gt;rsp_size));
 	if (!priv-&gt;rsp) {
 		dev_err(dev, &quot;ioremap of the response buffer failed\n&quot;);
<span class="p_header">diff --git a/drivers/char/tpm/tpm_ibmvtpm.c b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">index 42ffa5e7a1e0..27ebf9511cb4 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_ibmvtpm.c</span>
<span class="p_chunk">@@ -578,6 +578,9 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	ibmvtpm-&gt;dev = dev;</span>
<span class="p_add">+	ibmvtpm-&gt;vdev = vio_dev;</span>
<span class="p_add">+</span>
 	crq_q = &amp;ibmvtpm-&gt;crq_queue;
 	crq_q-&gt;crq_addr = (struct ibmvtpm_crq *)get_zeroed_page(GFP_KERNEL);
 	if (!crq_q-&gt;crq_addr) {
<span class="p_chunk">@@ -622,8 +625,6 @@</span> <span class="p_context"> static int tpm_ibmvtpm_probe(struct vio_dev *vio_dev,</span>
 
 	crq_q-&gt;index = 0;
 
<span class="p_del">-	ibmvtpm-&gt;dev = dev;</span>
<span class="p_del">-	ibmvtpm-&gt;vdev = vio_dev;</span>
 	TPM_VPRIV(chip) = (void *)ibmvtpm;
 
 	spin_lock_init(&amp;ibmvtpm-&gt;rtce_lock);
<span class="p_header">diff --git a/drivers/clk/clk.c b/drivers/clk/clk.c</span>
<span class="p_header">index 5b0f41868b42..9f9cadd00bc8 100644</span>
<span class="p_header">--- a/drivers/clk/clk.c</span>
<span class="p_header">+++ b/drivers/clk/clk.c</span>
<span class="p_chunk">@@ -230,11 +230,12 @@</span> <span class="p_context"> static void clk_dump_one(struct seq_file *s, struct clk_core *c, int level)</span>
 	if (!c)
 		return;
 
<span class="p_add">+	/* This should be JSON format, i.e. elements separated with a comma */</span>
 	seq_printf(s, &quot;\&quot;%s\&quot;: { &quot;, c-&gt;name);
 	seq_printf(s, &quot;\&quot;enable_count\&quot;: %d,&quot;, c-&gt;enable_count);
 	seq_printf(s, &quot;\&quot;prepare_count\&quot;: %d,&quot;, c-&gt;prepare_count);
<span class="p_del">-	seq_printf(s, &quot;\&quot;rate\&quot;: %lu&quot;, clk_core_get_rate(c));</span>
<span class="p_del">-	seq_printf(s, &quot;\&quot;accuracy\&quot;: %lu&quot;, clk_core_get_accuracy(c));</span>
<span class="p_add">+	seq_printf(s, &quot;\&quot;rate\&quot;: %lu,&quot;, clk_core_get_rate(c));</span>
<span class="p_add">+	seq_printf(s, &quot;\&quot;accuracy\&quot;: %lu,&quot;, clk_core_get_accuracy(c));</span>
 	seq_printf(s, &quot;\&quot;phase\&quot;: %d&quot;, clk_core_get_phase(c));
 }
 
<span class="p_header">diff --git a/drivers/clk/qcom/clk-rcg2.c b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">index b95d17fbb8d7..92936f0912d2 100644</span>
<span class="p_header">--- a/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_header">+++ b/drivers/clk/qcom/clk-rcg2.c</span>
<span class="p_chunk">@@ -530,19 +530,16 @@</span> <span class="p_context"> static int clk_pixel_set_rate(struct clk_hw *hw, unsigned long rate,</span>
 	struct clk_rcg2 *rcg = to_clk_rcg2(hw);
 	struct freq_tbl f = *rcg-&gt;freq_tbl;
 	const struct frac_entry *frac = frac_table_pixel;
<span class="p_del">-	unsigned long request, src_rate;</span>
<span class="p_add">+	unsigned long request;</span>
 	int delta = 100000;
 	u32 mask = BIT(rcg-&gt;hid_width) - 1;
 	u32 hid_div;
<span class="p_del">-	int index = qcom_find_src_index(hw, rcg-&gt;parent_map, f.src);</span>
<span class="p_del">-	struct clk *parent = clk_get_parent_by_index(hw-&gt;clk, index);</span>
 
 	for (; frac-&gt;num; frac++) {
 		request = (rate * frac-&gt;den) / frac-&gt;num;
 
<span class="p_del">-		src_rate = __clk_round_rate(parent, request);</span>
<span class="p_del">-		if ((src_rate &lt; (request - delta)) ||</span>
<span class="p_del">-			(src_rate &gt; (request + delta)))</span>
<span class="p_add">+		if ((parent_rate &lt; (request - delta)) ||</span>
<span class="p_add">+			(parent_rate &gt; (request + delta)))</span>
 			continue;
 
 		regmap_read(rcg-&gt;clkr.regmap, rcg-&gt;cmd_rcgr + CFG_REG,
<span class="p_header">diff --git a/drivers/clk/ti/clk-dra7-atl.c b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">index d86bc46b93bd..0a1df821860f 100644</span>
<span class="p_header">--- a/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_header">+++ b/drivers/clk/ti/clk-dra7-atl.c</span>
<span class="p_chunk">@@ -252,6 +252,11 @@</span> <span class="p_context"> static int of_dra7_atl_clk_probe(struct platform_device *pdev)</span>
 		}
 
 		clk = of_clk_get_from_provider(&amp;clkspec);
<span class="p_add">+		if (IS_ERR(clk)) {</span>
<span class="p_add">+			pr_err(&quot;%s: failed to get atl clock %d from provider\n&quot;,</span>
<span class="p_add">+			       __func__, i);</span>
<span class="p_add">+			return PTR_ERR(clk);</span>
<span class="p_add">+		}</span>
 
 		cdesc = to_atl_desc(__clk_get_hw(clk));
 		cdesc-&gt;cinfo = cinfo;
<span class="p_header">diff --git a/drivers/clocksource/exynos_mct.c b/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">index 83564c9cfdbe..c844616028d2 100644</span>
<span class="p_header">--- a/drivers/clocksource/exynos_mct.c</span>
<span class="p_header">+++ b/drivers/clocksource/exynos_mct.c</span>
<span class="p_chunk">@@ -466,15 +466,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 	exynos4_mct_write(TICK_BASE_CNT, mevt-&gt;base + MCT_L_TCNTB_OFFSET);
 
 	if (mct_int_type == MCT_INT_SPI) {
<span class="p_del">-		evt-&gt;irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_del">-		if (request_irq(evt-&gt;irq, exynos4_mct_tick_isr,</span>
<span class="p_del">-				IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_del">-				evt-&gt;name, mevt)) {</span>
<span class="p_del">-			pr_err(&quot;exynos-mct: cannot register IRQ %d\n&quot;,</span>
<span class="p_del">-				evt-&gt;irq);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (evt-&gt;irq == -1)</span>
 			return -EIO;
<span class="p_del">-		}</span>
<span class="p_del">-		irq_force_affinity(mct_irqs[MCT_L0_IRQ + cpu], cpumask_of(cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+		irq_force_affinity(evt-&gt;irq, cpumask_of(cpu));</span>
<span class="p_add">+		enable_irq(evt-&gt;irq);</span>
 	} else {
 		enable_percpu_irq(mct_irqs[MCT_L0_IRQ], 0);
 	}
<span class="p_chunk">@@ -487,10 +484,12 @@</span> <span class="p_context"> static int exynos4_local_timer_setup(struct clock_event_device *evt)</span>
 static void exynos4_local_timer_stop(struct clock_event_device *evt)
 {
 	evt-&gt;set_mode(CLOCK_EVT_MODE_UNUSED, evt);
<span class="p_del">-	if (mct_int_type == MCT_INT_SPI)</span>
<span class="p_del">-		free_irq(evt-&gt;irq, this_cpu_ptr(&amp;percpu_mct_tick));</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (mct_int_type == MCT_INT_SPI) {</span>
<span class="p_add">+		if (evt-&gt;irq != -1)</span>
<span class="p_add">+			disable_irq_nosync(evt-&gt;irq);</span>
<span class="p_add">+	} else {</span>
 		disable_percpu_irq(mct_irqs[MCT_L0_IRQ]);
<span class="p_add">+	}</span>
 }
 
 static int exynos4_mct_cpu_notify(struct notifier_block *self,
<span class="p_chunk">@@ -522,7 +521,7 @@</span> <span class="p_context"> static struct notifier_block exynos4_mct_cpu_nb = {</span>
 
 static void __init exynos4_timer_resources(struct device_node *np, void __iomem *base)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err, cpu;</span>
 	struct mct_clock_event_device *mevt = this_cpu_ptr(&amp;percpu_mct_tick);
 	struct clk *mct_clk, *tick_clk;
 
<span class="p_chunk">@@ -549,7 +548,25 @@</span> <span class="p_context"> static void __init exynos4_timer_resources(struct device_node *np, void __iomem</span>
 		WARN(err, &quot;MCT: can&#39;t request IRQ %d (%d)\n&quot;,
 		     mct_irqs[MCT_L0_IRQ], err);
 	} else {
<span class="p_del">-		irq_set_affinity(mct_irqs[MCT_L0_IRQ], cpumask_of(0));</span>
<span class="p_add">+		for_each_possible_cpu(cpu) {</span>
<span class="p_add">+			int mct_irq = mct_irqs[MCT_L0_IRQ + cpu];</span>
<span class="p_add">+			struct mct_clock_event_device *pcpu_mevt =</span>
<span class="p_add">+				per_cpu_ptr(&amp;percpu_mct_tick, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = -1;</span>
<span class="p_add">+</span>
<span class="p_add">+			irq_set_status_flags(mct_irq, IRQ_NOAUTOEN);</span>
<span class="p_add">+			if (request_irq(mct_irq,</span>
<span class="p_add">+					exynos4_mct_tick_isr,</span>
<span class="p_add">+					IRQF_TIMER | IRQF_NOBALANCING,</span>
<span class="p_add">+					pcpu_mevt-&gt;name, pcpu_mevt)) {</span>
<span class="p_add">+				pr_err(&quot;exynos-mct: cannot register IRQ (cpu%d)\n&quot;,</span>
<span class="p_add">+									cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			pcpu_mevt-&gt;evt.irq = mct_irq;</span>
<span class="p_add">+		}</span>
 	}
 
 	err = register_cpu_notifier(&amp;exynos4_mct_cpu_nb);
<span class="p_header">diff --git a/drivers/dma/mv_xor.c b/drivers/dma/mv_xor.c</span>
<span class="p_header">index 1c56001df676..50f1b422dee3 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.c</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.c</span>
<span class="p_chunk">@@ -273,7 +273,8 @@</span> <span class="p_context"> static void mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 	dma_cookie_t cookie = 0;
 	int busy = mv_chan_is_busy(mv_chan);
 	u32 current_desc = mv_chan_get_current_desc(mv_chan);
<span class="p_del">-	int seen_current = 0;</span>
<span class="p_add">+	int current_cleaned = 0;</span>
<span class="p_add">+	struct mv_xor_desc *hw_desc;</span>
 
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;%s %d\n&quot;, __func__, __LINE__);
 	dev_dbg(mv_chan_to_devp(mv_chan), &quot;current_desc %x\n&quot;, current_desc);
<span class="p_chunk">@@ -285,38 +286,57 @@</span> <span class="p_context"> static void mv_xor_slot_cleanup(struct mv_xor_chan *mv_chan)</span>
 
 	list_for_each_entry_safe(iter, _iter, &amp;mv_chan-&gt;chain,
 					chain_node) {
<span class="p_del">-		prefetch(_iter);</span>
<span class="p_del">-		prefetch(&amp;_iter-&gt;async_tx);</span>
 
<span class="p_del">-		/* do not advance past the current descriptor loaded into the</span>
<span class="p_del">-		 * hardware channel, subsequent descriptors are either in</span>
<span class="p_del">-		 * process or have not been submitted</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (seen_current)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+		/* clean finished descriptors */</span>
<span class="p_add">+		hw_desc = iter-&gt;hw_desc;</span>
<span class="p_add">+		if (hw_desc-&gt;status &amp; XOR_DESC_SUCCESS) {</span>
<span class="p_add">+			cookie = mv_xor_run_tx_complete_actions(iter, mv_chan,</span>
<span class="p_add">+								cookie);</span>
 
<span class="p_del">-		/* stop the search if we reach the current descriptor and the</span>
<span class="p_del">-		 * channel is busy</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_del">-			seen_current = 1;</span>
<span class="p_del">-			if (busy)</span>
<span class="p_add">+			/* done processing desc, clean slot */</span>
<span class="p_add">+			mv_xor_clean_slot(iter, mv_chan);</span>
<span class="p_add">+</span>
<span class="p_add">+			/* break if we did cleaned the current */</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 1;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (iter-&gt;async_tx.phys == current_desc) {</span>
<span class="p_add">+				current_cleaned = 0;</span>
 				break;
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		cookie = mv_xor_run_tx_complete_actions(iter, mv_chan, cookie);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mv_xor_clean_slot(iter, mv_chan))</span>
<span class="p_del">-			break;</span>
 	}
 
 	if ((busy == 0) &amp;&amp; !list_empty(&amp;mv_chan-&gt;chain)) {
<span class="p_del">-		struct mv_xor_desc_slot *chain_head;</span>
<span class="p_del">-		chain_head = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_del">-					struct mv_xor_desc_slot,</span>
<span class="p_del">-					chain_node);</span>
<span class="p_del">-</span>
<span class="p_del">-		mv_xor_start_new_chain(mv_chan, chain_head);</span>
<span class="p_add">+		if (current_cleaned) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * current descriptor cleaned and removed, run</span>
<span class="p_add">+			 * from list head</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			iter = list_entry(mv_chan-&gt;chain.next,</span>
<span class="p_add">+					  struct mv_xor_desc_slot,</span>
<span class="p_add">+					  chain_node);</span>
<span class="p_add">+			mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (!list_is_last(&amp;iter-&gt;chain_node, &amp;mv_chan-&gt;chain)) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * descriptors are still waiting after</span>
<span class="p_add">+				 * current, trigger them</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				iter = list_entry(iter-&gt;chain_node.next,</span>
<span class="p_add">+						  struct mv_xor_desc_slot,</span>
<span class="p_add">+						  chain_node);</span>
<span class="p_add">+				mv_xor_start_new_chain(mv_chan, iter);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * some descriptors are still waiting</span>
<span class="p_add">+				 * to be cleaned</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				tasklet_schedule(&amp;mv_chan-&gt;irq_tasklet);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 
 	if (cookie &gt; 0)
<span class="p_header">diff --git a/drivers/dma/mv_xor.h b/drivers/dma/mv_xor.h</span>
<span class="p_header">index 91958dba39a2..0e302b3a33ad 100644</span>
<span class="p_header">--- a/drivers/dma/mv_xor.h</span>
<span class="p_header">+++ b/drivers/dma/mv_xor.h</span>
<span class="p_chunk">@@ -31,6 +31,7 @@</span> <span class="p_context"></span>
 #define XOR_OPERATION_MODE_XOR		0
 #define XOR_OPERATION_MODE_MEMCPY	2
 #define XOR_DESCRIPTOR_SWAP		BIT(14)
<span class="p_add">+#define XOR_DESC_SUCCESS		0x40000000</span>
 
 #define XOR_DESC_DMA_OWNED		BIT(31)
 #define XOR_DESC_EOD_INT_EN		BIT(31)
<span class="p_header">diff --git a/drivers/edac/octeon_edac-l2c.c b/drivers/edac/octeon_edac-l2c.c</span>
<span class="p_header">index 7e98084d3645..afea7fc625cc 100644</span>
<span class="p_header">--- a/drivers/edac/octeon_edac-l2c.c</span>
<span class="p_header">+++ b/drivers/edac/octeon_edac-l2c.c</span>
<span class="p_chunk">@@ -151,7 +151,7 @@</span> <span class="p_context"> static int octeon_l2c_probe(struct platform_device *pdev)</span>
 	l2c-&gt;ctl_name = &quot;octeon_l2c_err&quot;;
 
 
<span class="p_del">-	if (OCTEON_IS_MODEL(OCTEON_FAM_1_PLUS)) {</span>
<span class="p_add">+	if (OCTEON_IS_OCTEON1PLUS()) {</span>
 		union cvmx_l2t_err l2t_err;
 		union cvmx_l2d_err l2d_err;
 
<span class="p_header">diff --git a/drivers/edac/octeon_edac-lmc.c b/drivers/edac/octeon_edac-lmc.c</span>
<span class="p_header">index bb19e0732681..cda6dab5067a 100644</span>
<span class="p_header">--- a/drivers/edac/octeon_edac-lmc.c</span>
<span class="p_header">+++ b/drivers/edac/octeon_edac-lmc.c</span>
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> static int octeon_lmc_edac_probe(struct platform_device *pdev)</span>
 	layers[0].size = 1;
 	layers[0].is_virt_csrow = false;
 
<span class="p_del">-	if (OCTEON_IS_MODEL(OCTEON_FAM_1_PLUS)) {</span>
<span class="p_add">+	if (OCTEON_IS_OCTEON1PLUS()) {</span>
 		union cvmx_lmcx_mem_cfg0 cfg0;
 
 		cfg0.u64 = cvmx_read_csr(CVMX_LMCX_MEM_CFG0(0));
<span class="p_header">diff --git a/drivers/edac/octeon_edac-pc.c b/drivers/edac/octeon_edac-pc.c</span>
<span class="p_header">index 0f83c33a7d1f..2ab6cf24c959 100644</span>
<span class="p_header">--- a/drivers/edac/octeon_edac-pc.c</span>
<span class="p_header">+++ b/drivers/edac/octeon_edac-pc.c</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> static int  co_cache_error_event(struct notifier_block *this,</span>
 			edac_device_handle_ce(p-&gt;ed, cpu, 0, &quot;dcache&quot;);
 
 		/* Clear the error indication */
<span class="p_del">-		if (OCTEON_IS_MODEL(OCTEON_FAM_2))</span>
<span class="p_add">+		if (OCTEON_IS_OCTEON2())</span>
 			write_octeon_c0_dcacheerr(1);
 		else
 			write_octeon_c0_dcacheerr(0);
<span class="p_header">diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c</span>
<span class="p_header">index 97b1616aa391..bba843c2b0ac 100644</span>
<span class="p_header">--- a/drivers/firmware/dmi_scan.c</span>
<span class="p_header">+++ b/drivers/firmware/dmi_scan.c</span>
<span class="p_chunk">@@ -89,9 +89,9 @@</span> <span class="p_context"> static void dmi_table(u8 *buf,</span>
 
 	/*
 	 * Stop when we have seen all the items the table claimed to have
<span class="p_del">-	 * (SMBIOS &lt; 3.0 only) OR we reach an end-of-table marker OR we run</span>
<span class="p_del">-	 * off the end of the table (should never happen but sometimes does</span>
<span class="p_del">-	 * on bogus implementations.)</span>
<span class="p_add">+	 * (SMBIOS &lt; 3.0 only) OR we reach an end-of-table marker (SMBIOS</span>
<span class="p_add">+	 * &gt;= 3.0 only) OR we run off the end of the table (should never</span>
<span class="p_add">+	 * happen but sometimes does on bogus implementations.)</span>
 	 */
 	while ((!dmi_num || i &lt; dmi_num) &amp;&amp;
 	       (data - buf + sizeof(struct dmi_header)) &lt;= dmi_len) {
<span class="p_chunk">@@ -110,8 +110,13 @@</span> <span class="p_context"> static void dmi_table(u8 *buf,</span>
 
 		/*
 		 * 7.45 End-of-Table (Type 127) [SMBIOS reference spec v3.0.0]
<span class="p_add">+		 * For tables behind a 64-bit entry point, we have no item</span>
<span class="p_add">+		 * count and no exact table length, so stop on end-of-table</span>
<span class="p_add">+		 * marker. For tables behind a 32-bit entry point, we have</span>
<span class="p_add">+		 * seen OEM structures behind the end-of-table marker on</span>
<span class="p_add">+		 * some systems, so don&#39;t trust it.</span>
 		 */
<span class="p_del">-		if (dm-&gt;type == DMI_ENTRY_END_OF_TABLE)</span>
<span class="p_add">+		if (!dmi_num &amp;&amp; dm-&gt;type == DMI_ENTRY_END_OF_TABLE)</span>
 			break;
 
 		data += 2;
<span class="p_header">diff --git a/drivers/gpu/drm/bridge/ptn3460.c b/drivers/gpu/drm/bridge/ptn3460.c</span>
<span class="p_header">index 9d2f053382e1..63a09e4079f3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/bridge/ptn3460.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/bridge/ptn3460.c</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/delay.h&gt;
 #include &lt;linux/gpio.h&gt;
<span class="p_add">+#include &lt;linux/gpio/consumer.h&gt;</span>
 #include &lt;linux/i2c.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/of.h&gt;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index 3007b44e6bf4..800a025dd062 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -2749,8 +2749,11 @@</span> <span class="p_context"> int drm_mode_setcrtc(struct drm_device *dev, void *data,</span>
 	if (!drm_core_check_feature(dev, DRIVER_MODESET))
 		return -EINVAL;
 
<span class="p_del">-	/* For some reason crtc x/y offsets are signed internally. */</span>
<span class="p_del">-	if (crtc_req-&gt;x &gt; INT_MAX || crtc_req-&gt;y &gt; INT_MAX)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Universal plane src offsets are only 16.16, prevent havoc for</span>
<span class="p_add">+	 * drivers using universal plane code internally.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (crtc_req-&gt;x &amp; 0xffff0000 || crtc_req-&gt;y &amp; 0xffff0000)</span>
 		return -ERANGE;
 
 	drm_modeset_lock_all(dev);
<span class="p_chunk">@@ -5048,12 +5051,9 @@</span> <span class="p_context"> void drm_mode_config_reset(struct drm_device *dev)</span>
 		if (encoder-&gt;funcs-&gt;reset)
 			encoder-&gt;funcs-&gt;reset(encoder);
 
<span class="p_del">-	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head) {</span>
<span class="p_del">-		connector-&gt;status = connector_status_unknown;</span>
<span class="p_del">-</span>
<span class="p_add">+	list_for_each_entry(connector, &amp;dev-&gt;mode_config.connector_list, head)</span>
 		if (connector-&gt;funcs-&gt;reset)
 			connector-&gt;funcs-&gt;reset(connector);
<span class="p_del">-	}</span>
 }
 EXPORT_SYMBOL(drm_mode_config_reset);
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_dp_mst_topology.c b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">index 132581ca4ad8..778bbb6425b8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_dp_mst_topology.c</span>
<span class="p_chunk">@@ -867,8 +867,16 @@</span> <span class="p_context"> static void drm_dp_destroy_port(struct kref *kref)</span>
 		port-&gt;vcpi.num_slots = 0;
 
 		kfree(port-&gt;cached_edid);
<span class="p_del">-		if (port-&gt;connector)</span>
<span class="p_del">-			(*port-&gt;mgr-&gt;cbs-&gt;destroy_connector)(mgr, port-&gt;connector);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* we can&#39;t destroy the connector here, as</span>
<span class="p_add">+		   we might be holding the mode_config.mutex</span>
<span class="p_add">+		   from an EDID retrieval */</span>
<span class="p_add">+		if (port-&gt;connector) {</span>
<span class="p_add">+			mutex_lock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+			list_add(&amp;port-&gt;connector-&gt;destroy_list, &amp;mgr-&gt;destroy_connector_list);</span>
<span class="p_add">+			mutex_unlock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+			schedule_work(&amp;mgr-&gt;destroy_connector_work);</span>
<span class="p_add">+		}</span>
 		drm_dp_port_teardown_pdt(port, port-&gt;pdt);
 
 		if (!port-&gt;input &amp;&amp; port-&gt;vcpi.vcpi &gt; 0)
<span class="p_chunk">@@ -1163,6 +1171,8 @@</span> <span class="p_context"> static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_</span>
 	struct drm_dp_mst_port *port;
 	int i;
 	/* find the port by iterating down */
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;mgr-&gt;lock);</span>
 	mstb = mgr-&gt;mst_primary;
 
 	for (i = 0; i &lt; lct - 1; i++) {
<span class="p_chunk">@@ -1182,6 +1192,7 @@</span> <span class="p_context"> static struct drm_dp_mst_branch *drm_dp_get_mst_branch_device(struct drm_dp_mst_</span>
 		}
 	}
 	kref_get(&amp;mstb-&gt;kref);
<span class="p_add">+	mutex_unlock(&amp;mgr-&gt;lock);</span>
 	return mstb;
 }
 
<span class="p_chunk">@@ -1189,7 +1200,7 @@</span> <span class="p_context"> static void drm_dp_check_and_send_link_address(struct drm_dp_mst_topology_mgr *m</span>
 					       struct drm_dp_mst_branch *mstb)
 {
 	struct drm_dp_mst_port *port;
<span class="p_del">-</span>
<span class="p_add">+	struct drm_dp_mst_branch *mstb_child;</span>
 	if (!mstb-&gt;link_address_sent) {
 		drm_dp_send_link_address(mgr, mstb);
 		mstb-&gt;link_address_sent = true;
<span class="p_chunk">@@ -1204,17 +1215,31 @@</span> <span class="p_context"> static void drm_dp_check_and_send_link_address(struct drm_dp_mst_topology_mgr *m</span>
 		if (!port-&gt;available_pbn)
 			drm_dp_send_enum_path_resources(mgr, mstb, port);
 
<span class="p_del">-		if (port-&gt;mstb)</span>
<span class="p_del">-			drm_dp_check_and_send_link_address(mgr, port-&gt;mstb);</span>
<span class="p_add">+		if (port-&gt;mstb) {</span>
<span class="p_add">+			mstb_child = drm_dp_get_validated_mstb_ref(mgr, port-&gt;mstb);</span>
<span class="p_add">+			if (mstb_child) {</span>
<span class="p_add">+				drm_dp_check_and_send_link_address(mgr, mstb_child);</span>
<span class="p_add">+				drm_dp_put_mst_branch_device(mstb_child);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
 	}
 }
 
 static void drm_dp_mst_link_probe_work(struct work_struct *work)
 {
 	struct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, work);
<span class="p_add">+	struct drm_dp_mst_branch *mstb;</span>
 
<span class="p_del">-	drm_dp_check_and_send_link_address(mgr, mgr-&gt;mst_primary);</span>
<span class="p_del">-</span>
<span class="p_add">+	mutex_lock(&amp;mgr-&gt;lock);</span>
<span class="p_add">+	mstb = mgr-&gt;mst_primary;</span>
<span class="p_add">+	if (mstb) {</span>
<span class="p_add">+		kref_get(&amp;mstb-&gt;kref);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;mgr-&gt;lock);</span>
<span class="p_add">+	if (mstb) {</span>
<span class="p_add">+		drm_dp_check_and_send_link_address(mgr, mstb);</span>
<span class="p_add">+		drm_dp_put_mst_branch_device(mstb);</span>
<span class="p_add">+	}</span>
 }
 
 static bool drm_dp_validate_guid(struct drm_dp_mst_topology_mgr *mgr,
<span class="p_chunk">@@ -2632,6 +2657,30 @@</span> <span class="p_context"> static void drm_dp_tx_work(struct work_struct *work)</span>
 	mutex_unlock(&amp;mgr-&gt;qlock);
 }
 
<span class="p_add">+static void drm_dp_destroy_connector_work(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_dp_mst_topology_mgr *mgr = container_of(work, struct drm_dp_mst_topology_mgr, destroy_connector_work);</span>
<span class="p_add">+	struct drm_connector *connector;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Not a regular list traverse as we have to drop the destroy</span>
<span class="p_add">+	 * connector lock before destroying the connector, to avoid AB-&gt;BA</span>
<span class="p_add">+	 * ordering between this lock and the config mutex.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (;;) {</span>
<span class="p_add">+		mutex_lock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+		connector = list_first_entry_or_null(&amp;mgr-&gt;destroy_connector_list, struct drm_connector, destroy_list);</span>
<span class="p_add">+		if (!connector) {</span>
<span class="p_add">+			mutex_unlock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		list_del(&amp;connector-&gt;destroy_list);</span>
<span class="p_add">+		mutex_unlock(&amp;mgr-&gt;destroy_connector_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		mgr-&gt;cbs-&gt;destroy_connector(mgr, connector);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * drm_dp_mst_topology_mgr_init - initialise a topology manager
  * @mgr: manager struct to initialise
<span class="p_chunk">@@ -2651,10 +2700,13 @@</span> <span class="p_context"> int drm_dp_mst_topology_mgr_init(struct drm_dp_mst_topology_mgr *mgr,</span>
 	mutex_init(&amp;mgr-&gt;lock);
 	mutex_init(&amp;mgr-&gt;qlock);
 	mutex_init(&amp;mgr-&gt;payload_lock);
<span class="p_add">+	mutex_init(&amp;mgr-&gt;destroy_connector_lock);</span>
 	INIT_LIST_HEAD(&amp;mgr-&gt;tx_msg_upq);
 	INIT_LIST_HEAD(&amp;mgr-&gt;tx_msg_downq);
<span class="p_add">+	INIT_LIST_HEAD(&amp;mgr-&gt;destroy_connector_list);</span>
 	INIT_WORK(&amp;mgr-&gt;work, drm_dp_mst_link_probe_work);
 	INIT_WORK(&amp;mgr-&gt;tx_work, drm_dp_tx_work);
<span class="p_add">+	INIT_WORK(&amp;mgr-&gt;destroy_connector_work, drm_dp_destroy_connector_work);</span>
 	init_waitqueue_head(&amp;mgr-&gt;tx_waitq);
 	mgr-&gt;dev = dev;
 	mgr-&gt;aux = aux;
<span class="p_chunk">@@ -2679,6 +2731,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(drm_dp_mst_topology_mgr_init);</span>
  */
 void drm_dp_mst_topology_mgr_destroy(struct drm_dp_mst_topology_mgr *mgr)
 {
<span class="p_add">+	flush_work(&amp;mgr-&gt;destroy_connector_work);</span>
 	mutex_lock(&amp;mgr-&gt;payload_lock);
 	kfree(mgr-&gt;payloads);
 	mgr-&gt;payloads = NULL;
<span class="p_header">diff --git a/drivers/gpu/drm/drm_ioc32.c b/drivers/gpu/drm/drm_ioc32.c</span>
<span class="p_header">index aa8bbb460c57..9cfcd0aef0df 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_ioc32.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_ioc32.c</span>
<span class="p_chunk">@@ -70,6 +70,8 @@</span> <span class="p_context"></span>
 
 #define DRM_IOCTL_WAIT_VBLANK32		DRM_IOWR(0x3a, drm_wait_vblank32_t)
 
<span class="p_add">+#define DRM_IOCTL_MODE_ADDFB232		DRM_IOWR(0xb8, drm_mode_fb_cmd232_t)</span>
<span class="p_add">+</span>
 typedef struct drm_version_32 {
 	int version_major;	  /**&lt; Major version */
 	int version_minor;	  /**&lt; Minor version */
<span class="p_chunk">@@ -1016,6 +1018,63 @@</span> <span class="p_context"> static int compat_drm_wait_vblank(struct file *file, unsigned int cmd,</span>
 	return 0;
 }
 
<span class="p_add">+typedef struct drm_mode_fb_cmd232 {</span>
<span class="p_add">+	u32 fb_id;</span>
<span class="p_add">+	u32 width;</span>
<span class="p_add">+	u32 height;</span>
<span class="p_add">+	u32 pixel_format;</span>
<span class="p_add">+	u32 flags;</span>
<span class="p_add">+	u32 handles[4];</span>
<span class="p_add">+	u32 pitches[4];</span>
<span class="p_add">+	u32 offsets[4];</span>
<span class="p_add">+	u64 modifier[4];</span>
<span class="p_add">+} __attribute__((packed)) drm_mode_fb_cmd232_t;</span>
<span class="p_add">+</span>
<span class="p_add">+static int compat_drm_mode_addfb2(struct file *file, unsigned int cmd,</span>
<span class="p_add">+				  unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_mode_fb_cmd232 __user *argp = (void __user *)arg;</span>
<span class="p_add">+	struct drm_mode_fb_cmd232 req32;</span>
<span class="p_add">+	struct drm_mode_fb_cmd2 __user *req64;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(&amp;req32, argp, sizeof(req32)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	req64 = compat_alloc_user_space(sizeof(*req64));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!access_ok(VERIFY_WRITE, req64, sizeof(*req64))</span>
<span class="p_add">+	    || __put_user(req32.width, &amp;req64-&gt;width)</span>
<span class="p_add">+	    || __put_user(req32.height, &amp;req64-&gt;height)</span>
<span class="p_add">+	    || __put_user(req32.pixel_format, &amp;req64-&gt;pixel_format)</span>
<span class="p_add">+	    || __put_user(req32.flags, &amp;req64-&gt;flags))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 4; i++) {</span>
<span class="p_add">+		if (__put_user(req32.handles[i], &amp;req64-&gt;handles[i]))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (__put_user(req32.pitches[i], &amp;req64-&gt;pitches[i]))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (__put_user(req32.offsets[i], &amp;req64-&gt;offsets[i]))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		if (__put_user(req32.modifier[i], &amp;req64-&gt;modifier[i]))</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	err = drm_ioctl(file, DRM_IOCTL_MODE_ADDFB2, (unsigned long)req64);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__get_user(req32.fb_id, &amp;req64-&gt;fb_id))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_to_user(argp, &amp;req32, sizeof(req32)))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static drm_ioctl_compat_t *drm_compat_ioctls[] = {
 	[DRM_IOCTL_NR(DRM_IOCTL_VERSION32)] = compat_drm_version,
 	[DRM_IOCTL_NR(DRM_IOCTL_GET_UNIQUE32)] = compat_drm_getunique,
<span class="p_chunk">@@ -1048,6 +1107,7 @@</span> <span class="p_context"> static drm_ioctl_compat_t *drm_compat_ioctls[] = {</span>
 	[DRM_IOCTL_NR(DRM_IOCTL_UPDATE_DRAW32)] = compat_drm_update_draw,
 #endif
 	[DRM_IOCTL_NR(DRM_IOCTL_WAIT_VBLANK32)] = compat_drm_wait_vblank,
<span class="p_add">+	[DRM_IOCTL_NR(DRM_IOCTL_MODE_ADDFB232)] = compat_drm_mode_addfb2,</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem.c b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">index 2d0995e7afc3..596bce56e379 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem.c</span>
<span class="p_chunk">@@ -2401,6 +2401,7 @@</span> <span class="p_context"> int __i915_add_request(struct intel_engine_cs *ring,</span>
 	}
 
 	request-&gt;emitted_jiffies = jiffies;
<span class="p_add">+	ring-&gt;last_submitted_seqno = request-&gt;seqno;</span>
 	list_add_tail(&amp;request-&gt;list, &amp;ring-&gt;request_list);
 	request-&gt;file_priv = NULL;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_gtt.c b/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_header">index 0239fbff7bf7..ad90fa3045e5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_chunk">@@ -502,17 +502,17 @@</span> <span class="p_context"> static void gen8_ppgtt_clear_range(struct i915_address_space *vm,</span>
 		struct page *page_table;
 
 		if (WARN_ON(!ppgtt-&gt;pdp.page_directory[pdpe]))
<span class="p_del">-			continue;</span>
<span class="p_add">+			break;</span>
 
 		pd = ppgtt-&gt;pdp.page_directory[pdpe];
 
 		if (WARN_ON(!pd-&gt;page_table[pde]))
<span class="p_del">-			continue;</span>
<span class="p_add">+			break;</span>
 
 		pt = pd-&gt;page_table[pde];
 
 		if (WARN_ON(!pt-&gt;page))
<span class="p_del">-			continue;</span>
<span class="p_add">+			break;</span>
 
 		page_table = pt-&gt;page;
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_ioc32.c b/drivers/gpu/drm/i915/i915_ioc32.c</span>
<span class="p_header">index 176de6322e4d..23aa04cded6b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_ioc32.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_ioc32.c</span>
<span class="p_chunk">@@ -204,7 +204,7 @@</span> <span class="p_context"> long i915_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span>
 	drm_ioctl_compat_t *fn = NULL;
 	int ret;
 
<span class="p_del">-	if (nr &lt; DRM_COMMAND_BASE)</span>
<span class="p_add">+	if (nr &lt; DRM_COMMAND_BASE || nr &gt;= DRM_COMMAND_END)</span>
 		return drm_compat_ioctl(filp, cmd, arg);
 
 	if (nr &lt; DRM_COMMAND_BASE + ARRAY_SIZE(i915_compat_ioctls))
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_irq.c b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">index 6d494432b19f..b0df8d10482a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_irq.c</span>
<span class="p_chunk">@@ -2650,18 +2650,11 @@</span> <span class="p_context"> static void gen8_disable_vblank(struct drm_device *dev, int pipe)</span>
 	spin_unlock_irqrestore(&amp;dev_priv-&gt;irq_lock, irqflags);
 }
 
<span class="p_del">-static struct drm_i915_gem_request *</span>
<span class="p_del">-ring_last_request(struct intel_engine_cs *ring)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return list_entry(ring-&gt;request_list.prev,</span>
<span class="p_del">-			  struct drm_i915_gem_request, list);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static bool
<span class="p_del">-ring_idle(struct intel_engine_cs *ring)</span>
<span class="p_add">+ring_idle(struct intel_engine_cs *ring, u32 seqno)</span>
 {
 	return (list_empty(&amp;ring-&gt;request_list) ||
<span class="p_del">-		i915_gem_request_completed(ring_last_request(ring), false));</span>
<span class="p_add">+		i915_seqno_passed(seqno, ring-&gt;last_submitted_seqno));</span>
 }
 
 static bool
<span class="p_chunk">@@ -2883,7 +2876,7 @@</span> <span class="p_context"> static void i915_hangcheck_elapsed(struct work_struct *work)</span>
 		acthd = intel_ring_get_active_head(ring);
 
 		if (ring-&gt;hangcheck.seqno == seqno) {
<span class="p_del">-			if (ring_idle(ring)) {</span>
<span class="p_add">+			if (ring_idle(ring, seqno)) {</span>
 				ring-&gt;hangcheck.action = HANGCHECK_IDLE;
 
 				if (waitqueue_active(&amp;ring-&gt;irq_queue)) {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index 773d1d24e604..a30db4b4050e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -3209,6 +3209,7 @@</span> <span class="p_context"> enum skl_disp_power_wells {</span>
 #define   BLM_POLARITY_PNV			(1 &lt;&lt; 0) /* pnv only */
 
 #define BLC_HIST_CTL	(dev_priv-&gt;info.display_mmio_offset + 0x61260)
<span class="p_add">+#define  BLM_HISTOGRAM_ENABLE			(1 &lt;&lt; 31)</span>
 
 /* New registers for PCH-split platforms. Safe where new bits show up, the
  * register layout machtes with gen4 BLC_PWM_CTL[12]. */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">index d0f3cbc87474..57c887843dc3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_display.c</span>
<span class="p_chunk">@@ -12499,6 +12499,16 @@</span> <span class="p_context"> intel_check_primary_plane(struct drm_plane *plane,</span>
 				intel_crtc-&gt;atomic.wait_vblank = true;
 		}
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * FIXME: Actually if we will still have any other plane enabled</span>
<span class="p_add">+		 * on the pipe we could let IPS enabled still, but for</span>
<span class="p_add">+		 * now lets consider that when we make primary invisible</span>
<span class="p_add">+		 * by setting DSPCNTR to 0 on update_primary_plane function</span>
<span class="p_add">+		 * IPS needs to be disable.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!state-&gt;visible || !fb)</span>
<span class="p_add">+			intel_crtc-&gt;atomic.disable_ips = true;</span>
<span class="p_add">+</span>
 		intel_crtc-&gt;atomic.fb_bits |=
 			INTEL_FRONTBUFFER_PRIMARY(intel_crtc-&gt;pipe);
 
<span class="p_chunk">@@ -12590,6 +12600,9 @@</span> <span class="p_context"> static void intel_begin_crtc_commit(struct drm_crtc *crtc)</span>
 	if (intel_crtc-&gt;atomic.disable_fbc)
 		intel_fbc_disable(dev);
 
<span class="p_add">+	if (intel_crtc-&gt;atomic.disable_ips)</span>
<span class="p_add">+		hsw_disable_ips(intel_crtc);</span>
<span class="p_add">+</span>
 	if (intel_crtc-&gt;atomic.pre_disable_primary)
 		intel_pre_disable_primary(crtc);
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index 897f17db08af..68d1f74a7403 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -424,6 +424,7 @@</span> <span class="p_context"> struct intel_crtc_atomic_commit {</span>
 	/* Sleepable operations to perform before commit */
 	bool wait_for_flips;
 	bool disable_fbc;
<span class="p_add">+	bool disable_ips;</span>
 	bool pre_disable_primary;
 	bool update_wm;
 	unsigned disabled_planes;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_panel.c b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">index 08532d4ffe0a..2bf92cba4a55 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_panel.c</span>
<span class="p_chunk">@@ -879,6 +879,14 @@</span> <span class="p_context"> static void i9xx_enable_backlight(struct intel_connector *connector)</span>
 
 	/* XXX: combine this into above write? */
 	intel_panel_actually_set_backlight(connector, panel-&gt;backlight.level);
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Needed to enable backlight on some 855gm models. BLC_HIST_CTL is</span>
<span class="p_add">+	 * 855gm only, but checking for gen2 is safe, as 855gm is the only gen2</span>
<span class="p_add">+	 * that has backlight.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (IS_GEN2(dev))</span>
<span class="p_add">+		I915_WRITE(BLC_HIST_CTL, BLM_HISTOGRAM_ENABLE);</span>
 }
 
 static void i965_enable_backlight(struct intel_connector *connector)
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ringbuffer.h b/drivers/gpu/drm/i915/intel_ringbuffer.h</span>
<span class="p_header">index c761fe05ad6f..94514d364d25 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ringbuffer.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ringbuffer.h</span>
<span class="p_chunk">@@ -266,6 +266,13 @@</span> <span class="p_context"> struct  intel_engine_cs {</span>
 	 * Do we have some not yet emitted requests outstanding?
 	 */
 	struct drm_i915_gem_request *outstanding_lazy_request;
<span class="p_add">+	/**</span>
<span class="p_add">+	 * Seqno of request most recently submitted to request_list.</span>
<span class="p_add">+	 * Used exclusively by hang checker to avoid grabbing lock while</span>
<span class="p_add">+	 * inspecting request list.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	u32 last_submitted_seqno;</span>
<span class="p_add">+</span>
 	bool gpu_caches_dirty;
 
 	wait_queue_head_t irq_queue;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_uncore.c b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">index ff2a74651dd4..a18807ec8371 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_uncore.c</span>
<span class="p_chunk">@@ -1220,10 +1220,12 @@</span> <span class="p_context"> int i915_reg_read_ioctl(struct drm_device *dev,</span>
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
 	struct drm_i915_reg_read *reg = data;
 	struct register_whitelist const *entry = whitelist;
<span class="p_add">+	unsigned size;</span>
<span class="p_add">+	u64 offset;</span>
 	int i, ret = 0;
 
 	for (i = 0; i &lt; ARRAY_SIZE(whitelist); i++, entry++) {
<span class="p_del">-		if (entry-&gt;offset == reg-&gt;offset &amp;&amp;</span>
<span class="p_add">+		if (entry-&gt;offset == (reg-&gt;offset &amp; -entry-&gt;size) &amp;&amp;</span>
 		    (1 &lt;&lt; INTEL_INFO(dev)-&gt;gen &amp; entry-&gt;gen_bitmask))
 			break;
 	}
<span class="p_chunk">@@ -1231,23 +1233,33 @@</span> <span class="p_context"> int i915_reg_read_ioctl(struct drm_device *dev,</span>
 	if (i == ARRAY_SIZE(whitelist))
 		return -EINVAL;
 
<span class="p_add">+	/* We use the low bits to encode extra flags as the register should</span>
<span class="p_add">+	 * be naturally aligned (and those that are not so aligned merely</span>
<span class="p_add">+	 * limit the available flags for that register).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	offset = entry-&gt;offset;</span>
<span class="p_add">+	size = entry-&gt;size;</span>
<span class="p_add">+	size |= reg-&gt;offset ^ offset;</span>
<span class="p_add">+</span>
 	intel_runtime_pm_get(dev_priv);
 
<span class="p_del">-	switch (entry-&gt;size) {</span>
<span class="p_add">+	switch (size) {</span>
<span class="p_add">+	case 8 | 1:</span>
<span class="p_add">+		reg-&gt;val = I915_READ64_2x32(offset, offset+4);</span>
<span class="p_add">+		break;</span>
 	case 8:
<span class="p_del">-		reg-&gt;val = I915_READ64(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ64(offset);</span>
 		break;
 	case 4:
<span class="p_del">-		reg-&gt;val = I915_READ(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ(offset);</span>
 		break;
 	case 2:
<span class="p_del">-		reg-&gt;val = I915_READ16(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ16(offset);</span>
 		break;
 	case 1:
<span class="p_del">-		reg-&gt;val = I915_READ8(reg-&gt;offset);</span>
<span class="p_add">+		reg-&gt;val = I915_READ8(offset);</span>
 		break;
 	default:
<span class="p_del">-		MISSING_CASE(entry-&gt;size);</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_cmd.c b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">index 97823644d347..f33251d67914 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_cmd.c</span>
<span class="p_chunk">@@ -505,6 +505,7 @@</span> <span class="p_context"> int qxl_hw_surface_alloc(struct qxl_device *qdev,</span>
 
 	cmd = (struct qxl_surface_cmd *)qxl_release_map(qdev, release);
 	cmd-&gt;type = QXL_SURFACE_CMD_CREATE;
<span class="p_add">+	cmd-&gt;flags = QXL_SURF_FLAG_KEEP_DATA;</span>
 	cmd-&gt;u.surface_create.format = surf-&gt;surf.format;
 	cmd-&gt;u.surface_create.width = surf-&gt;surf.width;
 	cmd-&gt;u.surface_create.height = surf-&gt;surf.height;
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_ioctl.c b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">index b110883f8253..7354a4cda59d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_ioctl.c</span>
<span class="p_chunk">@@ -122,8 +122,10 @@</span> <span class="p_context"> static struct qxl_bo *qxlhw_handle_to_bo(struct qxl_device *qdev,</span>
 	qobj = gem_to_qxl_bo(gobj);
 
 	ret = qxl_release_list_add(release, qobj);
<span class="p_del">-	if (ret)</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(gobj);</span>
 		return NULL;
<span class="p_add">+	}</span>
 
 	return qobj;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/ci_dpm.c b/drivers/gpu/drm/radeon/ci_dpm.c</span>
<span class="p_header">index 8730562323a8..4a09947be244 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/ci_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/ci_dpm.c</span>
<span class="p_chunk">@@ -5818,7 +5818,7 @@</span> <span class="p_context"> int ci_dpm_init(struct radeon_device *rdev)</span>
 			tmp |= DPM_ENABLED;
 			break;
 		default:
<span class="p_del">-			DRM_ERROR(&quot;Invalid PCC GPIO: %u!\n&quot;, gpio.shift);</span>
<span class="p_add">+			DRM_DEBUG(&quot;Invalid PCC GPIO: %u!\n&quot;, gpio.shift);</span>
 			break;
 		}
 		WREG32_SMC(CNB_PWRMGT_CNTL, tmp);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index ba50f3c1c2e0..845665362475 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -4579,6 +4579,31 @@</span> <span class="p_context"> void cik_compute_set_wptr(struct radeon_device *rdev,</span>
 	WDOORBELL32(ring-&gt;doorbell_index, ring-&gt;wptr);
 }
 
<span class="p_add">+static void cik_compute_stop(struct radeon_device *rdev,</span>
<span class="p_add">+			     struct radeon_ring *ring)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 j, tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	cik_srbm_select(rdev, ring-&gt;me, ring-&gt;pipe, ring-&gt;queue, 0);</span>
<span class="p_add">+	/* Disable wptr polling. */</span>
<span class="p_add">+	tmp = RREG32(CP_PQ_WPTR_POLL_CNTL);</span>
<span class="p_add">+	tmp &amp;= ~WPTR_POLL_EN;</span>
<span class="p_add">+	WREG32(CP_PQ_WPTR_POLL_CNTL, tmp);</span>
<span class="p_add">+	/* Disable HQD. */</span>
<span class="p_add">+	if (RREG32(CP_HQD_ACTIVE) &amp; 1) {</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 1);</span>
<span class="p_add">+		for (j = 0; j &lt; rdev-&gt;usec_timeout; j++) {</span>
<span class="p_add">+			if (!(RREG32(CP_HQD_ACTIVE) &amp; 1))</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			udelay(1);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		WREG32(CP_HQD_DEQUEUE_REQUEST, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_RPTR, 0);</span>
<span class="p_add">+		WREG32(CP_HQD_PQ_WPTR, 0);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cik_srbm_select(rdev, 0, 0, 0, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * cik_cp_compute_enable - enable/disable the compute CP MEs
  *
<span class="p_chunk">@@ -4592,6 +4617,15 @@</span> <span class="p_context"> static void cik_cp_compute_enable(struct radeon_device *rdev, bool enable)</span>
 	if (enable)
 		WREG32(CP_MEC_CNTL, 0);
 	else {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * To make hibernation reliable we need to clear compute ring</span>
<span class="p_add">+		 * configuration before halting the compute ring.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mutex_lock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX]);</span>
<span class="p_add">+		cik_compute_stop(rdev,&amp;rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX]);</span>
<span class="p_add">+		mutex_unlock(&amp;rdev-&gt;srbm_mutex);</span>
<span class="p_add">+</span>
 		WREG32(CP_MEC_CNTL, (MEC_ME1_HALT | MEC_ME2_HALT));
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP1_INDEX].ready = false;
 		rdev-&gt;ring[CAYMAN_RING_TYPE_CP2_INDEX].ready = false;
<span class="p_chunk">@@ -7905,23 +7939,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7931,23 +7969,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 2: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D2 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7957,23 +7999,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 3: /* D3 vblank/vline */
 			switch (src_data) {
 			case 0: /* D3 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D3 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -7983,23 +8029,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 4: /* D4 vblank/vline */
 			switch (src_data) {
 			case 0: /* D4 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D4 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -8009,23 +8059,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D5 vblank/vline */
 			switch (src_data) {
 			case 0: /* D5 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D5 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -8035,23 +8089,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 6: /* D6 vblank/vline */
 			switch (src_data) {
 			case 0: /* D6 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D6 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -8071,88 +8129,112 @@</span> <span class="p_context"> restart_ih:</span>
 		case 42: /* HPD hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 6:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int &amp; DC_HPD1_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~DC_HPD1_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int &amp; DC_HPD1_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int &amp;= ~DC_HPD1_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 7:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; DC_HPD2_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~DC_HPD2_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp; DC_HPD2_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont &amp;= ~DC_HPD2_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 2\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 8:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; DC_HPD3_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~DC_HPD3_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp; DC_HPD3_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont2 &amp;= ~DC_HPD3_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 3\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 9:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; DC_HPD4_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~DC_HPD4_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp; DC_HPD4_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont3 &amp;= ~DC_HPD4_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 4\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 10:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; DC_HPD5_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~DC_HPD5_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp; DC_HPD5_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont4 &amp;= ~DC_HPD5_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 5\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 11:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; DC_HPD6_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~DC_HPD6_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp; DC_HPD6_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.cik.disp_int_cont5 &amp;= ~DC_HPD6_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik_sdma.c b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">index f86eb54e7763..d16f2eebd95e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik_sdma.c</span>
<span class="p_chunk">@@ -268,6 +268,17 @@</span> <span class="p_context"> static void cik_sdma_gfx_stop(struct radeon_device *rdev)</span>
 	}
 	rdev-&gt;ring[R600_RING_TYPE_DMA_INDEX].ready = false;
 	rdev-&gt;ring[CAYMAN_RING_TYPE_DMA1_INDEX].ready = false;
<span class="p_add">+</span>
<span class="p_add">+	/* FIXME use something else than big hammer but after few days can not</span>
<span class="p_add">+	 * seem to find good combination so reset SDMA blocks as it seems we</span>
<span class="p_add">+	 * do not shut them down properly. This fix hibernation and does not</span>
<span class="p_add">+	 * affect suspend to ram.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, SOFT_RESET_SDMA | SOFT_RESET_SDMA1);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
<span class="p_add">+	udelay(50);</span>
<span class="p_add">+	WREG32(SRBM_SOFT_RESET, 0);</span>
<span class="p_add">+	(void)RREG32(SRBM_SOFT_RESET);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/evergreen.c b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">index f848acfd3fc8..feef136cdb55 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/evergreen.c</span>
<span class="p_chunk">@@ -4855,7 +4855,7 @@</span> <span class="p_context"> restart_ih:</span>
 		return IRQ_NONE;
 
 	rptr = rdev-&gt;ih.rptr;
<span class="p_del">-	DRM_DEBUG(&quot;r600_irq_process start: rptr %d, wptr %d\n&quot;, rptr, wptr);</span>
<span class="p_add">+	DRM_DEBUG(&quot;evergreen_irq_process start: rptr %d, wptr %d\n&quot;, rptr, wptr);</span>
 
 	/* Order reading of wptr vs. reading of IH ring data */
 	rmb();
<span class="p_chunk">@@ -4873,23 +4873,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D1 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D1 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4899,23 +4903,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 2: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D2 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4925,23 +4933,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 3: /* D3 vblank/vline */
 			switch (src_data) {
 			case 0: /* D3 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D3 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D3 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D3 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4951,23 +4963,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 4: /* D4 vblank/vline */
 			switch (src_data) {
 			case 0: /* D4 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D4 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D4 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D4 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4977,23 +4993,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D5 vblank/vline */
 			switch (src_data) {
 			case 0: /* D5 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D5 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D5 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D5 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -5003,23 +5023,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 6: /* D6 vblank/vline */
 			switch (src_data) {
 			case 0: /* D6 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D6 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D6 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D6 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -5039,88 +5063,100 @@</span> <span class="p_context"> restart_ih:</span>
 		case 42: /* HPD hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
 				break;
 			case 6:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 1\n&quot;);</span>
 				break;
 			case 7:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 2\n&quot;);</span>
 				break;
 			case 8:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 3\n&quot;);</span>
 				break;
 			case 9:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 4\n&quot;);</span>
 				break;
 			case 10:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 5\n&quot;);</span>
 				break;
 			case 11:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 6\n&quot;);</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -5130,46 +5166,52 @@</span> <span class="p_context"> restart_ih:</span>
 		case 44: /* hdmi */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status1 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status2 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status3 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI2\n&quot;);</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status4 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI3\n&quot;);</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status5 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI4\n&quot;);</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp; AFMT_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp; AFMT_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.afmt_status6 &amp;= ~AFMT_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI5\n&quot;);</span>
 				break;
 			default:
 				DRM_ERROR(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600.c b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">index 8f6d862a1882..21e479fefcab 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600.c</span>
<span class="p_chunk">@@ -4039,23 +4039,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D1 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+				    DRM_DEBUG(&quot;IH: D1 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4065,23 +4069,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vblank - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: D2 vline - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4101,46 +4109,53 @@</span> <span class="p_context"> restart_ih:</span>
 		case 19: /* HPD/DAC hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD1 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD2 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD3 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD4 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
 				break;
 			case 10:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD5 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
 				break;
 			case 12:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HPD6 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.disp_int_cont2 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -4150,18 +4165,22 @@</span> <span class="p_context"> restart_ih:</span>
 		case 21: /* hdmi */
 			switch (src_data) {
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp; HDMI0_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp; HDMI0_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HDMI0 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.hdmi0_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI0\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp; HDMI0_AZ_FORMAT_WTRIG) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_del">-					queue_hdmi = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp; HDMI0_AZ_FORMAT_WTRIG))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: HDMI1 - IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.r600.hdmi1_status &amp;= ~HDMI0_AZ_FORMAT_WTRIG;</span>
<span class="p_add">+				queue_hdmi = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HDMI1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_ERROR(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">index 25191f126f3b..fa719c53449b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_audio.c</span>
<span class="p_chunk">@@ -242,6 +242,13 @@</span> <span class="p_context"> static struct radeon_audio_funcs dce6_dp_funcs = {</span>
 	.dpms = evergreen_dp_enable,
 };
 
<span class="p_add">+static void radeon_audio_enable(struct radeon_device *rdev,</span>
<span class="p_add">+				struct r600_audio_pin *pin, u8 enable_mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (rdev-&gt;audio.funcs-&gt;enable)</span>
<span class="p_add">+		rdev-&gt;audio.funcs-&gt;enable(rdev, pin, enable_mask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void radeon_audio_interface_init(struct radeon_device *rdev)
 {
 	if (ASIC_IS_DCE6(rdev)) {
<span class="p_chunk">@@ -307,7 +314,7 @@</span> <span class="p_context"> int radeon_audio_init(struct radeon_device *rdev)</span>
 
 	/* disable audio.  it will be set up later */
 	for (i = 0; i &lt; rdev-&gt;audio.num_pins; i++)
<span class="p_del">-		radeon_audio_enable(rdev, &amp;rdev-&gt;audio.pin[i], false);</span>
<span class="p_add">+		radeon_audio_enable(rdev, &amp;rdev-&gt;audio.pin[i], 0);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -443,13 +450,6 @@</span> <span class="p_context"> static void radeon_audio_select_pin(struct drm_encoder *encoder)</span>
 		radeon_encoder-&gt;audio-&gt;select_pin(encoder);
 }
 
<span class="p_del">-void radeon_audio_enable(struct radeon_device *rdev,</span>
<span class="p_del">-	struct r600_audio_pin *pin, u8 enable_mask)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (rdev-&gt;audio.funcs-&gt;enable)</span>
<span class="p_del">-		rdev-&gt;audio.funcs-&gt;enable(rdev, pin, enable_mask);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void radeon_audio_detect(struct drm_connector *connector,
 			 enum drm_connector_status status)
 {
<span class="p_chunk">@@ -469,22 +469,22 @@</span> <span class="p_context"> void radeon_audio_detect(struct drm_connector *connector,</span>
 	dig = radeon_encoder-&gt;enc_priv;
 
 	if (status == connector_status_connected) {
<span class="p_del">-		struct radeon_connector *radeon_connector;</span>
<span class="p_del">-		int sink_type;</span>
<span class="p_del">-</span>
 		if (!drm_detect_monitor_audio(radeon_connector_edid(connector))) {
 			radeon_encoder-&gt;audio = NULL;
 			return;
 		}
 
<span class="p_del">-		radeon_connector = to_radeon_connector(connector);</span>
<span class="p_del">-		sink_type = radeon_dp_getsinktype(radeon_connector);</span>
<span class="p_add">+		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_DisplayPort) {</span>
<span class="p_add">+			struct radeon_connector *radeon_connector = to_radeon_connector(connector);</span>
 
<span class="p_del">-		if (connector-&gt;connector_type == DRM_MODE_CONNECTOR_DisplayPort &amp;&amp;</span>
<span class="p_del">-			sink_type == CONNECTOR_OBJECT_ID_DISPLAYPORT)</span>
<span class="p_del">-			radeon_encoder-&gt;audio = rdev-&gt;audio.dp_funcs;</span>
<span class="p_del">-		else</span>
<span class="p_add">+			if (radeon_dp_getsinktype(radeon_connector) ==</span>
<span class="p_add">+			    CONNECTOR_OBJECT_ID_DISPLAYPORT)</span>
<span class="p_add">+				radeon_encoder-&gt;audio = rdev-&gt;audio.dp_funcs;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				radeon_encoder-&gt;audio = rdev-&gt;audio.hdmi_funcs;</span>
<span class="p_add">+		} else {</span>
 			radeon_encoder-&gt;audio = rdev-&gt;audio.hdmi_funcs;
<span class="p_add">+		}</span>
 
 		dig-&gt;afmt-&gt;pin = radeon_audio_get_pin(connector-&gt;encoder);
 		radeon_audio_enable(rdev, dig-&gt;afmt-&gt;pin, 0xf);
<span class="p_chunk">@@ -502,7 +502,7 @@</span> <span class="p_context"> void radeon_audio_fini(struct radeon_device *rdev)</span>
 		return;
 
 	for (i = 0; i &lt; rdev-&gt;audio.num_pins; i++)
<span class="p_del">-		radeon_audio_enable(rdev, &amp;rdev-&gt;audio.pin[i], false);</span>
<span class="p_add">+		radeon_audio_enable(rdev, &amp;rdev-&gt;audio.pin[i], 0);</span>
 
 	rdev-&gt;audio.enabled = false;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_audio.h b/drivers/gpu/drm/radeon/radeon_audio.h</span>
<span class="p_header">index c92d059ab204..8438304f7139 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_audio.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_audio.h</span>
<span class="p_chunk">@@ -74,8 +74,6 @@</span> <span class="p_context"> u32 radeon_audio_endpoint_rreg(struct radeon_device *rdev,</span>
 void radeon_audio_endpoint_wreg(struct radeon_device *rdev,
 	u32 offset,	u32 reg, u32 v);
 struct r600_audio_pin *radeon_audio_get_pin(struct drm_encoder *encoder);
<span class="p_del">-void radeon_audio_enable(struct radeon_device *rdev,</span>
<span class="p_del">-	struct r600_audio_pin *pin, u8 enable_mask);</span>
 void radeon_audio_fini(struct radeon_device *rdev);
 void radeon_audio_mode_set(struct drm_encoder *encoder,
 	struct drm_display_mode *mode);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_cursor.c b/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_header">index 45e54060ee97..fa661744a1f5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_cursor.c</span>
<span class="p_chunk">@@ -205,8 +205,9 @@</span> <span class="p_context"> static int radeon_cursor_move_locked(struct drm_crtc *crtc, int x, int y)</span>
 			| (x &lt;&lt; 16)
 			| y));
 		/* offset is from DISP(2)_BASE_ADDRESS */
<span class="p_del">-		WREG32(RADEON_CUR_OFFSET + radeon_crtc-&gt;crtc_offset, (radeon_crtc-&gt;legacy_cursor_offset +</span>
<span class="p_del">-								      (yorigin * 256)));</span>
<span class="p_add">+		WREG32(RADEON_CUR_OFFSET + radeon_crtc-&gt;crtc_offset,</span>
<span class="p_add">+		       radeon_crtc-&gt;cursor_addr - radeon_crtc-&gt;legacy_display_base_addr +</span>
<span class="p_add">+		       yorigin * 256);</span>
 	}
 
 	radeon_crtc-&gt;cursor_x = x;
<span class="p_chunk">@@ -227,51 +228,32 @@</span> <span class="p_context"> int radeon_crtc_cursor_move(struct drm_crtc *crtc,</span>
 	return ret;
 }
 
<span class="p_del">-static int radeon_set_cursor(struct drm_crtc *crtc, struct drm_gem_object *obj)</span>
<span class="p_add">+static void radeon_set_cursor(struct drm_crtc *crtc)</span>
 {
 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
 	struct radeon_device *rdev = crtc-&gt;dev-&gt;dev_private;
<span class="p_del">-	struct radeon_bo *robj = gem_to_radeon_bo(obj);</span>
<span class="p_del">-	uint64_t gpu_addr;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = radeon_bo_reserve(robj, false);</span>
<span class="p_del">-	if (unlikely(ret != 0))</span>
<span class="p_del">-		goto fail;</span>
<span class="p_del">-	/* Only 27 bit offset for legacy cursor */</span>
<span class="p_del">-	ret = radeon_bo_pin_restricted(robj, RADEON_GEM_DOMAIN_VRAM,</span>
<span class="p_del">-				       ASIC_IS_AVIVO(rdev) ? 0 : 1 &lt;&lt; 27,</span>
<span class="p_del">-				       &amp;gpu_addr);</span>
<span class="p_del">-	radeon_bo_unreserve(robj);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto fail;</span>
 
 	if (ASIC_IS_DCE4(rdev)) {
 		WREG32(EVERGREEN_CUR_SURFACE_ADDRESS_HIGH + radeon_crtc-&gt;crtc_offset,
<span class="p_del">-		       upper_32_bits(gpu_addr));</span>
<span class="p_add">+		       upper_32_bits(radeon_crtc-&gt;cursor_addr));</span>
 		WREG32(EVERGREEN_CUR_SURFACE_ADDRESS + radeon_crtc-&gt;crtc_offset,
<span class="p_del">-		       gpu_addr &amp; 0xffffffff);</span>
<span class="p_add">+		       lower_32_bits(radeon_crtc-&gt;cursor_addr));</span>
 	} else if (ASIC_IS_AVIVO(rdev)) {
 		if (rdev-&gt;family &gt;= CHIP_RV770) {
 			if (radeon_crtc-&gt;crtc_id)
<span class="p_del">-				WREG32(R700_D2CUR_SURFACE_ADDRESS_HIGH, upper_32_bits(gpu_addr));</span>
<span class="p_add">+				WREG32(R700_D2CUR_SURFACE_ADDRESS_HIGH,</span>
<span class="p_add">+				       upper_32_bits(radeon_crtc-&gt;cursor_addr));</span>
 			else
<span class="p_del">-				WREG32(R700_D1CUR_SURFACE_ADDRESS_HIGH, upper_32_bits(gpu_addr));</span>
<span class="p_add">+				WREG32(R700_D1CUR_SURFACE_ADDRESS_HIGH,</span>
<span class="p_add">+				       upper_32_bits(radeon_crtc-&gt;cursor_addr));</span>
 		}
 		WREG32(AVIVO_D1CUR_SURFACE_ADDRESS + radeon_crtc-&gt;crtc_offset,
<span class="p_del">-		       gpu_addr &amp; 0xffffffff);</span>
<span class="p_add">+		       lower_32_bits(radeon_crtc-&gt;cursor_addr));</span>
 	} else {
<span class="p_del">-		radeon_crtc-&gt;legacy_cursor_offset = gpu_addr - radeon_crtc-&gt;legacy_display_base_addr;</span>
 		/* offset is from DISP(2)_BASE_ADDRESS */
<span class="p_del">-		WREG32(RADEON_CUR_OFFSET + radeon_crtc-&gt;crtc_offset, radeon_crtc-&gt;legacy_cursor_offset);</span>
<span class="p_add">+		WREG32(RADEON_CUR_OFFSET + radeon_crtc-&gt;crtc_offset,</span>
<span class="p_add">+		       radeon_crtc-&gt;cursor_addr - radeon_crtc-&gt;legacy_display_base_addr);</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-fail:</span>
<span class="p_del">-	drm_gem_object_unreference_unlocked(obj);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
 }
 
 int radeon_crtc_cursor_set2(struct drm_crtc *crtc,
<span class="p_chunk">@@ -283,7 +265,9 @@</span> <span class="p_context"> int radeon_crtc_cursor_set2(struct drm_crtc *crtc,</span>
 			    int32_t hot_y)
 {
 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
<span class="p_add">+	struct radeon_device *rdev = crtc-&gt;dev-&gt;dev_private;</span>
 	struct drm_gem_object *obj;
<span class="p_add">+	struct radeon_bo *robj;</span>
 	int ret;
 
 	if (!handle) {
<span class="p_chunk">@@ -305,6 +289,23 @@</span> <span class="p_context"> int radeon_crtc_cursor_set2(struct drm_crtc *crtc,</span>
 		return -ENOENT;
 	}
 
<span class="p_add">+	robj = gem_to_radeon_bo(obj);</span>
<span class="p_add">+	ret = radeon_bo_reserve(robj, false);</span>
<span class="p_add">+	if (ret != 0) {</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(obj);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Only 27 bit offset for legacy cursor */</span>
<span class="p_add">+	ret = radeon_bo_pin_restricted(robj, RADEON_GEM_DOMAIN_VRAM,</span>
<span class="p_add">+				       ASIC_IS_AVIVO(rdev) ? 0 : 1 &lt;&lt; 27,</span>
<span class="p_add">+				       &amp;radeon_crtc-&gt;cursor_addr);</span>
<span class="p_add">+	radeon_bo_unreserve(robj);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		DRM_ERROR(&quot;Failed to pin new cursor BO (%d)\n&quot;, ret);</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(obj);</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	radeon_crtc-&gt;cursor_width = width;
 	radeon_crtc-&gt;cursor_height = height;
 
<span class="p_chunk">@@ -323,13 +324,8 @@</span> <span class="p_context"> int radeon_crtc_cursor_set2(struct drm_crtc *crtc,</span>
 		radeon_crtc-&gt;cursor_hot_y = hot_y;
 	}
 
<span class="p_del">-	ret = radeon_set_cursor(crtc, obj);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		DRM_ERROR(&quot;radeon_set_cursor returned %d, not changing cursor\n&quot;,</span>
<span class="p_del">-			  ret);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		radeon_show_cursor(crtc);</span>
<span class="p_add">+	radeon_set_cursor(crtc);</span>
<span class="p_add">+	radeon_show_cursor(crtc);</span>
 
 	radeon_lock_cursor(crtc, false);
 
<span class="p_chunk">@@ -341,8 +337,7 @@</span> <span class="p_context"> unpin:</span>
 			radeon_bo_unpin(robj);
 			radeon_bo_unreserve(robj);
 		}
<span class="p_del">-		if (radeon_crtc-&gt;cursor_bo != obj)</span>
<span class="p_del">-			drm_gem_object_unreference_unlocked(radeon_crtc-&gt;cursor_bo);</span>
<span class="p_add">+		drm_gem_object_unreference_unlocked(radeon_crtc-&gt;cursor_bo);</span>
 	}
 
 	radeon_crtc-&gt;cursor_bo = obj;
<span class="p_chunk">@@ -360,7 +355,6 @@</span> <span class="p_context"> unpin:</span>
 void radeon_cursor_reset(struct drm_crtc *crtc)
 {
 	struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);
<span class="p_del">-	int ret;</span>
 
 	if (radeon_crtc-&gt;cursor_bo) {
 		radeon_lock_cursor(crtc, true);
<span class="p_chunk">@@ -368,12 +362,8 @@</span> <span class="p_context"> void radeon_cursor_reset(struct drm_crtc *crtc)</span>
 		radeon_cursor_move_locked(crtc, radeon_crtc-&gt;cursor_x,
 					  radeon_crtc-&gt;cursor_y);
 
<span class="p_del">-		ret = radeon_set_cursor(crtc, radeon_crtc-&gt;cursor_bo);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			DRM_ERROR(&quot;radeon_set_cursor returned %d, not showing &quot;</span>
<span class="p_del">-				  &quot;cursor\n&quot;, ret);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			radeon_show_cursor(crtc);</span>
<span class="p_add">+		radeon_set_cursor(crtc);</span>
<span class="p_add">+		radeon_show_cursor(crtc);</span>
 
 		radeon_lock_cursor(crtc, false);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index a7fdfa4f0857..604c44d88e7a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -1572,11 +1572,21 @@</span> <span class="p_context"> int radeon_suspend_kms(struct drm_device *dev, bool suspend, bool fbcon)</span>
 		drm_helper_connector_dpms(connector, DRM_MODE_DPMS_OFF);
 	}
 
<span class="p_del">-	/* unpin the front buffers */</span>
<span class="p_add">+	/* unpin the front buffers and cursors */</span>
 	list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
<span class="p_add">+		struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);</span>
 		struct radeon_framebuffer *rfb = to_radeon_framebuffer(crtc-&gt;primary-&gt;fb);
 		struct radeon_bo *robj;
 
<span class="p_add">+		if (radeon_crtc-&gt;cursor_bo) {</span>
<span class="p_add">+			struct radeon_bo *robj = gem_to_radeon_bo(radeon_crtc-&gt;cursor_bo);</span>
<span class="p_add">+			r = radeon_bo_reserve(robj, false);</span>
<span class="p_add">+			if (r == 0) {</span>
<span class="p_add">+				radeon_bo_unpin(robj);</span>
<span class="p_add">+				radeon_bo_unreserve(robj);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (rfb == NULL || rfb-&gt;obj == NULL) {
 			continue;
 		}
<span class="p_chunk">@@ -1639,6 +1649,7 @@</span> <span class="p_context"> int radeon_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 {
 	struct drm_connector *connector;
 	struct radeon_device *rdev = dev-&gt;dev_private;
<span class="p_add">+	struct drm_crtc *crtc;</span>
 	int r;
 
 	if (dev-&gt;switch_power_state == DRM_SWITCH_POWER_OFF)
<span class="p_chunk">@@ -1678,6 +1689,27 @@</span> <span class="p_context"> int radeon_resume_kms(struct drm_device *dev, bool resume, bool fbcon)</span>
 
 	radeon_restore_bios_scratch_regs(rdev);
 
<span class="p_add">+	/* pin cursors */</span>
<span class="p_add">+	list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {</span>
<span class="p_add">+		struct radeon_crtc *radeon_crtc = to_radeon_crtc(crtc);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (radeon_crtc-&gt;cursor_bo) {</span>
<span class="p_add">+			struct radeon_bo *robj = gem_to_radeon_bo(radeon_crtc-&gt;cursor_bo);</span>
<span class="p_add">+			r = radeon_bo_reserve(robj, false);</span>
<span class="p_add">+			if (r == 0) {</span>
<span class="p_add">+				/* Only 27 bit offset for legacy cursor */</span>
<span class="p_add">+				r = radeon_bo_pin_restricted(robj,</span>
<span class="p_add">+							     RADEON_GEM_DOMAIN_VRAM,</span>
<span class="p_add">+							     ASIC_IS_AVIVO(rdev) ?</span>
<span class="p_add">+							     0 : 1 &lt;&lt; 27,</span>
<span class="p_add">+							     &amp;radeon_crtc-&gt;cursor_addr);</span>
<span class="p_add">+				if (r != 0)</span>
<span class="p_add">+					DRM_ERROR(&quot;Failed to pin cursor BO (%d)\n&quot;, r);</span>
<span class="p_add">+				radeon_bo_unreserve(robj);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* init dig PHYs, disp eng pll */
 	if (rdev-&gt;is_atom_bios) {
 		radeon_atom_encoder_init(rdev);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_fb.c b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">index aeb676708e60..634793ea8418 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_fb.c</span>
<span class="p_chunk">@@ -257,7 +257,6 @@</span> <span class="p_context"> static int radeonfb_create(struct drm_fb_helper *helper,</span>
 	}
 
 	info-&gt;par = rfbdev;
<span class="p_del">-	info-&gt;skip_vt_switch = true;</span>
 
 	ret = radeon_framebuffer_init(rdev-&gt;ddev, &amp;rfbdev-&gt;rfb, &amp;mode_cmd, gobj);
 	if (ret) {
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_gart.c b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">index 5450fa95a47e..c4777c8d0312 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_gart.c</span>
<span class="p_chunk">@@ -260,8 +260,10 @@</span> <span class="p_context"> void radeon_gart_unbind(struct radeon_device *rdev, unsigned offset,</span>
 			}
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -306,8 +308,10 @@</span> <span class="p_context"> int radeon_gart_bind(struct radeon_device *rdev, unsigned offset,</span>
 			page_base += RADEON_GPU_PAGE_SIZE;
 		}
 	}
<span class="p_del">-	mb();</span>
<span class="p_del">-	radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	if (rdev-&gt;gart.ptr) {</span>
<span class="p_add">+		mb();</span>
<span class="p_add">+		radeon_gart_tlb_flush(rdev);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_gem.c b/drivers/gpu/drm/radeon/radeon_gem.c</span>
<span class="p_header">index ac3c1310b953..186d0b792a02 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_gem.c</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"> void radeon_gem_object_free(struct drm_gem_object *gobj)</span>
 	if (robj) {
 		if (robj-&gt;gem_base.import_attach)
 			drm_prime_gem_destroy(&amp;robj-&gt;gem_base, robj-&gt;tbo.sg);
<span class="p_add">+		radeon_mn_unregister(robj);</span>
 		radeon_bo_unref(&amp;robj);
 	}
 }
<span class="p_chunk">@@ -471,6 +472,7 @@</span> <span class="p_context"> int radeon_gem_wait_idle_ioctl(struct drm_device *dev, void *data,</span>
 		r = ret;
 
 	/* Flush HDP cache via MMIO if necessary */
<span class="p_add">+	cur_placement = ACCESS_ONCE(robj-&gt;tbo.mem.mem_type);</span>
 	if (rdev-&gt;asic-&gt;mmio_hdp_flush &amp;&amp;
 	    radeon_mem_type_to_domain(cur_placement) == RADEON_GEM_DOMAIN_VRAM)
 		robj-&gt;rdev-&gt;asic-&gt;mmio_hdp_flush(rdev);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_irq_kms.c b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">index 7162c935371c..f682e5351252 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_irq_kms.c</span>
<span class="p_chunk">@@ -79,10 +79,12 @@</span> <span class="p_context"> static void radeon_hotplug_work_func(struct work_struct *work)</span>
 	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;
 	struct drm_connector *connector;
 
<span class="p_add">+	mutex_lock(&amp;mode_config-&gt;mutex);</span>
 	if (mode_config-&gt;num_connector) {
 		list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head)
 			radeon_connector_hotplug(connector);
 	}
<span class="p_add">+	mutex_unlock(&amp;mode_config-&gt;mutex);</span>
 	/* Just fire off a uevent and let userspace tell us what to do */
 	drm_helper_hpd_irq_event(dev);
 }
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_mode.h b/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_header">index fa91a17b81b6..f01c797b78cf 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_mode.h</span>
<span class="p_chunk">@@ -343,7 +343,6 @@</span> <span class="p_context"> struct radeon_crtc {</span>
 	int max_cursor_width;
 	int max_cursor_height;
 	uint32_t legacy_display_base_addr;
<span class="p_del">-	uint32_t legacy_cursor_offset;</span>
 	enum radeon_rmx_type rmx_type;
 	u8 h_border;
 	u8 v_border;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_object.c b/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_header">index 318165d4855c..676362769b8d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_object.c</span>
<span class="p_chunk">@@ -75,7 +75,6 @@</span> <span class="p_context"> static void radeon_ttm_bo_destroy(struct ttm_buffer_object *tbo)</span>
 	bo = container_of(tbo, struct radeon_bo, tbo);
 
 	radeon_update_memory_usage(bo, bo-&gt;tbo.mem.mem_type, -1);
<span class="p_del">-	radeon_mn_unregister(bo);</span>
 
 	mutex_lock(&amp;bo-&gt;rdev-&gt;gem.mutex);
 	list_del_init(&amp;bo-&gt;list);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index 4c679b802bc8..e15185b16504 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -6466,23 +6466,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 1: /* D1 vblank/vline */
 			switch (src_data) {
 			case 0: /* D1 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[0]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 0);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[0]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 0);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D1 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; LB_D1_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~LB_D1_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D1 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6492,23 +6496,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 2: /* D2 vblank/vline */
 			switch (src_data) {
 			case 0: /* D2 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[1]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 1);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[1]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 1);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D2 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; LB_D2_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~LB_D2_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D2 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6518,23 +6526,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 3: /* D3 vblank/vline */
 			switch (src_data) {
 			case 0: /* D3 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[2]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 2);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[2]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 2);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D3 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; LB_D3_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~LB_D3_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D3 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6544,23 +6556,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 4: /* D4 vblank/vline */
 			switch (src_data) {
 			case 0: /* D4 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[3]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 3);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[3]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 3);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D4 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; LB_D4_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~LB_D4_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D4 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6570,23 +6586,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 5: /* D5 vblank/vline */
 			switch (src_data) {
 			case 0: /* D5 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[4]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 4);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[4]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 4);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D5 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; LB_D5_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~LB_D5_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D5 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6596,23 +6616,27 @@</span> <span class="p_context"> restart_ih:</span>
 		case 6: /* D6 vblank/vline */
 			switch (src_data) {
 			case 0: /* D6 vblank */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT) {</span>
<span class="p_del">-					if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_del">-						drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_del">-						rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_del">-						wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
<span class="p_del">-					}</span>
<span class="p_del">-					if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_del">-						radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VBLANK_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				if (rdev-&gt;irq.crtc_vblank_int[5]) {</span>
<span class="p_add">+					drm_handle_vblank(rdev-&gt;ddev, 5);</span>
<span class="p_add">+					rdev-&gt;pm.vblank_sync = true;</span>
<span class="p_add">+					wake_up(&amp;rdev-&gt;irq.vblank_queue);</span>
 				}
<span class="p_add">+				if (atomic_read(&amp;rdev-&gt;irq.pflip[5]))</span>
<span class="p_add">+					radeon_crtc_handle_vblank(rdev, 5);</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VBLANK_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vblank\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1: /* D6 vline */
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; LB_D6_VLINE_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~LB_D6_VLINE_INTERRUPT;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: D6 vline\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_chunk">@@ -6632,88 +6656,112 @@</span> <span class="p_context"> restart_ih:</span>
 		case 42: /* HPD hotplug */
 			switch (src_data) {
 			case 0:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 1:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD2\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 2:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD3\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 3:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD4\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 4:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD5\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 5:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_del">-					queue_hotplug = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_INTERRUPT;</span>
<span class="p_add">+				queue_hotplug = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 6:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 1\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int &amp; DC_HPD1_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int &amp;= ~DC_HPD1_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 1\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 7:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 2\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp; DC_HPD2_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont &amp;= ~DC_HPD2_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 2\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 8:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 3\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp; DC_HPD3_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont2 &amp;= ~DC_HPD3_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 3\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 9:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 4\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp; DC_HPD4_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont3 &amp;= ~DC_HPD4_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 4\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 10:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 5\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp; DC_HPD5_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont4 &amp;= ~DC_HPD5_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 5\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			case 11:
<span class="p_del">-				if (rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_RX_INTERRUPT) {</span>
<span class="p_del">-					rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_RX_INTERRUPT;</span>
<span class="p_del">-					queue_dp = true;</span>
<span class="p_del">-					DRM_DEBUG(&quot;IH: HPD_RX 6\n&quot;);</span>
<span class="p_del">-				}</span>
<span class="p_add">+				if (!(rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp; DC_HPD6_RX_INTERRUPT))</span>
<span class="p_add">+					DRM_DEBUG(&quot;IH: IH event w/o asserted irq bit?\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+				rdev-&gt;irq.stat_regs.evergreen.disp_int_cont5 &amp;= ~DC_HPD6_RX_INTERRUPT;</span>
<span class="p_add">+				queue_dp = true;</span>
<span class="p_add">+				DRM_DEBUG(&quot;IH: HPD_RX 6\n&quot;);</span>
<span class="p_add">+</span>
 				break;
 			default:
 				DRM_DEBUG(&quot;Unhandled interrupt: %d %d\n&quot;, src_id, src_data);
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index ff8b83f5e929..9dfcedec05a6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2925,6 +2925,7 @@</span> <span class="p_context"> static struct si_dpm_quirk si_dpm_quirk_list[] = {</span>
 	/* PITCAIRN - https://bugs.freedesktop.org/show_bug.cgi?id=76490 */
 	{ PCI_VENDOR_ID_ATI, 0x6810, 0x1462, 0x3036, 0, 120000 },
 	{ PCI_VENDOR_ID_ATI, 0x6811, 0x174b, 0xe271, 0, 120000 },
<span class="p_add">+	{ PCI_VENDOR_ID_ATI, 0x6810, 0x174b, 0xe271, 85000, 90000 },</span>
 	{ 0, 0, 0, 0 },
 };
 
<span class="p_header">diff --git a/drivers/gpu/drm/rockchip/rockchip_drm_gem.c b/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_header">index eb2282cc4a56..eba5f8a52fbd 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/rockchip/rockchip_drm_gem.c</span>
<span class="p_chunk">@@ -54,55 +54,56 @@</span> <span class="p_context"> static void rockchip_gem_free_buf(struct rockchip_gem_object *rk_obj)</span>
 		       &amp;rk_obj-&gt;dma_attrs);
 }
 
<span class="p_del">-int rockchip_gem_mmap_buf(struct drm_gem_object *obj,</span>
<span class="p_del">-			  struct vm_area_struct *vma)</span>
<span class="p_add">+static int rockchip_drm_gem_object_mmap(struct drm_gem_object *obj,</span>
<span class="p_add">+					struct vm_area_struct *vma)</span>
<span class="p_add">+</span>
 {
<span class="p_add">+	int ret;</span>
 	struct rockchip_gem_object *rk_obj = to_rockchip_obj(obj);
 	struct drm_device *drm = obj-&gt;dev;
<span class="p_del">-	unsigned long vm_size;</span>
 
<span class="p_del">-	vma-&gt;vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;</span>
<span class="p_del">-	vm_size = vma-&gt;vm_end - vma-&gt;vm_start;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (vm_size &gt; obj-&gt;size)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * dma_alloc_attrs() allocated a struct page table for rk_obj, so clear</span>
<span class="p_add">+	 * VM_PFNMAP flag that was set by drm_gem_mmap_obj()/drm_gem_mmap().</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	vma-&gt;vm_flags &amp;= ~VM_PFNMAP;</span>
 
<span class="p_del">-	return dma_mmap_attrs(drm-&gt;dev, vma, rk_obj-&gt;kvaddr, rk_obj-&gt;dma_addr,</span>
<span class="p_add">+	ret = dma_mmap_attrs(drm-&gt;dev, vma, rk_obj-&gt;kvaddr, rk_obj-&gt;dma_addr,</span>
 			     obj-&gt;size, &amp;rk_obj-&gt;dma_attrs);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		drm_gem_vm_close(vma);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
<span class="p_del">-/* drm driver mmap file operations */</span>
<span class="p_del">-int rockchip_gem_mmap(struct file *filp, struct vm_area_struct *vma)</span>
<span class="p_add">+int rockchip_gem_mmap_buf(struct drm_gem_object *obj,</span>
<span class="p_add">+			  struct vm_area_struct *vma)</span>
 {
<span class="p_del">-	struct drm_file *priv = filp-&gt;private_data;</span>
<span class="p_del">-	struct drm_device *dev = priv-&gt;minor-&gt;dev;</span>
<span class="p_del">-	struct drm_gem_object *obj;</span>
<span class="p_del">-	struct drm_vma_offset_node *node;</span>
<span class="p_add">+	struct drm_device *drm = obj-&gt;dev;</span>
 	int ret;
 
<span class="p_del">-	if (drm_device_is_unplugged(dev))</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+	mutex_lock(&amp;drm-&gt;struct_mutex);</span>
<span class="p_add">+	ret = drm_gem_mmap_obj(obj, obj-&gt;size, vma);</span>
<span class="p_add">+	mutex_unlock(&amp;drm-&gt;struct_mutex);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-	mutex_lock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_add">+	return rockchip_drm_gem_object_mmap(obj, vma);</span>
<span class="p_add">+}</span>
 
<span class="p_del">-	node = drm_vma_offset_exact_lookup(dev-&gt;vma_offset_manager,</span>
<span class="p_del">-					   vma-&gt;vm_pgoff,</span>
<span class="p_del">-					   vma_pages(vma));</span>
<span class="p_del">-	if (!node) {</span>
<span class="p_del">-		mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-		DRM_ERROR(&quot;failed to find vma node.\n&quot;);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	} else if (!drm_vma_node_is_allowed(node, filp)) {</span>
<span class="p_del">-		mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_del">-		return -EACCES;</span>
<span class="p_del">-	}</span>
<span class="p_add">+/* drm driver mmap file operations */</span>
<span class="p_add">+int rockchip_gem_mmap(struct file *filp, struct vm_area_struct *vma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_gem_object *obj;</span>
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	obj = container_of(node, struct drm_gem_object, vma_node);</span>
<span class="p_del">-	ret = rockchip_gem_mmap_buf(obj, vma);</span>
<span class="p_add">+	ret = drm_gem_mmap(filp, vma);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
<span class="p_del">-	mutex_unlock(&amp;dev-&gt;struct_mutex);</span>
<span class="p_add">+	obj = vma-&gt;vm_private_data;</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return rockchip_drm_gem_object_mmap(obj, vma);</span>
 }
 
 struct rockchip_gem_object *
<span class="p_header">diff --git a/drivers/gpu/drm/tegra/dpaux.c b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">index d6b55e3e3716..a43a836e6f88 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/tegra/dpaux.c</span>
<span class="p_chunk">@@ -72,34 +72,32 @@</span> <span class="p_context"> static inline void tegra_dpaux_writel(struct tegra_dpaux *dpaux,</span>
 static void tegra_dpaux_write_fifo(struct tegra_dpaux *dpaux, const u8 *buffer,
 				   size_t size)
 {
<span class="p_del">-	unsigned long offset = DPAUX_DP_AUXDATA_WRITE(0);</span>
 	size_t i, j;
 
<span class="p_del">-	for (i = 0; i &lt; size; i += 4) {</span>
<span class="p_del">-		size_t num = min_t(size_t, size - i, 4);</span>
<span class="p_add">+	for (i = 0; i &lt; DIV_ROUND_UP(size, 4); i++) {</span>
<span class="p_add">+		size_t num = min_t(size_t, size - i * 4, 4);</span>
 		unsigned long value = 0;
 
 		for (j = 0; j &lt; num; j++)
<span class="p_del">-			value |= buffer[i + j] &lt;&lt; (j * 8);</span>
<span class="p_add">+			value |= buffer[i * 4 + j] &lt;&lt; (j * 8);</span>
 
<span class="p_del">-		tegra_dpaux_writel(dpaux, value, offset++);</span>
<span class="p_add">+		tegra_dpaux_writel(dpaux, value, DPAUX_DP_AUXDATA_WRITE(i));</span>
 	}
 }
 
 static void tegra_dpaux_read_fifo(struct tegra_dpaux *dpaux, u8 *buffer,
 				  size_t size)
 {
<span class="p_del">-	unsigned long offset = DPAUX_DP_AUXDATA_READ(0);</span>
 	size_t i, j;
 
<span class="p_del">-	for (i = 0; i &lt; size; i += 4) {</span>
<span class="p_del">-		size_t num = min_t(size_t, size - i, 4);</span>
<span class="p_add">+	for (i = 0; i &lt; DIV_ROUND_UP(size, 4); i++) {</span>
<span class="p_add">+		size_t num = min_t(size_t, size - i * 4, 4);</span>
 		unsigned long value;
 
<span class="p_del">-		value = tegra_dpaux_readl(dpaux, offset++);</span>
<span class="p_add">+		value = tegra_dpaux_readl(dpaux, DPAUX_DP_AUXDATA_READ(i));</span>
 
 		for (j = 0; j &lt; num; j++)
<span class="p_del">-			buffer[i + j] = value &gt;&gt; (j * 8);</span>
<span class="p_add">+			buffer[i * 4 + j] = value &gt;&gt; (j * 8);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/vgem/vgem_drv.c b/drivers/gpu/drm/vgem/vgem_drv.c</span>
<span class="p_header">index 7a207ca547be..6394547cf67a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/vgem/vgem_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/vgem/vgem_drv.c</span>
<span class="p_chunk">@@ -328,6 +328,8 @@</span> <span class="p_context"> static int __init vgem_init(void)</span>
 		goto out;
 	}
 
<span class="p_add">+	drm_dev_set_unique(vgem_device, &quot;vgem&quot;);</span>
<span class="p_add">+</span>
 	ret  = drm_dev_register(vgem_device, 0);
 
 	if (ret)
<span class="p_header">diff --git a/drivers/hwmon/mcp3021.c b/drivers/hwmon/mcp3021.c</span>
<span class="p_header">index d219c06a857b..972444a14cca 100644</span>
<span class="p_header">--- a/drivers/hwmon/mcp3021.c</span>
<span class="p_header">+++ b/drivers/hwmon/mcp3021.c</span>
<span class="p_chunk">@@ -31,14 +31,11 @@</span> <span class="p_context"></span>
 /* output format */
 #define MCP3021_SAR_SHIFT	2
 #define MCP3021_SAR_MASK	0x3ff
<span class="p_del">-</span>
 #define MCP3021_OUTPUT_RES	10	/* 10-bit resolution */
<span class="p_del">-#define MCP3021_OUTPUT_SCALE	4</span>
 
 #define MCP3221_SAR_SHIFT	0
 #define MCP3221_SAR_MASK	0xfff
 #define MCP3221_OUTPUT_RES	12	/* 12-bit resolution */
<span class="p_del">-#define MCP3221_OUTPUT_SCALE	1</span>
 
 enum chips {
 	mcp3021,
<span class="p_chunk">@@ -54,7 +51,6 @@</span> <span class="p_context"> struct mcp3021_data {</span>
 	u16 sar_shift;
 	u16 sar_mask;
 	u8 output_res;
<span class="p_del">-	u8 output_scale;</span>
 };
 
 static int mcp3021_read16(struct i2c_client *client)
<span class="p_chunk">@@ -84,13 +80,7 @@</span> <span class="p_context"> static int mcp3021_read16(struct i2c_client *client)</span>
 
 static inline u16 volts_from_reg(struct mcp3021_data *data, u16 val)
 {
<span class="p_del">-	if (val == 0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	val = val * data-&gt;output_scale - data-&gt;output_scale / 2;</span>
<span class="p_del">-</span>
<span class="p_del">-	return val * DIV_ROUND_CLOSEST(data-&gt;vdd,</span>
<span class="p_del">-			(1 &lt;&lt; data-&gt;output_res) * data-&gt;output_scale);</span>
<span class="p_add">+	return DIV_ROUND_CLOSEST(data-&gt;vdd * val, 1 &lt;&lt; data-&gt;output_res);</span>
 }
 
 static ssize_t show_in_input(struct device *dev, struct device_attribute *attr,
<span class="p_chunk">@@ -132,14 +122,12 @@</span> <span class="p_context"> static int mcp3021_probe(struct i2c_client *client,</span>
 		data-&gt;sar_shift = MCP3021_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3021_SAR_MASK;
 		data-&gt;output_res = MCP3021_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3021_OUTPUT_SCALE;</span>
 		break;
 
 	case mcp3221:
 		data-&gt;sar_shift = MCP3221_SAR_SHIFT;
 		data-&gt;sar_mask = MCP3221_SAR_MASK;
 		data-&gt;output_res = MCP3221_OUTPUT_RES;
<span class="p_del">-		data-&gt;output_scale = MCP3221_OUTPUT_SCALE;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/hwmon/nct7802.c b/drivers/hwmon/nct7802.c</span>
<span class="p_header">index 55765790907b..28fcb2e246d5 100644</span>
<span class="p_header">--- a/drivers/hwmon/nct7802.c</span>
<span class="p_header">+++ b/drivers/hwmon/nct7802.c</span>
<span class="p_chunk">@@ -547,7 +547,7 @@</span> <span class="p_context"> static umode_t nct7802_temp_is_visible(struct kobject *kobj,</span>
 	if (index &gt;= 9 &amp;&amp; index &lt; 18 &amp;&amp;
 	    (reg &amp; 0x0c) != 0x04 &amp;&amp; (reg &amp; 0x0c) != 0x08)	/* RD2 */
 		return 0;
<span class="p_del">-	if (index &gt;= 18 &amp;&amp; index &lt; 27 &amp;&amp; (reg &amp; 0x30) != 0x10)	/* RD3 */</span>
<span class="p_add">+	if (index &gt;= 18 &amp;&amp; index &lt; 27 &amp;&amp; (reg &amp; 0x30) != 0x20)	/* RD3 */</span>
 		return 0;
 	if (index &gt;= 27 &amp;&amp; index &lt; 35)				/* local */
 		return attr-&gt;mode;
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-at91.c b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">index ff23d1bdd230..9bd10a9b4b50 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-at91.c</span>
<span class="p_chunk">@@ -65,6 +65,9 @@</span> <span class="p_context"></span>
 #define	AT91_TWI_UNRE		0x0080	/* Underrun Error */
 #define	AT91_TWI_NACK		0x0100	/* Not Acknowledged */
 
<span class="p_add">+#define	AT91_TWI_INT_MASK \</span>
<span class="p_add">+	(AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY | AT91_TWI_NACK)</span>
<span class="p_add">+</span>
 #define	AT91_TWI_IER		0x0024	/* Interrupt Enable Register */
 #define	AT91_TWI_IDR		0x0028	/* Interrupt Disable Register */
 #define	AT91_TWI_IMR		0x002c	/* Interrupt Mask Register */
<span class="p_chunk">@@ -119,13 +122,12 @@</span> <span class="p_context"> static void at91_twi_write(struct at91_twi_dev *dev, unsigned reg, unsigned val)</span>
 
 static void at91_disable_twi_interrupts(struct at91_twi_dev *dev)
 {
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IDR,</span>
<span class="p_del">-		       AT91_TWI_TXCOMP | AT91_TWI_RXRDY | AT91_TWI_TXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IDR, AT91_TWI_INT_MASK);</span>
 }
 
 static void at91_twi_irq_save(struct at91_twi_dev *dev)
 {
<span class="p_del">-	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; 0x7;</span>
<span class="p_add">+	dev-&gt;imr = at91_twi_read(dev, AT91_TWI_IMR) &amp; AT91_TWI_INT_MASK;</span>
 	at91_disable_twi_interrupts(dev);
 }
 
<span class="p_chunk">@@ -215,6 +217,14 @@</span> <span class="p_context"> static void at91_twi_write_data_dma_callback(void *data)</span>
 	dma_unmap_single(dev-&gt;dev, sg_dma_address(&amp;dev-&gt;dma.sg),
 			 dev-&gt;buf_len, DMA_TO_DEVICE);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When this callback is called, THR/TX FIFO is likely not to be empty</span>
<span class="p_add">+	 * yet. So we have to wait for TXCOMP or NACK bits to be set into the</span>
<span class="p_add">+	 * Status Register to be sure that the STOP bit has been sent and the</span>
<span class="p_add">+	 * transfer is completed. The NACK interrupt has already been enabled,</span>
<span class="p_add">+	 * we just have to enable TXCOMP one.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 	at91_twi_write(dev, AT91_TWI_CR, AT91_TWI_STOP);
 }
 
<span class="p_chunk">@@ -309,7 +319,7 @@</span> <span class="p_context"> static void at91_twi_read_data_dma_callback(void *data)</span>
 	/* The last two bytes have to be read without using dma */
 	dev-&gt;buf += dev-&gt;buf_len - 2;
 	dev-&gt;buf_len = 2;
<span class="p_del">-	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY);</span>
<span class="p_add">+	at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_RXRDY | AT91_TWI_TXCOMP);</span>
 }
 
 static void at91_twi_read_data_dma(struct at91_twi_dev *dev)
<span class="p_chunk">@@ -370,7 +380,7 @@</span> <span class="p_context"> static irqreturn_t atmel_twi_interrupt(int irq, void *dev_id)</span>
 	/* catch error flags */
 	dev-&gt;transfer_status |= status;
 
<span class="p_del">-	if (irqstatus &amp; AT91_TWI_TXCOMP) {</span>
<span class="p_add">+	if (irqstatus &amp; (AT91_TWI_TXCOMP | AT91_TWI_NACK)) {</span>
 		at91_disable_twi_interrupts(dev);
 		complete(&amp;dev-&gt;cmd_complete);
 	}
<span class="p_chunk">@@ -384,6 +394,34 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 	unsigned long time_left;
 	bool has_unre_flag = dev-&gt;pdata-&gt;has_unre_flag;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * WARNING: the TXCOMP bit in the Status Register is NOT a clear on</span>
<span class="p_add">+	 * read flag but shows the state of the transmission at the time the</span>
<span class="p_add">+	 * Status Register is read. According to the programmer datasheet,</span>
<span class="p_add">+	 * TXCOMP is set when both holding register and internal shifter are</span>
<span class="p_add">+	 * empty and STOP condition has been sent.</span>
<span class="p_add">+	 * Consequently, we should enable NACK interrupt rather than TXCOMP to</span>
<span class="p_add">+	 * detect transmission failure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Besides, the TXCOMP bit is already set before the i2c transaction</span>
<span class="p_add">+	 * has been started. For read transactions, this bit is cleared when</span>
<span class="p_add">+	 * writing the START bit into the Control Register. So the</span>
<span class="p_add">+	 * corresponding interrupt can safely be enabled just after.</span>
<span class="p_add">+	 * However for write transactions managed by the CPU, we first write</span>
<span class="p_add">+	 * into THR, so TXCOMP is cleared. Then we can safely enable TXCOMP</span>
<span class="p_add">+	 * interrupt. If TXCOMP interrupt were enabled before writing into THR,</span>
<span class="p_add">+	 * the interrupt handler would be called immediately and the i2c command</span>
<span class="p_add">+	 * would be reported as completed.</span>
<span class="p_add">+	 * Also when a write transaction is managed by the DMA controller,</span>
<span class="p_add">+	 * enabling the TXCOMP interrupt in this function may lead to a race</span>
<span class="p_add">+	 * condition since we don&#39;t know whether the TXCOMP interrupt is enabled</span>
<span class="p_add">+	 * before or after the DMA has started to write into THR. So the TXCOMP</span>
<span class="p_add">+	 * interrupt is enabled later by at91_twi_write_data_dma_callback().</span>
<span class="p_add">+	 * Immediately after in that DMA callback, we still need to send the</span>
<span class="p_add">+	 * STOP condition manually writing the corresponding bit into the</span>
<span class="p_add">+	 * Control Register.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
 	dev_dbg(dev-&gt;dev, &quot;transfer: %s %d bytes.\n&quot;,
 		(dev-&gt;msg-&gt;flags &amp; I2C_M_RD) ? &quot;read&quot; : &quot;write&quot;, dev-&gt;buf_len);
 
<span class="p_chunk">@@ -414,26 +452,24 @@</span> <span class="p_context"> static int at91_do_twi_transfer(struct at91_twi_dev *dev)</span>
 		 * seems to be the best solution.
 		 */
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_read_data_dma(dev);
<span class="p_del">-			/*</span>
<span class="p_del">-			 * It is important to enable TXCOMP irq here because</span>
<span class="p_del">-			 * doing it only when transferring the last two bytes</span>
<span class="p_del">-			 * will mask NACK errors since TXCOMP is set when a</span>
<span class="p_del">-			 * NACK occurs.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER,</span>
<span class="p_del">-			       AT91_TWI_TXCOMP);</span>
<span class="p_del">-		} else</span>
<span class="p_add">+		} else {</span>
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-			       AT91_TWI_TXCOMP | AT91_TWI_RXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_RXRDY);</span>
<span class="p_add">+		}</span>
 	} else {
 		if (dev-&gt;use_dma &amp;&amp; (dev-&gt;buf_len &gt; AT91_I2C_DMA_THRESHOLD)) {
<span class="p_add">+			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_NACK);</span>
 			at91_twi_write_data_dma(dev);
<span class="p_del">-			at91_twi_write(dev, AT91_TWI_IER, AT91_TWI_TXCOMP);</span>
 		} else {
 			at91_twi_write_next_byte(dev);
 			at91_twi_write(dev, AT91_TWI_IER,
<span class="p_del">-				AT91_TWI_TXCOMP | AT91_TWI_TXRDY);</span>
<span class="p_add">+				       AT91_TWI_TXCOMP |</span>
<span class="p_add">+				       AT91_TWI_NACK |</span>
<span class="p_add">+				       AT91_TWI_TXRDY);</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/i2c/i2c-mux.c b/drivers/i2c/i2c-mux.c</span>
<span class="p_header">index 06cc1ff088f1..2ba7c0fbc615 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-mux.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-mux.c</span>
<span class="p_chunk">@@ -51,7 +51,7 @@</span> <span class="p_context"> static int i2c_mux_master_xfer(struct i2c_adapter *adap,</span>
 
 	ret = priv-&gt;select(parent, priv-&gt;mux_priv, priv-&gt;chan_id);
 	if (ret &gt;= 0)
<span class="p_del">-		ret = parent-&gt;algo-&gt;master_xfer(parent, msgs, num);</span>
<span class="p_add">+		ret = __i2c_transfer(parent, msgs, num);</span>
 	if (priv-&gt;deselect)
 		priv-&gt;deselect(parent, priv-&gt;mux_priv, priv-&gt;chan_id);
 
<span class="p_chunk">@@ -144,6 +144,7 @@</span> <span class="p_context"> struct i2c_adapter *i2c_add_mux_adapter(struct i2c_adapter *parent,</span>
 	priv-&gt;adap.dev.parent = &amp;parent-&gt;dev;
 	priv-&gt;adap.retries = parent-&gt;retries;
 	priv-&gt;adap.timeout = parent-&gt;timeout;
<span class="p_add">+	priv-&gt;adap.quirks = parent-&gt;quirks;</span>
 
 	/* Sanity check on class */
 	if (i2c_mux_parent_classes(parent) &amp; class)
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca9541.c b/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_header">index cb772775da43..0c8d4d2cbdaf 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca9541.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> static int pca9541_reg_write(struct i2c_client *client, u8 command, u8 val)</span>
 		buf[0] = command;
 		buf[1] = val;
 		msg.buf = buf;
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, &amp;msg, 1);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, &amp;msg, 1);</span>
 	} else {
 		union i2c_smbus_data data;
 
<span class="p_chunk">@@ -144,7 +144,7 @@</span> <span class="p_context"> static int pca9541_reg_read(struct i2c_client *client, u8 command)</span>
 				.buf = &amp;val
 			}
 		};
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, msg, 2);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, msg, 2);</span>
 		if (ret == 2)
 			ret = val;
 		else if (ret &gt;= 0)
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-mux-pca954x.c b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">index bea0d2de2993..ea4aa9dfcea9 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-mux-pca954x.c</span>
<span class="p_chunk">@@ -134,7 +134,7 @@</span> <span class="p_context"> static int pca954x_reg_write(struct i2c_adapter *adap,</span>
 		msg.len = 1;
 		buf[0] = val;
 		msg.buf = buf;
<span class="p_del">-		ret = adap-&gt;algo-&gt;master_xfer(adap, &amp;msg, 1);</span>
<span class="p_add">+		ret = __i2c_transfer(adap, &amp;msg, 1);</span>
 	} else {
 		union i2c_smbus_data data;
 		ret = adap-&gt;algo-&gt;smbus_xfer(adap, client-&gt;addr,
<span class="p_header">diff --git a/drivers/iio/accel/bmc150-accel.c b/drivers/iio/accel/bmc150-accel.c</span>
<span class="p_header">index 73e87739d219..bf827d012a71 100644</span>
<span class="p_header">--- a/drivers/iio/accel/bmc150-accel.c</span>
<span class="p_header">+++ b/drivers/iio/accel/bmc150-accel.c</span>
<span class="p_chunk">@@ -1465,7 +1465,7 @@</span> <span class="p_context"> static void bmc150_accel_unregister_triggers(struct bmc150_accel_data *data,</span>
 {
 	int i;
 
<span class="p_del">-	for (i = from; i &gt;= 0; i++) {</span>
<span class="p_add">+	for (i = from; i &gt;= 0; i--) {</span>
 		if (data-&gt;triggers[i].indio_trig) {
 			iio_trigger_unregister(data-&gt;triggers[i].indio_trig);
 			data-&gt;triggers[i].indio_trig = NULL;
<span class="p_header">diff --git a/drivers/iio/adc/Kconfig b/drivers/iio/adc/Kconfig</span>
<span class="p_header">index e36a73e7c3a8..1bcb65b8d4a1 100644</span>
<span class="p_header">--- a/drivers/iio/adc/Kconfig</span>
<span class="p_header">+++ b/drivers/iio/adc/Kconfig</span>
<span class="p_chunk">@@ -146,8 +146,7 @@</span> <span class="p_context"> config DA9150_GPADC</span>
 
 config CC10001_ADC
 	tristate &quot;Cosmic Circuits 10001 ADC driver&quot;
<span class="p_del">-	depends on HAVE_CLK || REGULATOR</span>
<span class="p_del">-	depends on HAS_IOMEM</span>
<span class="p_add">+	depends on HAS_IOMEM &amp;&amp; HAVE_CLK &amp;&amp; REGULATOR</span>
 	select IIO_BUFFER
 	select IIO_TRIGGERED_BUFFER
 	help
<span class="p_header">diff --git a/drivers/iio/adc/at91_adc.c b/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">index 8a0eb4a04fb5..7b40925dd4ff 100644</span>
<span class="p_header">--- a/drivers/iio/adc/at91_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/at91_adc.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> struct at91_adc_caps {</span>
 	u8	ts_pen_detect_sensitivity;
 
 	/* startup time calculate function */
<span class="p_del">-	u32 (*calc_startup_ticks)(u8 startup_time, u32 adc_clk_khz);</span>
<span class="p_add">+	u32 (*calc_startup_ticks)(u32 startup_time, u32 adc_clk_khz);</span>
 
 	u8	num_channels;
 	struct at91_adc_reg_desc registers;
<span class="p_chunk">@@ -201,7 +201,7 @@</span> <span class="p_context"> struct at91_adc_state {</span>
 	u8			num_channels;
 	void __iomem		*reg_base;
 	struct at91_adc_reg_desc *registers;
<span class="p_del">-	u8			startup_time;</span>
<span class="p_add">+	u32			startup_time;</span>
 	u8			sample_hold_time;
 	bool			sleep_mode;
 	struct iio_trigger	**trig;
<span class="p_chunk">@@ -779,7 +779,7 @@</span> <span class="p_context"> ret:</span>
 	return ret;
 }
 
<span class="p_del">-static u32 calc_startup_ticks_9260(u8 startup_time, u32 adc_clk_khz)</span>
<span class="p_add">+static u32 calc_startup_ticks_9260(u32 startup_time, u32 adc_clk_khz)</span>
 {
 	/*
 	 * Number of ticks needed to cover the startup time of the ADC
<span class="p_chunk">@@ -790,7 +790,7 @@</span> <span class="p_context"> static u32 calc_startup_ticks_9260(u8 startup_time, u32 adc_clk_khz)</span>
 	return round_up((startup_time * adc_clk_khz / 1000) - 1, 8) / 8;
 }
 
<span class="p_del">-static u32 calc_startup_ticks_9x5(u8 startup_time, u32 adc_clk_khz)</span>
<span class="p_add">+static u32 calc_startup_ticks_9x5(u32 startup_time, u32 adc_clk_khz)</span>
 {
 	/*
 	 * For sama5d3x and at91sam9x5, the formula changes to:
<span class="p_header">diff --git a/drivers/iio/adc/rockchip_saradc.c b/drivers/iio/adc/rockchip_saradc.c</span>
<span class="p_header">index 8d4e019ea4ca..9c311c1e1ac7 100644</span>
<span class="p_header">--- a/drivers/iio/adc/rockchip_saradc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/rockchip_saradc.c</span>
<span class="p_chunk">@@ -349,3 +349,7 @@</span> <span class="p_context"> static struct platform_driver rockchip_saradc_driver = {</span>
 };
 
 module_platform_driver(rockchip_saradc_driver);
<span class="p_add">+</span>
<span class="p_add">+MODULE_AUTHOR(&quot;Heiko Stuebner &lt;heiko@sntech.de&gt;&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;Rockchip SARADC driver&quot;);</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_header">diff --git a/drivers/iio/adc/twl4030-madc.c b/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_header">index 94c5f05b4bc1..4caecbea4c97 100644</span>
<span class="p_header">--- a/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/twl4030-madc.c</span>
<span class="p_chunk">@@ -835,7 +835,8 @@</span> <span class="p_context"> static int twl4030_madc_probe(struct platform_device *pdev)</span>
 	irq = platform_get_irq(pdev, 0);
 	ret = devm_request_threaded_irq(&amp;pdev-&gt;dev, irq, NULL,
 				   twl4030_madc_threaded_irq_handler,
<span class="p_del">-				   IRQF_TRIGGER_RISING, &quot;twl4030_madc&quot;, madc);</span>
<span class="p_add">+				   IRQF_TRIGGER_RISING | IRQF_ONESHOT,</span>
<span class="p_add">+				   &quot;twl4030_madc&quot;, madc);</span>
 	if (ret) {
 		dev_err(&amp;pdev-&gt;dev, &quot;could not request irq\n&quot;);
 		goto err_i2c;
<span class="p_header">diff --git a/drivers/iio/common/hid-sensors/hid-sensor-trigger.c b/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_header">index 610fc98f88ef..595511022795 100644</span>
<span class="p_header">--- a/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_header">+++ b/drivers/iio/common/hid-sensors/hid-sensor-trigger.c</span>
<span class="p_chunk">@@ -36,6 +36,8 @@</span> <span class="p_context"> static int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 	s32 poll_value = 0;
 
 	if (state) {
<span class="p_add">+		if (!atomic_read(&amp;st-&gt;user_requested_state))</span>
<span class="p_add">+			return 0;</span>
 		if (sensor_hub_device_open(st-&gt;hsdev))
 			return -EIO;
 
<span class="p_chunk">@@ -52,8 +54,12 @@</span> <span class="p_context"> static int _hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 
 		poll_value = hid_sensor_read_poll_value(st);
 	} else {
<span class="p_del">-		if (!atomic_dec_and_test(&amp;st-&gt;data_ready))</span>
<span class="p_add">+		int val;</span>
<span class="p_add">+</span>
<span class="p_add">+		val = atomic_dec_if_positive(&amp;st-&gt;data_ready);</span>
<span class="p_add">+		if (val &lt; 0)</span>
 			return 0;
<span class="p_add">+</span>
 		sensor_hub_device_close(st-&gt;hsdev);
 		state_val = hid_sensor_get_usage_index(st-&gt;hsdev,
 			st-&gt;power_state.report_id,
<span class="p_chunk">@@ -92,9 +98,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(hid_sensor_power_state);</span>
 
 int hid_sensor_power_state(struct hid_sensor_common *st, bool state)
 {
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 	int ret;
 
<span class="p_add">+	atomic_set(&amp;st-&gt;user_requested_state, state);</span>
 	if (state)
 		ret = pm_runtime_get_sync(&amp;st-&gt;pdev-&gt;dev);
 	else {
<span class="p_chunk">@@ -109,6 +117,7 @@</span> <span class="p_context"> int hid_sensor_power_state(struct hid_sensor_common *st, bool state)</span>
 
  	return 0;
 #else
<span class="p_add">+	atomic_set(&amp;st-&gt;user_requested_state, state);</span>
 	return _hid_sensor_power_state(st, state);
 #endif
 }
<span class="p_header">diff --git a/drivers/iio/dac/ad5624r_spi.c b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">index 61bb9d4239ea..e98428df0d44 100644</span>
<span class="p_header">--- a/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_header">+++ b/drivers/iio/dac/ad5624r_spi.c</span>
<span class="p_chunk">@@ -22,7 +22,7 @@</span> <span class="p_context"></span>
 #include &quot;ad5624r.h&quot;
 
 static int ad5624r_spi_write(struct spi_device *spi,
<span class="p_del">-			     u8 cmd, u8 addr, u16 val, u8 len)</span>
<span class="p_add">+			     u8 cmd, u8 addr, u16 val, u8 shift)</span>
 {
 	u32 data;
 	u8 msg[3];
<span class="p_chunk">@@ -35,7 +35,7 @@</span> <span class="p_context"> static int ad5624r_spi_write(struct spi_device *spi,</span>
 	 * 14-, 12-bit input code followed by 0, 2, or 4 don&#39;t care bits,
 	 * for the AD5664R, AD5644R, and AD5624R, respectively.
 	 */
<span class="p_del">-	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; (16 - len));</span>
<span class="p_add">+	data = (0 &lt;&lt; 22) | (cmd &lt;&lt; 19) | (addr &lt;&lt; 16) | (val &lt;&lt; shift);</span>
 	msg[0] = data &gt;&gt; 16;
 	msg[1] = data &gt;&gt; 8;
 	msg[2] = data;
<span class="p_header">diff --git a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">index 17d4bb15be4d..65ce86837177 100644</span>
<span class="p_header">--- a/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_header">+++ b/drivers/iio/imu/inv_mpu6050/inv_mpu_core.c</span>
<span class="p_chunk">@@ -431,6 +431,23 @@</span> <span class="p_context"> static int inv_mpu6050_write_gyro_scale(struct inv_mpu6050_state *st, int val)</span>
 	return -EINVAL;
 }
 
<span class="p_add">+static int inv_write_raw_get_fmt(struct iio_dev *indio_dev,</span>
<span class="p_add">+				 struct iio_chan_spec const *chan, long mask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (mask) {</span>
<span class="p_add">+	case IIO_CHAN_INFO_SCALE:</span>
<span class="p_add">+		switch (chan-&gt;type) {</span>
<span class="p_add">+		case IIO_ANGL_VEL:</span>
<span class="p_add">+			return IIO_VAL_INT_PLUS_NANO;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return IIO_VAL_INT_PLUS_MICRO;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return IIO_VAL_INT_PLUS_MICRO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
 static int inv_mpu6050_write_accel_scale(struct inv_mpu6050_state *st, int val)
 {
 	int result, i;
<span class="p_chunk">@@ -696,6 +713,7 @@</span> <span class="p_context"> static const struct iio_info mpu_info = {</span>
 	.driver_module = THIS_MODULE,
 	.read_raw = &amp;inv_mpu6050_read_raw,
 	.write_raw = &amp;inv_mpu6050_write_raw,
<span class="p_add">+	.write_raw_get_fmt = &amp;inv_write_raw_get_fmt,</span>
 	.attrs = &amp;inv_attribute_group,
 	.validate_trigger = inv_mpu6050_validate_trigger,
 };
<span class="p_header">diff --git a/drivers/iio/light/cm3323.c b/drivers/iio/light/cm3323.c</span>
<span class="p_header">index 869033e48a1f..a1d4905cc9d2 100644</span>
<span class="p_header">--- a/drivers/iio/light/cm3323.c</span>
<span class="p_header">+++ b/drivers/iio/light/cm3323.c</span>
<span class="p_chunk">@@ -123,7 +123,7 @@</span> <span class="p_context"> static int cm3323_set_it_bits(struct cm3323_data *data, int val, int val2)</span>
 	for (i = 0; i &lt; ARRAY_SIZE(cm3323_int_time); i++) {
 		if (val == cm3323_int_time[i].val &amp;&amp;
 		    val2 == cm3323_int_time[i].val2) {
<span class="p_del">-			reg_conf = data-&gt;reg_conf;</span>
<span class="p_add">+			reg_conf = data-&gt;reg_conf &amp; ~CM3323_CONF_IT_MASK;</span>
 			reg_conf |= i &lt;&lt; CM3323_CONF_IT_SHIFT;
 
 			ret = i2c_smbus_write_word_data(data-&gt;client,
<span class="p_header">diff --git a/drivers/iio/light/tcs3414.c b/drivers/iio/light/tcs3414.c</span>
<span class="p_header">index 71c2bde275aa..f8b1df018abe 100644</span>
<span class="p_header">--- a/drivers/iio/light/tcs3414.c</span>
<span class="p_header">+++ b/drivers/iio/light/tcs3414.c</span>
<span class="p_chunk">@@ -185,7 +185,7 @@</span> <span class="p_context"> static int tcs3414_write_raw(struct iio_dev *indio_dev,</span>
 		if (val != 0)
 			return -EINVAL;
 		for (i = 0; i &lt; ARRAY_SIZE(tcs3414_times); i++) {
<span class="p_del">-			if (val == tcs3414_times[i] * 1000) {</span>
<span class="p_add">+			if (val2 == tcs3414_times[i] * 1000) {</span>
 				data-&gt;timing &amp;= ~TCS3414_INTEG_MASK;
 				data-&gt;timing |= i;
 				return i2c_smbus_write_byte_data(
<span class="p_header">diff --git a/drivers/iio/proximity/sx9500.c b/drivers/iio/proximity/sx9500.c</span>
<span class="p_header">index fa40f6d0ca39..bd26a484abcc 100644</span>
<span class="p_header">--- a/drivers/iio/proximity/sx9500.c</span>
<span class="p_header">+++ b/drivers/iio/proximity/sx9500.c</span>
<span class="p_chunk">@@ -206,7 +206,7 @@</span> <span class="p_context"> static int sx9500_read_proximity(struct sx9500_data *data,</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	*val = 32767 - (s16)be16_to_cpu(regval);</span>
<span class="p_add">+	*val = be16_to_cpu(regval);</span>
 
 	return IIO_VAL_INT;
 }
<span class="p_header">diff --git a/drivers/iio/temperature/tmp006.c b/drivers/iio/temperature/tmp006.c</span>
<span class="p_header">index 84a0789c3d96..7a8050996b4e 100644</span>
<span class="p_header">--- a/drivers/iio/temperature/tmp006.c</span>
<span class="p_header">+++ b/drivers/iio/temperature/tmp006.c</span>
<span class="p_chunk">@@ -132,6 +132,9 @@</span> <span class="p_context"> static int tmp006_write_raw(struct iio_dev *indio_dev,</span>
 	struct tmp006_data *data = iio_priv(indio_dev);
 	int i;
 
<span class="p_add">+	if (mask != IIO_CHAN_INFO_SAMP_FREQ)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; ARRAY_SIZE(tmp006_freqs); i++)
 		if ((val == tmp006_freqs[i][0]) &amp;&amp;
 		    (val2 == tmp006_freqs[i][1])) {
<span class="p_header">diff --git a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c</span>
<span class="p_header">index 9dcb66077d6c..219f2122f9b9 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/ocrdma/ocrdma_verbs.c</span>
<span class="p_chunk">@@ -679,7 +679,6 @@</span> <span class="p_context"> err:</span>
 		ocrdma_release_ucontext_pd(uctx);
 	} else {
 		status = _ocrdma_dealloc_pd(dev, pd);
<span class="p_del">-		kfree(pd);</span>
 	}
 exit:
 	return ERR_PTR(status);
<span class="p_header">diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c</span>
<span class="p_header">index 135a0907e9de..c90118e90708 100644</span>
<span class="p_header">--- a/drivers/md/bitmap.c</span>
<span class="p_header">+++ b/drivers/md/bitmap.c</span>
<span class="p_chunk">@@ -494,7 +494,7 @@</span> <span class="p_context"> static int bitmap_new_disk_sb(struct bitmap *bitmap)</span>
 	bitmap_super_t *sb;
 	unsigned long chunksize, daemon_sleep, write_behind;
 
<span class="p_del">-	bitmap-&gt;storage.sb_page = alloc_page(GFP_KERNEL);</span>
<span class="p_add">+	bitmap-&gt;storage.sb_page = alloc_page(GFP_KERNEL | __GFP_ZERO);</span>
 	if (bitmap-&gt;storage.sb_page == NULL)
 		return -ENOMEM;
 	bitmap-&gt;storage.sb_page-&gt;index = 0;
<span class="p_chunk">@@ -541,6 +541,7 @@</span> <span class="p_context"> static int bitmap_new_disk_sb(struct bitmap *bitmap)</span>
 	sb-&gt;state = cpu_to_le32(bitmap-&gt;flags);
 	bitmap-&gt;events_cleared = bitmap-&gt;mddev-&gt;events;
 	sb-&gt;events_cleared = cpu_to_le64(bitmap-&gt;mddev-&gt;events);
<span class="p_add">+	bitmap-&gt;mddev-&gt;bitmap_info.nodes = 0;</span>
 
 	kunmap_atomic(sb);
 
<span class="p_chunk">@@ -611,8 +612,16 @@</span> <span class="p_context"> re_read:</span>
 	daemon_sleep = le32_to_cpu(sb-&gt;daemon_sleep) * HZ;
 	write_behind = le32_to_cpu(sb-&gt;write_behind);
 	sectors_reserved = le32_to_cpu(sb-&gt;sectors_reserved);
<span class="p_del">-	nodes = le32_to_cpu(sb-&gt;nodes);</span>
<span class="p_del">-	strlcpy(bitmap-&gt;mddev-&gt;bitmap_info.cluster_name, sb-&gt;cluster_name, 64);</span>
<span class="p_add">+	/* XXX: This is a hack to ensure that we don&#39;t use clustering</span>
<span class="p_add">+	 *  in case:</span>
<span class="p_add">+	 *	- dm-raid is in use and</span>
<span class="p_add">+	 *	- the nodes written in bitmap_sb is erroneous.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!bitmap-&gt;mddev-&gt;sync_super) {</span>
<span class="p_add">+		nodes = le32_to_cpu(sb-&gt;nodes);</span>
<span class="p_add">+		strlcpy(bitmap-&gt;mddev-&gt;bitmap_info.cluster_name,</span>
<span class="p_add">+				sb-&gt;cluster_name, 64);</span>
<span class="p_add">+	}</span>
 
 	/* verify that the bitmap-specific fields are valid */
 	if (sb-&gt;magic != cpu_to_le32(BITMAP_MAGIC))
<span class="p_header">diff --git a/drivers/md/dm-cache-policy-cleaner.c b/drivers/md/dm-cache-policy-cleaner.c</span>
<span class="p_header">index b04d1f904d07..004e463c9423 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy-cleaner.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy-cleaner.c</span>
<span class="p_chunk">@@ -171,7 +171,8 @@</span> <span class="p_context"> static void remove_cache_hash_entry(struct wb_cache_entry *e)</span>
 /* Public interface (see dm-cache-policy.h */
 static int wb_map(struct dm_cache_policy *pe, dm_oblock_t oblock,
 		  bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-		  struct bio *bio, struct policy_result *result)</span>
<span class="p_add">+		  struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+		  struct policy_result *result)</span>
 {
 	struct policy *p = to_policy(pe);
 	struct wb_cache_entry *e;
<span class="p_header">diff --git a/drivers/md/dm-cache-policy-internal.h b/drivers/md/dm-cache-policy-internal.h</span>
<span class="p_header">index 2256a1f24f73..c198e6defb9c 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy-internal.h</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy-internal.h</span>
<span class="p_chunk">@@ -16,9 +16,10 @@</span> <span class="p_context"></span>
  */
 static inline int policy_map(struct dm_cache_policy *p, dm_oblock_t oblock,
 			     bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-			     struct bio *bio, struct policy_result *result)</span>
<span class="p_add">+			     struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+			     struct policy_result *result)</span>
 {
<span class="p_del">-	return p-&gt;map(p, oblock, can_block, can_migrate, discarded_oblock, bio, result);</span>
<span class="p_add">+	return p-&gt;map(p, oblock, can_block, can_migrate, discarded_oblock, bio, locker, result);</span>
 }
 
 static inline int policy_lookup(struct dm_cache_policy *p, dm_oblock_t oblock, dm_cblock_t *cblock)
<span class="p_header">diff --git a/drivers/md/dm-cache-policy-mq.c b/drivers/md/dm-cache-policy-mq.c</span>
<span class="p_header">index 3ddd1162334d..515d44bf24d3 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy-mq.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy-mq.c</span>
<span class="p_chunk">@@ -693,9 +693,10 @@</span> <span class="p_context"> static void requeue(struct mq_policy *mq, struct entry *e)</span>
  * - set the hit count to a hard coded value other than 1, eg, is it better
  *   if it goes in at level 2?
  */
<span class="p_del">-static int demote_cblock(struct mq_policy *mq, dm_oblock_t *oblock)</span>
<span class="p_add">+static int demote_cblock(struct mq_policy *mq,</span>
<span class="p_add">+			 struct policy_locker *locker, dm_oblock_t *oblock)</span>
 {
<span class="p_del">-	struct entry *demoted = pop(mq, &amp;mq-&gt;cache_clean);</span>
<span class="p_add">+	struct entry *demoted = peek(&amp;mq-&gt;cache_clean);</span>
 
 	if (!demoted)
 		/*
<span class="p_chunk">@@ -707,6 +708,13 @@</span> <span class="p_context"> static int demote_cblock(struct mq_policy *mq, dm_oblock_t *oblock)</span>
 		 */
 		return -ENOSPC;
 
<span class="p_add">+	if (locker-&gt;fn(locker, demoted-&gt;oblock))</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We couldn&#39;t lock the demoted block.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	del(mq, demoted);</span>
 	*oblock = demoted-&gt;oblock;
 	free_entry(&amp;mq-&gt;cache_pool, demoted);
 
<span class="p_chunk">@@ -795,6 +803,7 @@</span> <span class="p_context"> static int cache_entry_found(struct mq_policy *mq,</span>
  * finding which cache block to use.
  */
 static int pre_cache_to_cache(struct mq_policy *mq, struct entry *e,
<span class="p_add">+			      struct policy_locker *locker,</span>
 			      struct policy_result *result)
 {
 	int r;
<span class="p_chunk">@@ -803,11 +812,12 @@</span> <span class="p_context"> static int pre_cache_to_cache(struct mq_policy *mq, struct entry *e,</span>
 	/* Ensure there&#39;s a free cblock in the cache */
 	if (epool_empty(&amp;mq-&gt;cache_pool)) {
 		result-&gt;op = POLICY_REPLACE;
<span class="p_del">-		r = demote_cblock(mq, &amp;result-&gt;old_oblock);</span>
<span class="p_add">+		r = demote_cblock(mq, locker, &amp;result-&gt;old_oblock);</span>
 		if (r) {
 			result-&gt;op = POLICY_MISS;
 			return 0;
 		}
<span class="p_add">+</span>
 	} else
 		result-&gt;op = POLICY_NEW;
 
<span class="p_chunk">@@ -829,7 +839,8 @@</span> <span class="p_context"> static int pre_cache_to_cache(struct mq_policy *mq, struct entry *e,</span>
 
 static int pre_cache_entry_found(struct mq_policy *mq, struct entry *e,
 				 bool can_migrate, bool discarded_oblock,
<span class="p_del">-				 int data_dir, struct policy_result *result)</span>
<span class="p_add">+				 int data_dir, struct policy_locker *locker,</span>
<span class="p_add">+				 struct policy_result *result)</span>
 {
 	int r = 0;
 
<span class="p_chunk">@@ -842,7 +853,7 @@</span> <span class="p_context"> static int pre_cache_entry_found(struct mq_policy *mq, struct entry *e,</span>
 
 	else {
 		requeue(mq, e);
<span class="p_del">-		r = pre_cache_to_cache(mq, e, result);</span>
<span class="p_add">+		r = pre_cache_to_cache(mq, e, locker, result);</span>
 	}
 
 	return r;
<span class="p_chunk">@@ -872,6 +883,7 @@</span> <span class="p_context"> static void insert_in_pre_cache(struct mq_policy *mq,</span>
 }
 
 static void insert_in_cache(struct mq_policy *mq, dm_oblock_t oblock,
<span class="p_add">+			    struct policy_locker *locker,</span>
 			    struct policy_result *result)
 {
 	int r;
<span class="p_chunk">@@ -879,7 +891,7 @@</span> <span class="p_context"> static void insert_in_cache(struct mq_policy *mq, dm_oblock_t oblock,</span>
 
 	if (epool_empty(&amp;mq-&gt;cache_pool)) {
 		result-&gt;op = POLICY_REPLACE;
<span class="p_del">-		r = demote_cblock(mq, &amp;result-&gt;old_oblock);</span>
<span class="p_add">+		r = demote_cblock(mq, locker, &amp;result-&gt;old_oblock);</span>
 		if (unlikely(r)) {
 			result-&gt;op = POLICY_MISS;
 			insert_in_pre_cache(mq, oblock);
<span class="p_chunk">@@ -907,11 +919,12 @@</span> <span class="p_context"> static void insert_in_cache(struct mq_policy *mq, dm_oblock_t oblock,</span>
 
 static int no_entry_found(struct mq_policy *mq, dm_oblock_t oblock,
 			  bool can_migrate, bool discarded_oblock,
<span class="p_del">-			  int data_dir, struct policy_result *result)</span>
<span class="p_add">+			  int data_dir, struct policy_locker *locker,</span>
<span class="p_add">+			  struct policy_result *result)</span>
 {
 	if (adjusted_promote_threshold(mq, discarded_oblock, data_dir) &lt;= 1) {
 		if (can_migrate)
<span class="p_del">-			insert_in_cache(mq, oblock, result);</span>
<span class="p_add">+			insert_in_cache(mq, oblock, locker, result);</span>
 		else
 			return -EWOULDBLOCK;
 	} else {
<span class="p_chunk">@@ -928,7 +941,8 @@</span> <span class="p_context"> static int no_entry_found(struct mq_policy *mq, dm_oblock_t oblock,</span>
  */
 static int map(struct mq_policy *mq, dm_oblock_t oblock,
 	       bool can_migrate, bool discarded_oblock,
<span class="p_del">-	       int data_dir, struct policy_result *result)</span>
<span class="p_add">+	       int data_dir, struct policy_locker *locker,</span>
<span class="p_add">+	       struct policy_result *result)</span>
 {
 	int r = 0;
 	struct entry *e = hash_lookup(mq, oblock);
<span class="p_chunk">@@ -942,11 +956,11 @@</span> <span class="p_context"> static int map(struct mq_policy *mq, dm_oblock_t oblock,</span>
 
 	else if (e)
 		r = pre_cache_entry_found(mq, e, can_migrate, discarded_oblock,
<span class="p_del">-					  data_dir, result);</span>
<span class="p_add">+					  data_dir, locker, result);</span>
 
 	else
 		r = no_entry_found(mq, oblock, can_migrate, discarded_oblock,
<span class="p_del">-				   data_dir, result);</span>
<span class="p_add">+				   data_dir, locker, result);</span>
 
 	if (r == -EWOULDBLOCK)
 		result-&gt;op = POLICY_MISS;
<span class="p_chunk">@@ -1012,7 +1026,8 @@</span> <span class="p_context"> static void copy_tick(struct mq_policy *mq)</span>
 
 static int mq_map(struct dm_cache_policy *p, dm_oblock_t oblock,
 		  bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-		  struct bio *bio, struct policy_result *result)</span>
<span class="p_add">+		  struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+		  struct policy_result *result)</span>
 {
 	int r;
 	struct mq_policy *mq = to_mq_policy(p);
<span class="p_chunk">@@ -1028,7 +1043,7 @@</span> <span class="p_context"> static int mq_map(struct dm_cache_policy *p, dm_oblock_t oblock,</span>
 
 	iot_examine_bio(&amp;mq-&gt;tracker, bio);
 	r = map(mq, oblock, can_migrate, discarded_oblock,
<span class="p_del">-		bio_data_dir(bio), result);</span>
<span class="p_add">+		bio_data_dir(bio), locker, result);</span>
 
 	mutex_unlock(&amp;mq-&gt;lock);
 
<span class="p_header">diff --git a/drivers/md/dm-cache-policy.h b/drivers/md/dm-cache-policy.h</span>
<span class="p_header">index f50fe360c546..5524e21e4836 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-policy.h</span>
<span class="p_header">+++ b/drivers/md/dm-cache-policy.h</span>
<span class="p_chunk">@@ -70,6 +70,18 @@</span> <span class="p_context"> enum policy_operation {</span>
 };
 
 /*
<span class="p_add">+ * When issuing a POLICY_REPLACE the policy needs to make a callback to</span>
<span class="p_add">+ * lock the block being demoted.  This doesn&#39;t need to occur during a</span>
<span class="p_add">+ * writeback operation since the block remains in the cache.</span>
<span class="p_add">+ */</span>
<span class="p_add">+struct policy_locker;</span>
<span class="p_add">+typedef int (*policy_lock_fn)(struct policy_locker *l, dm_oblock_t oblock);</span>
<span class="p_add">+</span>
<span class="p_add">+struct policy_locker {</span>
<span class="p_add">+	policy_lock_fn fn;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * This is the instruction passed back to the core target.
  */
 struct policy_result {
<span class="p_chunk">@@ -122,7 +134,8 @@</span> <span class="p_context"> struct dm_cache_policy {</span>
 	 */
 	int (*map)(struct dm_cache_policy *p, dm_oblock_t oblock,
 		   bool can_block, bool can_migrate, bool discarded_oblock,
<span class="p_del">-		   struct bio *bio, struct policy_result *result);</span>
<span class="p_add">+		   struct bio *bio, struct policy_locker *locker,</span>
<span class="p_add">+		   struct policy_result *result);</span>
 
 	/*
 	 * Sometimes we want to see if a block is in the cache, without
<span class="p_header">diff --git a/drivers/md/dm-cache-target.c b/drivers/md/dm-cache-target.c</span>
<span class="p_header">index 7755af351867..e049becaaf2d 100644</span>
<span class="p_header">--- a/drivers/md/dm-cache-target.c</span>
<span class="p_header">+++ b/drivers/md/dm-cache-target.c</span>
<span class="p_chunk">@@ -1445,16 +1445,43 @@</span> <span class="p_context"> static void inc_miss_counter(struct cache *cache, struct bio *bio)</span>
 		   &amp;cache-&gt;stats.read_miss : &amp;cache-&gt;stats.write_miss);
 }
 
<span class="p_add">+/*----------------------------------------------------------------*/</span>
<span class="p_add">+</span>
<span class="p_add">+struct old_oblock_lock {</span>
<span class="p_add">+	struct policy_locker locker;</span>
<span class="p_add">+	struct cache *cache;</span>
<span class="p_add">+	struct prealloc *structs;</span>
<span class="p_add">+	struct dm_bio_prison_cell *cell;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static int null_locker(struct policy_locker *locker, dm_oblock_t b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* This should never be called */</span>
<span class="p_add">+	BUG();</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int cell_locker(struct policy_locker *locker, dm_oblock_t b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct old_oblock_lock *l = container_of(locker, struct old_oblock_lock, locker);</span>
<span class="p_add">+	struct dm_bio_prison_cell *cell_prealloc = prealloc_get_cell(l-&gt;structs);</span>
<span class="p_add">+</span>
<span class="p_add">+	return bio_detain(l-&gt;cache, b, NULL, cell_prealloc,</span>
<span class="p_add">+			  (cell_free_fn) prealloc_put_cell,</span>
<span class="p_add">+			  l-&gt;structs, &amp;l-&gt;cell);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void process_bio(struct cache *cache, struct prealloc *structs,
 			struct bio *bio)
 {
 	int r;
 	bool release_cell = true;
 	dm_oblock_t block = get_bio_block(cache, bio);
<span class="p_del">-	struct dm_bio_prison_cell *cell_prealloc, *old_ocell, *new_ocell;</span>
<span class="p_add">+	struct dm_bio_prison_cell *cell_prealloc, *new_ocell;</span>
 	struct policy_result lookup_result;
 	bool passthrough = passthrough_mode(&amp;cache-&gt;features);
 	bool discarded_block, can_migrate;
<span class="p_add">+	struct old_oblock_lock ool;</span>
 
 	/*
 	 * Check to see if that block is currently migrating.
<span class="p_chunk">@@ -1469,8 +1496,12 @@</span> <span class="p_context"> static void process_bio(struct cache *cache, struct prealloc *structs,</span>
 	discarded_block = is_discarded_oblock(cache, block);
 	can_migrate = !passthrough &amp;&amp; (discarded_block || spare_migration_bandwidth(cache));
 
<span class="p_add">+	ool.locker.fn = cell_locker;</span>
<span class="p_add">+	ool.cache = cache;</span>
<span class="p_add">+	ool.structs = structs;</span>
<span class="p_add">+	ool.cell = NULL;</span>
 	r = policy_map(cache-&gt;policy, block, true, can_migrate, discarded_block,
<span class="p_del">-		       bio, &amp;lookup_result);</span>
<span class="p_add">+		       bio, &amp;ool.locker, &amp;lookup_result);</span>
 
 	if (r == -EWOULDBLOCK)
 		/* migration has been denied */
<span class="p_chunk">@@ -1527,27 +1558,11 @@</span> <span class="p_context"> static void process_bio(struct cache *cache, struct prealloc *structs,</span>
 		break;
 
 	case POLICY_REPLACE:
<span class="p_del">-		cell_prealloc = prealloc_get_cell(structs);</span>
<span class="p_del">-		r = bio_detain(cache, lookup_result.old_oblock, bio, cell_prealloc,</span>
<span class="p_del">-			       (cell_free_fn) prealloc_put_cell,</span>
<span class="p_del">-			       structs, &amp;old_ocell);</span>
<span class="p_del">-		if (r &gt; 0) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We have to be careful to avoid lock inversion of</span>
<span class="p_del">-			 * the cells.  So we back off, and wait for the</span>
<span class="p_del">-			 * old_ocell to become free.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			policy_force_mapping(cache-&gt;policy, block,</span>
<span class="p_del">-					     lookup_result.old_oblock);</span>
<span class="p_del">-			atomic_inc(&amp;cache-&gt;stats.cache_cell_clash);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
 		atomic_inc(&amp;cache-&gt;stats.demotion);
 		atomic_inc(&amp;cache-&gt;stats.promotion);
<span class="p_del">-</span>
 		demote_then_promote(cache, structs, lookup_result.old_oblock,
 				    block, lookup_result.cblock,
<span class="p_del">-				    old_ocell, new_ocell);</span>
<span class="p_add">+				    ool.cell, new_ocell);</span>
 		release_cell = false;
 		break;
 
<span class="p_chunk">@@ -2595,6 +2610,9 @@</span> <span class="p_context"> static int __cache_map(struct cache *cache, struct bio *bio, struct dm_bio_priso</span>
 	bool discarded_block;
 	struct policy_result lookup_result;
 	struct per_bio_data *pb = init_per_bio_data(bio, pb_data_size);
<span class="p_add">+	struct old_oblock_lock ool;</span>
<span class="p_add">+</span>
<span class="p_add">+	ool.locker.fn = null_locker;</span>
 
 	if (unlikely(from_oblock(block) &gt;= from_oblock(cache-&gt;origin_blocks))) {
 		/*
<span class="p_chunk">@@ -2633,7 +2651,7 @@</span> <span class="p_context"> static int __cache_map(struct cache *cache, struct bio *bio, struct dm_bio_priso</span>
 	discarded_block = is_discarded_oblock(cache, block);
 
 	r = policy_map(cache-&gt;policy, block, false, can_migrate, discarded_block,
<span class="p_del">-		       bio, &amp;lookup_result);</span>
<span class="p_add">+		       bio, &amp;ool.locker, &amp;lookup_result);</span>
 	if (r == -EWOULDBLOCK) {
 		cell_defer(cache, *cell, true);
 		return DM_MAPIO_SUBMITTED;
<span class="p_header">diff --git a/drivers/md/dm-stats.c b/drivers/md/dm-stats.c</span>
<span class="p_header">index f478a4c96d2f..419bdd4fc8b8 100644</span>
<span class="p_header">--- a/drivers/md/dm-stats.c</span>
<span class="p_header">+++ b/drivers/md/dm-stats.c</span>
<span class="p_chunk">@@ -795,6 +795,8 @@</span> <span class="p_context"> static int message_stats_create(struct mapped_device *md,</span>
 		return -EINVAL;
 
 	if (sscanf(argv[2], &quot;/%u%c&quot;, &amp;divisor, &amp;dummy) == 1) {
<span class="p_add">+		if (!divisor)</span>
<span class="p_add">+			return -EINVAL;</span>
 		step = end - start;
 		if (do_div(step, divisor))
 			step++;
<span class="p_header">diff --git a/drivers/md/dm-thin.c b/drivers/md/dm-thin.c</span>
<span class="p_header">index 921aafd12aee..e22e6c892b8a 100644</span>
<span class="p_header">--- a/drivers/md/dm-thin.c</span>
<span class="p_header">+++ b/drivers/md/dm-thin.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/module.h&gt;
 #include &lt;linux/slab.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
 #include &lt;linux/sort.h&gt;
 #include &lt;linux/rbtree.h&gt;
 
<span class="p_chunk">@@ -260,7 +261,7 @@</span> <span class="p_context"> struct pool {</span>
 	process_mapping_fn process_prepared_mapping;
 	process_mapping_fn process_prepared_discard;
 
<span class="p_del">-	struct dm_bio_prison_cell *cell_sort_array[CELL_SORT_ARRAY_SIZE];</span>
<span class="p_add">+	struct dm_bio_prison_cell **cell_sort_array;</span>
 };
 
 static enum pool_mode get_pool_mode(struct pool *pool);
<span class="p_chunk">@@ -2499,6 +2500,7 @@</span> <span class="p_context"> static void __pool_destroy(struct pool *pool)</span>
 {
 	__pool_table_remove(pool);
 
<span class="p_add">+	vfree(pool-&gt;cell_sort_array);</span>
 	if (dm_pool_metadata_close(pool-&gt;pmd) &lt; 0)
 		DMWARN(&quot;%s: dm_pool_metadata_close() failed.&quot;, __func__);
 
<span class="p_chunk">@@ -2611,6 +2613,13 @@</span> <span class="p_context"> static struct pool *pool_create(struct mapped_device *pool_md,</span>
 		goto bad_mapping_pool;
 	}
 
<span class="p_add">+	pool-&gt;cell_sort_array = vmalloc(sizeof(*pool-&gt;cell_sort_array) * CELL_SORT_ARRAY_SIZE);</span>
<span class="p_add">+	if (!pool-&gt;cell_sort_array) {</span>
<span class="p_add">+		*error = &quot;Error allocating cell sort array&quot;;</span>
<span class="p_add">+		err_p = ERR_PTR(-ENOMEM);</span>
<span class="p_add">+		goto bad_sort_array;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	pool-&gt;ref_count = 1;
 	pool-&gt;last_commit_jiffies = jiffies;
 	pool-&gt;pool_md = pool_md;
<span class="p_chunk">@@ -2619,6 +2628,8 @@</span> <span class="p_context"> static struct pool *pool_create(struct mapped_device *pool_md,</span>
 
 	return pool;
 
<span class="p_add">+bad_sort_array:</span>
<span class="p_add">+	mempool_destroy(pool-&gt;mapping_pool);</span>
 bad_mapping_pool:
 	dm_deferred_set_destroy(pool-&gt;all_io_ds);
 bad_all_io_ds:
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 4dbed4a67aaf..b9200282fd77 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -4005,8 +4005,10 @@</span> <span class="p_context"> new_dev_store(struct mddev *mddev, const char *buf, size_t len)</span>
 	else
 		rdev = md_import_device(dev, -1, -1);
 
<span class="p_del">-	if (IS_ERR(rdev))</span>
<span class="p_add">+	if (IS_ERR(rdev)) {</span>
<span class="p_add">+		mddev_unlock(mddev);</span>
 		return PTR_ERR(rdev);
<span class="p_add">+	}</span>
 	err = bind_rdev_to_array(rdev, mddev);
  out:
 	if (err)
<span class="p_chunk">@@ -5159,6 +5161,7 @@</span> <span class="p_context"> int md_run(struct mddev *mddev)</span>
 		mddev_detach(mddev);
 		if (mddev-&gt;private)
 			pers-&gt;free(mddev, mddev-&gt;private);
<span class="p_add">+		mddev-&gt;private = NULL;</span>
 		module_put(pers-&gt;owner);
 		bitmap_destroy(mddev);
 		return err;
<span class="p_chunk">@@ -5294,6 +5297,7 @@</span> <span class="p_context"> static void md_clean(struct mddev *mddev)</span>
 	mddev-&gt;changed = 0;
 	mddev-&gt;degraded = 0;
 	mddev-&gt;safemode = 0;
<span class="p_add">+	mddev-&gt;private = NULL;</span>
 	mddev-&gt;merge_check_needed = 0;
 	mddev-&gt;bitmap_info.offset = 0;
 	mddev-&gt;bitmap_info.default_offset = 0;
<span class="p_chunk">@@ -5366,6 +5370,7 @@</span> <span class="p_context"> static void __md_stop(struct mddev *mddev)</span>
 	mddev-&gt;pers = NULL;
 	spin_unlock(&amp;mddev-&gt;lock);
 	pers-&gt;free(mddev, mddev-&gt;private);
<span class="p_add">+	mddev-&gt;private = NULL;</span>
 	if (pers-&gt;sync_request &amp;&amp; mddev-&gt;to_remove == NULL)
 		mddev-&gt;to_remove = &amp;md_redundancy_group;
 	module_put(pers-&gt;owner);
<span class="p_chunk">@@ -6375,7 +6380,7 @@</span> <span class="p_context"> static int update_array_info(struct mddev *mddev, mdu_array_info_t *info)</span>
 	    mddev-&gt;ctime         != info-&gt;ctime         ||
 	    mddev-&gt;level         != info-&gt;level         ||
 /*	    mddev-&gt;layout        != info-&gt;layout        || */
<span class="p_del">-	    !mddev-&gt;persistent	 != info-&gt;not_persistent||</span>
<span class="p_add">+	    mddev-&gt;persistent	 != !info-&gt;not_persistent ||</span>
 	    mddev-&gt;chunk_sectors != info-&gt;chunk_size &gt;&gt; 9 ||
 	    /* ignore bottom 8 bits of state, and allow SB_BITMAP_PRESENT to change */
 	    ((state^info-&gt;state) &amp; 0xfffffe00)
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree-remove.c b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">index b88757cd0d1d..a03178e91a79 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree-remove.c</span>
<span class="p_chunk">@@ -309,8 +309,8 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 
 		if (s &lt; 0 &amp;&amp; nr_center &lt; -s) {
 			/* not enough in central node */
<span class="p_del">-			shift(left, center, nr_center);</span>
<span class="p_del">-			s = nr_center - target;</span>
<span class="p_add">+			shift(left, center, -nr_center);</span>
<span class="p_add">+			s += nr_center;</span>
 			shift(left, right, s);
 			nr_right += s;
 		} else
<span class="p_chunk">@@ -323,7 +323,7 @@</span> <span class="p_context"> static void redistribute3(struct dm_btree_info *info, struct btree_node *parent,</span>
 		if (s &gt; 0 &amp;&amp; nr_center &lt; s) {
 			/* not enough in central node */
 			shift(center, right, nr_center);
<span class="p_del">-			s = target - nr_center;</span>
<span class="p_add">+			s -= nr_center;</span>
 			shift(left, right, s);
 			nr_left -= s;
 		} else
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-btree.c b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">index 200ac12a1d40..fdd3793e22f9 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-btree.c</span>
<span class="p_chunk">@@ -255,7 +255,7 @@</span> <span class="p_context"> int dm_btree_del(struct dm_btree_info *info, dm_block_t root)</span>
 	int r;
 	struct del_stack *s;
 
<span class="p_del">-	s = kmalloc(sizeof(*s), GFP_KERNEL);</span>
<span class="p_add">+	s = kmalloc(sizeof(*s), GFP_NOIO);</span>
 	if (!s)
 		return -ENOMEM;
 	s-&gt;info = info;
<span class="p_header">diff --git a/drivers/md/persistent-data/dm-space-map-metadata.c b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">index e8a904298887..53091295fce9 100644</span>
<span class="p_header">--- a/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_header">+++ b/drivers/md/persistent-data/dm-space-map-metadata.c</span>
<span class="p_chunk">@@ -204,6 +204,27 @@</span> <span class="p_context"> static void in(struct sm_metadata *smm)</span>
 	smm-&gt;recursion_count++;
 }
 
<span class="p_add">+static int apply_bops(struct sm_metadata *smm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int r = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_add">+		struct block_op bop;</span>
<span class="p_add">+</span>
<span class="p_add">+		r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		r = commit_bop(smm, &amp;bop);</span>
<span class="p_add">+		if (r)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return r;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int out(struct sm_metadata *smm)
 {
 	int r = 0;
<span class="p_chunk">@@ -216,21 +237,8 @@</span> <span class="p_context"> static int out(struct sm_metadata *smm)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	if (smm-&gt;recursion_count == 1) {</span>
<span class="p_del">-		while (!brb_empty(&amp;smm-&gt;uncommitted)) {</span>
<span class="p_del">-			struct block_op bop;</span>
<span class="p_del">-</span>
<span class="p_del">-			r = brb_pop(&amp;smm-&gt;uncommitted, &amp;bop);</span>
<span class="p_del">-			if (r) {</span>
<span class="p_del">-				DMERR(&quot;bug in bop ring buffer&quot;);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_del">-</span>
<span class="p_del">-			r = commit_bop(smm, &amp;bop);</span>
<span class="p_del">-			if (r)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (smm-&gt;recursion_count == 1)</span>
<span class="p_add">+		apply_bops(smm);</span>
 
 	smm-&gt;recursion_count--;
 
<span class="p_chunk">@@ -704,6 +712,12 @@</span> <span class="p_context"> static int sm_metadata_extend(struct dm_space_map *sm, dm_block_t extra_blocks)</span>
 		}
 		old_len = smm-&gt;begin;
 
<span class="p_add">+		r = apply_bops(smm);</span>
<span class="p_add">+		if (r) {</span>
<span class="p_add">+			DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		r = sm_ll_commit(&amp;smm-&gt;ll);
 		if (r)
 			goto out;
<span class="p_chunk">@@ -773,6 +787,12 @@</span> <span class="p_context"> int dm_sm_metadata_create(struct dm_space_map *sm,</span>
 	if (r)
 		return r;
 
<span class="p_add">+	r = apply_bops(smm);</span>
<span class="p_add">+	if (r) {</span>
<span class="p_add">+		DMERR(&quot;%s: apply_bops failed&quot;, __func__);</span>
<span class="p_add">+		return r;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return sm_metadata_commit(sm);
 }
 
<span class="p_header">diff --git a/drivers/media/dvb-frontends/af9013.c b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">index 8001690d7576..ba6c8f6c42a1 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/af9013.c</span>
<span class="p_chunk">@@ -605,6 +605,10 @@</span> <span class="p_context"> static int af9013_set_frontend(struct dvb_frontend *fe)</span>
 			}
 		}
 
<span class="p_add">+		/* Return an error if can&#39;t find bandwidth or the right clock */</span>
<span class="p_add">+		if (i == ARRAY_SIZE(coeff_lut))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		ret = af9013_wr_regs(state, 0xae00, coeff_lut[i].val,
 			sizeof(coeff_lut[i].val));
 	}
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24116.c b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">index 2916d7c74a1d..7bc68b355c0b 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24116.c</span>
<span class="p_chunk">@@ -963,6 +963,10 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	struct cx24116_state *state = fe-&gt;demodulator_priv;
 	int i, ret;
 
<span class="p_add">+	/* Validate length */</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
<span class="p_add">+                return -EINVAL;</span>
<span class="p_add">+</span>
 	/* Dump DiSEqC message */
 	if (debug) {
 		printk(KERN_INFO &quot;cx24116: %s(&quot;, __func__);
<span class="p_chunk">@@ -974,10 +978,6 @@</span> <span class="p_context"> static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,</span>
 		printk(&quot;) toneburst=%d\n&quot;, toneburst);
 	}
 
<span class="p_del">-	/* Validate length */</span>
<span class="p_del">-	if (d-&gt;msg_len &gt; (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DiSEqC message */
 	for (i = 0; i &lt; d-&gt;msg_len; i++)
 		state-&gt;dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d-&gt;msg[i];
<span class="p_header">diff --git a/drivers/media/dvb-frontends/cx24117.c b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">index acb965ce0358..af6363573efd 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/cx24117.c</span>
<span class="p_chunk">@@ -1043,7 +1043,7 @@</span> <span class="p_context"> static int cx24117_send_diseqc_msg(struct dvb_frontend *fe,</span>
 	dev_dbg(&amp;state-&gt;priv-&gt;i2c-&gt;dev, &quot;)\n&quot;);
 
 	/* Validate length */
<span class="p_del">-	if (d-&gt;msg_len &gt; 15)</span>
<span class="p_add">+	if (d-&gt;msg_len &gt; sizeof(d-&gt;msg))</span>
 		return -EINVAL;
 
 	/* DiSEqC message */
<span class="p_header">diff --git a/drivers/media/dvb-frontends/s5h1420.c b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">index 93eeaf7118fd..0b4f8fe6bf99 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/s5h1420.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static int s5h1420_send_master_cmd (struct dvb_frontend* fe,</span>
 	int result = 0;
 
 	dprintk(&quot;enter %s\n&quot;, __func__);
<span class="p_del">-	if (cmd-&gt;msg_len &gt; 8)</span>
<span class="p_add">+	if (cmd-&gt;msg_len &gt; sizeof(cmd-&gt;msg))</span>
 		return -EINVAL;
 
 	/* setup for DISEQC */
<span class="p_header">diff --git a/drivers/media/pci/cx18/cx18-streams.c b/drivers/media/pci/cx18/cx18-streams.c</span>
<span class="p_header">index c82d25d53341..c9860845264f 100644</span>
<span class="p_header">--- a/drivers/media/pci/cx18/cx18-streams.c</span>
<span class="p_header">+++ b/drivers/media/pci/cx18/cx18-streams.c</span>
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"> static struct {</span>
 		&quot;encoder PCM audio&quot;,
 		VFL_TYPE_GRABBER, CX18_V4L2_ENC_PCM_OFFSET,
 		PCI_DMA_FROMDEVICE,
<span class="p_add">+		V4L2_CAP_TUNER | V4L2_CAP_AUDIO | V4L2_CAP_READWRITE,</span>
 	},
 	{	/* CX18_ENC_STREAM_TYPE_IDX */
 		&quot;encoder IDX&quot;,
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-encoder.c b/drivers/media/pci/saa7164/saa7164-encoder.c</span>
<span class="p_header">index 9266965412c3..7a0a65146723 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-encoder.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-encoder.c</span>
<span class="p_chunk">@@ -721,13 +721,14 @@</span> <span class="p_context"> static int vidioc_querycap(struct file *file, void  *priv,</span>
 		sizeof(cap-&gt;card));
 	sprintf(cap-&gt;bus_info, &quot;PCI:%s&quot;, pci_name(dev-&gt;pci));
 
<span class="p_del">-	cap-&gt;capabilities =</span>
<span class="p_add">+	cap-&gt;device_caps =</span>
 		V4L2_CAP_VIDEO_CAPTURE |
<span class="p_del">-		V4L2_CAP_READWRITE     |</span>
<span class="p_del">-		0;</span>
<span class="p_add">+		V4L2_CAP_READWRITE |</span>
<span class="p_add">+		V4L2_CAP_TUNER;</span>
 
<span class="p_del">-	cap-&gt;capabilities |= V4L2_CAP_TUNER;</span>
<span class="p_del">-	cap-&gt;version = 0;</span>
<span class="p_add">+	cap-&gt;capabilities = cap-&gt;device_caps |</span>
<span class="p_add">+		V4L2_CAP_VBI_CAPTURE |</span>
<span class="p_add">+		V4L2_CAP_DEVICE_CAPS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/media/pci/saa7164/saa7164-vbi.c b/drivers/media/pci/saa7164/saa7164-vbi.c</span>
<span class="p_header">index 6e025fea2542..06117e6c0596 100644</span>
<span class="p_header">--- a/drivers/media/pci/saa7164/saa7164-vbi.c</span>
<span class="p_header">+++ b/drivers/media/pci/saa7164/saa7164-vbi.c</span>
<span class="p_chunk">@@ -660,13 +660,14 @@</span> <span class="p_context"> static int vidioc_querycap(struct file *file, void  *priv,</span>
 		sizeof(cap-&gt;card));
 	sprintf(cap-&gt;bus_info, &quot;PCI:%s&quot;, pci_name(dev-&gt;pci));
 
<span class="p_del">-	cap-&gt;capabilities =</span>
<span class="p_add">+	cap-&gt;device_caps =</span>
 		V4L2_CAP_VBI_CAPTURE |
<span class="p_del">-		V4L2_CAP_READWRITE     |</span>
<span class="p_del">-		0;</span>
<span class="p_add">+		V4L2_CAP_READWRITE |</span>
<span class="p_add">+		V4L2_CAP_TUNER;</span>
 
<span class="p_del">-	cap-&gt;capabilities |= V4L2_CAP_TUNER;</span>
<span class="p_del">-	cap-&gt;version = 0;</span>
<span class="p_add">+	cap-&gt;capabilities = cap-&gt;device_caps |</span>
<span class="p_add">+		V4L2_CAP_VIDEO_CAPTURE |</span>
<span class="p_add">+		V4L2_CAP_DEVICE_CAPS;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dib0700_core.c b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">index 2b40393836ff..0d248ce02a9b 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_chunk">@@ -655,10 +655,20 @@</span> <span class="p_context"> out:</span>
 struct dib0700_rc_response {
 	u8 report_id;
 	u8 data_state;
<span class="p_del">-	u8 system;</span>
<span class="p_del">-	u8 not_system;</span>
<span class="p_del">-	u8 data;</span>
<span class="p_del">-	u8 not_data;</span>
<span class="p_add">+	union {</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			u8 system;</span>
<span class="p_add">+			u8 not_system;</span>
<span class="p_add">+			u8 data;</span>
<span class="p_add">+			u8 not_data;</span>
<span class="p_add">+		} nec;</span>
<span class="p_add">+		struct {</span>
<span class="p_add">+			u8 not_used;</span>
<span class="p_add">+			u8 system;</span>
<span class="p_add">+			u8 data;</span>
<span class="p_add">+			u8 not_data;</span>
<span class="p_add">+		} rc5;</span>
<span class="p_add">+	};</span>
 };
 #define RC_MSG_SIZE_V1_20 6
 
<span class="p_chunk">@@ -694,8 +704,8 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 
 	deb_data(&quot;IR ID = %02X state = %02X System = %02X %02X Cmd = %02X %02X (len %d)\n&quot;,
 		 poll_reply-&gt;report_id, poll_reply-&gt;data_state,
<span class="p_del">-		 poll_reply-&gt;system, poll_reply-&gt;not_system,</span>
<span class="p_del">-		 poll_reply-&gt;data, poll_reply-&gt;not_data,</span>
<span class="p_add">+		 poll_reply-&gt;nec.system, poll_reply-&gt;nec.not_system,</span>
<span class="p_add">+		 poll_reply-&gt;nec.data, poll_reply-&gt;nec.not_data,</span>
 		 purb-&gt;actual_length);
 
 	switch (d-&gt;props.rc.core.protocol) {
<span class="p_chunk">@@ -704,30 +714,30 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 		toggle = 0;
 
 		/* NEC protocol sends repeat code as 0 0 0 FF */
<span class="p_del">-		if (poll_reply-&gt;system     == 0x00 &amp;&amp;</span>
<span class="p_del">-		    poll_reply-&gt;not_system == 0x00 &amp;&amp;</span>
<span class="p_del">-		    poll_reply-&gt;data       == 0x00 &amp;&amp;</span>
<span class="p_del">-		    poll_reply-&gt;not_data   == 0xff) {</span>
<span class="p_add">+		if (poll_reply-&gt;nec.system     == 0x00 &amp;&amp;</span>
<span class="p_add">+		    poll_reply-&gt;nec.not_system == 0x00 &amp;&amp;</span>
<span class="p_add">+		    poll_reply-&gt;nec.data       == 0x00 &amp;&amp;</span>
<span class="p_add">+		    poll_reply-&gt;nec.not_data   == 0xff) {</span>
 			poll_reply-&gt;data_state = 2;
 			break;
 		}
 
<span class="p_del">-		if ((poll_reply-&gt;data ^ poll_reply-&gt;not_data) != 0xff) {</span>
<span class="p_add">+		if ((poll_reply-&gt;nec.data ^ poll_reply-&gt;nec.not_data) != 0xff) {</span>
 			deb_data(&quot;NEC32 protocol\n&quot;);
<span class="p_del">-			keycode = RC_SCANCODE_NEC32(poll_reply-&gt;system     &lt;&lt; 24 |</span>
<span class="p_del">-						     poll_reply-&gt;not_system &lt;&lt; 16 |</span>
<span class="p_del">-						     poll_reply-&gt;data       &lt;&lt; 8  |</span>
<span class="p_del">-						     poll_reply-&gt;not_data);</span>
<span class="p_del">-		} else if ((poll_reply-&gt;system ^ poll_reply-&gt;not_system) != 0xff) {</span>
<span class="p_add">+			keycode = RC_SCANCODE_NEC32(poll_reply-&gt;nec.system     &lt;&lt; 24 |</span>
<span class="p_add">+						     poll_reply-&gt;nec.not_system &lt;&lt; 16 |</span>
<span class="p_add">+						     poll_reply-&gt;nec.data       &lt;&lt; 8  |</span>
<span class="p_add">+						     poll_reply-&gt;nec.not_data);</span>
<span class="p_add">+		} else if ((poll_reply-&gt;nec.system ^ poll_reply-&gt;nec.not_system) != 0xff) {</span>
 			deb_data(&quot;NEC extended protocol\n&quot;);
<span class="p_del">-			keycode = RC_SCANCODE_NECX(poll_reply-&gt;system &lt;&lt; 8 |</span>
<span class="p_del">-						    poll_reply-&gt;not_system,</span>
<span class="p_del">-						    poll_reply-&gt;data);</span>
<span class="p_add">+			keycode = RC_SCANCODE_NECX(poll_reply-&gt;nec.system &lt;&lt; 8 |</span>
<span class="p_add">+						    poll_reply-&gt;nec.not_system,</span>
<span class="p_add">+						    poll_reply-&gt;nec.data);</span>
 
 		} else {
 			deb_data(&quot;NEC normal protocol\n&quot;);
<span class="p_del">-			keycode = RC_SCANCODE_NEC(poll_reply-&gt;system,</span>
<span class="p_del">-						   poll_reply-&gt;data);</span>
<span class="p_add">+			keycode = RC_SCANCODE_NEC(poll_reply-&gt;nec.system,</span>
<span class="p_add">+						   poll_reply-&gt;nec.data);</span>
 		}
 
 		break;
<span class="p_chunk">@@ -735,19 +745,19 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 		deb_data(&quot;RC5 protocol\n&quot;);
 		protocol = RC_TYPE_RC5;
 		toggle = poll_reply-&gt;report_id;
<span class="p_del">-		keycode = RC_SCANCODE_RC5(poll_reply-&gt;system, poll_reply-&gt;data);</span>
<span class="p_add">+		keycode = RC_SCANCODE_RC5(poll_reply-&gt;rc5.system, poll_reply-&gt;rc5.data);</span>
<span class="p_add">+</span>
<span class="p_add">+		if ((poll_reply-&gt;rc5.data ^ poll_reply-&gt;rc5.not_data) != 0xff) {</span>
<span class="p_add">+			/* Key failed integrity check */</span>
<span class="p_add">+			err(&quot;key failed integrity check: %02x %02x %02x %02x&quot;,</span>
<span class="p_add">+			    poll_reply-&gt;rc5.not_used, poll_reply-&gt;rc5.system,</span>
<span class="p_add">+			    poll_reply-&gt;rc5.data, poll_reply-&gt;rc5.not_data);</span>
<span class="p_add">+			goto resubmit;</span>
<span class="p_add">+		}</span>
 
 		break;
 	}
 
<span class="p_del">-	if ((poll_reply-&gt;data + poll_reply-&gt;not_data) != 0xff) {</span>
<span class="p_del">-		/* Key failed integrity check */</span>
<span class="p_del">-		err(&quot;key failed integrity check: %02x %02x %02x %02x&quot;,</span>
<span class="p_del">-		    poll_reply-&gt;system,  poll_reply-&gt;not_system,</span>
<span class="p_del">-		    poll_reply-&gt;data, poll_reply-&gt;not_data);</span>
<span class="p_del">-		goto resubmit;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	rc_keydown(d-&gt;rc_dev, protocol, keycode, toggle);
 
 resubmit:
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dib0700_devices.c b/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_header">index d7d55a20e959..c170523226aa 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dib0700_devices.c</span>
<span class="p_chunk">@@ -3944,6 +3944,8 @@</span> <span class="p_context"> struct dvb_usb_device_properties dib0700_devices[] = {</span>
 
 				DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
 			}},
<span class="p_add">+				.size_of_priv = sizeof(struct</span>
<span class="p_add">+						dib0700_adapter_state),</span>
 			}, {
 			.num_frontends = 1,
 			.fe = {{
<span class="p_chunk">@@ -3956,6 +3958,8 @@</span> <span class="p_context"> struct dvb_usb_device_properties dib0700_devices[] = {</span>
 
 				DIB0700_DEFAULT_STREAMING_CONFIG(0x03),
 			}},
<span class="p_add">+				.size_of_priv = sizeof(struct</span>
<span class="p_add">+						dib0700_adapter_state),</span>
 			}
 		},
 
<span class="p_chunk">@@ -4009,6 +4013,8 @@</span> <span class="p_context"> struct dvb_usb_device_properties dib0700_devices[] = {</span>
 
 				DIB0700_DEFAULT_STREAMING_CONFIG(0x02),
 			}},
<span class="p_add">+				.size_of_priv = sizeof(struct</span>
<span class="p_add">+						dib0700_adapter_state),</span>
 			},
 		},
 
<span class="p_header">diff --git a/drivers/media/v4l2-core/videobuf2-core.c b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">index 66ada01c796c..cf9d644a8aff 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/videobuf2-core.c</span>
<span class="p_chunk">@@ -1237,6 +1237,23 @@</span> <span class="p_context"> void vb2_discard_done(struct vb2_queue *q)</span>
 }
 EXPORT_SYMBOL_GPL(vb2_discard_done);
 
<span class="p_add">+static void vb2_warn_zero_bytesused(struct vb2_buffer *vb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static bool __check_once __read_mostly;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__check_once)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	__check_once = true;</span>
<span class="p_add">+	__WARN();</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_warn_once(&quot;use of bytesused == 0 is deprecated and will be removed in the future,\n&quot;);</span>
<span class="p_add">+	if (vb-&gt;vb2_queue-&gt;allow_zero_bytesused)</span>
<span class="p_add">+		pr_warn_once(&quot;use VIDIOC_DECODER_CMD(V4L2_DEC_CMD_STOP) instead.\n&quot;);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		pr_warn_once(&quot;use the actual size instead.\n&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * __fill_vb2_buffer() - fill a vb2_buffer with information provided in a
  * v4l2_buffer by the userspace. The caller has already verified that struct
<span class="p_chunk">@@ -1247,16 +1264,6 @@</span> <span class="p_context"> static void __fill_vb2_buffer(struct vb2_buffer *vb, const struct v4l2_buffer *b</span>
 {
 	unsigned int plane;
 
<span class="p_del">-	if (V4L2_TYPE_IS_OUTPUT(b-&gt;type)) {</span>
<span class="p_del">-		if (WARN_ON_ONCE(b-&gt;bytesused == 0)) {</span>
<span class="p_del">-			pr_warn_once(&quot;use of bytesused == 0 is deprecated and will be removed in the future,\n&quot;);</span>
<span class="p_del">-			if (vb-&gt;vb2_queue-&gt;allow_zero_bytesused)</span>
<span class="p_del">-				pr_warn_once(&quot;use VIDIOC_DECODER_CMD(V4L2_DEC_CMD_STOP) instead.\n&quot;);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				pr_warn_once(&quot;use the actual size instead.\n&quot;);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (V4L2_TYPE_IS_MULTIPLANAR(b-&gt;type)) {
 		if (b-&gt;memory == V4L2_MEMORY_USERPTR) {
 			for (plane = 0; plane &lt; vb-&gt;num_planes; ++plane) {
<span class="p_chunk">@@ -1297,6 +1304,9 @@</span> <span class="p_context"> static void __fill_vb2_buffer(struct vb2_buffer *vb, const struct v4l2_buffer *b</span>
 				struct v4l2_plane *pdst = &amp;v4l2_planes[plane];
 				struct v4l2_plane *psrc = &amp;b-&gt;m.planes[plane];
 
<span class="p_add">+				if (psrc-&gt;bytesused == 0)</span>
<span class="p_add">+					vb2_warn_zero_bytesused(vb);</span>
<span class="p_add">+</span>
 				if (vb-&gt;vb2_queue-&gt;allow_zero_bytesused)
 					pdst-&gt;bytesused = psrc-&gt;bytesused;
 				else
<span class="p_chunk">@@ -1331,6 +1341,9 @@</span> <span class="p_context"> static void __fill_vb2_buffer(struct vb2_buffer *vb, const struct v4l2_buffer *b</span>
 		}
 
 		if (V4L2_TYPE_IS_OUTPUT(b-&gt;type)) {
<span class="p_add">+			if (b-&gt;bytesused == 0)</span>
<span class="p_add">+				vb2_warn_zero_bytesused(vb);</span>
<span class="p_add">+</span>
 			if (vb-&gt;vb2_queue-&gt;allow_zero_bytesused)
 				v4l2_planes[0].bytesused = b-&gt;bytesused;
 			else
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 60f7141a6b02..31d2627d9d4d 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -208,6 +208,8 @@</span> <span class="p_context"> static ssize_t power_ro_lock_show(struct device *dev,</span>
 
 	ret = snprintf(buf, PAGE_SIZE, &quot;%d\n&quot;, locked);
 
<span class="p_add">+	mmc_blk_put(md);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -1910,9 +1912,11 @@</span> <span class="p_context"> static int mmc_blk_issue_rw_rq(struct mmc_queue *mq, struct request *rqc)</span>
 			break;
 		case MMC_BLK_CMD_ERR:
 			ret = mmc_blk_cmd_err(md, card, brq, req, ret);
<span class="p_del">-			if (!mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			goto cmd_abort;</span>
<span class="p_add">+			if (mmc_blk_reset(md, card-&gt;host, type))</span>
<span class="p_add">+				goto cmd_abort;</span>
<span class="p_add">+			if (!ret)</span>
<span class="p_add">+				goto start_new_req;</span>
<span class="p_add">+			break;</span>
 		case MMC_BLK_RETRY:
 			if (retry++ &lt; 5)
 				break;
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index 9231cdfe2757..d3dbb28057e9 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -3315,13 +3315,14 @@</span> <span class="p_context"> int sdhci_add_host(struct sdhci_host *host)</span>
 				   SDHCI_MAX_CURRENT_MULTIPLIER;
 	}
 
<span class="p_del">-	/* If OCR set by external regulators, use it instead */</span>
<span class="p_add">+	/* If OCR set by host, use it instead. */</span>
<span class="p_add">+	if (host-&gt;ocr_mask)</span>
<span class="p_add">+		ocr_avail = host-&gt;ocr_mask;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If OCR set by external regulators, give it highest prio. */</span>
 	if (mmc-&gt;ocr_avail)
 		ocr_avail = mmc-&gt;ocr_avail;
 
<span class="p_del">-	if (host-&gt;ocr_mask)</span>
<span class="p_del">-		ocr_avail &amp;= host-&gt;ocr_mask;</span>
<span class="p_del">-</span>
 	mmc-&gt;ocr_avail = ocr_avail;
 	mmc-&gt;ocr_avail_sdio = ocr_avail;
 	if (host-&gt;ocr_avail_sdio)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/82571.c b/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_header">index dc79ed85030b..32e77755a9c6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/82571.c</span>
<span class="p_chunk">@@ -2010,7 +2010,7 @@</span> <span class="p_context"> const struct e1000_info e1000_82573_info = {</span>
 	.flags2			= FLAG2_DISABLE_ASPM_L1
 				  | FLAG2_DISABLE_ASPM_L0S,
 	.pba			= 20,
<span class="p_del">-	.max_hw_frame_size	= ETH_FRAME_LEN + ETH_FCS_LEN,</span>
<span class="p_add">+	.max_hw_frame_size	= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,</span>
 	.get_variants		= e1000_get_variants_82571,
 	.mac_ops		= &amp;e82571_mac_ops,
 	.phy_ops		= &amp;e82_phy_ops_m88,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/ich8lan.c b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">index 9d81c0317433..e2498dbf3c3b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/ich8lan.c</span>
<span class="p_chunk">@@ -1563,7 +1563,7 @@</span> <span class="p_context"> static s32 e1000_get_variants_ich8lan(struct e1000_adapter *adapter)</span>
 	    ((adapter-&gt;hw.mac.type &gt;= e1000_pch2lan) &amp;&amp;
 	     (!(er32(CTRL_EXT) &amp; E1000_CTRL_EXT_LSECCK)))) {
 		adapter-&gt;flags &amp;= ~FLAG_HAS_JUMBO_FRAMES;
<span class="p_del">-		adapter-&gt;max_hw_frame_size = ETH_FRAME_LEN + ETH_FCS_LEN;</span>
<span class="p_add">+		adapter-&gt;max_hw_frame_size = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 
 		hw-&gt;mac.ops.blink_led = NULL;
 	}
<span class="p_chunk">@@ -5681,7 +5681,7 @@</span> <span class="p_context"> const struct e1000_info e1000_ich8_info = {</span>
 				  | FLAG_HAS_FLASH
 				  | FLAG_APME_IN_WUC,
 	.pba			= 8,
<span class="p_del">-	.max_hw_frame_size	= ETH_FRAME_LEN + ETH_FCS_LEN,</span>
<span class="p_add">+	.max_hw_frame_size	= VLAN_ETH_FRAME_LEN + ETH_FCS_LEN,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_chunk">@@ -5754,7 +5754,7 @@</span> <span class="p_context"> const struct e1000_info e1000_pch2_info = {</span>
 	.flags2			= FLAG2_HAS_PHY_STATS
 				  | FLAG2_HAS_EEE,
 	.pba			= 26,
<span class="p_del">-	.max_hw_frame_size	= 9018,</span>
<span class="p_add">+	.max_hw_frame_size	= 9022,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_chunk">@@ -5774,7 +5774,7 @@</span> <span class="p_context"> const struct e1000_info e1000_pch_lpt_info = {</span>
 	.flags2			= FLAG2_HAS_PHY_STATS
 				  | FLAG2_HAS_EEE,
 	.pba			= 26,
<span class="p_del">-	.max_hw_frame_size	= 9018,</span>
<span class="p_add">+	.max_hw_frame_size	= 9022,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_chunk">@@ -5794,7 +5794,7 @@</span> <span class="p_context"> const struct e1000_info e1000_pch_spt_info = {</span>
 	.flags2			= FLAG2_HAS_PHY_STATS
 				  | FLAG2_HAS_EEE,
 	.pba			= 26,
<span class="p_del">-	.max_hw_frame_size	= 9018,</span>
<span class="p_add">+	.max_hw_frame_size	= 9022,</span>
 	.get_variants		= e1000_get_variants_ich8lan,
 	.mac_ops		= &amp;ich8_mac_ops,
 	.phy_ops		= &amp;ich8_phy_ops,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/e1000e/netdev.c b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">index c509a5c900f5..68913d103542 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/e1000e/netdev.c</span>
<span class="p_chunk">@@ -3807,7 +3807,7 @@</span> <span class="p_context"> void e1000e_reset(struct e1000_adapter *adapter)</span>
 	/* reset Packet Buffer Allocation to default */
 	ew32(PBA, pba);
 
<span class="p_del">-	if (adapter-&gt;max_frame_size &gt; ETH_FRAME_LEN + ETH_FCS_LEN) {</span>
<span class="p_add">+	if (adapter-&gt;max_frame_size &gt; (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) {</span>
 		/* To maintain wire speed transmits, the Tx FIFO should be
 		 * large enough to accommodate two full transmit packets,
 		 * rounded up to the next 1KB and expressed in KB.  Likewise,
<span class="p_chunk">@@ -4196,9 +4196,9 @@</span> <span class="p_context"> static int e1000_sw_init(struct e1000_adapter *adapter)</span>
 {
 	struct net_device *netdev = adapter-&gt;netdev;
 
<span class="p_del">-	adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	adapter-&gt;rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 	adapter-&gt;rx_ps_bsize0 = 128;
<span class="p_del">-	adapter-&gt;max_frame_size = netdev-&gt;mtu + ETH_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	adapter-&gt;max_frame_size = netdev-&gt;mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;</span>
 	adapter-&gt;min_frame_size = ETH_ZLEN + ETH_FCS_LEN;
 	adapter-&gt;tx_ring_count = E1000_DEFAULT_TXD;
 	adapter-&gt;rx_ring_count = E1000_DEFAULT_RXD;
<span class="p_chunk">@@ -5781,17 +5781,17 @@</span> <span class="p_context"> struct rtnl_link_stats64 *e1000e_get_stats64(struct net_device *netdev,</span>
 static int e1000_change_mtu(struct net_device *netdev, int new_mtu)
 {
 	struct e1000_adapter *adapter = netdev_priv(netdev);
<span class="p_del">-	int max_frame = new_mtu + VLAN_HLEN + ETH_HLEN + ETH_FCS_LEN;</span>
<span class="p_add">+	int max_frame = new_mtu + VLAN_ETH_HLEN + ETH_FCS_LEN;</span>
 
 	/* Jumbo frame support */
<span class="p_del">-	if ((max_frame &gt; ETH_FRAME_LEN + ETH_FCS_LEN) &amp;&amp;</span>
<span class="p_add">+	if ((max_frame &gt; (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN)) &amp;&amp;</span>
 	    !(adapter-&gt;flags &amp; FLAG_HAS_JUMBO_FRAMES)) {
 		e_err(&quot;Jumbo Frames not supported.\n&quot;);
 		return -EINVAL;
 	}
 
 	/* Supported frame sizes */
<span class="p_del">-	if ((new_mtu &lt; ETH_ZLEN + ETH_FCS_LEN + VLAN_HLEN) ||</span>
<span class="p_add">+	if ((new_mtu &lt; (VLAN_ETH_ZLEN + ETH_FCS_LEN)) ||</span>
 	    (max_frame &gt; adapter-&gt;max_hw_frame_size)) {
 		e_err(&quot;Unsupported MTU setting\n&quot;);
 		return -EINVAL;
<span class="p_chunk">@@ -5831,10 +5831,8 @@</span> <span class="p_context"> static int e1000_change_mtu(struct net_device *netdev, int new_mtu)</span>
 		adapter-&gt;rx_buffer_len = 4096;
 
 	/* adjust allocation if LPE protects us, and we aren&#39;t using SBP */
<span class="p_del">-	if ((max_frame == ETH_FRAME_LEN + ETH_FCS_LEN) ||</span>
<span class="p_del">-	    (max_frame == ETH_FRAME_LEN + VLAN_HLEN + ETH_FCS_LEN))</span>
<span class="p_del">-		adapter-&gt;rx_buffer_len = ETH_FRAME_LEN + VLAN_HLEN</span>
<span class="p_del">-		    + ETH_FCS_LEN;</span>
<span class="p_add">+	if (max_frame &lt;= (VLAN_ETH_FRAME_LEN + ETH_FCS_LEN))</span>
<span class="p_add">+		adapter-&gt;rx_buffer_len = VLAN_ETH_FRAME_LEN + ETH_FCS_LEN;</span>
 
 	if (netif_running(netdev))
 		e1000e_up(adapter);
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/htc.h b/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_header">index e82a0d4ce23f..5dbc617ecf8a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/htc.h</span>
<span class="p_chunk">@@ -440,9 +440,9 @@</span> <span class="p_context"> static inline void ath9k_htc_stop_btcoex(struct ath9k_htc_priv *priv)</span>
 }
 #endif /* CONFIG_ATH9K_BTCOEX_SUPPORT */
 
<span class="p_del">-#define OP_BT_PRIORITY_DETECTED    BIT(3)</span>
<span class="p_del">-#define OP_BT_SCAN                 BIT(4)</span>
<span class="p_del">-#define OP_TSF_RESET               BIT(6)</span>
<span class="p_add">+#define OP_BT_PRIORITY_DETECTED    3</span>
<span class="p_add">+#define OP_BT_SCAN                 4</span>
<span class="p_add">+#define OP_TSF_RESET               6</span>
 
 enum htc_op_flags {
 	HTC_FWFLAG_NO_RMW,
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/main.c b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">index b0badef71ce7..d5f2fbf62d72 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/main.c</span>
<span class="p_chunk">@@ -216,11 +216,13 @@</span> <span class="p_context"> static bool ath_prepare_reset(struct ath_softc *sc)</span>
 	ath_stop_ani(sc);
 	ath9k_hw_disable_interrupts(ah);
 
<span class="p_del">-	if (!ath_drain_all_txq(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ath_stoprecv(sc))</span>
<span class="p_del">-		ret = false;</span>
<span class="p_add">+	if (AR_SREV_9300_20_OR_LATER(ah)) {</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret &amp;= ath_drain_all_txq(sc);</span>
<span class="p_add">+		ret &amp;= ath_stoprecv(sc);</span>
<span class="p_add">+	}</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/debugfs.c b/drivers/net/wireless/iwlwifi/mvm/debugfs.c</span>
<span class="p_header">index 9ac04c1ea706..8c17b943cc6f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/debugfs.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/debugfs.c</span>
<span class="p_chunk">@@ -6,7 +6,7 @@</span> <span class="p_context"></span>
  * GPL LICENSE SUMMARY
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
  * BSD LICENSE
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
<span class="p_chunk">@@ -1356,6 +1356,7 @@</span> <span class="p_context"> static ssize_t iwl_dbgfs_d0i3_refs_read(struct file *file,</span>
 	PRINT_MVM_REF(IWL_MVM_REF_UCODE_DOWN);
 	PRINT_MVM_REF(IWL_MVM_REF_SCAN);
 	PRINT_MVM_REF(IWL_MVM_REF_ROC);
<span class="p_add">+	PRINT_MVM_REF(IWL_MVM_REF_ROC_AUX);</span>
 	PRINT_MVM_REF(IWL_MVM_REF_P2P_CLIENT);
 	PRINT_MVM_REF(IWL_MVM_REF_AP_IBSS);
 	PRINT_MVM_REF(IWL_MVM_REF_USER);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index dda9f7b5f342..60c138a9bf4f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -1404,7 +1404,7 @@</span> <span class="p_context"> void __iwl_mvm_mac_stop(struct iwl_mvm *mvm)</span>
 	 * The work item could be running or queued if the
 	 * ROC time event stops just as we get here.
 	 */
<span class="p_del">-	cancel_work_sync(&amp;mvm-&gt;roc_done_wk);</span>
<span class="p_add">+	flush_work(&amp;mvm-&gt;roc_done_wk);</span>
 
 	iwl_trans_stop_device(mvm-&gt;trans);
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mvm.h b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">index cf70f681d1ac..6af21daaaaef 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mvm.h</span>
<span class="p_chunk">@@ -275,6 +275,7 @@</span> <span class="p_context"> enum iwl_mvm_ref_type {</span>
 	IWL_MVM_REF_UCODE_DOWN,
 	IWL_MVM_REF_SCAN,
 	IWL_MVM_REF_ROC,
<span class="p_add">+	IWL_MVM_REF_ROC_AUX,</span>
 	IWL_MVM_REF_P2P_CLIENT,
 	IWL_MVM_REF_AP_IBSS,
 	IWL_MVM_REF_USER,
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/time-event.c b/drivers/net/wireless/iwlwifi/mvm/time-event.c</span>
<span class="p_header">index fd7b0d36f9a6..a7448cf01688 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/time-event.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/time-event.c</span>
<span class="p_chunk">@@ -6,7 +6,7 @@</span> <span class="p_context"></span>
  * GPL LICENSE SUMMARY
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
  * BSD LICENSE
  *
  * Copyright(c) 2012 - 2014 Intel Corporation. All rights reserved.
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
<span class="p_chunk">@@ -108,12 +108,14 @@</span> <span class="p_context"> void iwl_mvm_roc_done_wk(struct work_struct *wk)</span>
 	 * in the case that the time event actually completed in the firmware
 	 * (which is handled in iwl_mvm_te_handle_notif).
 	 */
<span class="p_del">-	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_RUNNING, &amp;mvm-&gt;status))</span>
<span class="p_add">+	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_RUNNING, &amp;mvm-&gt;status)) {</span>
 		queues |= BIT(IWL_MVM_OFFCHANNEL_QUEUE);
<span class="p_del">-	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &amp;mvm-&gt;status))</span>
<span class="p_add">+		iwl_mvm_unref(mvm, IWL_MVM_REF_ROC);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (test_and_clear_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &amp;mvm-&gt;status)) {</span>
 		queues |= BIT(mvm-&gt;aux_queue);
<span class="p_del">-</span>
<span class="p_del">-	iwl_mvm_unref(mvm, IWL_MVM_REF_ROC);</span>
<span class="p_add">+		iwl_mvm_unref(mvm, IWL_MVM_REF_ROC_AUX);</span>
<span class="p_add">+	}</span>
 
 	synchronize_net();
 
<span class="p_chunk">@@ -393,6 +395,7 @@</span> <span class="p_context"> static int iwl_mvm_aux_roc_te_handle_notif(struct iwl_mvm *mvm,</span>
 	} else if (le32_to_cpu(notif-&gt;action) == TE_V2_NOTIF_HOST_EVENT_START) {
 		set_bit(IWL_MVM_STATUS_ROC_AUX_RUNNING, &amp;mvm-&gt;status);
 		te_data-&gt;running = true;
<span class="p_add">+		iwl_mvm_ref(mvm, IWL_MVM_REF_ROC_AUX);</span>
 		ieee80211_ready_on_channel(mvm-&gt;hw); /* Start TE */
 	} else {
 		IWL_DEBUG_TE(mvm,
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c b/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c</span>
<span class="p_header">index 86ce5b1930e6..e5d8108f1987 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8188ee/hw.c</span>
<span class="p_chunk">@@ -1354,27 +1354,11 @@</span> <span class="p_context"> void rtl88ee_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl88ee_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl88ee_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl88ee_clear_interrupt(hw);/*clear it here first*/</span>
 	rtl_write_dword(rtlpriv, REG_HIMR,
 			rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE,
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c b/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_header">index da0a6125f314..cbf2ca7c7c6d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8192ee/hw.c</span>
<span class="p_chunk">@@ -1584,28 +1584,11 @@</span> <span class="p_context"> void rtl92ee_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl92ee_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl92ee_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl92ee_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_del">-</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c</span>
<span class="p_header">index 67bb47d77b68..a4b7eac6856f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723ae/hw.c</span>
<span class="p_chunk">@@ -1258,18 +1258,6 @@</span> <span class="p_context"> void rtl8723e_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl8723e_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl8723e_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
<span class="p_chunk">@@ -1284,7 +1272,6 @@</span> <span class="p_context"> void rtl8723e_disable_interrupt(struct ieee80211_hw *hw)</span>
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
<span class="p_del">-	rtl8723e_clear_interrupt(hw);/*clear it here first*/</span>
 	rtl_write_dword(rtlpriv, 0x3a8, IMR8190_DISABLED);
 	rtl_write_dword(rtlpriv, 0x3ac, IMR8190_DISABLED);
 	rtlpci-&gt;irq_enabled = false;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8723be/hw.c b/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_header">index b681af3c7a35..b9417268427e 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8723be/hw.c</span>
<span class="p_chunk">@@ -1634,28 +1634,11 @@</span> <span class="p_context"> void rtl8723be_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl8723be_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl8723be_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl8723be_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_del">-</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">index 8704eee9f3a4..57966e3c8e8d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -2253,31 +2253,11 @@</span> <span class="p_context"> void rtl8821ae_set_qos(struct ieee80211_hw *hw, int aci)</span>
 	}
 }
 
<span class="p_del">-static void rtl8821ae_clear_interrupt(struct ieee80211_hw *hw)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct rtl_priv *rtlpriv = rtl_priv(hw);</span>
<span class="p_del">-	u32 tmp;</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISR);</span>
<span class="p_del">-	/*printk(&quot;clear interrupt first:\n&quot;);</span>
<span class="p_del">-	printk(&quot;0x%x = 0x%08x\n&quot;,REG_HISR, tmp);*/</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISR, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HISRE);</span>
<span class="p_del">-	/*printk(&quot;0x%x = 0x%08x\n&quot;,REG_HISRE, tmp);*/</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HISRE, tmp);</span>
<span class="p_del">-</span>
<span class="p_del">-	tmp = rtl_read_dword(rtlpriv, REG_HSISR);</span>
<span class="p_del">-	/*printk(&quot;0x%x = 0x%08x\n&quot;,REG_HSISR, tmp);*/</span>
<span class="p_del">-	rtl_write_dword(rtlpriv, REG_HSISR, tmp);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void rtl8821ae_enable_interrupt(struct ieee80211_hw *hw)
 {
 	struct rtl_priv *rtlpriv = rtl_priv(hw);
 	struct rtl_pci *rtlpci = rtl_pcidev(rtl_pcipriv(hw));
 
<span class="p_del">-	rtl8821ae_clear_interrupt(hw);/*clear it here first*/</span>
<span class="p_del">-</span>
 	rtl_write_dword(rtlpriv, REG_HIMR, rtlpci-&gt;irq_mask[0] &amp; 0xFFFFFFFF);
 	rtl_write_dword(rtlpriv, REG_HIMRE, rtlpci-&gt;irq_mask[1] &amp; 0xFFFFFFFF);
 	rtlpci-&gt;irq_enabled = true;
<span class="p_header">diff --git a/drivers/nfc/st21nfcb/i2c.c b/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_header">index 76a4cad41cec..c44f8cf5391a 100644</span>
<span class="p_header">--- a/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_header">+++ b/drivers/nfc/st21nfcb/i2c.c</span>
<span class="p_chunk">@@ -87,11 +87,6 @@</span> <span class="p_context"> static void st21nfcb_nci_i2c_disable(void *phy_id)</span>
 	gpio_set_value(phy-&gt;gpio_reset, 1);
 }
 
<span class="p_del">-static void st21nfcb_nci_remove_header(struct sk_buff *skb)</span>
<span class="p_del">-{</span>
<span class="p_del">-	skb_pull(skb, ST21NFCB_FRAME_HEADROOM);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Writing a frame must not return the number of written bytes.
  * It must return either zero for success, or &lt;0 for error.
<span class="p_chunk">@@ -121,8 +116,6 @@</span> <span class="p_context"> static int st21nfcb_nci_i2c_write(void *phy_id, struct sk_buff *skb)</span>
 			r = 0;
 	}
 
<span class="p_del">-	st21nfcb_nci_remove_header(skb);</span>
<span class="p_del">-</span>
 	return r;
 }
 
<span class="p_chunk">@@ -366,9 +359,6 @@</span> <span class="p_context"> static int st21nfcb_nci_i2c_remove(struct i2c_client *client)</span>
 
 	ndlc_remove(phy-&gt;ndlc);
 
<span class="p_del">-	if (phy-&gt;powered)</span>
<span class="p_del">-		st21nfcb_nci_i2c_disable(phy);</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/nfc/st21nfcb/st21nfcb.c b/drivers/nfc/st21nfcb/st21nfcb.c</span>
<span class="p_header">index ca9871ab3fb3..c7dc282d5c3b 100644</span>
<span class="p_header">--- a/drivers/nfc/st21nfcb/st21nfcb.c</span>
<span class="p_header">+++ b/drivers/nfc/st21nfcb/st21nfcb.c</span>
<span class="p_chunk">@@ -131,11 +131,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(st21nfcb_nci_probe);</span>
 
 void st21nfcb_nci_remove(struct nci_dev *ndev)
 {
<span class="p_del">-	struct st21nfcb_nci_info *info = nci_get_drvdata(ndev);</span>
<span class="p_del">-</span>
 	nci_unregister_device(ndev);
 	nci_free_device(ndev);
<span class="p_del">-	kfree(info);</span>
 }
 EXPORT_SYMBOL_GPL(st21nfcb_nci_remove);
 
<span class="p_header">diff --git a/drivers/of/address.c b/drivers/of/address.c</span>
<span class="p_header">index 6906a3f61bd8..8bfda6ade2c0 100644</span>
<span class="p_header">--- a/drivers/of/address.c</span>
<span class="p_header">+++ b/drivers/of/address.c</span>
<span class="p_chunk">@@ -712,7 +712,7 @@</span> <span class="p_context"> int __weak pci_register_io_range(phys_addr_t addr, resource_size_t size)</span>
 	}
 
 	/* add the range to the list */
<span class="p_del">-	range = kzalloc(sizeof(*range), GFP_KERNEL);</span>
<span class="p_add">+	range = kzalloc(sizeof(*range), GFP_ATOMIC);</span>
 	if (!range) {
 		err = -ENOMEM;
 		goto end_register;
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index f0650265febf..5ed97246c2e7 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(of_n_size_cells);</span>
 #ifdef CONFIG_NUMA
 int __weak of_node_to_nid(struct device_node *np)
 {
<span class="p_del">-	return numa_node_id();</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/phy/phy-berlin-usb.c b/drivers/phy/phy-berlin-usb.c</span>
<span class="p_header">index c6fc95b53083..ab54f2864451 100644</span>
<span class="p_header">--- a/drivers/phy/phy-berlin-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-berlin-usb.c</span>
<span class="p_chunk">@@ -106,8 +106,8 @@</span> <span class="p_context"></span>
 static const u32 phy_berlin_pll_dividers[] = {
 	/* Berlin 2 */
 	CLK_REF_DIV(0xc) | FEEDBACK_CLK_DIV(0x54),
<span class="p_del">-	/* Berlin 2CD */</span>
<span class="p_del">-	CLK_REF_DIV(0x6) | FEEDBACK_CLK_DIV(0x55),</span>
<span class="p_add">+	/* Berlin 2CD/Q */</span>
<span class="p_add">+	CLK_REF_DIV(0xc) | FEEDBACK_CLK_DIV(0x54),</span>
 };
 
 struct phy_berlin_usb_priv {
<span class="p_header">diff --git a/drivers/phy/phy-twl4030-usb.c b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">index bc42d6a8939f..8882afbef688 100644</span>
<span class="p_header">--- a/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-twl4030-usb.c</span>
<span class="p_chunk">@@ -711,7 +711,6 @@</span> <span class="p_context"> static int twl4030_usb_probe(struct platform_device *pdev)</span>
 	pm_runtime_use_autosuspend(&amp;pdev-&gt;dev);
 	pm_runtime_set_autosuspend_delay(&amp;pdev-&gt;dev, 2000);
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_del">-	pm_runtime_get_sync(&amp;pdev-&gt;dev);</span>
 
 	/* Our job is to use irqs and status from the power module
 	 * to keep the transceiver disabled when nothing&#39;s connected.
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-370.c b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">index 03aa58c4cb85..1eb084c3b0c9 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-370.c</span>
<span class="p_chunk">@@ -370,11 +370,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6710_mpp_modes[] = {</span>
 	MPP_MODE(64,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;miso&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs1&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs1&quot;)),</span>
 	MPP_MODE(65,
 	   MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
 	   MPP_FUNCTION(0x1, &quot;spi0&quot;, &quot;mosi&quot;),
<span class="p_del">-	   MPP_FUNCTION(0x2, &quot;spi0-1&quot;, &quot;cs2&quot;)),</span>
<span class="p_add">+	   MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs2&quot;)),</span>
 };
 
 static struct mvebu_pinctrl_soc_info armada_370_pinctrl_info;
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-375.c b/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_header">index ca1e7571fedb..203291bde608 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-375.c</span>
<span class="p_chunk">@@ -92,19 +92,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode mv88f6720_mpp_modes[] = {</span>
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;io1&quot;)),
 	MPP_MODE(8,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;dev &quot;, &quot;bootcs&quot;),</span>
<span class="p_add">+		 MPP_FUNCTION(0x1, &quot;dev&quot;, &quot;bootcs&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;cs0&quot;),
 		 MPP_FUNCTION(0x3, &quot;spi1&quot;, &quot;cs0&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;ce&quot;)),
 	MPP_MODE(9,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;nf&quot;, &quot;wen&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;spi0&quot;, &quot;sck&quot;),
 		 MPP_FUNCTION(0x3, &quot;spi1&quot;, &quot;sck&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;we&quot;)),
 	MPP_MODE(10,
 		 MPP_FUNCTION(0x0, &quot;gpio&quot;, NULL),
<span class="p_del">-		 MPP_FUNCTION(0x1, &quot;nf&quot;, &quot;ren&quot;),</span>
 		 MPP_FUNCTION(0x2, &quot;dram&quot;, &quot;vttctrl&quot;),
 		 MPP_FUNCTION(0x3, &quot;led&quot;, &quot;c1&quot;),
 		 MPP_FUNCTION(0x5, &quot;nand&quot;, &quot;re&quot;),
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-38x.c b/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_header">index 83bbcc72be1f..ff411a53b5a4 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-38x.c</span>
<span class="p_chunk">@@ -94,37 +94,39 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd0&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs1&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad14&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad14&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie3&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(13,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd1&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad15&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;ad15&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie2&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(14,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd2&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;clk&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs3&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;wen1&quot;,       V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;wen1&quot;,       V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie3&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(15,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxd3&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ge&quot;,    &quot;mdc slave&quot;,  V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;mosi&quot;,       V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;mosi&quot;,       V_88F6810_PLUS)),</span>
 	MPP_MODE(16,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxctl&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ge&quot;,    &quot;mdio slave&quot;, V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;decc_err&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;miso&quot;,       V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS)),</span>
 	MPP_MODE(17,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxclk&quot;,      V_88F6810_PLUS),
<span class="p_chunk">@@ -137,13 +139,12 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;rxerr&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;trig_gen&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;ua1&quot;,   &quot;txd&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi0&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS)),</span>
 	MPP_MODE(19,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;col&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;event_req&quot;,  V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(3, &quot;ge0&quot;,   &quot;txerr&quot;,      V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;ua0&quot;,   &quot;cts&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(6, &quot;ua1&quot;,   &quot;rxd&quot;,        V_88F6810_PLUS)),
<span class="p_chunk">@@ -151,7 +152,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ge0&quot;,   &quot;txclk&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;ptp&quot;,   &quot;clk&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;ua0&quot;,   &quot;rts&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(6, &quot;ua1&quot;,   &quot;txd&quot;,        V_88F6810_PLUS)),
<span class="p_chunk">@@ -277,35 +277,27 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;m&quot;,     &quot;decc_err&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;dev&quot;,   &quot;clkout&quot;,     V_88F6810_PLUS)),
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828)),</span>
 	MPP_MODE(45,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ref&quot;,   &quot;clk_out0&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie2&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie3&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(46,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;ref&quot;,   &quot;clk_out1&quot;,   V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie2&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;pcie3&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(2, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(47,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs2&quot;,        V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
<span class="p_chunk">@@ -313,18 +305,19 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(2, &quot;m&quot;,     &quot;vtt_ctrl&quot;,   V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;pclk&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;mclk&quot;,       V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d4&quot;,         V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d4&quot;,         V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie0&quot;, &quot;clkreq&quot;,     V_88F6810_PLUS)),</span>
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;sata2&quot;, &quot;prsnt&quot;,      V_88F6828),
 		 MPP_VAR_FUNCTION(2, &quot;sata3&quot;, &quot;prsnt&quot;,      V_88F6828),
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;fsync&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;lrclk&quot;,      V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d5&quot;,         V_88F6810_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d5&quot;,         V_88F6810_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(6, &quot;pcie1&quot;, &quot;clkreq&quot;,     V_88F6820_PLUS)),</span>
 	MPP_MODE(50,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;drx&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;extclk&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;cmd&quot;,        V_88F6810_PLUS)),
<span class="p_chunk">@@ -336,7 +329,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 	MPP_MODE(52,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(2, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(3, &quot;tdm2c&quot;, &quot;intn&quot;,       V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(4, &quot;audio&quot;, &quot;sdi&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d6&quot;,         V_88F6810_PLUS)),
<span class="p_chunk">@@ -352,7 +344,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(1, &quot;sata0&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;sata1&quot;, &quot;prsnt&quot;,      V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(3, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(4, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(4, &quot;ge0&quot;,   &quot;txerr&quot;,      V_88F6810_PLUS),</span>
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d3&quot;,         V_88F6810_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
<span class="p_chunk">@@ -382,7 +374,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_38x_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0, &quot;gpio&quot;,  NULL,         V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(1, &quot;pcie0&quot;, &quot;rstout&quot;,     V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(2, &quot;i2c1&quot;,  &quot;sda&quot;,        V_88F6810_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(3, &quot;pcie1&quot;, &quot;rstout&quot;,     V_88F6820_PLUS),</span>
 		 MPP_VAR_FUNCTION(4, &quot;spi1&quot;,  &quot;cs0&quot;,        V_88F6810_PLUS),
 		 MPP_VAR_FUNCTION(5, &quot;sd0&quot;,   &quot;d2&quot;,         V_88F6810_PLUS)),
 };
<span class="p_chunk">@@ -411,7 +402,7 @@</span> <span class="p_context"> static struct mvebu_mpp_ctrl armada_38x_mpp_controls[] = {</span>
 
 static struct pinctrl_gpio_range armada_38x_mpp_gpio_ranges[] = {
 	MPP_GPIO_RANGE(0,   0,  0, 32),
<span class="p_del">-	MPP_GPIO_RANGE(1,  32, 32, 27),</span>
<span class="p_add">+	MPP_GPIO_RANGE(1,  32, 32, 28),</span>
 };
 
 static int armada_38x_pinctrl_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-39x.c b/drivers/pinctrl/mvebu/pinctrl-armada-39x.c</span>
<span class="p_header">index 42491624d660..2dcf9b41e01e 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-39x.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-39x.c</span>
<span class="p_chunk">@@ -380,7 +380,7 @@</span> <span class="p_context"> static struct mvebu_mpp_ctrl armada_39x_mpp_controls[] = {</span>
 
 static struct pinctrl_gpio_range armada_39x_mpp_gpio_ranges[] = {
 	MPP_GPIO_RANGE(0,   0,  0, 32),
<span class="p_del">-	MPP_GPIO_RANGE(1,  32, 32, 27),</span>
<span class="p_add">+	MPP_GPIO_RANGE(1,  32, 32, 28),</span>
 };
 
 static int armada_39x_pinctrl_probe(struct platform_device *pdev)
<span class="p_header">diff --git a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">index 578db9f033b2..d7cdb146f44d 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mvebu/pinctrl-armada-xp.c</span>
<span class="p_chunk">@@ -14,10 +14,7 @@</span> <span class="p_context"></span>
  * available: mv78230, mv78260 and mv78460. From a pin muxing
  * perspective, the mv78230 has 49 MPP pins. The mv78260 and mv78460
  * both have 67 MPP pins (more GPIOs and address lines for the memory
<span class="p_del">- * bus mainly). The only difference between the mv78260 and the</span>
<span class="p_del">- * mv78460 in terms of pin muxing is the addition of two functions on</span>
<span class="p_del">- * pins 43 and 56 to access the VDD of the CPU2 and 3 (mv78260 has two</span>
<span class="p_del">- * cores, mv78460 has four cores).</span>
<span class="p_add">+ * bus mainly).</span>
  */
 
 #include &lt;linux/err.h&gt;
<span class="p_chunk">@@ -172,20 +169,17 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(24,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata1&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-re&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;rst&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;hsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(25,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sata0&quot;, &quot;prsnt&quot;,    V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;nf&quot;, &quot;bootcs-we&quot;,   V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;pclk&quot;,       V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vsync&quot;,      V_MV78230_PLUS)),
 	MPP_MODE(26,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;fsync&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;clk&quot;,        V_MV78230_PLUS)),</span>
 	MPP_MODE(27,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;trig&quot;,       V_MV78230_PLUS),
<span class="p_chunk">@@ -200,8 +194,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;ptp&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int0&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;ref-clk&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(30,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;clk&quot;,        V_MV78230_PLUS),
<span class="p_chunk">@@ -209,13 +202,11 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 	MPP_MODE(31,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;cmd&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int2&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(32,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d0&quot;,         V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int3&quot;,       V_MV78230_PLUS)),</span>
 	MPP_MODE(33,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;sd0&quot;, &quot;d1&quot;,         V_MV78230_PLUS),
<span class="p_chunk">@@ -247,7 +238,6 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;spi&quot;, &quot;cs1&quot;,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x3, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x4, &quot;lcd&quot;, &quot;vga-hsync&quot;,  V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq0&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(41,
<span class="p_chunk">@@ -262,15 +252,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;rxd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;tdm&quot;, &quot;int7&quot;,       V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78230_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;tdm-1&quot;, &quot;timer&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(43,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;txd&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x2, &quot;uart0&quot;, &quot;rts&quot;,      V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x3, &quot;spi&quot;, &quot;cs3&quot;,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x5, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x4, &quot;pcie&quot;, &quot;rstout&quot;,    V_MV78230_PLUS)),</span>
 	MPP_MODE(44,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;uart2&quot;, &quot;cts&quot;,      V_MV78230_PLUS),
<span class="p_chunk">@@ -299,7 +287,7 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x5, &quot;pcie&quot;, &quot;clkreq3&quot;,   V_MV78230_PLUS)),
 	MPP_MODE(48,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78230_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;tclk&quot;, NULL,        V_MV78230_PLUS),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;clkout&quot;,     V_MV78230_PLUS),</span>
 		 MPP_VAR_FUNCTION(0x2, &quot;dev&quot;, &quot;burst/last&quot;, V_MV78230_PLUS)),
 	MPP_MODE(49,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_chunk">@@ -321,16 +309,13 @@</span> <span class="p_context"> static struct mvebu_mpp_mode armada_xp_mpp_modes[] = {</span>
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad19&quot;,       V_MV78260_PLUS)),
 	MPP_MODE(55,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu0-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad20&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(56,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu1-pd&quot;,    V_MV78260_PLUS)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad21&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(57,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
<span class="p_del">-		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS),</span>
<span class="p_del">-		 MPP_VAR_FUNCTION(0x2, &quot;vdd&quot;, &quot;cpu2-3-pd&quot;,  V_MV78460)),</span>
<span class="p_add">+		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad22&quot;,       V_MV78260_PLUS)),</span>
 	MPP_MODE(58,
 		 MPP_VAR_FUNCTION(0x0, &quot;gpio&quot;, NULL,        V_MV78260_PLUS),
 		 MPP_VAR_FUNCTION(0x1, &quot;dev&quot;, &quot;ad23&quot;,       V_MV78260_PLUS)),
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-zynq.c b/drivers/pinctrl/pinctrl-zynq.c</span>
<span class="p_header">index 22280bddb9e2..8c51a3c65513 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-zynq.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-zynq.c</span>
<span class="p_chunk">@@ -714,12 +714,13 @@</span> <span class="p_context"> static const char * const gpio0_groups[] = {&quot;gpio0_0_grp&quot;,</span>
 		.mux_val = mval,			\
 	}
 
<span class="p_del">-#define DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(fname, mval, mux, mask, shift)	\</span>
<span class="p_add">+#define DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(fname, mval, offset, mask, shift)\</span>
 	[ZYNQ_PMUX_##fname] = {				\
 		.name = #fname,				\
 		.groups = fname##_groups,		\
 		.ngroups = ARRAY_SIZE(fname##_groups),	\
 		.mux_val = mval,			\
<span class="p_add">+		.mux = offset,				\</span>
 		.mux_mask = mask,			\
 		.mux_shift = shift,			\
 	}
<span class="p_chunk">@@ -744,15 +745,15 @@</span> <span class="p_context"> static const struct zynq_pinmux_function zynq_pmux_functions[] = {</span>
 	DEFINE_ZYNQ_PINMUX_FUNCTION(spi1, 0x50),
 	DEFINE_ZYNQ_PINMUX_FUNCTION(sdio0, 0x40),
 	DEFINE_ZYNQ_PINMUX_FUNCTION(sdio0_pc, 0xc),
<span class="p_del">-	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio0_wp, 0, 130, ZYNQ_SDIO_WP_MASK,</span>
<span class="p_add">+	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio0_wp, 0, 0x130, ZYNQ_SDIO_WP_MASK,</span>
 					ZYNQ_SDIO_WP_SHIFT),
<span class="p_del">-	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio0_cd, 0, 130, ZYNQ_SDIO_CD_MASK,</span>
<span class="p_add">+	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio0_cd, 0, 0x130, ZYNQ_SDIO_CD_MASK,</span>
 					ZYNQ_SDIO_CD_SHIFT),
 	DEFINE_ZYNQ_PINMUX_FUNCTION(sdio1, 0x40),
 	DEFINE_ZYNQ_PINMUX_FUNCTION(sdio1_pc, 0xc),
<span class="p_del">-	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio1_wp, 0, 134, ZYNQ_SDIO_WP_MASK,</span>
<span class="p_add">+	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio1_wp, 0, 0x134, ZYNQ_SDIO_WP_MASK,</span>
 					ZYNQ_SDIO_WP_SHIFT),
<span class="p_del">-	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio1_cd, 0, 134, ZYNQ_SDIO_CD_MASK,</span>
<span class="p_add">+	DEFINE_ZYNQ_PINMUX_FUNCTION_MUX(sdio1_cd, 0, 0x134, ZYNQ_SDIO_CD_MASK,</span>
 					ZYNQ_SDIO_CD_SHIFT),
 	DEFINE_ZYNQ_PINMUX_FUNCTION(smc0_nor, 4),
 	DEFINE_ZYNQ_PINMUX_FUNCTION(smc0_nor_cs1, 8),
<span class="p_header">diff --git a/drivers/platform/x86/dell-laptop.c b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">index d688d806a8a5..2c1d5f5432a9 100644</span>
<span class="p_header">--- a/drivers/platform/x86/dell-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/dell-laptop.c</span>
<span class="p_chunk">@@ -305,7 +305,6 @@</span> <span class="p_context"> static const struct dmi_system_id dell_quirks[] __initconst = {</span>
 };
 
 static struct calling_interface_buffer *buffer;
<span class="p_del">-static struct page *bufferpage;</span>
 static DEFINE_MUTEX(buffer_mutex);
 
 static int hwswitch_state;
<span class="p_chunk">@@ -1896,12 +1895,11 @@</span> <span class="p_context"> static int __init dell_init(void)</span>
 	 * Allocate buffer below 4GB for SMI data--only 32-bit physical addr
 	 * is passed to SMI handler.
 	 */
<span class="p_del">-	bufferpage = alloc_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_del">-	if (!bufferpage) {</span>
<span class="p_add">+	buffer = (void *)__get_free_page(GFP_KERNEL | GFP_DMA32);</span>
<span class="p_add">+	if (!buffer) {</span>
 		ret = -ENOMEM;
 		goto fail_buffer;
 	}
<span class="p_del">-	buffer = page_address(bufferpage);</span>
 
 	ret = dell_setup_rfkill();
 
<span class="p_chunk">@@ -1965,7 +1963,7 @@</span> <span class="p_context"> fail_backlight:</span>
 	cancel_delayed_work_sync(&amp;dell_rfkill_work);
 	dell_cleanup_rfkill();
 fail_rfkill:
<span class="p_del">-	free_page((unsigned long)bufferpage);</span>
<span class="p_add">+	free_page((unsigned long)buffer);</span>
 fail_buffer:
 	platform_device_del(platform_device);
 fail_platform_device2:
<span class="p_header">diff --git a/drivers/platform/x86/ideapad-laptop.c b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">index b496db87bc05..cb7cd8d79329 100644</span>
<span class="p_header">--- a/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_header">+++ b/drivers/platform/x86/ideapad-laptop.c</span>
<span class="p_chunk">@@ -464,8 +464,9 @@</span> <span class="p_context"> static const struct ideapad_rfk_data ideapad_rfk_data[] = {</span>
 static int ideapad_rfk_set(void *data, bool blocked)
 {
 	struct ideapad_rfk_priv *priv = data;
<span class="p_add">+	int opcode = ideapad_rfk_data[priv-&gt;dev].opcode;</span>
 
<span class="p_del">-	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, priv-&gt;dev, !blocked);</span>
<span class="p_add">+	return write_ec_cmd(priv-&gt;priv-&gt;adev-&gt;handle, opcode, !blocked);</span>
 }
 
 static struct rfkill_ops ideapad_rfk_ops = {
<span class="p_chunk">@@ -837,6 +838,13 @@</span> <span class="p_context"> static const struct dmi_system_id no_hw_rfkill_list[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		.ident = &quot;Lenovo G50-30&quot;,</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_VERSION, &quot;Lenovo G50-30&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		.ident = &quot;Lenovo Yoga 2 11 / 13 / Pro&quot;,
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;LENOVO&quot;),
<span class="p_header">diff --git a/drivers/pnp/system.c b/drivers/pnp/system.c</span>
<span class="p_header">index 515f33882ab8..49c1720df59a 100644</span>
<span class="p_header">--- a/drivers/pnp/system.c</span>
<span class="p_header">+++ b/drivers/pnp/system.c</span>
<span class="p_chunk">@@ -7,7 +7,6 @@</span> <span class="p_context"></span>
  *	Bjorn Helgaas &lt;bjorn.helgaas@hp.com&gt;
  */
 
<span class="p_del">-#include &lt;linux/acpi.h&gt;</span>
 #include &lt;linux/pnp.h&gt;
 #include &lt;linux/device.h&gt;
 #include &lt;linux/init.h&gt;
<span class="p_chunk">@@ -23,41 +22,25 @@</span> <span class="p_context"> static const struct pnp_device_id pnp_dev_table[] = {</span>
 	{&quot;&quot;, 0}
 };
 
<span class="p_del">-#ifdef CONFIG_ACPI</span>
<span class="p_del">-static bool __reserve_range(u64 start, unsigned int length, bool io, char *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 space_id = io ? ACPI_ADR_SPACE_SYSTEM_IO : ACPI_ADR_SPACE_SYSTEM_MEMORY;</span>
<span class="p_del">-	return !acpi_reserve_region(start, length, space_id, IORESOURCE_BUSY, desc);</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-static bool __reserve_range(u64 start, unsigned int length, bool io, char *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct resource *res;</span>
<span class="p_del">-</span>
<span class="p_del">-	res = io ? request_region(start, length, desc) :</span>
<span class="p_del">-		request_mem_region(start, length, desc);</span>
<span class="p_del">-	if (res) {</span>
<span class="p_del">-		res-&gt;flags &amp;= ~IORESOURCE_BUSY;</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static void reserve_range(struct pnp_dev *dev, struct resource *r, int port)
 {
 	char *regionid;
 	const char *pnpid = dev_name(&amp;dev-&gt;dev);
 	resource_size_t start = r-&gt;start, end = r-&gt;end;
<span class="p_del">-	bool reserved;</span>
<span class="p_add">+	struct resource *res;</span>
 
 	regionid = kmalloc(16, GFP_KERNEL);
 	if (!regionid)
 		return;
 
 	snprintf(regionid, 16, &quot;pnp %s&quot;, pnpid);
<span class="p_del">-	reserved = __reserve_range(start, end - start + 1, !!port, regionid);</span>
<span class="p_del">-	if (!reserved)</span>
<span class="p_add">+	if (port)</span>
<span class="p_add">+		res = request_region(start, end - start + 1, regionid);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		res = request_mem_region(start, end - start + 1, regionid);</span>
<span class="p_add">+	if (res)</span>
<span class="p_add">+		res-&gt;flags &amp;= ~IORESOURCE_BUSY;</span>
<span class="p_add">+	else</span>
 		kfree(regionid);
 
 	/*
<span class="p_chunk">@@ -66,7 +49,7 @@</span> <span class="p_context"> static void reserve_range(struct pnp_dev *dev, struct resource *r, int port)</span>
 	 * have double reservations.
 	 */
 	dev_info(&amp;dev-&gt;dev, &quot;%pR %s reserved\n&quot;, r,
<span class="p_del">-		 reserved ? &quot;has been&quot; : &quot;could not be&quot;);</span>
<span class="p_add">+		 res ? &quot;has been&quot; : &quot;could not be&quot;);</span>
 }
 
 static void reserve_resources_of_dev(struct pnp_dev *dev)
<span class="p_header">diff --git a/drivers/rtc/rtc-snvs.c b/drivers/rtc/rtc-snvs.c</span>
<span class="p_header">index 0479e807a776..d87a85cefb66 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-snvs.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-snvs.c</span>
<span class="p_chunk">@@ -322,6 +322,13 @@</span> <span class="p_context"> static int snvs_rtc_suspend(struct device *dev)</span>
 	if (device_may_wakeup(dev))
 		enable_irq_wake(data-&gt;irq);
 
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int snvs_rtc_suspend_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snvs_rtc_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+</span>
 	if (data-&gt;clk)
 		clk_disable_unprepare(data-&gt;clk);
 
<span class="p_chunk">@@ -331,23 +338,28 @@</span> <span class="p_context"> static int snvs_rtc_suspend(struct device *dev)</span>
 static int snvs_rtc_resume(struct device *dev)
 {
 	struct snvs_rtc_data *data = dev_get_drvdata(dev);
<span class="p_del">-	int ret;</span>
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		disable_irq_wake(data-&gt;irq);</span>
<span class="p_add">+		return disable_irq_wake(data-&gt;irq);</span>
 
<span class="p_del">-	if (data-&gt;clk) {</span>
<span class="p_del">-		ret = clk_prepare_enable(data-&gt;clk);</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int snvs_rtc_resume_noirq(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct snvs_rtc_data *data = dev_get_drvdata(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (data-&gt;clk)</span>
<span class="p_add">+		return clk_prepare_enable(data-&gt;clk);</span>
 
 	return 0;
 }
 
 static const struct dev_pm_ops snvs_rtc_pm_ops = {
<span class="p_del">-	.suspend_noirq = snvs_rtc_suspend,</span>
<span class="p_del">-	.resume_noirq = snvs_rtc_resume,</span>
<span class="p_add">+	.suspend = snvs_rtc_suspend,</span>
<span class="p_add">+	.suspend_noirq = snvs_rtc_suspend_noirq,</span>
<span class="p_add">+	.resume = snvs_rtc_resume,</span>
<span class="p_add">+	.resume_noirq = snvs_rtc_resume_noirq,</span>
 };
 
 #define SNVS_RTC_PM_OPS	(&amp;snvs_rtc_pm_ops)
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/cb_pcimdas.c b/drivers/staging/comedi/drivers/cb_pcimdas.c</span>
<span class="p_header">index c458e5010a74..4ebf5aae5019 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/cb_pcimdas.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/cb_pcimdas.c</span>
<span class="p_chunk">@@ -243,7 +243,7 @@</span> <span class="p_context"> static int cb_pcimdas_ao_insn_write(struct comedi_device *dev,</span>
 	return insn-&gt;n;
 }
 
<span class="p_del">-static int cb_pcimdas_di_insn_read(struct comedi_device *dev,</span>
<span class="p_add">+static int cb_pcimdas_di_insn_bits(struct comedi_device *dev,</span>
 				   struct comedi_subdevice *s,
 				   struct comedi_insn *insn,
 				   unsigned int *data)
<span class="p_chunk">@@ -258,7 +258,7 @@</span> <span class="p_context"> static int cb_pcimdas_di_insn_read(struct comedi_device *dev,</span>
 	return insn-&gt;n;
 }
 
<span class="p_del">-static int cb_pcimdas_do_insn_write(struct comedi_device *dev,</span>
<span class="p_add">+static int cb_pcimdas_do_insn_bits(struct comedi_device *dev,</span>
 				    struct comedi_subdevice *s,
 				    struct comedi_insn *insn,
 				    unsigned int *data)
<span class="p_chunk">@@ -424,7 +424,7 @@</span> <span class="p_context"> static int cb_pcimdas_auto_attach(struct comedi_device *dev,</span>
 	s-&gt;n_chan	= 4;
 	s-&gt;maxdata	= 1;
 	s-&gt;range_table	= &amp;range_digital;
<span class="p_del">-	s-&gt;insn_read	= cb_pcimdas_di_insn_read;</span>
<span class="p_add">+	s-&gt;insn_bits	= cb_pcimdas_di_insn_bits;</span>
 
 	/* Digital Output subdevice (main connector) */
 	s = &amp;dev-&gt;subdevices[4];
<span class="p_chunk">@@ -433,7 +433,7 @@</span> <span class="p_context"> static int cb_pcimdas_auto_attach(struct comedi_device *dev,</span>
 	s-&gt;n_chan	= 4;
 	s-&gt;maxdata	= 1;
 	s-&gt;range_table	= &amp;range_digital;
<span class="p_del">-	s-&gt;insn_write	= cb_pcimdas_do_insn_write;</span>
<span class="p_add">+	s-&gt;insn_bits	= cb_pcimdas_do_insn_bits;</span>
 
 	/* Counter subdevice (8254) */
 	s = &amp;dev-&gt;subdevices[5];
<span class="p_header">diff --git a/drivers/staging/rtl8712/rtl8712_recv.c b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">index 50227b598e0c..fcb8c61b2884 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8712/rtl8712_recv.c</span>
<span class="p_chunk">@@ -1056,7 +1056,8 @@</span> <span class="p_context"> static int recvbuf2recvframe(struct _adapter *padapter, struct sk_buff *pskb)</span>
 		/* for first fragment packet, driver need allocate 1536 +
 		 * drvinfo_sz + RXDESC_SIZE to defrag packet. */
 		if ((mf == 1) &amp;&amp; (frag == 0))
<span class="p_del">-			alloc_sz = 1658;/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			/*1658+6=1664, 1664 is 128 alignment.*/</span>
<span class="p_add">+			alloc_sz = max_t(u16, tmp_len, 1658);</span>
 		else
 			alloc_sz = tmp_len;
 		/* 2 is for IP header 4 bytes alignment in QoS packet case.
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index 0343ae386f03..15baacb126ad 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -807,6 +807,10 @@</span> <span class="p_context"> static int device_rx_srv(struct vnt_private *pDevice, unsigned int uIdx)</span>
 	     pRD = pRD-&gt;next) {
 		if (works++ &gt; 15)
 			break;
<span class="p_add">+</span>
<span class="p_add">+		if (!pRD-&gt;pRDInfo-&gt;skb)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		if (vnt_receive_frame(pDevice, pRD)) {
 			if (!device_alloc_rx_buf(pDevice, pRD)) {
 				dev_err(&amp;pDevice-&gt;pcid-&gt;dev,
<span class="p_chunk">@@ -1417,7 +1421,7 @@</span> <span class="p_context"> static void vnt_bss_info_changed(struct ieee80211_hw *hw,</span>
 
 	priv-&gt;current_aid = conf-&gt;aid;
 
<span class="p_del">-	if (changed &amp; BSS_CHANGED_BSSID) {</span>
<span class="p_add">+	if (changed &amp; BSS_CHANGED_BSSID &amp;&amp; conf-&gt;bssid) {</span>
 		unsigned long flags;
 
 		spin_lock_irqsave(&amp;priv-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/staging/vt6656/main_usb.c b/drivers/staging/vt6656/main_usb.c</span>
<span class="p_header">index ab3ab84cb0a7..766fdcece074 100644</span>
<span class="p_header">--- a/drivers/staging/vt6656/main_usb.c</span>
<span class="p_header">+++ b/drivers/staging/vt6656/main_usb.c</span>
<span class="p_chunk">@@ -701,7 +701,7 @@</span> <span class="p_context"> static void vnt_bss_info_changed(struct ieee80211_hw *hw,</span>
 
 	priv-&gt;current_aid = conf-&gt;aid;
 
<span class="p_del">-	if (changed &amp; BSS_CHANGED_BSSID)</span>
<span class="p_add">+	if (changed &amp; BSS_CHANGED_BSSID &amp;&amp; conf-&gt;bssid)</span>
 		vnt_mac_set_bssid_addr(priv, (u8 *)conf-&gt;bssid);
 
 
<span class="p_header">diff --git a/drivers/tty/serial/Kconfig b/drivers/tty/serial/Kconfig</span>
<span class="p_header">index f8120c1bde14..8cd35348fc19 100644</span>
<span class="p_header">--- a/drivers/tty/serial/Kconfig</span>
<span class="p_header">+++ b/drivers/tty/serial/Kconfig</span>
<span class="p_chunk">@@ -241,7 +241,6 @@</span> <span class="p_context"> config SERIAL_SAMSUNG</span>
 	tristate &quot;Samsung SoC serial support&quot;
 	depends on PLAT_SAMSUNG || ARCH_EXYNOS
 	select SERIAL_CORE
<span class="p_del">-	select SERIAL_EARLYCON</span>
 	help
 	  Support for the on-chip UARTs on the Samsung S3C24XX series CPUs,
 	  providing /dev/ttySAC0, 1 and 2 (note, some machines may not
<span class="p_chunk">@@ -277,6 +276,7 @@</span> <span class="p_context"> config SERIAL_SAMSUNG_CONSOLE</span>
 	bool &quot;Support for console on Samsung SoC serial port&quot;
 	depends on SERIAL_SAMSUNG=y
 	select SERIAL_CORE_CONSOLE
<span class="p_add">+	select SERIAL_EARLYCON</span>
 	help
 	  Allow selection of the S3C24XX on-board serial ports for use as
 	  an virtual console.
<span class="p_header">diff --git a/drivers/tty/serial/atmel_serial.c b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">index 27dade29646b..5ca1dfb0561c 100644</span>
<span class="p_header">--- a/drivers/tty/serial/atmel_serial.c</span>
<span class="p_header">+++ b/drivers/tty/serial/atmel_serial.c</span>
<span class="p_chunk">@@ -315,8 +315,7 @@</span> <span class="p_context"> static int atmel_config_rs485(struct uart_port *port,</span>
 	if (rs485conf-&gt;flags &amp; SER_RS485_ENABLED) {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS485\n&quot;);
 		atmel_port-&gt;tx_done_mask = ATMEL_US_TXEMPTY;
<span class="p_del">-		if ((rs485conf-&gt;delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port, rs485conf-&gt;delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, rs485conf-&gt;delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else {
 		dev_dbg(port-&gt;dev, &quot;Setting UART to RS232\n&quot;);
<span class="p_chunk">@@ -354,8 +353,7 @@</span> <span class="p_context"> static void atmel_set_mctrl(struct uart_port *port, u_int mctrl)</span>
 
 	/* override mode to RS485 if needed, otherwise keep the current mode */
 	if (port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {
<span class="p_del">-		if ((port-&gt;rs485.delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
 		mode &amp;= ~ATMEL_US_USMODE;
 		mode |= ATMEL_US_USMODE_RS485;
 	}
<span class="p_chunk">@@ -2061,8 +2059,7 @@</span> <span class="p_context"> static void atmel_set_termios(struct uart_port *port, struct ktermios *termios,</span>
 
 	/* mode */
 	if (port-&gt;rs485.flags &amp; SER_RS485_ENABLED) {
<span class="p_del">-		if ((port-&gt;rs485.delay_rts_after_send) &gt; 0)</span>
<span class="p_del">-			UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
<span class="p_add">+		UART_PUT_TTGR(port, port-&gt;rs485.delay_rts_after_send);</span>
 		mode |= ATMEL_US_USMODE_RS485;
 	} else if (termios-&gt;c_cflag &amp; CRTSCTS) {
 		/* RS232 with hardware handshake (RTS/CTS) */
<span class="p_header">diff --git a/drivers/tty/sysrq.c b/drivers/tty/sysrq.c</span>
<span class="p_header">index 843f2cdc280b..9ffdfcf2ec6e 100644</span>
<span class="p_header">--- a/drivers/tty/sysrq.c</span>
<span class="p_header">+++ b/drivers/tty/sysrq.c</span>
<span class="p_chunk">@@ -55,9 +55,6 @@</span> <span class="p_context"></span>
 static int __read_mostly sysrq_enabled = CONFIG_MAGIC_SYSRQ_DEFAULT_ENABLE;
 static bool __read_mostly sysrq_always_enabled;
 
<span class="p_del">-unsigned short platform_sysrq_reset_seq[] __weak = { KEY_RESERVED };</span>
<span class="p_del">-int sysrq_reset_downtime_ms __weak;</span>
<span class="p_del">-</span>
 static bool sysrq_on(void)
 {
 	return sysrq_enabled || sysrq_always_enabled;
<span class="p_chunk">@@ -569,6 +566,7 @@</span> <span class="p_context"> void handle_sysrq(int key)</span>
 EXPORT_SYMBOL(handle_sysrq);
 
 #ifdef CONFIG_INPUT
<span class="p_add">+static int sysrq_reset_downtime_ms;</span>
 
 /* Simple translation table for the SysRq keys */
 static const unsigned char sysrq_xlate[KEY_CNT] =
<span class="p_chunk">@@ -949,23 +947,8 @@</span> <span class="p_context"> static bool sysrq_handler_registered;</span>
 
 static inline void sysrq_register_handler(void)
 {
<span class="p_del">-	unsigned short key;</span>
 	int error;
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* First check if a __weak interface was instantiated. */</span>
<span class="p_del">-	for (i = 0; i &lt; ARRAY_SIZE(sysrq_reset_seq); i++) {</span>
<span class="p_del">-		key = platform_sysrq_reset_seq[i];</span>
<span class="p_del">-		if (key == KEY_RESERVED || key &gt; KEY_MAX)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		sysrq_reset_seq[sysrq_reset_seq_len++] = key;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * DT configuration takes precedence over anything that would</span>
<span class="p_del">-	 * have been defined via the __weak interface.</span>
<span class="p_del">-	 */</span>
 	sysrq_of_get_keyreset_config();
 
 	error = input_register_handler(&amp;sysrq_handler);
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index 4b0448c26810..986abde07683 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -513,7 +513,7 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	snoop(&amp;urb-&gt;dev-&gt;dev, &quot;urb complete\n&quot;);
 	snoop_urb(urb-&gt;dev, as-&gt;userurb, urb-&gt;pipe, urb-&gt;actual_length,
 			as-&gt;status, COMPLETE, NULL, 0);
<span class="p_del">-	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == USB_DIR_IN)</span>
<span class="p_add">+	if ((urb-&gt;transfer_flags &amp; URB_DIR_MASK) == URB_DIR_IN)</span>
 		snoop_urb_data(urb, urb-&gt;actual_length);
 
 	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
<span class="p_header">diff --git a/drivers/usb/core/hcd.c b/drivers/usb/core/hcd.c</span>
<span class="p_header">index 45a915ccd71c..1c1385e3a824 100644</span>
<span class="p_header">--- a/drivers/usb/core/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/core/hcd.c</span>
<span class="p_chunk">@@ -1022,9 +1022,12 @@</span> <span class="p_context"> static int register_root_hub(struct usb_hcd *hcd)</span>
 				dev_name(&amp;usb_dev-&gt;dev), retval);
 		return (retval &lt; 0) ? retval : -EMSGSIZE;
 	}
<span class="p_del">-	if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
<span class="p_add">+</span>
<span class="p_add">+	if (le16_to_cpu(usb_dev-&gt;descriptor.bcdUSB) &gt;= 0x0201) {</span>
 		retval = usb_get_bos_descriptor(usb_dev);
<span class="p_del">-		if (retval &lt; 0) {</span>
<span class="p_add">+		if (!retval) {</span>
<span class="p_add">+			usb_dev-&gt;lpm_capable = usb_device_supports_lpm(usb_dev);</span>
<span class="p_add">+		} else if (usb_dev-&gt;speed == USB_SPEED_SUPER) {</span>
 			mutex_unlock(&amp;usb_bus_list_lock);
 			dev_dbg(parent_dev, &quot;can&#39;t read %s bos descriptor %d\n&quot;,
 					dev_name(&amp;usb_dev-&gt;dev), retval);
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index 3b7151687776..1e9a8c9aa531 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -122,7 +122,7 @@</span> <span class="p_context"> struct usb_hub *usb_hub_to_struct_hub(struct usb_device *hdev)</span>
 	return usb_get_intfdata(hdev-&gt;actconfig-&gt;interface[0]);
 }
 
<span class="p_del">-static int usb_device_supports_lpm(struct usb_device *udev)</span>
<span class="p_add">+int usb_device_supports_lpm(struct usb_device *udev)</span>
 {
 	/* USB 2.1 (and greater) devices indicate LPM support through
 	 * their USB 2.0 Extended Capabilities BOS descriptor.
<span class="p_chunk">@@ -2616,9 +2616,6 @@</span> <span class="p_context"> static bool use_new_scheme(struct usb_device *udev, int retry)</span>
 	return USE_NEW_SCHEME(retry);
 }
 
<span class="p_del">-static int hub_port_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, unsigned int delay, bool warm);</span>
<span class="p_del">-</span>
 /* Is a USB 3.0 port in the Inactive or Compliance Mode state?
  * Port worm reset is required to recover
  */
<span class="p_chunk">@@ -2706,44 +2703,6 @@</span> <span class="p_context"> static int hub_port_wait_reset(struct usb_hub *hub, int port1,</span>
 	return 0;
 }
 
<span class="p_del">-static void hub_port_finish_reset(struct usb_hub *hub, int port1,</span>
<span class="p_del">-			struct usb_device *udev, int *status)</span>
<span class="p_del">-{</span>
<span class="p_del">-	switch (*status) {</span>
<span class="p_del">-	case 0:</span>
<span class="p_del">-		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_del">-		msleep(10 + 40);</span>
<span class="p_del">-		if (udev) {</span>
<span class="p_del">-			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_del">-</span>
<span class="p_del">-			update_devnum(udev, 0);</span>
<span class="p_del">-			/* The xHC may think the device is already reset,</span>
<span class="p_del">-			 * so ignore the status.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_del">-				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		/* FALL THROUGH */</span>
<span class="p_del">-	case -ENOTCONN:</span>
<span class="p_del">-	case -ENODEV:</span>
<span class="p_del">-		usb_clear_port_feature(hub-&gt;hdev,</span>
<span class="p_del">-				port1, USB_PORT_FEAT_C_RESET);</span>
<span class="p_del">-		if (hub_is_superspeed(hub-&gt;hdev)) {</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_del">-			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_del">-					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (udev)</span>
<span class="p_del">-			usb_set_device_state(udev, *status</span>
<span class="p_del">-					? USB_STATE_NOTATTACHED</span>
<span class="p_del">-					: USB_STATE_DEFAULT);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Handle port reset and port warm(BH) reset (for USB3 protocol ports) */
 static int hub_port_reset(struct usb_hub *hub, int port1,
 			struct usb_device *udev, unsigned int delay, bool warm)
<span class="p_chunk">@@ -2767,13 +2726,10 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 		 * If the caller hasn&#39;t explicitly requested a warm reset,
 		 * double check and see if one is needed.
 		 */
<span class="p_del">-		status = hub_port_status(hub, port1,</span>
<span class="p_del">-					&amp;portstatus, &amp;portchange);</span>
<span class="p_del">-		if (status &lt; 0)</span>
<span class="p_del">-			goto done;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (hub_port_warm_reset_required(hub, port1, portstatus))</span>
<span class="p_del">-			warm = true;</span>
<span class="p_add">+		if (hub_port_status(hub, port1, &amp;portstatus, &amp;portchange) == 0)</span>
<span class="p_add">+			if (hub_port_warm_reset_required(hub, port1,</span>
<span class="p_add">+							portstatus))</span>
<span class="p_add">+				warm = true;</span>
 	}
 	clear_bit(port1, hub-&gt;warm_reset_bits);
 
<span class="p_chunk">@@ -2799,11 +2755,19 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 
 		/* Check for disconnect or reset */
 		if (status == 0 || status == -ENOTCONN || status == -ENODEV) {
<span class="p_del">-			hub_port_finish_reset(hub, port1, udev, &amp;status);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_RESET);</span>
 
 			if (!hub_is_superspeed(hub-&gt;hdev))
 				goto done;
 
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_BH_PORT_RESET);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_PORT_LINK_STATE);</span>
<span class="p_add">+			usb_clear_port_feature(hub-&gt;hdev, port1,</span>
<span class="p_add">+					USB_PORT_FEAT_C_CONNECTION);</span>
<span class="p_add">+</span>
 			/*
 			 * If a USB 3.0 device migrates from reset to an error
 			 * state, re-issue the warm reset.
<span class="p_chunk">@@ -2836,6 +2800,26 @@</span> <span class="p_context"> static int hub_port_reset(struct usb_hub *hub, int port1,</span>
 	dev_err(&amp;port_dev-&gt;dev, &quot;Cannot enable. Maybe the USB cable is bad?\n&quot;);
 
 done:
<span class="p_add">+	if (status == 0) {</span>
<span class="p_add">+		/* TRSTRCY = 10 ms; plus some extra */</span>
<span class="p_add">+		msleep(10 + 40);</span>
<span class="p_add">+		if (udev) {</span>
<span class="p_add">+			struct usb_hcd *hcd = bus_to_hcd(udev-&gt;bus);</span>
<span class="p_add">+</span>
<span class="p_add">+			update_devnum(udev, 0);</span>
<span class="p_add">+			/* The xHC may think the device is already reset,</span>
<span class="p_add">+			 * so ignore the status.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (hcd-&gt;driver-&gt;reset_device)</span>
<span class="p_add">+				hcd-&gt;driver-&gt;reset_device(hcd, udev);</span>
<span class="p_add">+</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_DEFAULT);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (udev)</span>
<span class="p_add">+			usb_set_device_state(udev, USB_STATE_NOTATTACHED);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (!hub_is_superspeed(hub-&gt;hdev))
 		up_read(&amp;ehci_cf_port_reset_rwsem);
 
<span class="p_header">diff --git a/drivers/usb/core/usb.h b/drivers/usb/core/usb.h</span>
<span class="p_header">index 7eb1e26798e5..457255a3306a 100644</span>
<span class="p_header">--- a/drivers/usb/core/usb.h</span>
<span class="p_header">+++ b/drivers/usb/core/usb.h</span>
<span class="p_chunk">@@ -65,6 +65,7 @@</span> <span class="p_context"> extern int  usb_hub_init(void);</span>
 extern void usb_hub_cleanup(void);
 extern int usb_major_init(void);
 extern void usb_major_cleanup(void);
<span class="p_add">+extern int usb_device_supports_lpm(struct usb_device *udev);</span>
 
 #ifdef	CONFIG_PM
 
<span class="p_header">diff --git a/drivers/usb/dwc3/ep0.c b/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">index 2ef3c8d6a9db..69e769c35cf5 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/ep0.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/ep0.c</span>
<span class="p_chunk">@@ -727,6 +727,10 @@</span> <span class="p_context"> static int dwc3_ep0_std_request(struct dwc3 *dwc, struct usb_ctrlrequest *ctrl)</span>
 		dwc3_trace(trace_dwc3_ep0, &quot;USB_REQ_SET_ISOCH_DELAY&quot;);
 		ret = dwc3_ep0_set_isoch_delay(dwc, ctrl);
 		break;
<span class="p_add">+	case USB_REQ_SET_INTERFACE:</span>
<span class="p_add">+		dwc3_trace(trace_dwc3_ep0, &quot;USB_REQ_SET_INTERFACE&quot;);</span>
<span class="p_add">+		dwc-&gt;start_config_issued = false;</span>
<span class="p_add">+		/* Fall through */</span>
 	default:
 		dwc3_trace(trace_dwc3_ep0, &quot;Forwarding to gadget driver&quot;);
 		ret = dwc3_ep0_delegate_req(dwc, ctrl);
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 8946c32047e9..333a7c0078fc 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -291,6 +291,8 @@</span> <span class="p_context"> int dwc3_send_gadget_generic_command(struct dwc3 *dwc, unsigned cmd, u32 param)</span>
 			dwc3_trace(trace_dwc3_gadget,
 					&quot;Command Complete --&gt; %d&quot;,
 					DWC3_DGCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DGCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_chunk">@@ -328,6 +330,8 @@</span> <span class="p_context"> int dwc3_send_gadget_ep_cmd(struct dwc3 *dwc, unsigned ep,</span>
 			dwc3_trace(trace_dwc3_gadget,
 					&quot;Command Complete --&gt; %d&quot;,
 					DWC3_DEPCMD_STATUS(reg));
<span class="p_add">+			if (DWC3_DEPCMD_STATUS(reg))</span>
<span class="p_add">+				return -EINVAL;</span>
 			return 0;
 		}
 
<span class="p_chunk">@@ -1902,12 +1906,16 @@</span> <span class="p_context"> static void dwc3_endpoint_transfer_complete(struct dwc3 *dwc,</span>
 {
 	unsigned		status = 0;
 	int			clean_busy;
<span class="p_add">+	u32			is_xfer_complete;</span>
<span class="p_add">+</span>
<span class="p_add">+	is_xfer_complete = (event-&gt;endpoint_event == DWC3_DEPEVT_XFERCOMPLETE);</span>
 
 	if (event-&gt;status &amp; DEPEVT_STATUS_BUSERR)
 		status = -ECONNRESET;
 
 	clean_busy = dwc3_cleanup_done_reqs(dwc, dep, event, status);
<span class="p_del">-	if (clean_busy)</span>
<span class="p_add">+	if (clean_busy &amp;&amp; (is_xfer_complete ||</span>
<span class="p_add">+				usb_endpoint_xfer_isoc(dep-&gt;endpoint.desc)))</span>
 		dep-&gt;flags &amp;= ~DWC3_EP_BUSY;
 
 	/*
<span class="p_header">diff --git a/drivers/usb/gadget/composite.c b/drivers/usb/gadget/composite.c</span>
<span class="p_header">index 4e3447bbd097..58b4657fc721 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/composite.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/composite.c</span>
<span class="p_chunk">@@ -1758,10 +1758,13 @@</span> <span class="p_context"> unknown:</span>
 		 * take such requests too, if that&#39;s ever needed:  to work
 		 * in config 0, etc.
 		 */
<span class="p_del">-		list_for_each_entry(f, &amp;cdev-&gt;config-&gt;functions, list)</span>
<span class="p_del">-			if (f-&gt;req_match &amp;&amp; f-&gt;req_match(f, ctrl))</span>
<span class="p_del">-				goto try_fun_setup;</span>
<span class="p_del">-		f = NULL;</span>
<span class="p_add">+		if (cdev-&gt;config) {</span>
<span class="p_add">+			list_for_each_entry(f, &amp;cdev-&gt;config-&gt;functions, list)</span>
<span class="p_add">+				if (f-&gt;req_match &amp;&amp; f-&gt;req_match(f, ctrl))</span>
<span class="p_add">+					goto try_fun_setup;</span>
<span class="p_add">+			f = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		switch (ctrl-&gt;bRequestType &amp; USB_RECIP_MASK) {
 		case USB_RECIP_INTERFACE:
 			if (!cdev-&gt;config || intf &gt;= MAX_CONFIG_INTERFACES)
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_fs.c b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">index 45b8c8b338df..6e7be91e6097 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_fs.c</span>
<span class="p_chunk">@@ -924,7 +924,8 @@</span> <span class="p_context"> static ssize_t ffs_epfile_write_iter(struct kiocb *kiocb, struct iov_iter *from)</span>
 
 	kiocb-&gt;private = p;
 
<span class="p_del">-	kiocb_set_cancel_fn(kiocb, ffs_aio_cancel);</span>
<span class="p_add">+	if (p-&gt;aio)</span>
<span class="p_add">+		kiocb_set_cancel_fn(kiocb, ffs_aio_cancel);</span>
 
 	res = ffs_epfile_io(kiocb-&gt;ki_filp, p);
 	if (res == -EIOCBQUEUED)
<span class="p_chunk">@@ -968,7 +969,8 @@</span> <span class="p_context"> static ssize_t ffs_epfile_read_iter(struct kiocb *kiocb, struct iov_iter *to)</span>
 
 	kiocb-&gt;private = p;
 
<span class="p_del">-	kiocb_set_cancel_fn(kiocb, ffs_aio_cancel);</span>
<span class="p_add">+	if (p-&gt;aio)</span>
<span class="p_add">+		kiocb_set_cancel_fn(kiocb, ffs_aio_cancel);</span>
 
 	res = ffs_epfile_io(kiocb-&gt;ki_filp, p);
 	if (res == -EIOCBQUEUED)
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_mass_storage.c b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">index 3cc109f3c9c8..15c307155037 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_mass_storage.c</span>
<span class="p_chunk">@@ -2786,7 +2786,7 @@</span> <span class="p_context"> int fsg_common_set_nluns(struct fsg_common *common, int nluns)</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	curlun = kcalloc(nluns, sizeof(*curlun), GFP_KERNEL);</span>
<span class="p_add">+	curlun = kcalloc(FSG_MAX_LUNS, sizeof(*curlun), GFP_KERNEL);</span>
 	if (unlikely(!curlun))
 		return -ENOMEM;
 
<span class="p_chunk">@@ -2796,8 +2796,6 @@</span> <span class="p_context"> int fsg_common_set_nluns(struct fsg_common *common, int nluns)</span>
 	common-&gt;luns = curlun;
 	common-&gt;nluns = nluns;
 
<span class="p_del">-	pr_info(&quot;Number of LUNs=%d\n&quot;, common-&gt;nluns);</span>
<span class="p_del">-</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(fsg_common_set_nluns);
<span class="p_chunk">@@ -3563,14 +3561,26 @@</span> <span class="p_context"> static struct usb_function *fsg_alloc(struct usb_function_instance *fi)</span>
 	struct fsg_opts *opts = fsg_opts_from_func_inst(fi);
 	struct fsg_common *common = opts-&gt;common;
 	struct fsg_dev *fsg;
<span class="p_add">+	unsigned nluns, i;</span>
 
 	fsg = kzalloc(sizeof(*fsg), GFP_KERNEL);
 	if (unlikely(!fsg))
 		return ERR_PTR(-ENOMEM);
 
 	mutex_lock(&amp;opts-&gt;lock);
<span class="p_add">+	if (!opts-&gt;refcnt) {</span>
<span class="p_add">+		for (nluns = i = 0; i &lt; FSG_MAX_LUNS; ++i)</span>
<span class="p_add">+			if (common-&gt;luns[i])</span>
<span class="p_add">+				nluns = i + 1;</span>
<span class="p_add">+		if (!nluns)</span>
<span class="p_add">+			pr_warn(&quot;No LUNS defined, continuing anyway\n&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			common-&gt;nluns = nluns;</span>
<span class="p_add">+		pr_info(&quot;Number of LUNs=%u\n&quot;, common-&gt;nluns);</span>
<span class="p_add">+	}</span>
 	opts-&gt;refcnt++;
 	mutex_unlock(&amp;opts-&gt;lock);
<span class="p_add">+</span>
 	fsg-&gt;function.name	= FSG_DRIVER_DESC;
 	fsg-&gt;function.bind	= fsg_bind;
 	fsg-&gt;function.unbind	= fsg_unbind;
<span class="p_header">diff --git a/drivers/usb/gadget/udc/mv_udc_core.c b/drivers/usb/gadget/udc/mv_udc_core.c</span>
<span class="p_header">index d32160d6463f..5da37c957b53 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/mv_udc_core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/mv_udc_core.c</span>
<span class="p_chunk">@@ -2167,7 +2167,7 @@</span> <span class="p_context"> static int mv_udc_probe(struct platform_device *pdev)</span>
 		return -ENODEV;
 	}
 
<span class="p_del">-	udc-&gt;phy_regs = ioremap(r-&gt;start, resource_size(r));</span>
<span class="p_add">+	udc-&gt;phy_regs = devm_ioremap(&amp;pdev-&gt;dev, r-&gt;start, resource_size(r));</span>
 	if (udc-&gt;phy_regs == NULL) {
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to map phy I/O memory\n&quot;);
 		return -EBUSY;
<span class="p_header">diff --git a/drivers/usb/host/ohci-q.c b/drivers/usb/host/ohci-q.c</span>
<span class="p_header">index 1463c398d322..fe1d5fc7da2d 100644</span>
<span class="p_header">--- a/drivers/usb/host/ohci-q.c</span>
<span class="p_header">+++ b/drivers/usb/host/ohci-q.c</span>
<span class="p_chunk">@@ -980,10 +980,6 @@</span> <span class="p_context"> rescan_all:</span>
 		int			completed, modified;
 		__hc32			*prev;
 
<span class="p_del">-		/* Is this ED already invisible to the hardware? */</span>
<span class="p_del">-		if (ed-&gt;state == ED_IDLE)</span>
<span class="p_del">-			goto ed_idle;</span>
<span class="p_del">-</span>
 		/* only take off EDs that the HC isn&#39;t using, accounting for
 		 * frame counter wraps and EDs with partially retired TDs
 		 */
<span class="p_chunk">@@ -1011,12 +1007,10 @@</span> <span class="p_context"> skip_ed:</span>
 		}
 
 		/* ED&#39;s now officially unlinked, hc doesn&#39;t see */
<span class="p_del">-		ed-&gt;state = ED_IDLE;</span>
 		ed-&gt;hwHeadP &amp;= ~cpu_to_hc32(ohci, ED_H);
 		ed-&gt;hwNextED = 0;
 		wmb();
 		ed-&gt;hwINFO &amp;= ~cpu_to_hc32(ohci, ED_SKIP | ED_DEQUEUE);
<span class="p_del">-ed_idle:</span>
 
 		/* reentrancy:  if we drop the schedule lock, someone might
 		 * have modified this list.  normally it&#39;s just prepending
<span class="p_chunk">@@ -1087,6 +1081,7 @@</span> <span class="p_context"> rescan_this:</span>
 		if (list_empty(&amp;ed-&gt;td_list)) {
 			*last = ed-&gt;ed_next;
 			ed-&gt;ed_next = NULL;
<span class="p_add">+			ed-&gt;state = ED_IDLE;</span>
 			list_del(&amp;ed-&gt;in_use_list);
 		} else if (ohci-&gt;rh_state == OHCI_RH_RUNNING) {
 			*last = ed-&gt;ed_next;
<span class="p_header">diff --git a/drivers/usb/host/xhci-mem.c b/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">index f8336408ef07..3e442f77a2b9 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-mem.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-mem.c</span>
<span class="p_chunk">@@ -1427,10 +1427,10 @@</span> <span class="p_context"> int xhci_endpoint_init(struct xhci_hcd *xhci,</span>
 		/* Attempt to use the ring cache */
 		if (virt_dev-&gt;num_rings_cached == 0)
 			return -ENOMEM;
<span class="p_add">+		virt_dev-&gt;num_rings_cached--;</span>
 		virt_dev-&gt;eps[ep_index].new_ring =
 			virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached];
 		virt_dev-&gt;ring_cache[virt_dev-&gt;num_rings_cached] = NULL;
<span class="p_del">-		virt_dev-&gt;num_rings_cached--;</span>
 		xhci_reinit_cached_ring(xhci, virt_dev-&gt;eps[ep_index].new_ring,
 					1, type);
 	}
<span class="p_header">diff --git a/drivers/usb/musb/musb_virthub.c b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">index 86c4b533e90b..4731baca377f 100644</span>
<span class="p_header">--- a/drivers/usb/musb/musb_virthub.c</span>
<span class="p_header">+++ b/drivers/usb/musb/musb_virthub.c</span>
<span class="p_chunk">@@ -273,9 +273,7 @@</span> <span class="p_context"> static int musb_has_gadget(struct musb *musb)</span>
 #ifdef CONFIG_USB_MUSB_HOST
 	return 1;
 #else
<span class="p_del">-	if (musb-&gt;port_mode == MUSB_PORT_MODE_HOST)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return musb-&gt;g.dev.driver != NULL;</span>
<span class="p_add">+	return musb-&gt;port_mode == MUSB_PORT_MODE_HOST;</span>
 #endif
 }
 
<span class="p_header">diff --git a/drivers/usb/phy/phy-mxs-usb.c b/drivers/usb/phy/phy-mxs-usb.c</span>
<span class="p_header">index 8f7cb068d29b..3fcc0483a081 100644</span>
<span class="p_header">--- a/drivers/usb/phy/phy-mxs-usb.c</span>
<span class="p_header">+++ b/drivers/usb/phy/phy-mxs-usb.c</span>
<span class="p_chunk">@@ -217,6 +217,9 @@</span> <span class="p_context"> static bool mxs_phy_get_vbus_status(struct mxs_phy *mxs_phy)</span>
 {
 	unsigned int vbus_value;
 
<span class="p_add">+	if (!mxs_phy-&gt;regmap_anatop)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	if (mxs_phy-&gt;port_id == 0)
 		regmap_read(mxs_phy-&gt;regmap_anatop,
 			ANADIG_USB1_VBUS_DET_STAT,
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index ffd739e31bfc..eac7ccaa3c85 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x1FB9, 0x0602) }, /* Lake Shore Model 648 Magnet Power Supply */
 	{ USB_DEVICE(0x1FB9, 0x0700) }, /* Lake Shore Model 737 VSM Controller */
 	{ USB_DEVICE(0x1FB9, 0x0701) }, /* Lake Shore Model 776 Hall Matrix */
<span class="p_add">+	{ USB_DEVICE(0x2626, 0xEA60) }, /* Aruba Networks 7xxx USB Serial Console */</span>
 	{ USB_DEVICE(0x3195, 0xF190) }, /* Link Instruments MSO-19 */
 	{ USB_DEVICE(0x3195, 0xF280) }, /* Link Instruments MSO-28 */
 	{ USB_DEVICE(0x3195, 0xF281) }, /* Link Instruments MSO-28 */
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index f0c0c53359ad..19b85ee98a72 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -1765,6 +1765,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */</span>
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
 	{ } /* Terminating entry */
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index 529066bbc7e8..46f1f13b41f1 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1306,6 +1306,7 @@</span> <span class="p_context"> static void __exit usb_serial_exit(void)</span>
 	tty_unregister_driver(usb_serial_tty_driver);
 	put_tty_driver(usb_serial_tty_driver);
 	bus_unregister(&amp;usb_serial_bus_type);
<span class="p_add">+	idr_destroy(&amp;serial_minors);</span>
 }
 
 
<span class="p_header">diff --git a/drivers/w1/slaves/w1_therm.c b/drivers/w1/slaves/w1_therm.c</span>
<span class="p_header">index 1f11a20a8ab9..55eb86c9e214 100644</span>
<span class="p_header">--- a/drivers/w1/slaves/w1_therm.c</span>
<span class="p_header">+++ b/drivers/w1/slaves/w1_therm.c</span>
<span class="p_chunk">@@ -59,16 +59,32 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;w1-family-&quot; __stringify(W1_THERM_DS28EA00));</span>
 static int w1_strong_pullup = 1;
 module_param_named(strong_pullup, w1_strong_pullup, int, 0);
 
<span class="p_add">+struct w1_therm_family_data {</span>
<span class="p_add">+	uint8_t rom[9];</span>
<span class="p_add">+	atomic_t refcnt;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* return the address of the refcnt in the family data */</span>
<span class="p_add">+#define THERM_REFCNT(family_data) \</span>
<span class="p_add">+	(&amp;((struct w1_therm_family_data*)family_data)-&gt;refcnt)</span>
<span class="p_add">+</span>
 static int w1_therm_add_slave(struct w1_slave *sl)
 {
<span class="p_del">-	sl-&gt;family_data = kzalloc(9, GFP_KERNEL);</span>
<span class="p_add">+	sl-&gt;family_data = kzalloc(sizeof(struct w1_therm_family_data),</span>
<span class="p_add">+		GFP_KERNEL);</span>
 	if (!sl-&gt;family_data)
 		return -ENOMEM;
<span class="p_add">+	atomic_set(THERM_REFCNT(sl-&gt;family_data), 1);</span>
 	return 0;
 }
 
 static void w1_therm_remove_slave(struct w1_slave *sl)
 {
<span class="p_add">+	int refcnt = atomic_sub_return(1, THERM_REFCNT(sl-&gt;family_data));</span>
<span class="p_add">+	while(refcnt) {</span>
<span class="p_add">+		msleep(1000);</span>
<span class="p_add">+		refcnt = atomic_read(THERM_REFCNT(sl-&gt;family_data));</span>
<span class="p_add">+	}</span>
 	kfree(sl-&gt;family_data);
 	sl-&gt;family_data = NULL;
 }
<span class="p_chunk">@@ -194,13 +210,22 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 	struct w1_slave *sl = dev_to_w1_slave(device);
 	struct w1_master *dev = sl-&gt;master;
 	u8 rom[9], crc, verdict, external_power;
<span class="p_del">-	int i, max_trying = 10;</span>
<span class="p_add">+	int i, ret, max_trying = 10;</span>
 	ssize_t c = PAGE_SIZE;
<span class="p_add">+	u8 *family_data = sl-&gt;family_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_add">+	if (ret != 0)</span>
<span class="p_add">+		goto post_unlock;</span>
 
<span class="p_del">-	i = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-	if (i != 0)</span>
<span class="p_del">-		return i;</span>
<span class="p_add">+	if(!sl-&gt;family_data)</span>
<span class="p_add">+	{</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto pre_unlock;</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	/* prevent the slave from going away in sleep */</span>
<span class="p_add">+	atomic_inc(THERM_REFCNT(family_data));</span>
 	memset(rom, 0, sizeof(rom));
 
 	while (max_trying--) {
<span class="p_chunk">@@ -230,17 +255,19 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 				mutex_unlock(&amp;dev-&gt;bus_mutex);
 
 				sleep_rem = msleep_interruptible(tm);
<span class="p_del">-				if (sleep_rem != 0)</span>
<span class="p_del">-					return -EINTR;</span>
<span class="p_add">+				if (sleep_rem != 0) {</span>
<span class="p_add">+					ret = -EINTR;</span>
<span class="p_add">+					goto post_unlock;</span>
<span class="p_add">+				}</span>
 
<span class="p_del">-				i = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-				if (i != 0)</span>
<span class="p_del">-					return i;</span>
<span class="p_add">+				ret = mutex_lock_interruptible(&amp;dev-&gt;bus_mutex);</span>
<span class="p_add">+				if (ret != 0)</span>
<span class="p_add">+					goto post_unlock;</span>
 			} else if (!w1_strong_pullup) {
 				sleep_rem = msleep_interruptible(tm);
 				if (sleep_rem != 0) {
<span class="p_del">-					mutex_unlock(&amp;dev-&gt;bus_mutex);</span>
<span class="p_del">-					return -EINTR;</span>
<span class="p_add">+					ret = -EINTR;</span>
<span class="p_add">+					goto pre_unlock;</span>
 				}
 			}
 
<span class="p_chunk">@@ -269,19 +296,24 @@</span> <span class="p_context"> static ssize_t w1_slave_show(struct device *device,</span>
 	c -= snprintf(buf + PAGE_SIZE - c, c, &quot;: crc=%02x %s\n&quot;,
 			   crc, (verdict) ? &quot;YES&quot; : &quot;NO&quot;);
 	if (verdict)
<span class="p_del">-		memcpy(sl-&gt;family_data, rom, sizeof(rom));</span>
<span class="p_add">+		memcpy(family_data, rom, sizeof(rom));</span>
 	else
 		dev_warn(device, &quot;Read failed CRC check\n&quot;);
 
 	for (i = 0; i &lt; 9; ++i)
 		c -= snprintf(buf + PAGE_SIZE - c, c, &quot;%02x &quot;,
<span class="p_del">-			      ((u8 *)sl-&gt;family_data)[i]);</span>
<span class="p_add">+			      ((u8 *)family_data)[i]);</span>
 
 	c -= snprintf(buf + PAGE_SIZE - c, c, &quot;t=%d\n&quot;,
 		w1_convert_temp(rom, sl-&gt;family-&gt;fid));
<span class="p_add">+	ret = PAGE_SIZE - c;</span>
<span class="p_add">+</span>
<span class="p_add">+pre_unlock:</span>
 	mutex_unlock(&amp;dev-&gt;bus_mutex);
 
<span class="p_del">-	return PAGE_SIZE - c;</span>
<span class="p_add">+post_unlock:</span>
<span class="p_add">+	atomic_dec(THERM_REFCNT(family_data));</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int __init w1_therm_init(void)
<span class="p_header">diff --git a/drivers/watchdog/omap_wdt.c b/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">index 1e6be9e40577..c9c97dacf452 100644</span>
<span class="p_header">--- a/drivers/watchdog/omap_wdt.c</span>
<span class="p_header">+++ b/drivers/watchdog/omap_wdt.c</span>
<span class="p_chunk">@@ -132,6 +132,13 @@</span> <span class="p_context"> static int omap_wdt_start(struct watchdog_device *wdog)</span>
 
 	pm_runtime_get_sync(wdev-&gt;dev);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Make sure the watchdog is disabled. This is unfortunately required</span>
<span class="p_add">+	 * because writing to various registers with the watchdog running has no</span>
<span class="p_add">+	 * effect.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	omap_wdt_disable(wdev);</span>
<span class="p_add">+</span>
 	/* initialize prescaler */
 	while (readl_relaxed(base + OMAP_WATCHDOG_WPS) &amp; 0x01)
 		cpu_relax();
<span class="p_header">diff --git a/fs/9p/vfs_inode.c b/fs/9p/vfs_inode.c</span>
<span class="p_header">index 703342e309f5..53f1e8a21707 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode.c</span>
<span class="p_chunk">@@ -540,8 +540,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/9p/vfs_inode_dotl.c b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">index 9861c7c951a6..4d3ecfb55fcf 100644</span>
<span class="p_header">--- a/fs/9p/vfs_inode_dotl.c</span>
<span class="p_header">+++ b/fs/9p/vfs_inode_dotl.c</span>
<span class="p_chunk">@@ -149,8 +149,7 @@</span> <span class="p_context"> static struct inode *v9fs_qid_iget_dotl(struct super_block *sb,</span>
 	unlock_new_inode(inode);
 	return inode;
 error:
<span class="p_del">-	unlock_new_inode(inode);</span>
<span class="p_del">-	iput(inode);</span>
<span class="p_add">+	iget_failed(inode);</span>
 	return ERR_PTR(retval);
 
 }
<span class="p_header">diff --git a/fs/btrfs/inode-map.c b/fs/btrfs/inode-map.c</span>
<span class="p_header">index f6a596d5a637..d4a582ac3f73 100644</span>
<span class="p_header">--- a/fs/btrfs/inode-map.c</span>
<span class="p_header">+++ b/fs/btrfs/inode-map.c</span>
<span class="p_chunk">@@ -246,6 +246,7 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 {
 	struct btrfs_free_space_ctl *ctl = root-&gt;free_ino_ctl;
 	struct rb_root *rbroot = &amp;root-&gt;free_ino_pinned-&gt;free_space_offset;
<span class="p_add">+	spinlock_t *rbroot_lock = &amp;root-&gt;free_ino_pinned-&gt;tree_lock;</span>
 	struct btrfs_free_space *info;
 	struct rb_node *n;
 	u64 count;
<span class="p_chunk">@@ -254,24 +255,30 @@</span> <span class="p_context"> void btrfs_unpin_free_ino(struct btrfs_root *root)</span>
 		return;
 
 	while (1) {
<span class="p_add">+		bool add_to_ctl = true;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(rbroot_lock);</span>
 		n = rb_first(rbroot);
<span class="p_del">-		if (!n)</span>
<span class="p_add">+		if (!n) {</span>
<span class="p_add">+			spin_unlock(rbroot_lock);</span>
 			break;
<span class="p_add">+		}</span>
 
 		info = rb_entry(n, struct btrfs_free_space, offset_index);
 		BUG_ON(info-&gt;bitmap); /* Logic error */
 
 		if (info-&gt;offset &gt; root-&gt;ino_cache_progress)
<span class="p_del">-			goto free;</span>
<span class="p_add">+			add_to_ctl = false;</span>
 		else if (info-&gt;offset + info-&gt;bytes &gt; root-&gt;ino_cache_progress)
 			count = root-&gt;ino_cache_progress - info-&gt;offset + 1;
 		else
 			count = info-&gt;bytes;
 
<span class="p_del">-		__btrfs_add_free_space(ctl, info-&gt;offset, count);</span>
<span class="p_del">-free:</span>
 		rb_erase(&amp;info-&gt;offset_index, rbroot);
<span class="p_del">-		kfree(info);</span>
<span class="p_add">+		spin_unlock(rbroot_lock);</span>
<span class="p_add">+		if (add_to_ctl)</span>
<span class="p_add">+			__btrfs_add_free_space(ctl, info-&gt;offset, count);</span>
<span class="p_add">+		kmem_cache_free(btrfs_free_space_cachep, info);</span>
 	}
 }
 
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 1c22c6518504..37d456a9a3b8 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -2413,8 +2413,6 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 		goto out_unlock_inode;
 	}
 
<span class="p_del">-	d_invalidate(dentry);</span>
<span class="p_del">-</span>
 	down_write(&amp;root-&gt;fs_info-&gt;subvol_sem);
 
 	err = may_destroy_subvol(dest);
<span class="p_chunk">@@ -2508,7 +2506,7 @@</span> <span class="p_context"> out_up_write:</span>
 out_unlock_inode:
 	mutex_unlock(&amp;inode-&gt;i_mutex);
 	if (!err) {
<span class="p_del">-		shrink_dcache_sb(root-&gt;fs_info-&gt;sb);</span>
<span class="p_add">+		d_invalidate(dentry);</span>
 		btrfs_invalidate_inodes(dest);
 		d_delete(dentry);
 		ASSERT(dest-&gt;send_in_progress == 0);
<span class="p_chunk">@@ -2940,7 +2938,7 @@</span> <span class="p_context"> out_unlock:</span>
 static long btrfs_ioctl_file_extent_same(struct file *file,
 			struct btrfs_ioctl_same_args __user *argp)
 {
<span class="p_del">-	struct btrfs_ioctl_same_args *same;</span>
<span class="p_add">+	struct btrfs_ioctl_same_args *same = NULL;</span>
 	struct btrfs_ioctl_same_extent_info *info;
 	struct inode *src = file_inode(file);
 	u64 off;
<span class="p_chunk">@@ -2970,6 +2968,7 @@</span> <span class="p_context"> static long btrfs_ioctl_file_extent_same(struct file *file,</span>
 
 	if (IS_ERR(same)) {
 		ret = PTR_ERR(same);
<span class="p_add">+		same = NULL;</span>
 		goto out;
 	}
 
<span class="p_chunk">@@ -3040,6 +3039,7 @@</span> <span class="p_context"> static long btrfs_ioctl_file_extent_same(struct file *file,</span>
 
 out:
 	mnt_drop_write_file(file);
<span class="p_add">+	kfree(same);</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -3434,6 +3434,20 @@</span> <span class="p_context"> process_slot:</span>
 				u64 trim = 0;
 				u64 aligned_end = 0;
 
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Don&#39;t copy an inline extent into an offset</span>
<span class="p_add">+				 * greater than zero. Having an inline extent</span>
<span class="p_add">+				 * at such an offset results in chaos as btrfs</span>
<span class="p_add">+				 * isn&#39;t prepared for such cases. Just skip</span>
<span class="p_add">+				 * this case for the same reasons as commented</span>
<span class="p_add">+				 * at btrfs_ioctl_clone().</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (last_dest_end &gt; 0) {</span>
<span class="p_add">+					ret = -EOPNOTSUPP;</span>
<span class="p_add">+					btrfs_end_transaction(trans, root);</span>
<span class="p_add">+					goto out;</span>
<span class="p_add">+				}</span>
<span class="p_add">+</span>
 				if (off &gt; key.offset) {
 					skip = off - key.offset;
 					new_key.offset += skip;
<span class="p_header">diff --git a/fs/btrfs/transaction.c b/fs/btrfs/transaction.c</span>
<span class="p_header">index 5628e25250c0..94e909c5a503 100644</span>
<span class="p_header">--- a/fs/btrfs/transaction.c</span>
<span class="p_header">+++ b/fs/btrfs/transaction.c</span>
<span class="p_chunk">@@ -758,7 +758,7 @@</span> <span class="p_context"> static int __btrfs_end_transaction(struct btrfs_trans_handle *trans,</span>
 
 	if (!list_empty(&amp;trans-&gt;ordered)) {
 		spin_lock(&amp;info-&gt;trans_lock);
<span class="p_del">-		list_splice(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
<span class="p_add">+		list_splice_init(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
 		spin_unlock(&amp;info-&gt;trans_lock);
 	}
 
<span class="p_chunk">@@ -1848,7 +1848,7 @@</span> <span class="p_context"> int btrfs_commit_transaction(struct btrfs_trans_handle *trans,</span>
 	}
 
 	spin_lock(&amp;root-&gt;fs_info-&gt;trans_lock);
<span class="p_del">-	list_splice(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
<span class="p_add">+	list_splice_init(&amp;trans-&gt;ordered, &amp;cur_trans-&gt;pending_ordered);</span>
 	if (cur_trans-&gt;state &gt;= TRANS_STATE_COMMIT_START) {
 		spin_unlock(&amp;root-&gt;fs_info-&gt;trans_lock);
 		atomic_inc(&amp;cur_trans-&gt;use_count);
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index d04968374e9d..4920fceffacb 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -4161,6 +4161,7 @@</span> <span class="p_context"> static int btrfs_log_inode(struct btrfs_trans_handle *trans,</span>
 	u64 ino = btrfs_ino(inode);
 	struct extent_map_tree *em_tree = &amp;BTRFS_I(inode)-&gt;extent_tree;
 	u64 logged_isize = 0;
<span class="p_add">+	bool need_log_inode_item = true;</span>
 
 	path = btrfs_alloc_path();
 	if (!path)
<span class="p_chunk">@@ -4269,11 +4270,6 @@</span> <span class="p_context"> static int btrfs_log_inode(struct btrfs_trans_handle *trans,</span>
 		} else {
 			if (inode_only == LOG_INODE_ALL)
 				fast_search = true;
<span class="p_del">-			ret = log_inode_item(trans, log, dst_path, inode);</span>
<span class="p_del">-			if (ret) {</span>
<span class="p_del">-				err = ret;</span>
<span class="p_del">-				goto out_unlock;</span>
<span class="p_del">-			}</span>
 			goto log_extents;
 		}
 
<span class="p_chunk">@@ -4296,6 +4292,9 @@</span> <span class="p_context"> again:</span>
 		if (min_key.type &gt; max_key.type)
 			break;
 
<span class="p_add">+		if (min_key.type == BTRFS_INODE_ITEM_KEY)</span>
<span class="p_add">+			need_log_inode_item = false;</span>
<span class="p_add">+</span>
 		src = path-&gt;nodes[0];
 		if (ins_nr &amp;&amp; ins_start_slot + ins_nr == path-&gt;slots[0]) {
 			ins_nr++;
<span class="p_chunk">@@ -4366,6 +4365,11 @@</span> <span class="p_context"> next_slot:</span>
 log_extents:
 	btrfs_release_path(path);
 	btrfs_release_path(dst_path);
<span class="p_add">+	if (need_log_inode_item) {</span>
<span class="p_add">+		err = log_inode_item(trans, log, dst_path, inode);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_unlock;</span>
<span class="p_add">+	}</span>
 	if (fast_search) {
 		/*
 		 * Some ordered extents started by fsync might have completed
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index e003a1e81dc3..87ba10d1d3bc 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -503,7 +503,7 @@</span> <span class="p_context"> __read_extent_tree_block(const char *function, unsigned int line,</span>
 	struct buffer_head		*bh;
 	int				err;
 
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, pblk);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, pblk, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (unlikely(!bh))
 		return ERR_PTR(-ENOMEM);
 
<span class="p_chunk">@@ -1088,7 +1088,7 @@</span> <span class="p_context"> static int ext4_ext_split(handle_t *handle, struct inode *inode,</span>
 		err = -EIO;
 		goto cleanup;
 	}
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, newblock);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (unlikely(!bh)) {
 		err = -ENOMEM;
 		goto cleanup;
<span class="p_chunk">@@ -1282,7 +1282,7 @@</span> <span class="p_context"> static int ext4_ext_grow_indepth(handle_t *handle, struct inode *inode,</span>
 	if (newblock == 0)
 		return err;
 
<span class="p_del">-	bh = sb_getblk(inode-&gt;i_sb, newblock);</span>
<span class="p_add">+	bh = sb_getblk_gfp(inode-&gt;i_sb, newblock, __GFP_MOVABLE | GFP_NOFS);</span>
 	if (unlikely(!bh))
 		return -ENOMEM;
 	lock_buffer(bh);
<span class="p_header">diff --git a/fs/ext4/indirect.c b/fs/ext4/indirect.c</span>
<span class="p_header">index 958824019509..94ae6874c2cb 100644</span>
<span class="p_header">--- a/fs/ext4/indirect.c</span>
<span class="p_header">+++ b/fs/ext4/indirect.c</span>
<span class="p_chunk">@@ -565,7 +565,7 @@</span> <span class="p_context"> int ext4_ind_map_blocks(handle_t *handle, struct inode *inode,</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC)) {
 		EXT4_ERROR_INODE(inode, &quot;Can&#39;t allocate blocks for &quot;
 				 &quot;non-extent mapped inodes with bigalloc&quot;);
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_add">+		return -EUCLEAN;</span>
 	}
 
 	/* Set up for the direct block allocation */
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index 0554b0b5957b..966c614822cc 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void ext4_da_page_release_reservation(struct page *page,</span>
 					     unsigned int offset,
 					     unsigned int length)
 {
<span class="p_del">-	int to_release = 0;</span>
<span class="p_add">+	int to_release = 0, contiguous_blks = 0;</span>
 	struct buffer_head *head, *bh;
 	unsigned int curr_off = 0;
 	struct inode *inode = page-&gt;mapping-&gt;host;
<span class="p_chunk">@@ -1363,14 +1363,23 @@</span> <span class="p_context"> static void ext4_da_page_release_reservation(struct page *page,</span>
 
 		if ((offset &lt;= curr_off) &amp;&amp; (buffer_delay(bh))) {
 			to_release++;
<span class="p_add">+			contiguous_blks++;</span>
 			clear_buffer_delay(bh);
<span class="p_add">+		} else if (contiguous_blks) {</span>
<span class="p_add">+			lblk = page-&gt;index &lt;&lt;</span>
<span class="p_add">+			       (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);</span>
<span class="p_add">+			lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) -</span>
<span class="p_add">+				contiguous_blks;</span>
<span class="p_add">+			ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
<span class="p_add">+			contiguous_blks = 0;</span>
 		}
 		curr_off = next_off;
 	} while ((bh = bh-&gt;b_this_page) != head);
 
<span class="p_del">-	if (to_release) {</span>
<span class="p_add">+	if (contiguous_blks) {</span>
 		lblk = page-&gt;index &lt;&lt; (PAGE_CACHE_SHIFT - inode-&gt;i_blkbits);
<span class="p_del">-		ext4_es_remove_extent(inode, lblk, to_release);</span>
<span class="p_add">+		lblk += (curr_off &gt;&gt; inode-&gt;i_blkbits) - contiguous_blks;</span>
<span class="p_add">+		ext4_es_remove_extent(inode, lblk, contiguous_blks);</span>
 	}
 
 	/* If we have released all the blocks belonging to a cluster, then we
<span class="p_chunk">@@ -1701,19 +1710,32 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 		ext4_walk_page_buffers(handle, page_bufs, 0, len,
 				       NULL, bget_one);
 	}
<span class="p_del">-	/* As soon as we unlock the page, it can go away, but we have</span>
<span class="p_del">-	 * references to buffers so we are safe */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need to release the page lock before we start the</span>
<span class="p_add">+	 * journal, so grab a reference so the page won&#39;t disappear</span>
<span class="p_add">+	 * out from under us.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	get_page(page);</span>
 	unlock_page(page);
 
 	handle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,
 				    ext4_writepage_trans_blocks(inode));
 	if (IS_ERR(handle)) {
 		ret = PTR_ERR(handle);
<span class="p_del">-		goto out;</span>
<span class="p_add">+		put_page(page);</span>
<span class="p_add">+		goto out_no_pagelock;</span>
 	}
<span class="p_del">-</span>
 	BUG_ON(!ext4_handle_valid(handle));
 
<span class="p_add">+	lock_page(page);</span>
<span class="p_add">+	put_page(page);</span>
<span class="p_add">+	if (page-&gt;mapping != mapping) {</span>
<span class="p_add">+		/* The page got truncated from under us */</span>
<span class="p_add">+		ext4_journal_stop(handle);</span>
<span class="p_add">+		ret = 0;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (inline_data) {
 		BUFFER_TRACE(inode_bh, &quot;get write access&quot;);
 		ret = ext4_journal_get_write_access(handle, inode_bh);
<span class="p_chunk">@@ -1739,6 +1761,8 @@</span> <span class="p_context"> static int __ext4_journalled_writepage(struct page *page,</span>
 				       NULL, bput_one);
 	ext4_set_inode_state(inode, EXT4_STATE_JDATA);
 out:
<span class="p_add">+	unlock_page(page);</span>
<span class="p_add">+out_no_pagelock:</span>
 	brelse(inode_bh);
 	return ret;
 }
<span class="p_chunk">@@ -4345,7 +4369,12 @@</span> <span class="p_context"> static void ext4_update_other_inodes_time(struct super_block *sb,</span>
 	int inode_size = EXT4_INODE_SIZE(sb);
 
 	oi.orig_ino = orig_ino;
<span class="p_del">-	ino = (orig_ino &amp; ~(inodes_per_block - 1)) + 1;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Calculate the first inode in the inode table block.  Inode</span>
<span class="p_add">+	 * numbers are one-based.  That is, the first inode in a block</span>
<span class="p_add">+	 * (assuming 4k blocks and 256 byte inodes) is (n*16 + 1).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ino = ((orig_ino - 1) &amp; ~(inodes_per_block - 1)) + 1;</span>
 	for (i = 0; i &lt; inodes_per_block; i++, ino++, buf += inode_size) {
 		if (ino == orig_ino)
 			continue;
<span class="p_header">diff --git a/fs/ext4/mballoc.c b/fs/ext4/mballoc.c</span>
<span class="p_header">index 8d1e60214ef0..41260489d3bc 100644</span>
<span class="p_header">--- a/fs/ext4/mballoc.c</span>
<span class="p_header">+++ b/fs/ext4/mballoc.c</span>
<span class="p_chunk">@@ -4800,18 +4800,12 @@</span> <span class="p_context"> do_more:</span>
 		/*
 		 * blocks being freed are metadata. these blocks shouldn&#39;t
 		 * be used until this transaction is committed
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We use __GFP_NOFAIL because ext4_free_blocks() is not allowed</span>
<span class="p_add">+		 * to fail.</span>
 		 */
<span class="p_del">-	retry:</span>
<span class="p_del">-		new_entry = kmem_cache_alloc(ext4_free_data_cachep, GFP_NOFS);</span>
<span class="p_del">-		if (!new_entry) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We use a retry loop because</span>
<span class="p_del">-			 * ext4_free_blocks() is not allowed to fail.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			cond_resched();</span>
<span class="p_del">-			congestion_wait(BLK_RW_ASYNC, HZ/50);</span>
<span class="p_del">-			goto retry;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		new_entry = kmem_cache_alloc(ext4_free_data_cachep,</span>
<span class="p_add">+				GFP_NOFS|__GFP_NOFAIL);</span>
 		new_entry-&gt;efd_start_cluster = bit;
 		new_entry-&gt;efd_group = block_group;
 		new_entry-&gt;efd_count = count_clusters;
<span class="p_header">diff --git a/fs/ext4/migrate.c b/fs/ext4/migrate.c</span>
<span class="p_header">index b52374e42102..6163ad21cb0e 100644</span>
<span class="p_header">--- a/fs/ext4/migrate.c</span>
<span class="p_header">+++ b/fs/ext4/migrate.c</span>
<span class="p_chunk">@@ -620,6 +620,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 	struct ext4_inode_info		*ei = EXT4_I(inode);
 	struct ext4_extent		*ex;
 	unsigned int			i, len;
<span class="p_add">+	ext4_lblk_t			start, end;</span>
 	ext4_fsblk_t			blk;
 	handle_t			*handle;
 	int				ret;
<span class="p_chunk">@@ -633,6 +634,14 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 				       EXT4_FEATURE_RO_COMPAT_BIGALLOC))
 		return -EOPNOTSUPP;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In order to get correct extent info, force all delayed allocation</span>
<span class="p_add">+	 * blocks to be allocated, otherwise delayed allocation blocks may not</span>
<span class="p_add">+	 * be reflected and bypass the checks on extent header.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (test_opt(inode-&gt;i_sb, DELALLOC))</span>
<span class="p_add">+		ext4_alloc_da_blocks(inode);</span>
<span class="p_add">+</span>
 	handle = ext4_journal_start(inode, EXT4_HT_MIGRATE, 1);
 	if (IS_ERR(handle))
 		return PTR_ERR(handle);
<span class="p_chunk">@@ -650,11 +659,13 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 		goto errout;
 	}
 	if (eh-&gt;eh_entries == 0)
<span class="p_del">-		blk = len = 0;</span>
<span class="p_add">+		blk = len = start = end = 0;</span>
 	else {
 		len = le16_to_cpu(ex-&gt;ee_len);
 		blk = ext4_ext_pblock(ex);
<span class="p_del">-		if (len &gt; EXT4_NDIR_BLOCKS) {</span>
<span class="p_add">+		start = le32_to_cpu(ex-&gt;ee_block);</span>
<span class="p_add">+		end = start + len - 1;</span>
<span class="p_add">+		if (end &gt;= EXT4_NDIR_BLOCKS) {</span>
 			ret = -EOPNOTSUPP;
 			goto errout;
 		}
<span class="p_chunk">@@ -662,7 +673,7 @@</span> <span class="p_context"> int ext4_ind_migrate(struct inode *inode)</span>
 
 	ext4_clear_inode_flag(inode, EXT4_INODE_EXTENTS);
 	memset(ei-&gt;i_data, 0, sizeof(ei-&gt;i_data));
<span class="p_del">-	for (i=0; i &lt; len; i++)</span>
<span class="p_add">+	for (i = start; i &lt;= end; i++)</span>
 		ei-&gt;i_data[i] = cpu_to_le32(blk++);
 	ext4_mark_inode_dirty(handle, inode);
 errout:
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index ca9d4a2fed41..ca12affdba96 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -807,6 +807,7 @@</span> <span class="p_context"> static void ext4_put_super(struct super_block *sb)</span>
 		dump_orphan_list(sb, sbi);
 	J_ASSERT(list_empty(&amp;sbi-&gt;s_orphan));
 
<span class="p_add">+	sync_blockdev(sb-&gt;s_bdev);</span>
 	invalidate_bdev(sb-&gt;s_bdev);
 	if (sbi-&gt;journal_bdev &amp;&amp; sbi-&gt;journal_bdev != sb-&gt;s_bdev) {
 		/*
<span class="p_chunk">@@ -4943,6 +4944,9 @@</span> <span class="p_context"> static int ext4_remount(struct super_block *sb, int *flags, char *data)</span>
 		set_task_ioprio(sbi-&gt;s_journal-&gt;j_task, journal_ioprio);
 	}
 
<span class="p_add">+	if (*flags &amp; MS_LAZYTIME)</span>
<span class="p_add">+		sb-&gt;s_flags |= MS_LAZYTIME;</span>
<span class="p_add">+</span>
 	if ((*flags &amp; MS_RDONLY) != (sb-&gt;s_flags &amp; MS_RDONLY)) {
 		if (sbi-&gt;s_mount_flags &amp; EXT4_MF_FS_ABORTED) {
 			err = -EROFS;
<span class="p_header">diff --git a/fs/fuse/inode.c b/fs/fuse/inode.c</span>
<span class="p_header">index 18dacf9ed8ff..708d697113fc 100644</span>
<span class="p_header">--- a/fs/fuse/inode.c</span>
<span class="p_header">+++ b/fs/fuse/inode.c</span>
<span class="p_chunk">@@ -1026,6 +1026,7 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		goto err_fput;
 
 	fuse_conn_init(fc);
<span class="p_add">+	fc-&gt;release = fuse_free_conn;</span>
 
 	fc-&gt;dev = sb-&gt;s_dev;
 	fc-&gt;sb = sb;
<span class="p_chunk">@@ -1040,7 +1041,6 @@</span> <span class="p_context"> static int fuse_fill_super(struct super_block *sb, void *data, int silent)</span>
 		fc-&gt;dont_mask = 1;
 	sb-&gt;s_flags |= MS_POSIXACL;
 
<span class="p_del">-	fc-&gt;release = fuse_free_conn;</span>
 	fc-&gt;flags = d.flags;
 	fc-&gt;user_id = d.user_id;
 	fc-&gt;group_id = d.group_id;
<span class="p_header">diff --git a/fs/hpfs/super.c b/fs/hpfs/super.c</span>
<span class="p_header">index 7cd00d3a7c9b..8685c655737f 100644</span>
<span class="p_header">--- a/fs/hpfs/super.c</span>
<span class="p_header">+++ b/fs/hpfs/super.c</span>
<span class="p_chunk">@@ -52,17 +52,20 @@</span> <span class="p_context"> static void unmark_dirty(struct super_block *s)</span>
 }
 
 /* Filesystem error... */
<span class="p_del">-static char err_buf[1024];</span>
<span class="p_del">-</span>
 void hpfs_error(struct super_block *s, const char *fmt, ...)
 {
<span class="p_add">+	struct va_format vaf;</span>
 	va_list args;
 
 	va_start(args, fmt);
<span class="p_del">-	vsnprintf(err_buf, sizeof(err_buf), fmt, args);</span>
<span class="p_add">+</span>
<span class="p_add">+	vaf.fmt = fmt;</span>
<span class="p_add">+	vaf.va = &amp;args;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_err(&quot;filesystem error: %pV&quot;, &amp;vaf);</span>
<span class="p_add">+</span>
 	va_end(args);
 
<span class="p_del">-	pr_err(&quot;filesystem error: %s&quot;, err_buf);</span>
 	if (!hpfs_sb(s)-&gt;sb_was_error) {
 		if (hpfs_sb(s)-&gt;sb_err == 2) {
 			pr_cont(&quot;; crashing the system because you wanted it\n&quot;);
<span class="p_chunk">@@ -424,11 +427,14 @@</span> <span class="p_context"> static int hpfs_remount_fs(struct super_block *s, int *flags, char *data)</span>
 	int o;
 	struct hpfs_sb_info *sbi = hpfs_sb(s);
 	char *new_opts = kstrdup(data, GFP_KERNEL);
<span class="p_del">-	</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new_opts)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	sync_filesystem(s);
 
 	*flags |= MS_NOATIME;
<span class="p_del">-	</span>
<span class="p_add">+</span>
 	hpfs_lock(s);
 	uid = sbi-&gt;sb_uid; gid = sbi-&gt;sb_gid;
 	umask = 0777 &amp; ~sbi-&gt;sb_mode;
<span class="p_header">diff --git a/fs/jbd2/checkpoint.c b/fs/jbd2/checkpoint.c</span>
<span class="p_header">index 988b32ed4c87..4227dc4f7437 100644</span>
<span class="p_header">--- a/fs/jbd2/checkpoint.c</span>
<span class="p_header">+++ b/fs/jbd2/checkpoint.c</span>
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	unsigned long	blocknr;
 
 	if (is_journal_aborted(journal))
<span class="p_del">-		return 1;</span>
<span class="p_add">+		return -EIO;</span>
 
 	if (!jbd2_journal_get_log_tail(journal, &amp;first_tid, &amp;blocknr))
 		return 1;
<span class="p_chunk">@@ -405,10 +405,9 @@</span> <span class="p_context"> int jbd2_cleanup_journal_tail(journal_t *journal)</span>
 	 * jbd2_cleanup_journal_tail() doesn&#39;t get called all that often.
 	 */
 	if (journal-&gt;j_flags &amp; JBD2_BARRIER)
<span class="p_del">-		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_KERNEL, NULL);</span>
<span class="p_add">+		blkdev_issue_flush(journal-&gt;j_fs_dev, GFP_NOFS, NULL);</span>
 
<span class="p_del">-	__jbd2_update_log_tail(journal, first_tid, blocknr);</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return __jbd2_update_log_tail(journal, first_tid, blocknr);</span>
 }
 
 
<span class="p_header">diff --git a/fs/jbd2/journal.c b/fs/jbd2/journal.c</span>
<span class="p_header">index b96bd8076b70..112fad9e1e20 100644</span>
<span class="p_header">--- a/fs/jbd2/journal.c</span>
<span class="p_header">+++ b/fs/jbd2/journal.c</span>
<span class="p_chunk">@@ -885,9 +885,10 @@</span> <span class="p_context"> int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,</span>
  *
  * Requires j_checkpoint_mutex
  */
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 {
 	unsigned long freed;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 
<span class="p_chunk">@@ -897,7 +898,10 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	 * space and if we lose sb update during power failure we&#39;d replay
 	 * old transaction with possibly newly overwritten data.
 	 */
<span class="p_del">-	jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	ret = jbd2_journal_update_sb_log_tail(journal, tid, block, WRITE_FUA);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	write_lock(&amp;journal-&gt;j_state_lock);
 	freed = block - journal-&gt;j_tail;
 	if (block &lt; journal-&gt;j_tail)
<span class="p_chunk">@@ -913,6 +917,9 @@</span> <span class="p_context"> void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block)</span>
 	journal-&gt;j_tail_sequence = tid;
 	journal-&gt;j_tail = block;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_chunk">@@ -1331,7 +1338,7 @@</span> <span class="p_context"> static int journal_reset(journal_t *journal)</span>
 	return jbd2_journal_start_thread(journal);
 }
 
<span class="p_del">-static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
<span class="p_add">+static int jbd2_write_superblock(journal_t *journal, int write_op)</span>
 {
 	struct buffer_head *bh = journal-&gt;j_sb_buffer;
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_chunk">@@ -1370,7 +1377,10 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
 		printk(KERN_ERR &quot;JBD2: Error %d detected when updating &quot;
 		       &quot;journal superblock for %s.\n&quot;, ret,
 		       journal-&gt;j_devname);
<span class="p_add">+		jbd2_journal_abort(journal, ret);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1383,10 +1393,11 @@</span> <span class="p_context"> static void jbd2_write_superblock(journal_t *journal, int write_op)</span>
  * Update a journal&#39;s superblock information about log tail and write it to
  * disk, waiting for the IO to complete.
  */
<span class="p_del">-void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
<span class="p_add">+int jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 				     unsigned long tail_block, int write_op)
 {
 	journal_superblock_t *sb = journal-&gt;j_superblock;
<span class="p_add">+	int ret;</span>
 
 	BUG_ON(!mutex_is_locked(&amp;journal-&gt;j_checkpoint_mutex));
 	jbd_debug(1, &quot;JBD2: updating superblock (start %lu, seq %u)\n&quot;,
<span class="p_chunk">@@ -1395,13 +1406,18 @@</span> <span class="p_context"> void jbd2_journal_update_sb_log_tail(journal_t *journal, tid_t tail_tid,</span>
 	sb-&gt;s_sequence = cpu_to_be32(tail_tid);
 	sb-&gt;s_start    = cpu_to_be32(tail_block);
 
<span class="p_del">-	jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	ret = jbd2_write_superblock(journal, write_op);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 
 	/* Log is no longer empty */
 	write_lock(&amp;journal-&gt;j_state_lock);
 	WARN_ON(!sb-&gt;s_sequence);
 	journal-&gt;j_flags &amp;= ~JBD2_FLUSHED;
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return ret;</span>
 }
 
 /**
<span class="p_chunk">@@ -1950,7 +1966,14 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 		return -EIO;
 
 	mutex_lock(&amp;journal-&gt;j_checkpoint_mutex);
<span class="p_del">-	jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		err = jbd2_cleanup_journal_tail(journal);</span>
<span class="p_add">+		if (err &lt; 0) {</span>
<span class="p_add">+			mutex_unlock(&amp;journal-&gt;j_checkpoint_mutex);</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+	}</span>
 
 	/* Finally, mark the journal as really needing no recovery.
 	 * This sets s_start==0 in the underlying superblock, which is
<span class="p_chunk">@@ -1966,7 +1989,8 @@</span> <span class="p_context"> int jbd2_journal_flush(journal_t *journal)</span>
 	J_ASSERT(journal-&gt;j_head == journal-&gt;j_tail);
 	J_ASSERT(journal-&gt;j_tail_sequence == journal-&gt;j_transaction_sequence);
 	write_unlock(&amp;journal-&gt;j_state_lock);
<span class="p_del">-	return 0;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return err;</span>
 }
 
 /**
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayout.c b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">index 7d05089e52d6..6f5f0f425e86 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayout.c</span>
<span class="p_chunk">@@ -631,7 +631,7 @@</span> <span class="p_context"> static void ff_layout_reset_write(struct nfs_pgio_header *hdr, bool retry_pnfs)</span>
 			nfs_direct_set_resched_writes(hdr-&gt;dreq);
 			/* fake unstable write to let common nfs resend pages */
 			hdr-&gt;verf.committed = NFS_UNSTABLE;
<span class="p_del">-			hdr-&gt;good_bytes = 0;</span>
<span class="p_add">+			hdr-&gt;good_bytes = hdr-&gt;args.count;</span>
 		}
 		return;
 	}
<span class="p_header">diff --git a/fs/nfs/flexfilelayout/flexfilelayoutdev.c b/fs/nfs/flexfilelayout/flexfilelayoutdev.c</span>
<span class="p_header">index 77a2d026aa12..f13e1969eedd 100644</span>
<span class="p_header">--- a/fs/nfs/flexfilelayout/flexfilelayoutdev.c</span>
<span class="p_header">+++ b/fs/nfs/flexfilelayout/flexfilelayoutdev.c</span>
<span class="p_chunk">@@ -324,7 +324,8 @@</span> <span class="p_context"> static int ff_layout_update_mirror_cred(struct nfs4_ff_layout_mirror *mirror,</span>
 				__func__, PTR_ERR(cred));
 			return PTR_ERR(cred);
 		} else {
<span class="p_del">-			mirror-&gt;cred = cred;</span>
<span class="p_add">+			if (cmpxchg(&amp;mirror-&gt;cred, NULL, cred))</span>
<span class="p_add">+				put_rpccred(cred);</span>
 		}
 	}
 	return 0;
<span class="p_chunk">@@ -386,7 +387,7 @@</span> <span class="p_context"> nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,</span>
 	/* matching smp_wmb() in _nfs4_pnfs_v3/4_ds_connect */
 	smp_rmb();
 	if (ds-&gt;ds_clp)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto out_update_creds;</span>
 
 	flavor = nfs4_ff_layout_choose_authflavor(mirror);
 
<span class="p_chunk">@@ -430,7 +431,7 @@</span> <span class="p_context"> nfs4_ff_layout_prepare_ds(struct pnfs_layout_segment *lseg, u32 ds_idx,</span>
 			}
 		}
 	}
<span class="p_del">-</span>
<span class="p_add">+out_update_creds:</span>
 	if (ff_layout_update_mirror_cred(mirror, ds))
 		ds = NULL;
 out:
<span class="p_header">diff --git a/fs/nfs/nfs3xdr.c b/fs/nfs/nfs3xdr.c</span>
<span class="p_header">index 53852a4bd88b..9b04c2e6fffc 100644</span>
<span class="p_header">--- a/fs/nfs/nfs3xdr.c</span>
<span class="p_header">+++ b/fs/nfs/nfs3xdr.c</span>
<span class="p_chunk">@@ -1342,7 +1342,7 @@</span> <span class="p_context"> static void nfs3_xdr_enc_setacl3args(struct rpc_rqst *req,</span>
 	if (args-&gt;npages != 0)
 		xdr_write_pages(xdr, args-&gt;pages, 0, args-&gt;len);
 	else
<span class="p_del">-		xdr_reserve_space(xdr, NFS_ACL_INLINE_BUFSIZE);</span>
<span class="p_add">+		xdr_reserve_space(xdr, args-&gt;len);</span>
 
 	error = nfsacl_encode(xdr-&gt;buf, base, args-&gt;inode,
 			    (args-&gt;mask &amp; NFS_ACL) ?
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index 2782cfca2265..ddef1dc80cf7 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1482,6 +1482,8 @@</span> <span class="p_context"> restart:</span>
 					spin_unlock(&amp;state-&gt;state_lock);
 				}
 				nfs4_put_open_state(state);
<span class="p_add">+				clear_bit(NFS4CLNT_RECLAIM_NOGRACE,</span>
<span class="p_add">+					&amp;state-&gt;flags);</span>
 				spin_lock(&amp;sp-&gt;so_lock);
 				goto restart;
 			}
<span class="p_header">diff --git a/fs/nfs/pnfs.c b/fs/nfs/pnfs.c</span>
<span class="p_header">index 230606243be6..d47c188682b1 100644</span>
<span class="p_header">--- a/fs/nfs/pnfs.c</span>
<span class="p_header">+++ b/fs/nfs/pnfs.c</span>
<span class="p_chunk">@@ -1821,6 +1821,7 @@</span> <span class="p_context"> int pnfs_write_done_resend_to_mds(struct nfs_pgio_header *hdr)</span>
 	/* Resend all requests through the MDS */
 	nfs_pageio_init_write(&amp;pgio, hdr-&gt;inode, FLUSH_STABLE, true,
 			      hdr-&gt;completion_ops);
<span class="p_add">+	set_bit(NFS_CONTEXT_RESEND_WRITES, &amp;hdr-&gt;args.context-&gt;flags);</span>
 	return nfs_pageio_resend(&amp;pgio, hdr);
 }
 EXPORT_SYMBOL_GPL(pnfs_write_done_resend_to_mds);
<span class="p_chunk">@@ -1865,6 +1866,7 @@</span> <span class="p_context"> pnfs_write_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		mirror-&gt;pg_recoalesce = 1;
 	}
 	nfs_pgio_data_destroy(hdr);
<span class="p_add">+	hdr-&gt;release(hdr);</span>
 }
 
 static enum pnfs_try_status
<span class="p_chunk">@@ -1979,6 +1981,7 @@</span> <span class="p_context"> pnfs_read_through_mds(struct nfs_pageio_descriptor *desc,</span>
 		mirror-&gt;pg_recoalesce = 1;
 	}
 	nfs_pgio_data_destroy(hdr);
<span class="p_add">+	hdr-&gt;release(hdr);</span>
 }
 
 /*
<span class="p_header">diff --git a/fs/nfs/write.c b/fs/nfs/write.c</span>
<span class="p_header">index dfc19f1575a1..daf355642845 100644</span>
<span class="p_header">--- a/fs/nfs/write.c</span>
<span class="p_header">+++ b/fs/nfs/write.c</span>
<span class="p_chunk">@@ -1289,6 +1289,7 @@</span> <span class="p_context"> static void nfs_initiate_write(struct nfs_pgio_header *hdr,</span>
 static void nfs_redirty_request(struct nfs_page *req)
 {
 	nfs_mark_request_dirty(req);
<span class="p_add">+	set_bit(NFS_CONTEXT_RESEND_WRITES, &amp;req-&gt;wb_context-&gt;flags);</span>
 	nfs_unlock_request(req);
 	nfs_end_page_writeback(req);
 	nfs_release_request(req);
<span class="p_header">diff --git a/fs/overlayfs/readdir.c b/fs/overlayfs/readdir.c</span>
<span class="p_header">index 907870e81a72..70e9af551600 100644</span>
<span class="p_header">--- a/fs/overlayfs/readdir.c</span>
<span class="p_header">+++ b/fs/overlayfs/readdir.c</span>
<span class="p_chunk">@@ -23,6 +23,7 @@</span> <span class="p_context"> struct ovl_cache_entry {</span>
 	u64 ino;
 	struct list_head l_node;
 	struct rb_node node;
<span class="p_add">+	struct ovl_cache_entry *next_maybe_whiteout;</span>
 	bool is_whiteout;
 	char name[];
 };
<span class="p_chunk">@@ -39,7 +40,7 @@</span> <span class="p_context"> struct ovl_readdir_data {</span>
 	struct rb_root root;
 	struct list_head *list;
 	struct list_head middle;
<span class="p_del">-	struct dentry *dir;</span>
<span class="p_add">+	struct ovl_cache_entry *first_maybe_whiteout;</span>
 	int count;
 	int err;
 };
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> static struct ovl_cache_entry *ovl_cache_entry_find(struct rb_root *root,</span>
 	return NULL;
 }
 
<span class="p_del">-static struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,</span>
<span class="p_add">+static struct ovl_cache_entry *ovl_cache_entry_new(struct ovl_readdir_data *rdd,</span>
 						   const char *name, int len,
 						   u64 ino, unsigned int d_type)
 {
<span class="p_chunk">@@ -98,29 +99,8 @@</span> <span class="p_context"> static struct ovl_cache_entry *ovl_cache_entry_new(struct dentry *dir,</span>
 	p-&gt;is_whiteout = false;
 
 	if (d_type == DT_CHR) {
<span class="p_del">-		struct dentry *dentry;</span>
<span class="p_del">-		const struct cred *old_cred;</span>
<span class="p_del">-		struct cred *override_cred;</span>
<span class="p_del">-</span>
<span class="p_del">-		override_cred = prepare_creds();</span>
<span class="p_del">-		if (!override_cred) {</span>
<span class="p_del">-			kfree(p);</span>
<span class="p_del">-			return NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * CAP_DAC_OVERRIDE for lookup</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		cap_raise(override_cred-&gt;cap_effective, CAP_DAC_OVERRIDE);</span>
<span class="p_del">-		old_cred = override_creds(override_cred);</span>
<span class="p_del">-</span>
<span class="p_del">-		dentry = lookup_one_len(name, dir, len);</span>
<span class="p_del">-		if (!IS_ERR(dentry)) {</span>
<span class="p_del">-			p-&gt;is_whiteout = ovl_is_whiteout(dentry);</span>
<span class="p_del">-			dput(dentry);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		revert_creds(old_cred);</span>
<span class="p_del">-		put_cred(override_cred);</span>
<span class="p_add">+		p-&gt;next_maybe_whiteout = rdd-&gt;first_maybe_whiteout;</span>
<span class="p_add">+		rdd-&gt;first_maybe_whiteout = p;</span>
 	}
 	return p;
 }
<span class="p_chunk">@@ -148,7 +128,7 @@</span> <span class="p_context"> static int ovl_cache_entry_add_rb(struct ovl_readdir_data *rdd,</span>
 			return 0;
 	}
 
<span class="p_del">-	p = ovl_cache_entry_new(rdd-&gt;dir, name, len, ino, d_type);</span>
<span class="p_add">+	p = ovl_cache_entry_new(rdd, name, len, ino, d_type);</span>
 	if (p == NULL)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -169,7 +149,7 @@</span> <span class="p_context"> static int ovl_fill_lower(struct ovl_readdir_data *rdd,</span>
 	if (p) {
 		list_move_tail(&amp;p-&gt;l_node, &amp;rdd-&gt;middle);
 	} else {
<span class="p_del">-		p = ovl_cache_entry_new(rdd-&gt;dir, name, namelen, ino, d_type);</span>
<span class="p_add">+		p = ovl_cache_entry_new(rdd, name, namelen, ino, d_type);</span>
 		if (p == NULL)
 			rdd-&gt;err = -ENOMEM;
 		else
<span class="p_chunk">@@ -219,6 +199,43 @@</span> <span class="p_context"> static int ovl_fill_merge(struct dir_context *ctx, const char *name,</span>
 		return ovl_fill_lower(rdd, name, namelen, offset, ino, d_type);
 }
 
<span class="p_add">+static int ovl_check_whiteouts(struct dentry *dir, struct ovl_readdir_data *rdd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	struct ovl_cache_entry *p;</span>
<span class="p_add">+	struct dentry *dentry;</span>
<span class="p_add">+	const struct cred *old_cred;</span>
<span class="p_add">+	struct cred *override_cred;</span>
<span class="p_add">+</span>
<span class="p_add">+	override_cred = prepare_creds();</span>
<span class="p_add">+	if (!override_cred)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * CAP_DAC_OVERRIDE for lookup</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cap_raise(override_cred-&gt;cap_effective, CAP_DAC_OVERRIDE);</span>
<span class="p_add">+	old_cred = override_creds(override_cred);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = mutex_lock_killable(&amp;dir-&gt;d_inode-&gt;i_mutex);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		while (rdd-&gt;first_maybe_whiteout) {</span>
<span class="p_add">+			p = rdd-&gt;first_maybe_whiteout;</span>
<span class="p_add">+			rdd-&gt;first_maybe_whiteout = p-&gt;next_maybe_whiteout;</span>
<span class="p_add">+			dentry = lookup_one_len(p-&gt;name, dir, p-&gt;len);</span>
<span class="p_add">+			if (!IS_ERR(dentry)) {</span>
<span class="p_add">+				p-&gt;is_whiteout = ovl_is_whiteout(dentry);</span>
<span class="p_add">+				dput(dentry);</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+		mutex_unlock(&amp;dir-&gt;d_inode-&gt;i_mutex);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	revert_creds(old_cred);</span>
<span class="p_add">+	put_cred(override_cred);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int ovl_dir_read(struct path *realpath,
 			       struct ovl_readdir_data *rdd)
 {
<span class="p_chunk">@@ -229,7 +246,7 @@</span> <span class="p_context"> static inline int ovl_dir_read(struct path *realpath,</span>
 	if (IS_ERR(realfile))
 		return PTR_ERR(realfile);
 
<span class="p_del">-	rdd-&gt;dir = realpath-&gt;dentry;</span>
<span class="p_add">+	rdd-&gt;first_maybe_whiteout = NULL;</span>
 	rdd-&gt;ctx.pos = 0;
 	do {
 		rdd-&gt;count = 0;
<span class="p_chunk">@@ -238,6 +255,10 @@</span> <span class="p_context"> static inline int ovl_dir_read(struct path *realpath,</span>
 		if (err &gt;= 0)
 			err = rdd-&gt;err;
 	} while (!err &amp;&amp; rdd-&gt;count);
<span class="p_add">+</span>
<span class="p_add">+	if (!err &amp;&amp; rdd-&gt;first_maybe_whiteout)</span>
<span class="p_add">+		err = ovl_check_whiteouts(realpath-&gt;dentry, rdd);</span>
<span class="p_add">+</span>
 	fput(realfile);
 
 	return err;
<span class="p_header">diff --git a/fs/xfs/xfs_attr_inactive.c b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">index 3fbf167cfb4c..73e75a87af50 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_attr_inactive.c</span>
<span class="p_chunk">@@ -435,8 +435,14 @@</span> <span class="p_context"> xfs_attr_inactive(</span>
 	 */
 	xfs_trans_ijoin(trans, dp, 0);
 
<span class="p_del">-	/* invalidate and truncate the attribute fork extents */</span>
<span class="p_del">-	if (dp-&gt;i_d.di_aformat != XFS_DINODE_FMT_LOCAL) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Invalidate and truncate the attribute fork extents. Make sure the</span>
<span class="p_add">+	 * fork actually has attributes as otherwise the invalidation has no</span>
<span class="p_add">+	 * blocks to read and returns an error. In this case, just do the fork</span>
<span class="p_add">+	 * removal below.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (xfs_inode_hasattr(dp) &amp;&amp;</span>
<span class="p_add">+	    dp-&gt;i_d.di_aformat != XFS_DINODE_FMT_LOCAL) {</span>
 		error = xfs_attr3_root_inactive(&amp;trans, dp);
 		if (error)
 			goto out_cancel;
<span class="p_header">diff --git a/fs/xfs/xfs_symlink.c b/fs/xfs/xfs_symlink.c</span>
<span class="p_header">index 3df411eadb86..40c076523cfa 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_symlink.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_symlink.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"> xfs_readlink_bmap(</span>
 			cur_chunk += sizeof(struct xfs_dsymlink_hdr);
 		}
 
<span class="p_del">-		memcpy(link + offset, bp-&gt;b_addr, byte_cnt);</span>
<span class="p_add">+		memcpy(link + offset, cur_chunk, byte_cnt);</span>
 
 		pathlen -= byte_cnt;
 		offset += byte_cnt;
<span class="p_header">diff --git a/include/acpi/acpixf.h b/include/acpi/acpixf.h</span>
<span class="p_header">index 08ef57bc8d63..f5ed1f17f061 100644</span>
<span class="p_header">--- a/include/acpi/acpixf.h</span>
<span class="p_header">+++ b/include/acpi/acpixf.h</span>
<span class="p_chunk">@@ -195,9 +195,18 @@</span> <span class="p_context"> ACPI_INIT_GLOBAL(u8, acpi_gbl_do_not_use_xsdt, FALSE);</span>
  * address. Although ACPICA adheres to the ACPI specification which
  * requires the use of the corresponding 64-bit address if it is non-zero,
  * some machines have been found to have a corrupted non-zero 64-bit
<span class="p_del">- * address. Default is TRUE, favor the 32-bit addresses.</span>
<span class="p_add">+ * address. Default is FALSE, do not favor the 32-bit addresses.</span>
  */
<span class="p_del">-ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_fadt_addresses, TRUE);</span>
<span class="p_add">+ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_fadt_addresses, FALSE);</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Optionally use 32-bit FACS table addresses.</span>
<span class="p_add">+ * It is reported that some platforms fail to resume from system suspending</span>
<span class="p_add">+ * if 64-bit FACS table address is selected:</span>
<span class="p_add">+ * https://bugzilla.kernel.org/show_bug.cgi?id=74021</span>
<span class="p_add">+ * Default is TRUE, favor the 32-bit addresses.</span>
<span class="p_add">+ */</span>
<span class="p_add">+ACPI_INIT_GLOBAL(u8, acpi_gbl_use32_bit_facs_addresses, TRUE);</span>
 
 /*
  * Optionally truncate I/O addresses to 16 bits. Provides compatibility
<span class="p_header">diff --git a/include/acpi/actypes.h b/include/acpi/actypes.h</span>
<span class="p_header">index 1c3002e1db20..181427ef3549 100644</span>
<span class="p_header">--- a/include/acpi/actypes.h</span>
<span class="p_header">+++ b/include/acpi/actypes.h</span>
<span class="p_chunk">@@ -572,6 +572,7 @@</span> <span class="p_context"> typedef u64 acpi_integer;</span>
 #define ACPI_NO_ACPI_ENABLE             0x10
 #define ACPI_NO_DEVICE_INIT             0x20
 #define ACPI_NO_OBJECT_INIT             0x40
<span class="p_add">+#define ACPI_NO_FACS_INIT               0x80</span>
 
 /*
  * Initialization state
<span class="p_header">diff --git a/include/drm/drm_atomic.h b/include/drm/drm_atomic.h</span>
<span class="p_header">index c157103492b0..3f13b910f8d2 100644</span>
<span class="p_header">--- a/include/drm/drm_atomic.h</span>
<span class="p_header">+++ b/include/drm/drm_atomic.h</span>
<span class="p_chunk">@@ -77,26 +77,26 @@</span> <span class="p_context"> int __must_check drm_atomic_async_commit(struct drm_atomic_state *state);</span>
 
 #define for_each_connector_in_state(state, connector, connector_state, __i) \
 	for ((__i) = 0;							\
<span class="p_del">-	     (connector) = (state)-&gt;connectors[__i],			\</span>
<span class="p_del">-	     (connector_state) = (state)-&gt;connector_states[__i],	\</span>
<span class="p_del">-	     (__i) &lt; (state)-&gt;num_connector;				\</span>
<span class="p_add">+	     (__i) &lt; (state)-&gt;num_connector &amp;&amp;				\</span>
<span class="p_add">+	     ((connector) = (state)-&gt;connectors[__i],			\</span>
<span class="p_add">+	     (connector_state) = (state)-&gt;connector_states[__i], 1); 	\</span>
 	     (__i)++)							\
 		if (connector)
 
 #define for_each_crtc_in_state(state, crtc, crtc_state, __i)	\
 	for ((__i) = 0;						\
<span class="p_del">-	     (crtc) = (state)-&gt;crtcs[__i],			\</span>
<span class="p_del">-	     (crtc_state) = (state)-&gt;crtc_states[__i],		\</span>
<span class="p_del">-	     (__i) &lt; (state)-&gt;dev-&gt;mode_config.num_crtc;	\</span>
<span class="p_add">+	     (__i) &lt; (state)-&gt;dev-&gt;mode_config.num_crtc &amp;&amp;	\</span>
<span class="p_add">+	     ((crtc) = (state)-&gt;crtcs[__i],			\</span>
<span class="p_add">+	     (crtc_state) = (state)-&gt;crtc_states[__i], 1);	\</span>
 	     (__i)++)						\
 		if (crtc_state)
 
<span class="p_del">-#define for_each_plane_in_state(state, plane, plane_state, __i)	\</span>
<span class="p_del">-	for ((__i) = 0;						\</span>
<span class="p_del">-	     (plane) = (state)-&gt;planes[__i],			\</span>
<span class="p_del">-	     (plane_state) = (state)-&gt;plane_states[__i],	\</span>
<span class="p_del">-	     (__i) &lt; (state)-&gt;dev-&gt;mode_config.num_total_plane;	\</span>
<span class="p_del">-	     (__i)++)						\</span>
<span class="p_add">+#define for_each_plane_in_state(state, plane, plane_state, __i)		\</span>
<span class="p_add">+	for ((__i) = 0;							\</span>
<span class="p_add">+	     (__i) &lt; (state)-&gt;dev-&gt;mode_config.num_total_plane &amp;&amp;	\</span>
<span class="p_add">+	     ((plane) = (state)-&gt;planes[__i],				\</span>
<span class="p_add">+	     (plane_state) = (state)-&gt;plane_states[__i], 1);		\</span>
<span class="p_add">+	     (__i)++)							\</span>
 		if (plane_state)
 
 #endif /* DRM_ATOMIC_H_ */
<span class="p_header">diff --git a/include/drm/drm_crtc.h b/include/drm/drm_crtc.h</span>
<span class="p_header">index ca71c03143d1..54233583c6cb 100644</span>
<span class="p_header">--- a/include/drm/drm_crtc.h</span>
<span class="p_header">+++ b/include/drm/drm_crtc.h</span>
<span class="p_chunk">@@ -731,6 +731,8 @@</span> <span class="p_context"> struct drm_connector {</span>
 	uint8_t num_h_tile, num_v_tile;
 	uint8_t tile_h_loc, tile_v_loc;
 	uint16_t tile_h_size, tile_v_size;
<span class="p_add">+</span>
<span class="p_add">+	struct list_head destroy_list;</span>
 };
 
 /**
<span class="p_header">diff --git a/include/drm/drm_dp_mst_helper.h b/include/drm/drm_dp_mst_helper.h</span>
<span class="p_header">index a2507817be41..86d0b25ed054 100644</span>
<span class="p_header">--- a/include/drm/drm_dp_mst_helper.h</span>
<span class="p_header">+++ b/include/drm/drm_dp_mst_helper.h</span>
<span class="p_chunk">@@ -463,6 +463,10 @@</span> <span class="p_context"> struct drm_dp_mst_topology_mgr {</span>
 	struct work_struct work;
 
 	struct work_struct tx_work;
<span class="p_add">+</span>
<span class="p_add">+	struct list_head destroy_connector_list;</span>
<span class="p_add">+	struct mutex destroy_connector_lock;</span>
<span class="p_add">+	struct work_struct destroy_connector_work;</span>
 };
 
 int drm_dp_mst_topology_mgr_init(struct drm_dp_mst_topology_mgr *mgr, struct device *dev, struct drm_dp_aux *aux, int max_dpcd_transaction_bytes, int max_payloads, int conn_base_id);
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index 5da2d2e9d38e..4550be3bb63b 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -332,9 +332,6 @@</span> <span class="p_context"> int acpi_check_region(resource_size_t start, resource_size_t n,</span>
 
 int acpi_resources_are_enforced(void);
 
<span class="p_del">-int acpi_reserve_region(u64 start, unsigned int length, u8 space_id,</span>
<span class="p_del">-			unsigned long flags, char *desc);</span>
<span class="p_del">-</span>
 #ifdef CONFIG_HIBERNATION
 void __init acpi_no_s4_hw_signature(void);
 #endif
<span class="p_chunk">@@ -530,13 +527,6 @@</span> <span class="p_context"> static inline int acpi_check_region(resource_size_t start, resource_size_t n,</span>
 	return 0;
 }
 
<span class="p_del">-static inline int acpi_reserve_region(u64 start, unsigned int length,</span>
<span class="p_del">-				      u8 space_id, unsigned long flags,</span>
<span class="p_del">-				      char *desc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return -ENXIO;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 struct acpi_table_header;
 static inline int acpi_table_parse(char *id,
 				int (*handler)(struct acpi_table_header *))
<span class="p_header">diff --git a/include/linux/ata.h b/include/linux/ata.h</span>
<span class="p_header">index b666b773e111..533dbb6428f5 100644</span>
<span class="p_header">--- a/include/linux/ata.h</span>
<span class="p_header">+++ b/include/linux/ata.h</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_SECT_SIZE		= 512,
 	ATA_MAX_SECTORS_128	= 128,
 	ATA_MAX_SECTORS		= 256,
<span class="p_add">+	ATA_MAX_SECTORS_1024    = 1024,</span>
 	ATA_MAX_SECTORS_LBA48	= 65535,/* TODO: 65536? */
 	ATA_MAX_SECTORS_TAPE	= 65535,
 
<span class="p_header">diff --git a/include/linux/buffer_head.h b/include/linux/buffer_head.h</span>
<span class="p_header">index 73b45225a7ca..e6797ded700e 100644</span>
<span class="p_header">--- a/include/linux/buffer_head.h</span>
<span class="p_header">+++ b/include/linux/buffer_head.h</span>
<span class="p_chunk">@@ -317,6 +317,13 @@</span> <span class="p_context"> sb_getblk(struct super_block *sb, sector_t block)</span>
 	return __getblk_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, __GFP_MOVABLE);
 }
 
<span class="p_add">+</span>
<span class="p_add">+static inline struct buffer_head *</span>
<span class="p_add">+sb_getblk_gfp(struct super_block *sb, sector_t block, gfp_t gfp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __getblk_gfp(sb-&gt;s_bdev, block, sb-&gt;s_blocksize, gfp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline struct buffer_head *
 sb_find_get_block(struct super_block *sb, sector_t block)
 {
<span class="p_header">diff --git a/include/linux/compiler-intel.h b/include/linux/compiler-intel.h</span>
<span class="p_header">index 0c9a2f2c2802..d4c71132d07f 100644</span>
<span class="p_header">--- a/include/linux/compiler-intel.h</span>
<span class="p_header">+++ b/include/linux/compiler-intel.h</span>
<span class="p_chunk">@@ -13,10 +13,12 @@</span> <span class="p_context"></span>
 /* Intel ECC compiler doesn&#39;t support gcc specific asm stmts.
  * It uses intrinsics to do the equivalent things.
  */
<span class="p_add">+#undef barrier</span>
 #undef barrier_data
 #undef RELOC_HIDE
 #undef OPTIMIZER_HIDE_VAR
 
<span class="p_add">+#define barrier() __memory_barrier()</span>
 #define barrier_data(ptr) barrier()
 
 #define RELOC_HIDE(ptr, off)					\
<span class="p_header">diff --git a/include/linux/gpio/consumer.h b/include/linux/gpio/consumer.h</span>
<span class="p_header">index 3a7c9ffd5ab9..da042657dc31 100644</span>
<span class="p_header">--- a/include/linux/gpio/consumer.h</span>
<span class="p_header">+++ b/include/linux/gpio/consumer.h</span>
<span class="p_chunk">@@ -406,6 +406,21 @@</span> <span class="p_context"> static inline int desc_to_gpio(const struct gpio_desc *desc)</span>
 	return -EINVAL;
 }
 
<span class="p_add">+/* Child properties interface */</span>
<span class="p_add">+struct fwnode_handle;</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct gpio_desc *fwnode_get_named_gpiod(</span>
<span class="p_add">+	struct fwnode_handle *fwnode, const char *propname)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ERR_PTR(-ENOSYS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline struct gpio_desc *devm_get_gpiod_from_child(</span>
<span class="p_add">+	struct device *dev, const char *con_id, struct fwnode_handle *child)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return ERR_PTR(-ENOSYS);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* CONFIG_GPIOLIB */
 
 /*
<span class="p_header">diff --git a/include/linux/hid-sensor-hub.h b/include/linux/hid-sensor-hub.h</span>
<span class="p_header">index 0042bf330b99..c02b5ce6c5cd 100644</span>
<span class="p_header">--- a/include/linux/hid-sensor-hub.h</span>
<span class="p_header">+++ b/include/linux/hid-sensor-hub.h</span>
<span class="p_chunk">@@ -230,6 +230,7 @@</span> <span class="p_context"> struct hid_sensor_common {</span>
 	struct platform_device *pdev;
 	unsigned usage_id;
 	atomic_t data_ready;
<span class="p_add">+	atomic_t user_requested_state;</span>
 	struct iio_trigger *trigger;
 	struct hid_sensor_hub_attribute_info poll;
 	struct hid_sensor_hub_attribute_info report_state;
<span class="p_header">diff --git a/include/linux/jbd2.h b/include/linux/jbd2.h</span>
<span class="p_header">index 20e7f78041c8..edb640ae9a94 100644</span>
<span class="p_header">--- a/include/linux/jbd2.h</span>
<span class="p_header">+++ b/include/linux/jbd2.h</span>
<span class="p_chunk">@@ -1035,7 +1035,7 @@</span> <span class="p_context"> struct buffer_head *jbd2_journal_get_descriptor_buffer(journal_t *journal);</span>
 int jbd2_journal_next_log_block(journal_t *, unsigned long long *);
 int jbd2_journal_get_log_tail(journal_t *journal, tid_t *tid,
 			      unsigned long *block);
<span class="p_del">-void __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
<span class="p_add">+int __jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);</span>
 void jbd2_update_log_tail(journal_t *journal, tid_t tid, unsigned long block);
 
 /* Commit management */
<span class="p_chunk">@@ -1157,7 +1157,7 @@</span> <span class="p_context"> extern int	   jbd2_journal_recover    (journal_t *journal);</span>
 extern int	   jbd2_journal_wipe       (journal_t *, int);
 extern int	   jbd2_journal_skip_recovery	(journal_t *);
 extern void	   jbd2_journal_update_sb_errno(journal_t *);
<span class="p_del">-extern void	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
<span class="p_add">+extern int	   jbd2_journal_update_sb_log_tail	(journal_t *, tid_t,</span>
 				unsigned long, int);
 extern void	   __jbd2_journal_abort_hard	(journal_t *);
 extern void	   jbd2_journal_abort      (journal_t *, int);
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 28aeae46f355..e0e33787c485 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -431,6 +431,9 @@</span> <span class="p_context"> enum {</span>
 	ATA_HORKAGE_NOLPM	= (1 &lt;&lt; 20),	/* don&#39;t use LPM */
 	ATA_HORKAGE_WD_BROKEN_LPM = (1 &lt;&lt; 21),	/* some WDs have broken LPM */
 	ATA_HORKAGE_ZERO_AFTER_TRIM = (1 &lt;&lt; 22),/* guarantees zero after trim */
<span class="p_add">+	ATA_HORKAGE_NO_NCQ_LOG	= (1 &lt;&lt; 23),	/* don&#39;t use NCQ for log read */</span>
<span class="p_add">+	ATA_HORKAGE_NOTRIM	= (1 &lt;&lt; 24),	/* don&#39;t use TRIM */</span>
<span class="p_add">+	ATA_HORKAGE_MAX_SEC_1024 = (1 &lt;&lt; 25),	/* Limit max sects to 1024 */</span>
 
 	 /* DMA mask for user DMA control: User visible values; DO NOT
 	    renumber */
<span class="p_header">diff --git a/include/linux/nfs_xdr.h b/include/linux/nfs_xdr.h</span>
<span class="p_header">index 93ab6071bbe9..e9e9a8dcfb47 100644</span>
<span class="p_header">--- a/include/linux/nfs_xdr.h</span>
<span class="p_header">+++ b/include/linux/nfs_xdr.h</span>
<span class="p_chunk">@@ -1142,7 +1142,7 @@</span> <span class="p_context"> struct nfs41_state_protection {</span>
 	struct nfs4_op_map allow;
 };
 
<span class="p_del">-#define NFS4_EXCHANGE_ID_LEN	(48)</span>
<span class="p_add">+#define NFS4_EXCHANGE_ID_LEN	(127)</span>
 struct nfs41_exchange_id_args {
 	struct nfs_client		*client;
 	nfs4_verifier			*verifier;
<span class="p_header">diff --git a/include/linux/of.h b/include/linux/of.h</span>
<span class="p_header">index b871ff9d81d7..8135d507d089 100644</span>
<span class="p_header">--- a/include/linux/of.h</span>
<span class="p_header">+++ b/include/linux/of.h</span>
<span class="p_chunk">@@ -673,7 +673,10 @@</span> <span class="p_context"> static inline void of_property_clear_flag(struct property *p, unsigned long flag</span>
 #if defined(CONFIG_OF) &amp;&amp; defined(CONFIG_NUMA)
 extern int of_node_to_nid(struct device_node *np);
 #else
<span class="p_del">-static inline int of_node_to_nid(struct device_node *device) { return 0; }</span>
<span class="p_add">+static inline int of_node_to_nid(struct device_node *device)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return NUMA_NO_NODE;</span>
<span class="p_add">+}</span>
 #endif
 
 static inline struct device_node *of_find_matching_node(
<span class="p_header">diff --git a/include/uapi/drm/i915_drm.h b/include/uapi/drm/i915_drm.h</span>
<span class="p_header">index 551b6737f5df..a7e41fb6ed54 100644</span>
<span class="p_header">--- a/include/uapi/drm/i915_drm.h</span>
<span class="p_header">+++ b/include/uapi/drm/i915_drm.h</span>
<span class="p_chunk">@@ -1065,6 +1065,14 @@</span> <span class="p_context"> struct drm_i915_reg_read {</span>
 	__u64 offset;
 	__u64 val; /* Return value */
 };
<span class="p_add">+/* Known registers:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Render engine timestamp - 0x2358 + 64bit - gen7+</span>
<span class="p_add">+ * - Note this register returns an invalid value if using the default</span>
<span class="p_add">+ *   single instruction 8byte read, in order to workaround that use</span>
<span class="p_add">+ *   offset (0x2538 | 1) instead.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ */</span>
 
 struct drm_i915_reset_stats {
 	__u32 ctx_id;
<span class="p_header">diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig</span>
<span class="p_header">index 7e01f78f0417..9e302315e33d 100644</span>
<span class="p_header">--- a/kernel/power/Kconfig</span>
<span class="p_header">+++ b/kernel/power/Kconfig</span>
<span class="p_chunk">@@ -187,7 +187,7 @@</span> <span class="p_context"> config DPM_WATCHDOG</span>
 config DPM_WATCHDOG_TIMEOUT
 	int &quot;Watchdog timeout in seconds&quot;
 	range 1 120
<span class="p_del">-	default 12</span>
<span class="p_add">+	default 60</span>
 	depends on DPM_WATCHDOG
 
 config PM_TRACE
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index c099b082cd02..bff0169e1ad8 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -484,11 +484,11 @@</span> <span class="p_context"> int check_syslog_permissions(int type, bool from_file)</span>
 	 * already done the capabilities checks at open time.
 	 */
 	if (from_file &amp;&amp; type != SYSLOG_ACTION_OPEN)
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto ok;</span>
 
 	if (syslog_action_restricted(type)) {
 		if (capable(CAP_SYSLOG))
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		/*
 		 * For historical reasons, accept CAP_SYS_ADMIN too, with
 		 * a warning.
<span class="p_chunk">@@ -498,10 +498,11 @@</span> <span class="p_context"> int check_syslog_permissions(int type, bool from_file)</span>
 				     &quot;CAP_SYS_ADMIN but no CAP_SYSLOG &quot;
 				     &quot;(deprecated).\n&quot;,
 				 current-&gt;comm, task_pid_nr(current));
<span class="p_del">-			return 0;</span>
<span class="p_add">+			goto ok;</span>
 		}
 		return -EPERM;
 	}
<span class="p_add">+ok:</span>
 	return security_syslog(type);
 }
 
<span class="p_chunk">@@ -1263,10 +1264,6 @@</span> <span class="p_context"> int do_syslog(int type, char __user *buf, int len, bool from_file)</span>
 	if (error)
 		goto out;
 
<span class="p_del">-	error = security_syslog(type);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return error;</span>
<span class="p_del">-</span>
 	switch (type) {
 	case SYSLOG_ACTION_CLOSE:	/* Close log */
 		break;
<span class="p_header">diff --git a/kernel/trace/trace.h b/kernel/trace/trace.h</span>
<span class="p_header">index d2612016de94..921691c5cb04 100644</span>
<span class="p_header">--- a/kernel/trace/trace.h</span>
<span class="p_header">+++ b/kernel/trace/trace.h</span>
<span class="p_chunk">@@ -444,6 +444,7 @@</span> <span class="p_context"> enum {</span>
 
 	TRACE_CONTROL_BIT,
 
<span class="p_add">+	TRACE_BRANCH_BIT,</span>
 /*
  * Abuse of the trace_recursion.
  * As we need a way to maintain state if we are tracing the function
<span class="p_chunk">@@ -1312,7 +1313,7 @@</span> <span class="p_context"> void trace_event_init(void);</span>
 void trace_event_enum_update(struct trace_enum_map **map, int len);
 #else
 static inline void __init trace_event_init(void) { }
<span class="p_del">-static inlin void trace_event_enum_update(struct trace_enum_map **map, int len) { }</span>
<span class="p_add">+static inline void trace_event_enum_update(struct trace_enum_map **map, int len) { }</span>
 #endif
 
 extern struct trace_iterator *tracepoint_print_iter;
<span class="p_header">diff --git a/kernel/trace/trace_branch.c b/kernel/trace/trace_branch.c</span>
<span class="p_header">index 57cbf1efdd44..1879980f06c2 100644</span>
<span class="p_header">--- a/kernel/trace/trace_branch.c</span>
<span class="p_header">+++ b/kernel/trace/trace_branch.c</span>
<span class="p_chunk">@@ -36,9 +36,12 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	struct trace_branch *entry;
 	struct ring_buffer *buffer;
 	unsigned long flags;
<span class="p_del">-	int cpu, pc;</span>
<span class="p_add">+	int pc;</span>
 	const char *p;
 
<span class="p_add">+	if (current-&gt;trace_recursion &amp; TRACE_BRANCH_BIT)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * I would love to save just the ftrace_likely_data pointer, but
 	 * this code can also be used by modules. Ugly things can happen
<span class="p_chunk">@@ -49,10 +52,10 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 	if (unlikely(!tr))
 		return;
 
<span class="p_del">-	local_irq_save(flags);</span>
<span class="p_del">-	cpu = raw_smp_processor_id();</span>
<span class="p_del">-	data = per_cpu_ptr(tr-&gt;trace_buffer.data, cpu);</span>
<span class="p_del">-	if (atomic_inc_return(&amp;data-&gt;disabled) != 1)</span>
<span class="p_add">+	raw_local_irq_save(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion |= TRACE_BRANCH_BIT;</span>
<span class="p_add">+	data = this_cpu_ptr(tr-&gt;trace_buffer.data);</span>
<span class="p_add">+	if (atomic_read(&amp;data-&gt;disabled))</span>
 		goto out;
 
 	pc = preempt_count();
<span class="p_chunk">@@ -81,8 +84,8 @@</span> <span class="p_context"> probe_likely_condition(struct ftrace_branch_data *f, int val, int expect)</span>
 		__buffer_unlock_commit(buffer, event);
 
  out:
<span class="p_del">-	atomic_dec(&amp;data-&gt;disabled);</span>
<span class="p_del">-	local_irq_restore(flags);</span>
<span class="p_add">+	current-&gt;trace_recursion &amp;= ~TRACE_BRANCH_BIT;</span>
<span class="p_add">+	raw_local_irq_restore(flags);</span>
 }
 
 static inline
<span class="p_header">diff --git a/kernel/trace/trace_events_filter.c b/kernel/trace/trace_events_filter.c</span>
<span class="p_header">index 7f2e97ce71a7..52adf02d7619 100644</span>
<span class="p_header">--- a/kernel/trace/trace_events_filter.c</span>
<span class="p_header">+++ b/kernel/trace/trace_events_filter.c</span>
<span class="p_chunk">@@ -1056,6 +1056,9 @@</span> <span class="p_context"> static void parse_init(struct filter_parse_state *ps,</span>
 
 static char infix_next(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 
 	return ps-&gt;infix.string[ps-&gt;infix.tail++];
<span class="p_chunk">@@ -1071,6 +1074,9 @@</span> <span class="p_context"> static char infix_peek(struct filter_parse_state *ps)</span>
 
 static void infix_advance(struct filter_parse_state *ps)
 {
<span class="p_add">+	if (!ps-&gt;infix.cnt)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	ps-&gt;infix.cnt--;
 	ps-&gt;infix.tail++;
 }
<span class="p_chunk">@@ -1385,7 +1391,9 @@</span> <span class="p_context"> static int check_preds(struct filter_parse_state *ps)</span>
 		if (elt-&gt;op != OP_NOT)
 			cnt--;
 		n_normal_preds++;
<span class="p_del">-		WARN_ON_ONCE(cnt &lt; 0);</span>
<span class="p_add">+		/* all ops should have operands */</span>
<span class="p_add">+		if (cnt &lt; 0)</span>
<span class="p_add">+			break;</span>
 	}
 
 	if (cnt != 1 || !n_normal_preds || n_logical_preds &gt;= n_normal_preds) {
<span class="p_header">diff --git a/lib/bitmap.c b/lib/bitmap.c</span>
<span class="p_header">index 64c0926f5dd8..40162f87ea2d 100644</span>
<span class="p_header">--- a/lib/bitmap.c</span>
<span class="p_header">+++ b/lib/bitmap.c</span>
<span class="p_chunk">@@ -506,12 +506,12 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 	unsigned a, b;
 	int c, old_c, totaldigits;
 	const char __user __force *ubuf = (const char __user __force *)buf;
<span class="p_del">-	int exp_digit, in_range;</span>
<span class="p_add">+	int at_start, in_range;</span>
 
 	totaldigits = c = 0;
 	bitmap_zero(maskp, nmaskbits);
 	do {
<span class="p_del">-		exp_digit = 1;</span>
<span class="p_add">+		at_start = 1;</span>
 		in_range = 0;
 		a = b = 0;
 
<span class="p_chunk">@@ -540,11 +540,10 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 				break;
 
 			if (c == &#39;-&#39;) {
<span class="p_del">-				if (exp_digit || in_range)</span>
<span class="p_add">+				if (at_start || in_range)</span>
 					return -EINVAL;
 				b = 0;
 				in_range = 1;
<span class="p_del">-				exp_digit = 1;</span>
 				continue;
 			}
 
<span class="p_chunk">@@ -554,16 +553,18 @@</span> <span class="p_context"> static int __bitmap_parselist(const char *buf, unsigned int buflen,</span>
 			b = b * 10 + (c - &#39;0&#39;);
 			if (!in_range)
 				a = b;
<span class="p_del">-			exp_digit = 0;</span>
<span class="p_add">+			at_start = 0;</span>
 			totaldigits++;
 		}
 		if (!(a &lt;= b))
 			return -EINVAL;
 		if (b &gt;= nmaskbits)
 			return -ERANGE;
<span class="p_del">-		while (a &lt;= b) {</span>
<span class="p_del">-			set_bit(a, maskp);</span>
<span class="p_del">-			a++;</span>
<span class="p_add">+		if (!at_start) {</span>
<span class="p_add">+			while (a &lt;= b) {</span>
<span class="p_add">+				set_bit(a, maskp);</span>
<span class="p_add">+				a++;</span>
<span class="p_add">+			}</span>
 		}
 	} while (buflen &amp;&amp; c == &#39;,&#39;);
 	return 0;
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 271e4432734c..8c4c1f9f9a9a 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -40,6 +40,11 @@</span> <span class="p_context"> int hugepages_treat_as_movable;</span>
 int hugetlb_max_hstate __read_mostly;
 unsigned int default_hstate_idx;
 struct hstate hstates[HUGE_MAX_HSTATE];
<span class="p_add">+/*</span>
<span class="p_add">+ * Minimum page order among possible hugepage sizes, set to a proper value</span>
<span class="p_add">+ * at boot time.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int minimum_order __read_mostly = UINT_MAX;</span>
 
 __initdata LIST_HEAD(huge_boot_pages);
 
<span class="p_chunk">@@ -1188,19 +1193,13 @@</span> <span class="p_context"> static void dissolve_free_huge_page(struct page *page)</span>
  */
 void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)
 {
<span class="p_del">-	unsigned int order = 8 * sizeof(void *);</span>
 	unsigned long pfn;
<span class="p_del">-	struct hstate *h;</span>
 
 	if (!hugepages_supported())
 		return;
 
<span class="p_del">-	/* Set scan step to minimum hugepage size */</span>
<span class="p_del">-	for_each_hstate(h)</span>
<span class="p_del">-		if (order &gt; huge_page_order(h))</span>
<span class="p_del">-			order = huge_page_order(h);</span>
<span class="p_del">-	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; order));</span>
<span class="p_del">-	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; order)</span>
<span class="p_add">+	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; minimum_order));</span>
<span class="p_add">+	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)</span>
 		dissolve_free_huge_page(pfn_to_page(pfn));
 }
 
<span class="p_chunk">@@ -1627,10 +1626,14 @@</span> <span class="p_context"> static void __init hugetlb_init_hstates(void)</span>
 	struct hstate *h;
 
 	for_each_hstate(h) {
<span class="p_add">+		if (minimum_order &gt; huge_page_order(h))</span>
<span class="p_add">+			minimum_order = huge_page_order(h);</span>
<span class="p_add">+</span>
 		/* oversize hugepages were init&#39;ed in early boot */
 		if (!hstate_is_gigantic(h))
 			hugetlb_hstate_alloc_pages(h);
 	}
<span class="p_add">+	VM_BUG_ON(minimum_order == UINT_MAX);</span>
 }
 
 static char * __init memfmt(char *buf, unsigned long n)
<span class="p_header">diff --git a/mm/memory.c b/mm/memory.c</span>
<span class="p_header">index 22e037e3364e..2a9e09870c20 100644</span>
<span class="p_header">--- a/mm/memory.c</span>
<span class="p_header">+++ b/mm/memory.c</span>
<span class="p_chunk">@@ -2669,6 +2669,10 @@</span> <span class="p_context"> static int do_anonymous_page(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 
 	pte_unmap(page_table);
 
<span class="p_add">+	/* File mapping without -&gt;vm_ops ? */</span>
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_SHARED)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
<span class="p_add">+</span>
 	/* Check if we need to add a guard page to the stack */
 	if (check_stack_guard_page(vma, address) &lt; 0)
 		return VM_FAULT_SIGSEGV;
<span class="p_chunk">@@ -3097,6 +3101,9 @@</span> <span class="p_context"> static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,</span>
 			- vma-&gt;vm_start) &gt;&gt; PAGE_SHIFT) + vma-&gt;vm_pgoff;
 
 	pte_unmap(page_table);
<span class="p_add">+	/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */</span>
<span class="p_add">+	if (!vma-&gt;vm_ops-&gt;fault)</span>
<span class="p_add">+		return VM_FAULT_SIGBUS;</span>
 	if (!(flags &amp; FAULT_FLAG_WRITE))
 		return do_read_fault(mm, vma, address, pmd, pgoff, flags,
 				orig_pte);
<span class="p_chunk">@@ -3242,13 +3249,12 @@</span> <span class="p_context"> static int handle_pte_fault(struct mm_struct *mm,</span>
 	barrier();
 	if (!pte_present(entry)) {
 		if (pte_none(entry)) {
<span class="p_del">-			if (vma-&gt;vm_ops) {</span>
<span class="p_del">-				if (likely(vma-&gt;vm_ops-&gt;fault))</span>
<span class="p_del">-					return do_fault(mm, vma, address, pte,</span>
<span class="p_del">-							pmd, flags, entry);</span>
<span class="p_del">-			}</span>
<span class="p_del">-			return do_anonymous_page(mm, vma, address,</span>
<span class="p_del">-						 pte, pmd, flags);</span>
<span class="p_add">+			if (vma-&gt;vm_ops)</span>
<span class="p_add">+				return do_fault(mm, vma, address, pte, pmd,</span>
<span class="p_add">+						flags, entry);</span>
<span class="p_add">+</span>
<span class="p_add">+			return do_anonymous_page(mm, vma, address, pte, pmd,</span>
<span class="p_add">+					flags);</span>
 		}
 		return do_swap_page(mm, vma, address,
 					pte, pmd, flags, entry);
<span class="p_header">diff --git a/net/9p/client.c b/net/9p/client.c</span>
<span class="p_header">index 6f4c4c88db84..81925b923318 100644</span>
<span class="p_header">--- a/net/9p/client.c</span>
<span class="p_header">+++ b/net/9p/client.c</span>
<span class="p_chunk">@@ -843,7 +843,8 @@</span> <span class="p_context"> static struct p9_req_t *p9_client_zc_rpc(struct p9_client *c, int8_t type,</span>
 	if (err &lt; 0) {
 		if (err == -EIO)
 			c-&gt;status = Disconnected;
<span class="p_del">-		goto reterr;</span>
<span class="p_add">+		if (err != -ERESTARTSYS)</span>
<span class="p_add">+			goto reterr;</span>
 	}
 	if (req-&gt;status == REQ_STATUS_ERROR) {
 		p9_debug(P9_DEBUG_ERROR, &quot;req_status error %d\n&quot;, req-&gt;t_err);
<span class="p_chunk">@@ -1647,6 +1648,7 @@</span> <span class="p_context"> p9_client_write(struct p9_fid *fid, u64 offset, struct iov_iter *from, int *err)</span>
 		if (*err) {
 			trace_9p_protocol_dump(clnt, req-&gt;rc);
 			p9_free_req(clnt, req);
<span class="p_add">+			break;</span>
 		}
 
 		p9_debug(P9_DEBUG_9P, &quot;&lt;&lt;&lt; RWRITE count %d\n&quot;, count);
<span class="p_header">diff --git a/net/bluetooth/hci_sock.c b/net/bluetooth/hci_sock.c</span>
<span class="p_header">index 56f9edbf3d05..e11a5cfda4b1 100644</span>
<span class="p_header">--- a/net/bluetooth/hci_sock.c</span>
<span class="p_header">+++ b/net/bluetooth/hci_sock.c</span>
<span class="p_chunk">@@ -741,10 +741,11 @@</span> <span class="p_context"> static int hci_sock_bind(struct socket *sock, struct sockaddr *addr,</span>
 			goto done;
 		}
 
<span class="p_del">-		if (test_bit(HCI_UP, &amp;hdev-&gt;flags) ||</span>
<span class="p_del">-		    test_bit(HCI_INIT, &amp;hdev-&gt;flags) ||</span>
<span class="p_add">+		if (test_bit(HCI_INIT, &amp;hdev-&gt;flags) ||</span>
 		    hci_dev_test_flag(hdev, HCI_SETUP) ||
<span class="p_del">-		    hci_dev_test_flag(hdev, HCI_CONFIG)) {</span>
<span class="p_add">+		    hci_dev_test_flag(hdev, HCI_CONFIG) ||</span>
<span class="p_add">+		    (!hci_dev_test_flag(hdev, HCI_AUTO_OFF) &amp;&amp;</span>
<span class="p_add">+		     test_bit(HCI_UP, &amp;hdev-&gt;flags))) {</span>
 			err = -EBUSY;
 			hci_dev_put(hdev);
 			goto done;
<span class="p_chunk">@@ -760,10 +761,21 @@</span> <span class="p_context"> static int hci_sock_bind(struct socket *sock, struct sockaddr *addr,</span>
 
 		err = hci_dev_open(hdev-&gt;id);
 		if (err) {
<span class="p_del">-			hci_dev_clear_flag(hdev, HCI_USER_CHANNEL);</span>
<span class="p_del">-			mgmt_index_added(hdev);</span>
<span class="p_del">-			hci_dev_put(hdev);</span>
<span class="p_del">-			goto done;</span>
<span class="p_add">+			if (err == -EALREADY) {</span>
<span class="p_add">+				/* In case the transport is already up and</span>
<span class="p_add">+				 * running, clear the error here.</span>
<span class="p_add">+				 *</span>
<span class="p_add">+				 * This can happen when opening an user</span>
<span class="p_add">+				 * channel and HCI_AUTO_OFF grace period</span>
<span class="p_add">+				 * is still active.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				err = 0;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				hci_dev_clear_flag(hdev, HCI_USER_CHANNEL);</span>
<span class="p_add">+				mgmt_index_added(hdev);</span>
<span class="p_add">+				hci_dev_put(hdev);</span>
<span class="p_add">+				goto done;</span>
<span class="p_add">+			}</span>
 		}
 
 		atomic_inc(&amp;hdev-&gt;promisc);
<span class="p_header">diff --git a/net/ceph/osdmap.c b/net/ceph/osdmap.c</span>
<span class="p_header">index 15796696d64e..4a3125836b64 100644</span>
<span class="p_header">--- a/net/ceph/osdmap.c</span>
<span class="p_header">+++ b/net/ceph/osdmap.c</span>
<span class="p_chunk">@@ -89,7 +89,7 @@</span> <span class="p_context"> static int crush_decode_tree_bucket(void **p, void *end,</span>
 {
 	int j;
 	dout(&quot;crush_decode_tree_bucket %p to %p\n&quot;, *p, end);
<span class="p_del">-	ceph_decode_32_safe(p, end, b-&gt;num_nodes, bad);</span>
<span class="p_add">+	ceph_decode_8_safe(p, end, b-&gt;num_nodes, bad);</span>
 	b-&gt;node_weights = kcalloc(b-&gt;num_nodes, sizeof(u32), GFP_NOFS);
 	if (b-&gt;node_weights == NULL)
 		return -ENOMEM;
<span class="p_header">diff --git a/net/ieee802154/socket.c b/net/ieee802154/socket.c</span>
<span class="p_header">index b60c65f70346..627a2537634e 100644</span>
<span class="p_header">--- a/net/ieee802154/socket.c</span>
<span class="p_header">+++ b/net/ieee802154/socket.c</span>
<span class="p_chunk">@@ -739,6 +739,12 @@</span> <span class="p_context"> static int dgram_recvmsg(struct sock *sk, struct msghdr *msg, size_t len,</span>
 	sock_recv_ts_and_drops(msg, sk, skb);
 
 	if (saddr) {
<span class="p_add">+		/* Clear the implicit padding in struct sockaddr_ieee802154</span>
<span class="p_add">+		 * (16 bits between &#39;family&#39; and &#39;addr&#39;) and in struct</span>
<span class="p_add">+		 * ieee802154_addr_sa (16 bits at the end of the structure).</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		memset(saddr, 0, sizeof(*saddr));</span>
<span class="p_add">+</span>
 		saddr-&gt;family = AF_IEEE802154;
 		ieee802154_addr_to_sa(&amp;saddr-&gt;addr, &amp;mac_cb(skb)-&gt;source);
 		*addr_len = sizeof(*saddr);
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index ff347a0eebd4..f06d42267306 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -3356,6 +3356,7 @@</span> <span class="p_context"> static int ieee80211_mgmt_tx(struct wiphy *wiphy, struct wireless_dev *wdev,</span>
 	/* Update CSA counters */
 	if (sdata-&gt;vif.csa_active &amp;&amp;
 	    (sdata-&gt;vif.type == NL80211_IFTYPE_AP ||
<span class="p_add">+	     sdata-&gt;vif.type == NL80211_IFTYPE_MESH_POINT ||</span>
 	     sdata-&gt;vif.type == NL80211_IFTYPE_ADHOC) &amp;&amp;
 	    params-&gt;n_csa_offsets) {
 		int i;
<span class="p_header">diff --git a/net/mac80211/ibss.c b/net/mac80211/ibss.c</span>
<span class="p_header">index bfef1b215050..a9c9d961f039 100644</span>
<span class="p_header">--- a/net/mac80211/ibss.c</span>
<span class="p_header">+++ b/net/mac80211/ibss.c</span>
<span class="p_chunk">@@ -146,6 +146,7 @@</span> <span class="p_context"> ieee80211_ibss_build_presp(struct ieee80211_sub_if_data *sdata,</span>
 				csa_settings-&gt;chandef.chan-&gt;center_freq);
 		presp-&gt;csa_counter_offsets[0] = (pos - presp-&gt;head);
 		*pos++ = csa_settings-&gt;count;
<span class="p_add">+		presp-&gt;csa_current_counter = csa_settings-&gt;count;</span>
 	}
 
 	/* put the remaining rates in WLAN_EID_EXT_SUPP_RATES */
<span class="p_header">diff --git a/net/mac80211/main.c b/net/mac80211/main.c</span>
<span class="p_header">index df3051d96aff..e86daed83c6f 100644</span>
<span class="p_header">--- a/net/mac80211/main.c</span>
<span class="p_header">+++ b/net/mac80211/main.c</span>
<span class="p_chunk">@@ -249,6 +249,7 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 {
 	struct ieee80211_local *local =
 		container_of(work, struct ieee80211_local, restart_work);
<span class="p_add">+	struct ieee80211_sub_if_data *sdata;</span>
 
 	/* wait for scan work complete */
 	flush_workqueue(local-&gt;workqueue);
<span class="p_chunk">@@ -257,6 +258,8 @@</span> <span class="p_context"> static void ieee80211_restart_work(struct work_struct *work)</span>
 	     &quot;%s called with hardware scan in progress\n&quot;, __func__);
 
 	rtnl_lock();
<span class="p_add">+	list_for_each_entry(sdata, &amp;local-&gt;interfaces, list)</span>
<span class="p_add">+		flush_delayed_work(&amp;sdata-&gt;dec_tailroom_needed_wk);</span>
 	ieee80211_scan_cancel(local);
 	ieee80211_reconfig(local);
 	rtnl_unlock();
<span class="p_header">diff --git a/net/mac80211/mesh.c b/net/mac80211/mesh.c</span>
<span class="p_header">index d4684242e78b..817098add1d6 100644</span>
<span class="p_header">--- a/net/mac80211/mesh.c</span>
<span class="p_header">+++ b/net/mac80211/mesh.c</span>
<span class="p_chunk">@@ -680,6 +680,7 @@</span> <span class="p_context"> ieee80211_mesh_build_beacon(struct ieee80211_if_mesh *ifmsh)</span>
 		*pos++ = 0x0;
 		*pos++ = ieee80211_frequency_to_channel(
 				csa-&gt;settings.chandef.chan-&gt;center_freq);
<span class="p_add">+		bcn-&gt;csa_current_counter = csa-&gt;settings.count;</span>
 		bcn-&gt;csa_counter_offsets[0] = hdr_len + 6;
 		*pos++ = csa-&gt;settings.count;
 		*pos++ = WLAN_EID_CHAN_SWITCH_PARAM;
<span class="p_header">diff --git a/net/sunrpc/backchannel_rqst.c b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">index 9dd0ea8db463..28504dfd3dad 100644</span>
<span class="p_header">--- a/net/sunrpc/backchannel_rqst.c</span>
<span class="p_header">+++ b/net/sunrpc/backchannel_rqst.c</span>
<span class="p_chunk">@@ -60,7 +60,7 @@</span> <span class="p_context"> static void xprt_free_allocation(struct rpc_rqst *req)</span>
 
 	dprintk(&quot;RPC:        free allocations for req= %p\n&quot;, req);
 	WARN_ON_ONCE(test_bit(RPC_BC_PA_IN_USE, &amp;req-&gt;rq_bc_pa_state));
<span class="p_del">-	xbufp = &amp;req-&gt;rq_private_buf;</span>
<span class="p_add">+	xbufp = &amp;req-&gt;rq_rcv_buf;</span>
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
 	xbufp = &amp;req-&gt;rq_snd_buf;
 	free_page((unsigned long)xbufp-&gt;head[0].iov_base);
<span class="p_header">diff --git a/net/wireless/util.c b/net/wireless/util.c</span>
<span class="p_header">index 70051ab52f4f..7e4e3fffe7ce 100644</span>
<span class="p_header">--- a/net/wireless/util.c</span>
<span class="p_header">+++ b/net/wireless/util.c</span>
<span class="p_chunk">@@ -944,7 +944,7 @@</span> <span class="p_context"> int cfg80211_change_iface(struct cfg80211_registered_device *rdev,</span>
 	     ntype == NL80211_IFTYPE_P2P_CLIENT))
 		return -EBUSY;
 
<span class="p_del">-	if (ntype != otype &amp;&amp; netif_running(dev)) {</span>
<span class="p_add">+	if (ntype != otype) {</span>
 		dev-&gt;ieee80211_ptr-&gt;use_4addr = false;
 		dev-&gt;ieee80211_ptr-&gt;mesh_id_up_len = 0;
 		wdev_lock(dev-&gt;ieee80211_ptr);
<span class="p_header">diff --git a/samples/trace_events/trace-events-sample.h b/samples/trace_events/trace-events-sample.h</span>
<span class="p_header">index 8965d1bb8811..125d6402f64f 100644</span>
<span class="p_header">--- a/samples/trace_events/trace-events-sample.h</span>
<span class="p_header">+++ b/samples/trace_events/trace-events-sample.h</span>
<span class="p_chunk">@@ -168,7 +168,10 @@</span> <span class="p_context"></span>
  *
  *      For __dynamic_array(int, foo, bar) use __get_dynamic_array(foo)
  *            Use __get_dynamic_array_len(foo) to get the length of the array
<span class="p_del">- *            saved.</span>
<span class="p_add">+ *            saved. Note, __get_dynamic_array_len() returns the total allocated</span>
<span class="p_add">+ *            length of the dynamic array; __print_array() expects the second</span>
<span class="p_add">+ *            parameter to be the number of elements. To get that, the array length</span>
<span class="p_add">+ *            needs to be divided by the element size.</span>
  *
  *      For __string(foo, bar) use __get_str(foo)
  *
<span class="p_chunk">@@ -288,7 +291,7 @@</span> <span class="p_context"> TRACE_EVENT(foo_bar,</span>
  *    This prints out the array that is defined by __array in a nice format.
  */
 		  __print_array(__get_dynamic_array(list),
<span class="p_del">-				__get_dynamic_array_len(list),</span>
<span class="p_add">+				__get_dynamic_array_len(list) / sizeof(int),</span>
 				sizeof(int)),
 		  __get_str(str), __get_bitmask(cpus))
 );
<span class="p_header">diff --git a/security/integrity/evm/evm_main.c b/security/integrity/evm/evm_main.c</span>
<span class="p_header">index 10f994307a04..582091498819 100644</span>
<span class="p_header">--- a/security/integrity/evm/evm_main.c</span>
<span class="p_header">+++ b/security/integrity/evm/evm_main.c</span>
<span class="p_chunk">@@ -296,6 +296,17 @@</span> <span class="p_context"> static int evm_protect_xattr(struct dentry *dentry, const char *xattr_name,</span>
 		iint = integrity_iint_find(d_backing_inode(dentry));
 		if (iint &amp;&amp; (iint-&gt;flags &amp; IMA_NEW_FILE))
 			return 0;
<span class="p_add">+</span>
<span class="p_add">+		/* exception for pseudo filesystems */</span>
<span class="p_add">+		if (dentry-&gt;d_inode-&gt;i_sb-&gt;s_magic == TMPFS_MAGIC</span>
<span class="p_add">+		    || dentry-&gt;d_inode-&gt;i_sb-&gt;s_magic == SYSFS_MAGIC)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		integrity_audit_msg(AUDIT_INTEGRITY_METADATA,</span>
<span class="p_add">+				    dentry-&gt;d_inode, dentry-&gt;d_name.name,</span>
<span class="p_add">+				    &quot;update_metadata&quot;,</span>
<span class="p_add">+				    integrity_status_msg[evm_status],</span>
<span class="p_add">+				    -EPERM, 0);</span>
 	}
 out:
 	if (evm_status != INTEGRITY_PASS)
<span class="p_header">diff --git a/security/integrity/ima/ima.h b/security/integrity/ima/ima.h</span>
<span class="p_header">index 8ee997dff139..fc56d4dfa954 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima.h</span>
<span class="p_header">+++ b/security/integrity/ima/ima.h</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void ima_add_violation(struct file *file, const unsigned char *filename,</span>
 		       const char *op, const char *cause);
 int ima_init_crypto(void);
 void ima_putc(struct seq_file *m, void *data, int datalen);
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size);</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size);</span>
 struct ima_template_desc *ima_template_desc_current(void);
 int ima_init_template(void);
 
<span class="p_header">diff --git a/security/integrity/ima/ima_fs.c b/security/integrity/ima/ima_fs.c</span>
<span class="p_header">index 461215e5fd31..816d175da79a 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_fs.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_fs.c</span>
<span class="p_chunk">@@ -190,9 +190,9 @@</span> <span class="p_context"> static const struct file_operations ima_measurements_ops = {</span>
 	.release = seq_release,
 };
 
<span class="p_del">-void ima_print_digest(struct seq_file *m, u8 *digest, int size)</span>
<span class="p_add">+void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)</span>
 {
<span class="p_del">-	int i;</span>
<span class="p_add">+	u32 i;</span>
 
 	for (i = 0; i &lt; size; i++)
 		seq_printf(m, &quot;%02x&quot;, *(digest + i));
<span class="p_header">diff --git a/security/integrity/ima/ima_policy.c b/security/integrity/ima/ima_policy.c</span>
<span class="p_header">index d1eefb9d65fb..3997e206f82d 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_policy.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_policy.c</span>
<span class="p_chunk">@@ -27,6 +27,8 @@</span> <span class="p_context"></span>
 #define IMA_UID		0x0008
 #define IMA_FOWNER	0x0010
 #define IMA_FSUUID	0x0020
<span class="p_add">+#define IMA_INMASK	0x0040</span>
<span class="p_add">+#define IMA_EUID	0x0080</span>
 
 #define UNKNOWN		0
 #define MEASURE		0x0001	/* same as IMA_MEASURE */
<span class="p_chunk">@@ -42,6 +44,8 @@</span> <span class="p_context"> enum lsm_rule_types { LSM_OBJ_USER, LSM_OBJ_ROLE, LSM_OBJ_TYPE,</span>
 	LSM_SUBJ_USER, LSM_SUBJ_ROLE, LSM_SUBJ_TYPE
 };
 
<span class="p_add">+enum policy_types { ORIGINAL_TCB = 1, DEFAULT_TCB };</span>
<span class="p_add">+</span>
 struct ima_rule_entry {
 	struct list_head list;
 	int action;
<span class="p_chunk">@@ -70,7 +74,7 @@</span> <span class="p_context"> struct ima_rule_entry {</span>
  * normal users can easily run the machine out of memory simply building
  * and running executables.
  */
<span class="p_del">-static struct ima_rule_entry default_rules[] = {</span>
<span class="p_add">+static struct ima_rule_entry dont_measure_rules[] = {</span>
 	{.action = DONT_MEASURE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_MEASURE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_MEASURE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},
<span class="p_chunk">@@ -79,12 +83,31 @@</span> <span class="p_context"> static struct ima_rule_entry default_rules[] = {</span>
 	{.action = DONT_MEASURE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_MEASURE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_MEASURE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},
<span class="p_add">+	{.action = DONT_MEASURE, .fsmagic = CGROUP_SUPER_MAGIC,</span>
<span class="p_add">+	 .flags = IMA_FSMAGIC},</span>
<span class="p_add">+	{.action = DONT_MEASURE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ima_rule_entry original_measurement_rules[] = {</span>
 	{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,
 	 .flags = IMA_FUNC | IMA_MASK},
 	{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,
 	 .flags = IMA_FUNC | IMA_MASK},
<span class="p_del">-	{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ, .uid = GLOBAL_ROOT_UID,</span>
<span class="p_del">-	 .flags = IMA_FUNC | IMA_MASK | IMA_UID},</span>
<span class="p_add">+	{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,</span>
<span class="p_add">+	 .uid = GLOBAL_ROOT_UID, .flags = IMA_FUNC | IMA_MASK | IMA_UID},</span>
<span class="p_add">+	{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},</span>
<span class="p_add">+	{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct ima_rule_entry default_measurement_rules[] = {</span>
<span class="p_add">+	{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,</span>
<span class="p_add">+	 .flags = IMA_FUNC | IMA_MASK},</span>
<span class="p_add">+	{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,</span>
<span class="p_add">+	 .flags = IMA_FUNC | IMA_MASK},</span>
<span class="p_add">+	{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,</span>
<span class="p_add">+	 .uid = GLOBAL_ROOT_UID, .flags = IMA_FUNC | IMA_INMASK | IMA_EUID},</span>
<span class="p_add">+	{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,</span>
<span class="p_add">+	 .uid = GLOBAL_ROOT_UID, .flags = IMA_FUNC | IMA_INMASK | IMA_UID},</span>
 	{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},
 	{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},
 };
<span class="p_chunk">@@ -99,6 +122,7 @@</span> <span class="p_context"> static struct ima_rule_entry default_appraise_rules[] = {</span>
 	{.action = DONT_APPRAISE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_APPRAISE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},
 	{.action = DONT_APPRAISE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},
<span class="p_add">+	{.action = DONT_APPRAISE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},</span>
 	{.action = DONT_APPRAISE, .fsmagic = CGROUP_SUPER_MAGIC, .flags = IMA_FSMAGIC},
 #ifndef CONFIG_IMA_APPRAISE_SIGNED_INIT
 	{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .flags = IMA_FOWNER},
<span class="p_chunk">@@ -115,14 +139,29 @@</span> <span class="p_context"> static struct list_head *ima_rules;</span>
 
 static DEFINE_MUTEX(ima_rules_mutex);
 
<span class="p_del">-static bool ima_use_tcb __initdata;</span>
<span class="p_add">+static int ima_policy __initdata;</span>
 static int __init default_measure_policy_setup(char *str)
 {
<span class="p_del">-	ima_use_tcb = 1;</span>
<span class="p_add">+	if (ima_policy)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	ima_policy = ORIGINAL_TCB;</span>
 	return 1;
 }
 __setup(&quot;ima_tcb&quot;, default_measure_policy_setup);
 
<span class="p_add">+static int __init policy_setup(char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ima_policy)</span>
<span class="p_add">+		return 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (strcmp(str, &quot;tcb&quot;) == 0)</span>
<span class="p_add">+		ima_policy = DEFAULT_TCB;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;ima_policy=&quot;, policy_setup);</span>
<span class="p_add">+</span>
 static bool ima_use_appraise_tcb __initdata;
 static int __init default_appraise_policy_setup(char *str)
 {
<span class="p_chunk">@@ -182,6 +221,9 @@</span> <span class="p_context"> static bool ima_match_rules(struct ima_rule_entry *rule,</span>
 	if ((rule-&gt;flags &amp; IMA_MASK) &amp;&amp;
 	    (rule-&gt;mask != mask &amp;&amp; func != POST_SETATTR))
 		return false;
<span class="p_add">+	if ((rule-&gt;flags &amp; IMA_INMASK) &amp;&amp;</span>
<span class="p_add">+	    (!(rule-&gt;mask &amp; mask) &amp;&amp; func != POST_SETATTR))</span>
<span class="p_add">+		return false;</span>
 	if ((rule-&gt;flags &amp; IMA_FSMAGIC)
 	    &amp;&amp; rule-&gt;fsmagic != inode-&gt;i_sb-&gt;s_magic)
 		return false;
<span class="p_chunk">@@ -190,6 +232,16 @@</span> <span class="p_context"> static bool ima_match_rules(struct ima_rule_entry *rule,</span>
 		return false;
 	if ((rule-&gt;flags &amp; IMA_UID) &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;uid))
 		return false;
<span class="p_add">+	if (rule-&gt;flags &amp; IMA_EUID) {</span>
<span class="p_add">+		if (has_capability_noaudit(current, CAP_SETUID)) {</span>
<span class="p_add">+			if (!uid_eq(rule-&gt;uid, cred-&gt;euid)</span>
<span class="p_add">+			    &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;suid)</span>
<span class="p_add">+			    &amp;&amp; !uid_eq(rule-&gt;uid, cred-&gt;uid))</span>
<span class="p_add">+				return false;</span>
<span class="p_add">+		} else if (!uid_eq(rule-&gt;uid, cred-&gt;euid))</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if ((rule-&gt;flags &amp; IMA_FOWNER) &amp;&amp; !uid_eq(rule-&gt;fowner, inode-&gt;i_uid))
 		return false;
 	for (i = 0; i &lt; MAX_LSM_RULES; i++) {
<span class="p_chunk">@@ -333,21 +385,31 @@</span> <span class="p_context"> void __init ima_init_policy(void)</span>
 {
 	int i, measure_entries, appraise_entries;
 
<span class="p_del">-	/* if !ima_use_tcb set entries = 0 so we load NO default rules */</span>
<span class="p_del">-	measure_entries = ima_use_tcb ? ARRAY_SIZE(default_rules) : 0;</span>
<span class="p_add">+	/* if !ima_policy set entries = 0 so we load NO default rules */</span>
<span class="p_add">+	measure_entries = ima_policy ? ARRAY_SIZE(dont_measure_rules) : 0;</span>
 	appraise_entries = ima_use_appraise_tcb ?
 			 ARRAY_SIZE(default_appraise_rules) : 0;
 
<span class="p_del">-	for (i = 0; i &lt; measure_entries + appraise_entries; i++) {</span>
<span class="p_del">-		if (i &lt; measure_entries)</span>
<span class="p_del">-			list_add_tail(&amp;default_rules[i].list,</span>
<span class="p_del">-				      &amp;ima_default_rules);</span>
<span class="p_del">-		else {</span>
<span class="p_del">-			int j = i - measure_entries;</span>
<span class="p_add">+	for (i = 0; i &lt; measure_entries; i++)</span>
<span class="p_add">+		list_add_tail(&amp;dont_measure_rules[i].list, &amp;ima_default_rules);</span>
 
<span class="p_del">-			list_add_tail(&amp;default_appraise_rules[j].list,</span>
<span class="p_add">+	switch (ima_policy) {</span>
<span class="p_add">+	case ORIGINAL_TCB:</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(original_measurement_rules); i++)</span>
<span class="p_add">+			list_add_tail(&amp;original_measurement_rules[i].list,</span>
 				      &amp;ima_default_rules);
<span class="p_del">-		}</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case DEFAULT_TCB:</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(default_measurement_rules); i++)</span>
<span class="p_add">+			list_add_tail(&amp;default_measurement_rules[i].list,</span>
<span class="p_add">+				      &amp;ima_default_rules);</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; appraise_entries; i++) {</span>
<span class="p_add">+		list_add_tail(&amp;default_appraise_rules[i].list,</span>
<span class="p_add">+			      &amp;ima_default_rules);</span>
 	}
 
 	ima_rules = &amp;ima_default_rules;
<span class="p_chunk">@@ -373,7 +435,8 @@</span> <span class="p_context"> enum {</span>
 	Opt_audit,
 	Opt_obj_user, Opt_obj_role, Opt_obj_type,
 	Opt_subj_user, Opt_subj_role, Opt_subj_type,
<span class="p_del">-	Opt_func, Opt_mask, Opt_fsmagic, Opt_uid, Opt_fowner,</span>
<span class="p_add">+	Opt_func, Opt_mask, Opt_fsmagic,</span>
<span class="p_add">+	Opt_uid, Opt_euid, Opt_fowner,</span>
 	Opt_appraise_type, Opt_fsuuid, Opt_permit_directio
 };
 
<span class="p_chunk">@@ -394,6 +457,7 @@</span> <span class="p_context"> static match_table_t policy_tokens = {</span>
 	{Opt_fsmagic, &quot;fsmagic=%s&quot;},
 	{Opt_fsuuid, &quot;fsuuid=%s&quot;},
 	{Opt_uid, &quot;uid=%s&quot;},
<span class="p_add">+	{Opt_euid, &quot;euid=%s&quot;},</span>
 	{Opt_fowner, &quot;fowner=%s&quot;},
 	{Opt_appraise_type, &quot;appraise_type=%s&quot;},
 	{Opt_permit_directio, &quot;permit_directio&quot;},
<span class="p_chunk">@@ -435,6 +499,7 @@</span> <span class="p_context"> static void ima_log_string(struct audit_buffer *ab, char *key, char *value)</span>
 static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)
 {
 	struct audit_buffer *ab;
<span class="p_add">+	char *from;</span>
 	char *p;
 	int result = 0;
 
<span class="p_chunk">@@ -525,18 +590,23 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 			if (entry-&gt;mask)
 				result = -EINVAL;
 
<span class="p_del">-			if ((strcmp(args[0].from, &quot;MAY_EXEC&quot;)) == 0)</span>
<span class="p_add">+			from = args[0].from;</span>
<span class="p_add">+			if (*from == &#39;^&#39;)</span>
<span class="p_add">+				from++;</span>
<span class="p_add">+</span>
<span class="p_add">+			if ((strcmp(from, &quot;MAY_EXEC&quot;)) == 0)</span>
 				entry-&gt;mask = MAY_EXEC;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_WRITE&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_WRITE&quot;) == 0)</span>
 				entry-&gt;mask = MAY_WRITE;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_READ&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_READ&quot;) == 0)</span>
 				entry-&gt;mask = MAY_READ;
<span class="p_del">-			else if (strcmp(args[0].from, &quot;MAY_APPEND&quot;) == 0)</span>
<span class="p_add">+			else if (strcmp(from, &quot;MAY_APPEND&quot;) == 0)</span>
 				entry-&gt;mask = MAY_APPEND;
 			else
 				result = -EINVAL;
 			if (!result)
<span class="p_del">-				entry-&gt;flags |= IMA_MASK;</span>
<span class="p_add">+				entry-&gt;flags |= (*args[0].from == &#39;^&#39;)</span>
<span class="p_add">+				     ? IMA_INMASK : IMA_MASK;</span>
 			break;
 		case Opt_fsmagic:
 			ima_log_string(ab, &quot;fsmagic&quot;, args[0].from);
<span class="p_chunk">@@ -566,6 +636,9 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 			break;
 		case Opt_uid:
 			ima_log_string(ab, &quot;uid&quot;, args[0].from);
<span class="p_add">+		case Opt_euid:</span>
<span class="p_add">+			if (token == Opt_euid)</span>
<span class="p_add">+				ima_log_string(ab, &quot;euid&quot;, args[0].from);</span>
 
 			if (uid_valid(entry-&gt;uid)) {
 				result = -EINVAL;
<span class="p_chunk">@@ -574,11 +647,14 @@</span> <span class="p_context"> static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)</span>
 
 			result = kstrtoul(args[0].from, 10, &amp;lnum);
 			if (!result) {
<span class="p_del">-				entry-&gt;uid = make_kuid(current_user_ns(), (uid_t)lnum);</span>
<span class="p_del">-				if (!uid_valid(entry-&gt;uid) || (((uid_t)lnum) != lnum))</span>
<span class="p_add">+				entry-&gt;uid = make_kuid(current_user_ns(),</span>
<span class="p_add">+						       (uid_t) lnum);</span>
<span class="p_add">+				if (!uid_valid(entry-&gt;uid) ||</span>
<span class="p_add">+				    (uid_t)lnum != lnum)</span>
 					result = -EINVAL;
 				else
<span class="p_del">-					entry-&gt;flags |= IMA_UID;</span>
<span class="p_add">+					entry-&gt;flags |= (token == Opt_uid)</span>
<span class="p_add">+					    ? IMA_UID : IMA_EUID;</span>
 			}
 			break;
 		case Opt_fowner:
<span class="p_header">diff --git a/security/integrity/ima/ima_template_lib.c b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">index bcfc36cbde6a..61fbd0c0d95c 100644</span>
<span class="p_header">--- a/security/integrity/ima/ima_template_lib.c</span>
<span class="p_header">+++ b/security/integrity/ima/ima_template_lib.c</span>
<span class="p_chunk">@@ -70,7 +70,8 @@</span> <span class="p_context"> static void ima_show_template_data_ascii(struct seq_file *m,</span>
 					 enum data_formats datafmt,
 					 struct ima_field_data *field_data)
 {
<span class="p_del">-	u8 *buf_ptr = field_data-&gt;data, buflen = field_data-&gt;len;</span>
<span class="p_add">+	u8 *buf_ptr = field_data-&gt;data;</span>
<span class="p_add">+	u32 buflen = field_data-&gt;len;</span>
 
 	switch (datafmt) {
 	case DATA_FMT_DIGEST_WITH_ALGO:
<span class="p_header">diff --git a/security/keys/keyring.c b/security/keys/keyring.c</span>
<span class="p_header">index e72548b5897e..d33437007ad2 100644</span>
<span class="p_header">--- a/security/keys/keyring.c</span>
<span class="p_header">+++ b/security/keys/keyring.c</span>
<span class="p_chunk">@@ -1181,9 +1181,11 @@</span> <span class="p_context"> void __key_link_end(struct key *keyring,</span>
 	if (index_key-&gt;type == &amp;key_type_keyring)
 		up_write(&amp;keyring_serialise_link_sem);
 
<span class="p_del">-	if (edit &amp;&amp; !edit-&gt;dead_leaf) {</span>
<span class="p_del">-		key_payload_reserve(keyring,</span>
<span class="p_del">-				    keyring-&gt;datalen - KEYQUOTA_LINK_BYTES);</span>
<span class="p_add">+	if (edit) {</span>
<span class="p_add">+		if (!edit-&gt;dead_leaf) {</span>
<span class="p_add">+			key_payload_reserve(keyring,</span>
<span class="p_add">+				keyring-&gt;datalen - KEYQUOTA_LINK_BYTES);</span>
<span class="p_add">+		}</span>
 		assoc_array_cancel_edit(edit);
 	}
 	up_write(&amp;keyring-&gt;sem);
<span class="p_header">diff --git a/security/selinux/hooks.c b/security/selinux/hooks.c</span>
<span class="p_header">index 212070e1de1a..7f8d7f19e044 100644</span>
<span class="p_header">--- a/security/selinux/hooks.c</span>
<span class="p_header">+++ b/security/selinux/hooks.c</span>
<span class="p_chunk">@@ -3288,7 +3288,8 @@</span> <span class="p_context"> static int file_map_prot_check(struct file *file, unsigned long prot, int shared</span>
 	int rc = 0;
 
 	if (default_noexec &amp;&amp;
<span class="p_del">-	    (prot &amp; PROT_EXEC) &amp;&amp; (!file || (!shared &amp;&amp; (prot &amp; PROT_WRITE)))) {</span>
<span class="p_add">+	    (prot &amp; PROT_EXEC) &amp;&amp; (!file || IS_PRIVATE(file_inode(file)) ||</span>
<span class="p_add">+				   (!shared &amp;&amp; (prot &amp; PROT_WRITE)))) {</span>
 		/*
 		 * We are making executable an anonymous mapping or a
 		 * private file mapping that will also be writable.
<span class="p_header">diff --git a/security/selinux/ss/ebitmap.c b/security/selinux/ss/ebitmap.c</span>
<span class="p_header">index afe6a269ec17..57644b1dc42e 100644</span>
<span class="p_header">--- a/security/selinux/ss/ebitmap.c</span>
<span class="p_header">+++ b/security/selinux/ss/ebitmap.c</span>
<span class="p_chunk">@@ -153,6 +153,12 @@</span> <span class="p_context"> int ebitmap_netlbl_import(struct ebitmap *ebmap,</span>
 		if (offset == (u32)-1)
 			return 0;
 
<span class="p_add">+		/* don&#39;t waste ebitmap space if the netlabel bitmap is empty */</span>
<span class="p_add">+		if (bitmap == 0) {</span>
<span class="p_add">+			offset += EBITMAP_UNIT_SIZE;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		if (e_iter == NULL ||
 		    offset &gt;= e_iter-&gt;startbit + EBITMAP_SIZE) {
 			e_prev = e_iter;
<span class="p_header">diff --git a/sound/soc/codecs/max98925.c b/sound/soc/codecs/max98925.c</span>
<span class="p_header">index 9b5a17de4690..aad664225dc3 100644</span>
<span class="p_header">--- a/sound/soc/codecs/max98925.c</span>
<span class="p_header">+++ b/sound/soc/codecs/max98925.c</span>
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> static int max98925_dai_set_fmt(struct snd_soc_dai *codec_dai,</span>
 	}
 
 	regmap_update_bits(max98925-&gt;regmap, MAX98925_FORMAT,
<span class="p_del">-			M98925_DAI_BCI_MASK, invert);</span>
<span class="p_add">+			M98925_DAI_BCI_MASK | M98925_DAI_WCI_MASK, invert);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/sound/soc/codecs/rt5645.c b/sound/soc/codecs/rt5645.c</span>
<span class="p_header">index be4d741c45ba..2ee44abd56a6 100644</span>
<span class="p_header">--- a/sound/soc/codecs/rt5645.c</span>
<span class="p_header">+++ b/sound/soc/codecs/rt5645.c</span>
<span class="p_chunk">@@ -2837,6 +2837,8 @@</span> <span class="p_context"> static int rt5645_i2c_probe(struct i2c_client *i2c,</span>
 		}
 	}
 
<span class="p_add">+	INIT_DELAYED_WORK(&amp;rt5645-&gt;jack_detect_work, rt5645_jack_detect_work);</span>
<span class="p_add">+</span>
 	if (rt5645-&gt;i2c-&gt;irq) {
 		ret = request_threaded_irq(rt5645-&gt;i2c-&gt;irq, NULL, rt5645_irq,
 			IRQF_TRIGGER_RISING | IRQF_TRIGGER_FALLING
<span class="p_chunk">@@ -2855,8 +2857,6 @@</span> <span class="p_context"> static int rt5645_i2c_probe(struct i2c_client *i2c,</span>
 			dev_err(&amp;i2c-&gt;dev, &quot;Fail gpio_direction hp_det_gpio\n&quot;);
 	}
 
<span class="p_del">-	INIT_DELAYED_WORK(&amp;rt5645-&gt;jack_detect_work, rt5645_jack_detect_work);</span>
<span class="p_del">-</span>
 	return snd_soc_register_codec(&amp;i2c-&gt;dev, &amp;soc_codec_dev_rt5645,
 				      rt5645_dai, ARRAY_SIZE(rt5645_dai));
 }
<span class="p_header">diff --git a/sound/soc/codecs/tas2552.c b/sound/soc/codecs/tas2552.c</span>
<span class="p_header">index dfb4ff5cc9ea..18558595ba72 100644</span>
<span class="p_header">--- a/sound/soc/codecs/tas2552.c</span>
<span class="p_header">+++ b/sound/soc/codecs/tas2552.c</span>
<span class="p_chunk">@@ -120,6 +120,9 @@</span> <span class="p_context"> static void tas2552_sw_shutdown(struct tas2552_data *tas_data, int sw_shutdown)</span>
 {
 	u8 cfg1_reg;
 
<span class="p_add">+	if (!tas_data-&gt;codec)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (sw_shutdown)
 		cfg1_reg = 0;
 	else
<span class="p_chunk">@@ -335,7 +338,6 @@</span> <span class="p_context"> static DECLARE_TLV_DB_SCALE(dac_tlv, -7, 100, 24);</span>
 static const struct snd_kcontrol_new tas2552_snd_controls[] = {
 	SOC_SINGLE_TLV(&quot;Speaker Driver Playback Volume&quot;,
 			 TAS2552_PGA_GAIN, 0, 0x1f, 1, dac_tlv),
<span class="p_del">-	SOC_DAPM_SINGLE(&quot;Playback AMP&quot;, SND_SOC_NOPM, 0, 1, 0),</span>
 };
 
 static const struct reg_default tas2552_init_regs[] = {
<span class="p_header">diff --git a/sound/soc/codecs/wm5102.c b/sound/soc/codecs/wm5102.c</span>
<span class="p_header">index 0c6d1bc0526e..d476221dba51 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5102.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5102.c</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> struct wm5102_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct wm_adsp_region wm5102_dsp1_regions[] = {
<span class="p_header">diff --git a/sound/soc/codecs/wm5110.c b/sound/soc/codecs/wm5110.c</span>
<span class="p_header">index fbaeddb3e903..3ee6cfd0578b 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm5110.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm5110.c</span>
<span class="p_chunk">@@ -167,7 +167,7 @@</span> <span class="p_context"> static int wm5110_sysclk_ev(struct snd_soc_dapm_widget *w,</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 #define WM5110_NG_SRC(name, base) \
<span class="p_header">diff --git a/sound/soc/codecs/wm8737.c b/sound/soc/codecs/wm8737.c</span>
<span class="p_header">index ada9ac1ba2c6..51171e457fa4 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8737.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8737.c</span>
<span class="p_chunk">@@ -483,7 +483,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 			/* Fast VMID ramp at 2*2.5k */
 			snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-					    WM8737_VMIDSEL_MASK, 0x4);</span>
<span class="p_add">+					    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+					    2 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 			/* Bring VMID up */
 			snd_soc_update_bits(codec, WM8737_POWER_MANAGEMENT,
<span class="p_chunk">@@ -497,7 +498,8 @@</span> <span class="p_context"> static int wm8737_set_bias_level(struct snd_soc_codec *codec,</span>
 
 		/* VMID at 2*300k */
 		snd_soc_update_bits(codec, WM8737_MISC_BIAS_CONTROL,
<span class="p_del">-				    WM8737_VMIDSEL_MASK, 2);</span>
<span class="p_add">+				    WM8737_VMIDSEL_MASK,</span>
<span class="p_add">+				    1 &lt;&lt; WM8737_VMIDSEL_SHIFT);</span>
 
 		break;
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8903.h b/sound/soc/codecs/wm8903.h</span>
<span class="p_header">index db949311c0f2..0bb4a647755d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8903.h</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8903.h</span>
<span class="p_chunk">@@ -172,7 +172,7 @@</span> <span class="p_context"> extern int wm8903_mic_detect(struct snd_soc_codec *codec,</span>
 #define WM8903_VMID_BUF_ENA_WIDTH                    1  /* VMID_BUF_ENA */
 
 #define WM8903_VMID_RES_50K                          2
<span class="p_del">-#define WM8903_VMID_RES_250K                         3</span>
<span class="p_add">+#define WM8903_VMID_RES_250K                         4</span>
 #define WM8903_VMID_RES_5K                           6
 
 /*
<span class="p_header">diff --git a/sound/soc/codecs/wm8955.c b/sound/soc/codecs/wm8955.c</span>
<span class="p_header">index 00bec915d652..03e04bf6c5ba 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8955.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8955.c</span>
<span class="p_chunk">@@ -298,7 +298,7 @@</span> <span class="p_context"> static int wm8955_configure_clocking(struct snd_soc_codec *codec)</span>
 		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,
 				    WM8955_K_17_9_MASK,
 				    (pll.k &gt;&gt; 9) &amp; WM8955_K_17_9_MASK);
<span class="p_del">-		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_2,</span>
<span class="p_add">+		snd_soc_update_bits(codec, WM8955_PLL_CONTROL_3,</span>
 				    WM8955_K_8_0_MASK,
 				    pll.k &amp; WM8955_K_8_0_MASK);
 		if (pll.k)
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index e97a7615df85..8d7f63253440 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> SOC_SINGLE(&quot;PCM Playback -6dB Switch&quot;, WM8960_DACCTL1, 7, 1, 0),</span>
 SOC_ENUM(&quot;ADC Polarity&quot;, wm8960_enum[0]),
 SOC_SINGLE(&quot;ADC High Pass Filter Switch&quot;, WM8960_DACCTL1, 0, 1, 0),
 
<span class="p_del">-SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[2]),</span>
<span class="p_add">+SOC_ENUM(&quot;DAC Polarity&quot;, wm8960_enum[1]),</span>
 SOC_SINGLE_BOOL_EXT(&quot;DAC Deemphasis Switch&quot;, 0,
 		    wm8960_get_deemph, wm8960_put_deemph),
 
<span class="p_header">diff --git a/sound/soc/codecs/wm8997.c b/sound/soc/codecs/wm8997.c</span>
<span class="p_header">index a4d11770630c..e7c81baefe66 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8997.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8997.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> struct wm8997_priv {</span>
 static DECLARE_TLV_DB_SCALE(ana_tlv, 0, 100, 0);
 static DECLARE_TLV_DB_SCALE(eq_tlv, -1200, 100, 0);
 static DECLARE_TLV_DB_SCALE(digital_tlv, -6400, 50, 0);
<span class="p_del">-static DECLARE_TLV_DB_SCALE(noise_tlv, 0, 600, 0);</span>
<span class="p_add">+static DECLARE_TLV_DB_SCALE(noise_tlv, -13200, 600, 0);</span>
 static DECLARE_TLV_DB_SCALE(ng_tlv, -10200, 600, 0);
 
 static const struct reg_default wm8997_sysclk_reva_patch[] = {
<span class="p_header">diff --git a/sound/soc/fsl/imx-wm8962.c b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">index cd146d4fa805..b38b98cae855 100644</span>
<span class="p_header">--- a/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_header">+++ b/sound/soc/fsl/imx-wm8962.c</span>
<span class="p_chunk">@@ -190,7 +190,7 @@</span> <span class="p_context"> static int imx_wm8962_probe(struct platform_device *pdev)</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;audmux internal port setup failed\n&quot;);
 		return ret;
 	}
<span class="p_del">-	imx_audmux_v2_configure_port(ext_port,</span>
<span class="p_add">+	ret = imx_audmux_v2_configure_port(ext_port,</span>
 			IMX_AUDMUX_V2_PTCR_SYN,
 			IMX_AUDMUX_V2_PDCR_RXDSEL(int_port));
 	if (ret) {
<span class="p_header">diff --git a/sound/soc/omap/Kconfig b/sound/soc/omap/Kconfig</span>
<span class="p_header">index 6768e4f7d7d0..30d0109703a9 100644</span>
<span class="p_header">--- a/sound/soc/omap/Kconfig</span>
<span class="p_header">+++ b/sound/soc/omap/Kconfig</span>
<span class="p_chunk">@@ -100,12 +100,13 @@</span> <span class="p_context"> config SND_OMAP_SOC_OMAP_TWL4030</span>
 
 config SND_OMAP_SOC_OMAP_ABE_TWL6040
 	tristate &quot;SoC Audio support for OMAP boards using ABE and twl6040 codec&quot;
<span class="p_del">-	depends on TWL6040_CORE &amp;&amp; SND_OMAP_SOC &amp;&amp; (ARCH_OMAP4 || SOC_OMAP5 || COMPILE_TEST)</span>
<span class="p_add">+	depends on TWL6040_CORE &amp;&amp; SND_OMAP_SOC</span>
<span class="p_add">+	depends on ARCH_OMAP4 || (SOC_OMAP5 &amp;&amp; MFD_PALMAS) || COMPILE_TEST</span>
 	select SND_OMAP_SOC_DMIC
 	select SND_OMAP_SOC_MCPDM
 	select SND_SOC_TWL6040
 	select SND_SOC_DMIC
<span class="p_del">-	select COMMON_CLK_PALMAS if MFD_PALMAS</span>
<span class="p_add">+	select COMMON_CLK_PALMAS if (SOC_OMAP5 &amp;&amp; MFD_PALMAS)</span>
 	help
 	  Say Y if you want to add support for SoC audio on OMAP boards using
 	  ABE and twl6040 codec. This driver currently supports:
<span class="p_header">diff --git a/sound/soc/qcom/Kconfig b/sound/soc/qcom/Kconfig</span>
<span class="p_header">index 5f58e4f1bca9..b07f183fc47f 100644</span>
<span class="p_header">--- a/sound/soc/qcom/Kconfig</span>
<span class="p_header">+++ b/sound/soc/qcom/Kconfig</span>
<span class="p_chunk">@@ -6,12 +6,10 @@</span> <span class="p_context"> config SND_SOC_QCOM</span>
 
 config SND_SOC_LPASS_CPU
 	tristate
<span class="p_del">-	depends on SND_SOC_QCOM</span>
 	select REGMAP_MMIO
 
 config SND_SOC_LPASS_PLATFORM
 	tristate
<span class="p_del">-	depends on SND_SOC_QCOM</span>
 	select REGMAP_MMIO
 
 config SND_SOC_STORM
<span class="p_header">diff --git a/tools/perf/util/cloexec.c b/tools/perf/util/cloexec.c</span>
<span class="p_header">index 85b523885f9d..2babddaa2481 100644</span>
<span class="p_header">--- a/tools/perf/util/cloexec.c</span>
<span class="p_header">+++ b/tools/perf/util/cloexec.c</span>
<span class="p_chunk">@@ -7,11 +7,15 @@</span> <span class="p_context"></span>
 
 static unsigned long flag = PERF_FLAG_FD_CLOEXEC;
 
<span class="p_add">+#ifdef __GLIBC_PREREQ</span>
<span class="p_add">+#if !__GLIBC_PREREQ(2, 6)</span>
 int __weak sched_getcpu(void)
 {
 	errno = ENOSYS;
 	return -1;
 }
<span class="p_add">+#endif</span>
<span class="p_add">+#endif</span>
 
 static int perf_flag_probe(void)
 {

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



