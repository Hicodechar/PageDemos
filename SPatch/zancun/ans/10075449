
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.51 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.51</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 26, 2017, 5:07 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171126170736.GN2971@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10075449/mbox/"
   >mbox</a>
|
   <a href="/patch/10075449/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10075449/">/patch/10075449/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	356E460211 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 26 Nov 2017 17:08:11 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E60BA28A2C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 26 Nov 2017 17:08:10 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D9A3828B25; Sun, 26 Nov 2017 17:08:10 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-4.5 required=2.0 tests=BAD_CREDIT,BAYES_00,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id C320828A2C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 26 Nov 2017 17:08:02 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752387AbdKZRH5 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 26 Nov 2017 12:07:57 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:35199 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1752352AbdKZRHs (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 26 Nov 2017 12:07:48 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1eJ0P2-0006we-9h; Sun, 26 Nov 2017 17:07:44 +0000
Date: Sun, 26 Nov 2017 17:07:36 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20171126170736.GN2971@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;0WGqsT62A4RTsSXf&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.51
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Nov. 26, 2017, 5:07 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.51 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.50 is attached to this message.

Ben.

------------

 Documentation/DocBook/media/v4l/dev-subdev.xml     |   2 +-
 Makefile                                           |   2 +-
 arch/arc/kernel/entry.S                            |   6 +
 arch/arc/mm/tlb.c                                  |   3 -
 arch/arm/boot/dts/dra7-evm.dts                     |  14 +-
 arch/arm/mach-omap2/omap_device.c                  |  10 --
 arch/arm/mm/fault.c                                |   5 +-
 arch/m68k/platform/coldfire/clk.c                  |   3 +
 arch/mips/ar7/clock.c                              |   3 +
 arch/mips/bcm63xx/clk.c                            |   3 +
 arch/mips/include/uapi/asm/inst.h                  |   2 +-
 arch/mips/kernel/process.c                         |  39 +++--
 arch/mips/loongson/lemote-2f/clock.c               |   3 +
 arch/mips/ralink/clk.c                             |   3 +
 arch/powerpc/boot/4xx.c                            |   2 +-
 arch/powerpc/include/asm/ppc-opcode.h              |   2 +-
 arch/powerpc/kernel/align.c                        | 119 ++++++++-----
 arch/powerpc/mm/hash_utils_64.c                    |   2 +-
 arch/powerpc/mm/init_64.c                          |   4 +-
 arch/s390/include/asm/mmu.h                        |   2 +
 arch/s390/include/asm/mmu_context.h                |   4 +-
 arch/s390/include/asm/tlbflush.h                   |   4 +-
 arch/x86/include/asm/elf.h                         |   5 +-
 arch/x86/include/asm/kvm_para.h                    |   4 +-
 arch/x86/kernel/kvm.c                              |  13 +-
 arch/x86/kvm/svm.c                                 |   3 +-
 arch/x86/kvm/x86.c                                 |  34 +++-
 block/blk-core.c                                   |   2 +-
 drivers/acpi/apei/einj.c                           |   2 +-
 drivers/ata/pata_amd.c                             |   1 +
 drivers/ata/pata_cs5536.c                          |   1 +
 drivers/base/bus.c                                 |   2 +-
 drivers/block/skd_main.c                           |  21 ++-
 drivers/gpu/drm/ttm/ttm_page_alloc.c               |   2 +-
 drivers/iio/accel/st_accel_core.c                  |   2 +-
 drivers/iio/magnetometer/st_magn_core.c            |   2 +-
 drivers/iio/pressure/st_pressure_core.c            |   2 +-
 drivers/infiniband/core/verbs.c                    |  44 ++++-
 drivers/infiniband/hw/mlx4/sysfs.c                 |   2 +-
 drivers/infiniband/hw/mlx5/mr.c                    |   9 +-
 drivers/infiniband/hw/qib/qib_rc.c                 |   3 +-
 drivers/infiniband/hw/usnic/usnic_fwd.c            |  12 +-
 drivers/infiniband/hw/usnic/usnic_fwd.h            |   2 +-
 drivers/infiniband/hw/usnic/usnic_ib_main.c        |  10 +-
 drivers/infiniband/hw/usnic/usnic_ib_verbs.c       |   2 +
 drivers/input/joystick/xpad.c                      | 191 ++++++++++++++++++---
 drivers/input/serio/i8042-x86ia64io.h              |   7 +
 drivers/input/tablet/gtco.c                        |  17 +-
 drivers/input/touchscreen/ucb1400_ts.c             |   4 +-
 drivers/md/bcache/bcache.h                         |   1 +
 drivers/md/bcache/request.c                        |  12 +-
 drivers/md/bcache/super.c                          |  10 +-
 drivers/md/bcache/sysfs.c                          |   4 +-
 drivers/md/bcache/util.c                           |  50 ++++--
 drivers/md/bcache/writeback.c                      |  20 ++-
 drivers/md/bcache/writeback.h                      |  21 ++-
 drivers/md/bitmap.c                                |   5 +
 drivers/media/rc/imon.c                            |   5 +
 drivers/media/usb/cx231xx/cx231xx-cards.c          |   2 +-
 drivers/media/usb/em28xx/em28xx-audio.c            |   2 +-
 drivers/media/usb/uvc/uvc_ctrl.c                   |   7 +
 drivers/media/v4l2-core/v4l2-compat-ioctl32.c      |   3 +-
 drivers/mfd/max8998.c                              |   6 +-
 drivers/mfd/omap-usb-tll.c                         |   4 +-
 drivers/net/ethernet/mellanox/mlx4/fw.c            |   2 +-
 drivers/net/usb/cdc_ether.c                        |   5 +-
 drivers/net/usb/qmi_wwan.c                         |   2 +-
 drivers/net/usb/smsc95xx.c                         |  11 +-
 drivers/net/wireless/ath/wcn36xx/main.c            |  49 +++++-
 drivers/net/wireless/ath/wcn36xx/wcn36xx.h         |   4 +
 drivers/net/wireless/iwlwifi/mvm/mac80211.c        |  11 +-
 drivers/net/wireless/iwlwifi/pcie/drv.c            |   1 +
 drivers/net/wireless/mac80211_hwsim.c              |   1 -
 drivers/pci/hotplug/shpchp_hpc.c                   |   2 +
 drivers/pwm/pwm-tiehrpwm.c                         |   5 +-
 drivers/regulator/da9063-regulator.c               |   2 +-
 drivers/rtc/rtc-sa1100.c                           |   4 +-
 drivers/s390/scsi/zfcp_dbf.c                       |  31 +++-
 drivers/s390/scsi/zfcp_dbf.h                       |  13 +-
 drivers/s390/scsi/zfcp_fc.h                        |   6 +-
 drivers/s390/scsi/zfcp_fsf.c                       |   7 +-
 drivers/s390/scsi/zfcp_scsi.c                      |  16 +-
 drivers/scsi/aacraid/aachba.c                      |  48 ++----
 drivers/scsi/mac_esp.c                             |  35 ++--
 drivers/scsi/qla2xxx/qla_attr.c                    |   8 +-
 drivers/staging/lustre/lustre/obdclass/class_obd.c |   4 +-
 drivers/staging/media/lirc/lirc_zilog.c            |   8 +-
 drivers/staging/rtl8821ae/rtl8821ae/hw.c           |   2 +-
 drivers/staging/rts5208/rtsx_scsi.c                |   2 +-
 drivers/usb/core/devio.c                           |   4 +-
 drivers/usb/core/quirks.c                          |   6 +-
 drivers/usb/host/pci-quirks.c                      |  35 ++--
 drivers/usb/serial/console.c                       |   1 +
 drivers/usb/serial/option.c                        |   1 +
 drivers/video/backlight/lm3630a_bl.c               |   5 +-
 drivers/xen/events/events_fifo.c                   |   7 +-
 fs/btrfs/super.c                                   |   3 +
 fs/dlm/user.c                                      |   4 +
 fs/f2fs/recovery.c                                 |   2 +-
 fs/fcntl.c                                         |  13 +-
 fs/xfs/xfs_log.c                                   |   7 -
 include/asm-generic/sections.h                     |  65 +++++++
 include/linux/pci_ids.h                            |   1 +
 include/linux/signal.h                             |  24 ++-
 include/net/inet_frag.h                            |  32 +---
 include/uapi/asm-generic/siginfo.h                 |   4 +-
 kernel/irq/irqdesc.c                               |  24 +--
 kernel/printk/printk.c                             |  24 ++-
 kernel/trace/trace.c                               |   2 +-
 kernel/trace/trace_selftest.c                      |   2 +-
 net/core/net-sysfs.c                               |  22 ++-
 net/ipv4/inet_fragment.c                           |   2 -
 net/ipv6/ip6_fib.c                                 |  25 ++-
 net/l2tp/l2tp_core.c                               |  41 +++--
 net/l2tp/l2tp_core.h                               |   8 +-
 net/l2tp/l2tp_eth.c                                |  11 +-
 net/l2tp/l2tp_netlink.c                            |   8 +-
 net/l2tp/l2tp_ppp.c                                |  19 +-
 net/mac80211/cfg.c                                 |   2 +
 net/mac80211/key.c                                 |  37 +++-
 net/sctp/socket.c                                  |   4 +
 net/vmw_vsock/vmci_transport.c                     | 173 +++++++++----------
 net/vmw_vsock/vmci_transport.h                     |   4 +-
 tools/perf/Documentation/Makefile                  |   2 +-
 ...st-record-no-delay =&gt; test-record-no-buffering} |   2 +-
 tools/perf/util/parse-events.c                     |   4 +-
 tools/perf/util/parse-events.h                     |   7 +-
 tools/perf/util/parse-events.y                     |  30 ++--
 128 files changed, 1145 insertions(+), 589 deletions(-)

Aleksa Sarai (1):
      btrfs: resume qgroup rescan on rw remount

Aleksandr Bezzubikov (1):
      PCI: shpchp: Enable bridge bus mastering if MSI is enabled

Alexandre Belloni (1):
      rtc: sa1100: fix unbalanced clk_prepare_enable/clk_disable_unprepare

Amir Goldstein (1):
      xfs: fix incorrect log_flushed on fsync

Andrey Korolyov (1):
      cs5536: add support for IDE controller variant

Andy Lutomirski (1):
      x86/fsgsbase/64: Report FSBASE and GSBASE correctly in core dumps

Aneesh Kumar K.V (1):
      powerpc/mm: Build fix for non SPARSEMEM_VMEMAP config

Arnaldo Carvalho de Melo (2):
      perf events parse: Rename parsing state struct to clearer name
      perf events parse: Use just one parse events state struct

Arnd Bergmann (2):
      mfd: omap-usb-tll: Fix register offsets
      IB/mlx4: fix sprintf format warning

Arvind Yadav (1):
      media: imon: Fix null-ptr-deref in imon_probe

Avraham Stern (1):
      mac80211: flush hw_roc_start work before cancelling the ROC

Baohong Liu (1):
      tracing: Apply trace_clock changes to instance max buffer

Bart Van Assche (3):
      block: Relax a check in blk_start_queue()
      skd: Avoid that module unloading triggers a use-after-free
      skd: Submit requests to firmware before triggering the doorbell

Ben Hutchings (1):
      Linux 3.16.51

Beni Lev (1):
      mac80211_hwsim: Use proper TX power

Benjamin Block (1):
      scsi: zfcp: add handling for FCP_RESID_OVER to the fcp ingress path

Bhushan Shah (1):
      backlight: lm3630a: Bump REG_MAX value to 0x50 instead of 0x1F

Bjorn Andersson (1):
      wcn36xx: Introduce mutual exclusion of fw configuration

Bjørn Mork (2):
      net: cdc_ether: fix divide by 0 on bad descriptors
      net: qmi_wwan: fix divide by 0 on bad descriptors

Boqun Feng (2):
      kvm/x86: Handle async PF in RCU read-side critical sections
      kvm/x86: Avoid async PF preempting the kernel incorrectly

Brian King (1):
      scsi: aacraid: Fix command send race condition

Cameron Gutman (2):
      Input: xpad - don&#39;t depend on endpoint order
      Input: xpad - validate USB endpoint type during probe

Christophe JAILLET (2):
      driver core: bus: Fix a potential double free
      mfd: max8998: Fix potential NULL pointer dereference

Colin Ian King (2):
      staging/rts5208: fix incorrect shift to extract upper nybble
      media: em28xx: calculate left volume level correctly

Dan Carpenter (6):
      rtlwifi: rtl8821ae: Fix HW_VAR_NAV_UPPER operation
      staging: lustre: obdclass: return -EFAULT if copy_from_user() fails
      IB/usnic: check for allocation failure
      regulator: da9063: Return an error code on probe failure
      scsi: qla2xxx: Fix an integer overflow in sysfs code
      powerpc/44x: Fix mask and shift to zero bug

Daniel Mentz (1):
      media: v4l2-compat-ioctl32: Fix timespec conversion

David Spinadel (1):
      iwlwifi: mvm: Avoid deferring non bufferable frames

Dmitry Fleytman (1):
      usb: Add device quirk for Logitech HD Pro Webcam C920-C

Dmitry Torokhov (2):
      Input: ucb1400_ts - fix suspend and resume handling
      Input: gtco - fix potential out-of-bound access

Douglas Anderson (1):
      USB: core: Avoid race of async_completed() w/ usbdev_release()

Edwin Török (1):
      dlm: avoid double-free on error path in dlm_device_{register,unregister}

Eric Dumazet (1):
      ipv6: fix typo in fib6_net_exit()

Eric W. Biederman (1):
      fcntl: Don&#39;t use ambiguous SIG_POLL si_codes

Finn Thain (1):
      scsi: mac_esp: Fix PIO transfers for MESSAGE IN phase

Guenter Roeck (1):
      media: uvcvideo: Prevent heap overflow when accessing mapped controls

Guillaume Nault (2):
      l2tp: prevent creation of sessions on terminated tunnels
      l2tp: pass tunnel pointer to -&gt;session_create()

Ilya Lesokhin (1):
      IB/mlx5: Fix integer overflow when page_shift == 31

Jaegeuk Kim (1):
      f2fs: check hot_data for roll-forward recovery

Jan H. Schönherr (1):
      KVM: SVM: Add a missing &#39;break&#39; statement

Jan Kara (1):
      bcache: Fix leak of bdev reference

Jason A. Donenfeld (1):
      mac80211: use constant time comparison with keys

Jesper Dangaard Brouer (1):
      Revert &quot;net: use lib/percpu_counter API for fragmentation mem accounting&quot;

Jia-Ju Bai (1):
      wcn36xx: Remove unnecessary rcu_read_unlock in wcn36xx_bss_info_changed

Jiri Olsa (1):
      perf tests attr: Fix no-delay test

Johan Hovold (5):
      ARM: OMAP2+: omap_device: drop broken RPM status update from suspend_noirq
      pwm: tiehrpwm: Fix runtime PM imbalance at unbind
      pwm: tiehrpwm: fix clock imbalance in probe error path
      USB: serial: console: fix use-after-free after failed setup
      cx231xx-cards: fix NULL-deref on missing association descriptor

Johannes Berg (2):
      iwlwifi: mvm: simplify bufferable MMPDU check
      mac80211: don&#39;t compare TKIP TX MIC key in reinstall prevention

Jonas Gorski (5):
      m68k: allow NULL clock for clk_get_rate
      MIPS: AR7: allow NULL clock for clk_get_rate
      MIPS: BCM63XX: allow NULL clock for clk_get_rate
      MIPS: Loongson 2F: allow NULL clock for clk_get_rate
      MIPS: ralink: allow NULL clock for clk_get_rate

Jorgen Hansen (3):
      VSOCK: sock_put wasn&#39;t safe to call in interrupt context
      VSOCK: Fix lockdep issue.
      VSOCK: Detach QP check should filter out non matching QPs.

Jose Abreu (1):
      ARC: Re-enable MMU upon Machine Check exception

Julien Grall (1):
      xen/events: events_fifo: Don&#39;t use {get,put}_cpu() in xen_evtchn_fifo_init()

Kai-Heng Feng (2):
      usb: quirks: add delay init quirk for Corsair Strafe RGB keyboard
      Input: i8042 - add Gigabyte P57 to the keyboard reset table

Konstantin Khlebnikov (1):
      perf tools: Really install manpages via &#39;make install-man&#39;

Leon Romanovsky (2):
      RDMA/usnic: Fix remove address space warning
      net/mlx4_core: Make explicit conversion to 64bit value

Lorenzo Bianconi (3):
      iio: magnetometer: st_magn_core: enable multiread by default for LIS3MDL
      iio: pressure: st_pressure: fix drdy configuration for LPS22HB and LPS25H
      iio: accel: st_accel: fix data-ready line configuration

Luca Coelho (1):
      iwlwifi: pci: add new PCI ID for 7265D

Maciej S. Szmigiero (1):
      USB: serial: option: add support for D-Link DWM-157 C1

Mark Rutland (1):
      ARM: 8692/1: mm: abort uaccess retries upon fatal signal

Martin Schwidefsky (1):
      s390/mm: fix race on mm-&gt;context.flush_mm

Matt Redfearn (6):
      printk/console: Always disable boot consoles that use init memory before it is freed
      MIPS: Handle non word sized instructions when examining frame
      MIPS: microMIPS: Fix detection of addiusp instruction
      MIPS: microMIPS: Fix decoding of addiusp instruction
      MIPS: microMIPS: Fix decoding of swsp16 instruction
      MIPS: Stacktrace: Fix microMIPS stack unwinding on big endian systems

Michael Ellerman (1):
      powerpc: Fix DAR reporting when alignment handler faults

Michael Lyle (1):
      bcache: fix bch_hprint crash and improve output

Mike Marciniszyn (1):
      IB/{qib, hfi1}: Avoid flow control testing for RDMA write operation

NeilBrown (1):
      md/bitmap: disable bitmap_resize for file-backed bitmaps.

Nisar Sayed (1):
      smsc95xx: Configure pause time to 0xffff when tx flow control enabled

Noa Osherovich (1):
      IB/core: Fix the validations of a multicast LID in attach or detach operations

Oleg Nesterov (1):
      signal: move the &quot;sig &lt; SIGRTMIN&quot; check into siginmask(sig)

Paul Mackerras (1):
      powerpc: Correct instruction code for xxlor instruction

Peter Ujfalusi (1):
      ARM: dts: dra7-evm: Rename mmc2_3v3 supply to evm_3v3_sw

Ravikumar Kattekola (1):
      ARM: dts: dra7-evm: Correct the vmmc-supply for mmc2

Rui Teng (1):
      powerpc/mm: Fix check of multiple 16G pages from device tree

Sabrina Dubroca (1):
      ipv6: fix memory leak with multiple tables during netns destruction

Sakari Ailus (1):
      media: docs-rst: v4l: Fix sink compose selection target documentation

Sandeep Singh (1):
      usb:xhci:Fix regression when ATI chipsets detected

Sean Young (1):
      media: lirc_zilog: driver only sends LIRCCODE

Slava Pestov (1):
      bcache: fix crash on shutdown in passthrough mode

Steffen Maier (6):
      scsi: zfcp: fix queuecommand for scsi_eh commands when DIX enabled
      scsi: zfcp: fix capping of unsuccessful GPN_FT SAN response trace records
      scsi: zfcp: fix passing fsf_req to SCSI trace on TMF to correlate with HBA
      scsi: zfcp: fix missing trace records for early returns in TMF eh handlers
      scsi: zfcp: fix payload with full FCP_RSP IU in SCSI trace records
      scsi: zfcp: trace HBA FSF response by default on dismiss or timedout late response

Steven Rostedt (VMware) (1):
      ftrace: Fix selftest goto location on error

Tang Junhui (5):
      bcache: fix sequential large write IO bypass
      bcache: do not subtract sectors_to_gc for bypassed IO
      bcache: correct cache_dirty_target in __update_writeback_rate()
      bcache: fix for gc and write-back race
      bcache: initialize dirty stripes in flash_dev_run()

Ted Mielczarek (1):
      Input: xpad - add support for Xbox One controllers

Thierry Reding (2):
      asm/sections: add helpers to check for section data
      printk: only unregister boot consoles when necessary

Thomas Gleixner (1):
      genirq: Make sparse_irq_lock protect what it should protect

Tony Asleson (1):
      bcache: Correct return value for sysfs attach errors

Wanpeng Li (1):
      KVM: async_pf: Fix #DF due to inject &quot;Page not Present&quot; and &quot;Page Ready&quot; exceptions simultaneously

Xiangliang.Yu (1):
      drm/ttm: Fix accounting error when fail to get pages for pool

Xin Long (1):
      sctp: do not peel off an assoc from one netns to another one

Yazen Ghannam (1):
      ACPI, APEI, EINJ: Subtract any matching Register Region from Trigger resources

stephen hemminger (1):
      net: don&#39;t decrement kobj reference count on init failure
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/DocBook/media/v4l/dev-subdev.xml b/Documentation/DocBook/media/v4l/dev-subdev.xml</span>
<span class="p_header">index d15aaf83f56f..cc4129d54890 100644</span>
<span class="p_header">--- a/Documentation/DocBook/media/v4l/dev-subdev.xml</span>
<span class="p_header">+++ b/Documentation/DocBook/media/v4l/dev-subdev.xml</span>
<span class="p_chunk">@@ -369,7 +369,7 @@</span> <span class="p_context"></span>
       underlying hardware.&lt;/para&gt;
 
       &lt;para&gt;The coordinates to a step always refer to the actual size
<span class="p_del">-      of the previous step. The exception to this rule is the source</span>
<span class="p_add">+      of the previous step. The exception to this rule is the sink</span>
       compose rectangle, which refers to the sink compose bounds
       rectangle --- if it is supported by the hardware.&lt;/para&gt;
 
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 11af06e140e2..fc9df28cecf1 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 50</span>
<span class="p_add">+SUBLEVEL = 51</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_header">diff --git a/arch/arc/kernel/entry.S b/arch/arc/kernel/entry.S</span>
<span class="p_header">index 83a046a7cd06..51b419a00def 100644</span>
<span class="p_header">--- a/arch/arc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/arc/kernel/entry.S</span>
<span class="p_chunk">@@ -315,6 +315,12 @@</span> <span class="p_context"> ENTRY(EV_MachineCheck)</span>
 	lr  r0, [efa]
 	mov r1, sp
 
<span class="p_add">+	; hardware auto-disables MMU, re-enable it to allow kernel vaddr</span>
<span class="p_add">+	; access for say stack unwinding of modules for crash dumps</span>
<span class="p_add">+	lr	r3, [ARC_REG_PID]</span>
<span class="p_add">+	or	r3, r3, MMU_ENABLE</span>
<span class="p_add">+	sr	r3, [ARC_REG_PID]</span>
<span class="p_add">+</span>
 	lsr  	r3, r2, 8
 	bmsk 	r3, r3, 7
 	brne    r3, ECR_C_MCHK_DUP_TLB, 1f
<span class="p_header">diff --git a/arch/arc/mm/tlb.c b/arch/arc/mm/tlb.c</span>
<span class="p_header">index e1acf0ce5647..f86d64990cd1 100644</span>
<span class="p_header">--- a/arch/arc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/arc/mm/tlb.c</span>
<span class="p_chunk">@@ -691,9 +691,6 @@</span> <span class="p_context"> void do_tlb_overlap_fault(unsigned long cause, unsigned long address,</span>
 
 	local_irq_save(flags);
 
<span class="p_del">-	/* re-enable the MMU */</span>
<span class="p_del">-	write_aux_reg(ARC_REG_PID, MMU_ENABLE | read_aux_reg(ARC_REG_PID));</span>
<span class="p_del">-</span>
 	/* loop thru all sets of TLB */
 	for (set = 0; set &lt; mmu-&gt;sets; set++) {
 
<span class="p_header">diff --git a/arch/arm/boot/dts/dra7-evm.dts b/arch/arm/boot/dts/dra7-evm.dts</span>
<span class="p_header">index 6944a6e9e162..1fdc6c2f2465 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dra7-evm.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dra7-evm.dts</span>
<span class="p_chunk">@@ -18,9 +18,17 @@</span> <span class="p_context"></span>
 		reg = &lt;0x80000000 0x60000000&gt;; /* 1536 MB */
 	};
 
<span class="p_del">-	mmc2_3v3: fixedregulator-mmc2 {</span>
<span class="p_add">+	evm_1v8_sw: fixedregulator-evm_1v8 {</span>
 		compatible = &quot;regulator-fixed&quot;;
<span class="p_del">-		regulator-name = &quot;mmc2_3v3&quot;;</span>
<span class="p_add">+		regulator-name = &quot;evm_1v8&quot;;</span>
<span class="p_add">+		vin-supply = &lt;&amp;smps9_reg&gt;;</span>
<span class="p_add">+		regulator-min-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+		regulator-max-microvolt = &lt;1800000&gt;;</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
<span class="p_add">+	evm_3v3_sw: fixedregulator-evm_3v3_sw {</span>
<span class="p_add">+		compatible = &quot;regulator-fixed&quot;;</span>
<span class="p_add">+		regulator-name = &quot;evm_3v3_sw&quot;;</span>
 		regulator-min-microvolt = &lt;3300000&gt;;
 		regulator-max-microvolt = &lt;3300000&gt;;
 	};
<span class="p_chunk">@@ -325,7 +333,7 @@</span> <span class="p_context"></span>
 
 &amp;mmc2 {
 	status = &quot;okay&quot;;
<span class="p_del">-	vmmc-supply = &lt;&amp;mmc2_3v3&gt;;</span>
<span class="p_add">+	vmmc-supply = &lt;&amp;evm_1v8_sw&gt;;</span>
 	bus-width = &lt;8&gt;;
 };
 
<span class="p_header">diff --git a/arch/arm/mach-omap2/omap_device.c b/arch/arm/mach-omap2/omap_device.c</span>
<span class="p_header">index 01ef59def44b..c3953b253130 100644</span>
<span class="p_header">--- a/arch/arm/mach-omap2/omap_device.c</span>
<span class="p_header">+++ b/arch/arm/mach-omap2/omap_device.c</span>
<span class="p_chunk">@@ -640,7 +640,6 @@</span> <span class="p_context"> static int _od_suspend_noirq(struct device *dev)</span>
 
 	if (!ret &amp;&amp; !pm_runtime_status_suspended(dev)) {
 		if (pm_generic_runtime_suspend(dev) == 0) {
<span class="p_del">-			pm_runtime_set_suspended(dev);</span>
 			omap_device_idle(pdev);
 			od-&gt;flags |= OMAP_DEVICE_SUSPENDED;
 		}
<span class="p_chunk">@@ -657,15 +656,6 @@</span> <span class="p_context"> static int _od_resume_noirq(struct device *dev)</span>
 	if (od-&gt;flags &amp; OMAP_DEVICE_SUSPENDED) {
 		od-&gt;flags &amp;= ~OMAP_DEVICE_SUSPENDED;
 		omap_device_enable(pdev);
<span class="p_del">-		/*</span>
<span class="p_del">-		 * XXX: we run before core runtime pm has resumed itself. At</span>
<span class="p_del">-		 * this point in time, we just restore the runtime pm state and</span>
<span class="p_del">-		 * considering symmetric operations in resume, we donot expect</span>
<span class="p_del">-		 * to fail. If we failed, something changed in core runtime_pm</span>
<span class="p_del">-		 * framework OR some device driver messed things up, hence, WARN</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		WARN(pm_runtime_set_active(dev),</span>
<span class="p_del">-		     &quot;Could not set %s runtime state active\n&quot;, dev_name(dev));</span>
 		pm_generic_runtime_resume(dev);
 	}
 
<span class="p_header">diff --git a/arch/arm/mm/fault.c b/arch/arm/mm/fault.c</span>
<span class="p_header">index eb8830a4c5ed..33f559c1c33e 100644</span>
<span class="p_header">--- a/arch/arm/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm/mm/fault.c</span>
<span class="p_chunk">@@ -315,8 +315,11 @@</span> <span class="p_context"> do_page_fault(unsigned long addr, unsigned int fsr, struct pt_regs *regs)</span>
 	 * signal first. We do not need to release the mmap_sem because
 	 * it would already be released in __lock_page_or_retry in
 	 * mm/filemap.c. */
<span class="p_del">-	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current))</span>
<span class="p_add">+	if ((fault &amp; VM_FAULT_RETRY) &amp;&amp; fatal_signal_pending(current)) {</span>
<span class="p_add">+		if (!user_mode(regs))</span>
<span class="p_add">+			goto no_context;</span>
 		return 0;
<span class="p_add">+	}</span>
 
 	/*
 	 * Major/minor page fault accounting is only done on the
<span class="p_header">diff --git a/arch/m68k/platform/coldfire/clk.c b/arch/m68k/platform/coldfire/clk.c</span>
<span class="p_header">index fddfdccae63b..9ebec9842e81 100644</span>
<span class="p_header">--- a/arch/m68k/platform/coldfire/clk.c</span>
<span class="p_header">+++ b/arch/m68k/platform/coldfire/clk.c</span>
<span class="p_chunk">@@ -117,6 +117,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(clk_put);</span>
 
 unsigned long clk_get_rate(struct clk *clk)
 {
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	return clk-&gt;rate;
 }
 EXPORT_SYMBOL(clk_get_rate);
<span class="p_header">diff --git a/arch/mips/ar7/clock.c b/arch/mips/ar7/clock.c</span>
<span class="p_header">index 2460f9d23f1b..320e5b888ad3 100644</span>
<span class="p_header">--- a/arch/mips/ar7/clock.c</span>
<span class="p_header">+++ b/arch/mips/ar7/clock.c</span>
<span class="p_chunk">@@ -430,6 +430,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(clk_disable);</span>
 
 unsigned long clk_get_rate(struct clk *clk)
 {
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	return clk-&gt;rate;
 }
 EXPORT_SYMBOL(clk_get_rate);
<span class="p_header">diff --git a/arch/mips/bcm63xx/clk.c b/arch/mips/bcm63xx/clk.c</span>
<span class="p_header">index 637565284732..6c72dd9cca14 100644</span>
<span class="p_header">--- a/arch/mips/bcm63xx/clk.c</span>
<span class="p_header">+++ b/arch/mips/bcm63xx/clk.c</span>
<span class="p_chunk">@@ -335,6 +335,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(clk_disable);</span>
 
 unsigned long clk_get_rate(struct clk *clk)
 {
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	return clk-&gt;rate;
 }
 
<span class="p_header">diff --git a/arch/mips/include/uapi/asm/inst.h b/arch/mips/include/uapi/asm/inst.h</span>
<span class="p_header">index 4bfdb9d4c186..63ce61a77216 100644</span>
<span class="p_header">--- a/arch/mips/include/uapi/asm/inst.h</span>
<span class="p_header">+++ b/arch/mips/include/uapi/asm/inst.h</span>
<span class="p_chunk">@@ -808,7 +808,7 @@</span> <span class="p_context"> struct mm16_r3_format {		/* Load from global pointer format */</span>
 struct mm16_r5_format {		/* Load/store from stack pointer format */
 	__BITFIELD_FIELD(unsigned int opcode : 6,
 	__BITFIELD_FIELD(unsigned int rt : 5,
<span class="p_del">-	__BITFIELD_FIELD(signed int simmediate : 5,</span>
<span class="p_add">+	__BITFIELD_FIELD(unsigned int imm : 5,</span>
 	__BITFIELD_FIELD(unsigned int : 16, /* Ignored */
 	;))))
 };
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index 6e90bf52b95b..dae2b8f9cd37 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -235,13 +235,13 @@</span> <span class="p_context"> static inline int is_ra_save_ins(union mips_instruction *ip, int *poff)</span>
 	 *
 	 * microMIPS is way more fun...
 	 */
<span class="p_del">-	if (mm_insn_16bit(ip-&gt;halfword[1])) {</span>
<span class="p_add">+	if (mm_insn_16bit(ip-&gt;word &gt;&gt; 16)) {</span>
 		switch (ip-&gt;mm16_r5_format.opcode) {
 		case mm_swsp16_op:
 			if (ip-&gt;mm16_r5_format.rt != 31)
 				return 0;
 
<span class="p_del">-			*poff = ip-&gt;mm16_r5_format.simmediate;</span>
<span class="p_add">+			*poff = ip-&gt;mm16_r5_format.imm;</span>
 			*poff = (*poff &lt;&lt; 2) / sizeof(ulong);
 			return 1;
 
<span class="p_chunk">@@ -314,7 +314,7 @@</span> <span class="p_context"> static inline int is_jump_ins(union mips_instruction *ip)</span>
 	 *
 	 * microMIPS is kind of more fun...
 	 */
<span class="p_del">-	if (mm_insn_16bit(ip-&gt;halfword[1])) {</span>
<span class="p_add">+	if (mm_insn_16bit(ip-&gt;word &gt;&gt; 16)) {</span>
 		if ((ip-&gt;mm16_r5_format.opcode == mm_pool16c_op &amp;&amp;
 		    (ip-&gt;mm16_r5_format.rt &amp; mm_jr16_op) == mm_jr16_op))
 			return 1;
<span class="p_chunk">@@ -351,9 +351,9 @@</span> <span class="p_context"> static inline int is_sp_move_ins(union mips_instruction *ip)</span>
 	 *
 	 * microMIPS is not more fun...
 	 */
<span class="p_del">-	if (mm_insn_16bit(ip-&gt;halfword[1])) {</span>
<span class="p_add">+	if (mm_insn_16bit(ip-&gt;word &gt;&gt; 16)) {</span>
 		return (ip-&gt;mm16_r3_format.opcode == mm_pool16d_op &amp;&amp;
<span class="p_del">-			ip-&gt;mm16_r3_format.simmediate &amp;&amp; mm_addiusp_func) ||</span>
<span class="p_add">+			ip-&gt;mm16_r3_format.simmediate &amp; mm_addiusp_func) ||</span>
 		       (ip-&gt;mm16_r5_format.opcode == mm_pool16d_op &amp;&amp;
 			ip-&gt;mm16_r5_format.rt == 29);
 	}
<span class="p_chunk">@@ -375,6 +375,7 @@</span> <span class="p_context"> static int get_frame_info(struct mips_frame_info *info)</span>
 	bool is_mmips = IS_ENABLED(CONFIG_CPU_MICROMIPS);
 	union mips_instruction insn, *ip, *ip_end;
 	const unsigned int max_insns = 128;
<span class="p_add">+	unsigned int last_insn_size = 0;</span>
 	unsigned int i;
 
 	info-&gt;pc_offset = -1;
<span class="p_chunk">@@ -386,15 +387,17 @@</span> <span class="p_context"> static int get_frame_info(struct mips_frame_info *info)</span>
 
 	ip_end = (void *)ip + info-&gt;func_size;
 
<span class="p_del">-	for (i = 0; i &lt; max_insns &amp;&amp; ip &lt; ip_end; i++, ip++) {</span>
<span class="p_add">+	for (i = 0; i &lt; max_insns &amp;&amp; ip &lt; ip_end; i++) {</span>
<span class="p_add">+		ip = (void *)ip + last_insn_size;</span>
 		if (is_mmips &amp;&amp; mm_insn_16bit(ip-&gt;halfword[0])) {
<span class="p_del">-			insn.halfword[0] = 0;</span>
<span class="p_del">-			insn.halfword[1] = ip-&gt;halfword[0];</span>
<span class="p_add">+			insn.word = ip-&gt;halfword[0] &lt;&lt; 16;</span>
<span class="p_add">+			last_insn_size = 2;</span>
 		} else if (is_mmips) {
<span class="p_del">-			insn.halfword[0] = ip-&gt;halfword[1];</span>
<span class="p_del">-			insn.halfword[1] = ip-&gt;halfword[0];</span>
<span class="p_add">+			insn.word = ip-&gt;halfword[0] &lt;&lt; 16 | ip-&gt;halfword[1];</span>
<span class="p_add">+			last_insn_size = 4;</span>
 		} else {
 			insn.word = ip-&gt;word;
<span class="p_add">+			last_insn_size = 4;</span>
 		}
 
 		if (is_jump_ins(&amp;insn))
<span class="p_chunk">@@ -404,20 +407,22 @@</span> <span class="p_context"> static int get_frame_info(struct mips_frame_info *info)</span>
 			if (is_sp_move_ins(&amp;insn))
 			{
 #ifdef CONFIG_CPU_MICROMIPS
<span class="p_del">-				if (mm_insn_16bit(ip-&gt;halfword[0]))</span>
<span class="p_add">+				if (mm_insn_16bit(insn.word &gt;&gt; 16))</span>
 				{
 					unsigned short tmp;
 
<span class="p_del">-					if (ip-&gt;halfword[0] &amp; mm_addiusp_func)</span>
<span class="p_add">+					if (ip-&gt;mm16_r3_format.simmediate &amp; mm_addiusp_func)</span>
 					{
<span class="p_del">-						tmp = (((ip-&gt;halfword[0] &gt;&gt; 1) &amp; 0x1ff) &lt;&lt; 2);</span>
<span class="p_del">-						info-&gt;frame_size = -(signed short)(tmp | ((tmp &amp; 0x100) ? 0xfe00 : 0));</span>
<span class="p_add">+						tmp = ip-&gt;mm_b0_format.simmediate &gt;&gt; 1;</span>
<span class="p_add">+						tmp = ((tmp &amp; 0x1ff) ^ 0x100) - 0x100;</span>
<span class="p_add">+						/* 0x0,0x1,0x1fe,0x1ff are special */</span>
<span class="p_add">+						if ((tmp + 2) &lt; 4)</span>
<span class="p_add">+							tmp ^= 0x100;</span>
<span class="p_add">+						info-&gt;frame_size = -(signed short)(tmp &lt;&lt; 2);</span>
 					} else {
<span class="p_del">-						tmp = (ip-&gt;halfword[0] &gt;&gt; 1);</span>
<span class="p_add">+						tmp = (ip-&gt;mm16_r5_format.imm &gt;&gt; 1);</span>
 						info-&gt;frame_size = -(signed short)(tmp &amp; 0xf);
 					}
<span class="p_del">-					ip = (void *) &amp;ip-&gt;halfword[1];</span>
<span class="p_del">-					ip--;</span>
 				} else
 #endif
 				info-&gt;frame_size = - ip-&gt;i_format.simmediate;
<span class="p_header">diff --git a/arch/mips/loongson/lemote-2f/clock.c b/arch/mips/loongson/lemote-2f/clock.c</span>
<span class="p_header">index ebfb9cd71ca1..b7b6fbf829b6 100644</span>
<span class="p_header">--- a/arch/mips/loongson/lemote-2f/clock.c</span>
<span class="p_header">+++ b/arch/mips/loongson/lemote-2f/clock.c</span>
<span class="p_chunk">@@ -80,6 +80,9 @@</span> <span class="p_context"> EXPORT_SYMBOL(clk_disable);</span>
 
 unsigned long clk_get_rate(struct clk *clk)
 {
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	return (unsigned long)clk-&gt;rate;
 }
 EXPORT_SYMBOL(clk_get_rate);
<span class="p_header">diff --git a/arch/mips/ralink/clk.c b/arch/mips/ralink/clk.c</span>
<span class="p_header">index 5d0983d47161..2ee93902990a 100644</span>
<span class="p_header">--- a/arch/mips/ralink/clk.c</span>
<span class="p_header">+++ b/arch/mips/ralink/clk.c</span>
<span class="p_chunk">@@ -52,6 +52,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(clk_disable);</span>
 
 unsigned long clk_get_rate(struct clk *clk)
 {
<span class="p_add">+	if (!clk)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	return clk-&gt;rate;
 }
 EXPORT_SYMBOL_GPL(clk_get_rate);
<span class="p_header">diff --git a/arch/powerpc/boot/4xx.c b/arch/powerpc/boot/4xx.c</span>
<span class="p_header">index 9d3bd4c45a24..f7da65169124 100644</span>
<span class="p_header">--- a/arch/powerpc/boot/4xx.c</span>
<span class="p_header">+++ b/arch/powerpc/boot/4xx.c</span>
<span class="p_chunk">@@ -564,7 +564,7 @@</span> <span class="p_context"> void ibm405gp_fixup_clocks(unsigned int sys_clk, unsigned int ser_clk)</span>
 		fbdv = 16;
 	cbdv = ((pllmr &amp; 0x00060000) &gt;&gt; 17) + 1; /* CPU:PLB */
 	opdv = ((pllmr &amp; 0x00018000) &gt;&gt; 15) + 1; /* PLB:OPB */
<span class="p_del">-	ppdv = ((pllmr &amp; 0x00001800) &gt;&gt; 13) + 1; /* PLB:PCI */</span>
<span class="p_add">+	ppdv = ((pllmr &amp; 0x00006000) &gt;&gt; 13) + 1; /* PLB:PCI */</span>
 	epdv = ((pllmr &amp; 0x00001800) &gt;&gt; 11) + 2; /* PLB:EBC */
 	udiv = ((cpc0_cr0 &amp; 0x3e) &gt;&gt; 1) + 1;
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/ppc-opcode.h b/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_header">index f47c3d9cb997..69d2dba00767 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/ppc-opcode.h</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"></span>
 #define PPC_INST_WAIT			0x7c00007c
 #define PPC_INST_TLBIVAX		0x7c000624
 #define PPC_INST_TLBSRX_DOT		0x7c0006a5
<span class="p_del">-#define PPC_INST_XXLOR			0xf0000510</span>
<span class="p_add">+#define PPC_INST_XXLOR			0xf0000490</span>
 #define PPC_INST_XXSWAPD		0xf0000250
 #define PPC_INST_XVCPSGNDP		0xf0000780
 #define PPC_INST_TRECHKPT		0x7c0007dd
<span class="p_header">diff --git a/arch/powerpc/kernel/align.c b/arch/powerpc/kernel/align.c</span>
<span class="p_header">index ce068cb2071f..aa3042044118 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/align.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/align.c</span>
<span class="p_chunk">@@ -236,6 +236,28 @@</span> <span class="p_context"> static int emulate_dcbz(struct pt_regs *regs, unsigned char __user *addr)</span>
 
 #define SWIZ_PTR(p)		((unsigned char __user *)((p) ^ swiz))
 
<span class="p_add">+#define __get_user_or_set_dar(_regs, _dest, _addr)		\</span>
<span class="p_add">+	({							\</span>
<span class="p_add">+		int rc = 0;					\</span>
<span class="p_add">+		typeof(_addr) __addr = (_addr);			\</span>
<span class="p_add">+		if (__get_user_inatomic(_dest, __addr)) {	\</span>
<span class="p_add">+			_regs-&gt;dar = (unsigned long)__addr;	\</span>
<span class="p_add">+			rc = -EFAULT;				\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+		rc;						\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
<span class="p_add">+#define __put_user_or_set_dar(_regs, _src, _addr)		\</span>
<span class="p_add">+	({							\</span>
<span class="p_add">+		int rc = 0;					\</span>
<span class="p_add">+		typeof(_addr) __addr = (_addr);			\</span>
<span class="p_add">+		if (__put_user_inatomic(_src, __addr)) {	\</span>
<span class="p_add">+			_regs-&gt;dar = (unsigned long)__addr;	\</span>
<span class="p_add">+			rc = -EFAULT;				\</span>
<span class="p_add">+		}						\</span>
<span class="p_add">+		rc;						\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
 static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,
 			    unsigned int reg, unsigned int nb,
 			    unsigned int flags, unsigned int instr,
<span class="p_chunk">@@ -264,9 +286,10 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
 		} else {
 			unsigned long pc = regs-&gt;nip ^ (swiz &amp; 4);
 
<span class="p_del">-			if (__get_user_inatomic(instr,</span>
<span class="p_del">-						(unsigned int __user *)pc))</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, instr,</span>
<span class="p_add">+						  (unsigned int __user *)pc))</span>
 				return -EFAULT;
<span class="p_add">+</span>
 			if (swiz == 0 &amp;&amp; (flags &amp; SW))
 				instr = cpu_to_le32(instr);
 			nb = (instr &gt;&gt; 11) &amp; 0x1f;
<span class="p_chunk">@@ -310,31 +333,31 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
 			       ((nb0 + 3) / 4) * sizeof(unsigned long));
 
 		for (i = 0; i &lt; nb; ++i, ++p)
<span class="p_del">-			if (__get_user_inatomic(REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_del">-						SWIZ_PTR(p)))</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+						  SWIZ_PTR(p)))</span>
 				return -EFAULT;
 		if (nb0 &gt; 0) {
 			rptr = &amp;regs-&gt;gpr[0];
 			addr += nb;
 			for (i = 0; i &lt; nb0; ++i, ++p)
<span class="p_del">-				if (__get_user_inatomic(REG_BYTE(rptr,</span>
<span class="p_del">-								 i ^ bswiz),</span>
<span class="p_del">-							SWIZ_PTR(p)))</span>
<span class="p_add">+				if (__get_user_or_set_dar(regs,</span>
<span class="p_add">+							  REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+							  SWIZ_PTR(p)))</span>
 					return -EFAULT;
 		}
 
 	} else {
 		for (i = 0; i &lt; nb; ++i, ++p)
<span class="p_del">-			if (__put_user_inatomic(REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_del">-						SWIZ_PTR(p)))</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+						  SWIZ_PTR(p)))</span>
 				return -EFAULT;
 		if (nb0 &gt; 0) {
 			rptr = &amp;regs-&gt;gpr[0];
 			addr += nb;
 			for (i = 0; i &lt; nb0; ++i, ++p)
<span class="p_del">-				if (__put_user_inatomic(REG_BYTE(rptr,</span>
<span class="p_del">-								 i ^ bswiz),</span>
<span class="p_del">-							SWIZ_PTR(p)))</span>
<span class="p_add">+				if (__put_user_or_set_dar(regs,</span>
<span class="p_add">+							  REG_BYTE(rptr, i ^ bswiz),</span>
<span class="p_add">+							  SWIZ_PTR(p)))</span>
 					return -EFAULT;
 		}
 	}
<span class="p_chunk">@@ -346,29 +369,32 @@</span> <span class="p_context"> static int emulate_multiple(struct pt_regs *regs, unsigned char __user *addr,</span>
  * Only POWER6 has these instructions, and it does true little-endian,
  * so we don&#39;t need the address swizzling.
  */
<span class="p_del">-static int emulate_fp_pair(unsigned char __user *addr, unsigned int reg,</span>
<span class="p_del">-			   unsigned int flags)</span>
<span class="p_add">+static int emulate_fp_pair(struct pt_regs *regs, unsigned char __user *addr,</span>
<span class="p_add">+			   unsigned int reg, unsigned int flags)</span>
 {
 	char *ptr0 = (char *) &amp;current-&gt;thread.TS_FPR(reg);
 	char *ptr1 = (char *) &amp;current-&gt;thread.TS_FPR(reg+1);
<span class="p_del">-	int i, ret, sw = 0;</span>
<span class="p_add">+	int i, sw = 0;</span>
 
 	if (reg &amp; 1)
 		return 0;	/* invalid form: FRS/FRT must be even */
 	if (flags &amp; SW)
 		sw = 7;
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; 8; ++i) {
 		if (!(flags &amp; ST)) {
<span class="p_del">-			ret |= __get_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __get_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		} else {
<span class="p_del">-			ret |= __put_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __put_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		}
 	}
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+</span>
 	return 1;	/* exception handled and fixed up */
 }
 
<span class="p_chunk">@@ -378,24 +404,27 @@</span> <span class="p_context"> static int emulate_lq_stq(struct pt_regs *regs, unsigned char __user *addr,</span>
 {
 	char *ptr0 = (char *)&amp;regs-&gt;gpr[reg];
 	char *ptr1 = (char *)&amp;regs-&gt;gpr[reg+1];
<span class="p_del">-	int i, ret, sw = 0;</span>
<span class="p_add">+	int i, sw = 0;</span>
 
 	if (reg &amp; 1)
 		return 0;	/* invalid form: GPR must be even */
 	if (flags &amp; SW)
 		sw = 7;
<span class="p_del">-	ret = 0;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; 8; ++i) {
 		if (!(flags &amp; ST)) {
<span class="p_del">-			ret |= __get_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __get_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		} else {
<span class="p_del">-			ret |= __put_user(ptr0[i^sw], addr + i);</span>
<span class="p_del">-			ret |= __put_user(ptr1[i^sw], addr + i + 8);</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr0[i^sw], addr + i))</span>
<span class="p_add">+				return -EFAULT;</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, ptr1[i^sw], addr + i + 8))</span>
<span class="p_add">+				return -EFAULT;</span>
 		}
 	}
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_add">+</span>
 	return 1;	/* exception handled and fixed up */
 }
 #endif /* CONFIG_PPC64 */
<span class="p_chunk">@@ -688,9 +717,14 @@</span> <span class="p_context"> static int emulate_vsx(unsigned char __user *addr, unsigned int reg,</span>
 	for (j = 0; j &lt; length; j += elsize) {
 		for (i = 0; i &lt; elsize; ++i) {
 			if (flags &amp; ST)
<span class="p_del">-				ret |= __put_user(ptr[i^sw], addr + i);</span>
<span class="p_add">+				ret = __put_user_or_set_dar(regs, ptr[i^sw],</span>
<span class="p_add">+							    addr + i);</span>
 			else
<span class="p_del">-				ret |= __get_user(ptr[i^sw], addr + i);</span>
<span class="p_add">+				ret = __get_user_or_set_dar(regs, ptr[i^sw],</span>
<span class="p_add">+							    addr + i);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (ret)</span>
<span class="p_add">+				return ret;</span>
 		}
 		ptr  += elsize;
 #ifdef __LITTLE_ENDIAN__
<span class="p_chunk">@@ -740,7 +774,7 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 	unsigned int dsisr;
 	unsigned char __user *addr;
 	unsigned long p, swiz;
<span class="p_del">-	int ret, i;</span>
<span class="p_add">+	int i;</span>
 	union data {
 		u64 ll;
 		double dd;
<span class="p_chunk">@@ -923,7 +957,7 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 		if (flags &amp; F) {
 			/* Special case for 16-byte FP loads and stores */
 			PPC_WARN_ALIGNMENT(fp_pair, regs);
<span class="p_del">-			return emulate_fp_pair(addr, reg, flags);</span>
<span class="p_add">+			return emulate_fp_pair(regs, addr, reg, flags);</span>
 		} else {
 #ifdef CONFIG_PPC64
 			/* Special case for 16-byte loads and stores */
<span class="p_chunk">@@ -953,15 +987,12 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 		}
 
 		data.ll = 0;
<span class="p_del">-		ret = 0;</span>
 		p = (unsigned long)addr;
 
 		for (i = 0; i &lt; nb; i++)
<span class="p_del">-			ret |= __get_user_inatomic(data.v[start + i],</span>
<span class="p_del">-						   SWIZ_PTR(p++));</span>
<span class="p_del">-</span>
<span class="p_del">-		if (unlikely(ret))</span>
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			if (__get_user_or_set_dar(regs, data.v[start + i],</span>
<span class="p_add">+						  SWIZ_PTR(p++)))</span>
<span class="p_add">+				return -EFAULT;</span>
 
 	} else if (flags &amp; F) {
 		data.ll = current-&gt;thread.TS_FPR(reg);
<span class="p_chunk">@@ -1031,15 +1062,13 @@</span> <span class="p_context"> int fix_alignment(struct pt_regs *regs)</span>
 			break;
 		}
 
<span class="p_del">-		ret = 0;</span>
 		p = (unsigned long)addr;
 
 		for (i = 0; i &lt; nb; i++)
<span class="p_del">-			ret |= __put_user_inatomic(data.v[start + i],</span>
<span class="p_del">-						   SWIZ_PTR(p++));</span>
<span class="p_add">+			if (__put_user_or_set_dar(regs, data.v[start + i],</span>
<span class="p_add">+						  SWIZ_PTR(p++)))</span>
<span class="p_add">+				return -EFAULT;</span>
 
<span class="p_del">-		if (unlikely(ret))</span>
<span class="p_del">-			return -EFAULT;</span>
 	} else if (flags &amp; F)
 		current-&gt;thread.TS_FPR(reg) = data.ll;
 	else
<span class="p_header">diff --git a/arch/powerpc/mm/hash_utils_64.c b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">index 8089998dbca3..084247b1b149 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/hash_utils_64.c</span>
<span class="p_chunk">@@ -433,7 +433,7 @@</span> <span class="p_context"> static int __init htab_dt_scan_hugepage_blocks(unsigned long node,</span>
 	printk(KERN_INFO &quot;Huge page(16GB) memory: &quot;
 			&quot;addr = 0x%lX size = 0x%lX pages = %d\n&quot;,
 			phys_addr, block_size, expected_pages);
<span class="p_del">-	if (phys_addr + (16 * GB) &lt;= memblock_end_of_DRAM()) {</span>
<span class="p_add">+	if (phys_addr + block_size * expected_pages &lt;= memblock_end_of_DRAM()) {</span>
 		memblock_reserve(phys_addr, block_size * expected_pages);
 		add_gpage(phys_addr, block_size, expected_pages);
 	}
<span class="p_header">diff --git a/arch/powerpc/mm/init_64.c b/arch/powerpc/mm/init_64.c</span>
<span class="p_header">index e3734edffa69..f00135abea40 100644</span>
<span class="p_header">--- a/arch/powerpc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/powerpc/mm/init_64.c</span>
<span class="p_chunk">@@ -345,7 +345,7 @@</span> <span class="p_context"> struct page *realmode_pfn_to_page(unsigned long pfn)</span>
 }
 EXPORT_SYMBOL_GPL(realmode_pfn_to_page);
 
<span class="p_del">-#elif defined(CONFIG_FLATMEM)</span>
<span class="p_add">+#else</span>
 
 struct page *realmode_pfn_to_page(unsigned long pfn)
 {
<span class="p_chunk">@@ -354,4 +354,4 @@</span> <span class="p_context"> struct page *realmode_pfn_to_page(unsigned long pfn)</span>
 }
 EXPORT_SYMBOL_GPL(realmode_pfn_to_page);
 
<span class="p_del">-#endif /* CONFIG_SPARSEMEM_VMEMMAP/CONFIG_FLATMEM */</span>
<span class="p_add">+#endif /* CONFIG_SPARSEMEM_VMEMMAP */</span>
<span class="p_header">diff --git a/arch/s390/include/asm/mmu.h b/arch/s390/include/asm/mmu.h</span>
<span class="p_header">index a5e656260a70..f3f038903860 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/mmu.h</span>
<span class="p_chunk">@@ -5,6 +5,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/errno.h&gt;
 
 typedef struct {
<span class="p_add">+	spinlock_t lock;</span>
 	cpumask_t cpu_attach_mask;
 	atomic_t attach_count;
 	unsigned int flush_mm;
<span class="p_chunk">@@ -21,6 +22,7 @@</span> <span class="p_context"> typedef struct {</span>
 } mm_context_t;
 
 #define INIT_MM_CONTEXT(name)						      \
<span class="p_add">+	.context.lock =	__SPIN_LOCK_UNLOCKED(name.context.lock),	      \</span>
 	.context.list_lock    = __SPIN_LOCK_UNLOCKED(name.context.list_lock), \
 	.context.pgtable_list = LIST_HEAD_INIT(name.context.pgtable_list),    \
 	.context.gmap_list = LIST_HEAD_INIT(name.context.gmap_list),
<span class="p_header">diff --git a/arch/s390/include/asm/mmu_context.h b/arch/s390/include/asm/mmu_context.h</span>
<span class="p_header">index d958de53d34a..db9bdd8f3223 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -15,6 +15,7 @@</span> <span class="p_context"></span>
 static inline int init_new_context(struct task_struct *tsk,
 				   struct mm_struct *mm)
 {
<span class="p_add">+	spin_lock_init(&amp;mm-&gt;context.lock);</span>
 	spin_lock_init(&amp;mm-&gt;context.list_lock);
 	INIT_LIST_HEAD(&amp;mm-&gt;context.pgtable_list);
 	INIT_LIST_HEAD(&amp;mm-&gt;context.gmap_list);
<span class="p_chunk">@@ -95,8 +96,7 @@</span> <span class="p_context"> static inline void finish_arch_post_lock_switch(void)</span>
 			cpu_relax();
 
 		cpumask_set_cpu(smp_processor_id(), mm_cpumask(mm));
<span class="p_del">-		if (mm-&gt;context.flush_mm)</span>
<span class="p_del">-			__tlb_flush_mm(mm);</span>
<span class="p_add">+		__tlb_flush_mm_lazy(mm);</span>
 		preempt_enable();
 	}
 	set_fs(current-&gt;thread.mm_segment);
<span class="p_header">diff --git a/arch/s390/include/asm/tlbflush.h b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">index 1f2fa85091ce..59949ebfa04c 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -164,10 +164,12 @@</span> <span class="p_context"> static inline void __tlb_flush_mm(struct mm_struct * mm)</span>
 
 static inline void __tlb_flush_mm_lazy(struct mm_struct * mm)
 {
<span class="p_add">+	spin_lock(&amp;mm-&gt;context.lock);</span>
 	if (mm-&gt;context.flush_mm) {
<span class="p_del">-		__tlb_flush_mm(mm);</span>
 		mm-&gt;context.flush_mm = 0;
<span class="p_add">+		__tlb_flush_mm(mm);</span>
 	}
<span class="p_add">+	spin_unlock(&amp;mm-&gt;context.lock);</span>
 }
 
 /*
<span class="p_header">diff --git a/arch/x86/include/asm/elf.h b/arch/x86/include/asm/elf.h</span>
<span class="p_header">index 2e5a79ad9061..bac0104fa3c3 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/elf.h</span>
<span class="p_chunk">@@ -203,6 +203,7 @@</span> <span class="p_context"> void set_personality_ia32(bool);</span>
 
 #define ELF_CORE_COPY_REGS(pr_reg, regs)			\
 do {								\
<span class="p_add">+	unsigned long base;					\</span>
 	unsigned v;						\
 	(pr_reg)[0] = (regs)-&gt;r15;				\
 	(pr_reg)[1] = (regs)-&gt;r14;				\
<span class="p_chunk">@@ -225,8 +226,8 @@</span> <span class="p_context"> do {								\</span>
 	(pr_reg)[18] = (regs)-&gt;flags;				\
 	(pr_reg)[19] = (regs)-&gt;sp;				\
 	(pr_reg)[20] = (regs)-&gt;ss;				\
<span class="p_del">-	(pr_reg)[21] = current-&gt;thread.fs;			\</span>
<span class="p_del">-	(pr_reg)[22] = current-&gt;thread.gs;			\</span>
<span class="p_add">+	rdmsrl(MSR_FS_BASE, base); (pr_reg)[21] = base;		\</span>
<span class="p_add">+	rdmsrl(MSR_KERNEL_GS_BASE, base); (pr_reg)[22] = base;	\</span>
 	asm(&quot;movl %%ds,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[23] = v;	\
 	asm(&quot;movl %%es,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[24] = v;	\
 	asm(&quot;movl %%fs,%0&quot; : &quot;=r&quot; (v)); (pr_reg)[25] = v;	\
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_para.h b/arch/x86/include/asm/kvm_para.h</span>
<span class="p_header">index e62cf897f781..9b06bd31db6a 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_para.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_para.h</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static inline long kvm_hypercall4(unsigned int nr, unsigned long p1,</span>
 bool kvm_para_available(void);
 unsigned int kvm_arch_para_features(void);
 void __init kvm_guest_init(void);
<span class="p_del">-void kvm_async_pf_task_wait(u32 token);</span>
<span class="p_add">+void kvm_async_pf_task_wait(u32 token, int interrupt_kernel);</span>
 void kvm_async_pf_task_wake(u32 token);
 u32 kvm_read_and_reset_pf_reason(void);
 extern void kvm_disable_steal_time(void);
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"> static inline void kvm_spinlock_init(void)</span>
 
 #else /* CONFIG_KVM_GUEST */
 #define kvm_guest_init() do {} while (0)
<span class="p_del">-#define kvm_async_pf_task_wait(T) do {} while(0)</span>
<span class="p_add">+#define kvm_async_pf_task_wait(T, I) do {} while(0)</span>
 #define kvm_async_pf_task_wake(T) do {} while(0)
 
 static inline bool kvm_para_available(void)
<span class="p_header">diff --git a/arch/x86/kernel/kvm.c b/arch/x86/kernel/kvm.c</span>
<span class="p_header">index 17cc2a2e27d6..26e265e3e8d7 100644</span>
<span class="p_header">--- a/arch/x86/kernel/kvm.c</span>
<span class="p_header">+++ b/arch/x86/kernel/kvm.c</span>
<span class="p_chunk">@@ -116,7 +116,11 @@</span> <span class="p_context"> static struct kvm_task_sleep_node *_find_apf_task(struct kvm_task_sleep_head *b,</span>
 	return NULL;
 }
 
<span class="p_del">-void kvm_async_pf_task_wait(u32 token)</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * @interrupt_kernel: Is this called from a routine which interrupts the kernel</span>
<span class="p_add">+ * 		      (other than user space)?</span>
<span class="p_add">+ */</span>
<span class="p_add">+void kvm_async_pf_task_wait(u32 token, int interrupt_kernel)</span>
 {
 	u32 key = hash_32(token, KVM_TASK_SLEEP_HASHBITS);
 	struct kvm_task_sleep_head *b = &amp;async_pf_sleepers[key];
<span class="p_chunk">@@ -139,7 +143,10 @@</span> <span class="p_context"> void kvm_async_pf_task_wait(u32 token)</span>
 
 	n.token = token;
 	n.cpu = smp_processor_id();
<span class="p_del">-	n.halted = is_idle_task(current) || preempt_count() &gt; 1;</span>
<span class="p_add">+	n.halted = is_idle_task(current) ||</span>
<span class="p_add">+		   (IS_ENABLED(CONFIG_PREEMPT_COUNT)</span>
<span class="p_add">+		    ? preempt_count() &gt; 1 || rcu_preempt_depth()</span>
<span class="p_add">+		    : interrupt_kernel);</span>
 	init_waitqueue_head(&amp;n.wq);
 	hlist_add_head(&amp;n.link, &amp;b-&gt;list);
 	spin_unlock(&amp;b-&gt;lock);
<span class="p_chunk">@@ -268,7 +275,7 @@</span> <span class="p_context"> do_async_page_fault(struct pt_regs *regs, unsigned long error_code)</span>
 		/* page is swapped out by the host. */
 		prev_state = exception_enter();
 		exit_idle();
<span class="p_del">-		kvm_async_pf_task_wait((u32)read_cr2());</span>
<span class="p_add">+		kvm_async_pf_task_wait((u32)read_cr2(), !user_mode_vm(regs));</span>
 		exception_exit(prev_state);
 		break;
 	case KVM_PV_REASON_PAGE_READY:
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index d09bc3e7882c..2003a07de9ad 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -1718,7 +1718,7 @@</span> <span class="p_context"> static int pf_interception(struct vcpu_svm *svm)</span>
 	case KVM_PV_REASON_PAGE_NOT_PRESENT:
 		svm-&gt;apf_reason = 0;
 		local_irq_disable();
<span class="p_del">-		kvm_async_pf_task_wait(fault_address);</span>
<span class="p_add">+		kvm_async_pf_task_wait(fault_address, 0);</span>
 		local_irq_enable();
 		break;
 	case KVM_PV_REASON_PAGE_READY:
<span class="p_chunk">@@ -4248,6 +4248,7 @@</span> <span class="p_context"> static int svm_check_intercept(struct kvm_vcpu *vcpu,</span>
 		 */
 		if (info-&gt;rep_prefix != REPE_PREFIX)
 			goto out;
<span class="p_add">+		break;</span>
 	case SVM_EXIT_IOIO: {
 		u64 exit_info;
 		u32 bytes;
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index d271869c488f..77edfa6d0b54 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -7561,6 +7561,13 @@</span> <span class="p_context"> static int apf_put_user(struct kvm_vcpu *vcpu, u32 val)</span>
 				      sizeof(val));
 }
 
<span class="p_add">+static int apf_get_user(struct kvm_vcpu *vcpu, u32 *val)</span>
<span class="p_add">+{</span>
<span class="p_add">+</span>
<span class="p_add">+	return kvm_read_guest_cached(vcpu-&gt;kvm, &amp;vcpu-&gt;arch.apf.data, val,</span>
<span class="p_add">+				      sizeof(u32));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void kvm_arch_async_page_not_present(struct kvm_vcpu *vcpu,
 				     struct kvm_async_pf *work)
 {
<span class="p_chunk">@@ -7587,6 +7594,7 @@</span> <span class="p_context"> void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,</span>
 				 struct kvm_async_pf *work)
 {
 	struct x86_exception fault;
<span class="p_add">+	u32 val;</span>
 
 	trace_kvm_async_pf_ready(work-&gt;arch.token, work-&gt;gva);
 	if (work-&gt;wakeup_all)
<span class="p_chunk">@@ -7594,14 +7602,24 @@</span> <span class="p_context"> void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,</span>
 	else
 		kvm_del_async_pf_gfn(vcpu, work-&gt;arch.gfn);
 
<span class="p_del">-	if ((vcpu-&gt;arch.apf.msr_val &amp; KVM_ASYNC_PF_ENABLED) &amp;&amp;</span>
<span class="p_del">-	    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {</span>
<span class="p_del">-		fault.vector = PF_VECTOR;</span>
<span class="p_del">-		fault.error_code_valid = true;</span>
<span class="p_del">-		fault.error_code = 0;</span>
<span class="p_del">-		fault.nested_page_fault = false;</span>
<span class="p_del">-		fault.address = work-&gt;arch.token;</span>
<span class="p_del">-		kvm_inject_page_fault(vcpu, &amp;fault);</span>
<span class="p_add">+	if (vcpu-&gt;arch.apf.msr_val &amp; KVM_ASYNC_PF_ENABLED &amp;&amp;</span>
<span class="p_add">+	    !apf_get_user(vcpu, &amp;val)) {</span>
<span class="p_add">+		if (val == KVM_PV_REASON_PAGE_NOT_PRESENT &amp;&amp;</span>
<span class="p_add">+		    vcpu-&gt;arch.exception.pending &amp;&amp;</span>
<span class="p_add">+		    vcpu-&gt;arch.exception.nr == PF_VECTOR &amp;&amp;</span>
<span class="p_add">+		    !apf_put_user(vcpu, 0)) {</span>
<span class="p_add">+			vcpu-&gt;arch.exception.pending = false;</span>
<span class="p_add">+			vcpu-&gt;arch.exception.nr = 0;</span>
<span class="p_add">+			vcpu-&gt;arch.exception.has_error_code = false;</span>
<span class="p_add">+			vcpu-&gt;arch.exception.error_code = 0;</span>
<span class="p_add">+		} else if (!apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {</span>
<span class="p_add">+			fault.vector = PF_VECTOR;</span>
<span class="p_add">+			fault.error_code_valid = true;</span>
<span class="p_add">+			fault.error_code = 0;</span>
<span class="p_add">+			fault.nested_page_fault = false;</span>
<span class="p_add">+			fault.address = work-&gt;arch.token;</span>
<span class="p_add">+			kvm_inject_page_fault(vcpu, &amp;fault);</span>
<span class="p_add">+		}</span>
 	}
 	vcpu-&gt;arch.apf.halted = false;
 	vcpu-&gt;arch.mp_state = KVM_MP_STATE_RUNNABLE;
<span class="p_header">diff --git a/block/blk-core.c b/block/blk-core.c</span>
<span class="p_header">index 0b4831a556fc..972e08de8ef8 100644</span>
<span class="p_header">--- a/block/blk-core.c</span>
<span class="p_header">+++ b/block/blk-core.c</span>
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"> EXPORT_SYMBOL(blk_delay_queue);</span>
  **/
 void blk_start_queue(struct request_queue *q)
 {
<span class="p_del">-	WARN_ON(!irqs_disabled());</span>
<span class="p_add">+	WARN_ON(!in_interrupt() &amp;&amp; !irqs_disabled());</span>
 
 	queue_flag_clear(QUEUE_FLAG_STOPPED, q);
 	__blk_run_queue(q);
<span class="p_header">diff --git a/drivers/acpi/apei/einj.c b/drivers/acpi/apei/einj.c</span>
<span class="p_header">index a095d4f858da..b462f846971c 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/einj.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/einj.c</span>
<span class="p_chunk">@@ -285,7 +285,7 @@</span> <span class="p_context"> static struct acpi_generic_address *einj_get_trigger_parameter_region(</span>
 		((char *)trigger_tab + sizeof(struct acpi_einj_trigger));
 	for (i = 0; i &lt; trigger_tab-&gt;entry_count; i++) {
 		if (entry-&gt;action == ACPI_EINJ_TRIGGER_ERROR &amp;&amp;
<span class="p_del">-		entry-&gt;instruction == ACPI_EINJ_WRITE_REGISTER_VALUE &amp;&amp;</span>
<span class="p_add">+		entry-&gt;instruction &lt;= ACPI_EINJ_WRITE_REGISTER_VALUE &amp;&amp;</span>
 		entry-&gt;register_region.space_id ==
 			ACPI_ADR_SPACE_SYSTEM_MEMORY &amp;&amp;
 		(entry-&gt;register_region.address &amp; param2) == (param1 &amp; param2))
<span class="p_header">diff --git a/drivers/ata/pata_amd.c b/drivers/ata/pata_amd.c</span>
<span class="p_header">index 8d4d959a821c..8706533db57b 100644</span>
<span class="p_header">--- a/drivers/ata/pata_amd.c</span>
<span class="p_header">+++ b/drivers/ata/pata_amd.c</span>
<span class="p_chunk">@@ -616,6 +616,7 @@</span> <span class="p_context"> static const struct pci_device_id amd[] = {</span>
 	{ PCI_VDEVICE(NVIDIA,	PCI_DEVICE_ID_NVIDIA_NFORCE_MCP73_IDE),	8 },
 	{ PCI_VDEVICE(NVIDIA,	PCI_DEVICE_ID_NVIDIA_NFORCE_MCP77_IDE),	8 },
 	{ PCI_VDEVICE(AMD,	PCI_DEVICE_ID_AMD_CS5536_IDE),		9 },
<span class="p_add">+	{ PCI_VDEVICE(AMD,	PCI_DEVICE_ID_AMD_CS5536_DEV_IDE),	9 },</span>
 
 	{ },
 };
<span class="p_header">diff --git a/drivers/ata/pata_cs5536.c b/drivers/ata/pata_cs5536.c</span>
<span class="p_header">index 6c15a554efbe..dc1255294628 100644</span>
<span class="p_header">--- a/drivers/ata/pata_cs5536.c</span>
<span class="p_header">+++ b/drivers/ata/pata_cs5536.c</span>
<span class="p_chunk">@@ -289,6 +289,7 @@</span> <span class="p_context"> static int cs5536_init_one(struct pci_dev *dev, const struct pci_device_id *id)</span>
 
 static const struct pci_device_id cs5536[] = {
 	{ PCI_VDEVICE(AMD,	PCI_DEVICE_ID_AMD_CS5536_IDE), },
<span class="p_add">+	{ PCI_VDEVICE(AMD,	PCI_DEVICE_ID_AMD_CS5536_DEV_IDE), },</span>
 	{ },
 };
 
<span class="p_header">diff --git a/drivers/base/bus.c b/drivers/base/bus.c</span>
<span class="p_header">index 79bc203f51ef..07ea8608fb0b 100644</span>
<span class="p_header">--- a/drivers/base/bus.c</span>
<span class="p_header">+++ b/drivers/base/bus.c</span>
<span class="p_chunk">@@ -722,7 +722,7 @@</span> <span class="p_context"> int bus_add_driver(struct device_driver *drv)</span>
 
 out_unregister:
 	kobject_put(&amp;priv-&gt;kobj);
<span class="p_del">-	kfree(drv-&gt;p);</span>
<span class="p_add">+	/* drv-&gt;p is freed in driver_release()  */</span>
 	drv-&gt;p = NULL;
 out_put_bus:
 	bus_put(bus);
<span class="p_header">diff --git a/drivers/block/skd_main.c b/drivers/block/skd_main.c</span>
<span class="p_header">index 608532d3f8c9..a07205678116 100644</span>
<span class="p_header">--- a/drivers/block/skd_main.c</span>
<span class="p_header">+++ b/drivers/block/skd_main.c</span>
<span class="p_chunk">@@ -2214,6 +2214,9 @@</span> <span class="p_context"> static void skd_send_fitmsg(struct skd_device *skdev,</span>
 		 */
 		qcmd |= FIT_QCMD_MSGSIZE_64;
 
<span class="p_add">+	/* Make sure skd_msg_buf is written before the doorbell is triggered. */</span>
<span class="p_add">+	smp_wmb();</span>
<span class="p_add">+</span>
 	SKD_WRITEQ(skdev, qcmd, FIT_Q_COMMAND);
 
 }
<span class="p_chunk">@@ -2260,6 +2263,9 @@</span> <span class="p_context"> static void skd_send_special_fitmsg(struct skd_device *skdev,</span>
 	qcmd = skspcl-&gt;mb_dma_address;
 	qcmd |= FIT_QCMD_QID_NORMAL + FIT_QCMD_MSGSIZE_128;
 
<span class="p_add">+	/* Make sure skd_msg_buf is written before the doorbell is triggered. */</span>
<span class="p_add">+	smp_wmb();</span>
<span class="p_add">+</span>
 	SKD_WRITEQ(skdev, qcmd, FIT_Q_COMMAND);
 }
 
<span class="p_chunk">@@ -4685,15 +4691,16 @@</span> <span class="p_context"> static void skd_free_disk(struct skd_device *skdev)</span>
 {
 	struct gendisk *disk = skdev-&gt;disk;
 
<span class="p_del">-	if (disk != NULL) {</span>
<span class="p_del">-		struct request_queue *q = disk-&gt;queue;</span>
<span class="p_add">+	if (disk &amp;&amp; (disk-&gt;flags &amp; GENHD_FL_UP))</span>
<span class="p_add">+		del_gendisk(disk);</span>
 
<span class="p_del">-		if (disk-&gt;flags &amp; GENHD_FL_UP)</span>
<span class="p_del">-			del_gendisk(disk);</span>
<span class="p_del">-		if (q)</span>
<span class="p_del">-			blk_cleanup_queue(q);</span>
<span class="p_del">-		put_disk(disk);</span>
<span class="p_add">+	if (skdev-&gt;queue) {</span>
<span class="p_add">+		blk_cleanup_queue(skdev-&gt;queue);</span>
<span class="p_add">+		skdev-&gt;queue = NULL;</span>
<span class="p_add">+		disk-&gt;queue = NULL;</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	put_disk(disk);</span>
 	skdev-&gt;disk = NULL;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/ttm/ttm_page_alloc.c b/drivers/gpu/drm/ttm/ttm_page_alloc.c</span>
<span class="p_header">index 76329d27385b..01631987781e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/ttm/ttm_page_alloc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/ttm/ttm_page_alloc.c</span>
<span class="p_chunk">@@ -612,7 +612,7 @@</span> <span class="p_context"> static void ttm_page_pool_fill_locked(struct ttm_page_pool *pool,</span>
 		} else {
 			pr_err(&quot;Failed to fill pool (%p)\n&quot;, pool);
 			/* If we have any pages left put them to the pool. */
<span class="p_del">-			list_for_each_entry(p, &amp;pool-&gt;list, lru) {</span>
<span class="p_add">+			list_for_each_entry(p, &amp;new_pages, lru) {</span>
 				++cpages;
 			}
 			list_splice(&amp;new_pages, &amp;pool-&gt;list);
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">index 36cb5139e48e..af621633c064 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_chunk">@@ -66,7 +66,7 @@</span> <span class="p_context"></span>
 #define ST_ACCEL_1_BDU_MASK			0x80
 #define ST_ACCEL_1_DRDY_IRQ_ADDR		0x22
 #define ST_ACCEL_1_DRDY_IRQ_INT1_MASK		0x10
<span class="p_del">-#define ST_ACCEL_1_DRDY_IRQ_INT2_MASK		0x08</span>
<span class="p_add">+#define ST_ACCEL_1_DRDY_IRQ_INT2_MASK		0x00</span>
 #define ST_ACCEL_1_MULTIREAD_BIT		true
 
 /* CUSTOM VALUES FOR SENSOR 2 */
<span class="p_header">diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">index 04ec7bae5655..844650f501a6 100644</span>
<span class="p_header">--- a/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">+++ b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_chunk">@@ -112,7 +112,7 @@</span> <span class="p_context"></span>
 #define ST_MAGN_2_FS_AVL_8000_GAIN		292
 #define ST_MAGN_2_FS_AVL_12000_GAIN		438
 #define ST_MAGN_2_FS_AVL_16000_GAIN		584
<span class="p_del">-#define ST_MAGN_2_MULTIREAD_BIT			false</span>
<span class="p_add">+#define ST_MAGN_2_MULTIREAD_BIT			true</span>
 #define ST_MAGN_2_OUT_X_L_ADDR			0x28
 #define ST_MAGN_2_OUT_Y_L_ADDR			0x2a
 #define ST_MAGN_2_OUT_Z_L_ADDR			0x2c
<span class="p_header">diff --git a/drivers/iio/pressure/st_pressure_core.c b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">index 3653d8bf2b4f..5e5dd28195f7 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_chunk">@@ -104,7 +104,7 @@</span> <span class="p_context"></span>
 #define ST_PRESS_LPS25H_BDU_MASK		0x04
 #define ST_PRESS_LPS25H_DRDY_IRQ_ADDR		0x23
 #define ST_PRESS_LPS25H_DRDY_IRQ_INT1_MASK	0x01
<span class="p_del">-#define ST_PRESS_LPS25H_DRDY_IRQ_INT2_MASK	0x10</span>
<span class="p_add">+#define ST_PRESS_LPS25H_DRDY_IRQ_INT2_MASK	0x00</span>
 #define ST_PRESS_LPS25H_MULTIREAD_BIT		true
 #define ST_PRESS_LPS25H_OUT_XL_ADDR		0x28
 #define ST_TEMP_LPS25H_OUT_L_ADDR		0x2b
<span class="p_header">diff --git a/drivers/infiniband/core/verbs.c b/drivers/infiniband/core/verbs.c</span>
<span class="p_header">index fb0a6d8f9c32..e1a5985a97bb 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/verbs.c</span>
<span class="p_chunk">@@ -1340,6 +1340,44 @@</span> <span class="p_context"> EXPORT_SYMBOL(ib_dealloc_fmr);</span>
 
 /* Multicast groups */
 
<span class="p_add">+static bool is_valid_mcast_lid(struct ib_qp *qp, u16 lid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ib_qp_init_attr init_attr = {};</span>
<span class="p_add">+	struct ib_qp_attr attr = {};</span>
<span class="p_add">+	int num_eth_ports = 0;</span>
<span class="p_add">+	int port;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If QP state &gt;= init, it is assigned to a port and we can check this</span>
<span class="p_add">+	 * port only.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!ib_query_qp(qp, &amp;attr, IB_QP_STATE | IB_QP_PORT, &amp;init_attr)) {</span>
<span class="p_add">+		if (attr.qp_state &gt;= IB_QPS_INIT) {</span>
<span class="p_add">+			if (qp-&gt;device-&gt;get_link_layer(qp-&gt;device, attr.port_num) !=</span>
<span class="p_add">+			    IB_LINK_LAYER_INFINIBAND)</span>
<span class="p_add">+				return true;</span>
<span class="p_add">+			goto lid_check;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Can&#39;t get a quick answer, iterate over all ports */</span>
<span class="p_add">+	for (port = 0; port &lt; qp-&gt;device-&gt;phys_port_cnt; port++)</span>
<span class="p_add">+		if (qp-&gt;device-&gt;get_link_layer(qp-&gt;device, port) !=</span>
<span class="p_add">+		    IB_LINK_LAYER_INFINIBAND)</span>
<span class="p_add">+			num_eth_ports++;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If we have at lease one Ethernet port, RoCE annex declares that</span>
<span class="p_add">+	 * multicast LID should be ignored. We can&#39;t tell at this step if the</span>
<span class="p_add">+	 * QP belongs to an IB or Ethernet port.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (num_eth_ports)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* If all the ports are IB, we can check according to IB spec. */</span>
<span class="p_add">+lid_check:</span>
<span class="p_add">+	return !(lid &lt; 0xC000 ||</span>
<span class="p_add">+		 lid == be16_to_cpu(IB_LID_PERMISSIVE));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int ib_attach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid)
 {
 	int ret;
<span class="p_chunk">@@ -1347,8 +1385,7 @@</span> <span class="p_context"> int ib_attach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid)</span>
 	if (!qp-&gt;device-&gt;attach_mcast)
 		return -ENOSYS;
 	if (gid-&gt;raw[0] != 0xff || qp-&gt;qp_type != IB_QPT_UD ||
<span class="p_del">-	    lid &lt; 0xC000 ||</span>
<span class="p_del">-	    lid == be16_to_cpu(IB_LID_PERMISSIVE))</span>
<span class="p_add">+	    !is_valid_mcast_lid(qp, lid))</span>
 		return -EINVAL;
 
 	ret = qp-&gt;device-&gt;attach_mcast(qp, gid, lid);
<span class="p_chunk">@@ -1365,8 +1402,7 @@</span> <span class="p_context"> int ib_detach_mcast(struct ib_qp *qp, union ib_gid *gid, u16 lid)</span>
 	if (!qp-&gt;device-&gt;detach_mcast)
 		return -ENOSYS;
 	if (gid-&gt;raw[0] != 0xff || qp-&gt;qp_type != IB_QPT_UD ||
<span class="p_del">-	    lid &lt; 0xC000 ||</span>
<span class="p_del">-	    lid == be16_to_cpu(IB_LID_PERMISSIVE))</span>
<span class="p_add">+	    !is_valid_mcast_lid(qp, lid))</span>
 		return -EINVAL;
 
 	ret = qp-&gt;device-&gt;detach_mcast(qp, gid, lid);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/sysfs.c b/drivers/infiniband/hw/mlx4/sysfs.c</span>
<span class="p_header">index 89b43da1978d..ccb35c737d9d 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/sysfs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/sysfs.c</span>
<span class="p_chunk">@@ -241,7 +241,7 @@</span> <span class="p_context"> void del_sysfs_port_mcg_attr(struct mlx4_ib_dev *device, int port_num,</span>
 static int add_port_entries(struct mlx4_ib_dev *device, int port_num)
 {
 	int i;
<span class="p_del">-	char buff[10];</span>
<span class="p_add">+	char buff[11];</span>
 	struct mlx4_ib_iov_port *port = NULL;
 	int ret = 0 ;
 	struct ib_port_attr attr;
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">index d1fd8b8f65f0..3a11876a8b7c 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_chunk">@@ -682,13 +682,14 @@</span> <span class="p_context"> struct ib_mr *mlx5_ib_get_dma_mr(struct ib_pd *pd, int acc)</span>
 	return ERR_PTR(err);
 }
 
<span class="p_del">-static int get_octo_len(u64 addr, u64 len, int page_size)</span>
<span class="p_add">+static int get_octo_len(u64 addr, u64 len, int page_shift)</span>
 {
<span class="p_add">+	u64 page_size = 1ULL &lt;&lt; page_shift;</span>
 	u64 offset;
 	int npages;
 
 	offset = addr &amp; (page_size - 1);
<span class="p_del">-	npages = ALIGN(len + offset, page_size) &gt;&gt; ilog2(page_size);</span>
<span class="p_add">+	npages = ALIGN(len + offset, page_size) &gt;&gt; page_shift;</span>
 	return (npages + 1) / 2;
 }
 
<span class="p_chunk">@@ -870,11 +871,11 @@</span> <span class="p_context"> static struct mlx5_ib_mr *reg_create(struct ib_pd *pd, u64 virt_addr,</span>
 	in-&gt;seg.start_addr = cpu_to_be64(virt_addr);
 	in-&gt;seg.len = cpu_to_be64(length);
 	in-&gt;seg.bsfs_octo_size = 0;
<span class="p_del">-	in-&gt;seg.xlt_oct_size = cpu_to_be32(get_octo_len(virt_addr, length, 1 &lt;&lt; page_shift));</span>
<span class="p_add">+	in-&gt;seg.xlt_oct_size = cpu_to_be32(get_octo_len(virt_addr, length, page_shift));</span>
 	in-&gt;seg.log2_page_size = page_shift;
 	in-&gt;seg.qpn_mkey7_0 = cpu_to_be32(0xffffff &lt;&lt; 8);
 	in-&gt;xlat_oct_act_size = cpu_to_be32(get_octo_len(virt_addr, length,
<span class="p_del">-							 1 &lt;&lt; page_shift));</span>
<span class="p_add">+							 page_shift));</span>
 	err = mlx5_core_create_mkey(&amp;dev-&gt;mdev, &amp;mr-&gt;mmr, in, inlen, NULL,
 				    NULL, NULL);
 	if (err) {
<span class="p_header">diff --git a/drivers/infiniband/hw/qib/qib_rc.c b/drivers/infiniband/hw/qib/qib_rc.c</span>
<span class="p_header">index 2f2501890c4e..d135c1cc99ac 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/qib/qib_rc.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/qib/qib_rc.c</span>
<span class="p_chunk">@@ -365,7 +365,7 @@</span> <span class="p_context"> int qib_make_rc_req(struct qib_qp *qp)</span>
 		case IB_WR_RDMA_WRITE:
 			if (newreq &amp;&amp; !(qp-&gt;s_flags &amp; QIB_S_UNLIMITED_CREDIT))
 				qp-&gt;s_lsn++;
<span class="p_del">-			/* FALLTHROUGH */</span>
<span class="p_add">+			goto no_flow_control;</span>
 		case IB_WR_RDMA_WRITE_WITH_IMM:
 			/* If no credit, return. */
 			if (!(qp-&gt;s_flags &amp; QIB_S_UNLIMITED_CREDIT) &amp;&amp;
<span class="p_chunk">@@ -373,6 +373,7 @@</span> <span class="p_context"> int qib_make_rc_req(struct qib_qp *qp)</span>
 				qp-&gt;s_flags |= QIB_S_WAIT_SSN_CREDIT;
 				goto bail;
 			}
<span class="p_add">+no_flow_control:</span>
 			ohdr-&gt;u.rc.reth.vaddr =
 				cpu_to_be64(wqe-&gt;wr.wr.rdma.remote_addr);
 			ohdr-&gt;u.rc.reth.rkey =
<span class="p_header">diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.c b/drivers/infiniband/hw/usnic/usnic_fwd.c</span>
<span class="p_header">index e3c9bd9d3ba3..e5ec9cda0833 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/usnic/usnic_fwd.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/usnic/usnic_fwd.c</span>
<span class="p_chunk">@@ -95,20 +95,12 @@</span> <span class="p_context"> void usnic_fwd_set_mac(struct usnic_fwd_dev *ufdev, char mac[ETH_ALEN])</span>
 	spin_unlock(&amp;ufdev-&gt;lock);
 }
 
<span class="p_del">-int usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr)</span>
<span class="p_add">+void usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr)</span>
 {
<span class="p_del">-	int status;</span>
<span class="p_del">-</span>
 	spin_lock(&amp;ufdev-&gt;lock);
<span class="p_del">-	if (ufdev-&gt;inaddr == 0) {</span>
<span class="p_add">+	if (!ufdev-&gt;inaddr)</span>
 		ufdev-&gt;inaddr = inaddr;
<span class="p_del">-		status = 0;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		status = -EFAULT;</span>
<span class="p_del">-	}</span>
 	spin_unlock(&amp;ufdev-&gt;lock);
<span class="p_del">-</span>
<span class="p_del">-	return status;</span>
 }
 
 void usnic_fwd_del_ipaddr(struct usnic_fwd_dev *ufdev)
<span class="p_header">diff --git a/drivers/infiniband/hw/usnic/usnic_fwd.h b/drivers/infiniband/hw/usnic/usnic_fwd.h</span>
<span class="p_header">index 93713a2230b3..570dcdcb06e3 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/usnic/usnic_fwd.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/usnic/usnic_fwd.h</span>
<span class="p_chunk">@@ -59,7 +59,7 @@</span> <span class="p_context"> struct usnic_fwd_dev *usnic_fwd_dev_alloc(struct pci_dev *pdev);</span>
 void usnic_fwd_dev_free(struct usnic_fwd_dev *ufdev);
 
 void usnic_fwd_set_mac(struct usnic_fwd_dev *ufdev, char mac[ETH_ALEN]);
<span class="p_del">-int usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr);</span>
<span class="p_add">+void usnic_fwd_add_ipaddr(struct usnic_fwd_dev *ufdev, __be32 inaddr);</span>
 void usnic_fwd_del_ipaddr(struct usnic_fwd_dev *ufdev);
 void usnic_fwd_carrier_up(struct usnic_fwd_dev *ufdev);
 void usnic_fwd_carrier_down(struct usnic_fwd_dev *ufdev);
<span class="p_header">diff --git a/drivers/infiniband/hw/usnic/usnic_ib_main.c b/drivers/infiniband/hw/usnic/usnic_ib_main.c</span>
<span class="p_header">index fb6d026f92cd..e5e9aa05dea5 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/usnic/usnic_ib_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/usnic/usnic_ib_main.c</span>
<span class="p_chunk">@@ -305,7 +305,7 @@</span> <span class="p_context"> static void *usnic_ib_device_add(struct pci_dev *dev)</span>
 {
 	struct usnic_ib_dev *us_ibdev;
 	union ib_gid gid;
<span class="p_del">-	struct in_ifaddr *in;</span>
<span class="p_add">+	struct in_device *ind;</span>
 	struct net_device *netdev;
 
 	usnic_dbg(&quot;\n&quot;);
<span class="p_chunk">@@ -393,9 +393,11 @@</span> <span class="p_context"> static void *usnic_ib_device_add(struct pci_dev *dev)</span>
 	if (netif_carrier_ok(us_ibdev-&gt;netdev))
 		usnic_fwd_carrier_up(us_ibdev-&gt;ufdev);
 
<span class="p_del">-	in = ((struct in_device *)(netdev-&gt;ip_ptr))-&gt;ifa_list;</span>
<span class="p_del">-	if (in != NULL)</span>
<span class="p_del">-		usnic_fwd_add_ipaddr(us_ibdev-&gt;ufdev, in-&gt;ifa_address);</span>
<span class="p_add">+	ind = in_dev_get(netdev);</span>
<span class="p_add">+	if (ind-&gt;ifa_list)</span>
<span class="p_add">+		usnic_fwd_add_ipaddr(us_ibdev-&gt;ufdev,</span>
<span class="p_add">+				     ind-&gt;ifa_list-&gt;ifa_address);</span>
<span class="p_add">+	in_dev_put(ind);</span>
 
 	usnic_mac_ip_to_gid(us_ibdev-&gt;netdev-&gt;perm_addr,
 				us_ibdev-&gt;ufdev-&gt;inaddr, &amp;gid.raw[0]);
<span class="p_header">diff --git a/drivers/infiniband/hw/usnic/usnic_ib_verbs.c b/drivers/infiniband/hw/usnic/usnic_ib_verbs.c</span>
<span class="p_header">index 53bd6a2d9cdb..806432ad21bf 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/usnic/usnic_ib_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/usnic/usnic_ib_verbs.c</span>
<span class="p_chunk">@@ -148,6 +148,8 @@</span> <span class="p_context"> find_free_vf_and_create_qp_grp(struct usnic_ib_dev *us_ibdev,</span>
 	if (usnic_ib_share_vf) {
 		/* Try to find resouces on a used vf which is in pd */
 		dev_list = usnic_uiom_get_dev_list(pd-&gt;umem_pd);
<span class="p_add">+		if (IS_ERR(dev_list))</span>
<span class="p_add">+			return ERR_CAST(dev_list);</span>
 		for (i = 0; dev_list[i]; i++) {
 			dev = dev_list[i];
 			vf = pci_get_drvdata(to_pci_dev(dev));
<span class="p_header">diff --git a/drivers/input/joystick/xpad.c b/drivers/input/joystick/xpad.c</span>
<span class="p_header">index a137a3738128..b76334b5bf83 100644</span>
<span class="p_header">--- a/drivers/input/joystick/xpad.c</span>
<span class="p_header">+++ b/drivers/input/joystick/xpad.c</span>
<span class="p_chunk">@@ -95,7 +95,8 @@</span> <span class="p_context"></span>
 #define XTYPE_XBOX        0
 #define XTYPE_XBOX360     1
 #define XTYPE_XBOX360W    2
<span class="p_del">-#define XTYPE_UNKNOWN     3</span>
<span class="p_add">+#define XTYPE_XBOXONE     3</span>
<span class="p_add">+#define XTYPE_UNKNOWN     4</span>
 
 static bool dpad_to_buttons;
 module_param(dpad_to_buttons, bool, S_IRUGO);
<span class="p_chunk">@@ -121,6 +122,7 @@</span> <span class="p_context"> static const struct xpad_device {</span>
 	{ 0x045e, 0x0287, &quot;Microsoft Xbox Controller S&quot;, 0, XTYPE_XBOX },
 	{ 0x045e, 0x0289, &quot;Microsoft X-Box pad v2 (US)&quot;, 0, XTYPE_XBOX },
 	{ 0x045e, 0x028e, &quot;Microsoft X-Box 360 pad&quot;, 0, XTYPE_XBOX360 },
<span class="p_add">+	{ 0x045e, 0x02d1, &quot;Microsoft X-Box One pad&quot;, 0, XTYPE_XBOXONE },</span>
 	{ 0x045e, 0x0291, &quot;Xbox 360 Wireless Receiver (XBOX)&quot;, MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
 	{ 0x045e, 0x0719, &quot;Xbox 360 Wireless Receiver&quot;, MAP_DPAD_TO_BUTTONS, XTYPE_XBOX360W },
 	{ 0x044f, 0x0f07, &quot;Thrustmaster, Inc. Controller&quot;, 0, XTYPE_XBOX },
<span class="p_chunk">@@ -263,10 +265,12 @@</span> <span class="p_context"> static const signed short xpad_abs_triggers[] = {</span>
 	-1
 };
 
<span class="p_del">-/* Xbox 360 has a vendor-specific class, so we cannot match it with only</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Xbox 360 has a vendor-specific class, so we cannot match it with only</span>
  * USB_INTERFACE_INFO (also specifically refused by USB subsystem), so we
  * match against vendor id as well. Wired Xbox 360 devices have protocol 1,
<span class="p_del">- * wireless controllers have protocol 129. */</span>
<span class="p_add">+ * wireless controllers have protocol 129.</span>
<span class="p_add">+ */</span>
 #define XPAD_XBOX360_VENDOR_PROTOCOL(vend,pr) \
 	.match_flags = USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_INT_INFO, \
 	.idVendor = (vend), \
<span class="p_chunk">@@ -277,9 +281,20 @@</span> <span class="p_context"> static const signed short xpad_abs_triggers[] = {</span>
 	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend,1) }, \
 	{ XPAD_XBOX360_VENDOR_PROTOCOL(vend,129) }
 
<span class="p_add">+/* The Xbox One controller uses subclass 71 and protocol 208. */</span>
<span class="p_add">+#define XPAD_XBOXONE_VENDOR_PROTOCOL(vend, pr) \</span>
<span class="p_add">+	.match_flags = USB_DEVICE_ID_MATCH_VENDOR | USB_DEVICE_ID_MATCH_INT_INFO, \</span>
<span class="p_add">+	.idVendor = (vend), \</span>
<span class="p_add">+	.bInterfaceClass = USB_CLASS_VENDOR_SPEC, \</span>
<span class="p_add">+	.bInterfaceSubClass = 71, \</span>
<span class="p_add">+	.bInterfaceProtocol = (pr)</span>
<span class="p_add">+#define XPAD_XBOXONE_VENDOR(vend) \</span>
<span class="p_add">+	{ XPAD_XBOXONE_VENDOR_PROTOCOL(vend, 208) }</span>
<span class="p_add">+</span>
 static struct usb_device_id xpad_table[] = {
 	{ USB_INTERFACE_INFO(&#39;X&#39;, &#39;B&#39;, 0) },	/* X-Box USB-IF not approved class */
 	XPAD_XBOX360_VENDOR(0x045e),		/* Microsoft X-Box 360 controllers */
<span class="p_add">+	XPAD_XBOXONE_VENDOR(0x045e),		/* Microsoft X-Box One controllers */</span>
 	XPAD_XBOX360_VENDOR(0x046d),		/* Logitech X-Box 360 style controllers */
 	XPAD_XBOX360_VENDOR(0x0738),		/* Mad Catz X-Box 360 controllers */
 	{ USB_DEVICE(0x0738, 0x4540) },		/* Mad Catz Beat Pad */
<span class="p_chunk">@@ -313,12 +328,10 @@</span> <span class="p_context"> struct usb_xpad {</span>
 	struct urb *bulk_out;
 	unsigned char *bdata;
 
<span class="p_del">-#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)</span>
 	struct urb *irq_out;		/* urb for interrupt out report */
 	unsigned char *odata;		/* output data */
 	dma_addr_t odata_dma;
 	struct mutex odata_mutex;
<span class="p_del">-#endif</span>
 
 #if defined(CONFIG_JOYSTICK_XPAD_LEDS)
 	struct xpad_led *led;
<span class="p_chunk">@@ -509,6 +522,105 @@</span> <span class="p_context"> static void xpad360w_process_packet(struct usb_xpad *xpad, u16 cmd, unsigned cha</span>
 	xpad360_process_packet(xpad, cmd, &amp;data[4]);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ *	xpadone_process_buttons</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Process a button update packet from an Xbox one controller.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void xpadone_process_buttons(struct usb_xpad *xpad,</span>
<span class="p_add">+				struct input_dev *dev,</span>
<span class="p_add">+				unsigned char *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* menu/view buttons */</span>
<span class="p_add">+	input_report_key(dev, BTN_START,  data[4] &amp; 0x04);</span>
<span class="p_add">+	input_report_key(dev, BTN_SELECT, data[4] &amp; 0x08);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* buttons A,B,X,Y */</span>
<span class="p_add">+	input_report_key(dev, BTN_A,	data[4] &amp; 0x10);</span>
<span class="p_add">+	input_report_key(dev, BTN_B,	data[4] &amp; 0x20);</span>
<span class="p_add">+	input_report_key(dev, BTN_X,	data[4] &amp; 0x40);</span>
<span class="p_add">+	input_report_key(dev, BTN_Y,	data[4] &amp; 0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* digital pad */</span>
<span class="p_add">+	if (xpad-&gt;mapping &amp; MAP_DPAD_TO_BUTTONS) {</span>
<span class="p_add">+		/* dpad as buttons (left, right, up, down) */</span>
<span class="p_add">+		input_report_key(dev, BTN_TRIGGER_HAPPY1, data[5] &amp; 0x04);</span>
<span class="p_add">+		input_report_key(dev, BTN_TRIGGER_HAPPY2, data[5] &amp; 0x08);</span>
<span class="p_add">+		input_report_key(dev, BTN_TRIGGER_HAPPY3, data[5] &amp; 0x01);</span>
<span class="p_add">+		input_report_key(dev, BTN_TRIGGER_HAPPY4, data[5] &amp; 0x02);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		input_report_abs(dev, ABS_HAT0X,</span>
<span class="p_add">+				 !!(data[5] &amp; 0x08) - !!(data[5] &amp; 0x04));</span>
<span class="p_add">+		input_report_abs(dev, ABS_HAT0Y,</span>
<span class="p_add">+				 !!(data[5] &amp; 0x02) - !!(data[5] &amp; 0x01));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* TL/TR */</span>
<span class="p_add">+	input_report_key(dev, BTN_TL,	data[5] &amp; 0x10);</span>
<span class="p_add">+	input_report_key(dev, BTN_TR,	data[5] &amp; 0x20);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* stick press left/right */</span>
<span class="p_add">+	input_report_key(dev, BTN_THUMBL, data[5] &amp; 0x40);</span>
<span class="p_add">+	input_report_key(dev, BTN_THUMBR, data[5] &amp; 0x80);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(xpad-&gt;mapping &amp; MAP_STICKS_TO_NULL)) {</span>
<span class="p_add">+		/* left stick */</span>
<span class="p_add">+		input_report_abs(dev, ABS_X,</span>
<span class="p_add">+				 (__s16) le16_to_cpup((__le16 *)(data + 10)));</span>
<span class="p_add">+		input_report_abs(dev, ABS_Y,</span>
<span class="p_add">+				 ~(__s16) le16_to_cpup((__le16 *)(data + 12)));</span>
<span class="p_add">+</span>
<span class="p_add">+		/* right stick */</span>
<span class="p_add">+		input_report_abs(dev, ABS_RX,</span>
<span class="p_add">+				 (__s16) le16_to_cpup((__le16 *)(data + 14)));</span>
<span class="p_add">+		input_report_abs(dev, ABS_RY,</span>
<span class="p_add">+				 ~(__s16) le16_to_cpup((__le16 *)(data + 16)));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* triggers left/right */</span>
<span class="p_add">+	if (xpad-&gt;mapping &amp; MAP_TRIGGERS_TO_BUTTONS) {</span>
<span class="p_add">+		input_report_key(dev, BTN_TL2,</span>
<span class="p_add">+				 (__u16) le16_to_cpup((__le16 *)(data + 6)));</span>
<span class="p_add">+		input_report_key(dev, BTN_TR2,</span>
<span class="p_add">+				 (__u16) le16_to_cpup((__le16 *)(data + 8)));</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		input_report_abs(dev, ABS_Z,</span>
<span class="p_add">+				 (__u16) le16_to_cpup((__le16 *)(data + 6)));</span>
<span class="p_add">+		input_report_abs(dev, ABS_RZ,</span>
<span class="p_add">+				 (__u16) le16_to_cpup((__le16 *)(data + 8)));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	input_sync(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ *	xpadone_process_packet</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Completes a request by converting the data into events for the</span>
<span class="p_add">+ *	input subsystem. This version is for the Xbox One controller.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	The report format was gleaned from</span>
<span class="p_add">+ *	https://github.com/kylelemons/xbox/blob/master/xbox.go</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+static void xpadone_process_packet(struct usb_xpad *xpad,</span>
<span class="p_add">+				u16 cmd, unsigned char *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct input_dev *dev = xpad-&gt;dev;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (data[0]) {</span>
<span class="p_add">+	case 0x20:</span>
<span class="p_add">+		xpadone_process_buttons(xpad, dev, data);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
<span class="p_add">+	case 0x07:</span>
<span class="p_add">+		/* the xbox button has its own special report */</span>
<span class="p_add">+		input_report_key(dev, BTN_MODE, data[4] &amp; 0x01);</span>
<span class="p_add">+		input_sync(dev);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void xpad_irq_in(struct urb *urb)
 {
 	struct usb_xpad *xpad = urb-&gt;context;
<span class="p_chunk">@@ -541,6 +653,9 @@</span> <span class="p_context"> static void xpad_irq_in(struct urb *urb)</span>
 	case XTYPE_XBOX360W:
 		xpad360w_process_packet(xpad, 0, xpad-&gt;idata);
 		break;
<span class="p_add">+	case XTYPE_XBOXONE:</span>
<span class="p_add">+		xpadone_process_packet(xpad, 0, xpad-&gt;idata);</span>
<span class="p_add">+		break;</span>
 	default:
 		xpad_process_packet(xpad, 0, xpad-&gt;idata);
 	}
<span class="p_chunk">@@ -574,7 +689,6 @@</span> <span class="p_context"> static void xpad_bulk_out(struct urb *urb)</span>
 	}
 }
 
<span class="p_del">-#if defined(CONFIG_JOYSTICK_XPAD_FF) || defined(CONFIG_JOYSTICK_XPAD_LEDS)</span>
 static void xpad_irq_out(struct urb *urb)
 {
 	struct usb_xpad *xpad = urb-&gt;context;
<span class="p_chunk">@@ -609,9 +723,9 @@</span> <span class="p_context"> static void xpad_irq_out(struct urb *urb)</span>
 			__func__, retval);
 }
 
<span class="p_del">-static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)</span>
<span class="p_add">+static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad,</span>
<span class="p_add">+			struct usb_endpoint_descriptor *ep_irq_out)</span>
 {
<span class="p_del">-	struct usb_endpoint_descriptor *ep_irq_out;</span>
 	int error;
 
 	if (xpad-&gt;xtype == XTYPE_UNKNOWN)
<span class="p_chunk">@@ -632,7 +746,6 @@</span> <span class="p_context"> static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad)</span>
 		goto fail2;
 	}
 
<span class="p_del">-	ep_irq_out = &amp;intf-&gt;cur_altsetting-&gt;endpoint[1].desc;</span>
 	usb_fill_int_urb(xpad-&gt;irq_out, xpad-&gt;udev,
 			 usb_sndintpipe(xpad-&gt;udev, ep_irq_out-&gt;bEndpointAddress),
 			 xpad-&gt;odata, XPAD_PKT_LEN,
<span class="p_chunk">@@ -660,11 +773,6 @@</span> <span class="p_context"> static void xpad_deinit_output(struct usb_xpad *xpad)</span>
 				xpad-&gt;odata, xpad-&gt;odata_dma);
 	}
 }
<span class="p_del">-#else</span>
<span class="p_del">-static int xpad_init_output(struct usb_interface *intf, struct usb_xpad *xpad) { return 0; }</span>
<span class="p_del">-static void xpad_deinit_output(struct usb_xpad *xpad) {}</span>
<span class="p_del">-static void xpad_stop_output(struct usb_xpad *xpad) {}</span>
<span class="p_del">-#endif</span>
 
 #ifdef CONFIG_JOYSTICK_XPAD_FF
 static int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect *effect)
<span class="p_chunk">@@ -731,7 +839,7 @@</span> <span class="p_context"> static int xpad_play_effect(struct input_dev *dev, void *data, struct ff_effect</span>
 
 static int xpad_init_ff(struct usb_xpad *xpad)
 {
<span class="p_del">-	if (xpad-&gt;xtype == XTYPE_UNKNOWN)</span>
<span class="p_add">+	if (xpad-&gt;xtype == XTYPE_UNKNOWN || xpad-&gt;xtype == XTYPE_XBOXONE)</span>
 		return 0;
 
 	input_set_capability(xpad-&gt;dev, EV_FF, FF_RUMBLE);
<span class="p_chunk">@@ -840,6 +948,14 @@</span> <span class="p_context"> static int xpad_open(struct input_dev *dev)</span>
 	if (usb_submit_urb(xpad-&gt;irq_in, GFP_KERNEL))
 		return -EIO;
 
<span class="p_add">+	if (xpad-&gt;xtype == XTYPE_XBOXONE) {</span>
<span class="p_add">+		/* Xbox one controller needs to be initialized. */</span>
<span class="p_add">+		xpad-&gt;odata[0] = 0x05;</span>
<span class="p_add">+		xpad-&gt;odata[1] = 0x20;</span>
<span class="p_add">+		xpad-&gt;irq_out-&gt;transfer_buffer_length = 2;</span>
<span class="p_add">+		return usb_submit_urb(xpad-&gt;irq_out, GFP_KERNEL);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -855,6 +971,7 @@</span> <span class="p_context"> static void xpad_close(struct input_dev *dev)</span>
 
 static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)
 {
<span class="p_add">+	struct usb_xpad *xpad = input_get_drvdata(input_dev);</span>
 	set_bit(abs, input_dev-&gt;absbit);
 
 	switch (abs) {
<span class="p_chunk">@@ -866,7 +983,10 @@</span> <span class="p_context"> static void xpad_set_up_abs(struct input_dev *input_dev, signed short abs)</span>
 		break;
 	case ABS_Z:
 	case ABS_RZ:	/* the triggers (if mapped to axes) */
<span class="p_del">-		input_set_abs_params(input_dev, abs, 0, 255, 0, 0);</span>
<span class="p_add">+		if (xpad-&gt;xtype == XTYPE_XBOXONE)</span>
<span class="p_add">+			input_set_abs_params(input_dev, abs, 0, 1023, 0, 0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			input_set_abs_params(input_dev, abs, 0, 255, 0, 0);</span>
 		break;
 	case ABS_HAT0X:
 	case ABS_HAT0Y:	/* the d-pad (only if dpad is mapped to axes */
<span class="p_chunk">@@ -880,7 +1000,7 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	struct usb_device *udev = interface_to_usbdev(intf);
 	struct usb_xpad *xpad;
 	struct input_dev *input_dev;
<span class="p_del">-	struct usb_endpoint_descriptor *ep_irq_in;</span>
<span class="p_add">+	struct usb_endpoint_descriptor *ep_irq_in, *ep_irq_out;</span>
 	int i, error;
 
 	if (intf-&gt;cur_altsetting-&gt;desc.bNumEndpoints != 2)
<span class="p_chunk">@@ -892,6 +1012,16 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 			break;
 	}
 
<span class="p_add">+	if (xpad_device[i].xtype == XTYPE_XBOXONE &amp;&amp;</span>
<span class="p_add">+	    intf-&gt;cur_altsetting-&gt;desc.bInterfaceNumber != 0) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The Xbox One controller lists three interfaces all with the</span>
<span class="p_add">+		 * same interface class, subclass and protocol. Differentiate by</span>
<span class="p_add">+		 * interface number.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	xpad = kzalloc(sizeof(struct usb_xpad), GFP_KERNEL);
 	input_dev = input_allocate_device();
 	if (!xpad || !input_dev) {
<span class="p_chunk">@@ -962,7 +1092,8 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 		__set_bit(xpad_common_btn[i], input_dev-&gt;keybit);
 
 	/* set up model-specific ones */
<span class="p_del">-	if (xpad-&gt;xtype == XTYPE_XBOX360 || xpad-&gt;xtype == XTYPE_XBOX360W) {</span>
<span class="p_add">+	if (xpad-&gt;xtype == XTYPE_XBOX360 || xpad-&gt;xtype == XTYPE_XBOX360W ||</span>
<span class="p_add">+	    xpad-&gt;xtype == XTYPE_XBOXONE) {</span>
 		for (i = 0; xpad360_btn[i] &gt;= 0; i++)
 			__set_bit(xpad360_btn[i], input_dev-&gt;keybit);
 	} else {
<span class="p_chunk">@@ -975,7 +1106,7 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 			__set_bit(xpad_btn_pad[i], input_dev-&gt;keybit);
 	} else {
 		for (i = 0; xpad_abs_pad[i] &gt;= 0; i++)
<span class="p_del">-		    xpad_set_up_abs(input_dev, xpad_abs_pad[i]);</span>
<span class="p_add">+			xpad_set_up_abs(input_dev, xpad_abs_pad[i]);</span>
 	}
 
 	if (xpad-&gt;mapping &amp; MAP_TRIGGERS_TO_BUTTONS) {
<span class="p_chunk">@@ -986,7 +1117,26 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 			xpad_set_up_abs(input_dev, xpad_abs_triggers[i]);
 	}
 
<span class="p_del">-	error = xpad_init_output(intf, xpad);</span>
<span class="p_add">+	ep_irq_in = ep_irq_out = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		struct usb_endpoint_descriptor *ep =</span>
<span class="p_add">+				&amp;intf-&gt;cur_altsetting-&gt;endpoint[i].desc;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (usb_endpoint_xfer_int(ep)) {</span>
<span class="p_add">+			if (usb_endpoint_dir_in(ep))</span>
<span class="p_add">+				ep_irq_in = ep;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				ep_irq_out = ep;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!ep_irq_in || !ep_irq_out) {</span>
<span class="p_add">+		error = -ENODEV;</span>
<span class="p_add">+		goto fail3;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	error = xpad_init_output(intf, xpad, ep_irq_out);</span>
 	if (error)
 		goto fail3;
 
<span class="p_chunk">@@ -998,7 +1148,6 @@</span> <span class="p_context"> static int xpad_probe(struct usb_interface *intf, const struct usb_device_id *id</span>
 	if (error)
 		goto fail5;
 
<span class="p_del">-	ep_irq_in = &amp;intf-&gt;cur_altsetting-&gt;endpoint[0].desc;</span>
 	usb_fill_int_urb(xpad-&gt;irq_in, udev,
 			 usb_rcvintpipe(udev, ep_irq_in-&gt;bEndpointAddress),
 			 xpad-&gt;idata, XPAD_PKT_LEN, xpad_irq_in,
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index fda2742f01e6..822d3f6e666b 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -803,6 +803,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_kbdreset_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P34&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Gigabyte P57 - Elantech touchpad */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;GIGABYTE&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P57&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{
 		/* Schenker XMG C504 - Elantech touchpad */
 		.matches = {
<span class="p_header">diff --git a/drivers/input/tablet/gtco.c b/drivers/input/tablet/gtco.c</span>
<span class="p_header">index a51de543a0b2..fe1ab5067b5d 100644</span>
<span class="p_header">--- a/drivers/input/tablet/gtco.c</span>
<span class="p_header">+++ b/drivers/input/tablet/gtco.c</span>
<span class="p_chunk">@@ -231,13 +231,17 @@</span> <span class="p_context"> static void parse_hid_report_descriptor(struct gtco *device, char * report,</span>
 
 	/* Walk  this report and pull out the info we need */
 	while (i &lt; length) {
<span class="p_del">-		prefix = report[i];</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Skip over prefix */</span>
<span class="p_del">-		i++;</span>
<span class="p_add">+		prefix = report[i++];</span>
 
 		/* Determine data size and save the data in the proper variable */
<span class="p_del">-		size = PREF_SIZE(prefix);</span>
<span class="p_add">+		size = (1U &lt;&lt; PREF_SIZE(prefix)) &gt;&gt; 1;</span>
<span class="p_add">+		if (i + size &gt; length) {</span>
<span class="p_add">+			dev_err(ddev,</span>
<span class="p_add">+				&quot;Not enough data (need %d, have %d)\n&quot;,</span>
<span class="p_add">+				i + size, length);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		switch (size) {
 		case 1:
 			data = report[i];
<span class="p_chunk">@@ -245,8 +249,7 @@</span> <span class="p_context"> static void parse_hid_report_descriptor(struct gtco *device, char * report,</span>
 		case 2:
 			data16 = get_unaligned_le16(&amp;report[i]);
 			break;
<span class="p_del">-		case 3:</span>
<span class="p_del">-			size = 4;</span>
<span class="p_add">+		case 4:</span>
 			data32 = get_unaligned_le32(&amp;report[i]);
 			break;
 		}
<span class="p_header">diff --git a/drivers/input/touchscreen/ucb1400_ts.c b/drivers/input/touchscreen/ucb1400_ts.c</span>
<span class="p_header">index b46c55cd1bbb..85e510b28a32 100644</span>
<span class="p_header">--- a/drivers/input/touchscreen/ucb1400_ts.c</span>
<span class="p_header">+++ b/drivers/input/touchscreen/ucb1400_ts.c</span>
<span class="p_chunk">@@ -415,7 +415,7 @@</span> <span class="p_context"> static int ucb1400_ts_suspend(struct device *dev)</span>
 	mutex_lock(&amp;idev-&gt;mutex);
 
 	if (idev-&gt;users)
<span class="p_del">-		ucb1400_ts_start(ucb);</span>
<span class="p_add">+		ucb1400_ts_stop(ucb);</span>
 
 	mutex_unlock(&amp;idev-&gt;mutex);
 	return 0;
<span class="p_chunk">@@ -429,7 +429,7 @@</span> <span class="p_context"> static int ucb1400_ts_resume(struct device *dev)</span>
 	mutex_lock(&amp;idev-&gt;mutex);
 
 	if (idev-&gt;users)
<span class="p_del">-		ucb1400_ts_stop(ucb);</span>
<span class="p_add">+		ucb1400_ts_start(ucb);</span>
 
 	mutex_unlock(&amp;idev-&gt;mutex);
 	return 0;
<span class="p_header">diff --git a/drivers/md/bcache/bcache.h b/drivers/md/bcache/bcache.h</span>
<span class="p_header">index d2ebcf323094..7cb1b2cb1a10 100644</span>
<span class="p_header">--- a/drivers/md/bcache/bcache.h</span>
<span class="p_header">+++ b/drivers/md/bcache/bcache.h</span>
<span class="p_chunk">@@ -348,6 +348,7 @@</span> <span class="p_context"> struct cached_dev {</span>
 	/* Limit number of writeback bios in flight */
 	struct semaphore	in_flight;
 	struct task_struct	*writeback_thread;
<span class="p_add">+	struct workqueue_struct	*writeback_write_wq;</span>
 
 	struct keybuf		writeback_keys;
 
<span class="p_header">diff --git a/drivers/md/bcache/request.c b/drivers/md/bcache/request.c</span>
<span class="p_header">index 15fff4f68a7c..cd41f03b91c2 100644</span>
<span class="p_header">--- a/drivers/md/bcache/request.c</span>
<span class="p_header">+++ b/drivers/md/bcache/request.c</span>
<span class="p_chunk">@@ -193,14 +193,14 @@</span> <span class="p_context"> static void bch_data_insert_start(struct closure *cl)</span>
 	struct data_insert_op *op = container_of(cl, struct data_insert_op, cl);
 	struct bio *bio = op-&gt;bio, *n;
 
<span class="p_add">+	if (op-&gt;bypass)</span>
<span class="p_add">+		return bch_data_invalidate(cl);</span>
<span class="p_add">+</span>
 	if (atomic_sub_return(bio_sectors(bio), &amp;op-&gt;c-&gt;sectors_to_gc) &lt; 0) {
 		set_gc_sectors(op-&gt;c);
 		wake_up_gc(op-&gt;c);
 	}
 
<span class="p_del">-	if (op-&gt;bypass)</span>
<span class="p_del">-		return bch_data_invalidate(cl);</span>
<span class="p_del">-</span>
 	/*
 	 * Journal writes are marked REQ_FLUSH; if the original write was a
 	 * flush, it&#39;ll wait on the journal write.
<span class="p_chunk">@@ -395,12 +395,6 @@</span> <span class="p_context"> static bool check_should_bypass(struct cached_dev *dc, struct bio *bio)</span>
 	if (!congested &amp;&amp; !dc-&gt;sequential_cutoff)
 		goto rescale;
 
<span class="p_del">-	if (!congested &amp;&amp;</span>
<span class="p_del">-	    mode == CACHE_MODE_WRITEBACK &amp;&amp;</span>
<span class="p_del">-	    (bio-&gt;bi_rw &amp; REQ_WRITE) &amp;&amp;</span>
<span class="p_del">-	    (bio-&gt;bi_rw &amp; REQ_SYNC))</span>
<span class="p_del">-		goto rescale;</span>
<span class="p_del">-</span>
 	spin_lock(&amp;dc-&gt;io_lock);
 
 	hlist_for_each_entry(i, iohash(dc, bio-&gt;bi_iter.bi_sector), hash)
<span class="p_header">diff --git a/drivers/md/bcache/super.c b/drivers/md/bcache/super.c</span>
<span class="p_header">index af7bae7b4daf..8498d9488bc0 100644</span>
<span class="p_header">--- a/drivers/md/bcache/super.c</span>
<span class="p_header">+++ b/drivers/md/bcache/super.c</span>
<span class="p_chunk">@@ -1045,7 +1045,7 @@</span> <span class="p_context"> int bch_cached_dev_attach(struct cached_dev *dc, struct cache_set *c)</span>
 	atomic_set(&amp;dc-&gt;count, 1);
 
 	if (BDEV_STATE(&amp;dc-&gt;sb) == BDEV_STATE_DIRTY) {
<span class="p_del">-		bch_sectors_dirty_init(dc);</span>
<span class="p_add">+		bch_sectors_dirty_init(&amp;dc-&gt;disk);</span>
 		atomic_set(&amp;dc-&gt;has_dirty, 1);
 		atomic_inc(&amp;dc-&gt;count);
 		bch_writeback_queue(dc);
<span class="p_chunk">@@ -1073,7 +1073,10 @@</span> <span class="p_context"> static void cached_dev_free(struct closure *cl)</span>
 	struct cached_dev *dc = container_of(cl, struct cached_dev, disk.cl);
 
 	cancel_delayed_work_sync(&amp;dc-&gt;writeback_rate_update);
<span class="p_del">-	kthread_stop(dc-&gt;writeback_thread);</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(dc-&gt;writeback_thread))</span>
<span class="p_add">+		kthread_stop(dc-&gt;writeback_thread);</span>
<span class="p_add">+	if (dc-&gt;writeback_write_wq)</span>
<span class="p_add">+		destroy_workqueue(dc-&gt;writeback_write_wq);</span>
 
 	mutex_lock(&amp;bch_register_lock);
 
<span class="p_chunk">@@ -1245,6 +1248,7 @@</span> <span class="p_context"> static int flash_dev_run(struct cache_set *c, struct uuid_entry *u)</span>
 		goto err;
 
 	bcache_device_attach(d, c, u - c-&gt;uuids);
<span class="p_add">+	bch_sectors_dirty_init(d);</span>
 	bch_flash_dev_request_init(d);
 	add_disk(d-&gt;disk);
 
<span class="p_chunk">@@ -1974,6 +1978,8 @@</span> <span class="p_context"> static ssize_t register_bcache(struct kobject *k, struct kobj_attribute *attr,</span>
 			else
 				err = &quot;device busy&quot;;
 			mutex_unlock(&amp;bch_register_lock);
<span class="p_add">+			if (!IS_ERR(bdev))</span>
<span class="p_add">+				bdput(bdev);</span>
 			if (attr == &amp;ksysfs_register_quiet)
 				goto out;
 		}
<span class="p_header">diff --git a/drivers/md/bcache/sysfs.c b/drivers/md/bcache/sysfs.c</span>
<span class="p_header">index b3ff57d61dde..4fbb5532f24c 100644</span>
<span class="p_header">--- a/drivers/md/bcache/sysfs.c</span>
<span class="p_header">+++ b/drivers/md/bcache/sysfs.c</span>
<span class="p_chunk">@@ -191,7 +191,7 @@</span> <span class="p_context"> STORE(__cached_dev)</span>
 {
 	struct cached_dev *dc = container_of(kobj, struct cached_dev,
 					     disk.kobj);
<span class="p_del">-	unsigned v = size;</span>
<span class="p_add">+	ssize_t v = size;</span>
 	struct cache_set *c;
 	struct kobj_uevent_env *env;
 
<span class="p_chunk">@@ -226,7 +226,7 @@</span> <span class="p_context"> STORE(__cached_dev)</span>
 		bch_cached_dev_run(dc);
 
 	if (attr == &amp;sysfs_cache_mode) {
<span class="p_del">-		ssize_t v = bch_read_string_list(buf, bch_cache_modes + 1);</span>
<span class="p_add">+		v = bch_read_string_list(buf, bch_cache_modes + 1);</span>
 
 		if (v &lt; 0)
 			return v;
<span class="p_header">diff --git a/drivers/md/bcache/util.c b/drivers/md/bcache/util.c</span>
<span class="p_header">index db3ae4c2b223..6c18e3ec3e48 100644</span>
<span class="p_header">--- a/drivers/md/bcache/util.c</span>
<span class="p_header">+++ b/drivers/md/bcache/util.c</span>
<span class="p_chunk">@@ -73,24 +73,44 @@</span> <span class="p_context"> STRTO_H(strtouint, unsigned int)</span>
 STRTO_H(strtoll, long long)
 STRTO_H(strtoull, unsigned long long)
 
<span class="p_add">+/**</span>
<span class="p_add">+ * bch_hprint() - formats @v to human readable string for sysfs.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @v - signed 64 bit integer</span>
<span class="p_add">+ * @buf - the (at least 8 byte) buffer to format the result into.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns the number of bytes used by format.</span>
<span class="p_add">+ */</span>
 ssize_t bch_hprint(char *buf, int64_t v)
 {
 	static const char units[] = &quot;?kMGTPEZY&quot;;
<span class="p_del">-	char dec[4] = &quot;&quot;;</span>
<span class="p_del">-	int u, t = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (u = 0; v &gt;= 1024 || v &lt;= -1024; u++) {</span>
<span class="p_del">-		t = v &amp; ~(~0 &lt;&lt; 10);</span>
<span class="p_del">-		v &gt;&gt;= 10;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!u)</span>
<span class="p_del">-		return sprintf(buf, &quot;%llu&quot;, v);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (v &lt; 100 &amp;&amp; v &gt; -100)</span>
<span class="p_del">-		snprintf(dec, sizeof(dec), &quot;.%i&quot;, t / 100);</span>
<span class="p_del">-</span>
<span class="p_del">-	return sprintf(buf, &quot;%lli%s%c&quot;, v, dec, units[u]);</span>
<span class="p_add">+	int u = 0, t;</span>
<span class="p_add">+</span>
<span class="p_add">+	uint64_t q;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (v &lt; 0)</span>
<span class="p_add">+		q = -v;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		q = v;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* For as long as the number is more than 3 digits, but at least</span>
<span class="p_add">+	 * once, shift right / divide by 1024.  Keep the remainder for</span>
<span class="p_add">+	 * a digit after the decimal point.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		u++;</span>
<span class="p_add">+</span>
<span class="p_add">+		t = q &amp; ~(~0 &lt;&lt; 10);</span>
<span class="p_add">+		q &gt;&gt;= 10;</span>
<span class="p_add">+	} while (q &gt;= 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (v &lt; 0)</span>
<span class="p_add">+		/* &#39;-&#39;, up to 3 digits, &#39;.&#39;, 1 digit, 1 character, null;</span>
<span class="p_add">+		 * yields 8 bytes.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return sprintf(buf, &quot;-%llu.%i%c&quot;, q, t * 10 / 1024, units[u]);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return sprintf(buf, &quot;%llu.%i%c&quot;, q, t * 10 / 1024, units[u]);</span>
 }
 
 ssize_t bch_snprint_string_list(char *buf, size_t size, const char * const list[],
<span class="p_header">diff --git a/drivers/md/bcache/writeback.c b/drivers/md/bcache/writeback.c</span>
<span class="p_header">index d6525c12c8d8..0952a21445ea 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.c</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.c</span>
<span class="p_chunk">@@ -21,7 +21,8 @@</span> <span class="p_context"></span>
 static void __update_writeback_rate(struct cached_dev *dc)
 {
 	struct cache_set *c = dc-&gt;disk.c;
<span class="p_del">-	uint64_t cache_sectors = c-&gt;nbuckets * c-&gt;sb.bucket_size;</span>
<span class="p_add">+	uint64_t cache_sectors = c-&gt;nbuckets * c-&gt;sb.bucket_size -</span>
<span class="p_add">+				bcache_flash_devs_sectors_dirty(c);</span>
 	uint64_t cache_dirty_target =
 		div_u64(cache_sectors * dc-&gt;writeback_percent, 100);
 
<span class="p_chunk">@@ -190,7 +191,7 @@</span> <span class="p_context"> static void write_dirty(struct closure *cl)</span>
 
 	closure_bio_submit(&amp;io-&gt;bio, cl, &amp;io-&gt;dc-&gt;disk);
 
<span class="p_del">-	continue_at(cl, write_dirty_finish, system_wq);</span>
<span class="p_add">+	continue_at(cl, write_dirty_finish, io-&gt;dc-&gt;writeback_write_wq);</span>
 }
 
 static void read_dirty_endio(struct bio *bio, int error)
<span class="p_chunk">@@ -210,7 +211,7 @@</span> <span class="p_context"> static void read_dirty_submit(struct closure *cl)</span>
 
 	closure_bio_submit(&amp;io-&gt;bio, cl, &amp;io-&gt;dc-&gt;disk);
 
<span class="p_del">-	continue_at(cl, write_dirty, system_wq);</span>
<span class="p_add">+	continue_at(cl, write_dirty, io-&gt;dc-&gt;writeback_write_wq);</span>
 }
 
 static void read_dirty(struct cached_dev *dc)
<span class="p_chunk">@@ -488,17 +489,17 @@</span> <span class="p_context"> static int sectors_dirty_init_fn(struct btree_op *_op, struct btree *b,</span>
 	return MAP_CONTINUE;
 }
 
<span class="p_del">-void bch_sectors_dirty_init(struct cached_dev *dc)</span>
<span class="p_add">+void bch_sectors_dirty_init(struct bcache_device *d)</span>
 {
 	struct sectors_dirty_init op;
 
 	bch_btree_op_init(&amp;op.op, -1);
<span class="p_del">-	op.inode = dc-&gt;disk.id;</span>
<span class="p_add">+	op.inode = d-&gt;id;</span>
 
<span class="p_del">-	bch_btree_map_keys(&amp;op.op, dc-&gt;disk.c, &amp;KEY(op.inode, 0, 0),</span>
<span class="p_add">+	bch_btree_map_keys(&amp;op.op, d-&gt;c, &amp;KEY(op.inode, 0, 0),</span>
 			   sectors_dirty_init_fn, 0);
 
<span class="p_del">-	dc-&gt;disk.sectors_dirty_last = bcache_dev_sectors_dirty(&amp;dc-&gt;disk);</span>
<span class="p_add">+	d-&gt;sectors_dirty_last = bcache_dev_sectors_dirty(d);</span>
 }
 
 int bch_cached_dev_writeback_init(struct cached_dev *dc)
<span class="p_chunk">@@ -517,6 +518,11 @@</span> <span class="p_context"> int bch_cached_dev_writeback_init(struct cached_dev *dc)</span>
 	dc-&gt;writeback_rate_d_term	= 30;
 	dc-&gt;writeback_rate_p_term_inverse = 6000;
 
<span class="p_add">+	dc-&gt;writeback_write_wq = alloc_workqueue(&quot;bcache_writeback_wq&quot;,</span>
<span class="p_add">+						WQ_MEM_RECLAIM, 0);</span>
<span class="p_add">+	if (!dc-&gt;writeback_write_wq)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	dc-&gt;writeback_thread = kthread_create(bch_writeback_thread, dc,
 					      &quot;bcache_writeback&quot;);
 	if (IS_ERR(dc-&gt;writeback_thread))
<span class="p_header">diff --git a/drivers/md/bcache/writeback.h b/drivers/md/bcache/writeback.h</span>
<span class="p_header">index afe7ecada503..d1ff56aeaeb3 100644</span>
<span class="p_header">--- a/drivers/md/bcache/writeback.h</span>
<span class="p_header">+++ b/drivers/md/bcache/writeback.h</span>
<span class="p_chunk">@@ -14,6 +14,25 @@</span> <span class="p_context"> static inline uint64_t bcache_dev_sectors_dirty(struct bcache_device *d)</span>
 	return ret;
 }
 
<span class="p_add">+static inline uint64_t  bcache_flash_devs_sectors_dirty(struct cache_set *c)</span>
<span class="p_add">+{</span>
<span class="p_add">+	uint64_t i, ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;bch_register_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; c-&gt;nr_uuids; i++) {</span>
<span class="p_add">+		struct bcache_device *d = c-&gt;devices[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!d || !UUID_FLASH_ONLY(&amp;c-&gt;uuids[i]))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+	   ret += bcache_dev_sectors_dirty(d);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;bch_register_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline unsigned offset_to_stripe(struct bcache_device *d,
 					uint64_t offset)
 {
<span class="p_chunk">@@ -85,7 +104,7 @@</span> <span class="p_context"> static inline void bch_writeback_add(struct cached_dev *dc)</span>
 
 void bcache_dev_sectors_dirty_add(struct cache_set *, unsigned, uint64_t, int);
 
<span class="p_del">-void bch_sectors_dirty_init(struct cached_dev *dc);</span>
<span class="p_add">+void bch_sectors_dirty_init(struct bcache_device *);</span>
 int bch_cached_dev_writeback_init(struct cached_dev *);
 
 #endif
<span class="p_header">diff --git a/drivers/md/bitmap.c b/drivers/md/bitmap.c</span>
<span class="p_header">index cced062cab4b..cb5c9d8ea139 100644</span>
<span class="p_header">--- a/drivers/md/bitmap.c</span>
<span class="p_header">+++ b/drivers/md/bitmap.c</span>
<span class="p_chunk">@@ -1802,6 +1802,11 @@</span> <span class="p_context"> int bitmap_resize(struct bitmap *bitmap, sector_t blocks,</span>
 	long pages;
 	struct bitmap_page *new_bp;
 
<span class="p_add">+	if (bitmap-&gt;storage.file &amp;&amp; !init) {</span>
<span class="p_add">+		pr_info(&quot;md: cannot resize file-based bitmap\n&quot;);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (chunksize == 0) {
 		/* If there is enough space, leave the chunk size unchanged,
 		 * else increase by factor of two until there is enough space.
<span class="p_header">diff --git a/drivers/media/rc/imon.c b/drivers/media/rc/imon.c</span>
<span class="p_header">index 6f24e77b1488..8e5104f18099 100644</span>
<span class="p_header">--- a/drivers/media/rc/imon.c</span>
<span class="p_header">+++ b/drivers/media/rc/imon.c</span>
<span class="p_chunk">@@ -2312,6 +2312,11 @@</span> <span class="p_context"> static int imon_probe(struct usb_interface *interface,</span>
 	mutex_lock(&amp;driver_lock);
 
 	first_if = usb_ifnum_to_if(usbdev, 0);
<span class="p_add">+	if (!first_if) {</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	first_if_ctx = usb_get_intfdata(first_if);
 
 	if (ifnum == 0) {
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-cards.c b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">index aae9831f05a8..5cc7f9220d51 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_chunk">@@ -1226,7 +1226,7 @@</span> <span class="p_context"> static int cx231xx_usb_probe(struct usb_interface *interface,</span>
 	nr = dev-&gt;devno;
 
 	assoc_desc = udev-&gt;actconfig-&gt;intf_assoc[0];
<span class="p_del">-	if (assoc_desc-&gt;bFirstInterface != ifnum) {</span>
<span class="p_add">+	if (!assoc_desc || assoc_desc-&gt;bFirstInterface != ifnum) {</span>
 		cx231xx_err(DRIVER_NAME &quot;: Not found &quot;
 			    &quot;matching IAD interface\n&quot;);
 		retval = -ENODEV;
<span class="p_header">diff --git a/drivers/media/usb/em28xx/em28xx-audio.c b/drivers/media/usb/em28xx/em28xx-audio.c</span>
<span class="p_header">index d04d9be10019..096fb9ddead2 100644</span>
<span class="p_header">--- a/drivers/media/usb/em28xx/em28xx-audio.c</span>
<span class="p_header">+++ b/drivers/media/usb/em28xx/em28xx-audio.c</span>
<span class="p_chunk">@@ -562,7 +562,7 @@</span> <span class="p_context"> static int em28xx_vol_get(struct snd_kcontrol *kcontrol,</span>
 		val, (int)kcontrol-&gt;private_value);
 
 	value-&gt;value.integer.value[0] = 0x1f - (val &amp; 0x1f);
<span class="p_del">-	value-&gt;value.integer.value[1] = 0x1f - ((val &lt;&lt; 8) &amp; 0x1f);</span>
<span class="p_add">+	value-&gt;value.integer.value[1] = 0x1f - ((val &gt;&gt; 8) &amp; 0x1f);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/media/usb/uvc/uvc_ctrl.c b/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_header">index 0eb82106d2ff..f1c146765443 100644</span>
<span class="p_header">--- a/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_header">+++ b/drivers/media/usb/uvc/uvc_ctrl.c</span>
<span class="p_chunk">@@ -1949,6 +1949,13 @@</span> <span class="p_context"> int uvc_ctrl_add_mapping(struct uvc_video_chain *chain,</span>
 		goto done;
 	}
 
<span class="p_add">+	/* Validate the user-provided bit-size and offset */</span>
<span class="p_add">+	if (mapping-&gt;size &gt; 32 ||</span>
<span class="p_add">+	    mapping-&gt;offset + mapping-&gt;size &gt; ctrl-&gt;info.size * 8) {</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+		goto done;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_for_each_entry(map, &amp;ctrl-&gt;info.mappings, list) {
 		if (mapping-&gt;id == map-&gt;id) {
 			uvc_trace(UVC_TRACE_CONTROL, &quot;Can&#39;t add mapping &#39;%s&#39;, &quot;
<span class="p_header">diff --git a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">index f6bcc64b7ac1..0f747ba40b52 100644</span>
<span class="p_header">--- a/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_header">+++ b/drivers/media/v4l2-core/v4l2-compat-ioctl32.c</span>
<span class="p_chunk">@@ -731,7 +731,8 @@</span> <span class="p_context"> static int put_v4l2_event32(struct v4l2_event *kp, struct v4l2_event32 __user *u</span>
 		copy_to_user(&amp;up-&gt;u, &amp;kp-&gt;u, sizeof(kp-&gt;u)) ||
 		put_user(kp-&gt;pending, &amp;up-&gt;pending) ||
 		put_user(kp-&gt;sequence, &amp;up-&gt;sequence) ||
<span class="p_del">-		compat_put_timespec(&amp;kp-&gt;timestamp, &amp;up-&gt;timestamp) ||</span>
<span class="p_add">+		put_user(kp-&gt;timestamp.tv_sec, &amp;up-&gt;timestamp.tv_sec) ||</span>
<span class="p_add">+		put_user(kp-&gt;timestamp.tv_nsec, &amp;up-&gt;timestamp.tv_nsec) ||</span>
 		put_user(kp-&gt;id, &amp;up-&gt;id) ||
 		copy_to_user(up-&gt;reserved, kp-&gt;reserved, 8 * sizeof(__u32)))
 			return -EFAULT;
<span class="p_header">diff --git a/drivers/mfd/max8998.c b/drivers/mfd/max8998.c</span>
<span class="p_header">index a37cb7444b6e..8670caa17bc3 100644</span>
<span class="p_header">--- a/drivers/mfd/max8998.c</span>
<span class="p_header">+++ b/drivers/mfd/max8998.c</span>
<span class="p_chunk">@@ -195,10 +195,8 @@</span> <span class="p_context"> static int max8998_i2c_probe(struct i2c_client *i2c,</span>
 
 	if (IS_ENABLED(CONFIG_OF) &amp;&amp; i2c-&gt;dev.of_node) {
 		pdata = max8998_i2c_parse_dt_pdata(&amp;i2c-&gt;dev);
<span class="p_del">-		if (IS_ERR(pdata)) {</span>
<span class="p_del">-			ret = PTR_ERR(pdata);</span>
<span class="p_del">-			goto err;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (IS_ERR(pdata))</span>
<span class="p_add">+			return PTR_ERR(pdata);</span>
 	}
 
 	i2c_set_clientdata(i2c, max8998);
<span class="p_header">diff --git a/drivers/mfd/omap-usb-tll.c b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">index 1224921217f2..c71b137f9976 100644</span>
<span class="p_header">--- a/drivers/mfd/omap-usb-tll.c</span>
<span class="p_header">+++ b/drivers/mfd/omap-usb-tll.c</span>
<span class="p_chunk">@@ -129,12 +129,12 @@</span> <span class="p_context"> static inline u32 usbtll_read(void __iomem *base, u32 reg)</span>
 	return readl_relaxed(base + reg);
 }
 
<span class="p_del">-static inline void usbtll_writeb(void __iomem *base, u8 reg, u8 val)</span>
<span class="p_add">+static inline void usbtll_writeb(void __iomem *base, u32 reg, u8 val)</span>
 {
 	writeb_relaxed(val, base + reg);
 }
 
<span class="p_del">-static inline u8 usbtll_readb(void __iomem *base, u8 reg)</span>
<span class="p_add">+static inline u8 usbtll_readb(void __iomem *base, u32 reg)</span>
 {
 	return readb_relaxed(base + reg);
 }
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/fw.c b/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_header">index 781e590efe8e..2a462664ed41 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/fw.c</span>
<span class="p_chunk">@@ -1084,7 +1084,7 @@</span> <span class="p_context"> int mlx4_map_cmd(struct mlx4_dev *dev, u16 op, struct mlx4_icm *icm, u64 virt)</span>
 		for (i = 0; i &lt; mlx4_icm_size(&amp;iter) &gt;&gt; lg; ++i) {
 			if (virt != -1) {
 				pages[nent * 2] = cpu_to_be64(virt);
<span class="p_del">-				virt += 1 &lt;&lt; lg;</span>
<span class="p_add">+				virt += 1ULL &lt;&lt; lg;</span>
 			}
 
 			pages[nent * 2 + 1] =
<span class="p_header">diff --git a/drivers/net/usb/cdc_ether.c b/drivers/net/usb/cdc_ether.c</span>
<span class="p_header">index 610b2858c5c3..797664f12d95 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ether.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ether.c</span>
<span class="p_chunk">@@ -235,8 +235,9 @@</span> <span class="p_context"> int usbnet_generic_cdc_bind(struct usbnet *dev, struct usb_interface *intf)</span>
 					info-&gt;ether-&gt;bLength);
 				goto bad_desc;
 			}
<span class="p_del">-			dev-&gt;hard_mtu = le16_to_cpu(</span>
<span class="p_del">-						info-&gt;ether-&gt;wMaxSegmentSize);</span>
<span class="p_add">+			if (info-&gt;ether-&gt;wMaxSegmentSize)</span>
<span class="p_add">+				dev-&gt;hard_mtu = le16_to_cpu(</span>
<span class="p_add">+					info-&gt;ether-&gt;wMaxSegmentSize);</span>
 			/* because of Zaurus, we may be ignoring the host
 			 * side link address we were given.
 			 */
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index f07777eb09b1..010ff1a92747 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -314,7 +314,7 @@</span> <span class="p_context"> static int qmi_wwan_bind(struct usbnet *dev, struct usb_interface *intf)</span>
 	}
 
 	/* errors aren&#39;t fatal - we can live with the dynamic address */
<span class="p_del">-	if (cdc_ether) {</span>
<span class="p_add">+	if (cdc_ether &amp;&amp; cdc_ether-&gt;wMaxSegmentSize) {</span>
 		dev-&gt;hard_mtu = le16_to_cpu(cdc_ether-&gt;wMaxSegmentSize);
 		usbnet_get_ethernet_addr(dev, cdc_ether-&gt;iMACAddress);
 	}
<span class="p_header">diff --git a/drivers/net/usb/smsc95xx.c b/drivers/net/usb/smsc95xx.c</span>
<span class="p_header">index d07bf4cb893f..fc629c315adc 100644</span>
<span class="p_header">--- a/drivers/net/usb/smsc95xx.c</span>
<span class="p_header">+++ b/drivers/net/usb/smsc95xx.c</span>
<span class="p_chunk">@@ -516,7 +516,7 @@</span> <span class="p_context"> static void smsc95xx_set_multicast(struct net_device *netdev)</span>
 static int smsc95xx_phy_update_flowcontrol(struct usbnet *dev, u8 duplex,
 					   u16 lcladv, u16 rmtadv)
 {
<span class="p_del">-	u32 flow, afc_cfg = 0;</span>
<span class="p_add">+	u32 flow = 0, afc_cfg;</span>
 
 	int ret = smsc95xx_read_reg(dev, AFC_CFG, &amp;afc_cfg);
 	if (ret &lt; 0)
<span class="p_chunk">@@ -527,20 +527,19 @@</span> <span class="p_context"> static int smsc95xx_phy_update_flowcontrol(struct usbnet *dev, u8 duplex,</span>
 
 		if (cap &amp; FLOW_CTRL_RX)
 			flow = 0xFFFF0002;
<span class="p_del">-		else</span>
<span class="p_del">-			flow = 0;</span>
 
<span class="p_del">-		if (cap &amp; FLOW_CTRL_TX)</span>
<span class="p_add">+		if (cap &amp; FLOW_CTRL_TX) {</span>
 			afc_cfg |= 0xF;
<span class="p_del">-		else</span>
<span class="p_add">+			flow |= 0xFFFF0000;</span>
<span class="p_add">+		} else {</span>
 			afc_cfg &amp;= ~0xF;
<span class="p_add">+		}</span>
 
 		netif_dbg(dev, link, dev-&gt;net, &quot;rx pause %s, tx pause %s\n&quot;,
 				   cap &amp; FLOW_CTRL_RX ? &quot;enabled&quot; : &quot;disabled&quot;,
 				   cap &amp; FLOW_CTRL_TX ? &quot;enabled&quot; : &quot;disabled&quot;);
 	} else {
 		netif_dbg(dev, link, dev-&gt;net, &quot;half duplex\n&quot;);
<span class="p_del">-		flow = 0;</span>
 		afc_cfg |= 0xF;
 	}
 
<span class="p_header">diff --git a/drivers/net/wireless/ath/wcn36xx/main.c b/drivers/net/wireless/ath/wcn36xx/main.c</span>
<span class="p_header">index 4ab5370ab7a6..f9ecd6ad5a0a 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/wcn36xx/main.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/wcn36xx/main.c</span>
<span class="p_chunk">@@ -339,6 +339,8 @@</span> <span class="p_context"> static int wcn36xx_config(struct ieee80211_hw *hw, u32 changed)</span>
 
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac config changed 0x%08x\n&quot;, changed);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	if (changed &amp; IEEE80211_CONF_CHANGE_CHANNEL) {
 		int ch = WCN36XX_HW_CHANNEL(wcn);
 		wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;wcn36xx_config channel switch=%d\n&quot;,
<span class="p_chunk">@@ -351,6 +353,8 @@</span> <span class="p_context"> static int wcn36xx_config(struct ieee80211_hw *hw, u32 changed)</span>
 		}
 	}
 
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -398,6 +402,8 @@</span> <span class="p_context"> static int wcn36xx_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,</span>
 			 key_conf-&gt;key,
 			 key_conf-&gt;keylen);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	switch (key_conf-&gt;cipher) {
 	case WLAN_CIPHER_SUITE_WEP40:
 		vif_priv-&gt;encrypt_type = WCN36XX_HAL_ED_WEP40;
<span class="p_chunk">@@ -492,6 +498,8 @@</span> <span class="p_context"> static int wcn36xx_set_key(struct ieee80211_hw *hw, enum set_key_cmd cmd,</span>
 	}
 
 out:
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -591,6 +599,8 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac bss info changed vif %p changed 0x%08x\n&quot;,
 		    vif, changed);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	if (changed &amp; BSS_CHANGED_BEACON_INFO) {
 		wcn36xx_dbg(WCN36XX_DBG_MAC,
 			    &quot;mac bss changed dtim period %d\n&quot;,
<span class="p_chunk">@@ -651,12 +661,17 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 				     vif-&gt;addr,
 				     bss_conf-&gt;aid);
 
<span class="p_del">-			rcu_read_lock();</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Holding conf_mutex ensures mutal exclusion with</span>
<span class="p_add">+			 * wcn36xx_sta_remove() and as such ensures that sta</span>
<span class="p_add">+			 * won&#39;t be freed while we&#39;re operating on it. As such</span>
<span class="p_add">+			 * we do not need to hold the rcu_read_lock().</span>
<span class="p_add">+			 */</span>
 			sta = ieee80211_find_sta(vif, bss_conf-&gt;bssid);
 			if (!sta) {
 				wcn36xx_err(&quot;sta %pM is not found\n&quot;,
 					      bss_conf-&gt;bssid);
<span class="p_del">-				rcu_read_unlock();</span>
 				goto out;
 			}
 			sta_priv = (struct wcn36xx_sta *)sta-&gt;drv_priv;
<span class="p_chunk">@@ -675,7 +690,6 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 			 * place where AID is available.
 			 */
 			wcn36xx_smd_config_sta(wcn, vif, sta);
<span class="p_del">-			rcu_read_unlock();</span>
 		} else {
 			wcn36xx_dbg(WCN36XX_DBG_MAC,
 				    &quot;disassociated bss %pM vif %pM AID=%d\n&quot;,
<span class="p_chunk">@@ -736,6 +750,9 @@</span> <span class="p_context"> static void wcn36xx_bss_info_changed(struct ieee80211_hw *hw,</span>
 		}
 	}
 out:
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return;
 }
 
<span class="p_chunk">@@ -745,7 +762,10 @@</span> <span class="p_context"> static int wcn36xx_set_rts_threshold(struct ieee80211_hw *hw, u32 value)</span>
 	struct wcn36xx *wcn = hw-&gt;priv;
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac set RTS threshold %d\n&quot;, value);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
 	wcn36xx_smd_update_cfg(wcn, WCN36XX_HAL_CFG_RTS_THRESHOLD, value);
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -756,8 +776,12 @@</span> <span class="p_context"> static void wcn36xx_remove_interface(struct ieee80211_hw *hw,</span>
 	struct wcn36xx_vif *vif_priv = (struct wcn36xx_vif *)vif-&gt;drv_priv;
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac remove interface vif %p\n&quot;, vif);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	list_del(&amp;vif_priv-&gt;list);
 	wcn36xx_smd_delete_sta_self(wcn, vif-&gt;addr);
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
 }
 
 static int wcn36xx_add_interface(struct ieee80211_hw *hw,
<span class="p_chunk">@@ -778,9 +802,13 @@</span> <span class="p_context"> static int wcn36xx_add_interface(struct ieee80211_hw *hw,</span>
 		return -EOPNOTSUPP;
 	}
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	list_add(&amp;vif_priv-&gt;list, &amp;wcn-&gt;vif_list);
 	wcn36xx_smd_add_sta_self(wcn, vif);
 
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -793,6 +821,8 @@</span> <span class="p_context"> static int wcn36xx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,</span>
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac sta add vif %p sta %pM\n&quot;,
 		    vif, sta-&gt;addr);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	vif_priv-&gt;sta = sta_priv;
 	sta_priv-&gt;vif = vif_priv;
 	/*
<span class="p_chunk">@@ -804,6 +834,9 @@</span> <span class="p_context"> static int wcn36xx_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,</span>
 		sta_priv-&gt;aid = sta-&gt;aid;
 		wcn36xx_smd_config_sta(wcn, vif, sta);
 	}
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -818,9 +851,14 @@</span> <span class="p_context"> static int wcn36xx_sta_remove(struct ieee80211_hw *hw,</span>
 	wcn36xx_dbg(WCN36XX_DBG_MAC, &quot;mac sta remove vif %p sta %pM index %d\n&quot;,
 		    vif, sta-&gt;addr, sta_priv-&gt;sta_index);
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	wcn36xx_smd_delete_sta(wcn, sta_priv-&gt;sta_index);
 	vif_priv-&gt;sta = NULL;
 	sta_priv-&gt;vif = NULL;
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -864,6 +902,8 @@</span> <span class="p_context"> static int wcn36xx_ampdu_action(struct ieee80211_hw *hw,</span>
 
 	sta_priv = (struct wcn36xx_sta *)sta-&gt;drv_priv;
 
<span class="p_add">+	mutex_lock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	switch (action) {
 	case IEEE80211_AMPDU_RX_START:
 		sta_priv-&gt;tid = tid;
<span class="p_chunk">@@ -892,6 +932,8 @@</span> <span class="p_context"> static int wcn36xx_ampdu_action(struct ieee80211_hw *hw,</span>
 		wcn36xx_err(&quot;Unknown AMPDU action\n&quot;);
 	}
 
<span class="p_add">+	mutex_unlock(&amp;wcn-&gt;conf_mutex);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -1022,6 +1064,7 @@</span> <span class="p_context"> static int wcn36xx_probe(struct platform_device *pdev)</span>
 	wcn-&gt;dev = &amp;pdev-&gt;dev;
 	wcn-&gt;ctrl_ops = pdev-&gt;dev.platform_data;
 
<span class="p_add">+	mutex_init(&amp;wcn-&gt;conf_mutex);</span>
 	mutex_init(&amp;wcn-&gt;hal_mutex);
 
 	if (!wcn-&gt;ctrl_ops-&gt;get_hw_mac(addr)) {
<span class="p_header">diff --git a/drivers/net/wireless/ath/wcn36xx/wcn36xx.h b/drivers/net/wireless/ath/wcn36xx/wcn36xx.h</span>
<span class="p_header">index f0fb81dfd17b..0578d430fa1d 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/wcn36xx/wcn36xx.h</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/wcn36xx/wcn36xx.h</span>
<span class="p_chunk">@@ -191,6 +191,10 @@</span> <span class="p_context"> struct wcn36xx {</span>
 	void __iomem		*mmio;
 
 	struct wcn36xx_platform_ctrl_ops *ctrl_ops;
<span class="p_add">+</span>
<span class="p_add">+	/* prevents concurrent FW reconfiguration */</span>
<span class="p_add">+	struct mutex		conf_mutex;</span>
<span class="p_add">+</span>
 	/*
 	 * smd_buf must be protected with smd_mutex to garantee
 	 * that all messages are sent one after another
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/mvm/mac80211.c b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">index 142e18ff0941..e83644dfaa6c 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/mvm/mac80211.c</span>
<span class="p_chunk">@@ -485,12 +485,11 @@</span> <span class="p_context"> static void iwl_mvm_mac_tx(struct ieee80211_hw *hw,</span>
 	    !test_bit(IWL_MVM_STATUS_ROC_RUNNING, &amp;mvm-&gt;status))
 		goto drop;
 
<span class="p_del">-	/* treat non-bufferable MMPDUs as broadcast if sta is sleeping */</span>
<span class="p_del">-	if (unlikely(info-&gt;flags &amp; IEEE80211_TX_CTL_NO_PS_BUFFER &amp;&amp;</span>
<span class="p_del">-		     ieee80211_is_mgmt(hdr-&gt;frame_control) &amp;&amp;</span>
<span class="p_del">-		     !ieee80211_is_deauth(hdr-&gt;frame_control) &amp;&amp;</span>
<span class="p_del">-		     !ieee80211_is_disassoc(hdr-&gt;frame_control) &amp;&amp;</span>
<span class="p_del">-		     !ieee80211_is_action(hdr-&gt;frame_control)))</span>
<span class="p_add">+	/* treat non-bufferable MMPDUs on AP interfaces as broadcast */</span>
<span class="p_add">+	if ((info-&gt;control.vif-&gt;type == NL80211_IFTYPE_AP ||</span>
<span class="p_add">+	     info-&gt;control.vif-&gt;type == NL80211_IFTYPE_ADHOC) &amp;&amp;</span>
<span class="p_add">+	    ieee80211_is_mgmt(hdr-&gt;frame_control) &amp;&amp;</span>
<span class="p_add">+	    !ieee80211_is_bufferable_mmpdu(hdr-&gt;frame_control))</span>
 		sta = NULL;
 
 	if (sta) {
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/drv.c b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">index 8e5ef14e1116..f1cd104a8da9 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/drv.c</span>
<span class="p_chunk">@@ -403,6 +403,7 @@</span> <span class="p_context"> static DEFINE_PCI_DEVICE_TABLE(iwl_hw_card_ids) = {</span>
 	{IWL_PCI_DEVICE(0x095B, 0x520A, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9000, iwl7265_2ac_cfg)},
 	{IWL_PCI_DEVICE(0x095A, 0x9400, iwl7265_2ac_cfg)},
<span class="p_add">+	{IWL_PCI_DEVICE(0x095A, 0x9E10, iwl7265_2ac_cfg)},</span>
 
 /* 8000 Series */
 	{IWL_PCI_DEVICE(0x24F3, 0x0010, iwl8260_2ac_cfg)},
<span class="p_header">diff --git a/drivers/net/wireless/mac80211_hwsim.c b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">index b6eca0cdfd46..f8dfef087a5f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mac80211_hwsim.c</span>
<span class="p_chunk">@@ -1122,7 +1122,6 @@</span> <span class="p_context"> static void mac80211_hwsim_tx(struct ieee80211_hw *hw,</span>
 				       txi-&gt;control.rates,
 				       ARRAY_SIZE(txi-&gt;control.rates));
 
<span class="p_del">-	txi-&gt;rate_driver_data[0] = channel;</span>
 	mac80211_hwsim_monitor_rx(hw, skb, channel);
 
 	/* wmediumd mode check */
<span class="p_header">diff --git a/drivers/pci/hotplug/shpchp_hpc.c b/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_header">index 29e22352822c..0f05314d3216 100644</span>
<span class="p_header">--- a/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_header">+++ b/drivers/pci/hotplug/shpchp_hpc.c</span>
<span class="p_chunk">@@ -1061,6 +1061,8 @@</span> <span class="p_context"> int shpc_init(struct controller *ctrl, struct pci_dev *pdev)</span>
 		if (rc) {
 			ctrl_info(ctrl, &quot;Can&#39;t get msi for the hotplug controller\n&quot;);
 			ctrl_info(ctrl, &quot;Use INTx for the hotplug controller\n&quot;);
<span class="p_add">+		} else {</span>
<span class="p_add">+			pci_set_master(pdev);</span>
 		}
 
 		rc = request_irq(ctrl-&gt;pci_dev-&gt;irq, shpc_isr, IRQF_SHARED,
<span class="p_header">diff --git a/drivers/pwm/pwm-tiehrpwm.c b/drivers/pwm/pwm-tiehrpwm.c</span>
<span class="p_header">index cb75133085a8..95f1ea79e7b6 100644</span>
<span class="p_header">--- a/drivers/pwm/pwm-tiehrpwm.c</span>
<span class="p_header">+++ b/drivers/pwm/pwm-tiehrpwm.c</span>
<span class="p_chunk">@@ -483,7 +483,7 @@</span> <span class="p_context"> static int ehrpwm_pwm_probe(struct platform_device *pdev)</span>
 	ret = pwmchip_add(&amp;pc-&gt;chip);
 	if (ret &lt; 0) {
 		dev_err(&amp;pdev-&gt;dev, &quot;pwmchip_add() failed: %d\n&quot;, ret);
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto err_clk_unprepare;</span>
 	}
 
 	pm_runtime_enable(&amp;pdev-&gt;dev);
<span class="p_chunk">@@ -506,7 +506,9 @@</span> <span class="p_context"> static int ehrpwm_pwm_probe(struct platform_device *pdev)</span>
 	pm_runtime_put_sync(&amp;pdev-&gt;dev);
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 	pwmchip_remove(&amp;pc-&gt;chip);
<span class="p_add">+err_clk_unprepare:</span>
 	clk_unprepare(pc-&gt;tbclk);
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -524,7 +526,6 @@</span> <span class="p_context"> static int ehrpwm_pwm_remove(struct platform_device *pdev)</span>
 	pwmss_submodule_state_change(pdev-&gt;dev.parent, PWMSS_EPWMCLK_STOP_REQ);
 	pm_runtime_put_sync(&amp;pdev-&gt;dev);
 
<span class="p_del">-	pm_runtime_put_sync(&amp;pdev-&gt;dev);</span>
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 	return pwmchip_remove(&amp;pc-&gt;chip);
 }
<span class="p_header">diff --git a/drivers/regulator/da9063-regulator.c b/drivers/regulator/da9063-regulator.c</span>
<span class="p_header">index 7c9461d13313..6ede3cf71670 100644</span>
<span class="p_header">--- a/drivers/regulator/da9063-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/da9063-regulator.c</span>
<span class="p_chunk">@@ -739,7 +739,7 @@</span> <span class="p_context"> static int da9063_regulator_probe(struct platform_device *pdev)</span>
 	if (IS_ERR(regl_pdata) || regl_pdata-&gt;n_regulators == 0) {
 		dev_err(&amp;pdev-&gt;dev,
 			&quot;No regulators defined for the platform\n&quot;);
<span class="p_del">-		return PTR_ERR(regl_pdata);</span>
<span class="p_add">+		return -ENODEV;</span>
 	}
 
 	/* Find regulators set for particular device model */
<span class="p_header">diff --git a/drivers/rtc/rtc-sa1100.c b/drivers/rtc/rtc-sa1100.c</span>
<span class="p_header">index b6e1ca08c2c0..17ac745533ad 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-sa1100.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-sa1100.c</span>
<span class="p_chunk">@@ -111,7 +111,7 @@</span> <span class="p_context"> static int sa1100_rtc_open(struct device *dev)</span>
 	ret = request_irq(info-&gt;irq_1hz, sa1100_rtc_interrupt, 0, &quot;rtc 1Hz&quot;, dev);
 	if (ret) {
 		dev_err(dev, &quot;IRQ %d already in use.\n&quot;, info-&gt;irq_1hz);
<span class="p_del">-		goto fail_ui;</span>
<span class="p_add">+		return ret;</span>
 	}
 	ret = request_irq(info-&gt;irq_alarm, sa1100_rtc_interrupt, 0, &quot;rtc Alrm&quot;, dev);
 	if (ret) {
<span class="p_chunk">@@ -125,8 +125,6 @@</span> <span class="p_context"> static int sa1100_rtc_open(struct device *dev)</span>
 
  fail_ai:
 	free_irq(info-&gt;irq_1hz, dev);
<span class="p_del">- fail_ui:</span>
<span class="p_del">-	clk_disable_unprepare(info-&gt;clk);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">index 598b577760ef..581f5e0ab10a 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Debug traces for zfcp.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2017</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -447,6 +447,7 @@</span> <span class="p_context"> static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
 	struct fc_ct_hdr *reqh = sg_virt(ct_els-&gt;req);
 	struct fc_ns_gid_ft *reqn = (struct fc_ns_gid_ft *)(reqh + 1);
 	struct scatterlist *resp_entry = ct_els-&gt;resp;
<span class="p_add">+	struct fc_ct_hdr *resph;</span>
 	struct fc_gpn_ft_resp *acc;
 	int max_entries, x, last = 0;
 
<span class="p_chunk">@@ -473,6 +474,13 @@</span> <span class="p_context"> static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
 		return len; /* not GPN_FT response so do not cap */
 
 	acc = sg_virt(resp_entry);
<span class="p_add">+</span>
<span class="p_add">+	/* cap all but accept CT responses to at least the CT header */</span>
<span class="p_add">+	resph = (struct fc_ct_hdr *)acc;</span>
<span class="p_add">+	if ((ct_els-&gt;status) ||</span>
<span class="p_add">+	    (resph-&gt;ct_cmd != cpu_to_be16(FC_FS_ACC)))</span>
<span class="p_add">+		return max(FC_CT_HDR_LEN, ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_add">+</span>
 	max_entries = (reqh-&gt;ct_mr_size * 4 / sizeof(struct fc_gpn_ft_resp))
 		+ 1 /* zfcp_fc_scan_ports: bytes correct, entries off-by-one
 		     * to account for header as 1st pseudo &quot;entry&quot; */;
<span class="p_chunk">@@ -563,19 +571,32 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
 
 	if (fsf) {
 		rec-&gt;fsf_req_id = fsf-&gt;req_id;
<span class="p_add">+		rec-&gt;pl_len = FCP_RESP_WITH_EXT;</span>
 		fcp_rsp = (struct fcp_resp_with_ext *)
 				&amp;(fsf-&gt;qtcb-&gt;bottom.io.fcp_rsp);
<span class="p_add">+		/* mandatory parts of FCP_RSP IU in this SCSI record */</span>
 		memcpy(&amp;rec-&gt;fcp_rsp, fcp_rsp, FCP_RESP_WITH_EXT);
 		if (fcp_rsp-&gt;resp.fr_flags &amp; FCP_RSP_LEN_VAL) {
 			fcp_rsp_info = (struct fcp_resp_rsp_info *) &amp;fcp_rsp[1];
 			rec-&gt;fcp_rsp_info = fcp_rsp_info-&gt;rsp_code;
<span class="p_add">+			rec-&gt;pl_len += be32_to_cpu(fcp_rsp-&gt;ext.fr_rsp_len);</span>
 		}
 		if (fcp_rsp-&gt;resp.fr_flags &amp; FCP_SNS_LEN_VAL) {
<span class="p_del">-			rec-&gt;pl_len = min((u16)SCSI_SENSE_BUFFERSIZE,</span>
<span class="p_del">-					  (u16)ZFCP_DBF_PAY_MAX_REC);</span>
<span class="p_del">-			zfcp_dbf_pl_write(dbf, sc-&gt;sense_buffer, rec-&gt;pl_len,</span>
<span class="p_del">-					  &quot;fcp_sns&quot;, fsf-&gt;req_id);</span>
<span class="p_add">+			rec-&gt;pl_len += be32_to_cpu(fcp_rsp-&gt;ext.fr_sns_len);</span>
 		}
<span class="p_add">+		/* complete FCP_RSP IU in associated PAYload record</span>
<span class="p_add">+		 * but only if there are optional parts</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (fcp_rsp-&gt;resp.fr_flags != 0)</span>
<span class="p_add">+			zfcp_dbf_pl_write(</span>
<span class="p_add">+				dbf, fcp_rsp,</span>
<span class="p_add">+				/* at least one full PAY record</span>
<span class="p_add">+				 * but not beyond hardware response field</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				min_t(u16, max_t(u16, rec-&gt;pl_len,</span>
<span class="p_add">+						 ZFCP_DBF_PAY_MAX_REC),</span>
<span class="p_add">+				      FSF_FCP_RSP_SIZE),</span>
<span class="p_add">+				&quot;fcp_riu&quot;, fsf-&gt;req_id);</span>
 	}
 
 	debug_event(dbf-&gt;scsi, level, rec, sizeof(*rec));
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">index db186d44cfaf..8e7f8e6037d2 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
  * zfcp device driver
  * debug feature declarations
  *
<span class="p_del">- * Copyright IBM Corp. 2008, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2008, 2017</span>
  */
 
 #ifndef ZFCP_DBF_H
<span class="p_chunk">@@ -323,7 +323,11 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_response(struct zfcp_fsf_req *req)</span>
 {
 	struct fsf_qtcb *qtcb = req-&gt;qtcb;
 
<span class="p_del">-	if ((qtcb-&gt;prefix.prot_status != FSF_PROT_GOOD) &amp;&amp;</span>
<span class="p_add">+	if (unlikely(req-&gt;status &amp; (ZFCP_STATUS_FSFREQ_DISMISSED |</span>
<span class="p_add">+				    ZFCP_STATUS_FSFREQ_ERROR))) {</span>
<span class="p_add">+		zfcp_dbf_hba_fsf_resp(&quot;fs_rerr&quot;, 3, req);</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if ((qtcb-&gt;prefix.prot_status != FSF_PROT_GOOD) &amp;&amp;</span>
 	    (qtcb-&gt;prefix.prot_status != FSF_PROT_FSF_STATUS_PRESENTED)) {
 		zfcp_dbf_hba_fsf_resp(&quot;fs_perr&quot;, 1, req);
 
<span class="p_chunk">@@ -401,7 +405,8 @@</span> <span class="p_context"> void zfcp_dbf_scsi_abort(char *tag, struct scsi_cmnd *scmd,</span>
  * @flag: indicates type of reset (Target Reset, Logical Unit Reset)
  */
 static inline
<span class="p_del">-void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)</span>
<span class="p_add">+void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag,</span>
<span class="p_add">+			    struct zfcp_fsf_req *fsf_req)</span>
 {
 	char tmp_tag[ZFCP_DBF_TAG_LEN];
 
<span class="p_chunk">@@ -411,7 +416,7 @@</span> <span class="p_context"> void zfcp_dbf_scsi_devreset(char *tag, struct scsi_cmnd *scmnd, u8 flag)</span>
 		memcpy(tmp_tag, &quot;lr_&quot;, 3);
 
 	memcpy(&amp;tmp_tag[3], tag, 4);
<span class="p_del">-	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, NULL);</span>
<span class="p_add">+	_zfcp_dbf_scsi(tmp_tag, 1, scmnd, fsf_req);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fc.h b/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_header">index b1d2024ed513..c2e40e10b293 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fc.h</span>
<span class="p_chunk">@@ -4,7 +4,7 @@</span> <span class="p_context"></span>
  * Fibre Channel related definitions and inline functions for the zfcp
  * device driver
  *
<span class="p_del">- * Copyright IBM Corp. 2009</span>
<span class="p_add">+ * Copyright IBM Corp. 2009, 2017</span>
  */
 
 #ifndef ZFCP_FC_H
<span class="p_chunk">@@ -291,6 +291,10 @@</span> <span class="p_context"> void zfcp_fc_eval_fcp_rsp(struct fcp_resp_with_ext *fcp_rsp,</span>
 		     !(rsp_flags &amp; FCP_SNS_LEN_VAL) &amp;&amp;
 		     fcp_rsp-&gt;resp.fr_status == SAM_STAT_GOOD)
 			set_host_byte(scsi, DID_ERROR);
<span class="p_add">+	} else if (unlikely(rsp_flags &amp; FCP_RESID_OVER)) {</span>
<span class="p_add">+		/* FCP_DL was not sufficient for SCSI data length */</span>
<span class="p_add">+		if (fcp_rsp-&gt;resp.fr_status == SAM_STAT_GOOD)</span>
<span class="p_add">+			set_host_byte(scsi, DID_ERROR);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">index 36cf11cafee7..196c81435507 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_chunk">@@ -928,8 +928,8 @@</span> <span class="p_context"> static void zfcp_fsf_send_ct_handler(struct zfcp_fsf_req *req)</span>
 
 	switch (header-&gt;fsf_status) {
         case FSF_GOOD:
<span class="p_del">-		zfcp_dbf_san_res(&quot;fsscth2&quot;, req);</span>
 		ct-&gt;status = 0;
<span class="p_add">+		zfcp_dbf_san_res(&quot;fsscth2&quot;, req);</span>
 		break;
         case FSF_SERVICE_CLASS_NOT_SUPPORTED:
 		zfcp_fsf_class_not_supp(req);
<span class="p_chunk">@@ -1109,8 +1109,8 @@</span> <span class="p_context"> static void zfcp_fsf_send_els_handler(struct zfcp_fsf_req *req)</span>
 
 	switch (header-&gt;fsf_status) {
 	case FSF_GOOD:
<span class="p_del">-		zfcp_dbf_san_res(&quot;fsselh1&quot;, req);</span>
 		send_els-&gt;status = 0;
<span class="p_add">+		zfcp_dbf_san_res(&quot;fsselh1&quot;, req);</span>
 		break;
 	case FSF_SERVICE_CLASS_NOT_SUPPORTED:
 		zfcp_fsf_class_not_supp(req);
<span class="p_chunk">@@ -2259,7 +2259,8 @@</span> <span class="p_context"> int zfcp_fsf_fcp_cmnd(struct scsi_cmnd *scsi_cmnd)</span>
 	fcp_cmnd = (struct fcp_cmnd *) &amp;req-&gt;qtcb-&gt;bottom.io.fcp_cmnd;
 	zfcp_fc_scsi_to_fcp(fcp_cmnd, scsi_cmnd, 0);
 
<span class="p_del">-	if (scsi_prot_sg_count(scsi_cmnd)) {</span>
<span class="p_add">+	if ((scsi_get_prot_op(scsi_cmnd) != SCSI_PROT_NORMAL) &amp;&amp;</span>
<span class="p_add">+	    scsi_prot_sg_count(scsi_cmnd)) {</span>
 		zfcp_qdio_set_data_div(qdio, &amp;req-&gt;qdio_req,
 				       scsi_prot_sg_count(scsi_cmnd));
 		retval = zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req,
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index 66c37e77ac7c..b495c085a0b5 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to Linux SCSI midlayer.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2016</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2017</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -294,25 +294,29 @@</span> <span class="p_context"> static int zfcp_task_mgmt_function(struct scsi_cmnd *scpnt, u8 tm_flags)</span>
 
 		zfcp_erp_wait(adapter);
 		ret = fc_block_scsi_eh(scpnt);
<span class="p_del">-		if (ret)</span>
<span class="p_add">+		if (ret) {</span>
<span class="p_add">+			zfcp_dbf_scsi_devreset(&quot;fiof&quot;, scpnt, tm_flags, NULL);</span>
 			return ret;
<span class="p_add">+		}</span>
 
 		if (!(atomic_read(&amp;adapter-&gt;status) &amp;
 		      ZFCP_STATUS_COMMON_RUNNING)) {
<span class="p_del">-			zfcp_dbf_scsi_devreset(&quot;nres&quot;, scpnt, tm_flags);</span>
<span class="p_add">+			zfcp_dbf_scsi_devreset(&quot;nres&quot;, scpnt, tm_flags, NULL);</span>
 			return SUCCESS;
 		}
 	}
<span class="p_del">-	if (!fsf_req)</span>
<span class="p_add">+	if (!fsf_req) {</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;reqf&quot;, scpnt, tm_flags, NULL);</span>
 		return FAILED;
<span class="p_add">+	}</span>
 
 	wait_for_completion(&amp;fsf_req-&gt;completion);
 
 	if (fsf_req-&gt;status &amp; ZFCP_STATUS_FSFREQ_TMFUNCFAILED) {
<span class="p_del">-		zfcp_dbf_scsi_devreset(&quot;fail&quot;, scpnt, tm_flags);</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;fail&quot;, scpnt, tm_flags, fsf_req);</span>
 		retval = FAILED;
 	} else {
<span class="p_del">-		zfcp_dbf_scsi_devreset(&quot;okay&quot;, scpnt, tm_flags);</span>
<span class="p_add">+		zfcp_dbf_scsi_devreset(&quot;okay&quot;, scpnt, tm_flags, fsf_req);</span>
 		zfcp_scsi_forget_cmnds(zfcp_sdev, tm_flags);
 	}
 
<span class="p_header">diff --git a/drivers/scsi/aacraid/aachba.c b/drivers/scsi/aacraid/aachba.c</span>
<span class="p_header">index 681434e2dfe9..4598a1978a1d 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/aachba.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/aachba.c</span>
<span class="p_chunk">@@ -480,6 +480,7 @@</span> <span class="p_context"> static int aac_get_container_name(struct scsi_cmnd * scsicmd)</span>
 
 	aac_fib_init(cmd_fibcontext);
 	dinfo = (struct aac_get_name *) fib_data(cmd_fibcontext);
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	dinfo-&gt;command = cpu_to_le32(VM_ContainerConfig);
 	dinfo-&gt;type = cpu_to_le32(CT_READ_NAME);
<span class="p_chunk">@@ -497,10 +498,8 @@</span> <span class="p_context"> static int aac_get_container_name(struct scsi_cmnd * scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_get_container_name: aac_fib_send failed with status: %d.\n&quot;, status);
 	aac_fib_complete(cmd_fibcontext);
<span class="p_chunk">@@ -589,6 +588,7 @@</span> <span class="p_context"> static void _aac_probe_container1(void * context, struct fib * fibptr)</span>
 	dinfo-&gt;command = cpu_to_le32(VM_NameServe64);
 	dinfo-&gt;count = cpu_to_le32(scmd_id(scsicmd));
 	dinfo-&gt;type = cpu_to_le32(FT_FILESYS);
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	status = aac_fib_send(ContainerCommand,
 			  fibptr,
<span class="p_chunk">@@ -600,9 +600,7 @@</span> <span class="p_context"> static void _aac_probe_container1(void * context, struct fib * fibptr)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS)</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_del">-	else if (status &lt; 0) {</span>
<span class="p_add">+	if (status &lt; 0 &amp;&amp; status != -EINPROGRESS) {</span>
 		/* Inherit results from VM_NameServe, if any */
 		dresp-&gt;status = cpu_to_le32(ST_OK);
 		_aac_probe_container2(context, fibptr);
<span class="p_chunk">@@ -625,6 +623,7 @@</span> <span class="p_context"> static int _aac_probe_container(struct scsi_cmnd * scsicmd, int (*callback)(stru</span>
 		dinfo-&gt;count = cpu_to_le32(scmd_id(scsicmd));
 		dinfo-&gt;type = cpu_to_le32(FT_FILESYS);
 		scsicmd-&gt;SCp.ptr = (char *)callback;
<span class="p_add">+		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 		status = aac_fib_send(ContainerCommand,
 			  fibptr,
<span class="p_chunk">@@ -636,10 +635,9 @@</span> <span class="p_context"> static int _aac_probe_container(struct scsi_cmnd * scsicmd, int (*callback)(stru</span>
 		/*
 		 *	Check that the command queued to the controller
 		 */
<span class="p_del">-		if (status == -EINPROGRESS) {</span>
<span class="p_del">-			scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+		if (status == -EINPROGRESS)</span>
 			return 0;
<span class="p_del">-		}</span>
<span class="p_add">+</span>
 		if (status &lt; 0) {
 			scsicmd-&gt;SCp.ptr = NULL;
 			aac_fib_complete(fibptr);
<span class="p_chunk">@@ -873,6 +871,7 @@</span> <span class="p_context"> static int aac_get_container_serial(struct scsi_cmnd * scsicmd)</span>
 	dinfo-&gt;command = cpu_to_le32(VM_ContainerConfig);
 	dinfo-&gt;type = cpu_to_le32(CT_CID_TO_32BITS_UID);
 	dinfo-&gt;cid = cpu_to_le32(scmd_id(scsicmd));
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	status = aac_fib_send(ContainerCommand,
 		  cmd_fibcontext,
<span class="p_chunk">@@ -885,10 +884,8 @@</span> <span class="p_context"> static int aac_get_container_serial(struct scsi_cmnd * scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_get_container_serial: aac_fib_send failed with status: %d.\n&quot;, status);
 	aac_fib_complete(cmd_fibcontext);
<span class="p_chunk">@@ -1774,16 +1771,14 @@</span> <span class="p_context"> static int aac_read(struct scsi_cmnd * scsicmd)</span>
 		printk(KERN_WARNING &quot;aac_read: fib allocation failed\n&quot;);
 		return -1;
 	}
<span class="p_del">-</span>
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 	status = aac_adapter_read(cmd_fibcontext, scsicmd, lba, count);
 
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_read: aac_fib_send failed with status: %d.\n&quot;, status);
 	/*
<span class="p_chunk">@@ -1877,16 +1872,14 @@</span> <span class="p_context"> static int aac_write(struct scsi_cmnd * scsicmd)</span>
 		printk(KERN_WARNING &quot;aac_write: fib allocation failed\n&quot;);
 		return -1;
 	}
<span class="p_del">-</span>
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 	status = aac_adapter_write(cmd_fibcontext, scsicmd, lba, count, fua);
 
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_write: aac_fib_send failed with status: %d\n&quot;, status);
 	/*
<span class="p_chunk">@@ -2036,6 +2029,7 @@</span> <span class="p_context"> static int aac_synchronize(struct scsi_cmnd *scsicmd)</span>
 	synchronizecmd-&gt;cid = cpu_to_le32(scmd_id(scsicmd));
 	synchronizecmd-&gt;count =
 	     cpu_to_le32(sizeof(((struct aac_synchronize_reply *)NULL)-&gt;data));
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	/*
 	 *	Now send the Fib to the adapter
<span class="p_chunk">@@ -2051,10 +2045,8 @@</span> <span class="p_context"> static int aac_synchronize(struct scsi_cmnd *scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING
 		&quot;aac_synchronize: aac_fib_send failed with status: %d.\n&quot;, status);
<span class="p_chunk">@@ -2116,6 +2108,7 @@</span> <span class="p_context"> static int aac_start_stop(struct scsi_cmnd *scsicmd)</span>
 	pmcmd-&gt;cid = cpu_to_le32(sdev_id(sdev));
 	pmcmd-&gt;parm = (scsicmd-&gt;cmnd[1] &amp; 1) ?
 		cpu_to_le32(CT_PM_UNIT_IMMEDIATE) : 0;
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 
 	/*
 	 *	Now send the Fib to the adapter
<span class="p_chunk">@@ -2131,10 +2124,8 @@</span> <span class="p_context"> static int aac_start_stop(struct scsi_cmnd *scsicmd)</span>
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	aac_fib_complete(cmd_fibcontext);
 	aac_fib_free(cmd_fibcontext);
<span class="p_chunk">@@ -2889,15 +2880,14 @@</span> <span class="p_context"> static int aac_send_srb_fib(struct scsi_cmnd* scsicmd)</span>
 	if (!(cmd_fibcontext = aac_fib_alloc(dev))) {
 		return -1;
 	}
<span class="p_add">+	scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
 	status = aac_adapter_scsi(cmd_fibcontext, scsicmd);
 
 	/*
 	 *	Check that the command queued to the controller
 	 */
<span class="p_del">-	if (status == -EINPROGRESS) {</span>
<span class="p_del">-		scsicmd-&gt;SCp.phase = AAC_OWNER_FIRMWARE;</span>
<span class="p_add">+	if (status == -EINPROGRESS)</span>
 		return 0;
<span class="p_del">-	}</span>
 
 	printk(KERN_WARNING &quot;aac_srb: aac_fib_send failed with status: %d\n&quot;, status);
 	aac_fib_complete(cmd_fibcontext);
<span class="p_header">diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c</span>
<span class="p_header">index 994fc5caf036..c1497fddf0b4 100644</span>
<span class="p_header">--- a/drivers/scsi/mac_esp.c</span>
<span class="p_header">+++ b/drivers/scsi/mac_esp.c</span>
<span class="p_chunk">@@ -348,25 +348,23 @@</span> <span class="p_context"> static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,</span>
 {
 	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
 	u8 *fifo = esp-&gt;regs + ESP_FDATA * 16;
<span class="p_add">+	u8 phase = esp-&gt;sreg &amp; ESP_STAT_PMASK;</span>
 
 	cmd &amp;= ~ESP_CMD_DMA;
 	mep-&gt;error = 0;
 
 	if (write) {
<span class="p_add">+		u8 *dst = (u8 *)addr;</span>
<span class="p_add">+		u8 mask = ~(phase == ESP_MIP ? ESP_INTR_FDONE : ESP_INTR_BSERV);</span>
<span class="p_add">+</span>
 		scsi_esp_cmd(esp, cmd);
 
 		while (1) {
<span class="p_del">-			unsigned int n;</span>
<span class="p_del">-</span>
<span class="p_del">-			n = mac_esp_wait_for_fifo(esp);</span>
<span class="p_del">-			if (!n)</span>
<span class="p_add">+			if (!mac_esp_wait_for_fifo(esp))</span>
 				break;
 
<span class="p_del">-			if (n &gt; esp_count)</span>
<span class="p_del">-				n = esp_count;</span>
<span class="p_del">-			esp_count -= n;</span>
<span class="p_del">-</span>
<span class="p_del">-			MAC_ESP_PIO_LOOP(&quot;%2@,%0@+&quot;, n);</span>
<span class="p_add">+			*dst++ = esp_read8(ESP_FDATA);</span>
<span class="p_add">+			--esp_count;</span>
 
 			if (!esp_count)
 				break;
<span class="p_chunk">@@ -374,14 +372,17 @@</span> <span class="p_context"> static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,</span>
 			if (mac_esp_wait_for_intr(esp))
 				break;
 
<span class="p_del">-			if (((esp-&gt;sreg &amp; ESP_STAT_PMASK) != ESP_DIP) &amp;&amp;</span>
<span class="p_del">-			    ((esp-&gt;sreg &amp; ESP_STAT_PMASK) != ESP_MIP))</span>
<span class="p_add">+			if ((esp-&gt;sreg &amp; ESP_STAT_PMASK) != phase)</span>
 				break;
 
 			esp-&gt;ireg = esp_read8(ESP_INTRPT);
<span class="p_del">-			if ((esp-&gt;ireg &amp; (ESP_INTR_DC | ESP_INTR_BSERV)) !=</span>
<span class="p_del">-			    ESP_INTR_BSERV)</span>
<span class="p_add">+			if (esp-&gt;ireg &amp; mask) {</span>
<span class="p_add">+				mep-&gt;error = 1;</span>
 				break;
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			if (phase == ESP_MIP)</span>
<span class="p_add">+				scsi_esp_cmd(esp, ESP_CMD_MOK);</span>
 
 			scsi_esp_cmd(esp, ESP_CMD_TI);
 		}
<span class="p_chunk">@@ -401,14 +402,14 @@</span> <span class="p_context"> static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,</span>
 			if (mac_esp_wait_for_intr(esp))
 				break;
 
<span class="p_del">-			if (((esp-&gt;sreg &amp; ESP_STAT_PMASK) != ESP_DOP) &amp;&amp;</span>
<span class="p_del">-			    ((esp-&gt;sreg &amp; ESP_STAT_PMASK) != ESP_MOP))</span>
<span class="p_add">+			if ((esp-&gt;sreg &amp; ESP_STAT_PMASK) != phase)</span>
 				break;
 
 			esp-&gt;ireg = esp_read8(ESP_INTRPT);
<span class="p_del">-			if ((esp-&gt;ireg &amp; (ESP_INTR_DC | ESP_INTR_BSERV)) !=</span>
<span class="p_del">-			    ESP_INTR_BSERV)</span>
<span class="p_add">+			if (esp-&gt;ireg &amp; ~ESP_INTR_BSERV) {</span>
<span class="p_add">+				mep-&gt;error = 1;</span>
 				break;
<span class="p_add">+			}</span>
 
 			n = MAC_ESP_FIFO_SIZE -
 			    (esp_read8(ESP_FFLAGS) &amp; ESP_FF_FBYTES);
<span class="p_header">diff --git a/drivers/scsi/qla2xxx/qla_attr.c b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">index 16fe5196e6d9..5ef9fa6c5a91 100644</span>
<span class="p_header">--- a/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_header">+++ b/drivers/scsi/qla2xxx/qla_attr.c</span>
<span class="p_chunk">@@ -396,6 +396,8 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		return -EINVAL;
 	if (start &gt; ha-&gt;optrom_size)
 		return -EINVAL;
<span class="p_add">+	if (size &gt; ha-&gt;optrom_size - start)</span>
<span class="p_add">+		size = ha-&gt;optrom_size - start;</span>
 
 	mutex_lock(&amp;ha-&gt;optrom_mutex);
 	switch (val) {
<span class="p_chunk">@@ -421,8 +423,7 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		}
 
 		ha-&gt;optrom_region_start = start;
<span class="p_del">-		ha-&gt;optrom_region_size = start + size &gt; ha-&gt;optrom_size ?</span>
<span class="p_del">-		    ha-&gt;optrom_size - start : size;</span>
<span class="p_add">+		ha-&gt;optrom_region_size = start + size;</span>
 
 		ha-&gt;optrom_state = QLA_SREADING;
 		ha-&gt;optrom_buffer = vmalloc(ha-&gt;optrom_region_size);
<span class="p_chunk">@@ -494,8 +495,7 @@</span> <span class="p_context"> qla2x00_sysfs_write_optrom_ctl(struct file *filp, struct kobject *kobj,</span>
 		}
 
 		ha-&gt;optrom_region_start = start;
<span class="p_del">-		ha-&gt;optrom_region_size = start + size &gt; ha-&gt;optrom_size ?</span>
<span class="p_del">-		    ha-&gt;optrom_size - start : size;</span>
<span class="p_add">+		ha-&gt;optrom_region_size = start + size;</span>
 
 		ha-&gt;optrom_state = QLA_SWRITING;
 		ha-&gt;optrom_buffer = vmalloc(ha-&gt;optrom_region_size);
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/obdclass/class_obd.c b/drivers/staging/lustre/lustre/obdclass/class_obd.c</span>
<span class="p_header">index b16687625c44..45d229995141 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/obdclass/class_obd.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/obdclass/class_obd.c</span>
<span class="p_chunk">@@ -232,8 +232,8 @@</span> <span class="p_context"> int class_handle_ioctl(unsigned int cmd, unsigned long arg)</span>
 		OBD_ALLOC(lcfg, data-&gt;ioc_plen1);
 		if (lcfg == NULL)
 			GOTO(out, err = -ENOMEM);
<span class="p_del">-		err = copy_from_user(lcfg, data-&gt;ioc_pbuf1,</span>
<span class="p_del">-					 data-&gt;ioc_plen1);</span>
<span class="p_add">+		if (copy_from_user(lcfg, data-&gt;ioc_pbuf1, data-&gt;ioc_plen1))</span>
<span class="p_add">+			err = -EFAULT;</span>
 		if (!err)
 			err = lustre_cfg_sanity_check(lcfg, data-&gt;ioc_plen1);
 		if (!err)
<span class="p_header">diff --git a/drivers/staging/media/lirc/lirc_zilog.c b/drivers/staging/media/lirc/lirc_zilog.c</span>
<span class="p_header">index 3259aacfd350..9cc0318fa20a 100644</span>
<span class="p_header">--- a/drivers/staging/media/lirc/lirc_zilog.c</span>
<span class="p_header">+++ b/drivers/staging/media/lirc/lirc_zilog.c</span>
<span class="p_chunk">@@ -300,7 +300,7 @@</span> <span class="p_context"> static void release_ir_tx(struct kref *ref)</span>
 	struct IR_tx *tx = container_of(ref, struct IR_tx, ref);
 	struct IR *ir = tx-&gt;ir;
 
<span class="p_del">-	ir-&gt;l.features &amp;= ~LIRC_CAN_SEND_PULSE;</span>
<span class="p_add">+	ir-&gt;l.features &amp;= ~LIRC_CAN_SEND_LIRCCODE;</span>
 	/* Don&#39;t put_ir_device(tx-&gt;ir) here, so our lock doesn&#39;t get freed */
 	ir-&gt;tx = NULL;
 	kfree(tx);
<span class="p_chunk">@@ -1271,14 +1271,14 @@</span> <span class="p_context"> static long ioctl(struct file *filep, unsigned int cmd, unsigned long arg)</span>
 		if (!(features&amp;LIRC_CAN_SEND_MASK))
 			return -ENOSYS;
 
<span class="p_del">-		result = put_user(LIRC_MODE_PULSE, uptr);</span>
<span class="p_add">+		result = put_user(LIRC_MODE_LIRCCODE, uptr);</span>
 		break;
 	case LIRC_SET_SEND_MODE:
 		if (!(features&amp;LIRC_CAN_SEND_MASK))
 			return -ENOSYS;
 
 		result = get_user(mode, uptr);
<span class="p_del">-		if (!result &amp;&amp; mode != LIRC_MODE_PULSE)</span>
<span class="p_add">+		if (!result &amp;&amp; mode != LIRC_MODE_LIRCCODE)</span>
 			return -EINVAL;
 		break;
 	default:
<span class="p_chunk">@@ -1516,7 +1516,7 @@</span> <span class="p_context"> static int ir_probe(struct i2c_client *client, const struct i2c_device_id *id)</span>
 		kref_init(&amp;tx-&gt;ref);
 		ir-&gt;tx = tx;
 
<span class="p_del">-		ir-&gt;l.features |= LIRC_CAN_SEND_PULSE;</span>
<span class="p_add">+		ir-&gt;l.features |= LIRC_CAN_SEND_LIRCCODE;</span>
 		mutex_init(&amp;tx-&gt;client_lock);
 		tx-&gt;c = client;
 		tx-&gt;need_boot = 1;
<span class="p_header">diff --git a/drivers/staging/rtl8821ae/rtl8821ae/hw.c b/drivers/staging/rtl8821ae/rtl8821ae/hw.c</span>
<span class="p_header">index ed3ed924b683..4d8d59acb902 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8821ae/rtl8821ae/hw.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8821ae/rtl8821ae/hw.c</span>
<span class="p_chunk">@@ -760,7 +760,7 @@</span> <span class="p_context"> void rtl8821ae_set_hw_reg(struct ieee80211_hw *hw, u8 variable, u8 *val)</span>
 
 		}
 	case HW_VAR_NAV_UPPER: {
<span class="p_del">-			u32	us_nav_upper = ((u32)*val);</span>
<span class="p_add">+			u32	us_nav_upper = *(u32 *)val;</span>
 
 			if(us_nav_upper &gt; HAL_92C_NAV_UPPER_UNIT * 0xFF)
 			{
<span class="p_header">diff --git a/drivers/staging/rts5208/rtsx_scsi.c b/drivers/staging/rts5208/rtsx_scsi.c</span>
<span class="p_header">index bbfa665c5c99..58ab211c6234 100644</span>
<span class="p_header">--- a/drivers/staging/rts5208/rtsx_scsi.c</span>
<span class="p_header">+++ b/drivers/staging/rts5208/rtsx_scsi.c</span>
<span class="p_chunk">@@ -417,7 +417,7 @@</span> <span class="p_context"> void set_sense_data(struct rtsx_chip *chip, unsigned int lun, u8 err_code,</span>
 	sense-&gt;ascq = ascq;
 	if (sns_key_info0 != 0) {
 		sense-&gt;sns_key_info[0] = SKSV | sns_key_info0;
<span class="p_del">-		sense-&gt;sns_key_info[1] = (sns_key_info1 &amp; 0xf0) &gt;&gt; 8;</span>
<span class="p_add">+		sense-&gt;sns_key_info[1] = (sns_key_info1 &amp; 0xf0) &gt;&gt; 4;</span>
 		sense-&gt;sns_key_info[2] = sns_key_info1 &amp; 0x0f;
 	}
 }
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index b62d65d46902..72cf56086c91 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -519,6 +519,8 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 	if (as-&gt;status &lt; 0 &amp;&amp; as-&gt;bulk_addr &amp;&amp; as-&gt;status != -ECONNRESET &amp;&amp;
 			as-&gt;status != -ENOENT)
 		cancel_bulk_urbs(ps, as-&gt;bulk_addr);
<span class="p_add">+</span>
<span class="p_add">+	wake_up(&amp;ps-&gt;wait);</span>
 	spin_unlock(&amp;ps-&gt;lock);
 
 	if (signr) {
<span class="p_chunk">@@ -526,8 +528,6 @@</span> <span class="p_context"> static void async_completed(struct urb *urb)</span>
 		put_pid(pid);
 		put_cred(cred);
 	}
<span class="p_del">-</span>
<span class="p_del">-	wake_up(&amp;ps-&gt;wait);</span>
 }
 
 static void destroy_async(struct usb_dev_state *ps, struct list_head *list)
<span class="p_header">diff --git a/drivers/usb/core/quirks.c b/drivers/usb/core/quirks.c</span>
<span class="p_header">index 88a49b1f8bbb..c9b564e362c8 100644</span>
<span class="p_header">--- a/drivers/usb/core/quirks.c</span>
<span class="p_header">+++ b/drivers/usb/core/quirks.c</span>
<span class="p_chunk">@@ -57,8 +57,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	/* Microsoft LifeCam-VX700 v2.0 */
 	{ USB_DEVICE(0x045e, 0x0770), .driver_info = USB_QUIRK_RESET_RESUME },
 
<span class="p_del">-	/* Logitech HD Pro Webcams C920 and C930e */</span>
<span class="p_add">+	/* Logitech HD Pro Webcams C920, C920-C and C930e */</span>
 	{ USB_DEVICE(0x046d, 0x082d), .driver_info = USB_QUIRK_DELAY_INIT },
<span class="p_add">+	{ USB_DEVICE(0x046d, 0x0841), .driver_info = USB_QUIRK_DELAY_INIT },</span>
 	{ USB_DEVICE(0x046d, 0x0843), .driver_info = USB_QUIRK_DELAY_INIT },
 
 	/* Logitech ConferenceCam CC3000e */
<span class="p_chunk">@@ -214,6 +215,9 @@</span> <span class="p_context"> static const struct usb_device_id usb_quirk_list[] = {</span>
 	{ USB_DEVICE(0x1a0a, 0x0200), .driver_info =
 			USB_QUIRK_LINEAR_UFRAME_INTR_BINTERVAL },
 
<span class="p_add">+	/* Corsair Strafe RGB */</span>
<span class="p_add">+	{ USB_DEVICE(0x1b1c, 0x1b20), .driver_info = USB_QUIRK_DELAY_INIT },</span>
<span class="p_add">+</span>
 	/* Acer C120 LED Projector */
 	{ USB_DEVICE(0x1de1, 0xc102), .driver_info = USB_QUIRK_NO_LPM },
 
<span class="p_header">diff --git a/drivers/usb/host/pci-quirks.c b/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">index 94039dc5de72..677b3714557e 100644</span>
<span class="p_header">--- a/drivers/usb/host/pci-quirks.c</span>
<span class="p_header">+++ b/drivers/usb/host/pci-quirks.c</span>
<span class="p_chunk">@@ -143,29 +143,30 @@</span> <span class="p_context"> static int amd_chipset_sb_type_init(struct amd_chipset_info *pinfo)</span>
 			pinfo-&gt;sb_type.gen = AMD_CHIPSET_SB700;
 		else if (rev &gt;= 0x40 &amp;&amp; rev &lt;= 0x4f)
 			pinfo-&gt;sb_type.gen = AMD_CHIPSET_SB800;
<span class="p_del">-	}</span>
<span class="p_del">-	pinfo-&gt;smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,</span>
<span class="p_del">-					  0x145c, NULL);</span>
<span class="p_del">-	if (pinfo-&gt;smbus_dev) {</span>
<span class="p_del">-		pinfo-&gt;sb_type.gen = AMD_CHIPSET_TAISHAN;</span>
 	} else {
 		pinfo-&gt;smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,
 				PCI_DEVICE_ID_AMD_HUDSON2_SMBUS, NULL);
 
<span class="p_del">-		if (!pinfo-&gt;smbus_dev) {</span>
<span class="p_del">-			pinfo-&gt;sb_type.gen = NOT_AMD_CHIPSET;</span>
<span class="p_del">-			return 0;</span>
<span class="p_add">+		if (pinfo-&gt;smbus_dev) {</span>
<span class="p_add">+			rev = pinfo-&gt;smbus_dev-&gt;revision;</span>
<span class="p_add">+			if (rev &gt;= 0x11 &amp;&amp; rev &lt;= 0x14)</span>
<span class="p_add">+				pinfo-&gt;sb_type.gen = AMD_CHIPSET_HUDSON2;</span>
<span class="p_add">+			else if (rev &gt;= 0x15 &amp;&amp; rev &lt;= 0x18)</span>
<span class="p_add">+				pinfo-&gt;sb_type.gen = AMD_CHIPSET_BOLTON;</span>
<span class="p_add">+			else if (rev &gt;= 0x39 &amp;&amp; rev &lt;= 0x3a)</span>
<span class="p_add">+				pinfo-&gt;sb_type.gen = AMD_CHIPSET_YANGTZE;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			pinfo-&gt;smbus_dev = pci_get_device(PCI_VENDOR_ID_AMD,</span>
<span class="p_add">+							  0x145c, NULL);</span>
<span class="p_add">+			if (pinfo-&gt;smbus_dev) {</span>
<span class="p_add">+				rev = pinfo-&gt;smbus_dev-&gt;revision;</span>
<span class="p_add">+				pinfo-&gt;sb_type.gen = AMD_CHIPSET_TAISHAN;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				pinfo-&gt;sb_type.gen = NOT_AMD_CHIPSET;</span>
<span class="p_add">+				return 0;</span>
<span class="p_add">+			}</span>
 		}
<span class="p_del">-</span>
<span class="p_del">-		rev = pinfo-&gt;smbus_dev-&gt;revision;</span>
<span class="p_del">-		if (rev &gt;= 0x11 &amp;&amp; rev &lt;= 0x14)</span>
<span class="p_del">-			pinfo-&gt;sb_type.gen = AMD_CHIPSET_HUDSON2;</span>
<span class="p_del">-		else if (rev &gt;= 0x15 &amp;&amp; rev &lt;= 0x18)</span>
<span class="p_del">-			pinfo-&gt;sb_type.gen = AMD_CHIPSET_BOLTON;</span>
<span class="p_del">-		else if (rev &gt;= 0x39 &amp;&amp; rev &lt;= 0x3a)</span>
<span class="p_del">-			pinfo-&gt;sb_type.gen = AMD_CHIPSET_YANGTZE;</span>
 	}
<span class="p_del">-</span>
 	pinfo-&gt;sb_type.rev = rev;
 	return 1;
 }
<span class="p_header">diff --git a/drivers/usb/serial/console.c b/drivers/usb/serial/console.c</span>
<span class="p_header">index 29fa1c3d0089..926c1f2dc962 100644</span>
<span class="p_header">--- a/drivers/usb/serial/console.c</span>
<span class="p_header">+++ b/drivers/usb/serial/console.c</span>
<span class="p_chunk">@@ -187,6 +187,7 @@</span> <span class="p_context"> static int usb_console_setup(struct console *co, char *options)</span>
 	tty_kref_put(tty);
  reset_open_count:
 	port-&gt;port.count = 0;
<span class="p_add">+	info-&gt;port = NULL;</span>
 	usb_autopm_put_interface(serial-&gt;interface);
  error_get_interface:
 	usb_serial_put(serial);
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 9cd199cbac2e..17d28273e03c 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -2034,6 +2034,7 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x02, 0x01) },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x2001, 0x7d03, 0xff, 0x00, 0x00) },
 	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7d04, 0xff) },			/* D-Link DWM-158 */
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7d0e, 0xff) },			/* D-Link DWM-157 C1 */</span>
 	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7e19, 0xff),			/* D-Link DWM-221 B1 */
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE_INTERFACE_CLASS(0x2001, 0x7e35, 0xff),			/* D-Link DWM-222 */
<span class="p_header">diff --git a/drivers/video/backlight/lm3630a_bl.c b/drivers/video/backlight/lm3630a_bl.c</span>
<span class="p_header">index 35fe4825a454..4505b92c189a 100644</span>
<span class="p_header">--- a/drivers/video/backlight/lm3630a_bl.c</span>
<span class="p_header">+++ b/drivers/video/backlight/lm3630a_bl.c</span>
<span class="p_chunk">@@ -31,7 +31,8 @@</span> <span class="p_context"></span>
 #define REG_FAULT	0x0B
 #define REG_PWM_OUTLOW	0x12
 #define REG_PWM_OUTHIGH	0x13
<span class="p_del">-#define REG_MAX		0x1F</span>
<span class="p_add">+#define REG_FILTER_STRENGTH	0x50</span>
<span class="p_add">+#define REG_MAX		0x50</span>
 
 #define INT_DEBOUNCE_MSEC	10
 struct lm3630a_chip {
<span class="p_chunk">@@ -80,7 +81,7 @@</span> <span class="p_context"> static int lm3630a_chip_init(struct lm3630a_chip *pchip)</span>
 
 	usleep_range(1000, 2000);
 	/* set Filter Strength Register */
<span class="p_del">-	rval = lm3630a_write(pchip, 0x50, 0x03);</span>
<span class="p_add">+	rval = lm3630a_write(pchip, REG_FILTER_STRENGTH, 0x03);</span>
 	/* set Cofig. register */
 	rval |= lm3630a_update(pchip, REG_CONFIG, 0x07, pdata-&gt;pwm_ctrl);
 	/* set boost control */
<span class="p_header">diff --git a/drivers/xen/events/events_fifo.c b/drivers/xen/events/events_fifo.c</span>
<span class="p_header">index e208af22b182..b22f709a05b4 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_fifo.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_fifo.c</span>
<span class="p_chunk">@@ -445,19 +445,18 @@</span> <span class="p_context"> static struct notifier_block evtchn_fifo_cpu_notifier = {</span>
 
 int __init xen_evtchn_fifo_init(void)
 {
<span class="p_del">-	int cpu = get_cpu();</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
 	int ret;
 
 	ret = evtchn_fifo_alloc_control_block(cpu);
 	if (ret &lt; 0)
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return ret;</span>
 
 	pr_info(&quot;Using FIFO-based ABI\n&quot;);
 
 	evtchn_ops = &amp;evtchn_ops_fifo;
 
 	register_cpu_notifier(&amp;evtchn_fifo_cpu_notifier);
<span class="p_del">-out:</span>
<span class="p_del">-	put_cpu();</span>
<span class="p_add">+</span>
 	return ret;
 }
<span class="p_header">diff --git a/fs/btrfs/super.c b/fs/btrfs/super.c</span>
<span class="p_header">index 863f3d65fe39..3cec2fb4fdc1 100644</span>
<span class="p_header">--- a/fs/btrfs/super.c</span>
<span class="p_header">+++ b/fs/btrfs/super.c</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"></span>
 #include &quot;free-space-cache.h&quot;
 #include &quot;backref.h&quot;
 #include &quot;tests/btrfs-tests.h&quot;
<span class="p_add">+#include &quot;qgroup.h&quot;</span>
 
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/btrfs.h&gt;
<span class="p_chunk">@@ -1495,6 +1496,8 @@</span> <span class="p_context"> static int btrfs_remount(struct super_block *sb, int *flags, char *data)</span>
 			goto restore;
 		}
 
<span class="p_add">+		btrfs_qgroup_rescan_resume(fs_info);</span>
<span class="p_add">+</span>
 		if (!fs_info-&gt;uuid_root) {
 			btrfs_info(fs_info, &quot;creating UUID tree&quot;);
 			ret = btrfs_create_uuid_tree(fs_info);
<span class="p_header">diff --git a/fs/dlm/user.c b/fs/dlm/user.c</span>
<span class="p_header">index 142e21655eed..12bcb3bf55ee 100644</span>
<span class="p_header">--- a/fs/dlm/user.c</span>
<span class="p_header">+++ b/fs/dlm/user.c</span>
<span class="p_chunk">@@ -346,6 +346,10 @@</span> <span class="p_context"> static int dlm_device_register(struct dlm_ls *ls, char *name)</span>
 	error = misc_register(&amp;ls-&gt;ls_device);
 	if (error) {
 		kfree(ls-&gt;ls_device.name);
<span class="p_add">+		/* this has to be set to NULL</span>
<span class="p_add">+		 * to avoid a double-free in dlm_device_deregister</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ls-&gt;ls_device.name = NULL;</span>
 	}
 fail:
 	return error;
<span class="p_header">diff --git a/fs/f2fs/recovery.c b/fs/f2fs/recovery.c</span>
<span class="p_header">index a112368a4a86..3762e9436278 100644</span>
<span class="p_header">--- a/fs/f2fs/recovery.c</span>
<span class="p_header">+++ b/fs/f2fs/recovery.c</span>
<span class="p_chunk">@@ -239,7 +239,7 @@</span> <span class="p_context"> static int check_index_in_prev_nodes(struct f2fs_sb_info *sbi,</span>
 		return 0;
 
 	/* Get the previous summary */
<span class="p_del">-	for (i = CURSEG_WARM_DATA; i &lt;= CURSEG_COLD_DATA; i++) {</span>
<span class="p_add">+	for (i = CURSEG_HOT_DATA; i &lt;= CURSEG_COLD_DATA; i++) {</span>
 		struct curseg_info *curseg = CURSEG_I(sbi, i);
 		if (curseg-&gt;segno == segno) {
 			sum = curseg-&gt;sum_blk-&gt;entries[blkoff];
<span class="p_header">diff --git a/fs/fcntl.c b/fs/fcntl.c</span>
<span class="p_header">index 72c82f69b01b..2ddbed2492df 100644</span>
<span class="p_header">--- a/fs/fcntl.c</span>
<span class="p_header">+++ b/fs/fcntl.c</span>
<span class="p_chunk">@@ -472,10 +472,21 @@</span> <span class="p_context"> static void send_sigio_to_task(struct task_struct *p,</span>
 			si.si_signo = signum;
 			si.si_errno = 0;
 		        si.si_code  = reason;
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Posix definies POLL_IN and friends to be signal</span>
<span class="p_add">+			 * specific si_codes for SIG_POLL.  Linux extended</span>
<span class="p_add">+			 * these si_codes to other signals in a way that is</span>
<span class="p_add">+			 * ambiguous if other signals also have signal</span>
<span class="p_add">+			 * specific si_codes.  In that case use SI_SIGIO instead</span>
<span class="p_add">+			 * to remove the ambiguity.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (sig_specific_sicodes(signum))</span>
<span class="p_add">+				si.si_code = SI_SIGIO;</span>
<span class="p_add">+</span>
 			/* Make sure we are called with one of the POLL_*
 			   reasons, otherwise we could leak kernel stack into
 			   userspace.  */
<span class="p_del">-			BUG_ON((reason &amp; __SI_MASK) != __SI_POLL);</span>
<span class="p_add">+			BUG_ON((reason &lt; POLL_IN) || ((reason - POLL_IN) &gt;= NSIGPOLL));</span>
 			if (reason - POLL_IN &gt;= NSIGPOLL)
 				si.si_band  = ~0L;
 			else
<span class="p_header">diff --git a/fs/xfs/xfs_log.c b/fs/xfs/xfs_log.c</span>
<span class="p_header">index 292308dede6d..fa81c1c8f0da 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_log.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_log.c</span>
<span class="p_chunk">@@ -3257,8 +3257,6 @@</span> <span class="p_context"> _xfs_log_force(</span>
 		 */
 		if (iclog-&gt;ic_state &amp; XLOG_STATE_IOERROR)
 			return XFS_ERROR(EIO);
<span class="p_del">-		if (log_flushed)</span>
<span class="p_del">-			*log_flushed = 1;</span>
 	} else {
 
 no_sleep:
<span class="p_chunk">@@ -3366,8 +3364,6 @@</span> <span class="p_context"> _xfs_log_force_lsn(</span>
 
 				xlog_wait(&amp;iclog-&gt;ic_prev-&gt;ic_write_wait,
 							&amp;log-&gt;l_icloglock);
<span class="p_del">-				if (log_flushed)</span>
<span class="p_del">-					*log_flushed = 1;</span>
 				already_slept = 1;
 				goto try_again;
 			}
<span class="p_chunk">@@ -3401,9 +3397,6 @@</span> <span class="p_context"> _xfs_log_force_lsn(</span>
 			 */
 			if (iclog-&gt;ic_state &amp; XLOG_STATE_IOERROR)
 				return XFS_ERROR(EIO);
<span class="p_del">-</span>
<span class="p_del">-			if (log_flushed)</span>
<span class="p_del">-				*log_flushed = 1;</span>
 		} else {		/* just return */
 			spin_unlock(&amp;log-&gt;l_icloglock);
 		}
<span class="p_header">diff --git a/include/asm-generic/sections.h b/include/asm-generic/sections.h</span>
<span class="p_header">index b58fd667f87b..af0254c09424 100644</span>
<span class="p_header">--- a/include/asm-generic/sections.h</span>
<span class="p_header">+++ b/include/asm-generic/sections.h</span>
<span class="p_chunk">@@ -4,6 +4,7 @@</span> <span class="p_context"></span>
 /* References to section boundaries */
 
 #include &lt;linux/compiler.h&gt;
<span class="p_add">+#include &lt;linux/types.h&gt;</span>
 
 /*
  * Usage guidelines:
<span class="p_chunk">@@ -63,4 +64,68 @@</span> <span class="p_context"> static inline int arch_is_kernel_data(unsigned long addr)</span>
 }
 #endif
 
<span class="p_add">+/**</span>
<span class="p_add">+ * memory_contains - checks if an object is contained within a memory region</span>
<span class="p_add">+ * @begin: virtual address of the beginning of the memory region</span>
<span class="p_add">+ * @end: virtual address of the end of the memory region</span>
<span class="p_add">+ * @virt: virtual address of the memory object</span>
<span class="p_add">+ * @size: size of the memory object</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns: true if the object specified by @virt and @size is entirely</span>
<span class="p_add">+ * contained within the memory region defined by @begin and @end, false</span>
<span class="p_add">+ * otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool memory_contains(void *begin, void *end, void *virt,</span>
<span class="p_add">+				   size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return virt &gt;= begin &amp;&amp; virt + size &lt;= end;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * memory_intersects - checks if the region occupied by an object intersects</span>
<span class="p_add">+ *                     with another memory region</span>
<span class="p_add">+ * @begin: virtual address of the beginning of the memory regien</span>
<span class="p_add">+ * @end: virtual address of the end of the memory region</span>
<span class="p_add">+ * @virt: virtual address of the memory object</span>
<span class="p_add">+ * @size: size of the memory object</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns: true if an object&#39;s memory region, specified by @virt and @size,</span>
<span class="p_add">+ * intersects with the region specified by @begin and @end, false otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool memory_intersects(void *begin, void *end, void *virt,</span>
<span class="p_add">+				     size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *vend = virt + size;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (virt &gt;= begin &amp;&amp; virt &lt; end) || (vend &gt;= begin &amp;&amp; vend &lt; end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * init_section_contains - checks if an object is contained within the init</span>
<span class="p_add">+ *                         section</span>
<span class="p_add">+ * @virt: virtual address of the memory object</span>
<span class="p_add">+ * @size: size of the memory object</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns: true if the object specified by @virt and @size is entirely</span>
<span class="p_add">+ * contained within the init section, false otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool init_section_contains(void *virt, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return memory_contains(__init_begin, __init_end, virt, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * init_section_intersects - checks if the region occupied by an object</span>
<span class="p_add">+ *                           intersects with the init section</span>
<span class="p_add">+ * @virt: virtual address of the memory object</span>
<span class="p_add">+ * @size: size of the memory object</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns: true if an object&#39;s memory region, specified by @virt and @size,</span>
<span class="p_add">+ * intersects with the init section, false otherwise.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool init_section_intersects(void *virt, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return memory_intersects(__init_begin, __init_end, virt, size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* _ASM_GENERIC_SECTIONS_H_ */
<span class="p_header">diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h</span>
<span class="p_header">index cf1846de8196..32709bcecfdd 100644</span>
<span class="p_header">--- a/include/linux/pci_ids.h</span>
<span class="p_header">+++ b/include/linux/pci_ids.h</span>
<span class="p_chunk">@@ -568,6 +568,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_AMD_CS5536_EHC    0x2095
 #define PCI_DEVICE_ID_AMD_CS5536_UDC    0x2096
 #define PCI_DEVICE_ID_AMD_CS5536_UOC    0x2097
<span class="p_add">+#define PCI_DEVICE_ID_AMD_CS5536_DEV_IDE    0x2092</span>
 #define PCI_DEVICE_ID_AMD_CS5536_IDE    0x209A
 #define PCI_DEVICE_ID_AMD_LX_VIDEO  0x2081
 #define PCI_DEVICE_ID_AMD_LX_AES    0x2082
<span class="p_header">diff --git a/include/linux/signal.h b/include/linux/signal.h</span>
<span class="p_header">index aa2625788594..eab3c8304543 100644</span>
<span class="p_header">--- a/include/linux/signal.h</span>
<span class="p_header">+++ b/include/linux/signal.h</span>
<span class="p_chunk">@@ -401,7 +401,9 @@</span> <span class="p_context"> int unhandled_signal(struct task_struct *tsk, int sig);</span>
 #else
 #define rt_sigmask(sig)	sigmask(sig)
 #endif
<span class="p_del">-#define siginmask(sig, mask) (rt_sigmask(sig) &amp; (mask))</span>
<span class="p_add">+</span>
<span class="p_add">+#define siginmask(sig, mask) \</span>
<span class="p_add">+	((sig) &lt; SIGRTMIN &amp;&amp; (rt_sigmask(sig) &amp; (mask)))</span>
 
 #define SIG_KERNEL_ONLY_MASK (\
 	rt_sigmask(SIGKILL)   |  rt_sigmask(SIGSTOP))
<span class="p_chunk">@@ -422,14 +424,18 @@</span> <span class="p_context"> int unhandled_signal(struct task_struct *tsk, int sig);</span>
         rt_sigmask(SIGCONT)   |  rt_sigmask(SIGCHLD)   | \
 	rt_sigmask(SIGWINCH)  |  rt_sigmask(SIGURG)    )
 
<span class="p_del">-#define sig_kernel_only(sig) \</span>
<span class="p_del">-	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_ONLY_MASK))</span>
<span class="p_del">-#define sig_kernel_coredump(sig) \</span>
<span class="p_del">-	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_COREDUMP_MASK))</span>
<span class="p_del">-#define sig_kernel_ignore(sig) \</span>
<span class="p_del">-	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_IGNORE_MASK))</span>
<span class="p_del">-#define sig_kernel_stop(sig) \</span>
<span class="p_del">-	(((sig) &lt; SIGRTMIN) &amp;&amp; siginmask(sig, SIG_KERNEL_STOP_MASK))</span>
<span class="p_add">+#define SIG_SPECIFIC_SICODES_MASK (\</span>
<span class="p_add">+	rt_sigmask(SIGILL)    |  rt_sigmask(SIGFPE)    | \</span>
<span class="p_add">+	rt_sigmask(SIGSEGV)   |  rt_sigmask(SIGBUS)    | \</span>
<span class="p_add">+	rt_sigmask(SIGTRAP)   |  rt_sigmask(SIGCHLD)   | \</span>
<span class="p_add">+	rt_sigmask(SIGPOLL)   |  rt_sigmask(SIGSYS)    | \</span>
<span class="p_add">+	SIGEMT_MASK                                    )</span>
<span class="p_add">+</span>
<span class="p_add">+#define sig_kernel_only(sig)		siginmask(sig, SIG_KERNEL_ONLY_MASK)</span>
<span class="p_add">+#define sig_kernel_coredump(sig)	siginmask(sig, SIG_KERNEL_COREDUMP_MASK)</span>
<span class="p_add">+#define sig_kernel_ignore(sig)		siginmask(sig, SIG_KERNEL_IGNORE_MASK)</span>
<span class="p_add">+#define sig_kernel_stop(sig)		siginmask(sig, SIG_KERNEL_STOP_MASK)</span>
<span class="p_add">+#define sig_specific_sicodes(sig)	siginmask(sig, SIG_SPECIFIC_SICODES_MASK)</span>
 
 #define sig_user_defined(t, signr) \
 	(((t)-&gt;sighand-&gt;action[(signr)-1].sa.sa_handler != SIG_DFL) &amp;&amp;	\
<span class="p_header">diff --git a/include/net/inet_frag.h b/include/net/inet_frag.h</span>
<span class="p_header">index 6f59de98dabd..223feaadaee2 100644</span>
<span class="p_header">--- a/include/net/inet_frag.h</span>
<span class="p_header">+++ b/include/net/inet_frag.h</span>
<span class="p_chunk">@@ -1,18 +1,13 @@</span> <span class="p_context"></span>
 #ifndef __NET_FRAG_H__
 #define __NET_FRAG_H__
 
<span class="p_del">-#include &lt;linux/percpu_counter.h&gt;</span>
<span class="p_del">-</span>
 struct netns_frags {
 	int			nqueues;
 	struct list_head	lru_list;
 	spinlock_t		lru_lock;
 
<span class="p_del">-	/* The percpu_counter &quot;mem&quot; need to be cacheline aligned.</span>
<span class="p_del">-	 *  mem.count must not share cacheline with other writers</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	struct percpu_counter   mem ____cacheline_aligned_in_smp;</span>
<span class="p_del">-</span>
<span class="p_add">+	/* Keep atomic mem on separate cachelines in structs that include it */</span>
<span class="p_add">+	atomic_t		mem ____cacheline_aligned_in_smp;</span>
 	/* sysctls */
 	int			timeout;
 	int			high_thresh;
<span class="p_chunk">@@ -104,42 +99,29 @@</span> <span class="p_context"> static inline void inet_frag_put(struct inet_frag_queue *q, struct inet_frags *f</span>
 
 /* Memory Tracking Functions. */
 
<span class="p_del">-/* The default percpu_counter batch size is not big enough to scale to</span>
<span class="p_del">- * fragmentation mem acct sizes.</span>
<span class="p_del">- * The mem size of a 64K fragment is approx:</span>
<span class="p_del">- *  (44 fragments * 2944 truesize) + frag_queue struct(200) = 129736 bytes</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned int frag_percpu_counter_batch = 130000;</span>
<span class="p_del">-</span>
 static inline int frag_mem_limit(struct netns_frags *nf)
 {
<span class="p_del">-	return percpu_counter_read(&amp;nf-&gt;mem);</span>
<span class="p_add">+	return atomic_read(&amp;nf-&gt;mem);</span>
 }
 
 static inline void sub_frag_mem_limit(struct inet_frag_queue *q, int i)
 {
<span class="p_del">-	__percpu_counter_add(&amp;q-&gt;net-&gt;mem, -i, frag_percpu_counter_batch);</span>
<span class="p_add">+	atomic_sub(i, &amp;q-&gt;net-&gt;mem);</span>
 }
 
 static inline void add_frag_mem_limit(struct inet_frag_queue *q, int i)
 {
<span class="p_del">-	__percpu_counter_add(&amp;q-&gt;net-&gt;mem, i, frag_percpu_counter_batch);</span>
<span class="p_add">+	atomic_add(i, &amp;q-&gt;net-&gt;mem);</span>
 }
 
 static inline void init_frag_mem_limit(struct netns_frags *nf)
 {
<span class="p_del">-	percpu_counter_init(&amp;nf-&gt;mem, 0);</span>
<span class="p_add">+	atomic_set(&amp;nf-&gt;mem, 0);</span>
 }
 
 static inline int sum_frag_mem_limit(struct netns_frags *nf)
 {
<span class="p_del">-	int res;</span>
<span class="p_del">-</span>
<span class="p_del">-	local_bh_disable();</span>
<span class="p_del">-	res = percpu_counter_sum_positive(&amp;nf-&gt;mem);</span>
<span class="p_del">-	local_bh_enable();</span>
<span class="p_del">-</span>
<span class="p_del">-	return res;</span>
<span class="p_add">+	return atomic_read(&amp;nf-&gt;mem);</span>
 }
 
 static inline void inet_frag_lru_move(struct inet_frag_queue *q)
<span class="p_header">diff --git a/include/uapi/asm-generic/siginfo.h b/include/uapi/asm-generic/siginfo.h</span>
<span class="p_header">index ba5be7fdbdfe..7680e28fe4f9 100644</span>
<span class="p_header">--- a/include/uapi/asm-generic/siginfo.h</span>
<span class="p_header">+++ b/include/uapi/asm-generic/siginfo.h</span>
<span class="p_chunk">@@ -161,7 +161,7 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 #define SI_TIMER __SI_CODE(__SI_TIMER,-2) /* sent by timer expiration */
 #define SI_MESGQ __SI_CODE(__SI_MESGQ,-3) /* sent by real time mesq state change */
 #define SI_ASYNCIO	-4		/* sent by AIO completion */
<span class="p_del">-#define SI_SIGIO	-5		/* sent by queued SIGIO */</span>
<span class="p_add">+#define SI_SIGIO __SI_CODE(__SI_POLL,-5) /* sent by queued SIGIO */</span>
 #define SI_TKILL	-6		/* sent by tkill system call */
 #define SI_DETHREAD	-7		/* sent by execve() killing subsidiary threads */
 
<span class="p_chunk">@@ -234,7 +234,7 @@</span> <span class="p_context"> typedef struct siginfo {</span>
 #define NSIGCHLD	6
 
 /*
<span class="p_del">- * SIGPOLL si_codes</span>
<span class="p_add">+ * SIGPOLL (or any other signal without signal specific si_codes) si_codes</span>
  */
 #define POLL_IN		(__SI_POLL|1)	/* data input available */
 #define POLL_OUT	(__SI_POLL|2)	/* output buffers available */
<span class="p_header">diff --git a/kernel/irq/irqdesc.c b/kernel/irq/irqdesc.c</span>
<span class="p_header">index 3922869d927a..f160d21bd998 100644</span>
<span class="p_header">--- a/kernel/irq/irqdesc.c</span>
<span class="p_header">+++ b/kernel/irq/irqdesc.c</span>
<span class="p_chunk">@@ -183,9 +183,7 @@</span> <span class="p_context"> static void free_desc(unsigned int irq)</span>
 	 * sparse tree we can free it. Access in proc will fail to
 	 * lookup the descriptor.
 	 */
<span class="p_del">-	mutex_lock(&amp;sparse_irq_lock);</span>
 	delete_irq_desc(irq);
<span class="p_del">-	mutex_unlock(&amp;sparse_irq_lock);</span>
 
 	free_masks(desc);
 	free_percpu(desc-&gt;kstat_irqs);
<span class="p_chunk">@@ -202,19 +200,14 @@</span> <span class="p_context"> static int alloc_descs(unsigned int start, unsigned int cnt, int node,</span>
 		desc = alloc_desc(start + i, node, owner);
 		if (!desc)
 			goto err;
<span class="p_del">-		mutex_lock(&amp;sparse_irq_lock);</span>
 		irq_insert_desc(start + i, desc);
<span class="p_del">-		mutex_unlock(&amp;sparse_irq_lock);</span>
 	}
<span class="p_add">+	bitmap_set(allocated_irqs, start, cnt);</span>
 	return start;
 
 err:
 	for (i--; i &gt;= 0; i--)
 		free_desc(start + i);
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;sparse_irq_lock);</span>
<span class="p_del">-	bitmap_clear(allocated_irqs, start, cnt);</span>
<span class="p_del">-	mutex_unlock(&amp;sparse_irq_lock);</span>
 	return -ENOMEM;
 }
 
<span class="p_chunk">@@ -312,6 +305,7 @@</span> <span class="p_context"> static inline int alloc_descs(unsigned int start, unsigned int cnt, int node,</span>
 
 		desc-&gt;owner = owner;
 	}
<span class="p_add">+	bitmap_set(allocated_irqs, start, cnt);</span>
 	return start;
 }
 
<span class="p_chunk">@@ -366,10 +360,10 @@</span> <span class="p_context"> void irq_free_descs(unsigned int from, unsigned int cnt)</span>
 	if (from &gt;= nr_irqs || (from + cnt) &gt; nr_irqs)
 		return;
 
<span class="p_add">+	mutex_lock(&amp;sparse_irq_lock);</span>
 	for (i = 0; i &lt; cnt; i++)
 		free_desc(from + i);
 
<span class="p_del">-	mutex_lock(&amp;sparse_irq_lock);</span>
 	bitmap_clear(allocated_irqs, from, cnt);
 	mutex_unlock(&amp;sparse_irq_lock);
 }
<span class="p_chunk">@@ -413,19 +407,15 @@</span> <span class="p_context"> __irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,</span>
 					   from, cnt, 0);
 	ret = -EEXIST;
 	if (irq &gt;=0 &amp;&amp; start != irq)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto unlock;</span>
 
 	if (start + cnt &gt; nr_irqs) {
 		ret = irq_expand_nr_irqs(start + cnt);
 		if (ret)
<span class="p_del">-			goto err;</span>
<span class="p_add">+			goto unlock;</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	bitmap_set(allocated_irqs, start, cnt);</span>
<span class="p_del">-	mutex_unlock(&amp;sparse_irq_lock);</span>
<span class="p_del">-	return alloc_descs(start, cnt, node, owner);</span>
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_add">+	ret = alloc_descs(start, cnt, node, owner);</span>
<span class="p_add">+unlock:</span>
 	mutex_unlock(&amp;sparse_irq_lock);
 	return ret;
 }
<span class="p_header">diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c</span>
<span class="p_header">index e4c6905db298..09d5b8143b94 100644</span>
<span class="p_header">--- a/kernel/printk/printk.c</span>
<span class="p_header">+++ b/kernel/printk/printk.c</span>
<span class="p_chunk">@@ -47,6 +47,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/utsname.h&gt;
 
 #include &lt;asm/uaccess.h&gt;
<span class="p_add">+#include &lt;asm-generic/sections.h&gt;</span>
 
 #define CREATE_TRACE_POINTS
 #include &lt;trace/events/printk.h&gt;
<span class="p_chunk">@@ -2558,12 +2559,33 @@</span> <span class="p_context"> int unregister_console(struct console *console)</span>
 }
 EXPORT_SYMBOL(unregister_console);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Some boot consoles access data that is in the init section and which will</span>
<span class="p_add">+ * be discarded after the initcalls have been run. To make sure that no code</span>
<span class="p_add">+ * will access this data, unregister the boot consoles in a late initcall.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If for some reason, such as deferred probe or the driver being a loadable</span>
<span class="p_add">+ * module, the real console hasn&#39;t registered yet at this point, there will</span>
<span class="p_add">+ * be a brief interval in which no messages are logged to the console, which</span>
<span class="p_add">+ * makes it difficult to diagnose problems that occur during this time.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * To mitigate this problem somewhat, only unregister consoles whose memory</span>
<span class="p_add">+ * intersects with the init section. Note that all other boot consoles will</span>
<span class="p_add">+ * get unregistred when the real preferred console is registered.</span>
<span class="p_add">+ */</span>
 static int __init printk_late_init(void)
 {
 	struct console *con;
 
 	for_each_console(con) {
<span class="p_del">-		if (!keep_bootcon &amp;&amp; con-&gt;flags &amp; CON_BOOT) {</span>
<span class="p_add">+		if ((con-&gt;flags &amp; CON_BOOT) &amp;&amp;</span>
<span class="p_add">+		    init_section_intersects(con, sizeof(*con))) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Please, consider moving the reported consoles out</span>
<span class="p_add">+			 * of the init section.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			pr_warn(&quot;bootconsole [%s%d] uses init memory and must be disabled even before the real one is ready\n&quot;,</span>
<span class="p_add">+				con-&gt;name, con-&gt;index);</span>
 			unregister_console(con);
 		}
 	}
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 4df317cb0e9a..591bbffc2384 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -4945,7 +4945,7 @@</span> <span class="p_context"> static int tracing_set_clock(struct trace_array *tr, const char *clockstr)</span>
 	tracing_reset_online_cpus(&amp;tr-&gt;trace_buffer);
 
 #ifdef CONFIG_TRACER_MAX_TRACE
<span class="p_del">-	if (tr-&gt;flags &amp; TRACE_ARRAY_FL_GLOBAL &amp;&amp; tr-&gt;max_buffer.buffer)</span>
<span class="p_add">+	if (tr-&gt;max_buffer.buffer)</span>
 		ring_buffer_set_clock(tr-&gt;max_buffer.buffer, trace_clocks[i].func);
 	tracing_reset_online_cpus(&amp;tr-&gt;max_buffer);
 #endif
<span class="p_header">diff --git a/kernel/trace/trace_selftest.c b/kernel/trace/trace_selftest.c</span>
<span class="p_header">index 5ef60499dc8e..bacea05e0a06 100644</span>
<span class="p_header">--- a/kernel/trace/trace_selftest.c</span>
<span class="p_header">+++ b/kernel/trace/trace_selftest.c</span>
<span class="p_chunk">@@ -272,7 +272,7 @@</span> <span class="p_context"> static int trace_selftest_ops(struct trace_array *tr, int cnt)</span>
 		goto out_free;
 	if (cnt &gt; 1) {
 		if (trace_selftest_test_global_cnt == 0)
<span class="p_del">-			goto out;</span>
<span class="p_add">+			goto out_free;</span>
 	}
 	if (trace_selftest_test_dyn_cnt == 0)
 		goto out_free;
<span class="p_header">diff --git a/net/core/net-sysfs.c b/net/core/net-sysfs.c</span>
<span class="p_header">index 1cac29ebb05b..777ac525ef27 100644</span>
<span class="p_header">--- a/net/core/net-sysfs.c</span>
<span class="p_header">+++ b/net/core/net-sysfs.c</span>
<span class="p_chunk">@@ -786,20 +786,19 @@</span> <span class="p_context"> static int rx_queue_add_kobject(struct net_device *net, int index)</span>
 	error = kobject_init_and_add(kobj, &amp;rx_queue_ktype, NULL,
 	    &quot;rx-%u&quot;, index);
 	if (error)
<span class="p_del">-		goto exit;</span>
<span class="p_add">+		return error;</span>
 
 	if (net-&gt;sysfs_rx_queue_group) {
 		error = sysfs_create_group(kobj, net-&gt;sysfs_rx_queue_group);
<span class="p_del">-		if (error)</span>
<span class="p_del">-			goto exit;</span>
<span class="p_add">+		if (error) {</span>
<span class="p_add">+			kobject_put(kobj);</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		}</span>
 	}
 
 	kobject_uevent(kobj, KOBJ_ADD);
 	dev_hold(queue-&gt;dev);
 
<span class="p_del">-	return error;</span>
<span class="p_del">-exit:</span>
<span class="p_del">-	kobject_put(kobj);</span>
 	return error;
 }
 #endif /* CONFIG_SYSFS */
<span class="p_chunk">@@ -1145,21 +1144,20 @@</span> <span class="p_context"> static int netdev_queue_add_kobject(struct net_device *net, int index)</span>
 	error = kobject_init_and_add(kobj, &amp;netdev_queue_ktype, NULL,
 	    &quot;tx-%u&quot;, index);
 	if (error)
<span class="p_del">-		goto exit;</span>
<span class="p_add">+		return error;</span>
 
 #ifdef CONFIG_BQL
 	error = sysfs_create_group(kobj, &amp;dql_group);
<span class="p_del">-	if (error)</span>
<span class="p_del">-		goto exit;</span>
<span class="p_add">+	if (error) {</span>
<span class="p_add">+		kobject_put(kobj);</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	}</span>
 #endif
 
 	kobject_uevent(kobj, KOBJ_ADD);
 	dev_hold(queue-&gt;dev);
 
 	return 0;
<span class="p_del">-exit:</span>
<span class="p_del">-	kobject_put(kobj);</span>
<span class="p_del">-	return error;</span>
 }
 #endif /* CONFIG_SYSFS */
 
<span class="p_header">diff --git a/net/ipv4/inet_fragment.c b/net/ipv4/inet_fragment.c</span>
<span class="p_header">index 3b01959bf4bb..e5c94fababe6 100644</span>
<span class="p_header">--- a/net/ipv4/inet_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/inet_fragment.c</span>
<span class="p_chunk">@@ -122,8 +122,6 @@</span> <span class="p_context"> void inet_frags_exit_net(struct netns_frags *nf, struct inet_frags *f)</span>
 	local_bh_disable();
 	inet_frag_evictor(nf, f, true);
 	local_bh_enable();
<span class="p_del">-</span>
<span class="p_del">-	percpu_counter_destroy(&amp;nf-&gt;mem);</span>
 }
 EXPORT_SYMBOL(inet_frags_exit_net);
 
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index 9f6024f0821d..567a8646bd47 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -174,6 +174,12 @@</span> <span class="p_context"> static __inline__ void rt6_release(struct rt6_info *rt)</span>
 		dst_free(&amp;rt-&gt;dst);
 }
 
<span class="p_add">+static void fib6_free_table(struct fib6_table *table)</span>
<span class="p_add">+{</span>
<span class="p_add">+	inetpeer_invalidate_tree(&amp;table-&gt;tb6_peers);</span>
<span class="p_add">+	kfree(table);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void fib6_link_table(struct net *net, struct fib6_table *tb)
 {
 	unsigned int h;
<span class="p_chunk">@@ -1836,15 +1842,22 @@</span> <span class="p_context"> static int __net_init fib6_net_init(struct net *net)</span>
 
 static void fib6_net_exit(struct net *net)
 {
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
 	rt6_ifdown(net, NULL);
 	del_timer_sync(&amp;net-&gt;ipv6.ip6_fib_timer);
 
<span class="p_del">-#ifdef CONFIG_IPV6_MULTIPLE_TABLES</span>
<span class="p_del">-	inetpeer_invalidate_tree(&amp;net-&gt;ipv6.fib6_local_tbl-&gt;tb6_peers);</span>
<span class="p_del">-	kfree(net-&gt;ipv6.fib6_local_tbl);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	inetpeer_invalidate_tree(&amp;net-&gt;ipv6.fib6_main_tbl-&gt;tb6_peers);</span>
<span class="p_del">-	kfree(net-&gt;ipv6.fib6_main_tbl);</span>
<span class="p_add">+	for (i = 0; i &lt; FIB6_TABLE_HASHSZ; i++) {</span>
<span class="p_add">+		struct hlist_head *head = &amp;net-&gt;ipv6.fib_table_hash[i];</span>
<span class="p_add">+		struct hlist_node *tmp;</span>
<span class="p_add">+		struct fib6_table *tb;</span>
<span class="p_add">+</span>
<span class="p_add">+		hlist_for_each_entry_safe(tb, tmp, head, tb6_hlist) {</span>
<span class="p_add">+			hlist_del(&amp;tb-&gt;tb6_hlist);</span>
<span class="p_add">+			fib6_free_table(tb);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	kfree(net-&gt;ipv6.fib_table_hash);
 	kfree(net-&gt;ipv6.rt6_stats);
 }
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index 45374242d19a..35f97d9abc4b 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -377,13 +377,21 @@</span> <span class="p_context"> static int l2tp_session_add_to_tunnel(struct l2tp_tunnel *tunnel,</span>
 	struct hlist_head *g_head;
 	struct hlist_head *head;
 	struct l2tp_net *pn;
<span class="p_add">+	int err;</span>
 
 	head = l2tp_session_id_hash(tunnel, session-&gt;session_id);
 
 	write_lock_bh(&amp;tunnel-&gt;hlist_lock);
<span class="p_add">+	if (!tunnel-&gt;acpt_newsess) {</span>
<span class="p_add">+		err = -ENODEV;</span>
<span class="p_add">+		goto err_tlock;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	hlist_for_each_entry(session_walk, head, hlist)
<span class="p_del">-		if (session_walk-&gt;session_id == session-&gt;session_id)</span>
<span class="p_del">-			goto exist;</span>
<span class="p_add">+		if (session_walk-&gt;session_id == session-&gt;session_id) {</span>
<span class="p_add">+			err = -EEXIST;</span>
<span class="p_add">+			goto err_tlock;</span>
<span class="p_add">+		}</span>
 
 	if (tunnel-&gt;version == L2TP_HDR_VER_3) {
 		pn = l2tp_pernet(tunnel-&gt;l2tp_net);
<span class="p_chunk">@@ -391,12 +399,21 @@</span> <span class="p_context"> static int l2tp_session_add_to_tunnel(struct l2tp_tunnel *tunnel,</span>
 						session-&gt;session_id);
 
 		spin_lock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);
<span class="p_add">+</span>
 		hlist_for_each_entry(session_walk, g_head, global_hlist)
<span class="p_del">-			if (session_walk-&gt;session_id == session-&gt;session_id)</span>
<span class="p_del">-				goto exist_glob;</span>
<span class="p_add">+			if (session_walk-&gt;session_id == session-&gt;session_id) {</span>
<span class="p_add">+				err = -EEXIST;</span>
<span class="p_add">+				goto err_tlock_pnlock;</span>
<span class="p_add">+			}</span>
 
<span class="p_add">+		l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_add">+		sock_hold(tunnel-&gt;sock);</span>
 		hlist_add_head_rcu(&amp;session-&gt;global_hlist, g_head);
<span class="p_add">+</span>
 		spin_unlock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);
<span class="p_add">+	} else {</span>
<span class="p_add">+		l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_add">+		sock_hold(tunnel-&gt;sock);</span>
 	}
 
 	hlist_add_head(&amp;session-&gt;hlist, head);
<span class="p_chunk">@@ -404,12 +421,12 @@</span> <span class="p_context"> static int l2tp_session_add_to_tunnel(struct l2tp_tunnel *tunnel,</span>
 
 	return 0;
 
<span class="p_del">-exist_glob:</span>
<span class="p_add">+err_tlock_pnlock:</span>
 	spin_unlock_bh(&amp;pn-&gt;l2tp_session_hlist_lock);
<span class="p_del">-exist:</span>
<span class="p_add">+err_tlock:</span>
 	write_unlock_bh(&amp;tunnel-&gt;hlist_lock);
 
<span class="p_del">-	return -EEXIST;</span>
<span class="p_add">+	return err;</span>
 }
 
 /* Lookup a tunnel by id
<span class="p_chunk">@@ -1299,7 +1316,6 @@</span> <span class="p_context"> static void l2tp_tunnel_destruct(struct sock *sk)</span>
 	/* Remove hooks into tunnel socket */
 	sk-&gt;sk_destruct = tunnel-&gt;old_sk_destruct;
 	sk-&gt;sk_user_data = NULL;
<span class="p_del">-	tunnel-&gt;sock = NULL;</span>
 
 	/* Remove the tunnel struct from the tunnel list */
 	pn = l2tp_pernet(tunnel-&gt;l2tp_net);
<span class="p_chunk">@@ -1309,6 +1325,8 @@</span> <span class="p_context"> static void l2tp_tunnel_destruct(struct sock *sk)</span>
 	atomic_dec(&amp;l2tp_tunnel_count);
 
 	l2tp_tunnel_closeall(tunnel);
<span class="p_add">+</span>
<span class="p_add">+	tunnel-&gt;sock = NULL;</span>
 	l2tp_tunnel_dec_refcount(tunnel);
 
 	/* Call the original destructor */
<span class="p_chunk">@@ -1333,6 +1351,7 @@</span> <span class="p_context"> void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)</span>
 		  tunnel-&gt;name);
 
 	write_lock_bh(&amp;tunnel-&gt;hlist_lock);
<span class="p_add">+	tunnel-&gt;acpt_newsess = false;</span>
 	for (hash = 0; hash &lt; L2TP_HASH_SIZE; hash++) {
 again:
 		hlist_for_each_safe(walk, tmp, &amp;tunnel-&gt;session_hlist[hash]) {
<span class="p_chunk">@@ -1665,6 +1684,7 @@</span> <span class="p_context"> int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32</span>
 	tunnel-&gt;magic = L2TP_TUNNEL_MAGIC;
 	sprintf(&amp;tunnel-&gt;name[0], &quot;tunl %u&quot;, tunnel_id);
 	rwlock_init(&amp;tunnel-&gt;hlist_lock);
<span class="p_add">+	tunnel-&gt;acpt_newsess = true;</span>
 
 	/* The net we belong to */
 	tunnel-&gt;l2tp_net = net;
<span class="p_chunk">@@ -1915,11 +1935,6 @@</span> <span class="p_context"> struct l2tp_session *l2tp_session_create(int priv_size, struct l2tp_tunnel *tunn</span>
 			return ERR_PTR(err);
 		}
 
<span class="p_del">-		l2tp_tunnel_inc_refcount(tunnel);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Ensure tunnel socket isn&#39;t deleted */</span>
<span class="p_del">-		sock_hold(tunnel-&gt;sock);</span>
<span class="p_del">-</span>
 		/* Ignore management session in session count value */
 		if (session-&gt;session_id != 0)
 			atomic_inc(&amp;l2tp_session_count);
<span class="p_header">diff --git a/net/l2tp/l2tp_core.h b/net/l2tp/l2tp_core.h</span>
<span class="p_header">index 2219f9d8d961..36c25b14bc6f 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.h</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.h</span>
<span class="p_chunk">@@ -171,6 +171,10 @@</span> <span class="p_context"> struct l2tp_tunnel {</span>
 	int			magic;		/* Should be L2TP_TUNNEL_MAGIC */
 	struct rcu_head rcu;
 	rwlock_t		hlist_lock;	/* protect session_hlist */
<span class="p_add">+	bool			acpt_newsess;	/* Indicates whether this</span>
<span class="p_add">+						 * tunnel accepts new sessions.</span>
<span class="p_add">+						 * Protected by hlist_lock.</span>
<span class="p_add">+						 */</span>
 	struct hlist_head	session_hlist[L2TP_HASH_SIZE];
 						/* hashed list of sessions,
 						 * hashed by id */
<span class="p_chunk">@@ -206,7 +210,9 @@</span> <span class="p_context"> struct l2tp_tunnel {</span>
 };
 
 struct l2tp_nl_cmd_ops {
<span class="p_del">-	int (*session_create)(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg);</span>
<span class="p_add">+	int (*session_create)(struct net *net, struct l2tp_tunnel *tunnel,</span>
<span class="p_add">+			      u32 session_id, u32 peer_session_id,</span>
<span class="p_add">+			      struct l2tp_session_cfg *cfg);</span>
 	int (*session_delete)(struct l2tp_session *session);
 };
 
<span class="p_header">diff --git a/net/l2tp/l2tp_eth.c b/net/l2tp/l2tp_eth.c</span>
<span class="p_header">index 992bc49f57ee..ed819454a4e7 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_eth.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_eth.c</span>
<span class="p_chunk">@@ -206,23 +206,18 @@</span> <span class="p_context"> static void l2tp_eth_show(struct seq_file *m, void *arg)</span>
 }
 #endif
 
<span class="p_del">-static int l2tp_eth_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)</span>
<span class="p_add">+static int l2tp_eth_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
<span class="p_add">+			   u32 session_id, u32 peer_session_id,</span>
<span class="p_add">+			   struct l2tp_session_cfg *cfg)</span>
 {
 	struct net_device *dev;
 	char name[IFNAMSIZ];
<span class="p_del">-	struct l2tp_tunnel *tunnel;</span>
 	struct l2tp_session *session;
 	struct l2tp_eth *priv;
 	struct l2tp_eth_sess *spriv;
 	int rc;
 	struct l2tp_eth_net *pn;
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-	if (!tunnel) {</span>
<span class="p_del">-		rc = -ENODEV;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	if (cfg-&gt;ifname) {
 		dev = dev_get_by_name(net, cfg-&gt;ifname);
 		if (dev) {
<span class="p_header">diff --git a/net/l2tp/l2tp_netlink.c b/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">index 6727f16afd44..0fc9e31d1edc 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_netlink.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_netlink.c</span>
<span class="p_chunk">@@ -540,10 +540,10 @@</span> <span class="p_context"> static int l2tp_nl_cmd_session_create(struct sk_buff *skb, struct genl_info *inf</span>
 		break;
 	}
 
<span class="p_del">-	ret = -EPROTONOSUPPORT;</span>
<span class="p_del">-	if (l2tp_nl_cmd_ops[cfg.pw_type]-&gt;session_create)</span>
<span class="p_del">-		ret = (*l2tp_nl_cmd_ops[cfg.pw_type]-&gt;session_create)(net, tunnel_id,</span>
<span class="p_del">-			session_id, peer_session_id, &amp;cfg);</span>
<span class="p_add">+	ret = l2tp_nl_cmd_ops[cfg.pw_type]-&gt;session_create(net, tunnel,</span>
<span class="p_add">+							   session_id,</span>
<span class="p_add">+							   peer_session_id,</span>
<span class="p_add">+							   &amp;cfg);</span>
 
 out_tunnel:
 	l2tp_tunnel_dec_refcount(tunnel);
<span class="p_header">diff --git a/net/l2tp/l2tp_ppp.c b/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">index 9e61075bc08b..80d4cfa9fe38 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ppp.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ppp.c</span>
<span class="p_chunk">@@ -807,25 +807,20 @@</span> <span class="p_context"> static int pppol2tp_connect(struct socket *sock, struct sockaddr *uservaddr,</span>
 
 #ifdef CONFIG_L2TP_V3
 
<span class="p_del">-/* Called when creating sessions via the netlink interface.</span>
<span class="p_del">- */</span>
<span class="p_del">-static int pppol2tp_session_create(struct net *net, u32 tunnel_id, u32 session_id, u32 peer_session_id, struct l2tp_session_cfg *cfg)</span>
<span class="p_add">+/* Called when creating sessions via the netlink interface. */</span>
<span class="p_add">+static int pppol2tp_session_create(struct net *net, struct l2tp_tunnel *tunnel,</span>
<span class="p_add">+				   u32 session_id, u32 peer_session_id,</span>
<span class="p_add">+				   struct l2tp_session_cfg *cfg)</span>
 {
 	int error;
<span class="p_del">-	struct l2tp_tunnel *tunnel;</span>
 	struct l2tp_session *session;
 	struct pppol2tp_session *ps;
 
<span class="p_del">-	tunnel = l2tp_tunnel_find(net, tunnel_id);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Error if we can&#39;t find the tunnel */</span>
<span class="p_del">-	error = -ENOENT;</span>
<span class="p_del">-	if (tunnel == NULL)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
 	/* Error if tunnel socket is not prepped */
<span class="p_del">-	if (tunnel-&gt;sock == NULL)</span>
<span class="p_add">+	if (!tunnel-&gt;sock) {</span>
<span class="p_add">+		error = -ENOENT;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	/* Default MTU values. */
 	if (cfg-&gt;mtu == 0)
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index 708bc2074d90..d8d65fed4e32 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -2891,6 +2891,8 @@</span> <span class="p_context"> static int ieee80211_cancel_roc(struct ieee80211_local *local,</span>
 	struct ieee80211_roc_work *roc, *tmp, *found = NULL;
 	int ret;
 
<span class="p_add">+	flush_work(&amp;local-&gt;hw_roc_start);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;local-&gt;mtx);
 	list_for_each_entry_safe(roc, tmp, &amp;local-&gt;roc_list, list) {
 		struct ieee80211_roc_work *dep, *tmp2;
<span class="p_header">diff --git a/net/mac80211/key.c b/net/mac80211/key.c</span>
<span class="p_header">index 398cc91aff65..6b9eed405c1b 100644</span>
<span class="p_header">--- a/net/mac80211/key.c</span>
<span class="p_header">+++ b/net/mac80211/key.c</span>
<span class="p_chunk">@@ -18,6 +18,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/export.h&gt;
 #include &lt;net/mac80211.h&gt;
<span class="p_add">+#include &lt;crypto/algapi.h&gt;</span>
 #include &lt;asm/unaligned.h&gt;
 #include &quot;ieee80211_i.h&quot;
 #include &quot;driver-ops.h&quot;
<span class="p_chunk">@@ -474,6 +475,39 @@</span> <span class="p_context"> void ieee80211_key_free_unused(struct ieee80211_key *key)</span>
 	ieee80211_key_free_common(key);
 }
 
<span class="p_add">+static bool ieee80211_key_identical(struct ieee80211_sub_if_data *sdata,</span>
<span class="p_add">+				    struct ieee80211_key *old,</span>
<span class="p_add">+				    struct ieee80211_key *new)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 tkip_old[WLAN_KEY_LEN_TKIP], tkip_new[WLAN_KEY_LEN_TKIP];</span>
<span class="p_add">+	u8 *tk_old, *tk_new;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!old || new-&gt;conf.keylen != old-&gt;conf.keylen)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	tk_old = old-&gt;conf.key;</span>
<span class="p_add">+	tk_new = new-&gt;conf.key;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * In station mode, don&#39;t compare the TX MIC key, as it&#39;s never used</span>
<span class="p_add">+	 * and offloaded rekeying may not care to send it to the host. This</span>
<span class="p_add">+	 * is the case in iwlwifi, for example.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (sdata-&gt;vif.type == NL80211_IFTYPE_STATION &amp;&amp;</span>
<span class="p_add">+	    new-&gt;conf.cipher == WLAN_CIPHER_SUITE_TKIP &amp;&amp;</span>
<span class="p_add">+	    new-&gt;conf.keylen == WLAN_KEY_LEN_TKIP &amp;&amp;</span>
<span class="p_add">+	    !(new-&gt;conf.flags &amp; IEEE80211_KEY_FLAG_PAIRWISE)) {</span>
<span class="p_add">+		memcpy(tkip_old, tk_old, WLAN_KEY_LEN_TKIP);</span>
<span class="p_add">+		memcpy(tkip_new, tk_new, WLAN_KEY_LEN_TKIP);</span>
<span class="p_add">+		memset(tkip_old + NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY, 0, 8);</span>
<span class="p_add">+		memset(tkip_new + NL80211_TKIP_DATA_OFFSET_TX_MIC_KEY, 0, 8);</span>
<span class="p_add">+		tk_old = tkip_old;</span>
<span class="p_add">+		tk_new = tkip_new;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return !crypto_memneq(tk_old, tk_new, new-&gt;conf.keylen);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int ieee80211_key_link(struct ieee80211_key *key,
 		       struct ieee80211_sub_if_data *sdata,
 		       struct sta_info *sta)
<span class="p_chunk">@@ -502,8 +536,7 @@</span> <span class="p_context"> int ieee80211_key_link(struct ieee80211_key *key,</span>
 	 * Silently accept key re-installation without really installing the
 	 * new version of the key to avoid nonce reuse or replay issues.
 	 */
<span class="p_del">-	if (old_key &amp;&amp; key-&gt;conf.keylen == old_key-&gt;conf.keylen &amp;&amp;</span>
<span class="p_del">-	    !memcmp(key-&gt;conf.key, old_key-&gt;conf.key, key-&gt;conf.keylen)) {</span>
<span class="p_add">+	if (ieee80211_key_identical(sdata, old_key, key)) {</span>
 		ieee80211_key_free_unused(key);
 		ret = 0;
 		goto out;
<span class="p_header">diff --git a/net/sctp/socket.c b/net/sctp/socket.c</span>
<span class="p_header">index ad0292262581..b0f068937260 100644</span>
<span class="p_header">--- a/net/sctp/socket.c</span>
<span class="p_header">+++ b/net/sctp/socket.c</span>
<span class="p_chunk">@@ -4328,6 +4328,10 @@</span> <span class="p_context"> int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)</span>
 	struct sctp_af *af;
 	int err = 0;
 
<span class="p_add">+	/* Do not peel off from one netns to another one. */</span>
<span class="p_add">+	if (!net_eq(current-&gt;nsproxy-&gt;net_ns, sock_net(sk)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if (!asoc)
 		return -EINVAL;
 
<span class="p_header">diff --git a/net/vmw_vsock/vmci_transport.c b/net/vmw_vsock/vmci_transport.c</span>
<span class="p_header">index 9bb63ffec4f2..c69c990ec4a2 100644</span>
<span class="p_header">--- a/net/vmw_vsock/vmci_transport.c</span>
<span class="p_header">+++ b/net/vmw_vsock/vmci_transport.c</span>
<span class="p_chunk">@@ -40,13 +40,11 @@</span> <span class="p_context"></span>
 
 static int vmci_transport_recv_dgram_cb(void *data, struct vmci_datagram *dg);
 static int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg);
<span class="p_del">-static void vmci_transport_peer_attach_cb(u32 sub_id,</span>
<span class="p_del">-					  const struct vmci_event_data *ed,</span>
<span class="p_del">-					  void *client_data);</span>
 static void vmci_transport_peer_detach_cb(u32 sub_id,
 					  const struct vmci_event_data *ed,
 					  void *client_data);
 static void vmci_transport_recv_pkt_work(struct work_struct *work);
<span class="p_add">+static void vmci_transport_cleanup(struct work_struct *work);</span>
 static int vmci_transport_recv_listen(struct sock *sk,
 				      struct vmci_transport_packet *pkt);
 static int vmci_transport_recv_connecting_server(
<span class="p_chunk">@@ -75,6 +73,10 @@</span> <span class="p_context"> struct vmci_transport_recv_pkt_info {</span>
 	struct vmci_transport_packet pkt;
 };
 
<span class="p_add">+static LIST_HEAD(vmci_transport_cleanup_list);</span>
<span class="p_add">+static DEFINE_SPINLOCK(vmci_transport_cleanup_lock);</span>
<span class="p_add">+static DECLARE_WORK(vmci_transport_cleanup_work, vmci_transport_cleanup);</span>
<span class="p_add">+</span>
 static struct vmci_handle vmci_transport_stream_handle = { VMCI_INVALID_ID,
 							   VMCI_INVALID_ID };
 static u32 vmci_transport_qp_resumed_sub_id = VMCI_INVALID_ID;
<span class="p_chunk">@@ -791,44 +793,6 @@</span> <span class="p_context"> static int vmci_transport_recv_stream_cb(void *data, struct vmci_datagram *dg)</span>
 	return err;
 }
 
<span class="p_del">-static void vmci_transport_peer_attach_cb(u32 sub_id,</span>
<span class="p_del">-					  const struct vmci_event_data *e_data,</span>
<span class="p_del">-					  void *client_data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct sock *sk = client_data;</span>
<span class="p_del">-	const struct vmci_event_payload_qp *e_payload;</span>
<span class="p_del">-	struct vsock_sock *vsk;</span>
<span class="p_del">-</span>
<span class="p_del">-	e_payload = vmci_event_data_const_payload(e_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	vsk = vsock_sk(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* We don&#39;t ask for delayed CBs when we subscribe to this event (we</span>
<span class="p_del">-	 * pass 0 as flags to vmci_event_subscribe()).  VMCI makes no</span>
<span class="p_del">-	 * guarantees in that case about what context we might be running in,</span>
<span class="p_del">-	 * so it could be BH or process, blockable or non-blockable.  So we</span>
<span class="p_del">-	 * need to account for all possible contexts here.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	local_bh_disable();</span>
<span class="p_del">-	bh_lock_sock(sk);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* XXX This is lame, we should provide a way to lookup sockets by</span>
<span class="p_del">-	 * qp_handle.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (vmci_handle_is_equal(vmci_trans(vsk)-&gt;qp_handle,</span>
<span class="p_del">-				 e_payload-&gt;handle)) {</span>
<span class="p_del">-		/* XXX This doesn&#39;t do anything, but in the future we may want</span>
<span class="p_del">-		 * to set a flag here to verify the attach really did occur and</span>
<span class="p_del">-		 * we weren&#39;t just sent a datagram claiming it was.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	bh_unlock_sock(sk);</span>
<span class="p_del">-	local_bh_enable();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void vmci_transport_handle_detach(struct sock *sk)
 {
 	struct vsock_sock *vsk;
<span class="p_chunk">@@ -871,28 +835,38 @@</span> <span class="p_context"> static void vmci_transport_peer_detach_cb(u32 sub_id,</span>
 					  const struct vmci_event_data *e_data,
 					  void *client_data)
 {
<span class="p_del">-	struct sock *sk = client_data;</span>
<span class="p_add">+	struct vmci_transport *trans = client_data;</span>
 	const struct vmci_event_payload_qp *e_payload;
<span class="p_del">-	struct vsock_sock *vsk;</span>
 
 	e_payload = vmci_event_data_const_payload(e_data);
<span class="p_del">-	vsk = vsock_sk(sk);</span>
<span class="p_del">-	if (vmci_handle_is_invalid(e_payload-&gt;handle))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Same rules for locking as for peer_attach_cb(). */</span>
<span class="p_del">-	local_bh_disable();</span>
<span class="p_del">-	bh_lock_sock(sk);</span>
 
 	/* XXX This is lame, we should provide a way to lookup sockets by
 	 * qp_handle.
 	 */
<span class="p_del">-	if (vmci_handle_is_equal(vmci_trans(vsk)-&gt;qp_handle,</span>
<span class="p_del">-				 e_payload-&gt;handle))</span>
<span class="p_del">-		vmci_transport_handle_detach(sk);</span>
<span class="p_add">+	if (vmci_handle_is_invalid(e_payload-&gt;handle) ||</span>
<span class="p_add">+	    !vmci_handle_is_equal(trans-&gt;qp_handle, e_payload-&gt;handle))</span>
<span class="p_add">+		return;</span>
 
<span class="p_del">-	bh_unlock_sock(sk);</span>
<span class="p_del">-	local_bh_enable();</span>
<span class="p_add">+	/* We don&#39;t ask for delayed CBs when we subscribe to this event (we</span>
<span class="p_add">+	 * pass 0 as flags to vmci_event_subscribe()).  VMCI makes no</span>
<span class="p_add">+	 * guarantees in that case about what context we might be running in,</span>
<span class="p_add">+	 * so it could be BH or process, blockable or non-blockable.  So we</span>
<span class="p_add">+	 * need to account for all possible contexts here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock_bh(&amp;trans-&gt;lock);</span>
<span class="p_add">+	if (!trans-&gt;sk)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Apart from here, trans-&gt;lock is only grabbed as part of sk destruct,</span>
<span class="p_add">+	 * where trans-&gt;sk isn&#39;t locked.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	bh_lock_sock(trans-&gt;sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	vmci_transport_handle_detach(trans-&gt;sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	bh_unlock_sock(trans-&gt;sk);</span>
<span class="p_add">+ out:</span>
<span class="p_add">+	spin_unlock_bh(&amp;trans-&gt;lock);</span>
 }
 
 static void vmci_transport_qp_resumed_cb(u32 sub_id,
<span class="p_chunk">@@ -1181,7 +1155,7 @@</span> <span class="p_context"> vmci_transport_recv_connecting_server(struct sock *listener,</span>
 	 */
 	err = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,
 				   vmci_transport_peer_detach_cb,
<span class="p_del">-				   pending, &amp;detach_sub_id);</span>
<span class="p_add">+				   vmci_trans(vpending), &amp;detach_sub_id);</span>
 	if (err &lt; VMCI_SUCCESS) {
 		vmci_transport_send_reset(pending, pkt);
 		err = vmci_transport_error_to_vsock_error(err);
<span class="p_chunk">@@ -1321,7 +1295,6 @@</span> <span class="p_context"> vmci_transport_recv_connecting_client(struct sock *sk,</span>
 		    || vmci_trans(vsk)-&gt;qpair
 		    || vmci_trans(vsk)-&gt;produce_size != 0
 		    || vmci_trans(vsk)-&gt;consume_size != 0
<span class="p_del">-		    || vmci_trans(vsk)-&gt;attach_sub_id != VMCI_INVALID_ID</span>
 		    || vmci_trans(vsk)-&gt;detach_sub_id != VMCI_INVALID_ID) {
 			skerr = EPROTO;
 			err = -EINVAL;
<span class="p_chunk">@@ -1389,7 +1362,6 @@</span> <span class="p_context"> static int vmci_transport_recv_connecting_client_negotiate(</span>
 	struct vsock_sock *vsk;
 	struct vmci_handle handle;
 	struct vmci_qp *qpair;
<span class="p_del">-	u32 attach_sub_id;</span>
 	u32 detach_sub_id;
 	bool is_local;
 	u32 flags;
<span class="p_chunk">@@ -1399,7 +1371,6 @@</span> <span class="p_context"> static int vmci_transport_recv_connecting_client_negotiate(</span>
 
 	vsk = vsock_sk(sk);
 	handle = VMCI_INVALID_HANDLE;
<span class="p_del">-	attach_sub_id = VMCI_INVALID_ID;</span>
 	detach_sub_id = VMCI_INVALID_ID;
 
 	/* If we have gotten here then we should be past the point where old
<span class="p_chunk">@@ -1444,23 +1415,15 @@</span> <span class="p_context"> static int vmci_transport_recv_connecting_client_negotiate(</span>
 		goto destroy;
 	}
 
<span class="p_del">-	/* Subscribe to attach and detach events first.</span>
<span class="p_add">+	/* Subscribe to detach events first.</span>
 	 *
 	 * XXX We attach once for each queue pair created for now so it is easy
 	 * to find the socket (it&#39;s provided), but later we should only
 	 * subscribe once and add a way to lookup sockets by queue pair handle.
 	 */
<span class="p_del">-	err = vmci_event_subscribe(VMCI_EVENT_QP_PEER_ATTACH,</span>
<span class="p_del">-				   vmci_transport_peer_attach_cb,</span>
<span class="p_del">-				   sk, &amp;attach_sub_id);</span>
<span class="p_del">-	if (err &lt; VMCI_SUCCESS) {</span>
<span class="p_del">-		err = vmci_transport_error_to_vsock_error(err);</span>
<span class="p_del">-		goto destroy;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	err = vmci_event_subscribe(VMCI_EVENT_QP_PEER_DETACH,
 				   vmci_transport_peer_detach_cb,
<span class="p_del">-				   sk, &amp;detach_sub_id);</span>
<span class="p_add">+				   vmci_trans(vsk), &amp;detach_sub_id);</span>
 	if (err &lt; VMCI_SUCCESS) {
 		err = vmci_transport_error_to_vsock_error(err);
 		goto destroy;
<span class="p_chunk">@@ -1496,7 +1459,6 @@</span> <span class="p_context"> static int vmci_transport_recv_connecting_client_negotiate(</span>
 	vmci_trans(vsk)-&gt;produce_size = vmci_trans(vsk)-&gt;consume_size =
 		pkt-&gt;u.size;
 
<span class="p_del">-	vmci_trans(vsk)-&gt;attach_sub_id = attach_sub_id;</span>
 	vmci_trans(vsk)-&gt;detach_sub_id = detach_sub_id;
 
 	vmci_trans(vsk)-&gt;notify_ops-&gt;process_negotiate(sk);
<span class="p_chunk">@@ -1504,9 +1466,6 @@</span> <span class="p_context"> static int vmci_transport_recv_connecting_client_negotiate(</span>
 	return 0;
 
 destroy:
<span class="p_del">-	if (attach_sub_id != VMCI_INVALID_ID)</span>
<span class="p_del">-		vmci_event_unsubscribe(attach_sub_id);</span>
<span class="p_del">-</span>
 	if (detach_sub_id != VMCI_INVALID_ID)
 		vmci_event_unsubscribe(detach_sub_id);
 
<span class="p_chunk">@@ -1607,9 +1566,11 @@</span> <span class="p_context"> static int vmci_transport_socket_init(struct vsock_sock *vsk,</span>
 	vmci_trans(vsk)-&gt;qp_handle = VMCI_INVALID_HANDLE;
 	vmci_trans(vsk)-&gt;qpair = NULL;
 	vmci_trans(vsk)-&gt;produce_size = vmci_trans(vsk)-&gt;consume_size = 0;
<span class="p_del">-	vmci_trans(vsk)-&gt;attach_sub_id = vmci_trans(vsk)-&gt;detach_sub_id =</span>
<span class="p_del">-		VMCI_INVALID_ID;</span>
<span class="p_add">+	vmci_trans(vsk)-&gt;detach_sub_id = VMCI_INVALID_ID;</span>
 	vmci_trans(vsk)-&gt;notify_ops = NULL;
<span class="p_add">+	INIT_LIST_HEAD(&amp;vmci_trans(vsk)-&gt;elem);</span>
<span class="p_add">+	vmci_trans(vsk)-&gt;sk = &amp;vsk-&gt;sk;</span>
<span class="p_add">+	spin_lock_init(&amp;vmci_trans(vsk)-&gt;lock);</span>
 	if (psk) {
 		vmci_trans(vsk)-&gt;queue_pair_size =
 			vmci_trans(psk)-&gt;queue_pair_size;
<span class="p_chunk">@@ -1629,29 +1590,57 @@</span> <span class="p_context"> static int vmci_transport_socket_init(struct vsock_sock *vsk,</span>
 	return 0;
 }
 
<span class="p_del">-static void vmci_transport_destruct(struct vsock_sock *vsk)</span>
<span class="p_add">+static void vmci_transport_free_resources(struct list_head *transport_list)</span>
 {
<span class="p_del">-	if (vmci_trans(vsk)-&gt;attach_sub_id != VMCI_INVALID_ID) {</span>
<span class="p_del">-		vmci_event_unsubscribe(vmci_trans(vsk)-&gt;attach_sub_id);</span>
<span class="p_del">-		vmci_trans(vsk)-&gt;attach_sub_id = VMCI_INVALID_ID;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	while (!list_empty(transport_list)) {</span>
<span class="p_add">+		struct vmci_transport *transport =</span>
<span class="p_add">+		    list_first_entry(transport_list, struct vmci_transport,</span>
<span class="p_add">+				     elem);</span>
<span class="p_add">+		list_del(&amp;transport-&gt;elem);</span>
 
<span class="p_del">-	if (vmci_trans(vsk)-&gt;detach_sub_id != VMCI_INVALID_ID) {</span>
<span class="p_del">-		vmci_event_unsubscribe(vmci_trans(vsk)-&gt;detach_sub_id);</span>
<span class="p_del">-		vmci_trans(vsk)-&gt;detach_sub_id = VMCI_INVALID_ID;</span>
<span class="p_del">-	}</span>
<span class="p_add">+		if (transport-&gt;detach_sub_id != VMCI_INVALID_ID) {</span>
<span class="p_add">+			vmci_event_unsubscribe(transport-&gt;detach_sub_id);</span>
<span class="p_add">+			transport-&gt;detach_sub_id = VMCI_INVALID_ID;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	if (!vmci_handle_is_invalid(vmci_trans(vsk)-&gt;qp_handle)) {</span>
<span class="p_del">-		vmci_qpair_detach(&amp;vmci_trans(vsk)-&gt;qpair);</span>
<span class="p_del">-		vmci_trans(vsk)-&gt;qp_handle = VMCI_INVALID_HANDLE;</span>
<span class="p_del">-		vmci_trans(vsk)-&gt;produce_size = 0;</span>
<span class="p_del">-		vmci_trans(vsk)-&gt;consume_size = 0;</span>
<span class="p_add">+		if (!vmci_handle_is_invalid(transport-&gt;qp_handle)) {</span>
<span class="p_add">+			vmci_qpair_detach(&amp;transport-&gt;qpair);</span>
<span class="p_add">+			transport-&gt;qp_handle = VMCI_INVALID_HANDLE;</span>
<span class="p_add">+			transport-&gt;produce_size = 0;</span>
<span class="p_add">+			transport-&gt;consume_size = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		kfree(transport);</span>
 	}
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void vmci_transport_cleanup(struct work_struct *work)</span>
<span class="p_add">+{</span>
<span class="p_add">+	LIST_HEAD(pending);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_bh(&amp;vmci_transport_cleanup_lock);</span>
<span class="p_add">+	list_replace_init(&amp;vmci_transport_cleanup_list, &amp;pending);</span>
<span class="p_add">+	spin_unlock_bh(&amp;vmci_transport_cleanup_lock);</span>
<span class="p_add">+	vmci_transport_free_resources(&amp;pending);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void vmci_transport_destruct(struct vsock_sock *vsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Ensure that the detach callback doesn&#39;t use the sk/vsk</span>
<span class="p_add">+	 * we are about to destruct.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock_bh(&amp;vmci_trans(vsk)-&gt;lock);</span>
<span class="p_add">+	vmci_trans(vsk)-&gt;sk = NULL;</span>
<span class="p_add">+	spin_unlock_bh(&amp;vmci_trans(vsk)-&gt;lock);</span>
 
 	if (vmci_trans(vsk)-&gt;notify_ops)
 		vmci_trans(vsk)-&gt;notify_ops-&gt;socket_destruct(vsk);
 
<span class="p_del">-	kfree(vsk-&gt;trans);</span>
<span class="p_add">+	spin_lock_bh(&amp;vmci_transport_cleanup_lock);</span>
<span class="p_add">+	list_add(&amp;vmci_trans(vsk)-&gt;elem, &amp;vmci_transport_cleanup_list);</span>
<span class="p_add">+	spin_unlock_bh(&amp;vmci_transport_cleanup_lock);</span>
<span class="p_add">+	schedule_work(&amp;vmci_transport_cleanup_work);</span>
<span class="p_add">+</span>
 	vsk-&gt;trans = NULL;
 }
 
<span class="p_chunk">@@ -2148,6 +2137,9 @@</span> <span class="p_context"> module_init(vmci_transport_init);</span>
 
 static void __exit vmci_transport_exit(void)
 {
<span class="p_add">+	cancel_work_sync(&amp;vmci_transport_cleanup_work);</span>
<span class="p_add">+	vmci_transport_free_resources(&amp;vmci_transport_cleanup_list);</span>
<span class="p_add">+</span>
 	if (!vmci_handle_is_invalid(vmci_transport_stream_handle)) {
 		if (vmci_datagram_destroy_handle(
 			vmci_transport_stream_handle) != VMCI_SUCCESS)
<span class="p_chunk">@@ -2166,6 +2158,7 @@</span> <span class="p_context"> module_exit(vmci_transport_exit);</span>
 
 MODULE_AUTHOR(&quot;VMware, Inc.&quot;);
 MODULE_DESCRIPTION(&quot;VMCI transport for Virtual Sockets&quot;);
<span class="p_add">+MODULE_VERSION(&quot;1.0.3.0-k&quot;);</span>
 MODULE_LICENSE(&quot;GPL v2&quot;);
 MODULE_ALIAS(&quot;vmware_vsock&quot;);
 MODULE_ALIAS_NETPROTO(PF_VSOCK);
<span class="p_header">diff --git a/net/vmw_vsock/vmci_transport.h b/net/vmw_vsock/vmci_transport.h</span>
<span class="p_header">index ce6c9623d5f0..2ad46f39649f 100644</span>
<span class="p_header">--- a/net/vmw_vsock/vmci_transport.h</span>
<span class="p_header">+++ b/net/vmw_vsock/vmci_transport.h</span>
<span class="p_chunk">@@ -119,10 +119,12 @@</span> <span class="p_context"> struct vmci_transport {</span>
 	u64 queue_pair_size;
 	u64 queue_pair_min_size;
 	u64 queue_pair_max_size;
<span class="p_del">-	u32 attach_sub_id;</span>
 	u32 detach_sub_id;
 	union vmci_transport_notify notify;
 	struct vmci_transport_notify_ops *notify_ops;
<span class="p_add">+	struct list_head elem;</span>
<span class="p_add">+	struct sock *sk;</span>
<span class="p_add">+	spinlock_t lock; /* protects sk. */</span>
 };
 
 int vmci_transport_register(void);
<span class="p_header">diff --git a/tools/perf/Documentation/Makefile b/tools/perf/Documentation/Makefile</span>
<span class="p_header">index 3ba1c0b09908..ac0e39306421 100644</span>
<span class="p_header">--- a/tools/perf/Documentation/Makefile</span>
<span class="p_header">+++ b/tools/perf/Documentation/Makefile</span>
<span class="p_chunk">@@ -192,7 +192,7 @@</span> <span class="p_context"> do-install-man: man</span>
 #		$(INSTALL) -m 644 $(DOC_MAN5) $(DESTDIR)$(man5dir); \
 #		$(INSTALL) -m 644 $(DOC_MAN7) $(DESTDIR)$(man7dir)
 
<span class="p_del">-install-man: check-man-tools man</span>
<span class="p_add">+install-man: check-man-tools man do-install-man</span>
 
 ifdef missing_tools
   DO_INSTALL_MAN = $(warning Please install $(missing_tools) to have the man pages installed)
<span class="p_header">diff --git a/tools/perf/tests/attr/test-record-no-delay b/tools/perf/tests/attr/test-record-no-buffering</span>
similarity index 70%
rename from tools/perf/tests/attr/test-record-no-delay
rename to tools/perf/tests/attr/test-record-no-buffering
<span class="p_header">index f253b78cdbf2..0b0355af013a 100644</span>
<span class="p_header">--- a/tools/perf/tests/attr/test-record-no-delay</span>
<span class="p_header">+++ b/tools/perf/tests/attr/test-record-no-buffering</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 [config]
 command = record
<span class="p_del">-args    = -D kill &gt;/dev/null 2&gt;&amp;1</span>
<span class="p_add">+args    = --no-buffering kill &gt;/dev/null 2&gt;&amp;1</span>
 
 [event:base-record]
 sample_period=4000
<span class="p_header">diff --git a/tools/perf/util/parse-events.c b/tools/perf/util/parse-events.c</span>
<span class="p_header">index 1e15df10a88c..4c498e61e340 100644</span>
<span class="p_header">--- a/tools/perf/util/parse-events.c</span>
<span class="p_header">+++ b/tools/perf/util/parse-events.c</span>
<span class="p_chunk">@@ -908,7 +908,7 @@</span> <span class="p_context"> static int parse_events__scanner(const char *str, void *data, int start_token)</span>
  */
 int parse_events_terms(struct list_head *terms, const char *str)
 {
<span class="p_del">-	struct parse_events_terms data = {</span>
<span class="p_add">+	struct parse_events_state data = {</span>
 		.terms = NULL,
 	};
 	int ret;
<span class="p_chunk">@@ -927,7 +927,7 @@</span> <span class="p_context"> int parse_events_terms(struct list_head *terms, const char *str)</span>
 
 int parse_events(struct perf_evlist *evlist, const char *str)
 {
<span class="p_del">-	struct parse_events_evlist data = {</span>
<span class="p_add">+	struct parse_events_state data = {</span>
 		.list = LIST_HEAD_INIT(data.list),
 		.idx  = evlist-&gt;nr_entries,
 	};
<span class="p_header">diff --git a/tools/perf/util/parse-events.h b/tools/perf/util/parse-events.h</span>
<span class="p_header">index df094b4ed5ed..464c6ffdcab7 100644</span>
<span class="p_header">--- a/tools/perf/util/parse-events.h</span>
<span class="p_header">+++ b/tools/perf/util/parse-events.h</span>
<span class="p_chunk">@@ -61,14 +61,11 @@</span> <span class="p_context"> struct parse_events_term {</span>
 	struct list_head list;
 };
 
<span class="p_del">-struct parse_events_evlist {</span>
<span class="p_add">+struct parse_events_state {</span>
 	struct list_head list;
 	int idx;
 	int nr_groups;
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-struct parse_events_terms {</span>
<span class="p_del">-	struct list_head *terms;</span>
<span class="p_add">+	struct list_head	  *terms;</span>
 };
 
 int parse_events__is_hardcoded_term(struct parse_events_term *term);
<span class="p_header">diff --git a/tools/perf/util/parse-events.y b/tools/perf/util/parse-events.y</span>
<span class="p_header">index 0bc87ba46bf3..9af659b1c478 100644</span>
<span class="p_header">--- a/tools/perf/util/parse-events.y</span>
<span class="p_header">+++ b/tools/perf/util/parse-events.y</span>
<span class="p_chunk">@@ -30,7 +30,7 @@</span> <span class="p_context"> do { \</span>
 } while (0)
 
 static inc_group_count(struct list_head *list,
<span class="p_del">-		       struct parse_events_evlist *data)</span>
<span class="p_add">+		       struct parse_events_state *data)</span>
 {
 	/* Count groups only have more than 1 members */
 	if (!list_is_last(list-&gt;next, list))
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> PE_START_TERMS  start_terms</span>
 
 start_events: groups
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 
 	parse_events_update_lists($1, &amp;data-&gt;list);
 }
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> event_def: event_pmu |</span>
 event_pmu:
 PE_NAME &#39;/&#39; event_config &#39;/&#39;
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -219,7 +219,7 @@</span> <span class="p_context"> PE_VALUE_SYM_SW</span>
 event_legacy_symbol:
 value_sym &#39;/&#39; event_config &#39;/&#39;
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 	int type = $1 &gt;&gt; 16;
 	int config = $1 &amp; 255;
<span class="p_chunk">@@ -233,7 +233,7 @@</span> <span class="p_context"> value_sym &#39;/&#39; event_config &#39;/&#39;</span>
 |
 value_sym sep_slash_dc
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 	int type = $1 &gt;&gt; 16;
 	int config = $1 &amp; 255;
<span class="p_chunk">@@ -247,7 +247,7 @@</span> <span class="p_context"> value_sym sep_slash_dc</span>
 event_legacy_cache:
 PE_NAME_CACHE_TYPE &#39;-&#39; PE_NAME_CACHE_OP_RESULT &#39;-&#39; PE_NAME_CACHE_OP_RESULT
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> PE_NAME_CACHE_TYPE &#39;-&#39; PE_NAME_CACHE_OP_RESULT &#39;-&#39; PE_NAME_CACHE_OP_RESULT</span>
 |
 PE_NAME_CACHE_TYPE &#39;-&#39; PE_NAME_CACHE_OP_RESULT
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -267,7 +267,7 @@</span> <span class="p_context"> PE_NAME_CACHE_TYPE &#39;-&#39; PE_NAME_CACHE_OP_RESULT</span>
 |
 PE_NAME_CACHE_TYPE
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -278,7 +278,7 @@</span> <span class="p_context"> PE_NAME_CACHE_TYPE</span>
 event_legacy_mem:
 PE_PREFIX_MEM PE_VALUE &#39;:&#39; PE_MODIFIER_BP sep_dc
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> PE_PREFIX_MEM PE_VALUE &#39;:&#39; PE_MODIFIER_BP sep_dc</span>
 |
 PE_PREFIX_MEM PE_VALUE sep_dc
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -301,7 +301,7 @@</span> <span class="p_context"> PE_PREFIX_MEM PE_VALUE sep_dc</span>
 event_legacy_tracepoint:
 PE_NAME &#39;-&#39; PE_NAME &#39;:&#39; PE_NAME
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 	char sys_name[128];
 	snprintf(&amp;sys_name, 128, &quot;%s-%s&quot;, $1, $3);
<span class="p_chunk">@@ -313,7 +313,7 @@</span> <span class="p_context"> PE_NAME &#39;-&#39; PE_NAME &#39;:&#39; PE_NAME</span>
 |
 PE_NAME &#39;:&#39; PE_NAME
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> PE_NAME &#39;:&#39; PE_NAME</span>
 event_legacy_numeric:
 PE_VALUE &#39;:&#39; PE_VALUE
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -335,7 +335,7 @@</span> <span class="p_context"> PE_VALUE &#39;:&#39; PE_VALUE</span>
 event_legacy_raw:
 PE_RAW
 {
<span class="p_del">-	struct parse_events_evlist *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	struct list_head *list;
 
 	ALLOC_LIST(list);
<span class="p_chunk">@@ -346,7 +346,7 @@</span> <span class="p_context"> PE_RAW</span>
 
 start_terms: event_config
 {
<span class="p_del">-	struct parse_events_terms *data = _data;</span>
<span class="p_add">+	struct parse_events_state *data = _data;</span>
 	data-&gt;terms = $1;
 }
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



