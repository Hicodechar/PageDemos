
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v3,3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v3,3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Oct. 11, 2016, 1:42 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1476193356-1350-4-git-send-email-matt.redfearn@imgtec.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9371047/mbox/"
   >mbox</a>
|
   <a href="/patch/9371047/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9371047/">/patch/9371047/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E659E607FD for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 11 Oct 2016 13:43:24 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id D689C29C26
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 11 Oct 2016 13:43:24 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C898A29C67; Tue, 11 Oct 2016 13:43:24 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id AD39629C26
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 11 Oct 2016 13:43:22 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753766AbcJKNnN (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 11 Oct 2016 09:43:13 -0400
Received: from mailapp02.imgtec.com ([217.156.133.132]:58495 &quot;EHLO
	mailapp01.imgtec.com&quot; rhost-flags-OK-OK-OK-FAIL) by vger.kernel.org
	with ESMTP id S1753578AbcJKNmq (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 11 Oct 2016 09:42:46 -0400
Received: from HHMAIL03.hh.imgtec.org (unknown [10.44.0.21])
	by Forcepoint Email with ESMTPS id 24432E1C3A3BF;
	Tue, 11 Oct 2016 14:42:40 +0100 (IST)
Received: from HHMAIL01.hh.imgtec.org (10.100.10.19) by
	HHMAIL03.hh.imgtec.org
	(10.44.0.21) with Microsoft SMTP Server (TLS) id 14.3.294.0;
	Tue, 11 Oct 2016 14:42:43 +0100
Received: from mredfearn-linux.le.imgtec.org (10.150.130.83) by
	HHMAIL01.hh.imgtec.org (10.100.10.21) with Microsoft SMTP Server
	(TLS) id 14.3.294.0; Tue, 11 Oct 2016 14:42:42 +0100
From: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
To: Ralf Baechle &lt;ralf@linux-mips.org&gt;,
	Bjorn Andersson &lt;bjorn.andersson@linaro.org&gt;,
	Ohad Ben-Cohen &lt;ohad@wizery.com&gt;, &quot;Thomas Gleixner&quot; &lt;tglx@linutronix.de&gt;
CC: &lt;linux-mips@linux-mips.org&gt;, &lt;linux-remoteproc@vger.kernel.org&gt;,
	&lt;lisa.parratt@imgtec.com&gt;, &lt;linux-kernel@vger.kernel.org&gt;,
	Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;
Subject: [PATCH v3 3/4] remoteproc/MIPS: Add a remoteproc driver for MIPS
Date: Tue, 11 Oct 2016 14:42:35 +0100
Message-ID: &lt;1476193356-1350-4-git-send-email-matt.redfearn@imgtec.com&gt;
X-Mailer: git-send-email 2.7.4
In-Reply-To: &lt;1476193356-1350-1-git-send-email-matt.redfearn@imgtec.com&gt;
References: &lt;1476193356-1350-1-git-send-email-matt.redfearn@imgtec.com&gt;
MIME-Version: 1.0
Content-Type: text/plain
X-Originating-IP: [10.150.130.83]
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=140431">Matt Redfearn</a> - Oct. 11, 2016, 1:42 p.m.</div>
<pre class="content">
This driver allows a MIPS processor offlined from Linux to be used as a
remote processor. Firmware may be loaded via the sysfs interface and
changed at runtime, allowing the processor to handle real-time tasks or
perform coprocessing while remaining processors are available to Linux.

Coprocessor firmware must abide by the remoteproc standard, i.e.
implement the resource table containing memory layouts and virtio device
descriptions, and additionally abide by the MIPS UHI coprocessor boot
protocol in the startup code.
<span class="signed-off-by">
Signed-off-by: Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>

---

Changes in v3:
Update MIPS remoteproc driver to use CPU hotplug state machine
Remove sysfs interface from MIPS rproc driver, now provided by the core.
Drop patches that Ralf has already merged to mips-next

Changes in v2: None

 drivers/remoteproc/Kconfig           |  11 +
 drivers/remoteproc/Makefile          |   1 +
 drivers/remoteproc/mips_remoteproc.c | 566 +++++++++++++++++++++++++++++++++++
 3 files changed, 578 insertions(+)
 create mode 100644 drivers/remoteproc/mips_remoteproc.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/remoteproc/Kconfig b/drivers/remoteproc/Kconfig</span>
<span class="p_header">index 1a8bf76a925f..05db52e0e668 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Kconfig</span>
<span class="p_header">+++ b/drivers/remoteproc/Kconfig</span>
<span class="p_chunk">@@ -100,4 +100,15 @@</span> <span class="p_context"> config ST_REMOTEPROC</span>
 	  processor framework.
 	  This can be either built-in or a loadable module.
 
<span class="p_add">+config MIPS_REMOTEPROC</span>
<span class="p_add">+	tristate &quot;MIPS remoteproc support&quot;</span>
<span class="p_add">+	depends on MIPS_CPS &amp;&amp; HAS_DMA</span>
<span class="p_add">+	select CMA</span>
<span class="p_add">+	select REMOTEPROC</span>
<span class="p_add">+	select MIPS_STEAL</span>
<span class="p_add">+	help</span>
<span class="p_add">+	  Say y here to support using offline cores/VPEs as remote processors</span>
<span class="p_add">+	  via the remote processor framework.</span>
<span class="p_add">+	  If unsure say N.</span>
<span class="p_add">+</span>
 endmenu
<span class="p_header">diff --git a/drivers/remoteproc/Makefile b/drivers/remoteproc/Makefile</span>
<span class="p_header">index 92d3758bd15c..de19cd320f3a 100644</span>
<span class="p_header">--- a/drivers/remoteproc/Makefile</span>
<span class="p_header">+++ b/drivers/remoteproc/Makefile</span>
<span class="p_chunk">@@ -14,3 +14,4 @@</span> <span class="p_context"> obj-$(CONFIG_DA8XX_REMOTEPROC)		+= da8xx_remoteproc.o</span>
 obj-$(CONFIG_QCOM_MDT_LOADER)		+= qcom_mdt_loader.o
 obj-$(CONFIG_QCOM_Q6V5_PIL)		+= qcom_q6v5_pil.o
 obj-$(CONFIG_ST_REMOTEPROC)		+= st_remoteproc.o
<span class="p_add">+obj-$(CONFIG_MIPS_REMOTEPROC)		+= mips_remoteproc.o</span>
<span class="p_header">diff --git a/drivers/remoteproc/mips_remoteproc.c b/drivers/remoteproc/mips_remoteproc.c</span>
new file mode 100644
<span class="p_header">index 000000000000..95aea67416b7</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/drivers/remoteproc/mips_remoteproc.c</span>
<span class="p_chunk">@@ -0,0 +1,566 @@</span> <span class="p_context"></span>
<span class="p_add">+/*</span>
<span class="p_add">+ * MIPS Remote Processor driver</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2016 Imagination Technologies</span>
<span class="p_add">+ * Lisa Parratt &lt;lisa.parratt@imgtec.com&gt;</span>
<span class="p_add">+ * Matt Redfearn &lt;matt.redfearn@imgtec.com&gt;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This program is free software; you can redistribute it and/or modify it</span>
<span class="p_add">+ * under the terms of the GNU General Public License as published by the</span>
<span class="p_add">+ * Free Software Foundation;  either version 2 of the  License, or (at your</span>
<span class="p_add">+ * option) any later version.</span>
<span class="p_add">+ */</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/dma-mapping.h&gt;</span>
<span class="p_add">+#include &lt;linux/interrupt.h&gt;</span>
<span class="p_add">+#include &lt;linux/io.h&gt;</span>
<span class="p_add">+#include &lt;linux/irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/module.h&gt;</span>
<span class="p_add">+#include &lt;linux/of_irq.h&gt;</span>
<span class="p_add">+#include &lt;linux/platform_device.h&gt;</span>
<span class="p_add">+#include &lt;linux/remoteproc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &lt;asm/smp-cps.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/tlbmisc.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#include &quot;remoteproc_internal.h&quot;</span>
<span class="p_add">+</span>
<span class="p_add">+struct mips_rproc {</span>
<span class="p_add">+	struct rproc		*rproc;</span>
<span class="p_add">+	struct task_struct	*tsk;</span>
<span class="p_add">+	struct device		dev;</span>
<span class="p_add">+	unsigned int		cpu;</span>
<span class="p_add">+	int			ipi_linux;</span>
<span class="p_add">+	int			ipi_remote;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct rproc *mips_rprocs[NR_CPUS];</span>
<span class="p_add">+</span>
<span class="p_add">+static int cpuhp_state;</span>
<span class="p_add">+</span>
<span class="p_add">+#define to_mips_rproc(d) container_of(d, struct mips_rproc, dev)</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the largest page mask a physical address can be mapped with */</span>
<span class="p_add">+static unsigned long mips_rproc_largest_pm(unsigned long pa,</span>
<span class="p_add">+					   unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long mask;</span>
<span class="p_add">+	/* Find address bits limiting alignment */</span>
<span class="p_add">+	unsigned long shift = ffs(pa);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Obey MIPS restrictions on page sizes */</span>
<span class="p_add">+	if (pa) {</span>
<span class="p_add">+		if (shift &amp; 1)</span>
<span class="p_add">+			shift -= 2;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			shift--;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mask = ULONG_MAX &lt;&lt; shift;</span>
<span class="p_add">+	return maxmask &amp; ~mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Compute the next largest page mask for a given page mask */</span>
<span class="p_add">+static unsigned long mips_rproc_next_pm(unsigned long pm, unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pm != PM_4K)</span>
<span class="p_add">+		return ((pm &lt;&lt; 2) | pm) &amp; maxmask;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		return PM_16K;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_map_page(unsigned long da, unsigned long pa, int c,</span>
<span class="p_add">+			  unsigned long pagemask, unsigned long pagesize)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long pa2 = pa + (pagesize / 2);</span>
<span class="p_add">+	unsigned long entryhi, entrylo0, entrylo1;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Compute the mapping */</span>
<span class="p_add">+	pa = (pa &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	pa2 = (pa2 &gt;&gt; 6) &amp; (ULONG_MAX &lt;&lt; MIPS_ENTRYLO_PFN_SHIFT);</span>
<span class="p_add">+	entryhi = da &amp; 0xfffffe000;</span>
<span class="p_add">+	entrylo0 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa;</span>
<span class="p_add">+	entrylo1 = (c &lt;&lt; ENTRYLO_C_SHIFT) | ENTRYLO_D | ENTRYLO_V | pa2;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Create wired entry %d, CCA %d\n&quot;, read_c0_wired(), c);</span>
<span class="p_add">+	pr_debug(&quot; EntryHi: 0x%016lx\n&quot;, entryhi);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo0: 0x%016lx\n&quot;, entrylo0);</span>
<span class="p_add">+	pr_debug(&quot; EntryLo1: 0x%016lx\n&quot;, entrylo1);</span>
<span class="p_add">+	pr_debug(&quot; Pagemask: 0x%016lx\n&quot;, pagemask);</span>
<span class="p_add">+	pr_debug(&quot;\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	add_wired_entry(entrylo0, entrylo1, entryhi, pagemask);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Compute the page required to fulfill a mapping. Escapes alignment derived</span>
<span class="p_add">+ * page size limitations before using biggest fit to map the remainder.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void mips_rproc_fit_page(unsigned long da, unsigned long pa,</span>
<span class="p_add">+					int c, unsigned long size,</span>
<span class="p_add">+					unsigned long maxmask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long bigmask, nextmask;</span>
<span class="p_add">+	unsigned long pagemask, pagesize;</span>
<span class="p_add">+	unsigned long distance, target;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		/* Compute the current largest page mask */</span>
<span class="p_add">+		bigmask = mips_rproc_largest_pm(pa, maxmask);</span>
<span class="p_add">+		/* Compute the next largest pagesize */</span>
<span class="p_add">+		nextmask = mips_rproc_next_pm(bigmask, maxmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Compute the distance from our current physical address to</span>
<span class="p_add">+		 * the next page boundary.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		distance = (nextmask + 0x2000) - (pa &amp; nextmask);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Decide between searching to get to the next highest page</span>
<span class="p_add">+		 * boundary or finishing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		target = distance &lt; size ? distance : size;</span>
<span class="p_add">+		/* Fit */</span>
<span class="p_add">+		while (target) {</span>
<span class="p_add">+			/* Find the largest supported page size that will fit */</span>
<span class="p_add">+			for (pagesize = maxmask + 0x2000;</span>
<span class="p_add">+			     (pagesize &gt; 0x2000) &amp;&amp; (pagesize &gt; target);</span>
<span class="p_add">+			     pagesize /= 4) {</span>
<span class="p_add">+			}</span>
<span class="p_add">+			/* Convert it to a page mask */</span>
<span class="p_add">+			pagemask = pagesize - 0x2000;</span>
<span class="p_add">+			/* Emit it */</span>
<span class="p_add">+			mips_map_page(da, pa, c, pagemask, pagesize);</span>
<span class="p_add">+			/* Move to next step */</span>
<span class="p_add">+			size -= pagesize;</span>
<span class="p_add">+			da += pagesize;</span>
<span class="p_add">+			pa += pagesize;</span>
<span class="p_add">+			target -= pagesize;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} while (size);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_carveouts(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_mem_entry *carveout;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(carveout, &amp;rproc-&gt;carveouts, node) {</span>
<span class="p_add">+		int c = CONF_CM_CACHABLE_COW;</span>
<span class="p_add">+</span>
<span class="p_add">+		dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+			&quot;carveout mapping da 0x%x -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+			carveout-&gt;da, &amp;carveout-&gt;dma, carveout-&gt;len, c);</span>
<span class="p_add">+</span>
<span class="p_add">+		mips_rproc_fit_page(carveout-&gt;da, carveout-&gt;dma, c,</span>
<span class="p_add">+				    carveout-&gt;len, max_pagemask);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_vdevs(struct rproc *rproc, int max_pagemask)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc_vdev *rvdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(rvdev, &amp;rproc-&gt;rvdevs, node) {</span>
<span class="p_add">+		int i, size;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 0; i &lt; ARRAY_SIZE(rvdev-&gt;vring); i++) {</span>
<span class="p_add">+			struct rproc_vring *vring = &amp;rvdev-&gt;vring[i];</span>
<span class="p_add">+			unsigned long pa = vring-&gt;dma;</span>
<span class="p_add">+			int c;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (hw_coherentio) {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * The DMA API will allocate cacheable buffers</span>
<span class="p_add">+				 * for shared resources, so the firmware should</span>
<span class="p_add">+				 * also access those buffers cached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = (_page_cachable_default &gt;&gt; _CACHE_SHIFT);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * Otherwise, shared buffers should be accessed</span>
<span class="p_add">+				 * uncached</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				c = CONF_CM_UNCACHED;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			/* actual size of vring (in bytes) */</span>
<span class="p_add">+			size = PAGE_ALIGN(vring_size(vring-&gt;len, vring-&gt;align));</span>
<span class="p_add">+</span>
<span class="p_add">+			dev_dbg(&amp;rproc-&gt;dev,</span>
<span class="p_add">+				&quot;vring mapping da %pad -&gt; %pad length 0x%x, CCA %d&quot;,</span>
<span class="p_add">+				&amp;vring-&gt;dma, &amp;vring-&gt;dma, size, c);</span>
<span class="p_add">+</span>
<span class="p_add">+			mips_rproc_fit_page(pa, pa, c, size, max_pagemask);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_rproc_cpu_entry(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc *rproc = mips_rprocs[smp_processor_id()];</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+	int ipi_to_remote = ipi_get_hwirq(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+	int ipi_from_remote = ipi_get_hwirq(mproc-&gt;ipi_linux, 0);</span>
<span class="p_add">+	unsigned long old_pagemask, max_pagemask;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rproc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;rproc-&gt;dev, &quot;Starting %s on MIPS CPU%d\n&quot;,</span>
<span class="p_add">+		 rproc-&gt;firmware, mproc-&gt;cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Get the maximum pagemask supported on this CPU */</span>
<span class="p_add">+	old_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(PM_HUGE_MASK);</span>
<span class="p_add">+	mtc0_tlbw_hazard();</span>
<span class="p_add">+	max_pagemask = read_c0_pagemask();</span>
<span class="p_add">+	write_c0_pagemask(old_pagemask);</span>
<span class="p_add">+	mtc0_tlbw_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Start with no wired entries */</span>
<span class="p_add">+	write_c0_wired(0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Flush all previous TLB entries */</span>
<span class="p_add">+	local_flush_tlb_all();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Map firmware resources into virtual memory */</span>
<span class="p_add">+	mips_rproc_carveouts(rproc, max_pagemask);</span>
<span class="p_add">+	mips_rproc_vdevs(rproc, max_pagemask);</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI to remote: %d\n&quot;, ipi_to_remote);</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;IPI from remote: %d\n&quot;, ipi_from_remote);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Hand off the CPU to the firmware */</span>
<span class="p_add">+	dev_dbg(&amp;rproc-&gt;dev, &quot;Jumping to firmware at 0x%x\n&quot;, rproc-&gt;bootaddr);</span>
<span class="p_add">+</span>
<span class="p_add">+	write_c0_entryhi(0); /* Set ASID 0 */</span>
<span class="p_add">+	tlbw_use_hazard();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Firmware protocol */</span>
<span class="p_add">+	__asm__(&quot;addiu $a0, $zero, -3&quot;);</span>
<span class="p_add">+	__asm__(&quot;move $a1, %0&quot; :: &quot;r&quot; (ipi_to_remote));</span>
<span class="p_add">+	__asm__(&quot;move $a2, %0&quot; :: &quot;r&quot; (ipi_from_remote));</span>
<span class="p_add">+	__asm__(&quot;move $a3, $zero&quot;);</span>
<span class="p_add">+	__asm__(&quot;jr %0&quot; :: &quot;r&quot; (rproc-&gt;bootaddr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_ipi_handler(int irq, void *dev_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Synthetic interrupts shouldn&#39;t need acking */</span>
<span class="p_add">+	return IRQ_WAKE_THREAD;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static irqreturn_t mips_rproc_vq_int(int irq, void *p)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc *rproc = (struct rproc *)p;</span>
<span class="p_add">+	void *entry;</span>
<span class="p_add">+	int id;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We don&#39;t have a mailbox, so iterate over all vqs and kick them. */</span>
<span class="p_add">+	idr_for_each_entry(&amp;rproc-&gt;notifyids, entry, id)</span>
<span class="p_add">+		rproc_vq_interrupt(rproc, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Helper function to find the IPI domain */</span>
<span class="p_add">+static struct irq_domain *ipi_domain(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device_node *node = of_irq_find_parent(of_root);</span>
<span class="p_add">+	struct irq_domain *ipidomain;</span>
<span class="p_add">+</span>
<span class="p_add">+	ipidomain = irq_find_matching_host(node, DOMAIN_BUS_IPI);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Some platforms have half DT setup. So if we found irq node but</span>
<span class="p_add">+	 * didn&#39;t find an ipidomain, try to search for one that is not in the</span>
<span class="p_add">+	 * DT.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (node &amp;&amp; !ipidomain)</span>
<span class="p_add">+		ipidomain = irq_find_matching_host(NULL, DOMAIN_BUS_IPI);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ipidomain;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_start(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+	int cpu = mproc-&gt;cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;%s\n&quot;, __func__);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Create task for the CPU to use before handing off to firmware */</span>
<span class="p_add">+	mproc-&gt;tsk = fork_idle(cpu);</span>
<span class="p_add">+	if (IS_ERR(mproc-&gt;tsk)) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;fork_idle() failed for CPU%d\n&quot;, cpu);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* We won&#39;t be needing the Linux IPIs anymore */</span>
<span class="p_add">+	if (mips_smp_ipi_free(get_cpu_mask(cpu))) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="p_add">+		goto exit_free_tsk;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Direct IPIs from the remote processor to CPU0 since that can&#39;t be</span>
<span class="p_add">+	 * offlined while the remote CPU is running.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mproc-&gt;ipi_linux = irq_reserve_ipi(ipi_domain(), get_cpu_mask(0));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_linux) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve incoming kick\n&quot;);</span>
<span class="p_add">+		goto exit_restore_ipi;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;ipi_remote = irq_reserve_ipi(ipi_domain(), get_cpu_mask(cpu));</span>
<span class="p_add">+	if (!mproc-&gt;ipi_remote) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to reserve outgoing kick\n&quot;);</span>
<span class="p_add">+		goto exit_destroy_ipi_linux;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* register incoming ipi */</span>
<span class="p_add">+	err = request_threaded_irq(mproc-&gt;ipi_linux, mips_rproc_ipi_handler,</span>
<span class="p_add">+				   mips_rproc_vq_int, 0,</span>
<span class="p_add">+				   &quot;mips-rproc IPI in&quot;, rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to register incoming kick: %d\n&quot;,</span>
<span class="p_add">+			err);</span>
<span class="p_add">+		goto exit_destroy_ipi_remote;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_cps_steal_cpu_and_execute(cpu, &amp;mips_rproc_cpu_entry,</span>
<span class="p_add">+						mproc-&gt;tsk)) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to steal CPU%d for remote\n&quot;, cpu);</span>
<span class="p_add">+		goto exit_free_irq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	dev_info(&amp;mproc-&gt;dev, &quot;CPU%d started\n&quot;, cpu);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+exit_free_irq:</span>
<span class="p_add">+	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="p_add">+exit_destroy_ipi_remote:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(cpu));</span>
<span class="p_add">+exit_destroy_ipi_linux:</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+exit_restore_ipi:</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(cpu));</span>
<span class="p_add">+exit_free_tsk:</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int mips_rproc_op_stop(struct rproc *rproc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	free_irq(mproc-&gt;ipi_linux, rproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_linux, get_cpu_mask(0));</span>
<span class="p_add">+	irq_destroy_ipi(mproc-&gt;ipi_remote, get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set up the Linux IPIs again */</span>
<span class="p_add">+	mips_smp_ipi_allocate(get_cpu_mask(mproc-&gt;cpu));</span>
<span class="p_add">+</span>
<span class="p_add">+	free_task(mproc-&gt;tsk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return mips_cps_halt_and_return_cpu(mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void mips_rproc_op_kick(struct rproc *rproc, int vqid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rproc-&gt;state == RPROC_RUNNING)</span>
<span class="p_add">+		ipi_send_single(mproc-&gt;ipi_remote, mproc-&gt;cpu);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct rproc_ops mips_rproc_proc_ops = {</span>
<span class="p_add">+	.start	= mips_rproc_op_start,</span>
<span class="p_add">+	.stop	= mips_rproc_op_stop,</span>
<span class="p_add">+	.kick	= mips_rproc_op_kick,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_probe(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_remove(struct platform_device *pdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct platform_driver mips_rproc_driver = {</span>
<span class="p_add">+	.probe = mips_rproc_probe,</span>
<span class="p_add">+	.remove = mips_rproc_remove,</span>
<span class="p_add">+	.driver = {</span>
<span class="p_add">+		.name = &quot;mips-rproc&quot;</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void mips_rproc_release(struct device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int mips_rproc_uevent(struct device *dev, struct kobj_uevent_env *env)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mips_rproc *mproc = to_mips_rproc(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mproc)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct device_type mips_rproc_type = {</span>
<span class="p_add">+	.release	= mips_rproc_release,</span>
<span class="p_add">+	.uevent		= mips_rproc_uevent</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/* Create an rproc instance in response to CPU down */</span>
<span class="p_add">+static int mips_rproc_device_register(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	char name[64], *template = &quot;mips-cpu%u&quot;;</span>
<span class="p_add">+	struct rproc *rproc;</span>
<span class="p_add">+	struct mips_rproc *mproc;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Allocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mips_rprocs[cpu]) {</span>
<span class="p_add">+		dev_err(&amp;rproc-&gt;dev, &quot;CPU%d in use\n&quot;, cpu);</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc = kzalloc(sizeof(struct mips_rproc), GFP_KERNEL);</span>
<span class="p_add">+	if (!mproc) {</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto exit;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc-&gt;dev.driver = &amp;mips_rproc_driver.driver;</span>
<span class="p_add">+	mproc-&gt;dev.type = &amp;mips_rproc_type;</span>
<span class="p_add">+	mproc-&gt;dev.id = cpu;</span>
<span class="p_add">+	snprintf(name, sizeof(name), template, cpu);</span>
<span class="p_add">+	dev_set_name(&amp;mproc-&gt;dev, name);</span>
<span class="p_add">+	mproc-&gt;cpu = cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Set device to have coherent DMA ops */</span>
<span class="p_add">+	arch_setup_dma_ops(&amp;mproc-&gt;dev, 0, 0, NULL, 1);</span>
<span class="p_add">+</span>
<span class="p_add">+	rproc = rproc_alloc(&amp;mproc-&gt;dev, dev_name(&amp;mproc-&gt;dev),</span>
<span class="p_add">+			    &amp;mips_rproc_proc_ops, NULL,</span>
<span class="p_add">+			    sizeof(struct mips_rproc *));</span>
<span class="p_add">+	if (!rproc) {</span>
<span class="p_add">+		pr_err(&quot;Error allocting rproc\n&quot;);</span>
<span class="p_add">+		err = -ENOMEM;</span>
<span class="p_add">+		goto exit_free_mproc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*(struct mips_rproc **)rproc-&gt;priv = mproc;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = device_register(&amp;mproc-&gt;dev);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		pr_err(&quot;device add failed\n&quot;);</span>
<span class="p_add">+		goto exit_free_rproc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	err = rproc_add(rproc);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;mproc-&gt;dev, &quot;Failed to add rproc: %d\n&quot;, err);</span>
<span class="p_add">+		goto exit_free_rproc;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rprocs[cpu] = rproc;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+exit_free_rproc:</span>
<span class="p_add">+	rproc_put(rproc);</span>
<span class="p_add">+exit_free_mproc:</span>
<span class="p_add">+	kfree(mproc);</span>
<span class="p_add">+exit:</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Destroy rproc instance in response to CPU up */</span>
<span class="p_add">+static int mips_rproc_device_unregister(unsigned int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct rproc *rproc = mips_rprocs[cpu];</span>
<span class="p_add">+	struct mips_rproc *mproc;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rproc)</span>
<span class="p_add">+		/* No rproc class has been created for this CPU */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_debug(&quot;Deallocating MIPS rproc for cpu%d\n&quot;, cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	rproc_del(rproc);</span>
<span class="p_add">+	rproc_put(rproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	mproc = *(struct mips_rproc **)rproc-&gt;priv;</span>
<span class="p_add">+	device_unregister(&amp;mproc-&gt;dev);</span>
<span class="p_add">+	kfree(mproc);</span>
<span class="p_add">+</span>
<span class="p_add">+	mips_rprocs[cpu] = NULL;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init mips_rproc_init(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Register with the cpu hotplug state machine.</span>
<span class="p_add">+	 * This driver requires opposite sense to &quot;normal&quot; drivers, since the</span>
<span class="p_add">+	 * driver is activated for offline CPUs via the teardown callback and</span>
<span class="p_add">+	 * deactivated via the online callback.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cpuhp_state = cpuhp_setup_state(CPUHP_AP_ONLINE_DYN, &quot;MIPS:REMOTEPROC&quot;,</span>
<span class="p_add">+					mips_rproc_device_unregister,</span>
<span class="p_add">+					mips_rproc_device_register);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Register a device for each offline CPU */</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+	for_each_possible_cpu(cpu)</span>
<span class="p_add">+		if (!cpu_online(cpu))</span>
<span class="p_add">+			mips_rproc_device_register(cpu);</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __exit mips_rproc_exit(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpuhp_state) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Unregister with the cpu hotplug state machine, but don&#39;t call</span>
<span class="p_add">+		 * the teardown callback, since that would try to start the</span>
<span class="p_add">+		 * remote processor device.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		__cpuhp_remove_state(cpuhp_state, false);</span>
<span class="p_add">+		cpuhp_state = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	get_online_cpus();</span>
<span class="p_add">+	/* Unregister devices created for any offline CPUs */</span>
<span class="p_add">+	for_each_possible_cpu(cpu)</span>
<span class="p_add">+		mips_rproc_device_unregister(cpu);</span>
<span class="p_add">+	put_online_cpus();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+subsys_initcall(mips_rproc_init);</span>
<span class="p_add">+module_exit(mips_rproc_exit);</span>
<span class="p_add">+</span>
<span class="p_add">+module_platform_driver(mips_rproc_driver);</span>
<span class="p_add">+</span>
<span class="p_add">+MODULE_LICENSE(&quot;GPL v2&quot;);</span>
<span class="p_add">+MODULE_DESCRIPTION(&quot;MIPS Remote Processor control driver&quot;);</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



