
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[v9,3/5] iommu/arm-smmu: Invoke pm_runtime during probe, add/remove device - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [v9,3/5] iommu/arm-smmu: Invoke pm_runtime during probe, add/remove device</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=170013">Vivek Gautam</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 13, 2018, 8:55 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180313085534.11650-4-vivek.gautam@codeaurora.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10277961/mbox/"
   >mbox</a>
|
   <a href="/patch/10277961/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10277961/">/patch/10277961/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	B2D2E602BD for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 13 Mar 2018 08:56:28 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B066C28F1C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 13 Mar 2018 08:56:28 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id A4CE028F48; Tue, 13 Mar 2018 08:56:28 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.8 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DA58328F1C
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 13 Mar 2018 08:56:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752628AbeCMI4Z (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 13 Mar 2018 04:56:25 -0400
Received: from smtp.codeaurora.org ([198.145.29.96]:38392 &quot;EHLO
	smtp.codeaurora.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752003AbeCMI4U (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 13 Mar 2018 04:56:20 -0400
Received: by smtp.codeaurora.org (Postfix, from userid 1000)
	id 043FB60FEE; Tue, 13 Mar 2018 08:56:17 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=codeaurora.org;
	s=default; t=1520931379;
	bh=KP2fkGPAIqPbmqhSaqsstMYHfbpMhZSS7OX/k+Oz1/A=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
	b=YVXWtU7aumOytT0vFEMDzLMpG6soFiQgFC2DhPlGIRcRl07/zchM6siQV/wDDnehb
	wzapHJLQY5FlFboI50LmZwVPCfDqjj0l5gtbVfkHCdqxclTRSzDw7zgQIN0apPE0l9
	ZM0IfAn6Jan7uIiTAlJEkm2pZ4uErUXTv1bb7VXI=
Received: from blr-ubuntu-41.ap.qualcomm.com
	(blr-bdr-fw-01_globalnat_allzones-outside.qualcomm.com
	[103.229.18.19])
	(using TLSv1.1 with cipher ECDHE-RSA-AES128-SHA (128/128 bits))
	(No client certificate requested)
	(Authenticated sender: vivek.gautam@smtp.codeaurora.org)
	by smtp.codeaurora.org (Postfix) with ESMTPSA id 8359560858;
	Tue, 13 Mar 2018 08:56:11 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=codeaurora.org;
	s=default; t=1520931375;
	bh=KP2fkGPAIqPbmqhSaqsstMYHfbpMhZSS7OX/k+Oz1/A=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References:From;
	b=f10VVWy2l6npvMdSzoOoya65OIpteEwz/tLr6l4avnwW0/EIwrQruLmqw3CllMY3W
	9ns9j0doTQYxVVl3pu7110i7KMOz8L9T6ljF63c9vAyAbjESf8kRUsxEQnw7Ew46U2
	mOToFIjY80o96thiI0lBoMYJCKPOLEPktebJ6HJ8=
DMARC-Filter: OpenDMARC Filter v1.3.2 smtp.codeaurora.org 8359560858
Authentication-Results: pdx-caf-mail.web.codeaurora.org;
	dmarc=none (p=none dis=none)
	header.from=codeaurora.org
Authentication-Results: pdx-caf-mail.web.codeaurora.org;
	spf=none smtp.mailfrom=vivek.gautam@codeaurora.org
From: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;
To: joro@8bytes.org, robh+dt@kernel.org, robin.murphy@arm.com,
	iommu@lists.linux-foundation.org, devicetree@vger.kernel.org,
	linux-kernel@vger.kernel.org
Cc: mark.rutland@arm.com, will.deacon@arm.com, robdclark@gmail.com,
	tfiga@chromium.org, sricharan@codeaurora.org,
	m.szyprowski@samsung.com, architt@codeaurora.org,
	linux-arm-msm@vger.kernel.org, vivek.gautam@codeaurora.org
Subject: [PATCH v9 3/5] iommu/arm-smmu: Invoke pm_runtime during probe,
	add/remove device
Date: Tue, 13 Mar 2018 14:25:32 +0530
Message-Id: &lt;20180313085534.11650-4-vivek.gautam@codeaurora.org&gt;
X-Mailer: git-send-email 2.16.1.72.g5be1f00a9a70
In-Reply-To: &lt;20180313085534.11650-1-vivek.gautam@codeaurora.org&gt;
References: &lt;20180313085534.11650-1-vivek.gautam@codeaurora.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=170013">Vivek Gautam</a> - March 13, 2018, 8:55 a.m.</div>
<pre class="content">
<span class="from">From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>

The smmu device probe/remove and add/remove master device callbacks
gets called when the smmu is not linked to its master, that is without
the context of the master device. So calling runtime apis in those places
separately.
<span class="signed-off-by">
Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
[vivek: Cleanup pm runtime calls]
<span class="signed-off-by">Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="reviewed-by">Reviewed-by: Tomasz Figa &lt;tfiga@chromium.org&gt;</span>
---
 drivers/iommu/arm-smmu.c | 95 ++++++++++++++++++++++++++++++++++++++++++++----
 1 file changed, 87 insertions(+), 8 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=77581">Robin Murphy</a> - March 14, 2018, 5:46 p.m.</div>
<pre class="content">
On 13/03/18 08:55, Vivek Gautam wrote:
<span class="quote">&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt; the context of the master device. So calling runtime apis in those places</span>
<span class="quote">&gt; separately.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt; Reviewed-by: Tomasz Figa &lt;tfiga@chromium.org&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;   drivers/iommu/arm-smmu.c | 95 ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;   1 file changed, 87 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt; index d5873d545024..56a04ae80bf3 100644</span>
<span class="quote">&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt; @@ -268,6 +268,20 @@ static struct arm_smmu_option_prop arm_smmu_options[] = {</span>
<span class="quote">&gt;   	{ 0, NULL},</span>
<span class="quote">&gt;   };</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +static inline int arm_smmu_rpm_get(struct arm_smmu_device *smmu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="quote">&gt; +		return pm_runtime_get_sync(smmu-&gt;dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +static inline void arm_smmu_rpm_put(struct arm_smmu_device *smmu)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="quote">&gt; +		pm_runtime_put(smmu-&gt;dev);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   static struct arm_smmu_domain *to_smmu_domain(struct iommu_domain *dom)</span>
<span class="quote">&gt;   {</span>
<span class="quote">&gt;   	return container_of(dom, struct arm_smmu_domain, domain);</span>
<span class="quote">&gt; @@ -913,11 +927,15 @@ static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
<span class="quote">&gt;   	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt;   	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt;   	struct arm_smmu_cfg *cfg = &amp;smmu_domain-&gt;cfg;</span>
<span class="quote">&gt; -	int irq;</span>
<span class="quote">&gt; +	int ret, irq;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!smmu || domain-&gt;type == IOMMU_DOMAIN_IDENTITY)</span>
<span class="quote">&gt;   		return;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	/*</span>
<span class="quote">&gt;   	 * Disable the context bank and free the page tables before freeing</span>
<span class="quote">&gt;   	 * it.</span>
<span class="quote">&gt; @@ -932,6 +950,8 @@ static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	free_io_pgtable_ops(smmu_domain-&gt;pgtbl_ops);</span>
<span class="quote">&gt;   	__arm_smmu_free_bitmap(smmu-&gt;context_map, cfg-&gt;cbndx);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   static struct iommu_domain *arm_smmu_domain_alloc(unsigned type)</span>
<span class="quote">&gt; @@ -1213,10 +1233,15 @@ static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
<span class="quote">&gt;   		return -ENODEV;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	smmu = fwspec_smmu(fwspec);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	/* Ensure that the domain is finalised */</span>
<span class="quote">&gt;   	ret = arm_smmu_init_domain_context(domain, smmu);</span>
<span class="quote">&gt;   	if (ret &lt; 0)</span>
<span class="quote">&gt; -		return ret;</span>
<span class="quote">&gt; +		goto rpm_put;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	/*</span>
<span class="quote">&gt;   	 * Sanity check the domain. We don&#39;t support domains across</span>
<span class="quote">&gt; @@ -1230,29 +1255,47 @@ static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
<span class="quote">&gt;   	}</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	/* Looks ok, so add the device to the domain */</span>
<span class="quote">&gt; -	return arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="quote">&gt; +	ret = arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +rpm_put:</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   static int arm_smmu_map(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt;   			phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt;   {</span>
<span class="quote">&gt;   	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;</span>
<span class="quote">&gt; +	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt; +	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>

Nit: please use arm_smmu_domain for ops as well (as it was before 
523d7423e21b), or consistently elide it for smmu - the mixture of both 
methods is just a horrible mess (here and in unmap).
<span class="quote">
&gt; +	int ret;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!ops)</span>
<span class="quote">&gt;   		return -ENODEV;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; -	return ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="quote">&gt; +	arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	ret = ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   static size_t arm_smmu_unmap(struct iommu_domain *domain, unsigned long iova,</span>
<span class="quote">&gt;   			     size_t size)</span>
<span class="quote">&gt;   {</span>
<span class="quote">&gt;   	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;</span>
<span class="quote">&gt; +	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt; +	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt; +	size_t ret;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!ops)</span>
<span class="quote">&gt;   		return 0;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; -	return ops-&gt;unmap(ops, iova, size);</span>
<span class="quote">&gt; +	arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	ret = ops-&gt;unmap(ops, iova, size);</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt;   }</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   static void arm_smmu_iotlb_sync(struct iommu_domain *domain)</span>
<span class="quote">&gt; @@ -1407,14 +1450,22 @@ static int arm_smmu_add_device(struct device *dev)</span>
<span class="quote">&gt;   	while (i--)</span>
<span class="quote">&gt;   		cfg-&gt;smendx[i] = INVALID_SMENDX;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		goto out_cfg_free;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	ret = arm_smmu_master_alloc_smes(dev);</span>

Nit: it would be easier to just do the rpm_put here; then you don&#39;t need 
to mess with the cleanup path.
<span class="quote">
&gt;   	if (ret)</span>
<span class="quote">&gt; -		goto out_cfg_free;</span>
<span class="quote">&gt; +		goto out_rpm_put;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	iommu_device_link(&amp;smmu-&gt;iommu, dev);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	return 0;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +out_rpm_put:</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;   out_cfg_free:</span>
<span class="quote">&gt;   	kfree(cfg);</span>
<span class="quote">&gt;   out_free:</span>
<span class="quote">&gt; @@ -1427,7 +1478,7 @@ static void arm_smmu_remove_device(struct device *dev)</span>
<span class="quote">&gt;   	struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;</span>
<span class="quote">&gt;   	struct arm_smmu_master_cfg *cfg;</span>
<span class="quote">&gt;   	struct arm_smmu_device *smmu;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; +	int ret;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	if (!fwspec || fwspec-&gt;ops != &amp;arm_smmu_ops)</span>
<span class="quote">&gt;   		return;</span>
<span class="quote">&gt; @@ -1435,8 +1486,15 @@ static void arm_smmu_remove_device(struct device *dev)</span>
<span class="quote">&gt;   	cfg  = fwspec-&gt;iommu_priv;</span>
<span class="quote">&gt;   	smmu = cfg-&gt;smmu;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		return;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	iommu_device_unlink(&amp;smmu-&gt;iommu, dev);</span>
<span class="quote">&gt;   	arm_smmu_master_free_smes(fwspec);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	iommu_group_remove_device(dev);</span>
<span class="quote">&gt;   	kfree(fwspec-&gt;iommu_priv);</span>
<span class="quote">&gt;   	iommu_fwspec_free(dev);</span>
<span class="quote">&gt; @@ -2124,6 +2182,8 @@ static int arm_smmu_device_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;   		smmu-&gt;irqs[i] = irq;</span>
<span class="quote">&gt;   	}</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	platform_set_drvdata(pdev, smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	err = devm_clk_bulk_get(smmu-&gt;dev, smmu-&gt;num_clks, smmu-&gt;clks);</span>
<span class="quote">&gt;   	if (err)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt; @@ -2132,6 +2192,19 @@ static int arm_smmu_device_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;   	if (err)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	/*</span>
<span class="quote">&gt; +	 * We want to avoid touching dev-&gt;power.lock in fastpaths unless</span>
<span class="quote">&gt; +	 * it&#39;s really going to do something useful - pm_runtime_enabled()</span>
<span class="quote">&gt; +	 * can serve as an ideal proxy for that decision. So, conditionally</span>
<span class="quote">&gt; +	 * enable pm_runtime.</span>
<span class="quote">&gt; +	 */</span>
<span class="quote">&gt; +	if (dev-&gt;pm_domain)</span>
<span class="quote">&gt; +		pm_runtime_enable(dev);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	err = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt; +	if (err &lt; 0)</span>
<span class="quote">&gt; +		return err;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	err = arm_smmu_device_cfg_probe(smmu);</span>
<span class="quote">&gt;   	if (err)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt; @@ -2173,10 +2246,11 @@ static int arm_smmu_device_probe(struct platform_device *pdev)</span>
<span class="quote">&gt;   		return err;</span>
<span class="quote">&gt;   	}</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; -	platform_set_drvdata(pdev, smmu);</span>
<span class="quote">&gt;   	arm_smmu_device_reset(smmu);</span>
<span class="quote">&gt;   	arm_smmu_test_smr_masks(smmu);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;   	/*</span>
<span class="quote">&gt;   	 * For ACPI and generic DT bindings, an SMMU will be probed before</span>
<span class="quote">&gt;   	 * any device which might need it, so we want the bus ops in place</span>
<span class="quote">&gt; @@ -2212,8 +2286,13 @@ static int arm_smmu_device_remove(struct platform_device *pdev)</span>
<span class="quote">&gt;   	if (!bitmap_empty(smmu-&gt;context_map, ARM_SMMU_MAX_CBS))</span>
<span class="quote">&gt;   		dev_err(&amp;pdev-&gt;dev, &quot;removing device with active domains!\n&quot;);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt; +	arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;   	/* Turn the thing off */</span>
<span class="quote">&gt;   	writel(sCR0_CLIENTPD, ARM_SMMU_GR0_NS(smmu) + ARM_SMMU_GR0_sCR0);</span>
<span class="quote">&gt; +	arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="quote">&gt; +		pm_runtime_disable(smmu-&gt;dev);</span>
<span class="quote">&gt;   </span>
<span class="quote">&gt;   	clk_bulk_unprepare(smmu-&gt;num_clks, smmu-&gt;clks);</span>
<span class="quote">&gt;   </span>

I don&#39;t know how runtime and system PM interact - does the reset in 
arm_smmu_pm_resume need special treatment as well, or is the device 
guaranteed to be powered up at that point by other means?

Robin.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=117291">Tomasz Figa</a> - March 15, 2018, 7:17 a.m.</div>
<pre class="content">
On Thu, Mar 15, 2018 at 2:46 AM, Robin Murphy &lt;robin.murphy@arm.com&gt; wrote:
<span class="quote">&gt; On 13/03/18 08:55, Vivek Gautam wrote:</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; From: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; The smmu device probe/remove and add/remove master device callbacks</span>
<span class="quote">&gt;&gt; gets called when the smmu is not linked to its master, that is without</span>
<span class="quote">&gt;&gt; the context of the master device. So calling runtime apis in those places</span>
<span class="quote">&gt;&gt; separately.</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; Signed-off-by: Sricharan R &lt;sricharan@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt; [vivek: Cleanup pm runtime calls]</span>
<span class="quote">&gt;&gt; Signed-off-by: Vivek Gautam &lt;vivek.gautam@codeaurora.org&gt;</span>
<span class="quote">&gt;&gt; Reviewed-by: Tomasz Figa &lt;tfiga@chromium.org&gt;</span>
<span class="quote">&gt;&gt; ---</span>
<span class="quote">&gt;&gt;   drivers/iommu/arm-smmu.c | 95</span>
<span class="quote">&gt;&gt; ++++++++++++++++++++++++++++++++++++++++++++----</span>
<span class="quote">&gt;&gt;   1 file changed, 87 insertions(+), 8 deletions(-)</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;&gt; diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt; index d5873d545024..56a04ae80bf3 100644</span>
<span class="quote">&gt;&gt; --- a/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt; +++ b/drivers/iommu/arm-smmu.c</span>
<span class="quote">&gt;&gt; @@ -268,6 +268,20 @@ static struct arm_smmu_option_prop arm_smmu_options[]</span>
<span class="quote">&gt;&gt; = {</span>
<span class="quote">&gt;&gt;         { 0, NULL},</span>
<span class="quote">&gt;&gt;   };</span>
<span class="quote">&gt;&gt;   +static inline int arm_smmu_rpm_get(struct arm_smmu_device *smmu)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="quote">&gt;&gt; +               return pm_runtime_get_sync(smmu-&gt;dev);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       return 0;</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +static inline void arm_smmu_rpm_put(struct arm_smmu_device *smmu)</span>
<span class="quote">&gt;&gt; +{</span>
<span class="quote">&gt;&gt; +       if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="quote">&gt;&gt; +               pm_runtime_put(smmu-&gt;dev);</span>
<span class="quote">&gt;&gt; +}</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;   static struct arm_smmu_domain *to_smmu_domain(struct iommu_domain *dom)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt;         return container_of(dom, struct arm_smmu_domain, domain);</span>
<span class="quote">&gt;&gt; @@ -913,11 +927,15 @@ static void arm_smmu_destroy_domain_context(struct</span>
<span class="quote">&gt;&gt; iommu_domain *domain)</span>
<span class="quote">&gt;&gt;         struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt;&gt;         struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt;&gt;         struct arm_smmu_cfg *cfg = &amp;smmu_domain-&gt;cfg;</span>
<span class="quote">&gt;&gt; -       int irq;</span>
<span class="quote">&gt;&gt; +       int ret, irq;</span>
<span class="quote">&gt;&gt;         if (!smmu || domain-&gt;type == IOMMU_DOMAIN_IDENTITY)</span>
<span class="quote">&gt;&gt;                 return;</span>
<span class="quote">&gt;&gt;   +     ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt; +       if (ret &lt; 0)</span>
<span class="quote">&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         /*</span>
<span class="quote">&gt;&gt;          * Disable the context bank and free the page tables before</span>
<span class="quote">&gt;&gt; freeing</span>
<span class="quote">&gt;&gt;          * it.</span>
<span class="quote">&gt;&gt; @@ -932,6 +950,8 @@ static void arm_smmu_destroy_domain_context(struct</span>
<span class="quote">&gt;&gt; iommu_domain *domain)</span>
<span class="quote">&gt;&gt;         free_io_pgtable_ops(smmu_domain-&gt;pgtbl_ops);</span>
<span class="quote">&gt;&gt;         __arm_smmu_free_bitmap(smmu-&gt;context_map, cfg-&gt;cbndx);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;     static struct iommu_domain *arm_smmu_domain_alloc(unsigned type)</span>
<span class="quote">&gt;&gt; @@ -1213,10 +1233,15 @@ static int arm_smmu_attach_dev(struct iommu_domain</span>
<span class="quote">&gt;&gt; *domain, struct device *dev)</span>
<span class="quote">&gt;&gt;                 return -ENODEV;</span>
<span class="quote">&gt;&gt;         smmu = fwspec_smmu(fwspec);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt; +       if (ret &lt; 0)</span>
<span class="quote">&gt;&gt; +               return ret;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         /* Ensure that the domain is finalised */</span>
<span class="quote">&gt;&gt;         ret = arm_smmu_init_domain_context(domain, smmu);</span>
<span class="quote">&gt;&gt;         if (ret &lt; 0)</span>
<span class="quote">&gt;&gt; -               return ret;</span>
<span class="quote">&gt;&gt; +               goto rpm_put;</span>
<span class="quote">&gt;&gt;         /*</span>
<span class="quote">&gt;&gt;          * Sanity check the domain. We don&#39;t support domains across</span>
<span class="quote">&gt;&gt; @@ -1230,29 +1255,47 @@ static int arm_smmu_attach_dev(struct iommu_domain</span>
<span class="quote">&gt;&gt; *domain, struct device *dev)</span>
<span class="quote">&gt;&gt;         }</span>
<span class="quote">&gt;&gt;         /* Looks ok, so add the device to the domain */</span>
<span class="quote">&gt;&gt; -       return arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="quote">&gt;&gt; +       ret = arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +rpm_put:</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt; +       return ret;</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;     static int arm_smmu_map(struct iommu_domain *domain, unsigned long</span>
<span class="quote">&gt;&gt; iova,</span>
<span class="quote">&gt;&gt;                         phys_addr_t paddr, size_t size, int prot)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt;         struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;</span>
<span class="quote">&gt;&gt; +       struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt;&gt; +       struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Nit: please use arm_smmu_domain for ops as well (as it was before</span>
<span class="quote">&gt; 523d7423e21b), or consistently elide it for smmu - the mixture of both</span>
<span class="quote">&gt; methods is just a horrible mess (here and in unmap).</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt; +       int ret;</span>
<span class="quote">&gt;&gt;         if (!ops)</span>
<span class="quote">&gt;&gt;                 return -ENODEV;</span>
<span class="quote">&gt;&gt;   -     return ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt; +       ret = ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       return ret;</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;     static size_t arm_smmu_unmap(struct iommu_domain *domain, unsigned</span>
<span class="quote">&gt;&gt; long iova,</span>
<span class="quote">&gt;&gt;                              size_t size)</span>
<span class="quote">&gt;&gt;   {</span>
<span class="quote">&gt;&gt;         struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;</span>
<span class="quote">&gt;&gt; +       struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="quote">&gt;&gt; +       struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="quote">&gt;&gt; +       size_t ret;</span>
<span class="quote">&gt;&gt;         if (!ops)</span>
<span class="quote">&gt;&gt;                 return 0;</span>
<span class="quote">&gt;&gt;   -     return ops-&gt;unmap(ops, iova, size);</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt; +       ret = ops-&gt;unmap(ops, iova, size);</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       return ret;</span>
<span class="quote">&gt;&gt;   }</span>
<span class="quote">&gt;&gt;     static void arm_smmu_iotlb_sync(struct iommu_domain *domain)</span>
<span class="quote">&gt;&gt; @@ -1407,14 +1450,22 @@ static int arm_smmu_add_device(struct device *dev)</span>
<span class="quote">&gt;&gt;         while (i--)</span>
<span class="quote">&gt;&gt;                 cfg-&gt;smendx[i] = INVALID_SMENDX;</span>
<span class="quote">&gt;&gt;   +     ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt; +       if (ret &lt; 0)</span>
<span class="quote">&gt;&gt; +               goto out_cfg_free;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         ret = arm_smmu_master_alloc_smes(dev);</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Nit: it would be easier to just do the rpm_put here; then you don&#39;t need to</span>
<span class="quote">&gt; mess with the cleanup path.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;&gt;         if (ret)</span>
<span class="quote">&gt;&gt; -               goto out_cfg_free;</span>
<span class="quote">&gt;&gt; +               goto out_rpm_put;</span>
<span class="quote">&gt;&gt;         iommu_device_link(&amp;smmu-&gt;iommu, dev);</span>
<span class="quote">&gt;&gt;   +     arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         return 0;</span>
<span class="quote">&gt;&gt;   +out_rpm_put:</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt;   out_cfg_free:</span>
<span class="quote">&gt;&gt;         kfree(cfg);</span>
<span class="quote">&gt;&gt;   out_free:</span>
<span class="quote">&gt;&gt; @@ -1427,7 +1478,7 @@ static void arm_smmu_remove_device(struct device</span>
<span class="quote">&gt;&gt; *dev)</span>
<span class="quote">&gt;&gt;         struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;</span>
<span class="quote">&gt;&gt;         struct arm_smmu_master_cfg *cfg;</span>
<span class="quote">&gt;&gt;         struct arm_smmu_device *smmu;</span>
<span class="quote">&gt;&gt; -</span>
<span class="quote">&gt;&gt; +       int ret;</span>
<span class="quote">&gt;&gt;         if (!fwspec || fwspec-&gt;ops != &amp;arm_smmu_ops)</span>
<span class="quote">&gt;&gt;                 return;</span>
<span class="quote">&gt;&gt; @@ -1435,8 +1486,15 @@ static void arm_smmu_remove_device(struct device</span>
<span class="quote">&gt;&gt; *dev)</span>
<span class="quote">&gt;&gt;         cfg  = fwspec-&gt;iommu_priv;</span>
<span class="quote">&gt;&gt;         smmu = cfg-&gt;smmu;</span>
<span class="quote">&gt;&gt;   +     ret = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt; +       if (ret &lt; 0)</span>
<span class="quote">&gt;&gt; +               return;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         iommu_device_unlink(&amp;smmu-&gt;iommu, dev);</span>
<span class="quote">&gt;&gt;         arm_smmu_master_free_smes(fwspec);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         iommu_group_remove_device(dev);</span>
<span class="quote">&gt;&gt;         kfree(fwspec-&gt;iommu_priv);</span>
<span class="quote">&gt;&gt;         iommu_fwspec_free(dev);</span>
<span class="quote">&gt;&gt; @@ -2124,6 +2182,8 @@ static int arm_smmu_device_probe(struct</span>
<span class="quote">&gt;&gt; platform_device *pdev)</span>
<span class="quote">&gt;&gt;                 smmu-&gt;irqs[i] = irq;</span>
<span class="quote">&gt;&gt;         }</span>
<span class="quote">&gt;&gt;   +     platform_set_drvdata(pdev, smmu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         err = devm_clk_bulk_get(smmu-&gt;dev, smmu-&gt;num_clks, smmu-&gt;clks);</span>
<span class="quote">&gt;&gt;         if (err)</span>
<span class="quote">&gt;&gt;                 return err;</span>
<span class="quote">&gt;&gt; @@ -2132,6 +2192,19 @@ static int arm_smmu_device_probe(struct</span>
<span class="quote">&gt;&gt; platform_device *pdev)</span>
<span class="quote">&gt;&gt;         if (err)</span>
<span class="quote">&gt;&gt;                 return err;</span>
<span class="quote">&gt;&gt;   +     /*</span>
<span class="quote">&gt;&gt; +        * We want to avoid touching dev-&gt;power.lock in fastpaths unless</span>
<span class="quote">&gt;&gt; +        * it&#39;s really going to do something useful - pm_runtime_enabled()</span>
<span class="quote">&gt;&gt; +        * can serve as an ideal proxy for that decision. So,</span>
<span class="quote">&gt;&gt; conditionally</span>
<span class="quote">&gt;&gt; +        * enable pm_runtime.</span>
<span class="quote">&gt;&gt; +        */</span>
<span class="quote">&gt;&gt; +       if (dev-&gt;pm_domain)</span>
<span class="quote">&gt;&gt; +               pm_runtime_enable(dev);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       err = arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt; +       if (err &lt; 0)</span>
<span class="quote">&gt;&gt; +               return err;</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         err = arm_smmu_device_cfg_probe(smmu);</span>
<span class="quote">&gt;&gt;         if (err)</span>
<span class="quote">&gt;&gt;                 return err;</span>
<span class="quote">&gt;&gt; @@ -2173,10 +2246,11 @@ static int arm_smmu_device_probe(struct</span>
<span class="quote">&gt;&gt; platform_device *pdev)</span>
<span class="quote">&gt;&gt;                 return err;</span>
<span class="quote">&gt;&gt;         }</span>
<span class="quote">&gt;&gt;   -     platform_set_drvdata(pdev, smmu);</span>
<span class="quote">&gt;&gt;         arm_smmu_device_reset(smmu);</span>
<span class="quote">&gt;&gt;         arm_smmu_test_smr_masks(smmu);</span>
<span class="quote">&gt;&gt;   +     arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt;         /*</span>
<span class="quote">&gt;&gt;          * For ACPI and generic DT bindings, an SMMU will be probed before</span>
<span class="quote">&gt;&gt;          * any device which might need it, so we want the bus ops in place</span>
<span class="quote">&gt;&gt; @@ -2212,8 +2286,13 @@ static int arm_smmu_device_remove(struct</span>
<span class="quote">&gt;&gt; platform_device *pdev)</span>
<span class="quote">&gt;&gt;         if (!bitmap_empty(smmu-&gt;context_map, ARM_SMMU_MAX_CBS))</span>
<span class="quote">&gt;&gt;                 dev_err(&amp;pdev-&gt;dev, &quot;removing device with active</span>
<span class="quote">&gt;&gt; domains!\n&quot;);</span>
<span class="quote">&gt;&gt;   +     arm_smmu_rpm_get(smmu);</span>
<span class="quote">&gt;&gt;         /* Turn the thing off */</span>
<span class="quote">&gt;&gt;         writel(sCR0_CLIENTPD, ARM_SMMU_GR0_NS(smmu) + ARM_SMMU_GR0_sCR0);</span>
<span class="quote">&gt;&gt; +       arm_smmu_rpm_put(smmu);</span>
<span class="quote">&gt;&gt; +</span>
<span class="quote">&gt;&gt; +       if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="quote">&gt;&gt; +               pm_runtime_disable(smmu-&gt;dev);</span>
<span class="quote">&gt;&gt;         clk_bulk_unprepare(smmu-&gt;num_clks, smmu-&gt;clks);</span>
<span class="quote">&gt;&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; I don&#39;t know how runtime and system PM interact - does the reset in</span>
<span class="quote">&gt; arm_smmu_pm_resume need special treatment as well, or is the device</span>
<span class="quote">&gt; guaranteed to be powered up at that point by other means?</span>

Actually, it&#39;s quite complicated...

1) device_prepare(), prevents suspending active devices by getting a
runtime enable count [1] and then, depending on whether there is a
prepare callback that could be called for this device [2] or the
device doesn&#39;t have any PM callbacks [3], it might set the
&quot;direct_complete&quot; flag [4].

2) Later, when device_suspend() is called, if &quot;direct_complete&quot; is set
(and disabling runtime PM ends up with the device still
runtime-suspended) [5], the .suspend callback will be skipped. If
&quot;direct_complete&quot; is not set (or direct complete fails), the suspend
callback (if one exists) would be called regardless of runtime PM
state of the device [6].

3) During system resume, if &quot;direct_complete&quot; was set, the resume
callback would be completely skipped [7]. Otherwise it would be called
without any special conditions [8].

4) At the end of the whole process, device_complete() would put the
remaining reference count and potentially trigger a runtime idle and
suspend, if the device was active. [9]

Now, the behavior of what happens past 2) and before 3) is affected by
PM domain callbacks, namely prepare, suspend_noirq and resume_noirq.
For genpd, genpd_prepare() never returns a positive value, so
&quot;direct_complete&quot; would never happen [10]. genpd_finish_suspend()
[11], called from genpd_suspend_noirq(), attempts to cut off the
power, while genpd_resume_noirq() restore it [12], so it looks like
the power would be on during the SMMU resume callback.

[1] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L1671
[2] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L1688
[3] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L1683
[4] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L1719
[5] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L1492
[6] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L1506
[7] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L833
[8] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L888
[9] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/main.c#L1012
[10] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/domain.c#L1019
[11] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/domain.c#L1032
[12] https://elixir.bootlin.com/linux/latest/source/drivers/base/power/domain.c#L1085

Phew. This is still with skipped wake up capability handling, since
SMMU doesn&#39;t have such.

Best regards,
Tomasz
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="p_header">index d5873d545024..56a04ae80bf3 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu.c</span>
<span class="p_chunk">@@ -268,6 +268,20 @@</span> <span class="p_context"> static struct arm_smmu_option_prop arm_smmu_options[] = {</span>
 	{ 0, NULL},
 };
 
<span class="p_add">+static inline int arm_smmu_rpm_get(struct arm_smmu_device *smmu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="p_add">+		return pm_runtime_get_sync(smmu-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void arm_smmu_rpm_put(struct arm_smmu_device *smmu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="p_add">+		pm_runtime_put(smmu-&gt;dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct arm_smmu_domain *to_smmu_domain(struct iommu_domain *dom)
 {
 	return container_of(dom, struct arm_smmu_domain, domain);
<span class="p_chunk">@@ -913,11 +927,15 @@</span> <span class="p_context"> static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
 	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);
 	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;
 	struct arm_smmu_cfg *cfg = &amp;smmu_domain-&gt;cfg;
<span class="p_del">-	int irq;</span>
<span class="p_add">+	int ret, irq;</span>
 
 	if (!smmu || domain-&gt;type == IOMMU_DOMAIN_IDENTITY)
 		return;
 
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	/*
 	 * Disable the context bank and free the page tables before freeing
 	 * it.
<span class="p_chunk">@@ -932,6 +950,8 @@</span> <span class="p_context"> static void arm_smmu_destroy_domain_context(struct iommu_domain *domain)</span>
 
 	free_io_pgtable_ops(smmu_domain-&gt;pgtbl_ops);
 	__arm_smmu_free_bitmap(smmu-&gt;context_map, cfg-&gt;cbndx);
<span class="p_add">+</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
 }
 
 static struct iommu_domain *arm_smmu_domain_alloc(unsigned type)
<span class="p_chunk">@@ -1213,10 +1233,15 @@</span> <span class="p_context"> static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
 		return -ENODEV;
 
 	smmu = fwspec_smmu(fwspec);
<span class="p_add">+</span>
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
 	/* Ensure that the domain is finalised */
 	ret = arm_smmu_init_domain_context(domain, smmu);
 	if (ret &lt; 0)
<span class="p_del">-		return ret;</span>
<span class="p_add">+		goto rpm_put;</span>
 
 	/*
 	 * Sanity check the domain. We don&#39;t support domains across
<span class="p_chunk">@@ -1230,29 +1255,47 @@</span> <span class="p_context"> static int arm_smmu_attach_dev(struct iommu_domain *domain, struct device *dev)</span>
 	}
 
 	/* Looks ok, so add the device to the domain */
<span class="p_del">-	return arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="p_add">+	ret = arm_smmu_domain_add_master(smmu_domain, fwspec);</span>
<span class="p_add">+</span>
<span class="p_add">+rpm_put:</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int arm_smmu_map(struct iommu_domain *domain, unsigned long iova,
 			phys_addr_t paddr, size_t size, int prot)
 {
 	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;
<span class="p_add">+	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="p_add">+	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="p_add">+	int ret;</span>
 
 	if (!ops)
 		return -ENODEV;
 
<span class="p_del">-	return ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="p_add">+	arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	ret = ops-&gt;map(ops, iova, paddr, size, prot);</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static size_t arm_smmu_unmap(struct iommu_domain *domain, unsigned long iova,
 			     size_t size)
 {
 	struct io_pgtable_ops *ops = to_smmu_domain(domain)-&gt;pgtbl_ops;
<span class="p_add">+	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);</span>
<span class="p_add">+	struct arm_smmu_device *smmu = smmu_domain-&gt;smmu;</span>
<span class="p_add">+	size_t ret;</span>
 
 	if (!ops)
 		return 0;
 
<span class="p_del">-	return ops-&gt;unmap(ops, iova, size);</span>
<span class="p_add">+	arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	ret = ops-&gt;unmap(ops, iova, size);</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static void arm_smmu_iotlb_sync(struct iommu_domain *domain)
<span class="p_chunk">@@ -1407,14 +1450,22 @@</span> <span class="p_context"> static int arm_smmu_add_device(struct device *dev)</span>
 	while (i--)
 		cfg-&gt;smendx[i] = INVALID_SMENDX;
 
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		goto out_cfg_free;</span>
<span class="p_add">+</span>
 	ret = arm_smmu_master_alloc_smes(dev);
 	if (ret)
<span class="p_del">-		goto out_cfg_free;</span>
<span class="p_add">+		goto out_rpm_put;</span>
 
 	iommu_device_link(&amp;smmu-&gt;iommu, dev);
 
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
 	return 0;
 
<span class="p_add">+out_rpm_put:</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
 out_cfg_free:
 	kfree(cfg);
 out_free:
<span class="p_chunk">@@ -1427,7 +1478,7 @@</span> <span class="p_context"> static void arm_smmu_remove_device(struct device *dev)</span>
 	struct iommu_fwspec *fwspec = dev-&gt;iommu_fwspec;
 	struct arm_smmu_master_cfg *cfg;
 	struct arm_smmu_device *smmu;
<span class="p_del">-</span>
<span class="p_add">+	int ret;</span>
 
 	if (!fwspec || fwspec-&gt;ops != &amp;arm_smmu_ops)
 		return;
<span class="p_chunk">@@ -1435,8 +1486,15 @@</span> <span class="p_context"> static void arm_smmu_remove_device(struct device *dev)</span>
 	cfg  = fwspec-&gt;iommu_priv;
 	smmu = cfg-&gt;smmu;
 
<span class="p_add">+	ret = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	iommu_device_unlink(&amp;smmu-&gt;iommu, dev);
 	arm_smmu_master_free_smes(fwspec);
<span class="p_add">+</span>
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
 	iommu_group_remove_device(dev);
 	kfree(fwspec-&gt;iommu_priv);
 	iommu_fwspec_free(dev);
<span class="p_chunk">@@ -2124,6 +2182,8 @@</span> <span class="p_context"> static int arm_smmu_device_probe(struct platform_device *pdev)</span>
 		smmu-&gt;irqs[i] = irq;
 	}
 
<span class="p_add">+	platform_set_drvdata(pdev, smmu);</span>
<span class="p_add">+</span>
 	err = devm_clk_bulk_get(smmu-&gt;dev, smmu-&gt;num_clks, smmu-&gt;clks);
 	if (err)
 		return err;
<span class="p_chunk">@@ -2132,6 +2192,19 @@</span> <span class="p_context"> static int arm_smmu_device_probe(struct platform_device *pdev)</span>
 	if (err)
 		return err;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We want to avoid touching dev-&gt;power.lock in fastpaths unless</span>
<span class="p_add">+	 * it&#39;s really going to do something useful - pm_runtime_enabled()</span>
<span class="p_add">+	 * can serve as an ideal proxy for that decision. So, conditionally</span>
<span class="p_add">+	 * enable pm_runtime.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dev-&gt;pm_domain)</span>
<span class="p_add">+		pm_runtime_enable(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = arm_smmu_rpm_get(smmu);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	err = arm_smmu_device_cfg_probe(smmu);
 	if (err)
 		return err;
<span class="p_chunk">@@ -2173,10 +2246,11 @@</span> <span class="p_context"> static int arm_smmu_device_probe(struct platform_device *pdev)</span>
 		return err;
 	}
 
<span class="p_del">-	platform_set_drvdata(pdev, smmu);</span>
 	arm_smmu_device_reset(smmu);
 	arm_smmu_test_smr_masks(smmu);
 
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
 	/*
 	 * For ACPI and generic DT bindings, an SMMU will be probed before
 	 * any device which might need it, so we want the bus ops in place
<span class="p_chunk">@@ -2212,8 +2286,13 @@</span> <span class="p_context"> static int arm_smmu_device_remove(struct platform_device *pdev)</span>
 	if (!bitmap_empty(smmu-&gt;context_map, ARM_SMMU_MAX_CBS))
 		dev_err(&amp;pdev-&gt;dev, &quot;removing device with active domains!\n&quot;);
 
<span class="p_add">+	arm_smmu_rpm_get(smmu);</span>
 	/* Turn the thing off */
 	writel(sCR0_CLIENTPD, ARM_SMMU_GR0_NS(smmu) + ARM_SMMU_GR0_sCR0);
<span class="p_add">+	arm_smmu_rpm_put(smmu);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pm_runtime_enabled(smmu-&gt;dev))</span>
<span class="p_add">+		pm_runtime_disable(smmu-&gt;dev);</span>
 
 	clk_bulk_unprepare(smmu-&gt;num_clks, smmu-&gt;clks);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



