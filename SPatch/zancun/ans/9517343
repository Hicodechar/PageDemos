
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] x86 fixes - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] x86 fixes</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Jan. 15, 2017, 10:06 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170115100640.GA31959@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9517343/mbox/"
   >mbox</a>
|
   <a href="/patch/9517343/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9517343/">/patch/9517343/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	0EE73607D4 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 15 Jan 2017 10:06:53 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E3579228C9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 15 Jan 2017 10:06:52 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D7BE728472; Sun, 15 Jan 2017 10:06:52 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.3 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI, RCVD_IN_SORBS_SPAM,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 823E4228C9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 15 Jan 2017 10:06:51 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751069AbdAOKGs (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 15 Jan 2017 05:06:48 -0500
Received: from mail-wm0-f67.google.com ([74.125.82.67]:34008 &quot;EHLO
	mail-wm0-f67.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1750802AbdAOKGq (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 15 Jan 2017 05:06:46 -0500
Received: by mail-wm0-f67.google.com with SMTP id c85so22970444wmi.1
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Sun, 15 Jan 2017 02:06:45 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=GPipOc882xGiDuOS1SurK9PCHtaEbGcKZonZQ+nxUCQ=;
	b=XHHEMcMB2AMLGqzzD2+FlmkxZnJFLM4IX4djI3EEUdu6g6HPuvgkOo9xj6UUknFbcE
	YUYkVFgZuafD/GYQjTW27pSQJ8QI5ZsLwxLSTyWK764gE29Z9imf/QwmqFW4b8/XVu+q
	oolB+pkQjyfGkFYg+leJ2C5NVMVuvJGVwEE3MChej/rw/ShkiiOSQogmnaASfHLvqsC8
	iim//Q/oCn1dKBYXI4k+Ea66Gds/O+SVNWsPrEXfwhKWfVCt4IIln6M1tijTPBHVEtm0
	osUiEFIDAMcJbfN4yNG1iU5H+It+Xia7NHzq0w9cq7Nc3Ye9aYEUfCKo7Ytq1tMIK8EY
	66nw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=GPipOc882xGiDuOS1SurK9PCHtaEbGcKZonZQ+nxUCQ=;
	b=YRsSdpPeKhBWUT7kA6Cu+D28sc6tngKl0lOQjsAhcibCeEm29zL5OqKAdpSm2/ySym
	BVmHdrJT7EMijqN4Ah23eSrYZUAbWHT1Cb22zbLBJq4JcqieCWlDNxif/VeM5gV/Ma+4
	Qgntbw6A24YEAFY8WGMORCDvx9fhKrXdfZY9sMNNSK4Pg+/o03SEmFlJKJF0TJN0+tdV
	cquTSqNZ0aI98zusbp24KyG9RdM+D6qyOxpXBhsFRZyfZH7v0tVWVeGd/7lyyMBoYOWj
	B9W0q6niYMnqWMj2Tt5Kuo7GfHV0vWk5+Lz7ubor4WufbQy0cn0gYHrM621ETsy4qljh
	/cCw==
X-Gm-Message-State: AIkVDXKec2Y799vQqQtdXe4vl5hc25/YrqCjN8pE6jGKu9rGWJ1bokLKOXwP5+Eb7yrSzQ==
X-Received: by 10.28.30.79 with SMTP id e76mr7909969wme.96.1484474804642;
	Sun, 15 Jan 2017 02:06:44 -0800 (PST)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	o132sm19542845wmo.17.2017.01.15.02.06.42
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Sun, 15 Jan 2017 02:06:43 -0800 (PST)
Date: Sun, 15 Jan 2017 11:06:40 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;
Subject: [GIT PULL] x86 fixes
Message-ID: &lt;20170115100640.GA31959@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.24 (2015-08-30)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Jan. 15, 2017, 10:06 a.m.</div>
<pre class="content">
Linus,

Please pull the latest x86-urgent-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-urgent-for-linus

   # HEAD: 453828625731d0ba7218242ef6ec88f59408f368 x86/mpx: Use compatible types in comparison to fix sparse error

Misc fixes:

 - unwinder fixes
 - AMD CPU topology enumeration fixes
 - microcode loader fixes
 - x86 embedded platform fixes
 - fix for a bootup crash that may trigger when clearcpuid= is used with invalid values

 Thanks,

	Ingo

------------------&gt;
Andy Shevchenko (2):
      x86/cpu: Fix typo in the comment for Anniedale
      x86/platform/intel-mid: Rename &#39;spidev&#39; to &#39;mrfld_spidev&#39;

Borislav Petkov (4):
      x86/CPU/AMD: Fix Bulldozer topology
      x86/CPU: Add native CPUID variants returning a single datum
      x86/microcode: Use native CPUID to tickle out microcode revision
      x86/microcode/intel: Add a helper which gives the microcode revision

Josh Poimboeuf (4):
      x86/unwind: Silence warnings for non-current tasks
      x86/unwind: Disable KASAN checks for non-current tasks
      x86/unwind: Include __schedule() in stack traces
      x86/entry: Fix the end of the stack for newly forked tasks

Junichi Nomura (2):
      x86/microcode/intel: Fix allocation size of struct ucode_patch
      x86/microcode/intel: Use correct buffer size for saving microcode data

Len Brown (1):
      x86/tsc: Add the Intel Denverton Processor to native_calibrate_tsc()

Lukasz Odzioba (1):
      x86/cpu: Fix bootup crashes by sanitizing the argument of the &#39;clearcpuid=&#39; command-line option

Nicholas Mc Guire (1):
      x86/boot: Add missing declaration of string functions

Tobias Klauser (1):
      x86/mpx: Use compatible types in comparison to fix sparse error


 arch/x86/boot/string.c                             |  1 +
 arch/x86/boot/string.h                             |  9 +++
 arch/x86/entry/entry_32.S                          | 30 ++++------
 arch/x86/entry/entry_64.S                          | 11 ++--
 arch/x86/include/asm/intel-family.h                |  2 +-
 arch/x86/include/asm/microcode_intel.h             | 15 +++++
 arch/x86/include/asm/processor.h                   | 18 ++++++
 arch/x86/include/asm/stacktrace.h                  |  2 +-
 arch/x86/include/asm/switch_to.h                   | 10 +++-
 arch/x86/kernel/cpu/amd.c                          |  9 +--
 arch/x86/kernel/cpu/common.c                       |  2 +-
 arch/x86/kernel/cpu/intel.c                        | 11 +---
 arch/x86/kernel/cpu/microcode/intel.c              | 70 ++++++----------------
 arch/x86/kernel/tsc.c                              |  1 +
 arch/x86/kernel/unwind_frame.c                     | 30 +++++++++-
 arch/x86/mm/mpx.c                                  |  2 +-
 arch/x86/platform/intel-mid/device_libs/Makefile   |  2 +-
 .../{platform_spidev.c =&gt; platform_mrfld_spidev.c} |  4 ++
 18 files changed, 129 insertions(+), 100 deletions(-)
 rename arch/x86/platform/intel-mid/device_libs/{platform_spidev.c =&gt; platform_mrfld_spidev.c} (91%)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/arch/x86/boot/string.c b/arch/x86/boot/string.c</span>
<span class="p_header">index cc3bd583dce1..9e240fcba784 100644</span>
<span class="p_header">--- a/arch/x86/boot/string.c</span>
<span class="p_header">+++ b/arch/x86/boot/string.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/types.h&gt;
 #include &quot;ctype.h&quot;
<span class="p_add">+#include &quot;string.h&quot;</span>
 
 int memcmp(const void *s1, const void *s2, size_t len)
 {
<span class="p_header">diff --git a/arch/x86/boot/string.h b/arch/x86/boot/string.h</span>
<span class="p_header">index 725e820602b1..113588ddb43f 100644</span>
<span class="p_header">--- a/arch/x86/boot/string.h</span>
<span class="p_header">+++ b/arch/x86/boot/string.h</span>
<span class="p_chunk">@@ -18,4 +18,13 @@</span> <span class="p_context"> int memcmp(const void *s1, const void *s2, size_t len);</span>
 #define memset(d,c,l) __builtin_memset(d,c,l)
 #define memcmp	__builtin_memcmp
 
<span class="p_add">+extern int strcmp(const char *str1, const char *str2);</span>
<span class="p_add">+extern int strncmp(const char *cs, const char *ct, size_t count);</span>
<span class="p_add">+extern size_t strlen(const char *s);</span>
<span class="p_add">+extern char *strstr(const char *s1, const char *s2);</span>
<span class="p_add">+extern size_t strnlen(const char *s, size_t maxlen);</span>
<span class="p_add">+extern unsigned int atou(const char *s);</span>
<span class="p_add">+extern unsigned long long simple_strtoull(const char *cp, char **endp,</span>
<span class="p_add">+					  unsigned int base);</span>
<span class="p_add">+</span>
 #endif /* BOOT_STRING_H */
<span class="p_header">diff --git a/arch/x86/entry/entry_32.S b/arch/x86/entry/entry_32.S</span>
<span class="p_header">index 701d29f8e4d3..57f7ec35216e 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_32.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_32.S</span>
<span class="p_chunk">@@ -255,23 +255,6 @@</span> <span class="p_context"> ENTRY(__switch_to_asm)</span>
 END(__switch_to_asm)
 
 /*
<span class="p_del">- * The unwinder expects the last frame on the stack to always be at the same</span>
<span class="p_del">- * offset from the end of the page, which allows it to validate the stack.</span>
<span class="p_del">- * Calling schedule_tail() directly would break that convention because its an</span>
<span class="p_del">- * asmlinkage function so its argument has to be pushed on the stack.  This</span>
<span class="p_del">- * wrapper creates a proper &quot;end of stack&quot; frame header before the call.</span>
<span class="p_del">- */</span>
<span class="p_del">-ENTRY(schedule_tail_wrapper)</span>
<span class="p_del">-	FRAME_BEGIN</span>
<span class="p_del">-</span>
<span class="p_del">-	pushl	%eax</span>
<span class="p_del">-	call	schedule_tail</span>
<span class="p_del">-	popl	%eax</span>
<span class="p_del">-</span>
<span class="p_del">-	FRAME_END</span>
<span class="p_del">-	ret</span>
<span class="p_del">-ENDPROC(schedule_tail_wrapper)</span>
<span class="p_del">-/*</span>
  * A newly forked process directly context switches into this address.
  *
  * eax: prev task we switched from
<span class="p_chunk">@@ -279,15 +262,24 @@</span> <span class="p_context"> ENDPROC(schedule_tail_wrapper)</span>
  * edi: kernel thread arg
  */
 ENTRY(ret_from_fork)
<span class="p_del">-	call	schedule_tail_wrapper</span>
<span class="p_add">+	FRAME_BEGIN		/* help unwinder find end of stack */</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * schedule_tail() is asmlinkage so we have to put its &#39;prev&#39; argument</span>
<span class="p_add">+	 * on the stack.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	pushl	%eax</span>
<span class="p_add">+	call	schedule_tail</span>
<span class="p_add">+	popl	%eax</span>
 
 	testl	%ebx, %ebx
 	jnz	1f		/* kernel threads are uncommon */
 
 2:
 	/* When we fork, we trace the syscall return in the child, too. */
<span class="p_del">-	movl    %esp, %eax</span>
<span class="p_add">+	leal	FRAME_OFFSET(%esp), %eax</span>
 	call    syscall_return_slowpath
<span class="p_add">+	FRAME_END</span>
 	jmp     restore_all
 
 	/* kernel thread */
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index 5b219707c2f2..044d18ebc43c 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -36,6 +36,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/smap.h&gt;
 #include &lt;asm/pgtable_types.h&gt;
 #include &lt;asm/export.h&gt;
<span class="p_add">+#include &lt;asm/frame.h&gt;</span>
 #include &lt;linux/err.h&gt;
 
 .code64
<span class="p_chunk">@@ -408,17 +409,19 @@</span> <span class="p_context"> END(__switch_to_asm)</span>
  * r12: kernel thread arg
  */
 ENTRY(ret_from_fork)
<span class="p_add">+	FRAME_BEGIN			/* help unwinder find end of stack */</span>
 	movq	%rax, %rdi
<span class="p_del">-	call	schedule_tail			/* rdi: &#39;prev&#39; task parameter */</span>
<span class="p_add">+	call	schedule_tail		/* rdi: &#39;prev&#39; task parameter */</span>
 
<span class="p_del">-	testq	%rbx, %rbx			/* from kernel_thread? */</span>
<span class="p_del">-	jnz	1f				/* kernel threads are uncommon */</span>
<span class="p_add">+	testq	%rbx, %rbx		/* from kernel_thread? */</span>
<span class="p_add">+	jnz	1f			/* kernel threads are uncommon */</span>
 
 2:
<span class="p_del">-	movq	%rsp, %rdi</span>
<span class="p_add">+	leaq	FRAME_OFFSET(%rsp),%rdi	/* pt_regs pointer */</span>
 	call	syscall_return_slowpath	/* returns with IRQs disabled */
 	TRACE_IRQS_ON			/* user mode is traced as IRQS on */
 	SWAPGS
<span class="p_add">+	FRAME_END</span>
 	jmp	restore_regs_and_iret
 
 1:
<span class="p_header">diff --git a/arch/x86/include/asm/intel-family.h b/arch/x86/include/asm/intel-family.h</span>
<span class="p_header">index 34a46dc076d3..8167fdb67ae8 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/intel-family.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/intel-family.h</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"></span>
 #define INTEL_FAM6_ATOM_SILVERMONT2	0x4D /* Avaton/Rangely */
 #define INTEL_FAM6_ATOM_AIRMONT		0x4C /* CherryTrail / Braswell */
 #define INTEL_FAM6_ATOM_MERRIFIELD	0x4A /* Tangier */
<span class="p_del">-#define INTEL_FAM6_ATOM_MOOREFIELD	0x5A /* Annidale */</span>
<span class="p_add">+#define INTEL_FAM6_ATOM_MOOREFIELD	0x5A /* Anniedale */</span>
 #define INTEL_FAM6_ATOM_GOLDMONT	0x5C
 #define INTEL_FAM6_ATOM_DENVERTON	0x5F /* Goldmont Microserver */
 
<span class="p_header">diff --git a/arch/x86/include/asm/microcode_intel.h b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">index 195becc6f780..e793fc9a9b20 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_chunk">@@ -52,6 +52,21 @@</span> <span class="p_context"> struct extended_sigtable {</span>
 
 #define exttable_size(et) ((et)-&gt;count * EXT_SIGNATURE_SIZE + EXT_HEADER_SIZE)
 
<span class="p_add">+static inline u32 intel_get_microcode_revision(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 rev, dummy;</span>
<span class="p_add">+</span>
<span class="p_add">+	native_wrmsrl(MSR_IA32_UCODE_REV, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_add">+	native_cpuid_eax(1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get the current revision from MSR 0x8B */</span>
<span class="p_add">+	native_rdmsr(MSR_IA32_UCODE_REV, dummy, rev);</span>
<span class="p_add">+</span>
<span class="p_add">+	return rev;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_MICROCODE_INTEL
 extern void __init load_ucode_intel_bsp(void);
 extern void load_ucode_intel_ap(void);
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index eaf100508c36..1be64da0384e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -219,6 +219,24 @@</span> <span class="p_context"> static inline void native_cpuid(unsigned int *eax, unsigned int *ebx,</span>
 	    : &quot;memory&quot;);
 }
 
<span class="p_add">+#define native_cpuid_reg(reg)					\</span>
<span class="p_add">+static inline unsigned int native_cpuid_##reg(unsigned int op)	\</span>
<span class="p_add">+{								\</span>
<span class="p_add">+	unsigned int eax = op, ebx, ecx = 0, edx;		\</span>
<span class="p_add">+								\</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);			\</span>
<span class="p_add">+								\</span>
<span class="p_add">+	return reg;						\</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Native CPUID functions returning a single datum.</span>
<span class="p_add">+ */</span>
<span class="p_add">+native_cpuid_reg(eax)</span>
<span class="p_add">+native_cpuid_reg(ebx)</span>
<span class="p_add">+native_cpuid_reg(ecx)</span>
<span class="p_add">+native_cpuid_reg(edx)</span>
<span class="p_add">+</span>
 static inline void load_cr3(pgd_t *pgdir)
 {
 	write_cr3(__pa(pgdir));
<span class="p_header">diff --git a/arch/x86/include/asm/stacktrace.h b/arch/x86/include/asm/stacktrace.h</span>
<span class="p_header">index a3269c897ec5..2e41c50ddf47 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/stacktrace.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/stacktrace.h</span>
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> get_frame_pointer(struct task_struct *task, struct pt_regs *regs)</span>
 	if (task == current)
 		return __builtin_frame_address(0);
 
<span class="p_del">-	return (unsigned long *)((struct inactive_task_frame *)task-&gt;thread.sp)-&gt;bp;</span>
<span class="p_add">+	return &amp;((struct inactive_task_frame *)task-&gt;thread.sp)-&gt;bp;</span>
 }
 #else
 static inline unsigned long *
<span class="p_header">diff --git a/arch/x86/include/asm/switch_to.h b/arch/x86/include/asm/switch_to.h</span>
<span class="p_header">index 5cb436acd463..fcc5cd387fd1 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/switch_to.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/switch_to.h</span>
<span class="p_chunk">@@ -36,7 +36,10 @@</span> <span class="p_context"> static inline void prepare_switch_to(struct task_struct *prev,</span>
 
 asmlinkage void ret_from_fork(void);
 
<span class="p_del">-/* data that is pointed to by thread.sp */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This is the structure pointed to by thread.sp for an inactive task.  The</span>
<span class="p_add">+ * order of the fields must match the code in __switch_to_asm().</span>
<span class="p_add">+ */</span>
 struct inactive_task_frame {
 #ifdef CONFIG_X86_64
 	unsigned long r15;
<span class="p_chunk">@@ -48,6 +51,11 @@</span> <span class="p_context"> struct inactive_task_frame {</span>
 	unsigned long di;
 #endif
 	unsigned long bx;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * These two fields must be together.  They form a stack frame header,</span>
<span class="p_add">+	 * needed by get_frame_pointer().</span>
<span class="p_add">+	 */</span>
 	unsigned long bp;
 	unsigned long ret_addr;
 };
<span class="p_header">diff --git a/arch/x86/kernel/cpu/amd.c b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">index 71cae73a5076..1d3167269a67 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/amd.c</span>
<span class="p_chunk">@@ -309,15 +309,8 @@</span> <span class="p_context"> static void amd_get_topology(struct cpuinfo_x86 *c)</span>
 
 	/* get information required for multi-node processors */
 	if (boot_cpu_has(X86_FEATURE_TOPOEXT)) {
<span class="p_del">-		u32 eax, ebx, ecx, edx;</span>
 
<span class="p_del">-		cpuid(0x8000001e, &amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-		node_id = ecx &amp; 7;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* get compute unit information */</span>
<span class="p_del">-		smp_num_siblings = ((ebx &gt;&gt; 8) &amp; 3) + 1;</span>
<span class="p_del">-		c-&gt;x86_max_cores /= smp_num_siblings;</span>
<span class="p_del">-		c-&gt;cpu_core_id = ebx &amp; 0xff;</span>
<span class="p_add">+		node_id = cpuid_ecx(0x8000001e) &amp; 7;</span>
 
 		/*
 		 * We may have multiple LLCs if L3 caches exist, so check if we
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index dc1697ca5191..9bab7a8a4293 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -1221,7 +1221,7 @@</span> <span class="p_context"> static __init int setup_disablecpuid(char *arg)</span>
 {
 	int bit;
 
<span class="p_del">-	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &lt; NCAPINTS*32)</span>
<span class="p_add">+	if (get_option(&amp;arg, &amp;bit) &amp;&amp; bit &gt;= 0 &amp;&amp; bit &lt; NCAPINTS * 32)</span>
 		setup_clear_cpu_cap(bit);
 	else
 		return 0;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/intel.c b/arch/x86/kernel/cpu/intel.c</span>
<span class="p_header">index fcd484d2bb03..203f860d2ab3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/intel.c</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/bugs.h&gt;
 #include &lt;asm/cpu.h&gt;
 #include &lt;asm/intel-family.h&gt;
<span class="p_add">+#include &lt;asm/microcode_intel.h&gt;</span>
 
 #ifdef CONFIG_X86_64
 #include &lt;linux/topology.h&gt;
<span class="p_chunk">@@ -78,14 +79,8 @@</span> <span class="p_context"> static void early_init_intel(struct cpuinfo_x86 *c)</span>
 		(c-&gt;x86 == 0x6 &amp;&amp; c-&gt;x86_model &gt;= 0x0e))
 		set_cpu_cap(c, X86_FEATURE_CONSTANT_TSC);
 
<span class="p_del">-	if (c-&gt;x86 &gt;= 6 &amp;&amp; !cpu_has(c, X86_FEATURE_IA64)) {</span>
<span class="p_del">-		unsigned lower_word;</span>
<span class="p_del">-</span>
<span class="p_del">-		wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_del">-		/* Required by the SDM */</span>
<span class="p_del">-		sync_core();</span>
<span class="p_del">-		rdmsr(MSR_IA32_UCODE_REV, lower_word, c-&gt;microcode);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (c-&gt;x86 &gt;= 6 &amp;&amp; !cpu_has(c, X86_FEATURE_IA64))</span>
<span class="p_add">+		c-&gt;microcode = intel_get_microcode_revision();</span>
 
 	/*
 	 * Atom erratum AAE44/AAF40/AAG38/AAH41:
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index b624b54912e1..3f329b74e040 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -150,7 +150,7 @@</span> <span class="p_context"> static struct ucode_patch *__alloc_microcode_buf(void *data, unsigned int size)</span>
 {
 	struct ucode_patch *p;
 
<span class="p_del">-	p = kzalloc(size, GFP_KERNEL);</span>
<span class="p_add">+	p = kzalloc(sizeof(struct ucode_patch), GFP_KERNEL);</span>
 	if (!p)
 		return ERR_PTR(-ENOMEM);
 
<span class="p_chunk">@@ -368,26 +368,6 @@</span> <span class="p_context"> scan_microcode(void *data, size_t size, struct ucode_cpu_info *uci, bool save)</span>
 	return patch;
 }
 
<span class="p_del">-static void cpuid_1(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * According to the Intel SDM, Volume 3, 9.11.7:</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 *   CPUID returns a value in a model specific register in</span>
<span class="p_del">-	 *   addition to its usual register return values. The</span>
<span class="p_del">-	 *   semantics of CPUID cause it to deposit an update ID value</span>
<span class="p_del">-	 *   in the 64-bit model-specific register at address 08BH</span>
<span class="p_del">-	 *   (IA32_BIOS_SIGN_ID). If no update is present in the</span>
<span class="p_del">-	 *   processor, the value in the MSR remains unmodified.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * Use native_cpuid -- this code runs very early and we don&#39;t</span>
<span class="p_del">-	 * want to mess with paravirt.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	unsigned int eax = 1, ebx, ecx = 0, edx;</span>
<span class="p_del">-</span>
<span class="p_del">-	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int collect_cpu_info_early(struct ucode_cpu_info *uci)
 {
 	unsigned int val[2];
<span class="p_chunk">@@ -410,15 +390,8 @@</span> <span class="p_context"> static int collect_cpu_info_early(struct ucode_cpu_info *uci)</span>
 		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);
 		csig.pf = 1 &lt;&lt; ((val[1] &gt;&gt; 18) &amp; 7);
 	}
<span class="p_del">-	native_wrmsrl(MSR_IA32_UCODE_REV, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_del">-	cpuid_1();</span>
 
<span class="p_del">-	/* get the current revision from MSR 0x8B */</span>
<span class="p_del">-	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_del">-</span>
<span class="p_del">-	csig.rev = val[1];</span>
<span class="p_add">+	csig.rev = intel_get_microcode_revision();</span>
 
 	uci-&gt;cpu_sig = csig;
 	uci-&gt;valid = 1;
<span class="p_chunk">@@ -602,7 +575,7 @@</span> <span class="p_context"> static inline void print_ucode(struct ucode_cpu_info *uci)</span>
 static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)
 {
 	struct microcode_intel *mc;
<span class="p_del">-	unsigned int val[2];</span>
<span class="p_add">+	u32 rev;</span>
 
 	mc = uci-&gt;mc;
 	if (!mc)
<span class="p_chunk">@@ -610,21 +583,16 @@</span> <span class="p_context"> static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)</span>
 
 	/* write microcode via MSR 0x79 */
 	native_wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc-&gt;bits);
<span class="p_del">-	native_wrmsrl(MSR_IA32_UCODE_REV, 0);</span>
 
<span class="p_del">-	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_del">-	cpuid_1();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* get the current revision from MSR 0x8B */</span>
<span class="p_del">-	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_del">-	if (val[1] != mc-&gt;hdr.rev)</span>
<span class="p_add">+	rev = intel_get_microcode_revision();</span>
<span class="p_add">+	if (rev != mc-&gt;hdr.rev)</span>
 		return -1;
 
 #ifdef CONFIG_X86_64
 	/* Flush global tlb. This is precaution. */
 	flush_tlb_early();
 #endif
<span class="p_del">-	uci-&gt;cpu_sig.rev = val[1];</span>
<span class="p_add">+	uci-&gt;cpu_sig.rev = rev;</span>
 
 	if (early)
 		print_ucode(uci);
<span class="p_chunk">@@ -804,8 +772,8 @@</span> <span class="p_context"> static int apply_microcode_intel(int cpu)</span>
 	struct microcode_intel *mc;
 	struct ucode_cpu_info *uci;
 	struct cpuinfo_x86 *c;
<span class="p_del">-	unsigned int val[2];</span>
 	static int prev_rev;
<span class="p_add">+	u32 rev;</span>
 
 	/* We should bind the task to the CPU */
 	if (WARN_ON(raw_smp_processor_id() != cpu))
<span class="p_chunk">@@ -822,33 +790,28 @@</span> <span class="p_context"> static int apply_microcode_intel(int cpu)</span>
 
 	/* write microcode via MSR 0x79 */
 	wrmsrl(MSR_IA32_UCODE_WRITE, (unsigned long)mc-&gt;bits);
<span class="p_del">-	wrmsrl(MSR_IA32_UCODE_REV, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_del">-	cpuid_1();</span>
 
<span class="p_del">-	/* get the current revision from MSR 0x8B */</span>
<span class="p_del">-	rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_add">+	rev = intel_get_microcode_revision();</span>
 
<span class="p_del">-	if (val[1] != mc-&gt;hdr.rev) {</span>
<span class="p_add">+	if (rev != mc-&gt;hdr.rev) {</span>
 		pr_err(&quot;CPU%d update to revision 0x%x failed\n&quot;,
 		       cpu, mc-&gt;hdr.rev);
 		return -1;
 	}
 
<span class="p_del">-	if (val[1] != prev_rev) {</span>
<span class="p_add">+	if (rev != prev_rev) {</span>
 		pr_info(&quot;updated to revision 0x%x, date = %04x-%02x-%02x\n&quot;,
<span class="p_del">-			val[1],</span>
<span class="p_add">+			rev,</span>
 			mc-&gt;hdr.date &amp; 0xffff,
 			mc-&gt;hdr.date &gt;&gt; 24,
 			(mc-&gt;hdr.date &gt;&gt; 16) &amp; 0xff);
<span class="p_del">-		prev_rev = val[1];</span>
<span class="p_add">+		prev_rev = rev;</span>
 	}
 
 	c = &amp;cpu_data(cpu);
 
<span class="p_del">-	uci-&gt;cpu_sig.rev = val[1];</span>
<span class="p_del">-	c-&gt;microcode = val[1];</span>
<span class="p_add">+	uci-&gt;cpu_sig.rev = rev;</span>
<span class="p_add">+	c-&gt;microcode = rev;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -860,7 +823,7 @@</span> <span class="p_context"> static enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,</span>
 	u8 *ucode_ptr = data, *new_mc = NULL, *mc = NULL;
 	int new_rev = uci-&gt;cpu_sig.rev;
 	unsigned int leftover = size;
<span class="p_del">-	unsigned int curr_mc_size = 0;</span>
<span class="p_add">+	unsigned int curr_mc_size = 0, new_mc_size = 0;</span>
 	unsigned int csig, cpf;
 
 	while (leftover) {
<span class="p_chunk">@@ -901,6 +864,7 @@</span> <span class="p_context"> static enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,</span>
 			vfree(new_mc);
 			new_rev = mc_header.rev;
 			new_mc  = mc;
<span class="p_add">+			new_mc_size = mc_size;</span>
 			mc = NULL;	/* trigger new vmalloc */
 		}
 
<span class="p_chunk">@@ -926,7 +890,7 @@</span> <span class="p_context"> static enum ucode_state generic_load_microcode(int cpu, void *data, size_t size,</span>
 	 * permanent memory. So it will be loaded early when a CPU is hot added
 	 * or resumes.
 	 */
<span class="p_del">-	save_mc_for_early(new_mc, curr_mc_size);</span>
<span class="p_add">+	save_mc_for_early(new_mc, new_mc_size);</span>
 
 	pr_debug(&quot;CPU%d found a matching microcode update with version 0x%x (current=0x%x)\n&quot;,
 		 cpu, new_rev, uci-&gt;cpu_sig.rev);
<span class="p_header">diff --git a/arch/x86/kernel/tsc.c b/arch/x86/kernel/tsc.c</span>
<span class="p_header">index be3a49ee0356..e41af597aed8 100644</span>
<span class="p_header">--- a/arch/x86/kernel/tsc.c</span>
<span class="p_header">+++ b/arch/x86/kernel/tsc.c</span>
<span class="p_chunk">@@ -694,6 +694,7 @@</span> <span class="p_context"> unsigned long native_calibrate_tsc(void)</span>
 			crystal_khz = 24000;	/* 24.0 MHz */
 			break;
 		case INTEL_FAM6_SKYLAKE_X:
<span class="p_add">+		case INTEL_FAM6_ATOM_DENVERTON:</span>
 			crystal_khz = 25000;	/* 25.0 MHz */
 			break;
 		case INTEL_FAM6_ATOM_GOLDMONT:
<span class="p_header">diff --git a/arch/x86/kernel/unwind_frame.c b/arch/x86/kernel/unwind_frame.c</span>
<span class="p_header">index 4443e499f279..23d15565d02a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/unwind_frame.c</span>
<span class="p_header">+++ b/arch/x86/kernel/unwind_frame.c</span>
<span class="p_chunk">@@ -6,6 +6,21 @@</span> <span class="p_context"></span>
 
 #define FRAME_HEADER_SIZE (sizeof(long) * 2)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This disables KASAN checking when reading a value from another task&#39;s stack,</span>
<span class="p_add">+ * since the other task could be running on another CPU and could have poisoned</span>
<span class="p_add">+ * the stack in the meantime.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define READ_ONCE_TASK_STACK(task, x)			\</span>
<span class="p_add">+({							\</span>
<span class="p_add">+	unsigned long val;				\</span>
<span class="p_add">+	if (task == current)				\</span>
<span class="p_add">+		val = READ_ONCE(x);			\</span>
<span class="p_add">+	else						\</span>
<span class="p_add">+		val = READ_ONCE_NOCHECK(x);		\</span>
<span class="p_add">+	val;						\</span>
<span class="p_add">+})</span>
<span class="p_add">+</span>
 static void unwind_dump(struct unwind_state *state, unsigned long *sp)
 {
 	static bool dumped_before = false;
<span class="p_chunk">@@ -48,7 +63,8 @@</span> <span class="p_context"> unsigned long unwind_get_return_address(struct unwind_state *state)</span>
 	if (state-&gt;regs &amp;&amp; user_mode(state-&gt;regs))
 		return 0;
 
<span class="p_del">-	addr = ftrace_graph_ret_addr(state-&gt;task, &amp;state-&gt;graph_idx, *addr_p,</span>
<span class="p_add">+	addr = READ_ONCE_TASK_STACK(state-&gt;task, *addr_p);</span>
<span class="p_add">+	addr = ftrace_graph_ret_addr(state-&gt;task, &amp;state-&gt;graph_idx, addr,</span>
 				     addr_p);
 
 	return __kernel_text_address(addr) ? addr : 0;
<span class="p_chunk">@@ -162,7 +178,7 @@</span> <span class="p_context"> bool unwind_next_frame(struct unwind_state *state)</span>
 	if (state-&gt;regs)
 		next_bp = (unsigned long *)state-&gt;regs-&gt;bp;
 	else
<span class="p_del">-		next_bp = (unsigned long *)*state-&gt;bp;</span>
<span class="p_add">+		next_bp = (unsigned long *)READ_ONCE_TASK_STACK(state-&gt;task,*state-&gt;bp);</span>
 
 	/* is the next frame pointer an encoded pointer to pt_regs? */
 	regs = decode_frame_pointer(next_bp);
<span class="p_chunk">@@ -207,6 +223,16 @@</span> <span class="p_context"> bool unwind_next_frame(struct unwind_state *state)</span>
 	return true;
 
 bad_address:
<span class="p_add">+	/*</span>
<span class="p_add">+	 * When unwinding a non-current task, the task might actually be</span>
<span class="p_add">+	 * running on another CPU, in which case it could be modifying its</span>
<span class="p_add">+	 * stack while we&#39;re reading it.  This is generally not a problem and</span>
<span class="p_add">+	 * can be ignored as long as the caller understands that unwinding</span>
<span class="p_add">+	 * another task will not always succeed.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (state-&gt;task != current)</span>
<span class="p_add">+		goto the_end;</span>
<span class="p_add">+</span>
 	if (state-&gt;regs) {
 		printk_deferred_once(KERN_WARNING
 			&quot;WARNING: kernel stack regs at %p in %s:%d has bad &#39;bp&#39; value %p\n&quot;,
<span class="p_header">diff --git a/arch/x86/mm/mpx.c b/arch/x86/mm/mpx.c</span>
<span class="p_header">index 324e5713d386..af59f808742f 100644</span>
<span class="p_header">--- a/arch/x86/mm/mpx.c</span>
<span class="p_header">+++ b/arch/x86/mm/mpx.c</span>
<span class="p_chunk">@@ -293,7 +293,7 @@</span> <span class="p_context"> siginfo_t *mpx_generate_siginfo(struct pt_regs *regs)</span>
 	 * We were not able to extract an address from the instruction,
 	 * probably because there was something invalid in it.
 	 */
<span class="p_del">-	if (info-&gt;si_addr == (void *)-1) {</span>
<span class="p_add">+	if (info-&gt;si_addr == (void __user *)-1) {</span>
 		err = -EINVAL;
 		goto err_out;
 	}
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/Makefile b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">index 61b5ed2b7d40..90e4f2a6625b 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/Makefile</span>
<span class="p_chunk">@@ -15,7 +15,7 @@</span> <span class="p_context"> obj-$(subst m,y,$(CONFIG_INTEL_MID_POWER_BUTTON)) += platform_msic_power_btn.o</span>
 obj-$(subst m,y,$(CONFIG_GPIO_INTEL_PMIC)) += platform_pmic_gpio.o
 obj-$(subst m,y,$(CONFIG_INTEL_MFLD_THERMAL)) += platform_msic_thermal.o
 # SPI Devices
<span class="p_del">-obj-$(subst m,y,$(CONFIG_SPI_SPIDEV)) += platform_spidev.o</span>
<span class="p_add">+obj-$(subst m,y,$(CONFIG_SPI_SPIDEV)) += platform_mrfld_spidev.o</span>
 # I2C Devices
 obj-$(subst m,y,$(CONFIG_SENSORS_EMC1403)) += platform_emc1403.o
 obj-$(subst m,y,$(CONFIG_SENSORS_LIS3LV02D)) += platform_lis331.o
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_spidev.c</span>
similarity index 91%
rename from arch/x86/platform/intel-mid/device_libs/platform_spidev.c
rename to arch/x86/platform/intel-mid/device_libs/platform_mrfld_spidev.c
<span class="p_header">index 30c601b399ee..27186ad654c9 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/device_libs/platform_spidev.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/device_libs/platform_mrfld_spidev.c</span>
<span class="p_chunk">@@ -11,6 +11,7 @@</span> <span class="p_context"></span>
  * of the License.
  */
 
<span class="p_add">+#include &lt;linux/err.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/sfi.h&gt;
 #include &lt;linux/spi/pxa2xx_spi.h&gt;
<span class="p_chunk">@@ -34,6 +35,9 @@</span> <span class="p_context"> static void __init *spidev_platform_data(void *info)</span>
 {
 	struct spi_board_info *spi_info = info;
 
<span class="p_add">+	if (intel_mid_identify_cpu() != INTEL_MID_CPU_CHIP_TANGIER)</span>
<span class="p_add">+		return ERR_PTR(-ENODEV);</span>
<span class="p_add">+</span>
 	spi_info-&gt;mode = SPI_MODE_0;
 	spi_info-&gt;controller_data = &amp;spidev_spi_chip;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



