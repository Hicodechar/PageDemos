
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[2/4] perf, tools, stat: Abstract stat metrics printing - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [2/4] perf, tools, stat: Abstract stat metrics printing</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=104">Andi Kleen</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>July 30, 2015, 12:21 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1438215700-5530-3-git-send-email-andi@firstfloor.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6896811/mbox/"
   >mbox</a>
|
   <a href="/patch/6896811/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6896811/">/patch/6896811/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 6B0FF9F38B
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jul 2015 00:22:31 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id D81152051D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jul 2015 00:22:29 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id E43542052D
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 30 Jul 2015 00:22:27 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1754422AbbG3AVq (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 29 Jul 2015 20:21:46 -0400
Received: from mga14.intel.com ([192.55.52.115]:60830 &quot;EHLO mga14.intel.com&quot;
	rhost-flags-OK-OK-OK-OK) by vger.kernel.org with ESMTP
	id S1754376AbbG3AVp (ORCPT &lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 29 Jul 2015 20:21:45 -0400
Received: from fmsmga003.fm.intel.com ([10.253.24.29])
	by fmsmga103.fm.intel.com with ESMTP; 29 Jul 2015 17:21:43 -0700
X-ExtLoop1: 1
X-IronPort-AV: E=Sophos;i=&quot;5.15,573,1432623600&quot;; d=&quot;scan&#39;208&quot;;a=&quot;532627731&quot;
Received: from tassilo.jf.intel.com (HELO tassilo.localdomain)
	([10.7.201.36])
	by FMSMGA003.fm.intel.com with ESMTP; 29 Jul 2015 17:21:43 -0700
Received: by tassilo.localdomain (Postfix, from userid 1000)
	id 0ECCC302695; Wed, 29 Jul 2015 17:21:43 -0700 (PDT)
From: Andi Kleen &lt;andi@firstfloor.org&gt;
To: acme@kernel.org
Cc: jolsa@kernel.org, eranian@google.com, linux-kernel@vger.kernel.org,
	Andi Kleen &lt;ak@linux.intel.com&gt;
Subject: [PATCH 2/4] perf, tools, stat: Abstract stat metrics printing
Date: Wed, 29 Jul 2015 17:21:38 -0700
Message-Id: &lt;1438215700-5530-3-git-send-email-andi@firstfloor.org&gt;
X-Mailer: git-send-email 2.4.3
In-Reply-To: &lt;1438215700-5530-1-git-send-email-andi@firstfloor.org&gt;
References: &lt;1438215700-5530-1-git-send-email-andi@firstfloor.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=104">Andi Kleen</a> - July 30, 2015, 12:21 a.m.</div>
<pre class="content">
<span class="from">From: Andi Kleen &lt;ak@linux.intel.com&gt;</span>

Abstract the printing of shadow metrics. Instead of every
metric calling fprintf directly and taking care of indentation,
use two call backs: one to print metrics and another to
start a new line.

This will allow adding metrics to CSV mode and also
using them for other purposes.

The computation of padding is now done in the central
callback, instead of every metric doing it manually.
This makes it easier to add new metrics.

Right now there is no (intentional) behavior change, just refactoring.
<span class="signed-off-by">
Signed-off-by: Andi Kleen &lt;ak@linux.intel.com&gt;</span>
---
 tools/perf/builtin-stat.c     |  98 +++++++++++++++++++--------
 tools/perf/util/stat-shadow.c | 154 ++++++++++++++++++++++--------------------
 tools/perf/util/stat.h        |  10 ++-
 3 files changed, 160 insertions(+), 102 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - July 30, 2015, 1:42 p.m.</div>
<pre class="content">
On Wed, Jul 29, 2015 at 05:21:38PM -0700, Andi Kleen wrote:

SNIP
<span class="quote">
&gt; +static void nsec_printout(int id, int nr, struct perf_evsel *evsel, double avg,</span>
<span class="quote">&gt; +			  void *ctx, print_metric_t print_metric)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	double msecs = avg / 1e6;</span>
<span class="quote">&gt;  	const char *fmt_v, *fmt_n;</span>
<span class="quote">&gt; @@ -647,13 +689,16 @@ static void nsec_printout(int id, int nr, struct perf_evsel *evsel, double avg)</span>
<span class="quote">&gt;  		return;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (perf_evsel__match(evsel, SOFTWARE, SW_TASK_CLOCK))</span>
<span class="quote">&gt; -		fprintf(output, &quot; # %8.3f CPUs utilized          &quot;,</span>
<span class="quote">&gt; -			avg / avg_stats(&amp;walltime_nsecs_stats));</span>
<span class="quote">&gt; +		print_metric(ctx, NULL, &quot;%8.3f&quot;, &quot;CPUs utilized&quot;,</span>
<span class="quote">&gt; +			     avg / avg_stats(&amp;walltime_nsecs_stats));</span>
<span class="quote">&gt;  	else</span>
<span class="quote">&gt; -		fprintf(output, &quot;                                   &quot;);</span>
<span class="quote">&gt; +		print_metric(ctx, NULL, NULL, NULL, 0);</span>
<span class="quote">&gt;  }</span>

hum, this should go to perf_stat__print_shadow_stats,
could you please move it there before this patch?

thanks,
jirka
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - July 30, 2015, 1:47 p.m.</div>
<pre class="content">
On Wed, Jul 29, 2015 at 05:21:38PM -0700, Andi Kleen wrote:
<span class="quote">&gt; From: Andi Kleen &lt;ak@linux.intel.com&gt;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Abstract the printing of shadow metrics. Instead of every</span>
<span class="quote">&gt; metric calling fprintf directly and taking care of indentation,</span>
<span class="quote">&gt; use two call backs: one to print metrics and another to</span>
<span class="quote">&gt; start a new line.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This will allow adding metrics to CSV mode and also</span>
<span class="quote">&gt; using them for other purposes.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The computation of padding is now done in the central</span>
<span class="quote">&gt; callback, instead of every metric doing it manually.</span>
<span class="quote">&gt; This makes it easier to add new metrics.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Right now there is no (intentional) behavior change, just refactoring.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Signed-off-by: Andi Kleen &lt;ak@linux.intel.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  tools/perf/builtin-stat.c     |  98 +++++++++++++++++++--------</span>
<span class="quote">&gt;  tools/perf/util/stat-shadow.c | 154 ++++++++++++++++++++++--------------------</span>
<span class="quote">&gt;  tools/perf/util/stat.h        |  10 ++-</span>
<span class="quote">&gt;  3 files changed, 160 insertions(+), 102 deletions(-)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c</span>
<span class="quote">&gt; index d99d850..e6386f1 100644</span>
<span class="quote">&gt; --- a/tools/perf/builtin-stat.c</span>
<span class="quote">&gt; +++ b/tools/perf/builtin-stat.c</span>
<span class="quote">&gt; @@ -617,7 +617,49 @@ static void aggr_printout(struct perf_evsel *evsel, int id, int nr)</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -static void nsec_printout(int id, int nr, struct perf_evsel *evsel, double avg)</span>
<span class="quote">&gt; +struct outstate {</span>
<span class="quote">&gt; +	FILE *fh;</span>
<span class="quote">&gt; +};</span>


because we already need to make the print_metric callback global,
would it be better to make this struct global, having all the
needed callbacks defined within? something like:

typedef void (*perf_stat_output_metric_t)(void *ctx, const char *color, const char *unit,
					  const char *fmt, double val);

typedef void (*perf_stat_output_newln_t)(void *ctx);

struct perf_stat_output_ctx {
	FILE			  *output
	perf_stat_output_metric_t  metric;
	perf_stat_output_newln_t   nl;
};

not sure about the naming, but IMO should have some perf_sta_.. global form

it&#39;d also ease the new arguments count from 3 to 1

jirka
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=104">Andi Kleen</a> - Aug. 4, 2015, 12:41 a.m.</div>
<pre class="content">
<span class="quote">&gt; </span>
<span class="quote">&gt; because we already need to make the print_metric callback global,</span>
<span class="quote">&gt; would it be better to make this struct global, having all the</span>
<span class="quote">&gt; needed callbacks defined within? something like:</span>

It&#39;s actually not global, but static.

I skipped this change. After some other changes there is only
a single function call with these arguments left, so it&#39;s not 
an issue to pass it around.

-Andi
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=2522">Jiri Olsa</a> - Aug. 8, 2015, 5:40 p.m.</div>
<pre class="content">
On Tue, Aug 04, 2015 at 02:41:11AM +0200, Andi Kleen wrote:
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; because we already need to make the print_metric callback global,</span>
<span class="quote">&gt; &gt; would it be better to make this struct global, having all the</span>
<span class="quote">&gt; &gt; needed callbacks defined within? something like:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; It&#39;s actually not global, but static.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I skipped this change. After some other changes there is only</span>
<span class="quote">&gt; a single function call with these arguments left, so it&#39;s not </span>
<span class="quote">&gt; an issue to pass it around.</span>

hum, I dont understand.. I can se the same code in the new version:


+typedef void (*print_metric_t)(void *ctx, const char *color, const char *unit,
+                              const char *fmt, double val);
+
 void perf_stat__reset_shadow_stats(void);
 void perf_stat__update_shadow_stats(struct perf_evsel *counter, u64 *count,
                                    int cpu);
-void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,
-                                  double avg, int cpu, enum aggr_mode aggr);
+void perf_stat__print_shadow_stats(struct perf_evsel *evsel,
+                                  double avg, int cpu,
+                                  print_metric_t print_metric,
+                                  void (*new_line)(void *ctx),
+                                  void *ctx);


both:

print_metric_t print_metric
void (*new_line)(void *ctx)

are still there.. what single function call did you mean?

jirka
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/tools/perf/builtin-stat.c b/tools/perf/builtin-stat.c</span>
<span class="p_header">index d99d850..e6386f1 100644</span>
<span class="p_header">--- a/tools/perf/builtin-stat.c</span>
<span class="p_header">+++ b/tools/perf/builtin-stat.c</span>
<span class="p_chunk">@@ -617,7 +617,49 @@</span> <span class="p_context"> static void aggr_printout(struct perf_evsel *evsel, int id, int nr)</span>
 	}
 }
 
<span class="p_del">-static void nsec_printout(int id, int nr, struct perf_evsel *evsel, double avg)</span>
<span class="p_add">+struct outstate {</span>
<span class="p_add">+	FILE *fh;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define BASE_INDENT 41</span>
<span class="p_add">+#define AGGR_INDENT  8</span>
<span class="p_add">+#define METRIC_LEN  35</span>
<span class="p_add">+#define NA_INDENT   16</span>
<span class="p_add">+</span>
<span class="p_add">+static void new_line_no_aggr_std(void *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct outstate *os = ctx;</span>
<span class="p_add">+	fprintf(os-&gt;fh, &quot;\n%*s&quot;, BASE_INDENT + NA_INDENT, &quot;&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void new_line_std(void *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct outstate *os = ctx;</span>
<span class="p_add">+	fprintf(os-&gt;fh, &quot;\n%-*s&quot;, BASE_INDENT + AGGR_INDENT, &quot;&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void print_metric_std(void *ctx, const char *color, const char *fmt,</span>
<span class="p_add">+			     const char *unit, double val)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct outstate *os = ctx;</span>
<span class="p_add">+	FILE *out = os-&gt;fh;</span>
<span class="p_add">+	int n;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (unit == NULL) {</span>
<span class="p_add">+		fprintf(out, &quot;%-*s&quot;, METRIC_LEN, &quot;&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	n = fprintf(out, &quot; # &quot;);</span>
<span class="p_add">+	if (color)</span>
<span class="p_add">+		n += color_fprintf(out, color, fmt, val);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		n += fprintf(out, fmt, val);</span>
<span class="p_add">+	fprintf(out, &quot; %-*s&quot;, METRIC_LEN - n - 1, unit);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void nsec_printout(int id, int nr, struct perf_evsel *evsel, double avg,</span>
<span class="p_add">+			  void *ctx, print_metric_t print_metric)</span>
 {
 	double msecs = avg / 1e6;
 	const char *fmt_v, *fmt_n;
<span class="p_chunk">@@ -647,13 +689,16 @@</span> <span class="p_context"> static void nsec_printout(int id, int nr, struct perf_evsel *evsel, double avg)</span>
 		return;
 
 	if (perf_evsel__match(evsel, SOFTWARE, SW_TASK_CLOCK))
<span class="p_del">-		fprintf(output, &quot; # %8.3f CPUs utilized          &quot;,</span>
<span class="p_del">-			avg / avg_stats(&amp;walltime_nsecs_stats));</span>
<span class="p_add">+		print_metric(ctx, NULL, &quot;%8.3f&quot;, &quot;CPUs utilized&quot;,</span>
<span class="p_add">+			     avg / avg_stats(&amp;walltime_nsecs_stats));</span>
 	else
<span class="p_del">-		fprintf(output, &quot;                                   &quot;);</span>
<span class="p_add">+		print_metric(ctx, NULL, NULL, NULL, 0);</span>
 }
 
<span class="p_del">-static void abs_printout(int id, int nr, struct perf_evsel *evsel, double avg)</span>
<span class="p_add">+static void abs_printout(int id, int nr, struct perf_evsel *evsel, double avg,</span>
<span class="p_add">+			 void *ctx,</span>
<span class="p_add">+			 print_metric_t print_metric,</span>
<span class="p_add">+			 void (*new_line)(void *))</span>
 {
 	double sc =  evsel-&gt;scale;
 	const char *fmt;
<span class="p_chunk">@@ -688,7 +733,23 @@</span> <span class="p_context"> static void abs_printout(int id, int nr, struct perf_evsel *evsel, double avg)</span>
 	if (csv_output || interval)
 		return;
 
<span class="p_del">-	perf_stat__print_shadow_stats(output, evsel, avg, cpu, aggr_mode);</span>
<span class="p_add">+	perf_stat__print_shadow_stats(evsel, avg, cpu,</span>
<span class="p_add">+				      print_metric,</span>
<span class="p_add">+				      new_line,</span>
<span class="p_add">+				      ctx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void printout(int id, int nr, struct perf_evsel *counter, double uval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct outstate os = { .fh = output };</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nsec_counter(counter))</span>
<span class="p_add">+		nsec_printout(id, nr, counter, uval, &amp;os, print_metric_std);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		abs_printout(id, nr, counter, uval, &amp;os,</span>
<span class="p_add">+			     print_metric_std,</span>
<span class="p_add">+			     aggr_mode == AGGR_NONE ?</span>
<span class="p_add">+			     new_line_no_aggr_std : new_line_std);</span>
 }
 
 static void print_aggr(char *prefix)
<span class="p_chunk">@@ -744,12 +805,7 @@</span> <span class="p_context"> static void print_aggr(char *prefix)</span>
 				continue;
 			}
 			uval = val * counter-&gt;scale;
<span class="p_del">-</span>
<span class="p_del">-			if (nsec_counter(counter))</span>
<span class="p_del">-				nsec_printout(id, nr, counter, uval);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				abs_printout(id, nr, counter, uval);</span>
<span class="p_del">-</span>
<span class="p_add">+			printout(id, nr, counter, uval);</span>
 			if (!csv_output)
 				print_noise(counter, 1.0);
 
<span class="p_chunk">@@ -779,11 +835,7 @@</span> <span class="p_context"> static void print_aggr_thread(struct perf_evsel *counter, char *prefix)</span>
 			fprintf(output, &quot;%s&quot;, prefix);
 
 		uval = val * counter-&gt;scale;
<span class="p_del">-</span>
<span class="p_del">-		if (nsec_counter(counter))</span>
<span class="p_del">-			nsec_printout(thread, 0, counter, uval);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			abs_printout(thread, 0, counter, uval);</span>
<span class="p_add">+		printout(thread, 0, counter, uval);</span>
 
 		if (!csv_output)
 			print_noise(counter, 1.0);
<span class="p_chunk">@@ -832,11 +884,7 @@</span> <span class="p_context"> static void print_counter_aggr(struct perf_evsel *counter, char *prefix)</span>
 	}
 
 	uval = avg * counter-&gt;scale;
<span class="p_del">-</span>
<span class="p_del">-	if (nsec_counter(counter))</span>
<span class="p_del">-		nsec_printout(-1, 0, counter, uval);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		abs_printout(-1, 0, counter, uval);</span>
<span class="p_add">+	printout(-1, 0, counter, uval);</span>
 
 	print_noise(counter, avg);
 
<span class="p_chunk">@@ -888,11 +936,7 @@</span> <span class="p_context"> static void print_counter(struct perf_evsel *counter, char *prefix)</span>
 		}
 
 		uval = val * counter-&gt;scale;
<span class="p_del">-</span>
<span class="p_del">-		if (nsec_counter(counter))</span>
<span class="p_del">-			nsec_printout(cpu, 0, counter, uval);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			abs_printout(cpu, 0, counter, uval);</span>
<span class="p_add">+		printout(cpu, 0, counter, uval);</span>
 
 		if (!csv_output)
 			print_noise(counter, 1.0);
<span class="p_header">diff --git a/tools/perf/util/stat-shadow.c b/tools/perf/util/stat-shadow.c</span>
<span class="p_header">index 53e8bb7..5abd444 100644</span>
<span class="p_header">--- a/tools/perf/util/stat-shadow.c</span>
<span class="p_header">+++ b/tools/perf/util/stat-shadow.c</span>
<span class="p_chunk">@@ -137,9 +137,11 @@</span> <span class="p_context"> static const char *get_ratio_color(enum grc_type type, double ratio)</span>
 	return color;
 }
 
<span class="p_del">-static void print_stalled_cycles_frontend(FILE *out, int cpu,</span>
<span class="p_add">+static void print_stalled_cycles_frontend(int cpu,</span>
 					  struct perf_evsel *evsel
<span class="p_del">-					  __maybe_unused, double avg)</span>
<span class="p_add">+					  __maybe_unused, double avg,</span>
<span class="p_add">+					  print_metric_t print_metric,</span>
<span class="p_add">+					  void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -152,14 +154,14 @@</span> <span class="p_context"> static void print_stalled_cycles_frontend(FILE *out, int cpu,</span>
 
 	color = get_ratio_color(GRC_STALLED_CYCLES_FE, ratio);
 
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; frontend cycles idle   &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;frontend cycles idle&quot;, ratio);</span>
 }
 
<span class="p_del">-static void print_stalled_cycles_backend(FILE *out, int cpu,</span>
<span class="p_add">+static void print_stalled_cycles_backend(int cpu,</span>
 					 struct perf_evsel *evsel
<span class="p_del">-					 __maybe_unused, double avg)</span>
<span class="p_add">+					 __maybe_unused, double avg,</span>
<span class="p_add">+					 print_metric_t print_metric,</span>
<span class="p_add">+					 void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -172,14 +174,14 @@</span> <span class="p_context"> static void print_stalled_cycles_backend(FILE *out, int cpu,</span>
 
 	color = get_ratio_color(GRC_STALLED_CYCLES_BE, ratio);
 
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; backend  cycles idle   &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%6.2f%%&quot;, &quot;backend cycles idle&quot;, ratio);</span>
 }
 
<span class="p_del">-static void print_branch_misses(FILE *out, int cpu,</span>
<span class="p_add">+static void print_branch_misses(int cpu,</span>
 				struct perf_evsel *evsel __maybe_unused,
<span class="p_del">-				double avg)</span>
<span class="p_add">+				double avg,</span>
<span class="p_add">+				print_metric_t print_metric,</span>
<span class="p_add">+				void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -192,14 +194,14 @@</span> <span class="p_context"> static void print_branch_misses(FILE *out, int cpu,</span>
 
 	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
 
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; of all branches        &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;of all branches&quot;, ratio);</span>
 }
 
<span class="p_del">-static void print_l1_dcache_misses(FILE *out, int cpu,</span>
<span class="p_add">+static void print_l1_dcache_misses(int cpu,</span>
 				   struct perf_evsel *evsel __maybe_unused,
<span class="p_del">-				   double avg)</span>
<span class="p_add">+				   double avg,</span>
<span class="p_add">+				   print_metric_t print_metric,</span>
<span class="p_add">+				   void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -212,14 +214,14 @@</span> <span class="p_context"> static void print_l1_dcache_misses(FILE *out, int cpu,</span>
 
 	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
 
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; of all L1-dcache hits  &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;of all L1-dcache hits&quot;, ratio);</span>
 }
 
<span class="p_del">-static void print_l1_icache_misses(FILE *out, int cpu,</span>
<span class="p_add">+static void print_l1_icache_misses(int cpu,</span>
 				   struct perf_evsel *evsel __maybe_unused,
<span class="p_del">-				   double avg)</span>
<span class="p_add">+				   double avg,</span>
<span class="p_add">+				   print_metric_t print_metric,</span>
<span class="p_add">+				   void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -231,15 +233,14 @@</span> <span class="p_context"> static void print_l1_icache_misses(FILE *out, int cpu,</span>
 		ratio = avg / total * 100.0;
 
 	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
<span class="p_del">-</span>
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; of all L1-icache hits  &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;of all L1-icache hits&quot;, ratio);</span>
 }
 
<span class="p_del">-static void print_dtlb_cache_misses(FILE *out, int cpu,</span>
<span class="p_add">+static void print_dtlb_cache_misses(int cpu,</span>
 				    struct perf_evsel *evsel __maybe_unused,
<span class="p_del">-				    double avg)</span>
<span class="p_add">+				    double avg,</span>
<span class="p_add">+				    print_metric_t print_metric,</span>
<span class="p_add">+				    void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -251,15 +252,14 @@</span> <span class="p_context"> static void print_dtlb_cache_misses(FILE *out, int cpu,</span>
 		ratio = avg / total * 100.0;
 
 	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
<span class="p_del">-</span>
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; of all dTLB cache hits &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;of all dTLB cache hits&quot;, ratio);</span>
 }
 
<span class="p_del">-static void print_itlb_cache_misses(FILE *out, int cpu,</span>
<span class="p_add">+static void print_itlb_cache_misses(int cpu,</span>
 				    struct perf_evsel *evsel __maybe_unused,
<span class="p_del">-				    double avg)</span>
<span class="p_add">+				    double avg,</span>
<span class="p_add">+				    print_metric_t print_metric,</span>
<span class="p_add">+				    void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -271,15 +271,14 @@</span> <span class="p_context"> static void print_itlb_cache_misses(FILE *out, int cpu,</span>
 		ratio = avg / total * 100.0;
 
 	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
<span class="p_del">-</span>
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; of all iTLB cache hits &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;of all iTLB cache hits&quot;, ratio);</span>
 }
 
<span class="p_del">-static void print_ll_cache_misses(FILE *out, int cpu,</span>
<span class="p_add">+static void print_ll_cache_misses(int cpu,</span>
 				  struct perf_evsel *evsel __maybe_unused,
<span class="p_del">-				  double avg)</span>
<span class="p_add">+				  double avg,</span>
<span class="p_add">+				  print_metric_t print_metric,</span>
<span class="p_add">+				  void *ctxp)</span>
 {
 	double total, ratio = 0.0;
 	const char *color;
<span class="p_chunk">@@ -291,14 +290,14 @@</span> <span class="p_context"> static void print_ll_cache_misses(FILE *out, int cpu,</span>
 		ratio = avg / total * 100.0;
 
 	color = get_ratio_color(GRC_CACHE_MISSES, ratio);
<span class="p_del">-</span>
<span class="p_del">-	fprintf(out, &quot; #  &quot;);</span>
<span class="p_del">-	color_fprintf(out, color, &quot;%6.2f%%&quot;, ratio);</span>
<span class="p_del">-	fprintf(out, &quot; of all LL-cache hits   &quot;);</span>
<span class="p_add">+	print_metric(ctxp, color, &quot;%7.2f%%&quot;, &quot;of all LL-cache hits&quot;, ratio);</span>
 }
 
<span class="p_del">-void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,</span>
<span class="p_del">-				   double avg, int cpu, enum aggr_mode aggr)</span>
<span class="p_add">+void perf_stat__print_shadow_stats(struct perf_evsel *evsel,</span>
<span class="p_add">+				   double avg, int cpu,</span>
<span class="p_add">+				   print_metric_t print_metric,</span>
<span class="p_add">+				   void (*new_line)(void *ctx),</span>
<span class="p_add">+				   void *ctxp)</span>
 {
 	double total, ratio = 0.0, total2;
 	int ctx = evsel_context(evsel);
<span class="p_chunk">@@ -307,59 +306,60 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,</span>
 		total = avg_stats(&amp;runtime_cycles_stats[ctx][cpu]);
 		if (total) {
 			ratio = avg / total;
<span class="p_del">-			fprintf(out, &quot; #   %5.2f  insns per cycle        &quot;, ratio);</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%7.2f &quot;,</span>
<span class="p_add">+					&quot;insn per cycle&quot;, ratio);</span>
 		} else {
<span class="p_del">-			fprintf(out, &quot;                                   &quot;);</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
 		}
 		total = avg_stats(&amp;runtime_stalled_cycles_front_stats[ctx][cpu]);
 		total = max(total, avg_stats(&amp;runtime_stalled_cycles_back_stats[ctx][cpu]));
 
 		if (total &amp;&amp; avg) {
 			ratio = total / avg;
<span class="p_del">-			fprintf(out, &quot;\n&quot;);</span>
<span class="p_del">-			if (aggr == AGGR_NONE)</span>
<span class="p_del">-				fprintf(out, &quot;        &quot;);</span>
<span class="p_del">-			fprintf(out, &quot;                                                  #   %5.2f  stalled cycles per insn&quot;, ratio);</span>
<span class="p_add">+			new_line(ctxp);</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%7.2f &quot;,</span>
<span class="p_add">+					&quot;stalled cycles per insn&quot;,</span>
<span class="p_add">+					ratio);</span>
 		}
 
 	} else if (perf_evsel__match(evsel, HARDWARE, HW_BRANCH_MISSES) &amp;&amp;
 			runtime_branches_stats[ctx][cpu].n != 0) {
<span class="p_del">-		print_branch_misses(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_branch_misses(cpu, evsel, avg, print_metric, ctxp);</span>
 	} else if (
 		evsel-&gt;attr.type == PERF_TYPE_HW_CACHE &amp;&amp;
 		evsel-&gt;attr.config ==  ( PERF_COUNT_HW_CACHE_L1D |
 					((PERF_COUNT_HW_CACHE_OP_READ) &lt;&lt; 8) |
 					((PERF_COUNT_HW_CACHE_RESULT_MISS) &lt;&lt; 16)) &amp;&amp;
 			runtime_l1_dcache_stats[ctx][cpu].n != 0) {
<span class="p_del">-		print_l1_dcache_misses(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_l1_dcache_misses(cpu, evsel, avg, print_metric, ctxp);</span>
 	} else if (
 		evsel-&gt;attr.type == PERF_TYPE_HW_CACHE &amp;&amp;
 		evsel-&gt;attr.config ==  ( PERF_COUNT_HW_CACHE_L1I |
 					((PERF_COUNT_HW_CACHE_OP_READ) &lt;&lt; 8) |
 					((PERF_COUNT_HW_CACHE_RESULT_MISS) &lt;&lt; 16)) &amp;&amp;
 			runtime_l1_icache_stats[ctx][cpu].n != 0) {
<span class="p_del">-		print_l1_icache_misses(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_l1_icache_misses(cpu, evsel, avg, print_metric, ctxp);</span>
 	} else if (
 		evsel-&gt;attr.type == PERF_TYPE_HW_CACHE &amp;&amp;
 		evsel-&gt;attr.config ==  ( PERF_COUNT_HW_CACHE_DTLB |
 					((PERF_COUNT_HW_CACHE_OP_READ) &lt;&lt; 8) |
 					((PERF_COUNT_HW_CACHE_RESULT_MISS) &lt;&lt; 16)) &amp;&amp;
 			runtime_dtlb_cache_stats[ctx][cpu].n != 0) {
<span class="p_del">-		print_dtlb_cache_misses(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_dtlb_cache_misses(cpu, evsel, avg, print_metric, ctxp);</span>
 	} else if (
 		evsel-&gt;attr.type == PERF_TYPE_HW_CACHE &amp;&amp;
 		evsel-&gt;attr.config ==  ( PERF_COUNT_HW_CACHE_ITLB |
 					((PERF_COUNT_HW_CACHE_OP_READ) &lt;&lt; 8) |
 					((PERF_COUNT_HW_CACHE_RESULT_MISS) &lt;&lt; 16)) &amp;&amp;
 			runtime_itlb_cache_stats[ctx][cpu].n != 0) {
<span class="p_del">-		print_itlb_cache_misses(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_itlb_cache_misses(cpu, evsel, avg, print_metric, ctxp);</span>
 	} else if (
 		evsel-&gt;attr.type == PERF_TYPE_HW_CACHE &amp;&amp;
 		evsel-&gt;attr.config ==  ( PERF_COUNT_HW_CACHE_LL |
 					((PERF_COUNT_HW_CACHE_OP_READ) &lt;&lt; 8) |
 					((PERF_COUNT_HW_CACHE_RESULT_MISS) &lt;&lt; 16)) &amp;&amp;
 			runtime_ll_cache_stats[ctx][cpu].n != 0) {
<span class="p_del">-		print_ll_cache_misses(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_ll_cache_misses(cpu, evsel, avg, print_metric, ctxp);</span>
 	} else if (perf_evsel__match(evsel, HARDWARE, HW_CACHE_MISSES) &amp;&amp;
 			runtime_cacherefs_stats[ctx][cpu].n != 0) {
 		total = avg_stats(&amp;runtime_cacherefs_stats[ctx][cpu]);
<span class="p_chunk">@@ -367,36 +367,41 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,</span>
 		if (total)
 			ratio = avg * 100 / total;
 
<span class="p_del">-		fprintf(out, &quot; # %8.3f %% of all cache refs    &quot;, ratio);</span>
<span class="p_del">-</span>
<span class="p_add">+		print_metric(ctxp, NULL, &quot;%8.3f %%&quot;,</span>
<span class="p_add">+				&quot;of all cache refs&quot;, ratio);</span>
 	} else if (perf_evsel__match(evsel, HARDWARE, HW_STALLED_CYCLES_FRONTEND)) {
<span class="p_del">-		print_stalled_cycles_frontend(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_stalled_cycles_frontend(cpu, evsel, avg, print_metric,</span>
<span class="p_add">+				ctxp);</span>
 	} else if (perf_evsel__match(evsel, HARDWARE, HW_STALLED_CYCLES_BACKEND)) {
<span class="p_del">-		print_stalled_cycles_backend(out, cpu, evsel, avg);</span>
<span class="p_add">+		print_stalled_cycles_backend(cpu, evsel, avg, print_metric,</span>
<span class="p_add">+				ctxp);</span>
 	} else if (perf_evsel__match(evsel, HARDWARE, HW_CPU_CYCLES)) {
 		total = avg_stats(&amp;runtime_nsecs_stats[cpu]);
 
 		if (total) {
 			ratio = avg / total;
<span class="p_del">-			fprintf(out, &quot; # %8.3f GHz                    &quot;, ratio);</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%8.3f&quot;, &quot;GHz&quot;, ratio);</span>
 		} else {
<span class="p_del">-			fprintf(out, &quot;                                   &quot;);</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
 		}
 	} else if (perf_stat_evsel__is(evsel, CYCLES_IN_TX)) {
 		total = avg_stats(&amp;runtime_cycles_stats[ctx][cpu]);
 		if (total)
<span class="p_del">-			fprintf(out,</span>
<span class="p_del">-				&quot; #   %5.2f%% transactional cycles   &quot;,</span>
<span class="p_del">-				100.0 * (avg / total));</span>
<span class="p_add">+			print_metric(ctxp, NULL,</span>
<span class="p_add">+					&quot;%7.2f%%&quot;, &quot;transactional cycles&quot;,</span>
<span class="p_add">+					100.0 * (avg / total));</span>
<span class="p_add">+		else</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
 	} else if (perf_stat_evsel__is(evsel, CYCLES_IN_TX_CP)) {
 		total = avg_stats(&amp;runtime_cycles_stats[ctx][cpu]);
 		total2 = avg_stats(&amp;runtime_cycles_in_tx_stats[ctx][cpu]);
 		if (total2 &lt; avg)
 			total2 = avg;
 		if (total)
<span class="p_del">-			fprintf(out,</span>
<span class="p_del">-				&quot; #   %5.2f%% aborted cycles         &quot;,</span>
<span class="p_add">+			print_metric(ctxp, NULL, &quot;%7.2f%%&quot;, &quot;aborted cycles&quot;,</span>
 				100.0 * ((total2-avg) / total));
<span class="p_add">+		else</span>
<span class="p_add">+			print_metric(ctxp, NULL, NULL, NULL, 0);</span>
 	} else if (perf_stat_evsel__is(evsel, TRANSACTION_START) &amp;&amp;
 		   avg &gt; 0 &amp;&amp;
 		   runtime_cycles_in_tx_stats[ctx][cpu].n != 0) {
<span class="p_chunk">@@ -405,7 +410,8 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,</span>
 		if (total)
 			ratio = total / avg;
 
<span class="p_del">-		fprintf(out, &quot; # %8.0f cycles / transaction   &quot;, ratio);</span>
<span class="p_add">+		print_metric(ctxp, NULL, &quot;%8.0f&quot;,</span>
<span class="p_add">+				&quot;cycles / transaction&quot;, ratio);</span>
 	} else if (perf_stat_evsel__is(evsel, ELISION_START) &amp;&amp;
 		   avg &gt; 0 &amp;&amp;
 		   runtime_cycles_in_tx_stats[ctx][cpu].n != 0) {
<span class="p_chunk">@@ -414,9 +420,10 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,</span>
 		if (total)
 			ratio = total / avg;
 
<span class="p_del">-		fprintf(out, &quot; # %8.0f cycles / elision       &quot;, ratio);</span>
<span class="p_add">+		print_metric(ctxp, NULL, &quot;%8.0f&quot;, &quot;cycles / elision&quot;, ratio);</span>
 	} else if (runtime_nsecs_stats[cpu].n != 0) {
 		char unit = &#39;M&#39;;
<span class="p_add">+		char unit_buf[10];</span>
 
 		total = avg_stats(&amp;runtime_nsecs_stats[cpu]);
 
<span class="p_chunk">@@ -427,8 +434,9 @@</span> <span class="p_context"> void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,</span>
 			unit = &#39;K&#39;;
 		}
 
<span class="p_del">-		fprintf(out, &quot; # %8.3f %c/sec                  &quot;, ratio, unit);</span>
<span class="p_add">+		snprintf(unit_buf, sizeof(unit_buf), &quot;%c/sec&quot;, unit);</span>
<span class="p_add">+		print_metric(ctxp, NULL, &quot;%8.3f&quot;, unit_buf, ratio);</span>
 	} else {
<span class="p_del">-		fprintf(out, &quot;                                   &quot;);</span>
<span class="p_add">+		print_metric(ctxp, NULL, NULL, NULL, 0);</span>
 	}
 }
<span class="p_header">diff --git a/tools/perf/util/stat.h b/tools/perf/util/stat.h</span>
<span class="p_header">index 1cfbe0a..152322d 100644</span>
<span class="p_header">--- a/tools/perf/util/stat.h</span>
<span class="p_header">+++ b/tools/perf/util/stat.h</span>
<span class="p_chunk">@@ -83,11 +83,17 @@</span> <span class="p_context"> void perf_stat_evsel_id_init(struct perf_evsel *evsel);</span>
 
 extern struct stats walltime_nsecs_stats;
 
<span class="p_add">+typedef void (*print_metric_t)(void *ctx, const char *color, const char *unit,</span>
<span class="p_add">+			       const char *fmt, double val);</span>
<span class="p_add">+</span>
 void perf_stat__reset_shadow_stats(void);
 void perf_stat__update_shadow_stats(struct perf_evsel *counter, u64 *count,
 				    int cpu);
<span class="p_del">-void perf_stat__print_shadow_stats(FILE *out, struct perf_evsel *evsel,</span>
<span class="p_del">-				   double avg, int cpu, enum aggr_mode aggr);</span>
<span class="p_add">+void perf_stat__print_shadow_stats(struct perf_evsel *evsel,</span>
<span class="p_add">+				   double avg, int cpu,</span>
<span class="p_add">+				   print_metric_t print_metric,</span>
<span class="p_add">+				   void (*new_line)(void *ctx),</span>
<span class="p_add">+				   void *ctx);</span>
 
 struct perf_counts *perf_counts__new(int ncpus, int nthreads);
 void perf_counts__delete(struct perf_counts *counts);

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



