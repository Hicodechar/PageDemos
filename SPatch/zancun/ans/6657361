
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[3.19.y-ckt,stable] Linux 3.19.8-ckt2 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [3.19.y-ckt,stable] Linux 3.19.8-ckt2</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 22, 2015, 5:46 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;1434995177-30837-2-git-send-email-kamal@canonical.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/6657361/mbox/"
   >mbox</a>
|
   <a href="/patch/6657361/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/6657361/">/patch/6657361/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork1.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork1.web.kernel.org (Postfix) with ESMTP id 360C39F3A0
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 22 Jun 2015 17:47:23 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 4A065205FA
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 22 Jun 2015 17:47:14 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 0DA7620602
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 22 Jun 2015 17:47:00 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753400AbbFVRqs (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 22 Jun 2015 13:46:48 -0400
Received: from youngberry.canonical.com ([91.189.89.112]:35751 &quot;EHLO
	youngberry.canonical.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751896AbbFVRqX (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 22 Jun 2015 13:46:23 -0400
Received: from [10.172.68.52] (helo=fourier)
	by youngberry.canonical.com with esmtpsa
	(TLS1.0:DHE_RSA_AES_128_CBC_SHA1:16) (Exim 4.76)
	(envelope-from &lt;kamal@canonical.com&gt;)
	id 1Z75nY-0006t3-RN; Mon, 22 Jun 2015 17:46:21 +0000
Received: from kamal by fourier with local (Exim 4.82)
	(envelope-from &lt;kamal@whence.com&gt;)
	id 1Z75nW-00081z-KV; Mon, 22 Jun 2015 10:46:18 -0700
From: Kamal Mostafa &lt;kamal@canonical.com&gt;
To: linux-kernel@vger.kernel.org, stable@vger.kernel.org,
	kernel-team@lists.ubuntu.com
Cc: lwn@lwn.net
Subject: Re: [3.19.y-ckt stable] Linux 3.19.8-ckt2
Date: Mon, 22 Jun 2015 10:46:17 -0700
Message-Id: &lt;1434995177-30837-2-git-send-email-kamal@canonical.com&gt;
X-Mailer: git-send-email 1.9.1
In-Reply-To: &lt;1434995177-30837-1-git-send-email-kamal@canonical.com&gt;
References: &lt;1434995177-30837-1-git-send-email-kamal@canonical.com&gt;
X-Extended-Stable: 3.19
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-8.3 required=5.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RP_MATCHES_RCVD,
	UNPARSEABLE_RELAY autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=7718">Kamal Mostafa</a> - June 22, 2015, 5:46 p.m.</div>
<pre class="content">
--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/serial/tty.txt b/Documentation/serial/tty.txt</span>
<span class="p_header">index 1e52d67..dbe6623 100644</span>
<span class="p_header">--- a/Documentation/serial/tty.txt</span>
<span class="p_header">+++ b/Documentation/serial/tty.txt</span>
<span class="p_chunk">@@ -198,6 +198,9 @@</span> <span class="p_context"> TTY_IO_ERROR		If set, causes all subsequent userspace read/write</span>
 
 TTY_OTHER_CLOSED	Device is a pty and the other side has closed.
 
<span class="p_add">+TTY_OTHER_DONE		Device is a pty and the other side has closed and</span>
<span class="p_add">+			all pending input processing has been completed.</span>
<span class="p_add">+</span>
 TTY_NO_WRITE_SPLIT	Prevent driver from splitting up writes into
 			smaller chunks.
 
<span class="p_header">diff --git a/Documentation/virtual/kvm/mmu.txt b/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_header">index 53838d9..c59bd9b 100644</span>
<span class="p_header">--- a/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_header">+++ b/Documentation/virtual/kvm/mmu.txt</span>
<span class="p_chunk">@@ -169,6 +169,10 @@</span> <span class="p_context"> Shadow pages contain the following information:</span>
     Contains the value of cr4.smep &amp;&amp; !cr0.wp for which the page is valid
     (pages for which this is true are different from other pages; see the
     treatment of cr0.wp=0 below).
<span class="p_add">+  role.smap_andnot_wp:</span>
<span class="p_add">+    Contains the value of cr4.smap &amp;&amp; !cr0.wp for which the page is valid</span>
<span class="p_add">+    (pages for which this is true are different from other pages; see the</span>
<span class="p_add">+    treatment of cr0.wp=0 below).</span>
   gfn:
     Either the guest page table containing the translations shadowed by this
     page, or the base page frame for linear translations.  See role.direct.
<span class="p_chunk">@@ -344,10 +348,16 @@</span> <span class="p_context"> on fault type:</span>
 
 (user write faults generate a #PF)
 
<span class="p_del">-In the first case there is an additional complication if CR4.SMEP is</span>
<span class="p_del">-enabled: since we&#39;ve turned the page into a kernel page, the kernel may now</span>
<span class="p_del">-execute it.  We handle this by also setting spte.nx.  If we get a user</span>
<span class="p_del">-fetch or read fault, we&#39;ll change spte.u=1 and spte.nx=gpte.nx back.</span>
<span class="p_add">+In the first case there are two additional complications:</span>
<span class="p_add">+- if CR4.SMEP is enabled: since we&#39;ve turned the page into a kernel page,</span>
<span class="p_add">+  the kernel may now execute it.  We handle this by also setting spte.nx.</span>
<span class="p_add">+  If we get a user fetch or read fault, we&#39;ll change spte.u=1 and</span>
<span class="p_add">+  spte.nx=gpte.nx back.</span>
<span class="p_add">+- if CR4.SMAP is disabled: since the page has been changed to a kernel</span>
<span class="p_add">+  page, it can not be reused when CR4.SMAP is enabled. We set</span>
<span class="p_add">+  CR4.SMAP &amp;&amp; !CR0.WP into shadow page&#39;s role to avoid this case. Note,</span>
<span class="p_add">+  here we do not care the case that CR4.SMAP is enabled since KVM will</span>
<span class="p_add">+  directly inject #PF to guest due to failed permission check.</span>
 
 To prevent an spte that was converted into a kernel page with cr0.wp=0
 from being written by the kernel after cr0.wp has changed to 1, we make
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 8723390b6..32d76f2 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,7 +1,7 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 19
 SUBLEVEL = 8
<span class="p_del">-EXTRAVERSION = -ckt1</span>
<span class="p_add">+EXTRAVERSION = -ckt2</span>
 NAME = Sedated Swine
 
 # *DOCUMENTATION*
<span class="p_header">diff --git a/arch/arc/include/asm/atomic.h b/arch/arc/include/asm/atomic.h</span>
<span class="p_header">index 067551b..9917a45 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/atomic.h</span>
<span class="p_chunk">@@ -99,7 +99,7 @@</span> <span class="p_context"> static inline void atomic_##op(int i, atomic_t *v)			\</span>
 	atomic_ops_unlock(flags);					\
 }
 
<span class="p_del">-#define ATOMIC_OP_RETURN(op, c_op)					\</span>
<span class="p_add">+#define ATOMIC_OP_RETURN(op, c_op, asm_op)				\</span>
 static inline int atomic_##op##_return(int i, atomic_t *v)		\
 {									\
 	unsigned long flags;						\
<span class="p_header">diff --git a/arch/arm/net/bpf_jit_32.c b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">index e1268f9..e0e2358 100644</span>
<span class="p_header">--- a/arch/arm/net/bpf_jit_32.c</span>
<span class="p_header">+++ b/arch/arm/net/bpf_jit_32.c</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"></span>
 #define SEEN_DATA		(1 &lt;&lt; (BPF_MEMWORDS + 3))
 
 #define FLAG_NEED_X_RESET	(1 &lt;&lt; 0)
<span class="p_add">+#define FLAG_IMM_OVERFLOW	(1 &lt;&lt; 1)</span>
 
 struct jit_ctx {
 	const struct bpf_prog *skf;
<span class="p_chunk">@@ -293,6 +294,15 @@</span> <span class="p_context"> static u16 imm_offset(u32 k, struct jit_ctx *ctx)</span>
 	/* PC in ARM mode == address of the instruction + 8 */
 	imm = offset - (8 + ctx-&gt;idx * 4);
 
<span class="p_add">+	if (imm &amp; ~0xfff) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * literal pool is too far, signal it into flags. we</span>
<span class="p_add">+		 * can only detect it on the second pass unfortunately.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ctx-&gt;flags |= FLAG_IMM_OVERFLOW;</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return imm;
 }
 
<span class="p_chunk">@@ -449,10 +459,21 @@</span> <span class="p_context"> static inline void emit_udiv(u8 rd, u8 rm, u8 rn, struct jit_ctx *ctx)</span>
 		return;
 	}
 #endif
<span class="p_del">-	if (rm != ARM_R0)</span>
<span class="p_del">-		emit(ARM_MOV_R(ARM_R0, rm), ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For BPF_ALU | BPF_DIV | BPF_K instructions, rm is ARM_R4</span>
<span class="p_add">+	 * (r_A) and rn is ARM_R0 (r_scratch) so load rn first into</span>
<span class="p_add">+	 * ARM_R1 to avoid accidentally overwriting ARM_R0 with rm</span>
<span class="p_add">+	 * before using it as a source for ARM_R1.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For BPF_ALU | BPF_DIV | BPF_X rm is ARM_R4 (r_A) and rn is</span>
<span class="p_add">+	 * ARM_R5 (r_X) so there is no particular register overlap</span>
<span class="p_add">+	 * issues.</span>
<span class="p_add">+	 */</span>
 	if (rn != ARM_R1)
 		emit(ARM_MOV_R(ARM_R1, rn), ctx);
<span class="p_add">+	if (rm != ARM_R0)</span>
<span class="p_add">+		emit(ARM_MOV_R(ARM_R0, rm), ctx);</span>
 
 	ctx-&gt;seen |= SEEN_CALL;
 	emit_mov_i(ARM_R3, (u32)jit_udiv, ctx);
<span class="p_chunk">@@ -855,6 +876,14 @@</span> <span class="p_context"> b_epilogue:</span>
 		default:
 			return -1;
 		}
<span class="p_add">+</span>
<span class="p_add">+		if (ctx-&gt;flags &amp; FLAG_IMM_OVERFLOW)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * this instruction generated an overflow when</span>
<span class="p_add">+			 * trying to access the literal pool, so</span>
<span class="p_add">+			 * delegate this filter to the kernel interpreter.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			return -1;</span>
 	}
 
 	/* compute offsets only during the first pass */
<span class="p_chunk">@@ -917,7 +946,14 @@</span> <span class="p_context"> void bpf_jit_compile(struct bpf_prog *fp)</span>
 	ctx.idx = 0;
 
 	build_prologue(&amp;ctx);
<span class="p_del">-	build_body(&amp;ctx);</span>
<span class="p_add">+	if (build_body(&amp;ctx) &lt; 0) {</span>
<span class="p_add">+#if __LINUX_ARM_ARCH__ &lt; 7</span>
<span class="p_add">+		if (ctx.imm_count)</span>
<span class="p_add">+			kfree(ctx.imms);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		bpf_jit_binary_free(header);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 	build_epilogue(&amp;ctx);
 
 	flush_icache_range((u32)ctx.target, (u32)(ctx.target + ctx.idx));
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit_comp.c b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">index edba042..dc6a484 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -487,7 +487,7 @@</span> <span class="p_context"> emit_cond_jmp:</span>
 			return -EINVAL;
 		}
 
<span class="p_del">-		imm64 = (u64)insn1.imm &lt;&lt; 32 | imm;</span>
<span class="p_add">+		imm64 = (u64)insn1.imm &lt;&lt; 32 | (u32)imm;</span>
 		emit_a64_mov_i64(dst, imm64, ctx);
 
 		return 1;
<span class="p_header">diff --git a/arch/parisc/include/asm/elf.h b/arch/parisc/include/asm/elf.h</span>
<span class="p_header">index 3391d06..78c9fd3 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/elf.h</span>
<span class="p_chunk">@@ -348,6 +348,10 @@</span> <span class="p_context"> struct pt_regs;	/* forward declaration... */</span>
 
 #define ELF_HWCAP	0
 
<span class="p_add">+#define STACK_RND_MASK	(is_32bit_task() ? \</span>
<span class="p_add">+				0x7ff &gt;&gt; (PAGE_SHIFT - 12) : \</span>
<span class="p_add">+				0x3ffff &gt;&gt; (PAGE_SHIFT - 12))</span>
<span class="p_add">+</span>
 struct mm_struct;
 extern unsigned long arch_randomize_brk(struct mm_struct *);
 #define arch_randomize_brk arch_randomize_brk
<span class="p_header">diff --git a/arch/parisc/kernel/sys_parisc.c b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">index e1ffea2..5aba01a 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/sys_parisc.c</span>
<span class="p_chunk">@@ -77,6 +77,9 @@</span> <span class="p_context"> static unsigned long mmap_upper_limit(void)</span>
 	if (stack_base &gt; STACK_SIZE_MAX)
 		stack_base = STACK_SIZE_MAX;
 
<span class="p_add">+	/* Add space for stack randomization. */</span>
<span class="p_add">+	stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
 	return PAGE_ALIGN(STACK_TOP - stack_base);
 }
 
<span class="p_header">diff --git a/arch/powerpc/kernel/mce.c b/arch/powerpc/kernel/mce.c</span>
<span class="p_header">index 15c99b6..b2eb468 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/mce.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/mce.c</span>
<span class="p_chunk">@@ -73,7 +73,7 @@</span> <span class="p_context"> void save_mce_event(struct pt_regs *regs, long handled,</span>
 		    uint64_t nip, uint64_t addr)
 {
 	uint64_t srr1;
<span class="p_del">-	int index = __this_cpu_inc_return(mce_nest_count);</span>
<span class="p_add">+	int index = __this_cpu_inc_return(mce_nest_count) - 1;</span>
 	struct machine_check_event *mce = this_cpu_ptr(&amp;mce_event[index]);
 
 	/*
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> void machine_check_queue_event(void)</span>
 	if (!get_mce_event(&amp;evt, MCE_EVENT_RELEASE))
 		return;
 
<span class="p_del">-	index = __this_cpu_inc_return(mce_queue_count);</span>
<span class="p_add">+	index = __this_cpu_inc_return(mce_queue_count) - 1;</span>
 	/* If queue is full, just return for now. */
 	if (index &gt;= MAX_MC_EVT) {
 		__this_cpu_dec(mce_queue_count);
<span class="p_header">diff --git a/arch/powerpc/kernel/vmlinux.lds.S b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">index f096e72..1db6851 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -213,6 +213,7 @@</span> <span class="p_context"> SECTIONS</span>
 		*(.opd)
 	}
 
<span class="p_add">+	. = ALIGN(256);</span>
 	.got : AT(ADDR(.got) - LOAD_OFFSET) {
 		__toc_start = .;
 #ifndef CONFIG_RELOCATABLE
<span class="p_header">diff --git a/arch/s390/crypto/ghash_s390.c b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">index 7940dc9..b258110 100644</span>
<span class="p_header">--- a/arch/s390/crypto/ghash_s390.c</span>
<span class="p_header">+++ b/arch/s390/crypto/ghash_s390.c</span>
<span class="p_chunk">@@ -16,11 +16,12 @@</span> <span class="p_context"></span>
 #define GHASH_DIGEST_SIZE	16
 
 struct ghash_ctx {
<span class="p_del">-	u8 icv[16];</span>
<span class="p_del">-	u8 key[16];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 };
 
 struct ghash_desc_ctx {
<span class="p_add">+	u8 icv[GHASH_BLOCK_SIZE];</span>
<span class="p_add">+	u8 key[GHASH_BLOCK_SIZE];</span>
 	u8 buffer[GHASH_BLOCK_SIZE];
 	u32 bytes;
 };
<span class="p_chunk">@@ -28,8 +29,10 @@</span> <span class="p_context"> struct ghash_desc_ctx {</span>
 static int ghash_init(struct shash_desc *desc)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_add">+	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 
 	memset(dctx, 0, sizeof(*dctx));
<span class="p_add">+	memcpy(dctx-&gt;key, ctx-&gt;key, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -45,7 +48,6 @@</span> <span class="p_context"> static int ghash_setkey(struct crypto_shash *tfm,</span>
 	}
 
 	memcpy(ctx-&gt;key, key, GHASH_BLOCK_SIZE);
<span class="p_del">-	memset(ctx-&gt;icv, 0, GHASH_BLOCK_SIZE);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -54,7 +56,6 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 			 const u8 *src, unsigned int srclen)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	unsigned int n;
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -70,7 +71,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 		src += n;
 
 		if (!dctx-&gt;bytes) {
<span class="p_del">-			ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf,</span>
<span class="p_add">+			ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf,</span>
 					      GHASH_BLOCK_SIZE);
 			if (ret != GHASH_BLOCK_SIZE)
 				return -EIO;
<span class="p_chunk">@@ -79,7 +80,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 
 	n = srclen &amp; ~(GHASH_BLOCK_SIZE - 1);
 	if (n) {
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, src, n);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, src, n);</span>
 		if (ret != n)
 			return -EIO;
 		src += n;
<span class="p_chunk">@@ -94,7 +95,7 @@</span> <span class="p_context"> static int ghash_update(struct shash_desc *desc,</span>
 	return 0;
 }
 
<span class="p_del">-static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
<span class="p_add">+static int ghash_flush(struct ghash_desc_ctx *dctx)</span>
 {
 	u8 *buf = dctx-&gt;buffer;
 	int ret;
<span class="p_chunk">@@ -104,24 +105,24 @@</span> <span class="p_context"> static int ghash_flush(struct ghash_ctx *ctx, struct ghash_desc_ctx *dctx)</span>
 
 		memset(pos, 0, dctx-&gt;bytes);
 
<span class="p_del">-		ret = crypt_s390_kimd(KIMD_GHASH, ctx, buf, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		ret = crypt_s390_kimd(KIMD_GHASH, dctx, buf, GHASH_BLOCK_SIZE);</span>
 		if (ret != GHASH_BLOCK_SIZE)
 			return -EIO;
<span class="p_add">+</span>
<span class="p_add">+		dctx-&gt;bytes = 0;</span>
 	}
 
<span class="p_del">-	dctx-&gt;bytes = 0;</span>
 	return 0;
 }
 
 static int ghash_final(struct shash_desc *desc, u8 *dst)
 {
 	struct ghash_desc_ctx *dctx = shash_desc_ctx(desc);
<span class="p_del">-	struct ghash_ctx *ctx = crypto_shash_ctx(desc-&gt;tfm);</span>
 	int ret;
 
<span class="p_del">-	ret = ghash_flush(ctx, dctx);</span>
<span class="p_add">+	ret = ghash_flush(dctx);</span>
 	if (!ret)
<span class="p_del">-		memcpy(dst, ctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
<span class="p_add">+		memcpy(dst, dctx-&gt;icv, GHASH_BLOCK_SIZE);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/s390/include/asm/pgtable.h b/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">index 5e102422..3883ee2 100644</span>
<span class="p_header">--- a/arch/s390/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/s390/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -599,7 +599,7 @@</span> <span class="p_context"> static inline int pmd_large(pmd_t pmd)</span>
 	return (pmd_val(pmd) &amp; _SEGMENT_ENTRY_LARGE) != 0;
 }
 
<span class="p_del">-static inline int pmd_pfn(pmd_t pmd)</span>
<span class="p_add">+static inline unsigned long pmd_pfn(pmd_t pmd)</span>
 {
 	unsigned long origin_mask;
 
<span class="p_header">diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">index d89c6b8..3a67d76 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -202,6 +202,7 @@</span> <span class="p_context"> union kvm_mmu_page_role {</span>
 		unsigned nxe:1;
 		unsigned cr0_wp:1;
 		unsigned smep_andnot_wp:1;
<span class="p_add">+		unsigned smap_andnot_wp:1;</span>
 	};
 };
 
<span class="p_chunk">@@ -394,6 +395,7 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	struct kvm_mmu_memory_cache mmu_page_header_cache;
 
 	struct fpu guest_fpu;
<span class="p_add">+	bool eager_fpu;</span>
 	u64 xcr0;
 	u64 guest_supported_xcr0;
 	u32 guest_xstate_size;
<span class="p_chunk">@@ -722,6 +724,7 @@</span> <span class="p_context"> struct kvm_x86_ops {</span>
 	void (*cache_reg)(struct kvm_vcpu *vcpu, enum kvm_reg reg);
 	unsigned long (*get_rflags)(struct kvm_vcpu *vcpu);
 	void (*set_rflags)(struct kvm_vcpu *vcpu, unsigned long rflags);
<span class="p_add">+	void (*fpu_activate)(struct kvm_vcpu *vcpu);</span>
 	void (*fpu_deactivate)(struct kvm_vcpu *vcpu);
 
 	void (*tlb_flush)(struct kvm_vcpu *vcpu);
<span class="p_header">diff --git a/arch/x86/include/asm/pvclock.h b/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">index d6b078e..25b1cc0 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/pvclock.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/pvclock.h</span>
<span class="p_chunk">@@ -95,6 +95,7 @@</span> <span class="p_context"> unsigned __pvclock_read_cycles(const struct pvclock_vcpu_time_info *src,</span>
 
 struct pvclock_vsyscall_time_info {
 	struct pvclock_vcpu_time_info pvti;
<span class="p_add">+	u32 migrate_count;</span>
 } __attribute__((__aligned__(SMP_CACHE_BYTES)));
 
 #define PVTI_SIZE sizeof(struct pvclock_vsyscall_time_info)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel_rapl.c b/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_header">index c4bb8b8..76d8cbe 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel_rapl.c</span>
<span class="p_chunk">@@ -680,6 +680,7 @@</span> <span class="p_context"> static int __init rapl_pmu_init(void)</span>
 		break;
 	case 60: /* Haswell */
 	case 69: /* Haswell-Celeron */
<span class="p_add">+	case 61: /* Broadwell */</span>
 		rapl_cntr_mask = RAPL_IDX_HSW;
 		rapl_pmu_events_group.attrs = rapl_events_hsw_attr;
 		break;
<span class="p_header">diff --git a/arch/x86/kernel/pvclock.c b/arch/x86/kernel/pvclock.c</span>
<span class="p_header">index 2f355d2..e5ecd20 100644</span>
<span class="p_header">--- a/arch/x86/kernel/pvclock.c</span>
<span class="p_header">+++ b/arch/x86/kernel/pvclock.c</span>
<span class="p_chunk">@@ -141,7 +141,46 @@</span> <span class="p_context"> void pvclock_read_wallclock(struct pvclock_wall_clock *wall_clock,</span>
 	set_normalized_timespec(ts, now.tv_sec, now.tv_nsec);
 }
 
<span class="p_add">+static struct pvclock_vsyscall_time_info *pvclock_vdso_info;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct pvclock_vsyscall_time_info *</span>
<span class="p_add">+pvclock_get_vsyscall_user_time_info(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (!pvclock_vdso_info) {</span>
<span class="p_add">+		BUG();</span>
<span class="p_add">+		return NULL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return &amp;pvclock_vdso_info[cpu];</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+struct pvclock_vcpu_time_info *pvclock_get_vsyscall_time_info(int cpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return &amp;pvclock_get_vsyscall_user_time_info(cpu)-&gt;pvti;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_64
<span class="p_add">+static int pvclock_task_migrate(struct notifier_block *nb, unsigned long l,</span>
<span class="p_add">+			        void *v)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct task_migration_notifier *mn = v;</span>
<span class="p_add">+	struct pvclock_vsyscall_time_info *pvti;</span>
<span class="p_add">+</span>
<span class="p_add">+	pvti = pvclock_get_vsyscall_user_time_info(mn-&gt;from_cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* this is NULL when pvclock vsyscall is not initialized */</span>
<span class="p_add">+	if (unlikely(pvti == NULL))</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	pvti-&gt;migrate_count++;</span>
<span class="p_add">+</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block pvclock_migrate = {</span>
<span class="p_add">+	.notifier_call = pvclock_task_migrate,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /*
  * Initialize the generic pvclock vsyscall state.  This will allocate
  * a/some page(s) for the per-vcpu pvclock information, set up a
<span class="p_chunk">@@ -155,12 +194,17 @@</span> <span class="p_context"> int __init pvclock_init_vsyscall(struct pvclock_vsyscall_time_info *i,</span>
 
 	WARN_ON (size != PVCLOCK_VSYSCALL_NR_PAGES*PAGE_SIZE);
 
<span class="p_add">+	pvclock_vdso_info = i;</span>
<span class="p_add">+</span>
 	for (idx = 0; idx &lt;= (PVCLOCK_FIXMAP_END-PVCLOCK_FIXMAP_BEGIN); idx++) {
 		__set_fixmap(PVCLOCK_FIXMAP_BEGIN + idx,
 			     __pa(i) + (idx*PAGE_SIZE),
 			     PAGE_KERNEL_VVAR);
 	}
 
<span class="p_add">+</span>
<span class="p_add">+	register_task_migration_notifier(&amp;pvclock_migrate);</span>
<span class="p_add">+</span>
 	return 0;
 }
 #endif
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.c b/arch/x86/kvm/cpuid.c</span>
<span class="p_header">index 8a80737..307f9ec 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.c</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.c</span>
<span class="p_chunk">@@ -16,6 +16,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/module.h&gt;
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/uaccess.h&gt;
<span class="p_add">+#include &lt;asm/i387.h&gt; /* For use_eager_fpu.  Ugh! */</span>
<span class="p_add">+#include &lt;asm/fpu-internal.h&gt; /* For use_eager_fpu.  Ugh! */</span>
 #include &lt;asm/user.h&gt;
 #include &lt;asm/xsave.h&gt;
 #include &quot;cpuid.h&quot;
<span class="p_chunk">@@ -95,6 +97,8 @@</span> <span class="p_context"> int kvm_update_cpuid(struct kvm_vcpu *vcpu)</span>
 	if (best &amp;&amp; (best-&gt;eax &amp; (F(XSAVES) | F(XSAVEC))))
 		best-&gt;ebx = xstate_required_size(vcpu-&gt;arch.xcr0, true);
 
<span class="p_add">+	vcpu-&gt;arch.eager_fpu = guest_cpuid_has_mpx(vcpu);</span>
<span class="p_add">+</span>
 	/*
 	 * The existing code assumes virtual address is 48-bit in the canonical
 	 * address checks; exit if it is ever changed.
<span class="p_header">diff --git a/arch/x86/kvm/cpuid.h b/arch/x86/kvm/cpuid.h</span>
<span class="p_header">index 4452eed..9bec2b8 100644</span>
<span class="p_header">--- a/arch/x86/kvm/cpuid.h</span>
<span class="p_header">+++ b/arch/x86/kvm/cpuid.h</span>
<span class="p_chunk">@@ -111,4 +111,12 @@</span> <span class="p_context"> static inline bool guest_cpuid_has_rtm(struct kvm_vcpu *vcpu)</span>
 	best = kvm_find_cpuid_entry(vcpu, 7, 0);
 	return best &amp;&amp; (best-&gt;ebx &amp; bit(X86_FEATURE_RTM));
 }
<span class="p_add">+</span>
<span class="p_add">+static inline bool guest_cpuid_has_mpx(struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct kvm_cpuid_entry2 *best;</span>
<span class="p_add">+</span>
<span class="p_add">+	best = kvm_find_cpuid_entry(vcpu, 7, 0);</span>
<span class="p_add">+	return best &amp;&amp; (best-&gt;ebx &amp; bit(X86_FEATURE_MPX));</span>
<span class="p_add">+}</span>
 #endif
<span class="p_header">diff --git a/arch/x86/kvm/mmu.c b/arch/x86/kvm/mmu.c</span>
<span class="p_header">index f83fc6c..a5f45d1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.c</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.c</span>
<span class="p_chunk">@@ -3624,8 +3624,8 @@</span> <span class="p_context"> static void reset_rsvds_bits_mask_ept(struct kvm_vcpu *vcpu,</span>
 	}
 }
 
<span class="p_del">-void update_permission_bitmask(struct kvm_vcpu *vcpu,</span>
<span class="p_del">-		struct kvm_mmu *mmu, bool ept)</span>
<span class="p_add">+static void update_permission_bitmask(struct kvm_vcpu *vcpu,</span>
<span class="p_add">+				      struct kvm_mmu *mmu, bool ept)</span>
 {
 	unsigned bit, byte, pfec;
 	u8 map;
<span class="p_chunk">@@ -3806,6 +3806,7 @@</span> <span class="p_context"> static void init_kvm_tdp_mmu(struct kvm_vcpu *vcpu)</span>
 void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context)
 {
 	bool smep = kvm_read_cr4_bits(vcpu, X86_CR4_SMEP);
<span class="p_add">+	bool smap = kvm_read_cr4_bits(vcpu, X86_CR4_SMAP);</span>
 	ASSERT(vcpu);
 	ASSERT(!VALID_PAGE(vcpu-&gt;arch.mmu.root_hpa));
 
<span class="p_chunk">@@ -3823,6 +3824,8 @@</span> <span class="p_context"> void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context)</span>
 	vcpu-&gt;arch.mmu.base_role.cr0_wp  = is_write_protection(vcpu);
 	vcpu-&gt;arch.mmu.base_role.smep_andnot_wp
 		= smep &amp;&amp; !is_write_protection(vcpu);
<span class="p_add">+	context-&gt;base_role.smap_andnot_wp</span>
<span class="p_add">+		= smap &amp;&amp; !is_write_protection(vcpu);</span>
 }
 EXPORT_SYMBOL_GPL(kvm_init_shadow_mmu);
 
<span class="p_chunk">@@ -4094,12 +4097,18 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 		       const u8 *new, int bytes)
 {
 	gfn_t gfn = gpa &gt;&gt; PAGE_SHIFT;
<span class="p_del">-	union kvm_mmu_page_role mask = { .word = 0 };</span>
 	struct kvm_mmu_page *sp;
 	LIST_HEAD(invalid_list);
 	u64 entry, gentry, *spte;
 	int npte;
 	bool remote_flush, local_flush, zap_page;
<span class="p_add">+	union kvm_mmu_page_role mask = (union kvm_mmu_page_role) {</span>
<span class="p_add">+		.cr0_wp = 1,</span>
<span class="p_add">+		.cr4_pae = 1,</span>
<span class="p_add">+		.nxe = 1,</span>
<span class="p_add">+		.smep_andnot_wp = 1,</span>
<span class="p_add">+		.smap_andnot_wp = 1,</span>
<span class="p_add">+	};</span>
 
 	/*
 	 * If we don&#39;t have indirect shadow pages, it means no page is
<span class="p_chunk">@@ -4125,7 +4134,6 @@</span> <span class="p_context"> void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,</span>
 	++vcpu-&gt;kvm-&gt;stat.mmu_pte_write;
 	kvm_mmu_audit(vcpu, AUDIT_PRE_PTE_WRITE);
 
<span class="p_del">-	mask.cr0_wp = mask.cr4_pae = mask.nxe = 1;</span>
 	for_each_gfn_indirect_valid_sp(vcpu-&gt;kvm, sp, gfn) {
 		if (detect_write_misaligned(sp, gpa, bytes) ||
 		      detect_write_flooding(sp)) {
<span class="p_header">diff --git a/arch/x86/kvm/mmu.h b/arch/x86/kvm/mmu.h</span>
<span class="p_header">index bde8ee7..a6b8764 100644</span>
<span class="p_header">--- a/arch/x86/kvm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/kvm/mmu.h</span>
<span class="p_chunk">@@ -84,8 +84,6 @@</span> <span class="p_context"> int handle_mmio_page_fault_common(struct kvm_vcpu *vcpu, u64 addr, bool direct);</span>
 void kvm_init_shadow_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context);
 void kvm_init_shadow_ept_mmu(struct kvm_vcpu *vcpu, struct kvm_mmu *context,
 		bool execonly);
<span class="p_del">-void update_permission_bitmask(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,</span>
<span class="p_del">-		bool ept);</span>
 
 static inline unsigned int kvm_mmu_available_pages(struct kvm *kvm)
 {
<span class="p_chunk">@@ -179,6 +177,8 @@</span> <span class="p_context"> static inline bool permission_fault(struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,</span>
 	int index = (pfec &gt;&gt; 1) +
 		    (smap &gt;&gt; (X86_EFLAGS_AC_BIT - PFERR_RSVD_BIT + 1));
 
<span class="p_add">+	WARN_ON(pfec &amp; PFERR_RSVD_MASK);</span>
<span class="p_add">+</span>
 	return (mmu-&gt;permissions[index] &gt;&gt; pte_access) &amp; 1;
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/paging_tmpl.h b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">index fd49c86..6e6d115 100644</span>
<span class="p_header">--- a/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_header">+++ b/arch/x86/kvm/paging_tmpl.h</span>
<span class="p_chunk">@@ -718,6 +718,13 @@</span> <span class="p_context"> static int FNAME(page_fault)(struct kvm_vcpu *vcpu, gva_t addr, u32 error_code,</span>
 					      mmu_is_nested(vcpu));
 		if (likely(r != RET_MMIO_PF_INVALID))
 			return r;
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * page fault with PFEC.RSVD  = 1 is caused by shadow</span>
<span class="p_add">+		 * page fault, should not be used to walk guest page</span>
<span class="p_add">+		 * table.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		error_code &amp;= ~PFERR_RSVD_MASK;</span>
 	};
 
 	r = mmu_topup_memory_caches(vcpu);
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index 41dd038..67f8457 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -4379,6 +4379,7 @@</span> <span class="p_context"> static struct kvm_x86_ops svm_x86_ops = {</span>
 	.cache_reg = svm_cache_reg,
 	.get_rflags = svm_get_rflags,
 	.set_rflags = svm_set_rflags,
<span class="p_add">+	.fpu_activate = svm_fpu_activate,</span>
 	.fpu_deactivate = svm_fpu_deactivate,
 
 	.tlb_flush = svm_flush_tlb,
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index 3124464..bde6bd1 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -9348,6 +9348,7 @@</span> <span class="p_context"> static struct kvm_x86_ops vmx_x86_ops = {</span>
 	.cache_reg = vmx_cache_reg,
 	.get_rflags = vmx_get_rflags,
 	.set_rflags = vmx_set_rflags,
<span class="p_add">+	.fpu_activate = vmx_fpu_activate,</span>
 	.fpu_deactivate = vmx_fpu_deactivate,
 
 	.tlb_flush = vmx_flush_tlb,
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 5ec6a99..4725957 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -697,8 +697,9 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(kvm_set_xcr);</span>
 int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)
 {
 	unsigned long old_cr4 = kvm_read_cr4(vcpu);
<span class="p_del">-	unsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE |</span>
<span class="p_del">-				   X86_CR4_PAE | X86_CR4_SMEP;</span>
<span class="p_add">+	unsigned long pdptr_bits = X86_CR4_PGE | X86_CR4_PSE | X86_CR4_PAE |</span>
<span class="p_add">+				   X86_CR4_SMEP | X86_CR4_SMAP;</span>
<span class="p_add">+</span>
 	if (cr4 &amp; CR4_RESERVED_BITS)
 		return 1;
 
<span class="p_chunk">@@ -739,9 +740,6 @@</span> <span class="p_context"> int kvm_set_cr4(struct kvm_vcpu *vcpu, unsigned long cr4)</span>
 	    (!(cr4 &amp; X86_CR4_PCIDE) &amp;&amp; (old_cr4 &amp; X86_CR4_PCIDE)))
 		kvm_mmu_reset_context(vcpu);
 
<span class="p_del">-	if ((cr4 ^ old_cr4) &amp; X86_CR4_SMAP)</span>
<span class="p_del">-		update_permission_bitmask(vcpu, vcpu-&gt;arch.walk_mmu, false);</span>
<span class="p_del">-</span>
 	if ((cr4 ^ old_cr4) &amp; X86_CR4_OSXSAVE)
 		kvm_update_cpuid(vcpu);
 
<span class="p_chunk">@@ -6147,6 +6145,8 @@</span> <span class="p_context"> void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)</span>
 		return;
 
 	page = gfn_to_page(vcpu-&gt;kvm, APIC_DEFAULT_PHYS_BASE &gt;&gt; PAGE_SHIFT);
<span class="p_add">+	if (is_error_page(page))</span>
<span class="p_add">+		return;</span>
 	kvm_x86_ops-&gt;set_apic_access_page_addr(vcpu, page_to_phys(page));
 
 	/*
<span class="p_chunk">@@ -7001,7 +7001,9 @@</span> <span class="p_context"> void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)</span>
 	fpu_save_init(&amp;vcpu-&gt;arch.guest_fpu);
 	__kernel_fpu_end();
 	++vcpu-&gt;stat.fpu_reload;
<span class="p_del">-	kvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);</span>
<span class="p_add">+	if (!vcpu-&gt;arch.eager_fpu)</span>
<span class="p_add">+		kvm_make_request(KVM_REQ_DEACTIVATE_FPU, vcpu);</span>
<span class="p_add">+</span>
 	trace_kvm_fpu(0);
 }
 
<span class="p_chunk">@@ -7017,11 +7019,21 @@</span> <span class="p_context"> void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)</span>
 struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
 						unsigned int id)
 {
<span class="p_add">+	struct kvm_vcpu *vcpu;</span>
<span class="p_add">+</span>
 	if (check_tsc_unstable() &amp;&amp; atomic_read(&amp;kvm-&gt;online_vcpus) != 0)
 		printk_once(KERN_WARNING
 		&quot;kvm: SMP vm created on host with unstable TSC; &quot;
 		&quot;guest TSC will not be reliable\n&quot;);
<span class="p_del">-	return kvm_x86_ops-&gt;vcpu_create(kvm, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	vcpu = kvm_x86_ops-&gt;vcpu_create(kvm, id);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Activate fpu unconditionally in case the guest needs eager FPU.  It will be</span>
<span class="p_add">+	 * deactivated soon if it doesn&#39;t.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	kvm_x86_ops-&gt;fpu_activate(vcpu);</span>
<span class="p_add">+	return vcpu;</span>
 }
 
 int kvm_arch_vcpu_setup(struct kvm_vcpu *vcpu)
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index 9875143..ddeff48 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -559,6 +559,13 @@</span> <span class="p_context"> static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,</span>
 				if (is_ereg(dst_reg))
 					EMIT1(0x41);
 				EMIT3(0xC1, add_1reg(0xC8, dst_reg), 8);
<span class="p_add">+</span>
<span class="p_add">+				/* emit &#39;movzwl eax, ax&#39; */</span>
<span class="p_add">+				if (is_ereg(dst_reg))</span>
<span class="p_add">+					EMIT3(0x45, 0x0F, 0xB7);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					EMIT2(0x0F, 0xB7);</span>
<span class="p_add">+				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));</span>
 				break;
 			case 32:
 				/* emit &#39;bswap eax&#39; to swap lower 4 bytes */
<span class="p_chunk">@@ -577,6 +584,27 @@</span> <span class="p_context"> static int do_jit(struct bpf_prog *bpf_prog, int *addrs, u8 *image,</span>
 			break;
 
 		case BPF_ALU | BPF_END | BPF_FROM_LE:
<span class="p_add">+			switch (imm32) {</span>
<span class="p_add">+			case 16:</span>
<span class="p_add">+				/* emit &#39;movzwl eax, ax&#39; to zero extend 16-bit</span>
<span class="p_add">+				 * into 64 bit</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				if (is_ereg(dst_reg))</span>
<span class="p_add">+					EMIT3(0x45, 0x0F, 0xB7);</span>
<span class="p_add">+				else</span>
<span class="p_add">+					EMIT2(0x0F, 0xB7);</span>
<span class="p_add">+				EMIT1(add_2reg(0xC0, dst_reg, dst_reg));</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case 32:</span>
<span class="p_add">+				/* emit &#39;mov eax, eax&#39; to clear upper 32-bits */</span>
<span class="p_add">+				if (is_ereg(dst_reg))</span>
<span class="p_add">+					EMIT1(0x45);</span>
<span class="p_add">+				EMIT2(0x89, add_2reg(0xC0, dst_reg, dst_reg));</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			case 64:</span>
<span class="p_add">+				/* nop */</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
 			break;
 
 			/* ST: *(u8*)(dst_reg + off) = imm */
<span class="p_chunk">@@ -938,7 +966,12 @@</span> <span class="p_context"> void bpf_int_jit_compile(struct bpf_prog *prog)</span>
 	}
 	ctx.cleanup_addr = proglen;
 
<span class="p_del">-	for (pass = 0; pass &lt; 10; pass++) {</span>
<span class="p_add">+	/* JITed image shrinks with every pass and the loop iterates</span>
<span class="p_add">+	 * until the image stops shrinking. Very large bpf programs</span>
<span class="p_add">+	 * may converge on the last pass. In such case do one more</span>
<span class="p_add">+	 * pass to emit the final image</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (pass = 0; pass &lt; 10 || image; pass++) {</span>
 		proglen = do_jit(prog, addrs, image, oldproglen, &amp;ctx);
 		if (proglen &lt;= 0) {
 			image = NULL;
<span class="p_header">diff --git a/arch/x86/vdso/Makefile b/arch/x86/vdso/Makefile</span>
<span class="p_header">index 5a4affe..0cd936e 100644</span>
<span class="p_header">--- a/arch/x86/vdso/Makefile</span>
<span class="p_header">+++ b/arch/x86/vdso/Makefile</span>
<span class="p_chunk">@@ -50,7 +50,7 @@</span> <span class="p_context"> VDSO_LDFLAGS_vdso.lds = -m64 -Wl,-soname=linux-vdso.so.1 \</span>
 $(obj)/vdso64.so.dbg: $(src)/vdso.lds $(vobjs) FORCE
 	$(call if_changed,vdso)
 
<span class="p_del">-HOST_EXTRACFLAGS += -I$(srctree)/tools/include</span>
<span class="p_add">+HOST_EXTRACFLAGS += -I$(srctree)/tools/include -I$(srctree)/include/uapi -I$(srctree)/arch/x86/include/uapi</span>
 hostprogs-y			+= vdso2c
 
 quiet_cmd_vdso2c = VDSO2C  $@
<span class="p_header">diff --git a/arch/x86/vdso/vclock_gettime.c b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">index 9793322..40d2473 100644</span>
<span class="p_header">--- a/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_header">+++ b/arch/x86/vdso/vclock_gettime.c</span>
<span class="p_chunk">@@ -82,18 +82,15 @@</span> <span class="p_context"> static notrace cycle_t vread_pvclock(int *mode)</span>
 	cycle_t ret;
 	u64 last;
 	u32 version;
<span class="p_add">+	u32 migrate_count;</span>
 	u8 flags;
 	unsigned cpu, cpu1;
 
 
 	/*
<span class="p_del">-	 * Note: hypervisor must guarantee that:</span>
<span class="p_del">-	 * 1. cpu ID number maps 1:1 to per-CPU pvclock time info.</span>
<span class="p_del">-	 * 2. that per-CPU pvclock time info is updated if the</span>
<span class="p_del">-	 *    underlying CPU changes.</span>
<span class="p_del">-	 * 3. that version is increased whenever underlying CPU</span>
<span class="p_del">-	 *    changes.</span>
<span class="p_del">-	 *</span>
<span class="p_add">+	 * When looping to get a consistent (time-info, tsc) pair, we</span>
<span class="p_add">+	 * also need to deal with the possibility we can switch vcpus,</span>
<span class="p_add">+	 * so make sure we always re-fetch time-info for the current vcpu.</span>
 	 */
 	do {
 		cpu = __getcpu() &amp; VGETCPU_CPU_MASK;
<span class="p_chunk">@@ -102,20 +99,27 @@</span> <span class="p_context"> static notrace cycle_t vread_pvclock(int *mode)</span>
 		 * __getcpu() calls (Gleb).
 		 */
 
<span class="p_del">-		pvti = get_pvti(cpu);</span>
<span class="p_add">+		/* Make sure migrate_count will change if we leave the VCPU. */</span>
<span class="p_add">+		do {</span>
<span class="p_add">+			pvti = get_pvti(cpu);</span>
<span class="p_add">+			migrate_count = pvti-&gt;migrate_count;</span>
<span class="p_add">+</span>
<span class="p_add">+			cpu1 = cpu;</span>
<span class="p_add">+			cpu = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_add">+		} while (unlikely(cpu != cpu1));</span>
 
 		version = __pvclock_read_cycles(&amp;pvti-&gt;pvti, &amp;ret, &amp;flags);
 
 		/*
 		 * Test we&#39;re still on the cpu as well as the version.
<span class="p_del">-		 * We could have been migrated just after the first</span>
<span class="p_del">-		 * vgetcpu but before fetching the version, so we</span>
<span class="p_del">-		 * wouldn&#39;t notice a version change.</span>
<span class="p_add">+		 * - We must read TSC of pvti&#39;s VCPU.</span>
<span class="p_add">+		 * - KVM doesn&#39;t follow the versioning protocol, so data could</span>
<span class="p_add">+		 *   change before version if we left the VCPU.</span>
 		 */
<span class="p_del">-		cpu1 = __getcpu() &amp; VGETCPU_CPU_MASK;</span>
<span class="p_del">-	} while (unlikely(cpu != cpu1 ||</span>
<span class="p_del">-			  (pvti-&gt;pvti.version &amp; 1) ||</span>
<span class="p_del">-			  pvti-&gt;pvti.version != version));</span>
<span class="p_add">+		smp_rmb();</span>
<span class="p_add">+	} while (unlikely((pvti-&gt;pvti.version &amp; 1) ||</span>
<span class="p_add">+			  pvti-&gt;pvti.version != version ||</span>
<span class="p_add">+			  pvti-&gt;migrate_count != migrate_count));</span>
 
 	if (unlikely(!(flags &amp; PVCLOCK_TSC_STABLE_BIT)))
 		*mode = VCLOCK_NONE;
<span class="p_header">diff --git a/drivers/acpi/osl.c b/drivers/acpi/osl.c</span>
<span class="p_header">index f9eeae8..5aa1f6e 100644</span>
<span class="p_header">--- a/drivers/acpi/osl.c</span>
<span class="p_header">+++ b/drivers/acpi/osl.c</span>
<span class="p_chunk">@@ -182,7 +182,7 @@</span> <span class="p_context"> static void __init acpi_request_region (struct acpi_generic_address *gas,</span>
 		request_mem_region(addr, length, desc);
 }
 
<span class="p_del">-static int __init acpi_reserve_resources(void)</span>
<span class="p_add">+static void __init acpi_reserve_resources(void)</span>
 {
 	acpi_request_region(&amp;acpi_gbl_FADT.xpm1a_event_block, acpi_gbl_FADT.pm1_event_length,
 		&quot;ACPI PM1a_EVT_BLK&quot;);
<span class="p_chunk">@@ -211,10 +211,7 @@</span> <span class="p_context"> static int __init acpi_reserve_resources(void)</span>
 	if (!(acpi_gbl_FADT.gpe1_block_length &amp; 0x1))
 		acpi_request_region(&amp;acpi_gbl_FADT.xgpe1_block,
 			       acpi_gbl_FADT.gpe1_block_length, &quot;ACPI GPE1_BLK&quot;);
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
 }
<span class="p_del">-device_initcall(acpi_reserve_resources);</span>
 
 void acpi_os_printf(const char *fmt, ...)
 {
<span class="p_chunk">@@ -1845,6 +1842,7 @@</span> <span class="p_context"> acpi_status __init acpi_os_initialize(void)</span>
 
 acpi_status __init acpi_os_initialize1(void)
 {
<span class="p_add">+	acpi_reserve_resources();</span>
 	kacpid_wq = alloc_workqueue(&quot;kacpid&quot;, 0, 1);
 	kacpi_notify_wq = alloc_workqueue(&quot;kacpi_notify&quot;, 0, 1);
 	kacpi_hotplug_wq = alloc_ordered_workqueue(&quot;kacpi_hotplug&quot;, 0);
<span class="p_header">diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c</span>
<span class="p_header">index 33bb06e..adce56f 100644</span>
<span class="p_header">--- a/drivers/ata/ahci.c</span>
<span class="p_header">+++ b/drivers/ata/ahci.c</span>
<span class="p_chunk">@@ -66,6 +66,7 @@</span> <span class="p_context"> enum board_ids {</span>
 	board_ahci_yes_fbs,
 
 	/* board IDs for specific chipsets in alphabetical order */
<span class="p_add">+	board_ahci_avn,</span>
 	board_ahci_mcp65,
 	board_ahci_mcp77,
 	board_ahci_mcp89,
<span class="p_chunk">@@ -84,6 +85,8 @@</span> <span class="p_context"> enum board_ids {</span>
 static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
 static int ahci_vt8251_hardreset(struct ata_link *link, unsigned int *class,
 				 unsigned long deadline);
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline);</span>
 static void ahci_mcp89_apple_enable(struct pci_dev *pdev);
 static bool is_mcp89_apple(struct pci_dev *pdev);
 static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,
<span class="p_chunk">@@ -107,6 +110,11 @@</span> <span class="p_context"> static struct ata_port_operations ahci_p5wdh_ops = {</span>
 	.hardreset		= ahci_p5wdh_hardreset,
 };
 
<span class="p_add">+static struct ata_port_operations ahci_avn_ops = {</span>
<span class="p_add">+	.inherits		= &amp;ahci_ops,</span>
<span class="p_add">+	.hardreset		= ahci_avn_hardreset,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct ata_port_info ahci_port_info[] = {
 	/* by features */
 	[board_ahci] = {
<span class="p_chunk">@@ -151,6 +159,12 @@</span> <span class="p_context"> static const struct ata_port_info ahci_port_info[] = {</span>
 		.port_ops	= &amp;ahci_ops,
 	},
 	/* by chipsets */
<span class="p_add">+	[board_ahci_avn] = {</span>
<span class="p_add">+		.flags		= AHCI_FLAG_COMMON,</span>
<span class="p_add">+		.pio_mask	= ATA_PIO4,</span>
<span class="p_add">+		.udma_mask	= ATA_UDMA6,</span>
<span class="p_add">+		.port_ops	= &amp;ahci_avn_ops,</span>
<span class="p_add">+	},</span>
 	[board_ahci_mcp65] = {
 		AHCI_HFLAGS	(AHCI_HFLAG_NO_FPDMA_AA | AHCI_HFLAG_NO_PMP |
 				 AHCI_HFLAG_YES_NCQ),
<span class="p_chunk">@@ -290,14 +304,14 @@</span> <span class="p_context"> static const struct pci_device_id ahci_pci_tbl[] = {</span>
 	{ PCI_VDEVICE(INTEL, 0x1f27), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2e), board_ahci }, /* Avoton RAID */
 	{ PCI_VDEVICE(INTEL, 0x1f2f), board_ahci }, /* Avoton RAID */
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci }, /* Avoton AHCI */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci }, /* Avoton RAID */</span>
<span class="p_del">-	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f32), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f33), board_ahci_avn }, /* Avoton AHCI */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f34), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f35), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f36), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f37), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3e), board_ahci_avn }, /* Avoton RAID */</span>
<span class="p_add">+	{ PCI_VDEVICE(INTEL, 0x1f3f), board_ahci_avn }, /* Avoton RAID */</span>
 	{ PCI_VDEVICE(INTEL, 0x2823), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x2827), board_ahci }, /* Wellsburg RAID */
 	{ PCI_VDEVICE(INTEL, 0x8d02), board_ahci }, /* Wellsburg AHCI */
<span class="p_chunk">@@ -670,6 +684,79 @@</span> <span class="p_context"> static int ahci_p5wdh_hardreset(struct ata_link *link, unsigned int *class,</span>
 	return rc;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * ahci_avn_hardreset - attempt more aggressive recovery of Avoton ports.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * It has been observed with some SSDs that the timing of events in the</span>
<span class="p_add">+ * link synchronization phase can leave the port in a state that can not</span>
<span class="p_add">+ * be recovered by a SATA-hard-reset alone.  The failing signature is</span>
<span class="p_add">+ * SStatus.DET stuck at 1 (&quot;Device presence detected but Phy</span>
<span class="p_add">+ * communication not established&quot;).  It was found that unloading and</span>
<span class="p_add">+ * reloading the driver when this problem occurs allows the drive</span>
<span class="p_add">+ * connection to be recovered (DET advanced to 0x3).  The critical</span>
<span class="p_add">+ * component of reloading the driver is that the port state machines are</span>
<span class="p_add">+ * reset by bouncing &quot;port enable&quot; in the AHCI PCS configuration</span>
<span class="p_add">+ * register.  So, reproduce that effect by bouncing a port whenever we</span>
<span class="p_add">+ * see DET==1 after a reset.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int ahci_avn_hardreset(struct ata_link *link, unsigned int *class,</span>
<span class="p_add">+			      unsigned long deadline)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const unsigned long *timing = sata_ehc_deb_timing(&amp;link-&gt;eh_context);</span>
<span class="p_add">+	struct ata_port *ap = link-&gt;ap;</span>
<span class="p_add">+	struct ahci_port_priv *pp = ap-&gt;private_data;</span>
<span class="p_add">+	struct ahci_host_priv *hpriv = ap-&gt;host-&gt;private_data;</span>
<span class="p_add">+	u8 *d2h_fis = pp-&gt;rx_fis + RX_FIS_D2H_REG;</span>
<span class="p_add">+	unsigned long tmo = deadline - jiffies;</span>
<span class="p_add">+	struct ata_taskfile tf;</span>
<span class="p_add">+	bool online;</span>
<span class="p_add">+	int rc, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;ENTER\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	ahci_stop_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; 2; i++) {</span>
<span class="p_add">+		u16 val;</span>
<span class="p_add">+		u32 sstatus;</span>
<span class="p_add">+		int port = ap-&gt;port_no;</span>
<span class="p_add">+		struct ata_host *host = ap-&gt;host;</span>
<span class="p_add">+		struct pci_dev *pdev = to_pci_dev(host-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* clear D2H reception area to properly wait for D2H FIS */</span>
<span class="p_add">+		ata_tf_init(link-&gt;device, &amp;tf);</span>
<span class="p_add">+		tf.command = ATA_BUSY;</span>
<span class="p_add">+		ata_tf_to_fis(&amp;tf, 0, 0, d2h_fis);</span>
<span class="p_add">+</span>
<span class="p_add">+		rc = sata_link_hardreset(link, timing, deadline, &amp;online,</span>
<span class="p_add">+				ahci_check_ready);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (sata_scr_read(link, SCR_STATUS, &amp;sstatus) != 0 ||</span>
<span class="p_add">+				(sstatus &amp; 0xf) != 1)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		ata_link_printk(link, KERN_INFO, &quot;avn bounce port%d\n&quot;,</span>
<span class="p_add">+				port);</span>
<span class="p_add">+</span>
<span class="p_add">+		pci_read_config_word(pdev, 0x92, &amp;val);</span>
<span class="p_add">+		val &amp;= ~(1 &lt;&lt; port);</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		ata_msleep(ap, 1000);</span>
<span class="p_add">+		val |= 1 &lt;&lt; port;</span>
<span class="p_add">+		pci_write_config_word(pdev, 0x92, val);</span>
<span class="p_add">+		deadline += tmo;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	hpriv-&gt;start_engine(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (online)</span>
<span class="p_add">+		*class = ahci_dev_classify(ap);</span>
<span class="p_add">+</span>
<span class="p_add">+	DPRINTK(&quot;EXIT, rc=%d, class=%u\n&quot;, rc, *class);</span>
<span class="p_add">+	return rc;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PM
 static int ahci_pci_device_suspend(struct pci_dev *pdev, pm_message_t mesg)
 {
<span class="p_header">diff --git a/drivers/ata/libahci.c b/drivers/ata/libahci.c</span>
<span class="p_header">index 61a9c07..287c4ba 100644</span>
<span class="p_header">--- a/drivers/ata/libahci.c</span>
<span class="p_header">+++ b/drivers/ata/libahci.c</span>
<span class="p_chunk">@@ -1707,8 +1707,7 @@</span> <span class="p_context"> static void ahci_handle_port_interrupt(struct ata_port *ap,</span>
 	if (unlikely(resetting))
 		status &amp;= ~PORT_IRQ_BAD_PMP;
 
<span class="p_del">-	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_del">-	if (ap-&gt;link.lpm_policy &gt; ATA_LPM_MAX_POWER) {</span>
<span class="p_add">+	if (sata_lpm_ignore_phy_events(&amp;ap-&gt;link)) {</span>
 		status &amp;= ~PORT_IRQ_PHYRDY;
 		ahci_scr_write(&amp;ap-&gt;link, SCR_ERROR, SERR_PHYRDY_CHG);
 	}
<span class="p_header">diff --git a/drivers/ata/libata-core.c b/drivers/ata/libata-core.c</span>
<span class="p_header">index 00f2f74..0b8d57c 100644</span>
<span class="p_header">--- a/drivers/ata/libata-core.c</span>
<span class="p_header">+++ b/drivers/ata/libata-core.c</span>
<span class="p_chunk">@@ -4243,7 +4243,7 @@</span> <span class="p_context"> static const struct ata_blacklist_entry ata_device_blacklist [] = {</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 	{ &quot;Crucial_CT*MX100*&quot;,		&quot;MU01&quot;,	ATA_HORKAGE_NO_NCQ_TRIM |
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
<span class="p_del">-	{ &quot;Samsung SSD 850 PRO*&quot;,	NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
<span class="p_add">+	{ &quot;Samsung SSD 8*&quot;,		NULL,	ATA_HORKAGE_NO_NCQ_TRIM |</span>
 						ATA_HORKAGE_ZERO_AFTER_TRIM, },
 
 	/*
<span class="p_chunk">@@ -6789,6 +6789,38 @@</span> <span class="p_context"> u32 ata_wait_register(struct ata_port *ap, void __iomem *reg, u32 mask, u32 val,</span>
 	return tmp;
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ *	sata_lpm_ignore_phy_events - test if PHY event should be ignored</span>
<span class="p_add">+ *	@link: Link receiving the event</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Test whether the received PHY event has to be ignored or not.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	LOCKING:</span>
<span class="p_add">+ *	None:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	RETURNS:</span>
<span class="p_add">+ *	True if the event has to be ignored.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool sata_lpm_ignore_phy_events(struct ata_link *link)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long lpm_timeout = link-&gt;last_lpm_change +</span>
<span class="p_add">+				    msecs_to_jiffies(ATA_TMOUT_SPURIOUS_PHY);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if LPM is enabled, PHYRDY doesn&#39;t mean anything */</span>
<span class="p_add">+	if (link-&gt;lpm_policy &gt; ATA_LPM_MAX_POWER)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* ignore the first PHY event after the LPM policy changed</span>
<span class="p_add">+	 * as it is might be spurious</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((link-&gt;flags &amp; ATA_LFLAG_CHANGED) &amp;&amp;</span>
<span class="p_add">+	    time_before(jiffies, lpm_timeout))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(sata_lpm_ignore_phy_events);</span>
<span class="p_add">+</span>
 /*
  * Dummy port_ops
  */
<span class="p_header">diff --git a/drivers/ata/libata-eh.c b/drivers/ata/libata-eh.c</span>
<span class="p_header">index 8d00c26..2efdb75 100644</span>
<span class="p_header">--- a/drivers/ata/libata-eh.c</span>
<span class="p_header">+++ b/drivers/ata/libata-eh.c</span>
<span class="p_chunk">@@ -3492,6 +3492,9 @@</span> <span class="p_context"> static int ata_eh_set_lpm(struct ata_link *link, enum ata_lpm_policy policy,</span>
 		}
 	}
 
<span class="p_add">+	link-&gt;last_lpm_change = jiffies;</span>
<span class="p_add">+	link-&gt;flags |= ATA_LFLAG_CHANGED;</span>
<span class="p_add">+</span>
 	return 0;
 
 fail:
<span class="p_header">diff --git a/drivers/clk/samsung/clk-exynos5420.c b/drivers/clk/samsung/clk-exynos5420.c</span>
<span class="p_header">index 848d602..aab8241 100644</span>
<span class="p_header">--- a/drivers/clk/samsung/clk-exynos5420.c</span>
<span class="p_header">+++ b/drivers/clk/samsung/clk-exynos5420.c</span>
<span class="p_chunk">@@ -271,6 +271,7 @@</span> <span class="p_context"> static const struct samsung_clk_reg_dump exynos5420_set_clksrc[] = {</span>
 	{ .offset = SRC_MASK_PERIC0,		.value = 0x11111110, },
 	{ .offset = SRC_MASK_PERIC1,		.value = 0x11111100, },
 	{ .offset = SRC_MASK_ISP,		.value = 0x11111000, },
<span class="p_add">+	{ .offset = GATE_BUS_TOP,		.value = 0xffffffff, },</span>
 	{ .offset = GATE_BUS_DISP1,		.value = 0xffffffff, },
 	{ .offset = GATE_IP_PERIC,		.value = 0xffffffff, },
 };
<span class="p_header">diff --git a/drivers/firmware/dmi_scan.c b/drivers/firmware/dmi_scan.c</span>
<span class="p_header">index 2eebd28b..ccc2018 100644</span>
<span class="p_header">--- a/drivers/firmware/dmi_scan.c</span>
<span class="p_header">+++ b/drivers/firmware/dmi_scan.c</span>
<span class="p_chunk">@@ -499,18 +499,19 @@</span> <span class="p_context"> static int __init dmi_present(const u8 *buf)</span>
 	buf += 16;
 
 	if (memcmp(buf, &quot;_DMI_&quot;, 5) == 0 &amp;&amp; dmi_checksum(buf, 15)) {
<span class="p_add">+		if (smbios_ver)</span>
<span class="p_add">+			dmi_ver = smbios_ver;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 | (buf[14] &amp; 0x0F);</span>
 		dmi_num = get_unaligned_le16(buf + 12);
 		dmi_len = get_unaligned_le16(buf + 6);
 		dmi_base = get_unaligned_le32(buf + 8);
 
 		if (dmi_walk_early(dmi_decode) == 0) {
 			if (smbios_ver) {
<span class="p_del">-				dmi_ver = smbios_ver;</span>
 				pr_info(&quot;SMBIOS %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
 			} else {
<span class="p_del">-				dmi_ver = (buf[14] &amp; 0xF0) &lt;&lt; 4 |</span>
<span class="p_del">-					   (buf[14] &amp; 0x0F);</span>
 				pr_info(&quot;Legacy DMI %d.%d present.\n&quot;,
 				       dmi_ver &gt;&gt; 8, dmi_ver &amp; 0xFF);
 			}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/atombios_dp.c b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">index 5bf825d..ceab25d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/atombios_dp.c</span>
<span class="p_chunk">@@ -405,19 +405,21 @@</span> <span class="p_context"> bool radeon_dp_getdpcd(struct radeon_connector *radeon_connector)</span>
 {
 	struct radeon_connector_atom_dig *dig_connector = radeon_connector-&gt;con_priv;
 	u8 msg[DP_DPCD_SIZE];
<span class="p_del">-	int ret;</span>
<span class="p_add">+	int ret, i;</span>
 
<span class="p_del">-	ret = drm_dp_dpcd_read(&amp;radeon_connector-&gt;ddc_bus-&gt;aux, DP_DPCD_REV, msg,</span>
<span class="p_del">-			       DP_DPCD_SIZE);</span>
<span class="p_del">-	if (ret &gt; 0) {</span>
<span class="p_del">-		memcpy(dig_connector-&gt;dpcd, msg, DP_DPCD_SIZE);</span>
<span class="p_add">+	for (i = 0; i &lt; 7; i++) {</span>
<span class="p_add">+		ret = drm_dp_dpcd_read(&amp;radeon_connector-&gt;ddc_bus-&gt;aux, DP_DPCD_REV, msg,</span>
<span class="p_add">+				       DP_DPCD_SIZE);</span>
<span class="p_add">+		if (ret == DP_DPCD_SIZE) {</span>
<span class="p_add">+			memcpy(dig_connector-&gt;dpcd, msg, DP_DPCD_SIZE);</span>
 
<span class="p_del">-		DRM_DEBUG_KMS(&quot;DPCD: %*ph\n&quot;, (int)sizeof(dig_connector-&gt;dpcd),</span>
<span class="p_del">-			      dig_connector-&gt;dpcd);</span>
<span class="p_add">+			DRM_DEBUG_KMS(&quot;DPCD: %*ph\n&quot;, (int)sizeof(dig_connector-&gt;dpcd),</span>
<span class="p_add">+				      dig_connector-&gt;dpcd);</span>
 
<span class="p_del">-		radeon_dp_probe_oui(radeon_connector);</span>
<span class="p_add">+			radeon_dp_probe_oui(radeon_connector);</span>
 
<span class="p_del">-		return true;</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		}</span>
 	}
 	dig_connector-&gt;dpcd[0] = 0;
 	return false;
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">index 53b9ac3..c94e68d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/cik.c</span>
<span class="p_chunk">@@ -5779,7 +5779,7 @@</span> <span class="p_context"> static int cik_pcie_gart_enable(struct radeon_device *rdev)</span>
 	/* restore context1-15 */
 	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
<span class="p_del">-	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn - 1);</span>
 	for (i = 1; i &lt; 16; i++) {
 		if (i &lt; 8)
 			WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i &lt;&lt; 2),
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">index 88b2c36..5d6dc1e 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_chunk">@@ -1269,7 +1269,8 @@</span> <span class="p_context"> static int cayman_pcie_gart_enable(struct radeon_device *rdev)</span>
 	 */
 	for (i = 1; i &lt; 8; i++) {
 		WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR + (i &lt;&lt; 2), 0);
<span class="p_del">-		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i &lt;&lt; 2), rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+		WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR + (i &lt;&lt; 2),</span>
<span class="p_add">+			rdev-&gt;vm_manager.max_pfn - 1);</span>
 		WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR + (i &lt;&lt; 2),
 		       rdev-&gt;vm_manager.saved_table_addr[i]);
 	}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si.c b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">index eed21db..17bbb7b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si.c</span>
<span class="p_chunk">@@ -4285,7 +4285,7 @@</span> <span class="p_context"> static int si_pcie_gart_enable(struct radeon_device *rdev)</span>
 	/* empty context1-15 */
 	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
<span class="p_del">-	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn);</span>
<span class="p_add">+	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev-&gt;vm_manager.max_pfn - 1);</span>
 	/* Assign the pt base to something valid for now; the pts used for
 	 * the VMs are determined by the application and setup and assigned
 	 * on the fly in the vm part of radeon_gart.c
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 9243359..fd6687a 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -454,6 +454,10 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_UGCI_FLYING	0x0020
 #define USB_DEVICE_ID_UGCI_FIGHTING	0x0030
 
<span class="p_add">+#define USB_VENDOR_ID_HP		0x03f0</span>
<span class="p_add">+#define USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE	0x0a4a</span>
<span class="p_add">+#define USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE		0x134a</span>
<span class="p_add">+</span>
 #define USB_VENDOR_ID_HUION		0x256c
 #define USB_DEVICE_ID_HUION_TABLET	0x006e
 
<span class="p_chunk">@@ -581,6 +585,7 @@</span> <span class="p_context"></span>
 #define USB_VENDOR_ID_LOGITECH		0x046d
 #define USB_DEVICE_ID_LOGITECH_AUDIOHUB 0x0a0e
 #define USB_DEVICE_ID_LOGITECH_T651	0xb00c
<span class="p_add">+#define USB_DEVICE_ID_LOGITECH_C077	0xc007</span>
 #define USB_DEVICE_ID_LOGITECH_RECEIVER	0xc101
 #define USB_DEVICE_ID_LOGITECH_HARMONY_FIRST  0xc110
 #define USB_DEVICE_ID_LOGITECH_HARMONY_LAST 0xc14f
<span class="p_header">diff --git a/drivers/hid/hid-logitech-hidpp.c b/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_header">index a93cefe..64816b03 100644</span>
<span class="p_header">--- a/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_header">+++ b/drivers/hid/hid-logitech-hidpp.c</span>
<span class="p_chunk">@@ -39,7 +39,6 @@</span> <span class="p_context"> MODULE_AUTHOR(&quot;Nestor Lopez Casado &lt;nlopezcasad@logitech.com&gt;&quot;);</span>
 /* bits 1..20 are reserved for classes */
 #define HIDPP_QUIRK_DELAYED_INIT		BIT(21)
 #define HIDPP_QUIRK_WTP_PHYSICAL_BUTTONS	BIT(22)
<span class="p_del">-#define HIDPP_QUIRK_MULTI_INPUT			BIT(23)</span>
 
 /*
  * There are two hidpp protocols in use, the first version hidpp10 is known
<span class="p_chunk">@@ -689,12 +688,6 @@</span> <span class="p_context"> static int wtp_input_mapping(struct hid_device *hdev, struct hid_input *hi,</span>
 		struct hid_field *field, struct hid_usage *usage,
 		unsigned long **bit, int *max)
 {
<span class="p_del">-	struct hidpp_device *hidpp = hid_get_drvdata(hdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((hidpp-&gt;quirks &amp; HIDPP_QUIRK_MULTI_INPUT) &amp;&amp;</span>
<span class="p_del">-	    (field-&gt;application == HID_GD_KEYBOARD))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
 	return -1;
 }
 
<span class="p_chunk">@@ -703,10 +696,6 @@</span> <span class="p_context"> static void wtp_populate_input(struct hidpp_device *hidpp,</span>
 {
 	struct wtp_data *wd = hidpp-&gt;private_data;
 
<span class="p_del">-	if ((hidpp-&gt;quirks &amp; HIDPP_QUIRK_MULTI_INPUT) &amp;&amp; origin_is_hid_core)</span>
<span class="p_del">-		/* this is the generic hid-input call */</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	__set_bit(EV_ABS, input_dev-&gt;evbit);
 	__set_bit(EV_KEY, input_dev-&gt;evbit);
 	__clear_bit(EV_REL, input_dev-&gt;evbit);
<span class="p_chunk">@@ -1205,10 +1194,6 @@</span> <span class="p_context"> static int hidpp_probe(struct hid_device *hdev, const struct hid_device_id *id)</span>
 	if (hidpp-&gt;quirks &amp; HIDPP_QUIRK_DELAYED_INIT)
 		connect_mask &amp;= ~HID_CONNECT_HIDINPUT;
 
<span class="p_del">-	/* Re-enable hidinput for multi-input devices */</span>
<span class="p_del">-	if (hidpp-&gt;quirks &amp; HIDPP_QUIRK_MULTI_INPUT)</span>
<span class="p_del">-		connect_mask |= HID_CONNECT_HIDINPUT;</span>
<span class="p_del">-</span>
 	ret = hid_hw_start(hdev, connect_mask);
 	if (ret) {
 		hid_err(hdev, &quot;%s:hid_hw_start returned error\n&quot;, __func__);
<span class="p_chunk">@@ -1256,11 +1241,6 @@</span> <span class="p_context"> static const struct hid_device_id hidpp_devices[] = {</span>
 	  HID_BLUETOOTH_DEVICE(USB_VENDOR_ID_LOGITECH,
 		USB_DEVICE_ID_LOGITECH_T651),
 	  .driver_data = HIDPP_QUIRK_CLASS_WTP },
<span class="p_del">-	{ /* Keyboard TK820 */</span>
<span class="p_del">-	  HID_DEVICE(BUS_USB, HID_GROUP_LOGITECH_DJ_DEVICE,</span>
<span class="p_del">-		USB_VENDOR_ID_LOGITECH, 0x4102),</span>
<span class="p_del">-	  .driver_data = HIDPP_QUIRK_DELAYED_INIT | HIDPP_QUIRK_MULTI_INPUT |</span>
<span class="p_del">-			 HIDPP_QUIRK_CLASS_WTP },</span>
 
 	{ HID_DEVICE(BUS_USB, HID_GROUP_LOGITECH_DJ_DEVICE,
 		USB_VENDOR_ID_LOGITECH, HID_ANY_ID)},
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index b27b3d3..5c5f97d 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -78,6 +78,9 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_ELO, USB_DEVICE_ID_ELO_TS2700, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_FORMOSA, USB_DEVICE_ID_FORMOSA_IR_RECEIVER, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_FREESCALE, USB_DEVICE_ID_FREESCALE_MX28, HID_QUIRK_NOGET },
<span class="p_add">+	{ USB_VENDOR_ID_HP, USB_PRODUCT_ID_HP_LOGITECH_OEM_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },</span>
<span class="p_add">+	{ USB_VENDOR_ID_HP, USB_PRODUCT_ID_HP_PIXART_OEM_USB_OPTICAL_MOUSE, HID_QUIRK_ALWAYS_POLL },</span>
<span class="p_add">+	{ USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_C077, HID_QUIRK_ALWAYS_POLL },</span>
 	{ USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_MICROSOFT, USB_DEVICE_ID_MS_TYPE_COVER_3, HID_QUIRK_NO_INIT_REPORTS },
 	{ USB_VENDOR_ID_MSI, USB_DEVICE_ID_MSI_GT683R_LED_PANEL, HID_QUIRK_NO_INIT_REPORTS },
<span class="p_header">diff --git a/drivers/hv/hyperv_vmbus.h b/drivers/hv/hyperv_vmbus.h</span>
<span class="p_header">index c386d8d..ce49de7 100644</span>
<span class="p_header">--- a/drivers/hv/hyperv_vmbus.h</span>
<span class="p_header">+++ b/drivers/hv/hyperv_vmbus.h</span>
<span class="p_chunk">@@ -49,6 +49,17 @@</span> <span class="p_context"> enum hv_cpuid_function {</span>
 	HVCPUID_IMPLEMENTATION_LIMITS		= 0x40000005,
 };
 
<span class="p_add">+#define  HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE   0x400</span>
<span class="p_add">+</span>
<span class="p_add">+#define HV_X64_MSR_CRASH_P0   0x40000100</span>
<span class="p_add">+#define HV_X64_MSR_CRASH_P1   0x40000101</span>
<span class="p_add">+#define HV_X64_MSR_CRASH_P2   0x40000102</span>
<span class="p_add">+#define HV_X64_MSR_CRASH_P3   0x40000103</span>
<span class="p_add">+#define HV_X64_MSR_CRASH_P4   0x40000104</span>
<span class="p_add">+#define HV_X64_MSR_CRASH_CTL  0x40000105</span>
<span class="p_add">+</span>
<span class="p_add">+#define HV_CRASH_CTL_CRASH_NOTIFY (1ULL &lt;&lt; 63)</span>
<span class="p_add">+</span>
 /* Define version of the synthetic interrupt controller. */
 #define HV_SYNIC_VERSION		(1)
 
<span class="p_header">diff --git a/drivers/hv/vmbus_drv.c b/drivers/hv/vmbus_drv.c</span>
<span class="p_header">index 4d6b269..3d2d710 100644</span>
<span class="p_header">--- a/drivers/hv/vmbus_drv.c</span>
<span class="p_header">+++ b/drivers/hv/vmbus_drv.c</span>
<span class="p_chunk">@@ -35,6 +35,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/hyperv.h&gt;
 #include &lt;asm/hypervisor.h&gt;
 #include &lt;asm/mshyperv.h&gt;
<span class="p_add">+#include &lt;linux/notifier.h&gt;</span>
<span class="p_add">+#include &lt;linux/ptrace.h&gt;</span>
 #include &quot;hyperv_vmbus.h&quot;
 
 static struct acpi_device  *hv_acpi_dev;
<span class="p_chunk">@@ -43,6 +45,31 @@</span> <span class="p_context"> static struct tasklet_struct msg_dpc;</span>
 static struct completion probe_event;
 static int irq;
 
<span class="p_add">+</span>
<span class="p_add">+int hyperv_panic_event(struct notifier_block *nb,</span>
<span class="p_add">+			unsigned long event, void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pt_regs *regs;</span>
<span class="p_add">+</span>
<span class="p_add">+	regs = current_pt_regs();</span>
<span class="p_add">+</span>
<span class="p_add">+	wrmsrl(HV_X64_MSR_CRASH_P0, regs-&gt;ip);</span>
<span class="p_add">+	wrmsrl(HV_X64_MSR_CRASH_P1, regs-&gt;ax);</span>
<span class="p_add">+	wrmsrl(HV_X64_MSR_CRASH_P2, regs-&gt;bx);</span>
<span class="p_add">+	wrmsrl(HV_X64_MSR_CRASH_P3, regs-&gt;cx);</span>
<span class="p_add">+	wrmsrl(HV_X64_MSR_CRASH_P4, regs-&gt;dx);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Let Hyper-V know there is crash data available</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	wrmsrl(HV_X64_MSR_CRASH_CTL, HV_CRASH_CTL_CRASH_NOTIFY);</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block hyperv_panic_block = {</span>
<span class="p_add">+	.notifier_call = hyperv_panic_event,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 struct resource hyperv_mmio = {
 	.name  = &quot;hyperv mmio&quot;,
 	.flags = IORESOURCE_MEM,
<span class="p_chunk">@@ -711,6 +738,14 @@</span> <span class="p_context"> static int vmbus_bus_init(int irq)</span>
 	if (ret)
 		goto err_alloc;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only register if the crash MSRs are available</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ms_hyperv.features &amp; HV_FEATURE_GUEST_CRASH_MSR_AVAILABLE) {</span>
<span class="p_add">+		atomic_notifier_chain_register(&amp;panic_notifier_list,</span>
<span class="p_add">+					       &amp;hyperv_panic_block);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	vmbus_request_offers();
 
 	return 0;
<span class="p_header">diff --git a/drivers/iio/accel/st_accel_core.c b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">index 53f3262..6805db0 100644</span>
<span class="p_header">--- a/drivers/iio/accel/st_accel_core.c</span>
<span class="p_header">+++ b/drivers/iio/accel/st_accel_core.c</span>
<span class="p_chunk">@@ -465,6 +465,7 @@</span> <span class="p_context"> int st_accel_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;accel_info;
<span class="p_add">+	mutex_init(&amp;adata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/adc/axp288_adc.c b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">index 08bcfb0..56008a8 100644</span>
<span class="p_header">--- a/drivers/iio/adc/axp288_adc.c</span>
<span class="p_header">+++ b/drivers/iio/adc/axp288_adc.c</span>
<span class="p_chunk">@@ -53,39 +53,42 @@</span> <span class="p_context"> static const struct iio_chan_spec const axp288_adc_channels[] = {</span>
 		.channel = 0,
 		.address = AXP288_TS_ADC_H,
 		.datasheet_name = &quot;TS_PIN&quot;,
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_TEMP,
 		.channel = 1,
 		.address = AXP288_PMIC_ADC_H,
 		.datasheet_name = &quot;PMIC_TEMP&quot;,
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_TEMP,
 		.channel = 2,
 		.address = AXP288_GP_ADC_H,
 		.datasheet_name = &quot;GPADC&quot;,
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_CURRENT,
 		.channel = 3,
 		.address = AXP20X_BATT_CHRG_I_H,
 		.datasheet_name = &quot;BATT_CHG_I&quot;,
<span class="p_del">-		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span>
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_CURRENT,
 		.channel = 4,
 		.address = AXP20X_BATT_DISCHRG_I_H,
 		.datasheet_name = &quot;BATT_DISCHRG_I&quot;,
<span class="p_del">-		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span>
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	}, {
 		.indexed = 1,
 		.type = IIO_VOLTAGE,
 		.channel = 5,
 		.address = AXP20X_BATT_V_H,
 		.datasheet_name = &quot;BATT_V&quot;,
<span class="p_del">-		.info_mask_separate = BIT(IIO_CHAN_INFO_PROCESSED),</span>
<span class="p_add">+		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),</span>
 	},
 };
 
<span class="p_chunk">@@ -151,9 +154,6 @@</span> <span class="p_context"> static int axp288_adc_read_raw(struct iio_dev *indio_dev,</span>
 						chan-&gt;address))
 			dev_err(&amp;indio_dev-&gt;dev, &quot;TS pin restore\n&quot;);
 		break;
<span class="p_del">-	case IIO_CHAN_INFO_PROCESSED:</span>
<span class="p_del">-		ret = axp288_adc_read_channel(val, chan-&gt;address, info-&gt;regmap);</span>
<span class="p_del">-		break;</span>
 	default:
 		ret = -EINVAL;
 	}
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc-core.c b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">index a221f73..ce93bd8 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc-core.c</span>
<span class="p_chunk">@@ -856,6 +856,7 @@</span> <span class="p_context"> static int xadc_read_raw(struct iio_dev *indio_dev,</span>
 			switch (chan-&gt;address) {
 			case XADC_REG_VCCINT:
 			case XADC_REG_VCCAUX:
<span class="p_add">+			case XADC_REG_VREFP:</span>
 			case XADC_REG_VCCBRAM:
 			case XADC_REG_VCCPINT:
 			case XADC_REG_VCCPAUX:
<span class="p_chunk">@@ -996,7 +997,7 @@</span> <span class="p_context"> static const struct iio_event_spec xadc_voltage_events[] = {</span>
 	.num_event_specs = (_alarm) ? ARRAY_SIZE(xadc_voltage_events) : 0, \
 	.scan_index = (_scan_index), \
 	.scan_type = { \
<span class="p_del">-		.sign = &#39;u&#39;, \</span>
<span class="p_add">+		.sign = ((_addr) == XADC_REG_VREFN) ? &#39;s&#39; : &#39;u&#39;, \</span>
 		.realbits = 12, \
 		.storagebits = 16, \
 		.shift = 4, \
<span class="p_chunk">@@ -1008,7 +1009,7 @@</span> <span class="p_context"> static const struct iio_event_spec xadc_voltage_events[] = {</span>
 static const struct iio_chan_spec xadc_channels[] = {
 	XADC_CHAN_TEMP(0, 8, XADC_REG_TEMP),
 	XADC_CHAN_VOLTAGE(0, 9, XADC_REG_VCCINT, &quot;vccint&quot;, true),
<span class="p_del">-	XADC_CHAN_VOLTAGE(1, 10, XADC_REG_VCCINT, &quot;vccaux&quot;, true),</span>
<span class="p_add">+	XADC_CHAN_VOLTAGE(1, 10, XADC_REG_VCCAUX, &quot;vccaux&quot;, true),</span>
 	XADC_CHAN_VOLTAGE(2, 14, XADC_REG_VCCBRAM, &quot;vccbram&quot;, true),
 	XADC_CHAN_VOLTAGE(3, 5, XADC_REG_VCCPINT, &quot;vccpint&quot;, true),
 	XADC_CHAN_VOLTAGE(4, 6, XADC_REG_VCCPAUX, &quot;vccpaux&quot;, true),
<span class="p_header">diff --git a/drivers/iio/adc/xilinx-xadc.h b/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_header">index c7487e8..54adc50 100644</span>
<span class="p_header">--- a/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_header">+++ b/drivers/iio/adc/xilinx-xadc.h</span>
<span class="p_chunk">@@ -145,9 +145,9 @@</span> <span class="p_context"> static inline int xadc_write_adc_reg(struct xadc *xadc, unsigned int reg,</span>
 #define XADC_REG_MAX_VCCPINT	0x28
 #define XADC_REG_MAX_VCCPAUX	0x29
 #define XADC_REG_MAX_VCCO_DDR	0x2a
<span class="p_del">-#define XADC_REG_MIN_VCCPINT	0x2b</span>
<span class="p_del">-#define XADC_REG_MIN_VCCPAUX	0x2c</span>
<span class="p_del">-#define XADC_REG_MIN_VCCO_DDR	0x2d</span>
<span class="p_add">+#define XADC_REG_MIN_VCCPINT	0x2c</span>
<span class="p_add">+#define XADC_REG_MIN_VCCPAUX	0x2d</span>
<span class="p_add">+#define XADC_REG_MIN_VCCO_DDR	0x2e</span>
 
 #define XADC_REG_CONF0		0x40
 #define XADC_REG_CONF1		0x41
<span class="p_header">diff --git a/drivers/iio/common/st_sensors/st_sensors_core.c b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">index edd13d2..8dd0477 100644</span>
<span class="p_header">--- a/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_header">+++ b/drivers/iio/common/st_sensors/st_sensors_core.c</span>
<span class="p_chunk">@@ -304,8 +304,6 @@</span> <span class="p_context"> int st_sensors_init_sensor(struct iio_dev *indio_dev,</span>
 	struct st_sensors_platform_data *of_pdata;
 	int err = 0;
 
<span class="p_del">-	mutex_init(&amp;sdata-&gt;tb.buf_lock);</span>
<span class="p_del">-</span>
 	/* If OF/DT pdata exists, it will take precedence of anything else */
 	of_pdata = st_sensors_of_probe(indio_dev-&gt;dev.parent, pdata);
 	if (of_pdata)
<span class="p_header">diff --git a/drivers/iio/gyro/st_gyro_core.c b/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_header">index f07a233..566f7d2 100644</span>
<span class="p_header">--- a/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_header">+++ b/drivers/iio/gyro/st_gyro_core.c</span>
<span class="p_chunk">@@ -317,6 +317,7 @@</span> <span class="p_context"> int st_gyro_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;gyro_info;
<span class="p_add">+	mutex_init(&amp;gdata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/light/hid-sensor-prox.c b/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_header">index f5a5146..d403c98 100644</span>
<span class="p_header">--- a/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_header">+++ b/drivers/iio/light/hid-sensor-prox.c</span>
<span class="p_chunk">@@ -43,8 +43,6 @@</span> <span class="p_context"> struct prox_state {</span>
 static const struct iio_chan_spec prox_channels[] = {
 	{
 		.type = IIO_PROXIMITY,
<span class="p_del">-		.modified = 1,</span>
<span class="p_del">-		.channel2 = IIO_NO_MOD,</span>
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
 		BIT(IIO_CHAN_INFO_SCALE) |
<span class="p_header">diff --git a/drivers/iio/magnetometer/st_magn_core.c b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">index 8ade473..2e56f81 100644</span>
<span class="p_header">--- a/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_header">+++ b/drivers/iio/magnetometer/st_magn_core.c</span>
<span class="p_chunk">@@ -369,6 +369,7 @@</span> <span class="p_context"> int st_magn_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;magn_info;
<span class="p_add">+	mutex_init(&amp;mdata-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/iio/pressure/hid-sensor-press.c b/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_header">index 7649286..127db53 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/hid-sensor-press.c</span>
<span class="p_chunk">@@ -47,8 +47,6 @@</span> <span class="p_context"> struct press_state {</span>
 static const struct iio_chan_spec press_channels[] = {
 	{
 		.type = IIO_PRESSURE,
<span class="p_del">-		.modified = 1,</span>
<span class="p_del">-		.channel2 = IIO_NO_MOD,</span>
 		.info_mask_separate = BIT(IIO_CHAN_INFO_RAW),
 		.info_mask_shared_by_type = BIT(IIO_CHAN_INFO_OFFSET) |
 		BIT(IIO_CHAN_INFO_SCALE) |
<span class="p_header">diff --git a/drivers/iio/pressure/st_pressure_core.c b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">index 97baf40d..e881fa6 100644</span>
<span class="p_header">--- a/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_header">+++ b/drivers/iio/pressure/st_pressure_core.c</span>
<span class="p_chunk">@@ -417,6 +417,7 @@</span> <span class="p_context"> int st_press_common_probe(struct iio_dev *indio_dev)</span>
 
 	indio_dev-&gt;modes = INDIO_DIRECT_MODE;
 	indio_dev-&gt;info = &amp;press_info;
<span class="p_add">+	mutex_init(&amp;press_data-&gt;tb.buf_lock);</span>
 
 	st_sensors_power_enable(indio_dev);
 
<span class="p_header">diff --git a/drivers/infiniband/core/iwpm_msg.c b/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_header">index b85ddbc..e5558b2 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/iwpm_msg.c</span>
<span class="p_chunk">@@ -33,7 +33,7 @@</span> <span class="p_context"></span>
 
 #include &quot;iwpm_util.h&quot;
 
<span class="p_del">-static const char iwpm_ulib_name[] = &quot;iWarpPortMapperUser&quot;;</span>
<span class="p_add">+static const char iwpm_ulib_name[IWPM_ULIBNAME_SIZE] = &quot;iWarpPortMapperUser&quot;;</span>
 static int iwpm_ulib_version = 3;
 static int iwpm_user_pid = IWPM_PID_UNDEFINED;
 static atomic_t echo_nlmsg_seq;
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 991dc6b..79363b6 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -315,7 +315,7 @@</span> <span class="p_context"> static void elantech_report_semi_mt_data(struct input_dev *dev,</span>
 					 unsigned int x2, unsigned int y2)
 {
 	elantech_set_slot(dev, 0, num_fingers != 0, x1, y1);
<span class="p_del">-	elantech_set_slot(dev, 1, num_fingers == 2, x2, y2);</span>
<span class="p_add">+	elantech_set_slot(dev, 1, num_fingers &gt;= 2, x2, y2);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/md/raid5.c b/drivers/md/raid5.c</span>
<span class="p_header">index 8577cc7..e421016 100644</span>
<span class="p_header">--- a/drivers/md/raid5.c</span>
<span class="p_header">+++ b/drivers/md/raid5.c</span>
<span class="p_chunk">@@ -1936,7 +1936,8 @@</span> <span class="p_context"> static int resize_stripes(struct r5conf *conf, int newsize)</span>
 
 	conf-&gt;slab_cache = sc;
 	conf-&gt;active_name = 1-conf-&gt;active_name;
<span class="p_del">-	conf-&gt;pool_size = newsize;</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		conf-&gt;pool_size = newsize;</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/mmc/host/atmel-mci.c b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">index 03d7c75..9a39e0b 100644</span>
<span class="p_header">--- a/drivers/mmc/host/atmel-mci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/atmel-mci.c</span>
<span class="p_chunk">@@ -1304,7 +1304,7 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 
 	if (ios-&gt;clock) {
 		unsigned int clock_min = ~0U;
<span class="p_del">-		u32 clkdiv;</span>
<span class="p_add">+		int clkdiv;</span>
 
 		spin_lock_bh(&amp;host-&gt;lock);
 		if (!host-&gt;mode_reg) {
<span class="p_chunk">@@ -1328,7 +1328,12 @@</span> <span class="p_context"> static void atmci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 		/* Calculate clock divider */
 		if (host-&gt;caps.has_odd_clk_div) {
 			clkdiv = DIV_ROUND_UP(host-&gt;bus_hz, clock_min) - 2;
<span class="p_del">-			if (clkdiv &gt; 511) {</span>
<span class="p_add">+			if (clkdiv &lt; 0) {</span>
<span class="p_add">+				dev_warn(&amp;mmc-&gt;class_dev,</span>
<span class="p_add">+					 &quot;clock %u too fast; using %lu\n&quot;,</span>
<span class="p_add">+					 clock_min, host-&gt;bus_hz / 2);</span>
<span class="p_add">+				clkdiv = 0;</span>
<span class="p_add">+			} else if (clkdiv &gt; 511) {</span>
 				dev_warn(&amp;mmc-&gt;class_dev,
 				         &quot;clock %u too slow; using %lu\n&quot;,
 				         clock_min, host-&gt;bus_hz / (511 + 2));
<span class="p_header">diff --git a/drivers/net/bonding/bond_options.c b/drivers/net/bonding/bond_options.c</span>
<span class="p_header">index 1a61cc9..37fcadc 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_options.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_options.c</span>
<span class="p_chunk">@@ -625,7 +625,7 @@</span> <span class="p_context"> int __bond_opt_set(struct bonding *bond,</span>
 out:
 	if (ret)
 		bond_opt_error_interpret(bond, opt, ret, val);
<span class="p_del">-	else</span>
<span class="p_add">+	else if (bond-&gt;dev-&gt;reg_state == NETREG_REGISTERED)</span>
 		call_netdevice_notifiers(NETDEV_CHANGEINFODATA, bond-&gt;dev);
 
 	return ret;
<span class="p_header">diff --git a/drivers/net/can/xilinx_can.c b/drivers/net/can/xilinx_can.c</span>
<span class="p_header">index 6c67643..0b27769 100644</span>
<span class="p_header">--- a/drivers/net/can/xilinx_can.c</span>
<span class="p_header">+++ b/drivers/net/can/xilinx_can.c</span>
<span class="p_chunk">@@ -509,10 +509,11 @@</span> <span class="p_context"> static int xcan_rx(struct net_device *ndev)</span>
 			cf-&gt;can_id |= CAN_RTR_FLAG;
 	}
 
<span class="p_del">-	if (!(id_xcan &amp; XCAN_IDR_SRR_MASK)) {</span>
<span class="p_del">-		data[0] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW1_OFFSET);</span>
<span class="p_del">-		data[1] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW2_OFFSET);</span>
<span class="p_add">+	/* DW1/DW2 must always be read to remove message from RXFIFO */</span>
<span class="p_add">+	data[0] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW1_OFFSET);</span>
<span class="p_add">+	data[1] = priv-&gt;read_reg(priv, XCAN_RXFIFO_DW2_OFFSET);</span>
 
<span class="p_add">+	if (!(cf-&gt;can_id &amp; CAN_RTR_FLAG)) {</span>
 		/* Change Xilinx CAN data format to socketCAN data format */
 		if (cf-&gt;can_dlc &gt; 0)
 			*(__be32 *)(cf-&gt;data) = cpu_to_be32(data[0]);
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_cmds.c b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">index fead5c6..9c827b7 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_cmds.c</span>
<span class="p_chunk">@@ -1705,9 +1705,9 @@</span> <span class="p_context"> int be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf)</span>
 	total_size = buf_len;
 
 	get_fat_cmd.size = sizeof(struct be_cmd_req_get_fat) + 60*1024;
<span class="p_del">-	get_fat_cmd.va = pci_alloc_consistent(adapter-&gt;pdev,</span>
<span class="p_del">-					      get_fat_cmd.size,</span>
<span class="p_del">-					      &amp;get_fat_cmd.dma);</span>
<span class="p_add">+	get_fat_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					     get_fat_cmd.size,</span>
<span class="p_add">+					     &amp;get_fat_cmd.dma, GFP_ATOMIC);</span>
 	if (!get_fat_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
 			&quot;Memory allocation failure while reading FAT data\n&quot;);
<span class="p_chunk">@@ -1752,8 +1752,8 @@</span> <span class="p_context"> int be_cmd_get_regs(struct be_adapter *adapter, u32 buf_len, void *buf)</span>
 		log_offset += buf_size;
 	}
 err:
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, get_fat_cmd.size,</span>
<span class="p_del">-			    get_fat_cmd.va, get_fat_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, get_fat_cmd.size,</span>
<span class="p_add">+			  get_fat_cmd.va, get_fat_cmd.dma);</span>
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
 	return status;
 }
<span class="p_chunk">@@ -2223,12 +2223,12 @@</span> <span class="p_context"> int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,</span>
 		return -EINVAL;
 
 	cmd.size = sizeof(struct be_cmd_resp_port_type);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory allocation failed\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_del">-	memset(cmd.va, 0, cmd.size);</span>
 
 	spin_lock_bh(&amp;adapter-&gt;mcc_lock);
 
<span class="p_chunk">@@ -2253,7 +2253,7 @@</span> <span class="p_context"> int be_cmd_read_port_transceiver_data(struct be_adapter *adapter,</span>
 	}
 err:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va, cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -2702,7 +2702,8 @@</span> <span class="p_context"> int be_cmd_get_phy_info(struct be_adapter *adapter)</span>
 		goto err;
 	}
 	cmd.size = sizeof(struct be_cmd_req_get_phy_info);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory alloc failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -2736,7 +2737,7 @@</span> <span class="p_context"> int be_cmd_get_phy_info(struct be_adapter *adapter)</span>
 				BE_SUPPORTED_SPEED_1GBPS;
 		}
 	}
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va, cmd.dma);</span>
 err:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
 	return status;
<span class="p_chunk">@@ -2787,8 +2788,9 @@</span> <span class="p_context"> int be_cmd_get_cntl_attributes(struct be_adapter *adapter)</span>
 
 	memset(&amp;attribs_cmd, 0, sizeof(struct be_dma_mem));
 	attribs_cmd.size = sizeof(struct be_cmd_resp_cntl_attribs);
<span class="p_del">-	attribs_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, attribs_cmd.size,</span>
<span class="p_del">-					      &amp;attribs_cmd.dma);</span>
<span class="p_add">+	attribs_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					     attribs_cmd.size,</span>
<span class="p_add">+					     &amp;attribs_cmd.dma, GFP_ATOMIC);</span>
 	if (!attribs_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory allocation failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -2815,8 +2817,8 @@</span> <span class="p_context"> int be_cmd_get_cntl_attributes(struct be_adapter *adapter)</span>
 err:
 	mutex_unlock(&amp;adapter-&gt;mbox_lock);
 	if (attribs_cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, attribs_cmd.size,</span>
<span class="p_del">-				    attribs_cmd.va, attribs_cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, attribs_cmd.size,</span>
<span class="p_add">+				  attribs_cmd.va, attribs_cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -2954,9 +2956,10 @@</span> <span class="p_context"> int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,</span>
 
 	memset(&amp;get_mac_list_cmd, 0, sizeof(struct be_dma_mem));
 	get_mac_list_cmd.size = sizeof(struct be_cmd_resp_get_mac_list);
<span class="p_del">-	get_mac_list_cmd.va = pci_alloc_consistent(adapter-&gt;pdev,</span>
<span class="p_del">-						   get_mac_list_cmd.size,</span>
<span class="p_del">-						   &amp;get_mac_list_cmd.dma);</span>
<span class="p_add">+	get_mac_list_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+						  get_mac_list_cmd.size,</span>
<span class="p_add">+						  &amp;get_mac_list_cmd.dma,</span>
<span class="p_add">+						  GFP_ATOMIC);</span>
 
 	if (!get_mac_list_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
<span class="p_chunk">@@ -3029,8 +3032,8 @@</span> <span class="p_context"> int be_cmd_get_mac_from_list(struct be_adapter *adapter, u8 *mac,</span>
 
 out:
 	spin_unlock_bh(&amp;adapter-&gt;mcc_lock);
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, get_mac_list_cmd.size,</span>
<span class="p_del">-			    get_mac_list_cmd.va, get_mac_list_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, get_mac_list_cmd.size,</span>
<span class="p_add">+			  get_mac_list_cmd.va, get_mac_list_cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3083,8 +3086,8 @@</span> <span class="p_context"> int be_cmd_set_mac_list(struct be_adapter *adapter, u8 *mac_array,</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_req_set_mac_list);
<span class="p_del">-	cmd.va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size,</span>
<span class="p_del">-				    &amp;cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_KERNEL);</span>
 	if (!cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3255,7 +3258,8 @@</span> <span class="p_context"> int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_acpi_wol_magic_config_v1);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory allocation failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -3290,7 +3294,8 @@</span> <span class="p_context"> int be_cmd_get_acpi_wol_cap(struct be_adapter *adapter)</span>
 err:
 	mutex_unlock(&amp;adapter-&gt;mbox_lock);
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 
 }
<span class="p_chunk">@@ -3304,8 +3309,9 @@</span> <span class="p_context"> int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)</span>
 
 	memset(&amp;extfat_cmd, 0, sizeof(struct be_dma_mem));
 	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
<span class="p_del">-	extfat_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, extfat_cmd.size,</span>
<span class="p_del">-					     &amp;extfat_cmd.dma);</span>
<span class="p_add">+	extfat_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    extfat_cmd.size, &amp;extfat_cmd.dma,</span>
<span class="p_add">+					    GFP_ATOMIC);</span>
 	if (!extfat_cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3327,8 +3333,8 @@</span> <span class="p_context"> int be_cmd_set_fw_log_level(struct be_adapter *adapter, u32 level)</span>
 
 	status = be_cmd_set_ext_fat_capabilites(adapter, &amp;extfat_cmd, cfgs);
 err:
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_del">-			    extfat_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_add">+			  extfat_cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3341,8 +3347,9 @@</span> <span class="p_context"> int be_cmd_get_fw_log_level(struct be_adapter *adapter)</span>
 
 	memset(&amp;extfat_cmd, 0, sizeof(struct be_dma_mem));
 	extfat_cmd.size = sizeof(struct be_cmd_resp_get_ext_fat_caps);
<span class="p_del">-	extfat_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, extfat_cmd.size,</span>
<span class="p_del">-					     &amp;extfat_cmd.dma);</span>
<span class="p_add">+	extfat_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    extfat_cmd.size, &amp;extfat_cmd.dma,</span>
<span class="p_add">+					    GFP_ATOMIC);</span>
 
 	if (!extfat_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;%s: Memory allocation failure\n&quot;,
<span class="p_chunk">@@ -3360,8 +3367,8 @@</span> <span class="p_context"> int be_cmd_get_fw_log_level(struct be_adapter *adapter)</span>
 				level = cfgs-&gt;module[0].trace_lvl[j].dbg_lvl;
 		}
 	}
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_del">-			    extfat_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, extfat_cmd.size, extfat_cmd.va,</span>
<span class="p_add">+			  extfat_cmd.dma);</span>
 err:
 	return level;
 }
<span class="p_chunk">@@ -3567,7 +3574,8 @@</span> <span class="p_context"> int be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_get_func_config);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev, &quot;Memory alloc failure\n&quot;);
 		status = -ENOMEM;
<span class="p_chunk">@@ -3607,7 +3615,8 @@</span> <span class="p_context"> int be_cmd_get_func_config(struct be_adapter *adapter, struct be_resources *res)</span>
 err:
 	mutex_unlock(&amp;adapter-&gt;mbox_lock);
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3628,7 +3637,8 @@</span> <span class="p_context"> int be_cmd_get_profile_config(struct be_adapter *adapter,</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_resp_get_profile_config);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3667,7 +3677,8 @@</span> <span class="p_context"> int be_cmd_get_profile_config(struct be_adapter *adapter,</span>
 		res-&gt;vf_if_cap_flags = vf_res-&gt;cap_flags;
 err:
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 }
 
<span class="p_chunk">@@ -3682,7 +3693,8 @@</span> <span class="p_context"> static int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,</span>
 
 	memset(&amp;cmd, 0, sizeof(struct be_dma_mem));
 	cmd.size = sizeof(struct be_cmd_req_set_profile_config);
<span class="p_del">-	cmd.va = pci_alloc_consistent(adapter-&gt;pdev, cmd.size, &amp;cmd.dma);</span>
<span class="p_add">+	cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, &amp;cmd.dma,</span>
<span class="p_add">+				     GFP_ATOMIC);</span>
 	if (!cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -3698,7 +3710,8 @@</span> <span class="p_context"> static int be_cmd_set_profile_config(struct be_adapter *adapter, void *desc,</span>
 	status = be_cmd_notify_wait(adapter, &amp;wrb);
 
 	if (cmd.va)
<span class="p_del">-		pci_free_consistent(adapter-&gt;pdev, cmd.size, cmd.va, cmd.dma);</span>
<span class="p_add">+		dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, cmd.size, cmd.va,</span>
<span class="p_add">+				  cmd.dma);</span>
 	return status;
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_ethtool.c b/drivers/net/ethernet/emulex/benet/be_ethtool.c</span>
<span class="p_header">index 73a500c..9a5b48b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_ethtool.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_ethtool.c</span>
<span class="p_chunk">@@ -266,8 +266,8 @@</span> <span class="p_context"> static int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,</span>
 	int status = 0;
 
 	read_cmd.size = LANCER_READ_FILE_CHUNK;
<span class="p_del">-	read_cmd.va = pci_alloc_consistent(adapter-&gt;pdev, read_cmd.size,</span>
<span class="p_del">-					   &amp;read_cmd.dma);</span>
<span class="p_add">+	read_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, read_cmd.size,</span>
<span class="p_add">+					  &amp;read_cmd.dma, GFP_ATOMIC);</span>
 
 	if (!read_cmd.va) {
 		dev_err(&amp;adapter-&gt;pdev-&gt;dev,
<span class="p_chunk">@@ -291,8 +291,8 @@</span> <span class="p_context"> static int lancer_cmd_read_file(struct be_adapter *adapter, u8 *file_name,</span>
 			break;
 		}
 	}
<span class="p_del">-	pci_free_consistent(adapter-&gt;pdev, read_cmd.size, read_cmd.va,</span>
<span class="p_del">-			    read_cmd.dma);</span>
<span class="p_add">+	dma_free_coherent(&amp;adapter-&gt;pdev-&gt;dev, read_cmd.size, read_cmd.va,</span>
<span class="p_add">+			  read_cmd.dma);</span>
 
 	return status;
 }
<span class="p_chunk">@@ -818,8 +818,9 @@</span> <span class="p_context"> static int be_test_ddr_dma(struct be_adapter *adapter)</span>
 	};
 
 	ddrdma_cmd.size = sizeof(struct be_cmd_req_ddrdma_test);
<span class="p_del">-	ddrdma_cmd.va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, ddrdma_cmd.size,</span>
<span class="p_del">-					   &amp;ddrdma_cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	ddrdma_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    ddrdma_cmd.size, &amp;ddrdma_cmd.dma,</span>
<span class="p_add">+					    GFP_KERNEL);</span>
 	if (!ddrdma_cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -941,8 +942,9 @@</span> <span class="p_context"> static int be_read_eeprom(struct net_device *netdev,</span>
 
 	memset(&amp;eeprom_cmd, 0, sizeof(struct be_dma_mem));
 	eeprom_cmd.size = sizeof(struct be_cmd_req_seeprom_read);
<span class="p_del">-	eeprom_cmd.va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, eeprom_cmd.size,</span>
<span class="p_del">-					   &amp;eeprom_cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	eeprom_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					    eeprom_cmd.size, &amp;eeprom_cmd.dma,</span>
<span class="p_add">+					    GFP_KERNEL);</span>
 
 	if (!eeprom_cmd.va)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/net/ethernet/emulex/benet/be_main.c b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">index d48806b..8948048 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/emulex/benet/be_main.c</span>
<span class="p_chunk">@@ -4118,8 +4118,8 @@</span> <span class="p_context"> static int lancer_fw_download(struct be_adapter *adapter,</span>
 
 	flash_cmd.size = sizeof(struct lancer_cmd_req_write_object)
 				+ LANCER_FW_DOWNLOAD_CHUNK;
<span class="p_del">-	flash_cmd.va = dma_alloc_coherent(dev, flash_cmd.size,</span>
<span class="p_del">-					  &amp;flash_cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	flash_cmd.va = dma_zalloc_coherent(dev, flash_cmd.size,</span>
<span class="p_add">+					   &amp;flash_cmd.dma, GFP_KERNEL);</span>
 	if (!flash_cmd.va)
 		return -ENOMEM;
 
<span class="p_chunk">@@ -4214,8 +4214,8 @@</span> <span class="p_context"> static int be_fw_download(struct be_adapter *adapter, const struct firmware* fw)</span>
 	int status = 0, i = 0, num_imgs = 0, ufi_type = 0;
 
 	flash_cmd.size = sizeof(struct be_cmd_write_flashrom);
<span class="p_del">-	flash_cmd.va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, flash_cmd.size,</span>
<span class="p_del">-					  &amp;flash_cmd.dma, GFP_KERNEL);</span>
<span class="p_add">+	flash_cmd.va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev, flash_cmd.size,</span>
<span class="p_add">+					   &amp;flash_cmd.dma, GFP_KERNEL);</span>
 	if (!flash_cmd.va) {
 		status = -ENOMEM;
 		goto be_fw_exit;
<span class="p_chunk">@@ -4646,10 +4646,10 @@</span> <span class="p_context"> static int be_ctrl_init(struct be_adapter *adapter)</span>
 		goto done;
 
 	mbox_mem_alloc-&gt;size = sizeof(struct be_mcc_mailbox) + 16;
<span class="p_del">-	mbox_mem_alloc-&gt;va = dma_alloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_del">-						mbox_mem_alloc-&gt;size,</span>
<span class="p_del">-						&amp;mbox_mem_alloc-&gt;dma,</span>
<span class="p_del">-						GFP_KERNEL);</span>
<span class="p_add">+	mbox_mem_alloc-&gt;va = dma_zalloc_coherent(&amp;adapter-&gt;pdev-&gt;dev,</span>
<span class="p_add">+						 mbox_mem_alloc-&gt;size,</span>
<span class="p_add">+						 &amp;mbox_mem_alloc-&gt;dma,</span>
<span class="p_add">+						 GFP_KERNEL);</span>
 	if (!mbox_mem_alloc-&gt;va) {
 		status = -ENOMEM;
 		goto unmap_pci_bars;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index ff59897..032791e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -1036,7 +1036,7 @@</span> <span class="p_context"> static void igb_reset_q_vector(struct igb_adapter *adapter, int v_idx)</span>
 		adapter-&gt;tx_ring[q_vector-&gt;tx.ring-&gt;queue_index] = NULL;
 
 	if (q_vector-&gt;rx.ring)
<span class="p_del">-		adapter-&gt;tx_ring[q_vector-&gt;rx.ring-&gt;queue_index] = NULL;</span>
<span class="p_add">+		adapter-&gt;rx_ring[q_vector-&gt;rx.ring-&gt;queue_index] = NULL;</span>
 
 	netif_napi_del(&amp;q_vector-&gt;napi);
 
<span class="p_chunk">@@ -1207,6 +1207,8 @@</span> <span class="p_context"> static int igb_alloc_q_vector(struct igb_adapter *adapter,</span>
 	q_vector = adapter-&gt;q_vector[v_idx];
 	if (!q_vector)
 		q_vector = kzalloc(size, GFP_KERNEL);
<span class="p_add">+	else</span>
<span class="p_add">+		memset(q_vector, 0, size);</span>
 	if (!q_vector)
 		return -ENOMEM;
 
<span class="p_header">diff --git a/drivers/net/ethernet/qualcomm/qca_spi.c b/drivers/net/ethernet/qualcomm/qca_spi.c</span>
<span class="p_header">index 2c811f6..eacd476 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/qualcomm/qca_spi.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/qualcomm/qca_spi.c</span>
<span class="p_chunk">@@ -913,6 +913,8 @@</span> <span class="p_context"> qca_spi_probe(struct spi_device *spi_device)</span>
 	qca-&gt;spi_dev = spi_device;
 	qca-&gt;legacy_mode = legacy_mode;
 
<span class="p_add">+	spi_set_drvdata(spi_device, qcaspi_devs);</span>
<span class="p_add">+</span>
 	mac = of_get_mac_address(spi_device-&gt;dev.of_node);
 
 	if (mac)
<span class="p_chunk">@@ -945,8 +947,6 @@</span> <span class="p_context"> qca_spi_probe(struct spi_device *spi_device)</span>
 		return -EFAULT;
 	}
 
<span class="p_del">-	spi_set_drvdata(spi_device, qcaspi_devs);</span>
<span class="p_del">-</span>
 	qcaspi_init_device_debugfs(qca);
 
 	return 0;
<span class="p_header">diff --git a/drivers/net/phy/dp83640.c b/drivers/net/phy/dp83640.c</span>
<span class="p_header">index e22e602..c5789cd 100644</span>
<span class="p_header">--- a/drivers/net/phy/dp83640.c</span>
<span class="p_header">+++ b/drivers/net/phy/dp83640.c</span>
<span class="p_chunk">@@ -47,7 +47,7 @@</span> <span class="p_context"></span>
 #define PSF_TX		0x1000
 #define EXT_EVENT	1
 #define CAL_EVENT	7
<span class="p_del">-#define CAL_TRIGGER	7</span>
<span class="p_add">+#define CAL_TRIGGER	1</span>
 #define DP83640_N_PINS	12
 
 #define MII_DP83640_MICR 0x11
<span class="p_chunk">@@ -495,7 +495,9 @@</span> <span class="p_context"> static int ptp_dp83640_enable(struct ptp_clock_info *ptp,</span>
 			else
 				evnt |= EVNT_RISE;
 		}
<span class="p_add">+		mutex_lock(&amp;clock-&gt;extreg_lock);</span>
 		ext_write(0, phydev, PAGE5, PTP_EVNT, evnt);
<span class="p_add">+		mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
 		return 0;
 
 	case PTP_CLK_REQ_PEROUT:
<span class="p_chunk">@@ -531,6 +533,8 @@</span> <span class="p_context"> static u8 status_frame_src[6] = { 0x08, 0x00, 0x17, 0x0B, 0x6B, 0x0F };</span>
 
 static void enable_status_frames(struct phy_device *phydev, bool on)
 {
<span class="p_add">+	struct dp83640_private *dp83640 = phydev-&gt;priv;</span>
<span class="p_add">+	struct dp83640_clock *clock = dp83640-&gt;clock;</span>
 	u16 cfg0 = 0, ver;
 
 	if (on)
<span class="p_chunk">@@ -538,9 +542,13 @@</span> <span class="p_context"> static void enable_status_frames(struct phy_device *phydev, bool on)</span>
 
 	ver = (PSF_PTPVER &amp; VERSIONPTP_MASK) &lt;&lt; VERSIONPTP_SHIFT;
 
<span class="p_add">+	mutex_lock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+</span>
 	ext_write(0, phydev, PAGE5, PSF_CFG0, cfg0);
 	ext_write(0, phydev, PAGE6, PSF_CFG1, ver);
 
<span class="p_add">+	mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+</span>
 	if (!phydev-&gt;attached_dev) {
 		pr_warn(&quot;expected to find an attached netdevice\n&quot;);
 		return;
<span class="p_chunk">@@ -837,7 +845,7 @@</span> <span class="p_context"> static void decode_rxts(struct dp83640_private *dp83640,</span>
 	list_del_init(&amp;rxts-&gt;list);
 	phy2rxts(phy_rxts, rxts);
 
<span class="p_del">-	spin_lock_irqsave(&amp;dp83640-&gt;rx_queue.lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;dp83640-&gt;rx_queue.lock);</span>
 	skb_queue_walk(&amp;dp83640-&gt;rx_queue, skb) {
 		struct dp83640_skb_info *skb_info;
 
<span class="p_chunk">@@ -852,7 +860,7 @@</span> <span class="p_context"> static void decode_rxts(struct dp83640_private *dp83640,</span>
 			break;
 		}
 	}
<span class="p_del">-	spin_unlock_irqrestore(&amp;dp83640-&gt;rx_queue.lock, flags);</span>
<span class="p_add">+	spin_unlock(&amp;dp83640-&gt;rx_queue.lock);</span>
 
 	if (!shhwtstamps)
 		list_add_tail(&amp;rxts-&gt;list, &amp;dp83640-&gt;rxts);
<span class="p_chunk">@@ -1172,11 +1180,18 @@</span> <span class="p_context"> static int dp83640_config_init(struct phy_device *phydev)</span>
 
 	if (clock-&gt;chosen &amp;&amp; !list_empty(&amp;clock-&gt;phylist))
 		recalibrate(clock);
<span class="p_del">-	else</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		mutex_lock(&amp;clock-&gt;extreg_lock);</span>
 		enable_broadcast(phydev, clock-&gt;page, 1);
<span class="p_add">+		mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+	}</span>
 
 	enable_status_frames(phydev, true);
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;clock-&gt;extreg_lock);</span>
 	ext_write(0, phydev, PAGE4, PTP_CTL, PTP_ENABLE);
<span class="p_add">+	mutex_unlock(&amp;clock-&gt;extreg_lock);</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c</span>
<span class="p_header">index 3ad8ca7..96061fc 100644</span>
<span class="p_header">--- a/drivers/net/phy/micrel.c</span>
<span class="p_header">+++ b/drivers/net/phy/micrel.c</span>
<span class="p_chunk">@@ -520,7 +520,8 @@</span> <span class="p_context"> static int kszphy_probe(struct phy_device *phydev)</span>
 	}
 
 	clk = devm_clk_get(&amp;phydev-&gt;dev, &quot;rmii-ref&quot;);
<span class="p_del">-	if (!IS_ERR(clk)) {</span>
<span class="p_add">+	/* NOTE: clk may be NULL if building without CONFIG_HAVE_CLK */</span>
<span class="p_add">+	if (!IS_ERR_OR_NULL(clk)) {</span>
 		unsigned long rate = clk_get_rate(clk);
 		bool rmii_ref_clk_sel_25_mhz;
 
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index dc1f6f0..91d6d03 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -1050,13 +1050,14 @@</span> <span class="p_context"> int phy_init_eee(struct phy_device *phydev, bool clk_stop_enable)</span>
 {
 	/* According to 802.3az,the EEE is supported only in full duplex-mode.
 	 * Also EEE feature is active when core is operating with MII, GMII
<span class="p_del">-	 * or RGMII. Internal PHYs are also allowed to proceed and should</span>
<span class="p_del">-	 * return an error if they do not support EEE.</span>
<span class="p_add">+	 * or RGMII (all kinds). Internal PHYs are also allowed to proceed and</span>
<span class="p_add">+	 * should return an error if they do not support EEE.</span>
 	 */
 	if ((phydev-&gt;duplex == DUPLEX_FULL) &amp;&amp;
 	    ((phydev-&gt;interface == PHY_INTERFACE_MODE_MII) ||
 	    (phydev-&gt;interface == PHY_INTERFACE_MODE_GMII) ||
<span class="p_del">-	    (phydev-&gt;interface == PHY_INTERFACE_MODE_RGMII) ||</span>
<span class="p_add">+	    (phydev-&gt;interface &gt;= PHY_INTERFACE_MODE_RGMII &amp;&amp;</span>
<span class="p_add">+	     phydev-&gt;interface &lt;= PHY_INTERFACE_MODE_RGMII_TXID) ||</span>
 	     phy_is_internal(phydev))) {
 		int eee_lp, eee_cap, eee_adv;
 		u32 lp, cap, adv;
<span class="p_header">diff --git a/drivers/net/usb/cdc_ncm.c b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">index c3e4da9..8067b8f 100644</span>
<span class="p_header">--- a/drivers/net/usb/cdc_ncm.c</span>
<span class="p_header">+++ b/drivers/net/usb/cdc_ncm.c</span>
<span class="p_chunk">@@ -1182,7 +1182,7 @@</span> <span class="p_context"> cdc_ncm_fill_tx_frame(struct usbnet *dev, struct sk_buff *skb, __le32 sign)</span>
 	 * payload data instead.
 	 */
 	usbnet_set_skb_tx_stats(skb_out, n,
<span class="p_del">-				ctx-&gt;tx_curr_frame_payload - skb_out-&gt;len);</span>
<span class="p_add">+				(long)ctx-&gt;tx_curr_frame_payload - skb_out-&gt;len);</span>
 
 	return skb_out;
 
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/pcie/trans.c b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">index 523fe0c..936b927 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/pcie/trans.c</span>
<span class="p_chunk">@@ -5,8 +5,8 @@</span> <span class="p_context"></span>
  *
  * GPL LICENSE SUMMARY
  *
<span class="p_del">- * Copyright(c) 2007 - 2014 Intel Corporation. All rights reserved.</span>
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2007 - 2015 Intel Corporation. All rights reserved.</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of version 2 of the GNU General Public License as
<span class="p_chunk">@@ -31,8 +31,8 @@</span> <span class="p_context"></span>
  *
  * BSD LICENSE
  *
<span class="p_del">- * Copyright(c) 2005 - 2014 Intel Corporation. All rights reserved.</span>
<span class="p_del">- * Copyright(c) 2013 - 2014 Intel Mobile Communications GmbH</span>
<span class="p_add">+ * Copyright(c) 2005 - 2015 Intel Corporation. All rights reserved.</span>
<span class="p_add">+ * Copyright(c) 2013 - 2015 Intel Mobile Communications GmbH</span>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
<span class="p_chunk">@@ -103,7 +103,7 @@</span> <span class="p_context"> static void iwl_pcie_free_fw_monitor(struct iwl_trans *trans)</span>
 static void iwl_pcie_alloc_fw_monitor(struct iwl_trans *trans)
 {
 	struct iwl_trans_pcie *trans_pcie = IWL_TRANS_GET_PCIE_TRANS(trans);
<span class="p_del">-	struct page *page;</span>
<span class="p_add">+	struct page *page = NULL;</span>
 	dma_addr_t phys;
 	u32 size;
 	u8 power;
<span class="p_chunk">@@ -130,6 +130,7 @@</span> <span class="p_context"> static void iwl_pcie_alloc_fw_monitor(struct iwl_trans *trans)</span>
 				    DMA_FROM_DEVICE);
 		if (dma_mapping_error(trans-&gt;dev, phys)) {
 			__free_pages(page, order);
<span class="p_add">+			page = NULL;</span>
 			continue;
 		}
 		IWL_INFO(trans,
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/usb.c b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">index 46ee956..27cd6ca 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/usb.c</span>
<span class="p_chunk">@@ -126,7 +126,7 @@</span> <span class="p_context"> static int _usbctrl_vendorreq_sync_read(struct usb_device *udev, u8 request,</span>
 
 	do {
 		status = usb_control_msg(udev, pipe, request, reqtype, value,
<span class="p_del">-					 index, pdata, len, 0); /*max. timeout*/</span>
<span class="p_add">+					 index, pdata, len, 1000);</span>
 		if (status &lt; 0) {
 			/* firmware download is checksumed, don&#39;t retry */
 			if ((value &gt;= FW_8192C_START_ADDRESS &amp;&amp;
<span class="p_header">diff --git a/drivers/net/xen-netback/xenbus.c b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">index 794204e..152131a 100644</span>
<span class="p_header">--- a/drivers/net/xen-netback/xenbus.c</span>
<span class="p_header">+++ b/drivers/net/xen-netback/xenbus.c</span>
<span class="p_chunk">@@ -34,6 +34,8 @@</span> <span class="p_context"> struct backend_info {</span>
 	enum xenbus_state frontend_state;
 	struct xenbus_watch hotplug_status_watch;
 	u8 have_hotplug_status_watch:1;
<span class="p_add">+</span>
<span class="p_add">+	const char *hotplug_script;</span>
 };
 
 static int connect_rings(struct backend_info *be, struct xenvif_queue *queue);
<span class="p_chunk">@@ -236,6 +238,7 @@</span> <span class="p_context"> static int netback_remove(struct xenbus_device *dev)</span>
 		xenvif_free(be-&gt;vif);
 		be-&gt;vif = NULL;
 	}
<span class="p_add">+	kfree(be-&gt;hotplug_script);</span>
 	kfree(be);
 	dev_set_drvdata(&amp;dev-&gt;dev, NULL);
 	return 0;
<span class="p_chunk">@@ -253,6 +256,7 @@</span> <span class="p_context"> static int netback_probe(struct xenbus_device *dev,</span>
 	struct xenbus_transaction xbt;
 	int err;
 	int sg;
<span class="p_add">+	const char *script;</span>
 	struct backend_info *be = kzalloc(sizeof(struct backend_info),
 					  GFP_KERNEL);
 	if (!be) {
<span class="p_chunk">@@ -345,6 +349,15 @@</span> <span class="p_context"> static int netback_probe(struct xenbus_device *dev,</span>
 	if (err)
 		pr_debug(&quot;Error writing multi-queue-max-queues\n&quot;);
 
<span class="p_add">+	script = xenbus_read(XBT_NIL, dev-&gt;nodename, &quot;script&quot;, NULL);</span>
<span class="p_add">+	if (IS_ERR(script)) {</span>
<span class="p_add">+		err = PTR_ERR(script);</span>
<span class="p_add">+		xenbus_dev_fatal(dev, err, &quot;reading script&quot;);</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	be-&gt;hotplug_script = script;</span>
<span class="p_add">+</span>
 	err = xenbus_switch_state(dev, XenbusStateInitWait);
 	if (err)
 		goto fail;
<span class="p_chunk">@@ -377,22 +390,14 @@</span> <span class="p_context"> static int netback_uevent(struct xenbus_device *xdev,</span>
 			  struct kobj_uevent_env *env)
 {
 	struct backend_info *be = dev_get_drvdata(&amp;xdev-&gt;dev);
<span class="p_del">-	char *val;</span>
 
<span class="p_del">-	val = xenbus_read(XBT_NIL, xdev-&gt;nodename, &quot;script&quot;, NULL);</span>
<span class="p_del">-	if (IS_ERR(val)) {</span>
<span class="p_del">-		int err = PTR_ERR(val);</span>
<span class="p_del">-		xenbus_dev_fatal(xdev, err, &quot;reading script&quot;);</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (add_uevent_var(env, &quot;script=%s&quot;, val)) {</span>
<span class="p_del">-			kfree(val);</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		kfree(val);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (!be)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (add_uevent_var(env, &quot;script=%s&quot;, be-&gt;hotplug_script))</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-	if (!be || !be-&gt;vif)</span>
<span class="p_add">+	if (!be-&gt;vif)</span>
 		return 0;
 
 	return add_uevent_var(env, &quot;vif=%s&quot;, be-&gt;vif-&gt;dev-&gt;name);
<span class="p_chunk">@@ -736,6 +741,7 @@</span> <span class="p_context"> static void connect(struct backend_info *be)</span>
 			goto err;
 		}
 
<span class="p_add">+		queue-&gt;credit_bytes = credit_bytes;</span>
 		queue-&gt;remaining_credit = credit_bytes;
 		queue-&gt;credit_usec = credit_usec;
 
<span class="p_header">diff --git a/drivers/power/reset/at91-reset.c b/drivers/power/reset/at91-reset.c</span>
<span class="p_header">index 69a75d99..3f7d20f 100644</span>
<span class="p_header">--- a/drivers/power/reset/at91-reset.c</span>
<span class="p_header">+++ b/drivers/power/reset/at91-reset.c</span>
<span class="p_chunk">@@ -205,9 +205,9 @@</span> <span class="p_context"> static int at91_reset_platform_probe(struct platform_device *pdev)</span>
 		res = platform_get_resource(pdev, IORESOURCE_MEM, idx + 1 );
 		at91_ramc_base[idx] = devm_ioremap(&amp;pdev-&gt;dev, res-&gt;start,
 						   resource_size(res));
<span class="p_del">-		if (IS_ERR(at91_ramc_base[idx])) {</span>
<span class="p_add">+		if (!at91_ramc_base[idx]) {</span>
 			dev_err(&amp;pdev-&gt;dev, &quot;Could not map ram controller address\n&quot;);
<span class="p_del">-			return PTR_ERR(at91_ramc_base[idx]);</span>
<span class="p_add">+			return -ENOMEM;</span>
 		}
 	}
 
<span class="p_header">diff --git a/drivers/scsi/sd.c b/drivers/scsi/sd.c</span>
<span class="p_header">index ad35ccd..7f71d7d 100644</span>
<span class="p_header">--- a/drivers/scsi/sd.c</span>
<span class="p_header">+++ b/drivers/scsi/sd.c</span>
<span class="p_chunk">@@ -1624,6 +1624,7 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 {
 	u64 start_lba = blk_rq_pos(scmd-&gt;request);
 	u64 end_lba = blk_rq_pos(scmd-&gt;request) + (scsi_bufflen(scmd) / 512);
<span class="p_add">+	u64 factor = scmd-&gt;device-&gt;sector_size / 512;</span>
 	u64 bad_lba;
 	int info_valid;
 	/*
<span class="p_chunk">@@ -1645,16 +1646,9 @@</span> <span class="p_context"> static unsigned int sd_completed_bytes(struct scsi_cmnd *scmd)</span>
 	if (scsi_bufflen(scmd) &lt;= scmd-&gt;device-&gt;sector_size)
 		return 0;
 
<span class="p_del">-	if (scmd-&gt;device-&gt;sector_size &lt; 512) {</span>
<span class="p_del">-		/* only legitimate sector_size here is 256 */</span>
<span class="p_del">-		start_lba &lt;&lt;= 1;</span>
<span class="p_del">-		end_lba &lt;&lt;= 1;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		/* be careful ... don&#39;t want any overflows */</span>
<span class="p_del">-		unsigned int factor = scmd-&gt;device-&gt;sector_size / 512;</span>
<span class="p_del">-		do_div(start_lba, factor);</span>
<span class="p_del">-		do_div(end_lba, factor);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* be careful ... don&#39;t want any overflows */</span>
<span class="p_add">+	do_div(start_lba, factor);</span>
<span class="p_add">+	do_div(end_lba, factor);</span>
 
 	/* The bad lba was reported incorrectly, we have no idea where
 	 * the error is.
<span class="p_chunk">@@ -2212,8 +2206,7 @@</span> <span class="p_context"> got_data:</span>
 	if (sector_size != 512 &amp;&amp;
 	    sector_size != 1024 &amp;&amp;
 	    sector_size != 2048 &amp;&amp;
<span class="p_del">-	    sector_size != 4096 &amp;&amp;</span>
<span class="p_del">-	    sector_size != 256) {</span>
<span class="p_add">+	    sector_size != 4096) {</span>
 		sd_printk(KERN_NOTICE, sdkp, &quot;Unsupported sector size %d.\n&quot;,
 			  sector_size);
 		/*
<span class="p_chunk">@@ -2268,8 +2261,6 @@</span> <span class="p_context"> got_data:</span>
 		sdkp-&gt;capacity &lt;&lt;= 2;
 	else if (sector_size == 1024)
 		sdkp-&gt;capacity &lt;&lt;= 1;
<span class="p_del">-	else if (sector_size == 256)</span>
<span class="p_del">-		sdkp-&gt;capacity &gt;&gt;= 1;</span>
 
 	blk_queue_physical_block_size(sdp-&gt;request_queue,
 				      sdkp-&gt;physical_block_size);
<span class="p_header">diff --git a/drivers/scsi/storvsc_drv.c b/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">index 3483b1d..8d0824d 100644</span>
<span class="p_header">--- a/drivers/scsi/storvsc_drv.c</span>
<span class="p_header">+++ b/drivers/scsi/storvsc_drv.c</span>
<span class="p_chunk">@@ -1623,8 +1623,7 @@</span> <span class="p_context"> static int storvsc_queuecommand(struct Scsi_Host *host, struct scsi_cmnd *scmnd)</span>
 		break;
 	default:
 		vm_srb-&gt;data_in = UNKNOWN_TYPE;
<span class="p_del">-		vm_srb-&gt;win8_extension.srb_flags |= (SRB_FLAGS_DATA_IN |</span>
<span class="p_del">-						     SRB_FLAGS_DATA_OUT);</span>
<span class="p_add">+		vm_srb-&gt;win8_extension.srb_flags |= SRB_FLAGS_NO_DATA_TRANSFER;</span>
 		break;
 	}
 
<span class="p_header">diff --git a/drivers/spi/spi-bitbang.c b/drivers/spi/spi-bitbang.c</span>
<span class="p_header">index dc7d2c2..fecdda2 100644</span>
<span class="p_header">--- a/drivers/spi/spi-bitbang.c</span>
<span class="p_header">+++ b/drivers/spi/spi-bitbang.c</span>
<span class="p_chunk">@@ -184,7 +184,6 @@</span> <span class="p_context"> int spi_bitbang_setup(struct spi_device *spi)</span>
 {
 	struct spi_bitbang_cs	*cs = spi-&gt;controller_state;
 	struct spi_bitbang	*bitbang;
<span class="p_del">-	int			retval;</span>
 	unsigned long		flags;
 
 	bitbang = spi_master_get_devdata(spi-&gt;master);
<span class="p_chunk">@@ -201,9 +200,11 @@</span> <span class="p_context"> int spi_bitbang_setup(struct spi_device *spi)</span>
 	if (!cs-&gt;txrx_word)
 		return -EINVAL;
 
<span class="p_del">-	retval = bitbang-&gt;setup_transfer(spi, NULL);</span>
<span class="p_del">-	if (retval &lt; 0)</span>
<span class="p_del">-		return retval;</span>
<span class="p_add">+	if (bitbang-&gt;setup_transfer) {</span>
<span class="p_add">+		int retval = bitbang-&gt;setup_transfer(spi, NULL);</span>
<span class="p_add">+		if (retval &lt; 0)</span>
<span class="p_add">+			return retval;</span>
<span class="p_add">+	}</span>
 
 	dev_dbg(&amp;spi-&gt;dev, &quot;%s, %u nsec/bit\n&quot;, __func__, 2 * cs-&gt;nsecs);
 
<span class="p_chunk">@@ -299,9 +300,11 @@</span> <span class="p_context"> static int spi_bitbang_transfer_one(struct spi_master *master,</span>
 
 		/* init (-1) or override (1) transfer params */
 		if (do_setup != 0) {
<span class="p_del">-			status = bitbang-&gt;setup_transfer(spi, t);</span>
<span class="p_del">-			if (status &lt; 0)</span>
<span class="p_del">-				break;</span>
<span class="p_add">+			if (bitbang-&gt;setup_transfer) {</span>
<span class="p_add">+				status = bitbang-&gt;setup_transfer(spi, t);</span>
<span class="p_add">+				if (status &lt; 0)</span>
<span class="p_add">+					break;</span>
<span class="p_add">+			}</span>
 			if (do_setup == -1)
 				do_setup = 0;
 		}
<span class="p_header">diff --git a/drivers/staging/gdm724x/gdm_mux.c b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">index b5b063a..fe41044 100644</span>
<span class="p_header">--- a/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_header">+++ b/drivers/staging/gdm724x/gdm_mux.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 	unsigned int start_flag;
 	unsigned int payload_size;
 	unsigned short packet_type;
<span class="p_del">-	int dummy_cnt;</span>
<span class="p_add">+	int total_len;</span>
 	u32 packet_size_sum = r-&gt;offset;
 	int index;
 	int ret = TO_HOST_INVALID_PACKET;
<span class="p_chunk">@@ -176,10 +176,10 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 			break;
 		}
 
<span class="p_del">-		dummy_cnt = ALIGN(MUX_HEADER_SIZE + payload_size, 4);</span>
<span class="p_add">+		total_len = ALIGN(MUX_HEADER_SIZE + payload_size, 4);</span>
 
 		if (len - packet_size_sum &lt;
<span class="p_del">-			MUX_HEADER_SIZE + payload_size + dummy_cnt) {</span>
<span class="p_add">+			total_len) {</span>
 			pr_err(&quot;invalid payload : %d %d %04x\n&quot;,
 			       payload_size, len, packet_type);
 			break;
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static int up_to_host(struct mux_rx *r)</span>
 			break;
 		}
 
<span class="p_del">-		packet_size_sum += MUX_HEADER_SIZE + payload_size + dummy_cnt;</span>
<span class="p_add">+		packet_size_sum += total_len;</span>
 		if (len - packet_size_sum &lt;= MUX_HEADER_SIZE + 2) {
 			ret = r-&gt;callback(NULL,
 					0,
<span class="p_chunk">@@ -361,7 +361,6 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 	struct mux_pkt_header *mux_header;
 	struct mux_tx *t = NULL;
 	static u32 seq_num = 1;
<span class="p_del">-	int dummy_cnt;</span>
 	int total_len;
 	int ret;
 	unsigned long flags;
<span class="p_chunk">@@ -374,9 +373,7 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 
 	spin_lock_irqsave(&amp;mux_dev-&gt;write_lock, flags);
 
<span class="p_del">-	dummy_cnt = ALIGN(MUX_HEADER_SIZE + len, 4);</span>
<span class="p_del">-</span>
<span class="p_del">-	total_len = len + MUX_HEADER_SIZE + dummy_cnt;</span>
<span class="p_add">+	total_len = ALIGN(MUX_HEADER_SIZE + len, 4);</span>
 
 	t = alloc_mux_tx(total_len);
 	if (!t) {
<span class="p_chunk">@@ -392,7 +389,8 @@</span> <span class="p_context"> static int gdm_mux_send(void *priv_dev, void *data, int len, int tty_index,</span>
 	mux_header-&gt;packet_type = __cpu_to_le16(packet_type[tty_index]);
 
 	memcpy(t-&gt;buf+MUX_HEADER_SIZE, data, len);
<span class="p_del">-	memset(t-&gt;buf+MUX_HEADER_SIZE+len, 0, dummy_cnt);</span>
<span class="p_add">+	memset(t-&gt;buf+MUX_HEADER_SIZE+len, 0, total_len - MUX_HEADER_SIZE -</span>
<span class="p_add">+	       len);</span>
 
 	t-&gt;len = total_len;
 	t-&gt;callback = cb;
<span class="p_header">diff --git a/drivers/staging/ozwpan/ozhcd.c b/drivers/staging/ozwpan/ozhcd.c</span>
<span class="p_header">index 8543bb2..9737a97 100644</span>
<span class="p_header">--- a/drivers/staging/ozwpan/ozhcd.c</span>
<span class="p_header">+++ b/drivers/staging/ozwpan/ozhcd.c</span>
<span class="p_chunk">@@ -743,8 +743,8 @@</span> <span class="p_context"> void oz_hcd_pd_reset(void *hpd, void *hport)</span>
 /*
  * Context: softirq
  */
<span class="p_del">-void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,</span>
<span class="p_del">-			int length, int offset, int total_size)</span>
<span class="p_add">+void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status, const u8 *desc,</span>
<span class="p_add">+			u8 length, u16 offset, u16 total_size)</span>
 {
 	struct oz_port *port = hport;
 	struct urb *urb;
<span class="p_chunk">@@ -756,8 +756,8 @@</span> <span class="p_context"> void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status, const u8 *desc,</span>
 	if (!urb)
 		return;
 	if (status == 0) {
<span class="p_del">-		int copy_len;</span>
<span class="p_del">-		int required_size = urb-&gt;transfer_buffer_length;</span>
<span class="p_add">+		unsigned int copy_len;</span>
<span class="p_add">+		unsigned int required_size = urb-&gt;transfer_buffer_length;</span>
 
 		if (required_size &gt; total_size)
 			required_size = total_size;
<span class="p_header">diff --git a/drivers/staging/ozwpan/ozusbif.h b/drivers/staging/ozwpan/ozusbif.h</span>
<span class="p_header">index 4249fa3..d2a6085 100644</span>
<span class="p_header">--- a/drivers/staging/ozwpan/ozusbif.h</span>
<span class="p_header">+++ b/drivers/staging/ozwpan/ozusbif.h</span>
<span class="p_chunk">@@ -29,8 +29,8 @@</span> <span class="p_context"> void oz_usb_request_heartbeat(void *hpd);</span>
 
 /* Confirmation functions.
  */
<span class="p_del">-void oz_hcd_get_desc_cnf(void *hport, u8 req_id, int status,</span>
<span class="p_del">-	const u8 *desc, int length, int offset, int total_size);</span>
<span class="p_add">+void oz_hcd_get_desc_cnf(void *hport, u8 req_id, u8 status,</span>
<span class="p_add">+	const u8 *desc, u8 length, u16 offset, u16 total_size);</span>
 void oz_hcd_control_cnf(void *hport, u8 req_id, u8 rcode,
 	const u8 *data, int data_len);
 
<span class="p_header">diff --git a/drivers/staging/ozwpan/ozusbsvc1.c b/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_header">index d434d8c..f660bb1 100644</span>
<span class="p_header">--- a/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_header">+++ b/drivers/staging/ozwpan/ozusbsvc1.c</span>
<span class="p_chunk">@@ -326,7 +326,11 @@</span> <span class="p_context"> static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,</span>
 			struct oz_multiple_fixed *body =
 				(struct oz_multiple_fixed *)data_hdr;
 			u8 *data = body-&gt;data;
<span class="p_del">-			int n = (len - sizeof(struct oz_multiple_fixed)+1)</span>
<span class="p_add">+			unsigned int n;</span>
<span class="p_add">+			if (!body-&gt;unit_size ||</span>
<span class="p_add">+				len &lt; sizeof(struct oz_multiple_fixed) - 1)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			n = (len - (sizeof(struct oz_multiple_fixed) - 1))</span>
 				/ body-&gt;unit_size;
 			while (n--) {
 				oz_hcd_data_ind(usb_ctx-&gt;hport, body-&gt;endpoint,
<span class="p_chunk">@@ -390,10 +394,15 @@</span> <span class="p_context"> void oz_usb_rx(struct oz_pd *pd, struct oz_elt *elt)</span>
 	case OZ_GET_DESC_RSP: {
 			struct oz_get_desc_rsp *body =
 				(struct oz_get_desc_rsp *)usb_hdr;
<span class="p_del">-			int data_len = elt-&gt;length -</span>
<span class="p_del">-					sizeof(struct oz_get_desc_rsp) + 1;</span>
<span class="p_del">-			u16 offs = le16_to_cpu(get_unaligned(&amp;body-&gt;offset));</span>
<span class="p_del">-			u16 total_size =</span>
<span class="p_add">+			u16 offs, total_size;</span>
<span class="p_add">+			u8 data_len;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (elt-&gt;length &lt; sizeof(struct oz_get_desc_rsp) - 1)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			data_len = elt-&gt;length -</span>
<span class="p_add">+					(sizeof(struct oz_get_desc_rsp) - 1);</span>
<span class="p_add">+			offs = le16_to_cpu(get_unaligned(&amp;body-&gt;offset));</span>
<span class="p_add">+			total_size =</span>
 				le16_to_cpu(get_unaligned(&amp;body-&gt;total_size));
 			oz_dbg(ON, &quot;USB_REQ_GET_DESCRIPTOR - cnf\n&quot;);
 			oz_hcd_get_desc_cnf(usb_ctx-&gt;hport, body-&gt;req_id,
<span class="p_header">diff --git a/drivers/staging/vt6655/card.c b/drivers/staging/vt6655/card.c</span>
<span class="p_header">index a079640..47801ca 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/card.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/card.c</span>
<span class="p_chunk">@@ -670,6 +670,9 @@</span> <span class="p_context"> void CARDvSetRSPINF(struct vnt_private *pDevice, u8 bb_type)</span>
 {
 	union vnt_phy_field_swap phy;
 	unsigned char byTxRate, byRsvTime;      /* For OFDM */
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;pDevice-&gt;lock, flags);</span>
 
 	/* Set to Page1 */
 	MACvSelectPage1(pDevice-&gt;PortOffset);
<span class="p_chunk">@@ -767,6 +770,8 @@</span> <span class="p_context"> void CARDvSetRSPINF(struct vnt_private *pDevice, u8 bb_type)</span>
 	VNSvOutPortW(pDevice-&gt;PortOffset + MAC_REG_RSPINF_A_72, MAKEWORD(byTxRate, byRsvTime));
 	/* Set to Page0 */
 	MACvSelectPage0(pDevice-&gt;PortOffset);
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;pDevice-&gt;lock, flags);</span>
 }
 
 void CARDvUpdateBasicTopRate(struct vnt_private *pDevice)
<span class="p_header">diff --git a/drivers/staging/vt6655/channel.c b/drivers/staging/vt6655/channel.c</span>
<span class="p_header">index 70f8705..d593f5f 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/channel.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/channel.c</span>
<span class="p_chunk">@@ -210,6 +210,10 @@</span> <span class="p_context"> bool set_channel(void *pDeviceHandler, unsigned int uConnectionChannel)</span>
 	BBvSoftwareReset(pDevice);
 
 	if (pDevice-&gt;byLocalID &gt; REV_ID_VT3253_B1) {
<span class="p_add">+		unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irqsave(&amp;pDevice-&gt;lock, flags);</span>
<span class="p_add">+</span>
 		/* set HW default power register */
 		MACvSelectPage1(pDevice-&gt;PortOffset);
 		RFbSetPower(pDevice, RATE_1M, pDevice-&gt;byCurrentCh);
<span class="p_chunk">@@ -217,6 +221,8 @@</span> <span class="p_context"> bool set_channel(void *pDeviceHandler, unsigned int uConnectionChannel)</span>
 		RFbSetPower(pDevice, RATE_6M, pDevice-&gt;byCurrentCh);
 		VNSvOutPortB(pDevice-&gt;PortOffset + MAC_REG_PWROFDM, pDevice-&gt;byCurPwr);
 		MACvSelectPage0(pDevice-&gt;PortOffset);
<span class="p_add">+</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;pDevice-&gt;lock, flags);</span>
 	}
 
 	if (pDevice-&gt;byBBType == BB_TYPE_11B)
<span class="p_header">diff --git a/drivers/staging/vt6655/device_main.c b/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">index ace0521..b95e915 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/device_main.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/device_main.c</span>
<span class="p_chunk">@@ -981,9 +981,6 @@</span> <span class="p_context"> static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)</span>
 		//Only the status of first TD in the chain is correct
 		if (pTD-&gt;m_td1TD1.byTCR &amp; TCR_STP) {
 			if ((pTD-&gt;pTDInfo-&gt;byFlags &amp; TD_FLAGS_NETIF_SKB) != 0) {
<span class="p_del">-</span>
<span class="p_del">-				vnt_int_report_rate(pDevice, pTD-&gt;pTDInfo, byTsr0, byTsr1);</span>
<span class="p_del">-</span>
 				if (!(byTsr1 &amp; TSR1_TERR)) {
 					if (byTsr0 != 0) {
 						pr_debug(&quot; Tx[%d] OK but has error. tsr1[%02X] tsr0[%02X]\n&quot;,
<span class="p_chunk">@@ -1002,6 +999,9 @@</span> <span class="p_context"> static int device_tx_srv(struct vnt_private *pDevice, unsigned int uIdx)</span>
 						 (int)uIdx, byTsr1, byTsr0);
 				}
 			}
<span class="p_add">+</span>
<span class="p_add">+			vnt_int_report_rate(pDevice, pTD-&gt;pTDInfo, byTsr0, byTsr1);</span>
<span class="p_add">+</span>
 			device_free_tx_buf(pDevice, pTD);
 			pDevice-&gt;iTDUsed[uIdx]--;
 		}
<span class="p_chunk">@@ -1033,10 +1033,8 @@</span> <span class="p_context"> static void device_free_tx_buf(struct vnt_private *pDevice, PSTxDesc pDesc)</span>
 				 PCI_DMA_TODEVICE);
 	}
 
<span class="p_del">-	if (pTDInfo-&gt;byFlags &amp; TD_FLAGS_NETIF_SKB)</span>
<span class="p_add">+	if (skb)</span>
 		ieee80211_tx_status_irqsafe(pDevice-&gt;hw, skb);
<span class="p_del">-	else</span>
<span class="p_del">-		dev_kfree_skb_irq(skb);</span>
 
 	pTDInfo-&gt;skb_dma = 0;
 	pTDInfo-&gt;skb = NULL;
<span class="p_chunk">@@ -1207,12 +1205,14 @@</span> <span class="p_context"> static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)</span>
 {
 	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *)skb-&gt;data;
 	PSTxDesc head_td;
<span class="p_del">-	u32 dma_idx = TYPE_AC0DMA;</span>
<span class="p_add">+	u32 dma_idx;</span>
 	unsigned long flags;
 
 	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
<span class="p_del">-	if (!ieee80211_is_data(hdr-&gt;frame_control))</span>
<span class="p_add">+	if (ieee80211_is_data(hdr-&gt;frame_control))</span>
<span class="p_add">+		dma_idx = TYPE_AC0DMA;</span>
<span class="p_add">+	else</span>
 		dma_idx = TYPE_TXDMA0;
 
 	if (AVAIL_TD(priv, dma_idx) &lt; 1) {
<span class="p_chunk">@@ -1226,14 +1226,9 @@</span> <span class="p_context"> static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)</span>
 
 	head_td-&gt;pTDInfo-&gt;skb = skb;
 
<span class="p_del">-	priv-&gt;iTDUsed[dma_idx]++;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Take ownership */</span>
<span class="p_del">-	wmb();</span>
<span class="p_del">-	head_td-&gt;m_td0TD0.f1Owner = OWNED_BY_NIC;</span>
<span class="p_add">+	if (dma_idx == TYPE_AC0DMA)</span>
<span class="p_add">+		head_td-&gt;pTDInfo-&gt;byFlags = TD_FLAGS_NETIF_SKB;</span>
 
<span class="p_del">-	/* get Next */</span>
<span class="p_del">-	wmb();</span>
 	priv-&gt;apCurrTD[dma_idx] = head_td-&gt;next;
 
 	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
<span class="p_chunk">@@ -1252,13 +1247,20 @@</span> <span class="p_context"> static int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)</span>
 	head_td-&gt;m_td1TD1.wReqCount =
 			cpu_to_le16((u16)head_td-&gt;pTDInfo-&gt;dwReqCount);
 
<span class="p_del">-	head_td-&gt;pTDInfo-&gt;byFlags = TD_FLAGS_NETIF_SKB;</span>
<span class="p_add">+	head_td-&gt;buff_addr = cpu_to_le32(head_td-&gt;pTDInfo-&gt;skb_dma);</span>
 
<span class="p_del">-	if (dma_idx == TYPE_AC0DMA)</span>
<span class="p_add">+	/* Poll Transmit the adapter */</span>
<span class="p_add">+	wmb();</span>
<span class="p_add">+	head_td-&gt;m_td0TD0.f1Owner = OWNED_BY_NIC;</span>
<span class="p_add">+	wmb(); /* second memory barrier */</span>
<span class="p_add">+</span>
<span class="p_add">+	if (head_td-&gt;pTDInfo-&gt;byFlags &amp; TD_FLAGS_NETIF_SKB)</span>
 		MACvTransmitAC0(priv-&gt;PortOffset);
 	else
 		MACvTransmit0(priv-&gt;PortOffset);
 
<span class="p_add">+	priv-&gt;iTDUsed[dma_idx]++;</span>
<span class="p_add">+</span>
 	spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);
 
 	return 0;
<span class="p_chunk">@@ -1445,9 +1447,16 @@</span> <span class="p_context"> static void vnt_bss_info_changed(struct ieee80211_hw *hw,</span>
 
 	priv-&gt;current_aid = conf-&gt;aid;
 
<span class="p_del">-	if (changed &amp; BSS_CHANGED_BSSID)</span>
<span class="p_add">+	if (changed &amp; BSS_CHANGED_BSSID) {</span>
<span class="p_add">+		unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+</span>
 		MACvWriteBSSIDAddress(priv-&gt;PortOffset, (u8 *)conf-&gt;bssid);
 
<span class="p_add">+		spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (changed &amp; BSS_CHANGED_BASIC_RATES) {
 		priv-&gt;basic_rates = conf-&gt;basic_rates;
 
<span class="p_chunk">@@ -1562,6 +1571,10 @@</span> <span class="p_context"> static void vnt_configure(struct ieee80211_hw *hw,</span>
 
 	if (changed_flags &amp; FIF_ALLMULTI) {
 		if (*total_flags &amp; FIF_ALLMULTI) {
<span class="p_add">+			unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+			spin_lock_irqsave(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+</span>
 			if (priv-&gt;mc_list_count &gt; 2) {
 				MACvSelectPage1(priv-&gt;PortOffset);
 
<span class="p_chunk">@@ -1583,6 +1596,8 @@</span> <span class="p_context"> static void vnt_configure(struct ieee80211_hw *hw,</span>
 				MACvSelectPage0(priv-&gt;PortOffset);
 			}
 
<span class="p_add">+			spin_unlock_irqrestore(&amp;priv-&gt;lock, flags);</span>
<span class="p_add">+</span>
 			rx_mode |= RCR_MULTICAST | RCR_BROADCAST;
 		} else {
 			rx_mode &amp;= ~(RCR_MULTICAST | RCR_BROADCAST);
<span class="p_header">diff --git a/drivers/staging/vt6655/rxtx.c b/drivers/staging/vt6655/rxtx.c</span>
<span class="p_header">index baaab3f..986fa11 100644</span>
<span class="p_header">--- a/drivers/staging/vt6655/rxtx.c</span>
<span class="p_header">+++ b/drivers/staging/vt6655/rxtx.c</span>
<span class="p_chunk">@@ -1207,7 +1207,6 @@</span> <span class="p_context"> s_cbFillTxBufHead(struct vnt_private *pDevice, unsigned char byPktType,</span>
 	ptdCurr-&gt;pTDInfo-&gt;dwReqCount = cbReqCount;
 	ptdCurr-&gt;pTDInfo-&gt;dwHeaderLength = cbHeaderLength;
 	ptdCurr-&gt;pTDInfo-&gt;skb_dma = ptdCurr-&gt;pTDInfo-&gt;buf_dma;
<span class="p_del">-	ptdCurr-&gt;buff_addr = cpu_to_le32(ptdCurr-&gt;pTDInfo-&gt;skb_dma);</span>
 
 	return cbHeaderLength;
 }
<span class="p_header">diff --git a/drivers/staging/vt6656/rxtx.c b/drivers/staging/vt6656/rxtx.c</span>
<span class="p_header">index ea5140a..b3500fd 100644</span>
<span class="p_header">--- a/drivers/staging/vt6656/rxtx.c</span>
<span class="p_header">+++ b/drivers/staging/vt6656/rxtx.c</span>
<span class="p_chunk">@@ -800,10 +800,18 @@</span> <span class="p_context"> int vnt_tx_packet(struct vnt_private *priv, struct sk_buff *skb)</span>
 		vnt_schedule_command(priv, WLAN_CMD_SETPOWER);
 	}
 
<span class="p_del">-	if (current_rate &gt; RATE_11M)</span>
<span class="p_del">-		pkt_type = priv-&gt;packet_type;</span>
<span class="p_del">-	else</span>
<span class="p_add">+	if (current_rate &gt; RATE_11M) {</span>
<span class="p_add">+		if (info-&gt;band == IEEE80211_BAND_5GHZ) {</span>
<span class="p_add">+			pkt_type = PK_TYPE_11A;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (tx_rate-&gt;flags &amp; IEEE80211_TX_RC_USE_CTS_PROTECT)</span>
<span class="p_add">+				pkt_type = PK_TYPE_11GB;</span>
<span class="p_add">+			else</span>
<span class="p_add">+				pkt_type = PK_TYPE_11GA;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
 		pkt_type = PK_TYPE_11B;
<span class="p_add">+	}</span>
 
 	spin_lock_irqsave(&amp;priv-&gt;lock, flags);
 
<span class="p_header">diff --git a/drivers/thermal/armada_thermal.c b/drivers/thermal/armada_thermal.c</span>
<span class="p_header">index c2556cf..01255fd 100644</span>
<span class="p_header">--- a/drivers/thermal/armada_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/armada_thermal.c</span>
<span class="p_chunk">@@ -224,9 +224,9 @@</span> <span class="p_context"> static const struct armada_thermal_data armada380_data = {</span>
 	.is_valid_shift = 10,
 	.temp_shift = 0,
 	.temp_mask = 0x3ff,
<span class="p_del">-	.coef_b = 1169498786UL,</span>
<span class="p_del">-	.coef_m = 2000000UL,</span>
<span class="p_del">-	.coef_div = 4289,</span>
<span class="p_add">+	.coef_b = 2931108200UL,</span>
<span class="p_add">+	.coef_m = 5000000UL,</span>
<span class="p_add">+	.coef_div = 10502,</span>
 	.inverted = true,
 };
 
<span class="p_header">diff --git a/drivers/thermal/rockchip_thermal.c b/drivers/thermal/rockchip_thermal.c</span>
<span class="p_header">index 9c6ce54..aba843a 100644</span>
<span class="p_header">--- a/drivers/thermal/rockchip_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/rockchip_thermal.c</span>
<span class="p_chunk">@@ -519,7 +519,7 @@</span> <span class="p_context"> static int rockchip_thermal_probe(struct platform_device *pdev)</span>
 
 	thermal-&gt;pclk = devm_clk_get(&amp;pdev-&gt;dev, &quot;apb_pclk&quot;);
 	if (IS_ERR(thermal-&gt;pclk)) {
<span class="p_del">-		error = PTR_ERR(thermal-&gt;clk);</span>
<span class="p_add">+		error = PTR_ERR(thermal-&gt;pclk);</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;failed to get apb_pclk clock: %d\n&quot;,
 			error);
 		return error;
<span class="p_header">diff --git a/drivers/tty/hvc/hvc_xen.c b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">index 5bab1c6..7a3d146 100644</span>
<span class="p_header">--- a/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_header">+++ b/drivers/tty/hvc/hvc_xen.c</span>
<span class="p_chunk">@@ -289,7 +289,7 @@</span> <span class="p_context"> static int xen_initial_domain_console_init(void)</span>
 			return -ENOMEM;
 	}
 
<span class="p_del">-	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0);</span>
<span class="p_add">+	info-&gt;irq = bind_virq_to_irq(VIRQ_CONSOLE, 0, false);</span>
 	info-&gt;vtermno = HVC_COOKIE;
 
 	spin_lock(&amp;xencons_lock);
<span class="p_header">diff --git a/drivers/tty/n_gsm.c b/drivers/tty/n_gsm.c</span>
<span class="p_header">index c434376..bce16e4 100644</span>
<span class="p_header">--- a/drivers/tty/n_gsm.c</span>
<span class="p_header">+++ b/drivers/tty/n_gsm.c</span>
<span class="p_chunk">@@ -3170,7 +3170,7 @@</span> <span class="p_context"> static int gsmtty_break_ctl(struct tty_struct *tty, int state)</span>
 	return gsmtty_modem_update(dlci, encode);
 }
 
<span class="p_del">-static void gsmtty_remove(struct tty_driver *driver, struct tty_struct *tty)</span>
<span class="p_add">+static void gsmtty_cleanup(struct tty_struct *tty)</span>
 {
 	struct gsm_dlci *dlci = tty-&gt;driver_data;
 	struct gsm_mux *gsm = dlci-&gt;gsm;
<span class="p_chunk">@@ -3178,7 +3178,6 @@</span> <span class="p_context"> static void gsmtty_remove(struct tty_driver *driver, struct tty_struct *tty)</span>
 	dlci_put(dlci);
 	dlci_put(gsm-&gt;dlci[0]);
 	mux_put(gsm);
<span class="p_del">-	driver-&gt;ttys[tty-&gt;index] = NULL;</span>
 }
 
 /* Virtual ttys for the demux */
<span class="p_chunk">@@ -3199,7 +3198,7 @@</span> <span class="p_context"> static const struct tty_operations gsmtty_ops = {</span>
 	.tiocmget		= gsmtty_tiocmget,
 	.tiocmset		= gsmtty_tiocmset,
 	.break_ctl		= gsmtty_break_ctl,
<span class="p_del">-	.remove			= gsmtty_remove,</span>
<span class="p_add">+	.cleanup		= gsmtty_cleanup,</span>
 };
 
 
<span class="p_header">diff --git a/drivers/tty/n_hdlc.c b/drivers/tty/n_hdlc.c</span>
<span class="p_header">index 644ddb8..bbc4ce6 100644</span>
<span class="p_header">--- a/drivers/tty/n_hdlc.c</span>
<span class="p_header">+++ b/drivers/tty/n_hdlc.c</span>
<span class="p_chunk">@@ -600,7 +600,7 @@</span> <span class="p_context"> static ssize_t n_hdlc_tty_read(struct tty_struct *tty, struct file *file,</span>
 	add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);
 
 	for (;;) {
<span class="p_del">-		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags)) {</span>
 			ret = -EIO;
 			break;
 		}
<span class="p_chunk">@@ -828,7 +828,7 @@</span> <span class="p_context"> static unsigned int n_hdlc_tty_poll(struct tty_struct *tty, struct file *filp,</span>
 		/* set bits for operations that won&#39;t block */
 		if (n_hdlc-&gt;rx_buf_list.head)
 			mask |= POLLIN | POLLRDNORM;	/* readable */
<span class="p_del">-		if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_add">+		if (test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags))</span>
 			mask |= POLLHUP;
 		if (tty_hung_up_p(filp))
 			mask |= POLLHUP;
<span class="p_header">diff --git a/drivers/tty/n_tty.c b/drivers/tty/n_tty.c</span>
<span class="p_header">index 6f8cf3a..f9d9ed3 100644</span>
<span class="p_header">--- a/drivers/tty/n_tty.c</span>
<span class="p_header">+++ b/drivers/tty/n_tty.c</span>
<span class="p_chunk">@@ -1960,6 +1960,18 @@</span> <span class="p_context"> static inline int input_available_p(struct tty_struct *tty, int poll)</span>
 		return read_cnt(ldata) &gt;= amt;
 }
 
<span class="p_add">+static inline int check_other_done(struct tty_struct *tty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int done = test_bit(TTY_OTHER_DONE, &amp;tty-&gt;flags);</span>
<span class="p_add">+	if (done) {</span>
<span class="p_add">+		/* paired with cmpxchg() in check_other_closed(); ensures</span>
<span class="p_add">+		 * read buffer head index is not stale</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_mb__after_atomic();</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return done;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	copy_from_read_buf	-	copy read data directly
  *	@tty: terminal device
<span class="p_chunk">@@ -2177,7 +2189,7 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 	struct n_tty_data *ldata = tty-&gt;disc_data;
 	unsigned char __user *b = buf;
 	DEFINE_WAIT_FUNC(wait, woken_wake_function);
<span class="p_del">-	int c;</span>
<span class="p_add">+	int c, done;</span>
 	int minimum, time;
 	ssize_t retval = 0;
 	long timeout;
<span class="p_chunk">@@ -2243,8 +2255,10 @@</span> <span class="p_context"> static ssize_t n_tty_read(struct tty_struct *tty, struct file *file,</span>
 		    ((minimum - (b - buf)) &gt;= 1))
 			ldata-&gt;minimum_to_wake = (minimum - (b - buf));
 
<span class="p_add">+		done = check_other_done(tty);</span>
<span class="p_add">+</span>
 		if (!input_available_p(tty, 0)) {
<span class="p_del">-			if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags)) {</span>
<span class="p_add">+			if (done) {</span>
 				retval = -EIO;
 				break;
 			}
<span class="p_chunk">@@ -2451,12 +2465,12 @@</span> <span class="p_context"> static unsigned int n_tty_poll(struct tty_struct *tty, struct file *file,</span>
 
 	poll_wait(file, &amp;tty-&gt;read_wait, wait);
 	poll_wait(file, &amp;tty-&gt;write_wait, wait);
<span class="p_add">+	if (check_other_done(tty))</span>
<span class="p_add">+		mask |= POLLHUP;</span>
 	if (input_available_p(tty, 1))
 		mask |= POLLIN | POLLRDNORM;
 	if (tty-&gt;packet &amp;&amp; tty-&gt;link-&gt;ctrl_status)
 		mask |= POLLPRI | POLLIN | POLLRDNORM;
<span class="p_del">-	if (test_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags))</span>
<span class="p_del">-		mask |= POLLHUP;</span>
 	if (tty_hung_up_p(file))
 		mask |= POLLHUP;
 	if (!(mask &amp; (POLLHUP | POLLIN | POLLRDNORM))) {
<span class="p_header">diff --git a/drivers/tty/pty.c b/drivers/tty/pty.c</span>
<span class="p_header">index 6e1f150..ca7b689 100644</span>
<span class="p_header">--- a/drivers/tty/pty.c</span>
<span class="p_header">+++ b/drivers/tty/pty.c</span>
<span class="p_chunk">@@ -53,9 +53,8 @@</span> <span class="p_context"> static void pty_close(struct tty_struct *tty, struct file *filp)</span>
 	/* Review - krefs on tty_link ?? */
 	if (!tty-&gt;link)
 		return;
<span class="p_del">-	tty_flush_to_ldisc(tty-&gt;link);</span>
 	set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_del">-	wake_up_interruptible(&amp;tty-&gt;link-&gt;read_wait);</span>
<span class="p_add">+	tty_flip_buffer_push(tty-&gt;link-&gt;port);</span>
 	wake_up_interruptible(&amp;tty-&gt;link-&gt;write_wait);
 	if (tty-&gt;driver-&gt;subtype == PTY_TYPE_MASTER) {
 		set_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;flags);
<span class="p_chunk">@@ -250,7 +249,9 @@</span> <span class="p_context"> static int pty_open(struct tty_struct *tty, struct file *filp)</span>
 		goto out;
 
 	clear_bit(TTY_IO_ERROR, &amp;tty-&gt;flags);
<span class="p_add">+	/* TTY_OTHER_CLOSED must be cleared before TTY_OTHER_DONE */</span>
 	clear_bit(TTY_OTHER_CLOSED, &amp;tty-&gt;link-&gt;flags);
<span class="p_add">+	clear_bit(TTY_OTHER_DONE, &amp;tty-&gt;link-&gt;flags);</span>
 	set_bit(TTY_THROTTLED, &amp;tty-&gt;flags);
 	return 0;
 
<span class="p_header">diff --git a/drivers/tty/tty_buffer.c b/drivers/tty/tty_buffer.c</span>
<span class="p_header">index 3605103..79bcdf9 100644</span>
<span class="p_header">--- a/drivers/tty/tty_buffer.c</span>
<span class="p_header">+++ b/drivers/tty/tty_buffer.c</span>
<span class="p_chunk">@@ -37,6 +37,28 @@</span> <span class="p_context"></span>
 
 #define TTY_BUFFER_PAGE	(((PAGE_SIZE - sizeof(struct tty_buffer)) / 2) &amp; ~0xFF)
 
<span class="p_add">+/*</span>
<span class="p_add">+ * If all tty flip buffers have been processed by flush_to_ldisc() or</span>
<span class="p_add">+ * dropped by tty_buffer_flush(), check if the linked pty has been closed.</span>
<span class="p_add">+ * If so, wake the reader/poll to process</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void check_other_closed(struct tty_struct *tty)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags, old;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* transition from TTY_OTHER_CLOSED =&gt; TTY_OTHER_DONE must be atomic */</span>
<span class="p_add">+	for (flags = ACCESS_ONCE(tty-&gt;flags);</span>
<span class="p_add">+	     test_bit(TTY_OTHER_CLOSED, &amp;flags);</span>
<span class="p_add">+	     ) {</span>
<span class="p_add">+		old = flags;</span>
<span class="p_add">+		__set_bit(TTY_OTHER_DONE, &amp;flags);</span>
<span class="p_add">+		flags = cmpxchg(&amp;tty-&gt;flags, old, flags);</span>
<span class="p_add">+		if (old == flags) {</span>
<span class="p_add">+			wake_up_interruptible(&amp;tty-&gt;read_wait);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 
 /**
  *	tty_buffer_lock_exclusive	-	gain exclusive access to buffer
<span class="p_chunk">@@ -229,6 +251,8 @@</span> <span class="p_context"> void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld)</span>
 	if (ld &amp;&amp; ld-&gt;ops-&gt;flush_buffer)
 		ld-&gt;ops-&gt;flush_buffer(tty);
 
<span class="p_add">+	check_other_closed(tty);</span>
<span class="p_add">+</span>
 	atomic_dec(&amp;buf-&gt;priority);
 	mutex_unlock(&amp;buf-&gt;lock);
 }
<span class="p_chunk">@@ -471,8 +495,10 @@</span> <span class="p_context"> static void flush_to_ldisc(struct work_struct *work)</span>
 		smp_rmb();
 		count = head-&gt;commit - head-&gt;read;
 		if (!count) {
<span class="p_del">-			if (next == NULL)</span>
<span class="p_add">+			if (next == NULL) {</span>
<span class="p_add">+				check_other_closed(tty);</span>
 				break;
<span class="p_add">+			}</span>
 			buf-&gt;head = next;
 			tty_buffer_free(port, head);
 			continue;
<span class="p_chunk">@@ -489,19 +515,6 @@</span> <span class="p_context"> static void flush_to_ldisc(struct work_struct *work)</span>
 }
 
 /**
<span class="p_del">- *	tty_flush_to_ldisc</span>
<span class="p_del">- *	@tty: tty to push</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Push the terminal flip buffers to the line discipline.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Must not be called from IRQ context.</span>
<span class="p_del">- */</span>
<span class="p_del">-void tty_flush_to_ldisc(struct tty_struct *tty)</span>
<span class="p_del">-{</span>
<span class="p_del">-	flush_work(&amp;tty-&gt;port-&gt;buf.work);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
  *	tty_flip_buffer_push	-	terminal
  *	@port: tty port to push
  *
<span class="p_header">diff --git a/drivers/usb/dwc2/hcd.c b/drivers/usb/dwc2/hcd.c</span>
<span class="p_header">index a0cd9db..f78e661 100644</span>
<span class="p_header">--- a/drivers/usb/dwc2/hcd.c</span>
<span class="p_header">+++ b/drivers/usb/dwc2/hcd.c</span>
<span class="p_chunk">@@ -1473,30 +1473,6 @@</span> <span class="p_context"> static void dwc2_port_suspend(struct dwc2_hsotg *hsotg, u16 windex)</span>
 	}
 }
 
<span class="p_del">-static void dwc2_port_resume(struct dwc2_hsotg *hsotg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 hprt0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* After clear the Stop PHY clock bit, we should wait for a moment</span>
<span class="p_del">-	 * for PLL work stable with clock output.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	writel(0, hsotg-&gt;regs + PCGCTL);</span>
<span class="p_del">-	usleep_range(2000, 4000);</span>
<span class="p_del">-</span>
<span class="p_del">-	hprt0 = dwc2_read_hprt0(hsotg);</span>
<span class="p_del">-	hprt0 |= HPRT0_RES;</span>
<span class="p_del">-	writel(hprt0, hsotg-&gt;regs + HPRT0);</span>
<span class="p_del">-	hprt0 &amp;= ~HPRT0_SUSP;</span>
<span class="p_del">-	/* according to USB2.0 Spec 7.1.7.7, the host must send the resume</span>
<span class="p_del">-	 * signal for at least 20ms</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	usleep_range(20000, 25000);</span>
<span class="p_del">-</span>
<span class="p_del">-	hprt0 &amp;= ~HPRT0_RES;</span>
<span class="p_del">-	writel(hprt0, hsotg-&gt;regs + HPRT0);</span>
<span class="p_del">-	hsotg-&gt;lx_state = DWC2_L0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Handles hub class-specific requests */
 static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,
 				u16 wvalue, u16 windex, char *buf, u16 wlength)
<span class="p_chunk">@@ -1542,7 +1518,17 @@</span> <span class="p_context"> static int dwc2_hcd_hub_control(struct dwc2_hsotg *hsotg, u16 typereq,</span>
 		case USB_PORT_FEAT_SUSPEND:
 			dev_dbg(hsotg-&gt;dev,
 				&quot;ClearPortFeature USB_PORT_FEAT_SUSPEND\n&quot;);
<span class="p_del">-			dwc2_port_resume(hsotg);</span>
<span class="p_add">+			writel(0, hsotg-&gt;regs + PCGCTL);</span>
<span class="p_add">+			msleep(USB_RESUME_TIMEOUT);</span>
<span class="p_add">+</span>
<span class="p_add">+			hprt0 = dwc2_read_hprt0(hsotg);</span>
<span class="p_add">+			hprt0 |= HPRT0_RES;</span>
<span class="p_add">+			writel(hprt0, hsotg-&gt;regs + HPRT0);</span>
<span class="p_add">+			hprt0 &amp;= ~HPRT0_SUSP;</span>
<span class="p_add">+			usleep_range(100000, 150000);</span>
<span class="p_add">+</span>
<span class="p_add">+			hprt0 &amp;= ~HPRT0_RES;</span>
<span class="p_add">+			writel(hprt0, hsotg-&gt;regs + HPRT0);</span>
 			break;
 
 		case USB_PORT_FEAT_POWER:
<span class="p_chunk">@@ -2315,55 +2301,6 @@</span> <span class="p_context"> static void _dwc2_hcd_stop(struct usb_hcd *hcd)</span>
 	usleep_range(1000, 3000);
 }
 
<span class="p_del">-static int _dwc2_hcd_suspend(struct usb_hcd *hcd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);</span>
<span class="p_del">-	u32 hprt0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!((hsotg-&gt;op_state == OTG_STATE_B_HOST) ||</span>
<span class="p_del">-		(hsotg-&gt;op_state == OTG_STATE_A_HOST)))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* TODO: We get into suspend from &#39;on&#39; state, maybe we need to do</span>
<span class="p_del">-	 * something if we get here from DWC2_L1(LPM sleep) state one day.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (hsotg-&gt;lx_state != DWC2_L0)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	hprt0 = dwc2_read_hprt0(hsotg);</span>
<span class="p_del">-	if (hprt0 &amp; HPRT0_CONNSTS) {</span>
<span class="p_del">-		dwc2_port_suspend(hsotg, 1);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		u32 pcgctl = readl(hsotg-&gt;regs + PCGCTL);</span>
<span class="p_del">-</span>
<span class="p_del">-		pcgctl |= PCGCTL_STOPPCLK;</span>
<span class="p_del">-		writel(pcgctl, hsotg-&gt;regs + PCGCTL);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int _dwc2_hcd_resume(struct usb_hcd *hcd)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct dwc2_hsotg *hsotg = dwc2_hcd_to_hsotg(hcd);</span>
<span class="p_del">-	u32 hprt0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!((hsotg-&gt;op_state == OTG_STATE_B_HOST) ||</span>
<span class="p_del">-		(hsotg-&gt;op_state == OTG_STATE_A_HOST)))</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (hsotg-&gt;lx_state != DWC2_L2)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	hprt0 = dwc2_read_hprt0(hsotg);</span>
<span class="p_del">-	if ((hprt0 &amp; HPRT0_CONNSTS) &amp;&amp; (hprt0 &amp; HPRT0_SUSP))</span>
<span class="p_del">-		dwc2_port_resume(hsotg);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		writel(0, hsotg-&gt;regs + PCGCTL);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /* Returns the current frame number */
 static int _dwc2_hcd_get_frame_number(struct usb_hcd *hcd)
 {
<span class="p_chunk">@@ -2734,9 +2671,6 @@</span> <span class="p_context"> static struct hc_driver dwc2_hc_driver = {</span>
 	.hub_status_data = _dwc2_hcd_hub_status_data,
 	.hub_control = _dwc2_hcd_hub_control,
 	.clear_tt_buffer_complete = _dwc2_hcd_clear_tt_buffer_complete,
<span class="p_del">-</span>
<span class="p_del">-	.bus_suspend = _dwc2_hcd_suspend,</span>
<span class="p_del">-	.bus_resume = _dwc2_hcd_resume,</span>
 };
 
 /*
<span class="p_header">diff --git a/drivers/usb/gadget/configfs.c b/drivers/usb/gadget/configfs.c</span>
<span class="p_header">index c42765b..0495c94 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/configfs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/configfs.c</span>
<span class="p_chunk">@@ -1295,6 +1295,7 @@</span> <span class="p_context"> static void purge_configs_funcs(struct gadget_info *gi)</span>
 			}
 		}
 		c-&gt;next_interface_id = 0;
<span class="p_add">+		memset(c-&gt;interface, 0, sizeof(c-&gt;interface));</span>
 		c-&gt;superspeed = 0;
 		c-&gt;highspeed = 0;
 		c-&gt;fullspeed = 0;
<span class="p_header">diff --git a/drivers/usb/host/isp1760-hcd.c b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">index c83ac89..3773e68 100644</span>
<span class="p_header">--- a/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/isp1760-hcd.c</span>
<span class="p_chunk">@@ -1895,7 +1895,7 @@</span> <span class="p_context"> static int isp1760_hub_control(struct usb_hcd *hcd, u16 typeReq,</span>
 				reg_write32(hcd-&gt;regs, HC_PORTSC1,
 							temp | PORT_RESUME);
 				priv-&gt;reset_done = jiffies +
<span class="p_del">-					msecs_to_jiffies(20);</span>
<span class="p_add">+					msecs_to_jiffies(USB_RESUME_TIMEOUT);</span>
 			}
 			break;
 		case USB_PORT_FEAT_C_SUSPEND:
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index 7dd25ce..861a810 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -2026,8 +2026,13 @@</span> <span class="p_context"> static int process_isoc_td(struct xhci_hcd *xhci, struct xhci_td *td,</span>
 		break;
 	case COMP_DEV_ERR:
 	case COMP_STALL:
<span class="p_add">+		frame-&gt;status = -EPROTO;</span>
<span class="p_add">+		skip_td = true;</span>
<span class="p_add">+		break;</span>
 	case COMP_TX_ERR:
 		frame-&gt;status = -EPROTO;
<span class="p_add">+		if (event_trb != td-&gt;last_trb)</span>
<span class="p_add">+			return 0;</span>
 		skip_td = true;
 		break;
 	case COMP_STOP:
<span class="p_chunk">@@ -2640,7 +2645,7 @@</span> <span class="p_context"> irqreturn_t xhci_irq(struct usb_hcd *hcd)</span>
 		xhci_halt(xhci);
 hw_died:
 		spin_unlock(&amp;xhci-&gt;lock);
<span class="p_del">-		return -ESHUTDOWN;</span>
<span class="p_add">+		return IRQ_HANDLED;</span>
 	}
 
 	/*
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index ab09b1a..30d1f97 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -1267,7 +1267,7 @@</span> <span class="p_context"> union xhci_trb {</span>
  * since the command ring is 64-byte aligned.
  * It must also be greater than 16.
  */
<span class="p_del">-#define TRBS_PER_SEGMENT	64</span>
<span class="p_add">+#define TRBS_PER_SEGMENT	256</span>
 /* Allow two commands + a link TRB, along with any reserved command TRBs */
 #define MAX_RSVD_CMD_TRBS	(TRBS_PER_SEGMENT - 3)
 #define TRB_SEGMENT_SIZE	(TRBS_PER_SEGMENT*16)
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 84ce2d7..9031750 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -127,6 +127,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */</span>
 	{ USB_DEVICE(0x10C4, 0xEA60) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA61) }, /* Silicon Labs factory default */
 	{ USB_DEVICE(0x10C4, 0xEA70) }, /* Silicon Labs factory default */
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.c b/drivers/usb/serial/pl2303.c</span>
<span class="p_header">index 0f872e6..534c308 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.c</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.c</span>
<span class="p_chunk">@@ -61,7 +61,6 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(DCU10_VENDOR_ID, DCU10_PRODUCT_ID) },
 	{ USB_DEVICE(SITECOM_VENDOR_ID, SITECOM_PRODUCT_ID) },
 	{ USB_DEVICE(ALCATEL_VENDOR_ID, ALCATEL_PRODUCT_ID) },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_PRODUCT_ID) },</span>
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_SX1),
 		.driver_info = PL2303_QUIRK_UART_STATE_IDX0 },
 	{ USB_DEVICE(SIEMENS_VENDOR_ID, SIEMENS_PRODUCT_ID_X65),
<span class="p_header">diff --git a/drivers/usb/serial/pl2303.h b/drivers/usb/serial/pl2303.h</span>
<span class="p_header">index 71fd9da..e3b7af8 100644</span>
<span class="p_header">--- a/drivers/usb/serial/pl2303.h</span>
<span class="p_header">+++ b/drivers/usb/serial/pl2303.h</span>
<span class="p_chunk">@@ -62,10 +62,6 @@</span> <span class="p_context"></span>
 #define ALCATEL_VENDOR_ID	0x11f7
 #define ALCATEL_PRODUCT_ID	0x02df
 
<span class="p_del">-/* Samsung I330 phone cradle */</span>
<span class="p_del">-#define SAMSUNG_VENDOR_ID	0x04e8</span>
<span class="p_del">-#define SAMSUNG_PRODUCT_ID	0x8001</span>
<span class="p_del">-</span>
 #define SIEMENS_VENDOR_ID	0x11f5
 #define SIEMENS_PRODUCT_ID_SX1	0x0001
 #define SIEMENS_PRODUCT_ID_X65	0x0003
<span class="p_header">diff --git a/drivers/usb/serial/visor.c b/drivers/usb/serial/visor.c</span>
<span class="p_header">index bf2bd40..60afb39 100644</span>
<span class="p_header">--- a/drivers/usb/serial/visor.c</span>
<span class="p_header">+++ b/drivers/usb/serial/visor.c</span>
<span class="p_chunk">@@ -95,7 +95,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(ACER_VENDOR_ID, ACER_S10_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_del">-	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID),</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(SAMSUNG_VENDOR_ID, SAMSUNG_SCH_I330_ID, 0xff),</span>
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
 	{ USB_DEVICE(SAMSUNG_VENDOR_ID, SAMSUNG_SPH_I500_ID),
 		.driver_info = (kernel_ulong_t)&amp;palm_os_4_probe },
<span class="p_header">diff --git a/drivers/usb/storage/unusual_devs.h b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">index d684b4b..caf1888 100644</span>
<span class="p_header">--- a/drivers/usb/storage/unusual_devs.h</span>
<span class="p_header">+++ b/drivers/usb/storage/unusual_devs.h</span>
<span class="p_chunk">@@ -766,6 +766,13 @@</span> <span class="p_context"> UNUSUAL_DEV(  0x059f, 0x0643, 0x0000, 0x0000,</span>
 		USB_SC_DEVICE, USB_PR_DEVICE, NULL,
 		US_FL_GO_SLOW ),
 
<span class="p_add">+/* Reported by Christian Schaller &lt;cschalle@redhat.com&gt; */</span>
<span class="p_add">+UNUSUAL_DEV(  0x059f, 0x0651, 0x0000, 0x0000,</span>
<span class="p_add">+		&quot;LaCie&quot;,</span>
<span class="p_add">+		&quot;External HDD&quot;,</span>
<span class="p_add">+		USB_SC_DEVICE, USB_PR_DEVICE, NULL,</span>
<span class="p_add">+		US_FL_NO_WP_DETECT ),</span>
<span class="p_add">+</span>
 /* Submitted by Joel Bourquard &lt;numlock@freesurf.ch&gt;
  * Some versions of this device need the SubClass and Protocol overrides
  * while others don&#39;t.
<span class="p_header">diff --git a/drivers/xen/events/events_base.c b/drivers/xen/events/events_base.c</span>
<span class="p_header">index 2b8553b..3838795 100644</span>
<span class="p_header">--- a/drivers/xen/events/events_base.c</span>
<span class="p_header">+++ b/drivers/xen/events/events_base.c</span>
<span class="p_chunk">@@ -957,7 +957,7 @@</span> <span class="p_context"> unsigned xen_evtchn_nr_channels(void)</span>
 }
 EXPORT_SYMBOL_GPL(xen_evtchn_nr_channels);
 
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu)</span>
 {
 	struct evtchn_bind_virq bind_virq;
 	int evtchn, irq, ret;
<span class="p_chunk">@@ -971,8 +971,12 @@</span> <span class="p_context"> int bind_virq_to_irq(unsigned int virq, unsigned int cpu)</span>
 		if (irq &lt; 0)
 			goto out;
 
<span class="p_del">-		irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_del">-					      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		if (percpu)</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_percpu_chip,</span>
<span class="p_add">+						      handle_percpu_irq, &quot;virq&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			irq_set_chip_and_handler_name(irq, &amp;xen_dynamic_chip,</span>
<span class="p_add">+						      handle_edge_irq, &quot;virq&quot;);</span>
 
 		bind_virq.virq = virq;
 		bind_virq.vcpu = cpu;
<span class="p_chunk">@@ -1062,7 +1066,7 @@</span> <span class="p_context"> int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,</span>
 {
 	int irq, retval;
 
<span class="p_del">-	irq = bind_virq_to_irq(virq, cpu);</span>
<span class="p_add">+	irq = bind_virq_to_irq(virq, cpu, irqflags &amp; IRQF_PERCPU);</span>
 	if (irq &lt; 0)
 		return irq;
 	retval = request_irq(irq, handler, irqflags, devname, dev_id);
<span class="p_header">diff --git a/firmware/ihex2fw.c b/firmware/ihex2fw.c</span>
<span class="p_header">index cf38e15..08d90e2 100644</span>
<span class="p_header">--- a/firmware/ihex2fw.c</span>
<span class="p_header">+++ b/firmware/ihex2fw.c</span>
<span class="p_chunk">@@ -86,6 +86,7 @@</span> <span class="p_context"> int main(int argc, char **argv)</span>
 		case &#39;j&#39;:
 			include_jump = 1;
 			break;
<span class="p_add">+		default:</span>
 			return usage();
 		}
 	}
<span class="p_header">diff --git a/fs/exec.c b/fs/exec.c</span>
<span class="p_header">index 4617a4e..be18722 100644</span>
<span class="p_header">--- a/fs/exec.c</span>
<span class="p_header">+++ b/fs/exec.c</span>
<span class="p_chunk">@@ -659,6 +659,9 @@</span> <span class="p_context"> int setup_arg_pages(struct linux_binprm *bprm,</span>
 	if (stack_base &gt; STACK_SIZE_MAX)
 		stack_base = STACK_SIZE_MAX;
 
<span class="p_add">+	/* Add space for stack randomization. */</span>
<span class="p_add">+	stack_base += (STACK_RND_MASK &lt;&lt; PAGE_SHIFT);</span>
<span class="p_add">+</span>
 	/* Make sure we didn&#39;t let the argument array grow too large. */
 	if (vma-&gt;vm_end - vma-&gt;vm_start &gt; stack_base)
 		return -ENOMEM;
<span class="p_header">diff --git a/fs/ext4/ext4_jbd2.c b/fs/ext4/ext4_jbd2.c</span>
<span class="p_header">index 3445035..d418431 100644</span>
<span class="p_header">--- a/fs/ext4/ext4_jbd2.c</span>
<span class="p_header">+++ b/fs/ext4/ext4_jbd2.c</span>
<span class="p_chunk">@@ -87,6 +87,12 @@</span> <span class="p_context"> int __ext4_journal_stop(const char *where, unsigned int line, handle_t *handle)</span>
 		ext4_put_nojournal(handle);
 		return 0;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (!handle-&gt;h_transaction) {</span>
<span class="p_add">+		err = jbd2_journal_stop(handle);</span>
<span class="p_add">+		return handle-&gt;h_err ? handle-&gt;h_err : err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	sb = handle-&gt;h_transaction-&gt;t_journal-&gt;j_private;
 	err = handle-&gt;h_err;
 	rc = jbd2_journal_stop(handle);
<span class="p_header">diff --git a/fs/ext4/extents.c b/fs/ext4/extents.c</span>
<span class="p_header">index 30dee3c..410841e 100644</span>
<span class="p_header">--- a/fs/ext4/extents.c</span>
<span class="p_header">+++ b/fs/ext4/extents.c</span>
<span class="p_chunk">@@ -377,7 +377,7 @@</span> <span class="p_context"> static int ext4_valid_extent(struct inode *inode, struct ext4_extent *ext)</span>
 	ext4_lblk_t lblock = le32_to_cpu(ext-&gt;ee_block);
 	ext4_lblk_t last = lblock + len - 1;
 
<span class="p_del">-	if (lblock &gt; last)</span>
<span class="p_add">+	if (len == 0 || lblock &gt; last)</span>
 		return 0;
 	return ext4_data_block_valid(EXT4_SB(inode-&gt;i_sb), block, len);
 }
<span class="p_header">diff --git a/fs/jbd2/recovery.c b/fs/jbd2/recovery.c</span>
<span class="p_header">index bcbef08..a5f72a3 100644</span>
<span class="p_header">--- a/fs/jbd2/recovery.c</span>
<span class="p_header">+++ b/fs/jbd2/recovery.c</span>
<span class="p_chunk">@@ -839,15 +839,23 @@</span> <span class="p_context"> static int scan_revoke_records(journal_t *journal, struct buffer_head *bh,</span>
 {
 	jbd2_journal_revoke_header_t *header;
 	int offset, max;
<span class="p_add">+	int csum_size = 0;</span>
<span class="p_add">+	__u32 rcount;</span>
 	int record_len = 4;
 
 	header = (jbd2_journal_revoke_header_t *) bh-&gt;b_data;
 	offset = sizeof(jbd2_journal_revoke_header_t);
<span class="p_del">-	max = be32_to_cpu(header-&gt;r_count);</span>
<span class="p_add">+	rcount = be32_to_cpu(header-&gt;r_count);</span>
 
 	if (!jbd2_revoke_block_csum_verify(journal, header))
 		return -EINVAL;
 
<span class="p_add">+	if (jbd2_journal_has_csum_v2or3(journal))</span>
<span class="p_add">+		csum_size = sizeof(struct jbd2_journal_revoke_tail);</span>
<span class="p_add">+	if (rcount &gt; journal-&gt;j_blocksize - csum_size)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	max = rcount;</span>
<span class="p_add">+</span>
 	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))
 		record_len = 8;
 
<span class="p_header">diff --git a/fs/jbd2/revoke.c b/fs/jbd2/revoke.c</span>
<span class="p_header">index c6cbaef..14214da 100644</span>
<span class="p_header">--- a/fs/jbd2/revoke.c</span>
<span class="p_header">+++ b/fs/jbd2/revoke.c</span>
<span class="p_chunk">@@ -577,7 +577,7 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 {
 	int csum_size = 0;
 	struct buffer_head *descriptor;
<span class="p_del">-	int offset;</span>
<span class="p_add">+	int sz, offset;</span>
 	journal_header_t *header;
 
 	/* If we are already aborting, this all becomes a noop.  We
<span class="p_chunk">@@ -594,9 +594,14 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 	if (jbd2_journal_has_csum_v2or3(journal))
 		csum_size = sizeof(struct jbd2_journal_revoke_tail);
 
<span class="p_add">+	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))</span>
<span class="p_add">+		sz = 8;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		sz = 4;</span>
<span class="p_add">+</span>
 	/* Make sure we have a descriptor with space left for the record */
 	if (descriptor) {
<span class="p_del">-		if (offset &gt;= journal-&gt;j_blocksize - csum_size) {</span>
<span class="p_add">+		if (offset + sz &gt; journal-&gt;j_blocksize - csum_size) {</span>
 			flush_descriptor(journal, descriptor, offset, write_op);
 			descriptor = NULL;
 		}
<span class="p_chunk">@@ -619,16 +624,13 @@</span> <span class="p_context"> static void write_one_revoke_record(journal_t *journal,</span>
 		*descriptorp = descriptor;
 	}
 
<span class="p_del">-	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT)) {</span>
<span class="p_add">+	if (JBD2_HAS_INCOMPAT_FEATURE(journal, JBD2_FEATURE_INCOMPAT_64BIT))</span>
 		* ((__be64 *)(&amp;descriptor-&gt;b_data[offset])) =
 			cpu_to_be64(record-&gt;blocknr);
<span class="p_del">-		offset += 8;</span>
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_add">+	else</span>
 		* ((__be32 *)(&amp;descriptor-&gt;b_data[offset])) =
 			cpu_to_be32(record-&gt;blocknr);
<span class="p_del">-		offset += 4;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	offset += sz;</span>
 
 	*offsetp = offset;
 }
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 5f09370..ff2f2e6 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -551,7 +551,6 @@</span> <span class="p_context"> int jbd2_journal_extend(handle_t *handle, int nblocks)</span>
 	int result;
 	int wanted;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -627,7 +626,6 @@</span> <span class="p_context"> int jbd2__journal_restart(handle_t *handle, int nblocks, gfp_t gfp_mask)</span>
 	tid_t		tid;
 	int		need_to_start, ret;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	/* If we&#39;ve had an abort of any type, don&#39;t even think about
 	 * actually doing the restart! */
 	if (is_handle_aborted(handle))
<span class="p_chunk">@@ -785,7 +783,6 @@</span> <span class="p_context"> do_get_write_access(handle_t *handle, struct journal_head *jh,</span>
 	int need_copy = 0;
 	unsigned long start_lock, time_lock;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1051,7 +1048,6 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 	int err;
 
 	jbd_debug(5, &quot;journal_head %p\n&quot;, jh);
<span class="p_del">-	WARN_ON(!transaction);</span>
 	err = -EROFS;
 	if (is_handle_aborted(handle))
 		goto out;
<span class="p_chunk">@@ -1266,7 +1262,6 @@</span> <span class="p_context"> int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)</span>
 	struct journal_head *jh;
 	int ret = 0;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1397,7 +1392,6 @@</span> <span class="p_context"> int jbd2_journal_forget (handle_t *handle, struct buffer_head *bh)</span>
 	int err = 0;
 	int was_modified = 0;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_chunk">@@ -1530,8 +1524,22 @@</span> <span class="p_context"> int jbd2_journal_stop(handle_t *handle)</span>
 	tid_t tid;
 	pid_t pid;
 
<span class="p_del">-	if (!transaction)</span>
<span class="p_del">-		goto free_and_exit;</span>
<span class="p_add">+	if (!transaction) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Handle is already detached from the transaction so</span>
<span class="p_add">+		 * there is nothing to do other than decrease a refcount,</span>
<span class="p_add">+		 * or free the handle if refcount drops to zero</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (--handle-&gt;h_ref &gt; 0) {</span>
<span class="p_add">+			jbd_debug(4, &quot;h_ref %d -&gt; %d\n&quot;, handle-&gt;h_ref + 1,</span>
<span class="p_add">+							 handle-&gt;h_ref);</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			if (handle-&gt;h_rsv_handle)</span>
<span class="p_add">+				jbd2_free_handle(handle-&gt;h_rsv_handle);</span>
<span class="p_add">+			goto free_and_exit;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	journal = transaction-&gt;t_journal;
 
 	J_ASSERT(journal_current_handle() == handle);
<span class="p_chunk">@@ -2373,7 +2381,6 @@</span> <span class="p_context"> int jbd2_journal_file_inode(handle_t *handle, struct jbd2_inode *jinode)</span>
 	transaction_t *transaction = handle-&gt;h_transaction;
 	journal_t *journal;
 
<span class="p_del">-	WARN_ON(!transaction);</span>
 	if (is_handle_aborted(handle))
 		return -EROFS;
 	journal = transaction-&gt;t_journal;
<span class="p_header">diff --git a/fs/nfsd/nfs4state.c b/fs/nfsd/nfs4state.c</span>
<span class="p_header">index ddacc43..ef0a612 100644</span>
<span class="p_header">--- a/fs/nfsd/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfsd/nfs4state.c</span>
<span class="p_chunk">@@ -4392,10 +4392,17 @@</span> <span class="p_context"> static __be32 check_stateid_generation(stateid_t *in, stateid_t *ref, bool has_s</span>
 	return nfserr_old_stateid;
 }
 
<span class="p_add">+static __be32 nfsd4_check_openowner_confirmed(struct nfs4_ol_stateid *ols)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (ols-&gt;st_stateowner-&gt;so_is_open_owner &amp;&amp;</span>
<span class="p_add">+	    !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		return nfserr_bad_stateid;</span>
<span class="p_add">+	return nfs_ok;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)
 {
 	struct nfs4_stid *s;
<span class="p_del">-	struct nfs4_ol_stateid *ols;</span>
 	__be32 status = nfserr_bad_stateid;
 
 	if (ZERO_STATEID(stateid) || ONE_STATEID(stateid))
<span class="p_chunk">@@ -4425,13 +4432,7 @@</span> <span class="p_context"> static __be32 nfsd4_validate_stateid(struct nfs4_client *cl, stateid_t *stateid)</span>
 		break;
 	case NFS4_OPEN_STID:
 	case NFS4_LOCK_STID:
<span class="p_del">-		ols = openlockstateid(s);</span>
<span class="p_del">-		if (ols-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-	    			&amp;&amp; !(openowner(ols-&gt;st_stateowner)-&gt;oo_flags</span>
<span class="p_del">-						&amp; NFS4_OO_CONFIRMED))</span>
<span class="p_del">-			status = nfserr_bad_stateid;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			status = nfs_ok;</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(openlockstateid(s));</span>
 		break;
 	default:
 		printk(&quot;unknown stateid type %x\n&quot;, s-&gt;sc_type);
<span class="p_chunk">@@ -4523,8 +4524,8 @@</span> <span class="p_context"> nfs4_preprocess_stateid_op(struct net *net, struct nfsd4_compound_state *cstate,</span>
 		status = nfs4_check_fh(current_fh, stp);
 		if (status)
 			goto out;
<span class="p_del">-		if (stp-&gt;st_stateowner-&gt;so_is_open_owner</span>
<span class="p_del">-		    &amp;&amp; !(openowner(stp-&gt;st_stateowner)-&gt;oo_flags &amp; NFS4_OO_CONFIRMED))</span>
<span class="p_add">+		status = nfsd4_check_openowner_confirmed(stp);</span>
<span class="p_add">+		if (status)</span>
 			goto out;
 		status = nfs4_check_openmode(stp, flags);
 		if (status)
<span class="p_header">diff --git a/fs/nfsd/nfsctl.c b/fs/nfsd/nfsctl.c</span>
<span class="p_header">index 19ace74..336a06b 100644</span>
<span class="p_header">--- a/fs/nfsd/nfsctl.c</span>
<span class="p_header">+++ b/fs/nfsd/nfsctl.c</span>
<span class="p_chunk">@@ -1249,15 +1249,15 @@</span> <span class="p_context"> static int __init init_nfsd(void)</span>
 	int retval;
 	printk(KERN_INFO &quot;Installing knfsd (copyright (C) 1996 okir@monad.swb.de).\n&quot;);
 
<span class="p_del">-	retval = register_cld_notifier();</span>
<span class="p_del">-	if (retval)</span>
<span class="p_del">-		return retval;</span>
 	retval = register_pernet_subsys(&amp;nfsd_net_ops);
 	if (retval &lt; 0)
<span class="p_del">-		goto out_unregister_notifier;</span>
<span class="p_del">-	retval = nfsd4_init_slabs();</span>
<span class="p_add">+		return retval;</span>
<span class="p_add">+	retval = register_cld_notifier();</span>
 	if (retval)
 		goto out_unregister_pernet;
<span class="p_add">+	retval = nfsd4_init_slabs();</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		goto out_unregister_notifier;</span>
 	retval = nfsd_fault_inject_init(); /* nfsd fault injection controls */
 	if (retval)
 		goto out_free_slabs;
<span class="p_chunk">@@ -1284,10 +1284,10 @@</span> <span class="p_context"> out_free_stat:</span>
 	nfsd_fault_inject_cleanup();
 out_free_slabs:
 	nfsd4_free_slabs();
<span class="p_del">-out_unregister_pernet:</span>
<span class="p_del">-	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 out_unregister_notifier:
 	unregister_cld_notifier();
<span class="p_add">+out_unregister_pernet:</span>
<span class="p_add">+	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -1301,8 +1301,8 @@</span> <span class="p_context"> static void __exit exit_nfsd(void)</span>
 	nfsd4_free_slabs();
 	nfsd_fault_inject_cleanup();
 	unregister_filesystem(&amp;nfsd_fs_type);
<span class="p_del">-	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 	unregister_cld_notifier();
<span class="p_add">+	unregister_pernet_subsys(&amp;nfsd_net_ops);</span>
 }
 
 MODULE_AUTHOR(&quot;Olaf Kirch &lt;okir@monad.swb.de&gt;&quot;);
<span class="p_header">diff --git a/include/drm/drm_pciids.h b/include/drm/drm_pciids.h</span>
<span class="p_header">index 2dd405c..45c39a3 100644</span>
<span class="p_header">--- a/include/drm/drm_pciids.h</span>
<span class="p_header">+++ b/include/drm/drm_pciids.h</span>
<span class="p_chunk">@@ -186,6 +186,7 @@</span> <span class="p_context"></span>
 	{0x1002, 0x6658, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x665c, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x665d, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \
<span class="p_add">+	{0x1002, 0x665f, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_BONAIRE|RADEON_NEW_MEMMAP}, \</span>
 	{0x1002, 0x6660, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6663, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6664, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAINAN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
<span class="p_header">diff --git a/include/linux/jhash.h b/include/linux/jhash.h</span>
<span class="p_header">index 47cb09e..348c6f4 100644</span>
<span class="p_header">--- a/include/linux/jhash.h</span>
<span class="p_header">+++ b/include/linux/jhash.h</span>
<span class="p_chunk">@@ -145,11 +145,11 @@</span> <span class="p_context"> static inline u32 jhash2(const u32 *k, u32 length, u32 initval)</span>
 }
 
 
<span class="p_del">-/* jhash_3words - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_del">-static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+/* __jhash_nwords - hash exactly 3, 2 or 1 word(s) */</span>
<span class="p_add">+static inline u32 __jhash_nwords(u32 a, u32 b, u32 c, u32 initval)</span>
 {
<span class="p_del">-	a += JHASH_INITVAL;</span>
<span class="p_del">-	b += JHASH_INITVAL;</span>
<span class="p_add">+	a += initval;</span>
<span class="p_add">+	b += initval;</span>
 	c += initval;
 
 	__jhash_final(a, b, c);
<span class="p_chunk">@@ -157,14 +157,19 @@</span> <span class="p_context"> static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
 	return c;
 }
 
<span class="p_add">+static inline u32 jhash_3words(u32 a, u32 b, u32 c, u32 initval)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __jhash_nwords(a, b, c, initval + JHASH_INITVAL + (3 &lt;&lt; 2));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline u32 jhash_2words(u32 a, u32 b, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, b, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, b, 0, initval + JHASH_INITVAL + (2 &lt;&lt; 2));</span>
 }
 
 static inline u32 jhash_1word(u32 a, u32 initval)
 {
<span class="p_del">-	return jhash_3words(a, 0, 0, initval);</span>
<span class="p_add">+	return __jhash_nwords(a, 0, 0, initval + JHASH_INITVAL + (1 &lt;&lt; 2));</span>
 }
 
 #endif /* _LINUX_JHASH_H */
<span class="p_header">diff --git a/include/linux/ktime.h b/include/linux/ktime.h</span>
<span class="p_header">index c9d645a..039bbe5 100644</span>
<span class="p_header">--- a/include/linux/ktime.h</span>
<span class="p_header">+++ b/include/linux/ktime.h</span>
<span class="p_chunk">@@ -166,9 +166,34 @@</span> <span class="p_context"> static inline bool ktime_before(const ktime_t cmp1, const ktime_t cmp2)</span>
 }
 
 #if BITS_PER_LONG &lt; 64
<span class="p_del">-extern u64 ktime_divns(const ktime_t kt, s64 div);</span>
<span class="p_add">+extern s64 __ktime_divns(const ktime_t kt, s64 div);</span>
<span class="p_add">+static inline s64 ktime_divns(const ktime_t kt, s64 div)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Negative divisors could cause an inf loop,</span>
<span class="p_add">+	 * so bug out here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUG_ON(div &lt; 0);</span>
<span class="p_add">+	if (__builtin_constant_p(div) &amp;&amp; !(div &gt;&gt; 32)) {</span>
<span class="p_add">+		s64 ns = kt.tv64;</span>
<span class="p_add">+		u64 tmp = ns &lt; 0 ? -ns : ns;</span>
<span class="p_add">+</span>
<span class="p_add">+		do_div(tmp, div);</span>
<span class="p_add">+		return ns &lt; 0 ? -tmp : tmp;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return __ktime_divns(kt, div);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 #else /* BITS_PER_LONG &lt; 64 */
<span class="p_del">-# define ktime_divns(kt, div)		(u64)((kt).tv64 / (div))</span>
<span class="p_add">+static inline s64 ktime_divns(const ktime_t kt, s64 div)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 32-bit implementation cannot handle negative divisors,</span>
<span class="p_add">+	 * so catch them on 64bit as well.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	WARN_ON(div &lt; 0);</span>
<span class="p_add">+	return kt.tv64 / div;</span>
<span class="p_add">+}</span>
 #endif
 
 static inline s64 ktime_to_us(const ktime_t kt)
<span class="p_header">diff --git a/include/linux/libata.h b/include/linux/libata.h</span>
<span class="p_header">index 91f705d..29284b6 100644</span>
<span class="p_header">--- a/include/linux/libata.h</span>
<span class="p_header">+++ b/include/linux/libata.h</span>
<span class="p_chunk">@@ -205,6 +205,7 @@</span> <span class="p_context"> enum {</span>
 	ATA_LFLAG_SW_ACTIVITY	= (1 &lt;&lt; 7), /* keep activity stats */
 	ATA_LFLAG_NO_LPM	= (1 &lt;&lt; 8), /* disable LPM on this link */
 	ATA_LFLAG_RST_ONCE	= (1 &lt;&lt; 9), /* limit recovery to one reset */
<span class="p_add">+	ATA_LFLAG_CHANGED	= (1 &lt;&lt; 10), /* LPM state changed on this link */</span>
 
 	/* struct ata_port flags */
 	ATA_FLAG_SLAVE_POSS	= (1 &lt;&lt; 0), /* host supports slave dev */
<span class="p_chunk">@@ -309,6 +310,12 @@</span> <span class="p_context"> enum {</span>
 	 */
 	ATA_TMOUT_PMP_SRST_WAIT	= 5000,
 
<span class="p_add">+	/* When the LPM policy is set to ATA_LPM_MAX_POWER, there might</span>
<span class="p_add">+	 * be a spurious PHY event, so ignore the first PHY event that</span>
<span class="p_add">+	 * occurs within 10s after the policy change.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ATA_TMOUT_SPURIOUS_PHY	= 10000,</span>
<span class="p_add">+</span>
 	/* ATA bus states */
 	BUS_UNKNOWN		= 0,
 	BUS_DMA			= 1,
<span class="p_chunk">@@ -788,6 +795,8 @@</span> <span class="p_context"> struct ata_link {</span>
 	struct ata_eh_context	eh_context;
 
 	struct ata_device	device[ATA_MAX_DEVICES];
<span class="p_add">+</span>
<span class="p_add">+	unsigned long		last_lpm_change; /* when last LPM change happened */</span>
 };
 #define ATA_LINK_CLEAR_BEGIN		offsetof(struct ata_link, active_tag)
 #define ATA_LINK_CLEAR_END		offsetof(struct ata_link, device[0])
<span class="p_chunk">@@ -1201,6 +1210,7 @@</span> <span class="p_context"> extern struct ata_device *ata_dev_pair(struct ata_device *adev);</span>
 extern int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev);
 extern void ata_scsi_port_error_handler(struct Scsi_Host *host, struct ata_port *ap);
 extern void ata_scsi_cmd_error_handler(struct Scsi_Host *host, struct ata_port *ap, struct list_head *eh_q);
<span class="p_add">+extern bool sata_lpm_ignore_phy_events(struct ata_link *link);</span>
 
 extern int ata_cable_40wire(struct ata_port *ap);
 extern int ata_cable_80wire(struct ata_port *ap);
<span class="p_header">diff --git a/include/linux/sched.h b/include/linux/sched.h</span>
<span class="p_header">index 8db31ef..9607fb3 100644</span>
<span class="p_header">--- a/include/linux/sched.h</span>
<span class="p_header">+++ b/include/linux/sched.h</span>
<span class="p_chunk">@@ -176,6 +176,14 @@</span> <span class="p_context"> extern void get_iowait_load(unsigned long *nr_waiters, unsigned long *load);</span>
 extern void calc_global_load(unsigned long ticks);
 extern void update_cpu_load_nohz(void);
 
<span class="p_add">+/* Notifier for when a task gets migrated to a new CPU */</span>
<span class="p_add">+struct task_migration_notifier {</span>
<span class="p_add">+	struct task_struct *task;</span>
<span class="p_add">+	int from_cpu;</span>
<span class="p_add">+	int to_cpu;</span>
<span class="p_add">+};</span>
<span class="p_add">+extern void register_task_migration_notifier(struct notifier_block *n);</span>
<span class="p_add">+</span>
 extern unsigned long get_parent_ip(unsigned long addr);
 
 extern void dump_cpu_task(int cpu);
<span class="p_header">diff --git a/include/linux/sched/rt.h b/include/linux/sched/rt.h</span>
<span class="p_header">index 6341f5b..a30b172 100644</span>
<span class="p_header">--- a/include/linux/sched/rt.h</span>
<span class="p_header">+++ b/include/linux/sched/rt.h</span>
<span class="p_chunk">@@ -18,7 +18,7 @@</span> <span class="p_context"> static inline int rt_task(struct task_struct *p)</span>
 #ifdef CONFIG_RT_MUTEXES
 extern int rt_mutex_getprio(struct task_struct *p);
 extern void rt_mutex_setprio(struct task_struct *p, int prio);
<span class="p_del">-extern int rt_mutex_check_prio(struct task_struct *task, int newprio);</span>
<span class="p_add">+extern int rt_mutex_get_effective_prio(struct task_struct *task, int newprio);</span>
 extern struct task_struct *rt_mutex_get_top_task(struct task_struct *task);
 extern void rt_mutex_adjust_pi(struct task_struct *p);
 static inline bool tsk_is_pi_blocked(struct task_struct *tsk)
<span class="p_chunk">@@ -31,9 +31,10 @@</span> <span class="p_context"> static inline int rt_mutex_getprio(struct task_struct *p)</span>
 	return p-&gt;normal_prio;
 }
 
<span class="p_del">-static inline int rt_mutex_check_prio(struct task_struct *task, int newprio)</span>
<span class="p_add">+static inline int rt_mutex_get_effective_prio(struct task_struct *task,</span>
<span class="p_add">+					      int newprio)</span>
 {
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return newprio;</span>
 }
 
 static inline struct task_struct *rt_mutex_get_top_task(struct task_struct *task)
<span class="p_header">diff --git a/include/linux/tty.h b/include/linux/tty.h</span>
<span class="p_header">index 7d66ae5..8716524 100644</span>
<span class="p_header">--- a/include/linux/tty.h</span>
<span class="p_header">+++ b/include/linux/tty.h</span>
<span class="p_chunk">@@ -316,6 +316,7 @@</span> <span class="p_context"> struct tty_file_private {</span>
 #define TTY_EXCLUSIVE 		3	/* Exclusive open mode */
 #define TTY_DEBUG 		4	/* Debugging */
 #define TTY_DO_WRITE_WAKEUP 	5	/* Call write_wakeup after queuing new */
<span class="p_add">+#define TTY_OTHER_DONE		6	/* Closed pty has completed input processing */</span>
 #define TTY_LDISC_OPEN	 	11	/* Line discipline is open */
 #define TTY_PTY_LOCK 		16	/* pty private */
 #define TTY_NO_WRITE_SPLIT 	17	/* Preserve write boundaries to driver */
<span class="p_chunk">@@ -439,7 +440,6 @@</span> <span class="p_context"> extern int tty_hung_up_p(struct file *filp);</span>
 extern void do_SAK(struct tty_struct *tty);
 extern void __do_SAK(struct tty_struct *tty);
 extern void no_tty(void);
<span class="p_del">-extern void tty_flush_to_ldisc(struct tty_struct *tty);</span>
 extern void tty_buffer_free_all(struct tty_port *port);
 extern void tty_buffer_flush(struct tty_struct *tty, struct tty_ldisc *ld);
 extern void tty_buffer_init(struct tty_port *port);
<span class="p_header">diff --git a/include/net/inet_connection_sock.h b/include/net/inet_connection_sock.h</span>
<span class="p_header">index 848e85c..24d5c09 100644</span>
<span class="p_header">--- a/include/net/inet_connection_sock.h</span>
<span class="p_header">+++ b/include/net/inet_connection_sock.h</span>
<span class="p_chunk">@@ -98,7 +98,8 @@</span> <span class="p_context"> struct inet_connection_sock {</span>
 	const struct tcp_congestion_ops *icsk_ca_ops;
 	const struct inet_connection_sock_af_ops *icsk_af_ops;
 	unsigned int		  (*icsk_sync_mss)(struct sock *sk, u32 pmtu);
<span class="p_del">-	__u8			  icsk_ca_state;</span>
<span class="p_add">+	__u8			  icsk_ca_state:7,</span>
<span class="p_add">+				  icsk_ca_setsockopt:1;</span>
 	__u8			  icsk_retransmits;
 	__u8			  icsk_pending;
 	__u8			  icsk_backoff;
<span class="p_header">diff --git a/include/net/sctp/sctp.h b/include/net/sctp/sctp.h</span>
<span class="p_header">index 856f01c..230775f 100644</span>
<span class="p_header">--- a/include/net/sctp/sctp.h</span>
<span class="p_header">+++ b/include/net/sctp/sctp.h</span>
<span class="p_chunk">@@ -571,11 +571,14 @@</span> <span class="p_context"> static inline void sctp_v6_map_v4(union sctp_addr *addr)</span>
 /* Map v4 address to v4-mapped v6 address */
 static inline void sctp_v4_map_v6(union sctp_addr *addr)
 {
<span class="p_add">+	__be16 port;</span>
<span class="p_add">+</span>
<span class="p_add">+	port = addr-&gt;v4.sin_port;</span>
<span class="p_add">+	addr-&gt;v6.sin6_addr.s6_addr32[3] = addr-&gt;v4.sin_addr.s_addr;</span>
<span class="p_add">+	addr-&gt;v6.sin6_port = port;</span>
 	addr-&gt;v6.sin6_family = AF_INET6;
 	addr-&gt;v6.sin6_flowinfo = 0;
 	addr-&gt;v6.sin6_scope_id = 0;
<span class="p_del">-	addr-&gt;v6.sin6_port = addr-&gt;v4.sin_port;</span>
<span class="p_del">-	addr-&gt;v6.sin6_addr.s6_addr32[3] = addr-&gt;v4.sin_addr.s_addr;</span>
 	addr-&gt;v6.sin6_addr.s6_addr32[0] = 0;
 	addr-&gt;v6.sin6_addr.s6_addr32[1] = 0;
 	addr-&gt;v6.sin6_addr.s6_addr32[2] = htonl(0x0000ffff);
<span class="p_header">diff --git a/include/uapi/linux/netfilter/nf_conntrack_tcp.h b/include/uapi/linux/netfilter/nf_conntrack_tcp.h</span>
<span class="p_header">index 9993a42..ef9f80f 100644</span>
<span class="p_header">--- a/include/uapi/linux/netfilter/nf_conntrack_tcp.h</span>
<span class="p_header">+++ b/include/uapi/linux/netfilter/nf_conntrack_tcp.h</span>
<span class="p_chunk">@@ -42,6 +42,9 @@</span> <span class="p_context"> enum tcp_conntrack {</span>
 /* The field td_maxack has been set */
 #define IP_CT_TCP_FLAG_MAXACK_SET		0x20
 
<span class="p_add">+/* Marks possibility for expected RFC5961 challenge ACK */</span>
<span class="p_add">+#define IP_CT_EXP_CHALLENGE_ACK 		0x40</span>
<span class="p_add">+</span>
 struct nf_ct_tcp_flags {
 	__u8 flags;
 	__u8 mask;
<span class="p_header">diff --git a/include/xen/events.h b/include/xen/events.h</span>
<span class="p_header">index 5321cd9..7d95fdf 100644</span>
<span class="p_header">--- a/include/xen/events.h</span>
<span class="p_header">+++ b/include/xen/events.h</span>
<span class="p_chunk">@@ -17,7 +17,7 @@</span> <span class="p_context"> int bind_evtchn_to_irqhandler(unsigned int evtchn,</span>
 			      irq_handler_t handler,
 			      unsigned long irqflags, const char *devname,
 			      void *dev_id);
<span class="p_del">-int bind_virq_to_irq(unsigned int virq, unsigned int cpu);</span>
<span class="p_add">+int bind_virq_to_irq(unsigned int virq, unsigned int cpu, bool percpu);</span>
 int bind_virq_to_irqhandler(unsigned int virq, unsigned int cpu,
 			    irq_handler_t handler,
 			    unsigned long irqflags, const char *devname,
<span class="p_header">diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c</span>
<span class="p_header">index 41d53e5..1929ee2 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex.c</span>
<span class="p_header">+++ b/kernel/locking/rtmutex.c</span>
<span class="p_chunk">@@ -265,15 +265,17 @@</span> <span class="p_context"> struct task_struct *rt_mutex_get_top_task(struct task_struct *task)</span>
 }
 
 /*
<span class="p_del">- * Called by sched_setscheduler() to check whether the priority change</span>
<span class="p_del">- * is overruled by a possible priority boosting.</span>
<span class="p_add">+ * Called by sched_setscheduler() to get the priority which will be</span>
<span class="p_add">+ * effective after the change.</span>
  */
<span class="p_del">-int rt_mutex_check_prio(struct task_struct *task, int newprio)</span>
<span class="p_add">+int rt_mutex_get_effective_prio(struct task_struct *task, int newprio)</span>
 {
 	if (!task_has_pi_waiters(task))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		return newprio;</span>
 
<span class="p_del">-	return task_top_pi_waiter(task)-&gt;task-&gt;prio &lt;= newprio;</span>
<span class="p_add">+	if (task_top_pi_waiter(task)-&gt;task-&gt;prio &lt;= newprio)</span>
<span class="p_add">+		return task_top_pi_waiter(task)-&gt;task-&gt;prio;</span>
<span class="p_add">+	return newprio;</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index d400c82..c90b977 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -1054,6 +1054,13 @@</span> <span class="p_context"> void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags)</span>
 		rq-&gt;skip_clock_update = 1;
 }
 
<span class="p_add">+static ATOMIC_NOTIFIER_HEAD(task_migration_notifier);</span>
<span class="p_add">+</span>
<span class="p_add">+void register_task_migration_notifier(struct notifier_block *n)</span>
<span class="p_add">+{</span>
<span class="p_add">+	atomic_notifier_chain_register(&amp;task_migration_notifier, n);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_SMP
 void set_task_cpu(struct task_struct *p, unsigned int new_cpu)
 {
<span class="p_chunk">@@ -1084,10 +1091,18 @@</span> <span class="p_context"> void set_task_cpu(struct task_struct *p, unsigned int new_cpu)</span>
 	trace_sched_migrate_task(p, new_cpu);
 
 	if (task_cpu(p) != new_cpu) {
<span class="p_add">+		struct task_migration_notifier tmn;</span>
<span class="p_add">+</span>
 		if (p-&gt;sched_class-&gt;migrate_task_rq)
 			p-&gt;sched_class-&gt;migrate_task_rq(p, new_cpu);
 		p-&gt;se.nr_migrations++;
 		perf_sw_event(PERF_COUNT_SW_CPU_MIGRATIONS, 1, NULL, 0);
<span class="p_add">+</span>
<span class="p_add">+		tmn.task = p;</span>
<span class="p_add">+		tmn.from_cpu = task_cpu(p);</span>
<span class="p_add">+		tmn.to_cpu = new_cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+		atomic_notifier_call_chain(&amp;task_migration_notifier, 0, &amp;tmn);</span>
 	}
 
 	__set_task_cpu(p, new_cpu);
<span class="p_chunk">@@ -3325,15 +3340,18 @@</span> <span class="p_context"> static void __setscheduler_params(struct task_struct *p,</span>
 
 /* Actually do priority change: must hold pi &amp; rq lock. */
 static void __setscheduler(struct rq *rq, struct task_struct *p,
<span class="p_del">-			   const struct sched_attr *attr)</span>
<span class="p_add">+			   const struct sched_attr *attr, bool keep_boost)</span>
 {
 	__setscheduler_params(p, attr);
 
 	/*
<span class="p_del">-	 * If we get here, there was no pi waiters boosting the</span>
<span class="p_del">-	 * task. It is safe to use the normal prio.</span>
<span class="p_add">+	 * Keep a potential priority boosting if called from</span>
<span class="p_add">+	 * sched_setscheduler().</span>
 	 */
<span class="p_del">-	p-&gt;prio = normal_prio(p);</span>
<span class="p_add">+	if (keep_boost)</span>
<span class="p_add">+		p-&gt;prio = rt_mutex_get_effective_prio(p, normal_prio(p));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		p-&gt;prio = normal_prio(p);</span>
 
 	if (dl_prio(p-&gt;prio))
 		p-&gt;sched_class = &amp;dl_sched_class;
<span class="p_chunk">@@ -3419,7 +3437,7 @@</span> <span class="p_context"> static int __sched_setscheduler(struct task_struct *p,</span>
 	int newprio = dl_policy(attr-&gt;sched_policy) ? MAX_DL_PRIO - 1 :
 		      MAX_RT_PRIO - 1 - attr-&gt;sched_priority;
 	int retval, oldprio, oldpolicy = -1, queued, running;
<span class="p_del">-	int policy = attr-&gt;sched_policy;</span>
<span class="p_add">+	int new_effective_prio, policy = attr-&gt;sched_policy;</span>
 	unsigned long flags;
 	const struct sched_class *prev_class;
 	struct rq *rq;
<span class="p_chunk">@@ -3601,15 +3619,14 @@</span> <span class="p_context"> change:</span>
 	oldprio = p-&gt;prio;
 
 	/*
<span class="p_del">-	 * Special case for priority boosted tasks.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * If the new priority is lower or equal (user space view)</span>
<span class="p_del">-	 * than the current (boosted) priority, we just store the new</span>
<span class="p_add">+	 * Take priority boosted tasks into account. If the new</span>
<span class="p_add">+	 * effective priority is unchanged, we just store the new</span>
 	 * normal parameters and do not touch the scheduler class and
 	 * the runqueue. This will be done when the task deboost
 	 * itself.
 	 */
<span class="p_del">-	if (rt_mutex_check_prio(p, newprio)) {</span>
<span class="p_add">+	new_effective_prio = rt_mutex_get_effective_prio(p, newprio);</span>
<span class="p_add">+	if (new_effective_prio == oldprio) {</span>
 		__setscheduler_params(p, attr);
 		task_rq_unlock(rq, p, &amp;flags);
 		return 0;
<span class="p_chunk">@@ -3623,7 +3640,7 @@</span> <span class="p_context"> change:</span>
 		put_prev_task(rq, p);
 
 	prev_class = p-&gt;sched_class;
<span class="p_del">-	__setscheduler(rq, p, attr);</span>
<span class="p_add">+	__setscheduler(rq, p, attr, true);</span>
 
 	if (running)
 		p-&gt;sched_class-&gt;set_curr_task(rq);
<span class="p_chunk">@@ -7385,7 +7402,7 @@</span> <span class="p_context"> static void normalize_task(struct rq *rq, struct task_struct *p)</span>
 	queued = task_on_rq_queued(p);
 	if (queued)
 		dequeue_task(rq, p, 0);
<span class="p_del">-	__setscheduler(rq, p, &amp;attr);</span>
<span class="p_add">+	__setscheduler(rq, p, &amp;attr, false);</span>
 	if (queued) {
 		enqueue_task(rq, p, 0);
 		resched_curr(rq);
<span class="p_header">diff --git a/kernel/time/hrtimer.c b/kernel/time/hrtimer.c</span>
<span class="p_header">index d8c724c..210b848 100644</span>
<span class="p_header">--- a/kernel/time/hrtimer.c</span>
<span class="p_header">+++ b/kernel/time/hrtimer.c</span>
<span class="p_chunk">@@ -266,23 +266,25 @@</span> <span class="p_context"> lock_hrtimer_base(const struct hrtimer *timer, unsigned long *flags)</span>
 /*
  * Divide a ktime value by a nanosecond value
  */
<span class="p_del">-u64 ktime_divns(const ktime_t kt, s64 div)</span>
<span class="p_add">+s64 __ktime_divns(const ktime_t kt, s64 div)</span>
 {
<span class="p_del">-	u64 dclc;</span>
 	int sft = 0;
<span class="p_add">+	s64 dclc;</span>
<span class="p_add">+	u64 tmp;</span>
 
 	dclc = ktime_to_ns(kt);
<span class="p_add">+	tmp = dclc &lt; 0 ? -dclc : dclc;</span>
<span class="p_add">+</span>
 	/* Make sure the divisor is less than 2^32: */
 	while (div &gt;&gt; 32) {
 		sft++;
 		div &gt;&gt;= 1;
 	}
<span class="p_del">-	dclc &gt;&gt;= sft;</span>
<span class="p_del">-	do_div(dclc, (unsigned long) div);</span>
<span class="p_del">-</span>
<span class="p_del">-	return dclc;</span>
<span class="p_add">+	tmp &gt;&gt;= sft;</span>
<span class="p_add">+	do_div(tmp, (unsigned long) div);</span>
<span class="p_add">+	return dclc &lt; 0 ? -tmp : tmp;</span>
 }
<span class="p_del">-EXPORT_SYMBOL_GPL(ktime_divns);</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(__ktime_divns);</span>
 #endif /* BITS_PER_LONG &gt;= 64 */
 
 /*
<span class="p_header">diff --git a/mm/mempolicy.c b/mm/mempolicy.c</span>
<span class="p_header">index 0e0961b..bf20260 100644</span>
<span class="p_header">--- a/mm/mempolicy.c</span>
<span class="p_header">+++ b/mm/mempolicy.c</span>
<span class="p_chunk">@@ -2537,7 +2537,7 @@</span> <span class="p_context"> static void __init check_numabalancing_enable(void)</span>
 	if (numabalancing_override)
 		set_numabalancing_state(numabalancing_override == 1);
 
<span class="p_del">-	if (nr_node_ids &gt; 1 &amp;&amp; !numabalancing_override) {</span>
<span class="p_add">+	if (num_online_nodes() &gt; 1 &amp;&amp; !numabalancing_override) {</span>
 		pr_info(&quot;%s automatic NUMA balancing. &quot;
 			&quot;Configure with numa_balancing= or the &quot;
 			&quot;kernel.numa_balancing sysctl&quot;,
<span class="p_header">diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c</span>
<span class="p_header">index cc36e59..79f59c5 100644</span>
<span class="p_header">--- a/net/bridge/br_fdb.c</span>
<span class="p_header">+++ b/net/bridge/br_fdb.c</span>
<span class="p_chunk">@@ -790,9 +790,11 @@</span> <span class="p_context"> static int __br_fdb_add(struct ndmsg *ndm, struct net_bridge_port *p,</span>
 	int err = 0;
 
 	if (ndm-&gt;ndm_flags &amp; NTF_USE) {
<span class="p_add">+		local_bh_disable();</span>
 		rcu_read_lock();
 		br_fdb_update(p-&gt;br, p, addr, vid, true);
 		rcu_read_unlock();
<span class="p_add">+		local_bh_enable();</span>
 	} else {
 		spin_lock_bh(&amp;p-&gt;br-&gt;hash_lock);
 		err = fdb_add_entry(p, addr, ndm-&gt;ndm_state,
<span class="p_header">diff --git a/net/bridge/br_mdb.c b/net/bridge/br_mdb.c</span>
<span class="p_header">index 5df0526..d8b1833 100644</span>
<span class="p_header">--- a/net/bridge/br_mdb.c</span>
<span class="p_header">+++ b/net/bridge/br_mdb.c</span>
<span class="p_chunk">@@ -170,7 +170,7 @@</span> <span class="p_context"> static int nlmsg_populate_mdb_fill(struct sk_buff *skb,</span>
 	struct br_port_msg *bpm;
 	struct nlattr *nest, *nest2;
 
<span class="p_del">-	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), NLM_F_MULTI);</span>
<span class="p_add">+	nlh = nlmsg_put(skb, pid, seq, type, sizeof(*bpm), 0);</span>
 	if (!nlh)
 		return -EMSGSIZE;
 
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index c465876..b0aee78 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -1071,7 +1071,7 @@</span> <span class="p_context"> static int br_ip6_multicast_mld2_report(struct net_bridge *br,</span>
 
 		err = br_ip6_multicast_add_group(br, port, &amp;grec-&gt;grec_mca,
 						 vid);
<span class="p_del">-		if (!err)</span>
<span class="p_add">+		if (err)</span>
 			break;
 	}
 
<span class="p_chunk">@@ -1821,7 +1821,7 @@</span> <span class="p_context"> static void br_multicast_query_expired(struct net_bridge *br,</span>
 	if (query-&gt;startup_sent &lt; br-&gt;multicast_startup_query_count)
 		query-&gt;startup_sent++;
 
<span class="p_del">-	RCU_INIT_POINTER(querier, NULL);</span>
<span class="p_add">+	RCU_INIT_POINTER(querier-&gt;port, NULL);</span>
 	br_multicast_send_query(br, NULL, query);
 	spin_unlock(&amp;br-&gt;multicast_lock);
 }
<span class="p_header">diff --git a/net/caif/caif_socket.c b/net/caif/caif_socket.c</span>
<span class="p_header">index a6e2da0..982101c 100644</span>
<span class="p_header">--- a/net/caif/caif_socket.c</span>
<span class="p_header">+++ b/net/caif/caif_socket.c</span>
<span class="p_chunk">@@ -330,6 +330,10 @@</span> <span class="p_context"> static long caif_stream_data_wait(struct sock *sk, long timeo)</span>
 		release_sock(sk);
 		timeo = schedule_timeout(timeo);
 		lock_sock(sk);
<span class="p_add">+</span>
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		clear_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);
 	}
 
<span class="p_chunk">@@ -374,6 +378,10 @@</span> <span class="p_context"> static int caif_stream_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 		struct sk_buff *skb;
 
 		lock_sock(sk);
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD)) {</span>
<span class="p_add">+			err = -ECONNRESET;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 		skb = skb_dequeue(&amp;sk-&gt;sk_receive_queue);
 		caif_check_flow_release(sk);
 
<span class="p_header">diff --git a/net/ceph/osd_client.c b/net/ceph/osd_client.c</span>
<span class="p_header">index f693a2f..9871411 100644</span>
<span class="p_header">--- a/net/ceph/osd_client.c</span>
<span class="p_header">+++ b/net/ceph/osd_client.c</span>
<span class="p_chunk">@@ -1305,8 +1305,6 @@</span> <span class="p_context"> static void __unregister_linger_request(struct ceph_osd_client *osdc,</span>
 		if (list_empty(&amp;req-&gt;r_osd_item))
 			req-&gt;r_osd = NULL;
 	}
<span class="p_del">-</span>
<span class="p_del">-	list_del_init(&amp;req-&gt;r_req_lru_item); /* can be on notarget */</span>
 	ceph_osdc_put_request(req);
 }
 
<span class="p_chunk">@@ -2016,20 +2014,29 @@</span> <span class="p_context"> static void kick_requests(struct ceph_osd_client *osdc, bool force_resend,</span>
 		err = __map_request(osdc, req,
 				    force_resend || force_resend_writes);
 		dout(&quot;__map_request returned %d\n&quot;, err);
<span class="p_del">-		if (err == 0)</span>
<span class="p_del">-			continue;  /* no change and no osd was specified */</span>
 		if (err &lt; 0)
 			continue;  /* hrm! */
<span class="p_del">-		if (req-&gt;r_osd == NULL) {</span>
<span class="p_del">-			dout(&quot;tid %llu maps to no valid osd\n&quot;, req-&gt;r_tid);</span>
<span class="p_del">-			needmap++;  /* request a newer map */</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (req-&gt;r_osd == NULL || err &gt; 0) {</span>
<span class="p_add">+			if (req-&gt;r_osd == NULL) {</span>
<span class="p_add">+				dout(&quot;lingering %p tid %llu maps to no osd\n&quot;,</span>
<span class="p_add">+				     req, req-&gt;r_tid);</span>
<span class="p_add">+				/*</span>
<span class="p_add">+				 * A homeless lingering request makes</span>
<span class="p_add">+				 * no sense, as it&#39;s job is to keep</span>
<span class="p_add">+				 * a particular OSD connection open.</span>
<span class="p_add">+				 * Request a newer map and kick the</span>
<span class="p_add">+				 * request, knowing that it won&#39;t be</span>
<span class="p_add">+				 * resent until we actually get a map</span>
<span class="p_add">+				 * that can tell us where to send it.</span>
<span class="p_add">+				 */</span>
<span class="p_add">+				needmap++;</span>
<span class="p_add">+			}</span>
 
<span class="p_del">-		dout(&quot;kicking lingering %p tid %llu osd%d\n&quot;, req, req-&gt;r_tid,</span>
<span class="p_del">-		     req-&gt;r_osd ? req-&gt;r_osd-&gt;o_osd : -1);</span>
<span class="p_del">-		__register_request(osdc, req);</span>
<span class="p_del">-		__unregister_linger_request(osdc, req);</span>
<span class="p_add">+			dout(&quot;kicking lingering %p tid %llu osd%d\n&quot;, req,</span>
<span class="p_add">+			     req-&gt;r_tid, req-&gt;r_osd ? req-&gt;r_osd-&gt;o_osd : -1);</span>
<span class="p_add">+			__register_request(osdc, req);</span>
<span class="p_add">+			__unregister_linger_request(osdc, req);</span>
<span class="p_add">+		}</span>
 	}
 	reset_changed_osds(osdc);
 	mutex_unlock(&amp;osdc-&gt;request_mutex);
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 5dd905c..307e744f 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -5131,7 +5131,7 @@</span> <span class="p_context"> static int __netdev_upper_dev_link(struct net_device *dev,</span>
 	if (__netdev_find_adj(upper_dev, dev, &amp;upper_dev-&gt;all_adj_list.upper))
 		return -EBUSY;
 
<span class="p_del">-	if (__netdev_find_adj(dev, upper_dev, &amp;dev-&gt;all_adj_list.upper))</span>
<span class="p_add">+	if (__netdev_find_adj(dev, upper_dev, &amp;dev-&gt;adj_list.upper))</span>
 		return -EEXIST;
 
 	if (master &amp;&amp; netdev_master_upper_dev_get(dev))
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index 76ec6c5..b73d29c 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -2284,6 +2284,9 @@</span> <span class="p_context"> void rtmsg_ifinfo(int type, struct net_device *dev, unsigned int change,</span>
 {
 	struct sk_buff *skb;
 
<span class="p_add">+	if (dev-&gt;reg_state != NETREG_REGISTERED)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	skb = rtmsg_ifinfo_build_skb(type, dev, change, flags);
 	if (skb)
 		rtmsg_ifinfo_send(skb, dev, flags);
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index ac40410..d0b0746 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -903,6 +903,10 @@</span> <span class="p_context"> static int ip_error(struct sk_buff *skb)</span>
 	bool send;
 	int code;
 
<span class="p_add">+	/* IP on this device is disabled. */</span>
<span class="p_add">+	if (!in_dev)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	net = dev_net(rt-&gt;dst.dev);
 	if (!IN_DEV_FORWARD(in_dev)) {
 		switch (rt-&gt;dst.error) {
<span class="p_header">diff --git a/net/ipv4/tcp_cong.c b/net/ipv4/tcp_cong.c</span>
<span class="p_header">index f2d4097..61f329f 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_cong.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_cong.c</span>
<span class="p_chunk">@@ -248,9 +248,10 @@</span> <span class="p_context"> int tcp_set_congestion_control(struct sock *sk, const char *name)</span>
 	ca = tcp_ca_find(name);
 
 	/* no change asking for existing value */
<span class="p_del">-	if (ca == icsk-&gt;icsk_ca_ops)</span>
<span class="p_add">+	if (ca == icsk-&gt;icsk_ca_ops) {</span>
<span class="p_add">+		icsk-&gt;icsk_ca_setsockopt = 1;</span>
 		goto out;
<span class="p_del">-</span>
<span class="p_add">+	}</span>
 #ifdef CONFIG_MODULES
 	/* not found attempt to autoload module */
 	if (!ca &amp;&amp; capable(CAP_NET_ADMIN)) {
<span class="p_chunk">@@ -273,6 +274,7 @@</span> <span class="p_context"> int tcp_set_congestion_control(struct sock *sk, const char *name)</span>
 	else {
 		tcp_cleanup_congestion_control(sk);
 		icsk-&gt;icsk_ca_ops = ca;
<span class="p_add">+		icsk-&gt;icsk_ca_setsockopt = 1;</span>
 
 		if (sk-&gt;sk_state != TCP_CLOSE &amp;&amp; icsk-&gt;icsk_ca_ops-&gt;init)
 			icsk-&gt;icsk_ca_ops-&gt;init(sk);
<span class="p_header">diff --git a/net/ipv4/tcp_minisocks.c b/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">index 63d2680..2f66671 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_minisocks.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_minisocks.c</span>
<span class="p_chunk">@@ -297,7 +297,7 @@</span> <span class="p_context"> void tcp_time_wait(struct sock *sk, int state, int timeo)</span>
 			tw-&gt;tw_v6_daddr = sk-&gt;sk_v6_daddr;
 			tw-&gt;tw_v6_rcv_saddr = sk-&gt;sk_v6_rcv_saddr;
 			tw-&gt;tw_tclass = np-&gt;tclass;
<span class="p_del">-			tw-&gt;tw_flowlabel = np-&gt;flow_label &gt;&gt; 12;</span>
<span class="p_add">+			tw-&gt;tw_flowlabel = be32_to_cpu(np-&gt;flow_label &amp; IPV6_FLOWLABEL_MASK);</span>
 			tw-&gt;tw_ipv6only = sk-&gt;sk_ipv6only;
 		}
 #endif
<span class="p_chunk">@@ -451,7 +451,8 @@</span> <span class="p_context"> struct sock *tcp_create_openreq_child(struct sock *sk, struct request_sock *req,</span>
 		newtp-&gt;snd_cwnd = TCP_INIT_CWND;
 		newtp-&gt;snd_cwnd_cnt = 0;
 
<span class="p_del">-		if (!try_module_get(newicsk-&gt;icsk_ca_ops-&gt;owner))</span>
<span class="p_add">+		if (!newicsk-&gt;icsk_ca_setsockopt ||</span>
<span class="p_add">+		    !try_module_get(newicsk-&gt;icsk_ca_ops-&gt;owner))</span>
 			tcp_assign_congestion_control(newsk);
 
 		tcp_set_ca_state(newsk, TCP_CA_Open);
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 13b4dcf..e0737ac 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -90,6 +90,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/socket.h&gt;
 #include &lt;linux/sockios.h&gt;
 #include &lt;linux/igmp.h&gt;
<span class="p_add">+#include &lt;linux/inetdevice.h&gt;</span>
 #include &lt;linux/in.h&gt;
 #include &lt;linux/errno.h&gt;
 #include &lt;linux/timer.h&gt;
<span class="p_chunk">@@ -1348,10 +1349,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 	}
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_chunk">@@ -1968,6 +1967,7 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 	struct sock *sk;
 	struct dst_entry *dst;
 	int dif = skb-&gt;dev-&gt;ifindex;
<span class="p_add">+	int ours;</span>
 
 	/* validate the packet */
 	if (!pskb_may_pull(skb, skb_transport_offset(skb) + sizeof(struct udphdr)))
<span class="p_chunk">@@ -1977,14 +1977,24 @@</span> <span class="p_context"> void udp_v4_early_demux(struct sk_buff *skb)</span>
 	uh = udp_hdr(skb);
 
 	if (skb-&gt;pkt_type == PACKET_BROADCAST ||
<span class="p_del">-	    skb-&gt;pkt_type == PACKET_MULTICAST)</span>
<span class="p_add">+	    skb-&gt;pkt_type == PACKET_MULTICAST) {</span>
<span class="p_add">+		struct in_device *in_dev = __in_dev_get_rcu(skb-&gt;dev);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!in_dev)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		ours = ip_check_mc_rcu(in_dev, iph-&gt;daddr, iph-&gt;saddr,</span>
<span class="p_add">+				       iph-&gt;protocol);</span>
<span class="p_add">+		if (!ours)</span>
<span class="p_add">+			return;</span>
 		sk = __udp4_lib_mcast_demux_lookup(net, uh-&gt;dest, iph-&gt;daddr,
 						   uh-&gt;source, iph-&gt;saddr, dif);
<span class="p_del">-	else if (skb-&gt;pkt_type == PACKET_HOST)</span>
<span class="p_add">+	} else if (skb-&gt;pkt_type == PACKET_HOST) {</span>
 		sk = __udp4_lib_demux_lookup(net, uh-&gt;dest, iph-&gt;daddr,
 					     uh-&gt;source, iph-&gt;saddr, dif);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		return;
<span class="p_add">+	}</span>
 
 	if (!sk)
 		return;
<span class="p_header">diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c</span>
<span class="p_header">index f1c6d5e..3a96300 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_fib.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_fib.c</span>
<span class="p_chunk">@@ -691,6 +691,7 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 {
 	struct rt6_info *iter = NULL;
 	struct rt6_info **ins;
<span class="p_add">+	struct rt6_info **fallback_ins = NULL;</span>
 	int replace = (info-&gt;nlh &amp;&amp;
 		       (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_REPLACE));
 	int add = (!info-&gt;nlh ||
<span class="p_chunk">@@ -714,8 +715,13 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 			    (info-&gt;nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL))
 				return -EEXIST;
 			if (replace) {
<span class="p_del">-				found++;</span>
<span class="p_del">-				break;</span>
<span class="p_add">+				if (rt_can_ecmp == rt6_qualify_for_ecmp(iter)) {</span>
<span class="p_add">+					found++;</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				if (rt_can_ecmp)</span>
<span class="p_add">+					fallback_ins = fallback_ins ?: ins;</span>
<span class="p_add">+				goto next_iter;</span>
 			}
 
 			if (iter-&gt;dst.dev == rt-&gt;dst.dev &amp;&amp;
<span class="p_chunk">@@ -751,9 +757,17 @@</span> <span class="p_context"> static int fib6_add_rt2node(struct fib6_node *fn, struct rt6_info *rt,</span>
 		if (iter-&gt;rt6i_metric &gt; rt-&gt;rt6i_metric)
 			break;
 
<span class="p_add">+next_iter:</span>
 		ins = &amp;iter-&gt;dst.rt6_next;
 	}
 
<span class="p_add">+	if (fallback_ins &amp;&amp; !found) {</span>
<span class="p_add">+		/* No ECMP-able route found, replace first non-ECMP one */</span>
<span class="p_add">+		ins = fallback_ins;</span>
<span class="p_add">+		iter = *ins;</span>
<span class="p_add">+		found++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Reset round-robin state, if necessary */
 	if (ins == &amp;fn-&gt;leaf)
 		fn-&gt;rr_ptr = NULL;
<span class="p_chunk">@@ -814,6 +828,8 @@</span> <span class="p_context"> add:</span>
 		}
 
 	} else {
<span class="p_add">+		int nsiblings;</span>
<span class="p_add">+</span>
 		if (!found) {
 			if (add)
 				goto add;
<span class="p_chunk">@@ -834,8 +850,27 @@</span> <span class="p_context"> add:</span>
 			info-&gt;nl_net-&gt;ipv6.rt6_stats-&gt;fib_route_nodes++;
 			fn-&gt;fn_flags |= RTN_RTINFO;
 		}
<span class="p_add">+		nsiblings = iter-&gt;rt6i_nsiblings;</span>
 		fib6_purge_rt(iter, fn, info-&gt;nl_net);
 		rt6_release(iter);
<span class="p_add">+</span>
<span class="p_add">+		if (nsiblings) {</span>
<span class="p_add">+			/* Replacing an ECMP route, remove all siblings */</span>
<span class="p_add">+			ins = &amp;rt-&gt;dst.rt6_next;</span>
<span class="p_add">+			iter = *ins;</span>
<span class="p_add">+			while (iter) {</span>
<span class="p_add">+				if (rt6_qualify_for_ecmp(iter)) {</span>
<span class="p_add">+					*ins = iter-&gt;dst.rt6_next;</span>
<span class="p_add">+					fib6_purge_rt(iter, fn, info-&gt;nl_net);</span>
<span class="p_add">+					rt6_release(iter);</span>
<span class="p_add">+					nsiblings--;</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					ins = &amp;iter-&gt;dst.rt6_next;</span>
<span class="p_add">+				}</span>
<span class="p_add">+				iter = *ins;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			WARN_ON(nsiblings != 0);</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/net/ipv6/route.c b/net/ipv6/route.c</span>
<span class="p_header">index 1528d84..efb491a 100644</span>
<span class="p_header">--- a/net/ipv6/route.c</span>
<span class="p_header">+++ b/net/ipv6/route.c</span>
<span class="p_chunk">@@ -2446,9 +2446,9 @@</span> <span class="p_context"> static int ip6_route_multipath(struct fib6_config *cfg, int add)</span>
 	int attrlen;
 	int err = 0, last_err = 0;
 
<span class="p_add">+	remaining = cfg-&gt;fc_mp_len;</span>
 beginning:
 	rtnh = (struct rtnexthop *)cfg-&gt;fc_mp;
<span class="p_del">-	remaining = cfg-&gt;fc_mp_len;</span>
 
 	/* Parse a Multipath Entry */
 	while (rtnh_ok(rtnh, remaining)) {
<span class="p_chunk">@@ -2478,15 +2478,19 @@</span> <span class="p_context"> beginning:</span>
 				 * next hops that have been already added.
 				 */
 				add = 0;
<span class="p_add">+				remaining = cfg-&gt;fc_mp_len - remaining;</span>
 				goto beginning;
 			}
 		}
 		/* Because each route is added like a single route we remove
<span class="p_del">-		 * this flag after the first nexthop (if there is a collision,</span>
<span class="p_del">-		 * we have already fail to add the first nexthop:</span>
<span class="p_del">-		 * fib6_add_rt2node() has reject it).</span>
<span class="p_add">+		 * these flags after the first nexthop: if there is a collision,</span>
<span class="p_add">+		 * we have already failed to add the first nexthop:</span>
<span class="p_add">+		 * fib6_add_rt2node() has rejected it; when replacing, old</span>
<span class="p_add">+		 * nexthops have been replaced by first new, the rest should</span>
<span class="p_add">+		 * be added to it.</span>
 		 */
<span class="p_del">-		cfg-&gt;fc_nlinfo.nlh-&gt;nlmsg_flags &amp;= ~NLM_F_EXCL;</span>
<span class="p_add">+		cfg-&gt;fc_nlinfo.nlh-&gt;nlmsg_flags &amp;= ~(NLM_F_EXCL |</span>
<span class="p_add">+						     NLM_F_REPLACE);</span>
 		rtnh = rtnh_next(rtnh, &amp;remaining);
 	}
 
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index b899793..fb41d5c 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -975,7 +975,7 @@</span> <span class="p_context"> static void tcp_v6_timewait_ack(struct sock *sk, struct sk_buff *skb)</span>
 			tcptw-&gt;tw_rcv_wnd &gt;&gt; tw-&gt;tw_rcv_wscale,
 			tcp_time_stamp + tcptw-&gt;tw_ts_offset,
 			tcptw-&gt;tw_ts_recent, tw-&gt;tw_bound_dev_if, tcp_twsk_md5_key(tcptw),
<span class="p_del">-			tw-&gt;tw_tclass, (tw-&gt;tw_flowlabel &lt;&lt; 12));</span>
<span class="p_add">+			tw-&gt;tw_tclass, cpu_to_be32(tw-&gt;tw_flowlabel));</span>
 
 	inet_twsk_put(tw);
 }
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index 189dc4a..daea755 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -528,10 +528,8 @@</span> <span class="p_context"> csum_copy_err:</span>
 	}
 	unlock_sock_fast(sk, slow);
 
<span class="p_del">-	if (noblock)</span>
<span class="p_del">-		return -EAGAIN;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* starting over for a new packet */</span>
<span class="p_add">+	/* starting over for a new packet, but check if we need to yield */</span>
<span class="p_add">+	cond_resched();</span>
 	msg-&gt;msg_flags &amp;= ~MSG_TRUNC;
 	goto try_again;
 }
<span class="p_chunk">@@ -734,7 +732,9 @@</span> <span class="p_context"> static bool __udp_v6_is_mcast_sock(struct net *net, struct sock *sk,</span>
 	    (inet-&gt;inet_dport &amp;&amp; inet-&gt;inet_dport != rmt_port) ||
 	    (!ipv6_addr_any(&amp;sk-&gt;sk_v6_daddr) &amp;&amp;
 		    !ipv6_addr_equal(&amp;sk-&gt;sk_v6_daddr, rmt_addr)) ||
<span class="p_del">-	    (sk-&gt;sk_bound_dev_if &amp;&amp; sk-&gt;sk_bound_dev_if != dif))</span>
<span class="p_add">+	    (sk-&gt;sk_bound_dev_if &amp;&amp; sk-&gt;sk_bound_dev_if != dif) ||</span>
<span class="p_add">+	    (!ipv6_addr_any(&amp;sk-&gt;sk_v6_rcv_saddr) &amp;&amp;</span>
<span class="p_add">+		    !ipv6_addr_equal(&amp;sk-&gt;sk_v6_rcv_saddr, loc_addr)))</span>
 		return false;
 	if (!inet6_mc_check(sk, loc_addr, rmt_addr))
 		return false;
<span class="p_header">diff --git a/net/mac80211/wep.c b/net/mac80211/wep.c</span>
<span class="p_header">index a4220e9..efa3f48 100644</span>
<span class="p_header">--- a/net/mac80211/wep.c</span>
<span class="p_header">+++ b/net/mac80211/wep.c</span>
<span class="p_chunk">@@ -98,8 +98,7 @@</span> <span class="p_context"> static u8 *ieee80211_wep_add_iv(struct ieee80211_local *local,</span>
 
 	hdr-&gt;frame_control |= cpu_to_le16(IEEE80211_FCTL_PROTECTED);
 
<span class="p_del">-	if (WARN_ON(skb_tailroom(skb) &lt; IEEE80211_WEP_ICV_LEN ||</span>
<span class="p_del">-		    skb_headroom(skb) &lt; IEEE80211_WEP_IV_LEN))</span>
<span class="p_add">+	if (WARN_ON(skb_headroom(skb) &lt; IEEE80211_WEP_IV_LEN))</span>
 		return NULL;
 
 	hdrlen = ieee80211_hdrlen(hdr-&gt;frame_control);
<span class="p_chunk">@@ -167,6 +166,9 @@</span> <span class="p_context"> int ieee80211_wep_encrypt(struct ieee80211_local *local,</span>
 	size_t len;
 	u8 rc4key[3 + WLAN_KEY_LEN_WEP104];
 
<span class="p_add">+	if (WARN_ON(skb_tailroom(skb) &lt; IEEE80211_WEP_ICV_LEN))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	iv = ieee80211_wep_add_iv(local, skb, keylen, keyidx);
 	if (!iv)
 		return -1;
<span class="p_header">diff --git a/net/netfilter/ipvs/ip_vs_ctl.c b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">index fdcda8b..7f91fbd 100644</span>
<span class="p_header">--- a/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_header">+++ b/net/netfilter/ipvs/ip_vs_ctl.c</span>
<span class="p_chunk">@@ -3754,6 +3754,9 @@</span> <span class="p_context"> static void __net_exit ip_vs_control_net_cleanup_sysctl(struct net *net)</span>
 	cancel_work_sync(&amp;ipvs-&gt;defense_work.work);
 	unregister_net_sysctl_table(ipvs-&gt;sysctl_hdr);
 	ip_vs_stop_estimator(net, &amp;ipvs-&gt;tot_stats);
<span class="p_add">+</span>
<span class="p_add">+	if (!net_eq(net, &amp;init_net))</span>
<span class="p_add">+		kfree(ipvs-&gt;sysctl_tbl);</span>
 }
 
 #else
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_proto_tcp.c b/net/netfilter/nf_conntrack_proto_tcp.c</span>
<span class="p_header">index 5caa0c4..70383de 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_proto_tcp.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_proto_tcp.c</span>
<span class="p_chunk">@@ -202,7 +202,7 @@</span> <span class="p_context"> static const u8 tcp_conntracks[2][6][TCP_CONNTRACK_MAX] = {</span>
  *	sES -&gt; sES	:-)
  *	sFW -&gt; sCW	Normal close request answered by ACK.
  *	sCW -&gt; sCW
<span class="p_del">- *	sLA -&gt; sTW	Last ACK detected.</span>
<span class="p_add">+ *	sLA -&gt; sTW	Last ACK detected (RFC5961 challenged)</span>
  *	sTW -&gt; sTW	Retransmitted last ACK. Remain in the same state.
  *	sCL -&gt; sCL
  */
<span class="p_chunk">@@ -261,7 +261,7 @@</span> <span class="p_context"> static const u8 tcp_conntracks[2][6][TCP_CONNTRACK_MAX] = {</span>
  *	sES -&gt; sES	:-)
  *	sFW -&gt; sCW	Normal close request answered by ACK.
  *	sCW -&gt; sCW
<span class="p_del">- *	sLA -&gt; sTW	Last ACK detected.</span>
<span class="p_add">+ *	sLA -&gt; sTW	Last ACK detected (RFC5961 challenged)</span>
  *	sTW -&gt; sTW	Retransmitted last ACK.
  *	sCL -&gt; sCL
  */
<span class="p_chunk">@@ -906,6 +906,7 @@</span> <span class="p_context"> static int tcp_packet(struct nf_conn *ct,</span>
 					1 : ct-&gt;proto.tcp.last_win;
 			ct-&gt;proto.tcp.seen[ct-&gt;proto.tcp.last_dir].td_scale =
 				ct-&gt;proto.tcp.last_wscale;
<span class="p_add">+			ct-&gt;proto.tcp.last_flags &amp;= ~IP_CT_EXP_CHALLENGE_ACK;</span>
 			ct-&gt;proto.tcp.seen[ct-&gt;proto.tcp.last_dir].flags =
 				ct-&gt;proto.tcp.last_flags;
 			memset(&amp;ct-&gt;proto.tcp.seen[dir], 0,
<span class="p_chunk">@@ -923,7 +924,9 @@</span> <span class="p_context"> static int tcp_packet(struct nf_conn *ct,</span>
 		 * may be in sync but we are not. In that case, we annotate
 		 * the TCP options and let the packet go through. If it is a
 		 * valid SYN packet, the server will reply with a SYN/ACK, and
<span class="p_del">-		 * then we&#39;ll get in sync. Otherwise, the server ignores it. */</span>
<span class="p_add">+		 * then we&#39;ll get in sync. Otherwise, the server potentially</span>
<span class="p_add">+		 * responds with a challenge ACK if implementing RFC5961.</span>
<span class="p_add">+		 */</span>
 		if (index == TCP_SYN_SET &amp;&amp; dir == IP_CT_DIR_ORIGINAL) {
 			struct ip_ct_tcp_state seen = {};
 
<span class="p_chunk">@@ -939,6 +942,13 @@</span> <span class="p_context"> static int tcp_packet(struct nf_conn *ct,</span>
 				ct-&gt;proto.tcp.last_flags |=
 					IP_CT_TCP_FLAG_SACK_PERM;
 			}
<span class="p_add">+			/* Mark the potential for RFC5961 challenge ACK,</span>
<span class="p_add">+			 * this pose a special problem for LAST_ACK state</span>
<span class="p_add">+			 * as ACK is intrepretated as ACKing last FIN.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (old_state == TCP_CONNTRACK_LAST_ACK)</span>
<span class="p_add">+				ct-&gt;proto.tcp.last_flags |=</span>
<span class="p_add">+					IP_CT_EXP_CHALLENGE_ACK;</span>
 		}
 		spin_unlock_bh(&amp;ct-&gt;lock);
 		if (LOG_INVALID(net, IPPROTO_TCP))
<span class="p_chunk">@@ -970,6 +980,25 @@</span> <span class="p_context"> static int tcp_packet(struct nf_conn *ct,</span>
 			nf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,
 				  &quot;nf_ct_tcp: invalid state &quot;);
 		return -NF_ACCEPT;
<span class="p_add">+	case TCP_CONNTRACK_TIME_WAIT:</span>
<span class="p_add">+		/* RFC5961 compliance cause stack to send &quot;challenge-ACK&quot;</span>
<span class="p_add">+		 * e.g. in response to spurious SYNs.  Conntrack MUST</span>
<span class="p_add">+		 * not believe this ACK is acking last FIN.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (old_state == TCP_CONNTRACK_LAST_ACK &amp;&amp;</span>
<span class="p_add">+		    index == TCP_ACK_SET &amp;&amp;</span>
<span class="p_add">+		    ct-&gt;proto.tcp.last_dir != dir &amp;&amp;</span>
<span class="p_add">+		    ct-&gt;proto.tcp.last_index == TCP_SYN_SET &amp;&amp;</span>
<span class="p_add">+		    (ct-&gt;proto.tcp.last_flags &amp; IP_CT_EXP_CHALLENGE_ACK)) {</span>
<span class="p_add">+			/* Detected RFC5961 challenge ACK */</span>
<span class="p_add">+			ct-&gt;proto.tcp.last_flags &amp;= ~IP_CT_EXP_CHALLENGE_ACK;</span>
<span class="p_add">+			spin_unlock_bh(&amp;ct-&gt;lock);</span>
<span class="p_add">+			if (LOG_INVALID(net, IPPROTO_TCP))</span>
<span class="p_add">+				nf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,</span>
<span class="p_add">+				      &quot;nf_ct_tcp: challenge-ACK ignored &quot;);</span>
<span class="p_add">+			return NF_ACCEPT; /* Don&#39;t change state */</span>
<span class="p_add">+		}</span>
<span class="p_add">+		break;</span>
 	case TCP_CONNTRACK_CLOSE:
 		if (index == TCP_RST_SET
 		    &amp;&amp; (ct-&gt;proto.tcp.seen[!dir].flags &amp; IP_CT_TCP_FLAG_MAXACK_SET)
<span class="p_header">diff --git a/net/sched/cls_api.c b/net/sched/cls_api.c</span>
<span class="p_header">index baef987..d3328a1 100644</span>
<span class="p_header">--- a/net/sched/cls_api.c</span>
<span class="p_header">+++ b/net/sched/cls_api.c</span>
<span class="p_chunk">@@ -81,6 +81,11 @@</span> <span class="p_context"> int unregister_tcf_proto_ops(struct tcf_proto_ops *ops)</span>
 	struct tcf_proto_ops *t;
 	int rc = -ENOENT;
 
<span class="p_add">+	/* Wait for outstanding call_rcu()s, if any, from a</span>
<span class="p_add">+	 * tcf_proto_ops&#39;s destroy() handler.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	rcu_barrier();</span>
<span class="p_add">+</span>
 	write_lock(&amp;cls_mod_lock);
 	list_for_each_entry(t, &amp;tcf_proto_base, head) {
 		if (t == ops) {
<span class="p_header">diff --git a/net/sched/sch_api.c b/net/sched/sch_api.c</span>
<span class="p_header">index 76f402e..a25fae3 100644</span>
<span class="p_header">--- a/net/sched/sch_api.c</span>
<span class="p_header">+++ b/net/sched/sch_api.c</span>
<span class="p_chunk">@@ -815,10 +815,8 @@</span> <span class="p_context"> static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,</span>
 		if (dev-&gt;flags &amp; IFF_UP)
 			dev_deactivate(dev);
 
<span class="p_del">-		if (new &amp;&amp; new-&gt;ops-&gt;attach) {</span>
<span class="p_del">-			new-&gt;ops-&gt;attach(new);</span>
<span class="p_del">-			num_q = 0;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (new &amp;&amp; new-&gt;ops-&gt;attach)</span>
<span class="p_add">+			goto skip;</span>
 
 		for (i = 0; i &lt; num_q; i++) {
 			struct netdev_queue *dev_queue = dev_ingress_queue(dev);
<span class="p_chunk">@@ -834,12 +832,16 @@</span> <span class="p_context"> static int qdisc_graft(struct net_device *dev, struct Qdisc *parent,</span>
 				qdisc_destroy(old);
 		}
 
<span class="p_add">+skip:</span>
 		if (!ingress) {
 			notify_and_destroy(net, skb, n, classid,
 					   dev-&gt;qdisc, new);
 			if (new &amp;&amp; !new-&gt;ops-&gt;attach)
 				atomic_inc(&amp;new-&gt;refcnt);
 			dev-&gt;qdisc = new ? : &amp;noop_qdisc;
<span class="p_add">+</span>
<span class="p_add">+			if (new &amp;&amp; new-&gt;ops-&gt;attach)</span>
<span class="p_add">+				new-&gt;ops-&gt;attach(new);</span>
 		} else {
 			notify_and_destroy(net, skb, n, classid, old, new);
 		}
<span class="p_header">diff --git a/net/sunrpc/auth_gss/gss_rpc_xdr.c b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">index 1ec19f6..eeeba5a 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/gss_rpc_xdr.c</span>
<span class="p_chunk">@@ -793,20 +793,26 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 {
 	u32 value_follows;
 	int err;
<span class="p_add">+	struct page *scratch;</span>
<span class="p_add">+</span>
<span class="p_add">+	scratch = alloc_page(GFP_KERNEL);</span>
<span class="p_add">+	if (!scratch)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	xdr_set_scratch_buffer(xdr, page_address(scratch), PAGE_SIZE);</span>
 
 	/* res-&gt;status */
 	err = gssx_dec_status(xdr, &amp;res-&gt;status);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 
 	/* res-&gt;context_handle */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		err = gssx_dec_ctx(xdr, res-&gt;context_handle);
 		if (err)
<span class="p_del">-			return err;</span>
<span class="p_add">+			goto out_free;</span>
 	} else {
 		res-&gt;context_handle = NULL;
 	}
<span class="p_chunk">@@ -814,11 +820,11 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 	/* res-&gt;output_token */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		err = gssx_dec_buffer(xdr, res-&gt;output_token);
 		if (err)
<span class="p_del">-			return err;</span>
<span class="p_add">+			goto out_free;</span>
 	} else {
 		res-&gt;output_token = NULL;
 	}
<span class="p_chunk">@@ -826,14 +832,17 @@</span> <span class="p_context"> int gssx_dec_accept_sec_context(struct rpc_rqst *rqstp,</span>
 	/* res-&gt;delegated_cred_handle */
 	err = gssx_dec_bool(xdr, &amp;value_follows);
 	if (err)
<span class="p_del">-		return err;</span>
<span class="p_add">+		goto out_free;</span>
 	if (value_follows) {
 		/* we do not support upcall servers sending this data. */
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		err = -EINVAL;</span>
<span class="p_add">+		goto out_free;</span>
 	}
 
 	/* res-&gt;options */
 	err = gssx_dec_option_array(xdr, &amp;res-&gt;options);
 
<span class="p_add">+out_free:</span>
<span class="p_add">+	__free_page(scratch);</span>
 	return err;
 }
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 8e1b102..a8b4284 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -1898,6 +1898,10 @@</span> <span class="p_context"> static long unix_stream_data_wait(struct sock *sk, long timeo,</span>
 		unix_state_unlock(sk);
 		timeo = freezable_schedule_timeout(timeo);
 		unix_state_lock(sk);
<span class="p_add">+</span>
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
 		clear_bit(SOCK_ASYNC_WAITDATA, &amp;sk-&gt;sk_socket-&gt;flags);
 	}
 
<span class="p_chunk">@@ -1962,6 +1966,10 @@</span> <span class="p_context"> static int unix_stream_recvmsg(struct kiocb *iocb, struct socket *sock,</span>
 		struct sk_buff *skb, *last;
 
 		unix_state_lock(sk);
<span class="p_add">+		if (sock_flag(sk, SOCK_DEAD)) {</span>
<span class="p_add">+			err = -ECONNRESET;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
 		last = skb = skb_peek(&amp;sk-&gt;sk_receive_queue);
 again:
 		if (skb == NULL) {
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index da67ea8..e27298b 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -973,6 +973,14 @@</span> <span class="p_context"> static const struct hda_codec_preset snd_hda_preset_conexant[] = {</span>
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f150b9, .name = &quot;CX20665&quot;,
 	  .patch = patch_conexant_auto },
<span class="p_add">+	{ .id = 0x14f150f1, .name = &quot;CX20721&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f2, .name = &quot;CX20722&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f3, .name = &quot;CX20723&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
<span class="p_add">+	{ .id = 0x14f150f4, .name = &quot;CX20724&quot;,</span>
<span class="p_add">+	  .patch = patch_conexant_auto },</span>
 	{ .id = 0x14f1510f, .name = &quot;CX20751/2&quot;,
 	  .patch = patch_conexant_auto },
 	{ .id = 0x14f15110, .name = &quot;CX20751/2&quot;,
<span class="p_chunk">@@ -1007,6 +1015,10 @@</span> <span class="p_context"> MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ab&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150ac&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b8&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f150b9&quot;);
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f1&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f2&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f3&quot;);</span>
<span class="p_add">+MODULE_ALIAS(&quot;snd-hda-codec-id:14f150f4&quot;);</span>
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f1510f&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15110&quot;);
 MODULE_ALIAS(&quot;snd-hda-codec-id:14f15111&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 39e3640..4cfab09 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -3534,6 +3534,7 @@</span> <span class="p_context"> static void alc_headset_mode_unplugged(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;vendor_id) {
 	case 0x10ec0255:
<span class="p_add">+	case 0x10ec0256:</span>
 		alc_process_coef_fw(codec, coef0255);
 		break;
 	case 0x10ec0233:
<span class="p_chunk">@@ -3589,6 +3590,7 @@</span> <span class="p_context"> static void alc_headset_mode_mic_in(struct hda_codec *codec, hda_nid_t hp_pin,</span>
 
 	switch (codec-&gt;vendor_id) {
 	case 0x10ec0255:
<span class="p_add">+	case 0x10ec0256:</span>
 		alc_write_coef_idx(codec, 0x45, 0xc489);
 		snd_hda_set_pin_ctl_cache(codec, hp_pin, 0);
 		alc_process_coef_fw(codec, coef0255);
<span class="p_chunk">@@ -3658,6 +3660,7 @@</span> <span class="p_context"> static void alc_headset_mode_default(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;vendor_id) {
 	case 0x10ec0255:
<span class="p_add">+	case 0x10ec0256:</span>
 		alc_process_coef_fw(codec, coef0255);
 		break;
 	case 0x10ec0233:
<span class="p_chunk">@@ -3712,6 +3715,7 @@</span> <span class="p_context"> static void alc_headset_mode_ctia(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;vendor_id) {
 	case 0x10ec0255:
<span class="p_add">+	case 0x10ec0256:</span>
 		alc_process_coef_fw(codec, coef0255);
 		break;
 	case 0x10ec0233:
<span class="p_chunk">@@ -3766,6 +3770,7 @@</span> <span class="p_context"> static void alc_headset_mode_omtp(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;vendor_id) {
 	case 0x10ec0255:
<span class="p_add">+	case 0x10ec0256:</span>
 		alc_process_coef_fw(codec, coef0255);
 		break;
 	case 0x10ec0233:
<span class="p_chunk">@@ -3811,6 +3816,7 @@</span> <span class="p_context"> static void alc_determine_headset_type(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;vendor_id) {
 	case 0x10ec0255:
<span class="p_add">+	case 0x10ec0256:</span>
 		alc_process_coef_fw(codec, coef0255);
 		msleep(300);
 		val = alc_read_coef_idx(codec, 0x46);
<span class="p_chunk">@@ -4926,6 +4932,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x104d, 0x9099, &quot;Sony VAIO S13&quot;, ALC275_FIXUP_SONY_DISABLE_AAMIX),
 	SND_PCI_QUIRK(0x10cf, 0x1475, &quot;Lifebook&quot;, ALC269_FIXUP_LIFEBOOK),
 	SND_PCI_QUIRK(0x10cf, 0x15dc, &quot;Lifebook T731&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),
<span class="p_add">+	SND_PCI_QUIRK(0x10cf, 0x1757, &quot;Lifebook E752&quot;, ALC269_FIXUP_LIFEBOOK_HP_PIN),</span>
 	SND_PCI_QUIRK(0x10cf, 0x1845, &quot;Lifebook U904&quot;, ALC269_FIXUP_LIFEBOOK_EXTMIC),
 	SND_PCI_QUIRK(0x144d, 0xc109, &quot;Samsung Ativ book 9 (NP900X3G)&quot;, ALC269_FIXUP_INV_DMIC),
 	SND_PCI_QUIRK(0x1458, 0xfa53, &quot;Gigabyte BXBT-2807&quot;, ALC283_FIXUP_BXBT2807_MIC),
<span class="p_chunk">@@ -4955,6 +4962,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x5026, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x5034, &quot;Thinkpad T450&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x5036, &quot;Thinkpad T450s&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x503c, &quot;Thinkpad L450&quot;, ALC292_FIXUP_TPT440_DOCK),</span>
 	SND_PCI_QUIRK(0x17aa, 0x5109, &quot;Thinkpad&quot;, ALC269_FIXUP_LIMIT_INT_MIC_BOOST),
 	SND_PCI_QUIRK(0x17aa, 0x3bf8, &quot;Quanta FL1&quot;, ALC269_FIXUP_PCM_44K),
 	SND_PCI_QUIRK(0x17aa, 0x9e54, &quot;LENOVO NB&quot;, ALC269_FIXUP_LENOVO_EAPD),
<span class="p_chunk">@@ -5043,6 +5051,16 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{0x1b, 0x411111f0}, \
 	{0x1e, 0x411111f0}
 
<span class="p_add">+#define ALC256_STANDARD_PINS \</span>
<span class="p_add">+	{0x12, 0x90a60140}, \</span>
<span class="p_add">+	{0x14, 0x90170110}, \</span>
<span class="p_add">+	{0x19, 0x411111f0}, \</span>
<span class="p_add">+	{0x1a, 0x411111f0}, \</span>
<span class="p_add">+	{0x1b, 0x411111f0}, \</span>
<span class="p_add">+	{0x1d, 0x40700001}, \</span>
<span class="p_add">+	{0x1e, 0x411111f0}, \</span>
<span class="p_add">+	{0x21, 0x02211020}</span>
<span class="p_add">+</span>
 #define ALC282_STANDARD_PINS \
 	{0x14, 0x90170110}, \
 	{0x18, 0x411111f0}, \
<span class="p_chunk">@@ -5135,6 +5153,19 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x17, 0x40000000},
 		{0x1d, 0x40700001},
 		{0x21, 0x02211050}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell Inspiron 5548&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC255_STANDARD_PINS,</span>
<span class="p_add">+		{0x12, 0x90a60180},</span>
<span class="p_add">+		{0x14, 0x90170130},</span>
<span class="p_add">+		{0x17, 0x40000000},</span>
<span class="p_add">+		{0x1d, 0x40700001},</span>
<span class="p_add">+		{0x21, 0x02211040}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC256_STANDARD_PINS,</span>
<span class="p_add">+		{0x13, 0x40000000}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		ALC256_STANDARD_PINS,</span>
<span class="p_add">+		{0x13, 0x411111f0}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0280, 0x103c, &quot;HP&quot;, ALC280_FIXUP_HP_GPIO4,
 		{0x12, 0x90a60130},
 		{0x13, 0x40000000},
<span class="p_header">diff --git a/sound/soc/codecs/mc13783.c b/sound/soc/codecs/mc13783.c</span>
<span class="p_header">index c1e441c..d80148e 100644</span>
<span class="p_header">--- a/sound/soc/codecs/mc13783.c</span>
<span class="p_header">+++ b/sound/soc/codecs/mc13783.c</span>
<span class="p_chunk">@@ -623,14 +623,14 @@</span> <span class="p_context"> static int mc13783_probe(struct snd_soc_codec *codec)</span>
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_CODEC,
<span class="p_del">-				0, AUDIO_SSI_SEL);</span>
<span class="p_add">+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);</span>
 
 	if (priv-&gt;dac_ssi_port == MC13783_SSI1_PORT)
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_DAC,
 				AUDIO_SSI_SEL, 0);
 	else
 		mc13xxx_reg_rmw(priv-&gt;mc13xxx, MC13783_AUDIO_DAC,
<span class="p_del">-				0, AUDIO_SSI_SEL);</span>
<span class="p_add">+				AUDIO_SSI_SEL, AUDIO_SSI_SEL);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/soc/codecs/uda1380.c b/sound/soc/codecs/uda1380.c</span>
<span class="p_header">index dc7778b..c3c33bd 100644</span>
<span class="p_header">--- a/sound/soc/codecs/uda1380.c</span>
<span class="p_header">+++ b/sound/soc/codecs/uda1380.c</span>
<span class="p_chunk">@@ -437,7 +437,7 @@</span> <span class="p_context"> static int uda1380_set_dai_fmt_both(struct snd_soc_dai *codec_dai,</span>
 	if ((fmt &amp; SND_SOC_DAIFMT_MASTER_MASK) != SND_SOC_DAIFMT_CBS_CFS)
 		return -EINVAL;
 
<span class="p_del">-	uda1380_write(codec, UDA1380_IFACE, iface);</span>
<span class="p_add">+	uda1380_write_reg_cache(codec, UDA1380_IFACE, iface);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/soc/codecs/wm8960.c b/sound/soc/codecs/wm8960.c</span>
<span class="p_header">index 0435aeb..a46e90d 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8960.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8960.c</span>
<span class="p_chunk">@@ -393,7 +393,7 @@</span> <span class="p_context"> static const struct snd_soc_dapm_route audio_paths[] = {</span>
 	{ &quot;Right Input Mixer&quot;, &quot;Boost Switch&quot;, &quot;Right Boost Mixer&quot;, },
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT1&quot;, },  /* Really Boost Switch */
 	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT2&quot; },
<span class="p_del">-	{ &quot;Right Input Mixer&quot;, NULL, &quot;LINPUT3&quot; },</span>
<span class="p_add">+	{ &quot;Right Input Mixer&quot;, NULL, &quot;RINPUT3&quot; },</span>
 
 	{ &quot;Left ADC&quot;, NULL, &quot;Left Input Mixer&quot; },
 	{ &quot;Right ADC&quot;, NULL, &quot;Right Input Mixer&quot; },
<span class="p_header">diff --git a/sound/soc/codecs/wm8994.c b/sound/soc/codecs/wm8994.c</span>
<span class="p_header">index 1b97de2..bd94903 100644</span>
<span class="p_header">--- a/sound/soc/codecs/wm8994.c</span>
<span class="p_header">+++ b/sound/soc/codecs/wm8994.c</span>
<span class="p_chunk">@@ -2753,7 +2753,7 @@</span> <span class="p_context"> static struct {</span>
 };
 
 static int fs_ratios[] = {
<span class="p_del">-	64, 128, 192, 256, 348, 512, 768, 1024, 1408, 1536</span>
<span class="p_add">+	64, 128, 192, 256, 384, 512, 768, 1024, 1408, 1536</span>
 };
 
 static int bclk_divs[] = {
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index c5136bb..9d56b0b 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -3073,11 +3073,16 @@</span> <span class="p_context"> snd_soc_dapm_new_control(struct snd_soc_dapm_context *dapm,</span>
 	}
 
 	prefix = soc_dapm_prefix(dapm);
<span class="p_del">-	if (prefix)</span>
<span class="p_add">+	if (prefix) {</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix, widget-&gt;name);
<span class="p_del">-	else</span>
<span class="p_add">+		if (widget-&gt;sname)</span>
<span class="p_add">+			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s %s&quot;, prefix,</span>
<span class="p_add">+					     widget-&gt;sname);</span>
<span class="p_add">+	} else {</span>
 		w-&gt;name = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;name);
<span class="p_del">-</span>
<span class="p_add">+		if (widget-&gt;sname)</span>
<span class="p_add">+			w-&gt;sname = kasprintf(GFP_KERNEL, &quot;%s&quot;, widget-&gt;sname);</span>
<span class="p_add">+	}</span>
 	if (w-&gt;name == NULL) {
 		kfree(w);
 		return NULL;
<span class="p_header">diff --git a/tools/vm/Makefile b/tools/vm/Makefile</span>
<span class="p_header">index ac884b6..93aadaf 100644</span>
<span class="p_header">--- a/tools/vm/Makefile</span>
<span class="p_header">+++ b/tools/vm/Makefile</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
 TARGETS=page-types slabinfo page_owner_sort
 
 LIB_DIR = ../lib/api
<span class="p_del">-LIBS = $(LIB_DIR)/libapikfs.a</span>
<span class="p_add">+LIBS = $(LIB_DIR)/libapi.a</span>
 
 CC = $(CROSS_COMPILE)gcc
 CFLAGS = -Wall -Wextra -I../lib/

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



