
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Add /proc/pid/smaps_rollup - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Add /proc/pid/smaps_rollup</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=175813">Daniel Colascione</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Aug. 8, 2017, 1:25 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170808132554.141143-1-dancol@google.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9888155/mbox/"
   >mbox</a>
|
   <a href="/patch/9888155/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9888155/">/patch/9888155/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	B0A0360352 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Aug 2017 13:26:46 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id A200D28911
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Aug 2017 13:26:46 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 970CD28918; Tue,  8 Aug 2017 13:26:46 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-7.0 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	DKIM_VALID, DKIM_VALID_AU,
	RCVD_IN_DNSWL_HI autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id B2FA028911
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  8 Aug 2017 13:26:45 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752205AbdHHN0m (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 8 Aug 2017 09:26:42 -0400
Received: from mail-pg0-f43.google.com ([74.125.83.43]:35367 &quot;EHLO
	mail-pg0-f43.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751880AbdHHN0k (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 8 Aug 2017 09:26:40 -0400
Received: by mail-pg0-f43.google.com with SMTP id v189so14848614pgd.2
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Tue, 08 Aug 2017 06:26:40 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=google.com; s=20161025;
	h=from:to:cc:subject:date:message-id;
	bh=vjYLapeWQet4GI7c7j450kCJjVWnfTpghso8XcHio8k=;
	b=swWgL1P3ygZeHg6rKkj1uJA8RJ3A9hVnU+Ogb5mKn/R41mOCbDF3cl/4cq1nRzYkaM
	Uwsp5c867dJ4g0tvpjbDKgBJw22ktV0Igf2WgEY1QXQFUM1/A+RHgc1yE7kQYsubMxBm
	unkiXE/ptcwuHZ7JALScA3lfV/0AUqYvs3lW8jC46T2UCArTvzLy4hqMsE6UnCTebDIi
	2T/pUJX7FvB/2NZPcG68+QjGjmWkgsYPXJJvhXztp8mNbakNYj5H6wMw6h9qy8gTU11V
	nKHH5nOz8j9mH/I12ifL92LnXYMdgkIoj4yQQSgJ8wzN7VxqzvCc0y5qr6441DvvtJlQ
	ml1A==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id;
	bh=vjYLapeWQet4GI7c7j450kCJjVWnfTpghso8XcHio8k=;
	b=K6YJLjIG5njuImMXUC4xFJIW4Tjoj/TsorR1gV90LvmuLcLI4qcoKQYZ9gs8TGkDbG
	PC2A+HR3rTBl4eWbjVX/1zRbGCbihOOtvue5PvCw2fei8iTOpIEBIIVvIRZzsI2+Xyxy
	CRx5Vecr91dv2gY//WctBwk39EOlOR7LGgJlPGSBfRzVCNf/7V4R5vMOkdu1HvuZRmR+
	nhWKNzBjTZZb7h/UOeX/vHC55+8GT+g8CruPUzqZfWuZGYYK0iPS6LuS9JBAIn8A9Oyz
	xIy7vaaupH/KfiI0/A24LHr/ftSz7mas12AaPjNbKhM/08iB9IxC9G9/ZaCgueP/+fQP
	BkwA==
X-Gm-Message-State: AHYfb5jOh+eG/O9Px0TMfXCIqpri7Ui9TJ0nT/v1tY7Nec4f9Z+jWGsW
	VTxNwjtCjp780BBsd67NLl66
X-Received: by 10.84.232.199 with SMTP id x7mr4610034plm.433.1502198799436; 
	Tue, 08 Aug 2017 06:26:39 -0700 (PDT)
Received: from poke.sea.corp.google.com ([100.100.214.22])
	by smtp.gmail.com with ESMTPSA id
	w24sm3124485pfk.183.2017.08.08.06.26.38
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-SHA bits=128/128);
	Tue, 08 Aug 2017 06:26:38 -0700 (PDT)
From: Daniel Colascione &lt;dancol@google.com&gt;
To: linux-kernel@vger.kernel.org
Cc: Daniel Colascione &lt;dancol@google.com&gt;
Subject: [PATCH] Add /proc/pid/smaps_rollup
Date: Tue,  8 Aug 2017 06:25:54 -0700
Message-Id: &lt;20170808132554.141143-1-dancol@google.com&gt;
X-Mailer: git-send-email 2.14.0.rc1.383.gd1ce394fe2-goog
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=175813">Daniel Colascione</a> - Aug. 8, 2017, 1:25 p.m.</div>
<pre class="content">
/proc/pid/smaps_rollup is a new proc file that improves the
performance of user programs that determine aggregate memory
statistics (e.g., total PSS) of a process.

Anroid regularly &quot;samples&quot; the memory usage of various processes in
order to blance its memory pool sizes. This sampling process involves
opening /proc/pid/smaps and summing certain fields. For very large
processes, sampling memory use this way can take several hundred
milliseconds, due mostly to the overhead of the seq_printf calls in
task_mmu.c.

smaps_rollup improves the situation. It contains most of the fields of
/proc/pid/smaps, but instead of a set of fields for each VMA,
smaps_rollup instead contains one synthetic smaps-format entry
representing the whole process. In the single smaps_rollup synthetic
entry, each field is the summation of the corresponding field in all
of the real-smaps VMAs. Using a common format for smaps_rollup and
smaps allows userspace parsers to repurpose parsers meant for use with
non-rollup smaps for smaps_rollup, and it allows userspace to switch
between smaps_rollup and smaps at runtime (say, based on the
availablity of smaps_rollup in a given kernel) with minimal fuss.

By using smaps_rollup instead of smaps, a caller can avoid the
significant overhead of formatting, reading, and parsing each of a
large process&#39;s potentially very numerous memory mappings. For
sampling system_server&#39;s PSS in Android, we measured a 12x speedup,
representing a savings of several hundred milliseconds.

One alternative to a new per-process proc file would have been
including PSS information in /proc/pid/status. We considered this
option but thought that PSS would be too expensive (by a few orders of
magnitude) to collect relative to what&#39;s already emitted as part of
/proc/pid/status, and slowing every user of /proc/pid/status for the
sake of readers that happen to want PSS feels wrong.

The code itself works by reusing the existing VMA-walking framework we
use for regular smaps generation and keeping the mem_size_stats
structure around between VMA walks instead of using a fresh one for
each VMA.  In this way, summation happens automatically.  We let
seq_file walk over the VMAs just as it does for regular smaps and just
emit nothing to the seq_file until we hit the last VMA.
<span class="signed-off-by">
Signed-off-by: Daniel Colascione &lt;dancol@google.com&gt;</span>
---
 fs/proc/base.c     |   2 +
 fs/proc/internal.h |   3 +
 fs/proc/task_mmu.c | 196 ++++++++++++++++++++++++++++++++++++-----------------
 3 files changed, 139 insertions(+), 62 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=175813">Daniel Colascione</a> - Aug. 8, 2017, 6:22 p.m.</div>
<pre class="content">
Adding more people.

On Tue, Aug 08 2017, Daniel Colascione wrote:
<span class="quote">&gt; /proc/pid/smaps_rollup is a new proc file that improves the</span>
<span class="quote">&gt; performance of user programs that determine aggregate memory</span>
<span class="quote">&gt; statistics (e.g., total PSS) of a process.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Anroid regularly &quot;samples&quot; the memory usage of various processes in</span>
<span class="quote">&gt; order to blance its memory pool sizes. This sampling process involves</span>
<span class="quote">&gt; opening /proc/pid/smaps and summing certain fields. For very large</span>
<span class="quote">&gt; processes, sampling memory use this way can take several hundred</span>
<span class="quote">&gt; milliseconds, due mostly to the overhead of the seq_printf calls in</span>
<span class="quote">&gt; task_mmu.c.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; smaps_rollup improves the situation. It contains most of the fields of</span>
<span class="quote">&gt; /proc/pid/smaps, but instead of a set of fields for each VMA,</span>
<span class="quote">&gt; smaps_rollup instead contains one synthetic smaps-format entry</span>
<span class="quote">&gt; representing the whole process. In the single smaps_rollup synthetic</span>
<span class="quote">&gt; entry, each field is the summation of the corresponding field in all</span>
<span class="quote">&gt; of the real-smaps VMAs. Using a common format for smaps_rollup and</span>
<span class="quote">&gt; smaps allows userspace parsers to repurpose parsers meant for use with</span>
<span class="quote">&gt; non-rollup smaps for smaps_rollup, and it allows userspace to switch</span>
<span class="quote">&gt; between smaps_rollup and smaps at runtime (say, based on the</span>
<span class="quote">&gt; availablity of smaps_rollup in a given kernel) with minimal fuss.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; By using smaps_rollup instead of smaps, a caller can avoid the</span>
<span class="quote">&gt; significant overhead of formatting, reading, and parsing each of a</span>
<span class="quote">&gt; large process&#39;s potentially very numerous memory mappings. For</span>
<span class="quote">&gt; sampling system_server&#39;s PSS in Android, we measured a 12x speedup,</span>
<span class="quote">&gt; representing a savings of several hundred milliseconds.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; One alternative to a new per-process proc file would have been</span>
<span class="quote">&gt; including PSS information in /proc/pid/status. We considered this</span>
<span class="quote">&gt; option but thought that PSS would be too expensive (by a few orders of</span>
<span class="quote">&gt; magnitude) to collect relative to what&#39;s already emitted as part of</span>
<span class="quote">&gt; /proc/pid/status, and slowing every user of /proc/pid/status for the</span>
<span class="quote">&gt; sake of readers that happen to want PSS feels wrong.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; The code itself works by reusing the existing VMA-walking framework we</span>
<span class="quote">&gt; use for regular smaps generation and keeping the mem_size_stats</span>
<span class="quote">&gt; structure around between VMA walks instead of using a fresh one for</span>
<span class="quote">&gt; each VMA.  In this way, summation happens automatically.  We let</span>
<span class="quote">&gt; seq_file walk over the VMAs just as it does for regular smaps and just</span>
<span class="quote">&gt; emit nothing to the seq_file until we hit the last VMA.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Signed-off-by: Daniel Colascione &lt;dancol@google.com&gt;</span>
<span class="quote">&gt; ---</span>
<span class="quote">&gt;  fs/proc/base.c     |   2 +</span>
<span class="quote">&gt;  fs/proc/internal.h |   3 +</span>
<span class="quote">&gt;  fs/proc/task_mmu.c | 196 ++++++++++++++++++++++++++++++++++++-----------------</span>
<span class="quote">&gt;  3 files changed, 139 insertions(+), 62 deletions(-)</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="quote">&gt; index 719c2e943ea1..a9587b9cace5 100644</span>
<span class="quote">&gt; --- a/fs/proc/base.c</span>
<span class="quote">&gt; +++ b/fs/proc/base.c</span>
<span class="quote">&gt; @@ -2930,6 +2930,7 @@ static const struct pid_entry tgid_base_stuff[] = {</span>
<span class="quote">&gt;  #ifdef CONFIG_PROC_PAGE_MONITOR</span>
<span class="quote">&gt;  	REG(&quot;clear_refs&quot;, S_IWUSR, proc_clear_refs_operations),</span>
<span class="quote">&gt;  	REG(&quot;smaps&quot;,      S_IRUGO, proc_pid_smaps_operations),</span>
<span class="quote">&gt; +	REG(&quot;smaps_rollup&quot;, S_IRUGO, proc_pid_smaps_rollup_operations),</span>
<span class="quote">&gt;  	REG(&quot;pagemap&quot;,    S_IRUSR, proc_pagemap_operations),</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  #ifdef CONFIG_SECURITY</span>
<span class="quote">&gt; @@ -3323,6 +3324,7 @@ static const struct pid_entry tid_base_stuff[] = {</span>
<span class="quote">&gt;  #ifdef CONFIG_PROC_PAGE_MONITOR</span>
<span class="quote">&gt;  	REG(&quot;clear_refs&quot;, S_IWUSR, proc_clear_refs_operations),</span>
<span class="quote">&gt;  	REG(&quot;smaps&quot;,     S_IRUGO, proc_tid_smaps_operations),</span>
<span class="quote">&gt; +	REG(&quot;smaps_rollup&quot;, S_IRUGO, proc_pid_smaps_rollup_operations),</span>
<span class="quote">&gt;  	REG(&quot;pagemap&quot;,    S_IRUSR, proc_pagemap_operations),</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  #ifdef CONFIG_SECURITY</span>
<span class="quote">&gt; diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="quote">&gt; index aa2b89071630..2cbfcd32e884 100644</span>
<span class="quote">&gt; --- a/fs/proc/internal.h</span>
<span class="quote">&gt; +++ b/fs/proc/internal.h</span>
<span class="quote">&gt; @@ -269,10 +269,12 @@ extern int proc_remount(struct super_block *, int *, char *);</span>
<span class="quote">&gt;  /*</span>
<span class="quote">&gt;   * task_[no]mmu.c</span>
<span class="quote">&gt;   */</span>
<span class="quote">&gt; +struct mem_size_stats;</span>
<span class="quote">&gt;  struct proc_maps_private {</span>
<span class="quote">&gt;  	struct inode *inode;</span>
<span class="quote">&gt;  	struct task_struct *task;</span>
<span class="quote">&gt;  	struct mm_struct *mm;</span>
<span class="quote">&gt; +	struct mem_size_stats *rollup;</span>
<span class="quote">&gt;  #ifdef CONFIG_MMU</span>
<span class="quote">&gt;  	struct vm_area_struct *tail_vma;</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt; @@ -288,6 +290,7 @@ extern const struct file_operations proc_tid_maps_operations;</span>
<span class="quote">&gt;  extern const struct file_operations proc_pid_numa_maps_operations;</span>
<span class="quote">&gt;  extern const struct file_operations proc_tid_numa_maps_operations;</span>
<span class="quote">&gt;  extern const struct file_operations proc_pid_smaps_operations;</span>
<span class="quote">&gt; +extern const struct file_operations proc_pid_smaps_rollup_operations;</span>
<span class="quote">&gt;  extern const struct file_operations proc_tid_smaps_operations;</span>
<span class="quote">&gt;  extern const struct file_operations proc_clear_refs_operations;</span>
<span class="quote">&gt;  extern const struct file_operations proc_pagemap_operations;</span>
<span class="quote">&gt; diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="quote">&gt; index b836fd61ed87..02b55df7291c 100644</span>
<span class="quote">&gt; --- a/fs/proc/task_mmu.c</span>
<span class="quote">&gt; +++ b/fs/proc/task_mmu.c</span>
<span class="quote">&gt; @@ -252,6 +252,7 @@ static int proc_map_release(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;  	if (priv-&gt;mm)</span>
<span class="quote">&gt;  		mmdrop(priv-&gt;mm);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +	kfree(priv-&gt;rollup);</span>
<span class="quote">&gt;  	return seq_release_private(inode, file);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; @@ -278,6 +279,23 @@ static int is_stack(struct proc_maps_private *priv,</span>
<span class="quote">&gt;  		vma-&gt;vm_end &gt;= vma-&gt;vm_mm-&gt;start_stack;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static void show_vma_header_prefix(struct seq_file *m,</span>
<span class="quote">&gt; +				   unsigned long start, unsigned long end,</span>
<span class="quote">&gt; +				   vm_flags_t flags, unsigned long long pgoff,</span>
<span class="quote">&gt; +				   dev_t dev, unsigned long ino)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);</span>
<span class="quote">&gt; +	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,</span>
<span class="quote">&gt; +		   start,</span>
<span class="quote">&gt; +		   end,</span>
<span class="quote">&gt; +		   flags &amp; VM_READ ? &#39;r&#39; : &#39;-&#39;,</span>
<span class="quote">&gt; +		   flags &amp; VM_WRITE ? &#39;w&#39; : &#39;-&#39;,</span>
<span class="quote">&gt; +		   flags &amp; VM_EXEC ? &#39;x&#39; : &#39;-&#39;,</span>
<span class="quote">&gt; +		   flags &amp; VM_MAYSHARE ? &#39;s&#39; : &#39;p&#39;,</span>
<span class="quote">&gt; +		   pgoff,</span>
<span class="quote">&gt; +		   MAJOR(dev), MINOR(dev), ino);</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static void</span>
<span class="quote">&gt;  show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; @@ -300,17 +318,7 @@ show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	start = vma-&gt;vm_start;</span>
<span class="quote">&gt;  	end = vma-&gt;vm_end;</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);</span>
<span class="quote">&gt; -	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,</span>
<span class="quote">&gt; -			start,</span>
<span class="quote">&gt; -			end,</span>
<span class="quote">&gt; -			flags &amp; VM_READ ? &#39;r&#39; : &#39;-&#39;,</span>
<span class="quote">&gt; -			flags &amp; VM_WRITE ? &#39;w&#39; : &#39;-&#39;,</span>
<span class="quote">&gt; -			flags &amp; VM_EXEC ? &#39;x&#39; : &#39;-&#39;,</span>
<span class="quote">&gt; -			flags &amp; VM_MAYSHARE ? &#39;s&#39; : &#39;p&#39;,</span>
<span class="quote">&gt; -			pgoff,</span>
<span class="quote">&gt; -			MAJOR(dev), MINOR(dev), ino);</span>
<span class="quote">&gt; +	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/*</span>
<span class="quote">&gt;  	 * Print the dentry name for named mappings, and a</span>
<span class="quote">&gt; @@ -429,6 +437,7 @@ const struct file_operations proc_tid_maps_operations = {</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_PROC_PAGE_MONITOR</span>
<span class="quote">&gt;  struct mem_size_stats {</span>
<span class="quote">&gt; +	bool first;</span>
<span class="quote">&gt;  	unsigned long resident;</span>
<span class="quote">&gt;  	unsigned long shared_clean;</span>
<span class="quote">&gt;  	unsigned long shared_dirty;</span>
<span class="quote">&gt; @@ -442,7 +451,9 @@ struct mem_size_stats {</span>
<span class="quote">&gt;  	unsigned long swap;</span>
<span class="quote">&gt;  	unsigned long shared_hugetlb;</span>
<span class="quote">&gt;  	unsigned long private_hugetlb;</span>
<span class="quote">&gt; +	unsigned long first_vma_start;</span>
<span class="quote">&gt;  	u64 pss;</span>
<span class="quote">&gt; +	u64 pss_locked;</span>
<span class="quote">&gt;  	u64 swap_pss;</span>
<span class="quote">&gt;  	bool check_shmem_swap;</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt; @@ -718,18 +729,36 @@ void __weak arch_show_smap(struct seq_file *m, struct vm_area_struct *vma)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt; +	struct proc_maps_private *priv = m-&gt;private;</span>
<span class="quote">&gt;  	struct vm_area_struct *vma = v;</span>
<span class="quote">&gt; -	struct mem_size_stats mss;</span>
<span class="quote">&gt; +	struct mem_size_stats mss_stack;</span>
<span class="quote">&gt; +	struct mem_size_stats *mss;</span>
<span class="quote">&gt;  	struct mm_walk smaps_walk = {</span>
<span class="quote">&gt;  		.pmd_entry = smaps_pte_range,</span>
<span class="quote">&gt;  #ifdef CONFIG_HUGETLB_PAGE</span>
<span class="quote">&gt;  		.hugetlb_entry = smaps_hugetlb_range,</span>
<span class="quote">&gt;  #endif</span>
<span class="quote">&gt;  		.mm = vma-&gt;vm_mm,</span>
<span class="quote">&gt; -		.private = &amp;mss,</span>
<span class="quote">&gt;  	};</span>
<span class="quote">&gt; +	int ret = 0;</span>
<span class="quote">&gt; +	bool rollup_mode;</span>
<span class="quote">&gt; +	bool last_vma;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (priv-&gt;rollup) {</span>
<span class="quote">&gt; +		rollup_mode = true;</span>
<span class="quote">&gt; +		mss = priv-&gt;rollup;</span>
<span class="quote">&gt; +		if (mss-&gt;first) {</span>
<span class="quote">&gt; +			mss-&gt;first_vma_start = vma-&gt;vm_start;</span>
<span class="quote">&gt; +			mss-&gt;first = false;</span>
<span class="quote">&gt; +		}</span>
<span class="quote">&gt; +		last_vma = !m_next_vma(priv, vma);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		rollup_mode = false;</span>
<span class="quote">&gt; +		memset(&amp;mss_stack, 0, sizeof(mss_stack));</span>
<span class="quote">&gt; +		mss = &amp;mss_stack;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	memset(&amp;mss, 0, sizeof mss);</span>
<span class="quote">&gt; +	smaps_walk.private = mss;</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  #ifdef CONFIG_SHMEM</span>
<span class="quote">&gt;  	if (vma-&gt;vm_file &amp;&amp; shmem_mapping(vma-&gt;vm_file-&gt;f_mapping)) {</span>
<span class="quote">&gt; @@ -747,9 +776,9 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  		if (!shmem_swapped || (vma-&gt;vm_flags &amp; VM_SHARED) ||</span>
<span class="quote">&gt;  					!(vma-&gt;vm_flags &amp; VM_WRITE)) {</span>
<span class="quote">&gt; -			mss.swap = shmem_swapped;</span>
<span class="quote">&gt; +			mss-&gt;swap = shmem_swapped;</span>
<span class="quote">&gt;  		} else {</span>
<span class="quote">&gt; -			mss.check_shmem_swap = true;</span>
<span class="quote">&gt; +			mss-&gt;check_shmem_swap = true;</span>
<span class="quote">&gt;  			smaps_walk.pte_hole = smaps_pte_hole;</span>
<span class="quote">&gt;  		}</span>
<span class="quote">&gt;  	}</span>
<span class="quote">&gt; @@ -757,54 +786,71 @@ static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	/* mmap_sem is held in m_start */</span>
<span class="quote">&gt;  	walk_page_vma(vma, &amp;smaps_walk);</span>
<span class="quote">&gt; +	if (vma-&gt;vm_flags &amp; VM_LOCKED)</span>
<span class="quote">&gt; +		mss-&gt;pss_locked += mss-&gt;pss;</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!rollup_mode) {</span>
<span class="quote">&gt; +		show_map_vma(m, vma, is_pid);</span>
<span class="quote">&gt; +	} else if (last_vma) {</span>
<span class="quote">&gt; +		show_vma_header_prefix(</span>
<span class="quote">&gt; +			m, mss-&gt;first_vma_start, vma-&gt;vm_end, 0, 0, 0, 0);</span>
<span class="quote">&gt; +		seq_pad(m, &#39; &#39;);</span>
<span class="quote">&gt; +		seq_puts(m, &quot;[rollup]\n&quot;);</span>
<span class="quote">&gt; +	} else {</span>
<span class="quote">&gt; +		ret = SEQ_SKIP;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; -	show_map_vma(m, vma, is_pid);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	seq_printf(m,</span>
<span class="quote">&gt; -		   &quot;Size:           %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Rss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Pss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;LazyFree:       %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;ShmemPmdMapped: %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Shared_Hugetlb: %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Private_Hugetlb: %7lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Swap:           %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;SwapPss:        %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;KernelPageSize: %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;MMUPageSize:    %8lu kB\n&quot;</span>
<span class="quote">&gt; -		   &quot;Locked:         %8lu kB\n&quot;,</span>
<span class="quote">&gt; -		   (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.resident &gt;&gt; 10,</span>
<span class="quote">&gt; -		   (unsigned long)(mss.pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; -		   mss.shared_clean  &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.shared_dirty  &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.private_clean &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.private_dirty &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.referenced &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.anonymous &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.lazyfree &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.anonymous_thp &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.shmem_thp &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.shared_hugetlb &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.private_hugetlb &gt;&gt; 10,</span>
<span class="quote">&gt; -		   mss.swap &gt;&gt; 10,</span>
<span class="quote">&gt; -		   (unsigned long)(mss.swap_pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; -		   vma_kernel_pagesize(vma) &gt;&gt; 10,</span>
<span class="quote">&gt; -		   vma_mmu_pagesize(vma) &gt;&gt; 10,</span>
<span class="quote">&gt; -		   (vma-&gt;vm_flags &amp; VM_LOCKED) ?</span>
<span class="quote">&gt; -			(unsigned long)(mss.pss &gt;&gt; (10 + PSS_SHIFT)) : 0);</span>
<span class="quote">&gt; -</span>
<span class="quote">&gt; -	arch_show_smap(m, vma);</span>
<span class="quote">&gt; -	show_smap_vma_flags(m, vma);</span>
<span class="quote">&gt; +	if (!rollup_mode)</span>
<span class="quote">&gt; +		seq_printf(m,</span>
<span class="quote">&gt; +			   &quot;Size:           %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;KernelPageSize: %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;MMUPageSize:    %8lu kB\n&quot;,</span>
<span class="quote">&gt; +			   (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; 10,</span>
<span class="quote">&gt; +			   vma_kernel_pagesize(vma) &gt;&gt; 10,</span>
<span class="quote">&gt; +			   vma_mmu_pagesize(vma) &gt;&gt; 10);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!rollup_mode || last_vma)</span>
<span class="quote">&gt; +		seq_printf(m,</span>
<span class="quote">&gt; +			   &quot;Rss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Pss:            %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;LazyFree:       %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;ShmemPmdMapped: %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Shared_Hugetlb: %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Private_Hugetlb: %7lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Swap:           %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;SwapPss:        %8lu kB\n&quot;</span>
<span class="quote">&gt; +			   &quot;Locked:         %8lu kB\n&quot;,</span>
<span class="quote">&gt; +			   mss-&gt;resident &gt;&gt; 10,</span>
<span class="quote">&gt; +			   (unsigned long)(mss-&gt;pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; +			   mss-&gt;shared_clean  &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;shared_dirty  &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;private_clean &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;private_dirty &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;referenced &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;anonymous &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;lazyfree &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;anonymous_thp &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;shmem_thp &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;shared_hugetlb &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;private_hugetlb &gt;&gt; 10,</span>
<span class="quote">&gt; +			   mss-&gt;swap &gt;&gt; 10,</span>
<span class="quote">&gt; +			   (unsigned long)(mss-&gt;swap_pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="quote">&gt; +			   (unsigned long)(mss-&gt;pss &gt;&gt; (10 + PSS_SHIFT)));</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (!rollup_mode) {</span>
<span class="quote">&gt; +		arch_show_smap(m, vma);</span>
<span class="quote">&gt; +		show_smap_vma_flags(m, vma);</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt;  	m_cache_vma(m, vma);</span>
<span class="quote">&gt; -	return 0;</span>
<span class="quote">&gt; +	return ret;</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  static int show_pid_smap(struct seq_file *m, void *v)</span>
<span class="quote">&gt; @@ -836,6 +882,25 @@ static int pid_smaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;  	return do_maps_open(inode, file, &amp;proc_pid_smaps_op);</span>
<span class="quote">&gt;  }</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +static int pid_smaps_rollup_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	struct seq_file *seq;</span>
<span class="quote">&gt; +	struct proc_maps_private *priv;</span>
<span class="quote">&gt; +	int ret = do_maps_open(inode, file, &amp;proc_pid_smaps_op);</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt; +	if (ret &lt; 0)</span>
<span class="quote">&gt; +		return ret;</span>
<span class="quote">&gt; +	seq = file-&gt;private_data;</span>
<span class="quote">&gt; +	priv = seq-&gt;private;</span>
<span class="quote">&gt; +	priv-&gt;rollup = kzalloc(sizeof(*priv-&gt;rollup), GFP_KERNEL);</span>
<span class="quote">&gt; +	if (!priv-&gt;rollup) {</span>
<span class="quote">&gt; +		proc_map_release(inode, file);</span>
<span class="quote">&gt; +		return -ENOMEM;</span>
<span class="quote">&gt; +	}</span>
<span class="quote">&gt; +	priv-&gt;rollup-&gt;first = true;</span>
<span class="quote">&gt; +	return 0;</span>
<span class="quote">&gt; +}</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  static int tid_smaps_open(struct inode *inode, struct file *file)</span>
<span class="quote">&gt;  {</span>
<span class="quote">&gt;  	return do_maps_open(inode, file, &amp;proc_tid_smaps_op);</span>
<span class="quote">&gt; @@ -848,6 +913,13 @@ const struct file_operations proc_pid_smaps_operations = {</span>
<span class="quote">&gt;  	.release	= proc_map_release,</span>
<span class="quote">&gt;  };</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt; +const struct file_operations proc_pid_smaps_rollup_operations = {</span>
<span class="quote">&gt; +	.open		= pid_smaps_rollup_open,</span>
<span class="quote">&gt; +	.read		= seq_read,</span>
<span class="quote">&gt; +	.llseek		= seq_lseek,</span>
<span class="quote">&gt; +	.release	= proc_map_release,</span>
<span class="quote">&gt; +};</span>
<span class="quote">&gt; +</span>
<span class="quote">&gt;  const struct file_operations proc_tid_smaps_operations = {</span>
<span class="quote">&gt;  	.open		= tid_smaps_open,</span>
<span class="quote">&gt;  	.read		= seq_read,</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 8, 2017, 6:42 p.m.</div>
<pre class="content">
On Tue, Aug 08, 2017 at 11:22:55AM -0700, Daniel Colascione wrote:
<span class="quote">&gt; Adding more people.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; On Tue, Aug 08 2017, Daniel Colascione wrote:</span>
<span class="quote">&gt; &gt; /proc/pid/smaps_rollup is a new proc file that improves the</span>
<span class="quote">&gt; &gt; performance of user programs that determine aggregate memory</span>
<span class="quote">&gt; &gt; statistics (e.g., total PSS) of a process.</span>

What about linux-mm?  Don&#39;t they care about this?

Also, do you have a Documentation/ABI update to describe exactly the
output of this file so we know what it is, and know not to change it in
the future?  Or wherever proc files are documented, I&#39;m not sure if ABI/
has all that many of them at the moment given the age of most of them...
<span class="quote">
&gt; &gt; Anroid regularly &quot;samples&quot; the memory usage of various processes in</span>

Spell checkers are your friend :)

thanks,

greg k-h
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=175813">Daniel Colascione</a> - Aug. 8, 2017, 6:51 p.m.</div>
<pre class="content">
On Tue, Aug 08 2017, Greg KH wrote:
<span class="quote">&gt; On Tue, Aug 08, 2017 at 11:22:55AM -0700, Daniel Colascione wrote:</span>
<span class="quote">&gt;&gt; Adding more people.</span>
<span class="quote">&gt;&gt; </span>
<span class="quote">&gt;&gt; On Tue, Aug 08 2017, Daniel Colascione wrote:</span>
<span class="quote">&gt;&gt; &gt; /proc/pid/smaps_rollup is a new proc file that improves the</span>
<span class="quote">&gt;&gt; &gt; performance of user programs that determine aggregate memory</span>
<span class="quote">&gt;&gt; &gt; statistics (e.g., total PSS) of a process.</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; What about linux-mm?  Don&#39;t they care about this?</span>

Thanks. Added.
<span class="quote">
&gt;</span>
<span class="quote">&gt; Also, do you have a Documentation/ABI update to describe exactly the</span>
<span class="quote">&gt; output of this file so we know what it is, and know not to change it in</span>
<span class="quote">&gt; the future?  Or wherever proc files are documented, I&#39;m not sure if ABI/</span>
<span class="quote">&gt; has all that many of them at the moment given the age of most of</span>
<span class="quote">&gt; them...</span>

I figured I&#39;d get feedback on the patch itself first. Does that make sense?
<span class="quote">
&gt;</span>
<span class="quote">&gt;&gt; &gt; Anroid regularly &quot;samples&quot; the memory usage of various processes in</span>
<span class="quote">&gt;</span>
<span class="quote">&gt; Spell checkers are your friend :)</span>

Egg applied to face.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Aug. 8, 2017, 6:56 p.m.</div>
<pre class="content">
On Tue, Aug 08, 2017 at 11:51:40AM -0700, Daniel Colascione wrote:
<span class="quote">&gt; On Tue, Aug 08 2017, Greg KH wrote:</span>
<span class="quote">&gt; &gt; On Tue, Aug 08, 2017 at 11:22:55AM -0700, Daniel Colascione wrote:</span>
<span class="quote">&gt; &gt;&gt; Adding more people.</span>
<span class="quote">&gt; &gt;&gt; </span>
<span class="quote">&gt; &gt;&gt; On Tue, Aug 08 2017, Daniel Colascione wrote:</span>
<span class="quote">&gt; &gt;&gt; &gt; /proc/pid/smaps_rollup is a new proc file that improves the</span>
<span class="quote">&gt; &gt;&gt; &gt; performance of user programs that determine aggregate memory</span>
<span class="quote">&gt; &gt;&gt; &gt; statistics (e.g., total PSS) of a process.</span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; What about linux-mm?  Don&#39;t they care about this?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Thanks. Added.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;</span>
<span class="quote">&gt; &gt; Also, do you have a Documentation/ABI update to describe exactly the</span>
<span class="quote">&gt; &gt; output of this file so we know what it is, and know not to change it in</span>
<span class="quote">&gt; &gt; the future?  Or wherever proc files are documented, I&#39;m not sure if ABI/</span>
<span class="quote">&gt; &gt; has all that many of them at the moment given the age of most of</span>
<span class="quote">&gt; &gt; them...</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I figured I&#39;d get feedback on the patch itself first. Does that make sense?</span>

You need to show exactly what this new file is looking like, that&#39;s the
the best way to see if the code is doing what you say you require in the
best way.

Also, linux-api might care about that, so you might want to do a v2 and
include that list as well.

thanks,

greg k-h
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/fs/proc/base.c b/fs/proc/base.c</span>
<span class="p_header">index 719c2e943ea1..a9587b9cace5 100644</span>
<span class="p_header">--- a/fs/proc/base.c</span>
<span class="p_header">+++ b/fs/proc/base.c</span>
<span class="p_chunk">@@ -2930,6 +2930,7 @@</span> <span class="p_context"> static const struct pid_entry tgid_base_stuff[] = {</span>
 #ifdef CONFIG_PROC_PAGE_MONITOR
 	REG(&quot;clear_refs&quot;, S_IWUSR, proc_clear_refs_operations),
 	REG(&quot;smaps&quot;,      S_IRUGO, proc_pid_smaps_operations),
<span class="p_add">+	REG(&quot;smaps_rollup&quot;, S_IRUGO, proc_pid_smaps_rollup_operations),</span>
 	REG(&quot;pagemap&quot;,    S_IRUSR, proc_pagemap_operations),
 #endif
 #ifdef CONFIG_SECURITY
<span class="p_chunk">@@ -3323,6 +3324,7 @@</span> <span class="p_context"> static const struct pid_entry tid_base_stuff[] = {</span>
 #ifdef CONFIG_PROC_PAGE_MONITOR
 	REG(&quot;clear_refs&quot;, S_IWUSR, proc_clear_refs_operations),
 	REG(&quot;smaps&quot;,     S_IRUGO, proc_tid_smaps_operations),
<span class="p_add">+	REG(&quot;smaps_rollup&quot;, S_IRUGO, proc_pid_smaps_rollup_operations),</span>
 	REG(&quot;pagemap&quot;,    S_IRUSR, proc_pagemap_operations),
 #endif
 #ifdef CONFIG_SECURITY
<span class="p_header">diff --git a/fs/proc/internal.h b/fs/proc/internal.h</span>
<span class="p_header">index aa2b89071630..2cbfcd32e884 100644</span>
<span class="p_header">--- a/fs/proc/internal.h</span>
<span class="p_header">+++ b/fs/proc/internal.h</span>
<span class="p_chunk">@@ -269,10 +269,12 @@</span> <span class="p_context"> extern int proc_remount(struct super_block *, int *, char *);</span>
 /*
  * task_[no]mmu.c
  */
<span class="p_add">+struct mem_size_stats;</span>
 struct proc_maps_private {
 	struct inode *inode;
 	struct task_struct *task;
 	struct mm_struct *mm;
<span class="p_add">+	struct mem_size_stats *rollup;</span>
 #ifdef CONFIG_MMU
 	struct vm_area_struct *tail_vma;
 #endif
<span class="p_chunk">@@ -288,6 +290,7 @@</span> <span class="p_context"> extern const struct file_operations proc_tid_maps_operations;</span>
 extern const struct file_operations proc_pid_numa_maps_operations;
 extern const struct file_operations proc_tid_numa_maps_operations;
 extern const struct file_operations proc_pid_smaps_operations;
<span class="p_add">+extern const struct file_operations proc_pid_smaps_rollup_operations;</span>
 extern const struct file_operations proc_tid_smaps_operations;
 extern const struct file_operations proc_clear_refs_operations;
 extern const struct file_operations proc_pagemap_operations;
<span class="p_header">diff --git a/fs/proc/task_mmu.c b/fs/proc/task_mmu.c</span>
<span class="p_header">index b836fd61ed87..02b55df7291c 100644</span>
<span class="p_header">--- a/fs/proc/task_mmu.c</span>
<span class="p_header">+++ b/fs/proc/task_mmu.c</span>
<span class="p_chunk">@@ -252,6 +252,7 @@</span> <span class="p_context"> static int proc_map_release(struct inode *inode, struct file *file)</span>
 	if (priv-&gt;mm)
 		mmdrop(priv-&gt;mm);
 
<span class="p_add">+	kfree(priv-&gt;rollup);</span>
 	return seq_release_private(inode, file);
 }
 
<span class="p_chunk">@@ -278,6 +279,23 @@</span> <span class="p_context"> static int is_stack(struct proc_maps_private *priv,</span>
 		vma-&gt;vm_end &gt;= vma-&gt;vm_mm-&gt;start_stack;
 }
 
<span class="p_add">+static void show_vma_header_prefix(struct seq_file *m,</span>
<span class="p_add">+				   unsigned long start, unsigned long end,</span>
<span class="p_add">+				   vm_flags_t flags, unsigned long long pgoff,</span>
<span class="p_add">+				   dev_t dev, unsigned long ino)</span>
<span class="p_add">+{</span>
<span class="p_add">+	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);</span>
<span class="p_add">+	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,</span>
<span class="p_add">+		   start,</span>
<span class="p_add">+		   end,</span>
<span class="p_add">+		   flags &amp; VM_READ ? &#39;r&#39; : &#39;-&#39;,</span>
<span class="p_add">+		   flags &amp; VM_WRITE ? &#39;w&#39; : &#39;-&#39;,</span>
<span class="p_add">+		   flags &amp; VM_EXEC ? &#39;x&#39; : &#39;-&#39;,</span>
<span class="p_add">+		   flags &amp; VM_MAYSHARE ? &#39;s&#39; : &#39;p&#39;,</span>
<span class="p_add">+		   pgoff,</span>
<span class="p_add">+		   MAJOR(dev), MINOR(dev), ino);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void
 show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)
 {
<span class="p_chunk">@@ -300,17 +318,7 @@</span> <span class="p_context"> show_map_vma(struct seq_file *m, struct vm_area_struct *vma, int is_pid)</span>
 
 	start = vma-&gt;vm_start;
 	end = vma-&gt;vm_end;
<span class="p_del">-</span>
<span class="p_del">-	seq_setwidth(m, 25 + sizeof(void *) * 6 - 1);</span>
<span class="p_del">-	seq_printf(m, &quot;%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu &quot;,</span>
<span class="p_del">-			start,</span>
<span class="p_del">-			end,</span>
<span class="p_del">-			flags &amp; VM_READ ? &#39;r&#39; : &#39;-&#39;,</span>
<span class="p_del">-			flags &amp; VM_WRITE ? &#39;w&#39; : &#39;-&#39;,</span>
<span class="p_del">-			flags &amp; VM_EXEC ? &#39;x&#39; : &#39;-&#39;,</span>
<span class="p_del">-			flags &amp; VM_MAYSHARE ? &#39;s&#39; : &#39;p&#39;,</span>
<span class="p_del">-			pgoff,</span>
<span class="p_del">-			MAJOR(dev), MINOR(dev), ino);</span>
<span class="p_add">+	show_vma_header_prefix(m, start, end, flags, pgoff, dev, ino);</span>
 
 	/*
 	 * Print the dentry name for named mappings, and a
<span class="p_chunk">@@ -429,6 +437,7 @@</span> <span class="p_context"> const struct file_operations proc_tid_maps_operations = {</span>
 
 #ifdef CONFIG_PROC_PAGE_MONITOR
 struct mem_size_stats {
<span class="p_add">+	bool first;</span>
 	unsigned long resident;
 	unsigned long shared_clean;
 	unsigned long shared_dirty;
<span class="p_chunk">@@ -442,7 +451,9 @@</span> <span class="p_context"> struct mem_size_stats {</span>
 	unsigned long swap;
 	unsigned long shared_hugetlb;
 	unsigned long private_hugetlb;
<span class="p_add">+	unsigned long first_vma_start;</span>
 	u64 pss;
<span class="p_add">+	u64 pss_locked;</span>
 	u64 swap_pss;
 	bool check_shmem_swap;
 };
<span class="p_chunk">@@ -718,18 +729,36 @@</span> <span class="p_context"> void __weak arch_show_smap(struct seq_file *m, struct vm_area_struct *vma)</span>
 
 static int show_smap(struct seq_file *m, void *v, int is_pid)
 {
<span class="p_add">+	struct proc_maps_private *priv = m-&gt;private;</span>
 	struct vm_area_struct *vma = v;
<span class="p_del">-	struct mem_size_stats mss;</span>
<span class="p_add">+	struct mem_size_stats mss_stack;</span>
<span class="p_add">+	struct mem_size_stats *mss;</span>
 	struct mm_walk smaps_walk = {
 		.pmd_entry = smaps_pte_range,
 #ifdef CONFIG_HUGETLB_PAGE
 		.hugetlb_entry = smaps_hugetlb_range,
 #endif
 		.mm = vma-&gt;vm_mm,
<span class="p_del">-		.private = &amp;mss,</span>
 	};
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	bool rollup_mode;</span>
<span class="p_add">+	bool last_vma;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (priv-&gt;rollup) {</span>
<span class="p_add">+		rollup_mode = true;</span>
<span class="p_add">+		mss = priv-&gt;rollup;</span>
<span class="p_add">+		if (mss-&gt;first) {</span>
<span class="p_add">+			mss-&gt;first_vma_start = vma-&gt;vm_start;</span>
<span class="p_add">+			mss-&gt;first = false;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		last_vma = !m_next_vma(priv, vma);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		rollup_mode = false;</span>
<span class="p_add">+		memset(&amp;mss_stack, 0, sizeof(mss_stack));</span>
<span class="p_add">+		mss = &amp;mss_stack;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	memset(&amp;mss, 0, sizeof mss);</span>
<span class="p_add">+	smaps_walk.private = mss;</span>
 
 #ifdef CONFIG_SHMEM
 	if (vma-&gt;vm_file &amp;&amp; shmem_mapping(vma-&gt;vm_file-&gt;f_mapping)) {
<span class="p_chunk">@@ -747,9 +776,9 @@</span> <span class="p_context"> static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
 
 		if (!shmem_swapped || (vma-&gt;vm_flags &amp; VM_SHARED) ||
 					!(vma-&gt;vm_flags &amp; VM_WRITE)) {
<span class="p_del">-			mss.swap = shmem_swapped;</span>
<span class="p_add">+			mss-&gt;swap = shmem_swapped;</span>
 		} else {
<span class="p_del">-			mss.check_shmem_swap = true;</span>
<span class="p_add">+			mss-&gt;check_shmem_swap = true;</span>
 			smaps_walk.pte_hole = smaps_pte_hole;
 		}
 	}
<span class="p_chunk">@@ -757,54 +786,71 @@</span> <span class="p_context"> static int show_smap(struct seq_file *m, void *v, int is_pid)</span>
 
 	/* mmap_sem is held in m_start */
 	walk_page_vma(vma, &amp;smaps_walk);
<span class="p_add">+	if (vma-&gt;vm_flags &amp; VM_LOCKED)</span>
<span class="p_add">+		mss-&gt;pss_locked += mss-&gt;pss;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rollup_mode) {</span>
<span class="p_add">+		show_map_vma(m, vma, is_pid);</span>
<span class="p_add">+	} else if (last_vma) {</span>
<span class="p_add">+		show_vma_header_prefix(</span>
<span class="p_add">+			m, mss-&gt;first_vma_start, vma-&gt;vm_end, 0, 0, 0, 0);</span>
<span class="p_add">+		seq_pad(m, &#39; &#39;);</span>
<span class="p_add">+		seq_puts(m, &quot;[rollup]\n&quot;);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		ret = SEQ_SKIP;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	show_map_vma(m, vma, is_pid);</span>
<span class="p_del">-</span>
<span class="p_del">-	seq_printf(m,</span>
<span class="p_del">-		   &quot;Size:           %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Rss:            %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Pss:            %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;LazyFree:       %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;ShmemPmdMapped: %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Shared_Hugetlb: %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Private_Hugetlb: %7lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Swap:           %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;SwapPss:        %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;KernelPageSize: %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;MMUPageSize:    %8lu kB\n&quot;</span>
<span class="p_del">-		   &quot;Locked:         %8lu kB\n&quot;,</span>
<span class="p_del">-		   (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; 10,</span>
<span class="p_del">-		   mss.resident &gt;&gt; 10,</span>
<span class="p_del">-		   (unsigned long)(mss.pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="p_del">-		   mss.shared_clean  &gt;&gt; 10,</span>
<span class="p_del">-		   mss.shared_dirty  &gt;&gt; 10,</span>
<span class="p_del">-		   mss.private_clean &gt;&gt; 10,</span>
<span class="p_del">-		   mss.private_dirty &gt;&gt; 10,</span>
<span class="p_del">-		   mss.referenced &gt;&gt; 10,</span>
<span class="p_del">-		   mss.anonymous &gt;&gt; 10,</span>
<span class="p_del">-		   mss.lazyfree &gt;&gt; 10,</span>
<span class="p_del">-		   mss.anonymous_thp &gt;&gt; 10,</span>
<span class="p_del">-		   mss.shmem_thp &gt;&gt; 10,</span>
<span class="p_del">-		   mss.shared_hugetlb &gt;&gt; 10,</span>
<span class="p_del">-		   mss.private_hugetlb &gt;&gt; 10,</span>
<span class="p_del">-		   mss.swap &gt;&gt; 10,</span>
<span class="p_del">-		   (unsigned long)(mss.swap_pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="p_del">-		   vma_kernel_pagesize(vma) &gt;&gt; 10,</span>
<span class="p_del">-		   vma_mmu_pagesize(vma) &gt;&gt; 10,</span>
<span class="p_del">-		   (vma-&gt;vm_flags &amp; VM_LOCKED) ?</span>
<span class="p_del">-			(unsigned long)(mss.pss &gt;&gt; (10 + PSS_SHIFT)) : 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	arch_show_smap(m, vma);</span>
<span class="p_del">-	show_smap_vma_flags(m, vma);</span>
<span class="p_add">+	if (!rollup_mode)</span>
<span class="p_add">+		seq_printf(m,</span>
<span class="p_add">+			   &quot;Size:           %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;KernelPageSize: %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;MMUPageSize:    %8lu kB\n&quot;,</span>
<span class="p_add">+			   (vma-&gt;vm_end - vma-&gt;vm_start) &gt;&gt; 10,</span>
<span class="p_add">+			   vma_kernel_pagesize(vma) &gt;&gt; 10,</span>
<span class="p_add">+			   vma_mmu_pagesize(vma) &gt;&gt; 10);</span>
<span class="p_add">+</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rollup_mode || last_vma)</span>
<span class="p_add">+		seq_printf(m,</span>
<span class="p_add">+			   &quot;Rss:            %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Pss:            %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Shared_Clean:   %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Shared_Dirty:   %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Private_Clean:  %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Private_Dirty:  %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Referenced:     %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Anonymous:      %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;LazyFree:       %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;AnonHugePages:  %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;ShmemPmdMapped: %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Shared_Hugetlb: %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Private_Hugetlb: %7lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Swap:           %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;SwapPss:        %8lu kB\n&quot;</span>
<span class="p_add">+			   &quot;Locked:         %8lu kB\n&quot;,</span>
<span class="p_add">+			   mss-&gt;resident &gt;&gt; 10,</span>
<span class="p_add">+			   (unsigned long)(mss-&gt;pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="p_add">+			   mss-&gt;shared_clean  &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;shared_dirty  &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;private_clean &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;private_dirty &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;referenced &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;anonymous &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;lazyfree &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;anonymous_thp &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;shmem_thp &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;shared_hugetlb &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;private_hugetlb &gt;&gt; 10,</span>
<span class="p_add">+			   mss-&gt;swap &gt;&gt; 10,</span>
<span class="p_add">+			   (unsigned long)(mss-&gt;swap_pss &gt;&gt; (10 + PSS_SHIFT)),</span>
<span class="p_add">+			   (unsigned long)(mss-&gt;pss &gt;&gt; (10 + PSS_SHIFT)));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!rollup_mode) {</span>
<span class="p_add">+		arch_show_smap(m, vma);</span>
<span class="p_add">+		show_smap_vma_flags(m, vma);</span>
<span class="p_add">+	}</span>
 	m_cache_vma(m, vma);
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int show_pid_smap(struct seq_file *m, void *v)
<span class="p_chunk">@@ -836,6 +882,25 @@</span> <span class="p_context"> static int pid_smaps_open(struct inode *inode, struct file *file)</span>
 	return do_maps_open(inode, file, &amp;proc_pid_smaps_op);
 }
 
<span class="p_add">+static int pid_smaps_rollup_open(struct inode *inode, struct file *file)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct seq_file *seq;</span>
<span class="p_add">+	struct proc_maps_private *priv;</span>
<span class="p_add">+	int ret = do_maps_open(inode, file, &amp;proc_pid_smaps_op);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+	seq = file-&gt;private_data;</span>
<span class="p_add">+	priv = seq-&gt;private;</span>
<span class="p_add">+	priv-&gt;rollup = kzalloc(sizeof(*priv-&gt;rollup), GFP_KERNEL);</span>
<span class="p_add">+	if (!priv-&gt;rollup) {</span>
<span class="p_add">+		proc_map_release(inode, file);</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	priv-&gt;rollup-&gt;first = true;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int tid_smaps_open(struct inode *inode, struct file *file)
 {
 	return do_maps_open(inode, file, &amp;proc_tid_smaps_op);
<span class="p_chunk">@@ -848,6 +913,13 @@</span> <span class="p_context"> const struct file_operations proc_pid_smaps_operations = {</span>
 	.release	= proc_map_release,
 };
 
<span class="p_add">+const struct file_operations proc_pid_smaps_rollup_operations = {</span>
<span class="p_add">+	.open		= pid_smaps_rollup_open,</span>
<span class="p_add">+	.read		= seq_read,</span>
<span class="p_add">+	.llseek		= seq_lseek,</span>
<span class="p_add">+	.release	= proc_map_release,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 const struct file_operations proc_tid_smaps_operations = {
 	.open		= tid_smaps_open,
 	.read		= seq_read,

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



