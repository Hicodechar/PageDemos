
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.14 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.14</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>June 24, 2016, 5:40 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160624174030.GB18687@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9197967/mbox/"
   >mbox</a>
|
   <a href="/patch/9197967/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9197967/">/patch/9197967/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	6D0F360754 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Jun 2016 17:41:21 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 539FC2094F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Jun 2016 17:41:21 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 46C5F284BE; Fri, 24 Jun 2016 17:41:21 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DF6A42094F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 24 Jun 2016 17:41:12 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751955AbcFXRks (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 24 Jun 2016 13:40:48 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:37135 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751872AbcFXRkc (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 24 Jun 2016 13:40:32 -0400
Received: from localhost (c-50-170-35-168.hsd1.wa.comcast.net
	[50.170.35.168])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id E6268305;
	Fri, 24 Jun 2016 17:40:30 +0000 (UTC)
Date: Fri, 24 Jun 2016 10:40:30 -0700
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.14
Message-ID: &lt;20160624174030.GB18687@kroah.com&gt;
References: &lt;20160624174023.GA18687@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160624174023.GA18687@kroah.com&gt;
User-Agent: Mutt/1.6.1 (2016-04-27)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - June 24, 2016, 5:40 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f4b33cdf991a..fadbb9d73c6d 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 13</span>
<span class="p_add">+SUBLEVEL = 14</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/arm/kernel/ptrace.c b/arch/arm/kernel/ptrace.c</span>
<span class="p_header">index ef9119f7462e..4d9375814b53 100644</span>
<span class="p_header">--- a/arch/arm/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/arm/kernel/ptrace.c</span>
<span class="p_chunk">@@ -733,8 +733,8 @@</span> <span class="p_context"> static int vfp_set(struct task_struct *target,</span>
 	if (ret)
 		return ret;
 
<span class="p_del">-	vfp_flush_hwstate(thread);</span>
 	thread-&gt;vfpstate.hard = new_vfp;
<span class="p_add">+	vfp_flush_hwstate(thread);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h</span>
<span class="p_header">index faad6df49e5b..bc6492b9a924 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/elf.h</span>
<span class="p_chunk">@@ -156,14 +156,14 @@</span> <span class="p_context"> extern int arch_setup_additional_pages(struct linux_binprm *bprm,</span>
 #define STACK_RND_MASK			(0x3ffff &gt;&gt; (PAGE_SHIFT - 12))
 #endif
 
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-</span>
 #ifdef __AARCH64EB__
 #define COMPAT_ELF_PLATFORM		(&quot;v8b&quot;)
 #else
 #define COMPAT_ELF_PLATFORM		(&quot;v8l&quot;)
 #endif
 
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+</span>
 #define COMPAT_ELF_ET_DYN_BASE		(2 * TASK_SIZE_32 / 3)
 
 /* AArch32 registers. */
<span class="p_header">diff --git a/arch/arm64/kernel/cpuinfo.c b/arch/arm64/kernel/cpuinfo.c</span>
<span class="p_header">index a5f234039616..0166cfbc866c 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/cpuinfo.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/cpuinfo.c</span>
<span class="p_chunk">@@ -22,6 +22,8 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/bitops.h&gt;
 #include &lt;linux/bug.h&gt;
<span class="p_add">+#include &lt;linux/compat.h&gt;</span>
<span class="p_add">+#include &lt;linux/elf.h&gt;</span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/kernel.h&gt;
 #include &lt;linux/personality.h&gt;
<span class="p_chunk">@@ -102,6 +104,7 @@</span> <span class="p_context"> static const char *const compat_hwcap2_str[] = {</span>
 static int c_show(struct seq_file *m, void *v)
 {
 	int i, j;
<span class="p_add">+	bool compat = personality(current-&gt;personality) == PER_LINUX32;</span>
 
 	for_each_online_cpu(i) {
 		struct cpuinfo_arm64 *cpuinfo = &amp;per_cpu(cpu_data, i);
<span class="p_chunk">@@ -113,6 +116,9 @@</span> <span class="p_context"> static int c_show(struct seq_file *m, void *v)</span>
 		 * &quot;processor&quot;.  Give glibc what it expects.
 		 */
 		seq_printf(m, &quot;processor\t: %d\n&quot;, i);
<span class="p_add">+		if (compat)</span>
<span class="p_add">+			seq_printf(m, &quot;model name\t: ARMv8 Processor rev %d (%s)\n&quot;,</span>
<span class="p_add">+				   MIDR_REVISION(midr), COMPAT_ELF_PLATFORM);</span>
 
 		seq_printf(m, &quot;BogoMIPS\t: %lu.%02lu\n&quot;,
 			   loops_per_jiffy / (500000UL/HZ),
<span class="p_chunk">@@ -125,7 +131,7 @@</span> <span class="p_context"> static int c_show(struct seq_file *m, void *v)</span>
 		 * software which does already (at least for 32-bit).
 		 */
 		seq_puts(m, &quot;Features\t:&quot;);
<span class="p_del">-		if (personality(current-&gt;personality) == PER_LINUX32) {</span>
<span class="p_add">+		if (compat) {</span>
 #ifdef CONFIG_COMPAT
 			for (j = 0; compat_hwcap_str[j]; j++)
 				if (compat_elf_hwcap &amp; (1 &lt;&lt; j))
<span class="p_header">diff --git a/arch/arm64/mm/fault.c b/arch/arm64/mm/fault.c</span>
<span class="p_header">index 40f5522245a2..4c1a118c1d09 100644</span>
<span class="p_header">--- a/arch/arm64/mm/fault.c</span>
<span class="p_header">+++ b/arch/arm64/mm/fault.c</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> int ptep_set_access_flags(struct vm_area_struct *vma,</span>
 	 * PTE_RDONLY is cleared by default in the asm below, so set it in
 	 * back if necessary (read-only or clean PTE).
 	 */
<span class="p_del">-	if (!pte_write(entry) || !dirty)</span>
<span class="p_add">+	if (!pte_write(entry) || !pte_sw_dirty(entry))</span>
 		pte_val(entry) |= PTE_RDONLY;
 
 	/*
<span class="p_header">diff --git a/arch/mips/include/asm/processor.h b/arch/mips/include/asm/processor.h</span>
<span class="p_header">index 3f832c3dd8f5..041153f5cf93 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/processor.h</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> extern unsigned int vced_count, vcei_count;</span>
  * User space process size: 2GB. This is hardcoded into a few places,
  * so don&#39;t change it unless you know what you are doing.
  */
<span class="p_del">-#define TASK_SIZE	0x7fff8000UL</span>
<span class="p_add">+#define TASK_SIZE	0x80000000UL</span>
 #endif
 
 #define STACK_TOP_MAX	TASK_SIZE
<span class="p_header">diff --git a/arch/parisc/kernel/unaligned.c b/arch/parisc/kernel/unaligned.c</span>
<span class="p_header">index d7c0acb35ec2..8d49614d600d 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/unaligned.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/unaligned.c</span>
<span class="p_chunk">@@ -666,7 +666,7 @@</span> <span class="p_context"> void handle_unaligned(struct pt_regs *regs)</span>
 		break;
 	}
 
<span class="p_del">-	if (modify &amp;&amp; R1(regs-&gt;iir))</span>
<span class="p_add">+	if (ret == 0 &amp;&amp; modify &amp;&amp; R1(regs-&gt;iir))</span>
 		regs-&gt;gr[R1(regs-&gt;iir)] = newbase;
 
 
<span class="p_chunk">@@ -677,6 +677,14 @@</span> <span class="p_context"> void handle_unaligned(struct pt_regs *regs)</span>
 
 	if (ret)
 	{
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The unaligned handler failed.</span>
<span class="p_add">+		 * If we were called by __get_user() or __put_user() jump</span>
<span class="p_add">+		 * to it&#39;s exception fixup handler instead of crashing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!user_mode(regs) &amp;&amp; fixup_exception(regs))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
 		printk(KERN_CRIT &quot;Unaligned handler failed, ret = %d\n&quot;, ret);
 		die_if_kernel(&quot;Unaligned data reference&quot;, regs, 28);
 
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index 2220f7a60def..070fa8552051 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -707,7 +707,7 @@</span> <span class="p_context"></span>
 #define   MMCR0_FCWAIT	0x00000002UL /* freeze counter in WAIT state */
 #define   MMCR0_FCHV	0x00000001UL /* freeze conditions in hypervisor mode */
 #define SPRN_MMCR1	798
<span class="p_del">-#define SPRN_MMCR2	769</span>
<span class="p_add">+#define SPRN_MMCR2	785</span>
 #define SPRN_MMCRA	0x312
 #define   MMCRA_SDSYNC	0x80000000UL /* SDAR synced with SIAR */
 #define   MMCRA_SDAR_DCACHE_MISS 0x40000000UL
<span class="p_chunk">@@ -744,13 +744,13 @@</span> <span class="p_context"></span>
 #define SPRN_PMC6	792
 #define SPRN_PMC7	793
 #define SPRN_PMC8	794
<span class="p_del">-#define SPRN_SIAR	780</span>
<span class="p_del">-#define SPRN_SDAR	781</span>
 #define SPRN_SIER	784
 #define   SIER_SIPR		0x2000000	/* Sampled MSR_PR */
 #define   SIER_SIHV		0x1000000	/* Sampled MSR_HV */
 #define   SIER_SIAR_VALID	0x0400000	/* SIAR contents valid */
 #define   SIER_SDAR_VALID	0x0200000	/* SDAR contents valid */
<span class="p_add">+#define SPRN_SIAR	796</span>
<span class="p_add">+#define SPRN_SDAR	797</span>
 #define SPRN_TACR	888
 #define SPRN_TCSCR	889
 #define SPRN_CSIGR	890
<span class="p_header">diff --git a/arch/powerpc/kernel/prom_init.c b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">index 92dea8df6b26..e52b82b71d79 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/prom_init.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/prom_init.c</span>
<span class="p_chunk">@@ -655,6 +655,7 @@</span> <span class="p_context"> unsigned char ibm_architecture_vec[] = {</span>
 	W(0xffff0000), W(0x003e0000),	/* POWER6 */
 	W(0xffff0000), W(0x003f0000),	/* POWER7 */
 	W(0xffff0000), W(0x004b0000),	/* POWER8E */
<span class="p_add">+	W(0xffff0000), W(0x004c0000),   /* POWER8NVL */</span>
 	W(0xffff0000), W(0x004d0000),	/* POWER8 */
 	W(0xffffffff), W(0x0f000004),	/* all 2.07-compliant */
 	W(0xffffffff), W(0x0f000003),	/* all 2.06-compliant */
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/eeh_pseries.c b/arch/powerpc/platforms/pseries/eeh_pseries.c</span>
<span class="p_header">index ac3ffd97e059..405baaf96864 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/eeh_pseries.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/eeh_pseries.c</span>
<span class="p_chunk">@@ -615,29 +615,50 @@</span> <span class="p_context"> static int pseries_eeh_configure_bridge(struct eeh_pe *pe)</span>
 {
 	int config_addr;
 	int ret;
<span class="p_add">+	/* Waiting 0.2s maximum before skipping configuration */</span>
<span class="p_add">+	int max_wait = 200;</span>
 
 	/* Figure out the PE address */
 	config_addr = pe-&gt;config_addr;
 	if (pe-&gt;addr)
 		config_addr = pe-&gt;addr;
 
<span class="p_del">-	/* Use new configure-pe function, if supported */</span>
<span class="p_del">-	if (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_del">-		ret = rtas_call(ibm_configure_pe, 3, 1, NULL,</span>
<span class="p_del">-				config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_del">-				BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_del">-	} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_del">-		ret = rtas_call(ibm_configure_bridge, 3, 1, NULL,</span>
<span class="p_del">-				config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_del">-				BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	while (max_wait &gt; 0) {</span>
<span class="p_add">+		/* Use new configure-pe function, if supported */</span>
<span class="p_add">+		if (ibm_configure_pe != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_add">+			ret = rtas_call(ibm_configure_pe, 3, 1, NULL,</span>
<span class="p_add">+					config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_add">+					BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_add">+		} else if (ibm_configure_bridge != RTAS_UNKNOWN_SERVICE) {</span>
<span class="p_add">+			ret = rtas_call(ibm_configure_bridge, 3, 1, NULL,</span>
<span class="p_add">+					config_addr, BUID_HI(pe-&gt;phb-&gt;buid),</span>
<span class="p_add">+					BUID_LO(pe-&gt;phb-&gt;buid));</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			return -EFAULT;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		pr_warn(&quot;%s: Unable to configure bridge PHB#%d-PE#%x (%d)\n&quot;,</span>
<span class="p_del">-			__func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr, ret);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If RTAS returns a delay value that&#39;s above 100ms, cut it</span>
<span class="p_add">+		 * down to 100ms in case firmware made a mistake.  For more</span>
<span class="p_add">+		 * on how these delay values work see rtas_busy_delay_time</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ret &gt; RTAS_EXTENDED_DELAY_MIN+2 &amp;&amp;</span>
<span class="p_add">+		    ret &lt;= RTAS_EXTENDED_DELAY_MAX)</span>
<span class="p_add">+			ret = RTAS_EXTENDED_DELAY_MIN+2;</span>
<span class="p_add">+</span>
<span class="p_add">+		max_wait -= rtas_busy_delay_time(ret);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (max_wait &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		rtas_busy_delay(ret);</span>
<span class="p_add">+	}</span>
 
<span class="p_add">+	pr_warn(&quot;%s: Unable to configure bridge PHB#%d-PE#%x (%d)\n&quot;,</span>
<span class="p_add">+		__func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr, ret);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/arch/s390/net/bpf_jit.h b/arch/s390/net/bpf_jit.h</span>
<span class="p_header">index f010c93a88b1..fda605dbc1b4 100644</span>
<span class="p_header">--- a/arch/s390/net/bpf_jit.h</span>
<span class="p_header">+++ b/arch/s390/net/bpf_jit.h</span>
<span class="p_chunk">@@ -37,7 +37,7 @@</span> <span class="p_context"> extern u8 sk_load_word[], sk_load_half[], sk_load_byte[];</span>
  *	      |		      |     |
  *	      +---------------+     |
  *	      | 8 byte skbp   |     |
<span class="p_del">- * R15+170 -&gt; +---------------+     |</span>
<span class="p_add">+ * R15+176 -&gt; +---------------+     |</span>
  *	      | 8 byte hlen   |     |
  * R15+168 -&gt; +---------------+     |
  *	      | 4 byte align  |     |
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> extern u8 sk_load_word[], sk_load_half[], sk_load_byte[];</span>
 #define STK_OFF		(STK_SPACE - STK_160_UNUSED)
 #define STK_OFF_TMP	160	/* Offset of tmp buffer on stack */
 #define STK_OFF_HLEN	168	/* Offset of SKB header length on stack */
<span class="p_del">-#define STK_OFF_SKBP	170	/* Offset of SKB pointer on stack */</span>
<span class="p_add">+#define STK_OFF_SKBP	176	/* Offset of SKB pointer on stack */</span>
 
 #define STK_OFF_R6	(160 - 11 * 8)	/* Offset of r6 on stack */
 #define STK_OFF_TCCNT	(160 - 12 * 8)	/* Offset of tail_call_cnt on stack */
<span class="p_header">diff --git a/arch/s390/net/bpf_jit_comp.c b/arch/s390/net/bpf_jit_comp.c</span>
<span class="p_header">index 9a0c4c22e536..0e2919dd8df3 100644</span>
<span class="p_header">--- a/arch/s390/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/s390/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> struct bpf_jit {</span>
 	int labels[1];		/* Labels for local jumps */
 };
 
<span class="p_del">-#define BPF_SIZE_MAX	0x7ffff	/* Max size for program (20 bit signed displ) */</span>
<span class="p_add">+#define BPF_SIZE_MAX	0xffff	/* Max size for program (16 bit branches) */</span>
 
 #define SEEN_SKB	1	/* skb access */
 #define SEEN_MEM	2	/* use mem[] for temporary storage */
<span class="p_chunk">@@ -446,7 +446,7 @@</span> <span class="p_context"> static void bpf_jit_prologue(struct bpf_jit *jit, bool is_classic)</span>
 		emit_load_skb_data_hlen(jit);
 	if (jit-&gt;seen &amp; SEEN_SKB_CHANGE)
 		/* stg %b1,ST_OFF_SKBP(%r0,%r15) */
<span class="p_del">-		EMIT6_DISP_LH(0xe3000000, 0x0024, REG_W1, REG_0, REG_15,</span>
<span class="p_add">+		EMIT6_DISP_LH(0xe3000000, 0x0024, BPF_REG_1, REG_0, REG_15,</span>
 			      STK_OFF_SKBP);
 	/* Clear A (%b0) and X (%b7) registers for converted BPF programs */
 	if (is_classic) {
<span class="p_header">diff --git a/arch/sparc/include/asm/head_64.h b/arch/sparc/include/asm/head_64.h</span>
<span class="p_header">index 10e9dabc4c41..f0700cfeedd7 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/head_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/head_64.h</span>
<span class="p_chunk">@@ -15,6 +15,10 @@</span> <span class="p_context"></span>
 
 #define	PTREGS_OFF	(STACK_BIAS + STACKFRAME_SZ)
 
<span class="p_add">+#define	RTRAP_PSTATE		(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_IE)</span>
<span class="p_add">+#define	RTRAP_PSTATE_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV)</span>
<span class="p_add">+#define RTRAP_PSTATE_AG_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_AG)</span>
<span class="p_add">+</span>
 #define __CHEETAH_ID	0x003e0014
 #define __JALAPENO_ID	0x003e0016
 #define __SERRANO_ID	0x003e0022
<span class="p_header">diff --git a/arch/sparc/include/asm/pgtable_64.h b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">index 131d36fcd07a..408b715c95a5 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/pgtable_64.h</span>
<span class="p_chunk">@@ -375,7 +375,7 @@</span> <span class="p_context"> static inline pgprot_t pgprot_noncached(pgprot_t prot)</span>
 #define pgprot_noncached pgprot_noncached
 
 #if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)
<span class="p_del">-static inline pte_t pte_mkhuge(pte_t pte)</span>
<span class="p_add">+static inline unsigned long __pte_huge_mask(void)</span>
 {
 	unsigned long mask;
 
<span class="p_chunk">@@ -390,8 +390,19 @@</span> <span class="p_context"> static inline pte_t pte_mkhuge(pte_t pte)</span>
 	: &quot;=r&quot; (mask)
 	: &quot;i&quot; (_PAGE_SZHUGE_4U), &quot;i&quot; (_PAGE_SZHUGE_4V));
 
<span class="p_del">-	return __pte(pte_val(pte) | mask);</span>
<span class="p_add">+	return mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline pte_t pte_mkhuge(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __pte(pte_val(pte) | __pte_huge_mask());</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool is_hugetlb_pte(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !!(pte_val(pte) &amp; __pte_huge_mask());</span>
 }
<span class="p_add">+</span>
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
 static inline pmd_t pmd_mkhuge(pmd_t pmd)
 {
<span class="p_chunk">@@ -403,6 +414,11 @@</span> <span class="p_context"> static inline pmd_t pmd_mkhuge(pmd_t pmd)</span>
 	return __pmd(pte_val(pte));
 }
 #endif
<span class="p_add">+#else</span>
<span class="p_add">+static inline bool is_hugetlb_pte(pte_t pte)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
 #endif
 
 static inline pte_t pte_mkdirty(pte_t pte)
<span class="p_chunk">@@ -865,6 +881,19 @@</span> <span class="p_context"> static inline unsigned long pud_pfn(pud_t pud)</span>
 void tlb_batch_add(struct mm_struct *mm, unsigned long vaddr,
 		   pte_t *ptep, pte_t orig, int fullmm);
 
<span class="p_add">+static void maybe_tlb_batch_add(struct mm_struct *mm, unsigned long vaddr,</span>
<span class="p_add">+				pte_t *ptep, pte_t orig, int fullmm)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* It is more efficient to let flush_tlb_kernel_range()</span>
<span class="p_add">+	 * handle init_mm tlb flushes.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * SUN4V NOTE: _PAGE_VALID is the same value in both the SUN4U</span>
<span class="p_add">+	 *             and SUN4V pte layout, so this inline test is fine.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (likely(mm != &amp;init_mm) &amp;&amp; pte_accessible(mm, orig))</span>
<span class="p_add">+		tlb_batch_add(mm, vaddr, ptep, orig, fullmm);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define __HAVE_ARCH_PMDP_HUGE_GET_AND_CLEAR
 static inline pmd_t pmdp_huge_get_and_clear(struct mm_struct *mm,
 					    unsigned long addr,
<span class="p_chunk">@@ -881,15 +910,7 @@</span> <span class="p_context"> static inline void __set_pte_at(struct mm_struct *mm, unsigned long addr,</span>
 	pte_t orig = *ptep;
 
 	*ptep = pte;
<span class="p_del">-</span>
<span class="p_del">-	/* It is more efficient to let flush_tlb_kernel_range()</span>
<span class="p_del">-	 * handle init_mm tlb flushes.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * SUN4V NOTE: _PAGE_VALID is the same value in both the SUN4U</span>
<span class="p_del">-	 *             and SUN4V pte layout, so this inline test is fine.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (likely(mm != &amp;init_mm) &amp;&amp; pte_accessible(mm, orig))</span>
<span class="p_del">-		tlb_batch_add(mm, addr, ptep, orig, fullmm);</span>
<span class="p_add">+	maybe_tlb_batch_add(mm, addr, ptep, orig, fullmm);</span>
 }
 
 #define set_pte_at(mm,addr,ptep,pte)	\
<span class="p_header">diff --git a/arch/sparc/include/asm/tlbflush_64.h b/arch/sparc/include/asm/tlbflush_64.h</span>
<span class="p_header">index dea1cfa2122b..a8e192e90700 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/tlbflush_64.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/tlbflush_64.h</span>
<span class="p_chunk">@@ -8,6 +8,7 @@</span> <span class="p_context"></span>
 #define TLB_BATCH_NR	192
 
 struct tlb_batch {
<span class="p_add">+	bool huge;</span>
 	struct mm_struct *mm;
 	unsigned long tlb_nr;
 	unsigned long active;
<span class="p_chunk">@@ -16,7 +17,7 @@</span> <span class="p_context"> struct tlb_batch {</span>
 
 void flush_tsb_kernel_range(unsigned long start, unsigned long end);
 void flush_tsb_user(struct tlb_batch *tb);
<span class="p_del">-void flush_tsb_user_page(struct mm_struct *mm, unsigned long vaddr);</span>
<span class="p_add">+void flush_tsb_user_page(struct mm_struct *mm, unsigned long vaddr, bool huge);</span>
 
 /* TLB flush operations. */
 
<span class="p_header">diff --git a/arch/sparc/include/asm/ttable.h b/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">index 71b5a67522ab..781b9f1dbdc2 100644</span>
<span class="p_header">--- a/arch/sparc/include/asm/ttable.h</span>
<span class="p_header">+++ b/arch/sparc/include/asm/ttable.h</span>
<span class="p_chunk">@@ -589,8 +589,8 @@</span> <span class="p_context"> user_rtt_fill_64bit:					\</span>
 	 restored;					\
 	nop; nop; nop; nop; nop; nop;			\
 	nop; nop; nop; nop; nop;			\
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_dax;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_mna;		\</span>
 	ba,a,pt	%xcc, user_rtt_fill_fixup;
 
 
<span class="p_chunk">@@ -652,8 +652,8 @@</span> <span class="p_context"> user_rtt_fill_32bit:					\</span>
 	 restored;					\
 	nop; nop; nop; nop; nop;			\
 	nop; nop; nop;					\
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_del">-	ba,a,pt	%xcc, user_rtt_fill_fixup;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_dax;		\</span>
<span class="p_add">+	ba,a,pt	%xcc, user_rtt_fill_fixup_mna;		\</span>
 	ba,a,pt	%xcc, user_rtt_fill_fixup;
 
 
<span class="p_header">diff --git a/arch/sparc/kernel/Makefile b/arch/sparc/kernel/Makefile</span>
<span class="p_header">index 7cf9c6ea3f1f..fdb13327fded 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/Makefile</span>
<span class="p_header">+++ b/arch/sparc/kernel/Makefile</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> CFLAGS_REMOVE_perf_event.o := -pg</span>
 CFLAGS_REMOVE_pcr.o := -pg
 endif
 
<span class="p_add">+obj-$(CONFIG_SPARC64)   += urtt_fill.o</span>
 obj-$(CONFIG_SPARC32)   += entry.o wof.o wuf.o
 obj-$(CONFIG_SPARC32)   += etrap_32.o
 obj-$(CONFIG_SPARC32)   += rtrap_32.o
<span class="p_header">diff --git a/arch/sparc/kernel/cherrs.S b/arch/sparc/kernel/cherrs.S</span>
<span class="p_header">index 4ee1ad420862..655628def68e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/cherrs.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/cherrs.S</span>
<span class="p_chunk">@@ -214,8 +214,7 @@</span> <span class="p_context"> do_dcpe_tl1_nonfatal:	/* Ok we may use interrupt globals safely. */</span>
 	subcc		%g1, %g2, %g1		! Next cacheline
 	bge,pt		%icc, 1b
 	 nop
<span class="p_del">-	ba,pt		%xcc, dcpe_icpe_tl1_common</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, dcpe_icpe_tl1_common</span>
 
 do_dcpe_tl1_fatal:
 	sethi		%hi(1f), %g7
<span class="p_chunk">@@ -224,8 +223,7 @@</span> <span class="p_context"> do_dcpe_tl1_fatal:</span>
 	mov		0x2, %o0
 	call		cheetah_plus_parity_error
 	 add		%sp, PTREGS_OFF, %o1
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_dcpe_tl1,.-do_dcpe_tl1
 
 	.globl		do_icpe_tl1
<span class="p_chunk">@@ -259,8 +257,7 @@</span> <span class="p_context"> do_icpe_tl1_nonfatal:	/* Ok we may use interrupt globals safely. */</span>
 	subcc		%g1, %g2, %g1
 	bge,pt		%icc, 1b
 	 nop
<span class="p_del">-	ba,pt		%xcc, dcpe_icpe_tl1_common</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, dcpe_icpe_tl1_common</span>
 
 do_icpe_tl1_fatal:
 	sethi		%hi(1f), %g7
<span class="p_chunk">@@ -269,8 +266,7 @@</span> <span class="p_context"> do_icpe_tl1_fatal:</span>
 	mov		0x3, %o0
 	call		cheetah_plus_parity_error
 	 add		%sp, PTREGS_OFF, %o1
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_icpe_tl1,.-do_icpe_tl1
 	
 	.type		dcpe_icpe_tl1_common,#function
<span class="p_chunk">@@ -456,7 +452,7 @@</span> <span class="p_context"> __cheetah_log_error:</span>
 	 cmp		%g2, 0x63
 	be		c_cee
 	 nop
<span class="p_del">-	ba,pt		%xcc, c_deferred</span>
<span class="p_add">+	ba,a,pt		%xcc, c_deferred</span>
 	.size		__cheetah_log_error,.-__cheetah_log_error
 
 	/* Cheetah FECC trap handling, we get here from tl{0,1}_fecc
<span class="p_header">diff --git a/arch/sparc/kernel/entry.S b/arch/sparc/kernel/entry.S</span>
<span class="p_header">index 33c02b15f478..a83707c83be8 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/entry.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/entry.S</span>
<span class="p_chunk">@@ -948,7 +948,24 @@</span> <span class="p_context"> linux_syscall_trace:</span>
 	cmp	%o0, 0
 	bne	3f
 	 mov	-ENOSYS, %o0
<span class="p_add">+</span>
<span class="p_add">+	/* Syscall tracing can modify the registers.  */</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_G1], %g1</span>
<span class="p_add">+	sethi	%hi(sys_call_table), %l7</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I0], %i0</span>
<span class="p_add">+	or	%l7, %lo(sys_call_table), %l7</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I1], %i1</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I2], %i2</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I3], %i3</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I4], %i4</span>
<span class="p_add">+	ld	[%sp + STACKFRAME_SZ + PT_I5], %i5</span>
<span class="p_add">+	cmp	%g1, NR_syscalls</span>
<span class="p_add">+	bgeu	3f</span>
<span class="p_add">+	 mov	-ENOSYS, %o0</span>
<span class="p_add">+</span>
<span class="p_add">+	sll	%g1, 2, %l4</span>
 	mov	%i0, %o0
<span class="p_add">+	ld	[%l7 + %l4], %l7</span>
 	mov	%i1, %o1
 	mov	%i2, %o2
 	mov	%i3, %o3
<span class="p_header">diff --git a/arch/sparc/kernel/fpu_traps.S b/arch/sparc/kernel/fpu_traps.S</span>
<span class="p_header">index a6864826a4bd..336d2750fe78 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/fpu_traps.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/fpu_traps.S</span>
<span class="p_chunk">@@ -100,8 +100,8 @@</span> <span class="p_context"> do_fpdis:</span>
 	fmuld		%f0, %f2, %f26
 	faddd		%f0, %f2, %f28
 	fmuld		%f0, %f2, %f30
<span class="p_del">-	b,pt		%xcc, fpdis_exit</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, fpdis_exit</span>
<span class="p_add">+</span>
 2:	andcc		%g5, FPRS_DU, %g0
 	bne,pt		%icc, 3f
 	 fzero		%f32
<span class="p_chunk">@@ -144,8 +144,8 @@</span> <span class="p_context"> do_fpdis:</span>
 	fmuld		%f32, %f34, %f58
 	faddd		%f32, %f34, %f60
 	fmuld		%f32, %f34, %f62
<span class="p_del">-	ba,pt		%xcc, fpdis_exit</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, fpdis_exit</span>
<span class="p_add">+</span>
 3:	mov		SECONDARY_CONTEXT, %g3
 	add		%g6, TI_FPREGS, %g1
 
<span class="p_chunk">@@ -197,8 +197,7 @@</span> <span class="p_context"> fpdis_exit2:</span>
 fp_other_bounce:
 	call		do_fpother
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		fp_other_bounce,.-fp_other_bounce
 
 	.align		32
<span class="p_header">diff --git a/arch/sparc/kernel/head_64.S b/arch/sparc/kernel/head_64.S</span>
<span class="p_header">index f2d30cab5b3f..51faf92ace00 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/head_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/head_64.S</span>
<span class="p_chunk">@@ -461,9 +461,8 @@</span> <span class="p_context"> sun4v_chip_type:</span>
 	subcc	%g3, 1, %g3
 	bne,pt	%xcc, 41b
 	add	%g1, 1, %g1
<span class="p_del">-	mov	SUN4V_CHIP_SPARC64X, %g4</span>
 	ba,pt	%xcc, 5f
<span class="p_del">-	nop</span>
<span class="p_add">+	 mov	SUN4V_CHIP_SPARC64X, %g4</span>
 
 49:
 	mov	SUN4V_CHIP_UNKNOWN, %g4
<span class="p_chunk">@@ -548,8 +547,7 @@</span> <span class="p_context"> sun4u_init:</span>
 	stxa		%g0, [%g7] ASI_DMMU
 	membar	#Sync
 
<span class="p_del">-	ba,pt		%xcc, sun4u_continue</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, sun4u_continue</span>
 
 sun4v_init:
 	/* Set ctx 0 */
<span class="p_chunk">@@ -560,14 +558,12 @@</span> <span class="p_context"> sun4v_init:</span>
 	mov		SECONDARY_CONTEXT, %g7
 	stxa		%g0, [%g7] ASI_MMU
 	membar		#Sync
<span class="p_del">-	ba,pt		%xcc, niagara_tlb_fixup</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, niagara_tlb_fixup</span>
 
 sun4u_continue:
 	BRANCH_IF_ANY_CHEETAH(g1, g7, cheetah_tlb_fixup)
 
<span class="p_del">-	ba,pt	%xcc, spitfire_tlb_fixup</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, spitfire_tlb_fixup</span>
 
 niagara_tlb_fixup:
 	mov	3, %g2		/* Set TLB type to hypervisor. */
<span class="p_chunk">@@ -639,8 +635,7 @@</span> <span class="p_context"> niagara_patch:</span>
 	call	hypervisor_patch_cachetlbops
 	 nop
 
<span class="p_del">-	ba,pt	%xcc, tlb_fixup_done</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, tlb_fixup_done</span>
 
 cheetah_tlb_fixup:
 	mov	2, %g2		/* Set TLB type to cheetah+. */
<span class="p_chunk">@@ -659,8 +654,7 @@</span> <span class="p_context"> cheetah_tlb_fixup:</span>
 	call	cheetah_patch_cachetlbops
 	 nop
 
<span class="p_del">-	ba,pt	%xcc, tlb_fixup_done</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, tlb_fixup_done</span>
 
 spitfire_tlb_fixup:
 	/* Set TLB type to spitfire. */
<span class="p_chunk">@@ -782,8 +776,7 @@</span> <span class="p_context"> setup_trap_table:</span>
 	call	%o1
 	 add	%sp, (2047 + 128), %o0
 
<span class="p_del">-	ba,pt	%xcc, 2f</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, 2f</span>
 
 1:	sethi	%hi(sparc64_ttable_tl0), %o0
 	set	prom_set_trap_table_name, %g2
<span class="p_chunk">@@ -822,8 +815,7 @@</span> <span class="p_context"> setup_trap_table:</span>
 
 	BRANCH_IF_ANY_CHEETAH(o2, o3, 1f)
 
<span class="p_del">-	ba,pt	%xcc, 2f</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, 2f</span>
 
 	/* Disable STICK_INT interrupts. */
 1:
<span class="p_header">diff --git a/arch/sparc/kernel/misctrap.S b/arch/sparc/kernel/misctrap.S</span>
<span class="p_header">index 753b4f031bfb..34b4933900bf 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/misctrap.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/misctrap.S</span>
<span class="p_chunk">@@ -18,8 +18,7 @@</span> <span class="p_context"> __do_privact:</span>
 109:	or		%g7, %lo(109b), %g7
 	call		do_privact
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__do_privact,.-__do_privact
 
 	.type		do_mna,#function
<span class="p_chunk">@@ -46,8 +45,7 @@</span> <span class="p_context"> do_mna:</span>
 	mov		%l5, %o2
 	call		mem_address_unaligned
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_mna,.-do_mna
 
 	.type		do_lddfmna,#function
<span class="p_chunk">@@ -65,8 +63,7 @@</span> <span class="p_context"> do_lddfmna:</span>
 	mov		%l5, %o2
 	call		handle_lddfmna
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_lddfmna,.-do_lddfmna
 
 	.type		do_stdfmna,#function
<span class="p_chunk">@@ -84,8 +81,7 @@</span> <span class="p_context"> do_stdfmna:</span>
 	mov		%l5, %o2
 	call		handle_stdfmna
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		do_stdfmna,.-do_stdfmna
 
 	.type		breakpoint_trap,#function
<span class="p_header">diff --git a/arch/sparc/kernel/pci.c b/arch/sparc/kernel/pci.c</span>
<span class="p_header">index badf0951d73c..9f9614df9e1e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/pci.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/pci.c</span>
<span class="p_chunk">@@ -994,6 +994,23 @@</span> <span class="p_context"> void pcibios_set_master(struct pci_dev *dev)</span>
 	/* No special bus mastering setup handling */
 }
 
<span class="p_add">+#ifdef CONFIG_PCI_IOV</span>
<span class="p_add">+int pcibios_add_device(struct pci_dev *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *pdev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Add sriov arch specific initialization here.</span>
<span class="p_add">+	 * Copy dev_archdata from PF to VF</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dev-&gt;is_virtfn) {</span>
<span class="p_add">+		pdev = dev-&gt;physfn;</span>
<span class="p_add">+		memcpy(&amp;dev-&gt;dev.archdata, &amp;pdev-&gt;dev.archdata,</span>
<span class="p_add">+		       sizeof(struct dev_archdata));</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif /* CONFIG_PCI_IOV */</span>
<span class="p_add">+</span>
 static int __init pcibios_init(void)
 {
 	pci_dfl_cache_line_size = 64 &gt;&gt; 2;
<span class="p_header">diff --git a/arch/sparc/kernel/rtrap_64.S b/arch/sparc/kernel/rtrap_64.S</span>
<span class="p_header">index d08bdaffdbfc..216948ca4382 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/rtrap_64.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/rtrap_64.S</span>
<span class="p_chunk">@@ -14,10 +14,6 @@</span> <span class="p_context"></span>
 #include &lt;asm/visasm.h&gt;
 #include &lt;asm/processor.h&gt;
 
<span class="p_del">-#define		RTRAP_PSTATE		(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_IE)</span>
<span class="p_del">-#define		RTRAP_PSTATE_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV)</span>
<span class="p_del">-#define		RTRAP_PSTATE_AG_IRQOFF	(PSTATE_TSO|PSTATE_PEF|PSTATE_PRIV|PSTATE_AG)</span>
<span class="p_del">-</span>
 #ifdef CONFIG_CONTEXT_TRACKING
 # define SCHEDULE_USER schedule_user
 #else
<span class="p_chunk">@@ -242,52 +238,17 @@</span> <span class="p_context"> rt_continue:	ldx			[%sp + PTREGS_OFF + PT_V9_G1], %g1</span>
 		 wrpr			%g1, %cwp
 		ba,a,pt			%xcc, user_rtt_fill_64bit
 
<span class="p_del">-user_rtt_fill_fixup:</span>
<span class="p_del">-		rdpr	%cwp, %g1</span>
<span class="p_del">-		add	%g1, 1, %g1</span>
<span class="p_del">-		wrpr	%g1, 0x0, %cwp</span>
<span class="p_del">-</span>
<span class="p_del">-		rdpr	%wstate, %g2</span>
<span class="p_del">-		sll	%g2, 3, %g2</span>
<span class="p_del">-		wrpr	%g2, 0x0, %wstate</span>
<span class="p_del">-</span>
<span class="p_del">-		/* We know %canrestore and %otherwin are both zero.  */</span>
<span class="p_del">-</span>
<span class="p_del">-		sethi	%hi(sparc64_kern_pri_context), %g2</span>
<span class="p_del">-		ldx	[%g2 + %lo(sparc64_kern_pri_context)], %g2</span>
<span class="p_del">-		mov	PRIMARY_CONTEXT, %g1</span>
<span class="p_del">-</span>
<span class="p_del">-661:		stxa	%g2, [%g1] ASI_DMMU</span>
<span class="p_del">-		.section .sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_del">-		.word	661b</span>
<span class="p_del">-		stxa	%g2, [%g1] ASI_MMU</span>
<span class="p_del">-		.previous</span>
<span class="p_del">-</span>
<span class="p_del">-		sethi	%hi(KERNBASE), %g1</span>
<span class="p_del">-		flush	%g1</span>
<span class="p_add">+user_rtt_fill_fixup_dax:</span>
<span class="p_add">+		ba,pt	%xcc, user_rtt_fill_fixup_common</span>
<span class="p_add">+		 mov	1, %g3</span>
 
<span class="p_del">-		or	%g4, FAULT_CODE_WINFIXUP, %g4</span>
<span class="p_del">-		stb	%g4, [%g6 + TI_FAULT_CODE]</span>
<span class="p_del">-		stx	%g5, [%g6 + TI_FAULT_ADDR]</span>
<span class="p_add">+user_rtt_fill_fixup_mna:</span>
<span class="p_add">+		ba,pt	%xcc, user_rtt_fill_fixup_common</span>
<span class="p_add">+		 mov	2, %g3</span>
 
<span class="p_del">-		mov	%g6, %l1</span>
<span class="p_del">-		wrpr	%g0, 0x0, %tl</span>
<span class="p_del">-</span>
<span class="p_del">-661:		nop</span>
<span class="p_del">-		.section		.sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_del">-		.word			661b</span>
<span class="p_del">-		SET_GL(0)</span>
<span class="p_del">-		.previous</span>
<span class="p_del">-</span>
<span class="p_del">-		wrpr	%g0, RTRAP_PSTATE, %pstate</span>
<span class="p_del">-</span>
<span class="p_del">-		mov	%l1, %g6</span>
<span class="p_del">-		ldx	[%g6 + TI_TASK], %g4</span>
<span class="p_del">-		LOAD_PER_CPU_BASE(%g5, %g6, %g1, %g2, %g3)</span>
<span class="p_del">-		call	do_sparc64_fault</span>
<span class="p_del">-		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_del">-		ba,pt	%xcc, rtrap</span>
<span class="p_del">-		 nop</span>
<span class="p_add">+user_rtt_fill_fixup:</span>
<span class="p_add">+		ba,pt	%xcc, user_rtt_fill_fixup_common</span>
<span class="p_add">+		 clr	%g3</span>
 
 user_rtt_pre_restore:
 		add			%g1, 1, %g1
<span class="p_header">diff --git a/arch/sparc/kernel/signal32.c b/arch/sparc/kernel/signal32.c</span>
<span class="p_header">index 4eed773a7735..77655f0f0fc7 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/signal32.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/signal32.c</span>
<span class="p_chunk">@@ -138,12 +138,24 @@</span> <span class="p_context"> int copy_siginfo_from_user32(siginfo_t *to, compat_siginfo_t __user *from)</span>
 	return 0;
 }
 
<span class="p_add">+/* Checks if the fp is valid.  We always build signal frames which are</span>
<span class="p_add">+ * 16-byte aligned, therefore we can always enforce that the restore</span>
<span class="p_add">+ * frame has that property as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((((unsigned long) fp) &amp; 15) ||</span>
<span class="p_add">+	    ((unsigned long)fp) &gt; 0x100000000ULL - fplen)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void do_sigreturn32(struct pt_regs *regs)
 {
 	struct signal_frame32 __user *sf;
 	compat_uptr_t fpu_save;
 	compat_uptr_t rwin_save;
<span class="p_del">-	unsigned int psr;</span>
<span class="p_add">+	unsigned int psr, ufp;</span>
 	unsigned pc, npc;
 	sigset_t set;
 	compat_sigset_t seta;
<span class="p_chunk">@@ -158,11 +170,16 @@</span> <span class="p_context"> void do_sigreturn32(struct pt_regs *regs)</span>
 	sf = (struct signal_frame32 __user *) regs-&gt;u_regs[UREG_FP];
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||</span>
<span class="p_del">-	    (((unsigned long) sf) &amp; 3))</span>
<span class="p_add">+	if (invalid_frame_pointer(sf, sizeof(*sf)))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;info.si_regs.u_regs[UREG_FP]))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
 		goto segv;
 
<span class="p_del">-	if (get_user(pc, &amp;sf-&gt;info.si_regs.pc) ||</span>
<span class="p_add">+	if (__get_user(pc, &amp;sf-&gt;info.si_regs.pc) ||</span>
 	    __get_user(npc, &amp;sf-&gt;info.si_regs.npc))
 		goto segv;
 
<span class="p_chunk">@@ -227,7 +244,7 @@</span> <span class="p_context"> segv:</span>
 asmlinkage void do_rt_sigreturn32(struct pt_regs *regs)
 {
 	struct rt_signal_frame32 __user *sf;
<span class="p_del">-	unsigned int psr, pc, npc;</span>
<span class="p_add">+	unsigned int psr, pc, npc, ufp;</span>
 	compat_uptr_t fpu_save;
 	compat_uptr_t rwin_save;
 	sigset_t set;
<span class="p_chunk">@@ -242,11 +259,16 @@</span> <span class="p_context"> asmlinkage void do_rt_sigreturn32(struct pt_regs *regs)</span>
 	sf = (struct rt_signal_frame32 __user *) regs-&gt;u_regs[UREG_FP];
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||</span>
<span class="p_del">-	    (((unsigned long) sf) &amp; 3))</span>
<span class="p_add">+	if (invalid_frame_pointer(sf, sizeof(*sf)))</span>
 		goto segv;
 
<span class="p_del">-	if (get_user(pc, &amp;sf-&gt;regs.pc) || </span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;regs.u_regs[UREG_FP]))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (__get_user(pc, &amp;sf-&gt;regs.pc) ||</span>
 	    __get_user(npc, &amp;sf-&gt;regs.npc))
 		goto segv;
 
<span class="p_chunk">@@ -307,14 +329,6 @@</span> <span class="p_context"> segv:</span>
 	force_sig(SIGSEGV, current);
 }
 
<span class="p_del">-/* Checks if the fp is valid */</span>
<span class="p_del">-static int invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((((unsigned long) fp) &amp; 7) || ((unsigned long)fp) &gt; 0x100000000ULL - fplen)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)
 {
 	unsigned long sp;
<span class="p_header">diff --git a/arch/sparc/kernel/signal_32.c b/arch/sparc/kernel/signal_32.c</span>
<span class="p_header">index 52aa5e4ce5e7..c3c12efe0bc0 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/signal_32.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/signal_32.c</span>
<span class="p_chunk">@@ -60,10 +60,22 @@</span> <span class="p_context"> struct rt_signal_frame {</span>
 #define SF_ALIGNEDSZ  (((sizeof(struct signal_frame) + 7) &amp; (~7)))
 #define RT_ALIGNEDSZ  (((sizeof(struct rt_signal_frame) + 7) &amp; (~7)))
 
<span class="p_add">+/* Checks if the fp is valid.  We always build signal frames which are</span>
<span class="p_add">+ * 16-byte aligned, therefore we can always enforce that the restore</span>
<span class="p_add">+ * frame has that property as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline bool invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if ((((unsigned long) fp) &amp; 15) || !__access_ok((unsigned long)fp, fplen))</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 asmlinkage void do_sigreturn(struct pt_regs *regs)
 {
<span class="p_add">+	unsigned long up_psr, pc, npc, ufp;</span>
 	struct signal_frame __user *sf;
<span class="p_del">-	unsigned long up_psr, pc, npc;</span>
 	sigset_t set;
 	__siginfo_fpu_t __user *fpu_save;
 	__siginfo_rwin_t __user *rwin_save;
<span class="p_chunk">@@ -77,10 +89,13 @@</span> <span class="p_context"> asmlinkage void do_sigreturn(struct pt_regs *regs)</span>
 	sf = (struct signal_frame __user *) regs-&gt;u_regs[UREG_FP];
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)))</span>
<span class="p_add">+	if (!invalid_frame_pointer(sf, sizeof(*sf)))</span>
<span class="p_add">+		goto segv_and_exit;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;info.si_regs.u_regs[UREG_FP]))</span>
 		goto segv_and_exit;
 
<span class="p_del">-	if (((unsigned long) sf) &amp; 3)</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
 		goto segv_and_exit;
 
 	err = __get_user(pc,  &amp;sf-&gt;info.si_regs.pc);
<span class="p_chunk">@@ -127,7 +142,7 @@</span> <span class="p_context"> segv_and_exit:</span>
 asmlinkage void do_rt_sigreturn(struct pt_regs *regs)
 {
 	struct rt_signal_frame __user *sf;
<span class="p_del">-	unsigned int psr, pc, npc;</span>
<span class="p_add">+	unsigned int psr, pc, npc, ufp;</span>
 	__siginfo_fpu_t __user *fpu_save;
 	__siginfo_rwin_t __user *rwin_save;
 	sigset_t set;
<span class="p_chunk">@@ -135,8 +150,13 @@</span> <span class="p_context"> asmlinkage void do_rt_sigreturn(struct pt_regs *regs)</span>
 
 	synchronize_user_stack();
 	sf = (struct rt_signal_frame __user *) regs-&gt;u_regs[UREG_FP];
<span class="p_del">-	if (!access_ok(VERIFY_READ, sf, sizeof(*sf)) ||</span>
<span class="p_del">-	    (((unsigned long) sf) &amp; 0x03))</span>
<span class="p_add">+	if (!invalid_frame_pointer(sf, sizeof(*sf)))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;regs.u_regs[UREG_FP]))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ufp &amp; 0x7)</span>
 		goto segv;
 
 	err = __get_user(pc, &amp;sf-&gt;regs.pc);
<span class="p_chunk">@@ -178,15 +198,6 @@</span> <span class="p_context"> segv:</span>
 	force_sig(SIGSEGV, current);
 }
 
<span class="p_del">-/* Checks if the fp is valid */</span>
<span class="p_del">-static inline int invalid_frame_pointer(void __user *fp, int fplen)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((((unsigned long) fp) &amp; 7) || !__access_ok((unsigned long)fp, fplen))</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)
 {
 	unsigned long sp = regs-&gt;u_regs[UREG_FP];
<span class="p_header">diff --git a/arch/sparc/kernel/signal_64.c b/arch/sparc/kernel/signal_64.c</span>
<span class="p_header">index d88beff47bab..5ee930c48f4c 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/signal_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/signal_64.c</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> asmlinkage void sparc64_set_context(struct pt_regs *regs)</span>
 	unsigned char fenab;
 	int err;
 
<span class="p_del">-	flush_user_windows();</span>
<span class="p_add">+	synchronize_user_stack();</span>
 	if (get_thread_wsaved()					||
 	    (((unsigned long)ucp) &amp; (sizeof(unsigned long)-1))	||
 	    (!__access_ok(ucp, sizeof(*ucp))))
<span class="p_chunk">@@ -234,6 +234,17 @@</span> <span class="p_context"> do_sigsegv:</span>
 	goto out;
 }
 
<span class="p_add">+/* Checks if the fp is valid.  We always build rt signal frames which</span>
<span class="p_add">+ * are 16-byte aligned, therefore we can always enforce that the</span>
<span class="p_add">+ * restore frame has that property as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool invalid_frame_pointer(void __user *fp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (((unsigned long) fp) &amp; 15)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct rt_signal_frame {
 	struct sparc_stackf	ss;
 	siginfo_t		info;
<span class="p_chunk">@@ -246,8 +257,8 @@</span> <span class="p_context"> struct rt_signal_frame {</span>
 
 void do_rt_sigreturn(struct pt_regs *regs)
 {
<span class="p_add">+	unsigned long tpc, tnpc, tstate, ufp;</span>
 	struct rt_signal_frame __user *sf;
<span class="p_del">-	unsigned long tpc, tnpc, tstate;</span>
 	__siginfo_fpu_t __user *fpu_save;
 	__siginfo_rwin_t __user *rwin_save;
 	sigset_t set;
<span class="p_chunk">@@ -261,10 +272,16 @@</span> <span class="p_context"> void do_rt_sigreturn(struct pt_regs *regs)</span>
 		(regs-&gt;u_regs [UREG_FP] + STACK_BIAS);
 
 	/* 1. Make sure we are not getting garbage from the user */
<span class="p_del">-	if (((unsigned long) sf) &amp; 3)</span>
<span class="p_add">+	if (invalid_frame_pointer(sf))</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (get_user(ufp, &amp;sf-&gt;regs.u_regs[UREG_FP]))</span>
 		goto segv;
 
<span class="p_del">-	err = get_user(tpc, &amp;sf-&gt;regs.tpc);</span>
<span class="p_add">+	if ((ufp + STACK_BIAS) &amp; 0x7)</span>
<span class="p_add">+		goto segv;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = __get_user(tpc, &amp;sf-&gt;regs.tpc);</span>
 	err |= __get_user(tnpc, &amp;sf-&gt;regs.tnpc);
 	if (test_thread_flag(TIF_32BIT)) {
 		tpc &amp;= 0xffffffff;
<span class="p_chunk">@@ -308,14 +325,6 @@</span> <span class="p_context"> segv:</span>
 	force_sig(SIGSEGV, current);
 }
 
<span class="p_del">-/* Checks if the fp is valid */</span>
<span class="p_del">-static int invalid_frame_pointer(void __user *fp)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (((unsigned long) fp) &amp; 15)</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline void __user *get_sigframe(struct ksignal *ksig, struct pt_regs *regs, unsigned long framesize)
 {
 	unsigned long sp = regs-&gt;u_regs[UREG_FP] + STACK_BIAS;
<span class="p_header">diff --git a/arch/sparc/kernel/sigutil_32.c b/arch/sparc/kernel/sigutil_32.c</span>
<span class="p_header">index 0f6eebe71e6c..e5fe8cef9a69 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sigutil_32.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sigutil_32.c</span>
<span class="p_chunk">@@ -48,6 +48,10 @@</span> <span class="p_context"> int save_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)</span>
 int restore_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)
 {
 	int err;
<span class="p_add">+</span>
<span class="p_add">+	if (((unsigned long) fpu) &amp; 3)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_SMP
 	if (test_tsk_thread_flag(current, TIF_USEDFPU))
 		regs-&gt;psr &amp;= ~PSR_EF;
<span class="p_chunk">@@ -97,7 +101,10 @@</span> <span class="p_context"> int restore_rwin_state(__siginfo_rwin_t __user *rp)</span>
 	struct thread_info *t = current_thread_info();
 	int i, wsaved, err;
 
<span class="p_del">-	__get_user(wsaved, &amp;rp-&gt;wsaved);</span>
<span class="p_add">+	if (((unsigned long) rp) &amp; 3)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	get_user(wsaved, &amp;rp-&gt;wsaved);</span>
 	if (wsaved &gt; NSWINS)
 		return -EFAULT;
 
<span class="p_header">diff --git a/arch/sparc/kernel/sigutil_64.c b/arch/sparc/kernel/sigutil_64.c</span>
<span class="p_header">index 387834a9c56a..36aadcbeac69 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/sigutil_64.c</span>
<span class="p_header">+++ b/arch/sparc/kernel/sigutil_64.c</span>
<span class="p_chunk">@@ -37,7 +37,10 @@</span> <span class="p_context"> int restore_fpu_state(struct pt_regs *regs, __siginfo_fpu_t __user *fpu)</span>
 	unsigned long fprs;
 	int err;
 
<span class="p_del">-	err = __get_user(fprs, &amp;fpu-&gt;si_fprs);</span>
<span class="p_add">+	if (((unsigned long) fpu) &amp; 7)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = get_user(fprs, &amp;fpu-&gt;si_fprs);</span>
 	fprs_write(0);
 	regs-&gt;tstate &amp;= ~TSTATE_PEF;
 	if (fprs &amp; FPRS_DL)
<span class="p_chunk">@@ -72,7 +75,10 @@</span> <span class="p_context"> int restore_rwin_state(__siginfo_rwin_t __user *rp)</span>
 	struct thread_info *t = current_thread_info();
 	int i, wsaved, err;
 
<span class="p_del">-	__get_user(wsaved, &amp;rp-&gt;wsaved);</span>
<span class="p_add">+	if (((unsigned long) rp) &amp; 7)</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	get_user(wsaved, &amp;rp-&gt;wsaved);</span>
 	if (wsaved &gt; NSWINS)
 		return -EFAULT;
 
<span class="p_header">diff --git a/arch/sparc/kernel/spiterrs.S b/arch/sparc/kernel/spiterrs.S</span>
<span class="p_header">index c357e40ffd01..4a73009f66a5 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/spiterrs.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/spiterrs.S</span>
<span class="p_chunk">@@ -85,8 +85,7 @@</span> <span class="p_context"> __spitfire_cee_trap_continue:</span>
 	ba,pt		%xcc, etraptl1
 	 rd		%pc, %g7
 
<span class="p_del">-	ba,pt		%xcc, 2f</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, 2f</span>
 
 1:	ba,pt		%xcc, etrap_irq
 	 rd		%pc, %g7
<span class="p_chunk">@@ -100,8 +99,7 @@</span> <span class="p_context"> __spitfire_cee_trap_continue:</span>
 	mov		%l5, %o2
 	call		spitfire_access_error
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_access_error,.-__spitfire_access_error
 
 	/* This is the trap handler entry point for ECC correctable
<span class="p_chunk">@@ -179,8 +177,7 @@</span> <span class="p_context"> __spitfire_data_access_exception_tl1:</span>
 	mov		%l5, %o2
 	call		spitfire_data_access_exception_tl1
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_data_access_exception_tl1,.-__spitfire_data_access_exception_tl1
 
 	.type		__spitfire_data_access_exception,#function
<span class="p_chunk">@@ -200,8 +197,7 @@</span> <span class="p_context"> __spitfire_data_access_exception:</span>
 	mov		%l5, %o2
 	call		spitfire_data_access_exception
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_data_access_exception,.-__spitfire_data_access_exception
 
 	.type		__spitfire_insn_access_exception_tl1,#function
<span class="p_chunk">@@ -220,8 +216,7 @@</span> <span class="p_context"> __spitfire_insn_access_exception_tl1:</span>
 	mov		%l5, %o2
 	call		spitfire_insn_access_exception_tl1
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_insn_access_exception_tl1,.-__spitfire_insn_access_exception_tl1
 
 	.type		__spitfire_insn_access_exception,#function
<span class="p_chunk">@@ -240,6 +235,5 @@</span> <span class="p_context"> __spitfire_insn_access_exception:</span>
 	mov		%l5, %o2
 	call		spitfire_insn_access_exception
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 	.size		__spitfire_insn_access_exception,.-__spitfire_insn_access_exception
<span class="p_header">diff --git a/arch/sparc/kernel/syscalls.S b/arch/sparc/kernel/syscalls.S</span>
<span class="p_header">index bb0008927598..c4a1b5c40e4e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/syscalls.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/syscalls.S</span>
<span class="p_chunk">@@ -158,7 +158,25 @@</span> <span class="p_context"> linux_syscall_trace32:</span>
 	 add	%sp, PTREGS_OFF, %o0
 	brnz,pn	%o0, 3f
 	 mov	-ENOSYS, %o0
<span class="p_add">+</span>
<span class="p_add">+	/* Syscall tracing can modify the registers.  */</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_G1], %g1</span>
<span class="p_add">+	sethi	%hi(sys_call_table32), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I0], %i0</span>
<span class="p_add">+	or	%l7, %lo(sys_call_table32), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I1], %i1</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I2], %i2</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I3], %i3</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I4], %i4</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I5], %i5</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	%g1, NR_syscalls</span>
<span class="p_add">+	bgeu,pn	%xcc, 3f</span>
<span class="p_add">+	 mov	-ENOSYS, %o0</span>
<span class="p_add">+</span>
<span class="p_add">+	sll	%g1, 2, %l4</span>
 	srl	%i0, 0, %o0
<span class="p_add">+	lduw	[%l7 + %l4], %l7</span>
 	srl	%i4, 0, %o4
 	srl	%i1, 0, %o1
 	srl	%i2, 0, %o2
<span class="p_chunk">@@ -170,7 +188,25 @@</span> <span class="p_context"> linux_syscall_trace:</span>
 	 add	%sp, PTREGS_OFF, %o0
 	brnz,pn	%o0, 3f
 	 mov	-ENOSYS, %o0
<span class="p_add">+</span>
<span class="p_add">+	/* Syscall tracing can modify the registers.  */</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_G1], %g1</span>
<span class="p_add">+	sethi	%hi(sys_call_table64), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I0], %i0</span>
<span class="p_add">+	or	%l7, %lo(sys_call_table64), %l7</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I1], %i1</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I2], %i2</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I3], %i3</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I4], %i4</span>
<span class="p_add">+	ldx	[%sp + PTREGS_OFF + PT_V9_I5], %i5</span>
<span class="p_add">+</span>
<span class="p_add">+	cmp	%g1, NR_syscalls</span>
<span class="p_add">+	bgeu,pn	%xcc, 3f</span>
<span class="p_add">+	 mov	-ENOSYS, %o0</span>
<span class="p_add">+</span>
<span class="p_add">+	sll	%g1, 2, %l4</span>
 	mov	%i0, %o0
<span class="p_add">+	lduw	[%l7 + %l4], %l7</span>
 	mov	%i1, %o1
 	mov	%i2, %o2
 	mov	%i3, %o3
<span class="p_header">diff --git a/arch/sparc/kernel/urtt_fill.S b/arch/sparc/kernel/urtt_fill.S</span>
new file mode 100644
<span class="p_header">index 000000000000..5604a2b051d4</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/arch/sparc/kernel/urtt_fill.S</span>
<span class="p_chunk">@@ -0,0 +1,98 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;asm/thread_info.h&gt;</span>
<span class="p_add">+#include &lt;asm/trap_block.h&gt;</span>
<span class="p_add">+#include &lt;asm/spitfire.h&gt;</span>
<span class="p_add">+#include &lt;asm/ptrace.h&gt;</span>
<span class="p_add">+#include &lt;asm/head.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+		.text</span>
<span class="p_add">+		.align	8</span>
<span class="p_add">+		.globl	user_rtt_fill_fixup_common</span>
<span class="p_add">+user_rtt_fill_fixup_common:</span>
<span class="p_add">+		rdpr	%cwp, %g1</span>
<span class="p_add">+		add	%g1, 1, %g1</span>
<span class="p_add">+		wrpr	%g1, 0x0, %cwp</span>
<span class="p_add">+</span>
<span class="p_add">+		rdpr	%wstate, %g2</span>
<span class="p_add">+		sll	%g2, 3, %g2</span>
<span class="p_add">+		wrpr	%g2, 0x0, %wstate</span>
<span class="p_add">+</span>
<span class="p_add">+		/* We know %canrestore and %otherwin are both zero.  */</span>
<span class="p_add">+</span>
<span class="p_add">+		sethi	%hi(sparc64_kern_pri_context), %g2</span>
<span class="p_add">+		ldx	[%g2 + %lo(sparc64_kern_pri_context)], %g2</span>
<span class="p_add">+		mov	PRIMARY_CONTEXT, %g1</span>
<span class="p_add">+</span>
<span class="p_add">+661:		stxa	%g2, [%g1] ASI_DMMU</span>
<span class="p_add">+		.section .sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_add">+		.word	661b</span>
<span class="p_add">+		stxa	%g2, [%g1] ASI_MMU</span>
<span class="p_add">+		.previous</span>
<span class="p_add">+</span>
<span class="p_add">+		sethi	%hi(KERNBASE), %g1</span>
<span class="p_add">+		flush	%g1</span>
<span class="p_add">+</span>
<span class="p_add">+		mov	%g4, %l4</span>
<span class="p_add">+		mov	%g5, %l5</span>
<span class="p_add">+		brnz,pn	%g3, 1f</span>
<span class="p_add">+		 mov	%g3, %l3</span>
<span class="p_add">+</span>
<span class="p_add">+		or	%g4, FAULT_CODE_WINFIXUP, %g4</span>
<span class="p_add">+		stb	%g4, [%g6 + TI_FAULT_CODE]</span>
<span class="p_add">+		stx	%g5, [%g6 + TI_FAULT_ADDR]</span>
<span class="p_add">+1:</span>
<span class="p_add">+		mov	%g6, %l1</span>
<span class="p_add">+		wrpr	%g0, 0x0, %tl</span>
<span class="p_add">+</span>
<span class="p_add">+661:		nop</span>
<span class="p_add">+		.section		.sun4v_1insn_patch, &quot;ax&quot;</span>
<span class="p_add">+		.word			661b</span>
<span class="p_add">+		SET_GL(0)</span>
<span class="p_add">+		.previous</span>
<span class="p_add">+</span>
<span class="p_add">+		wrpr	%g0, RTRAP_PSTATE, %pstate</span>
<span class="p_add">+</span>
<span class="p_add">+		mov	%l1, %g6</span>
<span class="p_add">+		ldx	[%g6 + TI_TASK], %g4</span>
<span class="p_add">+		LOAD_PER_CPU_BASE(%g5, %g6, %g1, %g2, %g3)</span>
<span class="p_add">+</span>
<span class="p_add">+		brnz,pn	%l3, 1f</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+</span>
<span class="p_add">+		call	do_sparc64_fault</span>
<span class="p_add">+		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+		ba,pt	%xcc, rtrap</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+</span>
<span class="p_add">+1:		cmp	%g3, 2</span>
<span class="p_add">+		bne,pn	%xcc, 2f</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+</span>
<span class="p_add">+		sethi	%hi(tlb_type), %g1</span>
<span class="p_add">+		lduw	[%g1 + %lo(tlb_type)], %g1</span>
<span class="p_add">+		cmp	%g1, 3</span>
<span class="p_add">+		bne,pt	%icc, 1f</span>
<span class="p_add">+		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+		mov	%l4, %o2</span>
<span class="p_add">+		call	sun4v_do_mna</span>
<span class="p_add">+		 mov	%l5, %o1</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_add">+1:		mov	%l4, %o1</span>
<span class="p_add">+		mov	%l5, %o2</span>
<span class="p_add">+		call	mem_address_unaligned</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_add">+</span>
<span class="p_add">+2:		sethi	%hi(tlb_type), %g1</span>
<span class="p_add">+		mov	%l4, %o1</span>
<span class="p_add">+		lduw	[%g1 + %lo(tlb_type)], %g1</span>
<span class="p_add">+		mov	%l5, %o2</span>
<span class="p_add">+		cmp	%g1, 3</span>
<span class="p_add">+		bne,pt	%icc, 1f</span>
<span class="p_add">+		 add	%sp, PTREGS_OFF, %o0</span>
<span class="p_add">+		call	sun4v_data_access_exception</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_add">+</span>
<span class="p_add">+1:		call	spitfire_data_access_exception</span>
<span class="p_add">+		 nop</span>
<span class="p_add">+		ba,a,pt	%xcc, rtrap</span>
<span class="p_header">diff --git a/arch/sparc/kernel/utrap.S b/arch/sparc/kernel/utrap.S</span>
<span class="p_header">index b7f0f3f3a909..c731e8023d3e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/utrap.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/utrap.S</span>
<span class="p_chunk">@@ -11,8 +11,7 @@</span> <span class="p_context"> utrap_trap:		/* %g3=handler,%g4=level */</span>
 	mov		%l4, %o1
         call		bad_trap
 	 add		%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt		%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt		%xcc, rtrap</span>
 
 invoke_utrap:
 	sllx		%g3, 3, %g3
<span class="p_header">diff --git a/arch/sparc/kernel/vmlinux.lds.S b/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_header">index f1a2f688b28a..4a41d412dd3d 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/vmlinux.lds.S</span>
<span class="p_chunk">@@ -33,6 +33,10 @@</span> <span class="p_context"> ENTRY(_start)</span>
 jiffies = jiffies_64;
 #endif
 
<span class="p_add">+#ifdef CONFIG_SPARC64</span>
<span class="p_add">+ASSERT((swapper_tsb == 0x0000000000408000), &quot;Error: sparc64 early assembler too large&quot;)</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 SECTIONS
 {
 #ifdef CONFIG_SPARC64
<span class="p_header">diff --git a/arch/sparc/kernel/winfixup.S b/arch/sparc/kernel/winfixup.S</span>
<span class="p_header">index 1e67ce958369..855019a8590e 100644</span>
<span class="p_header">--- a/arch/sparc/kernel/winfixup.S</span>
<span class="p_header">+++ b/arch/sparc/kernel/winfixup.S</span>
<span class="p_chunk">@@ -32,8 +32,7 @@</span> <span class="p_context"> fill_fixup:</span>
 	 rd	%pc, %g7
 	call	do_sparc64_fault
 	 add	%sp, PTREGS_OFF, %o0
<span class="p_del">-	ba,pt	%xcc, rtrap</span>
<span class="p_del">-	 nop</span>
<span class="p_add">+	ba,a,pt	%xcc, rtrap</span>
 
 	/* Be very careful about usage of the trap globals here.
 	 * You cannot touch %g5 as that has the fault information.
<span class="p_header">diff --git a/arch/sparc/mm/hugetlbpage.c b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">index 131eaf4ad7f5..364d093f46c6 100644</span>
<span class="p_header">--- a/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/sparc/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -176,17 +176,31 @@</span> <span class="p_context"> void set_huge_pte_at(struct mm_struct *mm, unsigned long addr,</span>
 		     pte_t *ptep, pte_t entry)
 {
 	int i;
<span class="p_add">+	pte_t orig[2];</span>
<span class="p_add">+	unsigned long nptes;</span>
 
 	if (!pte_present(*ptep) &amp;&amp; pte_present(entry))
 		mm-&gt;context.huge_pte_count++;
 
 	addr &amp;= HPAGE_MASK;
<span class="p_del">-	for (i = 0; i &lt; (1 &lt;&lt; HUGETLB_PAGE_ORDER); i++) {</span>
<span class="p_del">-		set_pte_at(mm, addr, ptep, entry);</span>
<span class="p_add">+</span>
<span class="p_add">+	nptes = 1 &lt;&lt; HUGETLB_PAGE_ORDER;</span>
<span class="p_add">+	orig[0] = *ptep;</span>
<span class="p_add">+	orig[1] = *(ptep + nptes / 2);</span>
<span class="p_add">+	for (i = 0; i &lt; nptes; i++) {</span>
<span class="p_add">+		*ptep = entry;</span>
 		ptep++;
 		addr += PAGE_SIZE;
 		pte_val(entry) += PAGE_SIZE;
 	}
<span class="p_add">+</span>
<span class="p_add">+	/* Issue TLB flush at REAL_HPAGE_SIZE boundaries */</span>
<span class="p_add">+	addr -= REAL_HPAGE_SIZE;</span>
<span class="p_add">+	ptep -= nptes / 2;</span>
<span class="p_add">+	maybe_tlb_batch_add(mm, addr, ptep, orig[1], 0);</span>
<span class="p_add">+	addr -= REAL_HPAGE_SIZE;</span>
<span class="p_add">+	ptep -= nptes / 2;</span>
<span class="p_add">+	maybe_tlb_batch_add(mm, addr, ptep, orig[0], 0);</span>
 }
 
 pte_t huge_ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,
<span class="p_chunk">@@ -194,19 +208,28 @@</span> <span class="p_context"> pte_t huge_ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,</span>
 {
 	pte_t entry;
 	int i;
<span class="p_add">+	unsigned long nptes;</span>
 
 	entry = *ptep;
 	if (pte_present(entry))
 		mm-&gt;context.huge_pte_count--;
 
 	addr &amp;= HPAGE_MASK;
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; (1 &lt;&lt; HUGETLB_PAGE_ORDER); i++) {</span>
<span class="p_del">-		pte_clear(mm, addr, ptep);</span>
<span class="p_add">+	nptes = 1 &lt;&lt; HUGETLB_PAGE_ORDER;</span>
<span class="p_add">+	for (i = 0; i &lt; nptes; i++) {</span>
<span class="p_add">+		*ptep = __pte(0UL);</span>
 		addr += PAGE_SIZE;
 		ptep++;
 	}
 
<span class="p_add">+	/* Issue TLB flush at REAL_HPAGE_SIZE boundaries */</span>
<span class="p_add">+	addr -= REAL_HPAGE_SIZE;</span>
<span class="p_add">+	ptep -= nptes / 2;</span>
<span class="p_add">+	maybe_tlb_batch_add(mm, addr, ptep, entry, 0);</span>
<span class="p_add">+	addr -= REAL_HPAGE_SIZE;</span>
<span class="p_add">+	ptep -= nptes / 2;</span>
<span class="p_add">+	maybe_tlb_batch_add(mm, addr, ptep, entry, 0);</span>
<span class="p_add">+</span>
 	return entry;
 }
 
<span class="p_header">diff --git a/arch/sparc/mm/init_64.c b/arch/sparc/mm/init_64.c</span>
<span class="p_header">index 3025bd57f7ab..3c4b8975fa76 100644</span>
<span class="p_header">--- a/arch/sparc/mm/init_64.c</span>
<span class="p_header">+++ b/arch/sparc/mm/init_64.c</span>
<span class="p_chunk">@@ -324,18 +324,6 @@</span> <span class="p_context"> static void __update_mmu_tsb_insert(struct mm_struct *mm, unsigned long tsb_inde</span>
 	tsb_insert(tsb, tag, tte);
 }
 
<span class="p_del">-#if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)</span>
<span class="p_del">-static inline bool is_hugetlb_pte(pte_t pte)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if ((tlb_type == hypervisor &amp;&amp;</span>
<span class="p_del">-	     (pte_val(pte) &amp; _PAGE_SZALL_4V) == _PAGE_SZHUGE_4V) ||</span>
<span class="p_del">-	    (tlb_type != hypervisor &amp;&amp;</span>
<span class="p_del">-	     (pte_val(pte) &amp; _PAGE_SZALL_4U) == _PAGE_SZHUGE_4U))</span>
<span class="p_del">-		return true;</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 void update_mmu_cache(struct vm_area_struct *vma, unsigned long address, pte_t *ptep)
 {
 	struct mm_struct *mm;
<span class="p_chunk">@@ -1267,13 +1255,6 @@</span> <span class="p_context"> static int __init numa_parse_mdesc(void)</span>
 	int i, j, err, count;
 	u64 node;
 
<span class="p_del">-	/* Some sane defaults for numa latency values */</span>
<span class="p_del">-	for (i = 0; i &lt; MAX_NUMNODES; i++) {</span>
<span class="p_del">-		for (j = 0; j &lt; MAX_NUMNODES; j++)</span>
<span class="p_del">-			numa_latency[i][j] = (i == j) ?</span>
<span class="p_del">-				LOCAL_DISTANCE : REMOTE_DISTANCE;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	node = mdesc_node_by_name(md, MDESC_NODE_NULL, &quot;latency-groups&quot;);
 	if (node == MDESC_NODE_NULL) {
 		mdesc_release(md);
<span class="p_chunk">@@ -1369,10 +1350,18 @@</span> <span class="p_context"> static int __init numa_parse_sun4u(void)</span>
 
 static int __init bootmem_init_numa(void)
 {
<span class="p_add">+	int i, j;</span>
 	int err = -1;
 
 	numadbg(&quot;bootmem_init_numa()\n&quot;);
 
<span class="p_add">+	/* Some sane defaults for numa latency values */</span>
<span class="p_add">+	for (i = 0; i &lt; MAX_NUMNODES; i++) {</span>
<span class="p_add">+		for (j = 0; j &lt; MAX_NUMNODES; j++)</span>
<span class="p_add">+			numa_latency[i][j] = (i == j) ?</span>
<span class="p_add">+				LOCAL_DISTANCE : REMOTE_DISTANCE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (numa_enabled) {
 		if (tlb_type == hypervisor)
 			err = numa_parse_mdesc();
<span class="p_chunk">@@ -2832,9 +2821,10 @@</span> <span class="p_context"> void hugetlb_setup(struct pt_regs *regs)</span>
 	 * the Data-TLB for huge pages.
 	 */
 	if (tlb_type == cheetah_plus) {
<span class="p_add">+		bool need_context_reload = false;</span>
 		unsigned long ctx;
 
<span class="p_del">-		spin_lock(&amp;ctx_alloc_lock);</span>
<span class="p_add">+		spin_lock_irq(&amp;ctx_alloc_lock);</span>
 		ctx = mm-&gt;context.sparc64_ctx_val;
 		ctx &amp;= ~CTX_PGSZ_MASK;
 		ctx |= CTX_PGSZ_BASE &lt;&lt; CTX_PGSZ0_SHIFT;
<span class="p_chunk">@@ -2853,9 +2843,12 @@</span> <span class="p_context"> void hugetlb_setup(struct pt_regs *regs)</span>
 			 * also executing in this address space.
 			 */
 			mm-&gt;context.sparc64_ctx_val = ctx;
<span class="p_del">-			on_each_cpu(context_reload, mm, 0);</span>
<span class="p_add">+			need_context_reload = true;</span>
 		}
<span class="p_del">-		spin_unlock(&amp;ctx_alloc_lock);</span>
<span class="p_add">+		spin_unlock_irq(&amp;ctx_alloc_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (need_context_reload)</span>
<span class="p_add">+			on_each_cpu(context_reload, mm, 0);</span>
 	}
 }
 #endif
<span class="p_header">diff --git a/arch/sparc/mm/tlb.c b/arch/sparc/mm/tlb.c</span>
<span class="p_header">index 9df2190c097e..f81cd9736700 100644</span>
<span class="p_header">--- a/arch/sparc/mm/tlb.c</span>
<span class="p_header">+++ b/arch/sparc/mm/tlb.c</span>
<span class="p_chunk">@@ -67,7 +67,7 @@</span> <span class="p_context"> void arch_leave_lazy_mmu_mode(void)</span>
 }
 
 static void tlb_batch_add_one(struct mm_struct *mm, unsigned long vaddr,
<span class="p_del">-			      bool exec)</span>
<span class="p_add">+			      bool exec, bool huge)</span>
 {
 	struct tlb_batch *tb = &amp;get_cpu_var(tlb_batch);
 	unsigned long nr;
<span class="p_chunk">@@ -84,13 +84,21 @@</span> <span class="p_context"> static void tlb_batch_add_one(struct mm_struct *mm, unsigned long vaddr,</span>
 	}
 
 	if (!tb-&gt;active) {
<span class="p_del">-		flush_tsb_user_page(mm, vaddr);</span>
<span class="p_add">+		flush_tsb_user_page(mm, vaddr, huge);</span>
 		global_flush_tlb_page(mm, vaddr);
 		goto out;
 	}
 
<span class="p_del">-	if (nr == 0)</span>
<span class="p_add">+	if (nr == 0) {</span>
 		tb-&gt;mm = mm;
<span class="p_add">+		tb-&gt;huge = huge;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (tb-&gt;huge != huge) {</span>
<span class="p_add">+		flush_tlb_pending();</span>
<span class="p_add">+		tb-&gt;huge = huge;</span>
<span class="p_add">+		nr = 0;</span>
<span class="p_add">+	}</span>
 
 	tb-&gt;vaddrs[nr] = vaddr;
 	tb-&gt;tlb_nr = ++nr;
<span class="p_chunk">@@ -104,6 +112,8 @@</span> <span class="p_context"> out:</span>
 void tlb_batch_add(struct mm_struct *mm, unsigned long vaddr,
 		   pte_t *ptep, pte_t orig, int fullmm)
 {
<span class="p_add">+	bool huge = is_hugetlb_pte(orig);</span>
<span class="p_add">+</span>
 	if (tlb_type != hypervisor &amp;&amp;
 	    pte_dirty(orig)) {
 		unsigned long paddr, pfn = pte_pfn(orig);
<span class="p_chunk">@@ -129,7 +139,7 @@</span> <span class="p_context"> void tlb_batch_add(struct mm_struct *mm, unsigned long vaddr,</span>
 
 no_cache_flush:
 	if (!fullmm)
<span class="p_del">-		tlb_batch_add_one(mm, vaddr, pte_exec(orig));</span>
<span class="p_add">+		tlb_batch_add_one(mm, vaddr, pte_exec(orig), huge);</span>
 }
 
 #ifdef CONFIG_TRANSPARENT_HUGEPAGE
<span class="p_chunk">@@ -145,7 +155,7 @@</span> <span class="p_context"> static void tlb_batch_pmd_scan(struct mm_struct *mm, unsigned long vaddr,</span>
 		if (pte_val(*pte) &amp; _PAGE_VALID) {
 			bool exec = pte_exec(*pte);
 
<span class="p_del">-			tlb_batch_add_one(mm, vaddr, exec);</span>
<span class="p_add">+			tlb_batch_add_one(mm, vaddr, exec, false);</span>
 		}
 		pte++;
 		vaddr += PAGE_SIZE;
<span class="p_chunk">@@ -185,8 +195,9 @@</span> <span class="p_context"> void set_pmd_at(struct mm_struct *mm, unsigned long addr,</span>
 			pte_t orig_pte = __pte(pmd_val(orig));
 			bool exec = pte_exec(orig_pte);
 
<span class="p_del">-			tlb_batch_add_one(mm, addr, exec);</span>
<span class="p_del">-			tlb_batch_add_one(mm, addr + REAL_HPAGE_SIZE, exec);</span>
<span class="p_add">+			tlb_batch_add_one(mm, addr, exec, true);</span>
<span class="p_add">+			tlb_batch_add_one(mm, addr + REAL_HPAGE_SIZE, exec,</span>
<span class="p_add">+					true);</span>
 		} else {
 			tlb_batch_pmd_scan(mm, addr, orig);
 		}
<span class="p_header">diff --git a/arch/sparc/mm/tsb.c b/arch/sparc/mm/tsb.c</span>
<span class="p_header">index a06576683c38..a0604a493a36 100644</span>
<span class="p_header">--- a/arch/sparc/mm/tsb.c</span>
<span class="p_header">+++ b/arch/sparc/mm/tsb.c</span>
<span class="p_chunk">@@ -76,14 +76,15 @@</span> <span class="p_context"> void flush_tsb_user(struct tlb_batch *tb)</span>
 
 	spin_lock_irqsave(&amp;mm-&gt;context.lock, flags);
 
<span class="p_del">-	base = (unsigned long) mm-&gt;context.tsb_block[MM_TSB_BASE].tsb;</span>
<span class="p_del">-	nentries = mm-&gt;context.tsb_block[MM_TSB_BASE].tsb_nentries;</span>
<span class="p_del">-	if (tlb_type == cheetah_plus || tlb_type == hypervisor)</span>
<span class="p_del">-		base = __pa(base);</span>
<span class="p_del">-	__flush_tsb_one(tb, PAGE_SHIFT, base, nentries);</span>
<span class="p_del">-</span>
<span class="p_add">+	if (!tb-&gt;huge) {</span>
<span class="p_add">+		base = (unsigned long) mm-&gt;context.tsb_block[MM_TSB_BASE].tsb;</span>
<span class="p_add">+		nentries = mm-&gt;context.tsb_block[MM_TSB_BASE].tsb_nentries;</span>
<span class="p_add">+		if (tlb_type == cheetah_plus || tlb_type == hypervisor)</span>
<span class="p_add">+			base = __pa(base);</span>
<span class="p_add">+		__flush_tsb_one(tb, PAGE_SHIFT, base, nentries);</span>
<span class="p_add">+	}</span>
 #if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)
<span class="p_del">-	if (mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb) {</span>
<span class="p_add">+	if (tb-&gt;huge &amp;&amp; mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb) {</span>
 		base = (unsigned long) mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb;
 		nentries = mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb_nentries;
 		if (tlb_type == cheetah_plus || tlb_type == hypervisor)
<span class="p_chunk">@@ -94,20 +95,21 @@</span> <span class="p_context"> void flush_tsb_user(struct tlb_batch *tb)</span>
 	spin_unlock_irqrestore(&amp;mm-&gt;context.lock, flags);
 }
 
<span class="p_del">-void flush_tsb_user_page(struct mm_struct *mm, unsigned long vaddr)</span>
<span class="p_add">+void flush_tsb_user_page(struct mm_struct *mm, unsigned long vaddr, bool huge)</span>
 {
 	unsigned long nentries, base, flags;
 
 	spin_lock_irqsave(&amp;mm-&gt;context.lock, flags);
 
<span class="p_del">-	base = (unsigned long) mm-&gt;context.tsb_block[MM_TSB_BASE].tsb;</span>
<span class="p_del">-	nentries = mm-&gt;context.tsb_block[MM_TSB_BASE].tsb_nentries;</span>
<span class="p_del">-	if (tlb_type == cheetah_plus || tlb_type == hypervisor)</span>
<span class="p_del">-		base = __pa(base);</span>
<span class="p_del">-	__flush_tsb_one_entry(base, vaddr, PAGE_SHIFT, nentries);</span>
<span class="p_del">-</span>
<span class="p_add">+	if (!huge) {</span>
<span class="p_add">+		base = (unsigned long) mm-&gt;context.tsb_block[MM_TSB_BASE].tsb;</span>
<span class="p_add">+		nentries = mm-&gt;context.tsb_block[MM_TSB_BASE].tsb_nentries;</span>
<span class="p_add">+		if (tlb_type == cheetah_plus || tlb_type == hypervisor)</span>
<span class="p_add">+			base = __pa(base);</span>
<span class="p_add">+		__flush_tsb_one_entry(base, vaddr, PAGE_SHIFT, nentries);</span>
<span class="p_add">+	}</span>
 #if defined(CONFIG_HUGETLB_PAGE) || defined(CONFIG_TRANSPARENT_HUGEPAGE)
<span class="p_del">-	if (mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb) {</span>
<span class="p_add">+	if (huge &amp;&amp; mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb) {</span>
 		base = (unsigned long) mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb;
 		nentries = mm-&gt;context.tsb_block[MM_TSB_HUGE].tsb_nentries;
 		if (tlb_type == cheetah_plus || tlb_type == hypervisor)
<span class="p_header">diff --git a/arch/x86/kernel/traps.c b/arch/x86/kernel/traps.c</span>
<span class="p_header">index ade185a46b1d..679302c312f8 100644</span>
<span class="p_header">--- a/arch/x86/kernel/traps.c</span>
<span class="p_header">+++ b/arch/x86/kernel/traps.c</span>
<span class="p_chunk">@@ -109,6 +109,12 @@</span> <span class="p_context"> static inline void preempt_conditional_cli(struct pt_regs *regs)</span>
 	preempt_count_dec();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * In IST context, we explicitly disable preemption.  This serves two</span>
<span class="p_add">+ * purposes: it makes it much less likely that we would accidentally</span>
<span class="p_add">+ * schedule in IST context and it will force a warning if we somehow</span>
<span class="p_add">+ * manage to schedule by accident.</span>
<span class="p_add">+ */</span>
 void ist_enter(struct pt_regs *regs)
 {
 	if (user_mode(regs)) {
<span class="p_chunk">@@ -123,13 +129,7 @@</span> <span class="p_context"> void ist_enter(struct pt_regs *regs)</span>
 		rcu_nmi_enter();
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We are atomic because we&#39;re on the IST stack; or we&#39;re on</span>
<span class="p_del">-	 * x86_32, in which case we still shouldn&#39;t schedule; or we&#39;re</span>
<span class="p_del">-	 * on x86_64 and entered from user mode, in which case we&#39;re</span>
<span class="p_del">-	 * still atomic unless ist_begin_non_atomic is called.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	preempt_count_add(HARDIRQ_OFFSET);</span>
<span class="p_add">+	preempt_disable();</span>
 
 	/* This code is a bit fragile.  Test it. */
 	RCU_LOCKDEP_WARN(!rcu_is_watching(), &quot;ist_enter didn&#39;t work&quot;);
<span class="p_chunk">@@ -137,7 +137,7 @@</span> <span class="p_context"> void ist_enter(struct pt_regs *regs)</span>
 
 void ist_exit(struct pt_regs *regs)
 {
<span class="p_del">-	preempt_count_sub(HARDIRQ_OFFSET);</span>
<span class="p_add">+	preempt_enable_no_resched();</span>
 
 	if (!user_mode(regs))
 		rcu_nmi_exit();
<span class="p_chunk">@@ -168,7 +168,7 @@</span> <span class="p_context"> void ist_begin_non_atomic(struct pt_regs *regs)</span>
 	BUG_ON((unsigned long)(current_top_of_stack() -
 			       current_stack_pointer()) &gt;= THREAD_SIZE);
 
<span class="p_del">-	preempt_count_sub(HARDIRQ_OFFSET);</span>
<span class="p_add">+	preempt_enable_no_resched();</span>
 }
 
 /**
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> void ist_begin_non_atomic(struct pt_regs *regs)</span>
  */
 void ist_end_non_atomic(void)
 {
<span class="p_del">-	preempt_count_add(HARDIRQ_OFFSET);</span>
<span class="p_add">+	preempt_disable();</span>
 }
 
 static nokprobe_inline int
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 605cea75eb0d..be222666b1c2 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -3014,6 +3014,11 @@</span> <span class="p_context"> static int kvm_vcpu_ioctl_x86_set_debugregs(struct kvm_vcpu *vcpu,</span>
 	if (dbgregs-&gt;flags)
 		return -EINVAL;
 
<span class="p_add">+	if (dbgregs-&gt;dr6 &amp; ~0xffffffffull)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	if (dbgregs-&gt;dr7 &amp; ~0xffffffffull)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	memcpy(vcpu-&gt;arch.db, dbgregs-&gt;db, sizeof(vcpu-&gt;arch.db));
 	kvm_update_dr0123(vcpu);
 	vcpu-&gt;arch.dr6 = dbgregs-&gt;dr6;
<span class="p_header">diff --git a/crypto/asymmetric_keys/Kconfig b/crypto/asymmetric_keys/Kconfig</span>
<span class="p_header">index 4870f28403f5..05bfe568cd30 100644</span>
<span class="p_header">--- a/crypto/asymmetric_keys/Kconfig</span>
<span class="p_header">+++ b/crypto/asymmetric_keys/Kconfig</span>
<span class="p_chunk">@@ -14,6 +14,7 @@</span> <span class="p_context"> config ASYMMETRIC_PUBLIC_KEY_SUBTYPE</span>
 	select MPILIB
 	select PUBLIC_KEY_ALGO_RSA
 	select CRYPTO_HASH_INFO
<span class="p_add">+	select CRYPTO_AKCIPHER</span>
 	help
 	  This option provides support for asymmetric public key type handling.
 	  If signature generation and/or verification are to be used,
<span class="p_header">diff --git a/drivers/crypto/ccp/ccp-crypto-aes-xts.c b/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_header">index 52c7395cb8d8..0d0d4529ee36 100644</span>
<span class="p_header">--- a/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_header">+++ b/drivers/crypto/ccp/ccp-crypto-aes-xts.c</span>
<span class="p_chunk">@@ -122,6 +122,7 @@</span> <span class="p_context"> static int ccp_aes_xts_crypt(struct ablkcipher_request *req,</span>
 	struct ccp_ctx *ctx = crypto_tfm_ctx(req-&gt;base.tfm);
 	struct ccp_aes_req_ctx *rctx = ablkcipher_request_ctx(req);
 	unsigned int unit;
<span class="p_add">+	u32 unit_size;</span>
 	int ret;
 
 	if (!ctx-&gt;u.aes.key_len)
<span class="p_chunk">@@ -133,11 +134,17 @@</span> <span class="p_context"> static int ccp_aes_xts_crypt(struct ablkcipher_request *req,</span>
 	if (!req-&gt;info)
 		return -EINVAL;
 
<span class="p_del">-	for (unit = 0; unit &lt; ARRAY_SIZE(unit_size_map); unit++)</span>
<span class="p_del">-		if (!(req-&gt;nbytes &amp; (unit_size_map[unit].size - 1)))</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	unit_size = CCP_XTS_AES_UNIT_SIZE__LAST;</span>
<span class="p_add">+	if (req-&gt;nbytes &lt;= unit_size_map[0].size) {</span>
<span class="p_add">+		for (unit = 0; unit &lt; ARRAY_SIZE(unit_size_map); unit++) {</span>
<span class="p_add">+			if (!(req-&gt;nbytes &amp; (unit_size_map[unit].size - 1))) {</span>
<span class="p_add">+				unit_size = unit_size_map[unit].value;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if ((unit_size_map[unit].value == CCP_XTS_AES_UNIT_SIZE__LAST) ||</span>
<span class="p_add">+	if ((unit_size == CCP_XTS_AES_UNIT_SIZE__LAST) ||</span>
 	    (ctx-&gt;u.aes.key_len != AES_KEYSIZE_128)) {
 		/* Use the fallback to process the request for any
 		 * unsupported unit sizes or key sizes
<span class="p_chunk">@@ -158,7 +165,7 @@</span> <span class="p_context"> static int ccp_aes_xts_crypt(struct ablkcipher_request *req,</span>
 	rctx-&gt;cmd.engine = CCP_ENGINE_XTS_AES_128;
 	rctx-&gt;cmd.u.xts.action = (encrypt) ? CCP_AES_ACTION_ENCRYPT
 					   : CCP_AES_ACTION_DECRYPT;
<span class="p_del">-	rctx-&gt;cmd.u.xts.unit_size = unit_size_map[unit].value;</span>
<span class="p_add">+	rctx-&gt;cmd.u.xts.unit_size = unit_size;</span>
 	rctx-&gt;cmd.u.xts.key = &amp;ctx-&gt;u.aes.key_sg;
 	rctx-&gt;cmd.u.xts.key_len = ctx-&gt;u.aes.key_len;
 	rctx-&gt;cmd.u.xts.iv = &amp;rctx-&gt;iv_sg;
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/adf_common_drv.h b/drivers/crypto/qat/qat_common/adf_common_drv.h</span>
<span class="p_header">index b9178d0a3093..aa1dbeaa9b49 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/adf_common_drv.h</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/adf_common_drv.h</span>
<span class="p_chunk">@@ -145,8 +145,6 @@</span> <span class="p_context"> int adf_enable_aer(struct adf_accel_dev *accel_dev, struct pci_driver *adf);</span>
 void adf_disable_aer(struct adf_accel_dev *accel_dev);
 int adf_init_aer(void);
 void adf_exit_aer(void);
<span class="p_del">-int adf_init_pf_wq(void);</span>
<span class="p_del">-void adf_exit_pf_wq(void);</span>
 int adf_init_admin_comms(struct adf_accel_dev *accel_dev);
 void adf_exit_admin_comms(struct adf_accel_dev *accel_dev);
 int adf_send_admin_init(struct adf_accel_dev *accel_dev);
<span class="p_chunk">@@ -229,6 +227,8 @@</span> <span class="p_context"> void adf_disable_vf2pf_interrupts(struct adf_accel_dev *accel_dev,</span>
 				  uint32_t vf_mask);
 void adf_enable_vf2pf_interrupts(struct adf_accel_dev *accel_dev,
 				 uint32_t vf_mask);
<span class="p_add">+int adf_init_pf_wq(void);</span>
<span class="p_add">+void adf_exit_pf_wq(void);</span>
 #else
 static inline int adf_sriov_configure(struct pci_dev *pdev, int numvfs)
 {
<span class="p_chunk">@@ -238,5 +238,14 @@</span> <span class="p_context"> static inline int adf_sriov_configure(struct pci_dev *pdev, int numvfs)</span>
 static inline void adf_disable_sriov(struct adf_accel_dev *accel_dev)
 {
 }
<span class="p_add">+</span>
<span class="p_add">+static inline int adf_init_pf_wq(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void adf_exit_pf_wq(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 #endif
 #endif
<span class="p_header">diff --git a/drivers/gpio/gpio-bcm-kona.c b/drivers/gpio/gpio-bcm-kona.c</span>
<span class="p_header">index 33a1f9779b86..4ea71d505bce 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-bcm-kona.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-bcm-kona.c</span>
<span class="p_chunk">@@ -551,11 +551,11 @@</span> <span class="p_context"> static void bcm_kona_gpio_reset(struct bcm_kona_gpio *kona_gpio)</span>
 	/* disable interrupts and clear status */
 	for (i = 0; i &lt; kona_gpio-&gt;num_bank; i++) {
 		/* Unlock the entire bank first */
<span class="p_del">-		bcm_kona_gpio_write_lock_regs(kona_gpio, i, UNLOCK_CODE);</span>
<span class="p_add">+		bcm_kona_gpio_write_lock_regs(reg_base, i, UNLOCK_CODE);</span>
 		writel(0xffffffff, reg_base + GPIO_INT_MASK(i));
 		writel(0xffffffff, reg_base + GPIO_INT_STATUS(i));
 		/* Now re-lock the bank */
<span class="p_del">-		bcm_kona_gpio_write_lock_regs(kona_gpio, i, LOCK_CODE);</span>
<span class="p_add">+		bcm_kona_gpio_write_lock_regs(reg_base, i, LOCK_CODE);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/drm_crtc.c b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">index 24c5434abd1c..a02238c85e18 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/drm_crtc.c</span>
<span class="p_chunk">@@ -3316,6 +3316,24 @@</span> <span class="p_context"> int drm_mode_addfb2(struct drm_device *dev,</span>
 	return 0;
 }
 
<span class="p_add">+struct drm_mode_rmfb_work {</span>
<span class="p_add">+	struct work_struct work;</span>
<span class="p_add">+	struct list_head fbs;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static void drm_mode_rmfb_work_fn(struct work_struct *w)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct drm_mode_rmfb_work *arg = container_of(w, typeof(*arg), work);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (!list_empty(&amp;arg-&gt;fbs)) {</span>
<span class="p_add">+		struct drm_framebuffer *fb =</span>
<span class="p_add">+			list_first_entry(&amp;arg-&gt;fbs, typeof(*fb), filp_head);</span>
<span class="p_add">+</span>
<span class="p_add">+		list_del_init(&amp;fb-&gt;filp_head);</span>
<span class="p_add">+		drm_framebuffer_remove(fb);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * drm_mode_rmfb - remove an FB from the configuration
  * @dev: drm device for the ioctl
<span class="p_chunk">@@ -3356,7 +3374,25 @@</span> <span class="p_context"> int drm_mode_rmfb(struct drm_device *dev,</span>
 	mutex_unlock(&amp;dev-&gt;mode_config.fb_lock);
 	mutex_unlock(&amp;file_priv-&gt;fbs_lock);
 
<span class="p_del">-	drm_framebuffer_unreference(fb);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * we now own the reference that was stored in the fbs list</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * drm_framebuffer_remove may fail with -EINTR on pending signals,</span>
<span class="p_add">+	 * so run this in a separate stack as there&#39;s no way to correctly</span>
<span class="p_add">+	 * handle this after the fb is already removed from the lookup table.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (atomic_read(&amp;fb-&gt;refcount.refcount) &gt; 1) {</span>
<span class="p_add">+		struct drm_mode_rmfb_work arg;</span>
<span class="p_add">+</span>
<span class="p_add">+		INIT_WORK_ONSTACK(&amp;arg.work, drm_mode_rmfb_work_fn);</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;arg.fbs);</span>
<span class="p_add">+		list_add_tail(&amp;fb-&gt;filp_head, &amp;arg.fbs);</span>
<span class="p_add">+</span>
<span class="p_add">+		schedule_work(&amp;arg.work);</span>
<span class="p_add">+		flush_work(&amp;arg.work);</span>
<span class="p_add">+		destroy_work_on_stack(&amp;arg.work);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		drm_framebuffer_unreference(fb);</span>
 
 	return 0;
 
<span class="p_chunk">@@ -3509,7 +3545,6 @@</span> <span class="p_context"> out_err1:</span>
 	return ret;
 }
 
<span class="p_del">-</span>
 /**
  * drm_fb_release - remove and free the FBs on this file
  * @priv: drm file for the ioctl
<span class="p_chunk">@@ -3524,6 +3559,9 @@</span> <span class="p_context"> out_err1:</span>
 void drm_fb_release(struct drm_file *priv)
 {
 	struct drm_framebuffer *fb, *tfb;
<span class="p_add">+	struct drm_mode_rmfb_work arg;</span>
<span class="p_add">+</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;arg.fbs);</span>
 
 	/*
 	 * When the file gets released that means no one else can access the fb
<span class="p_chunk">@@ -3536,10 +3574,22 @@</span> <span class="p_context"> void drm_fb_release(struct drm_file *priv)</span>
 	 * at it any more.
 	 */
 	list_for_each_entry_safe(fb, tfb, &amp;priv-&gt;fbs, filp_head) {
<span class="p_del">-		list_del_init(&amp;fb-&gt;filp_head);</span>
<span class="p_add">+		if (atomic_read(&amp;fb-&gt;refcount.refcount) &gt; 1) {</span>
<span class="p_add">+			list_move_tail(&amp;fb-&gt;filp_head, &amp;arg.fbs);</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			list_del_init(&amp;fb-&gt;filp_head);</span>
 
<span class="p_del">-		/* This drops the fpriv-&gt;fbs reference. */</span>
<span class="p_del">-		drm_framebuffer_unreference(fb);</span>
<span class="p_add">+			/* This drops the fpriv-&gt;fbs reference. */</span>
<span class="p_add">+			drm_framebuffer_unreference(fb);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!list_empty(&amp;arg.fbs)) {</span>
<span class="p_add">+		INIT_WORK_ONSTACK(&amp;arg.work, drm_mode_rmfb_work_fn);</span>
<span class="p_add">+</span>
<span class="p_add">+		schedule_work(&amp;arg.work);</span>
<span class="p_add">+		flush_work(&amp;arg.work);</span>
<span class="p_add">+		destroy_work_on_stack(&amp;arg.work);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/rocker/rocker.c b/drivers/net/ethernet/rocker/rocker.c</span>
<span class="p_header">index 2b34622a4bfe..3920c3eb6006 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/rocker/rocker.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/rocker/rocker.c</span>
<span class="p_chunk">@@ -4475,7 +4475,7 @@</span> <span class="p_context"> static int rocker_port_obj_add(struct net_device *dev,</span>
 		fib4 = SWITCHDEV_OBJ_IPV4_FIB(obj);
 		err = rocker_port_fib_ipv4(rocker_port, trans,
 					   htonl(fib4-&gt;dst), fib4-&gt;dst_len,
<span class="p_del">-					   &amp;fib4-&gt;fi, fib4-&gt;tb_id, 0);</span>
<span class="p_add">+					   fib4-&gt;fi, fib4-&gt;tb_id, 0);</span>
 		break;
 	case SWITCHDEV_OBJ_ID_PORT_FDB:
 		err = rocker_port_fdb_add(rocker_port, trans,
<span class="p_chunk">@@ -4547,7 +4547,7 @@</span> <span class="p_context"> static int rocker_port_obj_del(struct net_device *dev,</span>
 		fib4 = SWITCHDEV_OBJ_IPV4_FIB(obj);
 		err = rocker_port_fib_ipv4(rocker_port, NULL,
 					   htonl(fib4-&gt;dst), fib4-&gt;dst_len,
<span class="p_del">-					   &amp;fib4-&gt;fi, fib4-&gt;tb_id,</span>
<span class="p_add">+					   fib4-&gt;fi, fib4-&gt;tb_id,</span>
 					   ROCKER_OP_FLAG_REMOVE);
 		break;
 	case SWITCHDEV_OBJ_ID_PORT_FDB:
<span class="p_header">diff --git a/drivers/net/ethernet/sfc/ef10.c b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">index e6a084a6be12..cbe9a330117a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/sfc/ef10.c</span>
<span class="p_chunk">@@ -619,6 +619,17 @@</span> <span class="p_context"> fail:</span>
 	return rc;
 }
 
<span class="p_add">+static void efx_ef10_forget_old_piobufs(struct efx_nic *efx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct efx_channel *channel;</span>
<span class="p_add">+	struct efx_tx_queue *tx_queue;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* All our existing PIO buffers went away */</span>
<span class="p_add">+	efx_for_each_channel(channel, efx)</span>
<span class="p_add">+		efx_for_each_channel_tx_queue(tx_queue, channel)</span>
<span class="p_add">+			tx_queue-&gt;piobuf = NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #else /* !EFX_USE_PIO */
 
 static int efx_ef10_alloc_piobufs(struct efx_nic *efx, unsigned int n)
<span class="p_chunk">@@ -635,6 +646,10 @@</span> <span class="p_context"> static void efx_ef10_free_piobufs(struct efx_nic *efx)</span>
 {
 }
 
<span class="p_add">+static void efx_ef10_forget_old_piobufs(struct efx_nic *efx)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif /* EFX_USE_PIO */
 
 static void efx_ef10_remove(struct efx_nic *efx)
<span class="p_chunk">@@ -1018,6 +1033,7 @@</span> <span class="p_context"> static void efx_ef10_reset_mc_allocations(struct efx_nic *efx)</span>
 	nic_data-&gt;must_realloc_vis = true;
 	nic_data-&gt;must_restore_filters = true;
 	nic_data-&gt;must_restore_piobufs = true;
<span class="p_add">+	efx_ef10_forget_old_piobufs(efx);</span>
 	nic_data-&gt;rx_rss_context = EFX_EF10_RSS_CONTEXT_INVALID;
 
 	/* Driver-created vswitches and vports must be re-created */
<span class="p_header">diff --git a/drivers/net/geneve.c b/drivers/net/geneve.c</span>
<span class="p_header">index 58efdec12f30..69e31e2a68fc 100644</span>
<span class="p_header">--- a/drivers/net/geneve.c</span>
<span class="p_header">+++ b/drivers/net/geneve.c</span>
<span class="p_chunk">@@ -310,15 +310,15 @@</span> <span class="p_context"> static int geneve_udp_encap_recv(struct sock *sk, struct sk_buff *skb)</span>
 
 	/* Need Geneve and inner Ethernet header to be present */
 	if (unlikely(!pskb_may_pull(skb, GENEVE_BASE_HLEN)))
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto drop;</span>
 
 	/* Return packets with reserved bits set */
 	geneveh = geneve_hdr(skb);
 	if (unlikely(geneveh-&gt;ver != GENEVE_VER))
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto drop;</span>
 
 	if (unlikely(geneveh-&gt;proto_type != htons(ETH_P_TEB)))
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto drop;</span>
 
 	opts_len = geneveh-&gt;opt_len * 4;
 	if (iptunnel_pull_header(skb, GENEVE_BASE_HLEN + opts_len,
<span class="p_chunk">@@ -336,10 +336,6 @@</span> <span class="p_context"> drop:</span>
 	/* Consume bad packet */
 	kfree_skb(skb);
 	return 0;
<span class="p_del">-</span>
<span class="p_del">-error:</span>
<span class="p_del">-	/* Let the UDP layer deal with the skb */</span>
<span class="p_del">-	return 1;</span>
 }
 
 static struct socket *geneve_create_sock(struct net *net, bool ipv6,
<span class="p_chunk">@@ -998,6 +994,17 @@</span> <span class="p_context"> static netdev_tx_t geneve_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	return geneve_xmit_skb(skb, dev, info);
 }
 
<span class="p_add">+static int geneve_change_mtu(struct net_device *dev, int new_mtu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* GENEVE overhead is not fixed, so we can&#39;t enforce a more</span>
<span class="p_add">+	 * precise max MTU.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (new_mtu &lt; 68 || new_mtu &gt; IP_MAX_MTU)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	dev-&gt;mtu = new_mtu;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int geneve_fill_metadata_dst(struct net_device *dev, struct sk_buff *skb)
 {
 	struct ip_tunnel_info *info = skb_tunnel_info(skb);
<span class="p_chunk">@@ -1042,7 +1049,7 @@</span> <span class="p_context"> static const struct net_device_ops geneve_netdev_ops = {</span>
 	.ndo_stop		= geneve_stop,
 	.ndo_start_xmit		= geneve_xmit,
 	.ndo_get_stats64	= ip_tunnel_get_stats64,
<span class="p_del">-	.ndo_change_mtu		= eth_change_mtu,</span>
<span class="p_add">+	.ndo_change_mtu		= geneve_change_mtu,</span>
 	.ndo_validate_addr	= eth_validate_addr,
 	.ndo_set_mac_address	= eth_mac_addr,
 	.ndo_fill_metadata_dst	= geneve_fill_metadata_dst,
<span class="p_chunk">@@ -1349,11 +1356,21 @@</span> <span class="p_context"> struct net_device *geneve_dev_create_fb(struct net *net, const char *name,</span>
 
 	err = geneve_configure(net, dev, &amp;geneve_remote_unspec,
 			       0, 0, 0, htons(dst_port), true);
<span class="p_del">-	if (err) {</span>
<span class="p_del">-		free_netdev(dev);</span>
<span class="p_del">-		return ERR_PTR(err);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* openvswitch users expect packet sizes to be unrestricted,</span>
<span class="p_add">+	 * so set the largest MTU we can.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = geneve_change_mtu(dev, IP_MAX_MTU);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto err;</span>
<span class="p_add">+</span>
 	return dev;
<span class="p_add">+</span>
<span class="p_add">+ err:</span>
<span class="p_add">+	free_netdev(dev);</span>
<span class="p_add">+	return ERR_PTR(err);</span>
 }
 EXPORT_SYMBOL_GPL(geneve_dev_create_fb);
 
<span class="p_header">diff --git a/drivers/net/team/team.c b/drivers/net/team/team.c</span>
<span class="p_header">index 59fefca74263..a5f392ae30d5 100644</span>
<span class="p_header">--- a/drivers/net/team/team.c</span>
<span class="p_header">+++ b/drivers/net/team/team.c</span>
<span class="p_chunk">@@ -969,7 +969,7 @@</span> <span class="p_context"> static void team_port_disable(struct team *team,</span>
 			    NETIF_F_FRAGLIST | NETIF_F_ALL_TSO | \
 			    NETIF_F_HIGHDMA | NETIF_F_LRO)
 
<span class="p_del">-static void __team_compute_features(struct team *team)</span>
<span class="p_add">+static void ___team_compute_features(struct team *team)</span>
 {
 	struct team_port *port;
 	u32 vlan_features = TEAM_VLAN_FEATURES &amp; NETIF_F_ALL_FOR_ALL;
<span class="p_chunk">@@ -993,15 +993,20 @@</span> <span class="p_context"> static void __team_compute_features(struct team *team)</span>
 	team-&gt;dev-&gt;priv_flags &amp;= ~IFF_XMIT_DST_RELEASE;
 	if (dst_release_flag == (IFF_XMIT_DST_RELEASE | IFF_XMIT_DST_RELEASE_PERM))
 		team-&gt;dev-&gt;priv_flags |= IFF_XMIT_DST_RELEASE;
<span class="p_add">+}</span>
 
<span class="p_add">+static void __team_compute_features(struct team *team)</span>
<span class="p_add">+{</span>
<span class="p_add">+	___team_compute_features(team);</span>
 	netdev_change_features(team-&gt;dev);
 }
 
 static void team_compute_features(struct team *team)
 {
 	mutex_lock(&amp;team-&gt;lock);
<span class="p_del">-	__team_compute_features(team);</span>
<span class="p_add">+	___team_compute_features(team);</span>
 	mutex_unlock(&amp;team-&gt;lock);
<span class="p_add">+	netdev_change_features(team-&gt;dev);</span>
 }
 
 static int team_port_enter(struct team *team, struct team_port *port)
<span class="p_header">diff --git a/drivers/net/tun.c b/drivers/net/tun.c</span>
<span class="p_header">index 2d186bd66d43..111b972e3053 100644</span>
<span class="p_header">--- a/drivers/net/tun.c</span>
<span class="p_header">+++ b/drivers/net/tun.c</span>
<span class="p_chunk">@@ -567,11 +567,13 @@</span> <span class="p_context"> static void tun_detach_all(struct net_device *dev)</span>
 	for (i = 0; i &lt; n; i++) {
 		tfile = rtnl_dereference(tun-&gt;tfiles[i]);
 		BUG_ON(!tfile);
<span class="p_add">+		tfile-&gt;socket.sk-&gt;sk_shutdown = RCV_SHUTDOWN;</span>
 		tfile-&gt;socket.sk-&gt;sk_data_ready(tfile-&gt;socket.sk);
 		RCU_INIT_POINTER(tfile-&gt;tun, NULL);
 		--tun-&gt;numqueues;
 	}
 	list_for_each_entry(tfile, &amp;tun-&gt;disabled, next) {
<span class="p_add">+		tfile-&gt;socket.sk-&gt;sk_shutdown = RCV_SHUTDOWN;</span>
 		tfile-&gt;socket.sk-&gt;sk_data_ready(tfile-&gt;socket.sk);
 		RCU_INIT_POINTER(tfile-&gt;tun, NULL);
 	}
<span class="p_chunk">@@ -627,6 +629,7 @@</span> <span class="p_context"> static int tun_attach(struct tun_struct *tun, struct file *file, bool skip_filte</span>
 			goto out;
 	}
 	tfile-&gt;queue_index = tun-&gt;numqueues;
<span class="p_add">+	tfile-&gt;socket.sk-&gt;sk_shutdown &amp;= ~RCV_SHUTDOWN;</span>
 	rcu_assign_pointer(tfile-&gt;tun, tun);
 	rcu_assign_pointer(tun-&gt;tfiles[tun-&gt;numqueues], tfile);
 	tun-&gt;numqueues++;
<span class="p_chunk">@@ -1408,9 +1411,6 @@</span> <span class="p_context"> static ssize_t tun_do_read(struct tun_struct *tun, struct tun_file *tfile,</span>
 	if (!iov_iter_count(to))
 		return 0;
 
<span class="p_del">-	if (tun-&gt;dev-&gt;reg_state != NETREG_REGISTERED)</span>
<span class="p_del">-		return -EIO;</span>
<span class="p_del">-</span>
 	/* Read frames from queue */
 	skb = __skb_recv_datagram(tfile-&gt;socket.sk, noblock ? MSG_DONTWAIT : 0,
 				  &amp;peeked, &amp;off, &amp;err);
<span class="p_header">diff --git a/drivers/net/vxlan.c b/drivers/net/vxlan.c</span>
<span class="p_header">index 3c0df70e2f53..003780901628 100644</span>
<span class="p_header">--- a/drivers/net/vxlan.c</span>
<span class="p_header">+++ b/drivers/net/vxlan.c</span>
<span class="p_chunk">@@ -1254,7 +1254,7 @@</span> <span class="p_context"> static int vxlan_udp_encap_recv(struct sock *sk, struct sk_buff *skb)</span>
 
 	/* Need Vxlan and inner Ethernet header to be present */
 	if (!pskb_may_pull(skb, VXLAN_HLEN))
<span class="p_del">-		goto error;</span>
<span class="p_add">+		goto drop;</span>
 
 	vxh = (struct vxlanhdr *)(udp_hdr(skb) + 1);
 	flags = ntohl(vxh-&gt;vx_flags);
<span class="p_chunk">@@ -1344,13 +1344,7 @@</span> <span class="p_context"> drop:</span>
 bad_flags:
 	netdev_dbg(skb-&gt;dev, &quot;invalid vxlan flags=%#x vni=%#x\n&quot;,
 		   ntohl(vxh-&gt;vx_flags), ntohl(vxh-&gt;vx_vni));
<span class="p_del">-</span>
<span class="p_del">-error:</span>
<span class="p_del">-	if (tun_dst)</span>
<span class="p_del">-		dst_release((struct dst_entry *)tun_dst);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Return non vxlan pkt */</span>
<span class="p_del">-	return 1;</span>
<span class="p_add">+	goto drop;</span>
 }
 
 static int arp_reduce(struct net_device *dev, struct sk_buff *skb)
<span class="p_chunk">@@ -2370,29 +2364,43 @@</span> <span class="p_context"> static void vxlan_set_multicast_list(struct net_device *dev)</span>
 {
 }
 
<span class="p_del">-static int vxlan_change_mtu(struct net_device *dev, int new_mtu)</span>
<span class="p_add">+static int __vxlan_change_mtu(struct net_device *dev,</span>
<span class="p_add">+			      struct net_device *lowerdev,</span>
<span class="p_add">+			      struct vxlan_rdst *dst, int new_mtu, bool strict)</span>
 {
<span class="p_del">-	struct vxlan_dev *vxlan = netdev_priv(dev);</span>
<span class="p_del">-	struct vxlan_rdst *dst = &amp;vxlan-&gt;default_dst;</span>
<span class="p_del">-	struct net_device *lowerdev;</span>
<span class="p_del">-	int max_mtu;</span>
<span class="p_add">+	int max_mtu = IP_MAX_MTU;</span>
 
<span class="p_del">-	lowerdev = __dev_get_by_index(vxlan-&gt;net, dst-&gt;remote_ifindex);</span>
<span class="p_del">-	if (lowerdev == NULL)</span>
<span class="p_del">-		return eth_change_mtu(dev, new_mtu);</span>
<span class="p_add">+	if (lowerdev)</span>
<span class="p_add">+		max_mtu = lowerdev-&gt;mtu;</span>
 
 	if (dst-&gt;remote_ip.sa.sa_family == AF_INET6)
<span class="p_del">-		max_mtu = lowerdev-&gt;mtu - VXLAN6_HEADROOM;</span>
<span class="p_add">+		max_mtu -= VXLAN6_HEADROOM;</span>
 	else
<span class="p_del">-		max_mtu = lowerdev-&gt;mtu - VXLAN_HEADROOM;</span>
<span class="p_add">+		max_mtu -= VXLAN_HEADROOM;</span>
 
<span class="p_del">-	if (new_mtu &lt; 68 || new_mtu &gt; max_mtu)</span>
<span class="p_add">+	if (new_mtu &lt; 68)</span>
 		return -EINVAL;
 
<span class="p_add">+	if (new_mtu &gt; max_mtu) {</span>
<span class="p_add">+		if (strict)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		new_mtu = max_mtu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev-&gt;mtu = new_mtu;
 	return 0;
 }
 
<span class="p_add">+static int vxlan_change_mtu(struct net_device *dev, int new_mtu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct vxlan_dev *vxlan = netdev_priv(dev);</span>
<span class="p_add">+	struct vxlan_rdst *dst = &amp;vxlan-&gt;default_dst;</span>
<span class="p_add">+	struct net_device *lowerdev = __dev_get_by_index(vxlan-&gt;net,</span>
<span class="p_add">+							 dst-&gt;remote_ifindex);</span>
<span class="p_add">+	return __vxlan_change_mtu(dev, lowerdev, dst, new_mtu, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int egress_ipv4_tun_info(struct net_device *dev, struct sk_buff *skb,
 				struct ip_tunnel_info *info,
 				__be16 sport, __be16 dport)
<span class="p_chunk">@@ -2768,6 +2776,7 @@</span> <span class="p_context"> static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,</span>
 	int err;
 	bool use_ipv6 = false;
 	__be16 default_port = vxlan-&gt;cfg.dst_port;
<span class="p_add">+	struct net_device *lowerdev = NULL;</span>
 
 	vxlan-&gt;net = src_net;
 
<span class="p_chunk">@@ -2788,9 +2797,7 @@</span> <span class="p_context"> static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,</span>
 	}
 
 	if (conf-&gt;remote_ifindex) {
<span class="p_del">-		struct net_device *lowerdev</span>
<span class="p_del">-			 = __dev_get_by_index(src_net, conf-&gt;remote_ifindex);</span>
<span class="p_del">-</span>
<span class="p_add">+		lowerdev = __dev_get_by_index(src_net, conf-&gt;remote_ifindex);</span>
 		dst-&gt;remote_ifindex = conf-&gt;remote_ifindex;
 
 		if (!lowerdev) {
<span class="p_chunk">@@ -2814,6 +2821,12 @@</span> <span class="p_context"> static int vxlan_dev_configure(struct net *src_net, struct net_device *dev,</span>
 		needed_headroom = lowerdev-&gt;hard_header_len;
 	}
 
<span class="p_add">+	if (conf-&gt;mtu) {</span>
<span class="p_add">+		err = __vxlan_change_mtu(dev, lowerdev, dst, conf-&gt;mtu, false);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (use_ipv6 || conf-&gt;flags &amp; VXLAN_F_COLLECT_METADATA)
 		needed_headroom += VXLAN6_HEADROOM;
 	else
<span class="p_chunk">@@ -2991,6 +3004,9 @@</span> <span class="p_context"> static int vxlan_newlink(struct net *src_net, struct net_device *dev,</span>
 	if (data[IFLA_VXLAN_REMCSUM_NOPARTIAL])
 		conf.flags |= VXLAN_F_REMCSUM_NOPARTIAL;
 
<span class="p_add">+	if (tb[IFLA_MTU])</span>
<span class="p_add">+		conf.mtu = nla_get_u32(tb[IFLA_MTU]);</span>
<span class="p_add">+</span>
 	err = vxlan_dev_configure(src_net, dev, &amp;conf);
 	switch (err) {
 	case -ENODEV:
<span class="p_header">diff --git a/drivers/pinctrl/mediatek/pinctrl-mtk-common.c b/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_header">index 3d8019eb3d84..181b35879ebd 100644</span>
<span class="p_header">--- a/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_header">+++ b/drivers/pinctrl/mediatek/pinctrl-mtk-common.c</span>
<span class="p_chunk">@@ -1191,9 +1191,10 @@</span> <span class="p_context"> static void mtk_eint_irq_handler(struct irq_desc *desc)</span>
 	const struct mtk_desc_pin *pin;
 
 	chained_irq_enter(chip, desc);
<span class="p_del">-	for (eint_num = 0; eint_num &lt; pctl-&gt;devdata-&gt;ap_num; eint_num += 32) {</span>
<span class="p_add">+	for (eint_num = 0;</span>
<span class="p_add">+	     eint_num &lt; pctl-&gt;devdata-&gt;ap_num;</span>
<span class="p_add">+	     eint_num += 32, reg += 4) {</span>
 		status = readl(reg);
<span class="p_del">-		reg += 4;</span>
 		while (status) {
 			offset = __ffs(status);
 			index = eint_num + offset;
<span class="p_header">diff --git a/drivers/scsi/scsi_devinfo.c b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">index da2e068ee47d..93cbefa75b26 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_devinfo.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_devinfo.c</span>
<span class="p_chunk">@@ -227,6 +227,7 @@</span> <span class="p_context"> static struct {</span>
 	{&quot;PIONEER&quot;, &quot;CD-ROM DRM-624X&quot;, NULL, BLIST_FORCELUN | BLIST_SINGLELUN},
 	{&quot;Promise&quot;, &quot;VTrak E610f&quot;, NULL, BLIST_SPARSELUN | BLIST_NO_RSOC},
 	{&quot;Promise&quot;, &quot;&quot;, NULL, BLIST_SPARSELUN},
<span class="p_add">+	{&quot;QEMU&quot;, &quot;QEMU CD-ROM&quot;, NULL, BLIST_SKIP_VPD_PAGES},</span>
 	{&quot;QNAP&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},
 	{&quot;SYNOLOGY&quot;, &quot;iSCSI Storage&quot;, NULL, BLIST_MAX_1024},
 	{&quot;QUANTUM&quot;, &quot;XP34301&quot;, &quot;1071&quot;, BLIST_NOTQ},
<span class="p_header">diff --git a/drivers/scsi/scsi_lib.c b/drivers/scsi/scsi_lib.c</span>
<span class="p_header">index dd8ad2a44510..cf5b99e1f12b 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_lib.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_lib.c</span>
<span class="p_chunk">@@ -910,9 +910,12 @@</span> <span class="p_context"> void scsi_io_completion(struct scsi_cmnd *cmd, unsigned int good_bytes)</span>
 	}
 
 	/*
<span class="p_del">-	 * If we finished all bytes in the request we are done now.</span>
<span class="p_add">+	 * special case: failed zero length commands always need to</span>
<span class="p_add">+	 * drop down into the retry code. Otherwise, if we finished</span>
<span class="p_add">+	 * all bytes in the request we are done now.</span>
 	 */
<span class="p_del">-	if (!scsi_end_request(req, error, good_bytes, 0))</span>
<span class="p_add">+	if (!(blk_rq_bytes(req) == 0 &amp;&amp; error) &amp;&amp;</span>
<span class="p_add">+	    !scsi_end_request(req, error, good_bytes, 0))</span>
 		return;
 
 	/*
<span class="p_header">diff --git a/fs/dcache.c b/fs/dcache.c</span>
<span class="p_header">index 18effa378f97..108d7d810be3 100644</span>
<span class="p_header">--- a/fs/dcache.c</span>
<span class="p_header">+++ b/fs/dcache.c</span>
<span class="p_chunk">@@ -1618,7 +1618,7 @@</span> <span class="p_context"> struct dentry *d_alloc(struct dentry * parent, const struct qstr *name)</span>
 	struct dentry *dentry = __d_alloc(parent-&gt;d_sb, name);
 	if (!dentry)
 		return NULL;
<span class="p_del">-</span>
<span class="p_add">+	dentry-&gt;d_flags |= DCACHE_RCUACCESS;</span>
 	spin_lock(&amp;parent-&gt;d_lock);
 	/*
 	 * don&#39;t need child lock because it is not subject
<span class="p_chunk">@@ -2413,7 +2413,6 @@</span> <span class="p_context"> static void __d_rehash(struct dentry * entry, struct hlist_bl_head *b)</span>
 {
 	BUG_ON(!d_unhashed(entry));
 	hlist_bl_lock(b);
<span class="p_del">-	entry-&gt;d_flags |= DCACHE_RCUACCESS;</span>
 	hlist_bl_add_head_rcu(&amp;entry-&gt;d_hash, b);
 	hlist_bl_unlock(b);
 }
<span class="p_chunk">@@ -2632,6 +2631,7 @@</span> <span class="p_context"> static void __d_move(struct dentry *dentry, struct dentry *target,</span>
 	/* ... and switch them in the tree */
 	if (IS_ROOT(dentry)) {
 		/* splicing a tree */
<span class="p_add">+		dentry-&gt;d_flags |= DCACHE_RCUACCESS;</span>
 		dentry-&gt;d_parent = target-&gt;d_parent;
 		target-&gt;d_parent = target;
 		list_del_init(&amp;target-&gt;d_child);
<span class="p_header">diff --git a/fs/ecryptfs/kthread.c b/fs/ecryptfs/kthread.c</span>
<span class="p_header">index 866bb18efefe..e818f5ac7a26 100644</span>
<span class="p_header">--- a/fs/ecryptfs/kthread.c</span>
<span class="p_header">+++ b/fs/ecryptfs/kthread.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/wait.h&gt;
 #include &lt;linux/mount.h&gt;
<span class="p_add">+#include &lt;linux/file.h&gt;</span>
 #include &quot;ecryptfs_kernel.h&quot;
 
 struct ecryptfs_open_req {
<span class="p_chunk">@@ -147,7 +148,7 @@</span> <span class="p_context"> int ecryptfs_privileged_open(struct file **lower_file,</span>
 	flags |= IS_RDONLY(d_inode(lower_dentry)) ? O_RDONLY : O_RDWR;
 	(*lower_file) = dentry_open(&amp;req.path, flags, cred);
 	if (!IS_ERR(*lower_file))
<span class="p_del">-		goto out;</span>
<span class="p_add">+		goto have_file;</span>
 	if ((flags &amp; O_ACCMODE) == O_RDONLY) {
 		rc = PTR_ERR((*lower_file));
 		goto out;
<span class="p_chunk">@@ -165,8 +166,16 @@</span> <span class="p_context"> int ecryptfs_privileged_open(struct file **lower_file,</span>
 	mutex_unlock(&amp;ecryptfs_kthread_ctl.mux);
 	wake_up(&amp;ecryptfs_kthread_ctl.wait);
 	wait_for_completion(&amp;req.done);
<span class="p_del">-	if (IS_ERR(*lower_file))</span>
<span class="p_add">+	if (IS_ERR(*lower_file)) {</span>
 		rc = PTR_ERR(*lower_file);
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+have_file:</span>
<span class="p_add">+	if ((*lower_file)-&gt;f_op-&gt;mmap == NULL) {</span>
<span class="p_add">+		fput(*lower_file);</span>
<span class="p_add">+		*lower_file = NULL;</span>
<span class="p_add">+		rc = -EMEDIUMTYPE;</span>
<span class="p_add">+	}</span>
 out:
 	return rc;
 }
<span class="p_header">diff --git a/fs/proc/root.c b/fs/proc/root.c</span>
<span class="p_header">index 361ab4ee42fc..ec649c92d270 100644</span>
<span class="p_header">--- a/fs/proc/root.c</span>
<span class="p_header">+++ b/fs/proc/root.c</span>
<span class="p_chunk">@@ -121,6 +121,13 @@</span> <span class="p_context"> static struct dentry *proc_mount(struct file_system_type *fs_type,</span>
 	if (IS_ERR(sb))
 		return ERR_CAST(sb);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * procfs isn&#39;t actually a stacking filesystem; however, there is</span>
<span class="p_add">+	 * too much magic going on inside it to permit stacking things on</span>
<span class="p_add">+	 * top of it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	sb-&gt;s_stack_depth = FILESYSTEM_MAX_STACK_DEPTH;</span>
<span class="p_add">+</span>
 	if (!proc_parse_options(options, ns)) {
 		deactivate_locked_super(sb);
 		return ERR_PTR(-EINVAL);
<span class="p_header">diff --git a/include/linux/irqchip/arm-gic-v3.h b/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_header">index d5d798b35c1f..e98425058f20 100644</span>
<span class="p_header">--- a/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_header">+++ b/include/linux/irqchip/arm-gic-v3.h</span>
<span class="p_chunk">@@ -301,7 +301,7 @@</span> <span class="p_context"></span>
 #define ICC_SGI1R_AFFINITY_1_SHIFT	16
 #define ICC_SGI1R_AFFINITY_1_MASK	(0xff &lt;&lt; ICC_SGI1R_AFFINITY_1_SHIFT)
 #define ICC_SGI1R_SGI_ID_SHIFT		24
<span class="p_del">-#define ICC_SGI1R_SGI_ID_MASK		(0xff &lt;&lt; ICC_SGI1R_SGI_ID_SHIFT)</span>
<span class="p_add">+#define ICC_SGI1R_SGI_ID_MASK		(0xfULL &lt;&lt; ICC_SGI1R_SGI_ID_SHIFT)</span>
 #define ICC_SGI1R_AFFINITY_2_SHIFT	32
 #define ICC_SGI1R_AFFINITY_2_MASK	(0xffULL &lt;&lt; ICC_SGI1R_AFFINITY_1_SHIFT)
 #define ICC_SGI1R_IRQ_ROUTING_MODE_BIT	40
<span class="p_header">diff --git a/include/linux/netfilter/x_tables.h b/include/linux/netfilter/x_tables.h</span>
<span class="p_header">index c5577410c25d..04078e8a4803 100644</span>
<span class="p_header">--- a/include/linux/netfilter/x_tables.h</span>
<span class="p_header">+++ b/include/linux/netfilter/x_tables.h</span>
<span class="p_chunk">@@ -239,11 +239,18 @@</span> <span class="p_context"> void xt_unregister_match(struct xt_match *target);</span>
 int xt_register_matches(struct xt_match *match, unsigned int n);
 void xt_unregister_matches(struct xt_match *match, unsigned int n);
 
<span class="p_add">+int xt_check_entry_offsets(const void *base, const char *elems,</span>
<span class="p_add">+			   unsigned int target_offset,</span>
<span class="p_add">+			   unsigned int next_offset);</span>
<span class="p_add">+</span>
 int xt_check_match(struct xt_mtchk_param *, unsigned int size, u_int8_t proto,
 		   bool inv_proto);
 int xt_check_target(struct xt_tgchk_param *, unsigned int size, u_int8_t proto,
 		    bool inv_proto);
 
<span class="p_add">+void *xt_copy_counters_from_user(const void __user *user, unsigned int len,</span>
<span class="p_add">+				 struct xt_counters_info *info, bool compat);</span>
<span class="p_add">+</span>
 struct xt_table *xt_register_table(struct net *net,
 				   const struct xt_table *table,
 				   struct xt_table_info *bootstrap,
<span class="p_chunk">@@ -478,7 +485,7 @@</span> <span class="p_context"> void xt_compat_init_offsets(u_int8_t af, unsigned int number);</span>
 int xt_compat_calc_jump(u_int8_t af, unsigned int offset);
 
 int xt_compat_match_offset(const struct xt_match *match);
<span class="p_del">-int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
<span class="p_add">+void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
 			      unsigned int *size);
 int xt_compat_match_to_user(const struct xt_entry_match *m,
 			    void __user **dstptr, unsigned int *size);
<span class="p_chunk">@@ -488,6 +495,9 @@</span> <span class="p_context"> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span>
 				unsigned int *size);
 int xt_compat_target_to_user(const struct xt_entry_target *t,
 			     void __user **dstptr, unsigned int *size);
<span class="p_add">+int xt_compat_check_entry_offsets(const void *base, const char *elems,</span>
<span class="p_add">+				  unsigned int target_offset,</span>
<span class="p_add">+				  unsigned int next_offset);</span>
 
 #endif /* CONFIG_COMPAT */
 #endif /* _X_TABLES_H */
<span class="p_header">diff --git a/include/net/ip_tunnels.h b/include/net/ip_tunnels.h</span>
<span class="p_header">index 62a750a6a8f8..af40bc586a1b 100644</span>
<span class="p_header">--- a/include/net/ip_tunnels.h</span>
<span class="p_header">+++ b/include/net/ip_tunnels.h</span>
<span class="p_chunk">@@ -230,6 +230,7 @@</span> <span class="p_context"> void ip_tunnel_xmit(struct sk_buff *skb, struct net_device *dev,</span>
 int ip_tunnel_ioctl(struct net_device *dev, struct ip_tunnel_parm *p, int cmd);
 int ip_tunnel_encap(struct sk_buff *skb, struct ip_tunnel *t,
 		    u8 *protocol, struct flowi4 *fl4);
<span class="p_add">+int __ip_tunnel_change_mtu(struct net_device *dev, int new_mtu, bool strict);</span>
 int ip_tunnel_change_mtu(struct net_device *dev, int new_mtu);
 
 struct rtnl_link_stats64 *ip_tunnel_get_stats64(struct net_device *dev,
<span class="p_header">diff --git a/include/net/switchdev.h b/include/net/switchdev.h</span>
<span class="p_header">index 1d22ce9f352e..31d0e5143848 100644</span>
<span class="p_header">--- a/include/net/switchdev.h</span>
<span class="p_header">+++ b/include/net/switchdev.h</span>
<span class="p_chunk">@@ -88,7 +88,7 @@</span> <span class="p_context"> struct switchdev_obj_ipv4_fib {</span>
 	struct switchdev_obj obj;
 	u32 dst;
 	int dst_len;
<span class="p_del">-	struct fib_info fi;</span>
<span class="p_add">+	struct fib_info *fi;</span>
 	u8 tos;
 	u8 type;
 	u32 nlflags;
<span class="p_header">diff --git a/include/uapi/linux/libc-compat.h b/include/uapi/linux/libc-compat.h</span>
<span class="p_header">index d5e38c73377c..e4f048ee7043 100644</span>
<span class="p_header">--- a/include/uapi/linux/libc-compat.h</span>
<span class="p_header">+++ b/include/uapi/linux/libc-compat.h</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"></span>
 #if defined(__GLIBC__)
 
 /* Coordinate with glibc net/if.h header. */
<span class="p_del">-#if defined(_NET_IF_H)</span>
<span class="p_add">+#if defined(_NET_IF_H) &amp;&amp; defined(__USE_MISC)</span>
 
 /* GLIBC headers included first so don&#39;t define anything
  * that would already be defined. */
<span class="p_header">diff --git a/kernel/bpf/inode.c b/kernel/bpf/inode.c</span>
<span class="p_header">index d1a7646f79c5..cb85d228b1ac 100644</span>
<span class="p_header">--- a/kernel/bpf/inode.c</span>
<span class="p_header">+++ b/kernel/bpf/inode.c</span>
<span class="p_chunk">@@ -358,7 +358,7 @@</span> <span class="p_context"> static int bpf_fill_super(struct super_block *sb, void *data, int silent)</span>
 static struct dentry *bpf_mount(struct file_system_type *type, int flags,
 				const char *dev_name, void *data)
 {
<span class="p_del">-	return mount_ns(type, flags, current-&gt;nsproxy-&gt;mnt_ns, bpf_fill_super);</span>
<span class="p_add">+	return mount_nodev(type, flags, data, bpf_fill_super);</span>
 }
 
 static struct file_system_type bpf_fs_type = {
<span class="p_chunk">@@ -366,7 +366,6 @@</span> <span class="p_context"> static struct file_system_type bpf_fs_type = {</span>
 	.name		= &quot;bpf&quot;,
 	.mount		= bpf_mount,
 	.kill_sb	= kill_litter_super,
<span class="p_del">-	.fs_flags	= FS_USERNS_MOUNT,</span>
 };
 
 MODULE_ALIAS_FS(&quot;bpf&quot;);
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 55bebf924946..6c0cdb5a73f8 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -3008,7 +3008,8 @@</span> <span class="p_context"> static noinline void __schedule_bug(struct task_struct *prev)</span>
 static inline void schedule_debug(struct task_struct *prev)
 {
 #ifdef CONFIG_SCHED_STACK_END_CHECK
<span class="p_del">-	BUG_ON(task_stack_end_corrupted(prev));</span>
<span class="p_add">+	if (task_stack_end_corrupted(prev))</span>
<span class="p_add">+		panic(&quot;corrupted stack end detected inside scheduler\n&quot;);</span>
 #endif
 
 	if (unlikely(in_atomic_preempt_off())) {
<span class="p_header">diff --git a/mm/memcontrol.c b/mm/memcontrol.c</span>
<span class="p_header">index 6ba4dd988e2e..67648e6b2ac8 100644</span>
<span class="p_header">--- a/mm/memcontrol.c</span>
<span class="p_header">+++ b/mm/memcontrol.c</span>
<span class="p_chunk">@@ -3661,6 +3661,7 @@</span> <span class="p_context"> static void memcg_deactivate_kmem(struct mem_cgroup *memcg)</span>
 	 * ordering is imposed by list_lru_node-&gt;lock taken by
 	 * memcg_drain_all_list_lrus().
 	 */
<span class="p_add">+	rcu_read_lock(); /* can be called from css_free w/o cgroup_mutex */</span>
 	css_for_each_descendant_pre(css, &amp;memcg-&gt;css) {
 		child = mem_cgroup_from_css(css);
 		BUG_ON(child-&gt;kmemcg_id != kmemcg_id);
<span class="p_chunk">@@ -3668,6 +3669,8 @@</span> <span class="p_context"> static void memcg_deactivate_kmem(struct mem_cgroup *memcg)</span>
 		if (!memcg-&gt;use_hierarchy)
 			break;
 	}
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
 	memcg_drain_all_list_lrus(kmemcg_id, parent-&gt;kmemcg_id);
 
 	memcg_free_cache_id(kmemcg_id);
<span class="p_header">diff --git a/net/bridge/br_fdb.c b/net/bridge/br_fdb.c</span>
<span class="p_header">index a642bb829d09..09442e0f7f67 100644</span>
<span class="p_header">--- a/net/bridge/br_fdb.c</span>
<span class="p_header">+++ b/net/bridge/br_fdb.c</span>
<span class="p_chunk">@@ -278,6 +278,8 @@</span> <span class="p_context"> void br_fdb_change_mac_address(struct net_bridge *br, const u8 *newaddr)</span>
 	 * change from under us.
 	 */
 	list_for_each_entry(v, &amp;vg-&gt;vlan_list, vlist) {
<span class="p_add">+		if (!br_vlan_should_use(v))</span>
<span class="p_add">+			continue;</span>
 		f = __br_fdb_get(br, br-&gt;dev-&gt;dev_addr, v-&gt;vid);
 		if (f &amp;&amp; f-&gt;is_local &amp;&amp; !f-&gt;dst)
 			fdb_delete_local(br, NULL, f);
<span class="p_header">diff --git a/net/ipv4/ip_gre.c b/net/ipv4/ip_gre.c</span>
<span class="p_header">index 7dc962b89fa1..3e4184088082 100644</span>
<span class="p_header">--- a/net/ipv4/ip_gre.c</span>
<span class="p_header">+++ b/net/ipv4/ip_gre.c</span>
<span class="p_chunk">@@ -1247,6 +1247,14 @@</span> <span class="p_context"> struct net_device *gretap_fb_dev_create(struct net *net, const char *name,</span>
 	err = ipgre_newlink(net, dev, tb, NULL);
 	if (err &lt; 0)
 		goto out;
<span class="p_add">+</span>
<span class="p_add">+	/* openvswitch users expect packet sizes to be unrestricted,</span>
<span class="p_add">+	 * so set the largest MTU we can.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = __ip_tunnel_change_mtu(dev, IP_MAX_MTU, false);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	return dev;
 out:
 	free_netdev(dev);
<span class="p_header">diff --git a/net/ipv4/ip_tunnel.c b/net/ipv4/ip_tunnel.c</span>
<span class="p_header">index ce30c8b72457..3310ac75e3f3 100644</span>
<span class="p_header">--- a/net/ipv4/ip_tunnel.c</span>
<span class="p_header">+++ b/net/ipv4/ip_tunnel.c</span>
<span class="p_chunk">@@ -948,17 +948,31 @@</span> <span class="p_context"> done:</span>
 }
 EXPORT_SYMBOL_GPL(ip_tunnel_ioctl);
 
<span class="p_del">-int ip_tunnel_change_mtu(struct net_device *dev, int new_mtu)</span>
<span class="p_add">+int __ip_tunnel_change_mtu(struct net_device *dev, int new_mtu, bool strict)</span>
 {
 	struct ip_tunnel *tunnel = netdev_priv(dev);
 	int t_hlen = tunnel-&gt;hlen + sizeof(struct iphdr);
<span class="p_add">+	int max_mtu = 0xFFF8 - dev-&gt;hard_header_len - t_hlen;</span>
 
<span class="p_del">-	if (new_mtu &lt; 68 ||</span>
<span class="p_del">-	    new_mtu &gt; 0xFFF8 - dev-&gt;hard_header_len - t_hlen)</span>
<span class="p_add">+	if (new_mtu &lt; 68)</span>
 		return -EINVAL;
<span class="p_add">+</span>
<span class="p_add">+	if (new_mtu &gt; max_mtu) {</span>
<span class="p_add">+		if (strict)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		new_mtu = max_mtu;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	dev-&gt;mtu = new_mtu;
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL_GPL(__ip_tunnel_change_mtu);</span>
<span class="p_add">+</span>
<span class="p_add">+int ip_tunnel_change_mtu(struct net_device *dev, int new_mtu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __ip_tunnel_change_mtu(dev, new_mtu, true);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(ip_tunnel_change_mtu);
 
 static void ip_tunnel_dev_free(struct net_device *dev)
<span class="p_header">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">index 11dccba474b7..6e3e0e8b1ce3 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_chunk">@@ -359,11 +359,24 @@</span> <span class="p_context"> unsigned int arpt_do_table(struct sk_buff *skb,</span>
 }
 
 /* All zeroes == unconditional rule. */
<span class="p_del">-static inline bool unconditional(const struct arpt_arp *arp)</span>
<span class="p_add">+static inline bool unconditional(const struct arpt_entry *e)</span>
 {
 	static const struct arpt_arp uncond;
 
<span class="p_del">-	return memcmp(arp, &amp;uncond, sizeof(uncond)) == 0;</span>
<span class="p_add">+	return e-&gt;target_offset == sizeof(struct arpt_entry) &amp;&amp;</span>
<span class="p_add">+	       memcmp(&amp;e-&gt;arp, &amp;uncond, sizeof(uncond)) == 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool find_jump_target(const struct xt_table_info *t,</span>
<span class="p_add">+			     const struct arpt_entry *target)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct arpt_entry *iter;</span>
<span class="p_add">+</span>
<span class="p_add">+	xt_entry_foreach(iter, t-&gt;entries, t-&gt;size) {</span>
<span class="p_add">+		 if (iter == target)</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
 }
 
 /* Figures out from what hook each rule can be called: returns 0 if
<span class="p_chunk">@@ -402,11 +415,10 @@</span> <span class="p_context"> static int mark_source_chains(const struct xt_table_info *newinfo,</span>
 				|= ((1 &lt;&lt; hook) | (1 &lt;&lt; NF_ARP_NUMHOOKS));
 
 			/* Unconditional return/END. */
<span class="p_del">-			if ((e-&gt;target_offset == sizeof(struct arpt_entry) &amp;&amp;</span>
<span class="p_add">+			if ((unconditional(e) &amp;&amp;</span>
 			     (strcmp(t-&gt;target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &amp;&amp;
<span class="p_del">-			     t-&gt;verdict &lt; 0 &amp;&amp; unconditional(&amp;e-&gt;arp)) ||</span>
<span class="p_del">-			    visited) {</span>
<span class="p_add">+			     t-&gt;verdict &lt; 0) || visited) {</span>
 				unsigned int oldpos, size;
 
 				if ((strcmp(t-&gt;target.u.user.name,
<span class="p_chunk">@@ -439,6 +451,8 @@</span> <span class="p_context"> static int mark_source_chains(const struct xt_table_info *newinfo,</span>
 				size = e-&gt;next_offset;
 				e = (struct arpt_entry *)
 					(entry0 + pos + size);
<span class="p_add">+				if (pos + size &gt;= newinfo-&gt;size)</span>
<span class="p_add">+					return 0;</span>
 				e-&gt;counters.pcnt = pos;
 				pos += size;
 			} else {
<span class="p_chunk">@@ -458,9 +472,15 @@</span> <span class="p_context"> static int mark_source_chains(const struct xt_table_info *newinfo,</span>
 					/* This a jump; chase it. */
 					duprintf(&quot;Jump rule %u -&gt; %u\n&quot;,
 						 pos, newpos);
<span class="p_add">+					e = (struct arpt_entry *)</span>
<span class="p_add">+						(entry0 + newpos);</span>
<span class="p_add">+					if (!find_jump_target(newinfo, e))</span>
<span class="p_add">+						return 0;</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_add">+					if (newpos &gt;= newinfo-&gt;size)</span>
<span class="p_add">+						return 0;</span>
 				}
 				e = (struct arpt_entry *)
 					(entry0 + newpos);
<span class="p_chunk">@@ -474,25 +494,6 @@</span> <span class="p_context"> next:</span>
 	return 1;
 }
 
<span class="p_del">-static inline int check_entry(const struct arpt_entry *e, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct xt_entry_target *t;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!arp_checkentry(&amp;e-&gt;arp)) {</span>
<span class="p_del">-		duprintf(&quot;arp_tables: arp check failed %p %s.\n&quot;, e, name);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (e-&gt;target_offset + sizeof(struct xt_entry_target) &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	t = arpt_get_target_c(e);</span>
<span class="p_del">-	if (e-&gt;target_offset + t-&gt;u.target_size &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int check_target(struct arpt_entry *e, const char *name)
 {
 	struct xt_entry_target *t = arpt_get_target(e);
<span class="p_chunk">@@ -522,10 +523,6 @@</span> <span class="p_context"> find_check_entry(struct arpt_entry *e, const char *name, unsigned int size)</span>
 	struct xt_target *target;
 	int ret;
 
<span class="p_del">-	ret = check_entry(e, name);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
 	e-&gt;counters.pcnt = xt_percpu_counter_alloc();
 	if (IS_ERR_VALUE(e-&gt;counters.pcnt))
 		return -ENOMEM;
<span class="p_chunk">@@ -557,7 +554,7 @@</span> <span class="p_context"> static bool check_underflow(const struct arpt_entry *e)</span>
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
<span class="p_del">-	if (!unconditional(&amp;e-&gt;arp))</span>
<span class="p_add">+	if (!unconditional(e))</span>
 		return false;
 	t = arpt_get_target_c(e);
 	if (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) != 0)
<span class="p_chunk">@@ -576,9 +573,11 @@</span> <span class="p_context"> static inline int check_entry_size_and_hooks(struct arpt_entry *e,</span>
 					     unsigned int valid_hooks)
 {
 	unsigned int h;
<span class="p_add">+	int err;</span>
 
 	if ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||
<span class="p_del">-	    (unsigned char *)e + sizeof(struct arpt_entry) &gt;= limit) {</span>
<span class="p_add">+	    (unsigned char *)e + sizeof(struct arpt_entry) &gt;= limit ||</span>
<span class="p_add">+	    (unsigned char *)e + e-&gt;next_offset &gt; limit) {</span>
 		duprintf(&quot;Bad offset %p\n&quot;, e);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -590,6 +589,14 @@</span> <span class="p_context"> static inline int check_entry_size_and_hooks(struct arpt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	if (!arp_checkentry(&amp;e-&gt;arp))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = xt_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+				     e-&gt;next_offset);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	/* Check hooks &amp; underflows */
 	for (h = 0; h &lt; NF_ARP_NUMHOOKS; h++) {
 		if (!(valid_hooks &amp; (1 &lt;&lt; h)))
<span class="p_chunk">@@ -598,9 +605,9 @@</span> <span class="p_context"> static inline int check_entry_size_and_hooks(struct arpt_entry *e,</span>
 			newinfo-&gt;hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
<span class="p_del">-				pr_err(&quot;Underflows must be unconditional and &quot;</span>
<span class="p_del">-				       &quot;use the STANDARD target with &quot;</span>
<span class="p_del">-				       &quot;ACCEPT/DROP\n&quot;);</span>
<span class="p_add">+				pr_debug(&quot;Underflows must be unconditional and &quot;</span>
<span class="p_add">+					 &quot;use the STANDARD target with &quot;</span>
<span class="p_add">+					 &quot;ACCEPT/DROP\n&quot;);</span>
 				return -EINVAL;
 			}
 			newinfo-&gt;underflow[h] = underflows[h];
<span class="p_chunk">@@ -691,10 +698,8 @@</span> <span class="p_context"> static int translate_table(struct xt_table_info *newinfo, void *entry0,</span>
 		}
 	}
 
<span class="p_del">-	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0)) {</span>
<span class="p_del">-		duprintf(&quot;Looping hook\n&quot;);</span>
<span class="p_add">+	if (!mark_source_chains(newinfo, repl-&gt;valid_hooks, entry0))</span>
 		return -ELOOP;
<span class="p_del">-	}</span>
 
 	/* Finally, each sanity check must pass */
 	i = 0;
<span class="p_chunk">@@ -1125,55 +1130,17 @@</span> <span class="p_context"> static int do_add_counters(struct net *net, const void __user *user,</span>
 	unsigned int i;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
<span class="p_del">-	unsigned int num_counters;</span>
<span class="p_del">-	const char *name;</span>
<span class="p_del">-	int size;</span>
<span class="p_del">-	void *ptmp;</span>
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	struct arpt_entry *iter;
 	unsigned int addend;
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	struct compat_xt_counters_info compat_tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		ptmp = &amp;compat_tmp;</span>
<span class="p_del">-		size = sizeof(struct compat_xt_counters_info);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ptmp = &amp;tmp;</span>
<span class="p_del">-		size = sizeof(struct xt_counters_info);</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (copy_from_user(ptmp, user, size) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		num_counters = compat_tmp.num_counters;</span>
<span class="p_del">-		name = compat_tmp.name;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		num_counters = tmp.num_counters;</span>
<span class="p_del">-		name = tmp.name;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	paddc = xt_copy_counters_from_user(user, len, &amp;tmp, compat);</span>
<span class="p_add">+	if (IS_ERR(paddc))</span>
<span class="p_add">+		return PTR_ERR(paddc);</span>
 
<span class="p_del">-	if (len != size + num_counters * sizeof(struct xt_counters))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	paddc = vmalloc(len - size);</span>
<span class="p_del">-	if (!paddc)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(paddc, user + size, len - size) != 0) {</span>
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto free;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	t = xt_find_table_lock(net, NFPROTO_ARP, name);</span>
<span class="p_add">+	t = xt_find_table_lock(net, NFPROTO_ARP, tmp.name);</span>
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
<span class="p_chunk">@@ -1181,7 +1148,7 @@</span> <span class="p_context"> static int do_add_counters(struct net *net, const void __user *user,</span>
 
 	local_bh_disable();
 	private = t-&gt;private;
<span class="p_del">-	if (private-&gt;number != num_counters) {</span>
<span class="p_add">+	if (private-&gt;number != tmp.num_counters) {</span>
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
<span class="p_chunk">@@ -1208,6 +1175,18 @@</span> <span class="p_context"> static int do_add_counters(struct net *net, const void __user *user,</span>
 }
 
 #ifdef CONFIG_COMPAT
<span class="p_add">+struct compat_arpt_replace {</span>
<span class="p_add">+	char				name[XT_TABLE_MAXNAMELEN];</span>
<span class="p_add">+	u32				valid_hooks;</span>
<span class="p_add">+	u32				num_entries;</span>
<span class="p_add">+	u32				size;</span>
<span class="p_add">+	u32				hook_entry[NF_ARP_NUMHOOKS];</span>
<span class="p_add">+	u32				underflow[NF_ARP_NUMHOOKS];</span>
<span class="p_add">+	u32				num_counters;</span>
<span class="p_add">+	compat_uptr_t			counters;</span>
<span class="p_add">+	struct compat_arpt_entry	entries[0];</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static inline void compat_release_entry(struct compat_arpt_entry *e)
 {
 	struct xt_entry_target *t;
<span class="p_chunk">@@ -1216,24 +1195,22 @@</span> <span class="p_context"> static inline void compat_release_entry(struct compat_arpt_entry *e)</span>
 	module_put(t-&gt;u.kernel.target-&gt;me);
 }
 
<span class="p_del">-static inline int</span>
<span class="p_add">+static int</span>
 check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
<span class="p_del">-				  const unsigned char *limit,</span>
<span class="p_del">-				  const unsigned int *hook_entries,</span>
<span class="p_del">-				  const unsigned int *underflows,</span>
<span class="p_del">-				  const char *name)</span>
<span class="p_add">+				  const unsigned char *limit)</span>
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
<span class="p_del">-	int ret, off, h;</span>
<span class="p_add">+	int ret, off;</span>
 
 	duprintf(&quot;check_compat_entry_size_and_hooks %p\n&quot;, e);
 	if ((unsigned long)e % __alignof__(struct compat_arpt_entry) != 0 ||
<span class="p_del">-	    (unsigned char *)e + sizeof(struct compat_arpt_entry) &gt;= limit) {</span>
<span class="p_add">+	    (unsigned char *)e + sizeof(struct compat_arpt_entry) &gt;= limit ||</span>
<span class="p_add">+	    (unsigned char *)e + e-&gt;next_offset &gt; limit) {</span>
 		duprintf(&quot;Bad offset %p, limit = %p\n&quot;, e, limit);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -1245,8 +1222,11 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* For purposes of check_entry casting the compat entry is fine */</span>
<span class="p_del">-	ret = check_entry((struct arpt_entry *)e, name);</span>
<span class="p_add">+	if (!arp_checkentry(&amp;e-&gt;arp))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xt_compat_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+					    e-&gt;next_offset);</span>
 	if (ret)
 		return ret;
 
<span class="p_chunk">@@ -1270,17 +1250,6 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_arpt_entry *e,</span>
 	if (ret)
 		goto release_target;
 
<span class="p_del">-	/* Check hooks &amp; underflows */</span>
<span class="p_del">-	for (h = 0; h &lt; NF_ARP_NUMHOOKS; h++) {</span>
<span class="p_del">-		if ((unsigned char *)e - base == hook_entries[h])</span>
<span class="p_del">-			newinfo-&gt;hook_entry[h] = hook_entries[h];</span>
<span class="p_del">-		if ((unsigned char *)e - base == underflows[h])</span>
<span class="p_del">-			newinfo-&gt;underflow[h] = underflows[h];</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear counters and comefrom */</span>
<span class="p_del">-	memset(&amp;e-&gt;counters, 0, sizeof(e-&gt;counters));</span>
<span class="p_del">-	e-&gt;comefrom = 0;</span>
 	return 0;
 
 release_target:
<span class="p_chunk">@@ -1289,18 +1258,17 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_del">-static int</span>
<span class="p_add">+static void</span>
 compat_copy_entry_from_user(struct compat_arpt_entry *e, void **dstptr,
<span class="p_del">-			    unsigned int *size, const char *name,</span>
<span class="p_add">+			    unsigned int *size,</span>
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	struct arpt_entry *de;
 	unsigned int origsize;
<span class="p_del">-	int ret, h;</span>
<span class="p_add">+	int h;</span>
 
<span class="p_del">-	ret = 0;</span>
 	origsize = *size;
 	de = (struct arpt_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct arpt_entry));
<span class="p_chunk">@@ -1321,148 +1289,82 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_arpt_entry *e, void **dstptr,</span>
 		if ((unsigned char *)de - base &lt; newinfo-&gt;underflow[h])
 			newinfo-&gt;underflow[h] -= origsize - *size;
 	}
<span class="p_del">-	return ret;</span>
 }
 
<span class="p_del">-static int translate_compat_table(const char *name,</span>
<span class="p_del">-				  unsigned int valid_hooks,</span>
<span class="p_del">-				  struct xt_table_info **pinfo,</span>
<span class="p_add">+static int translate_compat_table(struct xt_table_info **pinfo,</span>
 				  void **pentry0,
<span class="p_del">-				  unsigned int total_size,</span>
<span class="p_del">-				  unsigned int number,</span>
<span class="p_del">-				  unsigned int *hook_entries,</span>
<span class="p_del">-				  unsigned int *underflows)</span>
<span class="p_add">+				  const struct compat_arpt_replace *compatr)</span>
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_arpt_entry *iter0;
<span class="p_del">-	struct arpt_entry *iter1;</span>
<span class="p_add">+	struct arpt_replace repl;</span>
 	unsigned int size;
 	int ret = 0;
 
 	info = *pinfo;
 	entry0 = *pentry0;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	info-&gt;number = number;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Init all hooks to impossible value. */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {</span>
<span class="p_del">-		info-&gt;hook_entry[i] = 0xFFFFFFFF;</span>
<span class="p_del">-		info-&gt;underflow[i] = 0xFFFFFFFF;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	info-&gt;number = compatr-&gt;num_entries;</span>
 
 	duprintf(&quot;translate_compat_table: size %u\n&quot;, info-&gt;size);
 	j = 0;
 	xt_compat_lock(NFPROTO_ARP);
<span class="p_del">-	xt_compat_init_offsets(NFPROTO_ARP, number);</span>
<span class="p_add">+	xt_compat_init_offsets(NFPROTO_ARP, compatr-&gt;num_entries);</span>
 	/* Walk through entries, checking offsets. */
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,
 							entry0,
<span class="p_del">-							entry0 + total_size,</span>
<span class="p_del">-							hook_entries,</span>
<span class="p_del">-							underflows,</span>
<span class="p_del">-							name);</span>
<span class="p_add">+							entry0 + compatr-&gt;size);</span>
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
<span class="p_del">-	if (j != number) {</span>
<span class="p_add">+	if (j != compatr-&gt;num_entries) {</span>
 		duprintf(&quot;translate_compat_table: %u not %u entries\n&quot;,
<span class="p_del">-			 j, number);</span>
<span class="p_add">+			 j, compatr-&gt;num_entries);</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/* Check hooks all assigned */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {</span>
<span class="p_del">-		/* Only hooks which are valid */</span>
<span class="p_del">-		if (!(valid_hooks &amp; (1 &lt;&lt; i)))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (info-&gt;hook_entry[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid hook entry %u %u\n&quot;,</span>
<span class="p_del">-				 i, hook_entries[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (info-&gt;underflow[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid underflow %u %u\n&quot;,</span>
<span class="p_del">-				 i, underflows[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
<span class="p_del">-	newinfo-&gt;number = number;</span>
<span class="p_add">+	newinfo-&gt;number = compatr-&gt;num_entries;</span>
 	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {
 		newinfo-&gt;hook_entry[i] = info-&gt;hook_entry[i];
 		newinfo-&gt;underflow[i] = info-&gt;underflow[i];
 	}
 	entry1 = newinfo-&gt;entries;
 	pos = entry1;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_del">-		ret = compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_del">-						  name, newinfo, entry1);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size)</span>
<span class="p_add">+		compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_add">+					    newinfo, entry1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all module references in entry0 are now gone */</span>
<span class="p_add">+</span>
 	xt_compat_flush_offsets(NFPROTO_ARP);
 	xt_compat_unlock(NFPROTO_ARP);
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto free_newinfo;</span>
 
<span class="p_del">-	ret = -ELOOP;</span>
<span class="p_del">-	if (!mark_source_chains(newinfo, valid_hooks, entry1))</span>
<span class="p_del">-		goto free_newinfo;</span>
<span class="p_add">+	memcpy(&amp;repl, compatr, sizeof(*compatr));</span>
 
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-		iter1-&gt;counters.pcnt = xt_percpu_counter_alloc();</span>
<span class="p_del">-		if (IS_ERR_VALUE(iter1-&gt;counters.pcnt)) {</span>
<span class="p_del">-			ret = -ENOMEM;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = check_target(iter1, name);</span>
<span class="p_del">-		if (ret != 0) {</span>
<span class="p_del">-			xt_percpu_counter_free(iter1-&gt;counters.pcnt);</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		++i;</span>
<span class="p_del">-		if (strcmp(arpt_get_target(iter1)-&gt;u.user.name,</span>
<span class="p_del">-		    XT_ERROR_TARGET) == 0)</span>
<span class="p_del">-			++newinfo-&gt;stacksize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The first i matches need cleanup_entry (calls -&gt;destroy)</span>
<span class="p_del">-		 * because they had called -&gt;check already. The other j-i</span>
<span class="p_del">-		 * entries need only release.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		int skip = i;</span>
<span class="p_del">-		j -= i;</span>
<span class="p_del">-		xt_entry_foreach(iter0, entry0, newinfo-&gt;size) {</span>
<span class="p_del">-			if (skip-- &gt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			if (j-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			compat_release_entry(iter0);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-			if (i-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			cleanup_entry(iter1);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_free_table_info(newinfo);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {</span>
<span class="p_add">+		repl.hook_entry[i] = newinfo-&gt;hook_entry[i];</span>
<span class="p_add">+		repl.underflow[i] = newinfo-&gt;underflow[i];</span>
 	}
 
<span class="p_add">+	repl.num_counters = 0;</span>
<span class="p_add">+	repl.counters = NULL;</span>
<span class="p_add">+	repl.size = newinfo-&gt;size;</span>
<span class="p_add">+	ret = translate_table(newinfo, entry1, &amp;repl);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto free_newinfo;</span>
<span class="p_add">+</span>
 	*pinfo = newinfo;
 	*pentry0 = entry1;
 	xt_free_table_info(info);
<span class="p_chunk">@@ -1470,31 +1372,18 @@</span> <span class="p_context"> static int translate_compat_table(const char *name,</span>
 
 free_newinfo:
 	xt_free_table_info(newinfo);
<span class="p_del">-out:</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	xt_compat_flush_offsets(NFPROTO_ARP);</span>
<span class="p_add">+	xt_compat_unlock(NFPROTO_ARP);</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
<span class="p_del">-out_unlock:</span>
<span class="p_del">-	xt_compat_flush_offsets(NFPROTO_ARP);</span>
<span class="p_del">-	xt_compat_unlock(NFPROTO_ARP);</span>
<span class="p_del">-	goto out;</span>
 }
 
<span class="p_del">-struct compat_arpt_replace {</span>
<span class="p_del">-	char				name[XT_TABLE_MAXNAMELEN];</span>
<span class="p_del">-	u32				valid_hooks;</span>
<span class="p_del">-	u32				num_entries;</span>
<span class="p_del">-	u32				size;</span>
<span class="p_del">-	u32				hook_entry[NF_ARP_NUMHOOKS];</span>
<span class="p_del">-	u32				underflow[NF_ARP_NUMHOOKS];</span>
<span class="p_del">-	u32				num_counters;</span>
<span class="p_del">-	compat_uptr_t			counters;</span>
<span class="p_del">-	struct compat_arpt_entry	entries[0];</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static int compat_do_replace(struct net *net, void __user *user,
 			     unsigned int len)
 {
<span class="p_chunk">@@ -1527,10 +1416,7 @@</span> <span class="p_context"> static int compat_do_replace(struct net *net, void __user *user,</span>
 		goto free_newinfo;
 	}
 
<span class="p_del">-	ret = translate_compat_table(tmp.name, tmp.valid_hooks,</span>
<span class="p_del">-				     &amp;newinfo, &amp;loc_cpu_entry, tmp.size,</span>
<span class="p_del">-				     tmp.num_entries, tmp.hook_entry,</span>
<span class="p_del">-				     tmp.underflow);</span>
<span class="p_add">+	ret = translate_compat_table(&amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span>
 	if (ret != 0)
 		goto free_newinfo;
 
<span class="p_header">diff --git a/net/ipv4/netfilter/ip_tables.c b/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_header">index b99affad6ba1..a399c5419622 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/ip_tables.c</span>
<span class="p_chunk">@@ -168,11 +168,12 @@</span> <span class="p_context"> get_entry(const void *base, unsigned int offset)</span>
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
<span class="p_del">-static inline bool unconditional(const struct ipt_ip *ip)</span>
<span class="p_add">+static inline bool unconditional(const struct ipt_entry *e)</span>
 {
 	static const struct ipt_ip uncond;
 
<span class="p_del">-	return memcmp(ip, &amp;uncond, sizeof(uncond)) == 0;</span>
<span class="p_add">+	return e-&gt;target_offset == sizeof(struct ipt_entry) &amp;&amp;</span>
<span class="p_add">+	       memcmp(&amp;e-&gt;ip, &amp;uncond, sizeof(uncond)) == 0;</span>
 #undef FWINV
 }
 
<span class="p_chunk">@@ -229,11 +230,10 @@</span> <span class="p_context"> get_chainname_rulenum(const struct ipt_entry *s, const struct ipt_entry *e,</span>
 	} else if (s == e) {
 		(*rulenum)++;
 
<span class="p_del">-		if (s-&gt;target_offset == sizeof(struct ipt_entry) &amp;&amp;</span>
<span class="p_add">+		if (unconditional(s) &amp;&amp;</span>
 		    strcmp(t-&gt;target.u.kernel.target-&gt;name,
 			   XT_STANDARD_TARGET) == 0 &amp;&amp;
<span class="p_del">-		   t-&gt;verdict &lt; 0 &amp;&amp;</span>
<span class="p_del">-		   unconditional(&amp;s-&gt;ip)) {</span>
<span class="p_add">+		   t-&gt;verdict &lt; 0) {</span>
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP_TRACE_COMMENT_POLICY]
<span class="p_chunk">@@ -443,6 +443,18 @@</span> <span class="p_context"> ipt_do_table(struct sk_buff *skb,</span>
 #endif
 }
 
<span class="p_add">+static bool find_jump_target(const struct xt_table_info *t,</span>
<span class="p_add">+			     const struct ipt_entry *target)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ipt_entry *iter;</span>
<span class="p_add">+</span>
<span class="p_add">+	xt_entry_foreach(iter, t-&gt;entries, t-&gt;size) {</span>
<span class="p_add">+		 if (iter == target)</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Figures out from what hook each rule can be called: returns 0 if
    there are loops.  Puts hook bitmask in comefrom. */
 static int
<span class="p_chunk">@@ -476,11 +488,10 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 			e-&gt;comefrom |= ((1 &lt;&lt; hook) | (1 &lt;&lt; NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
<span class="p_del">-			if ((e-&gt;target_offset == sizeof(struct ipt_entry) &amp;&amp;</span>
<span class="p_add">+			if ((unconditional(e) &amp;&amp;</span>
 			     (strcmp(t-&gt;target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &amp;&amp;
<span class="p_del">-			     t-&gt;verdict &lt; 0 &amp;&amp; unconditional(&amp;e-&gt;ip)) ||</span>
<span class="p_del">-			    visited) {</span>
<span class="p_add">+			     t-&gt;verdict &lt; 0) || visited) {</span>
 				unsigned int oldpos, size;
 
 				if ((strcmp(t-&gt;target.u.user.name,
<span class="p_chunk">@@ -521,6 +532,8 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 				size = e-&gt;next_offset;
 				e = (struct ipt_entry *)
 					(entry0 + pos + size);
<span class="p_add">+				if (pos + size &gt;= newinfo-&gt;size)</span>
<span class="p_add">+					return 0;</span>
 				e-&gt;counters.pcnt = pos;
 				pos += size;
 			} else {
<span class="p_chunk">@@ -539,9 +552,15 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 					/* This a jump; chase it. */
 					duprintf(&quot;Jump rule %u -&gt; %u\n&quot;,
 						 pos, newpos);
<span class="p_add">+					e = (struct ipt_entry *)</span>
<span class="p_add">+						(entry0 + newpos);</span>
<span class="p_add">+					if (!find_jump_target(newinfo, e))</span>
<span class="p_add">+						return 0;</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_add">+					if (newpos &gt;= newinfo-&gt;size)</span>
<span class="p_add">+						return 0;</span>
 				}
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
<span class="p_chunk">@@ -569,27 +588,6 @@</span> <span class="p_context"> static void cleanup_match(struct xt_entry_match *m, struct net *net)</span>
 }
 
 static int
<span class="p_del">-check_entry(const struct ipt_entry *e, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct xt_entry_target *t;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ip_checkentry(&amp;e-&gt;ip)) {</span>
<span class="p_del">-		duprintf(&quot;ip check failed %p %s.\n&quot;, e, name);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (e-&gt;target_offset + sizeof(struct xt_entry_target) &gt;</span>
<span class="p_del">-	    e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	t = ipt_get_target_c(e);</span>
<span class="p_del">-	if (e-&gt;target_offset + t-&gt;u.target_size &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int</span>
 check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 {
 	const struct ipt_ip *ip = par-&gt;entryinfo;
<span class="p_chunk">@@ -666,10 +664,6 @@</span> <span class="p_context"> find_check_entry(struct ipt_entry *e, struct net *net, const char *name,</span>
 	struct xt_mtchk_param mtpar;
 	struct xt_entry_match *ematch;
 
<span class="p_del">-	ret = check_entry(e, name);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
 	e-&gt;counters.pcnt = xt_percpu_counter_alloc();
 	if (IS_ERR_VALUE(e-&gt;counters.pcnt))
 		return -ENOMEM;
<span class="p_chunk">@@ -721,7 +715,7 @@</span> <span class="p_context"> static bool check_underflow(const struct ipt_entry *e)</span>
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
<span class="p_del">-	if (!unconditional(&amp;e-&gt;ip))</span>
<span class="p_add">+	if (!unconditional(e))</span>
 		return false;
 	t = ipt_get_target_c(e);
 	if (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) != 0)
<span class="p_chunk">@@ -741,9 +735,11 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ipt_entry *e,</span>
 			   unsigned int valid_hooks)
 {
 	unsigned int h;
<span class="p_add">+	int err;</span>
 
 	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0 ||
<span class="p_del">-	    (unsigned char *)e + sizeof(struct ipt_entry) &gt;= limit) {</span>
<span class="p_add">+	    (unsigned char *)e + sizeof(struct ipt_entry) &gt;= limit ||</span>
<span class="p_add">+	    (unsigned char *)e + e-&gt;next_offset &gt; limit) {</span>
 		duprintf(&quot;Bad offset %p\n&quot;, e);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -755,6 +751,14 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ipt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	if (!ip_checkentry(&amp;e-&gt;ip))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = xt_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+				     e-&gt;next_offset);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	/* Check hooks &amp; underflows */
 	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {
 		if (!(valid_hooks &amp; (1 &lt;&lt; h)))
<span class="p_chunk">@@ -763,9 +767,9 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ipt_entry *e,</span>
 			newinfo-&gt;hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
<span class="p_del">-				pr_err(&quot;Underflows must be unconditional and &quot;</span>
<span class="p_del">-				       &quot;use the STANDARD target with &quot;</span>
<span class="p_del">-				       &quot;ACCEPT/DROP\n&quot;);</span>
<span class="p_add">+				pr_debug(&quot;Underflows must be unconditional and &quot;</span>
<span class="p_add">+					 &quot;use the STANDARD target with &quot;</span>
<span class="p_add">+					 &quot;ACCEPT/DROP\n&quot;);</span>
 				return -EINVAL;
 			}
 			newinfo-&gt;underflow[h] = underflows[h];
<span class="p_chunk">@@ -1309,55 +1313,17 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user,</span>
 	unsigned int i;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
<span class="p_del">-	unsigned int num_counters;</span>
<span class="p_del">-	const char *name;</span>
<span class="p_del">-	int size;</span>
<span class="p_del">-	void *ptmp;</span>
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	struct ipt_entry *iter;
 	unsigned int addend;
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	struct compat_xt_counters_info compat_tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		ptmp = &amp;compat_tmp;</span>
<span class="p_del">-		size = sizeof(struct compat_xt_counters_info);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ptmp = &amp;tmp;</span>
<span class="p_del">-		size = sizeof(struct xt_counters_info);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(ptmp, user, size) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		num_counters = compat_tmp.num_counters;</span>
<span class="p_del">-		name = compat_tmp.name;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		num_counters = tmp.num_counters;</span>
<span class="p_del">-		name = tmp.name;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	if (len != size + num_counters * sizeof(struct xt_counters))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	paddc = vmalloc(len - size);</span>
<span class="p_del">-	if (!paddc)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	paddc = xt_copy_counters_from_user(user, len, &amp;tmp, compat);</span>
<span class="p_add">+	if (IS_ERR(paddc))</span>
<span class="p_add">+		return PTR_ERR(paddc);</span>
 
<span class="p_del">-	if (copy_from_user(paddc, user + size, len - size) != 0) {</span>
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto free;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	t = xt_find_table_lock(net, AF_INET, name);</span>
<span class="p_add">+	t = xt_find_table_lock(net, AF_INET, tmp.name);</span>
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
<span class="p_chunk">@@ -1365,7 +1331,7 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user,</span>
 
 	local_bh_disable();
 	private = t-&gt;private;
<span class="p_del">-	if (private-&gt;number != num_counters) {</span>
<span class="p_add">+	if (private-&gt;number != tmp.num_counters) {</span>
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
<span class="p_chunk">@@ -1444,7 +1410,6 @@</span> <span class="p_context"> compat_copy_entry_to_user(struct ipt_entry *e, void __user **dstptr,</span>
 
 static int
 compat_find_calc_match(struct xt_entry_match *m,
<span class="p_del">-		       const char *name,</span>
 		       const struct ipt_ip *ip,
 		       int *size)
 {
<span class="p_chunk">@@ -1479,21 +1444,19 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
<span class="p_del">-				  const unsigned char *limit,</span>
<span class="p_del">-				  const unsigned int *hook_entries,</span>
<span class="p_del">-				  const unsigned int *underflows,</span>
<span class="p_del">-				  const char *name)</span>
<span class="p_add">+				  const unsigned char *limit)</span>
 {
 	struct xt_entry_match *ematch;
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
 	unsigned int j;
<span class="p_del">-	int ret, off, h;</span>
<span class="p_add">+	int ret, off;</span>
 
 	duprintf(&quot;check_compat_entry_size_and_hooks %p\n&quot;, e);
 	if ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||
<span class="p_del">-	    (unsigned char *)e + sizeof(struct compat_ipt_entry) &gt;= limit) {</span>
<span class="p_add">+	    (unsigned char *)e + sizeof(struct compat_ipt_entry) &gt;= limit ||</span>
<span class="p_add">+	    (unsigned char *)e + e-&gt;next_offset &gt; limit) {</span>
 		duprintf(&quot;Bad offset %p, limit = %p\n&quot;, e, limit);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -1505,8 +1468,11 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* For purposes of check_entry casting the compat entry is fine */</span>
<span class="p_del">-	ret = check_entry((struct ipt_entry *)e, name);</span>
<span class="p_add">+	if (!ip_checkentry(&amp;e-&gt;ip))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xt_compat_check_entry_offsets(e, e-&gt;elems,</span>
<span class="p_add">+					    e-&gt;target_offset, e-&gt;next_offset);</span>
 	if (ret)
 		return ret;
 
<span class="p_chunk">@@ -1514,7 +1480,7 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 	entry_offset = (void *)e - (void *)base;
 	j = 0;
 	xt_ematch_foreach(ematch, e) {
<span class="p_del">-		ret = compat_find_calc_match(ematch, name, &amp;e-&gt;ip, &amp;off);</span>
<span class="p_add">+		ret = compat_find_calc_match(ematch, &amp;e-&gt;ip, &amp;off);</span>
 		if (ret != 0)
 			goto release_matches;
 		++j;
<span class="p_chunk">@@ -1537,17 +1503,6 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ipt_entry *e,</span>
 	if (ret)
 		goto out;
 
<span class="p_del">-	/* Check hooks &amp; underflows */</span>
<span class="p_del">-	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {</span>
<span class="p_del">-		if ((unsigned char *)e - base == hook_entries[h])</span>
<span class="p_del">-			newinfo-&gt;hook_entry[h] = hook_entries[h];</span>
<span class="p_del">-		if ((unsigned char *)e - base == underflows[h])</span>
<span class="p_del">-			newinfo-&gt;underflow[h] = underflows[h];</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear counters and comefrom */</span>
<span class="p_del">-	memset(&amp;e-&gt;counters, 0, sizeof(e-&gt;counters));</span>
<span class="p_del">-	e-&gt;comefrom = 0;</span>
 	return 0;
 
 out:
<span class="p_chunk">@@ -1561,19 +1516,18 @@</span> <span class="p_context"> release_matches:</span>
 	return ret;
 }
 
<span class="p_del">-static int</span>
<span class="p_add">+static void</span>
 compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,
<span class="p_del">-			    unsigned int *size, const char *name,</span>
<span class="p_add">+			    unsigned int *size,</span>
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	struct ipt_entry *de;
 	unsigned int origsize;
<span class="p_del">-	int ret, h;</span>
<span class="p_add">+	int h;</span>
 	struct xt_entry_match *ematch;
 
<span class="p_del">-	ret = 0;</span>
 	origsize = *size;
 	de = (struct ipt_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct ipt_entry));
<span class="p_chunk">@@ -1582,201 +1536,105 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_ipt_entry *e, void **dstptr,</span>
 	*dstptr += sizeof(struct ipt_entry);
 	*size += sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);
 
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	xt_ematch_foreach(ematch, e)</span>
<span class="p_add">+		xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_add">+</span>
 	de-&gt;target_offset = e-&gt;target_offset - (origsize - *size);
 	t = compat_ipt_get_target(e);
 	target = t-&gt;u.kernel.target;
 	xt_compat_target_from_user(t, dstptr, size);
 
 	de-&gt;next_offset = e-&gt;next_offset - (origsize - *size);
<span class="p_add">+</span>
 	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {
 		if ((unsigned char *)de - base &lt; newinfo-&gt;hook_entry[h])
 			newinfo-&gt;hook_entry[h] -= origsize - *size;
 		if ((unsigned char *)de - base &lt; newinfo-&gt;underflow[h])
 			newinfo-&gt;underflow[h] -= origsize - *size;
 	}
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int</span>
<span class="p_del">-compat_check_entry(struct ipt_entry *e, struct net *net, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct xt_entry_match *ematch;</span>
<span class="p_del">-	struct xt_mtchk_param mtpar;</span>
<span class="p_del">-	unsigned int j;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	e-&gt;counters.pcnt = xt_percpu_counter_alloc();</span>
<span class="p_del">-	if (IS_ERR_VALUE(e-&gt;counters.pcnt))</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	j = 0;</span>
<span class="p_del">-	mtpar.net	= net;</span>
<span class="p_del">-	mtpar.table     = name;</span>
<span class="p_del">-	mtpar.entryinfo = &amp;e-&gt;ip;</span>
<span class="p_del">-	mtpar.hook_mask = e-&gt;comefrom;</span>
<span class="p_del">-	mtpar.family    = NFPROTO_IPV4;</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = check_match(ematch, &amp;mtpar);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			goto cleanup_matches;</span>
<span class="p_del">-		++j;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = check_target(e, net, name);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto cleanup_matches;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">- cleanup_matches:</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		if (j-- == 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		cleanup_match(ematch, net);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	xt_percpu_counter_free(e-&gt;counters.pcnt);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
 }
 
 static int
 translate_compat_table(struct net *net,
<span class="p_del">-		       const char *name,</span>
<span class="p_del">-		       unsigned int valid_hooks,</span>
 		       struct xt_table_info **pinfo,
 		       void **pentry0,
<span class="p_del">-		       unsigned int total_size,</span>
<span class="p_del">-		       unsigned int number,</span>
<span class="p_del">-		       unsigned int *hook_entries,</span>
<span class="p_del">-		       unsigned int *underflows)</span>
<span class="p_add">+		       const struct compat_ipt_replace *compatr)</span>
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_ipt_entry *iter0;
<span class="p_del">-	struct ipt_entry *iter1;</span>
<span class="p_add">+	struct ipt_replace repl;</span>
 	unsigned int size;
 	int ret;
 
 	info = *pinfo;
 	entry0 = *pentry0;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	info-&gt;number = number;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Init all hooks to impossible value. */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		info-&gt;hook_entry[i] = 0xFFFFFFFF;</span>
<span class="p_del">-		info-&gt;underflow[i] = 0xFFFFFFFF;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	info-&gt;number = compatr-&gt;num_entries;</span>
 
 	duprintf(&quot;translate_compat_table: size %u\n&quot;, info-&gt;size);
 	j = 0;
 	xt_compat_lock(AF_INET);
<span class="p_del">-	xt_compat_init_offsets(AF_INET, number);</span>
<span class="p_add">+	xt_compat_init_offsets(AF_INET, compatr-&gt;num_entries);</span>
 	/* Walk through entries, checking offsets. */
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,
 							entry0,
<span class="p_del">-							entry0 + total_size,</span>
<span class="p_del">-							hook_entries,</span>
<span class="p_del">-							underflows,</span>
<span class="p_del">-							name);</span>
<span class="p_add">+							entry0 + compatr-&gt;size);</span>
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
<span class="p_del">-	if (j != number) {</span>
<span class="p_add">+	if (j != compatr-&gt;num_entries) {</span>
 		duprintf(&quot;translate_compat_table: %u not %u entries\n&quot;,
<span class="p_del">-			 j, number);</span>
<span class="p_add">+			 j, compatr-&gt;num_entries);</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/* Check hooks all assigned */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		/* Only hooks which are valid */</span>
<span class="p_del">-		if (!(valid_hooks &amp; (1 &lt;&lt; i)))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (info-&gt;hook_entry[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid hook entry %u %u\n&quot;,</span>
<span class="p_del">-				 i, hook_entries[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (info-&gt;underflow[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid underflow %u %u\n&quot;,</span>
<span class="p_del">-				 i, underflows[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
<span class="p_del">-	newinfo-&gt;number = number;</span>
<span class="p_add">+	newinfo-&gt;number = compatr-&gt;num_entries;</span>
 	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {
<span class="p_del">-		newinfo-&gt;hook_entry[i] = info-&gt;hook_entry[i];</span>
<span class="p_del">-		newinfo-&gt;underflow[i] = info-&gt;underflow[i];</span>
<span class="p_add">+		newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span>
<span class="p_add">+		newinfo-&gt;underflow[i] = compatr-&gt;underflow[i];</span>
 	}
 	entry1 = newinfo-&gt;entries;
 	pos = entry1;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_del">-		ret = compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_del">-						  name, newinfo, entry1);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size)</span>
<span class="p_add">+		compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_add">+					    newinfo, entry1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all module references in entry0 are now gone.</span>
<span class="p_add">+	 * entry1/newinfo contains a 64bit ruleset that looks exactly as</span>
<span class="p_add">+	 * generated by 64bit userspace.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Call standard translate_table() to validate all hook_entrys,</span>
<span class="p_add">+	 * underflows, check for loops, etc.</span>
<span class="p_add">+	 */</span>
 	xt_compat_flush_offsets(AF_INET);
 	xt_compat_unlock(AF_INET);
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto free_newinfo;</span>
 
<span class="p_del">-	ret = -ELOOP;</span>
<span class="p_del">-	if (!mark_source_chains(newinfo, valid_hooks, entry1))</span>
<span class="p_del">-		goto free_newinfo;</span>
<span class="p_add">+	memcpy(&amp;repl, compatr, sizeof(*compatr));</span>
 
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-		ret = compat_check_entry(iter1, net, name);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		++i;</span>
<span class="p_del">-		if (strcmp(ipt_get_target(iter1)-&gt;u.user.name,</span>
<span class="p_del">-		    XT_ERROR_TARGET) == 0)</span>
<span class="p_del">-			++newinfo-&gt;stacksize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The first i matches need cleanup_entry (calls -&gt;destroy)</span>
<span class="p_del">-		 * because they had called -&gt;check already. The other j-i</span>
<span class="p_del">-		 * entries need only release.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		int skip = i;</span>
<span class="p_del">-		j -= i;</span>
<span class="p_del">-		xt_entry_foreach(iter0, entry0, newinfo-&gt;size) {</span>
<span class="p_del">-			if (skip-- &gt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			if (j-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			compat_release_entry(iter0);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-			if (i-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			cleanup_entry(iter1, net);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_free_table_info(newinfo);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_add">+		repl.hook_entry[i] = newinfo-&gt;hook_entry[i];</span>
<span class="p_add">+		repl.underflow[i] = newinfo-&gt;underflow[i];</span>
 	}
 
<span class="p_add">+	repl.num_counters = 0;</span>
<span class="p_add">+	repl.counters = NULL;</span>
<span class="p_add">+	repl.size = newinfo-&gt;size;</span>
<span class="p_add">+	ret = translate_table(net, newinfo, entry1, &amp;repl);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto free_newinfo;</span>
<span class="p_add">+</span>
 	*pinfo = newinfo;
 	*pentry0 = entry1;
 	xt_free_table_info(info);
<span class="p_chunk">@@ -1784,17 +1642,16 @@</span> <span class="p_context"> translate_compat_table(struct net *net,</span>
 
 free_newinfo:
 	xt_free_table_info(newinfo);
<span class="p_del">-out:</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	xt_compat_flush_offsets(AF_INET);</span>
<span class="p_add">+	xt_compat_unlock(AF_INET);</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
<span class="p_del">-out_unlock:</span>
<span class="p_del">-	xt_compat_flush_offsets(AF_INET);</span>
<span class="p_del">-	xt_compat_unlock(AF_INET);</span>
<span class="p_del">-	goto out;</span>
 }
 
 static int
<span class="p_chunk">@@ -1830,10 +1687,7 @@</span> <span class="p_context"> compat_do_replace(struct net *net, void __user *user, unsigned int len)</span>
 		goto free_newinfo;
 	}
 
<span class="p_del">-	ret = translate_compat_table(net, tmp.name, tmp.valid_hooks,</span>
<span class="p_del">-				     &amp;newinfo, &amp;loc_cpu_entry, tmp.size,</span>
<span class="p_del">-				     tmp.num_entries, tmp.hook_entry,</span>
<span class="p_del">-				     tmp.underflow);</span>
<span class="p_add">+	ret = translate_compat_table(net, &amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span>
 	if (ret != 0)
 		goto free_newinfo;
 
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index 21fbb54f11d0..44e1632370dd 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1531,7 +1531,7 @@</span> <span class="p_context"> int udp_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 
 		/* if we&#39;re overly short, let UDP handle it */
 		encap_rcv = ACCESS_ONCE(up-&gt;encap_rcv);
<span class="p_del">-		if (skb-&gt;len &gt; sizeof(struct udphdr) &amp;&amp; encap_rcv) {</span>
<span class="p_add">+		if (encap_rcv) {</span>
 			int ret;
 
 			/* Verify checksum before giving to encap */
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index a175152d3e46..58900c21e4e4 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1072,17 +1072,12 @@</span> <span class="p_context"> struct dst_entry *ip6_sk_dst_lookup_flow(struct sock *sk, struct flowi6 *fl6,</span>
 					 const struct in6_addr *final_dst)
 {
 	struct dst_entry *dst = sk_dst_check(sk, inet6_sk(sk)-&gt;dst_cookie);
<span class="p_del">-	int err;</span>
 
 	dst = ip6_sk_dst_check(sk, dst, fl6);
<span class="p_add">+	if (!dst)</span>
<span class="p_add">+		dst = ip6_dst_lookup_flow(sk, fl6, final_dst);</span>
 
<span class="p_del">-	err = ip6_dst_lookup_tail(sock_net(sk), sk, &amp;dst, fl6);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return ERR_PTR(err);</span>
<span class="p_del">-	if (final_dst)</span>
<span class="p_del">-		fl6-&gt;daddr = *final_dst;</span>
<span class="p_del">-</span>
<span class="p_del">-	return xfrm_lookup_route(sock_net(sk), dst, flowi6_to_flowi(fl6), sk, 0);</span>
<span class="p_add">+	return dst;</span>
 }
 EXPORT_SYMBOL_GPL(ip6_sk_dst_lookup_flow);
 
<span class="p_header">diff --git a/net/ipv6/netfilter/ip6_tables.c b/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_header">index 99425cf2819b..22f39e00bef3 100644</span>
<span class="p_header">--- a/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_header">+++ b/net/ipv6/netfilter/ip6_tables.c</span>
<span class="p_chunk">@@ -198,11 +198,12 @@</span> <span class="p_context"> get_entry(const void *base, unsigned int offset)</span>
 
 /* All zeroes == unconditional rule. */
 /* Mildly perf critical (only if packet tracing is on) */
<span class="p_del">-static inline bool unconditional(const struct ip6t_ip6 *ipv6)</span>
<span class="p_add">+static inline bool unconditional(const struct ip6t_entry *e)</span>
 {
 	static const struct ip6t_ip6 uncond;
 
<span class="p_del">-	return memcmp(ipv6, &amp;uncond, sizeof(uncond)) == 0;</span>
<span class="p_add">+	return e-&gt;target_offset == sizeof(struct ip6t_entry) &amp;&amp;</span>
<span class="p_add">+	       memcmp(&amp;e-&gt;ipv6, &amp;uncond, sizeof(uncond)) == 0;</span>
 }
 
 static inline const struct xt_entry_target *
<span class="p_chunk">@@ -258,11 +259,10 @@</span> <span class="p_context"> get_chainname_rulenum(const struct ip6t_entry *s, const struct ip6t_entry *e,</span>
 	} else if (s == e) {
 		(*rulenum)++;
 
<span class="p_del">-		if (s-&gt;target_offset == sizeof(struct ip6t_entry) &amp;&amp;</span>
<span class="p_add">+		if (unconditional(s) &amp;&amp;</span>
 		    strcmp(t-&gt;target.u.kernel.target-&gt;name,
 			   XT_STANDARD_TARGET) == 0 &amp;&amp;
<span class="p_del">-		    t-&gt;verdict &lt; 0 &amp;&amp;</span>
<span class="p_del">-		    unconditional(&amp;s-&gt;ipv6)) {</span>
<span class="p_add">+		    t-&gt;verdict &lt; 0) {</span>
 			/* Tail of chains: STANDARD target (return/policy) */
 			*comment = *chainname == hookname
 				? comments[NF_IP6_TRACE_COMMENT_POLICY]
<span class="p_chunk">@@ -455,6 +455,18 @@</span> <span class="p_context"> ip6t_do_table(struct sk_buff *skb,</span>
 #endif
 }
 
<span class="p_add">+static bool find_jump_target(const struct xt_table_info *t,</span>
<span class="p_add">+			     const struct ip6t_entry *target)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ip6t_entry *iter;</span>
<span class="p_add">+</span>
<span class="p_add">+	xt_entry_foreach(iter, t-&gt;entries, t-&gt;size) {</span>
<span class="p_add">+		 if (iter == target)</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Figures out from what hook each rule can be called: returns 0 if
    there are loops.  Puts hook bitmask in comefrom. */
 static int
<span class="p_chunk">@@ -488,11 +500,10 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 			e-&gt;comefrom |= ((1 &lt;&lt; hook) | (1 &lt;&lt; NF_INET_NUMHOOKS));
 
 			/* Unconditional return/END. */
<span class="p_del">-			if ((e-&gt;target_offset == sizeof(struct ip6t_entry) &amp;&amp;</span>
<span class="p_add">+			if ((unconditional(e) &amp;&amp;</span>
 			     (strcmp(t-&gt;target.u.user.name,
 				     XT_STANDARD_TARGET) == 0) &amp;&amp;
<span class="p_del">-			     t-&gt;verdict &lt; 0 &amp;&amp;</span>
<span class="p_del">-			     unconditional(&amp;e-&gt;ipv6)) || visited) {</span>
<span class="p_add">+			     t-&gt;verdict &lt; 0) || visited) {</span>
 				unsigned int oldpos, size;
 
 				if ((strcmp(t-&gt;target.u.user.name,
<span class="p_chunk">@@ -533,6 +544,8 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 				size = e-&gt;next_offset;
 				e = (struct ip6t_entry *)
 					(entry0 + pos + size);
<span class="p_add">+				if (pos + size &gt;= newinfo-&gt;size)</span>
<span class="p_add">+					return 0;</span>
 				e-&gt;counters.pcnt = pos;
 				pos += size;
 			} else {
<span class="p_chunk">@@ -551,9 +564,15 @@</span> <span class="p_context"> mark_source_chains(const struct xt_table_info *newinfo,</span>
 					/* This a jump; chase it. */
 					duprintf(&quot;Jump rule %u -&gt; %u\n&quot;,
 						 pos, newpos);
<span class="p_add">+					e = (struct ip6t_entry *)</span>
<span class="p_add">+						(entry0 + newpos);</span>
<span class="p_add">+					if (!find_jump_target(newinfo, e))</span>
<span class="p_add">+						return 0;</span>
 				} else {
 					/* ... this is a fallthru */
 					newpos = pos + e-&gt;next_offset;
<span class="p_add">+					if (newpos &gt;= newinfo-&gt;size)</span>
<span class="p_add">+						return 0;</span>
 				}
 				e = (struct ip6t_entry *)
 					(entry0 + newpos);
<span class="p_chunk">@@ -580,27 +599,6 @@</span> <span class="p_context"> static void cleanup_match(struct xt_entry_match *m, struct net *net)</span>
 	module_put(par.match-&gt;me);
 }
 
<span class="p_del">-static int</span>
<span class="p_del">-check_entry(const struct ip6t_entry *e, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const struct xt_entry_target *t;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!ip6_checkentry(&amp;e-&gt;ipv6)) {</span>
<span class="p_del">-		duprintf(&quot;ip_tables: ip check failed %p %s.\n&quot;, e, name);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (e-&gt;target_offset + sizeof(struct xt_entry_target) &gt;</span>
<span class="p_del">-	    e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	t = ip6t_get_target_c(e);</span>
<span class="p_del">-	if (e-&gt;target_offset + t-&gt;u.target_size &gt; e-&gt;next_offset)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int check_match(struct xt_entry_match *m, struct xt_mtchk_param *par)
 {
 	const struct ip6t_ip6 *ipv6 = par-&gt;entryinfo;
<span class="p_chunk">@@ -679,10 +677,6 @@</span> <span class="p_context"> find_check_entry(struct ip6t_entry *e, struct net *net, const char *name,</span>
 	struct xt_mtchk_param mtpar;
 	struct xt_entry_match *ematch;
 
<span class="p_del">-	ret = check_entry(e, name);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
 	e-&gt;counters.pcnt = xt_percpu_counter_alloc();
 	if (IS_ERR_VALUE(e-&gt;counters.pcnt))
 		return -ENOMEM;
<span class="p_chunk">@@ -733,7 +727,7 @@</span> <span class="p_context"> static bool check_underflow(const struct ip6t_entry *e)</span>
 	const struct xt_entry_target *t;
 	unsigned int verdict;
 
<span class="p_del">-	if (!unconditional(&amp;e-&gt;ipv6))</span>
<span class="p_add">+	if (!unconditional(e))</span>
 		return false;
 	t = ip6t_get_target_c(e);
 	if (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) != 0)
<span class="p_chunk">@@ -753,9 +747,11 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ip6t_entry *e,</span>
 			   unsigned int valid_hooks)
 {
 	unsigned int h;
<span class="p_add">+	int err;</span>
 
 	if ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||
<span class="p_del">-	    (unsigned char *)e + sizeof(struct ip6t_entry) &gt;= limit) {</span>
<span class="p_add">+	    (unsigned char *)e + sizeof(struct ip6t_entry) &gt;= limit ||</span>
<span class="p_add">+	    (unsigned char *)e + e-&gt;next_offset &gt; limit) {</span>
 		duprintf(&quot;Bad offset %p\n&quot;, e);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -767,6 +763,14 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ip6t_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_add">+	if (!ip6_checkentry(&amp;e-&gt;ipv6))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = xt_check_entry_offsets(e, e-&gt;elems, e-&gt;target_offset,</span>
<span class="p_add">+				     e-&gt;next_offset);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	/* Check hooks &amp; underflows */
 	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {
 		if (!(valid_hooks &amp; (1 &lt;&lt; h)))
<span class="p_chunk">@@ -775,9 +779,9 @@</span> <span class="p_context"> check_entry_size_and_hooks(struct ip6t_entry *e,</span>
 			newinfo-&gt;hook_entry[h] = hook_entries[h];
 		if ((unsigned char *)e - base == underflows[h]) {
 			if (!check_underflow(e)) {
<span class="p_del">-				pr_err(&quot;Underflows must be unconditional and &quot;</span>
<span class="p_del">-				       &quot;use the STANDARD target with &quot;</span>
<span class="p_del">-				       &quot;ACCEPT/DROP\n&quot;);</span>
<span class="p_add">+				pr_debug(&quot;Underflows must be unconditional and &quot;</span>
<span class="p_add">+					 &quot;use the STANDARD target with &quot;</span>
<span class="p_add">+					 &quot;ACCEPT/DROP\n&quot;);</span>
 				return -EINVAL;
 			}
 			newinfo-&gt;underflow[h] = underflows[h];
<span class="p_chunk">@@ -1321,55 +1325,16 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user, unsigned int len,</span>
 	unsigned int i;
 	struct xt_counters_info tmp;
 	struct xt_counters *paddc;
<span class="p_del">-	unsigned int num_counters;</span>
<span class="p_del">-	char *name;</span>
<span class="p_del">-	int size;</span>
<span class="p_del">-	void *ptmp;</span>
 	struct xt_table *t;
 	const struct xt_table_info *private;
 	int ret = 0;
 	struct ip6t_entry *iter;
 	unsigned int addend;
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	struct compat_xt_counters_info compat_tmp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		ptmp = &amp;compat_tmp;</span>
<span class="p_del">-		size = sizeof(struct compat_xt_counters_info);</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		ptmp = &amp;tmp;</span>
<span class="p_del">-		size = sizeof(struct xt_counters_info);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(ptmp, user, size) != 0)</span>
<span class="p_del">-		return -EFAULT;</span>
 
<span class="p_del">-#ifdef CONFIG_COMPAT</span>
<span class="p_del">-	if (compat) {</span>
<span class="p_del">-		num_counters = compat_tmp.num_counters;</span>
<span class="p_del">-		name = compat_tmp.name;</span>
<span class="p_del">-	} else</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{</span>
<span class="p_del">-		num_counters = tmp.num_counters;</span>
<span class="p_del">-		name = tmp.name;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (len != size + num_counters * sizeof(struct xt_counters))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	paddc = vmalloc(len - size);</span>
<span class="p_del">-	if (!paddc)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (copy_from_user(paddc, user + size, len - size) != 0) {</span>
<span class="p_del">-		ret = -EFAULT;</span>
<span class="p_del">-		goto free;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	t = xt_find_table_lock(net, AF_INET6, name);</span>
<span class="p_add">+	paddc = xt_copy_counters_from_user(user, len, &amp;tmp, compat);</span>
<span class="p_add">+	if (IS_ERR(paddc))</span>
<span class="p_add">+		return PTR_ERR(paddc);</span>
<span class="p_add">+	t = xt_find_table_lock(net, AF_INET6, tmp.name);</span>
 	if (IS_ERR_OR_NULL(t)) {
 		ret = t ? PTR_ERR(t) : -ENOENT;
 		goto free;
<span class="p_chunk">@@ -1377,7 +1342,7 @@</span> <span class="p_context"> do_add_counters(struct net *net, const void __user *user, unsigned int len,</span>
 
 	local_bh_disable();
 	private = t-&gt;private;
<span class="p_del">-	if (private-&gt;number != num_counters) {</span>
<span class="p_add">+	if (private-&gt;number != tmp.num_counters) {</span>
 		ret = -EINVAL;
 		goto unlock_up_free;
 	}
<span class="p_chunk">@@ -1456,7 +1421,6 @@</span> <span class="p_context"> compat_copy_entry_to_user(struct ip6t_entry *e, void __user **dstptr,</span>
 
 static int
 compat_find_calc_match(struct xt_entry_match *m,
<span class="p_del">-		       const char *name,</span>
 		       const struct ip6t_ip6 *ipv6,
 		       int *size)
 {
<span class="p_chunk">@@ -1491,21 +1455,19 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 				  struct xt_table_info *newinfo,
 				  unsigned int *size,
 				  const unsigned char *base,
<span class="p_del">-				  const unsigned char *limit,</span>
<span class="p_del">-				  const unsigned int *hook_entries,</span>
<span class="p_del">-				  const unsigned int *underflows,</span>
<span class="p_del">-				  const char *name)</span>
<span class="p_add">+				  const unsigned char *limit)</span>
 {
 	struct xt_entry_match *ematch;
 	struct xt_entry_target *t;
 	struct xt_target *target;
 	unsigned int entry_offset;
 	unsigned int j;
<span class="p_del">-	int ret, off, h;</span>
<span class="p_add">+	int ret, off;</span>
 
 	duprintf(&quot;check_compat_entry_size_and_hooks %p\n&quot;, e);
 	if ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||
<span class="p_del">-	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) &gt;= limit) {</span>
<span class="p_add">+	    (unsigned char *)e + sizeof(struct compat_ip6t_entry) &gt;= limit ||</span>
<span class="p_add">+	    (unsigned char *)e + e-&gt;next_offset &gt; limit) {</span>
 		duprintf(&quot;Bad offset %p, limit = %p\n&quot;, e, limit);
 		return -EINVAL;
 	}
<span class="p_chunk">@@ -1517,8 +1479,11 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	/* For purposes of check_entry casting the compat entry is fine */</span>
<span class="p_del">-	ret = check_entry((struct ip6t_entry *)e, name);</span>
<span class="p_add">+	if (!ip6_checkentry(&amp;e-&gt;ipv6))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = xt_compat_check_entry_offsets(e, e-&gt;elems,</span>
<span class="p_add">+					    e-&gt;target_offset, e-&gt;next_offset);</span>
 	if (ret)
 		return ret;
 
<span class="p_chunk">@@ -1526,7 +1491,7 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 	entry_offset = (void *)e - (void *)base;
 	j = 0;
 	xt_ematch_foreach(ematch, e) {
<span class="p_del">-		ret = compat_find_calc_match(ematch, name, &amp;e-&gt;ipv6, &amp;off);</span>
<span class="p_add">+		ret = compat_find_calc_match(ematch, &amp;e-&gt;ipv6, &amp;off);</span>
 		if (ret != 0)
 			goto release_matches;
 		++j;
<span class="p_chunk">@@ -1549,17 +1514,6 @@</span> <span class="p_context"> check_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,</span>
 	if (ret)
 		goto out;
 
<span class="p_del">-	/* Check hooks &amp; underflows */</span>
<span class="p_del">-	for (h = 0; h &lt; NF_INET_NUMHOOKS; h++) {</span>
<span class="p_del">-		if ((unsigned char *)e - base == hook_entries[h])</span>
<span class="p_del">-			newinfo-&gt;hook_entry[h] = hook_entries[h];</span>
<span class="p_del">-		if ((unsigned char *)e - base == underflows[h])</span>
<span class="p_del">-			newinfo-&gt;underflow[h] = underflows[h];</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear counters and comefrom */</span>
<span class="p_del">-	memset(&amp;e-&gt;counters, 0, sizeof(e-&gt;counters));</span>
<span class="p_del">-	e-&gt;comefrom = 0;</span>
 	return 0;
 
 out:
<span class="p_chunk">@@ -1573,18 +1527,17 @@</span> <span class="p_context"> release_matches:</span>
 	return ret;
 }
 
<span class="p_del">-static int</span>
<span class="p_add">+static void</span>
 compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,
<span class="p_del">-			    unsigned int *size, const char *name,</span>
<span class="p_add">+			    unsigned int *size,</span>
 			    struct xt_table_info *newinfo, unsigned char *base)
 {
 	struct xt_entry_target *t;
 	struct ip6t_entry *de;
 	unsigned int origsize;
<span class="p_del">-	int ret, h;</span>
<span class="p_add">+	int h;</span>
 	struct xt_entry_match *ematch;
 
<span class="p_del">-	ret = 0;</span>
 	origsize = *size;
 	de = (struct ip6t_entry *)*dstptr;
 	memcpy(de, e, sizeof(struct ip6t_entry));
<span class="p_chunk">@@ -1593,11 +1546,9 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,</span>
 	*dstptr += sizeof(struct ip6t_entry);
 	*size += sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);
 
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	xt_ematch_foreach(ematch, e)</span>
<span class="p_add">+		xt_compat_match_from_user(ematch, dstptr, size);</span>
<span class="p_add">+</span>
 	de-&gt;target_offset = e-&gt;target_offset - (origsize - *size);
 	t = compat_ip6t_get_target(e);
 	xt_compat_target_from_user(t, dstptr, size);
<span class="p_chunk">@@ -1609,183 +1560,83 @@</span> <span class="p_context"> compat_copy_entry_from_user(struct compat_ip6t_entry *e, void **dstptr,</span>
 		if ((unsigned char *)de - base &lt; newinfo-&gt;underflow[h])
 			newinfo-&gt;underflow[h] -= origsize - *size;
 	}
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int compat_check_entry(struct ip6t_entry *e, struct net *net,</span>
<span class="p_del">-			      const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int j;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	struct xt_mtchk_param mtpar;</span>
<span class="p_del">-	struct xt_entry_match *ematch;</span>
<span class="p_del">-</span>
<span class="p_del">-	e-&gt;counters.pcnt = xt_percpu_counter_alloc();</span>
<span class="p_del">-	if (IS_ERR_VALUE(e-&gt;counters.pcnt))</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-	j = 0;</span>
<span class="p_del">-	mtpar.net	= net;</span>
<span class="p_del">-	mtpar.table     = name;</span>
<span class="p_del">-	mtpar.entryinfo = &amp;e-&gt;ipv6;</span>
<span class="p_del">-	mtpar.hook_mask = e-&gt;comefrom;</span>
<span class="p_del">-	mtpar.family    = NFPROTO_IPV6;</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		ret = check_match(ematch, &amp;mtpar);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			goto cleanup_matches;</span>
<span class="p_del">-		++j;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = check_target(e, net, name);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto cleanup_matches;</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">- cleanup_matches:</span>
<span class="p_del">-	xt_ematch_foreach(ematch, e) {</span>
<span class="p_del">-		if (j-- == 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		cleanup_match(ematch, net);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	xt_percpu_counter_free(e-&gt;counters.pcnt);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
 }
 
 static int
 translate_compat_table(struct net *net,
<span class="p_del">-		       const char *name,</span>
<span class="p_del">-		       unsigned int valid_hooks,</span>
 		       struct xt_table_info **pinfo,
 		       void **pentry0,
<span class="p_del">-		       unsigned int total_size,</span>
<span class="p_del">-		       unsigned int number,</span>
<span class="p_del">-		       unsigned int *hook_entries,</span>
<span class="p_del">-		       unsigned int *underflows)</span>
<span class="p_add">+		       const struct compat_ip6t_replace *compatr)</span>
 {
 	unsigned int i, j;
 	struct xt_table_info *newinfo, *info;
 	void *pos, *entry0, *entry1;
 	struct compat_ip6t_entry *iter0;
<span class="p_del">-	struct ip6t_entry *iter1;</span>
<span class="p_add">+	struct ip6t_replace repl;</span>
 	unsigned int size;
 	int ret = 0;
 
 	info = *pinfo;
 	entry0 = *pentry0;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	info-&gt;number = number;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Init all hooks to impossible value. */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		info-&gt;hook_entry[i] = 0xFFFFFFFF;</span>
<span class="p_del">-		info-&gt;underflow[i] = 0xFFFFFFFF;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	info-&gt;number = compatr-&gt;num_entries;</span>
 
 	duprintf(&quot;translate_compat_table: size %u\n&quot;, info-&gt;size);
 	j = 0;
 	xt_compat_lock(AF_INET6);
<span class="p_del">-	xt_compat_init_offsets(AF_INET6, number);</span>
<span class="p_add">+	xt_compat_init_offsets(AF_INET6, compatr-&gt;num_entries);</span>
 	/* Walk through entries, checking offsets. */
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		ret = check_compat_entry_size_and_hooks(iter0, info, &amp;size,
 							entry0,
<span class="p_del">-							entry0 + total_size,</span>
<span class="p_del">-							hook_entries,</span>
<span class="p_del">-							underflows,</span>
<span class="p_del">-							name);</span>
<span class="p_add">+							entry0 + compatr-&gt;size);</span>
 		if (ret != 0)
 			goto out_unlock;
 		++j;
 	}
 
 	ret = -EINVAL;
<span class="p_del">-	if (j != number) {</span>
<span class="p_add">+	if (j != compatr-&gt;num_entries) {</span>
 		duprintf(&quot;translate_compat_table: %u not %u entries\n&quot;,
<span class="p_del">-			 j, number);</span>
<span class="p_add">+			 j, compatr-&gt;num_entries);</span>
 		goto out_unlock;
 	}
 
<span class="p_del">-	/* Check hooks all assigned */</span>
<span class="p_del">-	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_del">-		/* Only hooks which are valid */</span>
<span class="p_del">-		if (!(valid_hooks &amp; (1 &lt;&lt; i)))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		if (info-&gt;hook_entry[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid hook entry %u %u\n&quot;,</span>
<span class="p_del">-				 i, hook_entries[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		if (info-&gt;underflow[i] == 0xFFFFFFFF) {</span>
<span class="p_del">-			duprintf(&quot;Invalid underflow %u %u\n&quot;,</span>
<span class="p_del">-				 i, underflows[i]);</span>
<span class="p_del">-			goto out_unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ret = -ENOMEM;
 	newinfo = xt_alloc_table_info(size);
 	if (!newinfo)
 		goto out_unlock;
 
<span class="p_del">-	newinfo-&gt;number = number;</span>
<span class="p_add">+	newinfo-&gt;number = compatr-&gt;num_entries;</span>
 	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {
<span class="p_del">-		newinfo-&gt;hook_entry[i] = info-&gt;hook_entry[i];</span>
<span class="p_del">-		newinfo-&gt;underflow[i] = info-&gt;underflow[i];</span>
<span class="p_add">+		newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span>
<span class="p_add">+		newinfo-&gt;underflow[i] = compatr-&gt;underflow[i];</span>
 	}
 	entry1 = newinfo-&gt;entries;
 	pos = entry1;
<span class="p_del">-	size = total_size;</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_del">-		ret = compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_del">-						  name, newinfo, entry1);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	size = compatr-&gt;size;</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size)</span>
<span class="p_add">+		compat_copy_entry_from_user(iter0, &amp;pos, &amp;size,</span>
<span class="p_add">+					    newinfo, entry1);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* all module references in entry0 are now gone. */</span>
 	xt_compat_flush_offsets(AF_INET6);
 	xt_compat_unlock(AF_INET6);
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto free_newinfo;</span>
 
<span class="p_del">-	ret = -ELOOP;</span>
<span class="p_del">-	if (!mark_source_chains(newinfo, valid_hooks, entry1))</span>
<span class="p_del">-		goto free_newinfo;</span>
<span class="p_add">+	memcpy(&amp;repl, compatr, sizeof(*compatr));</span>
 
<span class="p_del">-	i = 0;</span>
<span class="p_del">-	xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-		ret = compat_check_entry(iter1, net, name);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		++i;</span>
<span class="p_del">-		if (strcmp(ip6t_get_target(iter1)-&gt;u.user.name,</span>
<span class="p_del">-		    XT_ERROR_TARGET) == 0)</span>
<span class="p_del">-			++newinfo-&gt;stacksize;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The first i matches need cleanup_entry (calls -&gt;destroy)</span>
<span class="p_del">-		 * because they had called -&gt;check already. The other j-i</span>
<span class="p_del">-		 * entries need only release.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		int skip = i;</span>
<span class="p_del">-		j -= i;</span>
<span class="p_del">-		xt_entry_foreach(iter0, entry0, newinfo-&gt;size) {</span>
<span class="p_del">-			if (skip-- &gt; 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			if (j-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			compat_release_entry(iter0);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_entry_foreach(iter1, entry1, newinfo-&gt;size) {</span>
<span class="p_del">-			if (i-- == 0)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			cleanup_entry(iter1, net);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		xt_free_table_info(newinfo);</span>
<span class="p_del">-		return ret;</span>
<span class="p_add">+	for (i = 0; i &lt; NF_INET_NUMHOOKS; i++) {</span>
<span class="p_add">+		repl.hook_entry[i] = newinfo-&gt;hook_entry[i];</span>
<span class="p_add">+		repl.underflow[i] = newinfo-&gt;underflow[i];</span>
 	}
 
<span class="p_add">+	repl.num_counters = 0;</span>
<span class="p_add">+	repl.counters = NULL;</span>
<span class="p_add">+	repl.size = newinfo-&gt;size;</span>
<span class="p_add">+	ret = translate_table(net, newinfo, entry1, &amp;repl);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto free_newinfo;</span>
<span class="p_add">+</span>
 	*pinfo = newinfo;
 	*pentry0 = entry1;
 	xt_free_table_info(info);
<span class="p_chunk">@@ -1793,17 +1644,16 @@</span> <span class="p_context"> translate_compat_table(struct net *net,</span>
 
 free_newinfo:
 	xt_free_table_info(newinfo);
<span class="p_del">-out:</span>
<span class="p_del">-	xt_entry_foreach(iter0, entry0, total_size) {</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+out_unlock:</span>
<span class="p_add">+	xt_compat_flush_offsets(AF_INET6);</span>
<span class="p_add">+	xt_compat_unlock(AF_INET6);</span>
<span class="p_add">+	xt_entry_foreach(iter0, entry0, compatr-&gt;size) {</span>
 		if (j-- == 0)
 			break;
 		compat_release_entry(iter0);
 	}
 	return ret;
<span class="p_del">-out_unlock:</span>
<span class="p_del">-	xt_compat_flush_offsets(AF_INET6);</span>
<span class="p_del">-	xt_compat_unlock(AF_INET6);</span>
<span class="p_del">-	goto out;</span>
 }
 
 static int
<span class="p_chunk">@@ -1839,10 +1689,7 @@</span> <span class="p_context"> compat_do_replace(struct net *net, void __user *user, unsigned int len)</span>
 		goto free_newinfo;
 	}
 
<span class="p_del">-	ret = translate_compat_table(net, tmp.name, tmp.valid_hooks,</span>
<span class="p_del">-				     &amp;newinfo, &amp;loc_cpu_entry, tmp.size,</span>
<span class="p_del">-				     tmp.num_entries, tmp.hook_entry,</span>
<span class="p_del">-				     tmp.underflow);</span>
<span class="p_add">+	ret = translate_compat_table(net, &amp;newinfo, &amp;loc_cpu_entry, &amp;tmp);</span>
 	if (ret != 0)
 		goto free_newinfo;
 
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index b8d405623f4f..1a1cd3938fd0 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -1706,7 +1706,9 @@</span> <span class="p_context"> static void get_tcp6_sock(struct seq_file *seq, struct sock *sp, int i)</span>
 	destp = ntohs(inet-&gt;inet_dport);
 	srcp  = ntohs(inet-&gt;inet_sport);
 
<span class="p_del">-	if (icsk-&gt;icsk_pending == ICSK_TIME_RETRANS) {</span>
<span class="p_add">+	if (icsk-&gt;icsk_pending == ICSK_TIME_RETRANS ||</span>
<span class="p_add">+	    icsk-&gt;icsk_pending == ICSK_TIME_EARLY_RETRANS ||</span>
<span class="p_add">+	    icsk-&gt;icsk_pending == ICSK_TIME_LOSS_PROBE) {</span>
 		timer_active	= 1;
 		timer_expires	= icsk-&gt;icsk_timeout;
 	} else if (icsk-&gt;icsk_pending == ICSK_TIME_PROBE0) {
<span class="p_header">diff --git a/net/ipv6/udp.c b/net/ipv6/udp.c</span>
<span class="p_header">index 6665e1a0bfe1..275af43306f9 100644</span>
<span class="p_header">--- a/net/ipv6/udp.c</span>
<span class="p_header">+++ b/net/ipv6/udp.c</span>
<span class="p_chunk">@@ -647,7 +647,7 @@</span> <span class="p_context"> int udpv6_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 
 		/* if we&#39;re overly short, let UDP handle it */
 		encap_rcv = ACCESS_ONCE(up-&gt;encap_rcv);
<span class="p_del">-		if (skb-&gt;len &gt; sizeof(struct udphdr) &amp;&amp; encap_rcv) {</span>
<span class="p_add">+		if (encap_rcv) {</span>
 			int ret;
 
 			/* Verify checksum before giving to encap */
<span class="p_header">diff --git a/net/l2tp/l2tp_core.c b/net/l2tp/l2tp_core.c</span>
<span class="p_header">index afca2eb4dfa7..ec17cbe8a02b 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_core.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_core.c</span>
<span class="p_chunk">@@ -1581,7 +1581,7 @@</span> <span class="p_context"> int l2tp_tunnel_create(struct net *net, int fd, int version, u32 tunnel_id, u32</span>
 	/* Mark socket as an encapsulation socket. See net/ipv4/udp.c */
 	tunnel-&gt;encap = encap;
 	if (encap == L2TP_ENCAPTYPE_UDP) {
<span class="p_del">-		struct udp_tunnel_sock_cfg udp_cfg;</span>
<span class="p_add">+		struct udp_tunnel_sock_cfg udp_cfg = { };</span>
 
 		udp_cfg.sk_user_data = tunnel;
 		udp_cfg.encap_type = UDP_ENCAP_L2TPINUDP;
<span class="p_header">diff --git a/net/netfilter/x_tables.c b/net/netfilter/x_tables.c</span>
<span class="p_header">index d4aaad747ea9..25391fb25516 100644</span>
<span class="p_header">--- a/net/netfilter/x_tables.c</span>
<span class="p_header">+++ b/net/netfilter/x_tables.c</span>
<span class="p_chunk">@@ -415,6 +415,47 @@</span> <span class="p_context"> int xt_check_match(struct xt_mtchk_param *par,</span>
 }
 EXPORT_SYMBOL_GPL(xt_check_match);
 
<span class="p_add">+/** xt_check_entry_match - check that matches end before start of target</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @match: beginning of xt_entry_match</span>
<span class="p_add">+ * @target: beginning of this rules target (alleged end of matches)</span>
<span class="p_add">+ * @alignment: alignment requirement of match structures</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Validates that all matches add up to the beginning of the target,</span>
<span class="p_add">+ * and that each match covers at least the base structure size.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: 0 on success, negative errno on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int xt_check_entry_match(const char *match, const char *target,</span>
<span class="p_add">+				const size_t alignment)</span>
<span class="p_add">+{</span>
<span class="p_add">+	const struct xt_entry_match *pos;</span>
<span class="p_add">+	int length = target - match;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (length == 0) /* no matches */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	pos = (struct xt_entry_match *)match;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if ((unsigned long)pos % alignment)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (length &lt; (int)sizeof(struct xt_entry_match))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pos-&gt;u.match_size &lt; sizeof(struct xt_entry_match))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (pos-&gt;u.match_size &gt; length)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		length -= pos-&gt;u.match_size;</span>
<span class="p_add">+		pos = ((void *)((char *)(pos) + (pos)-&gt;u.match_size));</span>
<span class="p_add">+	} while (length &gt; 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_COMPAT
 int xt_compat_add_offset(u_int8_t af, unsigned int offset, int delta)
 {
<span class="p_chunk">@@ -484,13 +525,14 @@</span> <span class="p_context"> int xt_compat_match_offset(const struct xt_match *match)</span>
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_offset);
 
<span class="p_del">-int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
<span class="p_del">-			      unsigned int *size)</span>
<span class="p_add">+void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
<span class="p_add">+			       unsigned int *size)</span>
 {
 	const struct xt_match *match = m-&gt;u.kernel.match;
 	struct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;
 	int pad, off = xt_compat_match_offset(match);
 	u_int16_t msize = cm-&gt;u.user.match_size;
<span class="p_add">+	char name[sizeof(m-&gt;u.user.name)];</span>
 
 	m = *dstptr;
 	memcpy(m, cm, sizeof(*cm));
<span class="p_chunk">@@ -504,10 +546,12 @@</span> <span class="p_context"> int xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,</span>
 
 	msize += off;
 	m-&gt;u.user.match_size = msize;
<span class="p_add">+	strlcpy(name, match-&gt;name, sizeof(name));</span>
<span class="p_add">+	module_put(match-&gt;me);</span>
<span class="p_add">+	strncpy(m-&gt;u.user.name, name, sizeof(m-&gt;u.user.name));</span>
 
 	*size += off;
 	*dstptr += msize;
<span class="p_del">-	return 0;</span>
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_from_user);
 
<span class="p_chunk">@@ -538,8 +582,125 @@</span> <span class="p_context"> int xt_compat_match_to_user(const struct xt_entry_match *m,</span>
 	return 0;
 }
 EXPORT_SYMBOL_GPL(xt_compat_match_to_user);
<span class="p_add">+</span>
<span class="p_add">+/* non-compat version may have padding after verdict */</span>
<span class="p_add">+struct compat_xt_standard_target {</span>
<span class="p_add">+	struct compat_xt_entry_target t;</span>
<span class="p_add">+	compat_uint_t verdict;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+int xt_compat_check_entry_offsets(const void *base, const char *elems,</span>
<span class="p_add">+				  unsigned int target_offset,</span>
<span class="p_add">+				  unsigned int next_offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long size_of_base_struct = elems - (const char *)base;</span>
<span class="p_add">+	const struct compat_xt_entry_target *t;</span>
<span class="p_add">+	const char *e = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset &lt; size_of_base_struct)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + sizeof(*t) &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	t = (void *)(e + target_offset);</span>
<span class="p_add">+	if (t-&gt;u.target_size &lt; sizeof(*t))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + t-&gt;u.target_size &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) == 0 &amp;&amp;</span>
<span class="p_add">+	    COMPAT_XT_ALIGN(target_offset + sizeof(struct compat_xt_standard_target)) != next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* compat_xt_entry match has less strict aligment requirements,</span>
<span class="p_add">+	 * otherwise they are identical.  In case of padding differences</span>
<span class="p_add">+	 * we need to add compat version of xt_check_entry_match.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	BUILD_BUG_ON(sizeof(struct compat_xt_entry_match) != sizeof(struct xt_entry_match));</span>
<span class="p_add">+</span>
<span class="p_add">+	return xt_check_entry_match(elems, base + target_offset,</span>
<span class="p_add">+				    __alignof__(struct compat_xt_entry_match));</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(xt_compat_check_entry_offsets);</span>
 #endif /* CONFIG_COMPAT */
 
<span class="p_add">+/**</span>
<span class="p_add">+ * xt_check_entry_offsets - validate arp/ip/ip6t_entry</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @base: pointer to arp/ip/ip6t_entry</span>
<span class="p_add">+ * @elems: pointer to first xt_entry_match, i.e. ip(6)t_entry-&gt;elems</span>
<span class="p_add">+ * @target_offset: the arp/ip/ip6_t-&gt;target_offset</span>
<span class="p_add">+ * @next_offset: the arp/ip/ip6_t-&gt;next_offset</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * validates that target_offset and next_offset are sane and that all</span>
<span class="p_add">+ * match sizes (if any) align with the target offset.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function does not validate the targets or matches themselves, it</span>
<span class="p_add">+ * only tests that all the offsets and sizes are correct, that all</span>
<span class="p_add">+ * match structures are aligned, and that the last structure ends where</span>
<span class="p_add">+ * the target structure begins.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Also see xt_compat_check_entry_offsets for CONFIG_COMPAT version.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The arp/ip/ip6t_entry structure @base must have passed following tests:</span>
<span class="p_add">+ * - it must point to a valid memory location</span>
<span class="p_add">+ * - base to base + next_offset must be accessible, i.e. not exceed allocated</span>
<span class="p_add">+ *   length.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * A well-formed entry looks like this:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * ip(6)t_entry   match [mtdata]  match [mtdata] target [tgdata] ip(6)t_entry</span>
<span class="p_add">+ * e-&gt;elems[]-----&#39;                              |               |</span>
<span class="p_add">+ *                matchsize                      |               |</span>
<span class="p_add">+ *                                matchsize      |               |</span>
<span class="p_add">+ *                                               |               |</span>
<span class="p_add">+ * target_offset---------------------------------&#39;               |</span>
<span class="p_add">+ * next_offset---------------------------------------------------&#39;</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * elems[]: flexible array member at end of ip(6)/arpt_entry struct.</span>
<span class="p_add">+ *          This is where matches (if any) and the target reside.</span>
<span class="p_add">+ * target_offset: beginning of target.</span>
<span class="p_add">+ * next_offset: start of the next rule; also: size of this rule.</span>
<span class="p_add">+ * Since targets have a minimum size, target_offset + minlen &lt;= next_offset.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Every match stores its size, sum of sizes must not exceed target_offset.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: 0 on success, negative errno on failure.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int xt_check_entry_offsets(const void *base,</span>
<span class="p_add">+			   const char *elems,</span>
<span class="p_add">+			   unsigned int target_offset,</span>
<span class="p_add">+			   unsigned int next_offset)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long size_of_base_struct = elems - (const char *)base;</span>
<span class="p_add">+	const struct xt_entry_target *t;</span>
<span class="p_add">+	const char *e = base;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* target start is within the ip/ip6/arpt_entry struct */</span>
<span class="p_add">+	if (target_offset &lt; size_of_base_struct)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + sizeof(*t) &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	t = (void *)(e + target_offset);</span>
<span class="p_add">+	if (t-&gt;u.target_size &lt; sizeof(*t))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (target_offset + t-&gt;u.target_size &gt; next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (strcmp(t-&gt;u.user.name, XT_STANDARD_TARGET) == 0 &amp;&amp;</span>
<span class="p_add">+	    XT_ALIGN(target_offset + sizeof(struct xt_standard_target)) != next_offset)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	return xt_check_entry_match(elems, base + target_offset,</span>
<span class="p_add">+				    __alignof__(struct xt_entry_match));</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(xt_check_entry_offsets);</span>
<span class="p_add">+</span>
 int xt_check_target(struct xt_tgchk_param *par,
 		    unsigned int size, u_int8_t proto, bool inv_proto)
 {
<span class="p_chunk">@@ -590,6 +751,80 @@</span> <span class="p_context"> int xt_check_target(struct xt_tgchk_param *par,</span>
 }
 EXPORT_SYMBOL_GPL(xt_check_target);
 
<span class="p_add">+/**</span>
<span class="p_add">+ * xt_copy_counters_from_user - copy counters and metadata from userspace</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @user: src pointer to userspace memory</span>
<span class="p_add">+ * @len: alleged size of userspace memory</span>
<span class="p_add">+ * @info: where to store the xt_counters_info metadata</span>
<span class="p_add">+ * @compat: true if we setsockopt call is done by 32bit task on 64bit kernel</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copies counter meta data from @user and stores it in @info.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * vmallocs memory to hold the counters, then copies the counter data</span>
<span class="p_add">+ * from @user to the new memory and returns a pointer to it.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * If @compat is true, @info gets converted automatically to the 64bit</span>
<span class="p_add">+ * representation.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The metadata associated with the counters is stored in @info.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Return: returns pointer that caller has to test via IS_ERR().</span>
<span class="p_add">+ * If IS_ERR is false, caller has to vfree the pointer.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void *xt_copy_counters_from_user(const void __user *user, unsigned int len,</span>
<span class="p_add">+				 struct xt_counters_info *info, bool compat)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *mem;</span>
<span class="p_add">+	u64 size;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+	if (compat) {</span>
<span class="p_add">+		/* structures only differ in size due to alignment */</span>
<span class="p_add">+		struct compat_xt_counters_info compat_tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (len &lt;= sizeof(compat_tmp))</span>
<span class="p_add">+			return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+		len -= sizeof(compat_tmp);</span>
<span class="p_add">+		if (copy_from_user(&amp;compat_tmp, user, sizeof(compat_tmp)) != 0)</span>
<span class="p_add">+			return ERR_PTR(-EFAULT);</span>
<span class="p_add">+</span>
<span class="p_add">+		strlcpy(info-&gt;name, compat_tmp.name, sizeof(info-&gt;name));</span>
<span class="p_add">+		info-&gt;num_counters = compat_tmp.num_counters;</span>
<span class="p_add">+		user += sizeof(compat_tmp);</span>
<span class="p_add">+	} else</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	{</span>
<span class="p_add">+		if (len &lt;= sizeof(*info))</span>
<span class="p_add">+			return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+		len -= sizeof(*info);</span>
<span class="p_add">+		if (copy_from_user(info, user, sizeof(*info)) != 0)</span>
<span class="p_add">+			return ERR_PTR(-EFAULT);</span>
<span class="p_add">+</span>
<span class="p_add">+		info-&gt;name[sizeof(info-&gt;name) - 1] = &#39;\0&#39;;</span>
<span class="p_add">+		user += sizeof(*info);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	size = sizeof(struct xt_counters);</span>
<span class="p_add">+	size *= info-&gt;num_counters;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (size != (u64)len)</span>
<span class="p_add">+		return ERR_PTR(-EINVAL);</span>
<span class="p_add">+</span>
<span class="p_add">+	mem = vmalloc(len);</span>
<span class="p_add">+	if (!mem)</span>
<span class="p_add">+		return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (copy_from_user(mem, user, len) == 0)</span>
<span class="p_add">+		return mem;</span>
<span class="p_add">+</span>
<span class="p_add">+	vfree(mem);</span>
<span class="p_add">+	return ERR_PTR(-EFAULT);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(xt_copy_counters_from_user);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_COMPAT
 int xt_compat_target_offset(const struct xt_target *target)
 {
<span class="p_chunk">@@ -605,6 +840,7 @@</span> <span class="p_context"> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span>
 	struct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;
 	int pad, off = xt_compat_target_offset(target);
 	u_int16_t tsize = ct-&gt;u.user.target_size;
<span class="p_add">+	char name[sizeof(t-&gt;u.user.name)];</span>
 
 	t = *dstptr;
 	memcpy(t, ct, sizeof(*ct));
<span class="p_chunk">@@ -618,6 +854,9 @@</span> <span class="p_context"> void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,</span>
 
 	tsize += off;
 	t-&gt;u.user.target_size = tsize;
<span class="p_add">+	strlcpy(name, target-&gt;name, sizeof(name));</span>
<span class="p_add">+	module_put(target-&gt;me);</span>
<span class="p_add">+	strncpy(t-&gt;u.user.name, name, sizeof(t-&gt;u.user.name));</span>
 
 	*size += off;
 	*dstptr += tsize;
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 992b35fb8615..7a5fa0c98377 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2784,6 +2784,7 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 	struct netlink_callback *cb;
 	struct sk_buff *skb = NULL;
 	struct nlmsghdr *nlh;
<span class="p_add">+	struct module *module;</span>
 	int len, err = -ENOBUFS;
 	int alloc_min_size;
 	int alloc_size;
<span class="p_chunk">@@ -2863,9 +2864,11 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 		cb-&gt;done(cb);
 
 	nlk-&gt;cb_running = false;
<span class="p_add">+	module = cb-&gt;module;</span>
<span class="p_add">+	skb = cb-&gt;skb;</span>
 	mutex_unlock(nlk-&gt;cb_mutex);
<span class="p_del">-	module_put(cb-&gt;module);</span>
<span class="p_del">-	consume_skb(cb-&gt;skb);</span>
<span class="p_add">+	module_put(module);</span>
<span class="p_add">+	consume_skb(skb);</span>
 	return 0;
 
 errout_skb:
<span class="p_header">diff --git a/net/openvswitch/vport-vxlan.c b/net/openvswitch/vport-vxlan.c</span>
<span class="p_header">index d933cb89efac..5eb7694348b5 100644</span>
<span class="p_header">--- a/net/openvswitch/vport-vxlan.c</span>
<span class="p_header">+++ b/net/openvswitch/vport-vxlan.c</span>
<span class="p_chunk">@@ -91,6 +91,8 @@</span> <span class="p_context"> static struct vport *vxlan_tnl_create(const struct vport_parms *parms)</span>
 	struct vxlan_config conf = {
 		.no_share = true,
 		.flags = VXLAN_F_COLLECT_METADATA | VXLAN_F_UDP_ZERO_CSUM6_RX,
<span class="p_add">+		/* Don&#39;t restrict the packets that can be sent by MTU */</span>
<span class="p_add">+		.mtu = IP_MAX_MTU,</span>
 	};
 
 	if (!options) {
<span class="p_header">diff --git a/net/switchdev/switchdev.c b/net/switchdev/switchdev.c</span>
<span class="p_header">index d5d7132ac847..1b58866175e6 100644</span>
<span class="p_header">--- a/net/switchdev/switchdev.c</span>
<span class="p_header">+++ b/net/switchdev/switchdev.c</span>
<span class="p_chunk">@@ -1169,6 +1169,7 @@</span> <span class="p_context"> int switchdev_fib_ipv4_add(u32 dst, int dst_len, struct fib_info *fi,</span>
 		.obj.id = SWITCHDEV_OBJ_ID_IPV4_FIB,
 		.dst = dst,
 		.dst_len = dst_len,
<span class="p_add">+		.fi = fi,</span>
 		.tos = tos,
 		.type = type,
 		.nlflags = nlflags,
<span class="p_chunk">@@ -1177,8 +1178,6 @@</span> <span class="p_context"> int switchdev_fib_ipv4_add(u32 dst, int dst_len, struct fib_info *fi,</span>
 	struct net_device *dev;
 	int err = 0;
 
<span class="p_del">-	memcpy(&amp;ipv4_fib.fi, fi, sizeof(ipv4_fib.fi));</span>
<span class="p_del">-</span>
 	/* Don&#39;t offload route if using custom ip rules or if
 	 * IPv4 FIB offloading has been disabled completely.
 	 */
<span class="p_chunk">@@ -1222,6 +1221,7 @@</span> <span class="p_context"> int switchdev_fib_ipv4_del(u32 dst, int dst_len, struct fib_info *fi,</span>
 		.obj.id = SWITCHDEV_OBJ_ID_IPV4_FIB,
 		.dst = dst,
 		.dst_len = dst_len,
<span class="p_add">+		.fi = fi,</span>
 		.tos = tos,
 		.type = type,
 		.nlflags = 0,
<span class="p_chunk">@@ -1230,8 +1230,6 @@</span> <span class="p_context"> int switchdev_fib_ipv4_del(u32 dst, int dst_len, struct fib_info *fi,</span>
 	struct net_device *dev;
 	int err = 0;
 
<span class="p_del">-	memcpy(&amp;ipv4_fib.fi, fi, sizeof(ipv4_fib.fi));</span>
<span class="p_del">-</span>
 	if (!(fi-&gt;fib_flags &amp; RTNH_F_OFFLOAD))
 		return 0;
 
<span class="p_header">diff --git a/net/tipc/netlink_compat.c b/net/tipc/netlink_compat.c</span>
<span class="p_header">index 1eadc95e1132..2ed732bfe94b 100644</span>
<span class="p_header">--- a/net/tipc/netlink_compat.c</span>
<span class="p_header">+++ b/net/tipc/netlink_compat.c</span>
<span class="p_chunk">@@ -802,7 +802,7 @@</span> <span class="p_context"> static int tipc_nl_compat_name_table_dump(struct tipc_nl_compat_msg *msg,</span>
 		goto out;
 
 	tipc_tlv_sprintf(msg-&gt;rep, &quot;%-10u %s&quot;,
<span class="p_del">-			 nla_get_u32(publ[TIPC_NLA_PUBL_REF]),</span>
<span class="p_add">+			 nla_get_u32(publ[TIPC_NLA_PUBL_KEY]),</span>
 			 scope_str[nla_get_u32(publ[TIPC_NLA_PUBL_SCOPE])]);
 out:
 	tipc_tlv_sprintf(msg-&gt;rep, &quot;\n&quot;);
<span class="p_header">diff --git a/net/tipc/socket.c b/net/tipc/socket.c</span>
<span class="p_header">index e53003cf7703..9b713e0ce00d 100644</span>
<span class="p_header">--- a/net/tipc/socket.c</span>
<span class="p_header">+++ b/net/tipc/socket.c</span>
<span class="p_chunk">@@ -2814,6 +2814,9 @@</span> <span class="p_context"> int tipc_nl_publ_dump(struct sk_buff *skb, struct netlink_callback *cb)</span>
 		if (err)
 			return err;
 
<span class="p_add">+		if (!attrs[TIPC_NLA_SOCK])</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		err = nla_parse_nested(sock, TIPC_NLA_SOCK_MAX,
 				       attrs[TIPC_NLA_SOCK],
 				       tipc_nl_sock_policy);
<span class="p_header">diff --git a/net/wireless/wext-core.c b/net/wireless/wext-core.c</span>
<span class="p_header">index b50ee5d622e1..c753211cb83f 100644</span>
<span class="p_header">--- a/net/wireless/wext-core.c</span>
<span class="p_header">+++ b/net/wireless/wext-core.c</span>
<span class="p_chunk">@@ -955,8 +955,29 @@</span> <span class="p_context"> static int wireless_process_ioctl(struct net *net, struct ifreq *ifr,</span>
 			return private(dev, iwr, cmd, info, handler);
 	}
 	/* Old driver API : call driver ioctl handler */
<span class="p_del">-	if (dev-&gt;netdev_ops-&gt;ndo_do_ioctl)</span>
<span class="p_del">-		return dev-&gt;netdev_ops-&gt;ndo_do_ioctl(dev, ifr, cmd);</span>
<span class="p_add">+	if (dev-&gt;netdev_ops-&gt;ndo_do_ioctl) {</span>
<span class="p_add">+#ifdef CONFIG_COMPAT</span>
<span class="p_add">+		if (info-&gt;flags &amp; IW_REQUEST_FLAG_COMPAT) {</span>
<span class="p_add">+			int ret = 0;</span>
<span class="p_add">+			struct iwreq iwr_lcl;</span>
<span class="p_add">+			struct compat_iw_point *iwp_compat = (void *) &amp;iwr-&gt;u.data;</span>
<span class="p_add">+</span>
<span class="p_add">+			memcpy(&amp;iwr_lcl, iwr, sizeof(struct iwreq));</span>
<span class="p_add">+			iwr_lcl.u.data.pointer = compat_ptr(iwp_compat-&gt;pointer);</span>
<span class="p_add">+			iwr_lcl.u.data.length = iwp_compat-&gt;length;</span>
<span class="p_add">+			iwr_lcl.u.data.flags = iwp_compat-&gt;flags;</span>
<span class="p_add">+</span>
<span class="p_add">+			ret = dev-&gt;netdev_ops-&gt;ndo_do_ioctl(dev, (void *) &amp;iwr_lcl, cmd);</span>
<span class="p_add">+</span>
<span class="p_add">+			iwp_compat-&gt;pointer = ptr_to_compat(iwr_lcl.u.data.pointer);</span>
<span class="p_add">+			iwp_compat-&gt;length = iwr_lcl.u.data.length;</span>
<span class="p_add">+			iwp_compat-&gt;flags = iwr_lcl.u.data.flags;</span>
<span class="p_add">+</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+		} else</span>
<span class="p_add">+#endif</span>
<span class="p_add">+			return dev-&gt;netdev_ops-&gt;ndo_do_ioctl(dev, ifr, cmd);</span>
<span class="p_add">+	}</span>
 	return -EOPNOTSUPP;
 }
 
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 411630e9c034..1475440b70aa 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -359,8 +359,11 @@</span> <span class="p_context"> enum {</span>
 
 #define IS_SKL(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa170)
 #define IS_SKL_LP(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x9d70)
<span class="p_add">+#define IS_KBL(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0xa171)</span>
<span class="p_add">+#define IS_KBL_LP(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x9d71)</span>
 #define IS_BXT(pci) ((pci)-&gt;vendor == 0x8086 &amp;&amp; (pci)-&gt;device == 0x5a98)
<span class="p_del">-#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci))</span>
<span class="p_add">+#define IS_SKL_PLUS(pci) (IS_SKL(pci) || IS_SKL_LP(pci) || IS_BXT(pci)) || \</span>
<span class="p_add">+			IS_KBL(pci) || IS_KBL_LP(pci)</span>
 
 static char *driver_short_names[] = {
 	[AZX_DRIVER_ICH] = &quot;HDA Intel&quot;,
<span class="p_chunk">@@ -2204,6 +2207,12 @@</span> <span class="p_context"> static const struct pci_device_id azx_ids[] = {</span>
 	/* Sunrise Point-LP */
 	{ PCI_DEVICE(0x8086, 0x9d70),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE },
<span class="p_add">+	/* Kabylake */</span>
<span class="p_add">+	{ PCI_DEVICE(0x8086, 0xa171),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE },</span>
<span class="p_add">+	/* Kabylake-LP */</span>
<span class="p_add">+	{ PCI_DEVICE(0x8086, 0x9d71),</span>
<span class="p_add">+	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_SKYLAKE },</span>
 	/* Broxton-P(Apollolake) */
 	{ PCI_DEVICE(0x8086, 0x5a98),
 	  .driver_data = AZX_DRIVER_PCH | AZX_DCAPS_INTEL_BROXTON },
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index d53c25e7a1c1..0fe18ede3e85 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -346,6 +346,9 @@</span> <span class="p_context"> static void alc_fill_eapd_coef(struct hda_codec *codec)</span>
 	case 0x10ec0234:
 	case 0x10ec0274:
 	case 0x10ec0294:
<span class="p_add">+	case 0x10ec0700:</span>
<span class="p_add">+	case 0x10ec0701:</span>
<span class="p_add">+	case 0x10ec0703:</span>
 		alc_update_coef_idx(codec, 0x10, 1&lt;&lt;15, 0);
 		break;
 	case 0x10ec0662:
<span class="p_chunk">@@ -2655,6 +2658,7 @@</span> <span class="p_context"> enum {</span>
 	ALC269_TYPE_ALC256,
 	ALC269_TYPE_ALC225,
 	ALC269_TYPE_ALC294,
<span class="p_add">+	ALC269_TYPE_ALC700,</span>
 };
 
 /*
<span class="p_chunk">@@ -2686,6 +2690,7 @@</span> <span class="p_context"> static int alc269_parse_auto_config(struct hda_codec *codec)</span>
 	case ALC269_TYPE_ALC256:
 	case ALC269_TYPE_ALC225:
 	case ALC269_TYPE_ALC294:
<span class="p_add">+	case ALC269_TYPE_ALC700:</span>
 		ssids = alc269_ssids;
 		break;
 	default:
<span class="p_chunk">@@ -3618,13 +3623,20 @@</span> <span class="p_context"> static void alc269_fixup_hp_line1_mic1_led(struct hda_codec *codec,</span>
 static void alc_headset_mode_unplugged(struct hda_codec *codec)
 {
 	static struct coef_fw coef0255[] = {
<span class="p_del">-		WRITE_COEF(0x1b, 0x0c0b), /* LDO and MISC control */</span>
 		WRITE_COEF(0x45, 0xd089), /* UAJ function set to menual mode */
 		UPDATE_COEFEX(0x57, 0x05, 1&lt;&lt;14, 0), /* Direct Drive HP Amp control(Set to verb control)*/
 		WRITE_COEF(0x06, 0x6104), /* Set MIC2 Vref gate with HP */
 		WRITE_COEFEX(0x57, 0x03, 0x8aa6), /* Direct Drive HP Amp control */
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0255_1[] = {</span>
<span class="p_add">+		WRITE_COEF(0x1b, 0x0c0b), /* LDO and MISC control */</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
<span class="p_add">+	static struct coef_fw coef0256[] = {</span>
<span class="p_add">+		WRITE_COEF(0x1b, 0x0c4b), /* LDO and MISC control */</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
 	static struct coef_fw coef0233[] = {
 		WRITE_COEF(0x1b, 0x0c0b),
 		WRITE_COEF(0x45, 0xc429),
<span class="p_chunk">@@ -3677,7 +3689,11 @@</span> <span class="p_context"> static void alc_headset_mode_unplugged(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_add">+		alc_process_coef_fw(codec, coef0255_1);</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0255);</span>
<span class="p_add">+		break;</span>
 	case 0x10ec0256:
<span class="p_add">+		alc_process_coef_fw(codec, coef0256);</span>
 		alc_process_coef_fw(codec, coef0255);
 		break;
 	case 0x10ec0233:
<span class="p_chunk">@@ -3896,6 +3912,12 @@</span> <span class="p_context"> static void alc_headset_mode_ctia(struct hda_codec *codec)</span>
 		WRITE_COEFEX(0x57, 0x03, 0x8ea6),
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0256[] = {</span>
<span class="p_add">+		WRITE_COEF(0x45, 0xd489), /* Set to CTIA type */</span>
<span class="p_add">+		WRITE_COEF(0x1b, 0x0c6b),</span>
<span class="p_add">+		WRITE_COEFEX(0x57, 0x03, 0x8ea6),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
 	static struct coef_fw coef0233[] = {
 		WRITE_COEF(0x45, 0xd429),
 		WRITE_COEF(0x1b, 0x0c2b),
<span class="p_chunk">@@ -3936,9 +3958,11 @@</span> <span class="p_context"> static void alc_headset_mode_ctia(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_del">-	case 0x10ec0256:</span>
 		alc_process_coef_fw(codec, coef0255);
 		break;
<span class="p_add">+	case 0x10ec0256:</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0256);</span>
<span class="p_add">+		break;</span>
 	case 0x10ec0233:
 	case 0x10ec0283:
 		alc_process_coef_fw(codec, coef0233);
<span class="p_chunk">@@ -3978,6 +4002,12 @@</span> <span class="p_context"> static void alc_headset_mode_omtp(struct hda_codec *codec)</span>
 		WRITE_COEFEX(0x57, 0x03, 0x8ea6),
 		{}
 	};
<span class="p_add">+	static struct coef_fw coef0256[] = {</span>
<span class="p_add">+		WRITE_COEF(0x45, 0xe489), /* Set to OMTP Type */</span>
<span class="p_add">+		WRITE_COEF(0x1b, 0x0c6b),</span>
<span class="p_add">+		WRITE_COEFEX(0x57, 0x03, 0x8ea6),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
 	static struct coef_fw coef0233[] = {
 		WRITE_COEF(0x45, 0xe429),
 		WRITE_COEF(0x1b, 0x0c2b),
<span class="p_chunk">@@ -4018,9 +4048,11 @@</span> <span class="p_context"> static void alc_headset_mode_omtp(struct hda_codec *codec)</span>
 
 	switch (codec-&gt;core.vendor_id) {
 	case 0x10ec0255:
<span class="p_del">-	case 0x10ec0256:</span>
 		alc_process_coef_fw(codec, coef0255);
 		break;
<span class="p_add">+	case 0x10ec0256:</span>
<span class="p_add">+		alc_process_coef_fw(codec, coef0256);</span>
<span class="p_add">+		break;</span>
 	case 0x10ec0233:
 	case 0x10ec0283:
 		alc_process_coef_fw(codec, coef0233);
<span class="p_chunk">@@ -4266,7 +4298,7 @@</span> <span class="p_context"> static void alc_fixup_headset_mode_no_hp_mic(struct hda_codec *codec,</span>
 static void alc255_set_default_jack_type(struct hda_codec *codec)
 {
 	/* Set to iphone type */
<span class="p_del">-	static struct coef_fw fw[] = {</span>
<span class="p_add">+	static struct coef_fw alc255fw[] = {</span>
 		WRITE_COEF(0x1b, 0x880b),
 		WRITE_COEF(0x45, 0xd089),
 		WRITE_COEF(0x1b, 0x080b),
<span class="p_chunk">@@ -4274,7 +4306,22 @@</span> <span class="p_context"> static void alc255_set_default_jack_type(struct hda_codec *codec)</span>
 		WRITE_COEF(0x1b, 0x0c0b),
 		{}
 	};
<span class="p_del">-	alc_process_coef_fw(codec, fw);</span>
<span class="p_add">+	static struct coef_fw alc256fw[] = {</span>
<span class="p_add">+		WRITE_COEF(0x1b, 0x884b),</span>
<span class="p_add">+		WRITE_COEF(0x45, 0xd089),</span>
<span class="p_add">+		WRITE_COEF(0x1b, 0x084b),</span>
<span class="p_add">+		WRITE_COEF(0x46, 0x0004),</span>
<span class="p_add">+		WRITE_COEF(0x1b, 0x0c4b),</span>
<span class="p_add">+		{}</span>
<span class="p_add">+	};</span>
<span class="p_add">+	switch (codec-&gt;core.vendor_id) {</span>
<span class="p_add">+	case 0x10ec0255:</span>
<span class="p_add">+		alc_process_coef_fw(codec, alc255fw);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case 0x10ec0256:</span>
<span class="p_add">+		alc_process_coef_fw(codec, alc256fw);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
 	msleep(30);
 }
 
<span class="p_chunk">@@ -5587,6 +5634,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x17aa, 0x2218, &quot;Thinkpad X1 Carbon 2nd&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2223, &quot;ThinkPad T550&quot;, ALC292_FIXUP_TPT440_DOCK),
 	SND_PCI_QUIRK(0x17aa, 0x2226, &quot;ThinkPad X250&quot;, ALC292_FIXUP_TPT440_DOCK),
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2231, &quot;Thinkpad T560&quot;, ALC292_FIXUP_TPT460),</span>
 	SND_PCI_QUIRK(0x17aa, 0x2233, &quot;Thinkpad&quot;, ALC292_FIXUP_TPT460),
 	SND_PCI_QUIRK(0x17aa, 0x30bb, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),
 	SND_PCI_QUIRK(0x17aa, 0x30e2, &quot;ThinkCentre AIO&quot;, ALC233_FIXUP_LENOVO_LINE2_MIC_HOTKEY),
<span class="p_chunk">@@ -5775,6 +5823,10 @@</span> <span class="p_context"> static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {</span>
 		{0x12, 0x90a60180},
 		{0x14, 0x90170130},
 		{0x21, 0x02211040}),
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell Inspiron 5565&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
<span class="p_add">+		{0x12, 0x90a60180},</span>
<span class="p_add">+		{0x14, 0x90170120},</span>
<span class="p_add">+		{0x21, 0x02211030}),</span>
 	SND_HDA_PIN_QUIRK(0x10ec0256, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
 		{0x12, 0x90a60160},
 		{0x14, 0x90170120},
<span class="p_chunk">@@ -6053,6 +6105,14 @@</span> <span class="p_context"> static int patch_alc269(struct hda_codec *codec)</span>
 	case 0x10ec0294:
 		spec-&gt;codec_variant = ALC269_TYPE_ALC294;
 		break;
<span class="p_add">+	case 0x10ec0700:</span>
<span class="p_add">+	case 0x10ec0701:</span>
<span class="p_add">+	case 0x10ec0703:</span>
<span class="p_add">+		spec-&gt;codec_variant = ALC269_TYPE_ALC700;</span>
<span class="p_add">+		spec-&gt;gen.mixer_nid = 0; /* ALC700 does not have any loopback mixer path */</span>
<span class="p_add">+		alc_update_coef_idx(codec, 0x4a, 0, 1 &lt;&lt; 15); /* Combo jack auto trigger control */</span>
<span class="p_add">+		break;</span>
<span class="p_add">+</span>
 	}
 
 	if (snd_hda_codec_read(codec, 0x51, 0, AC_VERB_PARAMETERS, 0) == 0x10ec5505) {
<span class="p_chunk">@@ -7008,6 +7068,9 @@</span> <span class="p_context"> static const struct hda_device_id snd_hda_id_realtek[] = {</span>
 	HDA_CODEC_ENTRY(0x10ec0670, &quot;ALC670&quot;, patch_alc662),
 	HDA_CODEC_ENTRY(0x10ec0671, &quot;ALC671&quot;, patch_alc662),
 	HDA_CODEC_ENTRY(0x10ec0680, &quot;ALC680&quot;, patch_alc680),
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0700, &quot;ALC700&quot;, patch_alc269),</span>
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0701, &quot;ALC701&quot;, patch_alc269),</span>
<span class="p_add">+	HDA_CODEC_ENTRY(0x10ec0703, &quot;ALC703&quot;, patch_alc269),</span>
 	HDA_CODEC_ENTRY(0x10ec0867, &quot;ALC891&quot;, patch_alc882),
 	HDA_CODEC_ENTRY(0x10ec0880, &quot;ALC880&quot;, patch_alc880),
 	HDA_CODEC_ENTRY(0x10ec0882, &quot;ALC882&quot;, patch_alc882),
<span class="p_header">diff --git a/virt/kvm/irqchip.c b/virt/kvm/irqchip.c</span>
<span class="p_header">index f0b08a2a48ba..7d31d8c5b9ea 100644</span>
<span class="p_header">--- a/virt/kvm/irqchip.c</span>
<span class="p_header">+++ b/virt/kvm/irqchip.c</span>
<span class="p_chunk">@@ -40,7 +40,7 @@</span> <span class="p_context"> int kvm_irq_map_gsi(struct kvm *kvm,</span>
 
 	irq_rt = srcu_dereference_check(kvm-&gt;irq_routing, &amp;kvm-&gt;irq_srcu,
 					lockdep_is_held(&amp;kvm-&gt;irq_lock));
<span class="p_del">-	if (gsi &lt; irq_rt-&gt;nr_rt_entries) {</span>
<span class="p_add">+	if (irq_rt &amp;&amp; gsi &lt; irq_rt-&gt;nr_rt_entries) {</span>
 		hlist_for_each_entry(e, &amp;irq_rt-&gt;map[gsi], link) {
 			entries[n] = *e;
 			++n;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



