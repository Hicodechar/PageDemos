
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.23 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.23</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 30, 2016, 8:56 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160930085627.GB31792@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9357803/mbox/"
   >mbox</a>
|
   <a href="/patch/9357803/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9357803/">/patch/9357803/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	E63F86075E for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 30 Sep 2016 08:57:25 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CC7FF29F11
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 30 Sep 2016 08:57:25 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id C09C829F12; Fri, 30 Sep 2016 08:57:25 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 3A14829F13
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 30 Sep 2016 08:57:20 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932418AbcI3I5M (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 30 Sep 2016 04:57:12 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:59000 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752843AbcI3I4Z (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 30 Sep 2016 04:56:25 -0400
Received: from localhost (unknown [89.202.203.52])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 9B3DC8A6;
	Fri, 30 Sep 2016 08:56:22 +0000 (UTC)
Date: Fri, 30 Sep 2016 10:56:27 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.23
Message-ID: &lt;20160930085627.GB31792@kroah.com&gt;
References: &lt;20160930085619.GA31792@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160930085619.GA31792@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 30, 2016, 8:56 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index a6512f4eec9f..95421b688f23 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 22</span>
<span class="p_add">+SUBLEVEL = 23</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_chunk">@@ -128,6 +128,10 @@</span> <span class="p_context"> _all:</span>
 # Cancel implicit rules on top Makefile
 $(CURDIR)/Makefile Makefile: ;
 
<span class="p_add">+ifneq ($(words $(subst :, ,$(CURDIR))), 1)</span>
<span class="p_add">+  $(error main directory cannot contain spaces nor colons)</span>
<span class="p_add">+endif</span>
<span class="p_add">+</span>
 ifneq ($(KBUILD_OUTPUT),)
 # Invoke a second make in the output directory, passing relevant variables
 # check that the output directory actually exists
<span class="p_chunk">@@ -495,6 +499,12 @@</span> <span class="p_context"> ifeq ($(KBUILD_EXTMOD),)</span>
                 endif
         endif
 endif
<span class="p_add">+# install and module_install need also be processed one by one</span>
<span class="p_add">+ifneq ($(filter install,$(MAKECMDGOALS)),)</span>
<span class="p_add">+        ifneq ($(filter modules_install,$(MAKECMDGOALS)),)</span>
<span class="p_add">+	        mixed-targets := 1</span>
<span class="p_add">+        endif</span>
<span class="p_add">+endif</span>
 
 ifeq ($(mixed-targets),1)
 # ===========================================================================
<span class="p_chunk">@@ -606,11 +616,16 @@</span> <span class="p_context"> ARCH_CFLAGS :=</span>
 include arch/$(SRCARCH)/Makefile
 
 KBUILD_CFLAGS	+= $(call cc-option,-fno-delete-null-pointer-checks,)
<span class="p_add">+KBUILD_CFLAGS	+= $(call cc-disable-warning,maybe-uninitialized,)</span>
 
 ifdef CONFIG_CC_OPTIMIZE_FOR_SIZE
<span class="p_del">-KBUILD_CFLAGS	+= -Os $(call cc-disable-warning,maybe-uninitialized,)</span>
<span class="p_add">+KBUILD_CFLAGS	+= -Os</span>
 else
<span class="p_add">+ifdef CONFIG_PROFILE_ALL_BRANCHES</span>
 KBUILD_CFLAGS	+= -O2
<span class="p_add">+else</span>
<span class="p_add">+KBUILD_CFLAGS   += -O2</span>
<span class="p_add">+endif</span>
 endif
 
 # Tell gcc to never replace conditional load with a non-conditional one
<span class="p_chunk">@@ -1260,7 +1275,7 @@</span> <span class="p_context"> help:</span>
 	@echo  &#39;  firmware_install- Install all firmware to INSTALL_FW_PATH&#39;
 	@echo  &#39;                    (default: $$(INSTALL_MOD_PATH)/lib/firmware)&#39;
 	@echo  &#39;  dir/            - Build all files in dir and below&#39;
<span class="p_del">-	@echo  &#39;  dir/file.[oisS] - Build specified target only&#39;</span>
<span class="p_add">+	@echo  &#39;  dir/file.[ois]  - Build specified target only&#39;</span>
 	@echo  &#39;  dir/file.lst    - Build specified mixed source/assembly target only&#39;
 	@echo  &#39;                    (requires a recent binutils and recent build (System.map))&#39;
 	@echo  &#39;  dir/file.ko     - Build module including final link&#39;
<span class="p_chunk">@@ -1500,11 +1515,11 @@</span> <span class="p_context"> image_name:</span>
 # Clear a bunch of variables before executing the submake
 tools/: FORCE
 	$(Q)mkdir -p $(objtree)/tools
<span class="p_del">-	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS=&quot;$(filter --j% -j,$(MAKEFLAGS))&quot; O=$(O) subdir=tools -C $(src)/tools/</span>
<span class="p_add">+	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS=&quot;$(filter --j% -j,$(MAKEFLAGS))&quot; O=$(shell cd $(objtree) &amp;&amp; /bin/pwd) subdir=tools -C $(src)/tools/</span>
 
 tools/%: FORCE
 	$(Q)mkdir -p $(objtree)/tools
<span class="p_del">-	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS=&quot;$(filter --j% -j,$(MAKEFLAGS))&quot; O=$(O) subdir=tools -C $(src)/tools/ $*</span>
<span class="p_add">+	$(Q)$(MAKE) LDFLAGS= MAKEFLAGS=&quot;$(filter --j% -j,$(MAKEFLAGS))&quot; O=$(shell cd $(objtree) &amp;&amp; /bin/pwd) subdir=tools -C $(src)/tools/ $*</span>
 
 # Single targets
 # ---------------------------------------------------------------------------
<span class="p_header">diff --git a/arch/arm/crypto/aes-ce-glue.c b/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_header">index b445a5d56f43..593da7ffb449 100644</span>
<span class="p_header">--- a/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_header">+++ b/arch/arm/crypto/aes-ce-glue.c</span>
<span class="p_chunk">@@ -279,7 +279,7 @@</span> <span class="p_context"> static int ctr_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,</span>
 		err = blkcipher_walk_done(desc, &amp;walk,
 					  walk.nbytes % AES_BLOCK_SIZE);
 	}
<span class="p_del">-	if (nbytes) {</span>
<span class="p_add">+	if (walk.nbytes % AES_BLOCK_SIZE) {</span>
 		u8 *tdst = walk.dst.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 *tsrc = walk.src.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 __aligned(8) tail[AES_BLOCK_SIZE];
<span class="p_header">diff --git a/arch/arm/mach-pxa/idp.c b/arch/arm/mach-pxa/idp.c</span>
<span class="p_header">index f6d02e4cbcda..5c87dff5d46e 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/idp.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/idp.c</span>
<span class="p_chunk">@@ -83,7 +83,8 @@</span> <span class="p_context"> static struct resource smc91x_resources[] = {</span>
 };
 
 static struct smc91x_platdata smc91x_platdata = {
<span class="p_del">-	.flags = SMC91X_USE_32BIT | SMC91X_USE_DMA | SMC91X_NOWAIT,</span>
<span class="p_add">+	.flags = SMC91X_USE_8BIT | SMC91X_USE_16BIT | SMC91X_USE_32BIT |</span>
<span class="p_add">+		 SMC91X_USE_DMA | SMC91X_NOWAIT,</span>
 };
 
 static struct platform_device smc91x_device = {
<span class="p_header">diff --git a/arch/arm/mach-pxa/xcep.c b/arch/arm/mach-pxa/xcep.c</span>
<span class="p_header">index 13b1d4586d7d..9001312710f7 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/xcep.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/xcep.c</span>
<span class="p_chunk">@@ -120,7 +120,8 @@</span> <span class="p_context"> static struct resource smc91x_resources[] = {</span>
 };
 
 static struct smc91x_platdata xcep_smc91x_info = {
<span class="p_del">-	.flags	= SMC91X_USE_32BIT | SMC91X_NOWAIT | SMC91X_USE_DMA,</span>
<span class="p_add">+	.flags	= SMC91X_USE_8BIT | SMC91X_USE_16BIT | SMC91X_USE_32BIT |</span>
<span class="p_add">+		  SMC91X_NOWAIT | SMC91X_USE_DMA,</span>
 };
 
 static struct platform_device smc91x_device = {
<span class="p_header">diff --git a/arch/arm/mach-realview/core.c b/arch/arm/mach-realview/core.c</span>
<span class="p_header">index 44575edc44b1..cf0a7c2359f0 100644</span>
<span class="p_header">--- a/arch/arm/mach-realview/core.c</span>
<span class="p_header">+++ b/arch/arm/mach-realview/core.c</span>
<span class="p_chunk">@@ -95,7 +95,8 @@</span> <span class="p_context"> static struct smsc911x_platform_config smsc911x_config = {</span>
 };
 
 static struct smc91x_platdata smc91x_platdata = {
<span class="p_del">-	.flags = SMC91X_USE_32BIT | SMC91X_NOWAIT,</span>
<span class="p_add">+	.flags = SMC91X_USE_8BIT | SMC91X_USE_16BIT | SMC91X_USE_32BIT |</span>
<span class="p_add">+		 SMC91X_NOWAIT,</span>
 };
 
 static struct platform_device realview_eth_device = {
<span class="p_header">diff --git a/arch/arm/mach-sa1100/pleb.c b/arch/arm/mach-sa1100/pleb.c</span>
<span class="p_header">index 1525d7b5f1b7..88149f85bc49 100644</span>
<span class="p_header">--- a/arch/arm/mach-sa1100/pleb.c</span>
<span class="p_header">+++ b/arch/arm/mach-sa1100/pleb.c</span>
<span class="p_chunk">@@ -45,7 +45,7 @@</span> <span class="p_context"> static struct resource smc91x_resources[] = {</span>
 };
 
 static struct smc91x_platdata smc91x_platdata = {
<span class="p_del">-	.flags = SMC91X_USE_16BIT | SMC91X_NOWAIT,</span>
<span class="p_add">+	.flags = SMC91X_USE_16BIT | SMC91X_USE_8BIT | SMC91X_NOWAIT,</span>
 };
 
 static struct platform_device smc91x_device = {
<span class="p_header">diff --git a/arch/arm64/crypto/aes-glue.c b/arch/arm64/crypto/aes-glue.c</span>
<span class="p_header">index 05d9e16c0dfd..6a51dfccfe71 100644</span>
<span class="p_header">--- a/arch/arm64/crypto/aes-glue.c</span>
<span class="p_header">+++ b/arch/arm64/crypto/aes-glue.c</span>
<span class="p_chunk">@@ -211,7 +211,7 @@</span> <span class="p_context"> static int ctr_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,</span>
 		err = blkcipher_walk_done(desc, &amp;walk,
 					  walk.nbytes % AES_BLOCK_SIZE);
 	}
<span class="p_del">-	if (nbytes) {</span>
<span class="p_add">+	if (walk.nbytes % AES_BLOCK_SIZE) {</span>
 		u8 *tdst = walk.dst.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 *tsrc = walk.src.virt.addr + blocks * AES_BLOCK_SIZE;
 		u8 __aligned(8) tail[AES_BLOCK_SIZE];
<span class="p_header">diff --git a/arch/blackfin/mach-bf561/boards/cm_bf561.c b/arch/blackfin/mach-bf561/boards/cm_bf561.c</span>
<span class="p_header">index c6db52ba3a06..10c57771822d 100644</span>
<span class="p_header">--- a/arch/blackfin/mach-bf561/boards/cm_bf561.c</span>
<span class="p_header">+++ b/arch/blackfin/mach-bf561/boards/cm_bf561.c</span>
<span class="p_chunk">@@ -146,7 +146,8 @@</span> <span class="p_context"> static struct platform_device hitachi_fb_device = {</span>
 #include &lt;linux/smc91x.h&gt;
 
 static struct smc91x_platdata smc91x_info = {
<span class="p_del">-	.flags = SMC91X_USE_32BIT | SMC91X_NOWAIT,</span>
<span class="p_add">+	.flags = SMC91X_USE_8BIT | SMC91X_USE_16BIT | SMC91X_USE_32BIT |</span>
<span class="p_add">+		 SMC91X_NOWAIT,</span>
 	.leda = RPC_LED_100_10,
 	.ledb = RPC_LED_TX_RX,
 };
<span class="p_header">diff --git a/arch/blackfin/mach-bf561/boards/ezkit.c b/arch/blackfin/mach-bf561/boards/ezkit.c</span>
<span class="p_header">index 2de71e8c104b..93c22468cc14 100644</span>
<span class="p_header">--- a/arch/blackfin/mach-bf561/boards/ezkit.c</span>
<span class="p_header">+++ b/arch/blackfin/mach-bf561/boards/ezkit.c</span>
<span class="p_chunk">@@ -134,7 +134,8 @@</span> <span class="p_context"> static struct platform_device net2272_bfin_device = {</span>
 #include &lt;linux/smc91x.h&gt;
 
 static struct smc91x_platdata smc91x_info = {
<span class="p_del">-	.flags = SMC91X_USE_32BIT | SMC91X_NOWAIT,</span>
<span class="p_add">+	.flags = SMC91X_USE_8BIT | SMC91X_USE_16BIT | SMC91X_USE_32BIT |</span>
<span class="p_add">+		 SMC91X_NOWAIT,</span>
 	.leda = RPC_LED_100_10,
 	.ledb = RPC_LED_TX_RX,
 };
<span class="p_header">diff --git a/arch/mips/Kconfig.debug b/arch/mips/Kconfig.debug</span>
<span class="p_header">index f0e314ceb8ba..7f975b20b20c 100644</span>
<span class="p_header">--- a/arch/mips/Kconfig.debug</span>
<span class="p_header">+++ b/arch/mips/Kconfig.debug</span>
<span class="p_chunk">@@ -113,42 +113,6 @@</span> <span class="p_context"> config SPINLOCK_TEST</span>
 	help
 	  Add several files to the debugfs to test spinlock speed.
 
<span class="p_del">-if CPU_MIPSR6</span>
<span class="p_del">-</span>
<span class="p_del">-choice</span>
<span class="p_del">-	prompt &quot;Compact branch policy&quot;</span>
<span class="p_del">-	default MIPS_COMPACT_BRANCHES_OPTIMAL</span>
<span class="p_del">-</span>
<span class="p_del">-config MIPS_COMPACT_BRANCHES_NEVER</span>
<span class="p_del">-	bool &quot;Never (force delay slot branches)&quot;</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Pass the -mcompact-branches=never flag to the compiler in order to</span>
<span class="p_del">-	  force it to always emit branches with delay slots, and make no use</span>
<span class="p_del">-	  of the compact branch instructions introduced by MIPSr6. This is</span>
<span class="p_del">-	  useful if you suspect there may be an issue with compact branches in</span>
<span class="p_del">-	  either the compiler or the CPU.</span>
<span class="p_del">-</span>
<span class="p_del">-config MIPS_COMPACT_BRANCHES_OPTIMAL</span>
<span class="p_del">-	bool &quot;Optimal (use where beneficial)&quot;</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Pass the -mcompact-branches=optimal flag to the compiler in order for</span>
<span class="p_del">-	  it to make use of compact branch instructions where it deems them</span>
<span class="p_del">-	  beneficial, and use branches with delay slots elsewhere. This is the</span>
<span class="p_del">-	  default compiler behaviour, and should be used unless you have a</span>
<span class="p_del">-	  reason to choose otherwise.</span>
<span class="p_del">-</span>
<span class="p_del">-config MIPS_COMPACT_BRANCHES_ALWAYS</span>
<span class="p_del">-	bool &quot;Always (force compact branches)&quot;</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  Pass the -mcompact-branches=always flag to the compiler in order to</span>
<span class="p_del">-	  force it to always emit compact branches, making no use of branch</span>
<span class="p_del">-	  instructions with delay slots. This can result in more compact code</span>
<span class="p_del">-	  which may be beneficial in some scenarios.</span>
<span class="p_del">-</span>
<span class="p_del">-endchoice</span>
<span class="p_del">-</span>
<span class="p_del">-endif # CPU_MIPSR6</span>
<span class="p_del">-</span>
 config SCACHE_DEBUGFS
 	bool &quot;L2 cache debugfs entries&quot;
 	depends on DEBUG_FS
<span class="p_header">diff --git a/arch/mips/Makefile b/arch/mips/Makefile</span>
<span class="p_header">index 3f70ba54ae21..252e347958f3 100644</span>
<span class="p_header">--- a/arch/mips/Makefile</span>
<span class="p_header">+++ b/arch/mips/Makefile</span>
<span class="p_chunk">@@ -204,10 +204,6 @@</span> <span class="p_context"> toolchain-msa				:= $(call cc-option-yn,$(mips-cflags) -mhard-float -mfp64 -Wa$(</span>
 cflags-$(toolchain-msa)			+= -DTOOLCHAIN_SUPPORTS_MSA
 endif
 
<span class="p_del">-cflags-$(CONFIG_MIPS_COMPACT_BRANCHES_NEVER)	+= -mcompact-branches=never</span>
<span class="p_del">-cflags-$(CONFIG_MIPS_COMPACT_BRANCHES_OPTIMAL)	+= -mcompact-branches=optimal</span>
<span class="p_del">-cflags-$(CONFIG_MIPS_COMPACT_BRANCHES_ALWAYS)	+= -mcompact-branches=always</span>
<span class="p_del">-</span>
 #
 # Firmware support
 #
<span class="p_header">diff --git a/arch/mips/include/asm/asmmacro.h b/arch/mips/include/asm/asmmacro.h</span>
<span class="p_header">index e689b894353c..8dedee1def83 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/asmmacro.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/asmmacro.h</span>
<span class="p_chunk">@@ -135,6 +135,7 @@</span> <span class="p_context"></span>
 	ldc1	$f28, THREAD_FPR28(\thread)
 	ldc1	$f30, THREAD_FPR30(\thread)
 	ctc1	\tmp, fcr31
<span class="p_add">+	.set	pop</span>
 	.endm
 
 	.macro	fpu_restore_16odd thread
<span class="p_header">diff --git a/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h b/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_header">index 2f82bfa3a773..c9f5769dfc8f 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/mach-paravirt/kernel-entry-init.h</span>
<span class="p_chunk">@@ -11,11 +11,13 @@</span> <span class="p_context"></span>
 #define CP0_EBASE $15, 1
 
 	.macro  kernel_entry_setup
<span class="p_add">+#ifdef CONFIG_SMP</span>
 	mfc0	t0, CP0_EBASE
 	andi	t0, t0, 0x3ff		# CPUNum
 	beqz	t0, 1f
 	# CPUs other than zero goto smp_bootstrap
 	j	smp_bootstrap
<span class="p_add">+#endif /* CONFIG_SMP */</span>
 
 1:
 	.endm
<span class="p_header">diff --git a/arch/mips/kernel/mips-r2-to-r6-emul.c b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">index 4674a74a08b5..af27334d6809 100644</span>
<span class="p_header">--- a/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_header">+++ b/arch/mips/kernel/mips-r2-to-r6-emul.c</span>
<span class="p_chunk">@@ -1164,7 +1164,9 @@</span> <span class="p_context"> fpu_emul:</span>
 		regs-&gt;regs[31] = r31;
 		regs-&gt;cp0_epc = epc;
 		if (!used_math()) {     /* First time FPU user.  */
<span class="p_add">+			preempt_disable();</span>
 			err = init_fpu();
<span class="p_add">+			preempt_enable();</span>
 			set_used_math();
 		}
 		lose_fpu(1);    /* Save FPU state for the emulator. */
<span class="p_header">diff --git a/arch/mips/kernel/process.c b/arch/mips/kernel/process.c</span>
<span class="p_header">index 89847bee2b53..44a6f25e902e 100644</span>
<span class="p_header">--- a/arch/mips/kernel/process.c</span>
<span class="p_header">+++ b/arch/mips/kernel/process.c</span>
<span class="p_chunk">@@ -593,14 +593,14 @@</span> <span class="p_context"> int mips_set_process_fp_mode(struct task_struct *task, unsigned int value)</span>
 		return -EOPNOTSUPP;
 
 	/* Avoid inadvertently triggering emulation */
<span class="p_del">-	if ((value &amp; PR_FP_MODE_FR) &amp;&amp; cpu_has_fpu &amp;&amp;</span>
<span class="p_del">-	    !(current_cpu_data.fpu_id &amp; MIPS_FPIR_F64))</span>
<span class="p_add">+	if ((value &amp; PR_FP_MODE_FR) &amp;&amp; raw_cpu_has_fpu &amp;&amp;</span>
<span class="p_add">+	    !(raw_current_cpu_data.fpu_id &amp; MIPS_FPIR_F64))</span>
 		return -EOPNOTSUPP;
<span class="p_del">-	if ((value &amp; PR_FP_MODE_FRE) &amp;&amp; cpu_has_fpu &amp;&amp; !cpu_has_fre)</span>
<span class="p_add">+	if ((value &amp; PR_FP_MODE_FRE) &amp;&amp; raw_cpu_has_fpu &amp;&amp; !cpu_has_fre)</span>
 		return -EOPNOTSUPP;
 
 	/* FR = 0 not supported in MIPS R6 */
<span class="p_del">-	if (!(value &amp; PR_FP_MODE_FR) &amp;&amp; cpu_has_fpu &amp;&amp; cpu_has_mips_r6)</span>
<span class="p_add">+	if (!(value &amp; PR_FP_MODE_FR) &amp;&amp; raw_cpu_has_fpu &amp;&amp; cpu_has_mips_r6)</span>
 		return -EOPNOTSUPP;
 
 	/* Proceed with the mode switch */
<span class="p_header">diff --git a/arch/mips/kernel/smp.c b/arch/mips/kernel/smp.c</span>
<span class="p_header">index 2b521e07b860..7fef02a9eb85 100644</span>
<span class="p_header">--- a/arch/mips/kernel/smp.c</span>
<span class="p_header">+++ b/arch/mips/kernel/smp.c</span>
<span class="p_chunk">@@ -174,6 +174,9 @@</span> <span class="p_context"> asmlinkage void start_secondary(void)</span>
 	cpumask_set_cpu(cpu, &amp;cpu_coherent_mask);
 	notify_cpu_starting(cpu);
 
<span class="p_add">+	cpumask_set_cpu(cpu, &amp;cpu_callin_map);</span>
<span class="p_add">+	synchronise_count_slave(cpu);</span>
<span class="p_add">+</span>
 	set_cpu_online(cpu, true);
 
 	set_cpu_sibling_map(cpu);
<span class="p_chunk">@@ -181,10 +184,6 @@</span> <span class="p_context"> asmlinkage void start_secondary(void)</span>
 
 	calculate_cpu_foreign_map();
 
<span class="p_del">-	cpumask_set_cpu(cpu, &amp;cpu_callin_map);</span>
<span class="p_del">-</span>
<span class="p_del">-	synchronise_count_slave(cpu);</span>
<span class="p_del">-</span>
 	/*
 	 * irq will be enabled in -&gt;smp_finish(), enabling it too early
 	 * is dangerous.
<span class="p_header">diff --git a/arch/mips/kernel/vdso.c b/arch/mips/kernel/vdso.c</span>
<span class="p_header">index 975e99759bab..5649a9e429e0 100644</span>
<span class="p_header">--- a/arch/mips/kernel/vdso.c</span>
<span class="p_header">+++ b/arch/mips/kernel/vdso.c</span>
<span class="p_chunk">@@ -39,16 +39,16 @@</span> <span class="p_context"> static struct vm_special_mapping vdso_vvar_mapping = {</span>
 static void __init init_vdso_image(struct mips_vdso_image *image)
 {
 	unsigned long num_pages, i;
<span class="p_add">+	unsigned long data_pfn;</span>
 
 	BUG_ON(!PAGE_ALIGNED(image-&gt;data));
 	BUG_ON(!PAGE_ALIGNED(image-&gt;size));
 
 	num_pages = image-&gt;size / PAGE_SIZE;
 
<span class="p_del">-	for (i = 0; i &lt; num_pages; i++) {</span>
<span class="p_del">-		image-&gt;mapping.pages[i] =</span>
<span class="p_del">-			virt_to_page(image-&gt;data + (i * PAGE_SIZE));</span>
<span class="p_del">-	}</span>
<span class="p_add">+	data_pfn = __phys_to_pfn(__pa_symbol(image-&gt;data));</span>
<span class="p_add">+	for (i = 0; i &lt; num_pages; i++)</span>
<span class="p_add">+		image-&gt;mapping.pages[i] = pfn_to_page(data_pfn + i);</span>
 }
 
 static int __init init_vdso(void)
<span class="p_header">diff --git a/crypto/blkcipher.c b/crypto/blkcipher.c</span>
<span class="p_header">index 8cc1622b2ee0..dca7bc87dad9 100644</span>
<span class="p_header">--- a/crypto/blkcipher.c</span>
<span class="p_header">+++ b/crypto/blkcipher.c</span>
<span class="p_chunk">@@ -234,6 +234,8 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		return blkcipher_walk_done(desc, walk, -EINVAL);
 	}
 
<span class="p_add">+	bsize = min(walk-&gt;walk_blocksize, n);</span>
<span class="p_add">+</span>
 	walk-&gt;flags &amp;= ~(BLKCIPHER_WALK_SLOW | BLKCIPHER_WALK_COPY |
 			 BLKCIPHER_WALK_DIFF);
 	if (!scatterwalk_aligned(&amp;walk-&gt;in, walk-&gt;alignmask) ||
<span class="p_chunk">@@ -246,7 +248,6 @@</span> <span class="p_context"> static int blkcipher_walk_next(struct blkcipher_desc *desc,</span>
 		}
 	}
 
<span class="p_del">-	bsize = min(walk-&gt;walk_blocksize, n);</span>
 	n = scatterwalk_clamp(&amp;walk-&gt;in, n);
 	n = scatterwalk_clamp(&amp;walk-&gt;out, n);
 
<span class="p_header">diff --git a/crypto/echainiv.c b/crypto/echainiv.c</span>
<span class="p_header">index b96a84560b67..343a74e96e2a 100644</span>
<span class="p_header">--- a/crypto/echainiv.c</span>
<span class="p_header">+++ b/crypto/echainiv.c</span>
<span class="p_chunk">@@ -1,8 +1,8 @@</span> <span class="p_context"></span>
 /*
  * echainiv: Encrypted Chain IV Generator
  *
<span class="p_del">- * This generator generates an IV based on a sequence number by xoring it</span>
<span class="p_del">- * with a salt and then encrypting it with the same key as used to encrypt</span>
<span class="p_add">+ * This generator generates an IV based on a sequence number by multiplying</span>
<span class="p_add">+ * it with a salt and then encrypting it with the same key as used to encrypt</span>
  * the plain text.  This algorithm requires that the block size be equal
  * to the IV size.  It is mainly useful for CBC.
  *
<span class="p_chunk">@@ -23,81 +23,17 @@</span> <span class="p_context"></span>
 #include &lt;linux/err.h&gt;
 #include &lt;linux/init.h&gt;
 #include &lt;linux/kernel.h&gt;
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
 #include &lt;linux/module.h&gt;
<span class="p_del">-#include &lt;linux/percpu.h&gt;</span>
<span class="p_del">-#include &lt;linux/spinlock.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
 #include &lt;linux/string.h&gt;
 
<span class="p_del">-#define MAX_IV_SIZE 16</span>
<span class="p_del">-</span>
<span class="p_del">-static DEFINE_PER_CPU(u32 [MAX_IV_SIZE / sizeof(u32)], echainiv_iv);</span>
<span class="p_del">-</span>
<span class="p_del">-/* We don&#39;t care if we get preempted and read/write IVs from the next CPU. */</span>
<span class="p_del">-static void echainiv_read_iv(u8 *dst, unsigned size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u32 *a = (u32 *)dst;</span>
<span class="p_del">-	u32 __percpu *b = echainiv_iv;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (; size &gt;= 4; size -= 4) {</span>
<span class="p_del">-		*a++ = this_cpu_read(*b);</span>
<span class="p_del">-		b++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void echainiv_write_iv(const u8 *src, unsigned size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	const u32 *a = (const u32 *)src;</span>
<span class="p_del">-	u32 __percpu *b = echainiv_iv;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (; size &gt;= 4; size -= 4) {</span>
<span class="p_del">-		this_cpu_write(*b, *a);</span>
<span class="p_del">-		a++;</span>
<span class="p_del">-		b++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void echainiv_encrypt_complete2(struct aead_request *req, int err)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct aead_request *subreq = aead_request_ctx(req);</span>
<span class="p_del">-	struct crypto_aead *geniv;</span>
<span class="p_del">-	unsigned int ivsize;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err == -EINPROGRESS)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	geniv = crypto_aead_reqtfm(req);</span>
<span class="p_del">-	ivsize = crypto_aead_ivsize(geniv);</span>
<span class="p_del">-</span>
<span class="p_del">-	echainiv_write_iv(subreq-&gt;iv, ivsize);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (req-&gt;iv != subreq-&gt;iv)</span>
<span class="p_del">-		memcpy(req-&gt;iv, subreq-&gt;iv, ivsize);</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	if (req-&gt;iv != subreq-&gt;iv)</span>
<span class="p_del">-		kzfree(subreq-&gt;iv);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void echainiv_encrypt_complete(struct crypto_async_request *base,</span>
<span class="p_del">-					 int err)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct aead_request *req = base-&gt;data;</span>
<span class="p_del">-</span>
<span class="p_del">-	echainiv_encrypt_complete2(req, err);</span>
<span class="p_del">-	aead_request_complete(req, err);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static int echainiv_encrypt(struct aead_request *req)
 {
 	struct crypto_aead *geniv = crypto_aead_reqtfm(req);
 	struct aead_geniv_ctx *ctx = crypto_aead_ctx(geniv);
 	struct aead_request *subreq = aead_request_ctx(req);
<span class="p_del">-	crypto_completion_t compl;</span>
<span class="p_del">-	void *data;</span>
<span class="p_add">+	__be64 nseqno;</span>
<span class="p_add">+	u64 seqno;</span>
 	u8 *info;
 	unsigned int ivsize = crypto_aead_ivsize(geniv);
 	int err;
<span class="p_chunk">@@ -107,8 +43,6 @@</span> <span class="p_context"> static int echainiv_encrypt(struct aead_request *req)</span>
 
 	aead_request_set_tfm(subreq, ctx-&gt;child);
 
<span class="p_del">-	compl = echainiv_encrypt_complete;</span>
<span class="p_del">-	data = req;</span>
 	info = req-&gt;iv;
 
 	if (req-&gt;src != req-&gt;dst) {
<span class="p_chunk">@@ -123,29 +57,30 @@</span> <span class="p_context"> static int echainiv_encrypt(struct aead_request *req)</span>
 			return err;
 	}
 
<span class="p_del">-	if (unlikely(!IS_ALIGNED((unsigned long)info,</span>
<span class="p_del">-				 crypto_aead_alignmask(geniv) + 1))) {</span>
<span class="p_del">-		info = kmalloc(ivsize, req-&gt;base.flags &amp;</span>
<span class="p_del">-				       CRYPTO_TFM_REQ_MAY_SLEEP ? GFP_KERNEL:</span>
<span class="p_del">-								  GFP_ATOMIC);</span>
<span class="p_del">-		if (!info)</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		memcpy(info, req-&gt;iv, ivsize);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	aead_request_set_callback(subreq, req-&gt;base.flags, compl, data);</span>
<span class="p_add">+	aead_request_set_callback(subreq, req-&gt;base.flags,</span>
<span class="p_add">+				  req-&gt;base.complete, req-&gt;base.data);</span>
 	aead_request_set_crypt(subreq, req-&gt;dst, req-&gt;dst,
 			       req-&gt;cryptlen, info);
 	aead_request_set_ad(subreq, req-&gt;assoclen);
 
<span class="p_del">-	crypto_xor(info, ctx-&gt;salt, ivsize);</span>
<span class="p_add">+	memcpy(&amp;nseqno, info + ivsize - 8, 8);</span>
<span class="p_add">+	seqno = be64_to_cpu(nseqno);</span>
<span class="p_add">+	memset(info, 0, ivsize);</span>
<span class="p_add">+</span>
 	scatterwalk_map_and_copy(info, req-&gt;dst, req-&gt;assoclen, ivsize, 1);
<span class="p_del">-	echainiv_read_iv(info, ivsize);</span>
 
<span class="p_del">-	err = crypto_aead_encrypt(subreq);</span>
<span class="p_del">-	echainiv_encrypt_complete2(req, err);</span>
<span class="p_del">-	return err;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		u64 a;</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(&amp;a, ctx-&gt;salt + ivsize - 8, 8);</span>
<span class="p_add">+</span>
<span class="p_add">+		a |= 1;</span>
<span class="p_add">+		a *= seqno;</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(info + ivsize - 8, &amp;a, 8);</span>
<span class="p_add">+	} while ((ivsize -= 8));</span>
<span class="p_add">+</span>
<span class="p_add">+	return crypto_aead_encrypt(subreq);</span>
 }
 
 static int echainiv_decrypt(struct aead_request *req)
<span class="p_chunk">@@ -192,8 +127,7 @@</span> <span class="p_context"> static int echainiv_aead_create(struct crypto_template *tmpl,</span>
 	alg = crypto_spawn_aead_alg(spawn);
 
 	err = -EINVAL;
<span class="p_del">-	if (inst-&gt;alg.ivsize &amp; (sizeof(u32) - 1) ||</span>
<span class="p_del">-	    inst-&gt;alg.ivsize &gt; MAX_IV_SIZE)</span>
<span class="p_add">+	if (inst-&gt;alg.ivsize &amp; (sizeof(u64) - 1) || !inst-&gt;alg.ivsize)</span>
 		goto free_inst;
 
 	inst-&gt;alg.encrypt = echainiv_encrypt;
<span class="p_chunk">@@ -202,7 +136,6 @@</span> <span class="p_context"> static int echainiv_aead_create(struct crypto_template *tmpl,</span>
 	inst-&gt;alg.init = aead_init_geniv;
 	inst-&gt;alg.exit = aead_exit_geniv;
 
<span class="p_del">-	inst-&gt;alg.base.cra_alignmask |= __alignof__(u32) - 1;</span>
 	inst-&gt;alg.base.cra_ctxsize = sizeof(struct aead_geniv_ctx);
 	inst-&gt;alg.base.cra_ctxsize += inst-&gt;alg.ivsize;
 
<span class="p_header">diff --git a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c</span>
<span class="p_header">index 4bef72a9d106..3fda594700e0 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/nouveau/nvkm/engine/pm/nv40.c</span>
<span class="p_chunk">@@ -59,9 +59,11 @@</span> <span class="p_context"> static void</span>
 nv40_perfctr_next(struct nvkm_pm *pm, struct nvkm_perfdom *dom)
 {
 	struct nvkm_device *device = pm-&gt;engine.subdev.device;
<span class="p_del">-	if (pm-&gt;sequence != pm-&gt;sequence) {</span>
<span class="p_add">+	struct nv40_pm *nv40pm = container_of(pm, struct nv40_pm, base);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nv40pm-&gt;sequence != pm-&gt;sequence) {</span>
 		nvkm_wr32(device, 0x400084, 0x00000020);
<span class="p_del">-		pm-&gt;sequence = pm-&gt;sequence;</span>
<span class="p_add">+		nv40pm-&gt;sequence = pm-&gt;sequence;</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/qxl/qxl_draw.c b/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_header">index 56e1d633875e..6e6c76080d6a 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/qxl/qxl_draw.c</span>
<span class="p_chunk">@@ -136,6 +136,8 @@</span> <span class="p_context"> static int qxl_palette_create_1bit(struct qxl_bo *palette_bo,</span>
 				 * correctly globaly, since that would require
 				 * tracking all of our palettes. */
 	ret = qxl_bo_kmap(palette_bo, (void **)&amp;pal);
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 	pal-&gt;num_ents = 2;
 	pal-&gt;unique = unique++;
 	if (visual == FB_VISUAL_TRUECOLOR || visual == FB_VISUAL_DIRECTCOLOR) {
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-eg20t.c b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">index 76e699f9ed97..eef3aa6007f1 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-eg20t.c</span>
<span class="p_chunk">@@ -773,13 +773,6 @@</span> <span class="p_context"> static int pch_i2c_probe(struct pci_dev *pdev,</span>
 	/* Set the number of I2C channel instance */
 	adap_info-&gt;ch_num = id-&gt;driver_data;
 
<span class="p_del">-	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_del">-		  KBUILD_MODNAME, adap_info);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_del">-		goto err_request_irq;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {
 		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;
 		adap_info-&gt;pch_i2c_suspended = false;
<span class="p_chunk">@@ -796,6 +789,17 @@</span> <span class="p_context"> static int pch_i2c_probe(struct pci_dev *pdev,</span>
 		adap_info-&gt;pch_data[i].pch_base_address = base_addr + 0x100 * i;
 
 		pch_adap-&gt;dev.parent = &amp;pdev-&gt;dev;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = request_irq(pdev-&gt;irq, pch_i2c_handler, IRQF_SHARED,</span>
<span class="p_add">+		  KBUILD_MODNAME, adap_info);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pch_pci_err(pdev, &quot;request_irq FAILED\n&quot;);</span>
<span class="p_add">+		goto err_request_irq;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; adap_info-&gt;ch_num; i++) {</span>
<span class="p_add">+		pch_adap = &amp;adap_info-&gt;pch_data[i].pch_adapter;</span>
 
 		pch_i2c_init(&amp;adap_info-&gt;pch_data[i]);
 
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-qup.c b/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_header">index fdcbdab808e9..33b11563cde7 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-qup.c</span>
<span class="p_chunk">@@ -727,7 +727,8 @@</span> <span class="p_context"> static int qup_i2c_pm_resume_runtime(struct device *device)</span>
 #ifdef CONFIG_PM_SLEEP
 static int qup_i2c_suspend(struct device *device)
 {
<span class="p_del">-	qup_i2c_pm_suspend_runtime(device);</span>
<span class="p_add">+	if (!pm_runtime_suspended(device))</span>
<span class="p_add">+		return qup_i2c_pm_suspend_runtime(device);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/iio/industrialio-core.c b/drivers/iio/industrialio-core.c</span>
<span class="p_header">index 7ede941e9301..131b434af994 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-core.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-core.c</span>
<span class="p_chunk">@@ -433,16 +433,15 @@</span> <span class="p_context"> ssize_t iio_format_value(char *buf, unsigned int type, int size, int *vals)</span>
 		scale_db = true;
 	case IIO_VAL_INT_PLUS_MICRO:
 		if (vals[1] &lt; 0)
<span class="p_del">-			return sprintf(buf, &quot;-%ld.%06u%s\n&quot;, abs(vals[0]),</span>
<span class="p_del">-					-vals[1],</span>
<span class="p_del">-				scale_db ? &quot; dB&quot; : &quot;&quot;);</span>
<span class="p_add">+			return sprintf(buf, &quot;-%d.%06u%s\n&quot;, abs(vals[0]),</span>
<span class="p_add">+				       -vals[1], scale_db ? &quot; dB&quot; : &quot;&quot;);</span>
 		else
 			return sprintf(buf, &quot;%d.%06u%s\n&quot;, vals[0], vals[1],
 				scale_db ? &quot; dB&quot; : &quot;&quot;);
 	case IIO_VAL_INT_PLUS_NANO:
 		if (vals[1] &lt; 0)
<span class="p_del">-			return sprintf(buf, &quot;-%ld.%09u\n&quot;, abs(vals[0]),</span>
<span class="p_del">-					-vals[1]);</span>
<span class="p_add">+			return sprintf(buf, &quot;-%d.%09u\n&quot;, abs(vals[0]),</span>
<span class="p_add">+				       -vals[1]);</span>
 		else
 			return sprintf(buf, &quot;%d.%09u\n&quot;, vals[0], vals[1]);
 	case IIO_VAL_FRACTIONAL:
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index 3821c4786662..565bb2c140ed 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -1858,10 +1858,11 @@</span> <span class="p_context"> static int dmar_hp_remove_drhd(struct acpi_dmar_header *header, void *arg)</span>
 	/*
 	 * All PCI devices managed by this unit should have been destroyed.
 	 */
<span class="p_del">-	if (!dmaru-&gt;include_all &amp;&amp; dmaru-&gt;devices &amp;&amp; dmaru-&gt;devices_cnt)</span>
<span class="p_add">+	if (!dmaru-&gt;include_all &amp;&amp; dmaru-&gt;devices &amp;&amp; dmaru-&gt;devices_cnt) {</span>
 		for_each_active_dev_scope(dmaru-&gt;devices,
 					  dmaru-&gt;devices_cnt, i, dev)
 			return -EBUSY;
<span class="p_add">+	}</span>
 
 	ret = dmar_ir_hotplug(dmaru, false);
 	if (ret == 0)
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 24d81308a1a6..b7f852d824a3 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -4182,10 +4182,11 @@</span> <span class="p_context"> int dmar_check_one_atsr(struct acpi_dmar_header *hdr, void *arg)</span>
 	if (!atsru)
 		return 0;
 
<span class="p_del">-	if (!atsru-&gt;include_all &amp;&amp; atsru-&gt;devices &amp;&amp; atsru-&gt;devices_cnt)</span>
<span class="p_add">+	if (!atsru-&gt;include_all &amp;&amp; atsru-&gt;devices &amp;&amp; atsru-&gt;devices_cnt) {</span>
 		for_each_active_dev_scope(atsru-&gt;devices, atsru-&gt;devices_cnt,
 					  i, dev)
 			return -EBUSY;
<span class="p_add">+	}</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/drivers/media/platform/am437x/am437x-vpfe.c b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">index f0480d687f17..ba780c45f645 100644</span>
<span class="p_header">--- a/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_header">+++ b/drivers/media/platform/am437x/am437x-vpfe.c</span>
<span class="p_chunk">@@ -1706,7 +1706,7 @@</span> <span class="p_context"> static int vpfe_get_app_input_index(struct vpfe_device *vpfe,</span>
 		sdinfo = &amp;cfg-&gt;sub_devs[i];
 		client = v4l2_get_subdevdata(sdinfo-&gt;sd);
 		if (client-&gt;addr == curr_client-&gt;addr &amp;&amp;
<span class="p_del">-		    client-&gt;adapter-&gt;nr == client-&gt;adapter-&gt;nr) {</span>
<span class="p_add">+		    client-&gt;adapter-&gt;nr == curr_client-&gt;adapter-&gt;nr) {</span>
 			if (vpfe-&gt;current_input &gt;= 1)
 				return -1;
 			*app_input_index = j + vpfe-&gt;current_input;
<span class="p_header">diff --git a/drivers/mtd/maps/pmcmsp-flash.c b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">index 744ca5cacc9b..f9fa3fad728e 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/pmcmsp-flash.c</span>
<span class="p_chunk">@@ -75,15 +75,15 @@</span> <span class="p_context"> static int __init init_msp_flash(void)</span>
 
 	printk(KERN_NOTICE &quot;Found %d PMC flash devices\n&quot;, fcnt);
 
<span class="p_del">-	msp_flash = kmalloc(fcnt * sizeof(struct map_info *), GFP_KERNEL);</span>
<span class="p_add">+	msp_flash = kcalloc(fcnt, sizeof(*msp_flash), GFP_KERNEL);</span>
 	if (!msp_flash)
 		return -ENOMEM;
 
<span class="p_del">-	msp_parts = kmalloc(fcnt * sizeof(struct mtd_partition *), GFP_KERNEL);</span>
<span class="p_add">+	msp_parts = kcalloc(fcnt, sizeof(*msp_parts), GFP_KERNEL);</span>
 	if (!msp_parts)
 		goto free_msp_flash;
 
<span class="p_del">-	msp_maps = kcalloc(fcnt, sizeof(struct mtd_info), GFP_KERNEL);</span>
<span class="p_add">+	msp_maps = kcalloc(fcnt, sizeof(*msp_maps), GFP_KERNEL);</span>
 	if (!msp_maps)
 		goto free_msp_parts;
 
<span class="p_header">diff --git a/drivers/mtd/maps/sa1100-flash.c b/drivers/mtd/maps/sa1100-flash.c</span>
<span class="p_header">index 142fc3d79463..784c6e1a0391 100644</span>
<span class="p_header">--- a/drivers/mtd/maps/sa1100-flash.c</span>
<span class="p_header">+++ b/drivers/mtd/maps/sa1100-flash.c</span>
<span class="p_chunk">@@ -230,8 +230,10 @@</span> <span class="p_context"> static struct sa_info *sa1100_setup_mtd(struct platform_device *pdev,</span>
 
 		info-&gt;mtd = mtd_concat_create(cdev, info-&gt;num_subdev,
 					      plat-&gt;name);
<span class="p_del">-		if (info-&gt;mtd == NULL)</span>
<span class="p_add">+		if (info-&gt;mtd == NULL) {</span>
 			ret = -ENXIO;
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
 	}
 	info-&gt;mtd-&gt;dev.parent = &amp;pdev-&gt;dev;
 
<span class="p_header">diff --git a/drivers/net/bonding/bond_main.c b/drivers/net/bonding/bond_main.c</span>
<span class="p_header">index b3d70a7a5262..5dca77e0ffed 100644</span>
<span class="p_header">--- a/drivers/net/bonding/bond_main.c</span>
<span class="p_header">+++ b/drivers/net/bonding/bond_main.c</span>
<span class="p_chunk">@@ -1317,9 +1317,10 @@</span> <span class="p_context"> int bond_enslave(struct net_device *bond_dev, struct net_device *slave_dev)</span>
 			    slave_dev-&gt;name);
 	}
 
<span class="p_del">-	/* already enslaved */</span>
<span class="p_del">-	if (slave_dev-&gt;flags &amp; IFF_SLAVE) {</span>
<span class="p_del">-		netdev_dbg(bond_dev, &quot;Error: Device was already enslaved\n&quot;);</span>
<span class="p_add">+	/* already in-use? */</span>
<span class="p_add">+	if (netdev_is_rx_handler_busy(slave_dev)) {</span>
<span class="p_add">+		netdev_err(bond_dev,</span>
<span class="p_add">+			   &quot;Error: Device is in use and cannot be enslaved\n&quot;);</span>
 		return -EBUSY;
 	}
 
<span class="p_header">diff --git a/drivers/net/can/flexcan.c b/drivers/net/can/flexcan.c</span>
<span class="p_header">index 41c0fc9f3b14..16f7cadda5c3 100644</span>
<span class="p_header">--- a/drivers/net/can/flexcan.c</span>
<span class="p_header">+++ b/drivers/net/can/flexcan.c</span>
<span class="p_chunk">@@ -1268,11 +1268,10 @@</span> <span class="p_context"> static int __maybe_unused flexcan_suspend(struct device *device)</span>
 	struct flexcan_priv *priv = netdev_priv(dev);
 	int err;
 
<span class="p_del">-	err = flexcan_chip_disable(priv);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
 	if (netif_running(dev)) {
<span class="p_add">+		err = flexcan_chip_disable(priv);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 		netif_stop_queue(dev);
 		netif_device_detach(dev);
 	}
<span class="p_chunk">@@ -1285,13 +1284,17 @@</span> <span class="p_context"> static int __maybe_unused flexcan_resume(struct device *device)</span>
 {
 	struct net_device *dev = dev_get_drvdata(device);
 	struct flexcan_priv *priv = netdev_priv(dev);
<span class="p_add">+	int err;</span>
 
 	priv-&gt;can.state = CAN_STATE_ERROR_ACTIVE;
 	if (netif_running(dev)) {
 		netif_device_attach(dev);
 		netif_start_queue(dev);
<span class="p_add">+		err = flexcan_chip_enable(priv);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
 	}
<span class="p_del">-	return flexcan_chip_enable(priv);</span>
<span class="p_add">+	return 0;</span>
 }
 
 static SIMPLE_DEV_PM_OPS(flexcan_pm_ops, flexcan_suspend, flexcan_resume);
<span class="p_header">diff --git a/drivers/net/dsa/bcm_sf2.h b/drivers/net/dsa/bcm_sf2.h</span>
<span class="p_header">index 6bba1c98d764..c7994e372284 100644</span>
<span class="p_header">--- a/drivers/net/dsa/bcm_sf2.h</span>
<span class="p_header">+++ b/drivers/net/dsa/bcm_sf2.h</span>
<span class="p_chunk">@@ -187,8 +187,8 @@</span> <span class="p_context"> static inline void name##_writeq(struct bcm_sf2_priv *priv, u64 val,	\</span>
 static inline void intrl2_##which##_mask_clear(struct bcm_sf2_priv *priv, \
 						u32 mask)		\
 {									\
<span class="p_del">-	intrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);	\</span>
 	priv-&gt;irq##which##_mask &amp;= ~(mask);				\
<span class="p_add">+	intrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);	\</span>
 }									\
 static inline void intrl2_##which##_mask_set(struct bcm_sf2_priv *priv, \
 						u32 mask)		\
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">index 037fc4cdf5af..cc199063612a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/cmd.c</span>
<span class="p_chunk">@@ -143,13 +143,14 @@</span> <span class="p_context"> static struct mlx5_cmd_layout *get_inst(struct mlx5_cmd *cmd, int idx)</span>
 	return cmd-&gt;cmd_buf + (idx &lt;&lt; cmd-&gt;log_stride);
 }
 
<span class="p_del">-static u8 xor8_buf(void *buf, int len)</span>
<span class="p_add">+static u8 xor8_buf(void *buf, size_t offset, int len)</span>
 {
 	u8 *ptr = buf;
 	u8 sum = 0;
 	int i;
<span class="p_add">+	int end = len + offset;</span>
 
<span class="p_del">-	for (i = 0; i &lt; len; i++)</span>
<span class="p_add">+	for (i = offset; i &lt; end; i++)</span>
 		sum ^= ptr[i];
 
 	return sum;
<span class="p_chunk">@@ -157,41 +158,49 @@</span> <span class="p_context"> static u8 xor8_buf(void *buf, int len)</span>
 
 static int verify_block_sig(struct mlx5_cmd_prot_block *block)
 {
<span class="p_del">-	if (xor8_buf(block-&gt;rsvd0, sizeof(*block) - sizeof(block-&gt;data) - 1) != 0xff)</span>
<span class="p_add">+	size_t rsvd0_off = offsetof(struct mlx5_cmd_prot_block, rsvd0);</span>
<span class="p_add">+	int xor_len = sizeof(*block) - sizeof(block-&gt;data) - 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (xor8_buf(block, rsvd0_off, xor_len) != 0xff)</span>
 		return -EINVAL;
 
<span class="p_del">-	if (xor8_buf(block, sizeof(*block)) != 0xff)</span>
<span class="p_add">+	if (xor8_buf(block, 0, sizeof(*block)) != 0xff)</span>
 		return -EINVAL;
 
 	return 0;
 }
 
<span class="p_del">-static void calc_block_sig(struct mlx5_cmd_prot_block *block, u8 token,</span>
<span class="p_del">-			   int csum)</span>
<span class="p_add">+static void calc_block_sig(struct mlx5_cmd_prot_block *block)</span>
 {
<span class="p_del">-	block-&gt;token = token;</span>
<span class="p_del">-	if (csum) {</span>
<span class="p_del">-		block-&gt;ctrl_sig = ~xor8_buf(block-&gt;rsvd0, sizeof(*block) -</span>
<span class="p_del">-					    sizeof(block-&gt;data) - 2);</span>
<span class="p_del">-		block-&gt;sig = ~xor8_buf(block, sizeof(*block) - 1);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	int ctrl_xor_len = sizeof(*block) - sizeof(block-&gt;data) - 2;</span>
<span class="p_add">+	size_t rsvd0_off = offsetof(struct mlx5_cmd_prot_block, rsvd0);</span>
<span class="p_add">+</span>
<span class="p_add">+	block-&gt;ctrl_sig = ~xor8_buf(block, rsvd0_off, ctrl_xor_len);</span>
<span class="p_add">+	block-&gt;sig = ~xor8_buf(block, 0, sizeof(*block) - 1);</span>
 }
 
<span class="p_del">-static void calc_chain_sig(struct mlx5_cmd_msg *msg, u8 token, int csum)</span>
<span class="p_add">+static void calc_chain_sig(struct mlx5_cmd_msg *msg)</span>
 {
 	struct mlx5_cmd_mailbox *next = msg-&gt;next;
<span class="p_del">-</span>
<span class="p_del">-	while (next) {</span>
<span class="p_del">-		calc_block_sig(next-&gt;buf, token, csum);</span>
<span class="p_add">+	int size = msg-&gt;len;</span>
<span class="p_add">+	int blen = size - min_t(int, sizeof(msg-&gt;first.data), size);</span>
<span class="p_add">+	int n = (blen + MLX5_CMD_DATA_BLOCK_SIZE - 1)</span>
<span class="p_add">+		/ MLX5_CMD_DATA_BLOCK_SIZE;</span>
<span class="p_add">+	int i = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; n &amp;&amp; next; i++)  {</span>
<span class="p_add">+		calc_block_sig(next-&gt;buf);</span>
 		next = next-&gt;next;
 	}
 }
 
 static void set_signature(struct mlx5_cmd_work_ent *ent, int csum)
 {
<span class="p_del">-	ent-&gt;lay-&gt;sig = ~xor8_buf(ent-&gt;lay, sizeof(*ent-&gt;lay));</span>
<span class="p_del">-	calc_chain_sig(ent-&gt;in, ent-&gt;token, csum);</span>
<span class="p_del">-	calc_chain_sig(ent-&gt;out, ent-&gt;token, csum);</span>
<span class="p_add">+	ent-&gt;lay-&gt;sig = ~xor8_buf(ent-&gt;lay, 0,  sizeof(*ent-&gt;lay));</span>
<span class="p_add">+	if (csum) {</span>
<span class="p_add">+		calc_chain_sig(ent-&gt;in);</span>
<span class="p_add">+		calc_chain_sig(ent-&gt;out);</span>
<span class="p_add">+	}</span>
 }
 
 static void poll_timeout(struct mlx5_cmd_work_ent *ent)
<span class="p_chunk">@@ -222,12 +231,17 @@</span> <span class="p_context"> static int verify_signature(struct mlx5_cmd_work_ent *ent)</span>
 	struct mlx5_cmd_mailbox *next = ent-&gt;out-&gt;next;
 	int err;
 	u8 sig;
<span class="p_add">+	int size = ent-&gt;out-&gt;len;</span>
<span class="p_add">+	int blen = size - min_t(int, sizeof(ent-&gt;out-&gt;first.data), size);</span>
<span class="p_add">+	int n = (blen + MLX5_CMD_DATA_BLOCK_SIZE - 1)</span>
<span class="p_add">+		/ MLX5_CMD_DATA_BLOCK_SIZE;</span>
<span class="p_add">+	int i = 0;</span>
 
<span class="p_del">-	sig = xor8_buf(ent-&gt;lay, sizeof(*ent-&gt;lay));</span>
<span class="p_add">+	sig = xor8_buf(ent-&gt;lay, 0, sizeof(*ent-&gt;lay));</span>
 	if (sig != 0xff)
 		return -EINVAL;
 
<span class="p_del">-	while (next) {</span>
<span class="p_add">+	for (i = 0; i &lt; n &amp;&amp; next; i++) {</span>
 		err = verify_block_sig(next-&gt;buf);
 		if (err)
 			return err;
<span class="p_chunk">@@ -641,7 +655,6 @@</span> <span class="p_context"> static void cmd_work_handler(struct work_struct *work)</span>
 		spin_unlock_irqrestore(&amp;cmd-&gt;alloc_lock, flags);
 	}
 
<span class="p_del">-	ent-&gt;token = alloc_token(cmd);</span>
 	cmd-&gt;ent_arr[ent-&gt;idx] = ent;
 	lay = get_inst(cmd, ent-&gt;idx);
 	ent-&gt;lay = lay;
<span class="p_chunk">@@ -755,7 +768,8 @@</span> <span class="p_context"> static u8 *get_status_ptr(struct mlx5_outbox_hdr *out)</span>
 static int mlx5_cmd_invoke(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *in,
 			   struct mlx5_cmd_msg *out, void *uout, int uout_size,
 			   mlx5_cmd_cbk_t callback,
<span class="p_del">-			   void *context, int page_queue, u8 *status)</span>
<span class="p_add">+			   void *context, int page_queue, u8 *status,</span>
<span class="p_add">+			   u8 token)</span>
 {
 	struct mlx5_cmd *cmd = &amp;dev-&gt;cmd;
 	struct mlx5_cmd_work_ent *ent;
<span class="p_chunk">@@ -772,6 +786,8 @@</span> <span class="p_context"> static int mlx5_cmd_invoke(struct mlx5_core_dev *dev, struct mlx5_cmd_msg *in,</span>
 	if (IS_ERR(ent))
 		return PTR_ERR(ent);
 
<span class="p_add">+	ent-&gt;token = token;</span>
<span class="p_add">+</span>
 	if (!callback)
 		init_completion(&amp;ent-&gt;done);
 
<span class="p_chunk">@@ -844,7 +860,8 @@</span> <span class="p_context"> static const struct file_operations fops = {</span>
 	.write	= dbg_write,
 };
 
<span class="p_del">-static int mlx5_copy_to_msg(struct mlx5_cmd_msg *to, void *from, int size)</span>
<span class="p_add">+static int mlx5_copy_to_msg(struct mlx5_cmd_msg *to, void *from, int size,</span>
<span class="p_add">+			    u8 token)</span>
 {
 	struct mlx5_cmd_prot_block *block;
 	struct mlx5_cmd_mailbox *next;
<span class="p_chunk">@@ -870,6 +887,7 @@</span> <span class="p_context"> static int mlx5_copy_to_msg(struct mlx5_cmd_msg *to, void *from, int size)</span>
 		memcpy(block-&gt;data, from, copy);
 		from += copy;
 		size -= copy;
<span class="p_add">+		block-&gt;token = token;</span>
 		next = next-&gt;next;
 	}
 
<span class="p_chunk">@@ -939,7 +957,8 @@</span> <span class="p_context"> static void free_cmd_box(struct mlx5_core_dev *dev,</span>
 }
 
 static struct mlx5_cmd_msg *mlx5_alloc_cmd_msg(struct mlx5_core_dev *dev,
<span class="p_del">-					       gfp_t flags, int size)</span>
<span class="p_add">+					       gfp_t flags, int size,</span>
<span class="p_add">+					       u8 token)</span>
 {
 	struct mlx5_cmd_mailbox *tmp, *head = NULL;
 	struct mlx5_cmd_prot_block *block;
<span class="p_chunk">@@ -968,6 +987,7 @@</span> <span class="p_context"> static struct mlx5_cmd_msg *mlx5_alloc_cmd_msg(struct mlx5_core_dev *dev,</span>
 		tmp-&gt;next = head;
 		block-&gt;next = cpu_to_be64(tmp-&gt;next ? tmp-&gt;next-&gt;dma : 0);
 		block-&gt;block_num = cpu_to_be32(n - i - 1);
<span class="p_add">+		block-&gt;token = token;</span>
 		head = tmp;
 	}
 	msg-&gt;next = head;
<span class="p_chunk">@@ -1351,7 +1371,7 @@</span> <span class="p_context"> static struct mlx5_cmd_msg *alloc_msg(struct mlx5_core_dev *dev, int in_size,</span>
 	}
 
 	if (IS_ERR(msg))
<span class="p_del">-		msg = mlx5_alloc_cmd_msg(dev, gfp, in_size);</span>
<span class="p_add">+		msg = mlx5_alloc_cmd_msg(dev, gfp, in_size, 0);</span>
 
 	return msg;
 }
<span class="p_chunk">@@ -1376,6 +1396,7 @@</span> <span class="p_context"> static int cmd_exec(struct mlx5_core_dev *dev, void *in, int in_size, void *out,</span>
 	int err;
 	u8 status = 0;
 	u32 drv_synd;
<span class="p_add">+	u8 token;</span>
 
 	if (pci_channel_offline(dev-&gt;pdev) ||
 	    dev-&gt;state == MLX5_DEVICE_STATE_INTERNAL_ERROR) {
<span class="p_chunk">@@ -1394,20 +1415,22 @@</span> <span class="p_context"> static int cmd_exec(struct mlx5_core_dev *dev, void *in, int in_size, void *out,</span>
 		return err;
 	}
 
<span class="p_del">-	err = mlx5_copy_to_msg(inb, in, in_size);</span>
<span class="p_add">+	token = alloc_token(&amp;dev-&gt;cmd);</span>
<span class="p_add">+</span>
<span class="p_add">+	err = mlx5_copy_to_msg(inb, in, in_size, token);</span>
 	if (err) {
 		mlx5_core_warn(dev, &quot;err %d\n&quot;, err);
 		goto out_in;
 	}
 
<span class="p_del">-	outb = mlx5_alloc_cmd_msg(dev, gfp, out_size);</span>
<span class="p_add">+	outb = mlx5_alloc_cmd_msg(dev, gfp, out_size, token);</span>
 	if (IS_ERR(outb)) {
 		err = PTR_ERR(outb);
 		goto out_in;
 	}
 
 	err = mlx5_cmd_invoke(dev, inb, outb, out, out_size, callback, context,
<span class="p_del">-			      pages_queue, &amp;status);</span>
<span class="p_add">+			      pages_queue, &amp;status, token);</span>
 	if (err)
 		goto out_out;
 
<span class="p_chunk">@@ -1475,7 +1498,7 @@</span> <span class="p_context"> static int create_msg_cache(struct mlx5_core_dev *dev)</span>
 	INIT_LIST_HEAD(&amp;cmd-&gt;cache.med.head);
 
 	for (i = 0; i &lt; NUM_LONG_LISTS; i++) {
<span class="p_del">-		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, LONG_LIST_SIZE);</span>
<span class="p_add">+		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, LONG_LIST_SIZE, 0);</span>
 		if (IS_ERR(msg)) {
 			err = PTR_ERR(msg);
 			goto ex_err;
<span class="p_chunk">@@ -1485,7 +1508,7 @@</span> <span class="p_context"> static int create_msg_cache(struct mlx5_core_dev *dev)</span>
 	}
 
 	for (i = 0; i &lt; NUM_MED_LISTS; i++) {
<span class="p_del">-		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, MED_LIST_SIZE);</span>
<span class="p_add">+		msg = mlx5_alloc_cmd_msg(dev, GFP_KERNEL, MED_LIST_SIZE, 0);</span>
 		if (IS_ERR(msg)) {
 			err = PTR_ERR(msg);
 			goto ex_err;
<span class="p_header">diff --git a/drivers/net/ethernet/smsc/smc91x.c b/drivers/net/ethernet/smsc/smc91x.c</span>
<span class="p_header">index 0e2fc1a844ab..8c44cf6ff7a2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/smsc/smc91x.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/smsc/smc91x.c</span>
<span class="p_chunk">@@ -2269,6 +2269,13 @@</span> <span class="p_context"> static int smc_drv_probe(struct platform_device *pdev)</span>
 	if (pd) {
 		memcpy(&amp;lp-&gt;cfg, pd, sizeof(lp-&gt;cfg));
 		lp-&gt;io_shift = SMC91X_IO_SHIFT(lp-&gt;cfg.flags);
<span class="p_add">+</span>
<span class="p_add">+		if (!SMC_8BIT(lp) &amp;&amp; !SMC_16BIT(lp)) {</span>
<span class="p_add">+			dev_err(&amp;pdev-&gt;dev,</span>
<span class="p_add">+				&quot;at least one of 8-bit or 16-bit access support is required.\n&quot;);</span>
<span class="p_add">+			ret = -ENXIO;</span>
<span class="p_add">+			goto out_free_netdev;</span>
<span class="p_add">+		}</span>
 	}
 
 #if IS_BUILTIN(CONFIG_OF)
<span class="p_header">diff --git a/drivers/net/ethernet/smsc/smc91x.h b/drivers/net/ethernet/smsc/smc91x.h</span>
<span class="p_header">index a3c129e1e40a..29df0465daf4 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/smsc/smc91x.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/smsc/smc91x.h</span>
<span class="p_chunk">@@ -37,6 +37,27 @@</span> <span class="p_context"></span>
 #include &lt;linux/smc91x.h&gt;
 
 /*
<span class="p_add">+ * Any 16-bit access is performed with two 8-bit accesses if the hardware</span>
<span class="p_add">+ * can&#39;t do it directly. Most registers are 16-bit so those are mandatory.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SMC_outw_b(x, a, r)						\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		unsigned int __val16 = (x);				\</span>
<span class="p_add">+		unsigned int __reg = (r);				\</span>
<span class="p_add">+		SMC_outb(__val16, a, __reg);				\</span>
<span class="p_add">+		SMC_outb(__val16 &gt;&gt; 8, a, __reg + (1 &lt;&lt; SMC_IO_SHIFT));	\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
<span class="p_add">+#define SMC_inw_b(a, r)							\</span>
<span class="p_add">+	({								\</span>
<span class="p_add">+		unsigned int __val16;					\</span>
<span class="p_add">+		unsigned int __reg = r;					\</span>
<span class="p_add">+		__val16  = SMC_inb(a, __reg);				\</span>
<span class="p_add">+		__val16 |= SMC_inb(a, __reg + (1 &lt;&lt; SMC_IO_SHIFT)) &lt;&lt; 8; \</span>
<span class="p_add">+		__val16;						\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Define your architecture specific bus configuration parameters here.
  */
 
<span class="p_chunk">@@ -55,10 +76,30 @@</span> <span class="p_context"></span>
 #define SMC_IO_SHIFT		(lp-&gt;io_shift)
 
 #define SMC_inb(a, r)		readb((a) + (r))
<span class="p_del">-#define SMC_inw(a, r)		readw((a) + (r))</span>
<span class="p_add">+#define SMC_inw(a, r)							\</span>
<span class="p_add">+	({								\</span>
<span class="p_add">+		unsigned int __smc_r = r;				\</span>
<span class="p_add">+		SMC_16BIT(lp) ? readw((a) + __smc_r) :			\</span>
<span class="p_add">+		SMC_8BIT(lp) ? SMC_inw_b(a, __smc_r) :			\</span>
<span class="p_add">+		({ BUG(); 0; });					\</span>
<span class="p_add">+	})</span>
<span class="p_add">+</span>
 #define SMC_inl(a, r)		readl((a) + (r))
 #define SMC_outb(v, a, r)	writeb(v, (a) + (r))
<span class="p_add">+#define SMC_outw(v, a, r)						\</span>
<span class="p_add">+	do {								\</span>
<span class="p_add">+		unsigned int __v = v, __smc_r = r;			\</span>
<span class="p_add">+		if (SMC_16BIT(lp))					\</span>
<span class="p_add">+			__SMC_outw(__v, a, __smc_r);			\</span>
<span class="p_add">+		else if (SMC_8BIT(lp))					\</span>
<span class="p_add">+			SMC_outw_b(__v, a, __smc_r);			\</span>
<span class="p_add">+		else							\</span>
<span class="p_add">+			BUG();						\</span>
<span class="p_add">+	} while (0)</span>
<span class="p_add">+</span>
 #define SMC_outl(v, a, r)	writel(v, (a) + (r))
<span class="p_add">+#define SMC_insb(a, r, p, l)	readsb((a) + (r), p, l)</span>
<span class="p_add">+#define SMC_outsb(a, r, p, l)	writesb((a) + (r), p, l)</span>
 #define SMC_insw(a, r, p, l)	readsw((a) + (r), p, l)
 #define SMC_outsw(a, r, p, l)	writesw((a) + (r), p, l)
 #define SMC_insl(a, r, p, l)	readsl((a) + (r), p, l)
<span class="p_chunk">@@ -66,7 +107,7 @@</span> <span class="p_context"></span>
 #define SMC_IRQ_FLAGS		(-1)	/* from resource */
 
 /* We actually can&#39;t write halfwords properly if not word aligned */
<span class="p_del">-static inline void SMC_outw(u16 val, void __iomem *ioaddr, int reg)</span>
<span class="p_add">+static inline void __SMC_outw(u16 val, void __iomem *ioaddr, int reg)</span>
 {
 	if ((machine_is_mainstone() || machine_is_stargate2() ||
 	     machine_is_pxa_idp()) &amp;&amp; reg &amp; 2) {
<span class="p_chunk">@@ -405,24 +446,8 @@</span> <span class="p_context"> smc_pxa_dma_insw(void __iomem *ioaddr, struct smc_local *lp, int reg, int dma,</span>
 
 #if ! SMC_CAN_USE_16BIT
 
<span class="p_del">-/*</span>
<span class="p_del">- * Any 16-bit access is performed with two 8-bit accesses if the hardware</span>
<span class="p_del">- * can&#39;t do it directly. Most registers are 16-bit so those are mandatory.</span>
<span class="p_del">- */</span>
<span class="p_del">-#define SMC_outw(x, ioaddr, reg)					\</span>
<span class="p_del">-	do {								\</span>
<span class="p_del">-		unsigned int __val16 = (x);				\</span>
<span class="p_del">-		SMC_outb( __val16, ioaddr, reg );			\</span>
<span class="p_del">-		SMC_outb( __val16 &gt;&gt; 8, ioaddr, reg + (1 &lt;&lt; SMC_IO_SHIFT));\</span>
<span class="p_del">-	} while (0)</span>
<span class="p_del">-#define SMC_inw(ioaddr, reg)						\</span>
<span class="p_del">-	({								\</span>
<span class="p_del">-		unsigned int __val16;					\</span>
<span class="p_del">-		__val16 =  SMC_inb( ioaddr, reg );			\</span>
<span class="p_del">-		__val16 |= SMC_inb( ioaddr, reg + (1 &lt;&lt; SMC_IO_SHIFT)) &lt;&lt; 8; \</span>
<span class="p_del">-		__val16;						\</span>
<span class="p_del">-	})</span>
<span class="p_del">-</span>
<span class="p_add">+#define SMC_outw(x, ioaddr, reg)	SMC_outw_b(x, ioaddr, reg)</span>
<span class="p_add">+#define SMC_inw(ioaddr, reg)		SMC_inw_b(ioaddr, reg)</span>
 #define SMC_insw(a, r, p, l)		BUG()
 #define SMC_outsw(a, r, p, l)		BUG()
 
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index 47cd306dbb3c..bba0ca786aaa 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -640,8 +640,10 @@</span> <span class="p_context"> phy_err:</span>
 int phy_start_interrupts(struct phy_device *phydev)
 {
 	atomic_set(&amp;phydev-&gt;irq_disable, 0);
<span class="p_del">-	if (request_irq(phydev-&gt;irq, phy_interrupt, 0, &quot;phy_interrupt&quot;,</span>
<span class="p_del">-			phydev) &lt; 0) {</span>
<span class="p_add">+	if (request_irq(phydev-&gt;irq, phy_interrupt,</span>
<span class="p_add">+				IRQF_SHARED,</span>
<span class="p_add">+				&quot;phy_interrupt&quot;,</span>
<span class="p_add">+				phydev) &lt; 0) {</span>
 		pr_warn(&quot;%s: Can&#39;t get IRQ %d (PHY)\n&quot;,
 			phydev-&gt;bus-&gt;name, phydev-&gt;irq);
 		phydev-&gt;irq = PHY_POLL;
<span class="p_header">diff --git a/drivers/net/wireless/ath/ath9k/init.c b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">index 1bdeacf7b257..bc70ce62bc03 100644</span>
<span class="p_header">--- a/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_header">+++ b/drivers/net/wireless/ath/ath9k/init.c</span>
<span class="p_chunk">@@ -869,8 +869,8 @@</span> <span class="p_context"> static void ath9k_set_hw_capab(struct ath_softc *sc, struct ieee80211_hw *hw)</span>
 			hw-&gt;wiphy-&gt;interface_modes |=
 					BIT(NL80211_IFTYPE_P2P_DEVICE);
 
<span class="p_del">-			hw-&gt;wiphy-&gt;iface_combinations = if_comb;</span>
<span class="p_del">-			hw-&gt;wiphy-&gt;n_iface_combinations = ARRAY_SIZE(if_comb);</span>
<span class="p_add">+		hw-&gt;wiphy-&gt;iface_combinations = if_comb;</span>
<span class="p_add">+		hw-&gt;wiphy-&gt;n_iface_combinations = ARRAY_SIZE(if_comb);</span>
 	}
 
 	hw-&gt;wiphy-&gt;flags &amp;= ~WIPHY_FLAG_PS_ON_BY_DEFAULT;
<span class="p_header">diff --git a/drivers/net/wireless/iwlegacy/3945.c b/drivers/net/wireless/iwlegacy/3945.c</span>
<span class="p_header">index 93bdf684babe..ae047ab7a4df 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlegacy/3945.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlegacy/3945.c</span>
<span class="p_chunk">@@ -1019,12 +1019,13 @@</span> <span class="p_context"> il3945_hw_txq_ctx_free(struct il_priv *il)</span>
 	int txq_id;
 
 	/* Tx queues */
<span class="p_del">-	if (il-&gt;txq)</span>
<span class="p_add">+	if (il-&gt;txq) {</span>
 		for (txq_id = 0; txq_id &lt; il-&gt;hw_params.max_txq_num; txq_id++)
 			if (txq_id == IL39_CMD_QUEUE_NUM)
 				il_cmd_queue_free(il);
 			else
 				il_tx_queue_free(il, txq_id);
<span class="p_add">+	}</span>
 
 	/* free tx queue structure */
 	il_free_txq_mem(il);
<span class="p_header">diff --git a/drivers/net/wireless/iwlwifi/dvm/calib.c b/drivers/net/wireless/iwlwifi/dvm/calib.c</span>
<span class="p_header">index 20e6aa910700..c148085742a0 100644</span>
<span class="p_header">--- a/drivers/net/wireless/iwlwifi/dvm/calib.c</span>
<span class="p_header">+++ b/drivers/net/wireless/iwlwifi/dvm/calib.c</span>
<span class="p_chunk">@@ -901,7 +901,7 @@</span> <span class="p_context"> static void iwlagn_gain_computation(struct iwl_priv *priv,</span>
 		/* bound gain by 2 bits value max, 3rd bit is sign */
 		data-&gt;delta_gain_code[i] =
 			min(abs(delta_g),
<span class="p_del">-			(long) CHAIN_NOISE_MAX_DELTA_GAIN_CODE);</span>
<span class="p_add">+			(s32) CHAIN_NOISE_MAX_DELTA_GAIN_CODE);</span>
 
 		if (delta_g &lt; 0)
 			/*
<span class="p_header">diff --git a/drivers/power/max17042_battery.c b/drivers/power/max17042_battery.c</span>
<span class="p_header">index 9c65f134d447..da7a75f82489 100644</span>
<span class="p_header">--- a/drivers/power/max17042_battery.c</span>
<span class="p_header">+++ b/drivers/power/max17042_battery.c</span>
<span class="p_chunk">@@ -457,13 +457,16 @@</span> <span class="p_context"> static inline void max17042_write_model_data(struct max17042_chip *chip,</span>
 }
 
 static inline void max17042_read_model_data(struct max17042_chip *chip,
<span class="p_del">-					u8 addr, u32 *data, int size)</span>
<span class="p_add">+					u8 addr, u16 *data, int size)</span>
 {
 	struct regmap *map = chip-&gt;regmap;
 	int i;
<span class="p_add">+	u32 tmp;</span>
 
<span class="p_del">-	for (i = 0; i &lt; size; i++)</span>
<span class="p_del">-		regmap_read(map, addr + i, &amp;data[i]);</span>
<span class="p_add">+	for (i = 0; i &lt; size; i++) {</span>
<span class="p_add">+		regmap_read(map, addr + i, &amp;tmp);</span>
<span class="p_add">+		data[i] = (u16)tmp;</span>
<span class="p_add">+	}</span>
 }
 
 static inline int max17042_model_data_compare(struct max17042_chip *chip,
<span class="p_chunk">@@ -486,7 +489,7 @@</span> <span class="p_context"> static int max17042_init_model(struct max17042_chip *chip)</span>
 {
 	int ret;
 	int table_size = ARRAY_SIZE(chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl);
<span class="p_del">-	u32 *temp_data;</span>
<span class="p_add">+	u16 *temp_data;</span>
 
 	temp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);
 	if (!temp_data)
<span class="p_chunk">@@ -501,7 +504,7 @@</span> <span class="p_context"> static int max17042_init_model(struct max17042_chip *chip)</span>
 	ret = max17042_model_data_compare(
 		chip,
 		chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl,
<span class="p_del">-		(u16 *)temp_data,</span>
<span class="p_add">+		temp_data,</span>
 		table_size);
 
 	max10742_lock_model(chip);
<span class="p_chunk">@@ -514,7 +517,7 @@</span> <span class="p_context"> static int max17042_verify_model_lock(struct max17042_chip *chip)</span>
 {
 	int i;
 	int table_size = ARRAY_SIZE(chip-&gt;pdata-&gt;config_data-&gt;cell_char_tbl);
<span class="p_del">-	u32 *temp_data;</span>
<span class="p_add">+	u16 *temp_data;</span>
 	int ret = 0;
 
 	temp_data = kcalloc(table_size, sizeof(*temp_data), GFP_KERNEL);
<span class="p_header">diff --git a/drivers/power/reset/hisi-reboot.c b/drivers/power/reset/hisi-reboot.c</span>
<span class="p_header">index 9ab7f562a83b..f69387e12c1e 100644</span>
<span class="p_header">--- a/drivers/power/reset/hisi-reboot.c</span>
<span class="p_header">+++ b/drivers/power/reset/hisi-reboot.c</span>
<span class="p_chunk">@@ -53,13 +53,16 @@</span> <span class="p_context"> static int hisi_reboot_probe(struct platform_device *pdev)</span>
 
 	if (of_property_read_u32(np, &quot;reboot-offset&quot;, &amp;reboot_offset) &lt; 0) {
 		pr_err(&quot;failed to find reboot-offset property\n&quot;);
<span class="p_add">+		iounmap(base);</span>
 		return -EINVAL;
 	}
 
 	err = register_restart_handler(&amp;hisi_restart_nb);
<span class="p_del">-	if (err)</span>
<span class="p_add">+	if (err) {</span>
 		dev_err(&amp;pdev-&gt;dev, &quot;cannot register restart handler (err=%d)\n&quot;,
 			err);
<span class="p_add">+		iounmap(base);</span>
<span class="p_add">+	}</span>
 
 	return err;
 }
<span class="p_header">diff --git a/drivers/power/tps65217_charger.c b/drivers/power/tps65217_charger.c</span>
<span class="p_header">index d9f56730c735..040a40b4b173 100644</span>
<span class="p_header">--- a/drivers/power/tps65217_charger.c</span>
<span class="p_header">+++ b/drivers/power/tps65217_charger.c</span>
<span class="p_chunk">@@ -205,6 +205,7 @@</span> <span class="p_context"> static int tps65217_charger_probe(struct platform_device *pdev)</span>
 	if (!charger)
 		return -ENOMEM;
 
<span class="p_add">+	platform_set_drvdata(pdev, charger);</span>
 	charger-&gt;tps = tps;
 	charger-&gt;dev = &amp;pdev-&gt;dev;
 
<span class="p_header">diff --git a/drivers/pwm/core.c b/drivers/pwm/core.c</span>
<span class="p_header">index d24ca5f281b4..7831bc6b51dd 100644</span>
<span class="p_header">--- a/drivers/pwm/core.c</span>
<span class="p_header">+++ b/drivers/pwm/core.c</span>
<span class="p_chunk">@@ -889,7 +889,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(devm_pwm_put);</span>
   */
 bool pwm_can_sleep(struct pwm_device *pwm)
 {
<span class="p_del">-	return pwm-&gt;chip-&gt;can_sleep;</span>
<span class="p_add">+	return true;</span>
 }
 EXPORT_SYMBOL_GPL(pwm_can_sleep);
 
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 3f8d357b1bac..278e10cd771f 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -5941,11 +5941,11 @@</span> <span class="p_context"> static void megasas_detach_one(struct pci_dev *pdev)</span>
 			if (fusion-&gt;ld_drv_map[i])
 				free_pages((ulong)fusion-&gt;ld_drv_map[i],
 					fusion-&gt;drv_map_pages);
<span class="p_del">-				if (fusion-&gt;pd_seq_sync)</span>
<span class="p_del">-					dma_free_coherent(&amp;instance-&gt;pdev-&gt;dev,</span>
<span class="p_del">-						pd_seq_map_sz,</span>
<span class="p_del">-						fusion-&gt;pd_seq_sync[i],</span>
<span class="p_del">-						fusion-&gt;pd_seq_phys[i]);</span>
<span class="p_add">+			if (fusion-&gt;pd_seq_sync[i])</span>
<span class="p_add">+				dma_free_coherent(&amp;instance-&gt;pdev-&gt;dev,</span>
<span class="p_add">+					pd_seq_map_sz,</span>
<span class="p_add">+					fusion-&gt;pd_seq_sync[i],</span>
<span class="p_add">+					fusion-&gt;pd_seq_phys[i]);</span>
 		}
 		free_pages((ulong)instance-&gt;ctrl_context,
 			instance-&gt;ctrl_context_pages);
<span class="p_header">diff --git a/drivers/staging/iio/adc/ad7192.c b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">index bb40f3728742..20314ff08be0 100644</span>
<span class="p_header">--- a/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_header">+++ b/drivers/staging/iio/adc/ad7192.c</span>
<span class="p_chunk">@@ -236,7 +236,7 @@</span> <span class="p_context"> static int ad7192_setup(struct ad7192_state *st,</span>
 			st-&gt;mclk = pdata-&gt;ext_clk_hz;
 		else
 			st-&gt;mclk = AD7192_INT_FREQ_MHZ;
<span class="p_del">-			break;</span>
<span class="p_add">+		break;</span>
 	default:
 		ret = -EINVAL;
 		goto out;
<span class="p_header">diff --git a/fs/autofs4/autofs_i.h b/fs/autofs4/autofs_i.h</span>
<span class="p_header">index c37149b929be..502d3892d8a4 100644</span>
<span class="p_header">--- a/fs/autofs4/autofs_i.h</span>
<span class="p_header">+++ b/fs/autofs4/autofs_i.h</span>
<span class="p_chunk">@@ -79,9 +79,13 @@</span> <span class="p_context"> struct autofs_info {</span>
 };
 
 #define AUTOFS_INF_EXPIRING	(1&lt;&lt;0) /* dentry is in the process of expiring */
<span class="p_del">-#define AUTOFS_INF_NO_RCU	(1&lt;&lt;1) /* the dentry is being considered</span>
<span class="p_add">+#define AUTOFS_INF_WANT_EXPIRE	(1&lt;&lt;1) /* the dentry is being considered</span>
 					* for expiry, so RCU_walk is
<span class="p_del">-					* not permitted</span>
<span class="p_add">+					* not permitted.  If it progresses to</span>
<span class="p_add">+					* actual expiry attempt, the flag is</span>
<span class="p_add">+					* not cleared when EXPIRING is set -</span>
<span class="p_add">+					* in that case it gets cleared only</span>
<span class="p_add">+					* when it comes to clearing EXPIRING.</span>
 					*/
 #define AUTOFS_INF_PENDING	(1&lt;&lt;2) /* dentry pending mount */
 
<span class="p_header">diff --git a/fs/autofs4/expire.c b/fs/autofs4/expire.c</span>
<span class="p_header">index 1cebc3c52fa5..7a5a598a2d94 100644</span>
<span class="p_header">--- a/fs/autofs4/expire.c</span>
<span class="p_header">+++ b/fs/autofs4/expire.c</span>
<span class="p_chunk">@@ -315,19 +315,17 @@</span> <span class="p_context"> struct dentry *autofs4_expire_direct(struct super_block *sb,</span>
 	if (ino-&gt;flags &amp; AUTOFS_INF_PENDING)
 		goto out;
 	if (!autofs4_direct_busy(mnt, root, timeout, do_now)) {
<span class="p_del">-		ino-&gt;flags |= AUTOFS_INF_NO_RCU;</span>
<span class="p_add">+		ino-&gt;flags |= AUTOFS_INF_WANT_EXPIRE;</span>
 		spin_unlock(&amp;sbi-&gt;fs_lock);
 		synchronize_rcu();
 		spin_lock(&amp;sbi-&gt;fs_lock);
 		if (!autofs4_direct_busy(mnt, root, timeout, do_now)) {
 			ino-&gt;flags |= AUTOFS_INF_EXPIRING;
<span class="p_del">-			smp_mb();</span>
<span class="p_del">-			ino-&gt;flags &amp;= ~AUTOFS_INF_NO_RCU;</span>
 			init_completion(&amp;ino-&gt;expire_complete);
 			spin_unlock(&amp;sbi-&gt;fs_lock);
 			return root;
 		}
<span class="p_del">-		ino-&gt;flags &amp;= ~AUTOFS_INF_NO_RCU;</span>
<span class="p_add">+		ino-&gt;flags &amp;= ~AUTOFS_INF_WANT_EXPIRE;</span>
 	}
 out:
 	spin_unlock(&amp;sbi-&gt;fs_lock);
<span class="p_chunk">@@ -417,6 +415,7 @@</span> <span class="p_context"> static struct dentry *should_expire(struct dentry *dentry,</span>
 	}
 	return NULL;
 }
<span class="p_add">+</span>
 /*
  * Find an eligible tree to time-out
  * A tree is eligible if :-
<span class="p_chunk">@@ -432,6 +431,7 @@</span> <span class="p_context"> struct dentry *autofs4_expire_indirect(struct super_block *sb,</span>
 	struct dentry *root = sb-&gt;s_root;
 	struct dentry *dentry;
 	struct dentry *expired;
<span class="p_add">+	struct dentry *found;</span>
 	struct autofs_info *ino;
 
 	if (!root)
<span class="p_chunk">@@ -442,48 +442,54 @@</span> <span class="p_context"> struct dentry *autofs4_expire_indirect(struct super_block *sb,</span>
 
 	dentry = NULL;
 	while ((dentry = get_next_positive_subdir(dentry, root))) {
<span class="p_add">+		int flags = how;</span>
<span class="p_add">+</span>
 		spin_lock(&amp;sbi-&gt;fs_lock);
 		ino = autofs4_dentry_ino(dentry);
<span class="p_del">-		if (ino-&gt;flags &amp; AUTOFS_INF_NO_RCU)</span>
<span class="p_del">-			expired = NULL;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			expired = should_expire(dentry, mnt, timeout, how);</span>
<span class="p_del">-		if (!expired) {</span>
<span class="p_add">+		if (ino-&gt;flags &amp; AUTOFS_INF_WANT_EXPIRE) {</span>
 			spin_unlock(&amp;sbi-&gt;fs_lock);
 			continue;
 		}
<span class="p_add">+		spin_unlock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+		expired = should_expire(dentry, mnt, timeout, flags);</span>
<span class="p_add">+		if (!expired)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;sbi-&gt;fs_lock);</span>
 		ino = autofs4_dentry_ino(expired);
<span class="p_del">-		ino-&gt;flags |= AUTOFS_INF_NO_RCU;</span>
<span class="p_add">+		ino-&gt;flags |= AUTOFS_INF_WANT_EXPIRE;</span>
 		spin_unlock(&amp;sbi-&gt;fs_lock);
 		synchronize_rcu();
<span class="p_del">-		spin_lock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_del">-		if (should_expire(expired, mnt, timeout, how)) {</span>
<span class="p_del">-			if (expired != dentry)</span>
<span class="p_del">-				dput(dentry);</span>
<span class="p_del">-			goto found;</span>
<span class="p_del">-		}</span>
 
<span class="p_del">-		ino-&gt;flags &amp;= ~AUTOFS_INF_NO_RCU;</span>
<span class="p_add">+		/* Make sure a reference is not taken on found if</span>
<span class="p_add">+		 * things have changed.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		flags &amp;= ~AUTOFS_EXP_LEAVES;</span>
<span class="p_add">+		found = should_expire(expired, mnt, timeout, how);</span>
<span class="p_add">+		if (!found || found != expired)</span>
<span class="p_add">+			/* Something has changed, continue */</span>
<span class="p_add">+			goto next;</span>
<span class="p_add">+</span>
 		if (expired != dentry)
<span class="p_del">-			dput(expired);</span>
<span class="p_add">+			dput(dentry);</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_add">+		goto found;</span>
<span class="p_add">+next:</span>
<span class="p_add">+		spin_lock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_add">+		ino-&gt;flags &amp;= ~AUTOFS_INF_WANT_EXPIRE;</span>
 		spin_unlock(&amp;sbi-&gt;fs_lock);
<span class="p_add">+		if (expired != dentry)</span>
<span class="p_add">+			dput(expired);</span>
 	}
 	return NULL;
 
 found:
 	DPRINTK(&quot;returning %p %pd&quot;, expired, expired);
 	ino-&gt;flags |= AUTOFS_INF_EXPIRING;
<span class="p_del">-	smp_mb();</span>
<span class="p_del">-	ino-&gt;flags &amp;= ~AUTOFS_INF_NO_RCU;</span>
 	init_completion(&amp;ino-&gt;expire_complete);
 	spin_unlock(&amp;sbi-&gt;fs_lock);
<span class="p_del">-	spin_lock(&amp;sbi-&gt;lookup_lock);</span>
<span class="p_del">-	spin_lock(&amp;expired-&gt;d_parent-&gt;d_lock);</span>
<span class="p_del">-	spin_lock_nested(&amp;expired-&gt;d_lock, DENTRY_D_LOCK_NESTED);</span>
<span class="p_del">-	list_move(&amp;expired-&gt;d_parent-&gt;d_subdirs, &amp;expired-&gt;d_child);</span>
<span class="p_del">-	spin_unlock(&amp;expired-&gt;d_lock);</span>
<span class="p_del">-	spin_unlock(&amp;expired-&gt;d_parent-&gt;d_lock);</span>
<span class="p_del">-	spin_unlock(&amp;sbi-&gt;lookup_lock);</span>
 	return expired;
 }
 
<span class="p_chunk">@@ -492,15 +498,27 @@</span> <span class="p_context"> int autofs4_expire_wait(struct dentry *dentry, int rcu_walk)</span>
 	struct autofs_sb_info *sbi = autofs4_sbi(dentry-&gt;d_sb);
 	struct autofs_info *ino = autofs4_dentry_ino(dentry);
 	int status;
<span class="p_add">+	int state;</span>
 
 	/* Block on any pending expire */
<span class="p_del">-	if (!(ino-&gt;flags &amp; (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU)))</span>
<span class="p_add">+	if (!(ino-&gt;flags &amp; AUTOFS_INF_WANT_EXPIRE))</span>
 		return 0;
 	if (rcu_walk)
 		return -ECHILD;
 
<span class="p_add">+retry:</span>
 	spin_lock(&amp;sbi-&gt;fs_lock);
<span class="p_del">-	if (ino-&gt;flags &amp; AUTOFS_INF_EXPIRING) {</span>
<span class="p_add">+	state = ino-&gt;flags &amp; (AUTOFS_INF_WANT_EXPIRE | AUTOFS_INF_EXPIRING);</span>
<span class="p_add">+	if (state == AUTOFS_INF_WANT_EXPIRE) {</span>
<span class="p_add">+		spin_unlock(&amp;sbi-&gt;fs_lock);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Possibly being selected for expire, wait until</span>
<span class="p_add">+		 * it&#39;s selected or not.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		schedule_timeout_uninterruptible(HZ/10);</span>
<span class="p_add">+		goto retry;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (state &amp; AUTOFS_INF_EXPIRING) {</span>
 		spin_unlock(&amp;sbi-&gt;fs_lock);
 
 		DPRINTK(&quot;waiting for expire %p name=%pd&quot;, dentry, dentry);
<span class="p_chunk">@@ -551,7 +569,7 @@</span> <span class="p_context"> int autofs4_expire_run(struct super_block *sb,</span>
 	ino = autofs4_dentry_ino(dentry);
 	/* avoid rapid-fire expire attempts if expiry fails */
 	ino-&gt;last_used = now;
<span class="p_del">-	ino-&gt;flags &amp;= ~AUTOFS_INF_EXPIRING;</span>
<span class="p_add">+	ino-&gt;flags &amp;= ~(AUTOFS_INF_EXPIRING|AUTOFS_INF_WANT_EXPIRE);</span>
 	complete_all(&amp;ino-&gt;expire_complete);
 	spin_unlock(&amp;sbi-&gt;fs_lock);
 
<span class="p_chunk">@@ -579,7 +597,7 @@</span> <span class="p_context"> int autofs4_do_expire_multi(struct super_block *sb, struct vfsmount *mnt,</span>
 		spin_lock(&amp;sbi-&gt;fs_lock);
 		/* avoid rapid-fire expire attempts if expiry fails */
 		ino-&gt;last_used = now;
<span class="p_del">-		ino-&gt;flags &amp;= ~AUTOFS_INF_EXPIRING;</span>
<span class="p_add">+		ino-&gt;flags &amp;= ~(AUTOFS_INF_EXPIRING|AUTOFS_INF_WANT_EXPIRE);</span>
 		complete_all(&amp;ino-&gt;expire_complete);
 		spin_unlock(&amp;sbi-&gt;fs_lock);
 		dput(dentry);
<span class="p_header">diff --git a/fs/autofs4/root.c b/fs/autofs4/root.c</span>
<span class="p_header">index c6d7d3dbd52a..7a54c6a867c8 100644</span>
<span class="p_header">--- a/fs/autofs4/root.c</span>
<span class="p_header">+++ b/fs/autofs4/root.c</span>
<span class="p_chunk">@@ -455,7 +455,7 @@</span> <span class="p_context"> static int autofs4_d_manage(struct dentry *dentry, bool rcu_walk)</span>
 		 * a mount-trap.
 		 */
 		struct inode *inode;
<span class="p_del">-		if (ino-&gt;flags &amp; (AUTOFS_INF_EXPIRING | AUTOFS_INF_NO_RCU))</span>
<span class="p_add">+		if (ino-&gt;flags &amp; AUTOFS_INF_WANT_EXPIRE)</span>
 			return 0;
 		if (d_mountpoint(dentry))
 			return 0;
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 65f30b3b04f9..a7e18dbadf74 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -1619,6 +1619,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_transid(struct file *file,</span>
 	int namelen;
 	int ret = 0;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	ret = mnt_want_write_file(file);
 	if (ret)
 		goto out;
<span class="p_chunk">@@ -1676,6 +1679,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create(struct file *file,</span>
 	struct btrfs_ioctl_vol_args *vol_args;
 	int ret;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -1699,6 +1705,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_create_v2(struct file *file,</span>
 	bool readonly = false;
 	struct btrfs_qgroup_inherit *inherit = NULL;
 
<span class="p_add">+	if (!S_ISDIR(file_inode(file)-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_chunk">@@ -2345,6 +2354,9 @@</span> <span class="p_context"> static noinline int btrfs_ioctl_snap_destroy(struct file *file,</span>
 	int ret;
 	int err = 0;
 
<span class="p_add">+	if (!S_ISDIR(dir-&gt;i_mode))</span>
<span class="p_add">+		return -ENOTDIR;</span>
<span class="p_add">+</span>
 	vol_args = memdup_user(arg, sizeof(*vol_args));
 	if (IS_ERR(vol_args))
 		return PTR_ERR(vol_args);
<span class="p_header">diff --git a/fs/hostfs/hostfs_kern.c b/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">index 5a7b3229b956..f34d6f5a5aca 100644</span>
<span class="p_header">--- a/fs/hostfs/hostfs_kern.c</span>
<span class="p_header">+++ b/fs/hostfs/hostfs_kern.c</span>
<span class="p_chunk">@@ -959,10 +959,11 @@</span> <span class="p_context"> static int hostfs_fill_sb_common(struct super_block *sb, void *d, int silent)</span>
 
 	if (S_ISLNK(root_inode-&gt;i_mode)) {
 		char *name = follow_link(host_root_path);
<span class="p_del">-		if (IS_ERR(name))</span>
<span class="p_add">+		if (IS_ERR(name)) {</span>
 			err = PTR_ERR(name);
<span class="p_del">-		else</span>
<span class="p_del">-			err = read_name(root_inode, name);</span>
<span class="p_add">+			goto out_put;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		err = read_name(root_inode, name);</span>
 		kfree(name);
 		if (err)
 			goto out_put;
<span class="p_header">diff --git a/fs/notify/fanotify/fanotify.c b/fs/notify/fanotify/fanotify.c</span>
<span class="p_header">index d2f97ecca6a5..e0e5f7c3c99f 100644</span>
<span class="p_header">--- a/fs/notify/fanotify/fanotify.c</span>
<span class="p_header">+++ b/fs/notify/fanotify/fanotify.c</span>
<span class="p_chunk">@@ -67,18 +67,7 @@</span> <span class="p_context"> static int fanotify_get_response(struct fsnotify_group *group,</span>
 
 	pr_debug(&quot;%s: group=%p event=%p\n&quot;, __func__, group, event);
 
<span class="p_del">-	wait_event(group-&gt;fanotify_data.access_waitq, event-&gt;response ||</span>
<span class="p_del">-				atomic_read(&amp;group-&gt;fanotify_data.bypass_perm));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!event-&gt;response) {	/* bypass_perm set */</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Event was canceled because group is being destroyed. Remove</span>
<span class="p_del">-		 * it from group&#39;s event list because we are responsible for</span>
<span class="p_del">-		 * freeing the permission event.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		fsnotify_remove_event(group, &amp;event-&gt;fae.fse);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	wait_event(group-&gt;fanotify_data.access_waitq, event-&gt;response);</span>
 
 	/* userspace responded, convert to something usable */
 	switch (event-&gt;response) {
<span class="p_header">diff --git a/fs/notify/fanotify/fanotify_user.c b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">index 8e8e6bcd1d43..a64313868d3a 100644</span>
<span class="p_header">--- a/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_header">+++ b/fs/notify/fanotify/fanotify_user.c</span>
<span class="p_chunk">@@ -358,16 +358,20 @@</span> <span class="p_context"> static int fanotify_release(struct inode *ignored, struct file *file)</span>
 
 #ifdef CONFIG_FANOTIFY_ACCESS_PERMISSIONS
 	struct fanotify_perm_event_info *event, *next;
<span class="p_add">+	struct fsnotify_event *fsn_event;</span>
 
 	/*
<span class="p_del">-	 * There may be still new events arriving in the notification queue</span>
<span class="p_del">-	 * but since userspace cannot use fanotify fd anymore, no event can</span>
<span class="p_del">-	 * enter or leave access_list by now.</span>
<span class="p_add">+	 * Stop new events from arriving in the notification queue. since</span>
<span class="p_add">+	 * userspace cannot use fanotify fd anymore, no event can enter or</span>
<span class="p_add">+	 * leave access_list by now either.</span>
 	 */
<span class="p_del">-	spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-	atomic_inc(&amp;group-&gt;fanotify_data.bypass_perm);</span>
<span class="p_add">+	fsnotify_group_stop_queueing(group);</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Process all permission events on access_list and notification queue</span>
<span class="p_add">+	 * and simulate reply from userspace.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;group-&gt;fanotify_data.access_lock);</span>
 	list_for_each_entry_safe(event, next, &amp;group-&gt;fanotify_data.access_list,
 				 fae.fse.list) {
 		pr_debug(&quot;%s: found group=%p event=%p\n&quot;, __func__, group,
<span class="p_chunk">@@ -379,12 +383,21 @@</span> <span class="p_context"> static int fanotify_release(struct inode *ignored, struct file *file)</span>
 	spin_unlock(&amp;group-&gt;fanotify_data.access_lock);
 
 	/*
<span class="p_del">-	 * Since bypass_perm is set, newly queued events will not wait for</span>
<span class="p_del">-	 * access response. Wake up the already sleeping ones now.</span>
<span class="p_del">-	 * synchronize_srcu() in fsnotify_destroy_group() will wait for all</span>
<span class="p_del">-	 * processes sleeping in fanotify_handle_event() waiting for access</span>
<span class="p_del">-	 * response and thus also for all permission events to be freed.</span>
<span class="p_add">+	 * Destroy all non-permission events. For permission events just</span>
<span class="p_add">+	 * dequeue them and set the response. They will be freed once the</span>
<span class="p_add">+	 * response is consumed and fanotify_get_response() returns.</span>
 	 */
<span class="p_add">+	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+	while (!fsnotify_notify_queue_is_empty(group)) {</span>
<span class="p_add">+		fsn_event = fsnotify_remove_first_event(group);</span>
<span class="p_add">+		if (!(fsn_event-&gt;mask &amp; FAN_ALL_PERM_EVENTS))</span>
<span class="p_add">+			fsnotify_destroy_event(group, fsn_event);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			FANOTIFY_PE(fsn_event)-&gt;response = FAN_ALLOW;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Response for all permission events it set, wakeup waiters */</span>
 	wake_up(&amp;group-&gt;fanotify_data.access_waitq);
 #endif
 
<span class="p_chunk">@@ -755,7 +768,6 @@</span> <span class="p_context"> SYSCALL_DEFINE2(fanotify_init, unsigned int, flags, unsigned int, event_f_flags)</span>
 	spin_lock_init(&amp;group-&gt;fanotify_data.access_lock);
 	init_waitqueue_head(&amp;group-&gt;fanotify_data.access_waitq);
 	INIT_LIST_HEAD(&amp;group-&gt;fanotify_data.access_list);
<span class="p_del">-	atomic_set(&amp;group-&gt;fanotify_data.bypass_perm, 0);</span>
 #endif
 	switch (flags &amp; FAN_ALL_CLASS_BITS) {
 	case FAN_CLASS_NOTIF:
<span class="p_header">diff --git a/fs/notify/group.c b/fs/notify/group.c</span>
<span class="p_header">index d16b62cb2854..18eb30c6bd8f 100644</span>
<span class="p_header">--- a/fs/notify/group.c</span>
<span class="p_header">+++ b/fs/notify/group.c</span>
<span class="p_chunk">@@ -40,6 +40,17 @@</span> <span class="p_context"> static void fsnotify_final_destroy_group(struct fsnotify_group *group)</span>
 }
 
 /*
<span class="p_add">+ * Stop queueing new events for this group. Once this function returns</span>
<span class="p_add">+ * fsnotify_add_event() will not add any new events to the group&#39;s queue.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void fsnotify_group_stop_queueing(struct fsnotify_group *group)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+	group-&gt;shutdown = true;</span>
<span class="p_add">+	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Trying to get rid of a group. Remove all marks, flush all events and release
  * the group reference.
  * Note that another thread calling fsnotify_clear_marks_by_group() may still
<span class="p_chunk">@@ -47,6 +58,14 @@</span> <span class="p_context"> static void fsnotify_final_destroy_group(struct fsnotify_group *group)</span>
  */
 void fsnotify_destroy_group(struct fsnotify_group *group)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Stop queueing new events. The code below is careful enough to not</span>
<span class="p_add">+	 * require this but fanotify needs to stop queuing events even before</span>
<span class="p_add">+	 * fsnotify_destroy_group() is called and this makes the other callers</span>
<span class="p_add">+	 * of fsnotify_destroy_group() to see the same behavior.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	fsnotify_group_stop_queueing(group);</span>
<span class="p_add">+</span>
 	/* clear all inode marks for this group */
 	fsnotify_clear_marks_by_group(group);
 
<span class="p_header">diff --git a/fs/notify/notification.c b/fs/notify/notification.c</span>
<span class="p_header">index a95d8e037aeb..e455e83ceeeb 100644</span>
<span class="p_header">--- a/fs/notify/notification.c</span>
<span class="p_header">+++ b/fs/notify/notification.c</span>
<span class="p_chunk">@@ -82,7 +82,8 @@</span> <span class="p_context"> void fsnotify_destroy_event(struct fsnotify_group *group,</span>
  * Add an event to the group notification queue.  The group can later pull this
  * event off the queue to deal with.  The function returns 0 if the event was
  * added to the queue, 1 if the event was merged with some other queued event,
<span class="p_del">- * 2 if the queue of events has overflown.</span>
<span class="p_add">+ * 2 if the event was not queued - either the queue of events has overflown</span>
<span class="p_add">+ * or the group is shutting down.</span>
  */
 int fsnotify_add_event(struct fsnotify_group *group,
 		       struct fsnotify_event *event,
<span class="p_chunk">@@ -96,6 +97,11 @@</span> <span class="p_context"> int fsnotify_add_event(struct fsnotify_group *group,</span>
 
 	mutex_lock(&amp;group-&gt;notification_mutex);
 
<span class="p_add">+	if (group-&gt;shutdown) {</span>
<span class="p_add">+		mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_add">+		return 2;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (group-&gt;q_len &gt;= group-&gt;max_events) {
 		ret = 2;
 		/* Queue overflow event only if it isn&#39;t already queued */
<span class="p_chunk">@@ -126,21 +132,6 @@</span> <span class="p_context"> queue:</span>
 }
 
 /*
<span class="p_del">- * Remove @event from group&#39;s notification queue. It is the responsibility of</span>
<span class="p_del">- * the caller to destroy the event.</span>
<span class="p_del">- */</span>
<span class="p_del">-void fsnotify_remove_event(struct fsnotify_group *group,</span>
<span class="p_del">-			   struct fsnotify_event *event)</span>
<span class="p_del">-{</span>
<span class="p_del">-	mutex_lock(&amp;group-&gt;notification_mutex);</span>
<span class="p_del">-	if (!list_empty(&amp;event-&gt;list)) {</span>
<span class="p_del">-		list_del_init(&amp;event-&gt;list);</span>
<span class="p_del">-		group-&gt;q_len--;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	mutex_unlock(&amp;group-&gt;notification_mutex);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
  * Remove and return the first event from the notification list.  It is the
  * responsibility of the caller to destroy the obtained event
  */
<span class="p_header">diff --git a/fs/ocfs2/dlm/dlmconvert.c b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">index f90931335c6b..2e11658676eb 100644</span>
<span class="p_header">--- a/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_header">+++ b/fs/ocfs2/dlm/dlmconvert.c</span>
<span class="p_chunk">@@ -262,7 +262,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 				  struct dlm_lock *lock, int flags, int type)
 {
 	enum dlm_status status;
<span class="p_del">-	u8 old_owner = res-&gt;owner;</span>
 
 	mlog(0, &quot;type=%d, convert_type=%d, busy=%d\n&quot;, lock-&gt;ml.type,
 	     lock-&gt;ml.convert_type, res-&gt;state &amp; DLM_LOCK_RES_IN_PROGRESS);
<span class="p_chunk">@@ -329,7 +328,6 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 
 	spin_lock(&amp;res-&gt;spinlock);
 	res-&gt;state &amp;= ~DLM_LOCK_RES_IN_PROGRESS;
<span class="p_del">-	lock-&gt;convert_pending = 0;</span>
 	/* if it failed, move it back to granted queue.
 	 * if master returns DLM_NORMAL and then down before sending ast,
 	 * it may have already been moved to granted queue, reset to
<span class="p_chunk">@@ -338,12 +336,14 @@</span> <span class="p_context"> enum dlm_status dlmconvert_remote(struct dlm_ctxt *dlm,</span>
 		if (status != DLM_NOTQUEUED)
 			dlm_error(status);
 		dlm_revert_pending_convert(res, lock);
<span class="p_del">-	} else if ((res-&gt;state &amp; DLM_LOCK_RES_RECOVERING) ||</span>
<span class="p_del">-			(old_owner != res-&gt;owner)) {</span>
<span class="p_del">-		mlog(0, &quot;res %.*s is in recovering or has been recovered.\n&quot;,</span>
<span class="p_del">-				res-&gt;lockname.len, res-&gt;lockname.name);</span>
<span class="p_add">+	} else if (!lock-&gt;convert_pending) {</span>
<span class="p_add">+		mlog(0, &quot;%s: res %.*s, owner died and lock has been moved back &quot;</span>
<span class="p_add">+				&quot;to granted list, retry convert.\n&quot;,</span>
<span class="p_add">+				dlm-&gt;name, res-&gt;lockname.len, res-&gt;lockname.name);</span>
 		status = DLM_RECOVERING;
 	}
<span class="p_add">+</span>
<span class="p_add">+	lock-&gt;convert_pending = 0;</span>
 bail:
 	spin_unlock(&amp;res-&gt;spinlock);
 
<span class="p_header">diff --git a/fs/ocfs2/file.c b/fs/ocfs2/file.c</span>
<span class="p_header">index 77d30cbd944d..56dd3957cc91 100644</span>
<span class="p_header">--- a/fs/ocfs2/file.c</span>
<span class="p_header">+++ b/fs/ocfs2/file.c</span>
<span class="p_chunk">@@ -1536,7 +1536,8 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 				       u64 start, u64 len)
 {
 	int ret = 0;
<span class="p_del">-	u64 tmpend, end = start + len;</span>
<span class="p_add">+	u64 tmpend = 0;</span>
<span class="p_add">+	u64 end = start + len;</span>
 	struct ocfs2_super *osb = OCFS2_SB(inode-&gt;i_sb);
 	unsigned int csize = osb-&gt;s_clustersize;
 	handle_t *handle;
<span class="p_chunk">@@ -1568,18 +1569,31 @@</span> <span class="p_context"> static int ocfs2_zero_partial_clusters(struct inode *inode,</span>
 	}
 
 	/*
<span class="p_del">-	 * We want to get the byte offset of the end of the 1st cluster.</span>
<span class="p_add">+	 * If start is on a cluster boundary and end is somewhere in another</span>
<span class="p_add">+	 * cluster, we have not COWed the cluster starting at start, unless</span>
<span class="p_add">+	 * end is also within the same cluster. So, in this case, we skip this</span>
<span class="p_add">+	 * first call to ocfs2_zero_range_for_truncate() truncate and move on</span>
<span class="p_add">+	 * to the next one.</span>
 	 */
<span class="p_del">-	tmpend = (u64)osb-&gt;s_clustersize + (start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_del">-	if (tmpend &gt; end)</span>
<span class="p_del">-		tmpend = end;</span>
<span class="p_add">+	if ((start &amp; (csize - 1)) != 0) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We want to get the byte offset of the end of the 1st</span>
<span class="p_add">+		 * cluster.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tmpend = (u64)osb-&gt;s_clustersize +</span>
<span class="p_add">+			(start &amp; ~(osb-&gt;s_clustersize - 1));</span>
<span class="p_add">+		if (tmpend &gt; end)</span>
<span class="p_add">+			tmpend = end;</span>
 
<span class="p_del">-	trace_ocfs2_zero_partial_clusters_range1((unsigned long long)start,</span>
<span class="p_del">-						 (unsigned long long)tmpend);</span>
<span class="p_add">+		trace_ocfs2_zero_partial_clusters_range1(</span>
<span class="p_add">+			(unsigned long long)start,</span>
<span class="p_add">+			(unsigned long long)tmpend);</span>
 
<span class="p_del">-	ret = ocfs2_zero_range_for_truncate(inode, handle, start, tmpend);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		mlog_errno(ret);</span>
<span class="p_add">+		ret = ocfs2_zero_range_for_truncate(inode, handle, start,</span>
<span class="p_add">+						    tmpend);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			mlog_errno(ret);</span>
<span class="p_add">+	}</span>
 
 	if (tmpend &lt; end) {
 		/*
<span class="p_header">diff --git a/fs/reiserfs/ibalance.c b/fs/reiserfs/ibalance.c</span>
<span class="p_header">index b751eea32e20..5db6f45b3fed 100644</span>
<span class="p_header">--- a/fs/reiserfs/ibalance.c</span>
<span class="p_header">+++ b/fs/reiserfs/ibalance.c</span>
<span class="p_chunk">@@ -1153,8 +1153,9 @@</span> <span class="p_context"> int balance_internal(struct tree_balance *tb,</span>
 				       insert_ptr);
 	}
 
<span class="p_del">-	memcpy(new_insert_key_addr, &amp;new_insert_key, KEY_SIZE);</span>
 	insert_ptr[0] = new_insert_ptr;
<span class="p_add">+	if (new_insert_ptr)</span>
<span class="p_add">+		memcpy(new_insert_key_addr, &amp;new_insert_key, KEY_SIZE);</span>
 
 	return order;
 }
<span class="p_header">diff --git a/fs/xfs/xfs_buf.c b/fs/xfs/xfs_buf.c</span>
<span class="p_header">index 39090fc56f09..eb1b8c8acfcb 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_buf.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_buf.c</span>
<span class="p_chunk">@@ -1535,7 +1535,7 @@</span> <span class="p_context"> xfs_wait_buftarg(</span>
 	 * ensure here that all reference counts have been dropped before we
 	 * start walking the LRU list.
 	 */
<span class="p_del">-	drain_workqueue(btp-&gt;bt_mount-&gt;m_buf_workqueue);</span>
<span class="p_add">+	flush_workqueue(btp-&gt;bt_mount-&gt;m_buf_workqueue);</span>
 
 	/* loop until there is nothing left on the lru list. */
 	while (list_lru_count(&amp;btp-&gt;bt_lru)) {
<span class="p_header">diff --git a/include/linux/fsnotify_backend.h b/include/linux/fsnotify_backend.h</span>
<span class="p_header">index 533c4408529a..850d8822e8ff 100644</span>
<span class="p_header">--- a/include/linux/fsnotify_backend.h</span>
<span class="p_header">+++ b/include/linux/fsnotify_backend.h</span>
<span class="p_chunk">@@ -148,6 +148,7 @@</span> <span class="p_context"> struct fsnotify_group {</span>
 	#define FS_PRIO_1	1 /* fanotify content based access control */
 	#define FS_PRIO_2	2 /* fanotify pre-content access */
 	unsigned int priority;
<span class="p_add">+	bool shutdown;		/* group is being shut down, don&#39;t queue more events */</span>
 
 	/* stores all fastpath marks assoc with this group so they can be cleaned on unregister */
 	struct mutex mark_mutex;	/* protect marks_list */
<span class="p_chunk">@@ -179,7 +180,6 @@</span> <span class="p_context"> struct fsnotify_group {</span>
 			spinlock_t access_lock;
 			struct list_head access_list;
 			wait_queue_head_t access_waitq;
<span class="p_del">-			atomic_t bypass_perm;</span>
 #endif /* CONFIG_FANOTIFY_ACCESS_PERMISSIONS */
 			int f_flags;
 			unsigned int max_marks;
<span class="p_chunk">@@ -308,6 +308,8 @@</span> <span class="p_context"> extern struct fsnotify_group *fsnotify_alloc_group(const struct fsnotify_ops *op</span>
 extern void fsnotify_get_group(struct fsnotify_group *group);
 /* drop reference on a group from fsnotify_alloc_group */
 extern void fsnotify_put_group(struct fsnotify_group *group);
<span class="p_add">+/* group destruction begins, stop queuing new events */</span>
<span class="p_add">+extern void fsnotify_group_stop_queueing(struct fsnotify_group *group);</span>
 /* destroy group */
 extern void fsnotify_destroy_group(struct fsnotify_group *group);
 /* fasync handler function */
<span class="p_chunk">@@ -320,8 +322,6 @@</span> <span class="p_context"> extern int fsnotify_add_event(struct fsnotify_group *group,</span>
 			      struct fsnotify_event *event,
 			      int (*merge)(struct list_head *,
 					   struct fsnotify_event *));
<span class="p_del">-/* Remove passed event from groups notification queue */</span>
<span class="p_del">-extern void fsnotify_remove_event(struct fsnotify_group *group, struct fsnotify_event *event);</span>
 /* true if the group notification queue is empty */
 extern bool fsnotify_notify_queue_is_empty(struct fsnotify_group *group);
 /* return, but do not dequeue the first event on the notification queue */
<span class="p_header">diff --git a/include/linux/kernel.h b/include/linux/kernel.h</span>
<span class="p_header">index 924853d33a13..e571e592e53a 100644</span>
<span class="p_header">--- a/include/linux/kernel.h</span>
<span class="p_header">+++ b/include/linux/kernel.h</span>
<span class="p_chunk">@@ -202,26 +202,26 @@</span> <span class="p_context"> extern int _cond_resched(void);</span>
 
 /**
  * abs - return absolute value of an argument
<span class="p_del">- * @x: the value.  If it is unsigned type, it is converted to signed type first</span>
<span class="p_del">- *   (s64, long or int depending on its size).</span>
<span class="p_add">+ * @x: the value.  If it is unsigned type, it is converted to signed type first.</span>
<span class="p_add">+ *     char is treated as if it was signed (regardless of whether it really is)</span>
<span class="p_add">+ *     but the macro&#39;s return type is preserved as char.</span>
  *
<span class="p_del">- * Return: an absolute value of x.  If x is 64-bit, macro&#39;s return type is s64,</span>
<span class="p_del">- *   otherwise it is signed long.</span>
<span class="p_add">+ * Return: an absolute value of x.</span>
  */
<span class="p_del">-#define abs(x) __builtin_choose_expr(sizeof(x) == sizeof(s64), ({	\</span>
<span class="p_del">-		s64 __x = (x);						\</span>
<span class="p_del">-		(__x &lt; 0) ? -__x : __x;					\</span>
<span class="p_del">-	}), ({								\</span>
<span class="p_del">-		long ret;						\</span>
<span class="p_del">-		if (sizeof(x) == sizeof(long)) {			\</span>
<span class="p_del">-			long __x = (x);					\</span>
<span class="p_del">-			ret = (__x &lt; 0) ? -__x : __x;			\</span>
<span class="p_del">-		} else {						\</span>
<span class="p_del">-			int __x = (x);					\</span>
<span class="p_del">-			ret = (__x &lt; 0) ? -__x : __x;			\</span>
<span class="p_del">-		}							\</span>
<span class="p_del">-		ret;							\</span>
<span class="p_del">-	}))</span>
<span class="p_add">+#define abs(x)	__abs_choose_expr(x, long long,				\</span>
<span class="p_add">+		__abs_choose_expr(x, long,				\</span>
<span class="p_add">+		__abs_choose_expr(x, int,				\</span>
<span class="p_add">+		__abs_choose_expr(x, short,				\</span>
<span class="p_add">+		__abs_choose_expr(x, char,				\</span>
<span class="p_add">+		__builtin_choose_expr(					\</span>
<span class="p_add">+			__builtin_types_compatible_p(typeof(x), char),	\</span>
<span class="p_add">+			(char)({ signed char __x = (x); __x&lt;0?-__x:__x; }), \</span>
<span class="p_add">+			((void)0)))))))</span>
<span class="p_add">+</span>
<span class="p_add">+#define __abs_choose_expr(x, type, other) __builtin_choose_expr(	\</span>
<span class="p_add">+	__builtin_types_compatible_p(typeof(x),   signed type) ||	\</span>
<span class="p_add">+	__builtin_types_compatible_p(typeof(x), unsigned type),		\</span>
<span class="p_add">+	({ signed type __x = (x); __x &lt; 0 ? -__x : __x; }), other)</span>
 
 /**
  * reciprocal_scale - &quot;scale&quot; a value into range [0, ep_ro)
<span class="p_header">diff --git a/include/linux/netdevice.h b/include/linux/netdevice.h</span>
<span class="p_header">index b97d6823ef3c..4e9c75226f07 100644</span>
<span class="p_header">--- a/include/linux/netdevice.h</span>
<span class="p_header">+++ b/include/linux/netdevice.h</span>
<span class="p_chunk">@@ -3036,6 +3036,7 @@</span> <span class="p_context"> static inline void napi_free_frags(struct napi_struct *napi)</span>
 	napi-&gt;skb = NULL;
 }
 
<span class="p_add">+bool netdev_is_rx_handler_busy(struct net_device *dev);</span>
 int netdev_rx_handler_register(struct net_device *dev,
 			       rx_handler_func_t *rx_handler,
 			       void *rx_handler_data);
<span class="p_header">diff --git a/include/linux/pagemap.h b/include/linux/pagemap.h</span>
<span class="p_header">index 26eabf5ec718..fbfadba81c5a 100644</span>
<span class="p_header">--- a/include/linux/pagemap.h</span>
<span class="p_header">+++ b/include/linux/pagemap.h</span>
<span class="p_chunk">@@ -601,56 +601,56 @@</span> <span class="p_context"> static inline int fault_in_pages_readable(const char __user *uaddr, int size)</span>
  */
 static inline int fault_in_multipages_writeable(char __user *uaddr, int size)
 {
<span class="p_del">-	int ret = 0;</span>
 	char __user *end = uaddr + size - 1;
 
 	if (unlikely(size == 0))
<span class="p_del">-		return ret;</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_add">+	if (unlikely(uaddr &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
 	/*
 	 * Writing zeroes into userspace here is OK, because we know that if
 	 * the zero gets there, we&#39;ll be overwriting it.
 	 */
<span class="p_del">-	while (uaddr &lt;= end) {</span>
<span class="p_del">-		ret = __put_user(0, uaddr);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (unlikely(__put_user(0, uaddr) != 0))</span>
<span class="p_add">+			return -EFAULT;</span>
 		uaddr += PAGE_SIZE;
<span class="p_del">-	}</span>
<span class="p_add">+	} while (uaddr &lt;= end);</span>
 
 	/* Check whether the range spilled into the next page. */
 	if (((unsigned long)uaddr &amp; PAGE_MASK) ==
 			((unsigned long)end &amp; PAGE_MASK))
<span class="p_del">-		ret = __put_user(0, end);</span>
<span class="p_add">+		return __put_user(0, end);</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 static inline int fault_in_multipages_readable(const char __user *uaddr,
 					       int size)
 {
 	volatile char c;
<span class="p_del">-	int ret = 0;</span>
 	const char __user *end = uaddr + size - 1;
 
 	if (unlikely(size == 0))
<span class="p_del">-		return ret;</span>
<span class="p_add">+		return 0;</span>
 
<span class="p_del">-	while (uaddr &lt;= end) {</span>
<span class="p_del">-		ret = __get_user(c, uaddr);</span>
<span class="p_del">-		if (ret != 0)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+	if (unlikely(uaddr &gt; end))</span>
<span class="p_add">+		return -EFAULT;</span>
<span class="p_add">+</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		if (unlikely(__get_user(c, uaddr) != 0))</span>
<span class="p_add">+			return -EFAULT;</span>
 		uaddr += PAGE_SIZE;
<span class="p_del">-	}</span>
<span class="p_add">+	} while (uaddr &lt;= end);</span>
 
 	/* Check whether the range spilled into the next page. */
 	if (((unsigned long)uaddr &amp; PAGE_MASK) ==
 			((unsigned long)end &amp; PAGE_MASK)) {
<span class="p_del">-		ret = __get_user(c, end);</span>
<span class="p_del">-		(void)c;</span>
<span class="p_add">+		return __get_user(c, end);</span>
 	}
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return 0;</span>
 }
 
 int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
<span class="p_header">diff --git a/include/linux/smc91x.h b/include/linux/smc91x.h</span>
<span class="p_header">index 76199b75d584..e302c447e057 100644</span>
<span class="p_header">--- a/include/linux/smc91x.h</span>
<span class="p_header">+++ b/include/linux/smc91x.h</span>
<span class="p_chunk">@@ -1,6 +1,16 @@</span> <span class="p_context"></span>
 #ifndef __SMC91X_H__
 #define __SMC91X_H__
 
<span class="p_add">+/*</span>
<span class="p_add">+ * These bits define which access sizes a platform can support, rather</span>
<span class="p_add">+ * than the maximal access size.  So, if your platform can do 16-bit</span>
<span class="p_add">+ * and 32-bit accesses to the SMC91x device, but not 8-bit, set both</span>
<span class="p_add">+ * SMC91X_USE_16BIT and SMC91X_USE_32BIT.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The SMC91x driver requires at least one of SMC91X_USE_8BIT or</span>
<span class="p_add">+ * SMC91X_USE_16BIT to be supported - just setting SMC91X_USE_32BIT is</span>
<span class="p_add">+ * an invalid configuration.</span>
<span class="p_add">+ */</span>
 #define SMC91X_USE_8BIT (1 &lt;&lt; 0)
 #define SMC91X_USE_16BIT (1 &lt;&lt; 1)
 #define SMC91X_USE_32BIT (1 &lt;&lt; 2)
<span class="p_header">diff --git a/include/net/af_unix.h b/include/net/af_unix.h</span>
<span class="p_header">index 9b4c418bebd8..fd60eccb59a6 100644</span>
<span class="p_header">--- a/include/net/af_unix.h</span>
<span class="p_header">+++ b/include/net/af_unix.h</span>
<span class="p_chunk">@@ -52,7 +52,7 @@</span> <span class="p_context"> struct unix_sock {</span>
 	struct sock		sk;
 	struct unix_address     *addr;
 	struct path		path;
<span class="p_del">-	struct mutex		readlock;</span>
<span class="p_add">+	struct mutex		iolock, bindlock;</span>
 	struct sock		*peer;
 	struct list_head	link;
 	atomic_long_t		inflight;
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index 414d822bc1db..9c3ab544d3a8 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -1510,6 +1510,8 @@</span> <span class="p_context"> static inline void tcp_check_send_head(struct sock *sk, struct sk_buff *skb_unli</span>
 {
 	if (sk-&gt;sk_send_head == skb_unlinked)
 		sk-&gt;sk_send_head = NULL;
<span class="p_add">+	if (tcp_sk(sk)-&gt;highest_sack == skb_unlinked)</span>
<span class="p_add">+		tcp_sk(sk)-&gt;highest_sack = NULL;</span>
 }
 
 static inline void tcp_init_send_head(struct sock *sk)
<span class="p_header">diff --git a/kernel/cpuset.c b/kernel/cpuset.c</span>
<span class="p_header">index e120bd983ad0..b9279a2844d8 100644</span>
<span class="p_header">--- a/kernel/cpuset.c</span>
<span class="p_header">+++ b/kernel/cpuset.c</span>
<span class="p_chunk">@@ -2079,7 +2079,7 @@</span> <span class="p_context"> static void cpuset_bind(struct cgroup_subsys_state *root_css)</span>
  * which could have been changed by cpuset just after it inherits the
  * state from the parent and before it sits on the cgroup&#39;s task list.
  */
<span class="p_del">-void cpuset_fork(struct task_struct *task)</span>
<span class="p_add">+void cpuset_fork(struct task_struct *task, void *priv)</span>
 {
 	if (task_css_is_root(task, cpuset_cgrp_id))
 		return;
<span class="p_header">diff --git a/kernel/power/hibernate.c b/kernel/power/hibernate.c</span>
<span class="p_header">index b7dd5718836e..3124cebaec31 100644</span>
<span class="p_header">--- a/kernel/power/hibernate.c</span>
<span class="p_header">+++ b/kernel/power/hibernate.c</span>
<span class="p_chunk">@@ -299,12 +299,12 @@</span> <span class="p_context"> static int create_image(int platform_mode)</span>
 	save_processor_state();
 	trace_suspend_resume(TPS(&quot;machine_suspend&quot;), PM_EVENT_HIBERNATE, true);
 	error = swsusp_arch_suspend();
<span class="p_add">+	/* Restore control flow magically appears here */</span>
<span class="p_add">+	restore_processor_state();</span>
 	trace_suspend_resume(TPS(&quot;machine_suspend&quot;), PM_EVENT_HIBERNATE, false);
 	if (error)
 		printk(KERN_ERR &quot;PM: Error %d creating hibernation image\n&quot;,
 			error);
<span class="p_del">-	/* Restore control flow magically appears here */</span>
<span class="p_del">-	restore_processor_state();</span>
 	if (!in_suspend)
 		events_check_enabled = false;
 
<span class="p_header">diff --git a/kernel/power/snapshot.c b/kernel/power/snapshot.c</span>
<span class="p_header">index 3a970604308f..f155c62f1f2c 100644</span>
<span class="p_header">--- a/kernel/power/snapshot.c</span>
<span class="p_header">+++ b/kernel/power/snapshot.c</span>
<span class="p_chunk">@@ -765,9 +765,9 @@</span> <span class="p_context"> static bool memory_bm_pfn_present(struct memory_bitmap *bm, unsigned long pfn)</span>
  */
 static bool rtree_next_node(struct memory_bitmap *bm)
 {
<span class="p_del">-	bm-&gt;cur.node = list_entry(bm-&gt;cur.node-&gt;list.next,</span>
<span class="p_del">-				  struct rtree_node, list);</span>
<span class="p_del">-	if (&amp;bm-&gt;cur.node-&gt;list != &amp;bm-&gt;cur.zone-&gt;leaves) {</span>
<span class="p_add">+	if (!list_is_last(&amp;bm-&gt;cur.node-&gt;list, &amp;bm-&gt;cur.zone-&gt;leaves)) {</span>
<span class="p_add">+		bm-&gt;cur.node = list_entry(bm-&gt;cur.node-&gt;list.next,</span>
<span class="p_add">+					  struct rtree_node, list);</span>
 		bm-&gt;cur.node_pfn += BM_BITS_PER_BLOCK;
 		bm-&gt;cur.node_bit  = 0;
 		touch_softlockup_watchdog();
<span class="p_chunk">@@ -775,9 +775,9 @@</span> <span class="p_context"> static bool rtree_next_node(struct memory_bitmap *bm)</span>
 	}
 
 	/* No more nodes, goto next zone */
<span class="p_del">-	bm-&gt;cur.zone = list_entry(bm-&gt;cur.zone-&gt;list.next,</span>
<span class="p_add">+	if (!list_is_last(&amp;bm-&gt;cur.zone-&gt;list, &amp;bm-&gt;zones)) {</span>
<span class="p_add">+		bm-&gt;cur.zone = list_entry(bm-&gt;cur.zone-&gt;list.next,</span>
 				  struct mem_zone_bm_rtree, list);
<span class="p_del">-	if (&amp;bm-&gt;cur.zone-&gt;list != &amp;bm-&gt;zones) {</span>
 		bm-&gt;cur.node = list_entry(bm-&gt;cur.zone-&gt;leaves.next,
 					  struct rtree_node, list);
 		bm-&gt;cur.node_pfn = 0;
<span class="p_header">diff --git a/kernel/trace/Makefile b/kernel/trace/Makefile</span>
<span class="p_header">index 9b1044e936a6..05ea5167e6bb 100644</span>
<span class="p_header">--- a/kernel/trace/Makefile</span>
<span class="p_header">+++ b/kernel/trace/Makefile</span>
<span class="p_chunk">@@ -1,4 +1,8 @@</span> <span class="p_context"></span>
 
<span class="p_add">+# We are fully aware of the dangers of __builtin_return_address()</span>
<span class="p_add">+FRAME_CFLAGS := $(call cc-disable-warning,frame-address)</span>
<span class="p_add">+KBUILD_CFLAGS += $(FRAME_CFLAGS)</span>
<span class="p_add">+</span>
 # Do not instrument the tracer itself:
 
 ifdef CONFIG_FUNCTION_TRACER
<span class="p_header">diff --git a/kernel/trace/trace.c b/kernel/trace/trace.c</span>
<span class="p_header">index 8305cbb2d5a2..059233abcfcf 100644</span>
<span class="p_header">--- a/kernel/trace/trace.c</span>
<span class="p_header">+++ b/kernel/trace/trace.c</span>
<span class="p_chunk">@@ -4727,19 +4727,20 @@</span> <span class="p_context"> tracing_read_pipe(struct file *filp, char __user *ubuf,</span>
 	struct trace_iterator *iter = filp-&gt;private_data;
 	ssize_t sret;
 
<span class="p_del">-	/* return any leftover data */</span>
<span class="p_del">-	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_del">-	if (sret != -EBUSY)</span>
<span class="p_del">-		return sret;</span>
<span class="p_del">-</span>
<span class="p_del">-	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_del">-</span>
 	/*
 	 * Avoid more than one consumer on a single file descriptor
 	 * This is just a matter of traces coherency, the ring buffer itself
 	 * is protected.
 	 */
 	mutex_lock(&amp;iter-&gt;mutex);
<span class="p_add">+</span>
<span class="p_add">+	/* return any leftover data */</span>
<span class="p_add">+	sret = trace_seq_to_user(&amp;iter-&gt;seq, ubuf, cnt);</span>
<span class="p_add">+	if (sret != -EBUSY)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_seq_init(&amp;iter-&gt;seq);</span>
<span class="p_add">+</span>
 	if (iter-&gt;trace-&gt;read) {
 		sret = iter-&gt;trace-&gt;read(iter, filp, ubuf, cnt, ppos);
 		if (sret)
<span class="p_chunk">@@ -5766,9 +5767,6 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 		return -EBUSY;
 #endif
 
<span class="p_del">-	if (splice_grow_spd(pipe, &amp;spd))</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
 	if (*ppos &amp; (PAGE_SIZE - 1))
 		return -EINVAL;
 
<span class="p_chunk">@@ -5778,6 +5776,9 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 		len &amp;= PAGE_MASK;
 	}
 
<span class="p_add">+	if (splice_grow_spd(pipe, &amp;spd))</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
  again:
 	trace_access_lock(iter-&gt;cpu_file);
 	entries = ring_buffer_entries_cpu(iter-&gt;trace_buffer-&gt;buffer, iter-&gt;cpu_file);
<span class="p_chunk">@@ -5835,19 +5836,21 @@</span> <span class="p_context"> tracing_buffers_splice_read(struct file *file, loff_t *ppos,</span>
 	/* did we read anything? */
 	if (!spd.nr_pages) {
 		if (ret)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out;</span>
 
<span class="p_add">+		ret = -EAGAIN;</span>
 		if ((file-&gt;f_flags &amp; O_NONBLOCK) || (flags &amp; SPLICE_F_NONBLOCK))
<span class="p_del">-			return -EAGAIN;</span>
<span class="p_add">+			goto out;</span>
 
 		ret = wait_on_pipe(iter, true);
 		if (ret)
<span class="p_del">-			return ret;</span>
<span class="p_add">+			goto out;</span>
 
 		goto again;
 	}
 
 	ret = splice_to_pipe(pipe, &amp;spd);
<span class="p_add">+out:</span>
 	splice_shrink_spd(&amp;spd);
 
 	return ret;
<span class="p_header">diff --git a/mm/vmscan.c b/mm/vmscan.c</span>
<span class="p_header">index 0c114e2b01d3..0838e9f02b11 100644</span>
<span class="p_header">--- a/mm/vmscan.c</span>
<span class="p_header">+++ b/mm/vmscan.c</span>
<span class="p_chunk">@@ -2159,23 +2159,6 @@</span> <span class="p_context"> out:</span>
 	}
 }
 
<span class="p_del">-#ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH</span>
<span class="p_del">-static void init_tlb_ubc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This deliberately does not clear the cpumask as it&#39;s expensive</span>
<span class="p_del">-	 * and unnecessary. If there happens to be data in there then the</span>
<span class="p_del">-	 * first SWAP_CLUSTER_MAX pages will send an unnecessary IPI and</span>
<span class="p_del">-	 * then will be cleared.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	current-&gt;tlb_ubc.flush_required = false;</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline void init_tlb_ubc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif /* CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH */</span>
<span class="p_del">-</span>
 /*
  * This is a basic per-zone page freer.  Used by both kswapd and direct reclaim.
  */
<span class="p_chunk">@@ -2210,8 +2193,6 @@</span> <span class="p_context"> static void shrink_lruvec(struct lruvec *lruvec, int swappiness,</span>
 	scan_adjusted = (global_reclaim(sc) &amp;&amp; !current_is_kswapd() &amp;&amp;
 			 sc-&gt;priority == DEF_PRIORITY);
 
<span class="p_del">-	init_tlb_ubc();</span>
<span class="p_del">-</span>
 	blk_start_plug(&amp;plug);
 	while (nr[LRU_INACTIVE_ANON] || nr[LRU_ACTIVE_FILE] ||
 					nr[LRU_INACTIVE_FILE]) {
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 7173a685309a..9542e84a9455 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -1113,7 +1113,7 @@</span> <span class="p_context"> static int br_ip6_multicast_mld2_report(struct net_bridge *br,</span>
 		} else {
 			err = br_ip6_multicast_add_group(br, port,
 							 &amp;grec-&gt;grec_mca, vid);
<span class="p_del">-			if (!err)</span>
<span class="p_add">+			if (err)</span>
 				break;
 		}
 	}
<span class="p_header">diff --git a/net/caif/cfpkt_skbuff.c b/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">index f6c3b2137eea..59ce1fcc220c 100644</span>
<span class="p_header">--- a/net/caif/cfpkt_skbuff.c</span>
<span class="p_header">+++ b/net/caif/cfpkt_skbuff.c</span>
<span class="p_chunk">@@ -286,7 +286,7 @@</span> <span class="p_context"> int cfpkt_setlen(struct cfpkt *pkt, u16 len)</span>
 		else
 			skb_trim(skb, len);
 
<span class="p_del">-			return cfpkt_getlen(pkt);</span>
<span class="p_add">+		return cfpkt_getlen(pkt);</span>
 	}
 
 	/* Need to expand SKB */
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 9efbdb3ff78a..de4ed2b5a221 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -3722,6 +3722,22 @@</span> <span class="p_context"> static inline struct sk_buff *handle_ing(struct sk_buff *skb,</span>
 }
 
 /**
<span class="p_add">+ *	netdev_is_rx_handler_busy - check if receive handler is registered</span>
<span class="p_add">+ *	@dev: device to check</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Check if a receive handler is already registered for a given device.</span>
<span class="p_add">+ *	Return true if there one.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	The caller must hold the rtnl_mutex.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool netdev_is_rx_handler_busy(struct net_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ASSERT_RTNL();</span>
<span class="p_add">+	return dev &amp;&amp; rtnl_dereference(dev-&gt;rx_handler);</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(netdev_is_rx_handler_busy);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  *	netdev_rx_handler_register - register receive handler
  *	@dev: device to register a handler for
  *	@rx_handler: receive handler to register
<span class="p_header">diff --git a/net/ipv4/fib_trie.c b/net/ipv4/fib_trie.c</span>
<span class="p_header">index 744e5936c10d..e5a3ff210fec 100644</span>
<span class="p_header">--- a/net/ipv4/fib_trie.c</span>
<span class="p_header">+++ b/net/ipv4/fib_trie.c</span>
<span class="p_chunk">@@ -2453,9 +2453,7 @@</span> <span class="p_context"> struct fib_route_iter {</span>
 static struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,
 					    loff_t pos)
 {
<span class="p_del">-	struct fib_table *tb = iter-&gt;main_tb;</span>
 	struct key_vector *l, **tp = &amp;iter-&gt;tnode;
<span class="p_del">-	struct trie *t;</span>
 	t_key key;
 
 	/* use cache location of next-to-find key */
<span class="p_chunk">@@ -2463,8 +2461,6 @@</span> <span class="p_context"> static struct key_vector *fib_route_get_idx(struct fib_route_iter *iter,</span>
 		pos -= iter-&gt;pos;
 		key = iter-&gt;key;
 	} else {
<span class="p_del">-		t = (struct trie *)tb-&gt;tb_data;</span>
<span class="p_del">-		iter-&gt;tnode = t-&gt;kv;</span>
 		iter-&gt;pos = 0;
 		key = 0;
 	}
<span class="p_chunk">@@ -2505,12 +2501,12 @@</span> <span class="p_context"> static void *fib_route_seq_start(struct seq_file *seq, loff_t *pos)</span>
 		return NULL;
 
 	iter-&gt;main_tb = tb;
<span class="p_add">+	t = (struct trie *)tb-&gt;tb_data;</span>
<span class="p_add">+	iter-&gt;tnode = t-&gt;kv;</span>
 
 	if (*pos != 0)
 		return fib_route_get_idx(iter, *pos);
 
<span class="p_del">-	t = (struct trie *)tb-&gt;tb_data;</span>
<span class="p_del">-	iter-&gt;tnode = t-&gt;kv;</span>
 	iter-&gt;pos = 0;
 	iter-&gt;key = 0;
 
<span class="p_header">diff --git a/net/ipv4/ip_vti.c b/net/ipv4/ip_vti.c</span>
<span class="p_header">index 4d8f0b698777..65036891e080 100644</span>
<span class="p_header">--- a/net/ipv4/ip_vti.c</span>
<span class="p_header">+++ b/net/ipv4/ip_vti.c</span>
<span class="p_chunk">@@ -540,6 +540,33 @@</span> <span class="p_context"> static struct rtnl_link_ops vti_link_ops __read_mostly = {</span>
 	.get_link_net	= ip_tunnel_get_link_net,
 };
 
<span class="p_add">+static bool is_vti_tunnel(const struct net_device *dev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return dev-&gt;netdev_ops == &amp;vti_netdev_ops;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int vti_device_event(struct notifier_block *unused,</span>
<span class="p_add">+			    unsigned long event, void *ptr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct net_device *dev = netdev_notifier_info_to_dev(ptr);</span>
<span class="p_add">+	struct ip_tunnel *tunnel = netdev_priv(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!is_vti_tunnel(dev))</span>
<span class="p_add">+		return NOTIFY_DONE;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (event) {</span>
<span class="p_add">+	case NETDEV_DOWN:</span>
<span class="p_add">+		if (!net_eq(tunnel-&gt;net, dev_net(dev)))</span>
<span class="p_add">+			xfrm_garbage_collect(tunnel-&gt;net);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return NOTIFY_DONE;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static struct notifier_block vti_notifier_block __read_mostly = {</span>
<span class="p_add">+	.notifier_call = vti_device_event,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int __init vti_init(void)
 {
 	const char *msg;
<span class="p_chunk">@@ -547,6 +574,8 @@</span> <span class="p_context"> static int __init vti_init(void)</span>
 
 	pr_info(&quot;IPv4 over IPsec tunneling driver\n&quot;);
 
<span class="p_add">+	register_netdevice_notifier(&amp;vti_notifier_block);</span>
<span class="p_add">+</span>
 	msg = &quot;tunnel device&quot;;
 	err = register_pernet_device(&amp;vti_net_ops);
 	if (err &lt; 0)
<span class="p_chunk">@@ -579,6 +608,7 @@</span> <span class="p_context"> xfrm_proto_ah_failed:</span>
 xfrm_proto_esp_failed:
 	unregister_pernet_device(&amp;vti_net_ops);
 pernet_dev_failed:
<span class="p_add">+	unregister_netdevice_notifier(&amp;vti_notifier_block);</span>
 	pr_err(&quot;vti init: failed to register %s\n&quot;, msg);
 	return err;
 }
<span class="p_chunk">@@ -590,6 +620,7 @@</span> <span class="p_context"> static void __exit vti_fini(void)</span>
 	xfrm4_protocol_deregister(&amp;vti_ah4_protocol, IPPROTO_AH);
 	xfrm4_protocol_deregister(&amp;vti_esp4_protocol, IPPROTO_ESP);
 	unregister_pernet_device(&amp;vti_net_ops);
<span class="p_add">+	unregister_netdevice_notifier(&amp;vti_notifier_block);</span>
 }
 
 module_init(vti_init);
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index 048418b049d8..b5853cac3269 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -808,8 +808,14 @@</span> <span class="p_context"> static void tcp_v4_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,</span>
 	u32 seq = (sk-&gt;sk_state == TCP_LISTEN) ? tcp_rsk(req)-&gt;snt_isn + 1 :
 					     tcp_sk(sk)-&gt;snd_nxt;
 
<span class="p_add">+	/* RFC 7323 2.3</span>
<span class="p_add">+	 * The window field (SEG.WND) of every outgoing segment, with the</span>
<span class="p_add">+	 * exception of &lt;SYN&gt; segments, MUST be right-shifted by</span>
<span class="p_add">+	 * Rcv.Wind.Shift bits:</span>
<span class="p_add">+	 */</span>
 	tcp_v4_send_ack(sock_net(sk), skb, seq,
<span class="p_del">-			tcp_rsk(req)-&gt;rcv_nxt, req-&gt;rsk_rcv_wnd,</span>
<span class="p_add">+			tcp_rsk(req)-&gt;rcv_nxt,</span>
<span class="p_add">+			req-&gt;rsk_rcv_wnd &gt;&gt; inet_rsk(req)-&gt;rcv_wscale,</span>
 			tcp_time_stamp,
 			req-&gt;ts_recent,
 			0,
<span class="p_header">diff --git a/net/ipv4/tcp_yeah.c b/net/ipv4/tcp_yeah.c</span>
<span class="p_header">index 3e6a472e6b88..92ab5bc91592 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_yeah.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_yeah.c</span>
<span class="p_chunk">@@ -75,7 +75,7 @@</span> <span class="p_context"> static void tcp_yeah_cong_avoid(struct sock *sk, u32 ack, u32 acked)</span>
 	if (!tcp_is_cwnd_limited(sk))
 		return;
 
<span class="p_del">-	if (tp-&gt;snd_cwnd &lt;= tp-&gt;snd_ssthresh)</span>
<span class="p_add">+	if (tcp_in_slow_start(tp))</span>
 		tcp_slow_start(tp, acked);
 
 	else if (!yeah-&gt;doing_reno_now) {
<span class="p_header">diff --git a/net/ipv6/ping.c b/net/ipv6/ping.c</span>
<span class="p_header">index 263a5164a6f5..3e55447b63a4 100644</span>
<span class="p_header">--- a/net/ipv6/ping.c</span>
<span class="p_header">+++ b/net/ipv6/ping.c</span>
<span class="p_chunk">@@ -150,8 +150,10 @@</span> <span class="p_context"> int ping_v6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 	rt = (struct rt6_info *) dst;
 
 	np = inet6_sk(sk);
<span class="p_del">-	if (!np)</span>
<span class="p_del">-		return -EBADF;</span>
<span class="p_add">+	if (!np) {</span>
<span class="p_add">+		err = -EBADF;</span>
<span class="p_add">+		goto dst_err_out;</span>
<span class="p_add">+	}</span>
 
 	if (!fl6.flowi6_oif &amp;&amp; ipv6_addr_is_multicast(&amp;fl6.daddr))
 		fl6.flowi6_oif = np-&gt;mcast_oif;
<span class="p_chunk">@@ -186,6 +188,9 @@</span> <span class="p_context"> int ping_v6_sendmsg(struct sock *sk, struct msghdr *msg, size_t len)</span>
 	}
 	release_sock(sk);
 
<span class="p_add">+dst_err_out:</span>
<span class="p_add">+	dst_release(dst);</span>
<span class="p_add">+</span>
 	if (err)
 		return err;
 
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 1a1cd3938fd0..2d81e2f33ef2 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -932,9 +932,15 @@</span> <span class="p_context"> static void tcp_v6_reqsk_send_ack(const struct sock *sk, struct sk_buff *skb,</span>
 	/* sk-&gt;sk_state == TCP_LISTEN -&gt; for regular TCP_SYN_RECV
 	 * sk-&gt;sk_state == TCP_SYN_RECV -&gt; for Fast Open.
 	 */
<span class="p_add">+	/* RFC 7323 2.3</span>
<span class="p_add">+	 * The window field (SEG.WND) of every outgoing segment, with the</span>
<span class="p_add">+	 * exception of &lt;SYN&gt; segments, MUST be right-shifted by</span>
<span class="p_add">+	 * Rcv.Wind.Shift bits:</span>
<span class="p_add">+	 */</span>
 	tcp_v6_send_ack(sk, skb, (sk-&gt;sk_state == TCP_LISTEN) ?
 			tcp_rsk(req)-&gt;snt_isn + 1 : tcp_sk(sk)-&gt;snd_nxt,
<span class="p_del">-			tcp_rsk(req)-&gt;rcv_nxt, req-&gt;rsk_rcv_wnd,</span>
<span class="p_add">+			tcp_rsk(req)-&gt;rcv_nxt,</span>
<span class="p_add">+			req-&gt;rsk_rcv_wnd &gt;&gt; inet_rsk(req)-&gt;rcv_wscale,</span>
 			tcp_time_stamp, req-&gt;ts_recent, sk-&gt;sk_bound_dev_if,
 			tcp_v6_md5_do_lookup(sk, &amp;ipv6_hdr(skb)-&gt;daddr),
 			0, 0);
<span class="p_header">diff --git a/net/irda/iriap.c b/net/irda/iriap.c</span>
<span class="p_header">index 4a7ae32afa09..1138eaf5c682 100644</span>
<span class="p_header">--- a/net/irda/iriap.c</span>
<span class="p_header">+++ b/net/irda/iriap.c</span>
<span class="p_chunk">@@ -185,8 +185,12 @@</span> <span class="p_context"> struct iriap_cb *iriap_open(__u8 slsap_sel, int mode, void *priv,</span>
 
 	self-&gt;magic = IAS_MAGIC;
 	self-&gt;mode = mode;
<span class="p_del">-	if (mode == IAS_CLIENT)</span>
<span class="p_del">-		iriap_register_lsap(self, slsap_sel, mode);</span>
<span class="p_add">+	if (mode == IAS_CLIENT) {</span>
<span class="p_add">+		if (iriap_register_lsap(self, slsap_sel, mode)) {</span>
<span class="p_add">+			kfree(self);</span>
<span class="p_add">+			return NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
 	self-&gt;confirm = callback;
 	self-&gt;priv = priv;
<span class="p_header">diff --git a/net/tipc/socket.c b/net/tipc/socket.c</span>
<span class="p_header">index 9b713e0ce00d..b26b7a127773 100644</span>
<span class="p_header">--- a/net/tipc/socket.c</span>
<span class="p_header">+++ b/net/tipc/socket.c</span>
<span class="p_chunk">@@ -2111,7 +2111,8 @@</span> <span class="p_context"> restart:</span>
 					      TIPC_CONN_MSG, SHORT_H_SIZE,
 					      0, dnode, onode, dport, oport,
 					      TIPC_CONN_SHUTDOWN);
<span class="p_del">-			tipc_node_xmit_skb(net, skb, dnode, tsk-&gt;portid);</span>
<span class="p_add">+			if (skb)</span>
<span class="p_add">+				tipc_node_xmit_skb(net, skb, dnode, tsk-&gt;portid);</span>
 		}
 		tsk-&gt;connected = 0;
 		sock-&gt;state = SS_DISCONNECTING;
<span class="p_header">diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c</span>
<span class="p_header">index 6579fd6e7459..824cc1e160bc 100644</span>
<span class="p_header">--- a/net/unix/af_unix.c</span>
<span class="p_header">+++ b/net/unix/af_unix.c</span>
<span class="p_chunk">@@ -661,11 +661,11 @@</span> <span class="p_context"> static int unix_set_peek_off(struct sock *sk, int val)</span>
 {
 	struct unix_sock *u = unix_sk(sk);
 
<span class="p_del">-	if (mutex_lock_interruptible(&amp;u-&gt;readlock))</span>
<span class="p_add">+	if (mutex_lock_interruptible(&amp;u-&gt;iolock))</span>
 		return -EINTR;
 
 	sk-&gt;sk_peek_off = val;
<span class="p_del">-	mutex_unlock(&amp;u-&gt;readlock);</span>
<span class="p_add">+	mutex_unlock(&amp;u-&gt;iolock);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -778,7 +778,8 @@</span> <span class="p_context"> static struct sock *unix_create1(struct net *net, struct socket *sock, int kern)</span>
 	spin_lock_init(&amp;u-&gt;lock);
 	atomic_long_set(&amp;u-&gt;inflight, 0);
 	INIT_LIST_HEAD(&amp;u-&gt;link);
<span class="p_del">-	mutex_init(&amp;u-&gt;readlock); /* single task reading lock */</span>
<span class="p_add">+	mutex_init(&amp;u-&gt;iolock); /* single task reading lock */</span>
<span class="p_add">+	mutex_init(&amp;u-&gt;bindlock); /* single task binding lock */</span>
 	init_waitqueue_head(&amp;u-&gt;peer_wait);
 	init_waitqueue_func_entry(&amp;u-&gt;peer_wake, unix_dgram_peer_wake_relay);
 	unix_insert_socket(unix_sockets_unbound(sk), sk);
<span class="p_chunk">@@ -847,7 +848,7 @@</span> <span class="p_context"> static int unix_autobind(struct socket *sock)</span>
 	int err;
 	unsigned int retries = 0;
 
<span class="p_del">-	err = mutex_lock_interruptible(&amp;u-&gt;readlock);</span>
<span class="p_add">+	err = mutex_lock_interruptible(&amp;u-&gt;bindlock);</span>
 	if (err)
 		return err;
 
<span class="p_chunk">@@ -894,7 +895,7 @@</span> <span class="p_context"> retry:</span>
 	spin_unlock(&amp;unix_table_lock);
 	err = 0;
 
<span class="p_del">-out:	mutex_unlock(&amp;u-&gt;readlock);</span>
<span class="p_add">+out:	mutex_unlock(&amp;u-&gt;bindlock);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -953,20 +954,32 @@</span> <span class="p_context"> fail:</span>
 	return NULL;
 }
 
<span class="p_del">-static int unix_mknod(struct dentry *dentry, struct path *path, umode_t mode,</span>
<span class="p_del">-		      struct path *res)</span>
<span class="p_add">+static int unix_mknod(const char *sun_path, umode_t mode, struct path *res)</span>
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	struct dentry *dentry;</span>
<span class="p_add">+	struct path path;</span>
<span class="p_add">+	int err = 0;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Get the parent directory, calculate the hash for last</span>
<span class="p_add">+	 * component.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	dentry = kern_path_create(AT_FDCWD, sun_path, &amp;path, 0);</span>
<span class="p_add">+	err = PTR_ERR(dentry);</span>
<span class="p_add">+	if (IS_ERR(dentry))</span>
<span class="p_add">+		return err;</span>
 
<span class="p_del">-	err = security_path_mknod(path, dentry, mode, 0);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * All right, let&#39;s create it.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	err = security_path_mknod(&amp;path, dentry, mode, 0);</span>
 	if (!err) {
<span class="p_del">-		err = vfs_mknod(d_inode(path-&gt;dentry), dentry, mode, 0);</span>
<span class="p_add">+		err = vfs_mknod(d_inode(path.dentry), dentry, mode, 0);</span>
 		if (!err) {
<span class="p_del">-			res-&gt;mnt = mntget(path-&gt;mnt);</span>
<span class="p_add">+			res-&gt;mnt = mntget(path.mnt);</span>
 			res-&gt;dentry = dget(dentry);
 		}
 	}
<span class="p_del">-</span>
<span class="p_add">+	done_path_create(&amp;path, dentry);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -977,12 +990,10 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	struct unix_sock *u = unix_sk(sk);
 	struct sockaddr_un *sunaddr = (struct sockaddr_un *)uaddr;
 	char *sun_path = sunaddr-&gt;sun_path;
<span class="p_del">-	int err, name_err;</span>
<span class="p_add">+	int err;</span>
 	unsigned int hash;
 	struct unix_address *addr;
 	struct hlist_head *list;
<span class="p_del">-	struct path path;</span>
<span class="p_del">-	struct dentry *dentry;</span>
 
 	err = -EINVAL;
 	if (sunaddr-&gt;sun_family != AF_UNIX)
<span class="p_chunk">@@ -998,34 +1009,14 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 		goto out;
 	addr_len = err;
 
<span class="p_del">-	name_err = 0;</span>
<span class="p_del">-	dentry = NULL;</span>
<span class="p_del">-	if (sun_path[0]) {</span>
<span class="p_del">-		/* Get the parent directory, calculate the hash for last</span>
<span class="p_del">-		 * component.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		dentry = kern_path_create(AT_FDCWD, sun_path, &amp;path, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (IS_ERR(dentry)) {</span>
<span class="p_del">-			/* delay report until after &#39;already bound&#39; check */</span>
<span class="p_del">-			name_err = PTR_ERR(dentry);</span>
<span class="p_del">-			dentry = NULL;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	err = mutex_lock_interruptible(&amp;u-&gt;readlock);</span>
<span class="p_add">+	err = mutex_lock_interruptible(&amp;u-&gt;bindlock);</span>
 	if (err)
<span class="p_del">-		goto out_path;</span>
<span class="p_add">+		goto out;</span>
 
 	err = -EINVAL;
 	if (u-&gt;addr)
 		goto out_up;
 
<span class="p_del">-	if (name_err) {</span>
<span class="p_del">-		err = name_err == -EEXIST ? -EADDRINUSE : name_err;</span>
<span class="p_del">-		goto out_up;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	err = -ENOMEM;
 	addr = kmalloc(sizeof(*addr)+addr_len, GFP_KERNEL);
 	if (!addr)
<span class="p_chunk">@@ -1036,11 +1027,11 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 	addr-&gt;hash = hash ^ sk-&gt;sk_type;
 	atomic_set(&amp;addr-&gt;refcnt, 1);
 
<span class="p_del">-	if (dentry) {</span>
<span class="p_del">-		struct path u_path;</span>
<span class="p_add">+	if (sun_path[0]) {</span>
<span class="p_add">+		struct path path;</span>
 		umode_t mode = S_IFSOCK |
 		       (SOCK_INODE(sock)-&gt;i_mode &amp; ~current_umask());
<span class="p_del">-		err = unix_mknod(dentry, &amp;path, mode, &amp;u_path);</span>
<span class="p_add">+		err = unix_mknod(sun_path, mode, &amp;path);</span>
 		if (err) {
 			if (err == -EEXIST)
 				err = -EADDRINUSE;
<span class="p_chunk">@@ -1048,9 +1039,9 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 			goto out_up;
 		}
 		addr-&gt;hash = UNIX_HASH_SIZE;
<span class="p_del">-		hash = d_real_inode(dentry)-&gt;i_ino &amp; (UNIX_HASH_SIZE - 1);</span>
<span class="p_add">+		hash = d_real_inode(path.dentry)-&gt;i_ino &amp; (UNIX_HASH_SIZE - 1);</span>
 		spin_lock(&amp;unix_table_lock);
<span class="p_del">-		u-&gt;path = u_path;</span>
<span class="p_add">+		u-&gt;path = path;</span>
 		list = &amp;unix_socket_table[hash];
 	} else {
 		spin_lock(&amp;unix_table_lock);
<span class="p_chunk">@@ -1072,11 +1063,7 @@</span> <span class="p_context"> static int unix_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)</span>
 out_unlock:
 	spin_unlock(&amp;unix_table_lock);
 out_up:
<span class="p_del">-	mutex_unlock(&amp;u-&gt;readlock);</span>
<span class="p_del">-out_path:</span>
<span class="p_del">-	if (dentry)</span>
<span class="p_del">-		done_path_create(&amp;path, dentry);</span>
<span class="p_del">-</span>
<span class="p_add">+	mutex_unlock(&amp;u-&gt;bindlock);</span>
 out:
 	return err;
 }
<span class="p_chunk">@@ -1971,17 +1958,17 @@</span> <span class="p_context"> static ssize_t unix_stream_sendpage(struct socket *socket, struct page *page,</span>
 	if (false) {
 alloc_skb:
 		unix_state_unlock(other);
<span class="p_del">-		mutex_unlock(&amp;unix_sk(other)-&gt;readlock);</span>
<span class="p_add">+		mutex_unlock(&amp;unix_sk(other)-&gt;iolock);</span>
 		newskb = sock_alloc_send_pskb(sk, 0, 0, flags &amp; MSG_DONTWAIT,
 					      &amp;err, 0);
 		if (!newskb)
 			goto err;
 	}
 
<span class="p_del">-	/* we must acquire readlock as we modify already present</span>
<span class="p_add">+	/* we must acquire iolock as we modify already present</span>
 	 * skbs in the sk_receive_queue and mess with skb-&gt;len
 	 */
<span class="p_del">-	err = mutex_lock_interruptible(&amp;unix_sk(other)-&gt;readlock);</span>
<span class="p_add">+	err = mutex_lock_interruptible(&amp;unix_sk(other)-&gt;iolock);</span>
 	if (err) {
 		err = flags &amp; MSG_DONTWAIT ? -EAGAIN : -ERESTARTSYS;
 		goto err;
<span class="p_chunk">@@ -2048,7 +2035,7 @@</span> <span class="p_context"> alloc_skb:</span>
 	}
 
 	unix_state_unlock(other);
<span class="p_del">-	mutex_unlock(&amp;unix_sk(other)-&gt;readlock);</span>
<span class="p_add">+	mutex_unlock(&amp;unix_sk(other)-&gt;iolock);</span>
 
 	other-&gt;sk_data_ready(other);
 	scm_destroy(&amp;scm);
<span class="p_chunk">@@ -2057,7 +2044,7 @@</span> <span class="p_context"> alloc_skb:</span>
 err_state_unlock:
 	unix_state_unlock(other);
 err_unlock:
<span class="p_del">-	mutex_unlock(&amp;unix_sk(other)-&gt;readlock);</span>
<span class="p_add">+	mutex_unlock(&amp;unix_sk(other)-&gt;iolock);</span>
 err:
 	kfree_skb(newskb);
 	if (send_sigpipe &amp;&amp; !(flags &amp; MSG_NOSIGNAL))
<span class="p_chunk">@@ -2122,7 +2109,7 @@</span> <span class="p_context"> static int unix_dgram_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 	if (flags&amp;MSG_OOB)
 		goto out;
 
<span class="p_del">-	err = mutex_lock_interruptible(&amp;u-&gt;readlock);</span>
<span class="p_add">+	err = mutex_lock_interruptible(&amp;u-&gt;iolock);</span>
 	if (unlikely(err)) {
 		/* recvmsg() in non blocking mode is supposed to return -EAGAIN
 		 * sk_rcvtimeo is not honored by mutex_lock_interruptible()
<span class="p_chunk">@@ -2198,7 +2185,7 @@</span> <span class="p_context"> static int unix_dgram_recvmsg(struct socket *sock, struct msghdr *msg,</span>
 out_free:
 	skb_free_datagram(sk, skb);
 out_unlock:
<span class="p_del">-	mutex_unlock(&amp;u-&gt;readlock);</span>
<span class="p_add">+	mutex_unlock(&amp;u-&gt;iolock);</span>
 out:
 	return err;
 }
<span class="p_chunk">@@ -2293,7 +2280,7 @@</span> <span class="p_context"> static int unix_stream_read_generic(struct unix_stream_read_state *state)</span>
 	/* Lock the socket to prevent queue disordering
 	 * while sleeps in memcpy_tomsg
 	 */
<span class="p_del">-	mutex_lock(&amp;u-&gt;readlock);</span>
<span class="p_add">+	mutex_lock(&amp;u-&gt;iolock);</span>
 
 	if (flags &amp; MSG_PEEK)
 		skip = sk_peek_offset(sk, flags);
<span class="p_chunk">@@ -2334,7 +2321,7 @@</span> <span class="p_context"> again:</span>
 				break;
 			}
 
<span class="p_del">-			mutex_unlock(&amp;u-&gt;readlock);</span>
<span class="p_add">+			mutex_unlock(&amp;u-&gt;iolock);</span>
 
 			timeo = unix_stream_data_wait(sk, timeo, last,
 						      last_len);
<span class="p_chunk">@@ -2345,7 +2332,7 @@</span> <span class="p_context"> again:</span>
 				goto out;
 			}
 
<span class="p_del">-			mutex_lock(&amp;u-&gt;readlock);</span>
<span class="p_add">+			mutex_lock(&amp;u-&gt;iolock);</span>
 			continue;
 unlock:
 			unix_state_unlock(sk);
<span class="p_chunk">@@ -2448,7 +2435,7 @@</span> <span class="p_context"> unlock:</span>
 		}
 	} while (size);
 
<span class="p_del">-	mutex_unlock(&amp;u-&gt;readlock);</span>
<span class="p_add">+	mutex_unlock(&amp;u-&gt;iolock);</span>
 	if (state-&gt;msg)
 		scm_recv(sock, state-&gt;msg, &amp;scm, flags);
 	else
<span class="p_chunk">@@ -2489,9 +2476,9 @@</span> <span class="p_context"> static ssize_t skb_unix_socket_splice(struct sock *sk,</span>
 	int ret;
 	struct unix_sock *u = unix_sk(sk);
 
<span class="p_del">-	mutex_unlock(&amp;u-&gt;readlock);</span>
<span class="p_add">+	mutex_unlock(&amp;u-&gt;iolock);</span>
 	ret = splice_to_pipe(pipe, spd);
<span class="p_del">-	mutex_lock(&amp;u-&gt;readlock);</span>
<span class="p_add">+	mutex_lock(&amp;u-&gt;iolock);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/net/wireless/nl80211.c b/net/wireless/nl80211.c</span>
<span class="p_header">index 5d89f13a98db..bf65f31bd55e 100644</span>
<span class="p_header">--- a/net/wireless/nl80211.c</span>
<span class="p_header">+++ b/net/wireless/nl80211.c</span>
<span class="p_chunk">@@ -6628,7 +6628,7 @@</span> <span class="p_context"> static int nl80211_channel_switch(struct sk_buff *skb, struct genl_info *info)</span>
 
 		params.n_counter_offsets_presp = len / sizeof(u16);
 		if (rdev-&gt;wiphy.max_num_csa_counters &amp;&amp;
<span class="p_del">-		    (params.n_counter_offsets_beacon &gt;</span>
<span class="p_add">+		    (params.n_counter_offsets_presp &gt;</span>
 		     rdev-&gt;wiphy.max_num_csa_counters))
 			return -EINVAL;
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



