
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.4.108 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.4.108</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Dec. 25, 2017, 2:11 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171225141144.GB24312@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10132589/mbox/"
   >mbox</a>
|
   <a href="/patch/10132589/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10132589/">/patch/10132589/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	99411602BC for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 25 Dec 2017 14:12:44 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 7406F2EFBC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 25 Dec 2017 14:12:44 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 6871D2F0CF; Mon, 25 Dec 2017 14:12:44 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 375D12EFBC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Mon, 25 Dec 2017 14:12:40 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1753118AbdLYOMd (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Mon, 25 Dec 2017 09:12:33 -0500
Received: from mail.linuxfoundation.org ([140.211.169.12]:58818 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752806AbdLYOLn (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Mon, 25 Dec 2017 09:11:43 -0500
Received: from localhost (LFbn-1-12262-44.w90-92.abo.wanadoo.fr
	[90.92.75.44])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id B1953486;
	Mon, 25 Dec 2017 14:11:41 +0000 (UTC)
Date: Mon, 25 Dec 2017 15:11:44 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.4.108
Message-ID: &lt;20171225141144.GB24312@kroah.com&gt;
References: &lt;20171225141137.GA24312@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20171225141137.GA24312@kroah.com&gt;
User-Agent: Mutt/1.9.2 (2017-12-15)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Dec. 25, 2017, 2:11 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/kernel-parameters.txt b/Documentation/kernel-parameters.txt</span>
<span class="p_header">index 7c77d7edb851..5d593ecadb90 100644</span>
<span class="p_header">--- a/Documentation/kernel-parameters.txt</span>
<span class="p_header">+++ b/Documentation/kernel-parameters.txt</span>
<span class="p_chunk">@@ -2519,6 +2519,8 @@</span> <span class="p_context"> bytes respectively. Such letter suffixes can also be entirely omitted.</span>
 
 	nointroute	[IA-64]
 
<span class="p_add">+	noinvpcid	[X86] Disable the INVPCID cpu feature.</span>
<span class="p_add">+</span>
 	nojitter	[IA-64] Disables jitter checking for ITC timers.
 
 	no-kvmclock	[X86,KVM] Disable paravirtualized KVM clock driver
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index f7997b15d055..99f9834c4ba6 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 4
<span class="p_del">-SUBLEVEL = 107</span>
<span class="p_add">+SUBLEVEL = 108</span>
 EXTRAVERSION =
 NAME = Blurry Fish Butt
 
<span class="p_header">diff --git a/arch/alpha/include/asm/mmu_context.h b/arch/alpha/include/asm/mmu_context.h</span>
<span class="p_header">index 4c51c05333c6..4cafffa80e2c 100644</span>
<span class="p_header">--- a/arch/alpha/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/alpha/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
  * Copyright (C) 1996, Linus Torvalds
  */
 
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
 #include &lt;asm/machvec.h&gt;
 #include &lt;asm/compiler.h&gt;
 #include &lt;asm-generic/mm_hooks.h&gt;
<span class="p_header">diff --git a/arch/arm/boot/dts/am335x-evmsk.dts b/arch/arm/boot/dts/am335x-evmsk.dts</span>
<span class="p_header">index 89442e98a837..3af570517903 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/am335x-evmsk.dts</span>
<span class="p_header">+++ b/arch/arm/boot/dts/am335x-evmsk.dts</span>
<span class="p_chunk">@@ -668,6 +668,7 @@</span> <span class="p_context"></span>
 	ti,non-removable;
 	bus-width = &lt;4&gt;;
 	cap-power-off-card;
<span class="p_add">+	keep-power-in-suspend;</span>
 	pinctrl-names = &quot;default&quot;;
 	pinctrl-0 = &lt;&amp;mmc2_pins&gt;;
 
<span class="p_header">diff --git a/arch/arm/boot/dts/dra7.dtsi b/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_header">index c2a03c740e79..02bd6312d1d9 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/dra7.dtsi</span>
<span class="p_chunk">@@ -227,6 +227,7 @@</span> <span class="p_context"></span>
 				device_type = &quot;pci&quot;;
 				ranges = &lt;0x81000000 0 0          0x03000 0 0x00010000
 					  0x82000000 0 0x20013000 0x13000 0 0xffed000&gt;;
<span class="p_add">+				bus-range = &lt;0x00 0xff&gt;;</span>
 				#interrupt-cells = &lt;1&gt;;
 				num-lanes = &lt;1&gt;;
 				ti,hwmods = &quot;pcie1&quot;;
<span class="p_chunk">@@ -262,6 +263,7 @@</span> <span class="p_context"></span>
 				device_type = &quot;pci&quot;;
 				ranges = &lt;0x81000000 0 0          0x03000 0 0x00010000
 					  0x82000000 0 0x30013000 0x13000 0 0xffed000&gt;;
<span class="p_add">+				bus-range = &lt;0x00 0xff&gt;;</span>
 				#interrupt-cells = &lt;1&gt;;
 				num-lanes = &lt;1&gt;;
 				ti,hwmods = &quot;pcie2&quot;;
<span class="p_header">diff --git a/arch/arm/include/asm/mmu_context.h b/arch/arm/include/asm/mmu_context.h</span>
<span class="p_header">index 9b32f76bb0dd..10f662498eb7 100644</span>
<span class="p_header">--- a/arch/arm/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/arm/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"> static inline void check_and_switch_context(struct mm_struct *mm,</span>
 		cpu_switch_mm(mm-&gt;pgd, mm);
 }
 
<span class="p_add">+#ifndef MODULE</span>
 #define finish_arch_post_lock_switch \
 	finish_arch_post_lock_switch
 static inline void finish_arch_post_lock_switch(void)
<span class="p_chunk">@@ -82,6 +83,7 @@</span> <span class="p_context"> static inline void finish_arch_post_lock_switch(void)</span>
 		preempt_enable_no_resched();
 	}
 }
<span class="p_add">+#endif /* !MODULE */</span>
 
 #endif	/* CONFIG_MMU */
 
<span class="p_header">diff --git a/arch/arm/mm/dma-mapping.c b/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">index 534a60ae282e..613c1d06316a 100644</span>
<span class="p_header">--- a/arch/arm/mm/dma-mapping.c</span>
<span class="p_header">+++ b/arch/arm/mm/dma-mapping.c</span>
<span class="p_chunk">@@ -774,13 +774,31 @@</span> <span class="p_context"> static void arm_coherent_dma_free(struct device *dev, size_t size, void *cpu_add</span>
 	__arm_dma_free(dev, size, cpu_addr, handle, attrs, true);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * The whole dma_get_sgtable() idea is fundamentally unsafe - it seems</span>
<span class="p_add">+ * that the intention is to allow exporting memory allocated via the</span>
<span class="p_add">+ * coherent DMA APIs through the dma_buf API, which only accepts a</span>
<span class="p_add">+ * scattertable.  This presents a couple of problems:</span>
<span class="p_add">+ * 1. Not all memory allocated via the coherent DMA APIs is backed by</span>
<span class="p_add">+ *    a struct page</span>
<span class="p_add">+ * 2. Passing coherent DMA memory into the streaming APIs is not allowed</span>
<span class="p_add">+ *    as we will try to flush the memory through a different alias to that</span>
<span class="p_add">+ *    actually being used (and the flushes are redundant.)</span>
<span class="p_add">+ */</span>
 int arm_dma_get_sgtable(struct device *dev, struct sg_table *sgt,
 		 void *cpu_addr, dma_addr_t handle, size_t size,
 		 struct dma_attrs *attrs)
 {
<span class="p_del">-	struct page *page = pfn_to_page(dma_to_pfn(dev, handle));</span>
<span class="p_add">+	unsigned long pfn = dma_to_pfn(dev, handle);</span>
<span class="p_add">+	struct page *page;</span>
 	int ret;
 
<span class="p_add">+	/* If the PFN is not valid, we do not have a struct page */</span>
<span class="p_add">+	if (!pfn_valid(pfn))</span>
<span class="p_add">+		return -ENXIO;</span>
<span class="p_add">+</span>
<span class="p_add">+	page = pfn_to_page(pfn);</span>
<span class="p_add">+</span>
 	ret = sg_alloc_table(sgt, 1, GFP_KERNEL);
 	if (unlikely(ret))
 		return ret;
<span class="p_header">diff --git a/arch/arm/probes/kprobes/core.c b/arch/arm/probes/kprobes/core.c</span>
<span class="p_header">index a4ec240ee7ba..3eb018fa1a1f 100644</span>
<span class="p_header">--- a/arch/arm/probes/kprobes/core.c</span>
<span class="p_header">+++ b/arch/arm/probes/kprobes/core.c</span>
<span class="p_chunk">@@ -433,6 +433,7 @@</span> <span class="p_context"> static __used __kprobes void *trampoline_handler(struct pt_regs *regs)</span>
 	struct hlist_node *tmp;
 	unsigned long flags, orig_ret_address = 0;
 	unsigned long trampoline_address = (unsigned long)&amp;kretprobe_trampoline;
<span class="p_add">+	kprobe_opcode_t *correct_ret_addr = NULL;</span>
 
 	INIT_HLIST_HEAD(&amp;empty_rp);
 	kretprobe_hash_lock(current, &amp;head, &amp;flags);
<span class="p_chunk">@@ -455,14 +456,34 @@</span> <span class="p_context"> static __used __kprobes void *trampoline_handler(struct pt_regs *regs)</span>
 			/* another task is sharing our hash bucket */
 			continue;
 
<span class="p_add">+		orig_ret_address = (unsigned long)ri-&gt;ret_addr;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (orig_ret_address != trampoline_address)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * This is the real return address. Any other</span>
<span class="p_add">+			 * instances associated with this task are for</span>
<span class="p_add">+			 * other calls deeper on the call stack</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	kretprobe_assert(ri, orig_ret_address, trampoline_address);</span>
<span class="p_add">+</span>
<span class="p_add">+	correct_ret_addr = ri-&gt;ret_addr;</span>
<span class="p_add">+	hlist_for_each_entry_safe(ri, tmp, head, hlist) {</span>
<span class="p_add">+		if (ri-&gt;task != current)</span>
<span class="p_add">+			/* another task is sharing our hash bucket */</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		orig_ret_address = (unsigned long)ri-&gt;ret_addr;</span>
 		if (ri-&gt;rp &amp;&amp; ri-&gt;rp-&gt;handler) {
 			__this_cpu_write(current_kprobe, &amp;ri-&gt;rp-&gt;kp);
 			get_kprobe_ctlblk()-&gt;kprobe_status = KPROBE_HIT_ACTIVE;
<span class="p_add">+			ri-&gt;ret_addr = correct_ret_addr;</span>
 			ri-&gt;rp-&gt;handler(ri, regs);
 			__this_cpu_write(current_kprobe, NULL);
 		}
 
<span class="p_del">-		orig_ret_address = (unsigned long)ri-&gt;ret_addr;</span>
 		recycle_rp_inst(ri, &amp;empty_rp);
 
 		if (orig_ret_address != trampoline_address)
<span class="p_chunk">@@ -474,7 +495,6 @@</span> <span class="p_context"> static __used __kprobes void *trampoline_handler(struct pt_regs *regs)</span>
 			break;
 	}
 
<span class="p_del">-	kretprobe_assert(ri, orig_ret_address, trampoline_address);</span>
 	kretprobe_hash_unlock(current, &amp;flags);
 
 	hlist_for_each_entry_safe(ri, tmp, &amp;empty_rp, hlist) {
<span class="p_header">diff --git a/arch/arm/probes/kprobes/test-core.c b/arch/arm/probes/kprobes/test-core.c</span>
<span class="p_header">index 9775de22e2ff..a48354de1aa1 100644</span>
<span class="p_header">--- a/arch/arm/probes/kprobes/test-core.c</span>
<span class="p_header">+++ b/arch/arm/probes/kprobes/test-core.c</span>
<span class="p_chunk">@@ -976,7 +976,10 @@</span> <span class="p_context"> static void coverage_end(void)</span>
 void __naked __kprobes_test_case_start(void)
 {
 	__asm__ __volatile__ (
<span class="p_del">-		&quot;stmdb	sp!, {r4-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	r2, sp					\n\t&quot;</span>
<span class="p_add">+		&quot;bic	r3, r2, #7				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	sp, r3					\n\t&quot;</span>
<span class="p_add">+		&quot;stmdb	sp!, {r2-r11}				\n\t&quot;</span>
 		&quot;sub	sp, sp, #&quot;__stringify(TEST_MEMORY_SIZE)&quot;\n\t&quot;
 		&quot;bic	r0, lr, #1  @ r0 = inline data		\n\t&quot;
 		&quot;mov	r1, sp					\n\t&quot;
<span class="p_chunk">@@ -996,7 +999,8 @@</span> <span class="p_context"> void __naked __kprobes_test_case_end_32(void)</span>
 		&quot;movne	pc, r0					\n\t&quot;
 		&quot;mov	r0, r4					\n\t&quot;
 		&quot;add	sp, sp, #&quot;__stringify(TEST_MEMORY_SIZE)&quot;\n\t&quot;
<span class="p_del">-		&quot;ldmia	sp!, {r4-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;ldmia	sp!, {r2-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	sp, r2					\n\t&quot;</span>
 		&quot;mov	pc, r0					\n\t&quot;
 	);
 }
<span class="p_chunk">@@ -1012,7 +1016,8 @@</span> <span class="p_context"> void __naked __kprobes_test_case_end_16(void)</span>
 		&quot;bxne	r0					\n\t&quot;
 		&quot;mov	r0, r4					\n\t&quot;
 		&quot;add	sp, sp, #&quot;__stringify(TEST_MEMORY_SIZE)&quot;\n\t&quot;
<span class="p_del">-		&quot;ldmia	sp!, {r4-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;ldmia	sp!, {r2-r11}				\n\t&quot;</span>
<span class="p_add">+		&quot;mov	sp, r2					\n\t&quot;</span>
 		&quot;bx	r0					\n\t&quot;
 	);
 }
<span class="p_header">diff --git a/arch/arm64/mm/init.c b/arch/arm64/mm/init.c</span>
<span class="p_header">index 4cb98aa8c27b..efd89ce4533d 100644</span>
<span class="p_header">--- a/arch/arm64/mm/init.c</span>
<span class="p_header">+++ b/arch/arm64/mm/init.c</span>
<span class="p_chunk">@@ -178,6 +178,7 @@</span> <span class="p_context"> void __init arm64_memblock_init(void)</span>
 		arm64_dma_phys_limit = max_zone_dma_phys();
 	else
 		arm64_dma_phys_limit = PHYS_MASK + 1;
<span class="p_add">+	high_memory = __va(memblock_end_of_DRAM() - 1) + 1;</span>
 	dma_contiguous_reserve(arm64_dma_phys_limit);
 
 	memblock_allow_resize();
<span class="p_chunk">@@ -202,7 +203,6 @@</span> <span class="p_context"> void __init bootmem_init(void)</span>
 	sparse_init();
 	zone_sizes_init(min, max);
 
<span class="p_del">-	high_memory = __va((max &lt;&lt; PAGE_SHIFT) - 1) + 1;</span>
 	max_pfn = max_low_pfn = max;
 }
 
<span class="p_header">diff --git a/arch/mips/math-emu/cp1emu.c b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">index dd058aa8a3b5..89d05de8040a 100644</span>
<span class="p_header">--- a/arch/mips/math-emu/cp1emu.c</span>
<span class="p_header">+++ b/arch/mips/math-emu/cp1emu.c</span>
<span class="p_chunk">@@ -1777,7 +1777,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			SPFROMREG(fd, MIPSInst_FD(ir));
 			rv.s = ieee754sp_maddf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmsubf_op: {
<span class="p_chunk">@@ -1790,7 +1790,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			SPFROMREG(fd, MIPSInst_FD(ir));
 			rv.s = ieee754sp_msubf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case frint_op: {
<span class="p_chunk">@@ -1814,7 +1814,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.w = ieee754sp_2008class(fs);
 			rfmt = w_fmt;
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmin_op: {
<span class="p_chunk">@@ -1826,7 +1826,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmin(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmina_op: {
<span class="p_chunk">@@ -1838,7 +1838,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmina(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmax_op: {
<span class="p_chunk">@@ -1850,7 +1850,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmax(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmaxa_op: {
<span class="p_chunk">@@ -1862,7 +1862,7 @@</span> <span class="p_context"> static int fpu_emu(struct pt_regs *xcp, struct mips_fpu_struct *ctx,</span>
 			SPFROMREG(ft, MIPSInst_FT(ir));
 			SPFROMREG(fs, MIPSInst_FS(ir));
 			rv.s = ieee754sp_fmaxa(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fabs_op:
<span class="p_chunk">@@ -2095,7 +2095,7 @@</span> <span class="p_context"> copcsr:</span>
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			DPFROMREG(fd, MIPSInst_FD(ir));
 			rv.d = ieee754dp_maddf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmsubf_op: {
<span class="p_chunk">@@ -2108,7 +2108,7 @@</span> <span class="p_context"> copcsr:</span>
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			DPFROMREG(fd, MIPSInst_FD(ir));
 			rv.d = ieee754dp_msubf(fd, fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case frint_op: {
<span class="p_chunk">@@ -2132,7 +2132,7 @@</span> <span class="p_context"> copcsr:</span>
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.w = ieee754dp_2008class(fs);
 			rfmt = w_fmt;
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmin_op: {
<span class="p_chunk">@@ -2144,7 +2144,7 @@</span> <span class="p_context"> copcsr:</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmin(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmina_op: {
<span class="p_chunk">@@ -2156,7 +2156,7 @@</span> <span class="p_context"> copcsr:</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmina(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmax_op: {
<span class="p_chunk">@@ -2168,7 +2168,7 @@</span> <span class="p_context"> copcsr:</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmax(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fmaxa_op: {
<span class="p_chunk">@@ -2180,7 +2180,7 @@</span> <span class="p_context"> copcsr:</span>
 			DPFROMREG(ft, MIPSInst_FT(ir));
 			DPFROMREG(fs, MIPSInst_FS(ir));
 			rv.d = ieee754dp_fmaxa(fs, ft);
<span class="p_del">-			break;</span>
<span class="p_add">+			goto copcsr;</span>
 		}
 
 		case fabs_op:
<span class="p_header">diff --git a/arch/x86/include/asm/hardirq.h b/arch/x86/include/asm/hardirq.h</span>
<span class="p_header">index 7178043b0e1d..59405a248fc2 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hardirq.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hardirq.h</span>
<span class="p_chunk">@@ -22,10 +22,6 @@</span> <span class="p_context"> typedef struct {</span>
 #ifdef CONFIG_SMP
 	unsigned int irq_resched_count;
 	unsigned int irq_call_count;
<span class="p_del">-	/*</span>
<span class="p_del">-	 * irq_tlb_count is double-counted in irq_call_count, so it must be</span>
<span class="p_del">-	 * subtracted from irq_call_count when displaying irq_call_count</span>
<span class="p_del">-	 */</span>
 	unsigned int irq_tlb_count;
 #endif
 #ifdef CONFIG_X86_THERMAL_VECTOR
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index bfd9b2a35a0b..44fc93987869 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -104,103 +104,12 @@</span> <span class="p_context"> static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)</span>
 #endif
 }
 
<span class="p_del">-static inline void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
<span class="p_del">-			     struct task_struct *tsk)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned cpu = smp_processor_id();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (likely(prev != next)) {</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);</span>
<span class="p_del">-		this_cpu_write(cpu_tlbstate.active_mm, next);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-		cpumask_set_cpu(cpu, mm_cpumask(next));</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Re-load page tables.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * This logic has an ordering constraint:</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 *  CPU 0: Write to a PTE for &#39;next&#39;</span>
<span class="p_del">-		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.</span>
<span class="p_del">-		 *  CPU 1: set bit 1 in next&#39;s mm_cpumask</span>
<span class="p_del">-		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * We need to prevent an outcome in which CPU 1 observes</span>
<span class="p_del">-		 * the new PTE value and CPU 0 observes bit 1 clear in</span>
<span class="p_del">-		 * mm_cpumask.  (If that occurs, then the IPI will never</span>
<span class="p_del">-		 * be sent, and CPU 0&#39;s TLB will contain a stale entry.)</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * The bad outcome can occur if either CPU&#39;s load is</span>
<span class="p_del">-		 * reordered before that CPU&#39;s store, so both CPUs must</span>
<span class="p_del">-		 * execute full barriers to prevent this from happening.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * Thus, switch_mm needs a full barrier between the</span>
<span class="p_del">-		 * store to mm_cpumask and any operation that could load</span>
<span class="p_del">-		 * from next-&gt;pgd.  TLB fills are special and can happen</span>
<span class="p_del">-		 * due to instruction fetches or for no reason at all,</span>
<span class="p_del">-		 * and neither LOCK nor MFENCE orders them.</span>
<span class="p_del">-		 * Fortunately, load_cr3() is serializing and gives the</span>
<span class="p_del">-		 * ordering guarantee we need.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		load_cr3(next-&gt;pgd);</span>
<span class="p_del">-</span>
<span class="p_del">-		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Stop flush ipis for the previous mm */</span>
<span class="p_del">-		cpumask_clear_cpu(cpu, mm_cpumask(prev));</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Load per-mm CR4 state */</span>
<span class="p_del">-		load_mm_cr4(next);</span>
<span class="p_add">+extern void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
<span class="p_add">+		      struct task_struct *tsk);</span>
 
<span class="p_del">-#ifdef CONFIG_MODIFY_LDT_SYSCALL</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Load the LDT, if the LDT is different.</span>
<span class="p_del">-		 *</span>
<span class="p_del">-		 * It&#39;s possible that prev-&gt;context.ldt doesn&#39;t match</span>
<span class="p_del">-		 * the LDT register.  This can happen if leave_mm(prev)</span>
<span class="p_del">-		 * was called and then modify_ldt changed</span>
<span class="p_del">-		 * prev-&gt;context.ldt but suppressed an IPI to this CPU.</span>
<span class="p_del">-		 * In this case, prev-&gt;context.ldt != NULL, because we</span>
<span class="p_del">-		 * never set context.ldt to NULL while the mm still</span>
<span class="p_del">-		 * exists.  That means that next-&gt;context.ldt !=</span>
<span class="p_del">-		 * prev-&gt;context.ldt, because mms never share an LDT.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))</span>
<span class="p_del">-			load_mm_ldt(next);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-#ifdef CONFIG_SMP</span>
<span class="p_del">-	  else {</span>
<span class="p_del">-		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);</span>
<span class="p_del">-		BUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!cpumask_test_cpu(cpu, mm_cpumask(next))) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * On established mms, the mm_cpumask is only changed</span>
<span class="p_del">-			 * from irq context, from ptep_clear_flush() while in</span>
<span class="p_del">-			 * lazy tlb mode, and here. Irqs are blocked during</span>
<span class="p_del">-			 * schedule, protecting us from simultaneous changes.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			cpumask_set_cpu(cpu, mm_cpumask(next));</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We were in lazy tlb mode and leave_mm disabled</span>
<span class="p_del">-			 * tlb flush IPI delivery. We must reload CR3</span>
<span class="p_del">-			 * to make sure to use no freed page tables.</span>
<span class="p_del">-			 *</span>
<span class="p_del">-			 * As above, load_cr3() is serializing and orders TLB</span>
<span class="p_del">-			 * fills with respect to the mm_cpumask write.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			load_cr3(next-&gt;pgd);</span>
<span class="p_del">-			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);</span>
<span class="p_del">-			load_mm_cr4(next);</span>
<span class="p_del">-			load_mm_ldt(next);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_add">+extern void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
<span class="p_add">+			       struct task_struct *tsk);</span>
<span class="p_add">+#define switch_mm_irqs_off switch_mm_irqs_off</span>
 
 #define activate_mm(prev, next)			\
 do {						\
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 6433e28dc9c8..4dc534175b5e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -7,6 +7,54 @@</span> <span class="p_context"></span>
 #include &lt;asm/processor.h&gt;
 #include &lt;asm/special_insns.h&gt;
 
<span class="p_add">+static inline void __invpcid(unsigned long pcid, unsigned long addr,</span>
<span class="p_add">+			     unsigned long type)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct { u64 d[2]; } desc = { { pcid, addr } };</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The memory clobber is because the whole point is to invalidate</span>
<span class="p_add">+	 * stale TLB entries and, especially if we&#39;re flushing global</span>
<span class="p_add">+	 * mappings, we don&#39;t want the compiler to reorder any subsequent</span>
<span class="p_add">+	 * memory accesses before the TLB flush.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * The hex opcode is invpcid (%ecx), %eax in 32-bit mode and</span>
<span class="p_add">+	 * invpcid (%rcx), %rax in long mode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	asm volatile (&quot;.byte 0x66, 0x0f, 0x38, 0x82, 0x01&quot;</span>
<span class="p_add">+		      : : &quot;m&quot; (desc), &quot;a&quot; (type), &quot;c&quot; (&amp;desc) : &quot;memory&quot;);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define INVPCID_TYPE_INDIV_ADDR		0</span>
<span class="p_add">+#define INVPCID_TYPE_SINGLE_CTXT	1</span>
<span class="p_add">+#define INVPCID_TYPE_ALL_INCL_GLOBAL	2</span>
<span class="p_add">+#define INVPCID_TYPE_ALL_NON_GLOBAL	3</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings for a given pcid and addr, not including globals. */</span>
<span class="p_add">+static inline void invpcid_flush_one(unsigned long pcid,</span>
<span class="p_add">+				     unsigned long addr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(pcid, addr, INVPCID_TYPE_INDIV_ADDR);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings for a given PCID, not including globals. */</span>
<span class="p_add">+static inline void invpcid_flush_single_context(unsigned long pcid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(pcid, 0, INVPCID_TYPE_SINGLE_CTXT);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings, including globals, for all PCIDs. */</span>
<span class="p_add">+static inline void invpcid_flush_all(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(0, 0, INVPCID_TYPE_ALL_INCL_GLOBAL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Flush all mappings for all PCIDs except globals. */</span>
<span class="p_add">+static inline void invpcid_flush_all_nonglobals(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__invpcid(0, 0, INVPCID_TYPE_ALL_NON_GLOBAL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_PARAVIRT
 #include &lt;asm/paravirt.h&gt;
 #else
<span class="p_chunk">@@ -111,6 +159,15 @@</span> <span class="p_context"> static inline void __native_flush_tlb_global(void)</span>
 {
 	unsigned long flags;
 
<span class="p_add">+	if (static_cpu_has(X86_FEATURE_INVPCID)) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Using INVPCID is considerably faster than a pair of writes</span>
<span class="p_add">+		 * to CR4 sandwiched inside an IRQ flag save/restore.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		invpcid_flush_all();</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Read-modify-write to CR4 - protect it from preemption and
 	 * from interrupts. (Use the raw variant because this code can
<span class="p_chunk">@@ -268,12 +325,6 @@</span> <span class="p_context"> static inline void reset_lazy_tlbstate(void)</span>
 
 #endif	/* SMP */
 
<span class="p_del">-/* Not inlined due to inc_irq_stat not being defined yet */</span>
<span class="p_del">-#define flush_tlb_local() {		\</span>
<span class="p_del">-	inc_irq_stat(irq_tlb_count);	\</span>
<span class="p_del">-	local_flush_tlb();		\</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 #ifndef CONFIG_PARAVIRT
 #define flush_tlb_others(mask, mm, start, end)	\
 	native_flush_tlb_others(mask, mm, start, end)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 637ca414d431..c84b62956e8d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -162,6 +162,22 @@</span> <span class="p_context"> static int __init x86_mpx_setup(char *s)</span>
 }
 __setup(&quot;nompx&quot;, x86_mpx_setup);
 
<span class="p_add">+static int __init x86_noinvpcid_setup(char *s)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* noinvpcid doesn&#39;t accept parameters */</span>
<span class="p_add">+	if (s)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* do not emit a message if the feature is not present */</span>
<span class="p_add">+	if (!boot_cpu_has(X86_FEATURE_INVPCID))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	setup_clear_cpu_cap(X86_FEATURE_INVPCID);</span>
<span class="p_add">+	pr_info(&quot;noinvpcid: INVPCID feature disabled\n&quot;);</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+early_param(&quot;noinvpcid&quot;, x86_noinvpcid_setup);</span>
<span class="p_add">+</span>
 #ifdef CONFIG_X86_32
 static int cachesize_override = -1;
 static int disable_x86_serial_nr = 1;
<span class="p_header">diff --git a/arch/x86/kernel/irq.c b/arch/x86/kernel/irq.c</span>
<span class="p_header">index 61521dc19c10..9f669fdd2010 100644</span>
<span class="p_header">--- a/arch/x86/kernel/irq.c</span>
<span class="p_header">+++ b/arch/x86/kernel/irq.c</span>
<span class="p_chunk">@@ -102,8 +102,7 @@</span> <span class="p_context"> int arch_show_interrupts(struct seq_file *p, int prec)</span>
 	seq_puts(p, &quot;  Rescheduling interrupts\n&quot;);
 	seq_printf(p, &quot;%*s: &quot;, prec, &quot;CAL&quot;);
 	for_each_online_cpu(j)
<span class="p_del">-		seq_printf(p, &quot;%10u &quot;, irq_stats(j)-&gt;irq_call_count -</span>
<span class="p_del">-					irq_stats(j)-&gt;irq_tlb_count);</span>
<span class="p_add">+		seq_printf(p, &quot;%10u &quot;, irq_stats(j)-&gt;irq_call_count);</span>
 	seq_puts(p, &quot;  Function call interrupts\n&quot;);
 	seq_printf(p, &quot;%*s: &quot;, prec, &quot;TLB&quot;);
 	for_each_online_cpu(j)
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index dcbafe53e2d4..d915185ada05 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -1107,6 +1107,11 @@</span> <span class="p_context"> static inline bool cpu_has_vmx_invvpid_global(void)</span>
 	return vmx_capability.vpid &amp; VMX_VPID_EXTENT_GLOBAL_CONTEXT_BIT;
 }
 
<span class="p_add">+static inline bool cpu_has_vmx_invvpid(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return vmx_capability.vpid &amp; VMX_VPID_INVVPID_BIT;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline bool cpu_has_vmx_ept(void)
 {
 	return vmcs_config.cpu_based_2nd_exec_ctrl &amp;
<span class="p_chunk">@@ -6199,8 +6204,10 @@</span> <span class="p_context"> static __init int hardware_setup(void)</span>
 	if (boot_cpu_has(X86_FEATURE_NX))
 		kvm_enable_efer_bits(EFER_NX);
 
<span class="p_del">-	if (!cpu_has_vmx_vpid())</span>
<span class="p_add">+	if (!cpu_has_vmx_vpid() || !cpu_has_vmx_invvpid() ||</span>
<span class="p_add">+		!(cpu_has_vmx_invvpid_single() || cpu_has_vmx_invvpid_global()))</span>
 		enable_vpid = 0;
<span class="p_add">+</span>
 	if (!cpu_has_vmx_shadow_vmcs())
 		enable_shadow_vmcs = 0;
 	if (enable_shadow_vmcs)
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index df81717a92f3..e5f44f33de89 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -8230,11 +8230,11 @@</span> <span class="p_context"> void kvm_arch_async_page_present(struct kvm_vcpu *vcpu,</span>
 {
 	struct x86_exception fault;
 
<span class="p_del">-	trace_kvm_async_pf_ready(work-&gt;arch.token, work-&gt;gva);</span>
 	if (work-&gt;wakeup_all)
 		work-&gt;arch.token = ~0; /* broadcast wakeup */
 	else
 		kvm_del_async_pf_gfn(vcpu, work-&gt;arch.gfn);
<span class="p_add">+	trace_kvm_async_pf_ready(work-&gt;arch.token, work-&gt;gva);</span>
 
 	if ((vcpu-&gt;arch.apf.msr_val &amp; KVM_ASYNC_PF_ENABLED) &amp;&amp;
 	    !apf_put_user(vcpu, KVM_PV_REASON_PAGE_READY)) {
<span class="p_header">diff --git a/arch/x86/mm/Makefile b/arch/x86/mm/Makefile</span>
<span class="p_header">index 65c47fda26fc..1ae7c141f778 100644</span>
<span class="p_header">--- a/arch/x86/mm/Makefile</span>
<span class="p_header">+++ b/arch/x86/mm/Makefile</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 obj-y	:=  init.o init_$(BITS).o fault.o ioremap.o extable.o pageattr.o mmap.o \
<span class="p_del">-	    pat.o pgtable.o physaddr.o gup.o setup_nx.o</span>
<span class="p_add">+	    pat.o pgtable.o physaddr.o gup.o setup_nx.o tlb.o</span>
 
 # Make sure __phys_addr has no stackprotector
 nostackp := $(call cc-option, -fno-stack-protector)
<span class="p_chunk">@@ -9,7 +9,6 @@</span> <span class="p_context"> CFLAGS_setup_nx.o		:= $(nostackp)</span>
 CFLAGS_fault.o := -I$(src)/../include/asm/trace
 
 obj-$(CONFIG_X86_PAT)		+= pat_rbtree.o
<span class="p_del">-obj-$(CONFIG_SMP)		+= tlb.o</span>
 
 obj-$(CONFIG_X86_32)		+= pgtable_32.o iomap_32.o
 
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 5a760fd66bec..45ba87466e6a 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -28,6 +28,8 @@</span> <span class="p_context"></span>
  *	Implement flush IPI by CALL_FUNCTION_VECTOR, Alex Shi
  */
 
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+</span>
 struct flush_tlb_info {
 	struct mm_struct *flush_mm;
 	unsigned long flush_start;
<span class="p_chunk">@@ -57,6 +59,118 @@</span> <span class="p_context"> void leave_mm(int cpu)</span>
 }
 EXPORT_SYMBOL_GPL(leave_mm);
 
<span class="p_add">+#endif /* CONFIG_SMP */</span>
<span class="p_add">+</span>
<span class="p_add">+void switch_mm(struct mm_struct *prev, struct mm_struct *next,</span>
<span class="p_add">+	       struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+	switch_mm_irqs_off(prev, next, tsk);</span>
<span class="p_add">+	local_irq_restore(flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
<span class="p_add">+			struct task_struct *tsk)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned cpu = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	if (likely(prev != next)) {</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);</span>
<span class="p_add">+		this_cpu_write(cpu_tlbstate.active_mm, next);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+		cpumask_set_cpu(cpu, mm_cpumask(next));</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Re-load page tables.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This logic has an ordering constraint:</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 *  CPU 0: Write to a PTE for &#39;next&#39;</span>
<span class="p_add">+		 *  CPU 0: load bit 1 in mm_cpumask.  if nonzero, send IPI.</span>
<span class="p_add">+		 *  CPU 1: set bit 1 in next&#39;s mm_cpumask</span>
<span class="p_add">+		 *  CPU 1: load from the PTE that CPU 0 writes (implicit)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * We need to prevent an outcome in which CPU 1 observes</span>
<span class="p_add">+		 * the new PTE value and CPU 0 observes bit 1 clear in</span>
<span class="p_add">+		 * mm_cpumask.  (If that occurs, then the IPI will never</span>
<span class="p_add">+		 * be sent, and CPU 0&#39;s TLB will contain a stale entry.)</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * The bad outcome can occur if either CPU&#39;s load is</span>
<span class="p_add">+		 * reordered before that CPU&#39;s store, so both CPUs must</span>
<span class="p_add">+		 * execute full barriers to prevent this from happening.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * Thus, switch_mm needs a full barrier between the</span>
<span class="p_add">+		 * store to mm_cpumask and any operation that could load</span>
<span class="p_add">+		 * from next-&gt;pgd.  TLB fills are special and can happen</span>
<span class="p_add">+		 * due to instruction fetches or for no reason at all,</span>
<span class="p_add">+		 * and neither LOCK nor MFENCE orders them.</span>
<span class="p_add">+		 * Fortunately, load_cr3() is serializing and gives the</span>
<span class="p_add">+		 * ordering guarantee we need.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		load_cr3(next-&gt;pgd);</span>
<span class="p_add">+</span>
<span class="p_add">+		trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Stop flush ipis for the previous mm */</span>
<span class="p_add">+		cpumask_clear_cpu(cpu, mm_cpumask(prev));</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Load per-mm CR4 state */</span>
<span class="p_add">+		load_mm_cr4(next);</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_MODIFY_LDT_SYSCALL</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Load the LDT, if the LDT is different.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * It&#39;s possible that prev-&gt;context.ldt doesn&#39;t match</span>
<span class="p_add">+		 * the LDT register.  This can happen if leave_mm(prev)</span>
<span class="p_add">+		 * was called and then modify_ldt changed</span>
<span class="p_add">+		 * prev-&gt;context.ldt but suppressed an IPI to this CPU.</span>
<span class="p_add">+		 * In this case, prev-&gt;context.ldt != NULL, because we</span>
<span class="p_add">+		 * never set context.ldt to NULL while the mm still</span>
<span class="p_add">+		 * exists.  That means that next-&gt;context.ldt !=</span>
<span class="p_add">+		 * prev-&gt;context.ldt, because mms never share an LDT.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (unlikely(prev-&gt;context.ldt != next-&gt;context.ldt))</span>
<span class="p_add">+			load_mm_ldt(next);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	  else {</span>
<span class="p_add">+		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);</span>
<span class="p_add">+		BUG_ON(this_cpu_read(cpu_tlbstate.active_mm) != next);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!cpumask_test_cpu(cpu, mm_cpumask(next))) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * On established mms, the mm_cpumask is only changed</span>
<span class="p_add">+			 * from irq context, from ptep_clear_flush() while in</span>
<span class="p_add">+			 * lazy tlb mode, and here. Irqs are blocked during</span>
<span class="p_add">+			 * schedule, protecting us from simultaneous changes.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			cpumask_set_cpu(cpu, mm_cpumask(next));</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * We were in lazy tlb mode and leave_mm disabled</span>
<span class="p_add">+			 * tlb flush IPI delivery. We must reload CR3</span>
<span class="p_add">+			 * to make sure to use no freed page tables.</span>
<span class="p_add">+			 *</span>
<span class="p_add">+			 * As above, load_cr3() is serializing and orders TLB</span>
<span class="p_add">+			 * fills with respect to the mm_cpumask write.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			load_cr3(next-&gt;pgd);</span>
<span class="p_add">+			trace_tlb_flush(TLB_FLUSH_ON_TASK_SWITCH, TLB_FLUSH_ALL);</span>
<span class="p_add">+			load_mm_cr4(next);</span>
<span class="p_add">+			load_mm_ldt(next);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+</span>
 /*
  * The flush IPI assumes that a thread switch happens in this order:
  * [cpu0: the cpu that switches]
<span class="p_chunk">@@ -104,7 +218,7 @@</span> <span class="p_context"> static void flush_tlb_func(void *info)</span>
 
 	inc_irq_stat(irq_tlb_count);
 
<span class="p_del">-	if (f-&gt;flush_mm != this_cpu_read(cpu_tlbstate.active_mm))</span>
<span class="p_add">+	if (f-&gt;flush_mm &amp;&amp; f-&gt;flush_mm != this_cpu_read(cpu_tlbstate.active_mm))</span>
 		return;
 
 	count_vm_tlb_event(NR_TLB_REMOTE_FLUSH_RECEIVED);
<span class="p_chunk">@@ -351,3 +465,5 @@</span> <span class="p_context"> static int __init create_tlb_single_page_flush_ceiling(void)</span>
 	return 0;
 }
 late_initcall(create_tlb_single_page_flush_ceiling);
<span class="p_add">+</span>
<span class="p_add">+#endif /* CONFIG_SMP */</span>
<span class="p_header">diff --git a/drivers/bluetooth/btusb.c b/drivers/bluetooth/btusb.c</span>
<span class="p_header">index ce120fbe229e..1ccad79ce77c 100644</span>
<span class="p_header">--- a/drivers/bluetooth/btusb.c</span>
<span class="p_header">+++ b/drivers/bluetooth/btusb.c</span>
<span class="p_chunk">@@ -1050,10 +1050,6 @@</span> <span class="p_context"> static int btusb_open(struct hci_dev *hdev)</span>
 		return err;
 
 	data-&gt;intf-&gt;needs_remote_wakeup = 1;
<span class="p_del">-	/* device specific wakeup source enabled and required for USB</span>
<span class="p_del">-	 * remote wakeup while host is suspended</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	device_wakeup_enable(&amp;data-&gt;udev-&gt;dev);</span>
 
 	if (test_and_set_bit(BTUSB_INTR_RUNNING, &amp;data-&gt;flags))
 		goto done;
<span class="p_chunk">@@ -1117,7 +1113,6 @@</span> <span class="p_context"> static int btusb_close(struct hci_dev *hdev)</span>
 		goto failed;
 
 	data-&gt;intf-&gt;needs_remote_wakeup = 0;
<span class="p_del">-	device_wakeup_disable(&amp;data-&gt;udev-&gt;dev);</span>
 	usb_autopm_put_interface(data-&gt;intf);
 
 failed:
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle-powernv.c b/drivers/cpuidle/cpuidle-powernv.c</span>
<span class="p_header">index 845bafcfa792..d5c5a476360f 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle-powernv.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle-powernv.c</span>
<span class="p_chunk">@@ -160,6 +160,24 @@</span> <span class="p_context"> static int powernv_cpuidle_driver_init(void)</span>
 		drv-&gt;state_count += 1;
 	}
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On the PowerNV platform cpu_present may be less than cpu_possible in</span>
<span class="p_add">+	 * cases when firmware detects the CPU, but it is not available to the</span>
<span class="p_add">+	 * OS.  If CONFIG_HOTPLUG_CPU=n, then such CPUs are not hotplugable at</span>
<span class="p_add">+	 * run time and hence cpu_devices are not created for those CPUs by the</span>
<span class="p_add">+	 * generic topology_init().</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * drv-&gt;cpumask defaults to cpu_possible_mask in</span>
<span class="p_add">+	 * __cpuidle_driver_init().  This breaks cpuidle on PowerNV where</span>
<span class="p_add">+	 * cpu_devices are not created for CPUs in cpu_possible_mask that</span>
<span class="p_add">+	 * cannot be hot-added later at run time.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Trying cpuidle_register_device() on a CPU without a cpu_device is</span>
<span class="p_add">+	 * incorrect, so pass a correct CPU mask to the generic cpuidle driver.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	drv-&gt;cpumask = (struct cpumask *)cpu_present_mask;</span>
<span class="p_add">+</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/cpuidle/cpuidle.c b/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">index d40b2c077746..f1dd0f73820d 100644</span>
<span class="p_header">--- a/drivers/cpuidle/cpuidle.c</span>
<span class="p_header">+++ b/drivers/cpuidle/cpuidle.c</span>
<span class="p_chunk">@@ -189,6 +189,7 @@</span> <span class="p_context"> int cpuidle_enter_state(struct cpuidle_device *dev, struct cpuidle_driver *drv,</span>
 			return -EBUSY;
 		}
 		target_state = &amp;drv-&gt;states[index];
<span class="p_add">+		broadcast = false;</span>
 	}
 
 	/* Take note of the planned idle state. */
<span class="p_header">diff --git a/drivers/cpuidle/sysfs.c b/drivers/cpuidle/sysfs.c</span>
<span class="p_header">index 832a2c3f01ff..9e98a5fbbc1d 100644</span>
<span class="p_header">--- a/drivers/cpuidle/sysfs.c</span>
<span class="p_header">+++ b/drivers/cpuidle/sysfs.c</span>
<span class="p_chunk">@@ -613,6 +613,18 @@</span> <span class="p_context"> int cpuidle_add_sysfs(struct cpuidle_device *dev)</span>
 	struct device *cpu_dev = get_cpu_device((unsigned long)dev-&gt;cpu);
 	int error;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Return if cpu_device is not setup for this CPU.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * This could happen if the arch did not set up cpu_device</span>
<span class="p_add">+	 * since this CPU is not in cpu_present mask and the</span>
<span class="p_add">+	 * driver did not send a correct CPU mask during registration.</span>
<span class="p_add">+	 * Without this check we would end up passing bogus</span>
<span class="p_add">+	 * value for &amp;cpu_dev-&gt;kobj in kobject_init_and_add()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!cpu_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	kdev = kzalloc(sizeof(*kdev), GFP_KERNEL);
 	if (!kdev)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/crypto/amcc/crypto4xx_core.h b/drivers/crypto/amcc/crypto4xx_core.h</span>
<span class="p_header">index bac0bdeb4b5f..b6529b9fcbe2 100644</span>
<span class="p_header">--- a/drivers/crypto/amcc/crypto4xx_core.h</span>
<span class="p_header">+++ b/drivers/crypto/amcc/crypto4xx_core.h</span>
<span class="p_chunk">@@ -32,12 +32,12 @@</span> <span class="p_context"></span>
 #define PPC405EX_CE_RESET                       0x00000008
 
 #define CRYPTO4XX_CRYPTO_PRIORITY		300
<span class="p_del">-#define PPC4XX_LAST_PD				63</span>
<span class="p_del">-#define PPC4XX_NUM_PD				64</span>
<span class="p_del">-#define PPC4XX_LAST_GD				1023</span>
<span class="p_add">+#define PPC4XX_NUM_PD				256</span>
<span class="p_add">+#define PPC4XX_LAST_PD				(PPC4XX_NUM_PD - 1)</span>
 #define PPC4XX_NUM_GD				1024
<span class="p_del">-#define PPC4XX_LAST_SD				63</span>
<span class="p_del">-#define PPC4XX_NUM_SD				64</span>
<span class="p_add">+#define PPC4XX_LAST_GD				(PPC4XX_NUM_GD - 1)</span>
<span class="p_add">+#define PPC4XX_NUM_SD				256</span>
<span class="p_add">+#define PPC4XX_LAST_SD				(PPC4XX_NUM_SD - 1)</span>
 #define PPC4XX_SD_BUFFER_SIZE			2048
 
 #define PD_ENTRY_INUSE				1
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index 1a1fc8351289..3ba486d0ec6f 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -2053,6 +2053,7 @@</span> <span class="p_context"> static const struct hid_device_id hid_have_special_driver[] = {</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_WALTOP, USB_DEVICE_ID_WALTOP_SIRIUS_BATTERY_FREE_TABLET) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_X_TENSIONS, USB_DEVICE_ID_SPEEDLINK_VAD_CEZANNE) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_XIN_MO_DUAL_ARCADE) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_THT_2P_ARCADE) },</span>
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0005) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ZEROPLUS, 0x0030) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_ZYDACRON, USB_DEVICE_ID_ZYDACRON_REMOTE_CONTROL) },
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 6937086060a6..b554d17c9156 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -1021,6 +1021,7 @@</span> <span class="p_context"></span>
 
 #define USB_VENDOR_ID_XIN_MO			0x16c0
 #define USB_DEVICE_ID_XIN_MO_DUAL_ARCADE	0x05e1
<span class="p_add">+#define USB_DEVICE_ID_THT_2P_ARCADE		0x75e1</span>
 
 #define USB_VENDOR_ID_XIROKU		0x1477
 #define USB_DEVICE_ID_XIROKU_SPX	0x1006
<span class="p_header">diff --git a/drivers/hid/hid-xinmo.c b/drivers/hid/hid-xinmo.c</span>
<span class="p_header">index 7df5227a7e61..9ad7731d2e10 100644</span>
<span class="p_header">--- a/drivers/hid/hid-xinmo.c</span>
<span class="p_header">+++ b/drivers/hid/hid-xinmo.c</span>
<span class="p_chunk">@@ -46,6 +46,7 @@</span> <span class="p_context"> static int xinmo_event(struct hid_device *hdev, struct hid_field *field,</span>
 
 static const struct hid_device_id xinmo_devices[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_XIN_MO_DUAL_ARCADE) },
<span class="p_add">+	{ HID_USB_DEVICE(USB_VENDOR_ID_XIN_MO, USB_DEVICE_ID_THT_2P_ARCADE) },</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/hwmon/asus_atk0110.c b/drivers/hwmon/asus_atk0110.c</span>
<span class="p_header">index cccef87963e0..975c43d446f8 100644</span>
<span class="p_header">--- a/drivers/hwmon/asus_atk0110.c</span>
<span class="p_header">+++ b/drivers/hwmon/asus_atk0110.c</span>
<span class="p_chunk">@@ -646,6 +646,9 @@</span> <span class="p_context"> static int atk_read_value(struct atk_sensor_data *sensor, u64 *value)</span>
 		else
 			err = atk_read_value_new(sensor, value);
 
<span class="p_add">+		if (err)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+</span>
 		sensor-&gt;is_valid = true;
 		sensor-&gt;last_updated = jiffies;
 		sensor-&gt;cached_value = *value;
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.h b/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_header">index 8a5998e6a407..88f97ea6b366 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iscsi_iser.h</span>
<span class="p_chunk">@@ -450,6 +450,7 @@</span> <span class="p_context"> struct iser_fr_desc {</span>
 	struct list_head		  list;
 	struct iser_reg_resources	  rsc;
 	struct iser_pi_context		 *pi_ctx;
<span class="p_add">+	struct list_head                  all_list;</span>
 };
 
 /**
<span class="p_chunk">@@ -463,6 +464,7 @@</span> <span class="p_context"> struct iser_fr_pool {</span>
 	struct list_head        list;
 	spinlock_t              lock;
 	int                     size;
<span class="p_add">+	struct list_head        all_list;</span>
 };
 
 /**
<span class="p_header">diff --git a/drivers/infiniband/ulp/iser/iser_verbs.c b/drivers/infiniband/ulp/iser/iser_verbs.c</span>
<span class="p_header">index 42f4da620f2e..0cbc7ceb9a55 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/iser/iser_verbs.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/iser/iser_verbs.c</span>
<span class="p_chunk">@@ -405,6 +405,7 @@</span> <span class="p_context"> int iser_alloc_fastreg_pool(struct ib_conn *ib_conn,</span>
 	int i, ret;
 
 	INIT_LIST_HEAD(&amp;fr_pool-&gt;list);
<span class="p_add">+	INIT_LIST_HEAD(&amp;fr_pool-&gt;all_list);</span>
 	spin_lock_init(&amp;fr_pool-&gt;lock);
 	fr_pool-&gt;size = 0;
 	for (i = 0; i &lt; cmds_max; i++) {
<span class="p_chunk">@@ -416,6 +417,7 @@</span> <span class="p_context"> int iser_alloc_fastreg_pool(struct ib_conn *ib_conn,</span>
 		}
 
 		list_add_tail(&amp;desc-&gt;list, &amp;fr_pool-&gt;list);
<span class="p_add">+		list_add_tail(&amp;desc-&gt;all_list, &amp;fr_pool-&gt;all_list);</span>
 		fr_pool-&gt;size++;
 	}
 
<span class="p_chunk">@@ -435,13 +437,13 @@</span> <span class="p_context"> void iser_free_fastreg_pool(struct ib_conn *ib_conn)</span>
 	struct iser_fr_desc *desc, *tmp;
 	int i = 0;
 
<span class="p_del">-	if (list_empty(&amp;fr_pool-&gt;list))</span>
<span class="p_add">+	if (list_empty(&amp;fr_pool-&gt;all_list))</span>
 		return;
 
 	iser_info(&quot;freeing conn %p fr pool\n&quot;, ib_conn);
 
<span class="p_del">-	list_for_each_entry_safe(desc, tmp, &amp;fr_pool-&gt;list, list) {</span>
<span class="p_del">-		list_del(&amp;desc-&gt;list);</span>
<span class="p_add">+	list_for_each_entry_safe(desc, tmp, &amp;fr_pool-&gt;all_list, all_list) {</span>
<span class="p_add">+		list_del(&amp;desc-&gt;all_list);</span>
 		iser_free_reg_res(&amp;desc-&gt;rsc);
 		if (desc-&gt;pi_ctx)
 			iser_free_pi_ctx(desc-&gt;pi_ctx);
<span class="p_header">diff --git a/drivers/isdn/capi/kcapi.c b/drivers/isdn/capi/kcapi.c</span>
<span class="p_header">index 823f6985b260..dd7e38ac29bd 100644</span>
<span class="p_header">--- a/drivers/isdn/capi/kcapi.c</span>
<span class="p_header">+++ b/drivers/isdn/capi/kcapi.c</span>
<span class="p_chunk">@@ -1032,6 +1032,7 @@</span> <span class="p_context"> static int old_capi_manufacturer(unsigned int cmd, void __user *data)</span>
 						     sizeof(avmb1_carddef))))
 				return -EFAULT;
 			cdef.cardtype = AVM_CARDTYPE_B1;
<span class="p_add">+			cdef.cardnr = 0;</span>
 		} else {
 			if ((retval = copy_from_user(&amp;cdef, data,
 						     sizeof(avmb1_extcarddef))))
<span class="p_header">diff --git a/drivers/misc/cxl/pci.c b/drivers/misc/cxl/pci.c</span>
<span class="p_header">index 0c6c17a1c59e..ba2f6d1d7db7 100644</span>
<span class="p_header">--- a/drivers/misc/cxl/pci.c</span>
<span class="p_header">+++ b/drivers/misc/cxl/pci.c</span>
<span class="p_chunk">@@ -1329,6 +1329,9 @@</span> <span class="p_context"> static pci_ers_result_t cxl_vphb_error_detected(struct cxl_afu *afu,</span>
 	/* There should only be one entry, but go through the list
 	 * anyway
 	 */
<span class="p_add">+	if (afu-&gt;phb == NULL)</span>
<span class="p_add">+		return result;</span>
<span class="p_add">+</span>
 	list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 		if (!afu_dev-&gt;driver)
 			continue;
<span class="p_chunk">@@ -1369,6 +1372,10 @@</span> <span class="p_context"> static pci_ers_result_t cxl_pci_error_detected(struct pci_dev *pdev,</span>
 		 */
 		for (i = 0; i &lt; adapter-&gt;slices; i++) {
 			afu = adapter-&gt;afu[i];
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Tell the AFU drivers; but we don&#39;t care what they</span>
<span class="p_add">+			 * say, we&#39;re going away.</span>
<span class="p_add">+			 */</span>
 			cxl_vphb_error_detected(afu, state);
 		}
 		return PCI_ERS_RESULT_DISCONNECT;
<span class="p_chunk">@@ -1492,6 +1499,9 @@</span> <span class="p_context"> static pci_ers_result_t cxl_pci_slot_reset(struct pci_dev *pdev)</span>
 		if (cxl_afu_select_best_mode(afu))
 			goto err;
 
<span class="p_add">+		if (afu-&gt;phb == NULL)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		cxl_pci_vphb_reconfigure(afu);
 
 		list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
<span class="p_chunk">@@ -1556,6 +1566,9 @@</span> <span class="p_context"> static void cxl_pci_resume(struct pci_dev *pdev)</span>
 	for (i = 0; i &lt; adapter-&gt;slices; i++) {
 		afu = adapter-&gt;afu[i];
 
<span class="p_add">+		if (afu-&gt;phb == NULL)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
 		list_for_each_entry(afu_dev, &amp;afu-&gt;phb-&gt;bus-&gt;devices, bus_list) {
 			if (afu_dev-&gt;driver &amp;&amp; afu_dev-&gt;driver-&gt;err_handler &amp;&amp;
 			    afu_dev-&gt;driver-&gt;err_handler-&gt;resume)
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bnxt/bnxt.c b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">index 4744919440e0..a38a9cb3d544 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bnxt/bnxt.c</span>
<span class="p_chunk">@@ -2014,6 +2014,18 @@</span> <span class="p_context"> static int bnxt_init_one_rx_ring(struct bnxt *bp, int ring_nr)</span>
 	return 0;
 }
 
<span class="p_add">+static void bnxt_init_cp_rings(struct bnxt *bp)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; bp-&gt;cp_nr_rings; i++) {</span>
<span class="p_add">+		struct bnxt_cp_ring_info *cpr = &amp;bp-&gt;bnapi[i]-&gt;cp_ring;</span>
<span class="p_add">+		struct bnxt_ring_struct *ring = &amp;cpr-&gt;cp_ring_struct;</span>
<span class="p_add">+</span>
<span class="p_add">+		ring-&gt;fw_ring_id = INVALID_HW_RING_ID;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int bnxt_init_rx_rings(struct bnxt *bp)
 {
 	int i, rc = 0;
<span class="p_chunk">@@ -3977,6 +3989,7 @@</span> <span class="p_context"> static int bnxt_shutdown_nic(struct bnxt *bp, bool irq_re_init)</span>
 
 static int bnxt_init_nic(struct bnxt *bp, bool irq_re_init)
 {
<span class="p_add">+	bnxt_init_cp_rings(bp);</span>
 	bnxt_init_rx_rings(bp);
 	bnxt_init_tx_rings(bp);
 	bnxt_init_ring_grps(bp, irq_re_init);
<span class="p_header">diff --git a/drivers/net/ethernet/brocade/bna/bfa_ioc.c b/drivers/net/ethernet/brocade/bna/bfa_ioc.c</span>
<span class="p_header">index 9e59663a6ead..0f6811860ad5 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/brocade/bna/bfa_ioc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/brocade/bna/bfa_ioc.c</span>
<span class="p_chunk">@@ -1930,13 +1930,13 @@</span> <span class="p_context"> static void</span>
 bfa_ioc_send_enable(struct bfa_ioc *ioc)
 {
 	struct bfi_ioc_ctrl_req enable_req;
<span class="p_del">-	struct timeval tv;</span>
 
 	bfi_h2i_set(enable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_ENABLE_REQ,
 		    bfa_ioc_portid(ioc));
 	enable_req.clscode = htons(ioc-&gt;clscode);
<span class="p_del">-	do_gettimeofday(&amp;tv);</span>
<span class="p_del">-	enable_req.tv_sec = ntohl(tv.tv_sec);</span>
<span class="p_add">+	enable_req.rsvd = htons(0);</span>
<span class="p_add">+	/* overflow in 2106 */</span>
<span class="p_add">+	enable_req.tv_sec = ntohl(ktime_get_real_seconds());</span>
 	bfa_ioc_mbox_send(ioc, &amp;enable_req, sizeof(struct bfi_ioc_ctrl_req));
 }
 
<span class="p_chunk">@@ -1947,6 +1947,10 @@</span> <span class="p_context"> bfa_ioc_send_disable(struct bfa_ioc *ioc)</span>
 
 	bfi_h2i_set(disable_req.mh, BFI_MC_IOC, BFI_IOC_H2I_DISABLE_REQ,
 		    bfa_ioc_portid(ioc));
<span class="p_add">+	disable_req.clscode = htons(ioc-&gt;clscode);</span>
<span class="p_add">+	disable_req.rsvd = htons(0);</span>
<span class="p_add">+	/* overflow in 2106 */</span>
<span class="p_add">+	disable_req.tv_sec = ntohl(ktime_get_real_seconds());</span>
 	bfa_ioc_mbox_send(ioc, &amp;disable_req, sizeof(struct bfi_ioc_ctrl_req));
 }
 
<span class="p_header">diff --git a/drivers/net/ethernet/brocade/bna/bnad_debugfs.c b/drivers/net/ethernet/brocade/bna/bnad_debugfs.c</span>
<span class="p_header">index 8fc246ea1fb8..a4ad782007ce 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/brocade/bna/bnad_debugfs.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/brocade/bna/bnad_debugfs.c</span>
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> bnad_debugfs_write_regrd(struct file *file, const char __user *buf,</span>
 		return PTR_ERR(kern_buf);
 
 	rc = sscanf(kern_buf, &quot;%x:%x&quot;, &amp;addr, &amp;len);
<span class="p_del">-	if (rc &lt; 2) {</span>
<span class="p_add">+	if (rc &lt; 2 || len &gt; UINT_MAX &gt;&gt; 2) {</span>
 		netdev_warn(bnad-&gt;netdev, &quot;failed to read user buffer\n&quot;);
 		kfree(kern_buf);
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/net/ethernet/intel/fm10k/fm10k_iov.c b/drivers/net/ethernet/intel/fm10k/fm10k_iov.c</span>
<span class="p_header">index acfb8b1f88a7..a8f9d0012d82 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/fm10k/fm10k_iov.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/fm10k/fm10k_iov.c</span>
<span class="p_chunk">@@ -126,6 +126,9 @@</span> <span class="p_context"> process_mbx:</span>
 		struct fm10k_mbx_info *mbx = &amp;vf_info-&gt;mbx;
 		u16 glort = vf_info-&gt;glort;
 
<span class="p_add">+		/* process the SM mailbox first to drain outgoing messages */</span>
<span class="p_add">+		hw-&gt;mbx.ops.process(hw, &amp;hw-&gt;mbx);</span>
<span class="p_add">+</span>
 		/* verify port mapping is valid, if not reset port */
 		if (vf_info-&gt;vf_flags &amp;&amp; !fm10k_glort_valid_pf(hw, glort))
 			hw-&gt;iov.ops.reset_lport(hw, vf_info);
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index b5b228c9a030..06b38f50980c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -4201,8 +4201,12 @@</span> <span class="p_context"> static void i40e_napi_enable_all(struct i40e_vsi *vsi)</span>
 	if (!vsi-&gt;netdev)
 		return;
 
<span class="p_del">-	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++)</span>
<span class="p_del">-		napi_enable(&amp;vsi-&gt;q_vectors[q_idx]-&gt;napi);</span>
<span class="p_add">+	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++) {</span>
<span class="p_add">+		struct i40e_q_vector *q_vector = vsi-&gt;q_vectors[q_idx];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (q_vector-&gt;rx.ring || q_vector-&gt;tx.ring)</span>
<span class="p_add">+			napi_enable(&amp;q_vector-&gt;napi);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_chunk">@@ -4216,8 +4220,12 @@</span> <span class="p_context"> static void i40e_napi_disable_all(struct i40e_vsi *vsi)</span>
 	if (!vsi-&gt;netdev)
 		return;
 
<span class="p_del">-	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++)</span>
<span class="p_del">-		napi_disable(&amp;vsi-&gt;q_vectors[q_idx]-&gt;napi);</span>
<span class="p_add">+	for (q_idx = 0; q_idx &lt; vsi-&gt;num_q_vectors; q_idx++) {</span>
<span class="p_add">+		struct i40e_q_vector *q_vector = vsi-&gt;q_vectors[q_idx];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (q_vector-&gt;rx.ring || q_vector-&gt;tx.ring)</span>
<span class="p_add">+			napi_disable(&amp;q_vector-&gt;napi);</span>
<span class="p_add">+	}</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/net/ethernet/intel/igb/igb_main.c b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">index c55552c3d2f9..53803fd6350c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/igb/igb_main.c</span>
<span class="p_chunk">@@ -3005,6 +3005,8 @@</span> <span class="p_context"> static int igb_sw_init(struct igb_adapter *adapter)</span>
 	/* Setup and initialize a copy of the hw vlan table array */
 	adapter-&gt;shadow_vfta = kcalloc(E1000_VLAN_FILTER_TBL_SIZE, sizeof(u32),
 				       GFP_ATOMIC);
<span class="p_add">+	if (!adapter-&gt;shadow_vfta)</span>
<span class="p_add">+		return -ENOMEM;</span>
 
 	/* This call may decrease the number of queues */
 	if (igb_init_interrupt_scheme(adapter, true)) {
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c</span>
<span class="p_header">index ce61b36b94f1..105dd00ddc1a 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_common.c</span>
<span class="p_chunk">@@ -3620,10 +3620,10 @@</span> <span class="p_context"> s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,</span>
 	fw_cmd.ver_build = build;
 	fw_cmd.ver_sub = sub;
 	fw_cmd.hdr.checksum = 0;
<span class="p_del">-	fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&amp;fw_cmd,</span>
<span class="p_del">-				(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));</span>
 	fw_cmd.pad = 0;
 	fw_cmd.pad2 = 0;
<span class="p_add">+	fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&amp;fw_cmd,</span>
<span class="p_add">+				(FW_CEM_HDR_LEN + fw_cmd.hdr.buf_len));</span>
 
 	for (i = 0; i &lt;= FW_CEM_MAX_RETRIES; i++) {
 		ret_val = ixgbe_host_interface_command(hw, (u32 *)&amp;fw_cmd,
<span class="p_header">diff --git a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c</span>
<span class="p_header">index 31f864fb30c1..a75f2e3ce86f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/ixgbe/ixgbe_x550.c</span>
<span class="p_chunk">@@ -564,6 +564,8 @@</span> <span class="p_context"> static s32 ixgbe_read_ee_hostif_buffer_X550(struct ixgbe_hw *hw,</span>
 		/* convert offset from words to bytes */
 		buffer.address = cpu_to_be32((offset + current_word) * 2);
 		buffer.length = cpu_to_be16(words_to_read * 2);
<span class="p_add">+		buffer.pad2 = 0;</span>
<span class="p_add">+		buffer.pad3 = 0;</span>
 
 		status = ixgbe_host_interface_command(hw, (u32 *)&amp;buffer,
 						      sizeof(buffer),
<span class="p_header">diff --git a/drivers/net/irda/vlsi_ir.c b/drivers/net/irda/vlsi_ir.c</span>
<span class="p_header">index a0849f49bbec..c0192f97ecc8 100644</span>
<span class="p_header">--- a/drivers/net/irda/vlsi_ir.c</span>
<span class="p_header">+++ b/drivers/net/irda/vlsi_ir.c</span>
<span class="p_chunk">@@ -418,8 +418,9 @@</span> <span class="p_context"> static struct vlsi_ring *vlsi_alloc_ring(struct pci_dev *pdev, struct ring_descr</span>
 		memset(rd, 0, sizeof(*rd));
 		rd-&gt;hw = hwmap + i;
 		rd-&gt;buf = kmalloc(len, GFP_KERNEL|GFP_DMA);
<span class="p_del">-		if (rd-&gt;buf == NULL ||</span>
<span class="p_del">-		    !(busaddr = pci_map_single(pdev, rd-&gt;buf, len, dir))) {</span>
<span class="p_add">+		if (rd-&gt;buf)</span>
<span class="p_add">+			busaddr = pci_map_single(pdev, rd-&gt;buf, len, dir);</span>
<span class="p_add">+		if (rd-&gt;buf == NULL || pci_dma_mapping_error(pdev, busaddr)) {</span>
 			if (rd-&gt;buf) {
 				net_err_ratelimited(&quot;%s: failed to create PCI-MAP for %p\n&quot;,
 						    __func__, rd-&gt;buf);
<span class="p_chunk">@@ -430,8 +431,7 @@</span> <span class="p_context"> static struct vlsi_ring *vlsi_alloc_ring(struct pci_dev *pdev, struct ring_descr</span>
 				rd = r-&gt;rd + j;
 				busaddr = rd_get_addr(rd);
 				rd_set_addr_status(rd, 0, 0);
<span class="p_del">-				if (busaddr)</span>
<span class="p_del">-					pci_unmap_single(pdev, busaddr, len, dir);</span>
<span class="p_add">+				pci_unmap_single(pdev, busaddr, len, dir);</span>
 				kfree(rd-&gt;buf);
 				rd-&gt;buf = NULL;
 			}
<span class="p_header">diff --git a/drivers/net/phy/at803x.c b/drivers/net/phy/at803x.c</span>
<span class="p_header">index 2d020a3ec0b5..37333d38b576 100644</span>
<span class="p_header">--- a/drivers/net/phy/at803x.c</span>
<span class="p_header">+++ b/drivers/net/phy/at803x.c</span>
<span class="p_chunk">@@ -105,7 +105,7 @@</span> <span class="p_context"> static int at803x_set_wol(struct phy_device *phydev,</span>
 		mac = (const u8 *) ndev-&gt;dev_addr;
 
 		if (!is_valid_ether_addr(mac))
<span class="p_del">-			return -EFAULT;</span>
<span class="p_add">+			return -EINVAL;</span>
 
 		for (i = 0; i &lt; 3; i++) {
 			phy_write(phydev, AT803X_MMD_ACCESS_CONTROL,
<span class="p_header">diff --git a/drivers/net/usb/qmi_wwan.c b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">index e325ca3ad565..2cbecbda1ae3 100644</span>
<span class="p_header">--- a/drivers/net/usb/qmi_wwan.c</span>
<span class="p_header">+++ b/drivers/net/usb/qmi_wwan.c</span>
<span class="p_chunk">@@ -410,6 +410,10 @@</span> <span class="p_context"> static const struct usb_device_id products[] = {</span>
 		USB_VENDOR_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, USB_CLASS_VENDOR_SPEC, 0x01, 0x69),
 		.driver_info        = (unsigned long)&amp;qmi_wwan_info,
 	},
<span class="p_add">+	{	/* Motorola Mapphone devices with MDM6600 */</span>
<span class="p_add">+		USB_VENDOR_AND_INTERFACE_INFO(0x22b8, USB_CLASS_VENDOR_SPEC, 0xfb, 0xff),</span>
<span class="p_add">+		.driver_info        = (unsigned long)&amp;qmi_wwan_info,</span>
<span class="p_add">+	},</span>
 
 	/* 2. Combined interface devices matching on class+protocol */
 	{	/* Huawei E367 and possibly others in &quot;Windows mode&quot; */
<span class="p_header">diff --git a/drivers/net/usb/r8152.c b/drivers/net/usb/r8152.c</span>
<span class="p_header">index 1c27e6fb99f9..304ec25eaf95 100644</span>
<span class="p_header">--- a/drivers/net/usb/r8152.c</span>
<span class="p_header">+++ b/drivers/net/usb/r8152.c</span>
<span class="p_chunk">@@ -1207,6 +1207,7 @@</span> <span class="p_context"> static void intr_callback(struct urb *urb)</span>
 		}
 	} else {
 		if (netif_carrier_ok(tp-&gt;netdev)) {
<span class="p_add">+			netif_stop_queue(tp-&gt;netdev);</span>
 			set_bit(RTL8152_LINK_CHG, &amp;tp-&gt;flags);
 			schedule_delayed_work(&amp;tp-&gt;schedule, 0);
 		}
<span class="p_chunk">@@ -1277,6 +1278,7 @@</span> <span class="p_context"> static int alloc_all_mem(struct r8152 *tp)</span>
 	spin_lock_init(&amp;tp-&gt;rx_lock);
 	spin_lock_init(&amp;tp-&gt;tx_lock);
 	INIT_LIST_HEAD(&amp;tp-&gt;tx_free);
<span class="p_add">+	INIT_LIST_HEAD(&amp;tp-&gt;rx_done);</span>
 	skb_queue_head_init(&amp;tp-&gt;tx_queue);
 	skb_queue_head_init(&amp;tp-&gt;rx_queue);
 
<span class="p_chunk">@@ -3000,6 +3002,9 @@</span> <span class="p_context"> static void set_carrier(struct r8152 *tp)</span>
 			napi_enable(&amp;tp-&gt;napi);
 			netif_wake_queue(netdev);
 			netif_info(tp, link, netdev, &quot;carrier on\n&quot;);
<span class="p_add">+		} else if (netif_queue_stopped(netdev) &amp;&amp;</span>
<span class="p_add">+			   skb_queue_len(&amp;tp-&gt;tx_queue) &lt; tp-&gt;tx_qlen) {</span>
<span class="p_add">+			netif_wake_queue(netdev);</span>
 		}
 	} else {
 		if (netif_carrier_ok(netdev)) {
<span class="p_chunk">@@ -3560,8 +3565,18 @@</span> <span class="p_context"> static int rtl8152_resume(struct usb_interface *intf)</span>
 			clear_bit(SELECTIVE_SUSPEND, &amp;tp-&gt;flags);
 			napi_disable(&amp;tp-&gt;napi);
 			set_bit(WORK_ENABLE, &amp;tp-&gt;flags);
<span class="p_del">-			if (netif_carrier_ok(tp-&gt;netdev))</span>
<span class="p_del">-				rtl_start_rx(tp);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (netif_carrier_ok(tp-&gt;netdev)) {</span>
<span class="p_add">+				if (rtl8152_get_speed(tp) &amp; LINK_STATUS) {</span>
<span class="p_add">+					rtl_start_rx(tp);</span>
<span class="p_add">+				} else {</span>
<span class="p_add">+					netif_carrier_off(tp-&gt;netdev);</span>
<span class="p_add">+					tp-&gt;rtl_ops.disable(tp);</span>
<span class="p_add">+					netif_info(tp, link, tp-&gt;netdev,</span>
<span class="p_add">+						   &quot;linking down\n&quot;);</span>
<span class="p_add">+				}</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			napi_enable(&amp;tp-&gt;napi);
 		} else {
 			tp-&gt;rtl_ops.up(tp);
<span class="p_header">diff --git a/drivers/pci/iov.c b/drivers/pci/iov.c</span>
<span class="p_header">index 357527712539..7680fc0349fc 100644</span>
<span class="p_header">--- a/drivers/pci/iov.c</span>
<span class="p_header">+++ b/drivers/pci/iov.c</span>
<span class="p_chunk">@@ -161,7 +161,6 @@</span> <span class="p_context"> static int virtfn_add(struct pci_dev *dev, int id, int reset)</span>
 	pci_device_add(virtfn, virtfn-&gt;bus);
 	mutex_unlock(&amp;iov-&gt;dev-&gt;sriov-&gt;lock);
 
<span class="p_del">-	pci_bus_add_device(virtfn);</span>
 	sprintf(buf, &quot;virtfn%u&quot;, id);
 	rc = sysfs_create_link(&amp;dev-&gt;dev.kobj, &amp;virtfn-&gt;dev.kobj, buf);
 	if (rc)
<span class="p_chunk">@@ -172,6 +171,8 @@</span> <span class="p_context"> static int virtfn_add(struct pci_dev *dev, int id, int reset)</span>
 
 	kobject_uevent(&amp;virtfn-&gt;dev.kobj, KOBJ_CHANGE);
 
<span class="p_add">+	pci_bus_add_device(virtfn);</span>
<span class="p_add">+</span>
 	return 0;
 
 failed2:
<span class="p_header">diff --git a/drivers/pci/pci.c b/drivers/pci/pci.c</span>
<span class="p_header">index 1a14ca8965e6..295bf1472d02 100644</span>
<span class="p_header">--- a/drivers/pci/pci.c</span>
<span class="p_header">+++ b/drivers/pci/pci.c</span>
<span class="p_chunk">@@ -3850,6 +3850,10 @@</span> <span class="p_context"> static bool pci_bus_resetable(struct pci_bus *bus)</span>
 {
 	struct pci_dev *dev;
 
<span class="p_add">+</span>
<span class="p_add">+	if (bus-&gt;self &amp;&amp; (bus-&gt;self-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_BUS_RESET))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
 	list_for_each_entry(dev, &amp;bus-&gt;devices, bus_list) {
 		if (dev-&gt;dev_flags &amp; PCI_DEV_FLAGS_NO_BUS_RESET ||
 		    (dev-&gt;subordinate &amp;&amp; !pci_bus_resetable(dev-&gt;subordinate)))
<span class="p_header">diff --git a/drivers/pci/pcie/aer/aerdrv_core.c b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">index 4e14de0f0f98..ca5dbf03e388 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aer/aerdrv_core.c</span>
<span class="p_chunk">@@ -388,7 +388,14 @@</span> <span class="p_context"> static pci_ers_result_t broadcast_error_message(struct pci_dev *dev,</span>
 		 * If the error is reported by an end point, we think this
 		 * error is related to the upstream link of the end point.
 		 */
<span class="p_del">-		pci_walk_bus(dev-&gt;bus, cb, &amp;result_data);</span>
<span class="p_add">+		if (state == pci_channel_io_normal)</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * the error is non fatal so the bus is ok, just invoke</span>
<span class="p_add">+			 * the callback for the function that logged the error.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			cb(dev, &amp;result_data);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			pci_walk_bus(dev-&gt;bus, cb, &amp;result_data);</span>
 	}
 
 	return result_data.result;
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-st.c b/drivers/pinctrl/pinctrl-st.c</span>
<span class="p_header">index b58d3f29148a..6908b6ce2074 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-st.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-st.c</span>
<span class="p_chunk">@@ -1338,6 +1338,22 @@</span> <span class="p_context"> static void st_gpio_irq_unmask(struct irq_data *d)</span>
 	writel(BIT(d-&gt;hwirq), bank-&gt;base + REG_PIO_SET_PMASK);
 }
 
<span class="p_add">+static int st_gpio_irq_request_resources(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+</span>
<span class="p_add">+	st_gpio_direction_input(gc, d-&gt;hwirq);</span>
<span class="p_add">+</span>
<span class="p_add">+	return gpiochip_lock_as_irq(gc, d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void st_gpio_irq_release_resources(struct irq_data *d)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);</span>
<span class="p_add">+</span>
<span class="p_add">+	gpiochip_unlock_as_irq(gc, d-&gt;hwirq);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int st_gpio_irq_set_type(struct irq_data *d, unsigned type)
 {
 	struct gpio_chip *gc = irq_data_get_irq_chip_data(d);
<span class="p_chunk">@@ -1493,12 +1509,14 @@</span> <span class="p_context"> static struct gpio_chip st_gpio_template = {</span>
 };
 
 static struct irq_chip st_gpio_irqchip = {
<span class="p_del">-	.name		= &quot;GPIO&quot;,</span>
<span class="p_del">-	.irq_disable	= st_gpio_irq_mask,</span>
<span class="p_del">-	.irq_mask	= st_gpio_irq_mask,</span>
<span class="p_del">-	.irq_unmask	= st_gpio_irq_unmask,</span>
<span class="p_del">-	.irq_set_type	= st_gpio_irq_set_type,</span>
<span class="p_del">-	.flags		= IRQCHIP_SKIP_SET_WAKE,</span>
<span class="p_add">+	.name			= &quot;GPIO&quot;,</span>
<span class="p_add">+	.irq_request_resources	= st_gpio_irq_request_resources,</span>
<span class="p_add">+	.irq_release_resources	= st_gpio_irq_release_resources,</span>
<span class="p_add">+	.irq_disable		= st_gpio_irq_mask,</span>
<span class="p_add">+	.irq_mask		= st_gpio_irq_mask,</span>
<span class="p_add">+	.irq_unmask		= st_gpio_irq_unmask,</span>
<span class="p_add">+	.irq_set_type		= st_gpio_irq_set_type,</span>
<span class="p_add">+	.flags			= IRQCHIP_SKIP_SET_WAKE,</span>
 };
 
 static int st_gpiolib_register_bank(struct st_pinctrl *info,
<span class="p_header">diff --git a/drivers/rtc/interface.c b/drivers/rtc/interface.c</span>
<span class="p_header">index 9bb934ed2a7a..dcfd3655ef0a 100644</span>
<span class="p_header">--- a/drivers/rtc/interface.c</span>
<span class="p_header">+++ b/drivers/rtc/interface.c</span>
<span class="p_chunk">@@ -764,7 +764,7 @@</span> <span class="p_context"> static int rtc_timer_enqueue(struct rtc_device *rtc, struct rtc_timer *timer)</span>
 	}
 
 	timerqueue_add(&amp;rtc-&gt;timerqueue, &amp;timer-&gt;node);
<span class="p_del">-	if (!next) {</span>
<span class="p_add">+	if (!next || ktime_before(timer-&gt;node.expires, next-&gt;expires)) {</span>
 		struct rtc_wkalrm alarm;
 		int err;
 		alarm.time = rtc_ktime_to_tm(timer-&gt;node.expires);
<span class="p_header">diff --git a/drivers/rtc/rtc-pl031.c b/drivers/rtc/rtc-pl031.c</span>
<span class="p_header">index e1687e19c59f..a30f24cb6c83 100644</span>
<span class="p_header">--- a/drivers/rtc/rtc-pl031.c</span>
<span class="p_header">+++ b/drivers/rtc/rtc-pl031.c</span>
<span class="p_chunk">@@ -308,7 +308,8 @@</span> <span class="p_context"> static int pl031_remove(struct amba_device *adev)</span>
 
 	dev_pm_clear_wake_irq(&amp;adev-&gt;dev);
 	device_init_wakeup(&amp;adev-&gt;dev, false);
<span class="p_del">-	free_irq(adev-&gt;irq[0], ldata);</span>
<span class="p_add">+	if (adev-&gt;irq[0])</span>
<span class="p_add">+		free_irq(adev-&gt;irq[0], ldata);</span>
 	rtc_device_unregister(ldata-&gt;rtc);
 	iounmap(ldata-&gt;base);
 	kfree(ldata);
<span class="p_chunk">@@ -381,12 +382,13 @@</span> <span class="p_context"> static int pl031_probe(struct amba_device *adev, const struct amba_id *id)</span>
 		goto out_no_rtc;
 	}
 
<span class="p_del">-	if (request_irq(adev-&gt;irq[0], pl031_interrupt,</span>
<span class="p_del">-			vendor-&gt;irqflags, &quot;rtc-pl031&quot;, ldata)) {</span>
<span class="p_del">-		ret = -EIO;</span>
<span class="p_del">-		goto out_no_irq;</span>
<span class="p_add">+	if (adev-&gt;irq[0]) {</span>
<span class="p_add">+		ret = request_irq(adev-&gt;irq[0], pl031_interrupt,</span>
<span class="p_add">+				  vendor-&gt;irqflags, &quot;rtc-pl031&quot;, ldata);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out_no_irq;</span>
<span class="p_add">+		dev_pm_set_wake_irq(&amp;adev-&gt;dev, adev-&gt;irq[0]);</span>
 	}
<span class="p_del">-	dev_pm_set_wake_irq(&amp;adev-&gt;dev, adev-&gt;irq[0]);</span>
 	return 0;
 
 out_no_irq:
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">index bf3c1b2301db..0d6888cbd96e 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_chunk">@@ -2680,17 +2680,13 @@</span> <span class="p_context"> static void qeth_l3_fill_af_iucv_hdr(struct qeth_card *card,</span>
 	char daddr[16];
 	struct af_iucv_trans_hdr *iucv_hdr;
 
<span class="p_del">-	skb_pull(skb, 14);</span>
<span class="p_del">-	card-&gt;dev-&gt;header_ops-&gt;create(skb, card-&gt;dev, 0,</span>
<span class="p_del">-				      card-&gt;dev-&gt;dev_addr, card-&gt;dev-&gt;dev_addr,</span>
<span class="p_del">-				      card-&gt;dev-&gt;addr_len);</span>
<span class="p_del">-	skb_pull(skb, 14);</span>
<span class="p_del">-	iucv_hdr = (struct af_iucv_trans_hdr *)skb-&gt;data;</span>
 	memset(hdr, 0, sizeof(struct qeth_hdr));
 	hdr-&gt;hdr.l3.id = QETH_HEADER_TYPE_LAYER3;
 	hdr-&gt;hdr.l3.ext_flags = 0;
<span class="p_del">-	hdr-&gt;hdr.l3.length = skb-&gt;len;</span>
<span class="p_add">+	hdr-&gt;hdr.l3.length = skb-&gt;len - ETH_HLEN;</span>
 	hdr-&gt;hdr.l3.flags = QETH_HDR_IPV6 | QETH_CAST_UNICAST;
<span class="p_add">+</span>
<span class="p_add">+	iucv_hdr = (struct af_iucv_trans_hdr *) (skb-&gt;data + ETH_HLEN);</span>
 	memset(daddr, 0, sizeof(daddr));
 	daddr[0] = 0xfe;
 	daddr[1] = 0x80;
<span class="p_chunk">@@ -2873,10 +2869,7 @@</span> <span class="p_context"> static int qeth_l3_hard_start_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	if ((card-&gt;info.type == QETH_CARD_TYPE_IQD) &amp;&amp; (!large_send) &amp;&amp;
 	    (skb_shinfo(skb)-&gt;nr_frags == 0)) {
 		new_skb = skb;
<span class="p_del">-		if (new_skb-&gt;protocol == ETH_P_AF_IUCV)</span>
<span class="p_del">-			data_offset = 0;</span>
<span class="p_del">-		else</span>
<span class="p_del">-			data_offset = ETH_HLEN;</span>
<span class="p_add">+		data_offset = ETH_HLEN;</span>
 		hdr = kmem_cache_alloc(qeth_core_header_cache, GFP_ATOMIC);
 		if (!hdr)
 			goto tx_drop;
<span class="p_header">diff --git a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c</span>
<span class="p_header">index 804806e1cbb4..7a48905b8195 100644</span>
<span class="p_header">--- a/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c</span>
<span class="p_header">+++ b/drivers/scsi/cxgbi/cxgb4i/cxgb4i.c</span>
<span class="p_chunk">@@ -1339,6 +1339,7 @@</span> <span class="p_context"> static void release_offload_resources(struct cxgbi_sock *csk)</span>
 		csk, csk-&gt;state, csk-&gt;flags, csk-&gt;tid);
 
 	cxgbi_sock_free_cpl_skbs(csk);
<span class="p_add">+	cxgbi_sock_purge_write_queue(csk);</span>
 	if (csk-&gt;wr_cred != csk-&gt;wr_max_cred) {
 		cxgbi_sock_purge_wr_queue(csk);
 		cxgbi_sock_reset_wr_list(csk);
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_els.c b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">index fc8f9b446556..fd8fe1202dbe 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_els.c</span>
<span class="p_chunk">@@ -7491,7 +7491,8 @@</span> <span class="p_context"> lpfc_els_unsol_buffer(struct lpfc_hba *phba, struct lpfc_sli_ring *pring,</span>
 			did, vport-&gt;port_state, ndlp-&gt;nlp_flag);
 
 		phba-&gt;fc_stat.elsRcvPRLI++;
<span class="p_del">-		if (vport-&gt;port_state &lt; LPFC_DISC_AUTH) {</span>
<span class="p_add">+		if ((vport-&gt;port_state &lt; LPFC_DISC_AUTH) &amp;&amp;</span>
<span class="p_add">+		    (vport-&gt;fc_flag &amp; FC_FABRIC)) {</span>
 			rjt_err = LSRJT_UNABLE_TPC;
 			rjt_exp = LSEXP_NOTHING_MORE;
 			break;
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_hbadisc.c b/drivers/scsi/lpfc/lpfc_hbadisc.c</span>
<span class="p_header">index d3668aa555d5..be901f6db6d3 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_hbadisc.c</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_hbadisc.c</span>
<span class="p_chunk">@@ -4777,7 +4777,8 @@</span> <span class="p_context"> lpfc_nlp_remove(struct lpfc_vport *vport, struct lpfc_nodelist *ndlp)</span>
 	lpfc_cancel_retry_delay_tmo(vport, ndlp);
 	if ((ndlp-&gt;nlp_flag &amp; NLP_DEFER_RM) &amp;&amp;
 	    !(ndlp-&gt;nlp_flag &amp; NLP_REG_LOGIN_SEND) &amp;&amp;
<span class="p_del">-	    !(ndlp-&gt;nlp_flag &amp; NLP_RPI_REGISTERED)) {</span>
<span class="p_add">+	    !(ndlp-&gt;nlp_flag &amp; NLP_RPI_REGISTERED) &amp;&amp;</span>
<span class="p_add">+	    phba-&gt;sli_rev != LPFC_SLI_REV4) {</span>
 		/* For this case we need to cleanup the default rpi
 		 * allocated by the firmware.
 		 */
<span class="p_header">diff --git a/drivers/scsi/lpfc/lpfc_hw4.h b/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_header">index f224cdb2fce4..507869bc0673 100644</span>
<span class="p_header">--- a/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_header">+++ b/drivers/scsi/lpfc/lpfc_hw4.h</span>
<span class="p_chunk">@@ -3180,7 +3180,7 @@</span> <span class="p_context"> struct lpfc_mbx_get_port_name {</span>
 #define MB_CEQ_STATUS_QUEUE_FLUSHING		0x4
 #define MB_CQE_STATUS_DMA_FAILED		0x5
 
<span class="p_del">-#define LPFC_MBX_WR_CONFIG_MAX_BDE		8</span>
<span class="p_add">+#define LPFC_MBX_WR_CONFIG_MAX_BDE		1</span>
 struct lpfc_mbx_wr_object {
 	struct mbox_header header;
 	union {
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index e333029e4b6c..e111c3d8c5d6 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -4588,6 +4588,11 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 		} else if (log_info == VIRTUAL_IO_FAILED_RETRY) {
 			scmd-&gt;result = DID_RESET &lt;&lt; 16;
 			break;
<span class="p_add">+		} else if ((scmd-&gt;device-&gt;channel == RAID_CHANNEL) &amp;&amp;</span>
<span class="p_add">+		   (scsi_state == (MPI2_SCSI_STATE_TERMINATED |</span>
<span class="p_add">+		   MPI2_SCSI_STATE_NO_SCSI_STATUS))) {</span>
<span class="p_add">+			scmd-&gt;result = DID_RESET &lt;&lt; 16;</span>
<span class="p_add">+			break;</span>
 		}
 		scmd-&gt;result = DID_SOFT_ERROR &lt;&lt; 16;
 		break;
<span class="p_header">diff --git a/drivers/thermal/hisi_thermal.c b/drivers/thermal/hisi_thermal.c</span>
<span class="p_header">index 36d07295f8e3..a56f6cac6fc5 100644</span>
<span class="p_header">--- a/drivers/thermal/hisi_thermal.c</span>
<span class="p_header">+++ b/drivers/thermal/hisi_thermal.c</span>
<span class="p_chunk">@@ -389,8 +389,11 @@</span> <span class="p_context"> static int hisi_thermal_suspend(struct device *dev)</span>
 static int hisi_thermal_resume(struct device *dev)
 {
 	struct hisi_thermal_data *data = dev_get_drvdata(dev);
<span class="p_add">+	int ret;</span>
 
<span class="p_del">-	clk_prepare_enable(data-&gt;clk);</span>
<span class="p_add">+	ret = clk_prepare_enable(data-&gt;clk);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		return ret;</span>
 
 	data-&gt;irq_enabled = true;
 	hisi_thermal_enable_bind_irq_sensor(data);
<span class="p_header">diff --git a/drivers/usb/gadget/function/f_uvc.c b/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_header">index c7689d05356c..f8a1881609a2 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/function/f_uvc.c</span>
<span class="p_chunk">@@ -594,6 +594,14 @@</span> <span class="p_context"> uvc_function_bind(struct usb_configuration *c, struct usb_function *f)</span>
 	opts-&gt;streaming_maxpacket = clamp(opts-&gt;streaming_maxpacket, 1U, 3072U);
 	opts-&gt;streaming_maxburst = min(opts-&gt;streaming_maxburst, 15U);
 
<span class="p_add">+	/* For SS, wMaxPacketSize has to be 1024 if bMaxBurst is not 0 */</span>
<span class="p_add">+	if (opts-&gt;streaming_maxburst &amp;&amp;</span>
<span class="p_add">+	    (opts-&gt;streaming_maxpacket % 1024) != 0) {</span>
<span class="p_add">+		opts-&gt;streaming_maxpacket = roundup(opts-&gt;streaming_maxpacket, 1024);</span>
<span class="p_add">+		INFO(cdev, &quot;overriding streaming_maxpacket to %d\n&quot;,</span>
<span class="p_add">+		     opts-&gt;streaming_maxpacket);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* Fill in the FS/HS/SS Video Streaming specific descriptors from the
 	 * module parameters.
 	 *
<span class="p_header">diff --git a/drivers/usb/gadget/udc/pch_udc.c b/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_header">index 7a04157ff579..2806457b4748 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/pch_udc.c</span>
<span class="p_chunk">@@ -1534,7 +1534,6 @@</span> <span class="p_context"> static void pch_udc_free_dma_chain(struct pch_udc_dev *dev,</span>
 		td = phys_to_virt(addr);
 		addr2 = (dma_addr_t)td-&gt;next;
 		pci_pool_free(dev-&gt;data_requests, td, addr);
<span class="p_del">-		td-&gt;next = 0x00;</span>
 		addr = addr2;
 	}
 	req-&gt;chain_len = 1;
<span class="p_header">diff --git a/drivers/usb/host/xhci-plat.c b/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">index 062cf8a84a59..7afd607ea60f 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-plat.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-plat.c</span>
<span class="p_chunk">@@ -284,6 +284,7 @@</span> <span class="p_context"> MODULE_DEVICE_TABLE(acpi, usb_xhci_acpi_match);</span>
 static struct platform_driver usb_xhci_driver = {
 	.probe	= xhci_plat_probe,
 	.remove	= xhci_plat_remove,
<span class="p_add">+	.shutdown	= usb_hcd_platform_shutdown,</span>
 	.driver	= {
 		.name = &quot;xhci-hcd&quot;,
 		.pm = DEV_PM_OPS,
<span class="p_header">diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c</span>
<span class="p_header">index ae3c6b6fd5db..d0c79153081d 100644</span>
<span class="p_header">--- a/drivers/video/backlight/pwm_bl.c</span>
<span class="p_header">+++ b/drivers/video/backlight/pwm_bl.c</span>
<span class="p_chunk">@@ -79,14 +79,17 @@</span> <span class="p_context"> static void pwm_backlight_power_off(struct pwm_bl_data *pb)</span>
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness)
 {
 	unsigned int lth = pb-&gt;lth_brightness;
<span class="p_del">-	int duty_cycle;</span>
<span class="p_add">+	u64 duty_cycle;</span>
 
 	if (pb-&gt;levels)
 		duty_cycle = pb-&gt;levels[brightness];
 	else
 		duty_cycle = brightness;
 
<span class="p_del">-	return (duty_cycle * (pb-&gt;period - lth) / pb-&gt;scale) + lth;</span>
<span class="p_add">+	duty_cycle *= pb-&gt;period - lth;</span>
<span class="p_add">+	do_div(duty_cycle, pb-&gt;scale);</span>
<span class="p_add">+</span>
<span class="p_add">+	return duty_cycle + lth;</span>
 }
 
 static int pwm_backlight_update_status(struct backlight_device *bl)
<span class="p_header">diff --git a/include/linux/mmu_context.h b/include/linux/mmu_context.h</span>
<span class="p_header">index 70fffeba7495..a4441784503b 100644</span>
<span class="p_header">--- a/include/linux/mmu_context.h</span>
<span class="p_header">+++ b/include/linux/mmu_context.h</span>
<span class="p_chunk">@@ -1,9 +1,16 @@</span> <span class="p_context"></span>
 #ifndef _LINUX_MMU_CONTEXT_H
 #define _LINUX_MMU_CONTEXT_H
 
<span class="p_add">+#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+</span>
 struct mm_struct;
 
 void use_mm(struct mm_struct *mm);
 void unuse_mm(struct mm_struct *mm);
 
<span class="p_add">+/* Architectures that care about IRQ state in switch_mm can override this. */</span>
<span class="p_add">+#ifndef switch_mm_irqs_off</span>
<span class="p_add">+# define switch_mm_irqs_off switch_mm</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/kernel/sched/core.c b/kernel/sched/core.c</span>
<span class="p_header">index 15874a85ebcf..9d6b3d869592 100644</span>
<span class="p_header">--- a/kernel/sched/core.c</span>
<span class="p_header">+++ b/kernel/sched/core.c</span>
<span class="p_chunk">@@ -32,7 +32,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/init.h&gt;
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/highmem.h&gt;
<span class="p_del">-#include &lt;asm/mmu_context.h&gt;</span>
<span class="p_add">+#include &lt;linux/mmu_context.h&gt;</span>
 #include &lt;linux/interrupt.h&gt;
 #include &lt;linux/capability.h&gt;
 #include &lt;linux/completion.h&gt;
<span class="p_chunk">@@ -2708,7 +2708,7 @@</span> <span class="p_context"> context_switch(struct rq *rq, struct task_struct *prev,</span>
 		atomic_inc(&amp;oldmm-&gt;mm_count);
 		enter_lazy_tlb(oldmm, next);
 	} else
<span class="p_del">-		switch_mm(oldmm, mm, next);</span>
<span class="p_add">+		switch_mm_irqs_off(oldmm, mm, next);</span>
 
 	if (!prev-&gt;mm) {
 		prev-&gt;active_mm = NULL;
<span class="p_header">diff --git a/mm/mmu_context.c b/mm/mmu_context.c</span>
<span class="p_header">index f802c2d216a7..6f4d27c5bb32 100644</span>
<span class="p_header">--- a/mm/mmu_context.c</span>
<span class="p_header">+++ b/mm/mmu_context.c</span>
<span class="p_chunk">@@ -4,9 +4,9 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/mm.h&gt;
<span class="p_add">+#include &lt;linux/sched.h&gt;</span>
 #include &lt;linux/mmu_context.h&gt;
 #include &lt;linux/export.h&gt;
<span class="p_del">-#include &lt;linux/sched.h&gt;</span>
 
 #include &lt;asm/mmu_context.h&gt;
 
<span class="p_header">diff --git a/mm/rmap.c b/mm/rmap.c</span>
<span class="p_header">index ede183c32f45..1bceb49aa214 100644</span>
<span class="p_header">--- a/mm/rmap.c</span>
<span class="p_header">+++ b/mm/rmap.c</span>
<span class="p_chunk">@@ -587,19 +587,6 @@</span> <span class="p_context"> vma_address(struct page *page, struct vm_area_struct *vma)</span>
 }
 
 #ifdef CONFIG_ARCH_WANT_BATCHED_UNMAP_TLB_FLUSH
<span class="p_del">-static void percpu_flush_tlb_batch_pages(void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * All TLB entries are flushed on the assumption that it is</span>
<span class="p_del">-	 * cheaper to flush all TLBs and let them be refilled than</span>
<span class="p_del">-	 * flushing individual PFNs. Note that we do not track mm&#39;s</span>
<span class="p_del">-	 * to flush as that might simply be multiple full TLB flushes</span>
<span class="p_del">-	 * for no gain.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	count_vm_tlb_event(NR_TLB_REMOTE_FLUSH_RECEIVED);</span>
<span class="p_del">-	flush_tlb_local();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 /*
  * Flush TLB entries for recently unmapped pages from remote CPUs. It is
  * important if a PTE was dirty when it was unmapped that it&#39;s flushed
<span class="p_chunk">@@ -616,15 +603,14 @@</span> <span class="p_context"> void try_to_unmap_flush(void)</span>
 
 	cpu = get_cpu();
 
<span class="p_del">-	trace_tlb_flush(TLB_REMOTE_SHOOTDOWN, -1UL);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cpumask_test_cpu(cpu, &amp;tlb_ubc-&gt;cpumask))</span>
<span class="p_del">-		percpu_flush_tlb_batch_pages(&amp;tlb_ubc-&gt;cpumask);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cpumask_any_but(&amp;tlb_ubc-&gt;cpumask, cpu) &lt; nr_cpu_ids) {</span>
<span class="p_del">-		smp_call_function_many(&amp;tlb_ubc-&gt;cpumask,</span>
<span class="p_del">-			percpu_flush_tlb_batch_pages, (void *)tlb_ubc, true);</span>
<span class="p_add">+	if (cpumask_test_cpu(cpu, &amp;tlb_ubc-&gt;cpumask)) {</span>
<span class="p_add">+		count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);</span>
<span class="p_add">+		local_flush_tlb();</span>
<span class="p_add">+		trace_tlb_flush(TLB_LOCAL_SHOOTDOWN, TLB_FLUSH_ALL);</span>
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (cpumask_any_but(&amp;tlb_ubc-&gt;cpumask, cpu) &lt; nr_cpu_ids)</span>
<span class="p_add">+		flush_tlb_others(&amp;tlb_ubc-&gt;cpumask, NULL, 0, TLB_FLUSH_ALL);</span>
 	cpumask_clear(&amp;tlb_ubc-&gt;cpumask);
 	tlb_ubc-&gt;flush_required = false;
 	tlb_ubc-&gt;writable = false;
<span class="p_header">diff --git a/net/core/sysctl_net_core.c b/net/core/sysctl_net_core.c</span>
<span class="p_header">index a6beb7b6ae55..f5ef2115871f 100644</span>
<span class="p_header">--- a/net/core/sysctl_net_core.c</span>
<span class="p_header">+++ b/net/core/sysctl_net_core.c</span>
<span class="p_chunk">@@ -360,14 +360,16 @@</span> <span class="p_context"> static struct ctl_table net_core_table[] = {</span>
 		.data		= &amp;sysctl_net_busy_poll,
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;zero,</span>
 	},
 	{
 		.procname	= &quot;busy_read&quot;,
 		.data		= &amp;sysctl_net_busy_read,
 		.maxlen		= sizeof(unsigned int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;zero,</span>
 	},
 #endif
 #ifdef CONFIG_NET_SCHED
<span class="p_header">diff --git a/net/ipv4/ip_fragment.c b/net/ipv4/ip_fragment.c</span>
<span class="p_header">index e2e162432aa3..7057a1b09b5e 100644</span>
<span class="p_header">--- a/net/ipv4/ip_fragment.c</span>
<span class="p_header">+++ b/net/ipv4/ip_fragment.c</span>
<span class="p_chunk">@@ -200,6 +200,7 @@</span> <span class="p_context"> static void ip_expire(unsigned long arg)</span>
 	qp = container_of((struct inet_frag_queue *) arg, struct ipq, q);
 	net = container_of(qp-&gt;q.net, struct net, ipv4.frags);
 
<span class="p_add">+	rcu_read_lock();</span>
 	spin_lock(&amp;qp-&gt;q.lock);
 
 	if (qp-&gt;q.flags &amp; INET_FRAG_COMPLETE)
<span class="p_chunk">@@ -209,7 +210,7 @@</span> <span class="p_context"> static void ip_expire(unsigned long arg)</span>
 	IP_INC_STATS_BH(net, IPSTATS_MIB_REASMFAILS);
 
 	if (!inet_frag_evicting(&amp;qp-&gt;q)) {
<span class="p_del">-		struct sk_buff *head = qp-&gt;q.fragments;</span>
<span class="p_add">+		struct sk_buff *clone, *head = qp-&gt;q.fragments;</span>
 		const struct iphdr *iph;
 		int err;
 
<span class="p_chunk">@@ -218,32 +219,40 @@</span> <span class="p_context"> static void ip_expire(unsigned long arg)</span>
 		if (!(qp-&gt;q.flags &amp; INET_FRAG_FIRST_IN) || !qp-&gt;q.fragments)
 			goto out;
 
<span class="p_del">-		rcu_read_lock();</span>
 		head-&gt;dev = dev_get_by_index_rcu(net, qp-&gt;iif);
 		if (!head-&gt;dev)
<span class="p_del">-			goto out_rcu_unlock;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
 
 		/* skb has no dst, perform route lookup again */
 		iph = ip_hdr(head);
 		err = ip_route_input_noref(head, iph-&gt;daddr, iph-&gt;saddr,
 					   iph-&gt;tos, head-&gt;dev);
 		if (err)
<span class="p_del">-			goto out_rcu_unlock;</span>
<span class="p_add">+			goto out;</span>
 
 		/* Only an end host needs to send an ICMP
 		 * &quot;Fragment Reassembly Timeout&quot; message, per RFC792.
 		 */
 		if (frag_expire_skip_icmp(qp-&gt;user) &amp;&amp;
 		    (skb_rtable(head)-&gt;rt_type != RTN_LOCAL))
<span class="p_del">-			goto out_rcu_unlock;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+		clone = skb_clone(head, GFP_ATOMIC);</span>
 
 		/* Send an ICMP &quot;Fragment Reassembly Timeout&quot; message. */
<span class="p_del">-		icmp_send(head, ICMP_TIME_EXCEEDED, ICMP_EXC_FRAGTIME, 0);</span>
<span class="p_del">-out_rcu_unlock:</span>
<span class="p_del">-		rcu_read_unlock();</span>
<span class="p_add">+		if (clone) {</span>
<span class="p_add">+			spin_unlock(&amp;qp-&gt;q.lock);</span>
<span class="p_add">+			icmp_send(clone, ICMP_TIME_EXCEEDED,</span>
<span class="p_add">+				  ICMP_EXC_FRAGTIME, 0);</span>
<span class="p_add">+			consume_skb(clone);</span>
<span class="p_add">+			goto out_rcu_unlock;</span>
<span class="p_add">+		}</span>
 	}
 out:
 	spin_unlock(&amp;qp-&gt;q.lock);
<span class="p_add">+out_rcu_unlock:</span>
<span class="p_add">+	rcu_read_unlock();</span>
 	ipq_put(qp);
 }
 
<span class="p_header">diff --git a/net/ipv4/netfilter/nf_nat_snmp_basic.c b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">index 2689c9c4f1a0..182eb878633d 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/nf_nat_snmp_basic.c</span>
<span class="p_chunk">@@ -1260,16 +1260,6 @@</span> <span class="p_context"> static const struct nf_conntrack_expect_policy snmp_exp_policy = {</span>
 	.timeout	= 180,
 };
 
<span class="p_del">-static struct nf_conntrack_helper snmp_helper __read_mostly = {</span>
<span class="p_del">-	.me			= THIS_MODULE,</span>
<span class="p_del">-	.help			= help,</span>
<span class="p_del">-	.expect_policy		= &amp;snmp_exp_policy,</span>
<span class="p_del">-	.name			= &quot;snmp&quot;,</span>
<span class="p_del">-	.tuple.src.l3num	= AF_INET,</span>
<span class="p_del">-	.tuple.src.u.udp.port	= cpu_to_be16(SNMP_PORT),</span>
<span class="p_del">-	.tuple.dst.protonum	= IPPROTO_UDP,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 static struct nf_conntrack_helper snmp_trap_helper __read_mostly = {
 	.me			= THIS_MODULE,
 	.help			= help,
<span class="p_chunk">@@ -1288,17 +1278,10 @@</span> <span class="p_context"> static struct nf_conntrack_helper snmp_trap_helper __read_mostly = {</span>
 
 static int __init nf_nat_snmp_basic_init(void)
 {
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
 	BUG_ON(nf_nat_snmp_hook != NULL);
 	RCU_INIT_POINTER(nf_nat_snmp_hook, help);
 
<span class="p_del">-	ret = nf_conntrack_helper_register(&amp;snmp_trap_helper);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		nf_conntrack_helper_unregister(&amp;snmp_helper);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return nf_conntrack_helper_register(&amp;snmp_trap_helper);</span>
 }
 
 static void __exit nf_nat_snmp_basic_fini(void)
<span class="p_header">diff --git a/net/ipv4/tcp_vegas.c b/net/ipv4/tcp_vegas.c</span>
<span class="p_header">index 13951c4087d4..b9fac0522be6 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_vegas.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_vegas.c</span>
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(tcp_vegas_cwnd_event);</span>
 
 static inline u32 tcp_vegas_ssthresh(struct tcp_sock *tp)
 {
<span class="p_del">-	return  min(tp-&gt;snd_ssthresh, tp-&gt;snd_cwnd-1);</span>
<span class="p_add">+	return  min(tp-&gt;snd_ssthresh, tp-&gt;snd_cwnd);</span>
 }
 
 static void tcp_vegas_cong_avoid(struct sock *sk, u32 ack, u32 acked)
<span class="p_header">diff --git a/net/netfilter/nfnetlink_cthelper.c b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">index 6d10002d23f8..8d34a488efc0 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_cthelper.c</span>
<span class="p_chunk">@@ -32,6 +32,13 @@</span> <span class="p_context"> MODULE_LICENSE(&quot;GPL&quot;);</span>
 MODULE_AUTHOR(&quot;Pablo Neira Ayuso &lt;pablo@netfilter.org&gt;&quot;);
 MODULE_DESCRIPTION(&quot;nfnl_cthelper: User-space connection tracking helpers&quot;);
 
<span class="p_add">+struct nfnl_cthelper {</span>
<span class="p_add">+	struct list_head		list;</span>
<span class="p_add">+	struct nf_conntrack_helper	helper;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static LIST_HEAD(nfnl_cthelper_list);</span>
<span class="p_add">+</span>
 static int
 nfnl_userspace_cthelper(struct sk_buff *skb, unsigned int protoff,
 			struct nf_conn *ct, enum ip_conntrack_info ctinfo)
<span class="p_chunk">@@ -205,18 +212,20 @@</span> <span class="p_context"> nfnl_cthelper_create(const struct nlattr * const tb[],</span>
 		     struct nf_conntrack_tuple *tuple)
 {
 	struct nf_conntrack_helper *helper;
<span class="p_add">+	struct nfnl_cthelper *nfcth;</span>
 	int ret;
 
 	if (!tb[NFCTH_TUPLE] || !tb[NFCTH_POLICY] || !tb[NFCTH_PRIV_DATA_LEN])
 		return -EINVAL;
 
<span class="p_del">-	helper = kzalloc(sizeof(struct nf_conntrack_helper), GFP_KERNEL);</span>
<span class="p_del">-	if (helper == NULL)</span>
<span class="p_add">+	nfcth = kzalloc(sizeof(*nfcth), GFP_KERNEL);</span>
<span class="p_add">+	if (nfcth == NULL)</span>
 		return -ENOMEM;
<span class="p_add">+	helper = &amp;nfcth-&gt;helper;</span>
 
 	ret = nfnl_cthelper_parse_expect_policy(helper, tb[NFCTH_POLICY]);
 	if (ret &lt; 0)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto err1;</span>
 
 	strncpy(helper-&gt;name, nla_data(tb[NFCTH_NAME]), NF_CT_HELPER_NAME_LEN);
 	helper-&gt;data_len = ntohl(nla_get_be32(tb[NFCTH_PRIV_DATA_LEN]));
<span class="p_chunk">@@ -247,14 +256,100 @@</span> <span class="p_context"> nfnl_cthelper_create(const struct nlattr * const tb[],</span>
 
 	ret = nf_conntrack_helper_register(helper);
 	if (ret &lt; 0)
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto err2;</span>
 
<span class="p_add">+	list_add_tail(&amp;nfcth-&gt;list, &amp;nfnl_cthelper_list);</span>
 	return 0;
<span class="p_del">-err:</span>
<span class="p_del">-	kfree(helper);</span>
<span class="p_add">+err2:</span>
<span class="p_add">+	kfree(helper-&gt;expect_policy);</span>
<span class="p_add">+err1:</span>
<span class="p_add">+	kfree(nfcth);</span>
 	return ret;
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+nfnl_cthelper_update_policy_one(const struct nf_conntrack_expect_policy *policy,</span>
<span class="p_add">+				struct nf_conntrack_expect_policy *new_policy,</span>
<span class="p_add">+				const struct nlattr *attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nlattr *tb[NFCTH_POLICY_MAX + 1];</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = nla_parse_nested(tb, NFCTH_POLICY_MAX, attr,</span>
<span class="p_add">+			       nfnl_cthelper_expect_pol);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tb[NFCTH_POLICY_NAME] ||</span>
<span class="p_add">+	    !tb[NFCTH_POLICY_EXPECT_MAX] ||</span>
<span class="p_add">+	    !tb[NFCTH_POLICY_EXPECT_TIMEOUT])</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (nla_strcmp(tb[NFCTH_POLICY_NAME], policy-&gt;name))</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_policy-&gt;max_expected =</span>
<span class="p_add">+		ntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_MAX]));</span>
<span class="p_add">+	new_policy-&gt;timeout =</span>
<span class="p_add">+		ntohl(nla_get_be32(tb[NFCTH_POLICY_EXPECT_TIMEOUT]));</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int nfnl_cthelper_update_policy_all(struct nlattr *tb[],</span>
<span class="p_add">+					   struct nf_conntrack_helper *helper)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nf_conntrack_expect_policy new_policy[helper-&gt;expect_class_max + 1];</span>
<span class="p_add">+	struct nf_conntrack_expect_policy *policy;</span>
<span class="p_add">+	int i, err;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Check first that all policy attributes are well-formed, so we don&#39;t</span>
<span class="p_add">+	 * leave things in inconsistent state on errors.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 0; i &lt; helper-&gt;expect_class_max + 1; i++) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!tb[NFCTH_POLICY_SET + i])</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		err = nfnl_cthelper_update_policy_one(&amp;helper-&gt;expect_policy[i],</span>
<span class="p_add">+						      &amp;new_policy[i],</span>
<span class="p_add">+						      tb[NFCTH_POLICY_SET + i]);</span>
<span class="p_add">+		if (err &lt; 0)</span>
<span class="p_add">+			return err;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/* Now we can safely update them. */</span>
<span class="p_add">+	for (i = 0; i &lt; helper-&gt;expect_class_max + 1; i++) {</span>
<span class="p_add">+		policy = (struct nf_conntrack_expect_policy *)</span>
<span class="p_add">+				&amp;helper-&gt;expect_policy[i];</span>
<span class="p_add">+		policy-&gt;max_expected = new_policy-&gt;max_expected;</span>
<span class="p_add">+		policy-&gt;timeout	= new_policy-&gt;timeout;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int nfnl_cthelper_update_policy(struct nf_conntrack_helper *helper,</span>
<span class="p_add">+				       const struct nlattr *attr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct nlattr *tb[NFCTH_POLICY_SET_MAX + 1];</span>
<span class="p_add">+	unsigned int class_max;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = nla_parse_nested(tb, NFCTH_POLICY_SET_MAX, attr,</span>
<span class="p_add">+			       nfnl_cthelper_expect_policy_set);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!tb[NFCTH_POLICY_SET_NUM])</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	class_max = ntohl(nla_get_be32(tb[NFCTH_POLICY_SET_NUM]));</span>
<span class="p_add">+	if (helper-&gt;expect_class_max + 1 != class_max)</span>
<span class="p_add">+		return -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+	return nfnl_cthelper_update_policy_all(tb, helper);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int
 nfnl_cthelper_update(const struct nlattr * const tb[],
 		     struct nf_conntrack_helper *helper)
<span class="p_chunk">@@ -265,8 +360,7 @@</span> <span class="p_context"> nfnl_cthelper_update(const struct nlattr * const tb[],</span>
 		return -EBUSY;
 
 	if (tb[NFCTH_POLICY]) {
<span class="p_del">-		ret = nfnl_cthelper_parse_expect_policy(helper,</span>
<span class="p_del">-							tb[NFCTH_POLICY]);</span>
<span class="p_add">+		ret = nfnl_cthelper_update_policy(helper, tb[NFCTH_POLICY]);</span>
 		if (ret &lt; 0)
 			return ret;
 	}
<span class="p_chunk">@@ -295,7 +389,8 @@</span> <span class="p_context"> nfnl_cthelper_new(struct sock *nfnl, struct sk_buff *skb,</span>
 	const char *helper_name;
 	struct nf_conntrack_helper *cur, *helper = NULL;
 	struct nf_conntrack_tuple tuple;
<span class="p_del">-	int ret = 0, i;</span>
<span class="p_add">+	struct nfnl_cthelper *nlcth;</span>
<span class="p_add">+	int ret = 0;</span>
 
 	if (!tb[NFCTH_NAME] || !tb[NFCTH_TUPLE])
 		return -EINVAL;
<span class="p_chunk">@@ -306,31 +401,22 @@</span> <span class="p_context"> nfnl_cthelper_new(struct sock *nfnl, struct sk_buff *skb,</span>
 	if (ret &lt; 0)
 		return ret;
 
<span class="p_del">-	rcu_read_lock();</span>
<span class="p_del">-	for (i = 0; i &lt; nf_ct_helper_hsize &amp;&amp; !helper; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_rcu(cur, &amp;nf_ct_helper_hash[i], hnode) {</span>
<span class="p_add">+	list_for_each_entry(nlcth, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
 
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (strncmp(cur-&gt;name, helper_name, NF_CT_HELPER_NAME_LEN))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if (strncmp(cur-&gt;name, helper_name,</span>
<span class="p_del">-					NF_CT_HELPER_NAME_LEN) != 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if ((tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_add">+		     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if ((tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_del">-			     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL)</span>
<span class="p_add">+			return -EEXIST;</span>
 
<span class="p_del">-			if (nlh-&gt;nlmsg_flags &amp; NLM_F_EXCL) {</span>
<span class="p_del">-				ret = -EEXIST;</span>
<span class="p_del">-				goto err;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			helper = cur;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		helper = cur;</span>
<span class="p_add">+		break;</span>
 	}
<span class="p_del">-	rcu_read_unlock();</span>
 
 	if (helper == NULL)
 		ret = nfnl_cthelper_create(tb, &amp;tuple);
<span class="p_chunk">@@ -338,9 +424,6 @@</span> <span class="p_context"> nfnl_cthelper_new(struct sock *nfnl, struct sk_buff *skb,</span>
 		ret = nfnl_cthelper_update(tb, helper);
 
 	return ret;
<span class="p_del">-err:</span>
<span class="p_del">-	rcu_read_unlock();</span>
<span class="p_del">-	return ret;</span>
 }
 
 static int
<span class="p_chunk">@@ -504,11 +587,12 @@</span> <span class="p_context"> static int</span>
 nfnl_cthelper_get(struct sock *nfnl, struct sk_buff *skb,
 		  const struct nlmsghdr *nlh, const struct nlattr * const tb[])
 {
<span class="p_del">-	int ret = -ENOENT, i;</span>
<span class="p_add">+	int ret = -ENOENT;</span>
 	struct nf_conntrack_helper *cur;
 	struct sk_buff *skb2;
 	char *helper_name = NULL;
 	struct nf_conntrack_tuple tuple;
<span class="p_add">+	struct nfnl_cthelper *nlcth;</span>
 	bool tuple_set = false;
 
 	if (nlh-&gt;nlmsg_flags &amp; NLM_F_DUMP) {
<span class="p_chunk">@@ -529,45 +613,39 @@</span> <span class="p_context"> nfnl_cthelper_get(struct sock *nfnl, struct sk_buff *skb,</span>
 		tuple_set = true;
 	}
 
<span class="p_del">-	for (i = 0; i &lt; nf_ct_helper_hsize; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_rcu(cur, &amp;nf_ct_helper_hash[i], hnode) {</span>
<span class="p_add">+	list_for_each_entry(nlcth, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
<span class="p_add">+		if (helper_name &amp;&amp;</span>
<span class="p_add">+		    strncmp(cur-&gt;name, helper_name, NF_CT_HELPER_NAME_LEN))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (tuple_set &amp;&amp;</span>
<span class="p_add">+		    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_add">+		     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if (helper_name &amp;&amp; strncmp(cur-&gt;name, helper_name,</span>
<span class="p_del">-						NF_CT_HELPER_NAME_LEN) != 0) {</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (tuple_set &amp;&amp;</span>
<span class="p_del">-			    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_del">-			     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-</span>
<span class="p_del">-			skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);</span>
<span class="p_del">-			if (skb2 == NULL) {</span>
<span class="p_del">-				ret = -ENOMEM;</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		skb2 = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		if (skb2 == NULL) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-			ret = nfnl_cthelper_fill_info(skb2, NETLINK_CB(skb).portid,</span>
<span class="p_del">-						nlh-&gt;nlmsg_seq,</span>
<span class="p_del">-						NFNL_MSG_TYPE(nlh-&gt;nlmsg_type),</span>
<span class="p_del">-						NFNL_MSG_CTHELPER_NEW, cur);</span>
<span class="p_del">-			if (ret &lt;= 0) {</span>
<span class="p_del">-				kfree_skb(skb2);</span>
<span class="p_del">-				break;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		ret = nfnl_cthelper_fill_info(skb2, NETLINK_CB(skb).portid,</span>
<span class="p_add">+					      nlh-&gt;nlmsg_seq,</span>
<span class="p_add">+					      NFNL_MSG_TYPE(nlh-&gt;nlmsg_type),</span>
<span class="p_add">+					      NFNL_MSG_CTHELPER_NEW, cur);</span>
<span class="p_add">+		if (ret &lt;= 0) {</span>
<span class="p_add">+			kfree_skb(skb2);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-			ret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,</span>
<span class="p_del">-						MSG_DONTWAIT);</span>
<span class="p_del">-			if (ret &gt; 0)</span>
<span class="p_del">-				ret = 0;</span>
<span class="p_add">+		ret = netlink_unicast(nfnl, skb2, NETLINK_CB(skb).portid,</span>
<span class="p_add">+				      MSG_DONTWAIT);</span>
<span class="p_add">+		if (ret &gt; 0)</span>
<span class="p_add">+			ret = 0;</span>
 
<span class="p_del">-			/* this avoids a loop in nfnetlink. */</span>
<span class="p_del">-			return ret == -EAGAIN ? -ENOBUFS : ret;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		/* this avoids a loop in nfnetlink. */</span>
<span class="p_add">+		return ret == -EAGAIN ? -ENOBUFS : ret;</span>
 	}
 	return ret;
 }
<span class="p_chunk">@@ -578,10 +656,10 @@</span> <span class="p_context"> nfnl_cthelper_del(struct sock *nfnl, struct sk_buff *skb,</span>
 {
 	char *helper_name = NULL;
 	struct nf_conntrack_helper *cur;
<span class="p_del">-	struct hlist_node *tmp;</span>
 	struct nf_conntrack_tuple tuple;
 	bool tuple_set = false, found = false;
<span class="p_del">-	int i, j = 0, ret;</span>
<span class="p_add">+	struct nfnl_cthelper *nlcth, *n;</span>
<span class="p_add">+	int j = 0, ret;</span>
 
 	if (tb[NFCTH_NAME])
 		helper_name = nla_data(tb[NFCTH_NAME]);
<span class="p_chunk">@@ -594,28 +672,27 @@</span> <span class="p_context"> nfnl_cthelper_del(struct sock *nfnl, struct sk_buff *skb,</span>
 		tuple_set = true;
 	}
 
<span class="p_del">-	for (i = 0; i &lt; nf_ct_helper_hsize; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_safe(cur, tmp, &amp;nf_ct_helper_hash[i],</span>
<span class="p_del">-								hnode) {</span>
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+	list_for_each_entry_safe(nlcth, n, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
<span class="p_add">+		j++;</span>
 
<span class="p_del">-			j++;</span>
<span class="p_add">+		if (helper_name &amp;&amp;</span>
<span class="p_add">+		    strncmp(cur-&gt;name, helper_name, NF_CT_HELPER_NAME_LEN))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			if (helper_name &amp;&amp; strncmp(cur-&gt;name, helper_name,</span>
<span class="p_del">-						NF_CT_HELPER_NAME_LEN) != 0) {</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			}</span>
<span class="p_del">-			if (tuple_set &amp;&amp;</span>
<span class="p_del">-			    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_del">-			     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+		if (tuple_set &amp;&amp;</span>
<span class="p_add">+		    (tuple.src.l3num != cur-&gt;tuple.src.l3num ||</span>
<span class="p_add">+		     tuple.dst.protonum != cur-&gt;tuple.dst.protonum))</span>
<span class="p_add">+			continue;</span>
 
<span class="p_del">-			found = true;</span>
<span class="p_del">-			nf_conntrack_helper_unregister(cur);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		found = true;</span>
<span class="p_add">+		nf_conntrack_helper_unregister(cur);</span>
<span class="p_add">+		kfree(cur-&gt;expect_policy);</span>
<span class="p_add">+</span>
<span class="p_add">+		list_del(&amp;nlcth-&gt;list);</span>
<span class="p_add">+		kfree(nlcth);</span>
 	}
<span class="p_add">+</span>
 	/* Make sure we return success if we flush and there is no helpers */
 	return (found || j == 0) ? 0 : -ENOENT;
 }
<span class="p_chunk">@@ -664,20 +741,16 @@</span> <span class="p_context"> err_out:</span>
 static void __exit nfnl_cthelper_exit(void)
 {
 	struct nf_conntrack_helper *cur;
<span class="p_del">-	struct hlist_node *tmp;</span>
<span class="p_del">-	int i;</span>
<span class="p_add">+	struct nfnl_cthelper *nlcth, *n;</span>
 
 	nfnetlink_subsys_unregister(&amp;nfnl_cthelper_subsys);
 
<span class="p_del">-	for (i=0; i&lt;nf_ct_helper_hsize; i++) {</span>
<span class="p_del">-		hlist_for_each_entry_safe(cur, tmp, &amp;nf_ct_helper_hash[i],</span>
<span class="p_del">-									hnode) {</span>
<span class="p_del">-			/* skip non-userspace conntrack helpers. */</span>
<span class="p_del">-			if (!(cur-&gt;flags &amp; NF_CT_HELPER_F_USERSPACE))</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+	list_for_each_entry_safe(nlcth, n, &amp;nfnl_cthelper_list, list) {</span>
<span class="p_add">+		cur = &amp;nlcth-&gt;helper;</span>
 
<span class="p_del">-			nf_conntrack_helper_unregister(cur);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		nf_conntrack_helper_unregister(cur);</span>
<span class="p_add">+		kfree(cur-&gt;expect_policy);</span>
<span class="p_add">+		kfree(nlcth);</span>
 	}
 }
 
<span class="p_header">diff --git a/net/netfilter/nfnetlink_queue.c b/net/netfilter/nfnetlink_queue.c</span>
<span class="p_header">index 861c6615253b..f6837f9b6d6c 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink_queue.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink_queue.c</span>
<span class="p_chunk">@@ -390,7 +390,7 @@</span> <span class="p_context"> nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,</span>
 				  GFP_ATOMIC);
 	if (!skb) {
 		skb_tx_error(entskb);
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		goto nlmsg_failure;</span>
 	}
 
 	nlh = nlmsg_put(skb, 0, 0,
<span class="p_chunk">@@ -399,7 +399,7 @@</span> <span class="p_context"> nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,</span>
 	if (!nlh) {
 		skb_tx_error(entskb);
 		kfree_skb(skb);
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		goto nlmsg_failure;</span>
 	}
 	nfmsg = nlmsg_data(nlh);
 	nfmsg-&gt;nfgen_family = entry-&gt;state.pf;
<span class="p_chunk">@@ -542,12 +542,17 @@</span> <span class="p_context"> nfqnl_build_packet_message(struct net *net, struct nfqnl_instance *queue,</span>
 	}
 
 	nlh-&gt;nlmsg_len = skb-&gt;len;
<span class="p_add">+	if (seclen)</span>
<span class="p_add">+		security_release_secctx(secdata, seclen);</span>
 	return skb;
 
 nla_put_failure:
 	skb_tx_error(entskb);
 	kfree_skb(skb);
 	net_err_ratelimited(&quot;nf_queue: error creating packet message\n&quot;);
<span class="p_add">+nlmsg_failure:</span>
<span class="p_add">+	if (seclen)</span>
<span class="p_add">+		security_release_secctx(secdata, seclen);</span>
 	return NULL;
 }
 
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index a87afc4f3c91..5fabe68e20dd 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -96,6 +96,44 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(nl_table);</span>
 
 static DECLARE_WAIT_QUEUE_HEAD(nl_table_wait);
 
<span class="p_add">+static struct lock_class_key nlk_cb_mutex_keys[MAX_LINKS];</span>
<span class="p_add">+</span>
<span class="p_add">+static const char *const nlk_cb_mutex_key_strings[MAX_LINKS + 1] = {</span>
<span class="p_add">+	&quot;nlk_cb_mutex-ROUTE&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-1&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-USERSOCK&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-FIREWALL&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SOCK_DIAG&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-NFLOG&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-XFRM&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SELINUX&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-ISCSI&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-AUDIT&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-FIB_LOOKUP&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-CONNECTOR&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-NETFILTER&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-IP6_FW&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-DNRTMSG&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-KOBJECT_UEVENT&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-GENERIC&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-17&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SCSITRANSPORT&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-ECRYPTFS&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-RDMA&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-CRYPTO&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-SMC&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-23&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-24&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-25&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-26&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-27&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-28&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-29&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-30&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-31&quot;,</span>
<span class="p_add">+	&quot;nlk_cb_mutex-MAX_LINKS&quot;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int netlink_dump(struct sock *sk);
 static void netlink_skb_destructor(struct sk_buff *skb);
 
<span class="p_chunk">@@ -585,6 +623,9 @@</span> <span class="p_context"> static int __netlink_create(struct net *net, struct socket *sock,</span>
 	} else {
 		nlk-&gt;cb_mutex = &amp;nlk-&gt;cb_def_mutex;
 		mutex_init(nlk-&gt;cb_mutex);
<span class="p_add">+		lockdep_set_class_and_name(nlk-&gt;cb_mutex,</span>
<span class="p_add">+					   nlk_cb_mutex_keys + protocol,</span>
<span class="p_add">+					   nlk_cb_mutex_key_strings[protocol]);</span>
 	}
 	init_waitqueue_head(&amp;nlk-&gt;wait);
 
<span class="p_header">diff --git a/net/sched/sch_dsmark.c b/net/sched/sch_dsmark.c</span>
<span class="p_header">index d0dff0cd8186..cce4e6ada7fa 100644</span>
<span class="p_header">--- a/net/sched/sch_dsmark.c</span>
<span class="p_header">+++ b/net/sched/sch_dsmark.c</span>
<span class="p_chunk">@@ -199,9 +199,13 @@</span> <span class="p_context"> static int dsmark_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 	pr_debug(&quot;%s(skb %p,sch %p,[qdisc %p])\n&quot;, __func__, skb, sch, p);
 
 	if (p-&gt;set_tc_index) {
<span class="p_add">+		int wlen = skb_network_offset(skb);</span>
<span class="p_add">+</span>
 		switch (tc_skb_protocol(skb)) {
 		case htons(ETH_P_IP):
<span class="p_del">-			if (skb_cow_head(skb, sizeof(struct iphdr)))</span>
<span class="p_add">+			wlen += sizeof(struct iphdr);</span>
<span class="p_add">+			if (!pskb_may_pull(skb, wlen) ||</span>
<span class="p_add">+			    skb_try_make_writable(skb, wlen))</span>
 				goto drop;
 
 			skb-&gt;tc_index = ipv4_get_dsfield(ip_hdr(skb))
<span class="p_chunk">@@ -209,7 +213,9 @@</span> <span class="p_context"> static int dsmark_enqueue(struct sk_buff *skb, struct Qdisc *sch)</span>
 			break;
 
 		case htons(ETH_P_IPV6):
<span class="p_del">-			if (skb_cow_head(skb, sizeof(struct ipv6hdr)))</span>
<span class="p_add">+			wlen += sizeof(struct ipv6hdr);</span>
<span class="p_add">+			if (!pskb_may_pull(skb, wlen) ||</span>
<span class="p_add">+			    skb_try_make_writable(skb, wlen))</span>
 				goto drop;
 
 			skb-&gt;tc_index = ipv6_get_dsfield(ipv6_hdr(skb))
<span class="p_header">diff --git a/sound/hda/hdac_i915.c b/sound/hda/hdac_i915.c</span>
<span class="p_header">index 8fef1b8d1fd8..cce9ae5ec93b 100644</span>
<span class="p_header">--- a/sound/hda/hdac_i915.c</span>
<span class="p_header">+++ b/sound/hda/hdac_i915.c</span>
<span class="p_chunk">@@ -240,7 +240,8 @@</span> <span class="p_context"> out_master_del:</span>
 out_err:
 	kfree(acomp);
 	bus-&gt;audio_component = NULL;
<span class="p_del">-	dev_err(dev, &quot;failed to add i915 component master (%d)\n&quot;, ret);</span>
<span class="p_add">+	hdac_acomp = NULL;</span>
<span class="p_add">+	dev_info(dev, &quot;failed to add i915 component master (%d)\n&quot;, ret);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -273,6 +274,7 @@</span> <span class="p_context"> int snd_hdac_i915_exit(struct hdac_bus *bus)</span>
 
 	kfree(acomp);
 	bus-&gt;audio_component = NULL;
<span class="p_add">+	hdac_acomp = NULL;</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index e2e08fc73b50..20512fe32a97 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -2088,9 +2088,11 @@</span> <span class="p_context"> static int azx_probe_continue(struct azx *chip)</span>
 			 * for other chips, still continue probing as other
 			 * codecs can be on the same link.
 			 */
<span class="p_del">-			if (CONTROLLER_IN_GPU(pci))</span>
<span class="p_add">+			if (CONTROLLER_IN_GPU(pci)) {</span>
<span class="p_add">+				dev_err(chip-&gt;card-&gt;dev,</span>
<span class="p_add">+					&quot;HSW/BDW HD-audio HDMI/DP requires binding with gfx driver\n&quot;);</span>
 				goto out_free;
<span class="p_del">-			else</span>
<span class="p_add">+			} else</span>
 				goto skip_i915;
 		}
 
<span class="p_header">diff --git a/sound/pci/hda/patch_conexant.c b/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">index ac5de4365e15..c92b7ba344ef 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_conexant.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_conexant.c</span>
<span class="p_chunk">@@ -261,6 +261,7 @@</span> <span class="p_context"> enum {</span>
 	CXT_FIXUP_HP_530,
 	CXT_FIXUP_CAP_MIX_AMP_5047,
 	CXT_FIXUP_MUTE_LED_EAPD,
<span class="p_add">+	CXT_FIXUP_HP_DOCK,</span>
 	CXT_FIXUP_HP_SPECTRE,
 	CXT_FIXUP_HP_GATE_MIC,
 };
<span class="p_chunk">@@ -778,6 +779,14 @@</span> <span class="p_context"> static const struct hda_fixup cxt_fixups[] = {</span>
 		.type = HDA_FIXUP_FUNC,
 		.v.func = cxt_fixup_mute_led_eapd,
 	},
<span class="p_add">+	[CXT_FIXUP_HP_DOCK] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x16, 0x21011020 }, /* line-out */</span>
<span class="p_add">+			{ 0x18, 0x2181103f }, /* line-in */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
 	[CXT_FIXUP_HP_SPECTRE] = {
 		.type = HDA_FIXUP_PINS,
 		.v.pins = (const struct hda_pintbl[]) {
<span class="p_chunk">@@ -839,6 +848,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk cxt5066_fixups[] = {</span>
 	SND_PCI_QUIRK(0x1025, 0x0543, &quot;Acer Aspire One 522&quot;, CXT_FIXUP_STEREO_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054c, &quot;Acer Aspire 3830TG&quot;, CXT_FIXUP_ASPIRE_DMIC),
 	SND_PCI_QUIRK(0x1025, 0x054f, &quot;Acer Aspire 4830T&quot;, CXT_FIXUP_ASPIRE_DMIC),
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x8079, &quot;HP EliteBook 840 G3&quot;, CXT_FIXUP_HP_DOCK),</span>
 	SND_PCI_QUIRK(0x103c, 0x8174, &quot;HP Spectre x360&quot;, CXT_FIXUP_HP_SPECTRE),
 	SND_PCI_QUIRK(0x103c, 0x8115, &quot;HP Z1 Gen3&quot;, CXT_FIXUP_HP_GATE_MIC),
 	SND_PCI_QUIRK(0x1043, 0x138d, &quot;Asus&quot;, CXT_FIXUP_HEADPHONE_MIC_PIN),
<span class="p_chunk">@@ -872,6 +882,7 @@</span> <span class="p_context"> static const struct hda_model_fixup cxt5066_fixup_models[] = {</span>
 	{ .id = CXT_PINCFG_LEMOTE_A1205, .name = &quot;lemote-a1205&quot; },
 	{ .id = CXT_FIXUP_OLPC_XO, .name = &quot;olpc-xo&quot; },
 	{ .id = CXT_FIXUP_MUTE_LED_EAPD, .name = &quot;mute-led-eapd&quot; },
<span class="p_add">+	{ .id = CXT_FIXUP_HP_DOCK, .name = &quot;hp-dock&quot; },</span>
 	{}
 };
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index e5730a7d0480..2159b18f76bf 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4839,6 +4839,7 @@</span> <span class="p_context"> enum {</span>
 	ALC286_FIXUP_HP_GPIO_LED,
 	ALC280_FIXUP_HP_GPIO2_MIC_HOTKEY,
 	ALC280_FIXUP_HP_DOCK_PINS,
<span class="p_add">+	ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED,</span>
 	ALC280_FIXUP_HP_9480M,
 	ALC288_FIXUP_DELL_HEADSET_MODE,
 	ALC288_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_chunk">@@ -5377,6 +5378,16 @@</span> <span class="p_context"> static const struct hda_fixup alc269_fixups[] = {</span>
 		.chained = true,
 		.chain_id = ALC280_FIXUP_HP_GPIO4
 	},
<span class="p_add">+	[ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x1b, 0x21011020 }, /* line-out */</span>
<span class="p_add">+			{ 0x18, 0x2181103f }, /* line-in */</span>
<span class="p_add">+			{ },</span>
<span class="p_add">+		},</span>
<span class="p_add">+		.chained = true,</span>
<span class="p_add">+		.chain_id = ALC269_FIXUP_HP_GPIO_MIC1_LED</span>
<span class="p_add">+	},</span>
 	[ALC280_FIXUP_HP_9480M] = {
 		.type = HDA_FIXUP_FUNC,
 		.v.func = alc280_fixup_hp_9480m,
<span class="p_chunk">@@ -5629,7 +5640,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc269_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x103c, 0x2256, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),
 	SND_PCI_QUIRK(0x103c, 0x2257, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),
 	SND_PCI_QUIRK(0x103c, 0x2259, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),
<span class="p_del">-	SND_PCI_QUIRK(0x103c, 0x225a, &quot;HP&quot;, ALC269_FIXUP_HP_GPIO_MIC1_LED),</span>
<span class="p_add">+	SND_PCI_QUIRK(0x103c, 0x225a, &quot;HP&quot;, ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED),</span>
 	SND_PCI_QUIRK(0x103c, 0x2260, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC1),
 	SND_PCI_QUIRK(0x103c, 0x2263, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC1),
 	SND_PCI_QUIRK(0x103c, 0x2264, &quot;HP&quot;, ALC269_FIXUP_HP_MUTE_LED_MIC1),
<span class="p_chunk">@@ -5794,6 +5805,7 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 	{.id = ALC269_FIXUP_HEADSET_MODE_NO_HP_MIC, .name = &quot;headset-mode-no-hp-mic&quot;},
 	{.id = ALC269_FIXUP_LENOVO_DOCK, .name = &quot;lenovo-dock&quot;},
 	{.id = ALC269_FIXUP_HP_GPIO_LED, .name = &quot;hp-gpio-led&quot;},
<span class="p_add">+	{.id = ALC269_FIXUP_HP_DOCK_GPIO_MIC1_LED, .name = &quot;hp-dock-gpio-mic1-led&quot;},</span>
 	{.id = ALC269_FIXUP_DELL1_MIC_NO_PRESENCE, .name = &quot;dell-headset-multi&quot;},
 	{.id = ALC269_FIXUP_DELL2_MIC_NO_PRESENCE, .name = &quot;dell-headset-dock&quot;},
 	{.id = ALC283_FIXUP_CHROME_BOOK, .name = &quot;alc283-dac-wcaps&quot;},
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index cb092bd9965b..d080f06fd8d9 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -986,7 +986,7 @@</span> <span class="p_context"> int __kvm_set_memory_region(struct kvm *kvm,</span>
 	 * changes) is disallowed above, so any other attribute changes getting
 	 * here can be skipped.
 	 */
<span class="p_del">-	if ((change == KVM_MR_CREATE) || (change == KVM_MR_MOVE)) {</span>
<span class="p_add">+	if (as_id == 0 &amp;&amp; (change == KVM_MR_CREATE || change == KVM_MR_MOVE)) {</span>
 		r = kvm_iommu_map_pages(kvm, &amp;new);
 		return r;
 	}

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



