
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] RAS changes for v4.4 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] RAS changes for v4.4</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 3, 2015, 10:12 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20151103101201.GA29764@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/7541331/mbox/"
   >mbox</a>
|
   <a href="/patch/7541331/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/7541331/">/patch/7541331/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
X-Original-To: patchwork-LKML@patchwork.kernel.org
Delivered-To: patchwork-parsemail@patchwork2.web.kernel.org
Received: from mail.kernel.org (mail.kernel.org [198.145.29.136])
	by patchwork2.web.kernel.org (Postfix) with ESMTP id 9A992BEEA4
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  3 Nov 2015 10:12:29 +0000 (UTC)
Received: from mail.kernel.org (localhost [127.0.0.1])
	by mail.kernel.org (Postfix) with ESMTP id 9A70620605
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  3 Nov 2015 10:12:23 +0000 (UTC)
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.kernel.org (Postfix) with ESMTP id 11D1E205C6
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue,  3 Nov 2015 10:12:17 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752098AbbKCKMN (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 3 Nov 2015 05:12:13 -0500
Received: from mail-wi0-f177.google.com ([209.85.212.177]:35027 &quot;EHLO
	mail-wi0-f177.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1751249AbbKCKMG (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 3 Nov 2015 05:12:06 -0500
Received: by wicll6 with SMTP id ll6so66293016wic.0
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Tue, 03 Nov 2015 02:12:04 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20120113;
	h=sender:date:from:to:cc:subject:message-id:mime-version:content-type
	:content-disposition:user-agent;
	bh=7KzenRkCLSSEJbvSAbEi9dqWNg0n7/6pysKYndk4wUc=;
	b=CUS4spkIKACk8vP8i9mJV9iH1T/AUm7TaEf2jgj6MOBzd2+1yr2DQR1nRV+vHUnUyh
	Z5lVhMyAeuALfkCz6Tfnn0KVDlYA62xF1yhlsDjqJ3hK6RBY8879+HlxiwI+hTlemlJ0
	Dn/hzFXVWpxc+xid1JOACMj2jgDBmpMrTO94mS7Blld/nkwxxD+ZFj/AmL83XfYEjHEf
	Jex5sM5cEXcDmmDJGSFVXVN3lg4qKYcYiORoH9U6VIrWqYBkKoPAb8pnFoL30Im+SFr7
	jVi0kvjyRppjKua77p36j4tx1dcJcRIiFZHQu62gkQb1nO+aBLj1gtz8NE4jlSR5/ze8
	SUOw==
X-Received: by 10.195.11.33 with SMTP id ef1mr27382401wjd.34.1446545524447; 
	Tue, 03 Nov 2015 02:12:04 -0800 (PST)
Received: from gmail.com (54033495.catv.pool.telekom.hu. [84.3.52.149])
	by smtp.gmail.com with ESMTPSA id
	an7sm26699838wjc.44.2015.11.03.02.12.03
	(version=TLSv1.2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Tue, 03 Nov 2015 02:12:03 -0800 (PST)
Date: Tue, 3 Nov 2015 11:12:01 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Borislav Petkov &lt;bp@alien8.de&gt;,
	Thomas Gleixner &lt;tglx@linutronix.de&gt;, &quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;
Subject: [GIT PULL] RAS changes for v4.4
Message-ID: &lt;20151103101201.GA29764@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: Mutt/1.5.23 (2014-03-12)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Spam-Status: No, score=-6.8 required=5.0 tests=BAYES_00,DKIM_SIGNED,
	RCVD_IN_DNSWL_HI,T_DKIM_INVALID,T_RP_MATCHES_RCVD,UNPARSEABLE_RELAY
	autolearn=unavailable version=3.3.1
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on mail.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Nov. 3, 2015, 10:12 a.m.</div>
<pre class="content">
Linus,

Please pull the latest ras-core-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git ras-core-for-linus

   # HEAD: dc34bdd2367fd31744ee3ba1de1b1cc0fa2ce193 x86/mce: Add a default case to the switch in __mcheck_cpu_ancient_init()

The main system reliability related changes were from x86, but also some generic 
RAS changes:

  - AMD MCE error injection subsystem enhancements. (Aravind Gopalakrishnan)

  - Fix MCE and CPU hotplug interaction bug. (Ashok Raj)

  - kcrash bootup robustness fix. (Baoquan He)

  - kcrash cleanups. (Borislav Petkov)

  - x86 microcode driver rework: simplify it by unmodularizing it and other 
    cleanups. (Borislav Petkov)

 Thanks,

	Ingo

------------------&gt;
Andi Kleen (1):
      x86/mce: Fix thermal throttling reporting after kexec

Aravind Gopalakrishnan (5):
      x86/ras/mce_amd_inj: Return early on invalid input
      x86/ras/mce_amd_inj: Trigger deferred and thresholding errors interrupts
      x86/ras/mce_amd_inj: Inject bank 4 errors on the NBC
      x86/amd_nb, EDAC: Rename amd_get_node_id()
      x86/mce: Add a Scalable MCA vendor flags bit

Ashok Raj (1):
      x86/mce: Don&#39;t clear shared banks on Intel when offlining CPUs

Baoquan He (1):
      x86/setup: Do not reserve crashkernel high memory if low reservation failed

Borislav Petkov (14):
      x86/microcode/amd: Extract current patch level read to a function
      x86/microcode/amd: Do not overwrite final patch levels
      x86/setup: Cleanup crashkernel reservation functions
      x86/setup/crash: Remove alignment variable
      x86/setup/crash: Cleanup some more
      x86/setup/crash: Check memblock_reserve() retval
      kexec/crash: Say which char is the unrecognized
      x86/microcode: Unmodularize the microcode driver
      x86/microcode: Merge the early microcode loader
      x86/microcode: Remove modularization leftovers
      x86/microcode/amd: Remove maintainers from comments
      x86/microcode/intel: Move #ifdef DEBUG inside the function
      MAINTAINERS: Unify the microcode driver section
      x86/mce: Add a default case to the switch in __mcheck_cpu_ancient_init()

Gabriel Laskar (1):
      x86/mce: Include linux/ioctl.h in uapi mce header


 MAINTAINERS                                 |  16 +-
 arch/x86/Kconfig                            |  22 +-
 arch/x86/include/asm/amd_nb.h               |   2 +-
 arch/x86/include/asm/mce.h                  |  34 +-
 arch/x86/include/asm/microcode.h            |  26 +-
 arch/x86/include/asm/microcode_amd.h        |   3 +-
 arch/x86/include/asm/microcode_intel.h      |  10 +-
 arch/x86/include/uapi/asm/mce.h             |   2 +-
 arch/x86/kernel/cpu/mcheck/mce.c            |  34 +-
 arch/x86/kernel/cpu/mcheck/therm_throt.c    |   8 -
 arch/x86/kernel/cpu/microcode/Makefile      |   3 -
 arch/x86/kernel/cpu/microcode/amd.c         | 509 +++++++++++++++++-
 arch/x86/kernel/cpu/microcode/amd_early.c   | 440 ---------------
 arch/x86/kernel/cpu/microcode/core.c        | 232 +++++---
 arch/x86/kernel/cpu/microcode/core_early.c  | 170 ------
 arch/x86/kernel/cpu/microcode/intel.c       | 791 ++++++++++++++++++++++++++-
 arch/x86/kernel/cpu/microcode/intel_early.c | 808 ----------------------------
 arch/x86/kernel/cpu/microcode/intel_lib.c   |   1 -
 arch/x86/kernel/head_32.S                   |   5 +-
 arch/x86/kernel/setup.c                     | 102 ++--
 arch/x86/mm/init.c                          |   2 -
 arch/x86/ras/Kconfig                        |   4 +-
 arch/x86/ras/mce_amd_inj.c                  | 103 +++-
 drivers/edac/amd64_edac.c                   |   6 +-
 kernel/kexec_core.c                         |   6 +-
 25 files changed, 1678 insertions(+), 1661 deletions(-)
 delete mode 100644 arch/x86/kernel/cpu/microcode/amd_early.c
 delete mode 100644 arch/x86/kernel/cpu/microcode/core_early.c
 delete mode 100644 arch/x86/kernel/cpu/microcode/intel_early.c

--
To unsubscribe from this list: send the line &quot;unsubscribe linux-kernel&quot; in
the body of a message to majordomo@vger.kernel.org
More majordomo info at  http://vger.kernel.org/majordomo-info.html
Please read the FAQ at  http://www.tux.org/lkml/
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 5f467845ef72..3a39ef4b3c09 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -654,11 +654,6 @@</span> <span class="p_context"> F:	drivers/gpu/drm/radeon/radeon_kfd.c</span>
 F:	drivers/gpu/drm/radeon/radeon_kfd.h
 F:	include/uapi/linux/kfd_ioctl.h
 
<span class="p_del">-AMD MICROCODE UPDATE SUPPORT</span>
<span class="p_del">-M:	Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_del">-S:	Maintained</span>
<span class="p_del">-F:	arch/x86/kernel/cpu/microcode/amd*</span>
<span class="p_del">-</span>
 AMD XGBE DRIVER
 M:	Tom Lendacky &lt;thomas.lendacky@amd.com&gt;
 L:	netdev@vger.kernel.org
<span class="p_chunk">@@ -5430,12 +5425,6 @@</span> <span class="p_context"> W:	https://01.org/linux-acpi</span>
 S:	Supported
 F:	drivers/platform/x86/intel_menlow.c
 
<span class="p_del">-INTEL IA32 MICROCODE UPDATE SUPPORT</span>
<span class="p_del">-M:	Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_del">-S:	Maintained</span>
<span class="p_del">-F:	arch/x86/kernel/cpu/microcode/core*</span>
<span class="p_del">-F:	arch/x86/kernel/cpu/microcode/intel*</span>
<span class="p_del">-</span>
 INTEL I/OAT DMA DRIVER
 M:	Dave Jiang &lt;dave.jiang@intel.com&gt;
 R:	Dan Williams &lt;dan.j.williams@intel.com&gt;
<span class="p_chunk">@@ -11451,6 +11440,11 @@</span> <span class="p_context"> L:	linux-edac@vger.kernel.org</span>
 S:	Maintained
 F:	arch/x86/kernel/cpu/mcheck/*
 
<span class="p_add">+X86 MICROCODE UPDATE SUPPORT</span>
<span class="p_add">+M:	Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_add">+S:	Maintained</span>
<span class="p_add">+F:	arch/x86/kernel/cpu/microcode/*</span>
<span class="p_add">+</span>
 X86 VDSO
 M:	Andy Lutomirski &lt;luto@amacapital.net&gt;
 L:	linux-kernel@vger.kernel.org
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index 96d058a87100..255ea22ccbec 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -1123,8 +1123,10 @@</span> <span class="p_context"> config X86_REBOOTFIXUPS</span>
 	  Say N otherwise.
 
 config MICROCODE
<span class="p_del">-	tristate &quot;CPU microcode loading support&quot;</span>
<span class="p_add">+	bool &quot;CPU microcode loading support&quot;</span>
<span class="p_add">+	default y</span>
 	depends on CPU_SUP_AMD || CPU_SUP_INTEL
<span class="p_add">+	depends on BLK_DEV_INITRD</span>
 	select FW_LOADER
 	---help---
 
<span class="p_chunk">@@ -1166,24 +1168,6 @@</span> <span class="p_context"> config MICROCODE_OLD_INTERFACE</span>
 	def_bool y
 	depends on MICROCODE
 
<span class="p_del">-config MICROCODE_INTEL_EARLY</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
<span class="p_del">-config MICROCODE_AMD_EARLY</span>
<span class="p_del">-	bool</span>
<span class="p_del">-</span>
<span class="p_del">-config MICROCODE_EARLY</span>
<span class="p_del">-	bool &quot;Early load microcode&quot;</span>
<span class="p_del">-	depends on MICROCODE=y &amp;&amp; BLK_DEV_INITRD</span>
<span class="p_del">-	select MICROCODE_INTEL_EARLY if MICROCODE_INTEL</span>
<span class="p_del">-	select MICROCODE_AMD_EARLY if MICROCODE_AMD</span>
<span class="p_del">-	default y</span>
<span class="p_del">-	help</span>
<span class="p_del">-	  This option provides functionality to read additional microcode data</span>
<span class="p_del">-	  at the beginning of initrd image. The data tells kernel to load</span>
<span class="p_del">-	  microcode to CPU&#39;s as early as possible. No functional change if no</span>
<span class="p_del">-	  microcode data is glued to the initrd, therefore it&#39;s safe to say Y.</span>
<span class="p_del">-</span>
 config X86_MSR
 	tristate &quot;/dev/cpu/*/msr - Model-specific register support&quot;
 	---help---
<span class="p_header">diff --git a/arch/x86/include/asm/amd_nb.h b/arch/x86/include/asm/amd_nb.h</span>
<span class="p_header">index 1a5da2e63aee..3c56ef1ae068 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/amd_nb.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/amd_nb.h</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"> static inline struct amd_northbridge *node_to_amd_nb(int node)</span>
 	return (node &lt; amd_northbridges.num) ? &amp;amd_northbridges.nb[node] : NULL;
 }
 
<span class="p_del">-static inline u16 amd_get_node_id(struct pci_dev *pdev)</span>
<span class="p_add">+static inline u16 amd_pci_dev_to_node_id(struct pci_dev *pdev)</span>
 {
 	struct pci_dev *misc;
 	int i;
<span class="p_header">diff --git a/arch/x86/include/asm/mce.h b/arch/x86/include/asm/mce.h</span>
<span class="p_header">index 2dbc0bf2b9f3..2ea4527e462f 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mce.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mce.h</span>
<span class="p_chunk">@@ -123,19 +123,27 @@</span> <span class="p_context"> struct mca_config {</span>
 };
 
 struct mce_vendor_flags {
<span class="p_del">-			/*</span>
<span class="p_del">-			 * overflow recovery cpuid bit indicates that overflow</span>
<span class="p_del">-			 * conditions are not fatal</span>
<span class="p_del">-			 */</span>
<span class="p_del">-	__u64		overflow_recov	: 1,</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * SUCCOR stands for S/W UnCorrectable error COntainment</span>
<span class="p_del">-			 * and Recovery. It indicates support for data poisoning</span>
<span class="p_del">-			 * in HW and deferred error interrupts.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			succor		: 1,</span>
<span class="p_del">-			__reserved_0	: 62;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Indicates that overflow conditions are not fatal, when set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	__u64 overflow_recov	: 1,</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * (AMD) SUCCOR stands for S/W UnCorrectable error COntainment and</span>
<span class="p_add">+	 * Recovery. It indicates support for data poisoning in HW and deferred</span>
<span class="p_add">+	 * error interrupts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	      succor		: 1,</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * (AMD) SMCA: This bit indicates support for Scalable MCA which expands</span>
<span class="p_add">+	 * the register space for each MCA bank and also increases number of</span>
<span class="p_add">+	 * banks. Also, to accommodate the new banks and registers, the MCA</span>
<span class="p_add">+	 * register space is moved to a new MSR range.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	      smca		: 1,</span>
<span class="p_add">+</span>
<span class="p_add">+	      __reserved_0	: 61;</span>
 };
 extern struct mce_vendor_flags mce_flags;
 
<span class="p_header">diff --git a/arch/x86/include/asm/microcode.h b/arch/x86/include/asm/microcode.h</span>
<span class="p_header">index 9e6278c7140e..34e62b1dcfce 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode.h</span>
<span class="p_chunk">@@ -27,7 +27,6 @@</span> <span class="p_context"> struct cpu_signature {</span>
 struct device;
 
 enum ucode_state { UCODE_ERROR, UCODE_OK, UCODE_NFOUND };
<span class="p_del">-extern bool dis_ucode_ldr;</span>
 
 struct microcode_ops {
 	enum ucode_state (*request_microcode_user) (int cpu,
<span class="p_chunk">@@ -55,6 +54,12 @@</span> <span class="p_context"> struct ucode_cpu_info {</span>
 };
 extern struct ucode_cpu_info ucode_cpu_info[];
 
<span class="p_add">+#ifdef CONFIG_MICROCODE</span>
<span class="p_add">+int __init microcode_init(void);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline int __init microcode_init(void)	{ return 0; };</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #ifdef CONFIG_MICROCODE_INTEL
 extern struct microcode_ops * __init init_intel_microcode(void);
 #else
<span class="p_chunk">@@ -75,7 +80,6 @@</span> <span class="p_context"> static inline struct microcode_ops * __init init_amd_microcode(void)</span>
 static inline void __exit exit_amd_microcode(void) {}
 #endif
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
 #define MAX_UCODE_COUNT 128
 
 #define QCHAR(a, b, c, d) ((a) + ((b) &lt;&lt; 8) + ((c) &lt;&lt; 16) + ((d) &lt;&lt; 24))
<span class="p_chunk">@@ -150,22 +154,18 @@</span> <span class="p_context"> static inline unsigned int x86_model(unsigned int sig)</span>
 	return model;
 }
 
<span class="p_add">+#ifdef CONFIG_MICROCODE</span>
 extern void __init load_ucode_bsp(void);
 extern void load_ucode_ap(void);
 extern int __init save_microcode_in_initrd(void);
 void reload_early_microcode(void);
 extern bool get_builtin_firmware(struct cpio_data *cd, const char *name);
 #else
<span class="p_del">-static inline void __init load_ucode_bsp(void) {}</span>
<span class="p_del">-static inline void load_ucode_ap(void) {}</span>
<span class="p_del">-static inline int __init save_microcode_in_initrd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-static inline void reload_early_microcode(void) {}</span>
<span class="p_del">-static inline bool get_builtin_firmware(struct cpio_data *cd, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_add">+static inline void __init load_ucode_bsp(void)			{ }</span>
<span class="p_add">+static inline void load_ucode_ap(void)				{ }</span>
<span class="p_add">+static inline int __init save_microcode_in_initrd(void)		{ return 0; }</span>
<span class="p_add">+static inline void reload_early_microcode(void)			{ }</span>
<span class="p_add">+static inline bool</span>
<span class="p_add">+get_builtin_firmware(struct cpio_data *cd, const char *name)	{ return false; }</span>
 #endif
 #endif /* _ASM_X86_MICROCODE_H */
<span class="p_header">diff --git a/arch/x86/include/asm/microcode_amd.h b/arch/x86/include/asm/microcode_amd.h</span>
<span class="p_header">index ac6d328977a6..adfc847a395e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode_amd.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode_amd.h</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> extern enum ucode_state load_microcode_amd(int cpu, u8 family, const u8 *data, s</span>
 #define PATCH_MAX_SIZE PAGE_SIZE
 extern u8 amd_ucode_patch[PATCH_MAX_SIZE];
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_AMD_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE_AMD</span>
 extern void __init load_ucode_amd_bsp(unsigned int family);
 extern void load_ucode_amd_ap(void);
 extern int __init save_microcode_in_initrd_amd(void);
<span class="p_chunk">@@ -76,4 +76,5 @@</span> <span class="p_context"> static inline int __init save_microcode_in_initrd_amd(void) { return -EINVAL; }</span>
 void reload_ucode_amd(void) {}
 #endif
 
<span class="p_add">+extern bool check_current_patch_level(u32 *rev, bool early);</span>
 #endif /* _ASM_X86_MICROCODE_AMD_H */
<span class="p_header">diff --git a/arch/x86/include/asm/microcode_intel.h b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">index 7991c606125d..8559b0102ea1 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/microcode_intel.h</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> extern int has_newer_microcode(void *mc, unsigned int csig, int cpf, int rev);</span>
 extern int microcode_sanity_check(void *mc, int print_err);
 extern int find_matching_signature(void *mc, unsigned int csig, int cpf);
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_INTEL_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE_INTEL</span>
 extern void __init load_ucode_intel_bsp(void);
 extern void load_ucode_intel_ap(void);
 extern void show_ucode_info_early(void);
<span class="p_chunk">@@ -71,13 +71,9 @@</span> <span class="p_context"> static inline int __init save_microcode_in_initrd_intel(void) { return -EINVAL;</span>
 static inline void reload_ucode_intel(void) {}
 #endif
 
<span class="p_del">-#if defined(CONFIG_MICROCODE_INTEL_EARLY) &amp;&amp; defined(CONFIG_HOTPLUG_CPU)</span>
<span class="p_add">+#ifdef CONFIG_HOTPLUG_CPU</span>
 extern int save_mc_for_early(u8 *mc);
 #else
<span class="p_del">-static inline int save_mc_for_early(u8 *mc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_add">+static inline int save_mc_for_early(u8 *mc) { return 0; }</span>
 #endif
<span class="p_del">-</span>
 #endif /* _ASM_X86_MICROCODE_INTEL_H */
<span class="p_header">diff --git a/arch/x86/include/uapi/asm/mce.h b/arch/x86/include/uapi/asm/mce.h</span>
<span class="p_header">index 76880ede9a35..03429da2fa80 100644</span>
<span class="p_header">--- a/arch/x86/include/uapi/asm/mce.h</span>
<span class="p_header">+++ b/arch/x86/include/uapi/asm/mce.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
 #define _UAPI_ASM_X86_MCE_H
 
 #include &lt;linux/types.h&gt;
<span class="p_del">-#include &lt;asm/ioctls.h&gt;</span>
<span class="p_add">+#include &lt;linux/ioctl.h&gt;</span>
 
 /* Fields are zero when not available */
 struct mce {
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/mce.c b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">index 9d014b82a124..c5b0d562dbf5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/mce.c</span>
<span class="p_chunk">@@ -1586,6 +1586,8 @@</span> <span class="p_context"> static int __mcheck_cpu_ancient_init(struct cpuinfo_x86 *c)</span>
 		winchip_mcheck_init(c);
 		return 1;
 		break;
<span class="p_add">+	default:</span>
<span class="p_add">+		return 0;</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -1605,6 +1607,8 @@</span> <span class="p_context"> static void __mcheck_cpu_init_vendor(struct cpuinfo_x86 *c)</span>
 		mce_amd_feature_init(c);
 		mce_flags.overflow_recov = !!(ebx &amp; BIT(0));
 		mce_flags.succor	 = !!(ebx &amp; BIT(1));
<span class="p_add">+		mce_flags.smca		 = !!(ebx &amp; BIT(3));</span>
<span class="p_add">+</span>
 		break;
 		}
 
<span class="p_chunk">@@ -2042,7 +2046,7 @@</span> <span class="p_context"> int __init mcheck_init(void)</span>
  * Disable machine checks on suspend and shutdown. We can&#39;t really handle
  * them later.
  */
<span class="p_del">-static int mce_disable_error_reporting(void)</span>
<span class="p_add">+static void mce_disable_error_reporting(void)</span>
 {
 	int i;
 
<span class="p_chunk">@@ -2052,17 +2056,32 @@</span> <span class="p_context"> static int mce_disable_error_reporting(void)</span>
 		if (b-&gt;init)
 			wrmsrl(MSR_IA32_MCx_CTL(i), 0);
 	}
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void vendor_disable_error_reporting(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t clear on Intel CPUs. Some of these MSRs are socket-wide.</span>
<span class="p_add">+	 * Disabling them for just a single offlined CPU is bad, since it will</span>
<span class="p_add">+	 * inhibit reporting for all shared resources on the socket like the</span>
<span class="p_add">+	 * last level cache (LLC), the integrated memory controller (iMC), etc.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	mce_disable_error_reporting();</span>
 }
 
 static int mce_syscore_suspend(void)
 {
<span class="p_del">-	return mce_disable_error_reporting();</span>
<span class="p_add">+	vendor_disable_error_reporting();</span>
<span class="p_add">+	return 0;</span>
 }
 
 static void mce_syscore_shutdown(void)
 {
<span class="p_del">-	mce_disable_error_reporting();</span>
<span class="p_add">+	vendor_disable_error_reporting();</span>
 }
 
 /*
<span class="p_chunk">@@ -2342,19 +2361,14 @@</span> <span class="p_context"> static void mce_device_remove(unsigned int cpu)</span>
 static void mce_disable_cpu(void *h)
 {
 	unsigned long action = *(unsigned long *)h;
<span class="p_del">-	int i;</span>
 
 	if (!mce_available(raw_cpu_ptr(&amp;cpu_info)))
 		return;
 
 	if (!(action &amp; CPU_TASKS_FROZEN))
 		cmci_clear();
<span class="p_del">-	for (i = 0; i &lt; mca_cfg.banks; i++) {</span>
<span class="p_del">-		struct mce_bank *b = &amp;mce_banks[i];</span>
 
<span class="p_del">-		if (b-&gt;init)</span>
<span class="p_del">-			wrmsrl(MSR_IA32_MCx_CTL(i), 0);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	vendor_disable_error_reporting();</span>
 }
 
 static void mce_reenable_cpu(void *h)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/mcheck/therm_throt.c b/arch/x86/kernel/cpu/mcheck/therm_throt.c</span>
<span class="p_header">index 1af51b1586d7..2c5aaf8c2e2f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/mcheck/therm_throt.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/mcheck/therm_throt.c</span>
<span class="p_chunk">@@ -503,14 +503,6 @@</span> <span class="p_context"> void intel_init_thermal(struct cpuinfo_x86 *c)</span>
 		return;
 	}
 
<span class="p_del">-	/* Check whether a vector already exists */</span>
<span class="p_del">-	if (h &amp; APIC_VECTOR_MASK) {</span>
<span class="p_del">-		printk(KERN_DEBUG</span>
<span class="p_del">-		       &quot;CPU%d: Thermal LVT vector (%#x) already installed\n&quot;,</span>
<span class="p_del">-		       cpu, (h &amp; APIC_VECTOR_MASK));</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	/* early Pentium M models use different method for enabling TM2 */
 	if (cpu_has(c, X86_FEATURE_TM2)) {
 		if (c-&gt;x86 == 6 &amp;&amp; (c-&gt;x86_model == 9 || c-&gt;x86_model == 13)) {
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/Makefile b/arch/x86/kernel/cpu/microcode/Makefile</span>
<span class="p_header">index 285c85427c32..220b1a508513 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/Makefile</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/Makefile</span>
<span class="p_chunk">@@ -2,6 +2,3 @@</span> <span class="p_context"> microcode-y				:= core.o</span>
 obj-$(CONFIG_MICROCODE)			+= microcode.o
 microcode-$(CONFIG_MICROCODE_INTEL)	+= intel.o intel_lib.o
 microcode-$(CONFIG_MICROCODE_AMD)	+= amd.o
<span class="p_del">-obj-$(CONFIG_MICROCODE_EARLY)		+= core_early.o</span>
<span class="p_del">-obj-$(CONFIG_MICROCODE_INTEL_EARLY)	+= intel_early.o</span>
<span class="p_del">-obj-$(CONFIG_MICROCODE_AMD_EARLY)	+= amd_early.o</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd.c b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">index 12829c3ced3c..2233f8a76615 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/amd.c</span>
<span class="p_chunk">@@ -1,5 +1,9 @@</span> <span class="p_context"></span>
 /*
  *  AMD CPU Microcode Update Driver for Linux
<span class="p_add">+ *</span>
<span class="p_add">+ *  This driver allows to upgrade microcode on F10h AMD</span>
<span class="p_add">+ *  CPUs and later.</span>
<span class="p_add">+ *</span>
  *  Copyright (C) 2008-2011 Advanced Micro Devices Inc.
  *
  *  Author: Peter Oruba &lt;peter.oruba@amd.com&gt;
<span class="p_chunk">@@ -7,34 +11,31 @@</span> <span class="p_context"></span>
  *  Based on work by:
  *  Tigran Aivazian &lt;tigran@aivazian.fsnet.co.uk&gt;
  *
<span class="p_del">- *  Maintainers:</span>
<span class="p_del">- *  Andreas Herrmann &lt;herrmann.der.user@googlemail.com&gt;</span>
<span class="p_del">- *  Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_add">+ *  early loader:</span>
<span class="p_add">+ *  Copyright (C) 2013 Advanced Micro Devices, Inc.</span>
  *
<span class="p_del">- *  This driver allows to upgrade microcode on F10h AMD</span>
<span class="p_del">- *  CPUs and later.</span>
<span class="p_add">+ *  Author: Jacob Shin &lt;jacob.shin@amd.com&gt;</span>
<span class="p_add">+ *  Fixes: Borislav Petkov &lt;bp@suse.de&gt;</span>
  *
  *  Licensed under the terms of the GNU General Public
  *  License version 2. See file COPYING for details.
  */
<span class="p_add">+#define pr_fmt(fmt) &quot;microcode: &quot; fmt</span>
 
<span class="p_del">-#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="p_del">-</span>
<span class="p_add">+#include &lt;linux/earlycpio.h&gt;</span>
 #include &lt;linux/firmware.h&gt;
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/vmalloc.h&gt;
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
 #include &lt;linux/kernel.h&gt;
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
 #include &lt;linux/pci.h&gt;
 
<span class="p_add">+#include &lt;asm/microcode_amd.h&gt;</span>
 #include &lt;asm/microcode.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
<span class="p_add">+#include &lt;asm/cpu.h&gt;</span>
 #include &lt;asm/msr.h&gt;
<span class="p_del">-#include &lt;asm/microcode_amd.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-MODULE_DESCRIPTION(&quot;AMD Microcode Update Driver&quot;);</span>
<span class="p_del">-MODULE_AUTHOR(&quot;Peter Oruba&quot;);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL v2&quot;);</span>
 
 static struct equiv_cpu_entry *equiv_cpu_table;
 
<span class="p_chunk">@@ -47,6 +48,432 @@</span> <span class="p_context"> struct ucode_patch {</span>
 
 static LIST_HEAD(pcache);
 
<span class="p_add">+/*</span>
<span class="p_add">+ * This points to the current valid container of microcode patches which we will</span>
<span class="p_add">+ * save from the initrd before jettisoning its contents.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static u8 *container;</span>
<span class="p_add">+static size_t container_size;</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 ucode_new_rev;</span>
<span class="p_add">+u8 amd_ucode_patch[PATCH_MAX_SIZE];</span>
<span class="p_add">+static u16 this_equiv_id;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct cpio_data ucode_cpio;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Microcode patch container file is prepended to the initrd in cpio format.</span>
<span class="p_add">+ * See Documentation/x86/early-microcode.txt</span>
<span class="p_add">+ */</span>
<span class="p_add">+static __initdata char ucode_path[] = &quot;kernel/x86/microcode/AuthenticAMD.bin&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+static struct cpio_data __init find_ucode_in_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	long offset = 0;</span>
<span class="p_add">+	char *path;</span>
<span class="p_add">+	void *start;</span>
<span class="p_add">+	size_t size;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	struct boot_params *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * On 32-bit, early load occurs before paging is turned on so we need</span>
<span class="p_add">+	 * to use physical addresses.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	p       = (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_add">+	path    = (char *)__pa_nodebug(ucode_path);</span>
<span class="p_add">+	start   = (void *)p-&gt;hdr.ramdisk_image;</span>
<span class="p_add">+	size    = p-&gt;hdr.ramdisk_size;</span>
<span class="p_add">+#else</span>
<span class="p_add">+	path    = ucode_path;</span>
<span class="p_add">+	start   = (void *)(boot_params.hdr.ramdisk_image + PAGE_OFFSET);</span>
<span class="p_add">+	size    = boot_params.hdr.ramdisk_size;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	return find_cpio_data(path, start, size, &amp;offset);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static size_t compute_container_size(u8 *data, u32 total_size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t size = 0;</span>
<span class="p_add">+	u32 *header = (u32 *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_add">+	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_add">+	    header[2] == 0)                            /* size */</span>
<span class="p_add">+		return size;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_add">+	total_size -= size;</span>
<span class="p_add">+	data += size;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (total_size) {</span>
<span class="p_add">+		u16 patch_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		header = (u32 *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (header[0] != UCODE_UCODE_TYPE)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Sanity-check patch size.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		patch_size = header[1];</span>
<span class="p_add">+		if (patch_size &gt; PATCH_MAX_SIZE)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		size	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_add">+		data	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_add">+		total_size -= patch_size + SECTION_HDR_SIZE;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return size;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Early load occurs before we can vmalloc(). So we look for the microcode</span>
<span class="p_add">+ * patch container file in initrd, traverse equivalent cpu table, look for a</span>
<span class="p_add">+ * matching microcode patch, and update, all in initrd memory in place.</span>
<span class="p_add">+ * When vmalloc() is available for use later -- on 64-bit during first AP load,</span>
<span class="p_add">+ * and on 32-bit during save_microcode_in_initrd_amd() -- we can call</span>
<span class="p_add">+ * load_microcode_amd() to save equivalent cpu table and microcode patches in</span>
<span class="p_add">+ * kernel heap memory.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void apply_ucode_in_initrd(void *ucode, size_t size, bool save_patch)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct equiv_cpu_entry *eq;</span>
<span class="p_add">+	size_t *cont_sz;</span>
<span class="p_add">+	u32 *header;</span>
<span class="p_add">+	u8  *data, **cont;</span>
<span class="p_add">+	u8 (*patch)[PATCH_MAX_SIZE];</span>
<span class="p_add">+	u16 eq_id = 0;</span>
<span class="p_add">+	int offset, left;</span>
<span class="p_add">+	u32 rev, eax, ebx, ecx, edx;</span>
<span class="p_add">+	u32 *new_rev;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	new_rev = (u32 *)__pa_nodebug(&amp;ucode_new_rev);</span>
<span class="p_add">+	cont_sz = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_add">+	cont	= (u8 **)__pa_nodebug(&amp;container);</span>
<span class="p_add">+	patch	= (u8 (*)[PATCH_MAX_SIZE])__pa_nodebug(&amp;amd_ucode_patch);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	new_rev = &amp;ucode_new_rev;</span>
<span class="p_add">+	cont_sz = &amp;container_size;</span>
<span class="p_add">+	cont	= &amp;container;</span>
<span class="p_add">+	patch	= &amp;amd_ucode_patch;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	data   = ucode;</span>
<span class="p_add">+	left   = size;</span>
<span class="p_add">+	header = (u32 *)data;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* find equiv cpu table */</span>
<span class="p_add">+	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_add">+	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_add">+	    header[2] == 0)                            /* size */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	eax = 0x00000001;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+</span>
<span class="p_add">+	while (left &gt; 0) {</span>
<span class="p_add">+		eq = (struct equiv_cpu_entry *)(data + CONTAINER_HDR_SZ);</span>
<span class="p_add">+</span>
<span class="p_add">+		*cont = data;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Advance past the container header */</span>
<span class="p_add">+		offset = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_add">+		data  += offset;</span>
<span class="p_add">+		left  -= offset;</span>
<span class="p_add">+</span>
<span class="p_add">+		eq_id = find_equiv_id(eq, eax);</span>
<span class="p_add">+		if (eq_id) {</span>
<span class="p_add">+			this_equiv_id = eq_id;</span>
<span class="p_add">+			*cont_sz = compute_container_size(*cont, left + offset);</span>
<span class="p_add">+</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * truncate how much we need to iterate over in the</span>
<span class="p_add">+			 * ucode update loop below</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			left = *cont_sz - offset;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * support multiple container files appended together. if this</span>
<span class="p_add">+		 * one does not have a matching equivalent cpu entry, we fast</span>
<span class="p_add">+		 * forward to the next container file.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		while (left &gt; 0) {</span>
<span class="p_add">+			header = (u32 *)data;</span>
<span class="p_add">+			if (header[0] == UCODE_MAGIC &amp;&amp;</span>
<span class="p_add">+			    header[1] == UCODE_EQUIV_CPU_TABLE_TYPE)</span>
<span class="p_add">+				break;</span>
<span class="p_add">+</span>
<span class="p_add">+			offset = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_add">+			data  += offset;</span>
<span class="p_add">+			left  -= offset;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/* mark where the next microcode container file starts */</span>
<span class="p_add">+		offset    = data - (u8 *)ucode;</span>
<span class="p_add">+		ucode     = data;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!eq_id) {</span>
<span class="p_add">+		*cont = NULL;</span>
<span class="p_add">+		*cont_sz = 0;</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (check_current_patch_level(&amp;rev, true))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (left &gt; 0) {</span>
<span class="p_add">+		struct microcode_amd *mc;</span>
<span class="p_add">+</span>
<span class="p_add">+		header = (u32 *)data;</span>
<span class="p_add">+		if (header[0] != UCODE_UCODE_TYPE || /* type */</span>
<span class="p_add">+		    header[1] == 0)                  /* size */</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc = (struct microcode_amd *)(data + SECTION_HDR_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (eq_id == mc-&gt;hdr.processor_rev_id &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_add">+</span>
<span class="p_add">+			if (!__apply_microcode_amd(mc)) {</span>
<span class="p_add">+				rev = mc-&gt;hdr.patch_id;</span>
<span class="p_add">+				*new_rev = rev;</span>
<span class="p_add">+</span>
<span class="p_add">+				if (save_patch)</span>
<span class="p_add">+					memcpy(patch, mc,</span>
<span class="p_add">+					       min_t(u32, header[1], PATCH_MAX_SIZE));</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		offset  = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_add">+		data   += offset;</span>
<span class="p_add">+		left   -= offset;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool __init load_builtin_amd_microcode(struct cpio_data *cp,</span>
<span class="p_add">+					      unsigned int family)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	char fw_name[36] = &quot;amd-ucode/microcode_amd.bin&quot;;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (family &gt;= 0x15)</span>
<span class="p_add">+		snprintf(fw_name, sizeof(fw_name),</span>
<span class="p_add">+			 &quot;amd-ucode/microcode_amd_fam%.2xh.bin&quot;, family);</span>
<span class="p_add">+</span>
<span class="p_add">+	return get_builtin_firmware(cp, fw_name);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init load_ucode_amd_bsp(unsigned int family)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpio_data cp;</span>
<span class="p_add">+	void **data;</span>
<span class="p_add">+	size_t *size;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	data =  (void **)__pa_nodebug(&amp;ucode_cpio.data);</span>
<span class="p_add">+	size = (size_t *)__pa_nodebug(&amp;ucode_cpio.size);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	data = &amp;ucode_cpio.data;</span>
<span class="p_add">+	size = &amp;ucode_cpio.size;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	cp = find_ucode_in_initrd();</span>
<span class="p_add">+	if (!cp.data) {</span>
<span class="p_add">+		if (!load_builtin_amd_microcode(&amp;cp, family))</span>
<span class="p_add">+			return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	*data = cp.data;</span>
<span class="p_add">+	*size = cp.size;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_ucode_in_initrd(cp.data, cp.size, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * On 32-bit, since AP&#39;s early load occurs before paging is turned on, we</span>
<span class="p_add">+ * cannot traverse cpu_equiv_table and pcache in kernel heap memory. So during</span>
<span class="p_add">+ * cold boot, AP will apply_ucode_in_initrd() just like the BSP. During</span>
<span class="p_add">+ * save_microcode_in_initrd_amd() BSP&#39;s patch is copied to amd_ucode_patch,</span>
<span class="p_add">+ * which is used upon resume from suspend.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void load_ucode_amd_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_amd *mc;</span>
<span class="p_add">+	size_t *usize;</span>
<span class="p_add">+	void **ucode;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc = (struct microcode_amd *)__pa_nodebug(amd_ucode_patch);</span>
<span class="p_add">+	if (mc-&gt;hdr.patch_id &amp;&amp; mc-&gt;hdr.processor_rev_id) {</span>
<span class="p_add">+		__apply_microcode_amd(mc);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	ucode = (void *)__pa_nodebug(&amp;container);</span>
<span class="p_add">+	usize = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!*ucode || !*usize)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_ucode_in_initrd(*ucode, *usize, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init collect_cpu_sig_on_bsp(void *arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	uci-&gt;cpu_sig.sig = cpuid_eax(0x00000001);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init get_bsp_sig(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int bsp = boot_cpu_data.cpu_index;</span>
<span class="p_add">+	struct ucode_cpu_info *uci = ucode_cpu_info + bsp;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!uci-&gt;cpu_sig.sig)</span>
<span class="p_add">+		smp_call_function_single(bsp, collect_cpu_sig_on_bsp, NULL, 1);</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+void load_ucode_amd_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int cpu = smp_processor_id();</span>
<span class="p_add">+	struct equiv_cpu_entry *eq;</span>
<span class="p_add">+	struct microcode_amd *mc;</span>
<span class="p_add">+	u32 rev, eax;</span>
<span class="p_add">+	u16 eq_id;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Exit if called on the BSP. */</span>
<span class="p_add">+	if (!cpu)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!container)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * 64-bit runs with paging enabled, thus early==false.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	eax = cpuid_eax(0x00000001);</span>
<span class="p_add">+	eq  = (struct equiv_cpu_entry *)(container + CONTAINER_HDR_SZ);</span>
<span class="p_add">+</span>
<span class="p_add">+	eq_id = find_equiv_id(eq, eax);</span>
<span class="p_add">+	if (!eq_id)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (eq_id == this_equiv_id) {</span>
<span class="p_add">+		mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_add">+			if (!__apply_microcode_amd(mc))</span>
<span class="p_add">+				ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		if (!ucode_cpio.data)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * AP has a different equivalence ID than BSP, looks like</span>
<span class="p_add">+		 * mixed-steppings silicon so go through the ucode blob anew.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		apply_ucode_in_initrd(ucode_cpio.data, ucode_cpio.size, false);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+int __init save_microcode_in_initrd_amd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned long cont;</span>
<span class="p_add">+	int retval = 0;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+	u8 *cont_va;</span>
<span class="p_add">+	u32 eax;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!container)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	get_bsp_sig();</span>
<span class="p_add">+	cont	= (unsigned long)container;</span>
<span class="p_add">+	cont_va = __va(container);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We need the physical address of the container for both bitness since</span>
<span class="p_add">+	 * boot_params.hdr.ramdisk_image is a physical address.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	cont    = __pa(container);</span>
<span class="p_add">+	cont_va = container;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Take into account the fact that the ramdisk might get relocated and</span>
<span class="p_add">+	 * therefore we need to recompute the container&#39;s position in virtual</span>
<span class="p_add">+	 * memory space.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (relocated_ramdisk)</span>
<span class="p_add">+		container = (u8 *)(__va(relocated_ramdisk) +</span>
<span class="p_add">+			     (cont - boot_params.hdr.ramdisk_image));</span>
<span class="p_add">+	else</span>
<span class="p_add">+		container = cont_va;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ucode_new_rev)</span>
<span class="p_add">+		pr_info(&quot;microcode: updated early to new patch_level=0x%08x\n&quot;,</span>
<span class="p_add">+			ucode_new_rev);</span>
<span class="p_add">+</span>
<span class="p_add">+	eax   = cpuid_eax(0x00000001);</span>
<span class="p_add">+	eax   = ((eax &gt;&gt; 8) &amp; 0xf) + ((eax &gt;&gt; 20) &amp; 0xff);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = load_microcode_amd(smp_processor_id(), eax, container, container_size);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This will be freed any msec now, stash patches for the current</span>
<span class="p_add">+	 * family and switch to patch cache for cpu hotplug, etc later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	container = NULL;</span>
<span class="p_add">+	container_size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	return retval;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void reload_ucode_amd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_amd *mc;</span>
<span class="p_add">+	u32 rev;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * early==false because this is a syscore -&gt;resume path and by</span>
<span class="p_add">+	 * that time paging is long enabled.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_add">+		if (!__apply_microcode_amd(mc)) {</span>
<span class="p_add">+			ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_add">+			pr_info(&quot;microcode: reload patch_level=0x%08x\n&quot;,</span>
<span class="p_add">+				ucode_new_rev);</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
 static u16 __find_equiv_id(unsigned int cpu)
 {
 	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;
<span class="p_chunk">@@ -177,6 +604,53 @@</span> <span class="p_context"> static unsigned int verify_patch_size(u8 family, u32 patch_size,</span>
 	return patch_size;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Those patch levels cannot be updated to newer ones and thus should be final.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static u32 final_levels[] = {</span>
<span class="p_add">+	0x01000098,</span>
<span class="p_add">+	0x0100009f,</span>
<span class="p_add">+	0x010000af,</span>
<span class="p_add">+	0, /* T-101 terminator */</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Check the current patch level on this CPU.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @rev: Use it to return the patch level. It is set to 0 in the case of</span>
<span class="p_add">+ * error.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns:</span>
<span class="p_add">+ *  - true: if update should stop</span>
<span class="p_add">+ *  - false: otherwise</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool check_current_patch_level(u32 *rev, bool early)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 lvl, dummy, i;</span>
<span class="p_add">+	bool ret = false;</span>
<span class="p_add">+	u32 *levels;</span>
<span class="p_add">+</span>
<span class="p_add">+	native_rdmsr(MSR_AMD64_PATCH_LEVEL, lvl, dummy);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_ENABLED(CONFIG_X86_32) &amp;&amp; early)</span>
<span class="p_add">+		levels = (u32 *)__pa_nodebug(&amp;final_levels);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		levels = final_levels;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; levels[i]; i++) {</span>
<span class="p_add">+		if (lvl == levels[i]) {</span>
<span class="p_add">+			lvl = 0;</span>
<span class="p_add">+			ret = true;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rev)</span>
<span class="p_add">+		*rev = lvl;</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int __apply_microcode_amd(struct microcode_amd *mc_amd)
 {
 	u32 rev, dummy;
<span class="p_chunk">@@ -197,7 +671,7 @@</span> <span class="p_context"> int apply_microcode_amd(int cpu)</span>
 	struct microcode_amd *mc_amd;
 	struct ucode_cpu_info *uci;
 	struct ucode_patch *p;
<span class="p_del">-	u32 rev, dummy;</span>
<span class="p_add">+	u32 rev;</span>
 
 	BUG_ON(raw_smp_processor_id() != cpu);
 
<span class="p_chunk">@@ -210,7 +684,8 @@</span> <span class="p_context"> int apply_microcode_amd(int cpu)</span>
 	mc_amd  = p-&gt;data;
 	uci-&gt;mc = p-&gt;data;
 
<span class="p_del">-	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, dummy);</span>
<span class="p_add">+	if (check_current_patch_level(&amp;rev, false))</span>
<span class="p_add">+		return -1;</span>
 
 	/* need to apply patch? */
 	if (rev &gt;= mc_amd-&gt;hdr.patch_id) {
<span class="p_chunk">@@ -387,7 +862,7 @@</span> <span class="p_context"> enum ucode_state load_microcode_amd(int cpu, u8 family, const u8 *data, size_t s</span>
 	if (ret != UCODE_OK)
 		cleanup();
 
<span class="p_del">-#if defined(CONFIG_MICROCODE_AMD_EARLY) &amp;&amp; defined(CONFIG_X86_32)</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
 	/* save BSP&#39;s matching patch for early load */
 	if (cpu_data(cpu).cpu_index == boot_cpu_data.cpu_index) {
 		struct ucode_patch *p = find_patch(cpu);
<span class="p_chunk">@@ -475,7 +950,7 @@</span> <span class="p_context"> static struct microcode_ops microcode_amd_ops = {</span>
 
 struct microcode_ops * __init init_amd_microcode(void)
 {
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;cpu_data(0);</span>
<span class="p_add">+	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
 
 	if (c-&gt;x86_vendor != X86_VENDOR_AMD || c-&gt;x86 &lt; 0x10) {
 		pr_warning(&quot;AMD CPU family 0x%x not supported\n&quot;, c-&gt;x86);
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/amd_early.c b/arch/x86/kernel/cpu/microcode/amd_early.c</span>
deleted file mode 100644
<span class="p_header">index e8a215a9a345..000000000000</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/amd_early.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,440 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Copyright (C) 2013 Advanced Micro Devices, Inc.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Author: Jacob Shin &lt;jacob.shin@amd.com&gt;</span>
<span class="p_del">- * Fixes: Borislav Petkov &lt;bp@suse.de&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_del">- * published by the Free Software Foundation.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/earlycpio.h&gt;</span>
<span class="p_del">-#include &lt;linux/initrd.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;asm/cpu.h&gt;</span>
<span class="p_del">-#include &lt;asm/setup.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_amd.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This points to the current valid container of microcode patches which we will</span>
<span class="p_del">- * save from the initrd before jettisoning its contents.</span>
<span class="p_del">- */</span>
<span class="p_del">-static u8 *container;</span>
<span class="p_del">-static size_t container_size;</span>
<span class="p_del">-</span>
<span class="p_del">-static u32 ucode_new_rev;</span>
<span class="p_del">-u8 amd_ucode_patch[PATCH_MAX_SIZE];</span>
<span class="p_del">-static u16 this_equiv_id;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct cpio_data ucode_cpio;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Microcode patch container file is prepended to the initrd in cpio format.</span>
<span class="p_del">- * See Documentation/x86/early-microcode.txt</span>
<span class="p_del">- */</span>
<span class="p_del">-static __initdata char ucode_path[] = &quot;kernel/x86/microcode/AuthenticAMD.bin&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct cpio_data __init find_ucode_in_initrd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	long offset = 0;</span>
<span class="p_del">-	char *path;</span>
<span class="p_del">-	void *start;</span>
<span class="p_del">-	size_t size;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	struct boot_params *p;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * On 32-bit, early load occurs before paging is turned on so we need</span>
<span class="p_del">-	 * to use physical addresses.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	p       = (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_del">-	path    = (char *)__pa_nodebug(ucode_path);</span>
<span class="p_del">-	start   = (void *)p-&gt;hdr.ramdisk_image;</span>
<span class="p_del">-	size    = p-&gt;hdr.ramdisk_size;</span>
<span class="p_del">-#else</span>
<span class="p_del">-	path    = ucode_path;</span>
<span class="p_del">-	start   = (void *)(boot_params.hdr.ramdisk_image + PAGE_OFFSET);</span>
<span class="p_del">-	size    = boot_params.hdr.ramdisk_size;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	return find_cpio_data(path, start, size, &amp;offset);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static size_t compute_container_size(u8 *data, u32 total_size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t size = 0;</span>
<span class="p_del">-	u32 *header = (u32 *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_del">-	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_del">-	    header[2] == 0)                            /* size */</span>
<span class="p_del">-		return size;</span>
<span class="p_del">-</span>
<span class="p_del">-	size = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_del">-	total_size -= size;</span>
<span class="p_del">-	data += size;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (total_size) {</span>
<span class="p_del">-		u16 patch_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		header = (u32 *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (header[0] != UCODE_UCODE_TYPE)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Sanity-check patch size.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		patch_size = header[1];</span>
<span class="p_del">-		if (patch_size &gt; PATCH_MAX_SIZE)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		size	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_del">-		data	   += patch_size + SECTION_HDR_SIZE;</span>
<span class="p_del">-		total_size -= patch_size + SECTION_HDR_SIZE;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return size;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Early load occurs before we can vmalloc(). So we look for the microcode</span>
<span class="p_del">- * patch container file in initrd, traverse equivalent cpu table, look for a</span>
<span class="p_del">- * matching microcode patch, and update, all in initrd memory in place.</span>
<span class="p_del">- * When vmalloc() is available for use later -- on 64-bit during first AP load,</span>
<span class="p_del">- * and on 32-bit during save_microcode_in_initrd_amd() -- we can call</span>
<span class="p_del">- * load_microcode_amd() to save equivalent cpu table and microcode patches in</span>
<span class="p_del">- * kernel heap memory.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void apply_ucode_in_initrd(void *ucode, size_t size, bool save_patch)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct equiv_cpu_entry *eq;</span>
<span class="p_del">-	size_t *cont_sz;</span>
<span class="p_del">-	u32 *header;</span>
<span class="p_del">-	u8  *data, **cont;</span>
<span class="p_del">-	u8 (*patch)[PATCH_MAX_SIZE];</span>
<span class="p_del">-	u16 eq_id = 0;</span>
<span class="p_del">-	int offset, left;</span>
<span class="p_del">-	u32 rev, eax, ebx, ecx, edx;</span>
<span class="p_del">-	u32 *new_rev;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	new_rev = (u32 *)__pa_nodebug(&amp;ucode_new_rev);</span>
<span class="p_del">-	cont_sz = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_del">-	cont	= (u8 **)__pa_nodebug(&amp;container);</span>
<span class="p_del">-	patch	= (u8 (*)[PATCH_MAX_SIZE])__pa_nodebug(&amp;amd_ucode_patch);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	new_rev = &amp;ucode_new_rev;</span>
<span class="p_del">-	cont_sz = &amp;container_size;</span>
<span class="p_del">-	cont	= &amp;container;</span>
<span class="p_del">-	patch	= &amp;amd_ucode_patch;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	data   = ucode;</span>
<span class="p_del">-	left   = size;</span>
<span class="p_del">-	header = (u32 *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* find equiv cpu table */</span>
<span class="p_del">-	if (header[0] != UCODE_MAGIC ||</span>
<span class="p_del">-	    header[1] != UCODE_EQUIV_CPU_TABLE_TYPE || /* type */</span>
<span class="p_del">-	    header[2] == 0)                            /* size */</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	eax = 0x00000001;</span>
<span class="p_del">-	ecx = 0;</span>
<span class="p_del">-	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-</span>
<span class="p_del">-	while (left &gt; 0) {</span>
<span class="p_del">-		eq = (struct equiv_cpu_entry *)(data + CONTAINER_HDR_SZ);</span>
<span class="p_del">-</span>
<span class="p_del">-		*cont = data;</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Advance past the container header */</span>
<span class="p_del">-		offset = header[2] + CONTAINER_HDR_SZ;</span>
<span class="p_del">-		data  += offset;</span>
<span class="p_del">-		left  -= offset;</span>
<span class="p_del">-</span>
<span class="p_del">-		eq_id = find_equiv_id(eq, eax);</span>
<span class="p_del">-		if (eq_id) {</span>
<span class="p_del">-			this_equiv_id = eq_id;</span>
<span class="p_del">-			*cont_sz = compute_container_size(*cont, left + offset);</span>
<span class="p_del">-</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * truncate how much we need to iterate over in the</span>
<span class="p_del">-			 * ucode update loop below</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			left = *cont_sz - offset;</span>
<span class="p_del">-			break;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * support multiple container files appended together. if this</span>
<span class="p_del">-		 * one does not have a matching equivalent cpu entry, we fast</span>
<span class="p_del">-		 * forward to the next container file.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		while (left &gt; 0) {</span>
<span class="p_del">-			header = (u32 *)data;</span>
<span class="p_del">-			if (header[0] == UCODE_MAGIC &amp;&amp;</span>
<span class="p_del">-			    header[1] == UCODE_EQUIV_CPU_TABLE_TYPE)</span>
<span class="p_del">-				break;</span>
<span class="p_del">-</span>
<span class="p_del">-			offset = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_del">-			data  += offset;</span>
<span class="p_del">-			left  -= offset;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		/* mark where the next microcode container file starts */</span>
<span class="p_del">-		offset    = data - (u8 *)ucode;</span>
<span class="p_del">-		ucode     = data;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!eq_id) {</span>
<span class="p_del">-		*cont = NULL;</span>
<span class="p_del">-		*cont_sz = 0;</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* find ucode and update if needed */</span>
<span class="p_del">-</span>
<span class="p_del">-	native_rdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);</span>
<span class="p_del">-</span>
<span class="p_del">-	while (left &gt; 0) {</span>
<span class="p_del">-		struct microcode_amd *mc;</span>
<span class="p_del">-</span>
<span class="p_del">-		header = (u32 *)data;</span>
<span class="p_del">-		if (header[0] != UCODE_UCODE_TYPE || /* type */</span>
<span class="p_del">-		    header[1] == 0)                  /* size */</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc = (struct microcode_amd *)(data + SECTION_HDR_SIZE);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (eq_id == mc-&gt;hdr.processor_rev_id &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_del">-</span>
<span class="p_del">-			if (!__apply_microcode_amd(mc)) {</span>
<span class="p_del">-				rev = mc-&gt;hdr.patch_id;</span>
<span class="p_del">-				*new_rev = rev;</span>
<span class="p_del">-</span>
<span class="p_del">-				if (save_patch)</span>
<span class="p_del">-					memcpy(patch, mc,</span>
<span class="p_del">-					       min_t(u32, header[1], PATCH_MAX_SIZE));</span>
<span class="p_del">-			}</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		offset  = header[1] + SECTION_HDR_SIZE;</span>
<span class="p_del">-		data   += offset;</span>
<span class="p_del">-		left   -= offset;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool __init load_builtin_amd_microcode(struct cpio_data *cp,</span>
<span class="p_del">-					      unsigned int family)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	char fw_name[36] = &quot;amd-ucode/microcode_amd.bin&quot;;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (family &gt;= 0x15)</span>
<span class="p_del">-		snprintf(fw_name, sizeof(fw_name),</span>
<span class="p_del">-			 &quot;amd-ucode/microcode_amd_fam%.2xh.bin&quot;, family);</span>
<span class="p_del">-</span>
<span class="p_del">-	return get_builtin_firmware(cp, fw_name);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init load_ucode_amd_bsp(unsigned int family)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpio_data cp;</span>
<span class="p_del">-	void **data;</span>
<span class="p_del">-	size_t *size;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	data =  (void **)__pa_nodebug(&amp;ucode_cpio.data);</span>
<span class="p_del">-	size = (size_t *)__pa_nodebug(&amp;ucode_cpio.size);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	data = &amp;ucode_cpio.data;</span>
<span class="p_del">-	size = &amp;ucode_cpio.size;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	cp = find_ucode_in_initrd();</span>
<span class="p_del">-	if (!cp.data) {</span>
<span class="p_del">-		if (!load_builtin_amd_microcode(&amp;cp, family))</span>
<span class="p_del">-			return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	*data = cp.data;</span>
<span class="p_del">-	*size = cp.size;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_ucode_in_initrd(cp.data, cp.size, true);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-/*</span>
<span class="p_del">- * On 32-bit, since AP&#39;s early load occurs before paging is turned on, we</span>
<span class="p_del">- * cannot traverse cpu_equiv_table and pcache in kernel heap memory. So during</span>
<span class="p_del">- * cold boot, AP will apply_ucode_in_initrd() just like the BSP. During</span>
<span class="p_del">- * save_microcode_in_initrd_amd() BSP&#39;s patch is copied to amd_ucode_patch,</span>
<span class="p_del">- * which is used upon resume from suspend.</span>
<span class="p_del">- */</span>
<span class="p_del">-void load_ucode_amd_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_amd *mc;</span>
<span class="p_del">-	size_t *usize;</span>
<span class="p_del">-	void **ucode;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc = (struct microcode_amd *)__pa_nodebug(amd_ucode_patch);</span>
<span class="p_del">-	if (mc-&gt;hdr.patch_id &amp;&amp; mc-&gt;hdr.processor_rev_id) {</span>
<span class="p_del">-		__apply_microcode_amd(mc);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	ucode = (void *)__pa_nodebug(&amp;container);</span>
<span class="p_del">-	usize = (size_t *)__pa_nodebug(&amp;container_size);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!*ucode || !*usize)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_ucode_in_initrd(*ucode, *usize, false);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init collect_cpu_sig_on_bsp(void *arg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int cpu = smp_processor_id();</span>
<span class="p_del">-	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;</span>
<span class="p_del">-</span>
<span class="p_del">-	uci-&gt;cpu_sig.sig = cpuid_eax(0x00000001);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init get_bsp_sig(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int bsp = boot_cpu_data.cpu_index;</span>
<span class="p_del">-	struct ucode_cpu_info *uci = ucode_cpu_info + bsp;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!uci-&gt;cpu_sig.sig)</span>
<span class="p_del">-		smp_call_function_single(bsp, collect_cpu_sig_on_bsp, NULL, 1);</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-void load_ucode_amd_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int cpu = smp_processor_id();</span>
<span class="p_del">-	struct ucode_cpu_info *uci = ucode_cpu_info + cpu;</span>
<span class="p_del">-	struct equiv_cpu_entry *eq;</span>
<span class="p_del">-	struct microcode_amd *mc;</span>
<span class="p_del">-	u32 rev, eax;</span>
<span class="p_del">-	u16 eq_id;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Exit if called on the BSP. */</span>
<span class="p_del">-	if (!cpu)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!container)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);</span>
<span class="p_del">-</span>
<span class="p_del">-	uci-&gt;cpu_sig.rev = rev;</span>
<span class="p_del">-	uci-&gt;cpu_sig.sig = eax;</span>
<span class="p_del">-</span>
<span class="p_del">-	eax = cpuid_eax(0x00000001);</span>
<span class="p_del">-	eq  = (struct equiv_cpu_entry *)(container + CONTAINER_HDR_SZ);</span>
<span class="p_del">-</span>
<span class="p_del">-	eq_id = find_equiv_id(eq, eax);</span>
<span class="p_del">-	if (!eq_id)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (eq_id == this_equiv_id) {</span>
<span class="p_del">-		mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_del">-			if (!__apply_microcode_amd(mc))</span>
<span class="p_del">-				ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		if (!ucode_cpio.data)</span>
<span class="p_del">-			return;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * AP has a different equivalence ID than BSP, looks like</span>
<span class="p_del">-		 * mixed-steppings silicon so go through the ucode blob anew.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		apply_ucode_in_initrd(ucode_cpio.data, ucode_cpio.size, false);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-int __init save_microcode_in_initrd_amd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned long cont;</span>
<span class="p_del">-	int retval = 0;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-	u8 *cont_va;</span>
<span class="p_del">-	u32 eax;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!container)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	get_bsp_sig();</span>
<span class="p_del">-	cont	= (unsigned long)container;</span>
<span class="p_del">-	cont_va = __va(container);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We need the physical address of the container for both bitness since</span>
<span class="p_del">-	 * boot_params.hdr.ramdisk_image is a physical address.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	cont    = __pa(container);</span>
<span class="p_del">-	cont_va = container;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Take into account the fact that the ramdisk might get relocated and</span>
<span class="p_del">-	 * therefore we need to recompute the container&#39;s position in virtual</span>
<span class="p_del">-	 * memory space.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (relocated_ramdisk)</span>
<span class="p_del">-		container = (u8 *)(__va(relocated_ramdisk) +</span>
<span class="p_del">-			     (cont - boot_params.hdr.ramdisk_image));</span>
<span class="p_del">-	else</span>
<span class="p_del">-		container = cont_va;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ucode_new_rev)</span>
<span class="p_del">-		pr_info(&quot;microcode: updated early to new patch_level=0x%08x\n&quot;,</span>
<span class="p_del">-			ucode_new_rev);</span>
<span class="p_del">-</span>
<span class="p_del">-	eax   = cpuid_eax(0x00000001);</span>
<span class="p_del">-	eax   = ((eax &gt;&gt; 8) &amp; 0xf) + ((eax &gt;&gt; 20) &amp; 0xff);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = load_microcode_amd(smp_processor_id(), eax, container, container_size);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		retval = -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * This will be freed any msec now, stash patches for the current</span>
<span class="p_del">-	 * family and switch to patch cache for cpu hotplug, etc later.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	container = NULL;</span>
<span class="p_del">-	container_size = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	return retval;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void reload_ucode_amd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_amd *mc;</span>
<span class="p_del">-	u32 rev, eax;</span>
<span class="p_del">-</span>
<span class="p_del">-	rdmsr(MSR_AMD64_PATCH_LEVEL, rev, eax);</span>
<span class="p_del">-</span>
<span class="p_del">-	mc = (struct microcode_amd *)amd_ucode_patch;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc &amp;&amp; rev &lt; mc-&gt;hdr.patch_id) {</span>
<span class="p_del">-		if (!__apply_microcode_amd(mc)) {</span>
<span class="p_del">-			ucode_new_rev = mc-&gt;hdr.patch_id;</span>
<span class="p_del">-			pr_info(&quot;microcode: reload patch_level=0x%08x\n&quot;,</span>
<span class="p_del">-				ucode_new_rev);</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/core.c b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">index 9e3f3c7dd5d7..7fc27f1cca58 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/core.c</span>
<span class="p_chunk">@@ -5,6 +5,12 @@</span> <span class="p_context"></span>
  *	      2006	Shaohua Li &lt;shaohua.li@intel.com&gt;
  *	      2013-2015	Borislav Petkov &lt;bp@alien8.de&gt;
  *
<span class="p_add">+ * X86 CPU microcode early update for Linux:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_add">+ *			   H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_add">+ *		  (C) 2015 Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_add">+ *</span>
  * This driver allows to upgrade microcode on x86 processors.
  *
  * This program is free software; you can redistribute it and/or
<span class="p_chunk">@@ -13,34 +19,39 @@</span> <span class="p_context"></span>
  * 2 of the License, or (at your option) any later version.
  */
 
<span class="p_del">-#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="p_add">+#define pr_fmt(fmt) &quot;microcode: &quot; fmt</span>
 
 #include &lt;linux/platform_device.h&gt;
<span class="p_add">+#include &lt;linux/syscore_ops.h&gt;</span>
 #include &lt;linux/miscdevice.h&gt;
 #include &lt;linux/capability.h&gt;
<span class="p_add">+#include &lt;linux/firmware.h&gt;</span>
 #include &lt;linux/kernel.h&gt;
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/cpu.h&gt;
 #include &lt;linux/fs.h&gt;
 #include &lt;linux/mm.h&gt;
<span class="p_del">-#include &lt;linux/syscore_ops.h&gt;</span>
 
<span class="p_del">-#include &lt;asm/microcode.h&gt;</span>
<span class="p_del">-#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/microcode_intel.h&gt;</span>
 #include &lt;asm/cpu_device_id.h&gt;
<span class="p_add">+#include &lt;asm/microcode_amd.h&gt;</span>
 #include &lt;asm/perf_event.h&gt;
<span class="p_add">+#include &lt;asm/microcode.h&gt;</span>
<span class="p_add">+#include &lt;asm/processor.h&gt;</span>
<span class="p_add">+#include &lt;asm/cmdline.h&gt;</span>
 
<span class="p_del">-MODULE_DESCRIPTION(&quot;Microcode Update Driver&quot;);</span>
<span class="p_del">-MODULE_AUTHOR(&quot;Tigran Aivazian &lt;tigran@aivazian.fsnet.co.uk&gt;&quot;);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-#define MICROCODE_VERSION	&quot;2.00&quot;</span>
<span class="p_add">+#define MICROCODE_VERSION	&quot;2.01&quot;</span>
 
 static struct microcode_ops	*microcode_ops;
 
<span class="p_del">-bool dis_ucode_ldr;</span>
<span class="p_del">-module_param(dis_ucode_ldr, bool, 0);</span>
<span class="p_add">+static bool dis_ucode_ldr;</span>
<span class="p_add">+</span>
<span class="p_add">+static int __init disable_loader(char *str)</span>
<span class="p_add">+{</span>
<span class="p_add">+	dis_ucode_ldr = true;</span>
<span class="p_add">+	return 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+__setup(&quot;dis_ucode_ldr&quot;, disable_loader);</span>
 
 /*
  * Synchronization.
<span class="p_chunk">@@ -68,6 +79,150 @@</span> <span class="p_context"> struct cpu_info_ctx {</span>
 	int			err;
 };
 
<span class="p_add">+static bool __init check_loader_disabled_bsp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	const char *cmdline = (const char *)__pa_nodebug(boot_command_line);</span>
<span class="p_add">+	const char *opt	    = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_add">+	const char *option  = (const char *)__pa_nodebug(opt);</span>
<span class="p_add">+	bool *res = (bool *)__pa_nodebug(&amp;dis_ucode_ldr);</span>
<span class="p_add">+</span>
<span class="p_add">+#else /* CONFIG_X86_64 */</span>
<span class="p_add">+	const char *cmdline = boot_command_line;</span>
<span class="p_add">+	const char *option  = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_add">+	bool *res = &amp;dis_ucode_ldr;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cmdline_find_option_bool(cmdline, option))</span>
<span class="p_add">+		*res = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	return *res;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+extern struct builtin_fw __start_builtin_fw[];</span>
<span class="p_add">+extern struct builtin_fw __end_builtin_fw[];</span>
<span class="p_add">+</span>
<span class="p_add">+bool get_builtin_firmware(struct cpio_data *cd, const char *name)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_FW_LOADER</span>
<span class="p_add">+	struct builtin_fw *b_fw;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {</span>
<span class="p_add">+		if (!strcmp(name, b_fw-&gt;name)) {</span>
<span class="p_add">+			cd-&gt;size = b_fw-&gt;size;</span>
<span class="p_add">+			cd-&gt;data = b_fw-&gt;data;</span>
<span class="p_add">+			return true;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init load_ucode_bsp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int vendor;</span>
<span class="p_add">+	unsigned int family;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (check_loader_disabled_bsp())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!have_cpuid_p())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	vendor = x86_vendor();</span>
<span class="p_add">+	family = x86_family();</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (family &gt;= 6)</span>
<span class="p_add">+			load_ucode_intel_bsp();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (family &gt;= 0x10)</span>
<span class="p_add">+			load_ucode_amd_bsp(family);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static bool check_loader_disabled_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	return *((bool *)__pa_nodebug(&amp;dis_ucode_ldr));</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return dis_ucode_ldr;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void load_ucode_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int vendor, family;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (check_loader_disabled_ap())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!have_cpuid_p())</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	vendor = x86_vendor();</span>
<span class="p_add">+	family = x86_family();</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (family &gt;= 6)</span>
<span class="p_add">+			load_ucode_intel_ap();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (family &gt;= 0x10)</span>
<span class="p_add">+			load_ucode_amd_ap();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int __init save_microcode_in_initrd(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (c-&gt;x86_vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (c-&gt;x86 &gt;= 6)</span>
<span class="p_add">+			save_microcode_in_initrd_intel();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (c-&gt;x86 &gt;= 0x10)</span>
<span class="p_add">+			save_microcode_in_initrd_amd();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void reload_early_microcode(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int vendor, family;</span>
<span class="p_add">+</span>
<span class="p_add">+	vendor = x86_vendor();</span>
<span class="p_add">+	family = x86_family();</span>
<span class="p_add">+</span>
<span class="p_add">+	switch (vendor) {</span>
<span class="p_add">+	case X86_VENDOR_INTEL:</span>
<span class="p_add">+		if (family &gt;= 6)</span>
<span class="p_add">+			reload_ucode_intel();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case X86_VENDOR_AMD:</span>
<span class="p_add">+		if (family &gt;= 0x10)</span>
<span class="p_add">+			reload_ucode_amd();</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void collect_cpu_info_local(void *arg)
 {
 	struct cpu_info_ctx *ctx = arg;
<span class="p_chunk">@@ -210,9 +365,6 @@</span> <span class="p_context"> static void __exit microcode_dev_exit(void)</span>
 {
 	misc_deregister(&amp;microcode_dev);
 }
<span class="p_del">-</span>
<span class="p_del">-MODULE_ALIAS_MISCDEV(MICROCODE_MINOR);</span>
<span class="p_del">-MODULE_ALIAS(&quot;devname:cpu/microcode&quot;);</span>
 #else
 #define microcode_dev_init()	0
 #define microcode_dev_exit()	do { } while (0)
<span class="p_chunk">@@ -463,20 +615,6 @@</span> <span class="p_context"> static struct notifier_block mc_cpu_notifier = {</span>
 	.notifier_call	= mc_cpu_callback,
 };
 
<span class="p_del">-#ifdef MODULE</span>
<span class="p_del">-/* Autoload on Intel and AMD systems */</span>
<span class="p_del">-static const struct x86_cpu_id __initconst microcode_id[] = {</span>
<span class="p_del">-#ifdef CONFIG_MICROCODE_INTEL</span>
<span class="p_del">-	{ X86_VENDOR_INTEL, X86_FAMILY_ANY, X86_MODEL_ANY, },</span>
<span class="p_del">-#endif</span>
<span class="p_del">-#ifdef CONFIG_MICROCODE_AMD</span>
<span class="p_del">-	{ X86_VENDOR_AMD, X86_FAMILY_ANY, X86_MODEL_ANY, },</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	{}</span>
<span class="p_del">-};</span>
<span class="p_del">-MODULE_DEVICE_TABLE(x86cpu, microcode_id);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 static struct attribute *cpu_root_microcode_attrs[] = {
 	&amp;dev_attr_reload.attr,
 	NULL
<span class="p_chunk">@@ -487,9 +625,9 @@</span> <span class="p_context"> static struct attribute_group cpu_root_microcode_group = {</span>
 	.attrs = cpu_root_microcode_attrs,
 };
 
<span class="p_del">-static int __init microcode_init(void)</span>
<span class="p_add">+int __init microcode_init(void)</span>
 {
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;cpu_data(0);</span>
<span class="p_add">+	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
 	int error;
 
 	if (paravirt_enabled() || dis_ucode_ldr)
<span class="p_chunk">@@ -560,35 +698,3 @@</span> <span class="p_context"> static int __init microcode_init(void)</span>
 	return error;
 
 }
<span class="p_del">-module_init(microcode_init);</span>
<span class="p_del">-</span>
<span class="p_del">-static void __exit microcode_exit(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;cpu_data(0);</span>
<span class="p_del">-</span>
<span class="p_del">-	microcode_dev_exit();</span>
<span class="p_del">-</span>
<span class="p_del">-	unregister_hotcpu_notifier(&amp;mc_cpu_notifier);</span>
<span class="p_del">-	unregister_syscore_ops(&amp;mc_syscore_ops);</span>
<span class="p_del">-</span>
<span class="p_del">-	sysfs_remove_group(&amp;cpu_subsys.dev_root-&gt;kobj,</span>
<span class="p_del">-			   &amp;cpu_root_microcode_group);</span>
<span class="p_del">-</span>
<span class="p_del">-	get_online_cpus();</span>
<span class="p_del">-	mutex_lock(&amp;microcode_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	subsys_interface_unregister(&amp;mc_cpu_interface);</span>
<span class="p_del">-</span>
<span class="p_del">-	mutex_unlock(&amp;microcode_mutex);</span>
<span class="p_del">-	put_online_cpus();</span>
<span class="p_del">-</span>
<span class="p_del">-	platform_device_unregister(microcode_pdev);</span>
<span class="p_del">-</span>
<span class="p_del">-	microcode_ops = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (c-&gt;x86_vendor == X86_VENDOR_AMD)</span>
<span class="p_del">-		exit_amd_microcode();</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_info(&quot;Microcode Update Driver: v&quot; MICROCODE_VERSION &quot; removed.\n&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-module_exit(microcode_exit);</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/core_early.c b/arch/x86/kernel/cpu/microcode/core_early.c</span>
deleted file mode 100644
<span class="p_header">index 8ebc421d6299..000000000000</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/core_early.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,170 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- *	X86 CPU microcode early update for Linux</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_del">- *			   H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_del">- *		  (C) 2015 Borislav Petkov &lt;bp@alien8.de&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This driver allows to early upgrade microcode on Intel processors</span>
<span class="p_del">- *	belonging to IA-32 family - PentiumPro, Pentium II,</span>
<span class="p_del">- *	Pentium III, Xeon, Pentium 4, etc.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Reference: Section 9.11 of Volume 3, IA-32 Intel Architecture</span>
<span class="p_del">- *	Software Developer&#39;s Manual.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This program is free software; you can redistribute it and/or</span>
<span class="p_del">- *	modify it under the terms of the GNU General Public License</span>
<span class="p_del">- *	as published by the Free Software Foundation; either version</span>
<span class="p_del">- *	2 of the License, or (at your option) any later version.</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/firmware.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_intel.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_amd.h&gt;</span>
<span class="p_del">-#include &lt;asm/processor.h&gt;</span>
<span class="p_del">-#include &lt;asm/cmdline.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-static bool __init check_loader_disabled_bsp(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	const char *cmdline = (const char *)__pa_nodebug(boot_command_line);</span>
<span class="p_del">-	const char *opt	    = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_del">-	const char *option  = (const char *)__pa_nodebug(opt);</span>
<span class="p_del">-	bool *res = (bool *)__pa_nodebug(&amp;dis_ucode_ldr);</span>
<span class="p_del">-</span>
<span class="p_del">-#else /* CONFIG_X86_64 */</span>
<span class="p_del">-	const char *cmdline = boot_command_line;</span>
<span class="p_del">-	const char *option  = &quot;dis_ucode_ldr&quot;;</span>
<span class="p_del">-	bool *res = &amp;dis_ucode_ldr;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	if (cmdline_find_option_bool(cmdline, option))</span>
<span class="p_del">-		*res = true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return *res;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-extern struct builtin_fw __start_builtin_fw[];</span>
<span class="p_del">-extern struct builtin_fw __end_builtin_fw[];</span>
<span class="p_del">-</span>
<span class="p_del">-bool get_builtin_firmware(struct cpio_data *cd, const char *name)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_FW_LOADER</span>
<span class="p_del">-	struct builtin_fw *b_fw;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (b_fw = __start_builtin_fw; b_fw != __end_builtin_fw; b_fw++) {</span>
<span class="p_del">-		if (!strcmp(name, b_fw-&gt;name)) {</span>
<span class="p_del">-			cd-&gt;size = b_fw-&gt;size;</span>
<span class="p_del">-			cd-&gt;data = b_fw-&gt;data;</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init load_ucode_bsp(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int vendor;</span>
<span class="p_del">-	unsigned int family;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (check_loader_disabled_bsp())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!have_cpuid_p())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	vendor = x86_vendor();</span>
<span class="p_del">-	family = x86_family();</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (family &gt;= 6)</span>
<span class="p_del">-			load_ucode_intel_bsp();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (family &gt;= 0x10)</span>
<span class="p_del">-			load_ucode_amd_bsp(family);</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static bool check_loader_disabled_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	return *((bool *)__pa_nodebug(&amp;dis_ucode_ldr));</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return dis_ucode_ldr;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void load_ucode_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int vendor, family;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (check_loader_disabled_ap())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!have_cpuid_p())</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	vendor = x86_vendor();</span>
<span class="p_del">-	family = x86_family();</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (family &gt;= 6)</span>
<span class="p_del">-			load_ucode_intel_ap();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (family &gt;= 0x10)</span>
<span class="p_del">-			load_ucode_amd_ap();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int __init save_microcode_in_initrd(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (c-&gt;x86_vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (c-&gt;x86 &gt;= 6)</span>
<span class="p_del">-			save_microcode_in_initrd_intel();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (c-&gt;x86 &gt;= 0x10)</span>
<span class="p_del">-			save_microcode_in_initrd_amd();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void reload_early_microcode(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int vendor, family;</span>
<span class="p_del">-</span>
<span class="p_del">-	vendor = x86_vendor();</span>
<span class="p_del">-	family = x86_family();</span>
<span class="p_del">-</span>
<span class="p_del">-	switch (vendor) {</span>
<span class="p_del">-	case X86_VENDOR_INTEL:</span>
<span class="p_del">-		if (family &gt;= 6)</span>
<span class="p_del">-			reload_ucode_intel();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	case X86_VENDOR_AMD:</span>
<span class="p_del">-		if (family &gt;= 0x10)</span>
<span class="p_del">-			reload_ucode_amd();</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel.c b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">index 969dc17eb1b4..ce47402eb2f9 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel.c</span>
<span class="p_chunk">@@ -4,27 +4,804 @@</span> <span class="p_context"></span>
  * Copyright (C) 2000-2006 Tigran Aivazian &lt;tigran@aivazian.fsnet.co.uk&gt;
  *		 2006 Shaohua Li &lt;shaohua.li@intel.com&gt;
  *
<span class="p_add">+ * Intel CPU microcode early update for Linux</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_add">+ *		      H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_add">+ *</span>
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version
  * 2 of the License, or (at your option) any later version.
  */
 
<span class="p_del">-#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This needs to be before all headers so that pr_debug in printk.h doesn&#39;t turn</span>
<span class="p_add">+ * printk calls into no_printk().</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *#define DEBUG</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define pr_fmt(fmt) &quot;microcode: &quot; fmt</span>
 
<span class="p_add">+#include &lt;linux/earlycpio.h&gt;</span>
 #include &lt;linux/firmware.h&gt;
 #include &lt;linux/uaccess.h&gt;
<span class="p_del">-#include &lt;linux/kernel.h&gt;</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
 #include &lt;linux/vmalloc.h&gt;
<span class="p_add">+#include &lt;linux/initrd.h&gt;</span>
<span class="p_add">+#include &lt;linux/kernel.h&gt;</span>
<span class="p_add">+#include &lt;linux/slab.h&gt;</span>
<span class="p_add">+#include &lt;linux/cpu.h&gt;</span>
<span class="p_add">+#include &lt;linux/mm.h&gt;</span>
 
 #include &lt;asm/microcode_intel.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_add">+#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_add">+#include &lt;asm/setup.h&gt;</span>
 #include &lt;asm/msr.h&gt;
 
<span class="p_del">-MODULE_DESCRIPTION(&quot;Microcode Update Driver&quot;);</span>
<span class="p_del">-MODULE_AUTHOR(&quot;Tigran Aivazian &lt;tigran@aivazian.fsnet.co.uk&gt;&quot;);</span>
<span class="p_del">-MODULE_LICENSE(&quot;GPL&quot;);</span>
<span class="p_add">+static unsigned long mc_saved_in_initrd[MAX_UCODE_COUNT];</span>
<span class="p_add">+static struct mc_saved_data {</span>
<span class="p_add">+	unsigned int mc_saved_count;</span>
<span class="p_add">+	struct microcode_intel **mc_saved;</span>
<span class="p_add">+} mc_saved_data;</span>
<span class="p_add">+</span>
<span class="p_add">+static enum ucode_state</span>
<span class="p_add">+load_microcode_early(struct microcode_intel **saved,</span>
<span class="p_add">+		     unsigned int num_saved, struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *ucode_ptr, *new_mc = NULL;</span>
<span class="p_add">+	struct microcode_header_intel *mc_hdr;</span>
<span class="p_add">+	int new_rev, ret, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	new_rev = uci-&gt;cpu_sig.rev;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_add">+		ucode_ptr = saved[i];</span>
<span class="p_add">+		mc_hdr	  = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = has_newer_microcode(ucode_ptr,</span>
<span class="p_add">+					  uci-&gt;cpu_sig.sig,</span>
<span class="p_add">+					  uci-&gt;cpu_sig.pf,</span>
<span class="p_add">+					  new_rev);</span>
<span class="p_add">+		if (!ret)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		new_rev = mc_hdr-&gt;rev;</span>
<span class="p_add">+		new_mc  = ucode_ptr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!new_mc)</span>
<span class="p_add">+		return UCODE_NFOUND;</span>
<span class="p_add">+</span>
<span class="p_add">+	uci-&gt;mc = (struct microcode_intel *)new_mc;</span>
<span class="p_add">+	return UCODE_OK;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void</span>
<span class="p_add">+copy_initrd_ptrs(struct microcode_intel **mc_saved, unsigned long *initrd,</span>
<span class="p_add">+		  unsigned long off, int num_saved)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++)</span>
<span class="p_add">+		mc_saved[i] = (struct microcode_intel *)(initrd[i] + off);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+static void</span>
<span class="p_add">+microcode_phys(struct microcode_intel **mc_saved_tmp,</span>
<span class="p_add">+	       struct mc_saved_data *mc_saved_data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	struct microcode_intel ***mc_saved;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved = (struct microcode_intel ***)</span>
<span class="p_add">+		   __pa_nodebug(&amp;mc_saved_data-&gt;mc_saved);</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_data-&gt;mc_saved_count; i++) {</span>
<span class="p_add">+		struct microcode_intel *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		p = *(struct microcode_intel **)</span>
<span class="p_add">+			__pa_nodebug(mc_saved_data-&gt;mc_saved + i);</span>
<span class="p_add">+		mc_saved_tmp[i] = (struct microcode_intel *)__pa_nodebug(p);</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static enum ucode_state</span>
<span class="p_add">+load_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_add">+	       unsigned long initrd_start, struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_add">+	unsigned int count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mc_saved_data-&gt;mc_saved) {</span>
<span class="p_add">+		copy_initrd_ptrs(mc_saved_tmp, initrd, initrd_start, count);</span>
<span class="p_add">+</span>
<span class="p_add">+		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+		microcode_phys(mc_saved_tmp, mc_saved_data);</span>
<span class="p_add">+		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_add">+#else</span>
<span class="p_add">+		return load_microcode_early(mc_saved_data-&gt;mc_saved,</span>
<span class="p_add">+						    count, uci);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Given CPU signature and a microcode patch, this function finds if the</span>
<span class="p_add">+ * microcode patch has matching family and model with the CPU.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static enum ucode_state</span>
<span class="p_add">+matching_model_microcode(struct microcode_header_intel *mc_header,</span>
<span class="p_add">+			unsigned long sig)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int fam, model;</span>
<span class="p_add">+	unsigned int fam_ucode, model_ucode;</span>
<span class="p_add">+	struct extended_sigtable *ext_header;</span>
<span class="p_add">+	unsigned long total_size = get_totalsize(mc_header);</span>
<span class="p_add">+	unsigned long data_size = get_datasize(mc_header);</span>
<span class="p_add">+	int ext_sigcount, i;</span>
<span class="p_add">+	struct extended_signature *ext_sig;</span>
<span class="p_add">+</span>
<span class="p_add">+	fam   = __x86_family(sig);</span>
<span class="p_add">+	model = x86_model(sig);</span>
<span class="p_add">+</span>
<span class="p_add">+	fam_ucode   = __x86_family(mc_header-&gt;sig);</span>
<span class="p_add">+	model_ucode = x86_model(mc_header-&gt;sig);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_add">+		return UCODE_OK;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Look for ext. headers: */</span>
<span class="p_add">+	if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_add">+		return UCODE_NFOUND;</span>
<span class="p_add">+</span>
<span class="p_add">+	ext_header   = (void *) mc_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_add">+	ext_sig      = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_add">+	ext_sigcount = ext_header-&gt;count;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ext_sigcount; i++) {</span>
<span class="p_add">+		fam_ucode   = __x86_family(ext_sig-&gt;sig);</span>
<span class="p_add">+		model_ucode = x86_model(ext_sig-&gt;sig);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_add">+			return UCODE_OK;</span>
<span class="p_add">+</span>
<span class="p_add">+		ext_sig++;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return UCODE_NFOUND;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int</span>
<span class="p_add">+save_microcode(struct mc_saved_data *mc_saved_data,</span>
<span class="p_add">+	       struct microcode_intel **mc_saved_src,</span>
<span class="p_add">+	       unsigned int mc_saved_count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i, j;</span>
<span class="p_add">+	struct microcode_intel **saved_ptr;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mc_saved_count)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Copy new microcode data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	saved_ptr = kcalloc(mc_saved_count, sizeof(struct microcode_intel *), GFP_KERNEL);</span>
<span class="p_add">+	if (!saved_ptr)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_count; i++) {</span>
<span class="p_add">+		struct microcode_header_intel *mc_hdr;</span>
<span class="p_add">+		struct microcode_intel *mc;</span>
<span class="p_add">+		unsigned long size;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!mc_saved_src[i]) {</span>
<span class="p_add">+			ret = -EINVAL;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mc     = mc_saved_src[i];</span>
<span class="p_add">+		mc_hdr = &amp;mc-&gt;hdr;</span>
<span class="p_add">+		size   = get_totalsize(mc_hdr);</span>
<span class="p_add">+</span>
<span class="p_add">+		saved_ptr[i] = kmalloc(size, GFP_KERNEL);</span>
<span class="p_add">+		if (!saved_ptr[i]) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto err;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		memcpy(saved_ptr[i], mc, size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Point to newly saved microcode.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mc_saved_data-&gt;mc_saved = saved_ptr;</span>
<span class="p_add">+	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+err:</span>
<span class="p_add">+	for (j = 0; j &lt;= i; j++)</span>
<span class="p_add">+		kfree(saved_ptr[j]);</span>
<span class="p_add">+	kfree(saved_ptr);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * A microcode patch in ucode_ptr is saved into mc_saved</span>
<span class="p_add">+ * - if it has matching signature and newer revision compared to an existing</span>
<span class="p_add">+ *   patch mc_saved.</span>
<span class="p_add">+ * - or if it is a newly discovered microcode patch.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The microcode patch should have matching model with CPU.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns: The updated number @num_saved of saved microcode patches.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static unsigned int _save_mc(struct microcode_intel **mc_saved,</span>
<span class="p_add">+			     u8 *ucode_ptr, unsigned int num_saved)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_header_intel *mc_hdr, *mc_saved_hdr;</span>
<span class="p_add">+	unsigned int sig, pf;</span>
<span class="p_add">+	int found = 0, i;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_hdr = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_add">+		mc_saved_hdr = (struct microcode_header_intel *)mc_saved[i];</span>
<span class="p_add">+		sig	     = mc_saved_hdr-&gt;sig;</span>
<span class="p_add">+		pf	     = mc_saved_hdr-&gt;pf;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!find_matching_signature(ucode_ptr, sig, pf))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		found = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (mc_hdr-&gt;rev &lt;= mc_saved_hdr-&gt;rev)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Found an older ucode saved earlier. Replace it with</span>
<span class="p_add">+		 * this newer one.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mc_saved[i] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Newly detected microcode, save it to memory. */</span>
<span class="p_add">+	if (i &gt;= num_saved &amp;&amp; !found)</span>
<span class="p_add">+		mc_saved[num_saved++] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+	return num_saved;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Get microcode matching with BSP&#39;s model. Only CPUs with the same model as</span>
<span class="p_add">+ * BSP can stay in the platform.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static enum ucode_state __init</span>
<span class="p_add">+get_matching_model_microcode(int cpu, unsigned long start,</span>
<span class="p_add">+			     void *data, size_t size,</span>
<span class="p_add">+			     struct mc_saved_data *mc_saved_data,</span>
<span class="p_add">+			     unsigned long *mc_saved_in_initrd,</span>
<span class="p_add">+			     struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u8 *ucode_ptr = data;</span>
<span class="p_add">+	unsigned int leftover = size;</span>
<span class="p_add">+	enum ucode_state state = UCODE_OK;</span>
<span class="p_add">+	unsigned int mc_size;</span>
<span class="p_add">+	struct microcode_header_intel *mc_header;</span>
<span class="p_add">+	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_add">+	unsigned int mc_saved_count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (leftover &amp;&amp; mc_saved_count &lt; ARRAY_SIZE(mc_saved_tmp)) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (leftover &lt; sizeof(mc_header))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_header = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_size = get_totalsize(mc_header);</span>
<span class="p_add">+		if (!mc_size || mc_size &gt; leftover ||</span>
<span class="p_add">+			microcode_sanity_check(ucode_ptr, 0) &lt; 0)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		leftover -= mc_size;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Since APs with same family and model as the BSP may boot in</span>
<span class="p_add">+		 * the platform, we need to find and save microcode patches</span>
<span class="p_add">+		 * with the same family and model as the BSP.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (matching_model_microcode(mc_header, uci-&gt;cpu_sig.sig) !=</span>
<span class="p_add">+			 UCODE_OK) {</span>
<span class="p_add">+			ucode_ptr += mc_size;</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_saved_count = _save_mc(mc_saved_tmp, ucode_ptr, mc_saved_count);</span>
<span class="p_add">+</span>
<span class="p_add">+		ucode_ptr += mc_size;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (leftover) {</span>
<span class="p_add">+		state = UCODE_ERROR;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc_saved_count == 0) {</span>
<span class="p_add">+		state = UCODE_NFOUND;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_count; i++)</span>
<span class="p_add">+		mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_add">+out:</span>
<span class="p_add">+	return state;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static int collect_cpu_info_early(struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int val[2];</span>
<span class="p_add">+	unsigned int family, model;</span>
<span class="p_add">+	struct cpu_signature csig;</span>
<span class="p_add">+	unsigned int eax, ebx, ecx, edx;</span>
<span class="p_add">+</span>
<span class="p_add">+	csig.sig = 0;</span>
<span class="p_add">+	csig.pf = 0;</span>
<span class="p_add">+	csig.rev = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	memset(uci, 0, sizeof(*uci));</span>
<span class="p_add">+</span>
<span class="p_add">+	eax = 0x00000001;</span>
<span class="p_add">+	ecx = 0;</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+	csig.sig = eax;</span>
<span class="p_add">+</span>
<span class="p_add">+	family = __x86_family(csig.sig);</span>
<span class="p_add">+	model  = x86_model(csig.sig);</span>
<span class="p_add">+</span>
<span class="p_add">+	if ((model &gt;= 5) || (family &gt; 6)) {</span>
<span class="p_add">+		/* get processor flags from MSR 0x17 */</span>
<span class="p_add">+		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);</span>
<span class="p_add">+		csig.pf = 1 &lt;&lt; ((val[1] &gt;&gt; 18) &amp; 7);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_add">+	sync_core();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get the current revision from MSR 0x8B */</span>
<span class="p_add">+	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_add">+</span>
<span class="p_add">+	csig.rev = val[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	uci-&gt;cpu_sig = csig;</span>
<span class="p_add">+	uci-&gt;valid = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void show_saved_mc(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef DEBUG</span>
<span class="p_add">+	int i, j;</span>
<span class="p_add">+	unsigned int sig, pf, rev, total_size, data_size, date;</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc_saved_data.mc_saved_count == 0) {</span>
<span class="p_add">+		pr_debug(&quot;no microcode data saved.\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	pr_debug(&quot;Total microcode saved: %d\n&quot;, mc_saved_data.mc_saved_count);</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	sig = uci.cpu_sig.sig;</span>
<span class="p_add">+	pf = uci.cpu_sig.pf;</span>
<span class="p_add">+	rev = uci.cpu_sig.rev;</span>
<span class="p_add">+	pr_debug(&quot;CPU: sig=0x%x, pf=0x%x, rev=0x%x\n&quot;, sig, pf, rev);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; mc_saved_data.mc_saved_count; i++) {</span>
<span class="p_add">+		struct microcode_header_intel *mc_saved_header;</span>
<span class="p_add">+		struct extended_sigtable *ext_header;</span>
<span class="p_add">+		int ext_sigcount;</span>
<span class="p_add">+		struct extended_signature *ext_sig;</span>
<span class="p_add">+</span>
<span class="p_add">+		mc_saved_header = (struct microcode_header_intel *)</span>
<span class="p_add">+				  mc_saved_data.mc_saved[i];</span>
<span class="p_add">+		sig = mc_saved_header-&gt;sig;</span>
<span class="p_add">+		pf = mc_saved_header-&gt;pf;</span>
<span class="p_add">+		rev = mc_saved_header-&gt;rev;</span>
<span class="p_add">+		total_size = get_totalsize(mc_saved_header);</span>
<span class="p_add">+		data_size = get_datasize(mc_saved_header);</span>
<span class="p_add">+		date = mc_saved_header-&gt;date;</span>
<span class="p_add">+</span>
<span class="p_add">+		pr_debug(&quot;mc_saved[%d]: sig=0x%x, pf=0x%x, rev=0x%x, toal size=0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_add">+			 i, sig, pf, rev, total_size,</span>
<span class="p_add">+			 date &amp; 0xffff,</span>
<span class="p_add">+			 date &gt;&gt; 24,</span>
<span class="p_add">+			 (date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Look for ext. headers: */</span>
<span class="p_add">+		if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		ext_header = (void *) mc_saved_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_add">+		ext_sigcount = ext_header-&gt;count;</span>
<span class="p_add">+		ext_sig = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (j = 0; j &lt; ext_sigcount; j++) {</span>
<span class="p_add">+			sig = ext_sig-&gt;sig;</span>
<span class="p_add">+			pf = ext_sig-&gt;pf;</span>
<span class="p_add">+</span>
<span class="p_add">+			pr_debug(&quot;\tExtended[%d]: sig=0x%x, pf=0x%x\n&quot;,</span>
<span class="p_add">+				 j, sig, pf);</span>
<span class="p_add">+</span>
<span class="p_add">+			ext_sig++;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_HOTPLUG_CPU</span>
<span class="p_add">+static DEFINE_MUTEX(x86_cpu_microcode_mutex);</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Save this mc into mc_saved_data. So it will be loaded early when a CPU is</span>
<span class="p_add">+ * hot added or resumes.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Please make sure this mc should be a valid microcode patch before calling</span>
<span class="p_add">+ * this function.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int save_mc_for_early(u8 *mc)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_add">+	unsigned int mc_saved_count_init;</span>
<span class="p_add">+	unsigned int mc_saved_count;</span>
<span class="p_add">+	struct microcode_intel **mc_saved;</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Hold hotplug lock so mc_saved_data is not accessed by a CPU in</span>
<span class="p_add">+	 * hotplug.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved_count_init = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	mc_saved_count = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	mc_saved = mc_saved_data.mc_saved;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mc_saved &amp;&amp; mc_saved_count)</span>
<span class="p_add">+		memcpy(mc_saved_tmp, mc_saved,</span>
<span class="p_add">+		       mc_saved_count * sizeof(struct microcode_intel *));</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Save the microcode patch mc in mc_save_tmp structure if it&#39;s a newer</span>
<span class="p_add">+	 * version.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mc_saved_count = _save_mc(mc_saved_tmp, mc, mc_saved_count);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Save the mc_save_tmp in global mc_saved_data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ret = save_microcode(&amp;mc_saved_data, mc_saved_tmp, mc_saved_count);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;Cannot save microcode patch.\n&quot;);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	show_saved_mc();</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Free old saved microcode data.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mc_saved) {</span>
<span class="p_add">+		for (i = 0; i &lt; mc_saved_count_init; i++)</span>
<span class="p_add">+			kfree(mc_saved[i]);</span>
<span class="p_add">+		kfree(mc_saved);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	mutex_unlock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(save_mc_for_early);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static bool __init load_builtin_intel_microcode(struct cpio_data *cp)</span>
<span class="p_add">+{</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	unsigned int eax = 0x00000001, ebx, ecx = 0, edx;</span>
<span class="p_add">+	unsigned int family, model, stepping;</span>
<span class="p_add">+	char name[30];</span>
<span class="p_add">+</span>
<span class="p_add">+	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_add">+</span>
<span class="p_add">+	family   = __x86_family(eax);</span>
<span class="p_add">+	model    = x86_model(eax);</span>
<span class="p_add">+	stepping = eax &amp; 0xf;</span>
<span class="p_add">+</span>
<span class="p_add">+	sprintf(name, &quot;intel-ucode/%02x-%02x-%02x&quot;, family, model, stepping);</span>
<span class="p_add">+</span>
<span class="p_add">+	return get_builtin_firmware(cp, name);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return false;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static __initdata char ucode_name[] = &quot;kernel/x86/microcode/GenuineIntel.bin&quot;;</span>
<span class="p_add">+static __init enum ucode_state</span>
<span class="p_add">+scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_add">+	       unsigned long start, unsigned long size,</span>
<span class="p_add">+	       struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpio_data cd;</span>
<span class="p_add">+	long offset = 0;</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	char *p = (char *)__pa_nodebug(ucode_name);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	char *p = ucode_name;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	cd.data = NULL;</span>
<span class="p_add">+	cd.size = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_add">+	if (!cd.data) {</span>
<span class="p_add">+		if (!load_builtin_intel_microcode(&amp;cd))</span>
<span class="p_add">+			return UCODE_ERROR;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return get_matching_model_microcode(0, start, cd.data, cd.size,</span>
<span class="p_add">+					    mc_saved_data, initrd, uci);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Print ucode update info.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void</span>
<span class="p_add">+print_ucode_info(struct ucode_cpu_info *uci, unsigned int date)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu = smp_processor_id();</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_info(&quot;CPU%d microcode updated early to revision 0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_add">+		cpu,</span>
<span class="p_add">+		uci-&gt;cpu_sig.rev,</span>
<span class="p_add">+		date &amp; 0xffff,</span>
<span class="p_add">+		date &gt;&gt; 24,</span>
<span class="p_add">+		(date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+</span>
<span class="p_add">+static int delay_ucode_info;</span>
<span class="p_add">+static int current_mc_date;</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Print early updated ucode info after printk works. This is delayed info dump.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void show_ucode_info_early(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (delay_ucode_info) {</span>
<span class="p_add">+		collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+		print_ucode_info(&amp;uci, current_mc_date);</span>
<span class="p_add">+		delay_ucode_info = 0;</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * At this point, we can not call printk() yet. Keep microcode patch number in</span>
<span class="p_add">+ * mc_saved_data.mc_saved and delay printing microcode info in</span>
<span class="p_add">+ * show_ucode_info_early() until printk() works.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	int *delay_ucode_info_p;</span>
<span class="p_add">+	int *current_mc_date_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_intel = uci-&gt;mc;</span>
<span class="p_add">+	if (mc_intel == NULL)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	delay_ucode_info_p = (int *)__pa_nodebug(&amp;delay_ucode_info);</span>
<span class="p_add">+	current_mc_date_p = (int *)__pa_nodebug(&amp;current_mc_date);</span>
<span class="p_add">+</span>
<span class="p_add">+	*delay_ucode_info_p = 1;</span>
<span class="p_add">+	*current_mc_date_p = mc_intel-&gt;hdr.date;</span>
<span class="p_add">+}</span>
<span class="p_add">+#else</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Flush global tlb. We only do this in x86_64 where paging has been enabled</span>
<span class="p_add">+ * already and PGE should be enabled as well.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static inline void flush_tlb_early(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	__native_flush_tlb_global_irq_disabled();</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_intel;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_intel = uci-&gt;mc;</span>
<span class="p_add">+	if (mc_intel == NULL)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct microcode_intel *mc_intel;</span>
<span class="p_add">+	unsigned int val[2];</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_intel = uci-&gt;mc;</span>
<span class="p_add">+	if (mc_intel == NULL)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* write microcode via MSR 0x79 */</span>
<span class="p_add">+	native_wrmsr(MSR_IA32_UCODE_WRITE,</span>
<span class="p_add">+	      (unsigned long) mc_intel-&gt;bits,</span>
<span class="p_add">+	      (unsigned long) mc_intel-&gt;bits &gt;&gt; 16 &gt;&gt; 16);</span>
<span class="p_add">+	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_add">+	sync_core();</span>
<span class="p_add">+</span>
<span class="p_add">+	/* get the current revision from MSR 0x8B */</span>
<span class="p_add">+	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_add">+	if (val[1] != mc_intel-&gt;hdr.rev)</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
<span class="p_add">+#ifdef CONFIG_X86_64</span>
<span class="p_add">+	/* Flush global tlb. This is precaution. */</span>
<span class="p_add">+	flush_tlb_early();</span>
<span class="p_add">+#endif</span>
<span class="p_add">+	uci-&gt;cpu_sig.rev = val[1];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (early)</span>
<span class="p_add">+		print_ucode(uci);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * This function converts microcode patch offsets previously stored in</span>
<span class="p_add">+ * mc_saved_in_initrd to pointers and stores the pointers in mc_saved_data.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int __init save_microcode_in_initrd_intel(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	unsigned int count = mc_saved_data.mc_saved_count;</span>
<span class="p_add">+	struct microcode_intel *mc_saved[MAX_UCODE_COUNT];</span>
<span class="p_add">+	int ret = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (count == 0)</span>
<span class="p_add">+		return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	copy_initrd_ptrs(mc_saved, mc_saved_in_initrd, initrd_start, count);</span>
<span class="p_add">+	ret = save_microcode(&amp;mc_saved_data, mc_saved, count);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		pr_err(&quot;Cannot save microcode patches from initrd.\n&quot;);</span>
<span class="p_add">+</span>
<span class="p_add">+	show_saved_mc();</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init</span>
<span class="p_add">+_load_ucode_intel_bsp(struct mc_saved_data *mc_saved_data,</span>
<span class="p_add">+		      unsigned long *initrd,</span>
<span class="p_add">+		      unsigned long start, unsigned long size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = scan_microcode(mc_saved_data, initrd, start, size, &amp;uci);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = load_microcode(mc_saved_data, initrd, start, &amp;uci);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_microcode_early(&amp;uci, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void __init load_ucode_intel_bsp(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 start, size;</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	struct boot_params *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	p	= (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_add">+	start	= p-&gt;hdr.ramdisk_image;</span>
<span class="p_add">+	size	= p-&gt;hdr.ramdisk_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	_load_ucode_intel_bsp(</span>
<span class="p_add">+			(struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_add">+			(unsigned long *)__pa_nodebug(&amp;mc_saved_in_initrd),</span>
<span class="p_add">+			start, size);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	start	= boot_params.hdr.ramdisk_image + PAGE_OFFSET;</span>
<span class="p_add">+	size	= boot_params.hdr.ramdisk_size;</span>
<span class="p_add">+</span>
<span class="p_add">+	_load_ucode_intel_bsp(&amp;mc_saved_data, mc_saved_in_initrd, start, size);</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void load_ucode_intel_ap(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mc_saved_data *mc_saved_data_p;</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+	unsigned long *mc_saved_in_initrd_p;</span>
<span class="p_add">+	unsigned long initrd_start_addr;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+#ifdef CONFIG_X86_32</span>
<span class="p_add">+	unsigned long *initrd_start_p;</span>
<span class="p_add">+</span>
<span class="p_add">+	mc_saved_in_initrd_p =</span>
<span class="p_add">+		(unsigned long *)__pa_nodebug(mc_saved_in_initrd);</span>
<span class="p_add">+	mc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data);</span>
<span class="p_add">+	initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_add">+	initrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	mc_saved_data_p = &amp;mc_saved_data;</span>
<span class="p_add">+	mc_saved_in_initrd_p = mc_saved_in_initrd;</span>
<span class="p_add">+	initrd_start_addr = initrd_start;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If there is no valid ucode previously saved in memory, no need to</span>
<span class="p_add">+	 * update ucode on this AP.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (mc_saved_data_p-&gt;mc_saved_count == 0)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+	ret = load_microcode(mc_saved_data_p, mc_saved_in_initrd_p,</span>
<span class="p_add">+			     initrd_start_addr, &amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_microcode_early(&amp;uci, true);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void reload_ucode_intel(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ucode_cpu_info uci;</span>
<span class="p_add">+	enum ucode_state ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!mc_saved_data.mc_saved_count)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	collect_cpu_info_early(&amp;uci);</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = load_microcode_early(mc_saved_data.mc_saved,</span>
<span class="p_add">+				   mc_saved_data.mc_saved_count, &amp;uci);</span>
<span class="p_add">+	if (ret != UCODE_OK)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	apply_microcode_early(&amp;uci, false);</span>
<span class="p_add">+}</span>
 
 static int collect_cpu_info(int cpu_num, struct cpu_signature *csig)
 {
<span class="p_chunk">@@ -264,7 +1041,7 @@</span> <span class="p_context"> static struct microcode_ops microcode_intel_ops = {</span>
 
 struct microcode_ops * __init init_intel_microcode(void)
 {
<span class="p_del">-	struct cpuinfo_x86 *c = &amp;cpu_data(0);</span>
<span class="p_add">+	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
 
 	if (c-&gt;x86_vendor != X86_VENDOR_INTEL || c-&gt;x86 &lt; 6 ||
 	    cpu_has(c, X86_FEATURE_IA64)) {
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel_early.c b/arch/x86/kernel/cpu/microcode/intel_early.c</span>
deleted file mode 100644
<span class="p_header">index 37ea89c11520..000000000000</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel_early.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,808 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- *	Intel CPU microcode early update for Linux</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Copyright (C) 2012 Fenghua Yu &lt;fenghua.yu@intel.com&gt;</span>
<span class="p_del">- *			   H Peter Anvin&quot; &lt;hpa@zytor.com&gt;</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This allows to early upgrade microcode on Intel processors</span>
<span class="p_del">- *	belonging to IA-32 family - PentiumPro, Pentium II,</span>
<span class="p_del">- *	Pentium III, Xeon, Pentium 4, etc.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	Reference: Section 9.11 of Volume 3, IA-32 Intel Architecture</span>
<span class="p_del">- *	Software Developer&#39;s Manual.</span>
<span class="p_del">- *</span>
<span class="p_del">- *	This program is free software; you can redistribute it and/or</span>
<span class="p_del">- *	modify it under the terms of the GNU General Public License</span>
<span class="p_del">- *	as published by the Free Software Foundation; either version</span>
<span class="p_del">- *	2 of the License, or (at your option) any later version.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This needs to be before all headers so that pr_debug in printk.h doesn&#39;t turn</span>
<span class="p_del">- * printk calls into no_printk().</span>
<span class="p_del">- *</span>
<span class="p_del">- *#define DEBUG</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-#include &lt;linux/earlycpio.h&gt;</span>
<span class="p_del">-#include &lt;linux/initrd.h&gt;</span>
<span class="p_del">-#include &lt;linux/cpu.h&gt;</span>
<span class="p_del">-#include &lt;asm/msr.h&gt;</span>
<span class="p_del">-#include &lt;asm/microcode_intel.h&gt;</span>
<span class="p_del">-#include &lt;asm/processor.h&gt;</span>
<span class="p_del">-#include &lt;asm/tlbflush.h&gt;</span>
<span class="p_del">-#include &lt;asm/setup.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-#undef pr_fmt</span>
<span class="p_del">-#define pr_fmt(fmt)	&quot;microcode: &quot; fmt</span>
<span class="p_del">-</span>
<span class="p_del">-static unsigned long mc_saved_in_initrd[MAX_UCODE_COUNT];</span>
<span class="p_del">-static struct mc_saved_data {</span>
<span class="p_del">-	unsigned int mc_saved_count;</span>
<span class="p_del">-	struct microcode_intel **mc_saved;</span>
<span class="p_del">-} mc_saved_data;</span>
<span class="p_del">-</span>
<span class="p_del">-static enum ucode_state</span>
<span class="p_del">-load_microcode_early(struct microcode_intel **saved,</span>
<span class="p_del">-		     unsigned int num_saved, struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *ucode_ptr, *new_mc = NULL;</span>
<span class="p_del">-	struct microcode_header_intel *mc_hdr;</span>
<span class="p_del">-	int new_rev, ret, i;</span>
<span class="p_del">-</span>
<span class="p_del">-	new_rev = uci-&gt;cpu_sig.rev;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_del">-		ucode_ptr = saved[i];</span>
<span class="p_del">-		mc_hdr	  = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-		ret = has_newer_microcode(ucode_ptr,</span>
<span class="p_del">-					  uci-&gt;cpu_sig.sig,</span>
<span class="p_del">-					  uci-&gt;cpu_sig.pf,</span>
<span class="p_del">-					  new_rev);</span>
<span class="p_del">-		if (!ret)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		new_rev = mc_hdr-&gt;rev;</span>
<span class="p_del">-		new_mc  = ucode_ptr;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!new_mc)</span>
<span class="p_del">-		return UCODE_NFOUND;</span>
<span class="p_del">-</span>
<span class="p_del">-	uci-&gt;mc = (struct microcode_intel *)new_mc;</span>
<span class="p_del">-	return UCODE_OK;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void</span>
<span class="p_del">-copy_initrd_ptrs(struct microcode_intel **mc_saved, unsigned long *initrd,</span>
<span class="p_del">-		  unsigned long off, int num_saved)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_saved; i++)</span>
<span class="p_del">-		mc_saved[i] = (struct microcode_intel *)(initrd[i] + off);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-static void</span>
<span class="p_del">-microcode_phys(struct microcode_intel **mc_saved_tmp,</span>
<span class="p_del">-	       struct mc_saved_data *mc_saved_data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-	struct microcode_intel ***mc_saved;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved = (struct microcode_intel ***)</span>
<span class="p_del">-		   __pa_nodebug(&amp;mc_saved_data-&gt;mc_saved);</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_data-&gt;mc_saved_count; i++) {</span>
<span class="p_del">-		struct microcode_intel *p;</span>
<span class="p_del">-</span>
<span class="p_del">-		p = *(struct microcode_intel **)</span>
<span class="p_del">-			__pa_nodebug(mc_saved_data-&gt;mc_saved + i);</span>
<span class="p_del">-		mc_saved_tmp[i] = (struct microcode_intel *)__pa_nodebug(p);</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static enum ucode_state</span>
<span class="p_del">-load_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_del">-	       unsigned long initrd_start, struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_del">-	unsigned int count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mc_saved_data-&gt;mc_saved) {</span>
<span class="p_del">-		copy_initrd_ptrs(mc_saved_tmp, initrd, initrd_start, count);</span>
<span class="p_del">-</span>
<span class="p_del">-		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-		microcode_phys(mc_saved_tmp, mc_saved_data);</span>
<span class="p_del">-		return load_microcode_early(mc_saved_tmp, count, uci);</span>
<span class="p_del">-#else</span>
<span class="p_del">-		return load_microcode_early(mc_saved_data-&gt;mc_saved,</span>
<span class="p_del">-						    count, uci);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Given CPU signature and a microcode patch, this function finds if the</span>
<span class="p_del">- * microcode patch has matching family and model with the CPU.</span>
<span class="p_del">- */</span>
<span class="p_del">-static enum ucode_state</span>
<span class="p_del">-matching_model_microcode(struct microcode_header_intel *mc_header,</span>
<span class="p_del">-			unsigned long sig)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int fam, model;</span>
<span class="p_del">-	unsigned int fam_ucode, model_ucode;</span>
<span class="p_del">-	struct extended_sigtable *ext_header;</span>
<span class="p_del">-	unsigned long total_size = get_totalsize(mc_header);</span>
<span class="p_del">-	unsigned long data_size = get_datasize(mc_header);</span>
<span class="p_del">-	int ext_sigcount, i;</span>
<span class="p_del">-	struct extended_signature *ext_sig;</span>
<span class="p_del">-</span>
<span class="p_del">-	fam   = __x86_family(sig);</span>
<span class="p_del">-	model = x86_model(sig);</span>
<span class="p_del">-</span>
<span class="p_del">-	fam_ucode   = __x86_family(mc_header-&gt;sig);</span>
<span class="p_del">-	model_ucode = x86_model(mc_header-&gt;sig);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_del">-		return UCODE_OK;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Look for ext. headers: */</span>
<span class="p_del">-	if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_del">-		return UCODE_NFOUND;</span>
<span class="p_del">-</span>
<span class="p_del">-	ext_header   = (void *) mc_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_del">-	ext_sig      = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_del">-	ext_sigcount = ext_header-&gt;count;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; ext_sigcount; i++) {</span>
<span class="p_del">-		fam_ucode   = __x86_family(ext_sig-&gt;sig);</span>
<span class="p_del">-		model_ucode = x86_model(ext_sig-&gt;sig);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (fam == fam_ucode &amp;&amp; model == model_ucode)</span>
<span class="p_del">-			return UCODE_OK;</span>
<span class="p_del">-</span>
<span class="p_del">-		ext_sig++;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	return UCODE_NFOUND;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int</span>
<span class="p_del">-save_microcode(struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-	       struct microcode_intel **mc_saved_src,</span>
<span class="p_del">-	       unsigned int mc_saved_count)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, j;</span>
<span class="p_del">-	struct microcode_intel **saved_ptr;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mc_saved_count)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Copy new microcode data.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	saved_ptr = kcalloc(mc_saved_count, sizeof(struct microcode_intel *), GFP_KERNEL);</span>
<span class="p_del">-	if (!saved_ptr)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_count; i++) {</span>
<span class="p_del">-		struct microcode_header_intel *mc_hdr;</span>
<span class="p_del">-		struct microcode_intel *mc;</span>
<span class="p_del">-		unsigned long size;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!mc_saved_src[i]) {</span>
<span class="p_del">-			ret = -EINVAL;</span>
<span class="p_del">-			goto err;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		mc     = mc_saved_src[i];</span>
<span class="p_del">-		mc_hdr = &amp;mc-&gt;hdr;</span>
<span class="p_del">-		size   = get_totalsize(mc_hdr);</span>
<span class="p_del">-</span>
<span class="p_del">-		saved_ptr[i] = kmalloc(size, GFP_KERNEL);</span>
<span class="p_del">-		if (!saved_ptr[i]) {</span>
<span class="p_del">-			ret = -ENOMEM;</span>
<span class="p_del">-			goto err;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		memcpy(saved_ptr[i], mc, size);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Point to newly saved microcode.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mc_saved_data-&gt;mc_saved = saved_ptr;</span>
<span class="p_del">-	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-err:</span>
<span class="p_del">-	for (j = 0; j &lt;= i; j++)</span>
<span class="p_del">-		kfree(saved_ptr[j]);</span>
<span class="p_del">-	kfree(saved_ptr);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * A microcode patch in ucode_ptr is saved into mc_saved</span>
<span class="p_del">- * - if it has matching signature and newer revision compared to an existing</span>
<span class="p_del">- *   patch mc_saved.</span>
<span class="p_del">- * - or if it is a newly discovered microcode patch.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The microcode patch should have matching model with CPU.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Returns: The updated number @num_saved of saved microcode patches.</span>
<span class="p_del">- */</span>
<span class="p_del">-static unsigned int _save_mc(struct microcode_intel **mc_saved,</span>
<span class="p_del">-			     u8 *ucode_ptr, unsigned int num_saved)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_header_intel *mc_hdr, *mc_saved_hdr;</span>
<span class="p_del">-	unsigned int sig, pf;</span>
<span class="p_del">-	int found = 0, i;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_hdr = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; num_saved; i++) {</span>
<span class="p_del">-		mc_saved_hdr = (struct microcode_header_intel *)mc_saved[i];</span>
<span class="p_del">-		sig	     = mc_saved_hdr-&gt;sig;</span>
<span class="p_del">-		pf	     = mc_saved_hdr-&gt;pf;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (!find_matching_signature(ucode_ptr, sig, pf))</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		found = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (mc_hdr-&gt;rev &lt;= mc_saved_hdr-&gt;rev)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Found an older ucode saved earlier. Replace it with</span>
<span class="p_del">-		 * this newer one.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		mc_saved[i] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_del">-		break;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Newly detected microcode, save it to memory. */</span>
<span class="p_del">-	if (i &gt;= num_saved &amp;&amp; !found)</span>
<span class="p_del">-		mc_saved[num_saved++] = (struct microcode_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-	return num_saved;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Get microcode matching with BSP&#39;s model. Only CPUs with the same model as</span>
<span class="p_del">- * BSP can stay in the platform.</span>
<span class="p_del">- */</span>
<span class="p_del">-static enum ucode_state __init</span>
<span class="p_del">-get_matching_model_microcode(int cpu, unsigned long start,</span>
<span class="p_del">-			     void *data, size_t size,</span>
<span class="p_del">-			     struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-			     unsigned long *mc_saved_in_initrd,</span>
<span class="p_del">-			     struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u8 *ucode_ptr = data;</span>
<span class="p_del">-	unsigned int leftover = size;</span>
<span class="p_del">-	enum ucode_state state = UCODE_OK;</span>
<span class="p_del">-	unsigned int mc_size;</span>
<span class="p_del">-	struct microcode_header_intel *mc_header;</span>
<span class="p_del">-	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_del">-	unsigned int mc_saved_count = mc_saved_data-&gt;mc_saved_count;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (leftover &amp;&amp; mc_saved_count &lt; ARRAY_SIZE(mc_saved_tmp)) {</span>
<span class="p_del">-</span>
<span class="p_del">-		if (leftover &lt; sizeof(mc_header))</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_header = (struct microcode_header_intel *)ucode_ptr;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_size = get_totalsize(mc_header);</span>
<span class="p_del">-		if (!mc_size || mc_size &gt; leftover ||</span>
<span class="p_del">-			microcode_sanity_check(ucode_ptr, 0) &lt; 0)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-</span>
<span class="p_del">-		leftover -= mc_size;</span>
<span class="p_del">-</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * Since APs with same family and model as the BSP may boot in</span>
<span class="p_del">-		 * the platform, we need to find and save microcode patches</span>
<span class="p_del">-		 * with the same family and model as the BSP.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (matching_model_microcode(mc_header, uci-&gt;cpu_sig.sig) !=</span>
<span class="p_del">-			 UCODE_OK) {</span>
<span class="p_del">-			ucode_ptr += mc_size;</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_saved_count = _save_mc(mc_saved_tmp, ucode_ptr, mc_saved_count);</span>
<span class="p_del">-</span>
<span class="p_del">-		ucode_ptr += mc_size;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (leftover) {</span>
<span class="p_del">-		state = UCODE_ERROR;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc_saved_count == 0) {</span>
<span class="p_del">-		state = UCODE_NFOUND;</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_count; i++)</span>
<span class="p_del">-		mc_saved_in_initrd[i] = (unsigned long)mc_saved_tmp[i] - start;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved_data-&gt;mc_saved_count = mc_saved_count;</span>
<span class="p_del">-out:</span>
<span class="p_del">-	return state;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int collect_cpu_info_early(struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int val[2];</span>
<span class="p_del">-	unsigned int family, model;</span>
<span class="p_del">-	struct cpu_signature csig;</span>
<span class="p_del">-	unsigned int eax, ebx, ecx, edx;</span>
<span class="p_del">-</span>
<span class="p_del">-	csig.sig = 0;</span>
<span class="p_del">-	csig.pf = 0;</span>
<span class="p_del">-	csig.rev = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(uci, 0, sizeof(*uci));</span>
<span class="p_del">-</span>
<span class="p_del">-	eax = 0x00000001;</span>
<span class="p_del">-	ecx = 0;</span>
<span class="p_del">-	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-	csig.sig = eax;</span>
<span class="p_del">-</span>
<span class="p_del">-	family = __x86_family(csig.sig);</span>
<span class="p_del">-	model  = x86_model(csig.sig);</span>
<span class="p_del">-</span>
<span class="p_del">-	if ((model &gt;= 5) || (family &gt; 6)) {</span>
<span class="p_del">-		/* get processor flags from MSR 0x17 */</span>
<span class="p_del">-		native_rdmsr(MSR_IA32_PLATFORM_ID, val[0], val[1]);</span>
<span class="p_del">-		csig.pf = 1 &lt;&lt; ((val[1] &gt;&gt; 18) &amp; 7);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_del">-	sync_core();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* get the current revision from MSR 0x8B */</span>
<span class="p_del">-	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_del">-</span>
<span class="p_del">-	csig.rev = val[1];</span>
<span class="p_del">-</span>
<span class="p_del">-	uci-&gt;cpu_sig = csig;</span>
<span class="p_del">-	uci-&gt;valid = 1;</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef DEBUG</span>
<span class="p_del">-static void show_saved_mc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i, j;</span>
<span class="p_del">-	unsigned int sig, pf, rev, total_size, data_size, date;</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc_saved_data.mc_saved_count == 0) {</span>
<span class="p_del">-		pr_debug(&quot;no microcode data saved.\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	pr_debug(&quot;Total microcode saved: %d\n&quot;, mc_saved_data.mc_saved_count);</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	sig = uci.cpu_sig.sig;</span>
<span class="p_del">-	pf = uci.cpu_sig.pf;</span>
<span class="p_del">-	rev = uci.cpu_sig.rev;</span>
<span class="p_del">-	pr_debug(&quot;CPU: sig=0x%x, pf=0x%x, rev=0x%x\n&quot;, sig, pf, rev);</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; mc_saved_data.mc_saved_count; i++) {</span>
<span class="p_del">-		struct microcode_header_intel *mc_saved_header;</span>
<span class="p_del">-		struct extended_sigtable *ext_header;</span>
<span class="p_del">-		int ext_sigcount;</span>
<span class="p_del">-		struct extended_signature *ext_sig;</span>
<span class="p_del">-</span>
<span class="p_del">-		mc_saved_header = (struct microcode_header_intel *)</span>
<span class="p_del">-				  mc_saved_data.mc_saved[i];</span>
<span class="p_del">-		sig = mc_saved_header-&gt;sig;</span>
<span class="p_del">-		pf = mc_saved_header-&gt;pf;</span>
<span class="p_del">-		rev = mc_saved_header-&gt;rev;</span>
<span class="p_del">-		total_size = get_totalsize(mc_saved_header);</span>
<span class="p_del">-		data_size = get_datasize(mc_saved_header);</span>
<span class="p_del">-		date = mc_saved_header-&gt;date;</span>
<span class="p_del">-</span>
<span class="p_del">-		pr_debug(&quot;mc_saved[%d]: sig=0x%x, pf=0x%x, rev=0x%x, toal size=0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_del">-			 i, sig, pf, rev, total_size,</span>
<span class="p_del">-			 date &amp; 0xffff,</span>
<span class="p_del">-			 date &gt;&gt; 24,</span>
<span class="p_del">-			 (date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_del">-</span>
<span class="p_del">-		/* Look for ext. headers: */</span>
<span class="p_del">-		if (total_size &lt;= data_size + MC_HEADER_SIZE)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-</span>
<span class="p_del">-		ext_header = (void *) mc_saved_header + data_size + MC_HEADER_SIZE;</span>
<span class="p_del">-		ext_sigcount = ext_header-&gt;count;</span>
<span class="p_del">-		ext_sig = (void *)ext_header + EXT_HEADER_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (j = 0; j &lt; ext_sigcount; j++) {</span>
<span class="p_del">-			sig = ext_sig-&gt;sig;</span>
<span class="p_del">-			pf = ext_sig-&gt;pf;</span>
<span class="p_del">-</span>
<span class="p_del">-			pr_debug(&quot;\tExtended[%d]: sig=0x%x, pf=0x%x\n&quot;,</span>
<span class="p_del">-				 j, sig, pf);</span>
<span class="p_del">-</span>
<span class="p_del">-			ext_sig++;</span>
<span class="p_del">-		}</span>
<span class="p_del">-</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline void show_saved_mc(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-#if defined(CONFIG_MICROCODE_INTEL_EARLY) &amp;&amp; defined(CONFIG_HOTPLUG_CPU)</span>
<span class="p_del">-static DEFINE_MUTEX(x86_cpu_microcode_mutex);</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Save this mc into mc_saved_data. So it will be loaded early when a CPU is</span>
<span class="p_del">- * hot added or resumes.</span>
<span class="p_del">- *</span>
<span class="p_del">- * Please make sure this mc should be a valid microcode patch before calling</span>
<span class="p_del">- * this function.</span>
<span class="p_del">- */</span>
<span class="p_del">-int save_mc_for_early(u8 *mc)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_saved_tmp[MAX_UCODE_COUNT];</span>
<span class="p_del">-	unsigned int mc_saved_count_init;</span>
<span class="p_del">-	unsigned int mc_saved_count;</span>
<span class="p_del">-	struct microcode_intel **mc_saved;</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Hold hotplug lock so mc_saved_data is not accessed by a CPU in</span>
<span class="p_del">-	 * hotplug.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mutex_lock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved_count_init = mc_saved_data.mc_saved_count;</span>
<span class="p_del">-	mc_saved_count = mc_saved_data.mc_saved_count;</span>
<span class="p_del">-	mc_saved = mc_saved_data.mc_saved;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mc_saved &amp;&amp; mc_saved_count)</span>
<span class="p_del">-		memcpy(mc_saved_tmp, mc_saved,</span>
<span class="p_del">-		       mc_saved_count * sizeof(struct microcode_intel *));</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Save the microcode patch mc in mc_save_tmp structure if it&#39;s a newer</span>
<span class="p_del">-	 * version.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	mc_saved_count = _save_mc(mc_saved_tmp, mc, mc_saved_count);</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Save the mc_save_tmp in global mc_saved_data.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ret = save_microcode(&amp;mc_saved_data, mc_saved_tmp, mc_saved_count);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pr_err(&quot;Cannot save microcode patch.\n&quot;);</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	show_saved_mc();</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Free old saved microcode data.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mc_saved) {</span>
<span class="p_del">-		for (i = 0; i &lt; mc_saved_count_init; i++)</span>
<span class="p_del">-			kfree(mc_saved[i]);</span>
<span class="p_del">-		kfree(mc_saved);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-out:</span>
<span class="p_del">-	mutex_unlock(&amp;x86_cpu_microcode_mutex);</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL_GPL(save_mc_for_early);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static bool __init load_builtin_intel_microcode(struct cpio_data *cp)</span>
<span class="p_del">-{</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	unsigned int eax = 0x00000001, ebx, ecx = 0, edx;</span>
<span class="p_del">-	unsigned int family, model, stepping;</span>
<span class="p_del">-	char name[30];</span>
<span class="p_del">-</span>
<span class="p_del">-	native_cpuid(&amp;eax, &amp;ebx, &amp;ecx, &amp;edx);</span>
<span class="p_del">-</span>
<span class="p_del">-	family   = __x86_family(eax);</span>
<span class="p_del">-	model    = x86_model(eax);</span>
<span class="p_del">-	stepping = eax &amp; 0xf;</span>
<span class="p_del">-</span>
<span class="p_del">-	sprintf(name, &quot;intel-ucode/%02x-%02x-%02x&quot;, family, model, stepping);</span>
<span class="p_del">-</span>
<span class="p_del">-	return get_builtin_firmware(cp, name);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static __initdata char ucode_name[] = &quot;kernel/x86/microcode/GenuineIntel.bin&quot;;</span>
<span class="p_del">-static __init enum ucode_state</span>
<span class="p_del">-scan_microcode(struct mc_saved_data *mc_saved_data, unsigned long *initrd,</span>
<span class="p_del">-	       unsigned long start, unsigned long size,</span>
<span class="p_del">-	       struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct cpio_data cd;</span>
<span class="p_del">-	long offset = 0;</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	char *p = (char *)__pa_nodebug(ucode_name);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	char *p = ucode_name;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	cd.data = NULL;</span>
<span class="p_del">-	cd.size = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	cd = find_cpio_data(p, (void *)start, size, &amp;offset);</span>
<span class="p_del">-	if (!cd.data) {</span>
<span class="p_del">-		if (!load_builtin_intel_microcode(&amp;cd))</span>
<span class="p_del">-			return UCODE_ERROR;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return get_matching_model_microcode(0, start, cd.data, cd.size,</span>
<span class="p_del">-					    mc_saved_data, initrd, uci);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Print ucode update info.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void</span>
<span class="p_del">-print_ucode_info(struct ucode_cpu_info *uci, unsigned int date)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int cpu = smp_processor_id();</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_info(&quot;CPU%d microcode updated early to revision 0x%x, date = %04x-%02x-%02x\n&quot;,</span>
<span class="p_del">-		cpu,</span>
<span class="p_del">-		uci-&gt;cpu_sig.rev,</span>
<span class="p_del">-		date &amp; 0xffff,</span>
<span class="p_del">-		date &gt;&gt; 24,</span>
<span class="p_del">-		(date &gt;&gt; 16) &amp; 0xff);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-</span>
<span class="p_del">-static int delay_ucode_info;</span>
<span class="p_del">-static int current_mc_date;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Print early updated ucode info after printk works. This is delayed info dump.</span>
<span class="p_del">- */</span>
<span class="p_del">-void show_ucode_info_early(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (delay_ucode_info) {</span>
<span class="p_del">-		collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-		print_ucode_info(&amp;uci, current_mc_date);</span>
<span class="p_del">-		delay_ucode_info = 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * At this point, we can not call printk() yet. Keep microcode patch number in</span>
<span class="p_del">- * mc_saved_data.mc_saved and delay printing microcode info in</span>
<span class="p_del">- * show_ucode_info_early() until printk() works.</span>
<span class="p_del">- */</span>
<span class="p_del">-static void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_del">-	int *delay_ucode_info_p;</span>
<span class="p_del">-	int *current_mc_date_p;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	delay_ucode_info_p = (int *)__pa_nodebug(&amp;delay_ucode_info);</span>
<span class="p_del">-	current_mc_date_p = (int *)__pa_nodebug(&amp;current_mc_date);</span>
<span class="p_del">-</span>
<span class="p_del">-	*delay_ucode_info_p = 1;</span>
<span class="p_del">-	*current_mc_date_p = mc_intel-&gt;hdr.date;</span>
<span class="p_del">-}</span>
<span class="p_del">-#else</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Flush global tlb. We only do this in x86_64 where paging has been enabled</span>
<span class="p_del">- * already and PGE should be enabled as well.</span>
<span class="p_del">- */</span>
<span class="p_del">-static inline void flush_tlb_early(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	__native_flush_tlb_global_irq_disabled();</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static inline void print_ucode(struct ucode_cpu_info *uci)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_del">-}</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-static int apply_microcode_early(struct ucode_cpu_info *uci, bool early)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct microcode_intel *mc_intel;</span>
<span class="p_del">-	unsigned int val[2];</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_intel = uci-&gt;mc;</span>
<span class="p_del">-	if (mc_intel == NULL)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* write microcode via MSR 0x79 */</span>
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_WRITE,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits,</span>
<span class="p_del">-	      (unsigned long) mc_intel-&gt;bits &gt;&gt; 16 &gt;&gt; 16);</span>
<span class="p_del">-	native_wrmsr(MSR_IA32_UCODE_REV, 0, 0);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* As documented in the SDM: Do a CPUID 1 here */</span>
<span class="p_del">-	sync_core();</span>
<span class="p_del">-</span>
<span class="p_del">-	/* get the current revision from MSR 0x8B */</span>
<span class="p_del">-	native_rdmsr(MSR_IA32_UCODE_REV, val[0], val[1]);</span>
<span class="p_del">-	if (val[1] != mc_intel-&gt;hdr.rev)</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_X86_64</span>
<span class="p_del">-	/* Flush global tlb. This is precaution. */</span>
<span class="p_del">-	flush_tlb_early();</span>
<span class="p_del">-#endif</span>
<span class="p_del">-	uci-&gt;cpu_sig.rev = val[1];</span>
<span class="p_del">-</span>
<span class="p_del">-	if (early)</span>
<span class="p_del">-		print_ucode(uci);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		print_ucode_info(uci, mc_intel-&gt;hdr.date);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * This function converts microcode patch offsets previously stored in</span>
<span class="p_del">- * mc_saved_in_initrd to pointers and stores the pointers in mc_saved_data.</span>
<span class="p_del">- */</span>
<span class="p_del">-int __init save_microcode_in_initrd_intel(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int count = mc_saved_data.mc_saved_count;</span>
<span class="p_del">-	struct microcode_intel *mc_saved[MAX_UCODE_COUNT];</span>
<span class="p_del">-	int ret = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (count == 0)</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	copy_initrd_ptrs(mc_saved, mc_saved_in_initrd, initrd_start, count);</span>
<span class="p_del">-	ret = save_microcode(&amp;mc_saved_data, mc_saved, count);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		pr_err(&quot;Cannot save microcode patches from initrd.\n&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	show_saved_mc();</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init</span>
<span class="p_del">-_load_ucode_intel_bsp(struct mc_saved_data *mc_saved_data,</span>
<span class="p_del">-		      unsigned long *initrd,</span>
<span class="p_del">-		      unsigned long start, unsigned long size)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = scan_microcode(mc_saved_data, initrd, start, size, &amp;uci);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = load_microcode(mc_saved_data, initrd, start, &amp;uci);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_microcode_early(&amp;uci, true);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void __init load_ucode_intel_bsp(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	u64 start, size;</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	struct boot_params *p;</span>
<span class="p_del">-</span>
<span class="p_del">-	p	= (struct boot_params *)__pa_nodebug(&amp;boot_params);</span>
<span class="p_del">-	start	= p-&gt;hdr.ramdisk_image;</span>
<span class="p_del">-	size	= p-&gt;hdr.ramdisk_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	_load_ucode_intel_bsp(</span>
<span class="p_del">-			(struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data),</span>
<span class="p_del">-			(unsigned long *)__pa_nodebug(&amp;mc_saved_in_initrd),</span>
<span class="p_del">-			start, size);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	start	= boot_params.hdr.ramdisk_image + PAGE_OFFSET;</span>
<span class="p_del">-	size	= boot_params.hdr.ramdisk_size;</span>
<span class="p_del">-</span>
<span class="p_del">-	_load_ucode_intel_bsp(&amp;mc_saved_data, mc_saved_in_initrd, start, size);</span>
<span class="p_del">-#endif</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void load_ucode_intel_ap(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct mc_saved_data *mc_saved_data_p;</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-	unsigned long *mc_saved_in_initrd_p;</span>
<span class="p_del">-	unsigned long initrd_start_addr;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-#ifdef CONFIG_X86_32</span>
<span class="p_del">-	unsigned long *initrd_start_p;</span>
<span class="p_del">-</span>
<span class="p_del">-	mc_saved_in_initrd_p =</span>
<span class="p_del">-		(unsigned long *)__pa_nodebug(mc_saved_in_initrd);</span>
<span class="p_del">-	mc_saved_data_p = (struct mc_saved_data *)__pa_nodebug(&amp;mc_saved_data);</span>
<span class="p_del">-	initrd_start_p = (unsigned long *)__pa_nodebug(&amp;initrd_start);</span>
<span class="p_del">-	initrd_start_addr = (unsigned long)__pa_nodebug(*initrd_start_p);</span>
<span class="p_del">-#else</span>
<span class="p_del">-	mc_saved_data_p = &amp;mc_saved_data;</span>
<span class="p_del">-	mc_saved_in_initrd_p = mc_saved_in_initrd;</span>
<span class="p_del">-	initrd_start_addr = initrd_start;</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * If there is no valid ucode previously saved in memory, no need to</span>
<span class="p_del">-	 * update ucode on this AP.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (mc_saved_data_p-&gt;mc_saved_count == 0)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-	ret = load_microcode(mc_saved_data_p, mc_saved_in_initrd_p,</span>
<span class="p_del">-			     initrd_start_addr, &amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_microcode_early(&amp;uci, true);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void reload_ucode_intel(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ucode_cpu_info uci;</span>
<span class="p_del">-	enum ucode_state ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!mc_saved_data.mc_saved_count)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	collect_cpu_info_early(&amp;uci);</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = load_microcode_early(mc_saved_data.mc_saved,</span>
<span class="p_del">-				   mc_saved_data.mc_saved_count, &amp;uci);</span>
<span class="p_del">-	if (ret != UCODE_OK)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	apply_microcode_early(&amp;uci, false);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/arch/x86/kernel/cpu/microcode/intel_lib.c b/arch/x86/kernel/cpu/microcode/intel_lib.c</span>
<span class="p_header">index 1883d252ff7d..b96896bcbdaf 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/microcode/intel_lib.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/microcode/intel_lib.c</span>
<span class="p_chunk">@@ -25,7 +25,6 @@</span> <span class="p_context"></span>
 #include &lt;linux/firmware.h&gt;
 #include &lt;linux/uaccess.h&gt;
 #include &lt;linux/kernel.h&gt;
<span class="p_del">-#include &lt;linux/module.h&gt;</span>
 
 #include &lt;asm/microcode_intel.h&gt;
 #include &lt;asm/processor.h&gt;
<span class="p_header">diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S</span>
<span class="p_header">index 0e2d96ffd158..6bc9ae24b6d2 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_32.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_32.S</span>
<span class="p_chunk">@@ -152,7 +152,7 @@</span> <span class="p_context"> ENTRY(startup_32)</span>
 	movl %eax, pa(olpc_ofw_pgd)
 #endif
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE</span>
 	/* Early load ucode on BSP. */
 	call load_ucode_bsp
 #endif
<span class="p_chunk">@@ -311,12 +311,11 @@</span> <span class="p_context"> ENTRY(startup_32_smp)</span>
 	movl %eax,%ss
 	leal -__PAGE_OFFSET(%ecx),%esp
 
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
<span class="p_add">+#ifdef CONFIG_MICROCODE</span>
 	/* Early load ucode on AP. */
 	call load_ucode_ap
 #endif
 
<span class="p_del">-</span>
 default_entry:
 #define CR0_STATE	(X86_CR0_PE | X86_CR0_MP | X86_CR0_ET | \
 			 X86_CR0_NE | X86_CR0_WP | X86_CR0_AM | \
<span class="p_header">diff --git a/arch/x86/kernel/setup.c b/arch/x86/kernel/setup.c</span>
<span class="p_header">index fdb7f2a2d328..3a896109e1df 100644</span>
<span class="p_header">--- a/arch/x86/kernel/setup.c</span>
<span class="p_header">+++ b/arch/x86/kernel/setup.c</span>
<span class="p_chunk">@@ -111,6 +111,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/mce.h&gt;
 #include &lt;asm/alternative.h&gt;
 #include &lt;asm/prom.h&gt;
<span class="p_add">+#include &lt;asm/microcode.h&gt;</span>
 
 /*
  * max_low_pfn_mapped: highest direct mapped pfn under 4GB
<span class="p_chunk">@@ -480,34 +481,34 @@</span> <span class="p_context"> static void __init memblock_x86_reserve_range_setup_data(void)</span>
 
 #ifdef CONFIG_KEXEC_CORE
 
<span class="p_add">+/* 16M alignment for crash kernel regions */</span>
<span class="p_add">+#define CRASH_ALIGN		(16 &lt;&lt; 20)</span>
<span class="p_add">+</span>
 /*
  * Keep the crash kernel below this limit.  On 32 bits earlier kernels
  * would limit the kernel to the low 512 MiB due to mapping restrictions.
  * On 64bit, old kexec-tools need to under 896MiB.
  */
 #ifdef CONFIG_X86_32
<span class="p_del">-# define CRASH_KERNEL_ADDR_LOW_MAX	(512 &lt;&lt; 20)</span>
<span class="p_del">-# define CRASH_KERNEL_ADDR_HIGH_MAX	(512 &lt;&lt; 20)</span>
<span class="p_add">+# define CRASH_ADDR_LOW_MAX	(512 &lt;&lt; 20)</span>
<span class="p_add">+# define CRASH_ADDR_HIGH_MAX	(512 &lt;&lt; 20)</span>
 #else
<span class="p_del">-# define CRASH_KERNEL_ADDR_LOW_MAX	(896UL&lt;&lt;20)</span>
<span class="p_del">-# define CRASH_KERNEL_ADDR_HIGH_MAX	MAXMEM</span>
<span class="p_add">+# define CRASH_ADDR_LOW_MAX	(896UL &lt;&lt; 20)</span>
<span class="p_add">+# define CRASH_ADDR_HIGH_MAX	MAXMEM</span>
 #endif
 
<span class="p_del">-static void __init reserve_crashkernel_low(void)</span>
<span class="p_add">+static int __init reserve_crashkernel_low(void)</span>
 {
 #ifdef CONFIG_X86_64
<span class="p_del">-	const unsigned long long alignment = 16&lt;&lt;20;	/* 16M */</span>
<span class="p_del">-	unsigned long long low_base = 0, low_size = 0;</span>
<span class="p_add">+	unsigned long long base, low_base = 0, low_size = 0;</span>
 	unsigned long total_low_mem;
<span class="p_del">-	unsigned long long base;</span>
<span class="p_del">-	bool auto_set = false;</span>
 	int ret;
 
<span class="p_del">-	total_low_mem = memblock_mem_size(1UL&lt;&lt;(32-PAGE_SHIFT));</span>
<span class="p_add">+	total_low_mem = memblock_mem_size(1UL &lt;&lt; (32 - PAGE_SHIFT));</span>
<span class="p_add">+</span>
 	/* crashkernel=Y,low */
<span class="p_del">-	ret = parse_crashkernel_low(boot_command_line, total_low_mem,</span>
<span class="p_del">-						&amp;low_size, &amp;base);</span>
<span class="p_del">-	if (ret != 0) {</span>
<span class="p_add">+	ret = parse_crashkernel_low(boot_command_line, total_low_mem, &amp;low_size, &amp;base);</span>
<span class="p_add">+	if (ret) {</span>
 		/*
 		 * two parts from lib/swiotlb.c:
 		 * -swiotlb size: user-specified with swiotlb= or default.
<span class="p_chunk">@@ -517,52 +518,52 @@</span> <span class="p_context"> static void __init reserve_crashkernel_low(void)</span>
 		 * make sure we allocate enough extra low memory so that we
 		 * don&#39;t run out of DMA buffers for 32-bit devices.
 		 */
<span class="p_del">-		low_size = max(swiotlb_size_or_default() + (8UL&lt;&lt;20), 256UL&lt;&lt;20);</span>
<span class="p_del">-		auto_set = true;</span>
<span class="p_add">+		low_size = max(swiotlb_size_or_default() + (8UL &lt;&lt; 20), 256UL &lt;&lt; 20);</span>
 	} else {
 		/* passed with crashkernel=0,low ? */
 		if (!low_size)
<span class="p_del">-			return;</span>
<span class="p_add">+			return 0;</span>
 	}
 
<span class="p_del">-	low_base = memblock_find_in_range(low_size, (1ULL&lt;&lt;32),</span>
<span class="p_del">-					low_size, alignment);</span>
<span class="p_del">-</span>
<span class="p_add">+	low_base = memblock_find_in_range(low_size, 1ULL &lt;&lt; 32, low_size, CRASH_ALIGN);</span>
 	if (!low_base) {
<span class="p_del">-		if (!auto_set)</span>
<span class="p_del">-			pr_info(&quot;crashkernel low reservation failed - No suitable area found.\n&quot;);</span>
<span class="p_add">+		pr_err(&quot;Cannot reserve %ldMB crashkernel low memory, please try smaller size.\n&quot;,</span>
<span class="p_add">+		       (unsigned long)(low_size &gt;&gt; 20));</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-		return;</span>
<span class="p_add">+	ret = memblock_reserve(low_base, low_size);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: Error reserving crashkernel low memblock.\n&quot;, __func__);</span>
<span class="p_add">+		return ret;</span>
 	}
 
<span class="p_del">-	memblock_reserve(low_base, low_size);</span>
 	pr_info(&quot;Reserving %ldMB of low memory at %ldMB for crashkernel (System low RAM: %ldMB)\n&quot;,
<span class="p_del">-			(unsigned long)(low_size &gt;&gt; 20),</span>
<span class="p_del">-			(unsigned long)(low_base &gt;&gt; 20),</span>
<span class="p_del">-			(unsigned long)(total_low_mem &gt;&gt; 20));</span>
<span class="p_add">+		(unsigned long)(low_size &gt;&gt; 20),</span>
<span class="p_add">+		(unsigned long)(low_base &gt;&gt; 20),</span>
<span class="p_add">+		(unsigned long)(total_low_mem &gt;&gt; 20));</span>
<span class="p_add">+</span>
 	crashk_low_res.start = low_base;
 	crashk_low_res.end   = low_base + low_size - 1;
 	insert_resource(&amp;iomem_resource, &amp;crashk_low_res);
 #endif
<span class="p_add">+	return 0;</span>
 }
 
 static void __init reserve_crashkernel(void)
 {
<span class="p_del">-	const unsigned long long alignment = 16&lt;&lt;20;	/* 16M */</span>
<span class="p_del">-	unsigned long long total_mem;</span>
<span class="p_del">-	unsigned long long crash_size, crash_base;</span>
<span class="p_add">+	unsigned long long crash_size, crash_base, total_mem;</span>
 	bool high = false;
 	int ret;
 
 	total_mem = memblock_phys_mem_size();
 
 	/* crashkernel=XM */
<span class="p_del">-	ret = parse_crashkernel(boot_command_line, total_mem,</span>
<span class="p_del">-			&amp;crash_size, &amp;crash_base);</span>
<span class="p_add">+	ret = parse_crashkernel(boot_command_line, total_mem, &amp;crash_size, &amp;crash_base);</span>
 	if (ret != 0 || crash_size &lt;= 0) {
 		/* crashkernel=X,high */
 		ret = parse_crashkernel_high(boot_command_line, total_mem,
<span class="p_del">-				&amp;crash_size, &amp;crash_base);</span>
<span class="p_add">+					     &amp;crash_size, &amp;crash_base);</span>
 		if (ret != 0 || crash_size &lt;= 0)
 			return;
 		high = true;
<span class="p_chunk">@@ -573,11 +574,10 @@</span> <span class="p_context"> static void __init reserve_crashkernel(void)</span>
 		/*
 		 *  kexec want bzImage is below CRASH_KERNEL_ADDR_MAX
 		 */
<span class="p_del">-		crash_base = memblock_find_in_range(alignment,</span>
<span class="p_del">-					high ? CRASH_KERNEL_ADDR_HIGH_MAX :</span>
<span class="p_del">-					       CRASH_KERNEL_ADDR_LOW_MAX,</span>
<span class="p_del">-					crash_size, alignment);</span>
<span class="p_del">-</span>
<span class="p_add">+		crash_base = memblock_find_in_range(CRASH_ALIGN,</span>
<span class="p_add">+						    high ? CRASH_ADDR_HIGH_MAX</span>
<span class="p_add">+							 : CRASH_ADDR_LOW_MAX,</span>
<span class="p_add">+						    crash_size, CRASH_ALIGN);</span>
 		if (!crash_base) {
 			pr_info(&quot;crashkernel reservation failed - No suitable area found.\n&quot;);
 			return;
<span class="p_chunk">@@ -587,26 +587,32 @@</span> <span class="p_context"> static void __init reserve_crashkernel(void)</span>
 		unsigned long long start;
 
 		start = memblock_find_in_range(crash_base,
<span class="p_del">-				 crash_base + crash_size, crash_size, 1&lt;&lt;20);</span>
<span class="p_add">+					       crash_base + crash_size,</span>
<span class="p_add">+					       crash_size, 1 &lt;&lt; 20);</span>
 		if (start != crash_base) {
 			pr_info(&quot;crashkernel reservation failed - memory is in use.\n&quot;);
 			return;
 		}
 	}
<span class="p_del">-	memblock_reserve(crash_base, crash_size);</span>
<span class="p_add">+	ret = memblock_reserve(crash_base, crash_size);</span>
<span class="p_add">+	if (ret) {</span>
<span class="p_add">+		pr_err(&quot;%s: Error reserving crashkernel memblock.\n&quot;, __func__);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (crash_base &gt;= (1ULL &lt;&lt; 32) &amp;&amp; reserve_crashkernel_low()) {</span>
<span class="p_add">+		memblock_free(crash_base, crash_size);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	printk(KERN_INFO &quot;Reserving %ldMB of memory at %ldMB &quot;</span>
<span class="p_del">-			&quot;for crashkernel (System RAM: %ldMB)\n&quot;,</span>
<span class="p_del">-			(unsigned long)(crash_size &gt;&gt; 20),</span>
<span class="p_del">-			(unsigned long)(crash_base &gt;&gt; 20),</span>
<span class="p_del">-			(unsigned long)(total_mem &gt;&gt; 20));</span>
<span class="p_add">+	pr_info(&quot;Reserving %ldMB of memory at %ldMB for crashkernel (System RAM: %ldMB)\n&quot;,</span>
<span class="p_add">+		(unsigned long)(crash_size &gt;&gt; 20),</span>
<span class="p_add">+		(unsigned long)(crash_base &gt;&gt; 20),</span>
<span class="p_add">+		(unsigned long)(total_mem &gt;&gt; 20));</span>
 
 	crashk_res.start = crash_base;
 	crashk_res.end   = crash_base + crash_size - 1;
 	insert_resource(&amp;iomem_resource, &amp;crashk_res);
<span class="p_del">-</span>
<span class="p_del">-	if (crash_base &gt;= (1ULL&lt;&lt;32))</span>
<span class="p_del">-		reserve_crashkernel_low();</span>
 }
 #else
 static void __init reserve_crashkernel(void)
<span class="p_chunk">@@ -1234,6 +1240,8 @@</span> <span class="p_context"> void __init setup_arch(char **cmdline_p)</span>
 	if (efi_enabled(EFI_BOOT))
 		efi_apply_memmap_quirks();
 #endif
<span class="p_add">+</span>
<span class="p_add">+	microcode_init();</span>
 }
 
 #ifdef CONFIG_X86_32
<span class="p_header">diff --git a/arch/x86/mm/init.c b/arch/x86/mm/init.c</span>
<span class="p_header">index 1d8a83df153a..1f37cb2b56a9 100644</span>
<span class="p_header">--- a/arch/x86/mm/init.c</span>
<span class="p_header">+++ b/arch/x86/mm/init.c</span>
<span class="p_chunk">@@ -693,14 +693,12 @@</span> <span class="p_context"> void free_initmem(void)</span>
 #ifdef CONFIG_BLK_DEV_INITRD
 void __init free_initrd_mem(unsigned long start, unsigned long end)
 {
<span class="p_del">-#ifdef CONFIG_MICROCODE_EARLY</span>
 	/*
 	 * Remember, initrd memory may contain microcode or other useful things.
 	 * Before we lose initrd mem, we need to find a place to hold them
 	 * now that normal virtual memory is enabled.
 	 */
 	save_microcode_in_initrd();
<span class="p_del">-#endif</span>
 
 	/*
 	 * end could be not aligned, and We can not align that,
<span class="p_header">diff --git a/arch/x86/ras/Kconfig b/arch/x86/ras/Kconfig</span>
<span class="p_header">index 10fea5fc821e..df280da34825 100644</span>
<span class="p_header">--- a/arch/x86/ras/Kconfig</span>
<span class="p_header">+++ b/arch/x86/ras/Kconfig</span>
<span class="p_chunk">@@ -1,11 +1,9 @@</span> <span class="p_context"></span>
 config AMD_MCE_INJ
 	tristate &quot;Simple MCE injection interface for AMD processors&quot;
<span class="p_del">-	depends on RAS &amp;&amp; EDAC_DECODE_MCE &amp;&amp; DEBUG_FS</span>
<span class="p_add">+	depends on RAS &amp;&amp; EDAC_DECODE_MCE &amp;&amp; DEBUG_FS &amp;&amp; AMD_NB</span>
 	default n
 	help
 	  This is a simple debugfs interface to inject MCEs and test different
 	  aspects of the MCE handling code.
 
 	  WARNING: Do not even assume this interface is staying stable!
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_header">diff --git a/arch/x86/ras/mce_amd_inj.c b/arch/x86/ras/mce_amd_inj.c</span>
<span class="p_header">index 17e35b5bf779..55d38cfa46c2 100644</span>
<span class="p_header">--- a/arch/x86/ras/mce_amd_inj.c</span>
<span class="p_header">+++ b/arch/x86/ras/mce_amd_inj.c</span>
<span class="p_chunk">@@ -17,7 +17,11 @@</span> <span class="p_context"></span>
 #include &lt;linux/cpu.h&gt;
 #include &lt;linux/string.h&gt;
 #include &lt;linux/uaccess.h&gt;
<span class="p_add">+#include &lt;linux/pci.h&gt;</span>
<span class="p_add">+</span>
 #include &lt;asm/mce.h&gt;
<span class="p_add">+#include &lt;asm/amd_nb.h&gt;</span>
<span class="p_add">+#include &lt;asm/irq_vectors.h&gt;</span>
 
 #include &quot;../kernel/cpu/mcheck/mce-internal.h&quot;
 
<span class="p_chunk">@@ -30,16 +34,21 @@</span> <span class="p_context"> static struct dentry *dfs_inj;</span>
 static u8 n_banks;
 
 #define MAX_FLAG_OPT_SIZE	3
<span class="p_add">+#define NBCFG			0x44</span>
 
 enum injection_type {
 	SW_INJ = 0,	/* SW injection, simply decode the error */
 	HW_INJ,		/* Trigger a #MC */
<span class="p_add">+	DFR_INT_INJ,    /* Trigger Deferred error interrupt */</span>
<span class="p_add">+	THR_INT_INJ,    /* Trigger threshold interrupt */</span>
 	N_INJ_TYPES,
 };
 
 static const char * const flags_options[] = {
 	[SW_INJ] = &quot;sw&quot;,
 	[HW_INJ] = &quot;hw&quot;,
<span class="p_add">+	[DFR_INT_INJ] = &quot;df&quot;,</span>
<span class="p_add">+	[THR_INT_INJ] = &quot;th&quot;,</span>
 	NULL
 };
 
<span class="p_chunk">@@ -129,12 +138,9 @@</span> <span class="p_context"> static ssize_t flags_write(struct file *filp, const char __user *ubuf,</span>
 {
 	char buf[MAX_FLAG_OPT_SIZE], *__buf;
 	int err;
<span class="p_del">-	size_t ret;</span>
 
 	if (cnt &gt; MAX_FLAG_OPT_SIZE)
<span class="p_del">-		cnt = MAX_FLAG_OPT_SIZE;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = cnt;</span>
<span class="p_add">+		return -EINVAL;</span>
 
 	if (copy_from_user(&amp;buf, ubuf, cnt))
 		return -EFAULT;
<span class="p_chunk">@@ -150,9 +156,9 @@</span> <span class="p_context"> static ssize_t flags_write(struct file *filp, const char __user *ubuf,</span>
 		return err;
 	}
 
<span class="p_del">-	*ppos += ret;</span>
<span class="p_add">+	*ppos += cnt;</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return cnt;</span>
 }
 
 static const struct file_operations flags_fops = {
<span class="p_chunk">@@ -185,6 +191,55 @@</span> <span class="p_context"> static void trigger_mce(void *info)</span>
 	asm volatile(&quot;int $18&quot;);
 }
 
<span class="p_add">+static void trigger_dfr_int(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	asm volatile(&quot;int %0&quot; :: &quot;i&quot; (DEFERRED_ERROR_VECTOR));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void trigger_thr_int(void *info)</span>
<span class="p_add">+{</span>
<span class="p_add">+	asm volatile(&quot;int %0&quot; :: &quot;i&quot; (THRESHOLD_APIC_VECTOR));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u32 get_nbc_for_node(int node_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cpuinfo_x86 *c = &amp;boot_cpu_data;</span>
<span class="p_add">+	u32 cores_per_node;</span>
<span class="p_add">+</span>
<span class="p_add">+	cores_per_node = c-&gt;x86_max_cores / amd_get_nodes_per_socket();</span>
<span class="p_add">+</span>
<span class="p_add">+	return cores_per_node * node_id;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void toggle_nb_mca_mst_cpu(u16 nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct pci_dev *F3 = node_to_amd_nb(nid)-&gt;misc;</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!F3)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = pci_read_config_dword(F3, NBCFG, &amp;val);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		pr_err(&quot;%s: Error reading F%dx%03x.\n&quot;,</span>
<span class="p_add">+		       __func__, PCI_FUNC(F3-&gt;devfn), NBCFG);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (val &amp; BIT(27))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	pr_err(&quot;%s: Set D18F3x44[NbMcaToMstCpuEn] which BIOS hasn&#39;t done.\n&quot;,</span>
<span class="p_add">+	       __func__);</span>
<span class="p_add">+</span>
<span class="p_add">+	val |= BIT(27);</span>
<span class="p_add">+	err = pci_write_config_dword(F3, NBCFG, val);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		pr_err(&quot;%s: Error writing F%dx%03x.\n&quot;,</span>
<span class="p_add">+		       __func__, PCI_FUNC(F3-&gt;devfn), NBCFG);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void do_inject(void)
 {
 	u64 mcg_status = 0;
<span class="p_chunk">@@ -205,6 +260,26 @@</span> <span class="p_context"> static void do_inject(void)</span>
 	if (!(i_mce.status &amp; MCI_STATUS_PCC))
 		mcg_status |= MCG_STATUS_RIPV;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Ensure necessary status bits for deferred errors:</span>
<span class="p_add">+	 * - MCx_STATUS[Deferred]: make sure it is a deferred error</span>
<span class="p_add">+	 * - MCx_STATUS[UC] cleared: deferred errors are _not_ UC</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (inj_type == DFR_INT_INJ) {</span>
<span class="p_add">+		i_mce.status |= MCI_STATUS_DEFERRED;</span>
<span class="p_add">+		i_mce.status |= (i_mce.status &amp; ~MCI_STATUS_UC);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For multi node CPUs, logging and reporting of bank 4 errors happens</span>
<span class="p_add">+	 * only on the node base core. Refer to D18F3x44[NbMcaToMstCpuEn] for</span>
<span class="p_add">+	 * Fam10h and later BKDGs.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (static_cpu_has(X86_FEATURE_AMD_DCM) &amp;&amp; b == 4) {</span>
<span class="p_add">+		toggle_nb_mca_mst_cpu(amd_get_nb_id(cpu));</span>
<span class="p_add">+		cpu = get_nbc_for_node(amd_get_nb_id(cpu));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	get_online_cpus();
 	if (!cpu_online(cpu))
 		goto err;
<span class="p_chunk">@@ -225,7 +300,16 @@</span> <span class="p_context"> static void do_inject(void)</span>
 
 	toggle_hw_mce_inject(cpu, false);
 
<span class="p_del">-	smp_call_function_single(cpu, trigger_mce, NULL, 0);</span>
<span class="p_add">+	switch (inj_type) {</span>
<span class="p_add">+	case DFR_INT_INJ:</span>
<span class="p_add">+		smp_call_function_single(cpu, trigger_dfr_int, NULL, 0);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case THR_INT_INJ:</span>
<span class="p_add">+		smp_call_function_single(cpu, trigger_thr_int, NULL, 0);</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		smp_call_function_single(cpu, trigger_mce, NULL, 0);</span>
<span class="p_add">+	}</span>
 
 err:
 	put_online_cpus();
<span class="p_chunk">@@ -290,6 +374,11 @@</span> <span class="p_context"> static const char readme_msg[] =</span>
 &quot;\t    handle the error. Be warned: might cause system panic if MCi_STATUS[PCC] \n&quot;
 &quot;\t    is set. Therefore, consider setting (debugfs_mountpoint)/mce/fake_panic \n&quot;
 &quot;\t    before injecting.\n&quot;
<span class="p_add">+&quot;\t  - \&quot;df\&quot;: Trigger APIC interrupt for Deferred error. Causes deferred \n&quot;</span>
<span class="p_add">+&quot;\t    error APIC interrupt handler to handle the error if the feature is \n&quot;</span>
<span class="p_add">+&quot;\t    is present in hardware. \n&quot;</span>
<span class="p_add">+&quot;\t  - \&quot;th\&quot;: Trigger APIC interrupt for Threshold errors. Causes threshold \n&quot;</span>
<span class="p_add">+&quot;\t    APIC interrupt handler to handle the error. \n&quot;</span>
 &quot;\n&quot;;
 
 static ssize_t
<span class="p_header">diff --git a/drivers/edac/amd64_edac.c b/drivers/edac/amd64_edac.c</span>
<span class="p_header">index 73aea40a9c89..d5fcdbfd99b8 100644</span>
<span class="p_header">--- a/drivers/edac/amd64_edac.c</span>
<span class="p_header">+++ b/drivers/edac/amd64_edac.c</span>
<span class="p_chunk">@@ -2770,7 +2770,7 @@</span> <span class="p_context"> static int init_one_instance(struct pci_dev *F2)</span>
 	struct mem_ctl_info *mci = NULL;
 	struct edac_mc_layer layers[2];
 	int err = 0, ret;
<span class="p_del">-	u16 nid = amd_get_node_id(F2);</span>
<span class="p_add">+	u16 nid = amd_pci_dev_to_node_id(F2);</span>
 
 	ret = -ENOMEM;
 	pvt = kzalloc(sizeof(struct amd64_pvt), GFP_KERNEL);
<span class="p_chunk">@@ -2860,7 +2860,7 @@</span> <span class="p_context"> static int init_one_instance(struct pci_dev *F2)</span>
 static int probe_one_instance(struct pci_dev *pdev,
 			      const struct pci_device_id *mc_type)
 {
<span class="p_del">-	u16 nid = amd_get_node_id(pdev);</span>
<span class="p_add">+	u16 nid = amd_pci_dev_to_node_id(pdev);</span>
 	struct pci_dev *F3 = node_to_amd_nb(nid)-&gt;misc;
 	struct ecc_settings *s;
 	int ret = 0;
<span class="p_chunk">@@ -2910,7 +2910,7 @@</span> <span class="p_context"> static void remove_one_instance(struct pci_dev *pdev)</span>
 {
 	struct mem_ctl_info *mci;
 	struct amd64_pvt *pvt;
<span class="p_del">-	u16 nid = amd_get_node_id(pdev);</span>
<span class="p_add">+	u16 nid = amd_pci_dev_to_node_id(pdev);</span>
 	struct pci_dev *F3 = node_to_amd_nb(nid)-&gt;misc;
 	struct ecc_settings *s = ecc_stngs[nid];
 
<span class="p_header">diff --git a/kernel/kexec_core.c b/kernel/kexec_core.c</span>
<span class="p_header">index 201b45327804..bd9f8a03cefa 100644</span>
<span class="p_header">--- a/kernel/kexec_core.c</span>
<span class="p_header">+++ b/kernel/kexec_core.c</span>
<span class="p_chunk">@@ -1149,7 +1149,7 @@</span> <span class="p_context"> static int __init parse_crashkernel_simple(char *cmdline,</span>
 	if (*cur == &#39;@&#39;)
 		*crash_base = memparse(cur+1, &amp;cur);
 	else if (*cur != &#39; &#39; &amp;&amp; *cur != &#39;\0&#39;) {
<span class="p_del">-		pr_warn(&quot;crashkernel: unrecognized char\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;crashkernel: unrecognized char: %c\n&quot;, *cur);</span>
 		return -EINVAL;
 	}
 
<span class="p_chunk">@@ -1186,12 +1186,12 @@</span> <span class="p_context"> static int __init parse_crashkernel_suffix(char *cmdline,</span>
 
 	/* check with suffix */
 	if (strncmp(cur, suffix, strlen(suffix))) {
<span class="p_del">-		pr_warn(&quot;crashkernel: unrecognized char\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;crashkernel: unrecognized char: %c\n&quot;, *cur);</span>
 		return -EINVAL;
 	}
 	cur += strlen(suffix);
 	if (*cur != &#39; &#39; &amp;&amp; *cur != &#39;\0&#39;) {
<span class="p_del">-		pr_warn(&quot;crashkernel: unrecognized char\n&quot;);</span>
<span class="p_add">+		pr_warn(&quot;crashkernel: unrecognized char: %c\n&quot;, *cur);</span>
 		return -EINVAL;
 	}
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



