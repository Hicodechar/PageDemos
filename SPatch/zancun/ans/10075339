
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[GIT,PULL] x86 fixes - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [GIT,PULL] x86 fixes</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 26, 2017, 12:48 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20171126124825.kr25chegvi624ihe@gmail.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10075339/mbox/"
   >mbox</a>
|
   <a href="/patch/10075339/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10075339/">/patch/10075339/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	ABD4C60353 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 26 Nov 2017 12:48:40 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 89F85287BE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 26 Nov 2017 12:48:40 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 7E77F2885F; Sun, 26 Nov 2017 12:48:40 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-3.1 required=2.0 tests=BAYES_00,DKIM_SIGNED,
	FSL_HELO_FAKE, RCVD_IN_DNSWL_HI,
	T_DKIM_INVALID autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 04D23287BE
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 26 Nov 2017 12:48:37 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1752206AbdKZMse (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 26 Nov 2017 07:48:34 -0500
Received: from mail-wr0-f179.google.com ([209.85.128.179]:33987 &quot;EHLO
	mail-wr0-f179.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1752140AbdKZMsb (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 26 Nov 2017 07:48:31 -0500
Received: by mail-wr0-f179.google.com with SMTP id k18so18974455wre.1
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Sun, 26 Nov 2017 04:48:30 -0800 (PST)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=gmail.com; s=20161025;
	h=sender:date:from:to:cc:subject:message-id:mime-version
	:content-disposition:user-agent;
	bh=oQTYiM4Mmer6qsJQyaJgKQHqa1c/JKPpg5qP4IB+aGY=;
	b=d8CxbrfPWVLLggtmG5HOav4EjrYvSSopFo5+BzmJOEeywaciS9H7wLOhhPBK7aqYiM
	PEgHlKi3IG2ZtjsIYMBBKtvmVjIjwuK+/A1t5Dkr+9wQyGPlBkb8nOI2UIq4hU/1bBKN
	N1Q4qF3creFuhZL2CizC9KDOWk+Uyi0ddg/N7gkZlWPAj19ZXnuLPKLzgqr55anbsuNO
	Cnl4g2BKJDczbUNAGcRUVcKGu335ccuQAVCVL0NX0tWVpezTtDbetOHXrsrEXP7vdZNo
	RG8+v05azxmstGusq74ruBheFhBTcWR1k4pOMIodw09nhJO0ydZfHDSsmGIzn01bG/op
	kf+A==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:sender:date:from:to:cc:subject:message-id
	:mime-version:content-disposition:user-agent;
	bh=oQTYiM4Mmer6qsJQyaJgKQHqa1c/JKPpg5qP4IB+aGY=;
	b=mVbeJvGDDdQSgkKn6CYT7atDQQAHYw/pndx7b/p4FeK8Mrgta//4ISc18SOPpiECBB
	bOI/mSiNjZmaC/DOZfnNyPwZD/k0SEshMAd2CM0bMMBG1uzHwGZ3RIbbfEGDe7IUXK7y
	tMniqi9YOOkHfaG9tgjqOb2fT3a6R8VYA64YXKerqleMCO8DI1zTiC8rHgw64zPBFFoI
	6KYAH1yEev/1+HhmEla4JRhJ5xrZuOrzFjitqq53/7zD0PnSe1CJbTyhM5Ny2DWEYsc1
	6tGCoOG2yMn77az0C44mcdmiUedOqYoNT6S0JWvHnyGZwZj3r4k1eZTS/eePzCt11pk6
	oj1Q==
X-Gm-Message-State: AJaThX6mQ02G/YEf5rwUZCCJR5OCaQklygbgx9AuTtfc4l4IOeLQ3J+q
	ABXKKyT2Kj3CN4L97Cwe3Ow=
X-Google-Smtp-Source: AGs4zMbng/GB8uf3aX/DaHjeM98WTULu0vZGVjXQT65uJMhu/UPN2rnlsJ2kOymVLT16lxyqFS0U6w==
X-Received: by 10.223.144.204 with SMTP id i70mr18102165wri.57.1511700508395;
	Sun, 26 Nov 2017 04:48:28 -0800 (PST)
Received: from gmail.com (2E8B0CD5.catv.pool.telekom.hu. [46.139.12.213])
	by smtp.gmail.com with ESMTPSA id
	h8sm7521244wme.30.2017.11.26.04.48.27
	(version=TLS1_2 cipher=ECDHE-RSA-CHACHA20-POLY1305 bits=256/256);
	Sun, 26 Nov 2017 04:48:27 -0800 (PST)
Date: Sun, 26 Nov 2017 13:48:25 +0100
From: Ingo Molnar &lt;mingo@kernel.org&gt;
To: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Cc: linux-kernel@vger.kernel.org, Thomas Gleixner &lt;tglx@linutronix.de&gt;,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Peter Zijlstra &lt;a.p.zijlstra@chello.nl&gt;,
	Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Andy Lutomirski &lt;luto@kernel.org&gt;
Subject: [GIT PULL] x86 fixes
Message-ID: &lt;20171126124825.kr25chegvi624ihe@gmail.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
User-Agent: NeoMutt/20170609 (1.8.3)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=35552">Ingo Molnar</a> - Nov. 26, 2017, 12:48 p.m.</div>
<pre class="content">
Linus,

Please pull the latest x86-urgent-for-linus git tree from:

   git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git x86-urgent-for-linus

   # HEAD: 12a78d43de767eaf8fb272facb7a7b6f2dc6a9df x86/decoder: Add new TEST instruction pattern

Misc fixes:

 - topology enumeration fixes
 - KASAN fix
 - two entry fixes (not yet the big series related to KASLR)
 - remove obsolete code
 - instruction decoder fix
 - better /dev/mem sanity checks, hopefully working better this time
 - pkeys fixes
 - two ACPI fixes
 - 5-level paging related fixes
 - UMIP fixes that should make application visible faults more debuggable
 - boot fix for weird virtualization environment

  out-of-topic modifications in x86-urgent-for-linus:
  -----------------------------------------------------
  drivers/pci/Kconfig                # fd2fa6c18b72: x86/PCI: Remove unused Hyper
  drivers/pci/Makefile               # fd2fa6c18b72: x86/PCI: Remove unused Hyper
  drivers/pci/htirq.c                # fd2fa6c18b72: x86/PCI: Remove unused Hyper
  include/linux/htirq.h              # fd2fa6c18b72: x86/PCI: Remove unused Hyper
  include/linux/pci.h                # fd2fa6c18b72: x86/PCI: Remove unused Hyper
  tools/testing/selftests/x86/5lvl.c # 97f404ad3e53: x86/selftests: Add test for 
  tools/testing/selftests/x86/Makefile# 97f404ad3e53: x86/selftests: Add test for 
  tools/testing/selftests/x86/mpx-hw.h# a6400120d042: x86/mpx/selftests: Fix up we
  tools/testing/selftests/x86/pkey-helpers.h# 7b659ee3e1fe: x86/pkeys/selftests: Fix pro
  tools/testing/selftests/x86/protection_keys.c# 91c49c2deb96: x86/pkeys/selftests: Rename 

 Thanks,

	Ingo

------------------&gt;
Andi Kleen (2):
      perf/x86/intel/uncore: Cache logical pkg id in uncore driver
      x86/topology: Avoid wasting 128k for package id array

Andrey Ryabinin (1):
      x86/mm/kasan: Don&#39;t use vmemmap_populate() to initialize shadow

Andy Lutomirski (2):
      x86/entry/64: Fix entry_SYSCALL_64_after_hwframe() IRQ tracing
      x86/entry/64: Add missing irqflags tracing to native_load_gs_index()

Bjorn Helgaas (1):
      x86/PCI: Remove unused HyperTransport interrupt support

Borislav Petkov (1):
      x86/umip: Fix insn_get_code_seg_params()&#39;s return value

Chao Fan (1):
      x86/boot/KASLR: Remove unused variable

Craig Bergstrom (1):
      x86/mm: Limit mmap() of /dev/mem to valid physical addresses

Dave Hansen (4):
      x86/pkeys: Update documentation about availability
      x86/mpx/selftests: Fix up weird arrays
      x86/pkeys/selftests: Rename &#39;si_pkey&#39; to &#39;siginfo_pkey&#39;
      x86/pkeys/selftests: Fix protection keys write() warning

Kirill A. Shutemov (2):
      x86/mm: Prevent non-MAP_FIXED mapping across DEFAULT_MAP_WINDOW border
      x86/selftests: Add test for mapping placement for 5-level paging

Masami Hiramatsu (1):
      x86/decoder: Add new TEST instruction pattern

Prarit Bhargava (1):
      x86/smpboot: Fix __max_logical_packages estimate

Ricardo Neri (4):
      x86/umip: Select X86_INTEL_UMIP by default
      x86/umip: Print a line in the boot log that UMIP has been enabled
      x86/umip: Identify the STR and SLDT instructions
      x86/umip: Print a warning into the syslog if UMIP-protected instructions are used

Tom Lendacky (1):
      x86/boot: Fix boot failure when SMP MP-table is based at 0

Vikas C Sajjan (2):
      x86/acpi: Handle SCI interrupts above legacy space gracefully
      x86/acpi: Reduce code duplication in mp_override_legacy_irq()


 Documentation/x86/protection-keys.txt         |   9 +-
 arch/x86/Kconfig                              |  14 +-
 arch/x86/boot/compressed/kaslr.c              |   5 +-
 arch/x86/entry/entry_64.S                     |  14 +-
 arch/x86/events/intel/uncore.c                |   4 +-
 arch/x86/events/intel/uncore.h                |   2 +-
 arch/x86/events/intel/uncore_snbep.c          |   2 +-
 arch/x86/include/asm/elf.h                    |   1 +
 arch/x86/include/asm/hw_irq.h                 |   8 --
 arch/x86/include/asm/hypertransport.h         |  46 ------
 arch/x86/include/asm/insn-eval.h              |   2 +-
 arch/x86/include/asm/io.h                     |   4 +
 arch/x86/include/asm/irqdomain.h              |   6 -
 arch/x86/include/asm/processor.h              |   1 +
 arch/x86/kernel/acpi/boot.c                   |  61 +++++---
 arch/x86/kernel/apic/Makefile                 |   1 -
 arch/x86/kernel/apic/htirq.c                  | 198 --------------------------
 arch/x86/kernel/apic/vector.c                 |   5 +-
 arch/x86/kernel/cpu/common.c                  |   2 +
 arch/x86/kernel/mpparse.c                     |   6 +-
 arch/x86/kernel/smpboot.c                     | 128 +++++------------
 arch/x86/kernel/sys_x86_64.c                  |  10 +-
 arch/x86/kernel/umip.c                        |  88 ++++++++++--
 arch/x86/lib/insn-eval.c                      |   4 +-
 arch/x86/lib/x86-opcode-map.txt               |   2 +-
 arch/x86/mm/hugetlbpage.c                     |  11 +-
 arch/x86/mm/kasan_init_64.c                   | 143 ++++++++++++++++++-
 arch/x86/mm/mmap.c                            |  62 ++++++++
 drivers/char/mem.c                            |   4 +
 drivers/pci/Kconfig                           |   9 --
 drivers/pci/Makefile                          |   3 -
 drivers/pci/htirq.c                           | 135 ------------------
 include/linux/htirq.h                         |  39 -----
 include/linux/pci.h                           |   6 -
 tools/testing/selftests/x86/5lvl.c            | 177 +++++++++++++++++++++++
 tools/testing/selftests/x86/Makefile          |   2 +-
 tools/testing/selftests/x86/mpx-hw.h          |   4 +-
 tools/testing/selftests/x86/pkey-helpers.h    |   5 +-
 tools/testing/selftests/x86/protection_keys.c |  10 +-
 39 files changed, 609 insertions(+), 624 deletions(-)
 delete mode 100644 arch/x86/include/asm/hypertransport.h
 delete mode 100644 arch/x86/kernel/apic/htirq.c
 delete mode 100644 drivers/pci/htirq.c
 delete mode 100644 include/linux/htirq.h
 create mode 100644 tools/testing/selftests/x86/5lvl.c
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Documentation/x86/protection-keys.txt b/Documentation/x86/protection-keys.txt</span>
<span class="p_header">index fa46dcb347bc..ecb0d2dadfb7 100644</span>
<span class="p_header">--- a/Documentation/x86/protection-keys.txt</span>
<span class="p_header">+++ b/Documentation/x86/protection-keys.txt</span>
<span class="p_chunk">@@ -1,5 +1,10 @@</span> <span class="p_context"></span>
<span class="p_del">-Memory Protection Keys for Userspace (PKU aka PKEYs) is a CPU feature</span>
<span class="p_del">-which will be found on future Intel CPUs.</span>
<span class="p_add">+Memory Protection Keys for Userspace (PKU aka PKEYs) is a feature</span>
<span class="p_add">+which is found on Intel&#39;s Skylake &quot;Scalable Processor&quot; Server CPUs.</span>
<span class="p_add">+It will be avalable in future non-server parts.</span>
<span class="p_add">+</span>
<span class="p_add">+For anyone wishing to test or use this feature, it is available in</span>
<span class="p_add">+Amazon&#39;s EC2 C5 instances and is known to work there using an Ubuntu</span>
<span class="p_add">+17.04 image.</span>
 
 Memory Protection Keys provides a mechanism for enforcing page-based
 protections, but without requiring modification of the page tables
<span class="p_header">diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig</span>
<span class="p_header">index f08977d82ca0..09dcc94c4484 100644</span>
<span class="p_header">--- a/arch/x86/Kconfig</span>
<span class="p_header">+++ b/arch/x86/Kconfig</span>
<span class="p_chunk">@@ -110,7 +110,7 @@</span> <span class="p_context"> config X86</span>
 	select HAVE_ARCH_AUDITSYSCALL
 	select HAVE_ARCH_HUGE_VMAP		if X86_64 || X86_PAE
 	select HAVE_ARCH_JUMP_LABEL
<span class="p_del">-	select HAVE_ARCH_KASAN			if X86_64 &amp;&amp; SPARSEMEM_VMEMMAP</span>
<span class="p_add">+	select HAVE_ARCH_KASAN			if X86_64</span>
 	select HAVE_ARCH_KGDB
 	select HAVE_ARCH_KMEMCHECK
 	select HAVE_ARCH_MMAP_RND_BITS		if MMU
<span class="p_chunk">@@ -1805,14 +1805,20 @@</span> <span class="p_context"> config X86_SMAP</span>
 	  If unsure, say Y.
 
 config X86_INTEL_UMIP
<span class="p_del">-	def_bool n</span>
<span class="p_add">+	def_bool y</span>
 	depends on CPU_SUP_INTEL
 	prompt &quot;Intel User Mode Instruction Prevention&quot; if EXPERT
 	---help---
 	  The User Mode Instruction Prevention (UMIP) is a security
 	  feature in newer Intel processors. If enabled, a general
<span class="p_del">-	  protection fault is issued if the instructions SGDT, SLDT,</span>
<span class="p_del">-	  SIDT, SMSW and STR are executed in user mode.</span>
<span class="p_add">+	  protection fault is issued if the SGDT, SLDT, SIDT, SMSW</span>
<span class="p_add">+	  or STR instructions are executed in user mode. These instructions</span>
<span class="p_add">+	  unnecessarily expose information about the hardware state.</span>
<span class="p_add">+</span>
<span class="p_add">+	  The vast majority of applications do not use these instructions.</span>
<span class="p_add">+	  For the very few that do, software emulation is provided in</span>
<span class="p_add">+	  specific cases in protected and virtual-8086 modes. Emulated</span>
<span class="p_add">+	  results are dummy.</span>
 
 config X86_INTEL_MPX
 	prompt &quot;Intel MPX (Memory Protection Extensions)&quot;
<span class="p_header">diff --git a/arch/x86/boot/compressed/kaslr.c b/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_header">index a63fbc25ce84..8199a6187251 100644</span>
<span class="p_header">--- a/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_header">+++ b/arch/x86/boot/compressed/kaslr.c</span>
<span class="p_chunk">@@ -171,7 +171,6 @@</span> <span class="p_context"> parse_memmap(char *p, unsigned long long *start, unsigned long long *size)</span>
 static void mem_avoid_memmap(char *str)
 {
 	static int i;
<span class="p_del">-	int rc;</span>
 
 	if (i &gt;= MAX_MEMMAP_REGIONS)
 		return;
<span class="p_chunk">@@ -219,7 +218,7 @@</span> <span class="p_context"> static int handle_mem_memmap(void)</span>
 		return 0;
 
 	tmp_cmdline = malloc(len + 1);
<span class="p_del">-	if (!tmp_cmdline )</span>
<span class="p_add">+	if (!tmp_cmdline)</span>
 		error(&quot;Failed to allocate space for tmp_cmdline&quot;);
 
 	memcpy(tmp_cmdline, args, len);
<span class="p_chunk">@@ -363,7 +362,7 @@</span> <span class="p_context"> static void mem_avoid_init(unsigned long input, unsigned long input_size,</span>
 	cmd_line |= boot_params-&gt;hdr.cmd_line_ptr;
 	/* Calculate size of cmd_line. */
 	ptr = (char *)(unsigned long)cmd_line;
<span class="p_del">-	for (cmd_line_size = 0; ptr[cmd_line_size++]; )</span>
<span class="p_add">+	for (cmd_line_size = 0; ptr[cmd_line_size++];)</span>
 		;
 	mem_avoid[MEM_AVOID_CMDLINE].start = cmd_line;
 	mem_avoid[MEM_AVOID_CMDLINE].size = cmd_line_size;
<span class="p_header">diff --git a/arch/x86/entry/entry_64.S b/arch/x86/entry/entry_64.S</span>
<span class="p_header">index a2b30ec69497..f81d50d7ceac 100644</span>
<span class="p_header">--- a/arch/x86/entry/entry_64.S</span>
<span class="p_header">+++ b/arch/x86/entry/entry_64.S</span>
<span class="p_chunk">@@ -51,15 +51,19 @@</span> <span class="p_context"> ENTRY(native_usergs_sysret64)</span>
 END(native_usergs_sysret64)
 #endif /* CONFIG_PARAVIRT */
 
<span class="p_del">-.macro TRACE_IRQS_IRETQ</span>
<span class="p_add">+.macro TRACE_IRQS_FLAGS flags:req</span>
 #ifdef CONFIG_TRACE_IRQFLAGS
<span class="p_del">-	bt	$9, EFLAGS(%rsp)		/* interrupts off? */</span>
<span class="p_add">+	bt	$9, \flags		/* interrupts off? */</span>
 	jnc	1f
 	TRACE_IRQS_ON
 1:
 #endif
 .endm
 
<span class="p_add">+.macro TRACE_IRQS_IRETQ</span>
<span class="p_add">+	TRACE_IRQS_FLAGS EFLAGS(%rsp)</span>
<span class="p_add">+.endm</span>
<span class="p_add">+</span>
 /*
  * When dynamic function tracer is enabled it will add a breakpoint
  * to all locations that it is about to modify, sync CPUs, update
<span class="p_chunk">@@ -148,8 +152,6 @@</span> <span class="p_context"> ENTRY(entry_SYSCALL_64)</span>
 	movq	%rsp, PER_CPU_VAR(rsp_scratch)
 	movq	PER_CPU_VAR(cpu_current_top_of_stack), %rsp
 
<span class="p_del">-	TRACE_IRQS_OFF</span>
<span class="p_del">-</span>
 	/* Construct struct pt_regs on stack */
 	pushq	$__USER_DS			/* pt_regs-&gt;ss */
 	pushq	PER_CPU_VAR(rsp_scratch)	/* pt_regs-&gt;sp */
<span class="p_chunk">@@ -170,6 +172,8 @@</span> <span class="p_context"> GLOBAL(entry_SYSCALL_64_after_hwframe)</span>
 	sub	$(6*8), %rsp			/* pt_regs-&gt;bp, bx, r12-15 not saved */
 	UNWIND_HINT_REGS extra=0
 
<span class="p_add">+	TRACE_IRQS_OFF</span>
<span class="p_add">+</span>
 	/*
 	 * If we need to do entry work or if we guess we&#39;ll need to do
 	 * exit work, go straight to the slow path.
<span class="p_chunk">@@ -943,11 +947,13 @@</span> <span class="p_context"> ENTRY(native_load_gs_index)</span>
 	FRAME_BEGIN
 	pushfq
 	DISABLE_INTERRUPTS(CLBR_ANY &amp; ~CLBR_RDI)
<span class="p_add">+	TRACE_IRQS_OFF</span>
 	SWAPGS
 .Lgs_change:
 	movl	%edi, %gs
 2:	ALTERNATIVE &quot;&quot;, &quot;mfence&quot;, X86_BUG_SWAPGS_FENCE
 	SWAPGS
<span class="p_add">+	TRACE_IRQS_FLAGS (%rsp)</span>
 	popfq
 	FRAME_END
 	ret
<span class="p_header">diff --git a/arch/x86/events/intel/uncore.c b/arch/x86/events/intel/uncore.c</span>
<span class="p_header">index d45e06346f14..7874c980d569 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore.c</span>
<span class="p_chunk">@@ -975,10 +975,10 @@</span> <span class="p_context"> static void uncore_pci_remove(struct pci_dev *pdev)</span>
 	int i, phys_id, pkg;
 
 	phys_id = uncore_pcibus_to_physid(pdev-&gt;bus);
<span class="p_del">-	pkg = topology_phys_to_logical_pkg(phys_id);</span>
 
 	box = pci_get_drvdata(pdev);
 	if (!box) {
<span class="p_add">+		pkg = topology_phys_to_logical_pkg(phys_id);</span>
 		for (i = 0; i &lt; UNCORE_EXTRA_PCI_DEV_MAX; i++) {
 			if (uncore_extra_pci_dev[pkg].dev[i] == pdev) {
 				uncore_extra_pci_dev[pkg].dev[i] = NULL;
<span class="p_chunk">@@ -994,7 +994,7 @@</span> <span class="p_context"> static void uncore_pci_remove(struct pci_dev *pdev)</span>
 		return;
 
 	pci_set_drvdata(pdev, NULL);
<span class="p_del">-	pmu-&gt;boxes[pkg] = NULL;</span>
<span class="p_add">+	pmu-&gt;boxes[box-&gt;pkgid] = NULL;</span>
 	if (atomic_dec_return(&amp;pmu-&gt;activeboxes) == 0)
 		uncore_pmu_unregister(pmu);
 	uncore_box_exit(box);
<span class="p_header">diff --git a/arch/x86/events/intel/uncore.h b/arch/x86/events/intel/uncore.h</span>
<span class="p_header">index 4364191e7c6b..414dc7e7c950 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore.h</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore.h</span>
<span class="p_chunk">@@ -100,7 +100,7 @@</span> <span class="p_context"> struct intel_uncore_extra_reg {</span>
 
 struct intel_uncore_box {
 	int pci_phys_id;
<span class="p_del">-	int pkgid;</span>
<span class="p_add">+	int pkgid;	/* Logical package ID */</span>
 	int n_active;	/* number of active events */
 	int n_events;
 	int cpu;	/* cpu to collect events */
<span class="p_header">diff --git a/arch/x86/events/intel/uncore_snbep.c b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">index 95cb19f4e06f..de8f8625213c 100644</span>
<span class="p_header">--- a/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_header">+++ b/arch/x86/events/intel/uncore_snbep.c</span>
<span class="p_chunk">@@ -1057,7 +1057,7 @@</span> <span class="p_context"> static void snbep_qpi_enable_event(struct intel_uncore_box *box, struct perf_eve</span>
 
 	if (reg1-&gt;idx != EXTRA_REG_NONE) {
 		int idx = box-&gt;pmu-&gt;pmu_idx + SNBEP_PCI_QPI_PORT0_FILTER;
<span class="p_del">-		int pkg = topology_phys_to_logical_pkg(box-&gt;pci_phys_id);</span>
<span class="p_add">+		int pkg = box-&gt;pkgid;</span>
 		struct pci_dev *filter_pdev = uncore_extra_pci_dev[pkg].dev[idx];
 
 		if (filter_pdev) {
<span class="p_header">diff --git a/arch/x86/include/asm/elf.h b/arch/x86/include/asm/elf.h</span>
<span class="p_header">index 3a091cea36c5..0d157d2a1e2a 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/elf.h</span>
<span class="p_chunk">@@ -309,6 +309,7 @@</span> <span class="p_context"> static inline int mmap_is_ia32(void)</span>
 extern unsigned long task_size_32bit(void);
 extern unsigned long task_size_64bit(int full_addr_space);
 extern unsigned long get_mmap_base(int is_legacy);
<span class="p_add">+extern bool mmap_address_hint_valid(unsigned long addr, unsigned long len);</span>
 
 #ifdef CONFIG_X86_32
 
<span class="p_header">diff --git a/arch/x86/include/asm/hw_irq.h b/arch/x86/include/asm/hw_irq.h</span>
<span class="p_header">index b80e46733909..2851077b6051 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/hw_irq.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/hw_irq.h</span>
<span class="p_chunk">@@ -99,14 +99,6 @@</span> <span class="p_context"> struct irq_alloc_info {</span>
 			void		*dmar_data;
 		};
 #endif
<span class="p_del">-#ifdef	CONFIG_HT_IRQ</span>
<span class="p_del">-		struct {</span>
<span class="p_del">-			int		ht_pos;</span>
<span class="p_del">-			int		ht_idx;</span>
<span class="p_del">-			struct pci_dev	*ht_dev;</span>
<span class="p_del">-			void		*ht_update;</span>
<span class="p_del">-		};</span>
<span class="p_del">-#endif</span>
 #ifdef	CONFIG_X86_UV
 		struct {
 			int		uv_limit;
<span class="p_header">diff --git a/arch/x86/include/asm/hypertransport.h b/arch/x86/include/asm/hypertransport.h</span>
deleted file mode 100644
<span class="p_header">index 5d55df352879..000000000000</span>
<span class="p_header">--- a/arch/x86/include/asm/hypertransport.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,46 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/* SPDX-License-Identifier: GPL-2.0 */</span>
<span class="p_del">-#ifndef _ASM_X86_HYPERTRANSPORT_H</span>
<span class="p_del">-#define _ASM_X86_HYPERTRANSPORT_H</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Constants for x86 Hypertransport Interrupts.</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_LOW_BASE			0xf8000000</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_LOW_VECTOR_SHIFT		16</span>
<span class="p_del">-#define HT_IRQ_LOW_VECTOR_MASK		0x00ff0000</span>
<span class="p_del">-#define HT_IRQ_LOW_VECTOR(v)						\</span>
<span class="p_del">-	(((v) &lt;&lt; HT_IRQ_LOW_VECTOR_SHIFT) &amp; HT_IRQ_LOW_VECTOR_MASK)</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_LOW_DEST_ID_SHIFT	8</span>
<span class="p_del">-#define HT_IRQ_LOW_DEST_ID_MASK		0x0000ff00</span>
<span class="p_del">-#define HT_IRQ_LOW_DEST_ID(v)						\</span>
<span class="p_del">-	(((v) &lt;&lt; HT_IRQ_LOW_DEST_ID_SHIFT) &amp; HT_IRQ_LOW_DEST_ID_MASK)</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_LOW_DM_PHYSICAL		0x0000000</span>
<span class="p_del">-#define HT_IRQ_LOW_DM_LOGICAL		0x0000040</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_LOW_RQEOI_EDGE		0x0000000</span>
<span class="p_del">-#define HT_IRQ_LOW_RQEOI_LEVEL		0x0000020</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_FIXED		0x0000000</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_ARBITRATED	0x0000004</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_SMI		0x0000008</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_NMI		0x000000c</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_INIT		0x0000010</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_STARTUP		0x0000014</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_EXTINT		0x0000018</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_LINT1		0x000008c</span>
<span class="p_del">-#define HT_IRQ_LOW_MT_LINT0		0x0000098</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_LOW_IRQ_MASKED		0x0000001</span>
<span class="p_del">-</span>
<span class="p_del">-</span>
<span class="p_del">-#define HT_IRQ_HIGH_DEST_ID_SHIFT	0</span>
<span class="p_del">-#define HT_IRQ_HIGH_DEST_ID_MASK	0x00ffffff</span>
<span class="p_del">-#define HT_IRQ_HIGH_DEST_ID(v)						\</span>
<span class="p_del">-	((((v) &gt;&gt; 8) &lt;&lt; HT_IRQ_HIGH_DEST_ID_SHIFT) &amp; HT_IRQ_HIGH_DEST_ID_MASK)</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* _ASM_X86_HYPERTRANSPORT_H */</span>
<span class="p_header">diff --git a/arch/x86/include/asm/insn-eval.h b/arch/x86/include/asm/insn-eval.h</span>
<span class="p_header">index e1d3b4ce8a92..2b6ccf2c49f1 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/insn-eval.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/insn-eval.h</span>
<span class="p_chunk">@@ -18,6 +18,6 @@</span> <span class="p_context"></span>
 void __user *insn_get_addr_ref(struct insn *insn, struct pt_regs *regs);
 int insn_get_modrm_rm_off(struct insn *insn, struct pt_regs *regs);
 unsigned long insn_get_seg_base(struct pt_regs *regs, int seg_reg_idx);
<span class="p_del">-char insn_get_code_seg_params(struct pt_regs *regs);</span>
<span class="p_add">+int insn_get_code_seg_params(struct pt_regs *regs);</span>
 
 #endif /* _ASM_X86_INSN_EVAL_H */
<span class="p_header">diff --git a/arch/x86/include/asm/io.h b/arch/x86/include/asm/io.h</span>
<span class="p_header">index 93ae8aee1780..95e948627fd0 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/io.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/io.h</span>
<span class="p_chunk">@@ -111,6 +111,10 @@</span> <span class="p_context"> build_mmio_write(__writeq, &quot;q&quot;, unsigned long, &quot;r&quot;, )</span>
 
 #endif
 
<span class="p_add">+#define ARCH_HAS_VALID_PHYS_ADDR_RANGE</span>
<span class="p_add">+extern int valid_phys_addr_range(phys_addr_t addr, size_t size);</span>
<span class="p_add">+extern int valid_mmap_phys_addr_range(unsigned long pfn, size_t size);</span>
<span class="p_add">+</span>
 /**
  *	virt_to_phys	-	map virtual addresses to physical
  *	@address: address to remap
<span class="p_header">diff --git a/arch/x86/include/asm/irqdomain.h b/arch/x86/include/asm/irqdomain.h</span>
<span class="p_header">index f695cc6b8e1f..139feef467f7 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/irqdomain.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/irqdomain.h</span>
<span class="p_chunk">@@ -56,10 +56,4 @@</span> <span class="p_context"> extern void arch_init_msi_domain(struct irq_domain *domain);</span>
 static inline void arch_init_msi_domain(struct irq_domain *domain) { }
 #endif
 
<span class="p_del">-#ifdef CONFIG_HT_IRQ</span>
<span class="p_del">-extern void arch_init_htirq_domain(struct irq_domain *domain);</span>
<span class="p_del">-#else</span>
<span class="p_del">-static inline void arch_init_htirq_domain(struct irq_domain *domain) { }</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 #endif
<span class="p_header">diff --git a/arch/x86/include/asm/processor.h b/arch/x86/include/asm/processor.h</span>
<span class="p_header">index 2db7cf720b04..cc16fa882e3e 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/processor.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/processor.h</span>
<span class="p_chunk">@@ -132,6 +132,7 @@</span> <span class="p_context"> struct cpuinfo_x86 {</span>
 	/* Index into per_cpu list: */
 	u16			cpu_index;
 	u32			microcode;
<span class="p_add">+	unsigned		initialized : 1;</span>
 } __randomize_layout;
 
 struct cpuid_regs {
<span class="p_header">diff --git a/arch/x86/kernel/acpi/boot.c b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">index ef9e02e614d0..f4c463df8b08 100644</span>
<span class="p_header">--- a/arch/x86/kernel/acpi/boot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/acpi/boot.c</span>
<span class="p_chunk">@@ -342,13 +342,12 @@</span> <span class="p_context"> acpi_parse_lapic_nmi(struct acpi_subtable_header * header, const unsigned long e</span>
 #ifdef CONFIG_X86_IO_APIC
 #define MP_ISA_BUS		0
 
<span class="p_add">+static int __init mp_register_ioapic_irq(u8 bus_irq, u8 polarity,</span>
<span class="p_add">+						u8 trigger, u32 gsi);</span>
<span class="p_add">+</span>
 static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,
 					  u32 gsi)
 {
<span class="p_del">-	int ioapic;</span>
<span class="p_del">-	int pin;</span>
<span class="p_del">-	struct mpc_intsrc mp_irq;</span>
<span class="p_del">-</span>
 	/*
 	 * Check bus_irq boundary.
 	 */
<span class="p_chunk">@@ -357,14 +356,6 @@</span> <span class="p_context"> static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,</span>
 		return;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Convert &#39;gsi&#39; to &#39;ioapic.pin&#39;.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ioapic = mp_find_ioapic(gsi);</span>
<span class="p_del">-	if (ioapic &lt; 0)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	pin = mp_find_ioapic_pin(ioapic, gsi);</span>
<span class="p_del">-</span>
 	/*
 	 * TBD: This check is for faulty timer entries, where the override
 	 *      erroneously sets the trigger to level, resulting in a HUGE
<span class="p_chunk">@@ -373,16 +364,8 @@</span> <span class="p_context"> static void __init mp_override_legacy_irq(u8 bus_irq, u8 polarity, u8 trigger,</span>
 	if ((bus_irq == 0) &amp;&amp; (trigger == 3))
 		trigger = 1;
 
<span class="p_del">-	mp_irq.type = MP_INTSRC;</span>
<span class="p_del">-	mp_irq.irqtype = mp_INT;</span>
<span class="p_del">-	mp_irq.irqflag = (trigger &lt;&lt; 2) | polarity;</span>
<span class="p_del">-	mp_irq.srcbus = MP_ISA_BUS;</span>
<span class="p_del">-	mp_irq.srcbusirq = bus_irq;	/* IRQ */</span>
<span class="p_del">-	mp_irq.dstapic = mpc_ioapic_id(ioapic); /* APIC ID */</span>
<span class="p_del">-	mp_irq.dstirq = pin;	/* INTIN# */</span>
<span class="p_del">-</span>
<span class="p_del">-	mp_save_irq(&amp;mp_irq);</span>
<span class="p_del">-</span>
<span class="p_add">+	if (mp_register_ioapic_irq(bus_irq, polarity, trigger, gsi) &lt; 0)</span>
<span class="p_add">+		return;</span>
 	/*
 	 * Reset default identity mapping if gsi is also an legacy IRQ,
 	 * otherwise there will be more than one entry with the same GSI
<span class="p_chunk">@@ -429,6 +412,34 @@</span> <span class="p_context"> static int mp_config_acpi_gsi(struct device *dev, u32 gsi, int trigger,</span>
 	return 0;
 }
 
<span class="p_add">+static int __init mp_register_ioapic_irq(u8 bus_irq, u8 polarity,</span>
<span class="p_add">+						u8 trigger, u32 gsi)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct mpc_intsrc mp_irq;</span>
<span class="p_add">+	int ioapic, pin;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Convert &#39;gsi&#39; to &#39;ioapic.pin&#39;(INTIN#) */</span>
<span class="p_add">+	ioapic = mp_find_ioapic(gsi);</span>
<span class="p_add">+	if (ioapic &lt; 0) {</span>
<span class="p_add">+		pr_warn(&quot;Failed to find ioapic for gsi : %u\n&quot;, gsi);</span>
<span class="p_add">+		return ioapic;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pin = mp_find_ioapic_pin(ioapic, gsi);</span>
<span class="p_add">+</span>
<span class="p_add">+	mp_irq.type = MP_INTSRC;</span>
<span class="p_add">+	mp_irq.irqtype = mp_INT;</span>
<span class="p_add">+	mp_irq.irqflag = (trigger &lt;&lt; 2) | polarity;</span>
<span class="p_add">+	mp_irq.srcbus = MP_ISA_BUS;</span>
<span class="p_add">+	mp_irq.srcbusirq = bus_irq;</span>
<span class="p_add">+	mp_irq.dstapic = mpc_ioapic_id(ioapic);</span>
<span class="p_add">+	mp_irq.dstirq = pin;</span>
<span class="p_add">+</span>
<span class="p_add">+	mp_save_irq(&amp;mp_irq);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init
 acpi_parse_ioapic(struct acpi_subtable_header * header, const unsigned long end)
 {
<span class="p_chunk">@@ -473,7 +484,11 @@</span> <span class="p_context"> static void __init acpi_sci_ioapic_setup(u8 bus_irq, u16 polarity, u16 trigger,</span>
 	if (acpi_sci_flags &amp; ACPI_MADT_POLARITY_MASK)
 		polarity = acpi_sci_flags &amp; ACPI_MADT_POLARITY_MASK;
 
<span class="p_del">-	mp_override_legacy_irq(bus_irq, polarity, trigger, gsi);</span>
<span class="p_add">+	if (bus_irq &lt; NR_IRQS_LEGACY)</span>
<span class="p_add">+		mp_override_legacy_irq(bus_irq, polarity, trigger, gsi);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		mp_register_ioapic_irq(bus_irq, polarity, trigger, gsi);</span>
<span class="p_add">+</span>
 	acpi_penalize_sci_irq(bus_irq, trigger, polarity);
 
 	/*
<span class="p_header">diff --git a/arch/x86/kernel/apic/Makefile b/arch/x86/kernel/apic/Makefile</span>
<span class="p_header">index a9e08924927e..a6fcaf16cdbf 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/Makefile</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/Makefile</span>
<span class="p_chunk">@@ -12,7 +12,6 @@</span> <span class="p_context"> obj-y				+= hw_nmi.o</span>
 
 obj-$(CONFIG_X86_IO_APIC)	+= io_apic.o
 obj-$(CONFIG_PCI_MSI)		+= msi.o
<span class="p_del">-obj-$(CONFIG_HT_IRQ)		+= htirq.o</span>
 obj-$(CONFIG_SMP)		+= ipi.o
 
 ifeq ($(CONFIG_X86_64),y)
<span class="p_header">diff --git a/arch/x86/kernel/apic/htirq.c b/arch/x86/kernel/apic/htirq.c</span>
deleted file mode 100644
<span class="p_header">index b07075dce8b7..000000000000</span>
<span class="p_header">--- a/arch/x86/kernel/apic/htirq.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,198 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/*</span>
<span class="p_del">- * Support Hypertransport IRQ</span>
<span class="p_del">- *</span>
<span class="p_del">- * Copyright (C) 1997, 1998, 1999, 2000, 2009 Ingo Molnar, Hajnalka Szabo</span>
<span class="p_del">- *	Moved from arch/x86/kernel/apic/io_apic.c.</span>
<span class="p_del">- * Jiang Liu &lt;jiang.liu@linux.intel.com&gt;</span>
<span class="p_del">- *	Add support of hierarchical irqdomain</span>
<span class="p_del">- *</span>
<span class="p_del">- * This program is free software; you can redistribute it and/or modify</span>
<span class="p_del">- * it under the terms of the GNU General Public License version 2 as</span>
<span class="p_del">- * published by the Free Software Foundation.</span>
<span class="p_del">- */</span>
<span class="p_del">-#include &lt;linux/mm.h&gt;</span>
<span class="p_del">-#include &lt;linux/interrupt.h&gt;</span>
<span class="p_del">-#include &lt;linux/init.h&gt;</span>
<span class="p_del">-#include &lt;linux/device.h&gt;</span>
<span class="p_del">-#include &lt;linux/pci.h&gt;</span>
<span class="p_del">-#include &lt;linux/htirq.h&gt;</span>
<span class="p_del">-#include &lt;asm/irqdomain.h&gt;</span>
<span class="p_del">-#include &lt;asm/hw_irq.h&gt;</span>
<span class="p_del">-#include &lt;asm/apic.h&gt;</span>
<span class="p_del">-#include &lt;asm/hypertransport.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-static struct irq_domain *htirq_domain;</span>
<span class="p_del">-</span>
<span class="p_del">-/*</span>
<span class="p_del">- * Hypertransport interrupt support</span>
<span class="p_del">- */</span>
<span class="p_del">-static int</span>
<span class="p_del">-ht_set_affinity(struct irq_data *data, const struct cpumask *mask, bool force)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct irq_data *parent = data-&gt;parent_data;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = parent-&gt;chip-&gt;irq_set_affinity(parent, mask, force);</span>
<span class="p_del">-	if (ret &gt;= 0) {</span>
<span class="p_del">-		struct ht_irq_msg msg;</span>
<span class="p_del">-		struct irq_cfg *cfg = irqd_cfg(data);</span>
<span class="p_del">-</span>
<span class="p_del">-		fetch_ht_irq_msg(data-&gt;irq, &amp;msg);</span>
<span class="p_del">-		msg.address_lo &amp;= ~(HT_IRQ_LOW_VECTOR_MASK |</span>
<span class="p_del">-				    HT_IRQ_LOW_DEST_ID_MASK);</span>
<span class="p_del">-		msg.address_lo |= HT_IRQ_LOW_VECTOR(cfg-&gt;vector) |</span>
<span class="p_del">-				  HT_IRQ_LOW_DEST_ID(cfg-&gt;dest_apicid);</span>
<span class="p_del">-		msg.address_hi &amp;= ~(HT_IRQ_HIGH_DEST_ID_MASK);</span>
<span class="p_del">-		msg.address_hi |= HT_IRQ_HIGH_DEST_ID(cfg-&gt;dest_apicid);</span>
<span class="p_del">-		write_ht_irq_msg(data-&gt;irq, &amp;msg);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return ret;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct irq_chip ht_irq_chip = {</span>
<span class="p_del">-	.name			= &quot;PCI-HT&quot;,</span>
<span class="p_del">-	.irq_mask		= mask_ht_irq,</span>
<span class="p_del">-	.irq_unmask		= unmask_ht_irq,</span>
<span class="p_del">-	.irq_ack		= irq_chip_ack_parent,</span>
<span class="p_del">-	.irq_set_affinity	= ht_set_affinity,</span>
<span class="p_del">-	.irq_retrigger		= irq_chip_retrigger_hierarchy,</span>
<span class="p_del">-	.flags			= IRQCHIP_SKIP_SET_WAKE,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-static int htirq_domain_alloc(struct irq_domain *domain, unsigned int virq,</span>
<span class="p_del">-			      unsigned int nr_irqs, void *arg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ht_irq_cfg *ht_cfg;</span>
<span class="p_del">-	struct irq_alloc_info *info = arg;</span>
<span class="p_del">-	struct pci_dev *dev;</span>
<span class="p_del">-	irq_hw_number_t hwirq;</span>
<span class="p_del">-	int ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (nr_irqs &gt; 1 || !info)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	dev = info-&gt;ht_dev;</span>
<span class="p_del">-	hwirq = (info-&gt;ht_idx &amp; 0xFF) |</span>
<span class="p_del">-		PCI_DEVID(dev-&gt;bus-&gt;number, dev-&gt;devfn) &lt;&lt; 8 |</span>
<span class="p_del">-		(pci_domain_nr(dev-&gt;bus) &amp; 0xFFFFFFFF) &lt;&lt; 24;</span>
<span class="p_del">-	if (irq_find_mapping(domain, hwirq) &gt; 0)</span>
<span class="p_del">-		return -EEXIST;</span>
<span class="p_del">-</span>
<span class="p_del">-	ht_cfg = kmalloc(sizeof(*ht_cfg), GFP_KERNEL);</span>
<span class="p_del">-	if (!ht_cfg)</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, info);</span>
<span class="p_del">-	if (ret &lt; 0) {</span>
<span class="p_del">-		kfree(ht_cfg);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Initialize msg to a value that will never match the first write. */</span>
<span class="p_del">-	ht_cfg-&gt;msg.address_lo = 0xffffffff;</span>
<span class="p_del">-	ht_cfg-&gt;msg.address_hi = 0xffffffff;</span>
<span class="p_del">-	ht_cfg-&gt;dev = info-&gt;ht_dev;</span>
<span class="p_del">-	ht_cfg-&gt;update = info-&gt;ht_update;</span>
<span class="p_del">-	ht_cfg-&gt;pos = info-&gt;ht_pos;</span>
<span class="p_del">-	ht_cfg-&gt;idx = 0x10 + (info-&gt;ht_idx * 2);</span>
<span class="p_del">-	irq_domain_set_info(domain, virq, hwirq, &amp;ht_irq_chip, ht_cfg,</span>
<span class="p_del">-			    handle_edge_irq, ht_cfg, &quot;edge&quot;);</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void htirq_domain_free(struct irq_domain *domain, unsigned int virq,</span>
<span class="p_del">-			      unsigned int nr_irqs)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);</span>
<span class="p_del">-</span>
<span class="p_del">-	BUG_ON(nr_irqs != 1);</span>
<span class="p_del">-	kfree(irq_data-&gt;chip_data);</span>
<span class="p_del">-	irq_domain_free_irqs_top(domain, virq, nr_irqs);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static int htirq_domain_activate(struct irq_domain *domain,</span>
<span class="p_del">-				 struct irq_data *irq_data, bool early)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ht_irq_msg msg;</span>
<span class="p_del">-	struct irq_cfg *cfg = irqd_cfg(irq_data);</span>
<span class="p_del">-</span>
<span class="p_del">-	msg.address_hi = HT_IRQ_HIGH_DEST_ID(cfg-&gt;dest_apicid);</span>
<span class="p_del">-	msg.address_lo =</span>
<span class="p_del">-		HT_IRQ_LOW_BASE |</span>
<span class="p_del">-		HT_IRQ_LOW_DEST_ID(cfg-&gt;dest_apicid) |</span>
<span class="p_del">-		HT_IRQ_LOW_VECTOR(cfg-&gt;vector) |</span>
<span class="p_del">-		((apic-&gt;irq_dest_mode == 0) ?</span>
<span class="p_del">-			HT_IRQ_LOW_DM_PHYSICAL :</span>
<span class="p_del">-			HT_IRQ_LOW_DM_LOGICAL) |</span>
<span class="p_del">-		HT_IRQ_LOW_RQEOI_EDGE |</span>
<span class="p_del">-		((apic-&gt;irq_delivery_mode != dest_LowestPrio) ?</span>
<span class="p_del">-			HT_IRQ_LOW_MT_FIXED :</span>
<span class="p_del">-			HT_IRQ_LOW_MT_ARBITRATED) |</span>
<span class="p_del">-		HT_IRQ_LOW_IRQ_MASKED;</span>
<span class="p_del">-	write_ht_irq_msg(irq_data-&gt;irq, &amp;msg);</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static void htirq_domain_deactivate(struct irq_domain *domain,</span>
<span class="p_del">-				    struct irq_data *irq_data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ht_irq_msg msg;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(&amp;msg, 0, sizeof(msg));</span>
<span class="p_del">-	write_ht_irq_msg(irq_data-&gt;irq, &amp;msg);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static const struct irq_domain_ops htirq_domain_ops = {</span>
<span class="p_del">-	.alloc		= htirq_domain_alloc,</span>
<span class="p_del">-	.free		= htirq_domain_free,</span>
<span class="p_del">-	.activate	= htirq_domain_activate,</span>
<span class="p_del">-	.deactivate	= htirq_domain_deactivate,</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-void __init arch_init_htirq_domain(struct irq_domain *parent)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct fwnode_handle *fn;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (disable_apic)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	fn = irq_domain_alloc_named_fwnode(&quot;PCI-HT&quot;);</span>
<span class="p_del">-	if (!fn)</span>
<span class="p_del">-		goto warn;</span>
<span class="p_del">-</span>
<span class="p_del">-	htirq_domain = irq_domain_create_tree(fn, &amp;htirq_domain_ops, NULL);</span>
<span class="p_del">-	irq_domain_free_fwnode(fn);</span>
<span class="p_del">-	if (!htirq_domain)</span>
<span class="p_del">-		goto warn;</span>
<span class="p_del">-</span>
<span class="p_del">-	htirq_domain-&gt;parent = parent;</span>
<span class="p_del">-	return;</span>
<span class="p_del">-</span>
<span class="p_del">-warn:</span>
<span class="p_del">-	pr_warn(&quot;Failed to initialize irqdomain for HTIRQ.\n&quot;);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-int arch_setup_ht_irq(int idx, int pos, struct pci_dev *dev,</span>
<span class="p_del">-		      ht_irq_update_t *update)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct irq_alloc_info info;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!htirq_domain)</span>
<span class="p_del">-		return -ENOSYS;</span>
<span class="p_del">-</span>
<span class="p_del">-	init_irq_alloc_info(&amp;info, NULL);</span>
<span class="p_del">-	info.ht_idx = idx;</span>
<span class="p_del">-	info.ht_pos = pos;</span>
<span class="p_del">-	info.ht_dev = dev;</span>
<span class="p_del">-	info.ht_update = update;</span>
<span class="p_del">-</span>
<span class="p_del">-	return irq_domain_alloc_irqs(htirq_domain, 1, dev_to_node(&amp;dev-&gt;dev),</span>
<span class="p_del">-				     &amp;info);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void arch_teardown_ht_irq(unsigned int irq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	irq_domain_free_irqs(irq, 1);</span>
<span class="p_del">-}</span>
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index 05c85e693a5d..6a823a25eaff 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -1,5 +1,5 @@</span> <span class="p_context"></span>
 /*
<span class="p_del">- * Local APIC related interfaces to support IOAPIC, MSI, HT_IRQ etc.</span>
<span class="p_add">+ * Local APIC related interfaces to support IOAPIC, MSI, etc.</span>
  *
  * Copyright (C) 1997, 1998, 1999, 2000, 2009 Ingo Molnar, Hajnalka Szabo
  *	Moved from arch/x86/kernel/apic/io_apic.c.
<span class="p_chunk">@@ -601,7 +601,7 @@</span> <span class="p_context"> int __init arch_probe_nr_irqs(void)</span>
 		nr_irqs = NR_VECTORS * nr_cpu_ids;
 
 	nr = (gsi_top + nr_legacy_irqs()) + 8 * nr_cpu_ids;
<span class="p_del">-#if defined(CONFIG_PCI_MSI) || defined(CONFIG_HT_IRQ)</span>
<span class="p_add">+#if defined(CONFIG_PCI_MSI)</span>
 	/*
 	 * for MSI and HT dyn irq
 	 */
<span class="p_chunk">@@ -663,7 +663,6 @@</span> <span class="p_context"> int __init arch_early_irq_init(void)</span>
 	irq_set_default_host(x86_vector_domain);
 
 	arch_init_msi_domain(x86_vector_domain);
<span class="p_del">-	arch_init_htirq_domain(x86_vector_domain);</span>
 
 	BUG_ON(!alloc_cpumask_var(&amp;vector_searchmask, GFP_KERNEL));
 
<span class="p_header">diff --git a/arch/x86/kernel/cpu/common.c b/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">index 13ae9e5eec2f..fa998ca8aa5a 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/common.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/common.c</span>
<span class="p_chunk">@@ -341,6 +341,8 @@</span> <span class="p_context"> static __always_inline void setup_umip(struct cpuinfo_x86 *c)</span>
 
 	cr4_set_bits(X86_CR4_UMIP);
 
<span class="p_add">+	pr_info(&quot;x86/cpu: Activated the Intel User Mode Instruction Prevention (UMIP) CPU feature\n&quot;);</span>
<span class="p_add">+</span>
 	return;
 
 out:
<span class="p_header">diff --git a/arch/x86/kernel/mpparse.c b/arch/x86/kernel/mpparse.c</span>
<span class="p_header">index 410c5dadcee3..3a4b12809ab5 100644</span>
<span class="p_header">--- a/arch/x86/kernel/mpparse.c</span>
<span class="p_header">+++ b/arch/x86/kernel/mpparse.c</span>
<span class="p_chunk">@@ -431,6 +431,7 @@</span> <span class="p_context"> static inline void __init construct_default_ISA_mptable(int mpc_default_type)</span>
 }
 
 static unsigned long mpf_base;
<span class="p_add">+static bool mpf_found;</span>
 
 static unsigned long __init get_mpc_size(unsigned long physptr)
 {
<span class="p_chunk">@@ -504,7 +505,7 @@</span> <span class="p_context"> void __init default_get_smp_config(unsigned int early)</span>
 	if (!smp_found_config)
 		return;
 
<span class="p_del">-	if (!mpf_base)</span>
<span class="p_add">+	if (!mpf_found)</span>
 		return;
 
 	if (acpi_lapic &amp;&amp; early)
<span class="p_chunk">@@ -593,6 +594,7 @@</span> <span class="p_context"> static int __init smp_scan_config(unsigned long base, unsigned long length)</span>
 			smp_found_config = 1;
 #endif
 			mpf_base = base;
<span class="p_add">+			mpf_found = true;</span>
 
 			pr_info(&quot;found SMP MP-table at [mem %#010lx-%#010lx] mapped at [%p]\n&quot;,
 				base, base + sizeof(*mpf) - 1, mpf);
<span class="p_chunk">@@ -858,7 +860,7 @@</span> <span class="p_context"> static int __init update_mp_table(void)</span>
 	if (!enable_update_mptable)
 		return 0;
 
<span class="p_del">-	if (!mpf_base)</span>
<span class="p_add">+	if (!mpf_found)</span>
 		return 0;
 
 	mpf = early_memremap(mpf_base, sizeof(*mpf));
<span class="p_header">diff --git a/arch/x86/kernel/smpboot.c b/arch/x86/kernel/smpboot.c</span>
<span class="p_header">index 5f59e6bee123..3d01df7d7cf6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smpboot.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smpboot.c</span>
<span class="p_chunk">@@ -101,9 +101,6 @@</span> <span class="p_context"> DEFINE_PER_CPU_READ_MOSTLY(struct cpuinfo_x86, cpu_info);</span>
 EXPORT_PER_CPU_SYMBOL(cpu_info);
 
 /* Logical package management. We might want to allocate that dynamically */
<span class="p_del">-static int *physical_to_logical_pkg __read_mostly;</span>
<span class="p_del">-static unsigned long *physical_package_map __read_mostly;;</span>
<span class="p_del">-static unsigned int max_physical_pkg_id __read_mostly;</span>
 unsigned int __max_logical_packages __read_mostly;
 EXPORT_SYMBOL(__max_logical_packages);
 static unsigned int logical_packages __read_mostly;
<span class="p_chunk">@@ -280,6 +277,25 @@</span> <span class="p_context"> static void notrace start_secondary(void *unused)</span>
 	cpu_startup_entry(CPUHP_AP_ONLINE_IDLE);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * topology_phys_to_logical_pkg - Map a physical package id to a logical</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns logical package id or -1 if not found</span>
<span class="p_add">+ */</span>
<span class="p_add">+int topology_phys_to_logical_pkg(unsigned int phys_pkg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	for_each_possible_cpu(cpu) {</span>
<span class="p_add">+		struct cpuinfo_x86 *c = &amp;cpu_data(cpu);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (c-&gt;initialized &amp;&amp; c-&gt;phys_proc_id == phys_pkg)</span>
<span class="p_add">+			return c-&gt;logical_proc_id;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return -1;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(topology_phys_to_logical_pkg);</span>
<span class="p_add">+</span>
 /**
  * topology_update_package_map - Update the physical to logical package map
  * @pkg:	The physical package id as retrieved via CPUID
<span class="p_chunk">@@ -287,102 +303,23 @@</span> <span class="p_context"> static void notrace start_secondary(void *unused)</span>
  */
 int topology_update_package_map(unsigned int pkg, unsigned int cpu)
 {
<span class="p_del">-	unsigned int new;</span>
<span class="p_add">+	int new;</span>
 
<span class="p_del">-	/* Called from early boot ? */</span>
<span class="p_del">-	if (!physical_package_map)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (pkg &gt;= max_physical_pkg_id)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Set the logical package id */</span>
<span class="p_del">-	if (test_and_set_bit(pkg, physical_package_map))</span>
<span class="p_add">+	/* Already available somewhere? */</span>
<span class="p_add">+	new = topology_phys_to_logical_pkg(pkg);</span>
<span class="p_add">+	if (new &gt;= 0)</span>
 		goto found;
 
<span class="p_del">-	if (logical_packages &gt;= __max_logical_packages) {</span>
<span class="p_del">-		pr_warn(&quot;Package %u of CPU %u exceeds BIOS package data %u.\n&quot;,</span>
<span class="p_del">-			logical_packages, cpu, __max_logical_packages);</span>
<span class="p_del">-		return -ENOSPC;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	new = logical_packages++;
 	if (new != pkg) {
 		pr_info(&quot;CPU %u Converting physical %u to logical package %u\n&quot;,
 			cpu, pkg, new);
 	}
<span class="p_del">-	physical_to_logical_pkg[pkg] = new;</span>
<span class="p_del">-</span>
 found:
<span class="p_del">-	cpu_data(cpu).logical_proc_id = physical_to_logical_pkg[pkg];</span>
<span class="p_add">+	cpu_data(cpu).logical_proc_id = new;</span>
 	return 0;
 }
 
<span class="p_del">-/**</span>
<span class="p_del">- * topology_phys_to_logical_pkg - Map a physical package id to a logical</span>
<span class="p_del">- *</span>
<span class="p_del">- * Returns logical package id or -1 if not found</span>
<span class="p_del">- */</span>
<span class="p_del">-int topology_phys_to_logical_pkg(unsigned int phys_pkg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	if (phys_pkg &gt;= max_physical_pkg_id)</span>
<span class="p_del">-		return -1;</span>
<span class="p_del">-	return physical_to_logical_pkg[phys_pkg];</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(topology_phys_to_logical_pkg);</span>
<span class="p_del">-</span>
<span class="p_del">-static void __init smp_init_package_map(struct cpuinfo_x86 *c, unsigned int cpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	unsigned int ncpus;</span>
<span class="p_del">-	size_t size;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Today neither Intel nor AMD support heterogenous systems. That</span>
<span class="p_del">-	 * might change in the future....</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * While ideally we&#39;d want &#39;* smp_num_siblings&#39; in the below @ncpus</span>
<span class="p_del">-	 * computation, this won&#39;t actually work since some Intel BIOSes</span>
<span class="p_del">-	 * report inconsistent HT data when they disable HT.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * In particular, they reduce the APIC-IDs to only include the cores,</span>
<span class="p_del">-	 * but leave the CPUID topology to say there are (2) siblings.</span>
<span class="p_del">-	 * This means we don&#39;t know how many threads there will be until</span>
<span class="p_del">-	 * after the APIC enumeration.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * By not including this we&#39;ll sometimes over-estimate the number of</span>
<span class="p_del">-	 * logical packages by the amount of !present siblings, but this is</span>
<span class="p_del">-	 * still better than MAX_LOCAL_APIC.</span>
<span class="p_del">-	 *</span>
<span class="p_del">-	 * We use total_cpus not nr_cpu_ids because nr_cpu_ids can be limited</span>
<span class="p_del">-	 * on the command line leading to a similar issue as the HT disable</span>
<span class="p_del">-	 * problem because the hyperthreads are usually enumerated after the</span>
<span class="p_del">-	 * primary cores.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	ncpus = boot_cpu_data.x86_max_cores;</span>
<span class="p_del">-	if (!ncpus) {</span>
<span class="p_del">-		pr_warn(&quot;x86_max_cores == zero !?!?&quot;);</span>
<span class="p_del">-		ncpus = 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	__max_logical_packages = DIV_ROUND_UP(total_cpus, ncpus);</span>
<span class="p_del">-	logical_packages = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Possibly larger than what we need as the number of apic ids per</span>
<span class="p_del">-	 * package can be smaller than the actual used apic ids.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	max_physical_pkg_id = DIV_ROUND_UP(MAX_LOCAL_APIC, ncpus);</span>
<span class="p_del">-	size = max_physical_pkg_id * sizeof(unsigned int);</span>
<span class="p_del">-	physical_to_logical_pkg = kmalloc(size, GFP_KERNEL);</span>
<span class="p_del">-	memset(physical_to_logical_pkg, 0xff, size);</span>
<span class="p_del">-	size = BITS_TO_LONGS(max_physical_pkg_id) * sizeof(unsigned long);</span>
<span class="p_del">-	physical_package_map = kzalloc(size, GFP_KERNEL);</span>
<span class="p_del">-</span>
<span class="p_del">-	pr_info(&quot;Max logical packages: %u\n&quot;, __max_logical_packages);</span>
<span class="p_del">-</span>
<span class="p_del">-	topology_update_package_map(c-&gt;phys_proc_id, cpu);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void __init smp_store_boot_cpu_info(void)
 {
 	int id = 0; /* CPU 0 */
<span class="p_chunk">@@ -390,7 +327,8 @@</span> <span class="p_context"> void __init smp_store_boot_cpu_info(void)</span>
 
 	*c = boot_cpu_data;
 	c-&gt;cpu_index = id;
<span class="p_del">-	smp_init_package_map(c, id);</span>
<span class="p_add">+	topology_update_package_map(c-&gt;phys_proc_id, id);</span>
<span class="p_add">+	c-&gt;initialized = true;</span>
 }
 
 /*
<span class="p_chunk">@@ -401,13 +339,16 @@</span> <span class="p_context"> void smp_store_cpu_info(int id)</span>
 {
 	struct cpuinfo_x86 *c = &amp;cpu_data(id);
 
<span class="p_del">-	*c = boot_cpu_data;</span>
<span class="p_add">+	/* Copy boot_cpu_data only on the first bringup */</span>
<span class="p_add">+	if (!c-&gt;initialized)</span>
<span class="p_add">+		*c = boot_cpu_data;</span>
 	c-&gt;cpu_index = id;
 	/*
 	 * During boot time, CPU0 has this setup already. Save the info when
 	 * bringing up AP or offlined CPU0.
 	 */
 	identify_secondary_cpu(c);
<span class="p_add">+	c-&gt;initialized = true;</span>
 }
 
 static bool
<span class="p_chunk">@@ -1356,7 +1297,16 @@</span> <span class="p_context"> void __init native_smp_prepare_boot_cpu(void)</span>
 
 void __init native_smp_cpus_done(unsigned int max_cpus)
 {
<span class="p_add">+	int ncpus;</span>
<span class="p_add">+</span>
 	pr_debug(&quot;Boot done\n&quot;);
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Today neither Intel nor AMD support heterogenous systems so</span>
<span class="p_add">+	 * extrapolate the boot cpu&#39;s data to all packages.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	ncpus = cpu_data(0).booted_cores * smp_num_siblings;</span>
<span class="p_add">+	__max_logical_packages = DIV_ROUND_UP(nr_cpu_ids, ncpus);</span>
<span class="p_add">+	pr_info(&quot;Max logical packages: %u\n&quot;, __max_logical_packages);</span>
 
 	if (x86_has_numa_in_package)
 		set_sched_topology(x86_numa_in_package_topology);
<span class="p_header">diff --git a/arch/x86/kernel/sys_x86_64.c b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">index a63fe77b3217..676774b9bb8d 100644</span>
<span class="p_header">--- a/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_chunk">@@ -188,6 +188,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 	if (len &gt; TASK_SIZE)
 		return -ENOMEM;
 
<span class="p_add">+	/* No address checking. See comment at mmap_address_hint_valid() */</span>
 	if (flags &amp; MAP_FIXED)
 		return addr;
 
<span class="p_chunk">@@ -197,12 +198,15 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct file *filp, const unsigned long addr0,</span>
 
 	/* requesting a specific address */
 	if (addr) {
<span class="p_del">-		addr = PAGE_ALIGN(addr);</span>
<span class="p_add">+		addr &amp;= PAGE_MASK;</span>
<span class="p_add">+		if (!mmap_address_hint_valid(addr, len))</span>
<span class="p_add">+			goto get_unmapped_area;</span>
<span class="p_add">+</span>
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp;</span>
<span class="p_del">-				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="p_add">+		if (!vma || addr + len &lt;= vm_start_gap(vma))</span>
 			return addr;
 	}
<span class="p_add">+get_unmapped_area:</span>
 
 	info.flags = VM_UNMAPPED_AREA_TOPDOWN;
 	info.length = len;
<span class="p_header">diff --git a/arch/x86/kernel/umip.c b/arch/x86/kernel/umip.c</span>
<span class="p_header">index 6ba82be68cff..f44ce0fb3583 100644</span>
<span class="p_header">--- a/arch/x86/kernel/umip.c</span>
<span class="p_header">+++ b/arch/x86/kernel/umip.c</span>
<span class="p_chunk">@@ -78,7 +78,60 @@</span> <span class="p_context"></span>
 
 #define	UMIP_INST_SGDT	0	/* 0F 01 /0 */
 #define	UMIP_INST_SIDT	1	/* 0F 01 /1 */
<span class="p_del">-#define	UMIP_INST_SMSW	3	/* 0F 01 /4 */</span>
<span class="p_add">+#define	UMIP_INST_SMSW	2	/* 0F 01 /4 */</span>
<span class="p_add">+#define	UMIP_INST_SLDT  3       /* 0F 00 /0 */</span>
<span class="p_add">+#define	UMIP_INST_STR   4       /* 0F 00 /1 */</span>
<span class="p_add">+</span>
<span class="p_add">+const char * const umip_insns[5] = {</span>
<span class="p_add">+	[UMIP_INST_SGDT] = &quot;SGDT&quot;,</span>
<span class="p_add">+	[UMIP_INST_SIDT] = &quot;SIDT&quot;,</span>
<span class="p_add">+	[UMIP_INST_SMSW] = &quot;SMSW&quot;,</span>
<span class="p_add">+	[UMIP_INST_SLDT] = &quot;SLDT&quot;,</span>
<span class="p_add">+	[UMIP_INST_STR] = &quot;STR&quot;,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+#define umip_pr_err(regs, fmt, ...) \</span>
<span class="p_add">+	umip_printk(regs, KERN_ERR, fmt, ##__VA_ARGS__)</span>
<span class="p_add">+#define umip_pr_warning(regs, fmt, ...) \</span>
<span class="p_add">+	umip_printk(regs, KERN_WARNING, fmt,  ##__VA_ARGS__)</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * umip_printk() - Print a rate-limited message</span>
<span class="p_add">+ * @regs:	Register set with the context in which the warning is printed</span>
<span class="p_add">+ * @log_level:	Kernel log level to print the message</span>
<span class="p_add">+ * @fmt:	The text string to print</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Print the text contained in @fmt. The print rate is limited to bursts of 5</span>
<span class="p_add">+ * messages every two minutes. The purpose of this customized version of</span>
<span class="p_add">+ * printk() is to print messages when user space processes use any of the</span>
<span class="p_add">+ * UMIP-protected instructions. Thus, the printed text is prepended with the</span>
<span class="p_add">+ * task name and process ID number of the current task as well as the</span>
<span class="p_add">+ * instruction and stack pointers in @regs as seen when entering kernel mode.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Returns:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * None.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static __printf(3, 4)</span>
<span class="p_add">+void umip_printk(const struct pt_regs *regs, const char *log_level,</span>
<span class="p_add">+		 const char *fmt, ...)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Bursts of 5 messages every two minutes */</span>
<span class="p_add">+	static DEFINE_RATELIMIT_STATE(ratelimit, 2 * 60 * HZ, 5);</span>
<span class="p_add">+	struct task_struct *tsk = current;</span>
<span class="p_add">+	struct va_format vaf;</span>
<span class="p_add">+	va_list args;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!__ratelimit(&amp;ratelimit))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	va_start(args, fmt);</span>
<span class="p_add">+	vaf.fmt = fmt;</span>
<span class="p_add">+	vaf.va = &amp;args;</span>
<span class="p_add">+	printk(&quot;%s&quot; pr_fmt(&quot;%s[%d] ip:%lx sp:%lx: %pV&quot;), log_level, tsk-&gt;comm,</span>
<span class="p_add">+	       task_pid_nr(tsk), regs-&gt;ip, regs-&gt;sp, &amp;vaf);</span>
<span class="p_add">+	va_end(args);</span>
<span class="p_add">+}</span>
 
 /**
  * identify_insn() - Identify a UMIP-protected instruction
<span class="p_chunk">@@ -118,10 +171,16 @@</span> <span class="p_context"> static int identify_insn(struct insn *insn)</span>
 		default:
 			return -EINVAL;
 		}
<span class="p_add">+	} else if (insn-&gt;opcode.bytes[1] == 0x0) {</span>
<span class="p_add">+		if (X86_MODRM_REG(insn-&gt;modrm.value) == 0)</span>
<span class="p_add">+			return UMIP_INST_SLDT;</span>
<span class="p_add">+		else if (X86_MODRM_REG(insn-&gt;modrm.value) == 1)</span>
<span class="p_add">+			return UMIP_INST_STR;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		return -EINVAL;</span>
 	}
<span class="p_del">-</span>
<span class="p_del">-	/* SLDT AND STR are not emulated */</span>
<span class="p_del">-	return -EINVAL;</span>
 }
 
 /**
<span class="p_chunk">@@ -228,10 +287,8 @@</span> <span class="p_context"> static void force_sig_info_umip_fault(void __user *addr, struct pt_regs *regs)</span>
 	if (!(show_unhandled_signals &amp;&amp; unhandled_signal(tsk, SIGSEGV)))
 		return;
 
<span class="p_del">-	pr_err_ratelimited(&quot;%s[%d] umip emulation segfault ip:%lx sp:%lx error:%x in %lx\n&quot;,</span>
<span class="p_del">-			   tsk-&gt;comm, task_pid_nr(tsk), regs-&gt;ip,</span>
<span class="p_del">-			   regs-&gt;sp, X86_PF_USER | X86_PF_WRITE,</span>
<span class="p_del">-			   regs-&gt;ip);</span>
<span class="p_add">+	umip_pr_err(regs, &quot;segfault in emulation. error%x\n&quot;,</span>
<span class="p_add">+		    X86_PF_USER | X86_PF_WRITE);</span>
 }
 
 /**
<span class="p_chunk">@@ -262,15 +319,11 @@</span> <span class="p_context"> bool fixup_umip_exception(struct pt_regs *regs)</span>
 	unsigned char buf[MAX_INSN_SIZE];
 	void __user *uaddr;
 	struct insn insn;
<span class="p_del">-	char seg_defs;</span>
<span class="p_add">+	int seg_defs;</span>
 
 	if (!regs)
 		return false;
 
<span class="p_del">-	/* Do not emulate 64-bit processes. */</span>
<span class="p_del">-	if (user_64bit_mode(regs))</span>
<span class="p_del">-		return false;</span>
<span class="p_del">-</span>
 	/*
 	 * If not in user-space long mode, a custom code segment could be in
 	 * use. This is true in protected mode (if the process defined a local
<span class="p_chunk">@@ -322,6 +375,15 @@</span> <span class="p_context"> bool fixup_umip_exception(struct pt_regs *regs)</span>
 	if (umip_inst &lt; 0)
 		return false;
 
<span class="p_add">+	umip_pr_warning(regs, &quot;%s instruction cannot be used by applications.\n&quot;,</span>
<span class="p_add">+			umip_insns[umip_inst]);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Do not emulate SLDT, STR or user long mode processes. */</span>
<span class="p_add">+	if (umip_inst == UMIP_INST_STR || umip_inst == UMIP_INST_SLDT || user_64bit_mode(regs))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	umip_pr_warning(regs, &quot;For now, expensive software emulation returns the result.\n&quot;);</span>
<span class="p_add">+</span>
 	if (emulate_umip_insn(&amp;insn, umip_inst, dummy_data, &amp;dummy_data_size))
 		return false;
 
<span class="p_header">diff --git a/arch/x86/lib/insn-eval.c b/arch/x86/lib/insn-eval.c</span>
<span class="p_header">index 35625d279458..9119d8e41f1f 100644</span>
<span class="p_header">--- a/arch/x86/lib/insn-eval.c</span>
<span class="p_header">+++ b/arch/x86/lib/insn-eval.c</span>
<span class="p_chunk">@@ -733,11 +733,11 @@</span> <span class="p_context"> static unsigned long get_seg_limit(struct pt_regs *regs, int seg_reg_idx)</span>
  *
  * Returns:
  *
<span class="p_del">- * A signed 8-bit value containing the default parameters on success.</span>
<span class="p_add">+ * An int containing ORed-in default parameters on success.</span>
  *
  * -EINVAL on error.
  */
<span class="p_del">-char insn_get_code_seg_params(struct pt_regs *regs)</span>
<span class="p_add">+int insn_get_code_seg_params(struct pt_regs *regs)</span>
 {
 	struct desc_struct *desc;
 	short sel;
<span class="p_header">diff --git a/arch/x86/lib/x86-opcode-map.txt b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">index 12e377184ee4..c4d55919fac1 100644</span>
<span class="p_header">--- a/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_header">+++ b/arch/x86/lib/x86-opcode-map.txt</span>
<span class="p_chunk">@@ -896,7 +896,7 @@</span> <span class="p_context"> EndTable</span>
 
 GrpTable: Grp3_1
 0: TEST Eb,Ib
<span class="p_del">-1:</span>
<span class="p_add">+1: TEST Eb,Ib</span>
 2: NOT Eb
 3: NEG Eb
 4: MUL AL,Eb
<span class="p_header">diff --git a/arch/x86/mm/hugetlbpage.c b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">index 8ae0000cbdb3..00b296617ca4 100644</span>
<span class="p_header">--- a/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -158,6 +158,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 	if (len &gt; TASK_SIZE)
 		return -ENOMEM;
 
<span class="p_add">+	/* No address checking. See comment at mmap_address_hint_valid() */</span>
 	if (flags &amp; MAP_FIXED) {
 		if (prepare_hugepage_range(file, addr, len))
 			return -EINVAL;
<span class="p_chunk">@@ -165,12 +166,16 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
 	}
 
 	if (addr) {
<span class="p_del">-		addr = ALIGN(addr, huge_page_size(h));</span>
<span class="p_add">+		addr &amp;= huge_page_mask(h);</span>
<span class="p_add">+		if (!mmap_address_hint_valid(addr, len))</span>
<span class="p_add">+			goto get_unmapped_area;</span>
<span class="p_add">+</span>
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp;</span>
<span class="p_del">-		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="p_add">+		if (!vma || addr + len &lt;= vm_start_gap(vma))</span>
 			return addr;
 	}
<span class="p_add">+</span>
<span class="p_add">+get_unmapped_area:</span>
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
 		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
 				pgoff, flags);
<span class="p_header">diff --git a/arch/x86/mm/kasan_init_64.c b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">index 2b60dc6e64b1..99dfed6dfef8 100644</span>
<span class="p_header">--- a/arch/x86/mm/kasan_init_64.c</span>
<span class="p_header">+++ b/arch/x86/mm/kasan_init_64.c</span>
<span class="p_chunk">@@ -4,12 +4,14 @@</span> <span class="p_context"></span>
 #include &lt;linux/bootmem.h&gt;
 #include &lt;linux/kasan.h&gt;
 #include &lt;linux/kdebug.h&gt;
<span class="p_add">+#include &lt;linux/memblock.h&gt;</span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/sched.h&gt;
 #include &lt;linux/sched/task.h&gt;
 #include &lt;linux/vmalloc.h&gt;
 
 #include &lt;asm/e820/types.h&gt;
<span class="p_add">+#include &lt;asm/pgalloc.h&gt;</span>
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/sections.h&gt;
 #include &lt;asm/pgtable.h&gt;
<span class="p_chunk">@@ -18,7 +20,134 @@</span> <span class="p_context"> extern struct range pfn_mapped[E820_MAX_ENTRIES];</span>
 
 static p4d_t tmp_p4d_table[PTRS_PER_P4D] __initdata __aligned(PAGE_SIZE);
 
<span class="p_del">-static int __init map_range(struct range *range)</span>
<span class="p_add">+static __init void *early_alloc(size_t size, int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return memblock_virt_alloc_try_nid_nopanic(size, size,</span>
<span class="p_add">+		__pa(MAX_DMA_ADDRESS), BOOTMEM_ALLOC_ACCESSIBLE, nid);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init kasan_populate_pmd(pmd_t *pmd, unsigned long addr,</span>
<span class="p_add">+				      unsigned long end, int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pte_t *pte;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pmd_none(*pmd)) {</span>
<span class="p_add">+		void *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (boot_cpu_has(X86_FEATURE_PSE) &amp;&amp;</span>
<span class="p_add">+		    ((end - addr) == PMD_SIZE) &amp;&amp;</span>
<span class="p_add">+		    IS_ALIGNED(addr, PMD_SIZE)) {</span>
<span class="p_add">+			p = early_alloc(PMD_SIZE, nid);</span>
<span class="p_add">+			if (p &amp;&amp; pmd_set_huge(pmd, __pa(p), PAGE_KERNEL))</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			else if (p)</span>
<span class="p_add">+				memblock_free(__pa(p), PMD_SIZE);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		p = early_alloc(PAGE_SIZE, nid);</span>
<span class="p_add">+		pmd_populate_kernel(&amp;init_mm, pmd, p);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pte = pte_offset_kernel(pmd, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		pte_t entry;</span>
<span class="p_add">+		void *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!pte_none(*pte))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		p = early_alloc(PAGE_SIZE, nid);</span>
<span class="p_add">+		entry = pfn_pte(PFN_DOWN(__pa(p)), PAGE_KERNEL);</span>
<span class="p_add">+		set_pte_at(&amp;init_mm, addr, pte, entry);</span>
<span class="p_add">+	} while (pte++, addr += PAGE_SIZE, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init kasan_populate_pud(pud_t *pud, unsigned long addr,</span>
<span class="p_add">+				      unsigned long end, int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pmd_t *pmd;</span>
<span class="p_add">+	unsigned long next;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pud_none(*pud)) {</span>
<span class="p_add">+		void *p;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (boot_cpu_has(X86_FEATURE_GBPAGES) &amp;&amp;</span>
<span class="p_add">+		    ((end - addr) == PUD_SIZE) &amp;&amp;</span>
<span class="p_add">+		    IS_ALIGNED(addr, PUD_SIZE)) {</span>
<span class="p_add">+			p = early_alloc(PUD_SIZE, nid);</span>
<span class="p_add">+			if (p &amp;&amp; pud_set_huge(pud, __pa(p), PAGE_KERNEL))</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			else if (p)</span>
<span class="p_add">+				memblock_free(__pa(p), PUD_SIZE);</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		p = early_alloc(PAGE_SIZE, nid);</span>
<span class="p_add">+		pud_populate(&amp;init_mm, pud, p);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pmd = pmd_offset(pud, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = pmd_addr_end(addr, end);</span>
<span class="p_add">+		if (!pmd_large(*pmd))</span>
<span class="p_add">+			kasan_populate_pmd(pmd, addr, next, nid);</span>
<span class="p_add">+	} while (pmd++, addr = next, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init kasan_populate_p4d(p4d_t *p4d, unsigned long addr,</span>
<span class="p_add">+				      unsigned long end, int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pud_t *pud;</span>
<span class="p_add">+	unsigned long next;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (p4d_none(*p4d)) {</span>
<span class="p_add">+		void *p = early_alloc(PAGE_SIZE, nid);</span>
<span class="p_add">+</span>
<span class="p_add">+		p4d_populate(&amp;init_mm, p4d, p);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	pud = pud_offset(p4d, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = pud_addr_end(addr, end);</span>
<span class="p_add">+		if (!pud_large(*pud))</span>
<span class="p_add">+			kasan_populate_pud(pud, addr, next, nid);</span>
<span class="p_add">+	} while (pud++, addr = next, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init kasan_populate_pgd(pgd_t *pgd, unsigned long addr,</span>
<span class="p_add">+				      unsigned long end, int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	void *p;</span>
<span class="p_add">+	p4d_t *p4d;</span>
<span class="p_add">+	unsigned long next;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pgd_none(*pgd)) {</span>
<span class="p_add">+		p = early_alloc(PAGE_SIZE, nid);</span>
<span class="p_add">+		pgd_populate(&amp;init_mm, pgd, p);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	p4d = p4d_offset(pgd, addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = p4d_addr_end(addr, end);</span>
<span class="p_add">+		kasan_populate_p4d(p4d, addr, next, nid);</span>
<span class="p_add">+	} while (p4d++, addr = next, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init kasan_populate_shadow(unsigned long addr, unsigned long end,</span>
<span class="p_add">+					 int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	pgd_t *pgd;</span>
<span class="p_add">+	unsigned long next;</span>
<span class="p_add">+</span>
<span class="p_add">+	addr = addr &amp; PAGE_MASK;</span>
<span class="p_add">+	end = round_up(end, PAGE_SIZE);</span>
<span class="p_add">+	pgd = pgd_offset_k(addr);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		next = pgd_addr_end(addr, end);</span>
<span class="p_add">+		kasan_populate_pgd(pgd, addr, next, nid);</span>
<span class="p_add">+	} while (pgd++, addr = next, addr != end);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void __init map_range(struct range *range)</span>
 {
 	unsigned long start;
 	unsigned long end;
<span class="p_chunk">@@ -26,7 +155,7 @@</span> <span class="p_context"> static int __init map_range(struct range *range)</span>
 	start = (unsigned long)kasan_mem_to_shadow(pfn_to_kaddr(range-&gt;start));
 	end = (unsigned long)kasan_mem_to_shadow(pfn_to_kaddr(range-&gt;end));
 
<span class="p_del">-	return vmemmap_populate(start, end, NUMA_NO_NODE);</span>
<span class="p_add">+	kasan_populate_shadow(start, end, early_pfn_to_nid(range-&gt;start));</span>
 }
 
 static void __init clear_pgds(unsigned long start,
<span class="p_chunk">@@ -189,16 +318,16 @@</span> <span class="p_context"> void __init kasan_init(void)</span>
 		if (pfn_mapped[i].end == 0)
 			break;
 
<span class="p_del">-		if (map_range(&amp;pfn_mapped[i]))</span>
<span class="p_del">-			panic(&quot;kasan: unable to allocate shadow!&quot;);</span>
<span class="p_add">+		map_range(&amp;pfn_mapped[i]);</span>
 	}
<span class="p_add">+</span>
 	kasan_populate_zero_shadow(
 		kasan_mem_to_shadow((void *)PAGE_OFFSET + MAXMEM),
 		kasan_mem_to_shadow((void *)__START_KERNEL_map));
 
<span class="p_del">-	vmemmap_populate((unsigned long)kasan_mem_to_shadow(_stext),</span>
<span class="p_del">-			(unsigned long)kasan_mem_to_shadow(_end),</span>
<span class="p_del">-			NUMA_NO_NODE);</span>
<span class="p_add">+	kasan_populate_shadow((unsigned long)kasan_mem_to_shadow(_stext),</span>
<span class="p_add">+			      (unsigned long)kasan_mem_to_shadow(_end),</span>
<span class="p_add">+			      early_pfn_to_nid(__pa(_stext)));</span>
 
 	kasan_populate_zero_shadow(kasan_mem_to_shadow((void *)MODULES_END),
 			(void *)KASAN_SHADOW_END);
<span class="p_header">diff --git a/arch/x86/mm/mmap.c b/arch/x86/mm/mmap.c</span>
<span class="p_header">index a99679826846..155ecbac9e28 100644</span>
<span class="p_header">--- a/arch/x86/mm/mmap.c</span>
<span class="p_header">+++ b/arch/x86/mm/mmap.c</span>
<span class="p_chunk">@@ -33,6 +33,8 @@</span> <span class="p_context"></span>
 #include &lt;linux/compat.h&gt;
 #include &lt;asm/elf.h&gt;
 
<span class="p_add">+#include &quot;physaddr.h&quot;</span>
<span class="p_add">+</span>
 struct va_alignment __read_mostly va_align = {
 	.flags = -1,
 };
<span class="p_chunk">@@ -174,3 +176,63 @@</span> <span class="p_context"> const char *arch_vma_name(struct vm_area_struct *vma)</span>
 		return &quot;[mpx]&quot;;
 	return NULL;
 }
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * mmap_address_hint_valid - Validate the address hint of mmap</span>
<span class="p_add">+ * @addr:	Address hint</span>
<span class="p_add">+ * @len:	Mapping length</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Check whether @addr and @addr + @len result in a valid mapping.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * On 32bit this only checks whether @addr + @len is &lt;= TASK_SIZE.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * On 64bit with 5-level page tables another sanity check is required</span>
<span class="p_add">+ * because mappings requested by mmap(@addr, 0) which cross the 47-bit</span>
<span class="p_add">+ * virtual address boundary can cause the following theoretical issue:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  An application calls mmap(addr, 0), i.e. without MAP_FIXED, where @addr</span>
<span class="p_add">+ *  is below the border of the 47-bit address space and @addr + @len is</span>
<span class="p_add">+ *  above the border.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  With 4-level paging this request succeeds, but the resulting mapping</span>
<span class="p_add">+ *  address will always be within the 47-bit virtual address space, because</span>
<span class="p_add">+ *  the hint address does not result in a valid mapping and is</span>
<span class="p_add">+ *  ignored. Hence applications which are not prepared to handle virtual</span>
<span class="p_add">+ *  addresses above 47-bit work correctly.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  With 5-level paging this request would be granted and result in a</span>
<span class="p_add">+ *  mapping which crosses the border of the 47-bit virtual address</span>
<span class="p_add">+ *  space. If the application cannot handle addresses above 47-bit this</span>
<span class="p_add">+ *  will lead to misbehaviour and hard to diagnose failures.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Therefore ignore address hints which would result in a mapping crossing</span>
<span class="p_add">+ * the 47-bit virtual address boundary.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note, that in the same scenario with MAP_FIXED the behaviour is</span>
<span class="p_add">+ * different. The request with @addr &lt; 47-bit and @addr + @len &gt; 47-bit</span>
<span class="p_add">+ * fails on a 4-level paging machine but succeeds on a 5-level paging</span>
<span class="p_add">+ * machine. It is reasonable to expect that an application does not rely on</span>
<span class="p_add">+ * the failure of such a fixed mapping request, so the restriction is not</span>
<span class="p_add">+ * applied.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool mmap_address_hint_valid(unsigned long addr, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (TASK_SIZE - len &lt; addr)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	return (addr &gt; DEFAULT_MAP_WINDOW) == (addr + len &gt; DEFAULT_MAP_WINDOW);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Can we access it for direct reading/writing? Must be RAM: */</span>
<span class="p_add">+int valid_phys_addr_range(phys_addr_t addr, size_t count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return addr + count &lt;= __pa(high_memory);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Can we access it through mmap? Must be a valid physical address: */</span>
<span class="p_add">+int valid_mmap_phys_addr_range(unsigned long pfn, size_t count)</span>
<span class="p_add">+{</span>
<span class="p_add">+	phys_addr_t addr = (phys_addr_t)pfn &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	return phys_addr_valid(addr + count - 1);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/char/mem.c b/drivers/char/mem.c</span>
<span class="p_header">index 970e1242a282..6aefe5370e5b 100644</span>
<span class="p_header">--- a/drivers/char/mem.c</span>
<span class="p_header">+++ b/drivers/char/mem.c</span>
<span class="p_chunk">@@ -343,6 +343,10 @@</span> <span class="p_context"> static int mmap_mem(struct file *file, struct vm_area_struct *vma)</span>
 	size_t size = vma-&gt;vm_end - vma-&gt;vm_start;
 	phys_addr_t offset = (phys_addr_t)vma-&gt;vm_pgoff &lt;&lt; PAGE_SHIFT;
 
<span class="p_add">+	/* Does it even fit in phys_addr_t? */</span>
<span class="p_add">+	if (offset &gt;&gt; PAGE_SHIFT != vma-&gt;vm_pgoff)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/* It&#39;s illegal to wrap around the end of the physical address space. */
 	if (offset + (phys_addr_t)size - 1 &lt; offset)
 		return -EINVAL;
<span class="p_header">diff --git a/drivers/pci/Kconfig b/drivers/pci/Kconfig</span>
<span class="p_header">index c32a77fc8b03..99ae5e30eabe 100644</span>
<span class="p_header">--- a/drivers/pci/Kconfig</span>
<span class="p_header">+++ b/drivers/pci/Kconfig</span>
<span class="p_chunk">@@ -71,15 +71,6 @@</span> <span class="p_context"> config XEN_PCIDEV_FRONTEND</span>
           The PCI device frontend driver allows the kernel to import arbitrary
           PCI devices from a PCI backend to support PCI driver domains.
 
<span class="p_del">-config HT_IRQ</span>
<span class="p_del">-	bool &quot;Interrupts on hypertransport devices&quot;</span>
<span class="p_del">-	default y</span>
<span class="p_del">-	depends on PCI &amp;&amp; X86_LOCAL_APIC</span>
<span class="p_del">-	help</span>
<span class="p_del">-	   This allows native hypertransport devices to use interrupts.</span>
<span class="p_del">-</span>
<span class="p_del">-	   If unsure say Y.</span>
<span class="p_del">-</span>
 config PCI_ATS
 	bool
 
<span class="p_header">diff --git a/drivers/pci/Makefile b/drivers/pci/Makefile</span>
<span class="p_header">index 80adbdbcecce..ab0104e0ffac 100644</span>
<span class="p_header">--- a/drivers/pci/Makefile</span>
<span class="p_header">+++ b/drivers/pci/Makefile</span>
<span class="p_chunk">@@ -24,9 +24,6 @@</span> <span class="p_context"> endif</span>
 # Build the PCI MSI interrupt support
 obj-$(CONFIG_PCI_MSI) += msi.o
 
<span class="p_del">-# Build the Hypertransport interrupt support</span>
<span class="p_del">-obj-$(CONFIG_HT_IRQ) += htirq.o</span>
<span class="p_del">-</span>
 obj-$(CONFIG_PCI_ATS) += ats.o
 obj-$(CONFIG_PCI_IOV) += iov.o
 
<span class="p_header">diff --git a/drivers/pci/htirq.c b/drivers/pci/htirq.c</span>
deleted file mode 100644
<span class="p_header">index bb88c26f5144..000000000000</span>
<span class="p_header">--- a/drivers/pci/htirq.c</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,135 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-// SPDX-License-Identifier: GPL-2.0</span>
<span class="p_del">-/*</span>
<span class="p_del">- * File:	htirq.c</span>
<span class="p_del">- * Purpose:	Hypertransport Interrupt Capability</span>
<span class="p_del">- *</span>
<span class="p_del">- * Copyright (C) 2006 Linux Networx</span>
<span class="p_del">- * Copyright (C) Eric Biederman &lt;ebiederman@lnxi.com&gt;</span>
<span class="p_del">- */</span>
<span class="p_del">-</span>
<span class="p_del">-#include &lt;linux/irq.h&gt;</span>
<span class="p_del">-#include &lt;linux/pci.h&gt;</span>
<span class="p_del">-#include &lt;linux/spinlock.h&gt;</span>
<span class="p_del">-#include &lt;linux/export.h&gt;</span>
<span class="p_del">-#include &lt;linux/slab.h&gt;</span>
<span class="p_del">-#include &lt;linux/htirq.h&gt;</span>
<span class="p_del">-</span>
<span class="p_del">-/* Global ht irq lock.</span>
<span class="p_del">- *</span>
<span class="p_del">- * This is needed to serialize access to the data port in hypertransport</span>
<span class="p_del">- * irq capability.</span>
<span class="p_del">- *</span>
<span class="p_del">- * With multiple simultaneous hypertransport irq devices it might pay</span>
<span class="p_del">- * to make this more fine grained.  But start with simple, stupid, and correct.</span>
<span class="p_del">- */</span>
<span class="p_del">-static DEFINE_SPINLOCK(ht_irq_lock);</span>
<span class="p_del">-</span>
<span class="p_del">-void write_ht_irq_msg(unsigned int irq, struct ht_irq_msg *msg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ht_irq_cfg *cfg = irq_get_handler_data(irq);</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-</span>
<span class="p_del">-	spin_lock_irqsave(&amp;ht_irq_lock, flags);</span>
<span class="p_del">-	if (cfg-&gt;msg.address_lo != msg-&gt;address_lo) {</span>
<span class="p_del">-		pci_write_config_byte(cfg-&gt;dev, cfg-&gt;pos + 2, cfg-&gt;idx);</span>
<span class="p_del">-		pci_write_config_dword(cfg-&gt;dev, cfg-&gt;pos + 4, msg-&gt;address_lo);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (cfg-&gt;msg.address_hi != msg-&gt;address_hi) {</span>
<span class="p_del">-		pci_write_config_byte(cfg-&gt;dev, cfg-&gt;pos + 2, cfg-&gt;idx + 1);</span>
<span class="p_del">-		pci_write_config_dword(cfg-&gt;dev, cfg-&gt;pos + 4, msg-&gt;address_hi);</span>
<span class="p_del">-	}</span>
<span class="p_del">-	if (cfg-&gt;update)</span>
<span class="p_del">-		cfg-&gt;update(cfg-&gt;dev, irq, msg);</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;ht_irq_lock, flags);</span>
<span class="p_del">-	cfg-&gt;msg = *msg;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void fetch_ht_irq_msg(unsigned int irq, struct ht_irq_msg *msg)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ht_irq_cfg *cfg = irq_get_handler_data(irq);</span>
<span class="p_del">-</span>
<span class="p_del">-	*msg = cfg-&gt;msg;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void mask_ht_irq(struct irq_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ht_irq_cfg *cfg = irq_data_get_irq_handler_data(data);</span>
<span class="p_del">-	struct ht_irq_msg msg = cfg-&gt;msg;</span>
<span class="p_del">-</span>
<span class="p_del">-	msg.address_lo |= 1;</span>
<span class="p_del">-	write_ht_irq_msg(data-&gt;irq, &amp;msg);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-void unmask_ht_irq(struct irq_data *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct ht_irq_cfg *cfg = irq_data_get_irq_handler_data(data);</span>
<span class="p_del">-	struct ht_irq_msg msg = cfg-&gt;msg;</span>
<span class="p_del">-</span>
<span class="p_del">-	msg.address_lo &amp;= ~1;</span>
<span class="p_del">-	write_ht_irq_msg(data-&gt;irq, &amp;msg);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * __ht_create_irq - create an irq and attach it to a device.</span>
<span class="p_del">- * @dev: The hypertransport device to find the irq capability on.</span>
<span class="p_del">- * @idx: Which of the possible irqs to attach to.</span>
<span class="p_del">- * @update: Function to be called when changing the htirq message</span>
<span class="p_del">- *</span>
<span class="p_del">- * The irq number of the new irq or a negative error value is returned.</span>
<span class="p_del">- */</span>
<span class="p_del">-int __ht_create_irq(struct pci_dev *dev, int idx, ht_irq_update_t *update)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int max_irq, pos, irq;</span>
<span class="p_del">-	unsigned long flags;</span>
<span class="p_del">-	u32 data;</span>
<span class="p_del">-</span>
<span class="p_del">-	pos = pci_find_ht_capability(dev, HT_CAPTYPE_IRQ);</span>
<span class="p_del">-	if (!pos)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Verify the idx I want to use is in range */</span>
<span class="p_del">-	spin_lock_irqsave(&amp;ht_irq_lock, flags);</span>
<span class="p_del">-	pci_write_config_byte(dev, pos + 2, 1);</span>
<span class="p_del">-	pci_read_config_dword(dev, pos + 4, &amp;data);</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;ht_irq_lock, flags);</span>
<span class="p_del">-</span>
<span class="p_del">-	max_irq = (data &gt;&gt; 16) &amp; 0xff;</span>
<span class="p_del">-	if (idx &gt; max_irq)</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
<span class="p_del">-	irq = arch_setup_ht_irq(idx, pos, dev, update);</span>
<span class="p_del">-	if (irq &gt; 0)</span>
<span class="p_del">-		dev_dbg(&amp;dev-&gt;dev, &quot;irq %d for HT\n&quot;, irq);</span>
<span class="p_del">-</span>
<span class="p_del">-	return irq;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(__ht_create_irq);</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * ht_create_irq - create an irq and attach it to a device.</span>
<span class="p_del">- * @dev: The hypertransport device to find the irq capability on.</span>
<span class="p_del">- * @idx: Which of the possible irqs to attach to.</span>
<span class="p_del">- *</span>
<span class="p_del">- * ht_create_irq needs to be called for all hypertransport devices</span>
<span class="p_del">- * that generate irqs.</span>
<span class="p_del">- *</span>
<span class="p_del">- * The irq number of the new irq or a negative error value is returned.</span>
<span class="p_del">- */</span>
<span class="p_del">-int ht_create_irq(struct pci_dev *dev, int idx)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return __ht_create_irq(dev, idx, NULL);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(ht_create_irq);</span>
<span class="p_del">-</span>
<span class="p_del">-/**</span>
<span class="p_del">- * ht_destroy_irq - destroy an irq created with ht_create_irq</span>
<span class="p_del">- * @irq: irq to be destroyed</span>
<span class="p_del">- *</span>
<span class="p_del">- * This reverses ht_create_irq removing the specified irq from</span>
<span class="p_del">- * existence.  The irq should be free before this happens.</span>
<span class="p_del">- */</span>
<span class="p_del">-void ht_destroy_irq(unsigned int irq)</span>
<span class="p_del">-{</span>
<span class="p_del">-	arch_teardown_ht_irq(irq);</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(ht_destroy_irq);</span>
<span class="p_header">diff --git a/include/linux/htirq.h b/include/linux/htirq.h</span>
deleted file mode 100644
<span class="p_header">index 127c39d815ba..000000000000</span>
<span class="p_header">--- a/include/linux/htirq.h</span>
<span class="p_header">+++ /dev/null</span>
<span class="p_chunk">@@ -1,39 +0,0 @@</span> <span class="p_context"></span>
<span class="p_del">-/* SPDX-License-Identifier: GPL-2.0 */</span>
<span class="p_del">-#ifndef LINUX_HTIRQ_H</span>
<span class="p_del">-#define LINUX_HTIRQ_H</span>
<span class="p_del">-</span>
<span class="p_del">-struct pci_dev;</span>
<span class="p_del">-struct irq_data;</span>
<span class="p_del">-</span>
<span class="p_del">-struct ht_irq_msg {</span>
<span class="p_del">-	u32	address_lo;	/* low 32 bits of the ht irq message */</span>
<span class="p_del">-	u32	address_hi;	/* high 32 bits of the it irq message */</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-typedef void (ht_irq_update_t)(struct pci_dev *dev, int irq,</span>
<span class="p_del">-			       struct ht_irq_msg *msg);</span>
<span class="p_del">-</span>
<span class="p_del">-struct ht_irq_cfg {</span>
<span class="p_del">-	struct pci_dev *dev;</span>
<span class="p_del">-	 /* Update callback used to cope with buggy hardware */</span>
<span class="p_del">-	ht_irq_update_t *update;</span>
<span class="p_del">-	unsigned pos;</span>
<span class="p_del">-	unsigned idx;</span>
<span class="p_del">-	struct ht_irq_msg msg;</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
<span class="p_del">-/* Helper functions.. */</span>
<span class="p_del">-void fetch_ht_irq_msg(unsigned int irq, struct ht_irq_msg *msg);</span>
<span class="p_del">-void write_ht_irq_msg(unsigned int irq, struct ht_irq_msg *msg);</span>
<span class="p_del">-void mask_ht_irq(struct irq_data *data);</span>
<span class="p_del">-void unmask_ht_irq(struct irq_data *data);</span>
<span class="p_del">-</span>
<span class="p_del">-/* The arch hook for getting things started */</span>
<span class="p_del">-int arch_setup_ht_irq(int idx, int pos, struct pci_dev *dev,</span>
<span class="p_del">-		      ht_irq_update_t *update);</span>
<span class="p_del">-void arch_teardown_ht_irq(unsigned int irq);</span>
<span class="p_del">-</span>
<span class="p_del">-/* For drivers of buggy hardware */</span>
<span class="p_del">-int __ht_create_irq(struct pci_dev *dev, int idx, ht_irq_update_t *update);</span>
<span class="p_del">-</span>
<span class="p_del">-#endif /* LINUX_HTIRQ_H */</span>
<span class="p_header">diff --git a/include/linux/pci.h b/include/linux/pci.h</span>
<span class="p_header">index d16a7c037ec0..16287684dfe8 100644</span>
<span class="p_header">--- a/include/linux/pci.h</span>
<span class="p_header">+++ b/include/linux/pci.h</span>
<span class="p_chunk">@@ -1484,12 +1484,6 @@</span> <span class="p_context"> static inline void pcie_set_ecrc_checking(struct pci_dev *dev) { }</span>
 static inline void pcie_ecrc_get_policy(char *str) { }
 #endif
 
<span class="p_del">-#ifdef CONFIG_HT_IRQ</span>
<span class="p_del">-/* The functions a driver should call */</span>
<span class="p_del">-int  ht_create_irq(struct pci_dev *dev, int idx);</span>
<span class="p_del">-void ht_destroy_irq(unsigned int irq);</span>
<span class="p_del">-#endif /* CONFIG_HT_IRQ */</span>
<span class="p_del">-</span>
 #ifdef CONFIG_PCI_ATS
 /* Address Translation Service */
 void pci_ats_init(struct pci_dev *dev);
<span class="p_header">diff --git a/tools/testing/selftests/x86/5lvl.c b/tools/testing/selftests/x86/5lvl.c</span>
new file mode 100644
<span class="p_header">index 000000000000..2eafdcd4c2b3</span>
<span class="p_header">--- /dev/null</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/5lvl.c</span>
<span class="p_chunk">@@ -0,0 +1,177 @@</span> <span class="p_context"></span>
<span class="p_add">+#include &lt;stdio.h&gt;</span>
<span class="p_add">+#include &lt;sys/mman.h&gt;</span>
<span class="p_add">+</span>
<span class="p_add">+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))</span>
<span class="p_add">+</span>
<span class="p_add">+#define PAGE_SIZE	4096</span>
<span class="p_add">+#define LOW_ADDR	((void *) (1UL &lt;&lt; 30))</span>
<span class="p_add">+#define HIGH_ADDR	((void *) (1UL &lt;&lt; 50))</span>
<span class="p_add">+</span>
<span class="p_add">+struct testcase {</span>
<span class="p_add">+	void *addr;</span>
<span class="p_add">+	unsigned long size;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+	const char *msg;</span>
<span class="p_add">+	unsigned int low_addr_required:1;</span>
<span class="p_add">+	unsigned int keep_mapped:1;</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+static struct testcase testcases[] = {</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = NULL,</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(NULL)&quot;,</span>
<span class="p_add">+		.low_addr_required = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = LOW_ADDR,</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(LOW_ADDR)&quot;,</span>
<span class="p_add">+		.low_addr_required = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = HIGH_ADDR,</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(HIGH_ADDR)&quot;,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = HIGH_ADDR,</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(HIGH_ADDR) again&quot;,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = HIGH_ADDR,</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span>
<span class="p_add">+		.msg = &quot;mmap(HIGH_ADDR, MAP_FIXED)&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void*) -1,</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(-1)&quot;,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void*) -1,</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(-1) again&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void *)((1UL &lt;&lt; 47) - PAGE_SIZE),</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap((1UL &lt;&lt; 47), 2 * PAGE_SIZE)&quot;,</span>
<span class="p_add">+		.low_addr_required = 1,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void *)((1UL &lt;&lt; 47) - PAGE_SIZE / 2),</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap((1UL &lt;&lt; 47), 2 * PAGE_SIZE / 2)&quot;,</span>
<span class="p_add">+		.low_addr_required = 1,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void *)((1UL &lt;&lt; 47) - PAGE_SIZE),</span>
<span class="p_add">+		.size = 2 * PAGE_SIZE,</span>
<span class="p_add">+		.flags = MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span>
<span class="p_add">+		.msg = &quot;mmap((1UL &lt;&lt; 47) - PAGE_SIZE, 2 * PAGE_SIZE, MAP_FIXED)&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = NULL,</span>
<span class="p_add">+		.size = 2UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(NULL, MAP_HUGETLB)&quot;,</span>
<span class="p_add">+		.low_addr_required = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = LOW_ADDR,</span>
<span class="p_add">+		.size = 2UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(LOW_ADDR, MAP_HUGETLB)&quot;,</span>
<span class="p_add">+		.low_addr_required = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = HIGH_ADDR,</span>
<span class="p_add">+		.size = 2UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(HIGH_ADDR, MAP_HUGETLB)&quot;,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = HIGH_ADDR,</span>
<span class="p_add">+		.size = 2UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(HIGH_ADDR, MAP_HUGETLB) again&quot;,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = HIGH_ADDR,</span>
<span class="p_add">+		.size = 2UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span>
<span class="p_add">+		.msg = &quot;mmap(HIGH_ADDR, MAP_FIXED | MAP_HUGETLB)&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void*) -1,</span>
<span class="p_add">+		.size = 2UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(-1, MAP_HUGETLB)&quot;,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void*) -1,</span>
<span class="p_add">+		.size = 2UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap(-1, MAP_HUGETLB) again&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void *)((1UL &lt;&lt; 47) - PAGE_SIZE),</span>
<span class="p_add">+		.size = 4UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS,</span>
<span class="p_add">+		.msg = &quot;mmap((1UL &lt;&lt; 47), 4UL &lt;&lt; 20, MAP_HUGETLB)&quot;,</span>
<span class="p_add">+		.low_addr_required = 1,</span>
<span class="p_add">+		.keep_mapped = 1,</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
<span class="p_add">+		.addr = (void *)((1UL &lt;&lt; 47) - (2UL &lt;&lt; 20)),</span>
<span class="p_add">+		.size = 4UL &lt;&lt; 20,</span>
<span class="p_add">+		.flags = MAP_HUGETLB | MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED,</span>
<span class="p_add">+		.msg = &quot;mmap((1UL &lt;&lt; 47) - (2UL &lt;&lt; 20), 4UL &lt;&lt; 20, MAP_FIXED | MAP_HUGETLB)&quot;,</span>
<span class="p_add">+	},</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
<span class="p_add">+int main(int argc, char **argv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int i;</span>
<span class="p_add">+	void *p;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; ARRAY_SIZE(testcases); i++) {</span>
<span class="p_add">+		struct testcase *t = testcases + i;</span>
<span class="p_add">+</span>
<span class="p_add">+		p = mmap(t-&gt;addr, t-&gt;size, PROT_NONE, t-&gt;flags, -1, 0);</span>
<span class="p_add">+</span>
<span class="p_add">+		printf(&quot;%s: %p - &quot;, t-&gt;msg, p);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (p == MAP_FAILED) {</span>
<span class="p_add">+			printf(&quot;FAILED\n&quot;);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		if (t-&gt;low_addr_required &amp;&amp; p &gt;= (void *)(1UL &lt;&lt; 47))</span>
<span class="p_add">+			printf(&quot;FAILED\n&quot;);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			printf(&quot;OK\n&quot;);</span>
<span class="p_add">+		if (!t-&gt;keep_mapped)</span>
<span class="p_add">+			munmap(p, t-&gt;size);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/tools/testing/selftests/x86/Makefile b/tools/testing/selftests/x86/Makefile</span>
<span class="p_header">index 7b1adeee4b0f..939a337128db 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/Makefile</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/Makefile</span>
<span class="p_chunk">@@ -11,7 +11,7 @@</span> <span class="p_context"> TARGETS_C_BOTHBITS := single_step_syscall sysret_ss_attrs syscall_nt ptrace_sysc</span>
 TARGETS_C_32BIT_ONLY := entry_from_vm86 syscall_arg_fault test_syscall_vdso unwind_vdso \
 			test_FCMOV test_FCOMI test_FISTTP \
 			vdso_restorer
<span class="p_del">-TARGETS_C_64BIT_ONLY := fsgsbase sysret_rip</span>
<span class="p_add">+TARGETS_C_64BIT_ONLY := fsgsbase sysret_rip 5lvl</span>
 
 TARGETS_C_32BIT_ALL := $(TARGETS_C_BOTHBITS) $(TARGETS_C_32BIT_ONLY)
 TARGETS_C_64BIT_ALL := $(TARGETS_C_BOTHBITS) $(TARGETS_C_64BIT_ONLY)
<span class="p_header">diff --git a/tools/testing/selftests/x86/mpx-hw.h b/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_header">index 3f0093911f03..d1b61ab870f8 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/mpx-hw.h</span>
<span class="p_chunk">@@ -52,14 +52,14 @@</span> <span class="p_context"></span>
 struct mpx_bd_entry {
 	union {
 		char x[MPX_BOUNDS_DIR_ENTRY_SIZE_BYTES];
<span class="p_del">-		void *contents[1];</span>
<span class="p_add">+		void *contents[0];</span>
 	};
 } __attribute__((packed));
 
 struct mpx_bt_entry {
 	union {
 		char x[MPX_BOUNDS_TABLE_ENTRY_SIZE_BYTES];
<span class="p_del">-		unsigned long contents[1];</span>
<span class="p_add">+		unsigned long contents[0];</span>
 	};
 } __attribute__((packed));
 
<span class="p_header">diff --git a/tools/testing/selftests/x86/pkey-helpers.h b/tools/testing/selftests/x86/pkey-helpers.h</span>
<span class="p_header">index 3818f25391c2..b3cb7670e026 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/pkey-helpers.h</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/pkey-helpers.h</span>
<span class="p_chunk">@@ -30,6 +30,7 @@</span> <span class="p_context"> static inline void sigsafe_printf(const char *format, ...)</span>
 	if (!dprint_in_signal) {
 		vprintf(format, ap);
 	} else {
<span class="p_add">+		int ret;</span>
 		int len = vsnprintf(dprint_in_signal_buffer,
 				    DPRINT_IN_SIGNAL_BUF_SIZE,
 				    format, ap);
<span class="p_chunk">@@ -39,7 +40,9 @@</span> <span class="p_context"> static inline void sigsafe_printf(const char *format, ...)</span>
 		 */
 		if (len &gt; DPRINT_IN_SIGNAL_BUF_SIZE)
 			len = DPRINT_IN_SIGNAL_BUF_SIZE;
<span class="p_del">-		write(1, dprint_in_signal_buffer, len);</span>
<span class="p_add">+		ret = write(1, dprint_in_signal_buffer, len);</span>
<span class="p_add">+		if (ret &lt; 0)</span>
<span class="p_add">+			abort();</span>
 	}
 	va_end(ap);
 }
<span class="p_header">diff --git a/tools/testing/selftests/x86/protection_keys.c b/tools/testing/selftests/x86/protection_keys.c</span>
<span class="p_header">index 7a1cc0e56d2d..bc1b0735bb50 100644</span>
<span class="p_header">--- a/tools/testing/selftests/x86/protection_keys.c</span>
<span class="p_header">+++ b/tools/testing/selftests/x86/protection_keys.c</span>
<span class="p_chunk">@@ -250,7 +250,7 @@</span> <span class="p_context"> void signal_handler(int signum, siginfo_t *si, void *vucontext)</span>
 	unsigned long ip;
 	char *fpregs;
 	u32 *pkru_ptr;
<span class="p_del">-	u64 si_pkey;</span>
<span class="p_add">+	u64 siginfo_pkey;</span>
 	u32 *si_pkey_ptr;
 	int pkru_offset;
 	fpregset_t fpregset;
<span class="p_chunk">@@ -292,9 +292,9 @@</span> <span class="p_context"> void signal_handler(int signum, siginfo_t *si, void *vucontext)</span>
 	si_pkey_ptr = (u32 *)(((u8 *)si) + si_pkey_offset);
 	dprintf1(&quot;si_pkey_ptr: %p\n&quot;, si_pkey_ptr);
 	dump_mem(si_pkey_ptr - 8, 24);
<span class="p_del">-	si_pkey = *si_pkey_ptr;</span>
<span class="p_del">-	pkey_assert(si_pkey &lt; NR_PKEYS);</span>
<span class="p_del">-	last_si_pkey = si_pkey;</span>
<span class="p_add">+	siginfo_pkey = *si_pkey_ptr;</span>
<span class="p_add">+	pkey_assert(siginfo_pkey &lt; NR_PKEYS);</span>
<span class="p_add">+	last_si_pkey = siginfo_pkey;</span>
 
 	if ((si-&gt;si_code == SEGV_MAPERR) ||
 	    (si-&gt;si_code == SEGV_ACCERR) ||
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> void signal_handler(int signum, siginfo_t *si, void *vucontext)</span>
 	dprintf1(&quot;signal pkru from xsave: %08x\n&quot;, *pkru_ptr);
 	/* need __rdpkru() version so we do not do shadow_pkru checking */
 	dprintf1(&quot;signal pkru from  pkru: %08x\n&quot;, __rdpkru());
<span class="p_del">-	dprintf1(&quot;si_pkey from siginfo: %jx\n&quot;, si_pkey);</span>
<span class="p_add">+	dprintf1(&quot;pkey from siginfo: %jx\n&quot;, siginfo_pkey);</span>
 	*(u64 *)pkru_ptr = 0x00000000;
 	dprintf1(&quot;WARNING: set PRKU=0 to allow faulting instruction to continue\n&quot;);
 	pkru_faults++;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



