
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.7.3 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.7.3</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Sept. 7, 2016, 7:16 a.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20160907071653.GB32586@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9318325/mbox/"
   >mbox</a>
|
   <a href="/patch/9318325/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9318325/">/patch/9318325/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	8AE13601C0 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:17:25 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 69639290B3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:17:25 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 5D08E290B7; Wed,  7 Sep 2016 07:17:25 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 35543290B3
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Wed,  7 Sep 2016 07:17:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1756351AbcIGHRB (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Wed, 7 Sep 2016 03:17:01 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:46461 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1756268AbcIGHQt (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Wed, 7 Sep 2016 03:16:49 -0400
Received: from localhost (pes75-3-78-192-101-3.fbxo.proxad.net
	[78.192.101.3])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 90607951;
	Wed,  7 Sep 2016 07:16:46 +0000 (UTC)
Date: Wed, 7 Sep 2016 09:16:53 +0200
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.7.3
Message-ID: &lt;20160907071653.GB32586@kroah.com&gt;
References: &lt;20160907071647.GA32586@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20160907071647.GA32586@kroah.com&gt;
User-Agent: Mutt/1.7.0 (2016-08-17)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - Sept. 7, 2016, 7:16 a.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index bb98f1ce854e..4afff18fcb12 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 7
<span class="p_del">-SUBLEVEL = 2</span>
<span class="p_add">+SUBLEVEL = 3</span>
 EXTRAVERSION =
 NAME = Psychotic Stoned Sheep
 
<span class="p_header">diff --git a/arch/arc/include/asm/entry.h b/arch/arc/include/asm/entry.h</span>
<span class="p_header">index ad7860c5ce15..51597f344a62 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/entry.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/entry.h</span>
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"></span>
 
 #ifdef CONFIG_ARC_CURR_IN_REG
 	; Retrieve orig r25 and save it with rest of callee_regs
<span class="p_del">-	ld.as   r12, [r12, PT_user_r25]</span>
<span class="p_add">+	ld	r12, [r12, PT_user_r25]</span>
 	PUSH	r12
 #else
 	PUSH	r25
<span class="p_chunk">@@ -198,7 +198,7 @@</span> <span class="p_context"></span>
 
 	; SP is back to start of pt_regs
 #ifdef CONFIG_ARC_CURR_IN_REG
<span class="p_del">-	st.as   r12, [sp, PT_user_r25]</span>
<span class="p_add">+	st	r12, [sp, PT_user_r25]</span>
 #endif
 .endm
 
<span class="p_header">diff --git a/arch/arc/include/asm/irqflags-compact.h b/arch/arc/include/asm/irqflags-compact.h</span>
<span class="p_header">index c1d36458bfb7..4c6eed80cd8b 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/irqflags-compact.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/irqflags-compact.h</span>
<span class="p_chunk">@@ -188,10 +188,10 @@</span> <span class="p_context"> static inline int arch_irqs_disabled(void)</span>
 .endm
 
 .macro IRQ_ENABLE  scratch
<span class="p_add">+	TRACE_ASM_IRQ_ENABLE</span>
 	lr	\scratch, [status32]
 	or	\scratch, \scratch, (STATUS_E1_MASK | STATUS_E2_MASK)
 	flag	\scratch
<span class="p_del">-	TRACE_ASM_IRQ_ENABLE</span>
 .endm
 
 #endif	/* __ASSEMBLY__ */
<span class="p_header">diff --git a/arch/arc/include/asm/pgtable.h b/arch/arc/include/asm/pgtable.h</span>
<span class="p_header">index 0f92d97432a2..89eeb3720051 100644</span>
<span class="p_header">--- a/arch/arc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/arc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -280,7 +280,7 @@</span> <span class="p_context"> static inline void pmd_set(pmd_t *pmdp, pte_t *ptep)</span>
 
 #define pte_page(pte)		pfn_to_page(pte_pfn(pte))
 #define mk_pte(page, prot)	pfn_pte(page_to_pfn(page), prot)
<span class="p_del">-#define pfn_pte(pfn, prot)	(__pte(((pte_t)(pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot)))</span>
<span class="p_add">+#define pfn_pte(pfn, prot)	__pte(((pfn) &lt;&lt; PAGE_SHIFT) | pgprot_val(prot))</span>
 
 /* Don&#39;t use virt_to_pfn for macros below: could cause truncations for PAE40*/
 #define pte_pfn(pte)		(pte_val(pte) &gt;&gt; PAGE_SHIFT)
<span class="p_header">diff --git a/arch/arc/mm/cache.c b/arch/arc/mm/cache.c</span>
<span class="p_header">index 5a294b2c3cb3..0b10efe3a6a7 100644</span>
<span class="p_header">--- a/arch/arc/mm/cache.c</span>
<span class="p_header">+++ b/arch/arc/mm/cache.c</span>
<span class="p_chunk">@@ -921,6 +921,15 @@</span> <span class="p_context"> void arc_cache_init(void)</span>
 
 	printk(arc_cache_mumbojumbo(0, str, sizeof(str)));
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Only master CPU needs to execute rest of function:</span>
<span class="p_add">+	 *  - Assume SMP so all cores will have same cache config so</span>
<span class="p_add">+	 *    any geomtry checks will be same for all</span>
<span class="p_add">+	 *  - IOC setup / dma callbacks only need to be setup once</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpu)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	if (IS_ENABLED(CONFIG_ARC_HAS_ICACHE)) {
 		struct cpuinfo_arc_cache *ic = &amp;cpuinfo_arc700[cpu].icache;
 
<span class="p_header">diff --git a/arch/arm64/boot/dts/rockchip/rk3368.dtsi b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">index 080203e3aa2f..dc7f3bcc9fa2 100644</span>
<span class="p_header">--- a/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_header">+++ b/arch/arm64/boot/dts/rockchip/rk3368.dtsi</span>
<span class="p_chunk">@@ -270,6 +270,8 @@</span> <span class="p_context"></span>
 		#io-channel-cells = &lt;1&gt;;
 		clocks = &lt;&amp;cru SCLK_SARADC&gt;, &lt;&amp;cru PCLK_SARADC&gt;;
 		clock-names = &quot;saradc&quot;, &quot;apb_pclk&quot;;
<span class="p_add">+		resets = &lt;&amp;cru SRST_SARADC&gt;;</span>
<span class="p_add">+		reset-names = &quot;saradc-apb&quot;;</span>
 		status = &quot;disabled&quot;;
 	};
 
<span class="p_header">diff --git a/arch/arm64/include/asm/elf.h b/arch/arm64/include/asm/elf.h</span>
<span class="p_header">index 579b6e654f2d..a55384f4a5d7 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/elf.h</span>
<span class="p_chunk">@@ -140,6 +140,7 @@</span> <span class="p_context"> typedef struct user_fpsimd_state elf_fpregset_t;</span>
 
 #define SET_PERSONALITY(ex)		clear_thread_flag(TIF_32BIT);
 
<span class="p_add">+/* update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT entries changes */</span>
 #define ARCH_DLINFO							\
 do {									\
 	NEW_AUX_ENT(AT_SYSINFO_EHDR,					\
<span class="p_header">diff --git a/arch/arm64/include/uapi/asm/auxvec.h b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">index 22d6d8885854..4cf0c17787a8 100644</span>
<span class="p_header">--- a/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_header">+++ b/arch/arm64/include/uapi/asm/auxvec.h</span>
<span class="p_chunk">@@ -19,4 +19,6 @@</span> <span class="p_context"></span>
 /* vDSO location */
 #define AT_SYSINFO_EHDR	33
 
<span class="p_add">+#define AT_VECTOR_SIZE_ARCH 1 /* entries in ARCH_DLINFO */</span>
<span class="p_add">+</span>
 #endif
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index 2c6e598a94dc..aa68aadcdeea 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -757,6 +757,9 @@</span> <span class="p_context"> ENTRY(__enable_mmu)</span>
 	isb
 	bl	__create_page_tables		// recreate kernel mapping
 
<span class="p_add">+	tlbi	vmalle1				// Remove any stale TLB entries</span>
<span class="p_add">+	dsb	nsh</span>
<span class="p_add">+</span>
 	msr	sctlr_el1, x19			// re-enable the MMU
 	isb
 	ic	iallu				// flush instructions fetched
<span class="p_header">diff --git a/arch/arm64/kernel/sleep.S b/arch/arm64/kernel/sleep.S</span>
<span class="p_header">index 9a3aec97ac09..ccf79d849e0a 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/sleep.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/sleep.S</span>
<span class="p_chunk">@@ -101,12 +101,20 @@</span> <span class="p_context"> ENTRY(cpu_resume)</span>
 	bl	el2_setup		// if in EL2 drop to EL1 cleanly
 	/* enable the MMU early - so we can access sleep_save_stash by va */
 	adr_l	lr, __enable_mmu	/* __cpu_setup will return here */
<span class="p_del">-	ldr	x27, =_cpu_resume	/* __enable_mmu will branch here */</span>
<span class="p_add">+	adr_l	x27, _resume_switched	/* __enable_mmu will branch here */</span>
 	adrp	x25, idmap_pg_dir
 	adrp	x26, swapper_pg_dir
 	b	__cpu_setup
 ENDPROC(cpu_resume)
 
<span class="p_add">+	.pushsection	&quot;.idmap.text&quot;, &quot;ax&quot;</span>
<span class="p_add">+_resume_switched:</span>
<span class="p_add">+	ldr	x8, =_cpu_resume</span>
<span class="p_add">+	br	x8</span>
<span class="p_add">+ENDPROC(_resume_switched)</span>
<span class="p_add">+	.ltorg</span>
<span class="p_add">+	.popsection</span>
<span class="p_add">+</span>
 ENTRY(_cpu_resume)
 	mrs	x1, mpidr_el1
 	adrp	x8, mpidr_hash
<span class="p_header">diff --git a/arch/arm64/mm/proc.S b/arch/arm64/mm/proc.S</span>
<span class="p_header">index 5bb61de23201..9d37e967fa19 100644</span>
<span class="p_header">--- a/arch/arm64/mm/proc.S</span>
<span class="p_header">+++ b/arch/arm64/mm/proc.S</span>
<span class="p_chunk">@@ -100,7 +100,16 @@</span> <span class="p_context"> ENTRY(cpu_do_resume)</span>
 
 	msr	tcr_el1, x8
 	msr	vbar_el1, x9
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * __cpu_setup() cleared MDSCR_EL1.MDE and friends, before unmasking</span>
<span class="p_add">+	 * debug exceptions. By restoring MDSCR_EL1 here, we may take a debug</span>
<span class="p_add">+	 * exception. Mask them until local_dbg_restore() in cpu_suspend()</span>
<span class="p_add">+	 * resets them.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	disable_dbg</span>
 	msr	mdscr_el1, x10
<span class="p_add">+</span>
 	msr	sctlr_el1, x12
 	/*
 	 * Restore oslsr_el1 by writing oslar_el1
<span class="p_header">diff --git a/arch/parisc/include/uapi/asm/errno.h b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">index c0ae62520d15..274d5bc6ecce 100644</span>
<span class="p_header">--- a/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_header">+++ b/arch/parisc/include/uapi/asm/errno.h</span>
<span class="p_chunk">@@ -97,10 +97,10 @@</span> <span class="p_context"></span>
 #define	ENOTCONN	235	/* Transport endpoint is not connected */
 #define	ESHUTDOWN	236	/* Cannot send after transport endpoint shutdown */
 #define	ETOOMANYREFS	237	/* Too many references: cannot splice */
<span class="p_del">-#define EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
 #define	ETIMEDOUT	238	/* Connection timed out */
 #define	ECONNREFUSED	239	/* Connection refused */
<span class="p_del">-#define EREMOTERELEASE	240	/* Remote peer released connection */</span>
<span class="p_add">+#define	EREFUSED	ECONNREFUSED	/* for HP&#39;s NFS apparently */</span>
<span class="p_add">+#define	EREMOTERELEASE	240	/* Remote peer released connection */</span>
 #define	EHOSTDOWN	241	/* Host is down */
 #define	EHOSTUNREACH	242	/* No route to host */
 
<span class="p_header">diff --git a/arch/parisc/kernel/processor.c b/arch/parisc/kernel/processor.c</span>
<span class="p_header">index 5adc339eb7c8..0c2a94a0f751 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/processor.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/processor.c</span>
<span class="p_chunk">@@ -51,8 +51,6 @@</span> <span class="p_context"> EXPORT_SYMBOL(_parisc_requires_coherency);</span>
 
 DEFINE_PER_CPU(struct cpuinfo_parisc, cpu_data);
 
<span class="p_del">-extern int update_cr16_clocksource(void);	/* from time.c */</span>
<span class="p_del">-</span>
 /*
 **  	PARISC CPU driver - claim &quot;device&quot; and initialize CPU data structures.
 **
<span class="p_chunk">@@ -228,12 +226,6 @@</span> <span class="p_context"> static int processor_probe(struct parisc_device *dev)</span>
 	}
 #endif
 
<span class="p_del">-	/* If we&#39;ve registered more than one cpu,</span>
<span class="p_del">-	 * we&#39;ll use the jiffies clocksource since cr16</span>
<span class="p_del">-	 * is not synchronized between CPUs.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	update_cr16_clocksource();</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/arch/parisc/kernel/time.c b/arch/parisc/kernel/time.c</span>
<span class="p_header">index 31ec99a5f119..5eea7dc01ba5 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/time.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/time.c</span>
<span class="p_chunk">@@ -220,18 +220,6 @@</span> <span class="p_context"> static struct clocksource clocksource_cr16 = {</span>
 	.flags			= CLOCK_SOURCE_IS_CONTINUOUS,
 };
 
<span class="p_del">-int update_cr16_clocksource(void)</span>
<span class="p_del">-{</span>
<span class="p_del">-	/* since the cr16 cycle counters are not synchronized across CPUs,</span>
<span class="p_del">-	   we&#39;ll check if we should switch to a safe clocksource: */</span>
<span class="p_del">-	if (clocksource_cr16.rating != 0 &amp;&amp; num_online_cpus() &gt; 1) {</span>
<span class="p_del">-		clocksource_change_rating(&amp;clocksource_cr16, 0);</span>
<span class="p_del">-		return 1;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 void __init start_cpu_itimer(void)
 {
 	unsigned int cpu = smp_processor_id();
<span class="p_header">diff --git a/arch/um/include/asm/common.lds.S b/arch/um/include/asm/common.lds.S</span>
<span class="p_header">index 1dd5bd8a8c59..133055311dce 100644</span>
<span class="p_header">--- a/arch/um/include/asm/common.lds.S</span>
<span class="p_header">+++ b/arch/um/include/asm/common.lds.S</span>
<span class="p_chunk">@@ -81,7 +81,7 @@</span> <span class="p_context"></span>
   .altinstr_replacement : { *(.altinstr_replacement) }
   /* .exit.text is discard at runtime, not link time, to deal with references
      from .altinstructions and .eh_frame */
<span class="p_del">-  .exit.text : { *(.exit.text) }</span>
<span class="p_add">+  .exit.text : { EXIT_TEXT }</span>
   .exit.data : { *(.exit.data) }
 
   .preinit_array : {
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 4e5be94e079a..6fa85944af83 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -135,7 +135,14 @@</span> <span class="p_context"> static inline void cr4_set_bits_and_update_boot(unsigned long mask)</span>
 
 static inline void __native_flush_tlb(void)
 {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If current-&gt;mm == NULL then we borrow a mm which may change during a</span>
<span class="p_add">+	 * task switch and therefore we must not be preempted while we write CR3</span>
<span class="p_add">+	 * back:</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	preempt_disable();</span>
 	native_write_cr3(native_read_cr3());
<span class="p_add">+	preempt_enable();</span>
 }
 
 static inline void __native_flush_tlb_global_irq_disabled(void)
<span class="p_header">diff --git a/arch/x86/kernel/uprobes.c b/arch/x86/kernel/uprobes.c</span>
<span class="p_header">index 6c1ff31d99ff..495c776de4b4 100644</span>
<span class="p_header">--- a/arch/x86/kernel/uprobes.c</span>
<span class="p_header">+++ b/arch/x86/kernel/uprobes.c</span>
<span class="p_chunk">@@ -357,20 +357,22 @@</span> <span class="p_context"> static void riprel_analyze(struct arch_uprobe *auprobe, struct insn *insn)</span>
 		*cursor &amp;= 0xfe;
 	}
 	/*
<span class="p_del">-	 * Similar treatment for VEX3 prefix.</span>
<span class="p_del">-	 * TODO: add XOP/EVEX treatment when insn decoder supports them</span>
<span class="p_add">+	 * Similar treatment for VEX3/EVEX prefix.</span>
<span class="p_add">+	 * TODO: add XOP treatment when insn decoder supports them</span>
 	 */
<span class="p_del">-	if (insn-&gt;vex_prefix.nbytes == 3) {</span>
<span class="p_add">+	if (insn-&gt;vex_prefix.nbytes &gt;= 3) {</span>
 		/*
 		 * vex2:     c5    rvvvvLpp   (has no b bit)
 		 * vex3/xop: c4/8f rxbmmmmm wvvvvLpp
 		 * evex:     62    rxbR00mm wvvvv1pp zllBVaaa
<span class="p_del">-		 *   (evex will need setting of both b and x since</span>
<span class="p_del">-		 *   in non-sib encoding evex.x is 4th bit of MODRM.rm)</span>
<span class="p_del">-		 * Setting VEX3.b (setting because it has inverted meaning):</span>
<span class="p_add">+		 * Setting VEX3.b (setting because it has inverted meaning).</span>
<span class="p_add">+		 * Setting EVEX.x since (in non-SIB encoding) EVEX.x</span>
<span class="p_add">+		 * is the 4th bit of MODRM.rm, and needs the same treatment.</span>
<span class="p_add">+		 * For VEX3-encoded insns, VEX3.x value has no effect in</span>
<span class="p_add">+		 * non-SIB encoding, the change is superfluous but harmless.</span>
 		 */
 		cursor = auprobe-&gt;insn + insn_offset_vex_prefix(insn) + 1;
<span class="p_del">-		*cursor |= 0x20;</span>
<span class="p_add">+		*cursor |= 0x60;</span>
 	}
 
 	/*
<span class="p_chunk">@@ -415,12 +417,10 @@</span> <span class="p_context"> static void riprel_analyze(struct arch_uprobe *auprobe, struct insn *insn)</span>
 
 	reg = MODRM_REG(insn);	/* Fetch modrm.reg */
 	reg2 = 0xff;		/* Fetch vex.vvvv */
<span class="p_del">-	if (insn-&gt;vex_prefix.nbytes == 2)</span>
<span class="p_del">-		reg2 = insn-&gt;vex_prefix.bytes[1];</span>
<span class="p_del">-	else if (insn-&gt;vex_prefix.nbytes == 3)</span>
<span class="p_add">+	if (insn-&gt;vex_prefix.nbytes)</span>
 		reg2 = insn-&gt;vex_prefix.bytes[2];
 	/*
<span class="p_del">-	 * TODO: add XOP, EXEV vvvv reading.</span>
<span class="p_add">+	 * TODO: add XOP vvvv reading.</span>
 	 *
 	 * vex.vvvv field is in bits 6-3, bits are inverted.
 	 * But in 32-bit mode, high-order bit may be ignored.
<span class="p_header">diff --git a/arch/x86/platform/uv/bios_uv.c b/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_header">index 815fec6e05e2..17943a89d518 100644</span>
<span class="p_header">--- a/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_header">+++ b/arch/x86/platform/uv/bios_uv.c</span>
<span class="p_chunk">@@ -188,7 +188,8 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(uv_bios_set_legacy_vga_target);</span>
 void uv_bios_init(void)
 {
 	uv_systab = NULL;
<span class="p_del">-	if ((efi.uv_systab == EFI_INVALID_TABLE_ADDR) || !efi.uv_systab) {</span>
<span class="p_add">+	if ((efi.uv_systab == EFI_INVALID_TABLE_ADDR) ||</span>
<span class="p_add">+	    !efi.uv_systab || efi_runtime_disabled()) {</span>
 		pr_crit(&quot;UV: UVsystab: missing\n&quot;);
 		return;
 	}
<span class="p_header">diff --git a/drivers/acpi/cppc_acpi.c b/drivers/acpi/cppc_acpi.c</span>
<span class="p_header">index 8adac69dba3d..2e981732805b 100644</span>
<span class="p_header">--- a/drivers/acpi/cppc_acpi.c</span>
<span class="p_header">+++ b/drivers/acpi/cppc_acpi.c</span>
<span class="p_chunk">@@ -299,8 +299,10 @@</span> <span class="p_context"> int acpi_get_psd_map(struct cpudata **all_cpu_data)</span>
 			continue;
 
 		cpc_ptr = per_cpu(cpc_desc_ptr, i);
<span class="p_del">-		if (!cpc_ptr)</span>
<span class="p_del">-			continue;</span>
<span class="p_add">+		if (!cpc_ptr) {</span>
<span class="p_add">+			retval = -EFAULT;</span>
<span class="p_add">+			goto err_ret;</span>
<span class="p_add">+		}</span>
 
 		pdomain = &amp;(cpc_ptr-&gt;domain_info);
 		cpumask_set_cpu(i, pr-&gt;shared_cpu_map);
<span class="p_chunk">@@ -322,8 +324,10 @@</span> <span class="p_context"> int acpi_get_psd_map(struct cpudata **all_cpu_data)</span>
 				continue;
 
 			match_cpc_ptr = per_cpu(cpc_desc_ptr, j);
<span class="p_del">-			if (!match_cpc_ptr)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (!match_cpc_ptr) {</span>
<span class="p_add">+				retval = -EFAULT;</span>
<span class="p_add">+				goto err_ret;</span>
<span class="p_add">+			}</span>
 
 			match_pdomain = &amp;(match_cpc_ptr-&gt;domain_info);
 			if (match_pdomain-&gt;domain != pdomain-&gt;domain)
<span class="p_chunk">@@ -353,8 +357,10 @@</span> <span class="p_context"> int acpi_get_psd_map(struct cpudata **all_cpu_data)</span>
 				continue;
 
 			match_cpc_ptr = per_cpu(cpc_desc_ptr, j);
<span class="p_del">-			if (!match_cpc_ptr)</span>
<span class="p_del">-				continue;</span>
<span class="p_add">+			if (!match_cpc_ptr) {</span>
<span class="p_add">+				retval = -EFAULT;</span>
<span class="p_add">+				goto err_ret;</span>
<span class="p_add">+			}</span>
 
 			match_pdomain = &amp;(match_cpc_ptr-&gt;domain_info);
 			if (match_pdomain-&gt;domain != pdomain-&gt;domain)
<span class="p_chunk">@@ -595,9 +601,6 @@</span> <span class="p_context"> int acpi_cppc_processor_probe(struct acpi_processor *pr)</span>
 	/* Store CPU Logical ID */
 	cpc_ptr-&gt;cpu_id = pr-&gt;id;
 
<span class="p_del">-	/* Plug it into this CPUs CPC descriptor. */</span>
<span class="p_del">-	per_cpu(cpc_desc_ptr, pr-&gt;id) = cpc_ptr;</span>
<span class="p_del">-</span>
 	/* Parse PSD data for this CPU */
 	ret = acpi_get_psd(cpc_ptr, handle);
 	if (ret)
<span class="p_chunk">@@ -610,6 +613,9 @@</span> <span class="p_context"> int acpi_cppc_processor_probe(struct acpi_processor *pr)</span>
 			goto out_free;
 	}
 
<span class="p_add">+	/* Plug PSD data into this CPUs CPC descriptor. */</span>
<span class="p_add">+	per_cpu(cpc_desc_ptr, pr-&gt;id) = cpc_ptr;</span>
<span class="p_add">+</span>
 	/* Everything looks okay */
 	pr_debug(&quot;Parsed CPC struct for CPU: %d\n&quot;, pr-&gt;id);
 
<span class="p_header">diff --git a/drivers/acpi/nfit.c b/drivers/acpi/nfit.c</span>
<span class="p_header">index 1f0e06065ae6..375c10f38c63 100644</span>
<span class="p_header">--- a/drivers/acpi/nfit.c</span>
<span class="p_header">+++ b/drivers/acpi/nfit.c</span>
<span class="p_chunk">@@ -1396,11 +1396,12 @@</span> <span class="p_context"> static u32 read_blk_stat(struct nfit_blk *nfit_blk, unsigned int bw)</span>
 {
 	struct nfit_blk_mmio *mmio = &amp;nfit_blk-&gt;mmio[DCR];
 	u64 offset = nfit_blk-&gt;stat_offset + mmio-&gt;size * bw;
<span class="p_add">+	const u32 STATUS_MASK = 0x80000037;</span>
 
 	if (mmio-&gt;num_lines)
 		offset = to_interleave_offset(offset, mmio);
 
<span class="p_del">-	return readl(mmio-&gt;addr.base + offset);</span>
<span class="p_add">+	return readl(mmio-&gt;addr.base + offset) &amp; STATUS_MASK;</span>
 }
 
 static void write_blk_ctl(struct nfit_blk *nfit_blk, unsigned int bw,
<span class="p_header">diff --git a/drivers/acpi/scan.c b/drivers/acpi/scan.c</span>
<span class="p_header">index 5f28cf778349..f3c022292586 100644</span>
<span class="p_header">--- a/drivers/acpi/scan.c</span>
<span class="p_header">+++ b/drivers/acpi/scan.c</span>
<span class="p_chunk">@@ -1967,7 +1967,7 @@</span> <span class="p_context"> int __init acpi_scan_init(void)</span>
 
 static struct acpi_probe_entry *ape;
 static int acpi_probe_count;
<span class="p_del">-static DEFINE_SPINLOCK(acpi_probe_lock);</span>
<span class="p_add">+static DEFINE_MUTEX(acpi_probe_mutex);</span>
 
 static int __init acpi_match_madt(struct acpi_subtable_header *header,
 				  const unsigned long end)
<span class="p_chunk">@@ -1986,7 +1986,7 @@</span> <span class="p_context"> int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)</span>
 	if (acpi_disabled)
 		return 0;
 
<span class="p_del">-	spin_lock(&amp;acpi_probe_lock);</span>
<span class="p_add">+	mutex_lock(&amp;acpi_probe_mutex);</span>
 	for (ape = ap_head; nr; ape++, nr--) {
 		if (ACPI_COMPARE_NAME(ACPI_SIG_MADT, ape-&gt;id)) {
 			acpi_probe_count = 0;
<span class="p_chunk">@@ -1999,7 +1999,7 @@</span> <span class="p_context"> int __init __acpi_probe_device_table(struct acpi_probe_entry *ap_head, int nr)</span>
 				count++;
 		}
 	}
<span class="p_del">-	spin_unlock(&amp;acpi_probe_lock);</span>
<span class="p_add">+	mutex_unlock(&amp;acpi_probe_mutex);</span>
 
 	return count;
 }
<span class="p_header">diff --git a/drivers/block/floppy.c b/drivers/block/floppy.c</span>
<span class="p_header">index a1dcf12d3dad..84708a5f8c52 100644</span>
<span class="p_header">--- a/drivers/block/floppy.c</span>
<span class="p_header">+++ b/drivers/block/floppy.c</span>
<span class="p_chunk">@@ -3663,6 +3663,11 @@</span> <span class="p_context"> static int floppy_open(struct block_device *bdev, fmode_t mode)</span>
 
 	opened_bdev[drive] = bdev;
 
<span class="p_add">+	if (!(mode &amp; (FMODE_READ|FMODE_WRITE))) {</span>
<span class="p_add">+		res = -EINVAL;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	res = -ENXIO;
 
 	if (!floppy_track_buffer) {
<span class="p_chunk">@@ -3706,15 +3711,13 @@</span> <span class="p_context"> static int floppy_open(struct block_device *bdev, fmode_t mode)</span>
 	if (UFDCS-&gt;rawcmd == 1)
 		UFDCS-&gt;rawcmd = 2;
 
<span class="p_del">-	if (mode &amp; (FMODE_READ|FMODE_WRITE)) {</span>
<span class="p_del">-		UDRS-&gt;last_checked = 0;</span>
<span class="p_del">-		clear_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags);</span>
<span class="p_del">-		check_disk_change(bdev);</span>
<span class="p_del">-		if (test_bit(FD_DISK_CHANGED_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		if (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	UDRS-&gt;last_checked = 0;</span>
<span class="p_add">+	clear_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags);</span>
<span class="p_add">+	check_disk_change(bdev);</span>
<span class="p_add">+	if (test_bit(FD_DISK_CHANGED_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	if (test_bit(FD_OPEN_SHOULD_FAIL_BIT, &amp;UDRS-&gt;flags))</span>
<span class="p_add">+		goto out;</span>
 
 	res = -EROFS;
 
<span class="p_header">diff --git a/drivers/clk/renesas/r8a7795-cpg-mssr.c b/drivers/clk/renesas/r8a7795-cpg-mssr.c</span>
<span class="p_header">index ca5519c583d4..e7b98c4d49ad 100644</span>
<span class="p_header">--- a/drivers/clk/renesas/r8a7795-cpg-mssr.c</span>
<span class="p_header">+++ b/drivers/clk/renesas/r8a7795-cpg-mssr.c</span>
<span class="p_chunk">@@ -91,6 +91,7 @@</span> <span class="p_context"> static const struct cpg_core_clk r8a7795_core_clks[] __initconst = {</span>
 	DEF_FIXED(&quot;.s1&quot;,        CLK_S1,            CLK_PLL1_DIV2,  3, 1),
 	DEF_FIXED(&quot;.s2&quot;,        CLK_S2,            CLK_PLL1_DIV2,  4, 1),
 	DEF_FIXED(&quot;.s3&quot;,        CLK_S3,            CLK_PLL1_DIV2,  6, 1),
<span class="p_add">+	DEF_FIXED(&quot;.sdsrc&quot;,     CLK_SDSRC,         CLK_PLL1_DIV2,  2, 1),</span>
 
 	/* Core Clock Outputs */
 	DEF_FIXED(&quot;ztr&quot;,        R8A7795_CLK_ZTR,   CLK_PLL1_DIV2,  6, 1),
<span class="p_chunk">@@ -109,10 +110,10 @@</span> <span class="p_context"> static const struct cpg_core_clk r8a7795_core_clks[] __initconst = {</span>
 	DEF_FIXED(&quot;s3d2&quot;,       R8A7795_CLK_S3D2,  CLK_S3,         2, 1),
 	DEF_FIXED(&quot;s3d4&quot;,       R8A7795_CLK_S3D4,  CLK_S3,         4, 1),
 
<span class="p_del">-	DEF_GEN3_SD(&quot;sd0&quot;,      R8A7795_CLK_SD0,   CLK_PLL1_DIV2, 0x0074),</span>
<span class="p_del">-	DEF_GEN3_SD(&quot;sd1&quot;,      R8A7795_CLK_SD1,   CLK_PLL1_DIV2, 0x0078),</span>
<span class="p_del">-	DEF_GEN3_SD(&quot;sd2&quot;,      R8A7795_CLK_SD2,   CLK_PLL1_DIV2, 0x0268),</span>
<span class="p_del">-	DEF_GEN3_SD(&quot;sd3&quot;,      R8A7795_CLK_SD3,   CLK_PLL1_DIV2, 0x026c),</span>
<span class="p_add">+	DEF_GEN3_SD(&quot;sd0&quot;,      R8A7795_CLK_SD0,   CLK_SDSRC,     0x0074),</span>
<span class="p_add">+	DEF_GEN3_SD(&quot;sd1&quot;,      R8A7795_CLK_SD1,   CLK_SDSRC,     0x0078),</span>
<span class="p_add">+	DEF_GEN3_SD(&quot;sd2&quot;,      R8A7795_CLK_SD2,   CLK_SDSRC,     0x0268),</span>
<span class="p_add">+	DEF_GEN3_SD(&quot;sd3&quot;,      R8A7795_CLK_SD3,   CLK_SDSRC,     0x026c),</span>
 
 	DEF_FIXED(&quot;cl&quot;,         R8A7795_CLK_CL,    CLK_PLL1_DIV2, 48, 1),
 	DEF_FIXED(&quot;cp&quot;,         R8A7795_CLK_CP,    CLK_EXTAL,      2, 1),
<span class="p_header">diff --git a/drivers/crypto/caam/caamalg.c b/drivers/crypto/caam/caamalg.c</span>
<span class="p_header">index ea8189f4b021..6dc597126b79 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamalg.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamalg.c</span>
<span class="p_chunk">@@ -441,6 +441,9 @@</span> <span class="p_context"> static int aead_set_sh_desc(struct crypto_aead *aead)</span>
 			       OP_ALG_AAI_CTR_MOD128);
 	const bool is_rfc3686 = alg-&gt;caam.rfc3686;
 
<span class="p_add">+	if (!ctx-&gt;authsize)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	/* NULL encryption / decryption */
 	if (!ctx-&gt;enckeylen)
 		return aead_null_set_sh_desc(aead);
<span class="p_chunk">@@ -614,7 +617,7 @@</span> <span class="p_context"> skip_enc:</span>
 		keys_fit_inline = true;
 
 	/* aead_givencrypt shared descriptor */
<span class="p_del">-	desc = ctx-&gt;sh_desc_givenc;</span>
<span class="p_add">+	desc = ctx-&gt;sh_desc_enc;</span>
 
 	/* Note: Context registers are saved. */
 	init_sh_desc_key_aead(desc, ctx, keys_fit_inline, is_rfc3686);
<span class="p_chunk">@@ -645,13 +648,13 @@</span> <span class="p_context"> copy_iv:</span>
 	append_operation(desc, ctx-&gt;class2_alg_type |
 			 OP_ALG_AS_INITFINAL | OP_ALG_ENCRYPT);
 
<span class="p_del">-	/* ivsize + cryptlen = seqoutlen - authsize */</span>
<span class="p_del">-	append_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx-&gt;authsize);</span>
<span class="p_del">-</span>
 	/* Read and write assoclen bytes */
 	append_math_add(desc, VARSEQINLEN, ZERO, REG3, CAAM_CMD_SZ);
 	append_math_add(desc, VARSEQOUTLEN, ZERO, REG3, CAAM_CMD_SZ);
 
<span class="p_add">+	/* ivsize + cryptlen = seqoutlen - authsize */</span>
<span class="p_add">+	append_math_sub_imm_u32(desc, REG3, SEQOUTLEN, IMM, ctx-&gt;authsize);</span>
<span class="p_add">+</span>
 	/* Skip assoc data */
 	append_seq_fifo_store(desc, 0, FIFOST_TYPE_SKIP | FIFOLDST_VLF);
 
<span class="p_chunk">@@ -697,7 +700,7 @@</span> <span class="p_context"> copy_iv:</span>
 	ctx-&gt;sh_desc_enc_dma = dma_map_single(jrdev, desc,
 					      desc_bytes(desc),
 					      DMA_TO_DEVICE);
<span class="p_del">-	if (dma_mapping_error(jrdev, ctx-&gt;sh_desc_givenc_dma)) {</span>
<span class="p_add">+	if (dma_mapping_error(jrdev, ctx-&gt;sh_desc_enc_dma)) {</span>
 		dev_err(jrdev, &quot;unable to map shared descriptor\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_header">diff --git a/drivers/crypto/caam/caamhash.c b/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">index 5845d4a08797..e9703f9d15dd 100644</span>
<span class="p_header">--- a/drivers/crypto/caam/caamhash.c</span>
<span class="p_header">+++ b/drivers/crypto/caam/caamhash.c</span>
<span class="p_chunk">@@ -1897,6 +1897,7 @@</span> <span class="p_context"> caam_hash_alloc(struct caam_hash_template *template,</span>
 			 template-&gt;name);
 		snprintf(alg-&gt;cra_driver_name, CRYPTO_MAX_ALG_NAME, &quot;%s&quot;,
 			 template-&gt;driver_name);
<span class="p_add">+		t_alg-&gt;ahash_alg.setkey = NULL;</span>
 	}
 	alg-&gt;cra_module = THIS_MODULE;
 	alg-&gt;cra_init = caam_hash_cra_init;
<span class="p_header">diff --git a/drivers/crypto/nx/nx.c b/drivers/crypto/nx/nx.c</span>
<span class="p_header">index 0794f1cc0018..42f0f229f7f7 100644</span>
<span class="p_header">--- a/drivers/crypto/nx/nx.c</span>
<span class="p_header">+++ b/drivers/crypto/nx/nx.c</span>
<span class="p_chunk">@@ -392,7 +392,7 @@</span> <span class="p_context"> static void nx_of_update_msc(struct device   *dev,</span>
 		     ((bytes_so_far + sizeof(struct msc_triplet)) &lt;= lenp) &amp;&amp;
 		     i &lt; msc-&gt;triplets;
 		     i++) {
<span class="p_del">-			if (msc-&gt;fc &gt; NX_MAX_FC || msc-&gt;mode &gt; NX_MAX_MODE) {</span>
<span class="p_add">+			if (msc-&gt;fc &gt;= NX_MAX_FC || msc-&gt;mode &gt;= NX_MAX_MODE) {</span>
 				dev_err(dev, &quot;unknown function code/mode &quot;
 					&quot;combo: %d/%d (ignored)\n&quot;, msc-&gt;fc,
 					msc-&gt;mode);
<span class="p_header">diff --git a/drivers/crypto/qat/qat_common/qat_algs.c b/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_header">index 1e8852a8a057..4c9deef6a3e4 100644</span>
<span class="p_header">--- a/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_header">+++ b/drivers/crypto/qat/qat_common/qat_algs.c</span>
<span class="p_chunk">@@ -1260,8 +1260,8 @@</span> <span class="p_context"> static struct crypto_alg qat_algs[] = { {</span>
 			.setkey = qat_alg_ablkcipher_xts_setkey,
 			.decrypt = qat_alg_ablkcipher_decrypt,
 			.encrypt = qat_alg_ablkcipher_encrypt,
<span class="p_del">-			.min_keysize = AES_MIN_KEY_SIZE,</span>
<span class="p_del">-			.max_keysize = AES_MAX_KEY_SIZE,</span>
<span class="p_add">+			.min_keysize = 2 * AES_MIN_KEY_SIZE,</span>
<span class="p_add">+			.max_keysize = 2 * AES_MAX_KEY_SIZE,</span>
 			.ivsize = AES_BLOCK_SIZE,
 		},
 	},
<span class="p_header">diff --git a/drivers/dax/pmem.c b/drivers/dax/pmem.c</span>
<span class="p_header">index 55d510e36cd1..82e6743c48f8 100644</span>
<span class="p_header">--- a/drivers/dax/pmem.c</span>
<span class="p_header">+++ b/drivers/dax/pmem.c</span>
<span class="p_chunk">@@ -118,6 +118,9 @@</span> <span class="p_context"> static int dax_pmem_probe(struct device *dev)</span>
 		return rc;
 	}
 
<span class="p_add">+	/* adjust the dax_region resource to the start of data */</span>
<span class="p_add">+	res.start += le64_to_cpu(pfn_sb-&gt;dataoff);</span>
<span class="p_add">+</span>
 	nd_region = to_nd_region(dev-&gt;parent);
 	dax_region = alloc_dax_region(dev, nd_region-&gt;id, &amp;res,
 			le32_to_cpu(pfn_sb-&gt;align), addr, PFN_DEV|PFN_MAP);
<span class="p_header">diff --git a/drivers/dma/sh/usb-dmac.c b/drivers/dma/sh/usb-dmac.c</span>
<span class="p_header">index 749f1bd5d65d..06ecdc38cee0 100644</span>
<span class="p_header">--- a/drivers/dma/sh/usb-dmac.c</span>
<span class="p_header">+++ b/drivers/dma/sh/usb-dmac.c</span>
<span class="p_chunk">@@ -600,27 +600,30 @@</span> <span class="p_context"> static irqreturn_t usb_dmac_isr_channel(int irq, void *dev)</span>
 {
 	struct usb_dmac_chan *chan = dev;
 	irqreturn_t ret = IRQ_NONE;
<span class="p_del">-	u32 mask = USB_DMACHCR_TE;</span>
<span class="p_del">-	u32 check_bits = USB_DMACHCR_TE | USB_DMACHCR_SP;</span>
<span class="p_add">+	u32 mask = 0;</span>
 	u32 chcr;
<span class="p_add">+	bool xfer_end = false;</span>
 
 	spin_lock(&amp;chan-&gt;vc.lock);
 
 	chcr = usb_dmac_chan_read(chan, USB_DMACHCR);
<span class="p_del">-	if (chcr &amp; check_bits)</span>
<span class="p_del">-		mask |= USB_DMACHCR_DE | check_bits;</span>
<span class="p_add">+	if (chcr &amp; (USB_DMACHCR_TE | USB_DMACHCR_SP)) {</span>
<span class="p_add">+		mask |= USB_DMACHCR_DE | USB_DMACHCR_TE | USB_DMACHCR_SP;</span>
<span class="p_add">+		if (chcr &amp; USB_DMACHCR_DE)</span>
<span class="p_add">+			xfer_end = true;</span>
<span class="p_add">+		ret |= IRQ_HANDLED;</span>
<span class="p_add">+	}</span>
 	if (chcr &amp; USB_DMACHCR_NULL) {
 		/* An interruption of TE will happen after we set FTE */
 		mask |= USB_DMACHCR_NULL;
 		chcr |= USB_DMACHCR_FTE;
 		ret |= IRQ_HANDLED;
 	}
<span class="p_del">-	usb_dmac_chan_write(chan, USB_DMACHCR, chcr &amp; ~mask);</span>
<span class="p_add">+	if (mask)</span>
<span class="p_add">+		usb_dmac_chan_write(chan, USB_DMACHCR, chcr &amp; ~mask);</span>
 
<span class="p_del">-	if (chcr &amp; check_bits) {</span>
<span class="p_add">+	if (xfer_end)</span>
 		usb_dmac_isr_transfer_end(chan);
<span class="p_del">-		ret |= IRQ_HANDLED;</span>
<span class="p_del">-	}</span>
 
 	spin_unlock(&amp;chan-&gt;vc.lock);
 
<span class="p_header">diff --git a/drivers/edac/sb_edac.c b/drivers/edac/sb_edac.c</span>
<span class="p_header">index 4fb2eb7c800d..ce0067b7a2f6 100644</span>
<span class="p_header">--- a/drivers/edac/sb_edac.c</span>
<span class="p_header">+++ b/drivers/edac/sb_edac.c</span>
<span class="p_chunk">@@ -552,9 +552,9 @@</span> <span class="p_context"> static const struct pci_id_table pci_dev_descr_haswell_table[] = {</span>
 /* Knight&#39;s Landing Support */
 /*
  * KNL&#39;s memory channels are swizzled between memory controllers.
<span class="p_del">- * MC0 is mapped to CH3,5,6 and MC1 is mapped to CH0,1,2</span>
<span class="p_add">+ * MC0 is mapped to CH3,4,5 and MC1 is mapped to CH0,1,2</span>
  */
<span class="p_del">-#define knl_channel_remap(channel) ((channel + 3) % 6)</span>
<span class="p_add">+#define knl_channel_remap(mc, chan) ((mc) ? (chan) : (chan) + 3)</span>
 
 /* Memory controller, TAD tables, error injection - 2-8-0, 2-9-0 (2 of these) */
 #define PCI_DEVICE_ID_INTEL_KNL_IMC_MC       0x7840
<span class="p_chunk">@@ -1286,7 +1286,7 @@</span> <span class="p_context"> static u32 knl_get_mc_route(int entry, u32 reg)</span>
 	mc = GET_BITFIELD(reg, entry*3, (entry*3)+2);
 	chan = GET_BITFIELD(reg, (entry*2) + 18, (entry*2) + 18 + 1);
 
<span class="p_del">-	return knl_channel_remap(mc*3 + chan);</span>
<span class="p_add">+	return knl_channel_remap(mc, chan);</span>
 }
 
 /*
<span class="p_chunk">@@ -2997,8 +2997,15 @@</span> <span class="p_context"> static void sbridge_mce_output_error(struct mem_ctl_info *mci,</span>
 		} else {
 			char A = *(&quot;A&quot;);
 
<span class="p_del">-			channel = knl_channel_remap(channel);</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * Reported channel is in range 0-2, so we can&#39;t map it</span>
<span class="p_add">+			 * back to mc. To figure out mc we check machine check</span>
<span class="p_add">+			 * bank register that reported this error.</span>
<span class="p_add">+			 * bank15 means mc0 and bank16 means mc1.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			channel = knl_channel_remap(m-&gt;bank == 16, channel);</span>
 			channel_mask = 1 &lt;&lt; channel;
<span class="p_add">+</span>
 			snprintf(msg, sizeof(msg),
 				&quot;%s%s err_code:%04x:%04x channel:%d (DIMM_%c)&quot;,
 				overflow ? &quot; OVERFLOW&quot; : &quot;&quot;,
<span class="p_header">diff --git a/drivers/firmware/efi/capsule-loader.c b/drivers/firmware/efi/capsule-loader.c</span>
<span class="p_header">index c99c24bc79b0..9ae6c116c474 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/capsule-loader.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/capsule-loader.c</span>
<span class="p_chunk">@@ -16,6 +16,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/mutex.h&gt;
 #include &lt;linux/efi.h&gt;
<span class="p_add">+#include &lt;linux/vmalloc.h&gt;</span>
 
 #define NO_FURTHER_WRITE_ACTION -1
 
<span class="p_chunk">@@ -108,14 +109,15 @@</span> <span class="p_context"> static ssize_t efi_capsule_submit_update(struct capsule_info *cap_info)</span>
 	int ret;
 	void *cap_hdr_temp;
 
<span class="p_del">-	cap_hdr_temp = kmap(cap_info-&gt;pages[0]);</span>
<span class="p_add">+	cap_hdr_temp = vmap(cap_info-&gt;pages, cap_info-&gt;index,</span>
<span class="p_add">+			VM_MAP, PAGE_KERNEL);</span>
 	if (!cap_hdr_temp) {
<span class="p_del">-		pr_debug(&quot;%s: kmap() failed\n&quot;, __func__);</span>
<span class="p_add">+		pr_debug(&quot;%s: vmap() failed\n&quot;, __func__);</span>
 		return -EFAULT;
 	}
 
 	ret = efi_capsule_update(cap_hdr_temp, cap_info-&gt;pages);
<span class="p_del">-	kunmap(cap_info-&gt;pages[0]);</span>
<span class="p_add">+	vunmap(cap_hdr_temp);</span>
 	if (ret) {
 		pr_err(&quot;%s: efi_capsule_update() failed\n&quot;, __func__);
 		return ret;
<span class="p_header">diff --git a/drivers/firmware/efi/capsule.c b/drivers/firmware/efi/capsule.c</span>
<span class="p_header">index 53b9fd2293ee..6eedff45e6d7 100644</span>
<span class="p_header">--- a/drivers/firmware/efi/capsule.c</span>
<span class="p_header">+++ b/drivers/firmware/efi/capsule.c</span>
<span class="p_chunk">@@ -190,9 +190,9 @@</span> <span class="p_context"> efi_capsule_update_locked(efi_capsule_header_t *capsule,</span>
  * map the capsule described by @capsule with its data in @pages and
  * send it to the firmware via the UpdateCapsule() runtime service.
  *
<span class="p_del">- * @capsule must be a virtual mapping of the first page in @pages</span>
<span class="p_del">- * (@pages[0]) in the kernel address space. That is, a</span>
<span class="p_del">- * capsule_header_t that describes the entire contents of the capsule</span>
<span class="p_add">+ * @capsule must be a virtual mapping of the complete capsule update in the</span>
<span class="p_add">+ * kernel address space, as the capsule can be consumed immediately.</span>
<span class="p_add">+ * A capsule_header_t that describes the entire contents of the capsule</span>
  * must be at the start of the first data page.
  *
  * Even though this function will validate that the firmware supports
<span class="p_header">diff --git a/drivers/gpio/Kconfig b/drivers/gpio/Kconfig</span>
<span class="p_header">index d7860614f87f..5d457ff61325 100644</span>
<span class="p_header">--- a/drivers/gpio/Kconfig</span>
<span class="p_header">+++ b/drivers/gpio/Kconfig</span>
<span class="p_chunk">@@ -50,6 +50,7 @@</span> <span class="p_context"> config GPIO_DEVRES</span>
 config OF_GPIO
 	def_bool y
 	depends on OF
<span class="p_add">+	depends on HAS_IOMEM</span>
 
 config GPIO_ACPI
 	def_bool y
<span class="p_header">diff --git a/drivers/gpio/gpio-max730x.c b/drivers/gpio/gpio-max730x.c</span>
<span class="p_header">index 08807368f007..946d09195598 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-max730x.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-max730x.c</span>
<span class="p_chunk">@@ -192,6 +192,10 @@</span> <span class="p_context"> int __max730x_probe(struct max7301 *ts)</span>
 	ts-&gt;chip.parent = dev;
 	ts-&gt;chip.owner = THIS_MODULE;
 
<span class="p_add">+	ret = gpiochip_add_data(&amp;ts-&gt;chip, ts);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto exit_destroy;</span>
<span class="p_add">+</span>
 	/*
 	 * initialize pullups according to platform data and cache the
 	 * register values for later use.
<span class="p_chunk">@@ -213,10 +217,6 @@</span> <span class="p_context"> int __max730x_probe(struct max7301 *ts)</span>
 		}
 	}
 
<span class="p_del">-	ret = gpiochip_add_data(&amp;ts-&gt;chip, ts);</span>
<span class="p_del">-	if (ret)</span>
<span class="p_del">-		goto exit_destroy;</span>
<span class="p_del">-</span>
 	return ret;
 
 exit_destroy:
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">index e055d5be1c3c..56475b1f1581 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h</span>
<span class="p_chunk">@@ -415,6 +415,8 @@</span> <span class="p_context"> struct amdgpu_mman {</span>
 
 	/* custom LRU management */
 	struct amdgpu_mman_lru			log2_size[AMDGPU_TTM_LRU_SIZE];
<span class="p_add">+	/* guard for log2_size array, don&#39;t add anything in between */</span>
<span class="p_add">+	struct amdgpu_mman_lru			guard;</span>
 };
 
 int amdgpu_copy_buffer(struct amdgpu_ring *ring,
<span class="p_chunk">@@ -637,9 +639,9 @@</span> <span class="p_context"> int amdgpu_gart_table_vram_pin(struct amdgpu_device *adev);</span>
 void amdgpu_gart_table_vram_unpin(struct amdgpu_device *adev);
 int amdgpu_gart_init(struct amdgpu_device *adev);
 void amdgpu_gart_fini(struct amdgpu_device *adev);
<span class="p_del">-void amdgpu_gart_unbind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+void amdgpu_gart_unbind(struct amdgpu_device *adev, uint64_t offset,</span>
 			int pages);
<span class="p_del">-int amdgpu_gart_bind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+int amdgpu_gart_bind(struct amdgpu_device *adev, uint64_t offset,</span>
 		     int pages, struct page **pagelist,
 		     dma_addr_t *dma_addr, uint32_t flags);
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">index 983175363b06..fe872b82e619 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_atombios.c</span>
<span class="p_chunk">@@ -321,6 +321,19 @@</span> <span class="p_context"> bool amdgpu_atombios_get_connector_info_from_object_table(struct amdgpu_device *</span>
 			    (le16_to_cpu(path-&gt;usConnObjectId) &amp;
 			     OBJECT_TYPE_MASK) &gt;&gt; OBJECT_TYPE_SHIFT;
 
<span class="p_add">+			/* Skip TV/CV support */</span>
<span class="p_add">+			if ((le16_to_cpu(path-&gt;usDeviceTag) ==</span>
<span class="p_add">+			     ATOM_DEVICE_TV1_SUPPORT) ||</span>
<span class="p_add">+			    (le16_to_cpu(path-&gt;usDeviceTag) ==</span>
<span class="p_add">+			     ATOM_DEVICE_CV_SUPPORT))</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (con_obj_id &gt;= ARRAY_SIZE(object_connector_convert)) {</span>
<span class="p_add">+				DRM_ERROR(&quot;invalid con_obj_id %d for device tag 0x%04x\n&quot;,</span>
<span class="p_add">+					  con_obj_id, le16_to_cpu(path-&gt;usDeviceTag));</span>
<span class="p_add">+				continue;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
 			connector_type =
 				object_connector_convert[con_obj_id];
 			connector_object_id = con_obj_id;
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c</span>
<span class="p_header">index 921bce2df0b0..0feea347f680 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_gart.c</span>
<span class="p_chunk">@@ -221,7 +221,7 @@</span> <span class="p_context"> void amdgpu_gart_table_vram_free(struct amdgpu_device *adev)</span>
  * Unbinds the requested pages from the gart page table and
  * replaces them with the dummy page (all asics).
  */
<span class="p_del">-void amdgpu_gart_unbind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+void amdgpu_gart_unbind(struct amdgpu_device *adev, uint64_t offset,</span>
 			int pages)
 {
 	unsigned t;
<span class="p_chunk">@@ -268,7 +268,7 @@</span> <span class="p_context"> void amdgpu_gart_unbind(struct amdgpu_device *adev, unsigned offset,</span>
  * (all asics).
  * Returns 0 for success, -EINVAL for failure.
  */
<span class="p_del">-int amdgpu_gart_bind(struct amdgpu_device *adev, unsigned offset,</span>
<span class="p_add">+int amdgpu_gart_bind(struct amdgpu_device *adev, uint64_t offset,</span>
 		     int pages, struct page **pagelist, dma_addr_t *dma_addr,
 		     uint32_t flags)
 {
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c</span>
<span class="p_header">index 34e35423b78e..194cfc1a8cca 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c</span>
<span class="p_chunk">@@ -288,7 +288,7 @@</span> <span class="p_context"> void amdgpu_ib_pool_fini(struct amdgpu_device *adev)</span>
 int amdgpu_ib_ring_tests(struct amdgpu_device *adev)
 {
 	unsigned i;
<span class="p_del">-	int r;</span>
<span class="p_add">+	int r, ret = 0;</span>
 
 	for (i = 0; i &lt; AMDGPU_MAX_RINGS; ++i) {
 		struct amdgpu_ring *ring = adev-&gt;rings[i];
<span class="p_chunk">@@ -309,10 +309,11 @@</span> <span class="p_context"> int amdgpu_ib_ring_tests(struct amdgpu_device *adev)</span>
 			} else {
 				/* still not good, but we can live with it */
 				DRM_ERROR(&quot;amdgpu: failed testing IB on ring %d (%d).\n&quot;, i, r);
<span class="p_add">+				ret = r;</span>
 			}
 		}
 	}
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c</span>
<span class="p_header">index 3b9053af4762..46c5297f6dfe 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ttm.c</span>
<span class="p_chunk">@@ -251,8 +251,8 @@</span> <span class="p_context"> static int amdgpu_move_blit(struct ttm_buffer_object *bo,</span>
 
 	adev = amdgpu_get_adev(bo-&gt;bdev);
 	ring = adev-&gt;mman.buffer_funcs_ring;
<span class="p_del">-	old_start = old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_del">-	new_start = new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	old_start = (u64)old_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
<span class="p_add">+	new_start = (u64)new_mem-&gt;start &lt;&lt; PAGE_SHIFT;</span>
 
 	switch (old_mem-&gt;mem_type) {
 	case TTM_PL_VRAM:
<span class="p_chunk">@@ -943,6 +943,8 @@</span> <span class="p_context"> static struct list_head *amdgpu_ttm_lru_tail(struct ttm_buffer_object *tbo)</span>
 	struct list_head *res = lru-&gt;lru[tbo-&gt;mem.mem_type];
 
 	lru-&gt;lru[tbo-&gt;mem.mem_type] = &amp;tbo-&gt;lru;
<span class="p_add">+	while ((++lru)-&gt;lru[tbo-&gt;mem.mem_type] == res)</span>
<span class="p_add">+		lru-&gt;lru[tbo-&gt;mem.mem_type] = &amp;tbo-&gt;lru;</span>
 
 	return res;
 }
<span class="p_chunk">@@ -953,6 +955,8 @@</span> <span class="p_context"> static struct list_head *amdgpu_ttm_swap_lru_tail(struct ttm_buffer_object *tbo)</span>
 	struct list_head *res = lru-&gt;swap_lru;
 
 	lru-&gt;swap_lru = &amp;tbo-&gt;swap;
<span class="p_add">+	while ((++lru)-&gt;swap_lru == res)</span>
<span class="p_add">+		lru-&gt;swap_lru = &amp;tbo-&gt;swap;</span>
 
 	return res;
 }
<span class="p_chunk">@@ -1004,6 +1008,10 @@</span> <span class="p_context"> int amdgpu_ttm_init(struct amdgpu_device *adev)</span>
 		lru-&gt;swap_lru = &amp;adev-&gt;mman.bdev.glob-&gt;swap_lru;
 	}
 
<span class="p_add">+	for (j = 0; j &lt; TTM_NUM_MEM_TYPES; ++j)</span>
<span class="p_add">+		adev-&gt;mman.guard.lru[j] = NULL;</span>
<span class="p_add">+	adev-&gt;mman.guard.swap_lru = NULL;</span>
<span class="p_add">+</span>
 	adev-&gt;mman.initialized = true;
 	r = ttm_bo_init_mm(&amp;adev-&gt;mman.bdev, TTM_PL_VRAM,
 				adev-&gt;mc.real_vram_size &gt;&gt; PAGE_SHIFT);
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c</span>
<span class="p_header">index 9dc4e24e31e7..3a1bbe2d87ba 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c</span>
<span class="p_chunk">@@ -52,6 +52,7 @@</span> <span class="p_context"> static void cik_sdma_set_ring_funcs(struct amdgpu_device *adev);</span>
 static void cik_sdma_set_irq_funcs(struct amdgpu_device *adev);
 static void cik_sdma_set_buffer_funcs(struct amdgpu_device *adev);
 static void cik_sdma_set_vm_pte_funcs(struct amdgpu_device *adev);
<span class="p_add">+static int cik_sdma_soft_reset(void *handle);</span>
 
 MODULE_FIRMWARE(&quot;radeon/bonaire_sdma.bin&quot;);
 MODULE_FIRMWARE(&quot;radeon/bonaire_sdma1.bin&quot;);
<span class="p_chunk">@@ -1051,6 +1052,8 @@</span> <span class="p_context"> static int cik_sdma_resume(void *handle)</span>
 {
 	struct amdgpu_device *adev = (struct amdgpu_device *)handle;
 
<span class="p_add">+	cik_sdma_soft_reset(handle);</span>
<span class="p_add">+</span>
 	return cik_sdma_hw_init(adev);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_header">index fc8ff4d3ccf8..6b40809bbed5 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c</span>
<span class="p_chunk">@@ -2777,8 +2777,7 @@</span> <span class="p_context"> static int gfx_v7_0_cp_compute_resume(struct amdgpu_device *adev)</span>
 	u64 wb_gpu_addr;
 	u32 *buf;
 	struct bonaire_mqd *mqd;
<span class="p_del">-</span>
<span class="p_del">-	gfx_v7_0_cp_compute_enable(adev, true);</span>
<span class="p_add">+	struct amdgpu_ring *ring;</span>
 
 	/* fix up chicken bits */
 	tmp = RREG32(mmCP_CPF_DEBUG);
<span class="p_chunk">@@ -2813,7 +2812,7 @@</span> <span class="p_context"> static int gfx_v7_0_cp_compute_resume(struct amdgpu_device *adev)</span>
 
 	/* init the queues.  Just two for now. */
 	for (i = 0; i &lt; adev-&gt;gfx.num_compute_rings; i++) {
<span class="p_del">-		struct amdgpu_ring *ring = &amp;adev-&gt;gfx.compute_ring[i];</span>
<span class="p_add">+		ring = &amp;adev-&gt;gfx.compute_ring[i];</span>
 
 		if (ring-&gt;mqd_obj == NULL) {
 			r = amdgpu_bo_create(adev,
<span class="p_chunk">@@ -2992,6 +2991,13 @@</span> <span class="p_context"> static int gfx_v7_0_cp_compute_resume(struct amdgpu_device *adev)</span>
 		amdgpu_bo_unreserve(ring-&gt;mqd_obj);
 
 		ring-&gt;ready = true;
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	gfx_v7_0_cp_compute_enable(adev, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; adev-&gt;gfx.num_compute_rings; i++) {</span>
<span class="p_add">+		ring = &amp;adev-&gt;gfx.compute_ring[i];</span>
<span class="p_add">+</span>
 		r = amdgpu_ring_test_ring(ring);
 		if (r)
 			ring-&gt;ready = false;
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.c b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">index 85c4debf47e0..fd3553bebab2 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.c</span>
<span class="p_chunk">@@ -1578,6 +1578,9 @@</span> <span class="p_context"> static int intel_runtime_suspend(struct device *device)</span>
 
 	assert_forcewakes_inactive(dev_priv);
 
<span class="p_add">+	if (!IS_VALLEYVIEW(dev_priv) || !IS_CHERRYVIEW(dev_priv))</span>
<span class="p_add">+		intel_hpd_poll_init(dev_priv);</span>
<span class="p_add">+</span>
 	DRM_DEBUG_KMS(&quot;Device suspended\n&quot;);
 	return 0;
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_drv.h b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">index 227a63ee0067..0ed5fd3b1804 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_drv.h</span>
<span class="p_chunk">@@ -281,6 +281,9 @@</span> <span class="p_context"> struct i915_hotplug {</span>
 	u32 short_port_mask;
 	struct work_struct dig_port_work;
 
<span class="p_add">+	struct work_struct poll_init_work;</span>
<span class="p_add">+	bool poll_enabled;</span>
<span class="p_add">+</span>
 	/*
 	 * if we get a HPD irq from DP and a HPD irq from non-DP
 	 * the non-DP HPD could block the workqueue on a mode config
<span class="p_chunk">@@ -2791,6 +2794,8 @@</span> <span class="p_context"> void intel_hpd_init(struct drm_i915_private *dev_priv);</span>
 void intel_hpd_init_work(struct drm_i915_private *dev_priv);
 void intel_hpd_cancel_work(struct drm_i915_private *dev_priv);
 bool intel_hpd_pin_to_port(enum hpd_pin pin, enum port *port);
<span class="p_add">+bool intel_hpd_disable(struct drm_i915_private *dev_priv, enum hpd_pin pin);</span>
<span class="p_add">+void intel_hpd_enable(struct drm_i915_private *dev_priv, enum hpd_pin pin);</span>
 
 /* i915_irq.c */
 void i915_queue_hangcheck(struct drm_device *dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_gem_gtt.c b/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_header">index 92acdff9dad3..e856f7906a48 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_gem_gtt.c</span>
<span class="p_chunk">@@ -2826,6 +2826,7 @@</span> <span class="p_context"> void i915_ggtt_cleanup_hw(struct drm_device *dev)</span>
 		struct i915_hw_ppgtt *ppgtt = dev_priv-&gt;mm.aliasing_ppgtt;
 
 		ppgtt-&gt;base.cleanup(&amp;ppgtt-&gt;base);
<span class="p_add">+		kfree(ppgtt);</span>
 	}
 
 	i915_gem_cleanup_stolen(dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/i915_reg.h b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">index bc3b6dde7b4b..5369a6d87fd8 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/i915_reg.h</span>
<span class="p_chunk">@@ -1522,6 +1522,7 @@</span> <span class="p_context"> enum skl_disp_power_wells {</span>
 #define BALANCE_LEG_MASK(port)		(7&lt;&lt;(8+3*(port)))
 /* Balance leg disable bits */
 #define BALANCE_LEG_DISABLE_SHIFT	23
<span class="p_add">+#define BALANCE_LEG_DISABLE(port)	(1 &lt;&lt; (23 + (port)))</span>
 
 /*
  * Fence registers
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_audio.c b/drivers/gpu/drm/i915/intel_audio.c</span>
<span class="p_header">index 02a7527ce7bb..74eca43b2818 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_audio.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_audio.c</span>
<span class="p_chunk">@@ -600,6 +600,8 @@</span> <span class="p_context"> static void i915_audio_component_codec_wake_override(struct device *dev,</span>
 	if (!IS_SKYLAKE(dev_priv) &amp;&amp; !IS_KABYLAKE(dev_priv))
 		return;
 
<span class="p_add">+	i915_audio_component_get_power(dev);</span>
<span class="p_add">+</span>
 	/*
 	 * Enable/disable generating the codec wake signal, overriding the
 	 * internal logic to generate the codec wake to controller.
<span class="p_chunk">@@ -615,6 +617,8 @@</span> <span class="p_context"> static void i915_audio_component_codec_wake_override(struct device *dev,</span>
 		I915_WRITE(HSW_AUD_CHICKENBIT, tmp);
 		usleep_range(1000, 1500);
 	}
<span class="p_add">+</span>
<span class="p_add">+	i915_audio_component_put_power(dev);</span>
 }
 
 /* Get CDCLK in kHz  */
<span class="p_chunk">@@ -654,6 +658,7 @@</span> <span class="p_context"> static int i915_audio_component_sync_audio_rate(struct device *dev,</span>
 	    !IS_HASWELL(dev_priv))
 		return 0;
 
<span class="p_add">+	i915_audio_component_get_power(dev);</span>
 	mutex_lock(&amp;dev_priv-&gt;av_mutex);
 	/* 1. get the pipe */
 	intel_encoder = dev_priv-&gt;dig_port_map[port];
<span class="p_chunk">@@ -704,6 +709,7 @@</span> <span class="p_context"> static int i915_audio_component_sync_audio_rate(struct device *dev,</span>
 
  unlock:
 	mutex_unlock(&amp;dev_priv-&gt;av_mutex);
<span class="p_add">+	i915_audio_component_put_power(dev);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_crt.c b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">index 3fbb6fc66451..a3f87d66829d 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_chunk">@@ -327,10 +327,25 @@</span> <span class="p_context"> static bool valleyview_crt_detect_hotplug(struct drm_connector *connector)</span>
 	struct drm_device *dev = connector-&gt;dev;
 	struct intel_crt *crt = intel_attached_crt(connector);
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
<span class="p_add">+	bool reenable_hpd;</span>
 	u32 adpa;
 	bool ret;
 	u32 save_adpa;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Doing a force trigger causes a hpd interrupt to get sent, which can</span>
<span class="p_add">+	 * get us stuck in a loop if we&#39;re polling:</span>
<span class="p_add">+	 *  - We enable power wells and reset the ADPA</span>
<span class="p_add">+	 *  - output_poll_exec does force probe on VGA, triggering a hpd</span>
<span class="p_add">+	 *  - HPD handler waits for poll to unlock dev-&gt;mode_config.mutex</span>
<span class="p_add">+	 *  - output_poll_exec shuts off the ADPA, unlocks</span>
<span class="p_add">+	 *    dev-&gt;mode_config.mutex</span>
<span class="p_add">+	 *  - HPD handler runs, resets ADPA and brings us back to the start</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Just disable HPD interrupts here to prevent this</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	reenable_hpd = intel_hpd_disable(dev_priv, crt-&gt;base.hpd_pin);</span>
<span class="p_add">+</span>
 	save_adpa = adpa = I915_READ(crt-&gt;adpa_reg);
 	DRM_DEBUG_KMS(&quot;trigger hotplug detect cycle: adpa=0x%x\n&quot;, adpa);
 
<span class="p_chunk">@@ -353,6 +368,9 @@</span> <span class="p_context"> static bool valleyview_crt_detect_hotplug(struct drm_connector *connector)</span>
 
 	DRM_DEBUG_KMS(&quot;valleyview hotplug adpa=0x%x, result %d\n&quot;, adpa, ret);
 
<span class="p_add">+	if (reenable_hpd)</span>
<span class="p_add">+		intel_hpd_enable(dev_priv, crt-&gt;base.hpd_pin);</span>
<span class="p_add">+</span>
 	return ret;
 }
 
<span class="p_chunk">@@ -713,11 +731,11 @@</span> <span class="p_context"> static int intel_crt_set_property(struct drm_connector *connector,</span>
 	return 0;
 }
 
<span class="p_del">-static void intel_crt_reset(struct drm_connector *connector)</span>
<span class="p_add">+void intel_crt_reset(struct drm_encoder *encoder)</span>
 {
<span class="p_del">-	struct drm_device *dev = connector-&gt;dev;</span>
<span class="p_add">+	struct drm_device *dev = encoder-&gt;dev;</span>
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
<span class="p_del">-	struct intel_crt *crt = intel_attached_crt(connector);</span>
<span class="p_add">+	struct intel_crt *crt = intel_encoder_to_crt(to_intel_encoder(encoder));</span>
 
 	if (INTEL_INFO(dev)-&gt;gen &gt;= 5) {
 		u32 adpa;
<span class="p_chunk">@@ -739,7 +757,6 @@</span> <span class="p_context"> static void intel_crt_reset(struct drm_connector *connector)</span>
  */
 
 static const struct drm_connector_funcs intel_crt_connector_funcs = {
<span class="p_del">-	.reset = intel_crt_reset,</span>
 	.dpms = drm_atomic_helper_connector_dpms,
 	.detect = intel_crt_detect,
 	.fill_modes = drm_helper_probe_single_connector_modes,
<span class="p_chunk">@@ -757,6 +774,7 @@</span> <span class="p_context"> static const struct drm_connector_helper_funcs intel_crt_connector_helper_funcs</span>
 };
 
 static const struct drm_encoder_funcs intel_crt_enc_funcs = {
<span class="p_add">+	.reset = intel_crt_reset,</span>
 	.destroy = intel_encoder_destroy,
 };
 
<span class="p_chunk">@@ -902,5 +920,5 @@</span> <span class="p_context"> void intel_crt_init(struct drm_device *dev)</span>
 		dev_priv-&gt;fdi_rx_config = I915_READ(FDI_RX_CTL(PIPE_A)) &amp; fdi_config;
 	}
 
<span class="p_del">-	intel_crt_reset(connector);</span>
<span class="p_add">+	intel_crt_reset(&amp;crt-&gt;base.base);</span>
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_ddi.c b/drivers/gpu/drm/i915/intel_ddi.c</span>
<span class="p_header">index 01e523df363b..12c4f4356fd9 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_ddi.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_ddi.c</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> static const struct ddi_buf_trans skl_ddi_translations_dp[] = {</span>
 static const struct ddi_buf_trans skl_u_ddi_translations_dp[] = {
 	{ 0x0000201B, 0x000000A2, 0x0 },
 	{ 0x00005012, 0x00000088, 0x0 },
<span class="p_del">-	{ 0x80007011, 0x000000CD, 0x0 },</span>
<span class="p_add">+	{ 0x80007011, 0x000000CD, 0x1 },</span>
 	{ 0x80009010, 0x000000C0, 0x1 },
 	{ 0x0000201B, 0x0000009D, 0x0 },
 	{ 0x80005012, 0x000000C0, 0x1 },
<span class="p_chunk">@@ -158,7 +158,7 @@</span> <span class="p_context"> static const struct ddi_buf_trans skl_u_ddi_translations_dp[] = {</span>
 static const struct ddi_buf_trans skl_y_ddi_translations_dp[] = {
 	{ 0x00000018, 0x000000A2, 0x0 },
 	{ 0x00005012, 0x00000088, 0x0 },
<span class="p_del">-	{ 0x80007011, 0x000000CD, 0x0 },</span>
<span class="p_add">+	{ 0x80007011, 0x000000CD, 0x3 },</span>
 	{ 0x80009010, 0x000000C0, 0x3 },
 	{ 0x00000018, 0x0000009D, 0x0 },
 	{ 0x80005012, 0x000000C0, 0x3 },
<span class="p_chunk">@@ -388,6 +388,40 @@</span> <span class="p_context"> skl_get_buf_trans_hdmi(struct drm_i915_private *dev_priv, int *n_entries)</span>
 	}
 }
 
<span class="p_add">+static int intel_ddi_hdmi_level(struct drm_i915_private *dev_priv, enum port port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int n_hdmi_entries;</span>
<span class="p_add">+	int hdmi_level;</span>
<span class="p_add">+	int hdmi_default_entry;</span>
<span class="p_add">+</span>
<span class="p_add">+	hdmi_level = dev_priv-&gt;vbt.ddi_port_info[port].hdmi_level_shift;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_BROXTON(dev_priv))</span>
<span class="p_add">+		return hdmi_level;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv)) {</span>
<span class="p_add">+		skl_get_buf_trans_hdmi(dev_priv, &amp;n_hdmi_entries);</span>
<span class="p_add">+		hdmi_default_entry = 8;</span>
<span class="p_add">+	} else if (IS_BROADWELL(dev_priv)) {</span>
<span class="p_add">+		n_hdmi_entries = ARRAY_SIZE(bdw_ddi_translations_hdmi);</span>
<span class="p_add">+		hdmi_default_entry = 7;</span>
<span class="p_add">+	} else if (IS_HASWELL(dev_priv)) {</span>
<span class="p_add">+		n_hdmi_entries = ARRAY_SIZE(hsw_ddi_translations_hdmi);</span>
<span class="p_add">+		hdmi_default_entry = 6;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		WARN(1, &quot;ddi translation table missing\n&quot;);</span>
<span class="p_add">+		n_hdmi_entries = ARRAY_SIZE(bdw_ddi_translations_hdmi);</span>
<span class="p_add">+		hdmi_default_entry = 7;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Choose a good default if VBT is badly populated */</span>
<span class="p_add">+	if (hdmi_level == HDMI_LEVEL_SHIFT_UNKNOWN ||</span>
<span class="p_add">+	    hdmi_level &gt;= n_hdmi_entries)</span>
<span class="p_add">+		hdmi_level = hdmi_default_entry;</span>
<span class="p_add">+</span>
<span class="p_add">+	return hdmi_level;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Starting with Haswell, DDI port buffers must be programmed with correct
  * values in advance. The buffer values are different for FDI and DP modes,
<span class="p_chunk">@@ -399,7 +433,7 @@</span> <span class="p_context"> void intel_prepare_ddi_buffer(struct intel_encoder *encoder)</span>
 {
 	struct drm_i915_private *dev_priv = to_i915(encoder-&gt;base.dev);
 	u32 iboost_bit = 0;
<span class="p_del">-	int i, n_hdmi_entries, n_dp_entries, n_edp_entries, hdmi_default_entry,</span>
<span class="p_add">+	int i, n_hdmi_entries, n_dp_entries, n_edp_entries,</span>
 	    size;
 	int hdmi_level;
 	enum port port;
<span class="p_chunk">@@ -410,7 +444,7 @@</span> <span class="p_context"> void intel_prepare_ddi_buffer(struct intel_encoder *encoder)</span>
 	const struct ddi_buf_trans *ddi_translations;
 
 	port = intel_ddi_get_encoder_port(encoder);
<span class="p_del">-	hdmi_level = dev_priv-&gt;vbt.ddi_port_info[port].hdmi_level_shift;</span>
<span class="p_add">+	hdmi_level = intel_ddi_hdmi_level(dev_priv, port);</span>
 
 	if (IS_BROXTON(dev_priv)) {
 		if (encoder-&gt;type != INTEL_OUTPUT_HDMI)
<span class="p_chunk">@@ -430,7 +464,6 @@</span> <span class="p_context"> void intel_prepare_ddi_buffer(struct intel_encoder *encoder)</span>
 				skl_get_buf_trans_edp(dev_priv, &amp;n_edp_entries);
 		ddi_translations_hdmi =
 				skl_get_buf_trans_hdmi(dev_priv, &amp;n_hdmi_entries);
<span class="p_del">-		hdmi_default_entry = 8;</span>
 		/* If we&#39;re boosting the current, set bit 31 of trans1 */
 		if (dev_priv-&gt;vbt.ddi_port_info[port].hdmi_boost_level ||
 		    dev_priv-&gt;vbt.ddi_port_info[port].dp_boost_level)
<span class="p_chunk">@@ -456,7 +489,6 @@</span> <span class="p_context"> void intel_prepare_ddi_buffer(struct intel_encoder *encoder)</span>
 
 		n_dp_entries = ARRAY_SIZE(bdw_ddi_translations_dp);
 		n_hdmi_entries = ARRAY_SIZE(bdw_ddi_translations_hdmi);
<span class="p_del">-		hdmi_default_entry = 7;</span>
 	} else if (IS_HASWELL(dev_priv)) {
 		ddi_translations_fdi = hsw_ddi_translations_fdi;
 		ddi_translations_dp = hsw_ddi_translations_dp;
<span class="p_chunk">@@ -464,7 +496,6 @@</span> <span class="p_context"> void intel_prepare_ddi_buffer(struct intel_encoder *encoder)</span>
 		ddi_translations_hdmi = hsw_ddi_translations_hdmi;
 		n_dp_entries = n_edp_entries = ARRAY_SIZE(hsw_ddi_translations_dp);
 		n_hdmi_entries = ARRAY_SIZE(hsw_ddi_translations_hdmi);
<span class="p_del">-		hdmi_default_entry = 6;</span>
 	} else {
 		WARN(1, &quot;ddi translation table missing\n&quot;);
 		ddi_translations_edp = bdw_ddi_translations_dp;
<span class="p_chunk">@@ -474,7 +505,6 @@</span> <span class="p_context"> void intel_prepare_ddi_buffer(struct intel_encoder *encoder)</span>
 		n_edp_entries = ARRAY_SIZE(bdw_ddi_translations_edp);
 		n_dp_entries = ARRAY_SIZE(bdw_ddi_translations_dp);
 		n_hdmi_entries = ARRAY_SIZE(bdw_ddi_translations_hdmi);
<span class="p_del">-		hdmi_default_entry = 7;</span>
 	}
 
 	switch (encoder-&gt;type) {
<span class="p_chunk">@@ -505,11 +535,6 @@</span> <span class="p_context"> void intel_prepare_ddi_buffer(struct intel_encoder *encoder)</span>
 	if (encoder-&gt;type != INTEL_OUTPUT_HDMI)
 		return;
 
<span class="p_del">-	/* Choose a good default if VBT is badly populated */</span>
<span class="p_del">-	if (hdmi_level == HDMI_LEVEL_SHIFT_UNKNOWN ||</span>
<span class="p_del">-	    hdmi_level &gt;= n_hdmi_entries)</span>
<span class="p_del">-		hdmi_level = hdmi_default_entry;</span>
<span class="p_del">-</span>
 	/* Entry 9 is for HDMI: */
 	I915_WRITE(DDI_BUF_TRANS_LO(port, i),
 		   ddi_translations_hdmi[hdmi_level].trans1 | iboost_bit);
<span class="p_chunk">@@ -1371,14 +1396,30 @@</span> <span class="p_context"> void intel_ddi_disable_pipe_clock(struct intel_crtc *intel_crtc)</span>
 			   TRANS_CLK_SEL_DISABLED);
 }
 
<span class="p_del">-static void skl_ddi_set_iboost(struct drm_i915_private *dev_priv,</span>
<span class="p_del">-			       u32 level, enum port port, int type)</span>
<span class="p_add">+static void _skl_ddi_set_iboost(struct drm_i915_private *dev_priv,</span>
<span class="p_add">+				enum port port, uint8_t iboost)</span>
 {
<span class="p_add">+	u32 tmp;</span>
<span class="p_add">+</span>
<span class="p_add">+	tmp = I915_READ(DISPIO_CR_TX_BMU_CR0);</span>
<span class="p_add">+	tmp &amp;= ~(BALANCE_LEG_MASK(port) | BALANCE_LEG_DISABLE(port));</span>
<span class="p_add">+	if (iboost)</span>
<span class="p_add">+		tmp |= iboost &lt;&lt; BALANCE_LEG_SHIFT(port);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		tmp |= BALANCE_LEG_DISABLE(port);</span>
<span class="p_add">+	I915_WRITE(DISPIO_CR_TX_BMU_CR0, tmp);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void skl_ddi_set_iboost(struct intel_encoder *encoder, u32 level)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct intel_digital_port *intel_dig_port = enc_to_dig_port(&amp;encoder-&gt;base);</span>
<span class="p_add">+	struct drm_i915_private *dev_priv = to_i915(intel_dig_port-&gt;base.base.dev);</span>
<span class="p_add">+	enum port port = intel_dig_port-&gt;port;</span>
<span class="p_add">+	int type = encoder-&gt;type;</span>
 	const struct ddi_buf_trans *ddi_translations;
 	uint8_t iboost;
 	uint8_t dp_iboost, hdmi_iboost;
 	int n_entries;
<span class="p_del">-	u32 reg;</span>
 
 	/* VBT may override standard boost values */
 	dp_iboost = dev_priv-&gt;vbt.ddi_port_info[port].dp_boost_level;
<span class="p_chunk">@@ -1420,16 +1461,10 @@</span> <span class="p_context"> static void skl_ddi_set_iboost(struct drm_i915_private *dev_priv,</span>
 		return;
 	}
 
<span class="p_del">-	reg = I915_READ(DISPIO_CR_TX_BMU_CR0);</span>
<span class="p_del">-	reg &amp;= ~BALANCE_LEG_MASK(port);</span>
<span class="p_del">-	reg &amp;= ~(1 &lt;&lt; (BALANCE_LEG_DISABLE_SHIFT + port));</span>
<span class="p_del">-</span>
<span class="p_del">-	if (iboost)</span>
<span class="p_del">-		reg |= iboost &lt;&lt; BALANCE_LEG_SHIFT(port);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		reg |= 1 &lt;&lt; (BALANCE_LEG_DISABLE_SHIFT + port);</span>
<span class="p_add">+	_skl_ddi_set_iboost(dev_priv, port, iboost);</span>
 
<span class="p_del">-	I915_WRITE(DISPIO_CR_TX_BMU_CR0, reg);</span>
<span class="p_add">+	if (port == PORT_A &amp;&amp; intel_dig_port-&gt;max_lanes == 4)</span>
<span class="p_add">+		_skl_ddi_set_iboost(dev_priv, PORT_E, iboost);</span>
 }
 
 static void bxt_ddi_vswing_sequence(struct drm_i915_private *dev_priv,
<span class="p_chunk">@@ -1560,7 +1595,7 @@</span> <span class="p_context"> uint32_t ddi_signal_levels(struct intel_dp *intel_dp)</span>
 	level = translate_signal_level(signal_levels);
 
 	if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))
<span class="p_del">-		skl_ddi_set_iboost(dev_priv, level, port, encoder-&gt;type);</span>
<span class="p_add">+		skl_ddi_set_iboost(encoder, level);</span>
 	else if (IS_BROXTON(dev_priv))
 		bxt_ddi_vswing_sequence(dev_priv, level, port, encoder-&gt;type);
 
<span class="p_chunk">@@ -1629,6 +1664,10 @@</span> <span class="p_context"> static void intel_ddi_pre_enable(struct intel_encoder *intel_encoder)</span>
 			intel_dp_stop_link_train(intel_dp);
 	} else if (type == INTEL_OUTPUT_HDMI) {
 		struct intel_hdmi *intel_hdmi = enc_to_intel_hdmi(encoder);
<span class="p_add">+		int level = intel_ddi_hdmi_level(dev_priv, port);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (IS_SKYLAKE(dev_priv) || IS_KABYLAKE(dev_priv))</span>
<span class="p_add">+			skl_ddi_set_iboost(intel_encoder, level);</span>
 
 		intel_hdmi-&gt;set_infoframes(encoder,
 					   crtc-&gt;config-&gt;has_hdmi_sink,
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index f7f0f01814f6..94144a70b225 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -1052,7 +1052,7 @@</span> <span class="p_context"> void gen8_irq_power_well_pre_disable(struct drm_i915_private *dev_priv,</span>
 
 /* intel_crt.c */
 void intel_crt_init(struct drm_device *dev);
<span class="p_del">-</span>
<span class="p_add">+void intel_crt_reset(struct drm_encoder *encoder);</span>
 
 /* intel_ddi.c */
 void intel_ddi_clk_select(struct intel_encoder *encoder,
<span class="p_chunk">@@ -1346,6 +1346,8 @@</span> <span class="p_context"> void intel_dsi_init(struct drm_device *dev);</span>
 
 /* intel_dvo.c */
 void intel_dvo_init(struct drm_device *dev);
<span class="p_add">+/* intel_hotplug.c */</span>
<span class="p_add">+void intel_hpd_poll_init(struct drm_i915_private *dev_priv);</span>
 
 
 /* legacy fbdev emulation in intel_fbdev.c */
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_hotplug.c b/drivers/gpu/drm/i915/intel_hotplug.c</span>
<span class="p_header">index bee673005d48..2c49458a9316 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_hotplug.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_hotplug.c</span>
<span class="p_chunk">@@ -453,20 +453,47 @@</span> <span class="p_context"> void intel_hpd_irq_handler(struct drm_device *dev,</span>
  *
  * This is a separate step from interrupt enabling to simplify the locking rules
  * in the driver load and resume code.
<span class="p_add">+ *</span>
<span class="p_add">+ * Also see: intel_hpd_poll_init(), which enables connector polling</span>
  */
 void intel_hpd_init(struct drm_i915_private *dev_priv)
 {
<span class="p_del">-	struct drm_device *dev = dev_priv-&gt;dev;</span>
<span class="p_del">-	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;</span>
<span class="p_del">-	struct drm_connector *connector;</span>
 	int i;
 
 	for_each_hpd_pin(i) {
 		dev_priv-&gt;hotplug.stats[i].count = 0;
 		dev_priv-&gt;hotplug.stats[i].state = HPD_ENABLED;
 	}
<span class="p_add">+</span>
<span class="p_add">+	WRITE_ONCE(dev_priv-&gt;hotplug.poll_enabled, false);</span>
<span class="p_add">+	schedule_work(&amp;dev_priv-&gt;hotplug.poll_init_work);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Interrupt setup is already guaranteed to be single-threaded, this is</span>
<span class="p_add">+	 * just to make the assert_spin_locked checks happy.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_add">+	if (dev_priv-&gt;display.hpd_irq_setup)</span>
<span class="p_add">+		dev_priv-&gt;display.hpd_irq_setup(dev_priv-&gt;dev);</span>
<span class="p_add">+	spin_unlock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void i915_hpd_poll_init_work(struct work_struct *work) {</span>
<span class="p_add">+	struct drm_i915_private *dev_priv =</span>
<span class="p_add">+		container_of(work, struct drm_i915_private,</span>
<span class="p_add">+			     hotplug.poll_init_work);</span>
<span class="p_add">+	struct drm_device *dev = dev_priv-&gt;dev;</span>
<span class="p_add">+	struct drm_mode_config *mode_config = &amp;dev-&gt;mode_config;</span>
<span class="p_add">+	struct drm_connector *connector;</span>
<span class="p_add">+	bool enabled;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;dev-&gt;mode_config.mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	enabled = READ_ONCE(dev_priv-&gt;hotplug.poll_enabled);</span>
<span class="p_add">+</span>
 	list_for_each_entry(connector, &amp;mode_config-&gt;connector_list, head) {
<span class="p_del">-		struct intel_connector *intel_connector = to_intel_connector(connector);</span>
<span class="p_add">+		struct intel_connector *intel_connector =</span>
<span class="p_add">+			to_intel_connector(connector);</span>
 		connector-&gt;polled = intel_connector-&gt;polled;
 
 		/* MST has a dynamic intel_connector-&gt;encoder and it&#39;s reprobing
<span class="p_chunk">@@ -475,24 +502,62 @@</span> <span class="p_context"> void intel_hpd_init(struct drm_i915_private *dev_priv)</span>
 			continue;
 
 		if (!connector-&gt;polled &amp;&amp; I915_HAS_HOTPLUG(dev) &amp;&amp;
<span class="p_del">-		    intel_connector-&gt;encoder-&gt;hpd_pin &gt; HPD_NONE)</span>
<span class="p_del">-			connector-&gt;polled = DRM_CONNECTOR_POLL_HPD;</span>
<span class="p_add">+		    intel_connector-&gt;encoder-&gt;hpd_pin &gt; HPD_NONE) {</span>
<span class="p_add">+			connector-&gt;polled = enabled ?</span>
<span class="p_add">+				DRM_CONNECTOR_POLL_CONNECT |</span>
<span class="p_add">+				DRM_CONNECTOR_POLL_DISCONNECT :</span>
<span class="p_add">+				DRM_CONNECTOR_POLL_HPD;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_add">+	if (enabled)</span>
<span class="p_add">+		drm_kms_helper_poll_enable_locked(dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_unlock(&amp;dev-&gt;mode_config.mutex);</span>
<span class="p_add">+</span>
 	/*
<span class="p_del">-	 * Interrupt setup is already guaranteed to be single-threaded, this is</span>
<span class="p_del">-	 * just to make the assert_spin_locked checks happy.</span>
<span class="p_add">+	 * We might have missed any hotplugs that happened while we were</span>
<span class="p_add">+	 * in the middle of disabling polling</span>
 	 */
<span class="p_del">-	spin_lock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_del">-	if (dev_priv-&gt;display.hpd_irq_setup)</span>
<span class="p_del">-		dev_priv-&gt;display.hpd_irq_setup(dev);</span>
<span class="p_del">-	spin_unlock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_add">+	if (!enabled)</span>
<span class="p_add">+		drm_helper_hpd_irq_event(dev);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * intel_hpd_poll_init - enables/disables polling for connectors with hpd</span>
<span class="p_add">+ * @dev_priv: i915 device instance</span>
<span class="p_add">+ * @enabled: Whether to enable or disable polling</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function enables polling for all connectors, regardless of whether or</span>
<span class="p_add">+ * not they support hotplug detection. Under certain conditions HPD may not be</span>
<span class="p_add">+ * functional. On most Intel GPUs, this happens when we enter runtime suspend.</span>
<span class="p_add">+ * On Valleyview and Cherryview systems, this also happens when we shut off all</span>
<span class="p_add">+ * of the powerwells.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Since this function can get called in contexts where we&#39;re already holding</span>
<span class="p_add">+ * dev-&gt;mode_config.mutex, we do the actual hotplug enabling in a seperate</span>
<span class="p_add">+ * worker.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Also see: intel_hpd_init(), which restores hpd handling.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void intel_hpd_poll_init(struct drm_i915_private *dev_priv)</span>
<span class="p_add">+{</span>
<span class="p_add">+	WRITE_ONCE(dev_priv-&gt;hotplug.poll_enabled, true);</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * We might already be holding dev-&gt;mode_config.mutex, so do this in a</span>
<span class="p_add">+	 * seperate worker</span>
<span class="p_add">+	 * As well, there&#39;s no issue if we race here since we always reschedule</span>
<span class="p_add">+	 * this worker anyway</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	schedule_work(&amp;dev_priv-&gt;hotplug.poll_init_work);</span>
 }
 
 void intel_hpd_init_work(struct drm_i915_private *dev_priv)
 {
 	INIT_WORK(&amp;dev_priv-&gt;hotplug.hotplug_work, i915_hotplug_work_func);
 	INIT_WORK(&amp;dev_priv-&gt;hotplug.dig_port_work, i915_digport_work_func);
<span class="p_add">+	INIT_WORK(&amp;dev_priv-&gt;hotplug.poll_init_work, i915_hpd_poll_init_work);</span>
 	INIT_DELAYED_WORK(&amp;dev_priv-&gt;hotplug.reenable_work,
 			  intel_hpd_irq_storm_reenable_work);
 }
<span class="p_chunk">@@ -509,5 +574,33 @@</span> <span class="p_context"> void intel_hpd_cancel_work(struct drm_i915_private *dev_priv)</span>
 
 	cancel_work_sync(&amp;dev_priv-&gt;hotplug.dig_port_work);
 	cancel_work_sync(&amp;dev_priv-&gt;hotplug.hotplug_work);
<span class="p_add">+	cancel_work_sync(&amp;dev_priv-&gt;hotplug.poll_init_work);</span>
 	cancel_delayed_work_sync(&amp;dev_priv-&gt;hotplug.reenable_work);
 }
<span class="p_add">+</span>
<span class="p_add">+bool intel_hpd_disable(struct drm_i915_private *dev_priv, enum hpd_pin pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool ret = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (pin == HPD_NONE)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_add">+	if (dev_priv-&gt;hotplug.stats[pin].state == HPD_ENABLED) {</span>
<span class="p_add">+		dev_priv-&gt;hotplug.stats[pin].state = HPD_DISABLED;</span>
<span class="p_add">+		ret = true;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void intel_hpd_enable(struct drm_i915_private *dev_priv, enum hpd_pin pin)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (pin == HPD_NONE)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_add">+	dev_priv-&gt;hotplug.stats[pin].state = HPD_ENABLED;</span>
<span class="p_add">+	spin_unlock_irq(&amp;dev_priv-&gt;irq_lock);</span>
<span class="p_add">+}</span>
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_runtime_pm.c b/drivers/gpu/drm/i915/intel_runtime_pm.c</span>
<span class="p_header">index 7fb1da4e7fc3..2592b39ff43b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_runtime_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_runtime_pm.c</span>
<span class="p_chunk">@@ -952,6 +952,7 @@</span> <span class="p_context"> static void vlv_init_display_clock_gating(struct drm_i915_private *dev_priv)</span>
 
 static void vlv_display_power_well_init(struct drm_i915_private *dev_priv)
 {
<span class="p_add">+	struct intel_encoder *encoder;</span>
 	enum pipe pipe;
 
 	/*
<span class="p_chunk">@@ -987,6 +988,12 @@</span> <span class="p_context"> static void vlv_display_power_well_init(struct drm_i915_private *dev_priv)</span>
 
 	intel_hpd_init(dev_priv);
 
<span class="p_add">+	/* Re-enable the ADPA, if we have one */</span>
<span class="p_add">+	for_each_intel_encoder(dev_priv-&gt;dev, encoder) {</span>
<span class="p_add">+		if (encoder-&gt;type == INTEL_OUTPUT_ANALOG)</span>
<span class="p_add">+			intel_crt_reset(&amp;encoder-&gt;base);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	i915_redisable_vga_power_on(dev_priv-&gt;dev);
 }
 
<span class="p_chunk">@@ -1000,6 +1007,8 @@</span> <span class="p_context"> static void vlv_display_power_well_deinit(struct drm_i915_private *dev_priv)</span>
 	synchronize_irq(dev_priv-&gt;dev-&gt;irq);
 
 	vlv_power_sequencer_reset(dev_priv);
<span class="p_add">+</span>
<span class="p_add">+	intel_hpd_poll_init(dev_priv);</span>
 }
 
 static void vlv_display_power_well_enable(struct drm_i915_private *dev_priv,
<span class="p_header">diff --git a/drivers/hwmon/iio_hwmon.c b/drivers/hwmon/iio_hwmon.c</span>
<span class="p_header">index b550ba5fa58a..89449871bca7 100644</span>
<span class="p_header">--- a/drivers/hwmon/iio_hwmon.c</span>
<span class="p_header">+++ b/drivers/hwmon/iio_hwmon.c</span>
<span class="p_chunk">@@ -110,24 +110,24 @@</span> <span class="p_context"> static int iio_hwmon_probe(struct platform_device *pdev)</span>
 
 		switch (type) {
 		case IIO_VOLTAGE:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;in%d_input&quot;,</span>
<span class="p_del">-							  in_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;in%d_input&quot;,</span>
<span class="p_add">+							       in_i++);</span>
 			break;
 		case IIO_TEMP:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;temp%d_input&quot;,</span>
<span class="p_del">-							  temp_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;temp%d_input&quot;,</span>
<span class="p_add">+							       temp_i++);</span>
 			break;
 		case IIO_CURRENT:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;curr%d_input&quot;,</span>
<span class="p_del">-							  curr_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;curr%d_input&quot;,</span>
<span class="p_add">+							       curr_i++);</span>
 			break;
 		case IIO_HUMIDITYRELATIVE:
<span class="p_del">-			a-&gt;dev_attr.attr.name = kasprintf(GFP_KERNEL,</span>
<span class="p_del">-							  &quot;humidity%d_input&quot;,</span>
<span class="p_del">-							  humidity_i++);</span>
<span class="p_add">+			a-&gt;dev_attr.attr.name = devm_kasprintf(dev, GFP_KERNEL,</span>
<span class="p_add">+							       &quot;humidity%d_input&quot;,</span>
<span class="p_add">+							       humidity_i++);</span>
 			break;
 		default:
 			ret = -EINVAL;
<span class="p_header">diff --git a/drivers/hwmon/it87.c b/drivers/hwmon/it87.c</span>
<span class="p_header">index 730d84028260..55bf479349ff 100644</span>
<span class="p_header">--- a/drivers/hwmon/it87.c</span>
<span class="p_header">+++ b/drivers/hwmon/it87.c</span>
<span class="p_chunk">@@ -2015,6 +2015,7 @@</span> <span class="p_context"> static struct attribute *it87_attributes_in[] = {</span>
 	&amp;sensor_dev_attr_in10_input.dev_attr.attr,	/* 41 */
 	&amp;sensor_dev_attr_in11_input.dev_attr.attr,	/* 41 */
 	&amp;sensor_dev_attr_in12_input.dev_attr.attr,	/* 41 */
<span class="p_add">+	NULL</span>
 };
 
 static const struct attribute_group it87_group_in = {
<span class="p_header">diff --git a/drivers/i2c/busses/i2c-cros-ec-tunnel.c b/drivers/i2c/busses/i2c-cros-ec-tunnel.c</span>
<span class="p_header">index a0d95ff682ae..2d5ff86398d0 100644</span>
<span class="p_header">--- a/drivers/i2c/busses/i2c-cros-ec-tunnel.c</span>
<span class="p_header">+++ b/drivers/i2c/busses/i2c-cros-ec-tunnel.c</span>
<span class="p_chunk">@@ -215,7 +215,7 @@</span> <span class="p_context"> static int ec_i2c_xfer(struct i2c_adapter *adap, struct i2c_msg i2c_msgs[],</span>
 	msg-&gt;outsize = request_len;
 	msg-&gt;insize = response_len;
 
<span class="p_del">-	result = cros_ec_cmd_xfer(bus-&gt;ec, msg);</span>
<span class="p_add">+	result = cros_ec_cmd_xfer_status(bus-&gt;ec, msg);</span>
 	if (result &lt; 0) {
 		dev_err(dev, &quot;Error transferring EC i2c message %d\n&quot;, result);
 		goto exit;
<span class="p_header">diff --git a/drivers/i2c/muxes/i2c-demux-pinctrl.c b/drivers/i2c/muxes/i2c-demux-pinctrl.c</span>
<span class="p_header">index 8de073aed001..215ac87f606d 100644</span>
<span class="p_header">--- a/drivers/i2c/muxes/i2c-demux-pinctrl.c</span>
<span class="p_header">+++ b/drivers/i2c/muxes/i2c-demux-pinctrl.c</span>
<span class="p_chunk">@@ -68,7 +68,7 @@</span> <span class="p_context"> static int i2c_demux_activate_master(struct i2c_demux_pinctrl_priv *priv, u32 ne</span>
 	adap = of_find_i2c_adapter_by_node(priv-&gt;chan[new_chan].parent_np);
 	if (!adap) {
 		ret = -ENODEV;
<span class="p_del">-		goto err;</span>
<span class="p_add">+		goto err_with_revert;</span>
 	}
 
 	p = devm_pinctrl_get_select(adap-&gt;dev.parent, priv-&gt;bus_name);
<span class="p_chunk">@@ -103,6 +103,8 @@</span> <span class="p_context"> static int i2c_demux_activate_master(struct i2c_demux_pinctrl_priv *priv, u32 ne</span>
 
  err_with_put:
 	i2c_put_adapter(adap);
<span class="p_add">+ err_with_revert:</span>
<span class="p_add">+	of_changeset_revert(&amp;priv-&gt;chan[new_chan].chgset);</span>
  err:
 	dev_err(priv-&gt;dev, &quot;failed to setup demux-adapter %d (%d)\n&quot;, new_chan, ret);
 	return ret;
<span class="p_header">diff --git a/drivers/iio/industrialio-buffer.c b/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">index 90462fcf5436..49bf9c59f117 100644</span>
<span class="p_header">--- a/drivers/iio/industrialio-buffer.c</span>
<span class="p_header">+++ b/drivers/iio/industrialio-buffer.c</span>
<span class="p_chunk">@@ -107,6 +107,7 @@</span> <span class="p_context"> ssize_t iio_buffer_read_first_n_outer(struct file *filp, char __user *buf,</span>
 {
 	struct iio_dev *indio_dev = filp-&gt;private_data;
 	struct iio_buffer *rb = indio_dev-&gt;buffer;
<span class="p_add">+	DEFINE_WAIT_FUNC(wait, woken_wake_function);</span>
 	size_t datum_size;
 	size_t to_wait;
 	int ret;
<span class="p_chunk">@@ -131,19 +132,29 @@</span> <span class="p_context"> ssize_t iio_buffer_read_first_n_outer(struct file *filp, char __user *buf,</span>
 	else
 		to_wait = min_t(size_t, n / datum_size, rb-&gt;watermark);
 
<span class="p_add">+	add_wait_queue(&amp;rb-&gt;pollq, &amp;wait);</span>
 	do {
<span class="p_del">-		ret = wait_event_interruptible(rb-&gt;pollq,</span>
<span class="p_del">-		      iio_buffer_ready(indio_dev, rb, to_wait, n / datum_size));</span>
<span class="p_del">-		if (ret)</span>
<span class="p_del">-			return ret;</span>
<span class="p_add">+		if (!indio_dev-&gt;info) {</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
 
<span class="p_del">-		if (!indio_dev-&gt;info)</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+		if (!iio_buffer_ready(indio_dev, rb, to_wait, n / datum_size)) {</span>
<span class="p_add">+			if (signal_pending(current)) {</span>
<span class="p_add">+				ret = -ERESTARTSYS;</span>
<span class="p_add">+				break;</span>
<span class="p_add">+			}</span>
<span class="p_add">+</span>
<span class="p_add">+			wait_woken(&amp;wait, TASK_INTERRUPTIBLE,</span>
<span class="p_add">+				   MAX_SCHEDULE_TIMEOUT);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 
 		ret = rb-&gt;access-&gt;read_first_n(rb, n, buf);
 		if (ret == 0 &amp;&amp; (filp-&gt;f_flags &amp; O_NONBLOCK))
 			ret = -EAGAIN;
 	 } while (ret == 0);
<span class="p_add">+	remove_wait_queue(&amp;rb-&gt;pollq, &amp;wait);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/drivers/input/keyboard/tegra-kbc.c b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">index acc5394afb03..29485bc4221c 100644</span>
<span class="p_header">--- a/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_header">+++ b/drivers/input/keyboard/tegra-kbc.c</span>
<span class="p_chunk">@@ -376,7 +376,7 @@</span> <span class="p_context"> static int tegra_kbc_start(struct tegra_kbc *kbc)</span>
 	/* Reset the KBC controller to clear all previous status.*/
 	reset_control_assert(kbc-&gt;rst);
 	udelay(100);
<span class="p_del">-	reset_control_assert(kbc-&gt;rst);</span>
<span class="p_add">+	reset_control_deassert(kbc-&gt;rst);</span>
 	udelay(100);
 
 	tegra_kbc_config_pins(kbc);
<span class="p_header">diff --git a/drivers/input/rmi4/rmi_driver.c b/drivers/input/rmi4/rmi_driver.c</span>
<span class="p_header">index faa295ec4f31..c83bce89028b 100644</span>
<span class="p_header">--- a/drivers/input/rmi4/rmi_driver.c</span>
<span class="p_header">+++ b/drivers/input/rmi4/rmi_driver.c</span>
<span class="p_chunk">@@ -553,7 +553,6 @@</span> <span class="p_context"> int rmi_read_register_desc(struct rmi_device *d, u16 addr,</span>
 		goto free_struct_buff;
 
 	reg = find_first_bit(rdesc-&gt;presense_map, RMI_REG_DESC_PRESENSE_BITS);
<span class="p_del">-	map_offset = 0;</span>
 	for (i = 0; i &lt; rdesc-&gt;num_registers; i++) {
 		struct rmi_register_desc_item *item = &amp;rdesc-&gt;registers[i];
 		int reg_size = struct_buf[offset];
<span class="p_chunk">@@ -576,6 +575,8 @@</span> <span class="p_context"> int rmi_read_register_desc(struct rmi_device *d, u16 addr,</span>
 		item-&gt;reg = reg;
 		item-&gt;reg_size = reg_size;
 
<span class="p_add">+		map_offset = 0;</span>
<span class="p_add">+</span>
 		do {
 			for (b = 0; b &lt; 7; b++) {
 				if (struct_buf[offset] &amp; (0x1 &lt;&lt; b))
<span class="p_header">diff --git a/drivers/input/serio/i8042.c b/drivers/input/serio/i8042.c</span>
<span class="p_header">index 454195709a82..405252a884dd 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042.c</span>
<span class="p_header">+++ b/drivers/input/serio/i8042.c</span>
<span class="p_chunk">@@ -1277,6 +1277,7 @@</span> <span class="p_context"> static int __init i8042_create_kbd_port(void)</span>
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
 	serio-&gt;close		= i8042_port_close;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	strlcpy(serio-&gt;name, &quot;i8042 KBD port&quot;, sizeof(serio-&gt;name));
<span class="p_chunk">@@ -1304,6 +1305,7 @@</span> <span class="p_context"> static int __init i8042_create_aux_port(int idx)</span>
 	serio-&gt;write		= i8042_aux_write;
 	serio-&gt;start		= i8042_start;
 	serio-&gt;stop		= i8042_stop;
<span class="p_add">+	serio-&gt;ps2_cmd_mutex	= &amp;i8042_mutex;</span>
 	serio-&gt;port_data	= port;
 	serio-&gt;dev.parent	= &amp;i8042_platform_device-&gt;dev;
 	if (idx &lt; 0) {
<span class="p_chunk">@@ -1373,21 +1375,6 @@</span> <span class="p_context"> static void i8042_unregister_ports(void)</span>
 	}
 }
 
<span class="p_del">-/*</span>
<span class="p_del">- * Checks whether port belongs to i8042 controller.</span>
<span class="p_del">- */</span>
<span class="p_del">-bool i8042_check_port_owner(const struct serio *port)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int i;</span>
<span class="p_del">-</span>
<span class="p_del">-	for (i = 0; i &lt; I8042_NUM_PORTS; i++)</span>
<span class="p_del">-		if (i8042_ports[i].serio == port)</span>
<span class="p_del">-			return true;</span>
<span class="p_del">-</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-EXPORT_SYMBOL(i8042_check_port_owner);</span>
<span class="p_del">-</span>
 static void i8042_free_irqs(void)
 {
 	if (i8042_aux_irq_registered)
<span class="p_header">diff --git a/drivers/input/serio/libps2.c b/drivers/input/serio/libps2.c</span>
<span class="p_header">index 316f2c897101..83e9c663aa67 100644</span>
<span class="p_header">--- a/drivers/input/serio/libps2.c</span>
<span class="p_header">+++ b/drivers/input/serio/libps2.c</span>
<span class="p_chunk">@@ -56,19 +56,17 @@</span> <span class="p_context"> EXPORT_SYMBOL(ps2_sendbyte);</span>
 
 void ps2_begin_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	mutex_lock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_lock_chip();</span>
<span class="p_add">+	mutex_lock(m);</span>
 }
 EXPORT_SYMBOL(ps2_begin_command);
 
 void ps2_end_command(struct ps2dev *ps2dev)
 {
<span class="p_del">-	if (i8042_check_port_owner(ps2dev-&gt;serio))</span>
<span class="p_del">-		i8042_unlock_chip();</span>
<span class="p_add">+	struct mutex *m = ps2dev-&gt;serio-&gt;ps2_cmd_mutex ?: &amp;ps2dev-&gt;cmd_mutex;</span>
 
<span class="p_del">-	mutex_unlock(&amp;ps2dev-&gt;cmd_mutex);</span>
<span class="p_add">+	mutex_unlock(m);</span>
 }
 EXPORT_SYMBOL(ps2_end_command);
 
<span class="p_header">diff --git a/drivers/iommu/arm-smmu-v3.c b/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_header">index 5f6b3bcab078..46ba2b64b6b3 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu-v3.c</span>
<span class="p_chunk">@@ -879,7 +879,7 @@</span> <span class="p_context"> static void arm_smmu_cmdq_skip_err(struct arm_smmu_device *smmu)</span>
 	 * We may have concurrent producers, so we need to be careful
 	 * not to touch any of the shadow cmdq state.
 	 */
<span class="p_del">-	queue_read(cmd, Q_ENT(q, idx), q-&gt;ent_dwords);</span>
<span class="p_add">+	queue_read(cmd, Q_ENT(q, cons), q-&gt;ent_dwords);</span>
 	dev_err(smmu-&gt;dev, &quot;skipping command in error state:\n&quot;);
 	for (i = 0; i &lt; ARRAY_SIZE(cmd); ++i)
 		dev_err(smmu-&gt;dev, &quot;\t0x%016llx\n&quot;, (unsigned long long)cmd[i]);
<span class="p_chunk">@@ -890,7 +890,7 @@</span> <span class="p_context"> static void arm_smmu_cmdq_skip_err(struct arm_smmu_device *smmu)</span>
 		return;
 	}
 
<span class="p_del">-	queue_write(cmd, Q_ENT(q, idx), q-&gt;ent_dwords);</span>
<span class="p_add">+	queue_write(Q_ENT(q, cons), cmd, q-&gt;ent_dwords);</span>
 }
 
 static void arm_smmu_cmdq_issue_cmd(struct arm_smmu_device *smmu,
<span class="p_chunk">@@ -1034,6 +1034,9 @@</span> <span class="p_context"> static void arm_smmu_write_strtab_ent(struct arm_smmu_device *smmu, u32 sid,</span>
 		case STRTAB_STE_0_CFG_S2_TRANS:
 			ste_live = true;
 			break;
<span class="p_add">+		case STRTAB_STE_0_CFG_ABORT:</span>
<span class="p_add">+			if (disable_bypass)</span>
<span class="p_add">+				break;</span>
 		default:
 			BUG(); /* STE corruption */
 		}
<span class="p_header">diff --git a/drivers/iommu/arm-smmu.c b/drivers/iommu/arm-smmu.c</span>
<span class="p_header">index 9345a3fcb706..31422d440d07 100644</span>
<span class="p_header">--- a/drivers/iommu/arm-smmu.c</span>
<span class="p_header">+++ b/drivers/iommu/arm-smmu.c</span>
<span class="p_chunk">@@ -686,8 +686,7 @@</span> <span class="p_context"> static struct iommu_gather_ops arm_smmu_gather_ops = {</span>
 
 static irqreturn_t arm_smmu_context_fault(int irq, void *dev)
 {
<span class="p_del">-	int flags, ret;</span>
<span class="p_del">-	u32 fsr, fsynr, resume;</span>
<span class="p_add">+	u32 fsr, fsynr;</span>
 	unsigned long iova;
 	struct iommu_domain *domain = dev;
 	struct arm_smmu_domain *smmu_domain = to_smmu_domain(domain);
<span class="p_chunk">@@ -701,34 +700,15 @@</span> <span class="p_context"> static irqreturn_t arm_smmu_context_fault(int irq, void *dev)</span>
 	if (!(fsr &amp; FSR_FAULT))
 		return IRQ_NONE;
 
<span class="p_del">-	if (fsr &amp; FSR_IGN)</span>
<span class="p_del">-		dev_err_ratelimited(smmu-&gt;dev,</span>
<span class="p_del">-				    &quot;Unexpected context fault (fsr 0x%x)\n&quot;,</span>
<span class="p_del">-				    fsr);</span>
<span class="p_del">-</span>
 	fsynr = readl_relaxed(cb_base + ARM_SMMU_CB_FSYNR0);
<span class="p_del">-	flags = fsynr &amp; FSYNR0_WNR ? IOMMU_FAULT_WRITE : IOMMU_FAULT_READ;</span>
<span class="p_del">-</span>
 	iova = readq_relaxed(cb_base + ARM_SMMU_CB_FAR);
<span class="p_del">-	if (!report_iommu_fault(domain, smmu-&gt;dev, iova, flags)) {</span>
<span class="p_del">-		ret = IRQ_HANDLED;</span>
<span class="p_del">-		resume = RESUME_RETRY;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		dev_err_ratelimited(smmu-&gt;dev,</span>
<span class="p_del">-		    &quot;Unhandled context fault: iova=0x%08lx, fsynr=0x%x, cb=%d\n&quot;,</span>
<span class="p_del">-		    iova, fsynr, cfg-&gt;cbndx);</span>
<span class="p_del">-		ret = IRQ_NONE;</span>
<span class="p_del">-		resume = RESUME_TERMINATE;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Clear the faulting FSR */</span>
<span class="p_del">-	writel(fsr, cb_base + ARM_SMMU_CB_FSR);</span>
 
<span class="p_del">-	/* Retry or terminate any stalled transactions */</span>
<span class="p_del">-	if (fsr &amp; FSR_SS)</span>
<span class="p_del">-		writel_relaxed(resume, cb_base + ARM_SMMU_CB_RESUME);</span>
<span class="p_add">+	dev_err_ratelimited(smmu-&gt;dev,</span>
<span class="p_add">+	&quot;Unhandled context fault: fsr=0x%x, iova=0x%08lx, fsynr=0x%x, cb=%d\n&quot;,</span>
<span class="p_add">+			    fsr, iova, fsynr, cfg-&gt;cbndx);</span>
 
<span class="p_del">-	return ret;</span>
<span class="p_add">+	writel(fsr, cb_base + ARM_SMMU_CB_FSR);</span>
<span class="p_add">+	return IRQ_HANDLED;</span>
 }
 
 static irqreturn_t arm_smmu_global_fault(int irq, void *dev)
<span class="p_chunk">@@ -837,7 +817,7 @@</span> <span class="p_context"> static void arm_smmu_init_context_bank(struct arm_smmu_domain *smmu_domain,</span>
 	}
 
 	/* SCTLR */
<span class="p_del">-	reg = SCTLR_CFCFG | SCTLR_CFIE | SCTLR_CFRE | SCTLR_M | SCTLR_EAE_SBOP;</span>
<span class="p_add">+	reg = SCTLR_CFIE | SCTLR_CFRE | SCTLR_M | SCTLR_EAE_SBOP;</span>
 	if (stage1)
 		reg |= SCTLR_S1_ASIDPNE;
 #ifdef __BIG_ENDIAN
<span class="p_header">diff --git a/drivers/iommu/dma-iommu.c b/drivers/iommu/dma-iommu.c</span>
<span class="p_header">index ea5a9ebf0f78..97a23082e18a 100644</span>
<span class="p_header">--- a/drivers/iommu/dma-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/dma-iommu.c</span>
<span class="p_chunk">@@ -68,7 +68,8 @@</span> <span class="p_context"> void iommu_put_dma_cookie(struct iommu_domain *domain)</span>
 	if (!iovad)
 		return;
 
<span class="p_del">-	put_iova_domain(iovad);</span>
<span class="p_add">+	if (iovad-&gt;granule)</span>
<span class="p_add">+		put_iova_domain(iovad);</span>
 	kfree(iovad);
 	domain-&gt;iova_cookie = NULL;
 }
<span class="p_header">diff --git a/drivers/iommu/io-pgtable-arm-v7s.c b/drivers/iommu/io-pgtable-arm-v7s.c</span>
<span class="p_header">index 8c6139986d7d..def8ca1c982d 100644</span>
<span class="p_header">--- a/drivers/iommu/io-pgtable-arm-v7s.c</span>
<span class="p_header">+++ b/drivers/iommu/io-pgtable-arm-v7s.c</span>
<span class="p_chunk">@@ -286,12 +286,14 @@</span> <span class="p_context"> static int arm_v7s_pte_to_prot(arm_v7s_iopte pte, int lvl)</span>
 	int prot = IOMMU_READ;
 	arm_v7s_iopte attr = pte &gt;&gt; ARM_V7S_ATTR_SHIFT(lvl);
 
<span class="p_del">-	if (attr &amp; ARM_V7S_PTE_AP_RDONLY)</span>
<span class="p_add">+	if (!(attr &amp; ARM_V7S_PTE_AP_RDONLY))</span>
 		prot |= IOMMU_WRITE;
 	if ((attr &amp; (ARM_V7S_TEX_MASK &lt;&lt; ARM_V7S_TEX_SHIFT)) == 0)
 		prot |= IOMMU_MMIO;
 	else if (pte &amp; ARM_V7S_ATTR_C)
 		prot |= IOMMU_CACHE;
<span class="p_add">+	if (pte &amp; ARM_V7S_ATTR_XN(lvl))</span>
<span class="p_add">+		prot |= IOMMU_NOEXEC;</span>
 
 	return prot;
 }
<span class="p_header">diff --git a/drivers/md/dm-round-robin.c b/drivers/md/dm-round-robin.c</span>
<span class="p_header">index 4ace1da17db8..6c25213ab38c 100644</span>
<span class="p_header">--- a/drivers/md/dm-round-robin.c</span>
<span class="p_header">+++ b/drivers/md/dm-round-robin.c</span>
<span class="p_chunk">@@ -210,14 +210,17 @@</span> <span class="p_context"> static struct dm_path *rr_select_path(struct path_selector *ps, size_t nr_bytes)</span>
 	struct path_info *pi = NULL;
 	struct dm_path *current_path = NULL;
 
<span class="p_add">+	local_irq_save(flags);</span>
 	current_path = *this_cpu_ptr(s-&gt;current_path);
 	if (current_path) {
 		percpu_counter_dec(&amp;s-&gt;repeat_count);
<span class="p_del">-		if (percpu_counter_read_positive(&amp;s-&gt;repeat_count) &gt; 0)</span>
<span class="p_add">+		if (percpu_counter_read_positive(&amp;s-&gt;repeat_count) &gt; 0) {</span>
<span class="p_add">+			local_irq_restore(flags);</span>
 			return current_path;
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	spin_lock_irqsave(&amp;s-&gt;lock, flags);</span>
<span class="p_add">+	spin_lock(&amp;s-&gt;lock);</span>
 	if (!list_empty(&amp;s-&gt;valid_paths)) {
 		pi = list_entry(s-&gt;valid_paths.next, struct path_info, list);
 		list_move_tail(&amp;pi-&gt;list, &amp;s-&gt;valid_paths);
<span class="p_header">diff --git a/drivers/of/base.c b/drivers/of/base.c</span>
<span class="p_header">index 8bb3d1adf1b0..c6a8f47f505e 100644</span>
<span class="p_header">--- a/drivers/of/base.c</span>
<span class="p_header">+++ b/drivers/of/base.c</span>
<span class="p_chunk">@@ -2318,20 +2318,13 @@</span> <span class="p_context"> struct device_node *of_graph_get_endpoint_by_regs(</span>
 	const struct device_node *parent, int port_reg, int reg)
 {
 	struct of_endpoint endpoint;
<span class="p_del">-	struct device_node *node, *prev_node = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-	while (1) {</span>
<span class="p_del">-		node = of_graph_get_next_endpoint(parent, prev_node);</span>
<span class="p_del">-		of_node_put(prev_node);</span>
<span class="p_del">-		if (!node)</span>
<span class="p_del">-			break;</span>
<span class="p_add">+	struct device_node *node = NULL;</span>
 
<span class="p_add">+	for_each_endpoint_of_node(parent, node) {</span>
 		of_graph_parse_endpoint(node, &amp;endpoint);
 		if (((port_reg == -1) || (endpoint.port == port_reg)) &amp;&amp;
 			((reg == -1) || (endpoint.id == reg)))
 			return node;
<span class="p_del">-</span>
<span class="p_del">-		prev_node = node;</span>
 	}
 
 	return NULL;
<span class="p_header">diff --git a/drivers/pci/msi.c b/drivers/pci/msi.c</span>
<span class="p_header">index a080f4496fe2..565e2a4e6afa 100644</span>
<span class="p_header">--- a/drivers/pci/msi.c</span>
<span class="p_header">+++ b/drivers/pci/msi.c</span>
<span class="p_chunk">@@ -1277,6 +1277,8 @@</span> <span class="p_context"> struct irq_domain *pci_msi_create_irq_domain(struct fwnode_handle *fwnode,</span>
 	if (info-&gt;flags &amp; MSI_FLAG_USE_DEF_CHIP_OPS)
 		pci_msi_domain_update_chip_ops(info);
 
<span class="p_add">+	info-&gt;flags |= MSI_FLAG_ACTIVATE_EARLY;</span>
<span class="p_add">+</span>
 	domain = msi_create_irq_domain(fwnode, info, parent);
 	if (!domain)
 		return NULL;
<span class="p_header">diff --git a/drivers/pinctrl/meson/pinctrl-meson.c b/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_header">index 11623c6b0cb3..44e69c963f5d 100644</span>
<span class="p_header">--- a/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_header">+++ b/drivers/pinctrl/meson/pinctrl-meson.c</span>
<span class="p_chunk">@@ -727,13 +727,7 @@</span> <span class="p_context"> static int meson_pinctrl_probe(struct platform_device *pdev)</span>
 		return PTR_ERR(pc-&gt;pcdev);
 	}
 
<span class="p_del">-	ret = meson_gpiolib_register(pc);</span>
<span class="p_del">-	if (ret) {</span>
<span class="p_del">-		pinctrl_unregister(pc-&gt;pcdev);</span>
<span class="p_del">-		return ret;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return meson_gpiolib_register(pc);</span>
 }
 
 static struct platform_driver meson_pinctrl_driver = {
<span class="p_header">diff --git a/drivers/pinctrl/pinctrl-amd.c b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">index 634b4d30eefb..b3e772390ab6 100644</span>
<span class="p_header">--- a/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_header">+++ b/drivers/pinctrl/pinctrl-amd.c</span>
<span class="p_chunk">@@ -43,17 +43,6 @@</span> <span class="p_context"> static int amd_gpio_direction_input(struct gpio_chip *gc, unsigned offset)</span>
 
 	spin_lock_irqsave(&amp;gpio_dev-&gt;lock, flags);
 	pin_reg = readl(gpio_dev-&gt;base + offset * 4);
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Suppose BIOS or Bootloader sets specific debounce for the</span>
<span class="p_del">-	 * GPIO. if not, set debounce to be  2.75ms and remove glitch.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	if ((pin_reg &amp; DB_TMR_OUT_MASK) == 0) {</span>
<span class="p_del">-		pin_reg |= 0xf;</span>
<span class="p_del">-		pin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);</span>
<span class="p_del">-		pin_reg |= DB_TYPE_REMOVE_GLITCH &lt;&lt; DB_CNTRL_OFF;</span>
<span class="p_del">-		pin_reg &amp;= ~BIT(DB_TMR_LARGE_OFF);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	pin_reg &amp;= ~BIT(OUTPUT_ENABLE_OFF);
 	writel(pin_reg, gpio_dev-&gt;base + offset * 4);
 	spin_unlock_irqrestore(&amp;gpio_dev-&gt;lock, flags);
<span class="p_chunk">@@ -326,15 +315,6 @@</span> <span class="p_context"> static void amd_gpio_irq_enable(struct irq_data *d)</span>
 
 	spin_lock_irqsave(&amp;gpio_dev-&gt;lock, flags);
 	pin_reg = readl(gpio_dev-&gt;base + (d-&gt;hwirq)*4);
<span class="p_del">-	/*</span>
<span class="p_del">-		Suppose BIOS or Bootloader sets specific debounce for the</span>
<span class="p_del">-		GPIO. if not, set debounce to be  2.75ms.</span>
<span class="p_del">-	*/</span>
<span class="p_del">-	if ((pin_reg &amp; DB_TMR_OUT_MASK) == 0) {</span>
<span class="p_del">-		pin_reg |= 0xf;</span>
<span class="p_del">-		pin_reg |= BIT(DB_TMR_OUT_UNIT_OFF);</span>
<span class="p_del">-		pin_reg &amp;= ~BIT(DB_TMR_LARGE_OFF);</span>
<span class="p_del">-	}</span>
 	pin_reg |= BIT(INTERRUPT_ENABLE_OFF);
 	pin_reg |= BIT(INTERRUPT_MASK_OFF);
 	writel(pin_reg, gpio_dev-&gt;base + (d-&gt;hwirq)*4);
<span class="p_header">diff --git a/drivers/platform/chrome/cros_ec_proto.c b/drivers/platform/chrome/cros_ec_proto.c</span>
<span class="p_header">index b6e161f71b26..6c084b266651 100644</span>
<span class="p_header">--- a/drivers/platform/chrome/cros_ec_proto.c</span>
<span class="p_header">+++ b/drivers/platform/chrome/cros_ec_proto.c</span>
<span class="p_chunk">@@ -380,3 +380,20 @@</span> <span class="p_context"> int cros_ec_cmd_xfer(struct cros_ec_device *ec_dev,</span>
 	return ret;
 }
 EXPORT_SYMBOL(cros_ec_cmd_xfer);
<span class="p_add">+</span>
<span class="p_add">+int cros_ec_cmd_xfer_status(struct cros_ec_device *ec_dev,</span>
<span class="p_add">+			    struct cros_ec_command *msg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = cros_ec_cmd_xfer(ec_dev, msg);</span>
<span class="p_add">+	if (ret &lt; 0) {</span>
<span class="p_add">+		dev_err(ec_dev-&gt;dev, &quot;Command xfer error (err:%d)\n&quot;, ret);</span>
<span class="p_add">+	} else if (msg-&gt;result != EC_RES_SUCCESS) {</span>
<span class="p_add">+		dev_dbg(ec_dev-&gt;dev, &quot;Command result (err: %d)\n&quot;, msg-&gt;result);</span>
<span class="p_add">+		return -EPROTO;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(cros_ec_cmd_xfer_status);</span>
<span class="p_header">diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c</span>
<span class="p_header">index 8973d34ce5ba..fb1b56a71475 100644</span>
<span class="p_header">--- a/drivers/s390/block/dasd.c</span>
<span class="p_header">+++ b/drivers/s390/block/dasd.c</span>
<span class="p_chunk">@@ -1643,9 +1643,18 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	u8 *sense = NULL;
 	int expires;
 
<span class="p_add">+	cqr = (struct dasd_ccw_req *) intparm;</span>
 	if (IS_ERR(irb)) {
 		switch (PTR_ERR(irb)) {
 		case -EIO:
<span class="p_add">+			if (cqr &amp;&amp; cqr-&gt;status == DASD_CQR_CLEAR_PENDING) {</span>
<span class="p_add">+				device = (struct dasd_device *) cqr-&gt;startdev;</span>
<span class="p_add">+				cqr-&gt;status = DASD_CQR_CLEARED;</span>
<span class="p_add">+				dasd_device_clear_timer(device);</span>
<span class="p_add">+				wake_up(&amp;dasd_flush_wq);</span>
<span class="p_add">+				dasd_schedule_device_bh(device);</span>
<span class="p_add">+				return;</span>
<span class="p_add">+			}</span>
 			break;
 		case -ETIMEDOUT:
 			DBF_EVENT_DEVID(DBF_WARNING, cdev, &quot;%s: &quot;
<span class="p_chunk">@@ -1661,7 +1670,6 @@</span> <span class="p_context"> void dasd_int_handler(struct ccw_device *cdev, unsigned long intparm,</span>
 	}
 
 	now = get_tod_clock();
<span class="p_del">-	cqr = (struct dasd_ccw_req *) intparm;</span>
 	/* check for conditions that should be handled immediately */
 	if (!cqr ||
 	    !(scsw_dstat(&amp;irb-&gt;scsw) == (DEV_STAT_CHN_END | DEV_STAT_DEV_END) &amp;&amp;
<span class="p_header">diff --git a/drivers/scsi/aacraid/commctrl.c b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">index 4b3bb52b5108..c424e8bc2e31 100644</span>
<span class="p_header">--- a/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_header">+++ b/drivers/scsi/aacraid/commctrl.c</span>
<span class="p_chunk">@@ -63,7 +63,7 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	struct fib *fibptr;
 	struct hw_fib * hw_fib = (struct hw_fib *)0;
 	dma_addr_t hw_fib_pa = (dma_addr_t)0LL;
<span class="p_del">-	unsigned size;</span>
<span class="p_add">+	unsigned int size, osize;</span>
 	int retval;
 
 	if (dev-&gt;in_reset) {
<span class="p_chunk">@@ -87,7 +87,8 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 	 *	will not overrun the buffer when we copy the memory. Return
 	 *	an error if we would.
 	 */
<span class="p_del">-	size = le16_to_cpu(kfib-&gt;header.Size) + sizeof(struct aac_fibhdr);</span>
<span class="p_add">+	osize = size = le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr);</span>
 	if (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))
 		size = le16_to_cpu(kfib-&gt;header.SenderSize);
 	if (size &gt; dev-&gt;max_fib_size) {
<span class="p_chunk">@@ -118,6 +119,14 @@</span> <span class="p_context"> static int ioctl_send_fib(struct aac_dev * dev, void __user *arg)</span>
 		goto cleanup;
 	}
 
<span class="p_add">+	/* Sanity check the second copy */</span>
<span class="p_add">+	if ((osize != le16_to_cpu(kfib-&gt;header.Size) +</span>
<span class="p_add">+		sizeof(struct aac_fibhdr))</span>
<span class="p_add">+		|| (size &lt; le16_to_cpu(kfib-&gt;header.SenderSize))) {</span>
<span class="p_add">+		retval = -EINVAL;</span>
<span class="p_add">+		goto cleanup;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	if (kfib-&gt;header.Command == cpu_to_le16(TakeABreakPt)) {
 		aac_adapter_interrupt(dev);
 		/*
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 2dab3dc2aa69..c1ed25adb17e 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -5037,7 +5037,7 @@</span> <span class="p_context"> static int megasas_init_fw(struct megasas_instance *instance)</span>
 	/* Find first memory bar */
 	bar_list = pci_select_bars(instance-&gt;pdev, IORESOURCE_MEM);
 	instance-&gt;bar = find_first_bit(&amp;bar_list, sizeof(unsigned long));
<span class="p_del">-	if (pci_request_selected_regions(instance-&gt;pdev, instance-&gt;bar,</span>
<span class="p_add">+	if (pci_request_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar,</span>
 					 &quot;megasas: LSI&quot;)) {
 		dev_printk(KERN_DEBUG, &amp;instance-&gt;pdev-&gt;dev, &quot;IO memory region busy!\n&quot;);
 		return -EBUSY;
<span class="p_chunk">@@ -5339,7 +5339,7 @@</span> <span class="p_context"> fail_ready_state:</span>
 	iounmap(instance-&gt;reg_set);
 
       fail_ioremap:
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 
 	return -EINVAL;
 }
<span class="p_chunk">@@ -5360,7 +5360,7 @@</span> <span class="p_context"> static void megasas_release_mfi(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_fusion.c b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">index ec837544f784..52d8bbf7feb5 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_fusion.c</span>
<span class="p_chunk">@@ -2603,7 +2603,7 @@</span> <span class="p_context"> megasas_release_fusion(struct megasas_instance *instance)</span>
 
 	iounmap(instance-&gt;reg_set);
 
<span class="p_del">-	pci_release_selected_regions(instance-&gt;pdev, instance-&gt;bar);</span>
<span class="p_add">+	pci_release_selected_regions(instance-&gt;pdev, 1&lt;&lt;instance-&gt;bar);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_base.c b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">index 751f13edece0..750f82c339d4 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_base.c</span>
<span class="p_chunk">@@ -2188,6 +2188,17 @@</span> <span class="p_context"> mpt3sas_base_map_resources(struct MPT3SAS_ADAPTER *ioc)</span>
 	} else
 		ioc-&gt;msix96_vector = 0;
 
<span class="p_add">+	if (ioc-&gt;is_warpdrive) {</span>
<span class="p_add">+		ioc-&gt;reply_post_host_index[0] = (resource_size_t __iomem *)</span>
<span class="p_add">+		    &amp;ioc-&gt;chip-&gt;ReplyPostHostIndex;</span>
<span class="p_add">+</span>
<span class="p_add">+		for (i = 1; i &lt; ioc-&gt;cpu_msix_table_sz; i++)</span>
<span class="p_add">+			ioc-&gt;reply_post_host_index[i] =</span>
<span class="p_add">+			(resource_size_t __iomem *)</span>
<span class="p_add">+			((u8 __iomem *)&amp;ioc-&gt;chip-&gt;Doorbell + (0x4000 + ((i - 1)</span>
<span class="p_add">+			* 4)));</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	list_for_each_entry(reply_q, &amp;ioc-&gt;reply_queue_list, list)
 		pr_info(MPT3SAS_FMT &quot;%s: IRQ %d\n&quot;,
 		    reply_q-&gt;name,  ((ioc-&gt;msix_enable) ? &quot;PCI-MSI-X enabled&quot; :
<span class="p_chunk">@@ -5280,17 +5291,6 @@</span> <span class="p_context"> mpt3sas_base_attach(struct MPT3SAS_ADAPTER *ioc)</span>
 	if (r)
 		goto out_free_resources;
 
<span class="p_del">-	if (ioc-&gt;is_warpdrive) {</span>
<span class="p_del">-		ioc-&gt;reply_post_host_index[0] = (resource_size_t __iomem *)</span>
<span class="p_del">-		    &amp;ioc-&gt;chip-&gt;ReplyPostHostIndex;</span>
<span class="p_del">-</span>
<span class="p_del">-		for (i = 1; i &lt; ioc-&gt;cpu_msix_table_sz; i++)</span>
<span class="p_del">-			ioc-&gt;reply_post_host_index[i] =</span>
<span class="p_del">-			(resource_size_t __iomem *)</span>
<span class="p_del">-			((u8 __iomem *)&amp;ioc-&gt;chip-&gt;Doorbell + (0x4000 + ((i - 1)</span>
<span class="p_del">-			* 4)));</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	pci_set_drvdata(ioc-&gt;pdev, ioc-&gt;shost);
 	r = _base_get_ioc_facts(ioc, CAN_SLEEP);
 	if (r)
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/comedi_test.c b/drivers/staging/comedi/drivers/comedi_test.c</span>
<span class="p_header">index 4ab186669f0c..ec5b9a23494d 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/comedi_test.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/comedi_test.c</span>
<span class="p_chunk">@@ -56,11 +56,6 @@</span> <span class="p_context"></span>
 
 #define N_CHANS 8
 
<span class="p_del">-enum waveform_state_bits {</span>
<span class="p_del">-	WAVEFORM_AI_RUNNING,</span>
<span class="p_del">-	WAVEFORM_AO_RUNNING</span>
<span class="p_del">-};</span>
<span class="p_del">-</span>
 /* Data unique to this driver */
 struct waveform_private {
 	struct timer_list ai_timer;	/* timer for AI commands */
<span class="p_chunk">@@ -68,7 +63,6 @@</span> <span class="p_context"> struct waveform_private {</span>
 	unsigned int wf_amplitude;	/* waveform amplitude in microvolts */
 	unsigned int wf_period;		/* waveform period in microseconds */
 	unsigned int wf_current;	/* current time in waveform period */
<span class="p_del">-	unsigned long state_bits;</span>
 	unsigned int ai_scan_period;	/* AI scan period in usec */
 	unsigned int ai_convert_period;	/* AI conversion period in usec */
 	struct timer_list ao_timer;	/* timer for AO commands */
<span class="p_chunk">@@ -191,10 +185,6 @@</span> <span class="p_context"> static void waveform_ai_timer(unsigned long arg)</span>
 	unsigned int nsamples;
 	unsigned int time_increment;
 
<span class="p_del">-	/* check command is still active */</span>
<span class="p_del">-	if (!test_bit(WAVEFORM_AI_RUNNING, &amp;devpriv-&gt;state_bits))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	now = ktime_to_us(ktime_get());
 	nsamples = comedi_nsamples_left(s, UINT_MAX);
 
<span class="p_chunk">@@ -386,11 +376,6 @@</span> <span class="p_context"> static int waveform_ai_cmd(struct comedi_device *dev,</span>
 	 */
 	devpriv-&gt;ai_timer.expires =
 		jiffies + usecs_to_jiffies(devpriv-&gt;ai_convert_period) + 1;
<span class="p_del">-</span>
<span class="p_del">-	/* mark command as active */</span>
<span class="p_del">-	smp_mb__before_atomic();</span>
<span class="p_del">-	set_bit(WAVEFORM_AI_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
 	add_timer(&amp;devpriv-&gt;ai_timer);
 	return 0;
 }
<span class="p_chunk">@@ -400,11 +385,12 @@</span> <span class="p_context"> static int waveform_ai_cancel(struct comedi_device *dev,</span>
 {
 	struct waveform_private *devpriv = dev-&gt;private;
 
<span class="p_del">-	/* mark command as no longer active */</span>
<span class="p_del">-	clear_bit(WAVEFORM_AI_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
<span class="p_del">-	/* cannot call del_timer_sync() as may be called from timer routine */</span>
<span class="p_del">-	del_timer(&amp;devpriv-&gt;ai_timer);</span>
<span class="p_add">+	if (in_softirq()) {</span>
<span class="p_add">+		/* Assume we were called from the timer routine itself. */</span>
<span class="p_add">+		del_timer(&amp;devpriv-&gt;ai_timer);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		del_timer_sync(&amp;devpriv-&gt;ai_timer);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -436,10 +422,6 @@</span> <span class="p_context"> static void waveform_ao_timer(unsigned long arg)</span>
 	u64 scans_since;
 	unsigned int scans_avail = 0;
 
<span class="p_del">-	/* check command is still active */</span>
<span class="p_del">-	if (!test_bit(WAVEFORM_AO_RUNNING, &amp;devpriv-&gt;state_bits))</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
 	/* determine number of scan periods since last time */
 	now = ktime_to_us(ktime_get());
 	scans_since = now - devpriv-&gt;ao_last_scan_time;
<span class="p_chunk">@@ -518,11 +500,6 @@</span> <span class="p_context"> static int waveform_ao_inttrig_start(struct comedi_device *dev,</span>
 	devpriv-&gt;ao_last_scan_time = ktime_to_us(ktime_get());
 	devpriv-&gt;ao_timer.expires =
 		jiffies + usecs_to_jiffies(devpriv-&gt;ao_scan_period);
<span class="p_del">-</span>
<span class="p_del">-	/* mark command as active */</span>
<span class="p_del">-	smp_mb__before_atomic();</span>
<span class="p_del">-	set_bit(WAVEFORM_AO_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
 	add_timer(&amp;devpriv-&gt;ao_timer);
 
 	return 1;
<span class="p_chunk">@@ -608,11 +585,12 @@</span> <span class="p_context"> static int waveform_ao_cancel(struct comedi_device *dev,</span>
 	struct waveform_private *devpriv = dev-&gt;private;
 
 	s-&gt;async-&gt;inttrig = NULL;
<span class="p_del">-	/* mark command as no longer active */</span>
<span class="p_del">-	clear_bit(WAVEFORM_AO_RUNNING, &amp;devpriv-&gt;state_bits);</span>
<span class="p_del">-	smp_mb__after_atomic();</span>
<span class="p_del">-	/* cannot call del_timer_sync() as may be called from timer routine */</span>
<span class="p_del">-	del_timer(&amp;devpriv-&gt;ao_timer);</span>
<span class="p_add">+	if (in_softirq()) {</span>
<span class="p_add">+		/* Assume we were called from the timer routine itself. */</span>
<span class="p_add">+		del_timer(&amp;devpriv-&gt;ao_timer);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		del_timer_sync(&amp;devpriv-&gt;ao_timer);</span>
<span class="p_add">+	}</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/daqboard2000.c b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">index a536a15c1d30..a91ea0235191 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/daqboard2000.c</span>
<span class="p_chunk">@@ -636,7 +636,7 @@</span> <span class="p_context"> static const void *daqboard2000_find_boardinfo(struct comedi_device *dev,</span>
 	const struct daq200_boardtype *board;
 	int i;
 
<span class="p_del">-	if (pcidev-&gt;subsystem_device != PCI_VENDOR_ID_IOTECH)</span>
<span class="p_add">+	if (pcidev-&gt;subsystem_vendor != PCI_VENDOR_ID_IOTECH)</span>
 		return NULL;
 
 	for (i = 0; i &lt; ARRAY_SIZE(boardtypes); i++) {
<span class="p_header">diff --git a/drivers/staging/comedi/drivers/ni_mio_common.c b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">index 8dabb19519a5..0f97d7b611d7 100644</span>
<span class="p_header">--- a/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_header">+++ b/drivers/staging/comedi/drivers/ni_mio_common.c</span>
<span class="p_chunk">@@ -2772,7 +2772,15 @@</span> <span class="p_context"> static int ni_ao_inttrig(struct comedi_device *dev,</span>
 	int i;
 	static const int timeout = 1000;
 
<span class="p_del">-	if (trig_num != cmd-&gt;start_arg)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Require trig_num == cmd-&gt;start_arg when cmd-&gt;start_src == TRIG_INT.</span>
<span class="p_add">+	 * For backwards compatibility, also allow trig_num == 0 when</span>
<span class="p_add">+	 * cmd-&gt;start_src != TRIG_INT (i.e. when cmd-&gt;start_src == TRIG_EXT);</span>
<span class="p_add">+	 * in that case, the internal trigger is being used as a pre-trigger</span>
<span class="p_add">+	 * before the external trigger.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!(trig_num == cmd-&gt;start_arg ||</span>
<span class="p_add">+	      (trig_num == 0 &amp;&amp; cmd-&gt;start_src != TRIG_INT)))</span>
 		return -EINVAL;
 
 	/*
<span class="p_chunk">@@ -5480,7 +5488,7 @@</span> <span class="p_context"> static int ni_E_init(struct comedi_device *dev,</span>
 		s-&gt;maxdata	= (devpriv-&gt;is_m_series) ? 0xffffffff
 							 : 0x00ffffff;
 		s-&gt;insn_read	= ni_tio_insn_read;
<span class="p_del">-		s-&gt;insn_write	= ni_tio_insn_read;</span>
<span class="p_add">+		s-&gt;insn_write	= ni_tio_insn_write;</span>
 		s-&gt;insn_config	= ni_tio_insn_config;
 #ifdef PCIDMA
 		if (dev-&gt;irq &amp;&amp; devpriv-&gt;mite) {
<span class="p_header">diff --git a/drivers/staging/lustre/lustre/llite/namei.c b/drivers/staging/lustre/lustre/llite/namei.c</span>
<span class="p_header">index 5eba0ebae10f..86e40ce39632 100644</span>
<span class="p_header">--- a/drivers/staging/lustre/lustre/llite/namei.c</span>
<span class="p_header">+++ b/drivers/staging/lustre/lustre/llite/namei.c</span>
<span class="p_chunk">@@ -391,6 +391,7 @@</span> <span class="p_context"> static int ll_lookup_it_finish(struct ptlrpc_request *request,</span>
 	struct inode *inode = NULL;
 	__u64 bits = 0;
 	int rc = 0;
<span class="p_add">+	struct dentry *alias;</span>
 
 	/* NB 1 request reference will be taken away by ll_intent_lock()
 	 * when I return
<span class="p_chunk">@@ -415,26 +416,12 @@</span> <span class="p_context"> static int ll_lookup_it_finish(struct ptlrpc_request *request,</span>
 		 */
 	}
 
<span class="p_del">-	/* Only hash *de if it is unhashed (new dentry).</span>
<span class="p_del">-	 * Atoimc_open may passing hashed dentries for open.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (d_unhashed(*de)) {</span>
<span class="p_del">-		struct dentry *alias;</span>
<span class="p_del">-</span>
<span class="p_del">-		alias = ll_splice_alias(inode, *de);</span>
<span class="p_del">-		if (IS_ERR(alias)) {</span>
<span class="p_del">-			rc = PTR_ERR(alias);</span>
<span class="p_del">-			goto out;</span>
<span class="p_del">-		}</span>
<span class="p_del">-		*de = alias;</span>
<span class="p_del">-	} else if (!it_disposition(it, DISP_LOOKUP_NEG)  &amp;&amp;</span>
<span class="p_del">-		   !it_disposition(it, DISP_OPEN_CREATE)) {</span>
<span class="p_del">-		/* With DISP_OPEN_CREATE dentry will be</span>
<span class="p_del">-		 * instantiated in ll_create_it.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		LASSERT(!d_inode(*de));</span>
<span class="p_del">-		d_instantiate(*de, inode);</span>
<span class="p_add">+	alias = ll_splice_alias(inode, *de);</span>
<span class="p_add">+	if (IS_ERR(alias)) {</span>
<span class="p_add">+		rc = PTR_ERR(alias);</span>
<span class="p_add">+		goto out;</span>
 	}
<span class="p_add">+	*de = alias;</span>
 
 	if (!it_disposition(it, DISP_LOOKUP_NEG)) {
 		/* we have lookup look - unhide dentry */
<span class="p_chunk">@@ -590,6 +577,24 @@</span> <span class="p_context"> static int ll_atomic_open(struct inode *dir, struct dentry *dentry,</span>
 	       dentry, PFID(ll_inode2fid(dir)), dir, file, open_flags, mode,
 	       *opened);
 
<span class="p_add">+	/* Only negative dentries enter here */</span>
<span class="p_add">+	LASSERT(!d_inode(dentry));</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!d_in_lookup(dentry)) {</span>
<span class="p_add">+		/* A valid negative dentry that just passed revalidation,</span>
<span class="p_add">+		 * there&#39;s little point to try and open it server-side,</span>
<span class="p_add">+		 * even though there&#39;s a minuscle chance it might succeed.</span>
<span class="p_add">+		 * Either way it&#39;s a valid race to just return -ENOENT here.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!(open_flags &amp; O_CREAT))</span>
<span class="p_add">+			return -ENOENT;</span>
<span class="p_add">+</span>
<span class="p_add">+		/* Otherwise we just unhash it to be rehashed afresh via</span>
<span class="p_add">+		 * lookup if necessary</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		d_drop(dentry);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	it = kzalloc(sizeof(*it), GFP_NOFS);
 	if (!it)
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/usb/chipidea/udc.c b/drivers/usb/chipidea/udc.c</span>
<span class="p_header">index 065f5d97aa67..dfec5a176315 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/udc.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/udc.c</span>
<span class="p_chunk">@@ -1596,8 +1596,11 @@</span> <span class="p_context"> static int ci_udc_pullup(struct usb_gadget *_gadget, int is_on)</span>
 {
 	struct ci_hdrc *ci = container_of(_gadget, struct ci_hdrc, gadget);
 
<span class="p_del">-	/* Data+ pullup controlled by OTG state machine in OTG fsm mode */</span>
<span class="p_del">-	if (ci_otg_is_fsm_mode(ci))</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Data+ pullup controlled by OTG state machine in OTG fsm mode;</span>
<span class="p_add">+	 * and don&#39;t touch Data+ in host mode for dual role config.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ci_otg_is_fsm_mode(ci) || ci-&gt;role == CI_ROLE_HOST)</span>
 		return 0;
 
 	pm_runtime_get_sync(&amp;ci-&gt;gadget.dev);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 94a14f5dc4d4..0a4d54a87f7c 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -1405,7 +1405,6 @@</span> <span class="p_context"> made_compressed_probe:</span>
 	spin_lock_init(&amp;acm-&gt;write_lock);
 	spin_lock_init(&amp;acm-&gt;read_lock);
 	mutex_init(&amp;acm-&gt;mutex);
<span class="p_del">-	acm-&gt;rx_endpoint = usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress);</span>
 	acm-&gt;is_int_ep = usb_endpoint_xfer_int(epread);
 	if (acm-&gt;is_int_ep)
 		acm-&gt;bInterval = epread-&gt;bInterval;
<span class="p_chunk">@@ -1445,14 +1444,14 @@</span> <span class="p_context"> made_compressed_probe:</span>
 		urb-&gt;transfer_dma = rb-&gt;dma;
 		if (acm-&gt;is_int_ep) {
 			usb_fill_int_urb(urb, acm-&gt;dev,
<span class="p_del">-					 acm-&gt;rx_endpoint,</span>
<span class="p_add">+					 usb_rcvintpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					 rb-&gt;base,
 					 acm-&gt;readsize,
 					 acm_read_bulk_callback, rb,
 					 acm-&gt;bInterval);
 		} else {
 			usb_fill_bulk_urb(urb, acm-&gt;dev,
<span class="p_del">-					  acm-&gt;rx_endpoint,</span>
<span class="p_add">+					  usb_rcvbulkpipe(usb_dev, epread-&gt;bEndpointAddress),</span>
 					  rb-&gt;base,
 					  acm-&gt;readsize,
 					  acm_read_bulk_callback, rb);
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.h b/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">index 05ce308d5d2a..1f1eabfd8462 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.h</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.h</span>
<span class="p_chunk">@@ -96,7 +96,6 @@</span> <span class="p_context"> struct acm {</span>
 	struct acm_rb read_buffers[ACM_NR];
 	struct acm_wb *putbuffer;			/* for acm_tty_put_char() */
 	int rx_buflimit;
<span class="p_del">-	int rx_endpoint;</span>
 	spinlock_t read_lock;
 	int write_used;					/* number of non-empty write buffers */
 	int transmitting;
<span class="p_header">diff --git a/drivers/usb/core/config.c b/drivers/usb/core/config.c</span>
<span class="p_header">index 31ccdccd7a04..15ce4ab11688 100644</span>
<span class="p_header">--- a/drivers/usb/core/config.c</span>
<span class="p_header">+++ b/drivers/usb/core/config.c</span>
<span class="p_chunk">@@ -171,6 +171,31 @@</span> <span class="p_context"> static void usb_parse_ss_endpoint_companion(struct device *ddev, int cfgno,</span>
 							ep, buffer, size);
 }
 
<span class="p_add">+static const unsigned short low_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 8,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 0,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 8,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short full_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1023,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 64,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short high_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 64,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+static const unsigned short super_speed_maxpacket_maxes[4] = {</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_CONTROL] = 512,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_ISOC] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_BULK] = 1024,</span>
<span class="p_add">+	[USB_ENDPOINT_XFER_INT] = 1024,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,
     int asnum, struct usb_host_interface *ifp, int num_ep,
     unsigned char *buffer, int size)
<span class="p_chunk">@@ -179,6 +204,8 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	struct usb_endpoint_descriptor *d;
 	struct usb_host_endpoint *endpoint;
 	int n, i, j, retval;
<span class="p_add">+	unsigned int maxp;</span>
<span class="p_add">+	const unsigned short *maxpacket_maxes;</span>
 
 	d = (struct usb_endpoint_descriptor *) buffer;
 	buffer += d-&gt;bLength;
<span class="p_chunk">@@ -286,6 +313,42 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 			endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(8);
 	}
 
<span class="p_add">+	/* Validate the wMaxPacketSize field */</span>
<span class="p_add">+	maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Find the highest legal maxpacket size for this endpoint */</span>
<span class="p_add">+	i = 0;		/* additional transactions per microframe */</span>
<span class="p_add">+	switch (to_usb_device(ddev)-&gt;speed) {</span>
<span class="p_add">+	case USB_SPEED_LOW:</span>
<span class="p_add">+		maxpacket_maxes = low_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_FULL:</span>
<span class="p_add">+		maxpacket_maxes = full_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_HIGH:</span>
<span class="p_add">+		/* Bits 12..11 are allowed only for HS periodic endpoints */</span>
<span class="p_add">+		if (usb_endpoint_xfer_int(d) || usb_endpoint_xfer_isoc(d)) {</span>
<span class="p_add">+			i = maxp &amp; (BIT(12) | BIT(11));</span>
<span class="p_add">+			maxp &amp;= ~i;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		/* fallthrough */</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		maxpacket_maxes = high_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	case USB_SPEED_SUPER:</span>
<span class="p_add">+	case USB_SPEED_SUPER_PLUS:</span>
<span class="p_add">+		maxpacket_maxes = super_speed_maxpacket_maxes;</span>
<span class="p_add">+		break;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	j = maxpacket_maxes[usb_endpoint_type(&amp;endpoint-&gt;desc)];</span>
<span class="p_add">+</span>
<span class="p_add">+	if (maxp &gt; j) {</span>
<span class="p_add">+		dev_warn(ddev, &quot;config %d interface %d altsetting %d endpoint 0x%X has invalid maxpacket %d, setting to %d\n&quot;,</span>
<span class="p_add">+		    cfgno, inum, asnum, d-&gt;bEndpointAddress, maxp, j);</span>
<span class="p_add">+		maxp = j;</span>
<span class="p_add">+		endpoint-&gt;desc.wMaxPacketSize = cpu_to_le16(i | maxp);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Some buggy high speed devices have bulk endpoints using
 	 * maxpacket sizes other than 512.  High speed HCDs may not
<span class="p_chunk">@@ -293,9 +356,6 @@</span> <span class="p_context"> static int usb_parse_endpoint(struct device *ddev, int cfgno, int inum,</span>
 	 */
 	if (to_usb_device(ddev)-&gt;speed == USB_SPEED_HIGH
 			&amp;&amp; usb_endpoint_xfer_bulk(d)) {
<span class="p_del">-		unsigned maxp;</span>
<span class="p_del">-</span>
<span class="p_del">-		maxp = usb_endpoint_maxp(&amp;endpoint-&gt;desc) &amp; 0x07ff;</span>
 		if (maxp != 512)
 			dev_warn(ddev, &quot;config %d interface %d altsetting %d &quot;
 				&quot;bulk endpoint 0x%X has invalid maxpacket %d\n&quot;,
<span class="p_header">diff --git a/drivers/usb/core/devio.c b/drivers/usb/core/devio.c</span>
<span class="p_header">index e9f5043a2167..50b6baa50e11 100644</span>
<span class="p_header">--- a/drivers/usb/core/devio.c</span>
<span class="p_header">+++ b/drivers/usb/core/devio.c</span>
<span class="p_chunk">@@ -241,7 +241,8 @@</span> <span class="p_context"> static int usbdev_mmap(struct file *file, struct vm_area_struct *vma)</span>
 		goto error_decrease_mem;
 	}
 
<span class="p_del">-	mem = usb_alloc_coherent(ps-&gt;dev, size, GFP_USER, &amp;dma_handle);</span>
<span class="p_add">+	mem = usb_alloc_coherent(ps-&gt;dev, size, GFP_USER | __GFP_NOWARN,</span>
<span class="p_add">+			&amp;dma_handle);</span>
 	if (!mem) {
 		ret = -ENOMEM;
 		goto error_free_usbm;
<span class="p_chunk">@@ -1708,11 +1709,17 @@</span> <span class="p_context"> static int proc_do_submiturb(struct usb_dev_state *ps, struct usbdevfs_urb *uurb</span>
 	as-&gt;urb-&gt;start_frame = uurb-&gt;start_frame;
 	as-&gt;urb-&gt;number_of_packets = number_of_packets;
 	as-&gt;urb-&gt;stream_id = stream_id;
<span class="p_del">-	if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_del">-			ps-&gt;dev-&gt;speed == USB_SPEED_HIGH)</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = 1 &lt;&lt; min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ep-&gt;desc.bInterval) {</span>
<span class="p_add">+		if (uurb-&gt;type == USBDEVFS_URB_TYPE_ISO ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed == USB_SPEED_HIGH ||</span>
<span class="p_add">+				ps-&gt;dev-&gt;speed &gt;= USB_SPEED_SUPER)</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = 1 &lt;&lt;</span>
<span class="p_add">+					min(15, ep-&gt;desc.bInterval - 1);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			as-&gt;urb-&gt;interval = ep-&gt;desc.bInterval;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	as-&gt;urb-&gt;context = as;
 	as-&gt;urb-&gt;complete = async_completed;
 	for (totlen = u = 0; u &lt; number_of_packets; u++) {
<span class="p_header">diff --git a/drivers/usb/core/hub.c b/drivers/usb/core/hub.c</span>
<span class="p_header">index bee13517676f..1d5fc32d06d0 100644</span>
<span class="p_header">--- a/drivers/usb/core/hub.c</span>
<span class="p_header">+++ b/drivers/usb/core/hub.c</span>
<span class="p_chunk">@@ -1052,14 +1052,11 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 
 	/* Continue a partial initialization */
 	if (type == HUB_INIT2 || type == HUB_INIT3) {
<span class="p_del">-		device_lock(hub-&gt;intfdev);</span>
<span class="p_add">+		device_lock(&amp;hdev-&gt;dev);</span>
 
 		/* Was the hub disconnected while we were waiting? */
<span class="p_del">-		if (hub-&gt;disconnected) {</span>
<span class="p_del">-			device_unlock(hub-&gt;intfdev);</span>
<span class="p_del">-			kref_put(&amp;hub-&gt;kref, hub_release);</span>
<span class="p_del">-			return;</span>
<span class="p_del">-		}</span>
<span class="p_add">+		if (hub-&gt;disconnected)</span>
<span class="p_add">+			goto disconnected;</span>
 		if (type == HUB_INIT2)
 			goto init2;
 		goto init3;
<span class="p_chunk">@@ -1262,7 +1259,7 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 			queue_delayed_work(system_power_efficient_wq,
 					&amp;hub-&gt;init_work,
 					msecs_to_jiffies(delay));
<span class="p_del">-			device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+			device_unlock(&amp;hdev-&gt;dev);</span>
 			return;		/* Continues at init3: below */
 		} else {
 			msleep(delay);
<span class="p_chunk">@@ -1281,12 +1278,12 @@</span> <span class="p_context"> static void hub_activate(struct usb_hub *hub, enum hub_activation_type type)</span>
 	/* Scan all ports that need attention */
 	kick_hub_wq(hub);
 
<span class="p_del">-	/* Allow autosuspend if it was suppressed */</span>
<span class="p_del">-	if (type &lt;= HUB_INIT3)</span>
<span class="p_add">+	if (type == HUB_INIT2 || type == HUB_INIT3) {</span>
<span class="p_add">+		/* Allow autosuspend if it was suppressed */</span>
<span class="p_add">+ disconnected:</span>
 		usb_autopm_put_interface_async(to_usb_interface(hub-&gt;intfdev));
<span class="p_del">-</span>
<span class="p_del">-	if (type == HUB_INIT2 || type == HUB_INIT3)</span>
<span class="p_del">-		device_unlock(hub-&gt;intfdev);</span>
<span class="p_add">+		device_unlock(&amp;hdev-&gt;dev);</span>
<span class="p_add">+	}</span>
 
 	kref_put(&amp;hub-&gt;kref, hub_release);
 }
<span class="p_chunk">@@ -1315,8 +1312,6 @@</span> <span class="p_context"> static void hub_quiesce(struct usb_hub *hub, enum hub_quiescing_type type)</span>
 	struct usb_device *hdev = hub-&gt;hdev;
 	int i;
 
<span class="p_del">-	cancel_delayed_work_sync(&amp;hub-&gt;init_work);</span>
<span class="p_del">-</span>
 	/* hub_wq and related activity won&#39;t re-trigger */
 	hub-&gt;quiescing = 1;
 
<span class="p_header">diff --git a/drivers/usb/dwc3/dwc3-pci.c b/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_header">index 14196cd416b3..2fd50578b41d 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/dwc3-pci.c</span>
<span class="p_chunk">@@ -37,6 +37,7 @@</span> <span class="p_context"></span>
 #define PCI_DEVICE_ID_INTEL_BXT			0x0aaa
 #define PCI_DEVICE_ID_INTEL_BXT_M		0x1aaa
 #define PCI_DEVICE_ID_INTEL_APL			0x5aaa
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_KBP			0xa2b0</span>
 
 static const struct acpi_gpio_params reset_gpios = { 0, 0, false };
 static const struct acpi_gpio_params cs_gpios = { 1, 0, false };
<span class="p_chunk">@@ -214,6 +215,7 @@</span> <span class="p_context"> static const struct pci_device_id dwc3_pci_id_table[] = {</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BXT), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_BXT_M), },
 	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_APL), },
<span class="p_add">+	{ PCI_DEVICE(PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_INTEL_KBP), },</span>
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_NL_USB), },
 	{  }	/* Terminating Entry */
 };
<span class="p_header">diff --git a/drivers/usb/dwc3/gadget.c b/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">index 716f4f051a0a..05a5300aa1ab 100644</span>
<span class="p_header">--- a/drivers/usb/dwc3/gadget.c</span>
<span class="p_header">+++ b/drivers/usb/dwc3/gadget.c</span>
<span class="p_chunk">@@ -1897,7 +1897,8 @@</span> <span class="p_context"> static void dwc3_gadget_free_endpoints(struct dwc3 *dwc)</span>
 
 static int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,
 		struct dwc3_request *req, struct dwc3_trb *trb,
<span class="p_del">-		const struct dwc3_event_depevt *event, int status)</span>
<span class="p_add">+		const struct dwc3_event_depevt *event, int status,</span>
<span class="p_add">+		int chain)</span>
 {
 	unsigned int		count;
 	unsigned int		s_pkt = 0;
<span class="p_chunk">@@ -1905,6 +1906,19 @@</span> <span class="p_context"> static int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 
 	trace_dwc3_complete_trb(dep, trb);
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If we&#39;re in the middle of series of chained TRBs and we</span>
<span class="p_add">+	 * receive a short transfer along the way, DWC3 will skip</span>
<span class="p_add">+	 * through all TRBs including the last TRB in the chain (the</span>
<span class="p_add">+	 * where CHN bit is zero. DWC3 will also avoid clearing HWO</span>
<span class="p_add">+	 * bit and SW has to do it manually.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * We&#39;re going to do that here to avoid problems of HW trying</span>
<span class="p_add">+	 * to use bogus TRBs for transfers.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (chain &amp;&amp; (trb-&gt;ctrl &amp; DWC3_TRB_CTRL_HWO))</span>
<span class="p_add">+		trb-&gt;ctrl &amp;= ~DWC3_TRB_CTRL_HWO;</span>
<span class="p_add">+</span>
 	if ((trb-&gt;ctrl &amp; DWC3_TRB_CTRL_HWO) &amp;&amp; status != -ESHUTDOWN)
 		/*
 		 * We continue despite the error. There is not much we
<span class="p_chunk">@@ -1916,6 +1930,7 @@</span> <span class="p_context"> static int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 		 */
 		dev_err(dwc-&gt;dev, &quot;%s&#39;s TRB (%p) still owned by HW\n&quot;,
 				dep-&gt;name, trb);
<span class="p_add">+</span>
 	count = trb-&gt;size &amp; DWC3_TRB_SIZE_MASK;
 
 	if (dep-&gt;direction) {
<span class="p_chunk">@@ -1954,15 +1969,7 @@</span> <span class="p_context"> static int __dwc3_cleanup_done_trbs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 			s_pkt = 1;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We assume here we will always receive the entire data block</span>
<span class="p_del">-	 * which we should receive. Meaning, if we program RX to</span>
<span class="p_del">-	 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_del">-	 * should receive and we simply bounce the request back to the</span>
<span class="p_del">-	 * gadget driver for further processing.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	req-&gt;request.actual += req-&gt;request.length - count;</span>
<span class="p_del">-	if (s_pkt)</span>
<span class="p_add">+	if (s_pkt &amp;&amp; !chain)</span>
 		return 1;
 	if ((event-&gt;status &amp; DEPEVT_STATUS_LST) &amp;&amp;
 			(trb-&gt;ctrl &amp; (DWC3_TRB_CTRL_LST |
<span class="p_chunk">@@ -1981,13 +1988,17 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 	struct dwc3_trb		*trb;
 	unsigned int		slot;
 	unsigned int		i;
<span class="p_add">+	int			count = 0;</span>
 	int			ret;
 
 	do {
<span class="p_add">+		int chain;</span>
<span class="p_add">+</span>
 		req = next_request(&amp;dep-&gt;started_list);
 		if (WARN_ON_ONCE(!req))
 			return 1;
 
<span class="p_add">+		chain = req-&gt;request.num_mapped_sgs &gt; 0;</span>
 		i = 0;
 		do {
 			slot = req-&gt;first_trb_index + i;
<span class="p_chunk">@@ -1995,13 +2006,22 @@</span> <span class="p_context"> static int dwc3_cleanup_done_reqs(struct dwc3 *dwc, struct dwc3_ep *dep,</span>
 				slot++;
 			slot %= DWC3_TRB_NUM;
 			trb = &amp;dep-&gt;trb_pool[slot];
<span class="p_add">+			count += trb-&gt;size &amp; DWC3_TRB_SIZE_MASK;</span>
 
 			ret = __dwc3_cleanup_done_trbs(dwc, dep, req, trb,
<span class="p_del">-					event, status);</span>
<span class="p_add">+					event, status, chain);</span>
 			if (ret)
 				break;
 		} while (++i &lt; req-&gt;request.num_mapped_sgs);
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We assume here we will always receive the entire data block</span>
<span class="p_add">+		 * which we should receive. Meaning, if we program RX to</span>
<span class="p_add">+		 * receive 4K but we receive only 2K, we assume that&#39;s all we</span>
<span class="p_add">+		 * should receive and we simply bounce the request back to the</span>
<span class="p_add">+		 * gadget driver for further processing.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		req-&gt;request.actual += req-&gt;request.length - count;</span>
 		dwc3_gadget_giveback(dep, req, status);
 
 		if (ret)
<span class="p_header">diff --git a/drivers/usb/gadget/legacy/inode.c b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">index aa3707bdebb4..be6479830221 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/legacy/inode.c</span>
<span class="p_chunk">@@ -542,7 +542,7 @@</span> <span class="p_context"> static ssize_t ep_aio(struct kiocb *iocb,</span>
 	 */
 	spin_lock_irq(&amp;epdata-&gt;dev-&gt;lock);
 	value = -ENODEV;
<span class="p_del">-	if (unlikely(epdata-&gt;ep))</span>
<span class="p_add">+	if (unlikely(epdata-&gt;ep == NULL))</span>
 		goto fail;
 
 	req = usb_ep_alloc_request(epdata-&gt;ep, GFP_ATOMIC);
<span class="p_header">diff --git a/drivers/usb/gadget/udc/fsl_qe_udc.c b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">index 93d28cb00b76..cf8819a5c5b2 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/fsl_qe_udc.c</span>
<span class="p_chunk">@@ -2053,7 +2053,7 @@</span> <span class="p_context"> static void setup_received_handle(struct qe_udc *udc,</span>
 			struct qe_ep *ep;
 
 			if (wValue != 0 || wLength != 0
<span class="p_del">-				|| pipe &gt; USB_MAX_ENDPOINTS)</span>
<span class="p_add">+				|| pipe &gt;= USB_MAX_ENDPOINTS)</span>
 				break;
 			ep = &amp;udc-&gt;eps[pipe];
 
<span class="p_header">diff --git a/drivers/usb/gadget/udc/udc-core.c b/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_header">index e1b2dcebdc2e..bd4695075bac 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/udc/udc-core.c</span>
<span class="p_chunk">@@ -106,7 +106,7 @@</span> <span class="p_context"> void usb_gadget_unmap_request_by_dev(struct device *dev,</span>
 		return;
 
 	if (req-&gt;num_mapped_sgs) {
<span class="p_del">-		dma_unmap_sg(dev, req-&gt;sg, req-&gt;num_mapped_sgs,</span>
<span class="p_add">+		dma_unmap_sg(dev, req-&gt;sg, req-&gt;num_sgs,</span>
 				is_in ? DMA_TO_DEVICE : DMA_FROM_DEVICE);
 
 		req-&gt;num_mapped_sgs = 0;
<span class="p_header">diff --git a/drivers/usb/host/ehci-hcd.c b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">index a962b89b65a6..1e5f529d51a2 100644</span>
<span class="p_header">--- a/drivers/usb/host/ehci-hcd.c</span>
<span class="p_header">+++ b/drivers/usb/host/ehci-hcd.c</span>
<span class="p_chunk">@@ -332,11 +332,11 @@</span> <span class="p_context"> static void ehci_turn_off_all_ports(struct ehci_hcd *ehci)</span>
 	int	port = HCS_N_PORTS(ehci-&gt;hcs_params);
 
 	while (port--) {
<span class="p_del">-		ehci_writel(ehci, PORT_RWC_BITS,</span>
<span class="p_del">-				&amp;ehci-&gt;regs-&gt;port_status[port]);</span>
 		spin_unlock_irq(&amp;ehci-&gt;lock);
 		ehci_port_power(ehci, port, false);
 		spin_lock_irq(&amp;ehci-&gt;lock);
<span class="p_add">+		ehci_writel(ehci, PORT_RWC_BITS,</span>
<span class="p_add">+				&amp;ehci-&gt;regs-&gt;port_status[port]);</span>
 	}
 }
 
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index d61fcc48099e..730b9fd26685 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -386,6 +386,9 @@</span> <span class="p_context"> static int xhci_stop_device(struct xhci_hcd *xhci, int slot_id, int suspend)</span>
 
 	ret = 0;
 	virt_dev = xhci-&gt;devs[slot_id];
<span class="p_add">+	if (!virt_dev)</span>
<span class="p_add">+		return -ENODEV;</span>
<span class="p_add">+</span>
 	cmd = xhci_alloc_command(xhci, false, true, GFP_NOIO);
 	if (!cmd) {
 		xhci_dbg(xhci, &quot;Couldn&#39;t allocate command structure.\n&quot;);
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index c10972fcc8e4..69f7fabdbb53 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -314,11 +314,12 @@</span> <span class="p_context"> static void xhci_pci_remove(struct pci_dev *dev)</span>
 		usb_remove_hcd(xhci-&gt;shared_hcd);
 		usb_put_hcd(xhci-&gt;shared_hcd);
 	}
<span class="p_del">-	usb_hcd_pci_remove(dev);</span>
 
 	/* Workaround for spurious wakeups at shutdown with HSW */
 	if (xhci-&gt;quirks &amp; XHCI_SPURIOUS_WAKEUP)
 		pci_set_power_state(dev, PCI_D3hot);
<span class="p_add">+</span>
<span class="p_add">+	usb_hcd_pci_remove(dev);</span>
 }
 
 #ifdef CONFIG_PM
<span class="p_header">diff --git a/drivers/usb/host/xhci-ring.c b/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">index d7d502578d79..bc17bcf57bbd 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-ring.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-ring.c</span>
<span class="p_chunk">@@ -1325,12 +1325,6 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 
 	cmd = list_entry(xhci-&gt;cmd_list.next, struct xhci_command, cmd_list);
 
<span class="p_del">-	if (cmd-&gt;command_trb != xhci-&gt;cmd_ring-&gt;dequeue) {</span>
<span class="p_del">-		xhci_err(xhci,</span>
<span class="p_del">-			 &quot;Command completion event does not match command\n&quot;);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	del_timer(&amp;xhci-&gt;cmd_timer);
 
 	trace_xhci_cmd_completion(cmd_trb, (struct xhci_generic_trb *) event);
<span class="p_chunk">@@ -1342,6 +1336,13 @@</span> <span class="p_context"> static void handle_cmd_completion(struct xhci_hcd *xhci,</span>
 		xhci_handle_stopped_cmd_ring(xhci, cmd);
 		return;
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (cmd-&gt;command_trb != xhci-&gt;cmd_ring-&gt;dequeue) {</span>
<span class="p_add">+		xhci_err(xhci,</span>
<span class="p_add">+			 &quot;Command completion event does not match command\n&quot;);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/*
 	 * Host aborted the command ring, check if the current command was
 	 * supposed to be aborted, otherwise continue normally.
<span class="p_header">diff --git a/drivers/usb/misc/usbtest.c b/drivers/usb/misc/usbtest.c</span>
<span class="p_header">index 6b978f04b8d7..5c8210dc6fd9 100644</span>
<span class="p_header">--- a/drivers/usb/misc/usbtest.c</span>
<span class="p_header">+++ b/drivers/usb/misc/usbtest.c</span>
<span class="p_chunk">@@ -585,7 +585,6 @@</span> <span class="p_context"> static void sg_timeout(unsigned long _req)</span>
 {
 	struct usb_sg_request	*req = (struct usb_sg_request *) _req;
 
<span class="p_del">-	req-&gt;status = -ETIMEDOUT;</span>
 	usb_sg_cancel(req);
 }
 
<span class="p_chunk">@@ -616,8 +615,10 @@</span> <span class="p_context"> static int perform_sglist(</span>
 		mod_timer(&amp;sg_timer, jiffies +
 				msecs_to_jiffies(SIMPLE_IO_TIMEOUT));
 		usb_sg_wait(req);
<span class="p_del">-		del_timer_sync(&amp;sg_timer);</span>
<span class="p_del">-		retval = req-&gt;status;</span>
<span class="p_add">+		if (!del_timer_sync(&amp;sg_timer))</span>
<span class="p_add">+			retval = -ETIMEDOUT;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			retval = req-&gt;status;</span>
 
 		/* FIXME check resulting data pattern */
 
<span class="p_chunk">@@ -2602,7 +2603,7 @@</span> <span class="p_context"> usbtest_ioctl(struct usb_interface *intf, unsigned int code, void *buf)</span>
 	ktime_get_ts64(&amp;start);
 
 	retval = usbtest_do_ioctl(intf, param_32);
<span class="p_del">-	if (retval)</span>
<span class="p_add">+	if (retval &lt; 0)</span>
 		goto free_mutex;
 
 	ktime_get_ts64(&amp;end);
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/common.c b/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_header">index baeb7d23bf24..8c81aac09d71 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/common.c</span>
<span class="p_chunk">@@ -514,7 +514,8 @@</span> <span class="p_context"> static struct renesas_usbhs_platform_info *usbhs_parse_dt(struct device *dev)</span>
 	if (gpio &gt; 0)
 		dparam-&gt;enable_gpio = gpio;
 
<span class="p_del">-	if (dparam-&gt;type == USBHS_TYPE_RCAR_GEN2)</span>
<span class="p_add">+	if (dparam-&gt;type == USBHS_TYPE_RCAR_GEN2 ||</span>
<span class="p_add">+	    dparam-&gt;type == USBHS_TYPE_RCAR_GEN3)</span>
 		dparam-&gt;has_usb_dmac = 1;
 
 	return info;
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/fifo.c b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">index 280ed5ff021b..857e78337324 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/fifo.c</span>
<span class="p_chunk">@@ -871,7 +871,7 @@</span> <span class="p_context"> static int usbhsf_dma_prepare_push(struct usbhs_pkt *pkt, int *is_done)</span>
 
 	/* use PIO if packet is less than pio_dma_border or pipe is DCP */
 	if ((len &lt; usbhs_get_dparam(priv, pio_dma_border)) ||
<span class="p_del">-	    usbhs_pipe_is_dcp(pipe))</span>
<span class="p_add">+	    usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC))</span>
 		goto usbhsf_pio_prepare_push;
 
 	/* check data length if this driver don&#39;t use USB-DMAC */
<span class="p_chunk">@@ -976,7 +976,7 @@</span> <span class="p_context"> static int usbhsf_dma_prepare_pop_with_usb_dmac(struct usbhs_pkt *pkt,</span>
 
 	/* use PIO if packet is less than pio_dma_border or pipe is DCP */
 	if ((pkt-&gt;length &lt; usbhs_get_dparam(priv, pio_dma_border)) ||
<span class="p_del">-	    usbhs_pipe_is_dcp(pipe))</span>
<span class="p_add">+	    usbhs_pipe_type_is(pipe, USB_ENDPOINT_XFER_ISOC))</span>
 		goto usbhsf_pio_prepare_pop;
 
 	fifo = usbhsf_get_dma_fifo(priv, pkt);
<span class="p_header">diff --git a/drivers/usb/renesas_usbhs/mod_gadget.c b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">index 50f3363cc382..c4c64740a3e7 100644</span>
<span class="p_header">--- a/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_header">+++ b/drivers/usb/renesas_usbhs/mod_gadget.c</span>
<span class="p_chunk">@@ -617,10 +617,13 @@</span> <span class="p_context"> static int usbhsg_ep_enable(struct usb_ep *ep,</span>
 		 * use dmaengine if possible.
 		 * It will use pio handler if impossible.
 		 */
<span class="p_del">-		if (usb_endpoint_dir_in(desc))</span>
<span class="p_add">+		if (usb_endpoint_dir_in(desc)) {</span>
 			pipe-&gt;handler = &amp;usbhs_fifo_dma_push_handler;
<span class="p_del">-		else</span>
<span class="p_add">+		} else {</span>
 			pipe-&gt;handler = &amp;usbhs_fifo_dma_pop_handler;
<span class="p_add">+			usbhs_xxxsts_clear(priv, BRDYSTS,</span>
<span class="p_add">+					   usbhs_pipe_number(pipe));</span>
<span class="p_add">+		}</span>
 
 		ret = 0;
 	}
<span class="p_chunk">@@ -1073,7 +1076,7 @@</span> <span class="p_context"> int usbhs_mod_gadget_probe(struct usbhs_priv *priv)</span>
 
 	gpriv-&gt;transceiver = usb_get_phy(USB_PHY_TYPE_UNDEFINED);
 	dev_info(dev, &quot;%stransceiver found\n&quot;,
<span class="p_del">-		 gpriv-&gt;transceiver ? &quot;&quot; : &quot;no &quot;);</span>
<span class="p_add">+		 !IS_ERR(gpriv-&gt;transceiver) ? &quot;&quot; : &quot;no &quot;);</span>
 
 	/*
 	 * CAUTION
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 00820809139a..b2d767e743fc 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -648,6 +648,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_TFD128_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_FM3RX_PID) },
 	{ USB_DEVICE(FTDI_VID, FTDI_ELV_WS777_PID) },
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_PALMSENS_PID) },</span>
<span class="p_add">+	{ USB_DEVICE(FTDI_VID, FTDI_IVIUM_XSTAT_PID) },</span>
 	{ USB_DEVICE(FTDI_VID, LINX_SDMUSBQSS_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_MASTERDEVEL2_PID) },
 	{ USB_DEVICE(FTDI_VID, LINX_FUTURE_0_PID) },
<span class="p_chunk">@@ -1008,6 +1010,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7560U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },
<span class="p_add">+	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index c5d6c1e73e8e..f87a938cf005 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -406,6 +406,12 @@</span> <span class="p_context"></span>
 #define FTDI_4N_GALAXY_DE_3_PID	0xF3C2
 
 /*
<span class="p_add">+ * Ivium Technologies product IDs</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define FTDI_PALMSENS_PID	0xf440</span>
<span class="p_add">+#define FTDI_IVIUM_XSTAT_PID	0xf441</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Linx Technologies product ids
  */
 #define LINX_SDMUSBQSS_PID	0xF448	/* Linx SDM-USB-QS-S */
<span class="p_chunk">@@ -673,6 +679,12 @@</span> <span class="p_context"></span>
 #define INTREPID_NEOVI_PID	0x0701
 
 /*
<span class="p_add">+ * WICED USB UART</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define WICED_VID		0x0A5C</span>
<span class="p_add">+#define WICED_USB20706V2_PID	0x6422</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Definitions for ID TECH (www.idt-net.com) devices
  */
 #define IDTECH_VID		0x0ACD	/* ID TECH Vendor ID */
<span class="p_header">diff --git a/drivers/usb/serial/mos7720.c b/drivers/usb/serial/mos7720.c</span>
<span class="p_header">index 5608af4a369d..de9992b492b0 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7720.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7720.c</span>
<span class="p_chunk">@@ -1252,7 +1252,7 @@</span> <span class="p_context"> static int mos7720_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 
 	if (urb-&gt;transfer_buffer == NULL) {
 		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,
<span class="p_del">-					       GFP_KERNEL);</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/mos7840.c b/drivers/usb/serial/mos7840.c</span>
<span class="p_header">index ed378fb232e7..57426d703a09 100644</span>
<span class="p_header">--- a/drivers/usb/serial/mos7840.c</span>
<span class="p_header">+++ b/drivers/usb/serial/mos7840.c</span>
<span class="p_chunk">@@ -1340,8 +1340,8 @@</span> <span class="p_context"> static int mos7840_write(struct tty_struct *tty, struct usb_serial_port *port,</span>
 	}
 
 	if (urb-&gt;transfer_buffer == NULL) {
<span class="p_del">-		urb-&gt;transfer_buffer =</span>
<span class="p_del">-		    kmalloc(URB_TRANSFER_BUFFER_SIZE, GFP_KERNEL);</span>
<span class="p_add">+		urb-&gt;transfer_buffer = kmalloc(URB_TRANSFER_BUFFER_SIZE,</span>
<span class="p_add">+					       GFP_ATOMIC);</span>
 		if (!urb-&gt;transfer_buffer)
 			goto exit;
 	}
<span class="p_header">diff --git a/drivers/usb/serial/option.c b/drivers/usb/serial/option.c</span>
<span class="p_header">index 8e07536c233a..9894e341c6ac 100644</span>
<span class="p_header">--- a/drivers/usb/serial/option.c</span>
<span class="p_header">+++ b/drivers/usb/serial/option.c</span>
<span class="p_chunk">@@ -274,6 +274,12 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define TELIT_PRODUCT_LE920			0x1200
 #define TELIT_PRODUCT_LE910			0x1201
 #define TELIT_PRODUCT_LE910_USBCFG4		0x1206
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1207		0x1207</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1208		0x1208</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1211		0x1211</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1212		0x1212</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1213		0x1213</span>
<span class="p_add">+#define TELIT_PRODUCT_LE920A4_1214		0x1214</span>
 
 /* ZTE PRODUCTS */
 #define ZTE_VENDOR_ID				0x19d2
<span class="p_chunk">@@ -519,6 +525,12 @@</span> <span class="p_context"> static void option_instat_callback(struct urb *urb);</span>
 #define VIATELECOM_VENDOR_ID			0x15eb
 #define VIATELECOM_PRODUCT_CDS7			0x0001
 
<span class="p_add">+/* WeTelecom products */</span>
<span class="p_add">+#define WETELECOM_VENDOR_ID			0x22de</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD200		0x6801</span>
<span class="p_add">+#define WETELECOM_PRODUCT_6802			0x6802</span>
<span class="p_add">+#define WETELECOM_PRODUCT_WMD300		0x6803</span>
<span class="p_add">+</span>
 struct option_blacklist_info {
 	/* bitmask of interface numbers blacklisted for send_setup */
 	const unsigned long sendsetup;
<span class="p_chunk">@@ -628,6 +640,11 @@</span> <span class="p_context"> static const struct option_blacklist_info telit_le920_blacklist = {</span>
 	.reserved = BIT(1) | BIT(5),
 };
 
<span class="p_add">+static const struct option_blacklist_info telit_le920a4_blacklist_1 = {</span>
<span class="p_add">+	.sendsetup = BIT(0),</span>
<span class="p_add">+	.reserved = BIT(1),</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct option_blacklist_info telit_le922_blacklist_usbcfg0 = {
 	.sendsetup = BIT(2),
 	.reserved = BIT(0) | BIT(1) | BIT(3),
<span class="p_chunk">@@ -1203,6 +1220,16 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },
 	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920),
 		.driver_info = (kernel_ulong_t)&amp;telit_le920_blacklist },
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1207) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1208),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1211),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1212),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le920a4_blacklist_1 },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_CLASS(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1213, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE(TELIT_VENDOR_ID, TELIT_PRODUCT_LE920A4_1214),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;telit_le922_blacklist_usbcfg3 },</span>
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_MF622, 0xff, 0xff, 0xff) }, /* ZTE WCDMA products */
 	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, 0x0002, 0xff, 0xff, 0xff),
 		.driver_info = (kernel_ulong_t)&amp;net_intf1_blacklist },
<span class="p_chunk">@@ -1966,9 +1993,13 @@</span> <span class="p_context"> static const struct usb_device_id option_ids[] = {</span>
 	  .driver_info = (kernel_ulong_t)&amp;net_intf4_blacklist },
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e01, 0xff, 0xff, 0xff) }, /* D-Link DWM-152/C1 */
 	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x3e02, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/C1 */
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(0x07d1, 0x7e11, 0xff, 0xff, 0xff) }, /* D-Link DWM-156/A3 */</span>
 	{ USB_DEVICE_INTERFACE_CLASS(0x2020, 0x4000, 0xff) },                /* OLICARD300 - MT6225 */
 	{ USB_DEVICE(INOVIA_VENDOR_ID, INOVIA_SEW858) },
 	{ USB_DEVICE(VIATELECOM_VENDOR_ID, VIATELECOM_PRODUCT_CDS7) },
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD200, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_6802, 0xff, 0xff, 0xff) },</span>
<span class="p_add">+	{ USB_DEVICE_AND_INTERFACE_INFO(WETELECOM_VENDOR_ID, WETELECOM_PRODUCT_WMD300, 0xff, 0xff, 0xff) },</span>
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index b1b9bac44016..d213cf44a7e4 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1433,7 +1433,7 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 
 	rc = usb_register(udriver);
 	if (rc)
<span class="p_del">-		return rc;</span>
<span class="p_add">+		goto failed_usb_register;</span>
 
 	for (sd = serial_drivers; *sd; ++sd) {
 		(*sd)-&gt;usb_driver = udriver;
<span class="p_chunk">@@ -1451,6 +1451,8 @@</span> <span class="p_context"> int usb_serial_register_drivers(struct usb_serial_driver *const serial_drivers[]</span>
 	while (sd-- &gt; serial_drivers)
 		usb_serial_deregister(*sd);
 	usb_deregister(udriver);
<span class="p_add">+failed_usb_register:</span>
<span class="p_add">+	kfree(udriver);</span>
 	return rc;
 }
 EXPORT_SYMBOL_GPL(usb_serial_register_drivers);
<span class="p_header">diff --git a/drivers/vfio/pci/vfio_pci_intrs.c b/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_header">index 15ecfc9c5f6c..152b43822ef1 100644</span>
<span class="p_header">--- a/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_header">+++ b/drivers/vfio/pci/vfio_pci_intrs.c</span>
<span class="p_chunk">@@ -564,67 +564,80 @@</span> <span class="p_context"> static int vfio_pci_set_msi_trigger(struct vfio_pci_device *vdev,</span>
 }
 
 static int vfio_pci_set_ctx_trigger_single(struct eventfd_ctx **ctx,
<span class="p_del">-					   uint32_t flags, void *data)</span>
<span class="p_add">+					   unsigned int count, uint32_t flags,</span>
<span class="p_add">+					   void *data)</span>
 {
<span class="p_del">-	int32_t fd = *(int32_t *)data;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (!(flags &amp; VFIO_IRQ_SET_DATA_TYPE_MASK))</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_del">-</span>
 	/* DATA_NONE/DATA_BOOL enables loopback testing */
 	if (flags &amp; VFIO_IRQ_SET_DATA_NONE) {
<span class="p_del">-		if (*ctx)</span>
<span class="p_del">-			eventfd_signal(*ctx, 1);</span>
<span class="p_del">-		return 0;</span>
<span class="p_add">+		if (*ctx) {</span>
<span class="p_add">+			if (count) {</span>
<span class="p_add">+				eventfd_signal(*ctx, 1);</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				eventfd_ctx_put(*ctx);</span>
<span class="p_add">+				*ctx = NULL;</span>
<span class="p_add">+			}</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	} else if (flags &amp; VFIO_IRQ_SET_DATA_BOOL) {
<span class="p_del">-		uint8_t trigger = *(uint8_t *)data;</span>
<span class="p_add">+		uint8_t trigger;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		trigger = *(uint8_t *)data;</span>
 		if (trigger &amp;&amp; *ctx)
 			eventfd_signal(*ctx, 1);
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	/* Handle SET_DATA_EVENTFD */</span>
<span class="p_del">-	if (fd == -1) {</span>
<span class="p_del">-		if (*ctx)</span>
<span class="p_del">-			eventfd_ctx_put(*ctx);</span>
<span class="p_del">-		*ctx = NULL;</span>
 		return 0;
<span class="p_del">-	} else if (fd &gt;= 0) {</span>
<span class="p_del">-		struct eventfd_ctx *efdctx;</span>
<span class="p_del">-		efdctx = eventfd_ctx_fdget(fd);</span>
<span class="p_del">-		if (IS_ERR(efdctx))</span>
<span class="p_del">-			return PTR_ERR(efdctx);</span>
<span class="p_del">-		if (*ctx)</span>
<span class="p_del">-			eventfd_ctx_put(*ctx);</span>
<span class="p_del">-		*ctx = efdctx;</span>
<span class="p_add">+	} else if (flags &amp; VFIO_IRQ_SET_DATA_EVENTFD) {</span>
<span class="p_add">+		int32_t fd;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!count)</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+		fd = *(int32_t *)data;</span>
<span class="p_add">+		if (fd == -1) {</span>
<span class="p_add">+			if (*ctx)</span>
<span class="p_add">+				eventfd_ctx_put(*ctx);</span>
<span class="p_add">+			*ctx = NULL;</span>
<span class="p_add">+		} else if (fd &gt;= 0) {</span>
<span class="p_add">+			struct eventfd_ctx *efdctx;</span>
<span class="p_add">+</span>
<span class="p_add">+			efdctx = eventfd_ctx_fdget(fd);</span>
<span class="p_add">+			if (IS_ERR(efdctx))</span>
<span class="p_add">+				return PTR_ERR(efdctx);</span>
<span class="p_add">+</span>
<span class="p_add">+			if (*ctx)</span>
<span class="p_add">+				eventfd_ctx_put(*ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+			*ctx = efdctx;</span>
<span class="p_add">+		}</span>
 		return 0;
<span class="p_del">-	} else</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return -EINVAL;</span>
 }
 
 static int vfio_pci_set_err_trigger(struct vfio_pci_device *vdev,
 				    unsigned index, unsigned start,
 				    unsigned count, uint32_t flags, void *data)
 {
<span class="p_del">-	if (index != VFIO_PCI_ERR_IRQ_INDEX)</span>
<span class="p_add">+	if (index != VFIO_PCI_ERR_IRQ_INDEX || start != 0 || count &gt; 1)</span>
 		return -EINVAL;
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We should sanitize start &amp; count, but that wasn&#39;t caught</span>
<span class="p_del">-	 * originally, so this IRQ index must forever ignore them :-(</span>
<span class="p_del">-	 */</span>
<span class="p_del">-</span>
<span class="p_del">-	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;err_trigger, flags, data);</span>
<span class="p_add">+	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;err_trigger,</span>
<span class="p_add">+					       count, flags, data);</span>
 }
 
 static int vfio_pci_set_req_trigger(struct vfio_pci_device *vdev,
 				    unsigned index, unsigned start,
 				    unsigned count, uint32_t flags, void *data)
 {
<span class="p_del">-	if (index != VFIO_PCI_REQ_IRQ_INDEX || start != 0 || count != 1)</span>
<span class="p_add">+	if (index != VFIO_PCI_REQ_IRQ_INDEX || start != 0 || count &gt; 1)</span>
 		return -EINVAL;
 
<span class="p_del">-	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;req_trigger, flags, data);</span>
<span class="p_add">+	return vfio_pci_set_ctx_trigger_single(&amp;vdev-&gt;req_trigger,</span>
<span class="p_add">+					       count, flags, data);</span>
 }
 
 int vfio_pci_set_irqs_ioctl(struct vfio_pci_device *vdev, uint32_t flags,
<span class="p_header">diff --git a/drivers/virtio/virtio_ring.c b/drivers/virtio/virtio_ring.c</span>
<span class="p_header">index ca6bfddaacad..2ebf30e57eec 100644</span>
<span class="p_header">--- a/drivers/virtio/virtio_ring.c</span>
<span class="p_header">+++ b/drivers/virtio/virtio_ring.c</span>
<span class="p_chunk">@@ -316,6 +316,8 @@</span> <span class="p_context"> static inline int virtqueue_add(struct virtqueue *_vq,</span>
 		 * host should service the ring ASAP. */
 		if (out_sgs)
 			vq-&gt;notify(&amp;vq-&gt;vq);
<span class="p_add">+		if (indirect)</span>
<span class="p_add">+			kfree(desc);</span>
 		END_USE(vq);
 		return -ENOSPC;
 	}
<span class="p_header">diff --git a/fs/btrfs/ctree.h b/fs/btrfs/ctree.h</span>
<span class="p_header">index 4274a7bfdaed..72f50480eee7 100644</span>
<span class="p_header">--- a/fs/btrfs/ctree.h</span>
<span class="p_header">+++ b/fs/btrfs/ctree.h</span>
<span class="p_chunk">@@ -1040,6 +1040,7 @@</span> <span class="p_context"> struct btrfs_fs_info {</span>
 	struct btrfs_workqueue *qgroup_rescan_workers;
 	struct completion qgroup_rescan_completion;
 	struct btrfs_work qgroup_rescan_work;
<span class="p_add">+	bool qgroup_rescan_running;	/* protected by qgroup_rescan_lock */</span>
 
 	/* filesystem state */
 	unsigned long fs_state;
<span class="p_header">diff --git a/fs/btrfs/disk-io.c b/fs/btrfs/disk-io.c</span>
<span class="p_header">index 60ce1190307b..864cf3be0251 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.c</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.c</span>
<span class="p_chunk">@@ -1626,8 +1626,8 @@</span> <span class="p_context"> fail:</span>
 	return ret;
 }
 
<span class="p_del">-static struct btrfs_root *btrfs_lookup_fs_root(struct btrfs_fs_info *fs_info,</span>
<span class="p_del">-					       u64 root_id)</span>
<span class="p_add">+struct btrfs_root *btrfs_lookup_fs_root(struct btrfs_fs_info *fs_info,</span>
<span class="p_add">+					u64 root_id)</span>
 {
 	struct btrfs_root *root;
 
<span class="p_chunk">@@ -2306,6 +2306,7 @@</span> <span class="p_context"> static void btrfs_init_qgroup(struct btrfs_fs_info *fs_info)</span>
 	fs_info-&gt;quota_enabled = 0;
 	fs_info-&gt;pending_quota_state = 0;
 	fs_info-&gt;qgroup_ulist = NULL;
<span class="p_add">+	fs_info-&gt;qgroup_rescan_running = false;</span>
 	mutex_init(&amp;fs_info-&gt;qgroup_rescan_lock);
 }
 
<span class="p_chunk">@@ -3849,7 +3850,7 @@</span> <span class="p_context"> void close_ctree(struct btrfs_root *root)</span>
 	smp_mb();
 
 	/* wait for the qgroup rescan worker to stop */
<span class="p_del">-	btrfs_qgroup_wait_for_completion(fs_info);</span>
<span class="p_add">+	btrfs_qgroup_wait_for_completion(fs_info, false);</span>
 
 	/* wait for the uuid_scan task to finish */
 	down(&amp;fs_info-&gt;uuid_tree_rescan_sem);
<span class="p_header">diff --git a/fs/btrfs/disk-io.h b/fs/btrfs/disk-io.h</span>
<span class="p_header">index acba821499a9..355e31f90106 100644</span>
<span class="p_header">--- a/fs/btrfs/disk-io.h</span>
<span class="p_header">+++ b/fs/btrfs/disk-io.h</span>
<span class="p_chunk">@@ -68,6 +68,8 @@</span> <span class="p_context"> struct extent_buffer *btrfs_find_tree_block(struct btrfs_fs_info *fs_info,</span>
 struct btrfs_root *btrfs_read_fs_root(struct btrfs_root *tree_root,
 				      struct btrfs_key *location);
 int btrfs_init_fs_root(struct btrfs_root *root);
<span class="p_add">+struct btrfs_root *btrfs_lookup_fs_root(struct btrfs_fs_info *fs_info,</span>
<span class="p_add">+					u64 root_id);</span>
 int btrfs_insert_fs_root(struct btrfs_fs_info *fs_info,
 			 struct btrfs_root *root);
 void btrfs_free_fs_roots(struct btrfs_fs_info *fs_info);
<span class="p_header">diff --git a/fs/btrfs/ioctl.c b/fs/btrfs/ioctl.c</span>
<span class="p_header">index 05173563e4a6..3722a1f65069 100644</span>
<span class="p_header">--- a/fs/btrfs/ioctl.c</span>
<span class="p_header">+++ b/fs/btrfs/ioctl.c</span>
<span class="p_chunk">@@ -5088,7 +5088,7 @@</span> <span class="p_context"> static long btrfs_ioctl_quota_rescan_wait(struct file *file, void __user *arg)</span>
 	if (!capable(CAP_SYS_ADMIN))
 		return -EPERM;
 
<span class="p_del">-	return btrfs_qgroup_wait_for_completion(root-&gt;fs_info);</span>
<span class="p_add">+	return btrfs_qgroup_wait_for_completion(root-&gt;fs_info, true);</span>
 }
 
 static long _btrfs_ioctl_set_received_subvol(struct file *file,
<span class="p_header">diff --git a/fs/btrfs/qgroup.c b/fs/btrfs/qgroup.c</span>
<span class="p_header">index 9d4c05b14f6e..4904ebee449b 100644</span>
<span class="p_header">--- a/fs/btrfs/qgroup.c</span>
<span class="p_header">+++ b/fs/btrfs/qgroup.c</span>
<span class="p_chunk">@@ -995,7 +995,7 @@</span> <span class="p_context"> int btrfs_quota_disable(struct btrfs_trans_handle *trans,</span>
 		goto out;
 	fs_info-&gt;quota_enabled = 0;
 	fs_info-&gt;pending_quota_state = 0;
<span class="p_del">-	btrfs_qgroup_wait_for_completion(fs_info);</span>
<span class="p_add">+	btrfs_qgroup_wait_for_completion(fs_info, false);</span>
 	spin_lock(&amp;fs_info-&gt;qgroup_lock);
 	quota_root = fs_info-&gt;quota_root;
 	fs_info-&gt;quota_root = NULL;
<span class="p_chunk">@@ -2302,6 +2302,10 @@</span> <span class="p_context"> static void btrfs_qgroup_rescan_worker(struct btrfs_work *work)</span>
 	int err = -ENOMEM;
 	int ret = 0;
 
<span class="p_add">+	mutex_lock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
<span class="p_add">+	fs_info-&gt;qgroup_rescan_running = true;</span>
<span class="p_add">+	mutex_unlock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
<span class="p_add">+</span>
 	path = btrfs_alloc_path();
 	if (!path)
 		goto out;
<span class="p_chunk">@@ -2368,6 +2372,9 @@</span> <span class="p_context"> out:</span>
 	}
 
 done:
<span class="p_add">+	mutex_lock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
<span class="p_add">+	fs_info-&gt;qgroup_rescan_running = false;</span>
<span class="p_add">+	mutex_unlock(&amp;fs_info-&gt;qgroup_rescan_lock);</span>
 	complete_all(&amp;fs_info-&gt;qgroup_rescan_completion);
 }
 
<span class="p_chunk">@@ -2486,20 +2493,26 @@</span> <span class="p_context"> btrfs_qgroup_rescan(struct btrfs_fs_info *fs_info)</span>
 	return 0;
 }
 
<span class="p_del">-int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info)</span>
<span class="p_add">+int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info,</span>
<span class="p_add">+				     bool interruptible)</span>
 {
 	int running;
 	int ret = 0;
 
 	mutex_lock(&amp;fs_info-&gt;qgroup_rescan_lock);
 	spin_lock(&amp;fs_info-&gt;qgroup_lock);
<span class="p_del">-	running = fs_info-&gt;qgroup_flags &amp; BTRFS_QGROUP_STATUS_FLAG_RESCAN;</span>
<span class="p_add">+	running = fs_info-&gt;qgroup_rescan_running;</span>
 	spin_unlock(&amp;fs_info-&gt;qgroup_lock);
 	mutex_unlock(&amp;fs_info-&gt;qgroup_rescan_lock);
 
<span class="p_del">-	if (running)</span>
<span class="p_add">+	if (!running)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (interruptible)</span>
 		ret = wait_for_completion_interruptible(
 					&amp;fs_info-&gt;qgroup_rescan_completion);
<span class="p_add">+	else</span>
<span class="p_add">+		wait_for_completion(&amp;fs_info-&gt;qgroup_rescan_completion);</span>
 
 	return ret;
 }
<span class="p_header">diff --git a/fs/btrfs/qgroup.h b/fs/btrfs/qgroup.h</span>
<span class="p_header">index ecb2c143ef75..3d73e4c9c7df 100644</span>
<span class="p_header">--- a/fs/btrfs/qgroup.h</span>
<span class="p_header">+++ b/fs/btrfs/qgroup.h</span>
<span class="p_chunk">@@ -46,7 +46,8 @@</span> <span class="p_context"> int btrfs_quota_disable(struct btrfs_trans_handle *trans,</span>
 			struct btrfs_fs_info *fs_info);
 int btrfs_qgroup_rescan(struct btrfs_fs_info *fs_info);
 void btrfs_qgroup_rescan_resume(struct btrfs_fs_info *fs_info);
<span class="p_del">-int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info);</span>
<span class="p_add">+int btrfs_qgroup_wait_for_completion(struct btrfs_fs_info *fs_info,</span>
<span class="p_add">+				     bool interruptible);</span>
 int btrfs_add_qgroup_relation(struct btrfs_trans_handle *trans,
 			      struct btrfs_fs_info *fs_info, u64 src, u64 dst);
 int btrfs_del_qgroup_relation(struct btrfs_trans_handle *trans,
<span class="p_header">diff --git a/fs/btrfs/root-tree.c b/fs/btrfs/root-tree.c</span>
<span class="p_header">index f1c30861d062..3454aa4faecb 100644</span>
<span class="p_header">--- a/fs/btrfs/root-tree.c</span>
<span class="p_header">+++ b/fs/btrfs/root-tree.c</span>
<span class="p_chunk">@@ -272,6 +272,23 @@</span> <span class="p_context"> int btrfs_find_orphan_roots(struct btrfs_root *tree_root)</span>
 		root_key.objectid = key.offset;
 		key.offset++;
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The root might have been inserted already, as before we look</span>
<span class="p_add">+		 * for orphan roots, log replay might have happened, which</span>
<span class="p_add">+		 * triggers a transaction commit and qgroup accounting, which</span>
<span class="p_add">+		 * in turn reads and inserts fs roots while doing backref</span>
<span class="p_add">+		 * walking.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		root = btrfs_lookup_fs_root(tree_root-&gt;fs_info,</span>
<span class="p_add">+					    root_key.objectid);</span>
<span class="p_add">+		if (root) {</span>
<span class="p_add">+			WARN_ON(!test_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED,</span>
<span class="p_add">+					  &amp;root-&gt;state));</span>
<span class="p_add">+			if (btrfs_root_refs(&amp;root-&gt;root_item) == 0)</span>
<span class="p_add">+				btrfs_add_dead_root(root);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		root = btrfs_read_fs_root(tree_root, &amp;root_key);
 		err = PTR_ERR_OR_ZERO(root);
 		if (err &amp;&amp; err != -ENOENT) {
<span class="p_chunk">@@ -310,16 +327,8 @@</span> <span class="p_context"> int btrfs_find_orphan_roots(struct btrfs_root *tree_root)</span>
 		set_bit(BTRFS_ROOT_ORPHAN_ITEM_INSERTED, &amp;root-&gt;state);
 
 		err = btrfs_insert_fs_root(root-&gt;fs_info, root);
<span class="p_del">-		/*</span>
<span class="p_del">-		 * The root might have been inserted already, as before we look</span>
<span class="p_del">-		 * for orphan roots, log replay might have happened, which</span>
<span class="p_del">-		 * triggers a transaction commit and qgroup accounting, which</span>
<span class="p_del">-		 * in turn reads and inserts fs roots while doing backref</span>
<span class="p_del">-		 * walking.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (err == -EEXIST)</span>
<span class="p_del">-			err = 0;</span>
 		if (err) {
<span class="p_add">+			BUG_ON(err == -EEXIST);</span>
 			btrfs_free_fs_root(root);
 			break;
 		}
<span class="p_header">diff --git a/fs/seq_file.c b/fs/seq_file.c</span>
<span class="p_header">index 19f532e7d35e..6dc4296eed62 100644</span>
<span class="p_header">--- a/fs/seq_file.c</span>
<span class="p_header">+++ b/fs/seq_file.c</span>
<span class="p_chunk">@@ -223,8 +223,10 @@</span> <span class="p_context"> ssize_t seq_read(struct file *file, char __user *buf, size_t size, loff_t *ppos)</span>
 		size -= n;
 		buf += n;
 		copied += n;
<span class="p_del">-		if (!m-&gt;count)</span>
<span class="p_add">+		if (!m-&gt;count) {</span>
<span class="p_add">+			m-&gt;from = 0;</span>
 			m-&gt;index++;
<span class="p_add">+		}</span>
 		if (!size)
 			goto Done;
 	}
<span class="p_header">diff --git a/fs/sysfs/file.c b/fs/sysfs/file.c</span>
<span class="p_header">index f35523d4fa3a..b803213d1307 100644</span>
<span class="p_header">--- a/fs/sysfs/file.c</span>
<span class="p_header">+++ b/fs/sysfs/file.c</span>
<span class="p_chunk">@@ -114,9 +114,15 @@</span> <span class="p_context"> static ssize_t sysfs_kf_read(struct kernfs_open_file *of, char *buf,</span>
 	 * If buf != of-&gt;prealloc_buf, we don&#39;t know how
 	 * large it is, so cannot safely pass it to -&gt;show
 	 */
<span class="p_del">-	if (pos || WARN_ON_ONCE(buf != of-&gt;prealloc_buf))</span>
<span class="p_add">+	if (WARN_ON_ONCE(buf != of-&gt;prealloc_buf))</span>
 		return 0;
 	len = ops-&gt;show(kobj, of-&gt;kn-&gt;priv, buf);
<span class="p_add">+	if (pos) {</span>
<span class="p_add">+		if (len &lt;= pos)</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		len -= pos;</span>
<span class="p_add">+		memmove(buf, buf + pos, len);</span>
<span class="p_add">+	}</span>
 	return min(count, len);
 }
 
<span class="p_header">diff --git a/include/linux/acpi.h b/include/linux/acpi.h</span>
<span class="p_header">index 288fac5294f5..47f950856346 100644</span>
<span class="p_header">--- a/include/linux/acpi.h</span>
<span class="p_header">+++ b/include/linux/acpi.h</span>
<span class="p_chunk">@@ -985,7 +985,7 @@</span> <span class="p_context"> static inline struct fwnode_handle *acpi_get_next_subnode(struct device *dev,</span>
 	return NULL;
 }
 
<span class="p_del">-#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable, validate, data, fn) \</span>
<span class="p_add">+#define ACPI_DECLARE_PROBE_ENTRY(table, name, table_id, subtable, valid, data, fn) \</span>
 	static const void * __acpi_table_##name[]			\
 		__attribute__((unused))					\
 		 = { (void *) table_id,					\
<span class="p_header">diff --git a/include/linux/i8042.h b/include/linux/i8042.h</span>
<span class="p_header">index 0f9bafa17a02..d98780ca9604 100644</span>
<span class="p_header">--- a/include/linux/i8042.h</span>
<span class="p_header">+++ b/include/linux/i8042.h</span>
<span class="p_chunk">@@ -62,7 +62,6 @@</span> <span class="p_context"> struct serio;</span>
 void i8042_lock_chip(void);
 void i8042_unlock_chip(void);
 int i8042_command(unsigned char *param, int command);
<span class="p_del">-bool i8042_check_port_owner(const struct serio *);</span>
 int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio));
 int i8042_remove_filter(bool (*filter)(unsigned char data, unsigned char str,
<span class="p_chunk">@@ -83,11 +82,6 @@</span> <span class="p_context"> static inline int i8042_command(unsigned char *param, int command)</span>
 	return -ENODEV;
 }
 
<span class="p_del">-static inline bool i8042_check_port_owner(const struct serio *serio)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return false;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline int i8042_install_filter(bool (*filter)(unsigned char data, unsigned char str,
 					struct serio *serio))
 {
<span class="p_header">diff --git a/include/linux/mfd/cros_ec.h b/include/linux/mfd/cros_ec.h</span>
<span class="p_header">index 64184d27e3cd..d641a18abacb 100644</span>
<span class="p_header">--- a/include/linux/mfd/cros_ec.h</span>
<span class="p_header">+++ b/include/linux/mfd/cros_ec.h</span>
<span class="p_chunk">@@ -226,6 +226,21 @@</span> <span class="p_context"> int cros_ec_cmd_xfer(struct cros_ec_device *ec_dev,</span>
 		     struct cros_ec_command *msg);
 
 /**
<span class="p_add">+ * cros_ec_cmd_xfer_status - Send a command to the ChromeOS EC</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * This function is identical to cros_ec_cmd_xfer, except it returns success</span>
<span class="p_add">+ * status only if both the command was transmitted successfully and the EC</span>
<span class="p_add">+ * replied with success status. It&#39;s not necessary to check msg-&gt;result when</span>
<span class="p_add">+ * using this function.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * @ec_dev: EC device</span>
<span class="p_add">+ * @msg: Message to write</span>
<span class="p_add">+ * @return: Num. of bytes transferred on success, &lt;0 on failure</span>
<span class="p_add">+ */</span>
<span class="p_add">+int cros_ec_cmd_xfer_status(struct cros_ec_device *ec_dev,</span>
<span class="p_add">+			    struct cros_ec_command *msg);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  * cros_ec_remove - Remove a ChromeOS EC
  *
  * Call this to deregister a ChromeOS EC, then clean up any private data.
<span class="p_header">diff --git a/include/linux/msi.h b/include/linux/msi.h</span>
<span class="p_header">index 8b425c66305a..ec39a086f1f6 100644</span>
<span class="p_header">--- a/include/linux/msi.h</span>
<span class="p_header">+++ b/include/linux/msi.h</span>
<span class="p_chunk">@@ -264,12 +264,12 @@</span> <span class="p_context"> enum {</span>
 	 * callbacks.
 	 */
 	MSI_FLAG_USE_DEF_CHIP_OPS	= (1 &lt;&lt; 1),
<span class="p_del">-	/* Build identity map between hwirq and irq */</span>
<span class="p_del">-	MSI_FLAG_IDENTITY_MAP		= (1 &lt;&lt; 2),</span>
 	/* Support multiple PCI MSI interrupts */
<span class="p_del">-	MSI_FLAG_MULTI_PCI_MSI		= (1 &lt;&lt; 3),</span>
<span class="p_add">+	MSI_FLAG_MULTI_PCI_MSI		= (1 &lt;&lt; 2),</span>
 	/* Support PCI MSIX interrupts */
<span class="p_del">-	MSI_FLAG_PCI_MSIX		= (1 &lt;&lt; 4),</span>
<span class="p_add">+	MSI_FLAG_PCI_MSIX		= (1 &lt;&lt; 3),</span>
<span class="p_add">+	/* Needs early activate, required for PCI */</span>
<span class="p_add">+	MSI_FLAG_ACTIVATE_EARLY		= (1 &lt;&lt; 4),</span>
 };
 
 int msi_domain_set_affinity(struct irq_data *data, const struct cpumask *mask,
<span class="p_header">diff --git a/include/linux/serio.h b/include/linux/serio.h</span>
<span class="p_header">index df4ab5de1586..c733cff44e18 100644</span>
<span class="p_header">--- a/include/linux/serio.h</span>
<span class="p_header">+++ b/include/linux/serio.h</span>
<span class="p_chunk">@@ -31,7 +31,8 @@</span> <span class="p_context"> struct serio {</span>
 
 	struct serio_device_id id;
 
<span class="p_del">-	spinlock_t lock;		/* protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	/* Protects critical sections from port&#39;s interrupt handler */</span>
<span class="p_add">+	spinlock_t lock;</span>
 
 	int (*write)(struct serio *, unsigned char);
 	int (*open)(struct serio *);
<span class="p_chunk">@@ -40,16 +41,29 @@</span> <span class="p_context"> struct serio {</span>
 	void (*stop)(struct serio *);
 
 	struct serio *parent;
<span class="p_del">-	struct list_head child_node;	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	/* Entry in parent-&gt;children list */</span>
<span class="p_add">+	struct list_head child_node;</span>
 	struct list_head children;
<span class="p_del">-	unsigned int depth;		/* level of nesting in serio hierarchy */</span>
<span class="p_add">+	/* Level of nesting in serio hierarchy */</span>
<span class="p_add">+	unsigned int depth;</span>
 
<span class="p_del">-	struct serio_driver *drv;	/* accessed from interrupt, must be protected by serio-&gt;lock and serio-&gt;sem */</span>
<span class="p_del">-	struct mutex drv_mutex;		/* protects serio-&gt;drv so attributes can pin driver */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * serio-&gt;drv is accessed from interrupt handlers; when modifying</span>
<span class="p_add">+	 * caller should acquire serio-&gt;drv_mutex and serio-&gt;lock.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct serio_driver *drv;</span>
<span class="p_add">+	/* Protects serio-&gt;drv so attributes can pin current driver */</span>
<span class="p_add">+	struct mutex drv_mutex;</span>
 
 	struct device dev;
 
 	struct list_head node;
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * For use by PS/2 layer when several ports share hardware and</span>
<span class="p_add">+	 * may get indigestion when exposed to concurrent access (i8042).</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	struct mutex *ps2_cmd_mutex;</span>
 };
 #define to_serio_port(d)	container_of(d, struct serio, dev)
 
<span class="p_header">diff --git a/include/trace/events/timer.h b/include/trace/events/timer.h</span>
<span class="p_header">index 51440131d337..28c5da6fdfac 100644</span>
<span class="p_header">--- a/include/trace/events/timer.h</span>
<span class="p_header">+++ b/include/trace/events/timer.h</span>
<span class="p_chunk">@@ -330,24 +330,32 @@</span> <span class="p_context"> TRACE_EVENT(itimer_expire,</span>
 #ifdef CONFIG_NO_HZ_COMMON
 
 #define TICK_DEP_NAMES					\
<span class="p_del">-		tick_dep_name(NONE)			\</span>
<span class="p_add">+		tick_dep_mask_name(NONE)		\</span>
 		tick_dep_name(POSIX_TIMER)		\
 		tick_dep_name(PERF_EVENTS)		\
 		tick_dep_name(SCHED)			\
 		tick_dep_name_end(CLOCK_UNSTABLE)
 
 #undef tick_dep_name
<span class="p_add">+#undef tick_dep_mask_name</span>
 #undef tick_dep_name_end
 
<span class="p_del">-#define tick_dep_name(sdep) TRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);</span>
<span class="p_del">-#define tick_dep_name_end(sdep)  TRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);</span>
<span class="p_add">+/* The MASK will convert to their bits and they need to be processed too */</span>
<span class="p_add">+#define tick_dep_name(sdep) TRACE_DEFINE_ENUM(TICK_DEP_BIT_##sdep); \</span>
<span class="p_add">+	TRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);</span>
<span class="p_add">+#define tick_dep_name_end(sdep)  TRACE_DEFINE_ENUM(TICK_DEP_BIT_##sdep); \</span>
<span class="p_add">+	TRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);</span>
<span class="p_add">+/* NONE only has a mask defined for it */</span>
<span class="p_add">+#define tick_dep_mask_name(sdep) TRACE_DEFINE_ENUM(TICK_DEP_MASK_##sdep);</span>
 
 TICK_DEP_NAMES
 
 #undef tick_dep_name
<span class="p_add">+#undef tick_dep_mask_name</span>
 #undef tick_dep_name_end
 
 #define tick_dep_name(sdep) { TICK_DEP_MASK_##sdep, #sdep },
<span class="p_add">+#define tick_dep_mask_name(sdep) { TICK_DEP_MASK_##sdep, #sdep },</span>
 #define tick_dep_name_end(sdep) { TICK_DEP_MASK_##sdep, #sdep }
 
 #define show_tick_dep_name(val)				\
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index 43d43a2d5811..e68c0a735c8f 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -242,18 +242,6 @@</span> <span class="p_context"> unlock:</span>
 	return ret;
 }
 
<span class="p_del">-static void event_function_local(struct perf_event *event, event_f func, void *data)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct event_function_struct efs = {</span>
<span class="p_del">-		.event = event,</span>
<span class="p_del">-		.func = func,</span>
<span class="p_del">-		.data = data,</span>
<span class="p_del">-	};</span>
<span class="p_del">-</span>
<span class="p_del">-	int ret = event_function(&amp;efs);</span>
<span class="p_del">-	WARN_ON_ONCE(ret);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static void event_function_call(struct perf_event *event, event_f func, void *data)
 {
 	struct perf_event_context *ctx = event-&gt;ctx;
<span class="p_chunk">@@ -303,6 +291,54 @@</span> <span class="p_context"> again:</span>
 	raw_spin_unlock_irq(&amp;ctx-&gt;lock);
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Similar to event_function_call() + event_function(), but hard assumes IRQs</span>
<span class="p_add">+ * are already disabled and we&#39;re on the right CPU.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void event_function_local(struct perf_event *event, event_f func, void *data)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event_context *ctx = event-&gt;ctx;</span>
<span class="p_add">+	struct perf_cpu_context *cpuctx = __get_cpu_context(ctx);</span>
<span class="p_add">+	struct task_struct *task = READ_ONCE(ctx-&gt;task);</span>
<span class="p_add">+	struct perf_event_context *task_ctx = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	WARN_ON_ONCE(!irqs_disabled());</span>
<span class="p_add">+</span>
<span class="p_add">+	if (task) {</span>
<span class="p_add">+		if (task == TASK_TOMBSTONE)</span>
<span class="p_add">+			return;</span>
<span class="p_add">+</span>
<span class="p_add">+		task_ctx = ctx;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	perf_ctx_lock(cpuctx, task_ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+	task = ctx-&gt;task;</span>
<span class="p_add">+	if (task == TASK_TOMBSTONE)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (task) {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * We must be either inactive or active and the right task,</span>
<span class="p_add">+		 * otherwise we&#39;re screwed, since we cannot IPI to somewhere</span>
<span class="p_add">+		 * else.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (ctx-&gt;is_active) {</span>
<span class="p_add">+			if (WARN_ON_ONCE(task != current))</span>
<span class="p_add">+				goto unlock;</span>
<span class="p_add">+</span>
<span class="p_add">+			if (WARN_ON_ONCE(cpuctx-&gt;task_ctx != ctx))</span>
<span class="p_add">+				goto unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		WARN_ON_ONCE(&amp;cpuctx-&gt;ctx != ctx);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	func(event, cpuctx, ctx, data);</span>
<span class="p_add">+unlock:</span>
<span class="p_add">+	perf_ctx_unlock(cpuctx, task_ctx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #define PERF_FLAG_ALL (PERF_FLAG_FD_NO_GROUP |\
 		       PERF_FLAG_FD_OUTPUT  |\
 		       PERF_FLAG_PID_CGROUP |\
<span class="p_header">diff --git a/kernel/events/uprobes.c b/kernel/events/uprobes.c</span>
<span class="p_header">index b7a525ab2083..8c50276b60d1 100644</span>
<span class="p_header">--- a/kernel/events/uprobes.c</span>
<span class="p_header">+++ b/kernel/events/uprobes.c</span>
<span class="p_chunk">@@ -172,8 +172,10 @@</span> <span class="p_context"> static int __replace_page(struct vm_area_struct *vma, unsigned long addr,</span>
 	mmu_notifier_invalidate_range_start(mm, mmun_start, mmun_end);
 	err = -EAGAIN;
 	ptep = page_check_address(page, mm, addr, &amp;ptl, 0);
<span class="p_del">-	if (!ptep)</span>
<span class="p_add">+	if (!ptep) {</span>
<span class="p_add">+		mem_cgroup_cancel_charge(kpage, memcg, false);</span>
 		goto unlock;
<span class="p_add">+	}</span>
 
 	get_page(kpage);
 	page_add_new_anon_rmap(kpage, vma, addr, false);
<span class="p_chunk">@@ -200,7 +202,6 @@</span> <span class="p_context"> static int __replace_page(struct vm_area_struct *vma, unsigned long addr,</span>
 
 	err = 0;
  unlock:
<span class="p_del">-	mem_cgroup_cancel_charge(kpage, memcg, false);</span>
 	mmu_notifier_invalidate_range_end(mm, mmun_start, mmun_end);
 	unlock_page(page);
 	return err;
<span class="p_header">diff --git a/kernel/irq/msi.c b/kernel/irq/msi.c</span>
<span class="p_header">index 38e89ce7b071..0afe671f1770 100644</span>
<span class="p_header">--- a/kernel/irq/msi.c</span>
<span class="p_header">+++ b/kernel/irq/msi.c</span>
<span class="p_chunk">@@ -324,7 +324,7 @@</span> <span class="p_context"> int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,</span>
 	struct msi_domain_ops *ops = info-&gt;ops;
 	msi_alloc_info_t arg;
 	struct msi_desc *desc;
<span class="p_del">-	int i, ret, virq = -1;</span>
<span class="p_add">+	int i, ret, virq;</span>
 
 	ret = msi_domain_prepare_irqs(domain, dev, nvec, &amp;arg);
 	if (ret)
<span class="p_chunk">@@ -332,12 +332,8 @@</span> <span class="p_context"> int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,</span>
 
 	for_each_msi_entry(desc, dev) {
 		ops-&gt;set_desc(&amp;arg, desc);
<span class="p_del">-		if (info-&gt;flags &amp; MSI_FLAG_IDENTITY_MAP)</span>
<span class="p_del">-			virq = (int)ops-&gt;get_hwirq(info, &amp;arg);</span>
<span class="p_del">-		else</span>
<span class="p_del">-			virq = -1;</span>
 
<span class="p_del">-		virq = __irq_domain_alloc_irqs(domain, virq, desc-&gt;nvec_used,</span>
<span class="p_add">+		virq = __irq_domain_alloc_irqs(domain, -1, desc-&gt;nvec_used,</span>
 					       dev_to_node(dev), &amp;arg, false);
 		if (virq &lt; 0) {
 			ret = -ENOSPC;
<span class="p_chunk">@@ -361,6 +357,17 @@</span> <span class="p_context"> int msi_domain_alloc_irqs(struct irq_domain *domain, struct device *dev,</span>
 		else
 			dev_dbg(dev, &quot;irq [%d-%d] for MSI\n&quot;,
 				virq, virq + desc-&gt;nvec_used - 1);
<span class="p_add">+		/*</span>
<span class="p_add">+		 * This flag is set by the PCI layer as we need to activate</span>
<span class="p_add">+		 * the MSI entries before the PCI layer enables MSI in the</span>
<span class="p_add">+		 * card. Otherwise the card latches a random msi message.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (info-&gt;flags &amp; MSI_FLAG_ACTIVATE_EARLY) {</span>
<span class="p_add">+			struct irq_data *irq_data;</span>
<span class="p_add">+</span>
<span class="p_add">+			irq_data = irq_domain_get_irq_data(domain, desc-&gt;irq);</span>
<span class="p_add">+			irq_domain_activate_irq(irq_data);</span>
<span class="p_add">+		}</span>
 	}
 
 	return 0;
<span class="p_header">diff --git a/kernel/sched/cputime.c b/kernel/sched/cputime.c</span>
<span class="p_header">index 75f98c5498d5..a24cfb41d1fc 100644</span>
<span class="p_header">--- a/kernel/sched/cputime.c</span>
<span class="p_header">+++ b/kernel/sched/cputime.c</span>
<span class="p_chunk">@@ -603,19 +603,25 @@</span> <span class="p_context"> static void cputime_adjust(struct task_cputime *curr,</span>
 	stime = curr-&gt;stime;
 	utime = curr-&gt;utime;
 
<span class="p_del">-	if (utime == 0) {</span>
<span class="p_del">-		stime = rtime;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If either stime or both stime and utime are 0, assume all runtime is</span>
<span class="p_add">+	 * userspace. Once a task gets some ticks, the monotonicy code at</span>
<span class="p_add">+	 * &#39;update&#39; will ensure things converge to the observed ratio.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (stime == 0) {</span>
<span class="p_add">+		utime = rtime;</span>
 		goto update;
 	}
 
<span class="p_del">-	if (stime == 0) {</span>
<span class="p_del">-		utime = rtime;</span>
<span class="p_add">+	if (utime == 0) {</span>
<span class="p_add">+		stime = rtime;</span>
 		goto update;
 	}
 
 	stime = scale_stime((__force u64)stime, (__force u64)rtime,
 			    (__force u64)(stime + utime));
 
<span class="p_add">+update:</span>
 	/*
 	 * Make sure stime doesn&#39;t go backwards; this preserves monotonicity
 	 * for utime because rtime is monotonic.
<span class="p_chunk">@@ -638,7 +644,6 @@</span> <span class="p_context"> static void cputime_adjust(struct task_cputime *curr,</span>
 		stime = rtime - utime;
 	}
 
<span class="p_del">-update:</span>
 	prev-&gt;stime = stime;
 	prev-&gt;utime = utime;
 out:
<span class="p_header">diff --git a/mm/huge_memory.c b/mm/huge_memory.c</span>
<span class="p_header">index 343a2b7e57aa..07f28251f6e0 100644</span>
<span class="p_header">--- a/mm/huge_memory.c</span>
<span class="p_header">+++ b/mm/huge_memory.c</span>
<span class="p_chunk">@@ -2872,7 +2872,7 @@</span> <span class="p_context"> static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,</span>
 	struct page *page;
 	pgtable_t pgtable;
 	pmd_t _pmd;
<span class="p_del">-	bool young, write, dirty;</span>
<span class="p_add">+	bool young, write, dirty, soft_dirty;</span>
 	unsigned long addr;
 	int i;
 
<span class="p_chunk">@@ -2898,6 +2898,7 @@</span> <span class="p_context"> static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,</span>
 	write = pmd_write(*pmd);
 	young = pmd_young(*pmd);
 	dirty = pmd_dirty(*pmd);
<span class="p_add">+	soft_dirty = pmd_soft_dirty(*pmd);</span>
 
 	pmdp_huge_split_prepare(vma, haddr, pmd);
 	pgtable = pgtable_trans_huge_withdraw(mm, pmd);
<span class="p_chunk">@@ -2914,6 +2915,8 @@</span> <span class="p_context"> static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,</span>
 			swp_entry_t swp_entry;
 			swp_entry = make_migration_entry(page + i, write);
 			entry = swp_entry_to_pte(swp_entry);
<span class="p_add">+			if (soft_dirty)</span>
<span class="p_add">+				entry = pte_swp_mksoft_dirty(entry);</span>
 		} else {
 			entry = mk_pte(page + i, vma-&gt;vm_page_prot);
 			entry = maybe_mkwrite(entry, vma);
<span class="p_chunk">@@ -2921,6 +2924,8 @@</span> <span class="p_context"> static void __split_huge_pmd_locked(struct vm_area_struct *vma, pmd_t *pmd,</span>
 				entry = pte_wrprotect(entry);
 			if (!young)
 				entry = pte_mkold(entry);
<span class="p_add">+			if (soft_dirty)</span>
<span class="p_add">+				entry = pte_mksoft_dirty(entry);</span>
 		}
 		if (dirty)
 			SetPageDirty(page + i);
<span class="p_header">diff --git a/mm/readahead.c b/mm/readahead.c</span>
<span class="p_header">index 40be3ae0afe3..7f9f8c3464e2 100644</span>
<span class="p_header">--- a/mm/readahead.c</span>
<span class="p_header">+++ b/mm/readahead.c</span>
<span class="p_chunk">@@ -8,6 +8,7 @@</span> <span class="p_context"></span>
  */
 
 #include &lt;linux/kernel.h&gt;
<span class="p_add">+#include &lt;linux/dax.h&gt;</span>
 #include &lt;linux/gfp.h&gt;
 #include &lt;linux/export.h&gt;
 #include &lt;linux/blkdev.h&gt;
<span class="p_chunk">@@ -545,6 +546,14 @@</span> <span class="p_context"> do_readahead(struct address_space *mapping, struct file *filp,</span>
 	if (!mapping || !mapping-&gt;a_ops)
 		return -EINVAL;
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Readahead doesn&#39;t make sense for DAX inodes, but we don&#39;t want it</span>
<span class="p_add">+	 * to report a failure either.  Instead, we just return success and</span>
<span class="p_add">+	 * don&#39;t do any work.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (dax_mapping(mapping))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	return force_page_cache_readahead(mapping, filp, index, nr);
 }
 
<span class="p_header">diff --git a/mm/slub.c b/mm/slub.c</span>
<span class="p_header">index 825ff4505336..7a6d268840c0 100644</span>
<span class="p_header">--- a/mm/slub.c</span>
<span class="p_header">+++ b/mm/slub.c</span>
<span class="p_chunk">@@ -3479,6 +3479,7 @@</span> <span class="p_context"> static void list_slab_objects(struct kmem_cache *s, struct page *page,</span>
  */
 static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)
 {
<span class="p_add">+	LIST_HEAD(discard);</span>
 	struct page *page, *h;
 
 	BUG_ON(irqs_disabled());
<span class="p_chunk">@@ -3486,13 +3487,16 @@</span> <span class="p_context"> static void free_partial(struct kmem_cache *s, struct kmem_cache_node *n)</span>
 	list_for_each_entry_safe(page, h, &amp;n-&gt;partial, lru) {
 		if (!page-&gt;inuse) {
 			remove_partial(n, page);
<span class="p_del">-			discard_slab(s, page);</span>
<span class="p_add">+			list_add(&amp;page-&gt;lru, &amp;discard);</span>
 		} else {
 			list_slab_objects(s, page,
 			&quot;Objects remaining in %s on __kmem_cache_shutdown()&quot;);
 		}
 	}
 	spin_unlock_irq(&amp;n-&gt;list_lock);
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry_safe(page, h, &amp;discard, lru)</span>
<span class="p_add">+		discard_slab(s, page);</span>
 }
 
 /*
<span class="p_header">diff --git a/net/mac80211/cfg.c b/net/mac80211/cfg.c</span>
<span class="p_header">index 0c12e4001f19..8cc49c04458a 100644</span>
<span class="p_header">--- a/net/mac80211/cfg.c</span>
<span class="p_header">+++ b/net/mac80211/cfg.c</span>
<span class="p_chunk">@@ -869,7 +869,7 @@</span> <span class="p_context"> static int ieee80211_stop_ap(struct wiphy *wiphy, struct net_device *dev)</span>
 
 	/* free all potentially still buffered bcast frames */
 	local-&gt;total_ps_buffered -= skb_queue_len(&amp;sdata-&gt;u.ap.ps.bc_buf);
<span class="p_del">-	skb_queue_purge(&amp;sdata-&gt;u.ap.ps.bc_buf);</span>
<span class="p_add">+	ieee80211_purge_tx_queue(&amp;local-&gt;hw, &amp;sdata-&gt;u.ap.ps.bc_buf);</span>
 
 	mutex_lock(&amp;local-&gt;mtx);
 	ieee80211_vif_copy_chanctx_to_vlans(sdata, true);
<span class="p_header">diff --git a/net/mac80211/tx.c b/net/mac80211/tx.c</span>
<span class="p_header">index 203044379ce0..8bad2ad81399 100644</span>
<span class="p_header">--- a/net/mac80211/tx.c</span>
<span class="p_header">+++ b/net/mac80211/tx.c</span>
<span class="p_chunk">@@ -365,7 +365,7 @@</span> <span class="p_context"> static void purge_old_ps_buffers(struct ieee80211_local *local)</span>
 		skb = skb_dequeue(&amp;ps-&gt;bc_buf);
 		if (skb) {
 			purged++;
<span class="p_del">-			dev_kfree_skb(skb);</span>
<span class="p_add">+			ieee80211_free_txskb(&amp;local-&gt;hw, skb);</span>
 		}
 		total += skb_queue_len(&amp;ps-&gt;bc_buf);
 	}
<span class="p_chunk">@@ -448,7 +448,7 @@</span> <span class="p_context"> ieee80211_tx_h_multicast_ps_buf(struct ieee80211_tx_data *tx)</span>
 	if (skb_queue_len(&amp;ps-&gt;bc_buf) &gt;= AP_MAX_BC_BUFFER) {
 		ps_dbg(tx-&gt;sdata,
 		       &quot;BC TX buffer full - dropping the oldest frame\n&quot;);
<span class="p_del">-		dev_kfree_skb(skb_dequeue(&amp;ps-&gt;bc_buf));</span>
<span class="p_add">+		ieee80211_free_txskb(&amp;tx-&gt;local-&gt;hw, skb_dequeue(&amp;ps-&gt;bc_buf));</span>
 	} else
 		tx-&gt;local-&gt;total_ps_buffered++;
 
<span class="p_chunk">@@ -4055,7 +4055,7 @@</span> <span class="p_context"> ieee80211_get_buffered_bc(struct ieee80211_hw *hw,</span>
 			sdata = IEEE80211_DEV_TO_SUB_IF(skb-&gt;dev);
 		if (!ieee80211_tx_prepare(sdata, &amp;tx, NULL, skb))
 			break;
<span class="p_del">-		dev_kfree_skb_any(skb);</span>
<span class="p_add">+		ieee80211_free_txskb(hw, skb);</span>
 	}
 
 	info = IEEE80211_SKB_CB(skb);
<span class="p_header">diff --git a/net/sunrpc/auth_gss/auth_gss.c b/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_header">index e64ae93d5b4f..bf4b0e98f5b5 100644</span>
<span class="p_header">--- a/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_header">+++ b/net/sunrpc/auth_gss/auth_gss.c</span>
<span class="p_chunk">@@ -340,12 +340,14 @@</span> <span class="p_context"> gss_release_msg(struct gss_upcall_msg *gss_msg)</span>
 }
 
 static struct gss_upcall_msg *
<span class="p_del">-__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid)</span>
<span class="p_add">+__gss_find_upcall(struct rpc_pipe *pipe, kuid_t uid, const struct gss_auth *auth)</span>
 {
 	struct gss_upcall_msg *pos;
 	list_for_each_entry(pos, &amp;pipe-&gt;in_downcall, list) {
 		if (!uid_eq(pos-&gt;uid, uid))
 			continue;
<span class="p_add">+		if (auth &amp;&amp; pos-&gt;auth-&gt;service != auth-&gt;service)</span>
<span class="p_add">+			continue;</span>
 		atomic_inc(&amp;pos-&gt;count);
 		dprintk(&quot;RPC:       %s found msg %p\n&quot;, __func__, pos);
 		return pos;
<span class="p_chunk">@@ -365,7 +367,7 @@</span> <span class="p_context"> gss_add_msg(struct gss_upcall_msg *gss_msg)</span>
 	struct gss_upcall_msg *old;
 
 	spin_lock(&amp;pipe-&gt;lock);
<span class="p_del">-	old = __gss_find_upcall(pipe, gss_msg-&gt;uid);</span>
<span class="p_add">+	old = __gss_find_upcall(pipe, gss_msg-&gt;uid, gss_msg-&gt;auth);</span>
 	if (old == NULL) {
 		atomic_inc(&amp;gss_msg-&gt;count);
 		list_add(&amp;gss_msg-&gt;list, &amp;pipe-&gt;in_downcall);
<span class="p_chunk">@@ -714,7 +716,7 @@</span> <span class="p_context"> gss_pipe_downcall(struct file *filp, const char __user *src, size_t mlen)</span>
 	err = -ENOENT;
 	/* Find a matching upcall */
 	spin_lock(&amp;pipe-&gt;lock);
<span class="p_del">-	gss_msg = __gss_find_upcall(pipe, uid);</span>
<span class="p_add">+	gss_msg = __gss_find_upcall(pipe, uid, NULL);</span>
 	if (gss_msg == NULL) {
 		spin_unlock(&amp;pipe-&gt;lock);
 		goto err_put_ctx;
<span class="p_header">diff --git a/net/sunrpc/xprtmultipath.c b/net/sunrpc/xprtmultipath.c</span>
<span class="p_header">index e7fd76975d86..66c9d63f4797 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtmultipath.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtmultipath.c</span>
<span class="p_chunk">@@ -271,14 +271,12 @@</span> <span class="p_context"> struct rpc_xprt *xprt_iter_next_entry_multiple(struct rpc_xprt_iter *xpi,</span>
 		xprt_switch_find_xprt_t find_next)
 {
 	struct rpc_xprt_switch *xps = rcu_dereference(xpi-&gt;xpi_xpswitch);
<span class="p_del">-	struct list_head *head;</span>
 
 	if (xps == NULL)
 		return NULL;
<span class="p_del">-	head = &amp;xps-&gt;xps_xprt_list;</span>
<span class="p_del">-	if (xps-&gt;xps_nxprts &lt; 2)</span>
<span class="p_del">-		return xprt_switch_find_first_entry(head);</span>
<span class="p_del">-	return xprt_switch_set_next_cursor(head, &amp;xpi-&gt;xpi_cursor, find_next);</span>
<span class="p_add">+	return xprt_switch_set_next_cursor(&amp;xps-&gt;xps_xprt_list,</span>
<span class="p_add">+			&amp;xpi-&gt;xpi_cursor,</span>
<span class="p_add">+			find_next);</span>
 }
 
 static
<span class="p_header">diff --git a/net/sunrpc/xprtsock.c b/net/sunrpc/xprtsock.c</span>
<span class="p_header">index 7e2b2fa189c3..167cf59318ed 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtsock.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtsock.c</span>
<span class="p_chunk">@@ -2278,6 +2278,10 @@</span> <span class="p_context"> static int xs_tcp_finish_connecting(struct rpc_xprt *xprt, struct socket *sock)</span>
 		/* SYN_SENT! */
 		if (xprt-&gt;reestablish_timeout &lt; XS_TCP_INIT_REEST_TO)
 			xprt-&gt;reestablish_timeout = XS_TCP_INIT_REEST_TO;
<span class="p_add">+		break;</span>
<span class="p_add">+	case -EADDRNOTAVAIL:</span>
<span class="p_add">+		/* Source port number is unavailable. Try a new one! */</span>
<span class="p_add">+		transport-&gt;srcport = 0;</span>
 	}
 out:
 	return ret;
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 89dacf9b4e6c..160c7f713722 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -906,20 +906,23 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 	struct snd_card *card = dev_get_drvdata(dev);
 	struct azx *chip;
 	struct hda_intel *hda;
<span class="p_add">+	struct hdac_bus *bus;</span>
 
 	if (!card)
 		return 0;
 
 	chip = card-&gt;private_data;
 	hda = container_of(chip, struct hda_intel, chip);
<span class="p_add">+	bus = azx_bus(chip);</span>
 	if (chip-&gt;disabled || hda-&gt;init_failed || !chip-&gt;running)
 		return 0;
 
<span class="p_del">-	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL</span>
<span class="p_del">-		&amp;&amp; hda-&gt;need_i915_power) {</span>
<span class="p_del">-		snd_hdac_display_power(azx_bus(chip), true);</span>
<span class="p_del">-		snd_hdac_i915_set_bclk(azx_bus(chip));</span>
<span class="p_add">+	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) {</span>
<span class="p_add">+		snd_hdac_display_power(bus, true);</span>
<span class="p_add">+		if (hda-&gt;need_i915_power)</span>
<span class="p_add">+			snd_hdac_i915_set_bclk(bus);</span>
 	}
<span class="p_add">+</span>
 	if (chip-&gt;msi)
 		if (pci_enable_msi(pci) &lt; 0)
 			chip-&gt;msi = 0;
<span class="p_chunk">@@ -929,6 +932,11 @@</span> <span class="p_context"> static int azx_resume(struct device *dev)</span>
 
 	hda_intel_init_chip(chip, true);
 
<span class="p_add">+	/* power down again for link-controlled chips */</span>
<span class="p_add">+	if ((chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) &amp;&amp;</span>
<span class="p_add">+	    !hda-&gt;need_i915_power)</span>
<span class="p_add">+		snd_hdac_display_power(bus, false);</span>
<span class="p_add">+</span>
 	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
 
 	trace_azx_resume(chip);
<span class="p_chunk">@@ -1008,6 +1016,7 @@</span> <span class="p_context"> static int azx_runtime_resume(struct device *dev)</span>
 
 	chip = card-&gt;private_data;
 	hda = container_of(chip, struct hda_intel, chip);
<span class="p_add">+	bus = azx_bus(chip);</span>
 	if (chip-&gt;disabled || hda-&gt;init_failed)
 		return 0;
 
<span class="p_chunk">@@ -1015,15 +1024,9 @@</span> <span class="p_context"> static int azx_runtime_resume(struct device *dev)</span>
 		return 0;
 
 	if (chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) {
<span class="p_del">-		bus = azx_bus(chip);</span>
<span class="p_del">-		if (hda-&gt;need_i915_power) {</span>
<span class="p_del">-			snd_hdac_display_power(bus, true);</span>
<span class="p_add">+		snd_hdac_display_power(bus, true);</span>
<span class="p_add">+		if (hda-&gt;need_i915_power)</span>
 			snd_hdac_i915_set_bclk(bus);
<span class="p_del">-		} else {</span>
<span class="p_del">-			/* toggle codec wakeup bit for STATESTS read */</span>
<span class="p_del">-			snd_hdac_set_codec_wakeup(bus, true);</span>
<span class="p_del">-			snd_hdac_set_codec_wakeup(bus, false);</span>
<span class="p_del">-		}</span>
 	}
 
 	/* Read STATESTS before controller reset */
<span class="p_chunk">@@ -1043,6 +1046,11 @@</span> <span class="p_context"> static int azx_runtime_resume(struct device *dev)</span>
 	azx_writew(chip, WAKEEN, azx_readw(chip, WAKEEN) &amp;
 			~STATESTS_INT_MASK);
 
<span class="p_add">+	/* power down again for link-controlled chips */</span>
<span class="p_add">+	if ((chip-&gt;driver_caps &amp; AZX_DCAPS_I915_POWERWELL) &amp;&amp;</span>
<span class="p_add">+	    !hda-&gt;need_i915_power)</span>
<span class="p_add">+		snd_hdac_display_power(bus, false);</span>
<span class="p_add">+</span>
 	trace_azx_runtime_resume(chip);
 	return 0;
 }
<span class="p_header">diff --git a/sound/usb/line6/pcm.c b/sound/usb/line6/pcm.c</span>
<span class="p_header">index 204cc074adb9..41aa3355e920 100644</span>
<span class="p_header">--- a/sound/usb/line6/pcm.c</span>
<span class="p_header">+++ b/sound/usb/line6/pcm.c</span>
<span class="p_chunk">@@ -55,7 +55,6 @@</span> <span class="p_context"> static int snd_line6_impulse_volume_put(struct snd_kcontrol *kcontrol,</span>
 		err = line6_pcm_acquire(line6pcm, LINE6_STREAM_IMPULSE);
 		if (err &lt; 0) {
 			line6pcm-&gt;impulse_volume = 0;
<span class="p_del">-			line6_pcm_release(line6pcm, LINE6_STREAM_IMPULSE);</span>
 			return err;
 		}
 	} else {
<span class="p_chunk">@@ -211,7 +210,9 @@</span> <span class="p_context"> static void line6_stream_stop(struct snd_line6_pcm *line6pcm, int direction,</span>
 	spin_lock_irqsave(&amp;pstr-&gt;lock, flags);
 	clear_bit(type, &amp;pstr-&gt;running);
 	if (!pstr-&gt;running) {
<span class="p_add">+		spin_unlock_irqrestore(&amp;pstr-&gt;lock, flags);</span>
 		line6_unlink_audio_urbs(line6pcm, pstr);
<span class="p_add">+		spin_lock_irqsave(&amp;pstr-&gt;lock, flags);</span>
 		if (direction == SNDRV_PCM_STREAM_CAPTURE) {
 			line6pcm-&gt;prev_fbuf = NULL;
 			line6pcm-&gt;prev_fsize = 0;
<span class="p_header">diff --git a/sound/usb/line6/pod.c b/sound/usb/line6/pod.c</span>
<span class="p_header">index daf81d169a42..45dd34874f43 100644</span>
<span class="p_header">--- a/sound/usb/line6/pod.c</span>
<span class="p_header">+++ b/sound/usb/line6/pod.c</span>
<span class="p_chunk">@@ -244,8 +244,8 @@</span> <span class="p_context"> static int pod_set_system_param_int(struct usb_line6_pod *pod, int value,</span>
 static ssize_t serial_number_show(struct device *dev,
 				  struct device_attribute *attr, char *buf)
 {
<span class="p_del">-	struct usb_interface *interface = to_usb_interface(dev);</span>
<span class="p_del">-	struct usb_line6_pod *pod = usb_get_intfdata(interface);</span>
<span class="p_add">+	struct snd_card *card = dev_to_snd_card(dev);</span>
<span class="p_add">+	struct usb_line6_pod *pod = card-&gt;private_data;</span>
 
 	return sprintf(buf, &quot;%u\n&quot;, pod-&gt;serial_number);
 }
<span class="p_chunk">@@ -256,8 +256,8 @@</span> <span class="p_context"> static ssize_t serial_number_show(struct device *dev,</span>
 static ssize_t firmware_version_show(struct device *dev,
 				     struct device_attribute *attr, char *buf)
 {
<span class="p_del">-	struct usb_interface *interface = to_usb_interface(dev);</span>
<span class="p_del">-	struct usb_line6_pod *pod = usb_get_intfdata(interface);</span>
<span class="p_add">+	struct snd_card *card = dev_to_snd_card(dev);</span>
<span class="p_add">+	struct usb_line6_pod *pod = card-&gt;private_data;</span>
 
 	return sprintf(buf, &quot;%d.%02d\n&quot;, pod-&gt;firmware_version / 100,
 		       pod-&gt;firmware_version % 100);
<span class="p_chunk">@@ -269,8 +269,8 @@</span> <span class="p_context"> static ssize_t firmware_version_show(struct device *dev,</span>
 static ssize_t device_id_show(struct device *dev,
 			      struct device_attribute *attr, char *buf)
 {
<span class="p_del">-	struct usb_interface *interface = to_usb_interface(dev);</span>
<span class="p_del">-	struct usb_line6_pod *pod = usb_get_intfdata(interface);</span>
<span class="p_add">+	struct snd_card *card = dev_to_snd_card(dev);</span>
<span class="p_add">+	struct usb_line6_pod *pod = card-&gt;private_data;</span>
 
 	return sprintf(buf, &quot;%d\n&quot;, pod-&gt;device_id);
 }
<span class="p_header">diff --git a/sound/usb/quirks.c b/sound/usb/quirks.c</span>
<span class="p_header">index 6adde457b602..6cf1f3597455 100644</span>
<span class="p_header">--- a/sound/usb/quirks.c</span>
<span class="p_header">+++ b/sound/usb/quirks.c</span>
<span class="p_chunk">@@ -1128,6 +1128,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 {
 	/* devices which do not support reading the sample rate. */
 	switch (chip-&gt;usb_id) {
<span class="p_add">+	case USB_ID(0x041E, 0x4080): /* Creative Live Cam VF0610 */</span>
 	case USB_ID(0x045E, 0x075D): /* MS Lifecam Cinema  */
 	case USB_ID(0x045E, 0x076D): /* MS Lifecam HD-5000 */
 	case USB_ID(0x045E, 0x076E): /* MS Lifecam HD-5001 */
<span class="p_chunk">@@ -1138,6 +1139,7 @@</span> <span class="p_context"> bool snd_usb_get_sample_rate_quirk(struct snd_usb_audio *chip)</span>
 	case USB_ID(0x047F, 0xAA05): /* Plantronics DA45 */
 	case USB_ID(0x04D8, 0xFEEA): /* Benchmark DAC1 Pre */
 	case USB_ID(0x0556, 0x0014): /* Phoenix Audio TMX320VC */
<span class="p_add">+	case USB_ID(0x05A3, 0x9420): /* ELP HD USB Camera */</span>
 	case USB_ID(0x074D, 0x3553): /* Outlaw RR2150 (Micronas UAC3553B) */
 	case USB_ID(0x1de7, 0x0013): /* Phoenix Audio MT202exe */
 	case USB_ID(0x1de7, 0x0014): /* Phoenix Audio TMX320 */
<span class="p_header">diff --git a/tools/perf/arch/x86/util/intel-pt.c b/tools/perf/arch/x86/util/intel-pt.c</span>
<span class="p_header">index a07b9605e93b..853b26d85a76 100644</span>
<span class="p_header">--- a/tools/perf/arch/x86/util/intel-pt.c</span>
<span class="p_header">+++ b/tools/perf/arch/x86/util/intel-pt.c</span>
<span class="p_chunk">@@ -501,7 +501,7 @@</span> <span class="p_context"> static int intel_pt_recording_options(struct auxtrace_record *itr,</span>
 	struct intel_pt_recording *ptr =
 			container_of(itr, struct intel_pt_recording, itr);
 	struct perf_pmu *intel_pt_pmu = ptr-&gt;intel_pt_pmu;
<span class="p_del">-	bool have_timing_info;</span>
<span class="p_add">+	bool have_timing_info, need_immediate = false;</span>
 	struct perf_evsel *evsel, *intel_pt_evsel = NULL;
 	const struct cpu_map *cpus = evlist-&gt;cpus;
 	bool privileged = geteuid() == 0 || perf_event_paranoid() &lt; 0;
<span class="p_chunk">@@ -655,6 +655,7 @@</span> <span class="p_context"> static int intel_pt_recording_options(struct auxtrace_record *itr,</span>
 				ptr-&gt;have_sched_switch = 3;
 			} else {
 				opts-&gt;record_switch_events = true;
<span class="p_add">+				need_immediate = true;</span>
 				if (cpu_wide)
 					ptr-&gt;have_sched_switch = 3;
 				else
<span class="p_chunk">@@ -700,6 +701,9 @@</span> <span class="p_context"> static int intel_pt_recording_options(struct auxtrace_record *itr,</span>
 		tracking_evsel-&gt;attr.freq = 0;
 		tracking_evsel-&gt;attr.sample_period = 1;
 
<span class="p_add">+		if (need_immediate)</span>
<span class="p_add">+			tracking_evsel-&gt;immediate = true;</span>
<span class="p_add">+</span>
 		/* In per-cpu case, always need the time of mmap events etc */
 		if (!cpu_map__empty(cpus)) {
 			perf_evsel__set_sample_bit(tracking_evsel, TIME);
<span class="p_header">diff --git a/tools/perf/builtin-mem.c b/tools/perf/builtin-mem.c</span>
<span class="p_header">index 1dc140c5481d..3f02bea102b1 100644</span>
<span class="p_header">--- a/tools/perf/builtin-mem.c</span>
<span class="p_header">+++ b/tools/perf/builtin-mem.c</span>
<span class="p_chunk">@@ -87,6 +87,9 @@</span> <span class="p_context"> static int __cmd_record(int argc, const char **argv, struct perf_mem *mem)</span>
 	if (mem-&gt;operation &amp; MEM_OPERATION_LOAD)
 		perf_mem_events[PERF_MEM_EVENTS__LOAD].record = true;
 
<span class="p_add">+	if (mem-&gt;operation &amp; MEM_OPERATION_STORE)</span>
<span class="p_add">+		perf_mem_events[PERF_MEM_EVENTS__STORE].record = true;</span>
<span class="p_add">+</span>
 	if (perf_mem_events[PERF_MEM_EVENTS__LOAD].record)
 		rec_argv[i++] = &quot;-W&quot;;
 
<span class="p_header">diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c</span>
<span class="p_header">index 87a297dd8901..c33efb9d49f5 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol-elf.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol-elf.c</span>
<span class="p_chunk">@@ -827,7 +827,8 @@</span> <span class="p_context"> int dso__load_sym(struct dso *dso, struct map *map,</span>
 	sec = syms_ss-&gt;symtab;
 	shdr = syms_ss-&gt;symshdr;
 
<span class="p_del">-	if (elf_section_by_name(elf, &amp;ehdr, &amp;tshdr, &quot;.text&quot;, NULL))</span>
<span class="p_add">+	if (elf_section_by_name(runtime_ss-&gt;elf, &amp;runtime_ss-&gt;ehdr, &amp;tshdr,</span>
<span class="p_add">+				&quot;.text&quot;, NULL))</span>
 		dso-&gt;text_offset = tshdr.sh_addr - tshdr.sh_offset;
 
 	if (runtime_ss-&gt;opdsec)
<span class="p_header">diff --git a/tools/testing/nvdimm/test/nfit.c b/tools/testing/nvdimm/test/nfit.c</span>
<span class="p_header">index c919866853a0..1bfacc8e509a 100644</span>
<span class="p_header">--- a/tools/testing/nvdimm/test/nfit.c</span>
<span class="p_header">+++ b/tools/testing/nvdimm/test/nfit.c</span>
<span class="p_chunk">@@ -13,6 +13,7 @@</span> <span class="p_context"></span>
 #define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/dma-mapping.h&gt;
<span class="p_add">+#include &lt;linux/workqueue.h&gt;</span>
 #include &lt;linux/libnvdimm.h&gt;
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;linux/device.h&gt;
<span class="p_chunk">@@ -1480,6 +1481,7 @@</span> <span class="p_context"> static int nfit_test_probe(struct platform_device *pdev)</span>
 	if (nfit_test-&gt;setup != nfit_test0_setup)
 		return 0;
 
<span class="p_add">+	flush_work(&amp;acpi_desc-&gt;work);</span>
 	nfit_test-&gt;setup_hotplug = 1;
 	nfit_test-&gt;setup(nfit_test);
 

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



