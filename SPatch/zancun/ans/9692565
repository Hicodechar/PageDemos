
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[05/13] mm, memory_hotplug: split up register_one_node - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [05/13] mm, memory_hotplug: split up register_one_node</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>April 21, 2017, 12:05 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170421120512.23960-6-mhocko@kernel.org&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9692565/mbox/"
   >mbox</a>
|
   <a href="/patch/9692565/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9692565/">/patch/9692565/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	B7807601D4 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 21 Apr 2017 12:06:56 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id AA5A4267EC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 21 Apr 2017 12:06:56 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 9F35428521; Fri, 21 Apr 2017 12:06:56 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.4 required=2.0 tests=BAYES_00, RCVD_IN_DNSWL_HI, 
	RCVD_IN_SORBS_SPAM autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id CBBF4277D9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Fri, 21 Apr 2017 12:06:55 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1039137AbdDUMGq (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Fri, 21 Apr 2017 08:06:46 -0400
Received: from mail-io0-f193.google.com ([209.85.223.193]:35840 &quot;EHLO
	mail-io0-f193.google.com&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1039120AbdDUMGj (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Fri, 21 Apr 2017 08:06:39 -0400
Received: by mail-io0-f193.google.com with SMTP id x86so29657452ioe.3
	for &lt;linux-kernel@vger.kernel.org&gt;;
	Fri, 21 Apr 2017 05:06:39 -0700 (PDT)
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
	d=1e100.net; s=20161025;
	h=x-gm-message-state:from:to:cc:subject:date:message-id:in-reply-to
	:references;
	bh=u7lPrutV+4iA8Dp9xg+iQElig2B9Q26J82pWHhKwPOI=;
	b=pvSaZovMdB/gSDY30jkxvbKBAKvlKYKncPfAGkkOt09UO077cFVidwOrEhFcjhMItY
	O03cw73dBgVtwMMjkqykE+tG8R/uveXoaOTyDCHDPQU030HlBdT7aUnEs6NTC7qfYGtO
	wnrKsjdIwTzaAqdjbAx/MbQ5KaFy1lJ16g9GOyP8pJHFpTs7Ka6sBBpM9Lyo5y+Ov5oV
	m1c3JuZUlzNKvEgXAFviWuD9TXVNMnLt26IzXIRKFAte+M+Muw04wjNZte5qSZGUPFPY
	rCZfrXGWgUcSoRr/iVlKtSyCP7aNResmo1t58pHhKPuESNsfmyVwyzve3o3rZRPRQ+tW
	G6Sw==
X-Gm-Message-State: AN3rC/6audO7xXm648TRM/eaZYX51P9R96PLQogZoWRl4rSGxx1s+fKc
	LjA65iv6mmFATg==
X-Received: by 10.99.3.18 with SMTP id 18mr12104139pgd.105.1492776398831;
	Fri, 21 Apr 2017 05:06:38 -0700 (PDT)
Received: from tiehlicka.suse.cz (prg-ext-pat.suse.com. [213.151.95.130])
	by smtp.gmail.com with ESMTPSA id
	m19sm15951059pfg.115.2017.04.21.05.06.28
	(version=TLS1_2 cipher=ECDHE-RSA-AES128-GCM-SHA256 bits=128/128);
	Fri, 21 Apr 2017 05:06:38 -0700 (PDT)
From: Michal Hocko &lt;mhocko@kernel.org&gt;
To: linux-mm@kvack.org
Cc: Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	Mel Gorman &lt;mgorman@suse.de&gt;, Vlastimil Babka &lt;vbabka@suse.cz&gt;,
	Andrea Arcangeli &lt;aarcange@redhat.com&gt;,
	Jerome Glisse &lt;jglisse@redhat.com&gt;,
	Reza Arbab &lt;arbab@linux.vnet.ibm.com&gt;,
	Yasuaki Ishimatsu &lt;yasu.isimatu@gmail.com&gt;,
	qiuxishi@huawei.com, Kani Toshimitsu &lt;toshi.kani@hpe.com&gt;,
	slaoub@gmail.com, Joonsoo Kim &lt;js1304@gmail.com&gt;,
	Andi Kleen &lt;ak@linux.intel.com&gt;, David Rientjes &lt;rientjes@google.com&gt;,
	Daniel Kiper &lt;daniel.kiper@oracle.com&gt;,
	Igor Mammedov &lt;imammedo@redhat.com&gt;,
	Vitaly Kuznetsov &lt;vkuznets@redhat.com&gt;,
	LKML &lt;linux-kernel@vger.kernel.org&gt;, Michal Hocko &lt;mhocko@suse.com&gt;
Subject: [PATCH 05/13] mm, memory_hotplug: split up register_one_node
Date: Fri, 21 Apr 2017 14:05:08 +0200
Message-Id: &lt;20170421120512.23960-6-mhocko@kernel.org&gt;
X-Mailer: git-send-email 2.11.0
In-Reply-To: &lt;20170421120512.23960-1-mhocko@kernel.org&gt;
References: &lt;20170421120512.23960-1-mhocko@kernel.org&gt;
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=137061">Michal Hocko</a> - April 21, 2017, 12:05 p.m.</div>
<pre class="content">
<span class="from">From: Michal Hocko &lt;mhocko@suse.com&gt;</span>

Memory hotplug (add_memory_resource) has to reinitialize node
infrastructure if the node is offline (one which went through the
complete add_memory(); remove_memory() cycle). That involves node
registration to the kobj infrastructure (register_node), the proper
association with cpus (register_cpu_under_node) and finally creation of
node&lt;-&gt;memblock symlinks (link_mem_sections).

The last part requires to know node_start_pfn and node_spanned_pages
which we currently have but a leter patch will postpone this
initialization to the onlining phase which happens later. In fact we do
not need to rely on the early pgdat initialization even now because the
currently hot added pfn range is currently known.

Split register_one_node into core which does all the common work for
the boot time NUMA initialization and the hotplug (__register_one_node).
register_one_node keeps the full initialization while hotplug calls
__register_one_node and manually calls link_mem_sections for the proper
range.

This shouldn&#39;t introduce any functional change.
<span class="acked-by">
Acked-by: Vlastimil Babka &lt;vbabka@suse.cz&gt;</span>
<span class="signed-off-by">Signed-off-by: Michal Hocko &lt;mhocko@suse.com&gt;</span>
---
 drivers/base/node.c  | 51 ++++++++++++++++++++-------------------------------
 include/linux/node.h | 35 ++++++++++++++++++++++++++++++++++-
 mm/memory_hotplug.c  | 17 ++++++++++++++++-
 3 files changed, 70 insertions(+), 33 deletions(-)
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/drivers/base/node.c b/drivers/base/node.c</span>
<span class="p_header">index 06294d69779b..dff5b53f7905 100644</span>
<span class="p_header">--- a/drivers/base/node.c</span>
<span class="p_header">+++ b/drivers/base/node.c</span>
<span class="p_chunk">@@ -461,10 +461,9 @@</span> <span class="p_context"> int unregister_mem_sect_under_nodes(struct memory_block *mem_blk,</span>
 	return 0;
 }
 
<span class="p_del">-static int link_mem_sections(int nid)</span>
<span class="p_add">+int link_mem_sections(int nid, unsigned long start_pfn, unsigned long nr_pages)</span>
 {
<span class="p_del">-	unsigned long start_pfn = NODE_DATA(nid)-&gt;node_start_pfn;</span>
<span class="p_del">-	unsigned long end_pfn = start_pfn + NODE_DATA(nid)-&gt;node_spanned_pages;</span>
<span class="p_add">+	unsigned long end_pfn = start_pfn + nr_pages;</span>
 	unsigned long pfn;
 	struct memory_block *mem_blk = NULL;
 	int err = 0;
<span class="p_chunk">@@ -552,10 +551,7 @@</span> <span class="p_context"> static int node_memory_callback(struct notifier_block *self,</span>
 	return NOTIFY_OK;
 }
 #endif	/* CONFIG_HUGETLBFS */
<span class="p_del">-#else	/* !CONFIG_MEMORY_HOTPLUG_SPARSE */</span>
<span class="p_del">-</span>
<span class="p_del">-static int link_mem_sections(int nid) { return 0; }</span>
<span class="p_del">-#endif	/* CONFIG_MEMORY_HOTPLUG_SPARSE */</span>
<span class="p_add">+#endif /* CONFIG_MEMORY_HOTPLUG_SPARSE */</span>
 
 #if !defined(CONFIG_MEMORY_HOTPLUG_SPARSE) || \
     !defined(CONFIG_HUGETLBFS)
<span class="p_chunk">@@ -569,39 +565,32 @@</span> <span class="p_context"> static void init_node_hugetlb_work(int nid) { }</span>
 
 #endif
 
<span class="p_del">-int register_one_node(int nid)</span>
<span class="p_add">+int __register_one_node(int nid)</span>
 {
<span class="p_del">-	int error = 0;</span>
<span class="p_add">+	int p_node = parent_node(nid);</span>
<span class="p_add">+	struct node *parent = NULL;</span>
<span class="p_add">+	int error;</span>
 	int cpu;
 
<span class="p_del">-	if (node_online(nid)) {</span>
<span class="p_del">-		int p_node = parent_node(nid);</span>
<span class="p_del">-		struct node *parent = NULL;</span>
<span class="p_del">-</span>
<span class="p_del">-		if (p_node != nid)</span>
<span class="p_del">-			parent = node_devices[p_node];</span>
<span class="p_del">-</span>
<span class="p_del">-		node_devices[nid] = kzalloc(sizeof(struct node), GFP_KERNEL);</span>
<span class="p_del">-		if (!node_devices[nid])</span>
<span class="p_del">-			return -ENOMEM;</span>
<span class="p_del">-</span>
<span class="p_del">-		error = register_node(node_devices[nid], nid, parent);</span>
<span class="p_add">+	if (p_node != nid)</span>
<span class="p_add">+		parent = node_devices[p_node];</span>
 
<span class="p_del">-		/* link cpu under this node */</span>
<span class="p_del">-		for_each_present_cpu(cpu) {</span>
<span class="p_del">-			if (cpu_to_node(cpu) == nid)</span>
<span class="p_del">-				register_cpu_under_node(cpu, nid);</span>
<span class="p_del">-		}</span>
<span class="p_add">+	node_devices[nid] = kzalloc(sizeof(struct node), GFP_KERNEL);</span>
<span class="p_add">+	if (!node_devices[nid])</span>
<span class="p_add">+		return -ENOMEM;</span>
 
<span class="p_del">-		/* link memory sections under this node */</span>
<span class="p_del">-		error = link_mem_sections(nid);</span>
<span class="p_add">+	error = register_node(node_devices[nid], nid, parent);</span>
 
<span class="p_del">-		/* initialize work queue for memory hot plug */</span>
<span class="p_del">-		init_node_hugetlb_work(nid);</span>
<span class="p_add">+	/* link cpu under this node */</span>
<span class="p_add">+	for_each_present_cpu(cpu) {</span>
<span class="p_add">+		if (cpu_to_node(cpu) == nid)</span>
<span class="p_add">+			register_cpu_under_node(cpu, nid);</span>
 	}
 
<span class="p_del">-	return error;</span>
<span class="p_add">+	/* initialize work queue for memory hot plug */</span>
<span class="p_add">+	init_node_hugetlb_work(nid);</span>
 
<span class="p_add">+	return error;</span>
 }
 
 void unregister_one_node(int nid)
<span class="p_header">diff --git a/include/linux/node.h b/include/linux/node.h</span>
<span class="p_header">index 2115ad5d6f19..d1751beb462c 100644</span>
<span class="p_header">--- a/include/linux/node.h</span>
<span class="p_header">+++ b/include/linux/node.h</span>
<span class="p_chunk">@@ -30,9 +30,38 @@</span> <span class="p_context"> struct memory_block;</span>
 extern struct node *node_devices[];
 typedef  void (*node_registration_func_t)(struct node *);
 
<span class="p_add">+#if defined(CONFIG_MEMORY_HOTPLUG_SPARSE) &amp;&amp; defined(CONFIG_NUMA)</span>
<span class="p_add">+extern int link_mem_sections(int nid, unsigned long start_pfn, unsigned long nr_pages);</span>
<span class="p_add">+#else</span>
<span class="p_add">+static inline int link_mem_sections(int nid, unsigned long start_pfn, unsigned long nr_pages)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 extern void unregister_node(struct node *node);
 #ifdef CONFIG_NUMA
<span class="p_del">-extern int register_one_node(int nid);</span>
<span class="p_add">+/* Core of the node registration - only memory hotplug should use this */</span>
<span class="p_add">+extern int __register_one_node(int nid);</span>
<span class="p_add">+</span>
<span class="p_add">+/* Registers an online node */</span>
<span class="p_add">+static inline int register_one_node(int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int error = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (node_online(nid)) {</span>
<span class="p_add">+		struct pglist_data *pgdat = NODE_DATA(nid);</span>
<span class="p_add">+</span>
<span class="p_add">+		error = __register_one_node(nid);</span>
<span class="p_add">+		if (error)</span>
<span class="p_add">+			return error;</span>
<span class="p_add">+		/* link memory sections under this node */</span>
<span class="p_add">+		error = link_mem_sections(nid, pgdat-&gt;node_start_pfn, pgdat-&gt;node_spanned_pages);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return error;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 extern void unregister_one_node(int nid);
 extern int register_cpu_under_node(unsigned int cpu, unsigned int nid);
 extern int unregister_cpu_under_node(unsigned int cpu, unsigned int nid);
<span class="p_chunk">@@ -46,6 +75,10 @@</span> <span class="p_context"> extern void register_hugetlbfs_with_node(node_registration_func_t doregister,</span>
 					 node_registration_func_t unregister);
 #endif
 #else
<span class="p_add">+static inline int __register_one_node(int nid)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
 static inline int register_one_node(int nid)
 {
 	return 0;
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index c0147d3024eb..caa58338d121 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -1388,7 +1388,22 @@</span> <span class="p_context"> int __ref add_memory_resource(int nid, struct resource *res, bool online)</span>
 	node_set_online(nid);
 
 	if (new_node) {
<span class="p_del">-		ret = register_one_node(nid);</span>
<span class="p_add">+		unsigned long start_pfn = start &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+		unsigned long nr_pages = size &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+		ret = __register_one_node(nid);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto register_fail;</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * link memory sections under this node. This is already</span>
<span class="p_add">+		 * done when creatig memory section in register_new_memory</span>
<span class="p_add">+		 * but that depends to have the node registered so offline</span>
<span class="p_add">+		 * nodes have to go through register_node.</span>
<span class="p_add">+		 * TODO clean up this mess.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = link_mem_sections(nid, start_pfn, nr_pages);</span>
<span class="p_add">+register_fail:</span>
 		/*
 		 * If sysfs file of new node can&#39;t create, cpu on the node
 		 * can&#39;t be hot-added. There is no rollback way now.

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



