
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>[PATCHv2,1/2] x86/mm: Do not allow non-MAP_FIXED mapping across DEFAULT_MAP_WINDOW border - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    [PATCHv2,1/2] x86/mm: Do not allow non-MAP_FIXED mapping across DEFAULT_MAP_WINDOW border</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Nov. 14, 2017, 4:01 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;alpine.DEB.2.20.1711141630210.2044@nanos&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10057861/mbox/"
   >mbox</a>
|
   <a href="/patch/10057861/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10057861/">/patch/10057861/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	EE9286023A for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 14 Nov 2017 16:03:19 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id DE16E2985F
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 14 Nov 2017 16:03:19 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D2AB42986D; Tue, 14 Nov 2017 16:03:19 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 963282986A
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Tue, 14 Nov 2017 16:03:18 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932067AbdKNQDR (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Tue, 14 Nov 2017 11:03:17 -0500
Received: from Galois.linutronix.de ([146.0.238.70]:38009 &quot;EHLO
	Galois.linutronix.de&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S1754021AbdKNQCp (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Tue, 14 Nov 2017 11:02:45 -0500
Received: from hsi-kbw-5-158-153-52.hsi19.kabel-badenwuerttemberg.de
	([5.158.153.52] helo=nanos) by Galois.linutronix.de with esmtpsa
	(TLS1.2:DHE_RSA_AES_256_CBC_SHA256:256) (Exim 4.80)
	(envelope-from &lt;tglx@linutronix.de&gt;)
	id 1eEde5-0001o1-W6; Tue, 14 Nov 2017 17:01:06 +0100
Date: Tue, 14 Nov 2017 17:01:50 +0100 (CET)
From: Thomas Gleixner &lt;tglx@linutronix.de&gt;
To: &quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;
cc: Ingo Molnar &lt;mingo@redhat.com&gt;, x86@kernel.org,
	&quot;H. Peter Anvin&quot; &lt;hpa@zytor.com&gt;,
	Linus Torvalds &lt;torvalds@linux-foundation.org&gt;,
	Andy Lutomirski &lt;luto@amacapital.net&gt;,
	Nicholas Piggin &lt;npiggin@gmail.com&gt;, linux-mm@kvack.org,
	linux-kernel@vger.kernel.org
Subject: Re: [PATCHv2 1/2] x86/mm: Do not allow non-MAP_FIXED mapping across
	DEFAULT_MAP_WINDOW border
In-Reply-To: &lt;20171114134322.40321-1-kirill.shutemov@linux.intel.com&gt;
Message-ID: &lt;alpine.DEB.2.20.1711141630210.2044@nanos&gt;
References: &lt;20171114134322.40321-1-kirill.shutemov@linux.intel.com&gt;
User-Agent: Alpine 2.20 (DEB 67 2015-01-07)
MIME-Version: 1.0
Content-Type: text/plain; charset=US-ASCII
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Nov. 14, 2017, 4:01 p.m.</div>
<pre class="content">
On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:
<span class="quote">&gt; --- a/arch/x86/mm/hugetlbpage.c</span>
<span class="quote">&gt; +++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="quote">&gt; @@ -166,11 +166,20 @@ hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
<span class="quote">&gt;  </span>
<span class="quote">&gt;  	if (addr) {</span>
<span class="quote">&gt;  		addr = ALIGN(addr, huge_page_size(h));</span>
<span class="quote">&gt; +		if (TASK_SIZE - len &gt;= addr)</span>
<span class="quote">&gt; +			goto get_unmapped_area;</span>

That&#39;s wrong. You got it right in arch_get_unmapped_area_topdown() ...
<span class="quote">
&gt; +</span>
<span class="quote">&gt; +		/* See a comment in arch_get_unmapped_area_topdown */</span>

This is lame, really.
<span class="quote">
&gt; +		if ((addr &gt; DEFAULT_MAP_WINDOW) !=</span>
<span class="quote">&gt; +				(addr + len &gt; DEFAULT_MAP_WINDOW))</span>
<span class="quote">&gt; +			goto get_unmapped_area;</span>

Instead of duplicating that horrible formatted condition and adding this
lousy comment why can&#39;t you just put all of it (including the TASK_SIZE
check) into a proper validation function and put the comment there?

The fixed up variant of your patch below does that.

Aside of that please spend a bit more time on describing things precisely
at the technical and factual level next time. I fixed that up (once more)
both in the comment and the changelog.

Please double check.

Thanks,

	tglx

8&lt;----------------
Subject: x86/mm: Prevent non-MAP_FIXED mapping across DEFAULT_MAP_WINDOW border
<span class="from">From: &quot;Kirill A. Shutemov&quot; &lt;kirill.shutemov@linux.intel.com&gt;</span>
Date: Tue, 14 Nov 2017 16:43:21 +0300

In case of 5-level paging, the kernel does not place any mapping above
47-bit, unless userspace explicitly asks for it.

Userspace can request an allocation from the full address space by
specifying the mmap address hint above 47-bit.

Nicholas noticed that the current implementation violates this interface:

  If user space requests a mapping at the end of the 47-bit address space
  with a length which causes the mapping to cross the 47-bit border
  (DEFAULT_MAP_WINDOW), then the vma is partially in the address space
  below and above.

Sanity check the mmap address hint so that start and end of the resulting
vma are on the same side of the 47-bit border. If that&#39;s not the case fall
back to the code path which ignores the address hint and allocate from the
regular address space below 47-bit.

[ tglx: Moved the address check to a function and massaged comment and
  	changelog ]

Reported-by: Nicholas Piggin &lt;npiggin@gmail.com&gt;
<span class="signed-off-by">Signed-off-by: Kirill A. Shutemov &lt;kirill.shutemov@linux.intel.com&gt;</span>
<span class="signed-off-by">Signed-off-by: Thomas Gleixner &lt;tglx@linutronix.de&gt;</span>
Cc: Andy Lutomirski &lt;luto@amacapital.net&gt;
Cc: linux-mm@kvack.org
Cc: Linus Torvalds &lt;torvalds@linux-foundation.org&gt;
Link: https://lkml.kernel.org/r/20171114134322.40321-1-kirill.shutemov@linux.intel.com

---
 arch/x86/include/asm/elf.h   |    1 
 arch/x86/kernel/sys_x86_64.c |    8 +++++--
 arch/x86/mm/hugetlbpage.c    |    9 ++++++-
 arch/x86/mm/mmap.c           |   49 +++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 63 insertions(+), 4 deletions(-)
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Nov. 14, 2017, 7:21 p.m.</div>
<pre class="content">
On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:
<span class="quote">&gt; On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; --- a/arch/x86/mm/hugetlbpage.c</span>
<span class="quote">&gt; &gt; +++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="quote">&gt; &gt; @@ -166,11 +166,20 @@ hugetlb_get_unmapped_area(struct file *file, unsigned long addr,</span>
<span class="quote">&gt; &gt;  </span>
<span class="quote">&gt; &gt;  	if (addr) {</span>
<span class="quote">&gt; &gt;  		addr = ALIGN(addr, huge_page_size(h));</span>
<span class="quote">&gt; &gt; +		if (TASK_SIZE - len &gt;= addr)</span>
<span class="quote">&gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That&#39;s wrong. You got it right in arch_get_unmapped_area_topdown() ...</span>

Ouch.

Please ignore selftest patch. I&#39;ll rework it to cover hugetlb.
<span class="quote">
&gt; &gt; +</span>
<span class="quote">&gt; &gt; +		/* See a comment in arch_get_unmapped_area_topdown */</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; This is lame, really.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; +		if ((addr &gt; DEFAULT_MAP_WINDOW) !=</span>
<span class="quote">&gt; &gt; +				(addr + len &gt; DEFAULT_MAP_WINDOW))</span>
<span class="quote">&gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Instead of duplicating that horrible formatted condition and adding this</span>
<span class="quote">&gt; lousy comment why can&#39;t you just put all of it (including the TASK_SIZE</span>
<span class="quote">&gt; check) into a proper validation function and put the comment there?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; The fixed up variant of your patch below does that.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Aside of that please spend a bit more time on describing things precisely</span>
<span class="quote">&gt; at the technical and factual level next time. I fixed that up (once more)</span>
<span class="quote">&gt; both in the comment and the changelog.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Please double check.</span>

Works fine.
<span class="quote">
&gt; +bool mmap_address_hint_valid(unsigned long addr, unsigned long len)</span>
<span class="quote">&gt; +{</span>
<span class="quote">&gt; +	if (TASK_SIZE - len &lt; addr)</span>
<span class="quote">&gt; +		return false;</span>
<span class="quote">&gt; +#if CONFIG_PGTABLE_LEVELS &gt;= 5</span>
<span class="quote">&gt; +	return (addr &gt; DEFAULT_MAP_WINDOW) == (addr + len &gt; DEFAULT_MAP_WINDOW);</span>

Is it micro optimization? I don&#39;t feel it necessary. It&#39;s not that hot
codepath to care about few cycles. (And one more place to care about for
boot-time switching.)

If you think it&#39;s needed, maybe IS_ENABLED() instead?
<span class="quote">
&gt; +#else</span>
<span class="quote">&gt; +	return true;</span>
<span class="quote">&gt; +#endif</span>
<span class="quote">&gt; +}</span>
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Nov. 14, 2017, 8:21 p.m.</div>
<pre class="content">
On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:
<span class="quote">&gt; @@ -198,11 +199,14 @@ arch_get_unmapped_area_topdown(struct fi</span>
<span class="quote">&gt;  	/* requesting a specific address */</span>
<span class="quote">&gt;  	if (addr) {</span>
<span class="quote">&gt;  		addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; +		if (!mmap_address_hint_valid(addr, len))</span>
<span class="quote">&gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; +</span>

Here and in hugetlb_get_unmapped_area(), we should align the addr after
the check, not before. Otherwise the alignment itself can bring us over
the borderline as we align up.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Nov. 14, 2017, 8:29 p.m.</div>
<pre class="content">
On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:
<span class="quote">&gt; On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; +bool mmap_address_hint_valid(unsigned long addr, unsigned long len)</span>
<span class="quote">&gt; &gt; +{</span>
<span class="quote">&gt; &gt; +	if (TASK_SIZE - len &lt; addr)</span>
<span class="quote">&gt; &gt; +		return false;</span>
<span class="quote">&gt; &gt; +#if CONFIG_PGTABLE_LEVELS &gt;= 5</span>
<span class="quote">&gt; &gt; +	return (addr &gt; DEFAULT_MAP_WINDOW) == (addr + len &gt; DEFAULT_MAP_WINDOW);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Is it micro optimization? I don&#39;t feel it necessary. It&#39;s not that hot</span>
<span class="quote">&gt; codepath to care about few cycles. (And one more place to care about for</span>
<span class="quote">&gt; boot-time switching.)</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; If you think it&#39;s needed, maybe IS_ENABLED() instead?</span>

You&#39;re right. It&#39;s can be unconditional, For page table levels &lt; 5 its just
redundant as its covered by the TASK_SIZE check already.

Thanks,

	tglx
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Nov. 14, 2017, 8:54 p.m.</div>
<pre class="content">
On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:
<span class="quote">
&gt; On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; @@ -198,11 +199,14 @@ arch_get_unmapped_area_topdown(struct fi</span>
<span class="quote">&gt; &gt;  	/* requesting a specific address */</span>
<span class="quote">&gt; &gt;  	if (addr) {</span>
<span class="quote">&gt; &gt;  		addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; +		if (!mmap_address_hint_valid(addr, len))</span>
<span class="quote">&gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; &gt; +</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Here and in hugetlb_get_unmapped_area(), we should align the addr after</span>
<span class="quote">&gt; the check, not before. Otherwise the alignment itself can bring us over</span>
<span class="quote">&gt; the borderline as we align up.</span>

Hmm, then I wonder whether the next check against vm_start_gap() which
checks against the aligned address is correct:

                addr = PAGE_ALIGN(addr);
                vma = find_vma(mm, addr);

                if (end - len &gt;= addr &amp;&amp;
                    (!vma || addr + len &lt;= vm_start_gap(vma)))
                        return addr;

Thanks,

	tglx
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Nov. 14, 2017, 10:27 p.m.</div>
<pre class="content">
On Tue, Nov 14, 2017 at 09:54:52PM +0100, Thomas Gleixner wrote:
<span class="quote">&gt; On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt; On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; @@ -198,11 +199,14 @@ arch_get_unmapped_area_topdown(struct fi</span>
<span class="quote">&gt; &gt; &gt;  	/* requesting a specific address */</span>
<span class="quote">&gt; &gt; &gt;  	if (addr) {</span>
<span class="quote">&gt; &gt; &gt;  		addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt; +		if (!mmap_address_hint_valid(addr, len))</span>
<span class="quote">&gt; &gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Here and in hugetlb_get_unmapped_area(), we should align the addr after</span>
<span class="quote">&gt; &gt; the check, not before. Otherwise the alignment itself can bring us over</span>
<span class="quote">&gt; &gt; the borderline as we align up.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Hmm, then I wonder whether the next check against vm_start_gap() which</span>
<span class="quote">&gt; checks against the aligned address is correct:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;                 addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt;                 vma = find_vma(mm, addr);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;                 if (end - len &gt;= addr &amp;&amp;</span>
<span class="quote">&gt;                     (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="quote">&gt;                         return addr;</span>

I think the check is correct. The check is against resulting addresses
that end up in vm_start/vm_end. In our case we want to figure out what
user asked for.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Nov. 14, 2017, 11 p.m.</div>
<pre class="content">
On Wed, 15 Nov 2017, Kirill A. Shutemov wrote:
<span class="quote">&gt; On Tue, Nov 14, 2017 at 09:54:52PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; @@ -198,11 +199,14 @@ arch_get_unmapped_area_topdown(struct fi</span>
<span class="quote">&gt; &gt; &gt; &gt;  	/* requesting a specific address */</span>
<span class="quote">&gt; &gt; &gt; &gt;  	if (addr) {</span>
<span class="quote">&gt; &gt; &gt; &gt;  		addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt; &gt; +		if (!mmap_address_hint_valid(addr, len))</span>
<span class="quote">&gt; &gt; &gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Here and in hugetlb_get_unmapped_area(), we should align the addr after</span>
<span class="quote">&gt; &gt; &gt; the check, not before. Otherwise the alignment itself can bring us over</span>
<span class="quote">&gt; &gt; &gt; the borderline as we align up.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Hmm, then I wonder whether the next check against vm_start_gap() which</span>
<span class="quote">&gt; &gt; checks against the aligned address is correct:</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;                 addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt;                 vma = find_vma(mm, addr);</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;                 if (end - len &gt;= addr &amp;&amp;</span>
<span class="quote">&gt; &gt;                     (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="quote">&gt; &gt;                         return addr;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think the check is correct. The check is against resulting addresses</span>
<span class="quote">&gt; that end up in vm_start/vm_end. In our case we want to figure out what</span>
<span class="quote">&gt; user asked for.</span>

Well, but then checking just against the user supplied addr is only half of
the story.

    addr = boundary - PAGE_SIZE - PAGE_SIZE / 2;
    len = PAGE_SIZE - PAGE_SIZE / 2;

That fits, but then after alignment we end up with

    addr = boudary - PAGE_SIZE;

and due to len &gt; PAGE_SIZE this will result in a mapping which crosses the
boundary, right? So checking against the PAGE_ALIGN(addr) should be the
right thing to do.

Thanks,

	tglx
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Nov. 15, 2017, 11:27 a.m.</div>
<pre class="content">
On Wed, Nov 15, 2017 at 12:00:46AM +0100, Thomas Gleixner wrote:
<span class="quote">&gt; On Wed, 15 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; On Tue, Nov 14, 2017 at 09:54:52PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; @@ -198,11 +199,14 @@ arch_get_unmapped_area_topdown(struct fi</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  	/* requesting a specific address */</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  	if (addr) {</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;  		addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +		if (!mmap_address_hint_valid(addr, len))</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Here and in hugetlb_get_unmapped_area(), we should align the addr after</span>
<span class="quote">&gt; &gt; &gt; &gt; the check, not before. Otherwise the alignment itself can bring us over</span>
<span class="quote">&gt; &gt; &gt; &gt; the borderline as we align up.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Hmm, then I wonder whether the next check against vm_start_gap() which</span>
<span class="quote">&gt; &gt; &gt; checks against the aligned address is correct:</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt;                 addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt;                 vma = find_vma(mm, addr);</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt;                 if (end - len &gt;= addr &amp;&amp;</span>
<span class="quote">&gt; &gt; &gt;                     (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="quote">&gt; &gt; &gt;                         return addr;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I think the check is correct. The check is against resulting addresses</span>
<span class="quote">&gt; &gt; that end up in vm_start/vm_end. In our case we want to figure out what</span>
<span class="quote">&gt; &gt; user asked for.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Well, but then checking just against the user supplied addr is only half of</span>
<span class="quote">&gt; the story.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     addr = boundary - PAGE_SIZE - PAGE_SIZE / 2;</span>
<span class="quote">&gt;     len = PAGE_SIZE - PAGE_SIZE / 2;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; That fits, but then after alignment we end up with</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;     addr = boudary - PAGE_SIZE;</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; and due to len &gt; PAGE_SIZE this will result in a mapping which crosses the</span>
<span class="quote">&gt; boundary, right? So checking against the PAGE_ALIGN(addr) should be the</span>
<span class="quote">&gt; right thing to do.</span>

IIUC, this is only the case if &#39;len&#39; is not aligned, right?

From what I see we expect caller to align it (and mm/mmap.c does this, I
haven&#39;t checked other callers).

And hugetlb would actively reject non-aligned len.

I *think* we should be fine with checking unaligned &#39;addr&#39;.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Nov. 15, 2017, 11:39 a.m.</div>
<pre class="content">
On Wed, 15 Nov 2017, Kirill A. Shutemov wrote:
<span class="quote">&gt; On Wed, Nov 15, 2017 at 12:00:46AM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; On Wed, 15 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; &gt; On Tue, Nov 14, 2017 at 09:54:52PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; @@ -198,11 +199,14 @@ arch_get_unmapped_area_topdown(struct fi</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  	/* requesting a specific address */</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  	if (addr) {</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt;  		addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; +		if (!mmap_address_hint_valid(addr, len))</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Here and in hugetlb_get_unmapped_area(), we should align the addr after</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; the check, not before. Otherwise the alignment itself can bring us over</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; the borderline as we align up.</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; Hmm, then I wonder whether the next check against vm_start_gap() which</span>
<span class="quote">&gt; &gt; &gt; &gt; checks against the aligned address is correct:</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt;                 addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt; &gt;                 vma = find_vma(mm, addr);</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt;                 if (end - len &gt;= addr &amp;&amp;</span>
<span class="quote">&gt; &gt; &gt; &gt;                     (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="quote">&gt; &gt; &gt; &gt;                         return addr;</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; I think the check is correct. The check is against resulting addresses</span>
<span class="quote">&gt; &gt; &gt; that end up in vm_start/vm_end. In our case we want to figure out what</span>
<span class="quote">&gt; &gt; &gt; user asked for.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; Well, but then checking just against the user supplied addr is only half of</span>
<span class="quote">&gt; &gt; the story.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;     addr = boundary - PAGE_SIZE - PAGE_SIZE / 2;</span>
<span class="quote">&gt; &gt;     len = PAGE_SIZE - PAGE_SIZE / 2;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; That fits, but then after alignment we end up with</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt;     addr = boudary - PAGE_SIZE;</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; and due to len &gt; PAGE_SIZE this will result in a mapping which crosses the</span>
<span class="quote">&gt; &gt; boundary, right? So checking against the PAGE_ALIGN(addr) should be the</span>
<span class="quote">&gt; &gt; right thing to do.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; IIUC, this is only the case if &#39;len&#39; is not aligned, right?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; &gt;From what I see we expect caller to align it (and mm/mmap.c does this, I</span>
<span class="quote">&gt; haven&#39;t checked other callers).</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; And hugetlb would actively reject non-aligned len.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I *think* we should be fine with checking unaligned &#39;addr&#39;.</span>

I think we should keep it consistent for the normal and the huge case and
just check aligned and be done with it.

Thanks,

	tglx
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=874">Kirill A. Shutemov</a> - Nov. 15, 2017, 12:10 p.m.</div>
<pre class="content">
On Wed, Nov 15, 2017 at 12:39:40PM +0100, Thomas Gleixner wrote:
<span class="quote">&gt; On Wed, 15 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; On Wed, Nov 15, 2017 at 12:00:46AM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; On Wed, 15 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; On Tue, Nov 14, 2017 at 09:54:52PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; On Tue, 14 Nov 2017, Kirill A. Shutemov wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; On Tue, Nov 14, 2017 at 05:01:50PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; &gt; @@ -198,11 +199,14 @@ arch_get_unmapped_area_topdown(struct fi</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; &gt;  	/* requesting a specific address */</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; &gt;  	if (addr) {</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; &gt;  		addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; &gt; +		if (!mmap_address_hint_valid(addr, len))</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; &gt; +			goto get_unmapped_area;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; &gt; +</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; Here and in hugetlb_get_unmapped_area(), we should align the addr after</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; the check, not before. Otherwise the alignment itself can bring us over</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; &gt; the borderline as we align up.</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; Hmm, then I wonder whether the next check against vm_start_gap() which</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; checks against the aligned address is correct:</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;                 addr = PAGE_ALIGN(addr);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;                 vma = find_vma(mm, addr);</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;                 if (end - len &gt;= addr &amp;&amp;</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;                     (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="quote">&gt; &gt; &gt; &gt; &gt;                         return addr;</span>
<span class="quote">&gt; &gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; &gt; I think the check is correct. The check is against resulting addresses</span>
<span class="quote">&gt; &gt; &gt; &gt; that end up in vm_start/vm_end. In our case we want to figure out what</span>
<span class="quote">&gt; &gt; &gt; &gt; user asked for.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; Well, but then checking just against the user supplied addr is only half of</span>
<span class="quote">&gt; &gt; &gt; the story.</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt;     addr = boundary - PAGE_SIZE - PAGE_SIZE / 2;</span>
<span class="quote">&gt; &gt; &gt;     len = PAGE_SIZE - PAGE_SIZE / 2;</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; That fits, but then after alignment we end up with</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt;     addr = boudary - PAGE_SIZE;</span>
<span class="quote">&gt; &gt; &gt; </span>
<span class="quote">&gt; &gt; &gt; and due to len &gt; PAGE_SIZE this will result in a mapping which crosses the</span>
<span class="quote">&gt; &gt; &gt; boundary, right? So checking against the PAGE_ALIGN(addr) should be the</span>
<span class="quote">&gt; &gt; &gt; right thing to do.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; IIUC, this is only the case if &#39;len&#39; is not aligned, right?</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; &gt;From what I see we expect caller to align it (and mm/mmap.c does this, I</span>
<span class="quote">&gt; &gt; haven&#39;t checked other callers).</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; And hugetlb would actively reject non-aligned len.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I *think* we should be fine with checking unaligned &#39;addr&#39;.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; I think we should keep it consistent for the normal and the huge case and</span>
<span class="quote">&gt; just check aligned and be done with it.</span>

Aligned &#39;addr&#39;? Or &#39;len&#39;? Both?

We would have problem with checking aligned addr. I steped it in hugetlb
case:

  - User asks for mmap((1UL &lt;&lt; 47) - PAGE_SIZE, 2 &lt;&lt; 20, MAP_HUGETLB);

  - On 4-level paging machine this gives us invalid hint address as
    &#39;TASK_SIZE - len&#39; is more than &#39;addr&#39;. Goto get_unmapped_area.

  - On 5-level paging machine hint address gets rounded up to next 2MB
    boundary that is exactly 1UL &lt;&lt; 47 and we happily allocate from full
    address space which may lead to trouble.
</pre>
</div>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=107">Thomas Gleixner</a> - Nov. 15, 2017, 2:18 p.m.</div>
<pre class="content">
On Wed, 15 Nov 2017, Kirill A. Shutemov wrote:
<span class="quote">&gt; On Wed, Nov 15, 2017 at 12:39:40PM +0100, Thomas Gleixner wrote:</span>
<span class="quote">&gt; &gt; &gt; I *think* we should be fine with checking unaligned &#39;addr&#39;.</span>
<span class="quote">&gt; &gt; </span>
<span class="quote">&gt; &gt; I think we should keep it consistent for the normal and the huge case and</span>
<span class="quote">&gt; &gt; just check aligned and be done with it.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; Aligned &#39;addr&#39;? Or &#39;len&#39;? Both?</span>
<span class="quote">&gt; </span>
<span class="quote">&gt; We would have problem with checking aligned addr. I steped it in hugetlb</span>
<span class="quote">&gt; case:</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   - User asks for mmap((1UL &lt;&lt; 47) - PAGE_SIZE, 2 &lt;&lt; 20, MAP_HUGETLB);</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   - On 4-level paging machine this gives us invalid hint address as</span>
<span class="quote">&gt;     &#39;TASK_SIZE - len&#39; is more than &#39;addr&#39;. Goto get_unmapped_area.</span>
<span class="quote">&gt; </span>
<span class="quote">&gt;   - On 5-level paging machine hint address gets rounded up to next 2MB</span>
<span class="quote">&gt;     boundary that is exactly 1UL &lt;&lt; 47 and we happily allocate from full</span>
<span class="quote">&gt;     address space which may lead to trouble.</span>

Ah, right because that ALIGN is using huge_page_size(h) and not PAGE_SIZE.
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">--- a/arch/x86/include/asm/elf.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/elf.h</span>
<span class="p_chunk">@@ -309,6 +309,7 @@</span> <span class="p_context"> static inline int mmap_is_ia32(void)</span>
 extern unsigned long task_size_32bit(void);
 extern unsigned long task_size_64bit(int full_addr_space);
 extern unsigned long get_mmap_base(int is_legacy);
<span class="p_add">+extern bool mmap_address_hint_valid(unsigned long addr, unsigned long len);</span>
 
 #ifdef CONFIG_X86_32
 
<span class="p_header">--- a/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_header">+++ b/arch/x86/kernel/sys_x86_64.c</span>
<span class="p_chunk">@@ -188,6 +188,7 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct fi</span>
 	if (len &gt; TASK_SIZE)
 		return -ENOMEM;
 
<span class="p_add">+	/* No address checking. See comment at mmap_address_hint_valid() */</span>
 	if (flags &amp; MAP_FIXED)
 		return addr;
 
<span class="p_chunk">@@ -198,11 +199,14 @@</span> <span class="p_context"> arch_get_unmapped_area_topdown(struct fi</span>
 	/* requesting a specific address */
 	if (addr) {
 		addr = PAGE_ALIGN(addr);
<span class="p_add">+		if (!mmap_address_hint_valid(addr, len))</span>
<span class="p_add">+			goto get_unmapped_area;</span>
<span class="p_add">+</span>
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp;</span>
<span class="p_del">-				(!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="p_add">+		if (!vma || addr + len &lt;= vm_start_gap(vma))</span>
 			return addr;
 	}
<span class="p_add">+get_unmapped_area:</span>
 
 	info.flags = VM_UNMAPPED_AREA_TOPDOWN;
 	info.length = len;
<span class="p_header">--- a/arch/x86/mm/hugetlbpage.c</span>
<span class="p_header">+++ b/arch/x86/mm/hugetlbpage.c</span>
<span class="p_chunk">@@ -158,6 +158,7 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *f</span>
 	if (len &gt; TASK_SIZE)
 		return -ENOMEM;
 
<span class="p_add">+	/* No address checking. See comment at mmap_address_hint_valid() */</span>
 	if (flags &amp; MAP_FIXED) {
 		if (prepare_hugepage_range(file, addr, len))
 			return -EINVAL;
<span class="p_chunk">@@ -166,11 +167,15 @@</span> <span class="p_context"> hugetlb_get_unmapped_area(struct file *f</span>
 
 	if (addr) {
 		addr = ALIGN(addr, huge_page_size(h));
<span class="p_add">+		if (!mmap_address_hint_valid(addr, len))</span>
<span class="p_add">+			goto get_unmapped_area;</span>
<span class="p_add">+</span>
 		vma = find_vma(mm, addr);
<span class="p_del">-		if (TASK_SIZE - len &gt;= addr &amp;&amp;</span>
<span class="p_del">-		    (!vma || addr + len &lt;= vm_start_gap(vma)))</span>
<span class="p_add">+		if (!vma || addr + len &lt;= vm_start_gap(vma))</span>
 			return addr;
 	}
<span class="p_add">+</span>
<span class="p_add">+get_unmapped_area:</span>
 	if (mm-&gt;get_unmapped_area == arch_get_unmapped_area)
 		return hugetlb_get_unmapped_area_bottomup(file, addr, len,
 				pgoff, flags);
<span class="p_header">--- a/arch/x86/mm/mmap.c</span>
<span class="p_header">+++ b/arch/x86/mm/mmap.c</span>
<span class="p_chunk">@@ -174,3 +174,52 @@</span> <span class="p_context"> const char *arch_vma_name(struct vm_area</span>
 		return &quot;[mpx]&quot;;
 	return NULL;
 }
<span class="p_add">+</span>
<span class="p_add">+/**</span>
<span class="p_add">+ * mmap_address_hint_valid - Validate the address hint of mmap</span>
<span class="p_add">+ * @addr:	Address hint</span>
<span class="p_add">+ * @len:	Mapping length</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Check whether @addr and @addr + @len result in a valid mapping.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * On 32bit this only checks whether @addr + @len is &lt;= TASK_SIZE.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * On 64bit with 5-level page tables another sanity check is required</span>
<span class="p_add">+ * because mappings requested by mmap(@addr, 0) which cross the 47-bit</span>
<span class="p_add">+ * virtual address boundary can cause the following theoretical issue:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  An application calls mmap(addr, 0), i.e. without MAP_FIXED, where @addr</span>
<span class="p_add">+ *  is below the border of the 47-bit address space and @addr + @len is</span>
<span class="p_add">+ *  above the border.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  With 4-level paging this request succeeds, but the resulting mapping</span>
<span class="p_add">+ *  address will always be within the 47-bit virtual address space, because</span>
<span class="p_add">+ *  the hint address does not result in a valid mapping and is</span>
<span class="p_add">+ *  ignored. Hence applications which are not prepared to handle virtual</span>
<span class="p_add">+ *  addresses above 47-bit work correctly.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *  With 5-level paging this request would be granted and result in a</span>
<span class="p_add">+ *  mapping which crosses the border of the 47-bit virtual address</span>
<span class="p_add">+ *  space. If the application cannot handle addresses above 47-bit this</span>
<span class="p_add">+ *  will lead to misbehaviour and hard to diagnose failures.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Therefore ignore address hints which would result in a mapping crossing</span>
<span class="p_add">+ * the 47-bit virtual address boundary.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Note, that in the same scenario with MAP_FIXED the behaviour is</span>
<span class="p_add">+ * different. The request with @addr &lt; 47-bit and @addr + @len &gt; 47-bit</span>
<span class="p_add">+ * fails on a 4-level paging machine but succeeds on a 5-level paging</span>
<span class="p_add">+ * machine. It is reasonable to expect that an application does not rely on</span>
<span class="p_add">+ * the failure of such a fixed mapping request, so the restriction is not</span>
<span class="p_add">+ * applied.</span>
<span class="p_add">+ */</span>
<span class="p_add">+bool mmap_address_hint_valid(unsigned long addr, unsigned long len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (TASK_SIZE - len &lt; addr)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+#if CONFIG_PGTABLE_LEVELS &gt;= 5</span>
<span class="p_add">+	return (addr &gt; DEFAULT_MAP_WINDOW) == (addr + len &gt; DEFAULT_MAP_WINDOW);</span>
<span class="p_add">+#else</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+#endif</span>
<span class="p_add">+}</span>

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



