
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 4.9.87 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 4.9.87</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>March 11, 2018, 4:45 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20180311164520.GB23799@kroah.com&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/10274861/mbox/"
   >mbox</a>
|
   <a href="/patch/10274861/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/10274861/">/patch/10274861/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	172D1602BD for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 11 Mar 2018 16:45:34 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id E2F3928CCC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 11 Mar 2018 16:45:33 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id D5D1628CF8; Sun, 11 Mar 2018 16:45:33 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 0BF1A28CCC
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Sun, 11 Mar 2018 16:45:30 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S932379AbeCKQp1 (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Sun, 11 Mar 2018 12:45:27 -0400
Received: from mail.linuxfoundation.org ([140.211.169.12]:42394 &quot;EHLO
	mail.linuxfoundation.org&quot; rhost-flags-OK-OK-OK-OK) by vger.kernel.org
	with ESMTP id S932153AbeCKQpU (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Sun, 11 Mar 2018 12:45:20 -0400
Received: from localhost (LFbn-1-12258-90.w90-92.abo.wanadoo.fr
	[90.92.71.90])
	by mail.linuxfoundation.org (Postfix) with ESMTPSA id 1FE23F33;
	Sun, 11 Mar 2018 16:45:18 +0000 (UTC)
Date: Sun, 11 Mar 2018 17:45:20 +0100
From: Greg KH &lt;gregkh@linuxfoundation.org&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, stable@vger.kernel.org
Cc: lwn@lwn.net, Jiri Slaby &lt;jslaby@suse.cz&gt;
Subject: Re: Linux 4.9.87
Message-ID: &lt;20180311164520.GB23799@kroah.com&gt;
References: &lt;20180311164516.GA23799@kroah.com&gt;
MIME-Version: 1.0
Content-Type: text/plain; charset=us-ascii
Content-Disposition: inline
In-Reply-To: &lt;20180311164516.GA23799@kroah.com&gt;
User-Agent: Mutt/1.9.4 (2018-02-28)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=37061">gregkh@linuxfoundation.org</a> - March 11, 2018, 4:45 p.m.</div>
<pre class="content">

</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index e918d25e95bb..3043937a65d1 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 4
 PATCHLEVEL = 9
<span class="p_del">-SUBLEVEL = 86</span>
<span class="p_add">+SUBLEVEL = 87</span>
 EXTRAVERSION =
 NAME = Roaring Lionus
 
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-som-lv.dtsi b/arch/arm/boot/dts/logicpd-som-lv.dtsi</span>
<span class="p_header">index 4f2c5ec75714..e262fa9ef334 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-som-lv.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-som-lv.dtsi</span>
<span class="p_chunk">@@ -97,6 +97,8 @@</span> <span class="p_context"></span>
 };
 
 &amp;i2c1 {
<span class="p_add">+	pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;i2c1_pins&gt;;</span>
 	clock-frequency = &lt;2600000&gt;;
 
 	twl: twl@48 {
<span class="p_chunk">@@ -215,7 +217,12 @@</span> <span class="p_context"></span>
 		&gt;;
 	};
 
<span class="p_del">-</span>
<span class="p_add">+	i2c1_pins: pinmux_i2c1_pins {</span>
<span class="p_add">+		pinctrl-single,pins = &lt;</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21ba, PIN_INPUT | MUX_MODE0)        /* i2c1_scl.i2c1_scl */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21bc, PIN_INPUT | MUX_MODE0)        /* i2c1_sda.i2c1_sda */</span>
<span class="p_add">+		&gt;;</span>
<span class="p_add">+	};</span>
 };
 
 &amp;omap3_pmx_wkup {
<span class="p_header">diff --git a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">index efe53998c961..08f0a35dc0d1 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/logicpd-torpedo-som.dtsi</span>
<span class="p_chunk">@@ -100,6 +100,8 @@</span> <span class="p_context"></span>
 };
 
 &amp;i2c1 {
<span class="p_add">+	pinctrl-names = &quot;default&quot;;</span>
<span class="p_add">+	pinctrl-0 = &lt;&amp;i2c1_pins&gt;;</span>
 	clock-frequency = &lt;2600000&gt;;
 
 	twl: twl@48 {
<span class="p_chunk">@@ -207,6 +209,12 @@</span> <span class="p_context"></span>
 			OMAP3_CORE1_IOPAD(0x21b8, PIN_INPUT | MUX_MODE0)	/* hsusb0_data7.hsusb0_data7 */
 		&gt;;
 	};
<span class="p_add">+	i2c1_pins: pinmux_i2c1_pins {</span>
<span class="p_add">+		pinctrl-single,pins = &lt;</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21ba, PIN_INPUT | MUX_MODE0)        /* i2c1_scl.i2c1_scl */</span>
<span class="p_add">+			OMAP3_CORE1_IOPAD(0x21bc, PIN_INPUT | MUX_MODE0)        /* i2c1_sda.i2c1_sda */</span>
<span class="p_add">+		&gt;;</span>
<span class="p_add">+	};</span>
 };
 
 &amp;uart2 {
<span class="p_header">diff --git a/arch/arm/kvm/hyp/Makefile b/arch/arm/kvm/hyp/Makefile</span>
<span class="p_header">index 92eab1d51785..61049216e4d5 100644</span>
<span class="p_header">--- a/arch/arm/kvm/hyp/Makefile</span>
<span class="p_header">+++ b/arch/arm/kvm/hyp/Makefile</span>
<span class="p_chunk">@@ -6,6 +6,8 @@</span> <span class="p_context"> ccflags-y += -fno-stack-protector -DDISABLE_BRANCH_PROFILING</span>
 
 KVM=../../../../virt/kvm
 
<span class="p_add">+CFLAGS_ARMV7VE		   :=$(call cc-option, -march=armv7ve)</span>
<span class="p_add">+</span>
 obj-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/hyp/vgic-v2-sr.o
 obj-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/hyp/vgic-v3-sr.o
 obj-$(CONFIG_KVM_ARM_HOST) += $(KVM)/arm/hyp/timer-sr.o
<span class="p_chunk">@@ -14,7 +16,10 @@</span> <span class="p_context"> obj-$(CONFIG_KVM_ARM_HOST) += tlb.o</span>
 obj-$(CONFIG_KVM_ARM_HOST) += cp15-sr.o
 obj-$(CONFIG_KVM_ARM_HOST) += vfp.o
 obj-$(CONFIG_KVM_ARM_HOST) += banked-sr.o
<span class="p_add">+CFLAGS_banked-sr.o	   += $(CFLAGS_ARMV7VE)</span>
<span class="p_add">+</span>
 obj-$(CONFIG_KVM_ARM_HOST) += entry.o
 obj-$(CONFIG_KVM_ARM_HOST) += hyp-entry.o
 obj-$(CONFIG_KVM_ARM_HOST) += switch.o
<span class="p_add">+CFLAGS_switch.o		   += $(CFLAGS_ARMV7VE)</span>
 obj-$(CONFIG_KVM_ARM_HOST) += s2-setup.o
<span class="p_header">diff --git a/arch/arm/kvm/hyp/banked-sr.c b/arch/arm/kvm/hyp/banked-sr.c</span>
<span class="p_header">index 111bda8cdebd..be4b8b0a40ad 100644</span>
<span class="p_header">--- a/arch/arm/kvm/hyp/banked-sr.c</span>
<span class="p_header">+++ b/arch/arm/kvm/hyp/banked-sr.c</span>
<span class="p_chunk">@@ -20,6 +20,10 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/kvm_hyp.h&gt;
 
<span class="p_add">+/*</span>
<span class="p_add">+ * gcc before 4.9 doesn&#39;t understand -march=armv7ve, so we have to</span>
<span class="p_add">+ * trick the assembler.</span>
<span class="p_add">+ */</span>
 __asm__(&quot;.arch_extension     virt&quot;);
 
 void __hyp_text __banked_save_state(struct kvm_cpu_context *ctxt)
<span class="p_header">diff --git a/arch/arm/mach-mvebu/Kconfig b/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_header">index 541647f57192..895c0746fe50 100644</span>
<span class="p_header">--- a/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_header">+++ b/arch/arm/mach-mvebu/Kconfig</span>
<span class="p_chunk">@@ -42,7 +42,7 @@</span> <span class="p_context"> config MACH_ARMADA_375</span>
 	depends on ARCH_MULTI_V7
 	select ARMADA_370_XP_IRQ
 	select ARM_ERRATA_720789
<span class="p_del">-	select ARM_ERRATA_753970</span>
<span class="p_add">+	select PL310_ERRATA_753970</span>
 	select ARM_GIC
 	select ARMADA_375_CLK
 	select HAVE_ARM_SCU
<span class="p_chunk">@@ -58,7 +58,7 @@</span> <span class="p_context"> config MACH_ARMADA_38X</span>
 	bool &quot;Marvell Armada 380/385 boards&quot;
 	depends on ARCH_MULTI_V7
 	select ARM_ERRATA_720789
<span class="p_del">-	select ARM_ERRATA_753970</span>
<span class="p_add">+	select PL310_ERRATA_753970</span>
 	select ARM_GIC
 	select ARMADA_370_XP_IRQ
 	select ARMADA_38X_CLK
<span class="p_header">diff --git a/arch/arm64/net/bpf_jit_comp.c b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">index d8199e12fb6e..b47a26f4290c 100644</span>
<span class="p_header">--- a/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/arm64/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -234,8 +234,9 @@</span> <span class="p_context"> static int emit_bpf_tail_call(struct jit_ctx *ctx)</span>
 	off = offsetof(struct bpf_array, map.max_entries);
 	emit_a64_mov_i64(tmp, off, ctx);
 	emit(A64_LDR32(tmp, r2, tmp), ctx);
<span class="p_add">+	emit(A64_MOV(0, r3, r3), ctx);</span>
 	emit(A64_CMP(0, r3, tmp), ctx);
<span class="p_del">-	emit(A64_B_(A64_COND_GE, jmp_offset), ctx);</span>
<span class="p_add">+	emit(A64_B_(A64_COND_CS, jmp_offset), ctx);</span>
 
 	/* if (tail_call_cnt &gt; MAX_TAIL_CALL_CNT)
 	 *     goto out;
<span class="p_chunk">@@ -243,7 +244,7 @@</span> <span class="p_context"> static int emit_bpf_tail_call(struct jit_ctx *ctx)</span>
 	 */
 	emit_a64_mov_i64(tmp, MAX_TAIL_CALL_CNT, ctx);
 	emit(A64_CMP(1, tcc, tmp), ctx);
<span class="p_del">-	emit(A64_B_(A64_COND_GT, jmp_offset), ctx);</span>
<span class="p_add">+	emit(A64_B_(A64_COND_HI, jmp_offset), ctx);</span>
 	emit(A64_ADD_I(1, tcc, tcc, 1), ctx);
 
 	/* prog = array-&gt;ptrs[index];
<span class="p_header">diff --git a/arch/parisc/include/asm/cacheflush.h b/arch/parisc/include/asm/cacheflush.h</span>
<span class="p_header">index 1d8c24dc04d4..88290d32b956 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/cacheflush.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/cacheflush.h</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"> void flush_user_icache_range_asm(unsigned long, unsigned long);</span>
 void flush_kernel_icache_range_asm(unsigned long, unsigned long);
 void flush_user_dcache_range_asm(unsigned long, unsigned long);
 void flush_kernel_dcache_range_asm(unsigned long, unsigned long);
<span class="p_add">+void purge_kernel_dcache_range_asm(unsigned long, unsigned long);</span>
 void flush_kernel_dcache_page_asm(void *);
 void flush_kernel_icache_page(void *);
 void flush_user_dcache_range(unsigned long, unsigned long);
<span class="p_header">diff --git a/arch/parisc/kernel/cache.c b/arch/parisc/kernel/cache.c</span>
<span class="p_header">index df757c9675e6..025afe5f17a7 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/cache.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/cache.c</span>
<span class="p_chunk">@@ -464,10 +464,10 @@</span> <span class="p_context"> EXPORT_SYMBOL(copy_user_page);</span>
 int __flush_tlb_range(unsigned long sid, unsigned long start,
 		      unsigned long end)
 {
<span class="p_del">-	unsigned long flags, size;</span>
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_del">-	size = (end - start);</span>
<span class="p_del">-	if (size &gt;= parisc_tlb_flush_threshold) {</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    end - start &gt;= parisc_tlb_flush_threshold) {</span>
 		flush_tlb_all();
 		return 1;
 	}
<span class="p_chunk">@@ -538,13 +538,11 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 	struct vm_area_struct *vma;
 	pgd_t *pgd;
 
<span class="p_del">-	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_del">-	if (parisc_requires_coherency())</span>
<span class="p_del">-		flush_tlb_all();</span>
<span class="p_del">-</span>
 	/* Flushing the whole cache on each cpu takes forever on
 	   rp3440, etc.  So, avoid it if the mm isn&#39;t too big.  */
<span class="p_del">-	if (mm_total_size(mm) &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    mm_total_size(mm) &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+		flush_tlb_all();</span>
 		flush_cache_all();
 		return;
 	}
<span class="p_chunk">@@ -552,9 +550,9 @@</span> <span class="p_context"> void flush_cache_mm(struct mm_struct *mm)</span>
 	if (mm-&gt;context == mfsp(3)) {
 		for (vma = mm-&gt;mmap; vma; vma = vma-&gt;vm_next) {
 			flush_user_dcache_range_asm(vma-&gt;vm_start, vma-&gt;vm_end);
<span class="p_del">-			if ((vma-&gt;vm_flags &amp; VM_EXEC) == 0)</span>
<span class="p_del">-				continue;</span>
<span class="p_del">-			flush_user_icache_range_asm(vma-&gt;vm_start, vma-&gt;vm_end);</span>
<span class="p_add">+			if (vma-&gt;vm_flags &amp; VM_EXEC)</span>
<span class="p_add">+				flush_user_icache_range_asm(vma-&gt;vm_start, vma-&gt;vm_end);</span>
<span class="p_add">+			flush_tlb_range(vma, vma-&gt;vm_start, vma-&gt;vm_end);</span>
 		}
 		return;
 	}
<span class="p_chunk">@@ -598,14 +596,9 @@</span> <span class="p_context"> flush_user_icache_range(unsigned long start, unsigned long end)</span>
 void flush_cache_range(struct vm_area_struct *vma,
 		unsigned long start, unsigned long end)
 {
<span class="p_del">-	BUG_ON(!vma-&gt;vm_mm-&gt;context);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* Flush the TLB to avoid speculation if coherency is required. */</span>
<span class="p_del">-	if (parisc_requires_coherency())</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    end - start &gt;= parisc_cache_flush_threshold) {</span>
 		flush_tlb_range(vma, start, end);
<span class="p_del">-</span>
<span class="p_del">-	if ((end - start) &gt;= parisc_cache_flush_threshold</span>
<span class="p_del">-	    || vma-&gt;vm_mm-&gt;context != mfsp(3)) {</span>
 		flush_cache_all();
 		return;
 	}
<span class="p_chunk">@@ -613,6 +606,7 @@</span> <span class="p_context"> void flush_cache_range(struct vm_area_struct *vma,</span>
 	flush_user_dcache_range_asm(start, end);
 	if (vma-&gt;vm_flags &amp; VM_EXEC)
 		flush_user_icache_range_asm(start, end);
<span class="p_add">+	flush_tlb_range(vma, start, end);</span>
 }
 
 void
<span class="p_chunk">@@ -621,8 +615,7 @@</span> <span class="p_context"> flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long</span>
 	BUG_ON(!vma-&gt;vm_mm-&gt;context);
 
 	if (pfn_valid(pfn)) {
<span class="p_del">-		if (parisc_requires_coherency())</span>
<span class="p_del">-			flush_tlb_page(vma, vmaddr);</span>
<span class="p_add">+		flush_tlb_page(vma, vmaddr);</span>
 		__flush_cache_page(vma, vmaddr, PFN_PHYS(pfn));
 	}
 }
<span class="p_chunk">@@ -630,21 +623,33 @@</span> <span class="p_context"> flush_cache_page(struct vm_area_struct *vma, unsigned long vmaddr, unsigned long</span>
 void flush_kernel_vmap_range(void *vaddr, int size)
 {
 	unsigned long start = (unsigned long)vaddr;
<span class="p_add">+	unsigned long end = start + size;</span>
 
<span class="p_del">-	if ((unsigned long)size &gt; parisc_cache_flush_threshold)</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    (unsigned long)size &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+		flush_tlb_kernel_range(start, end);</span>
 		flush_data_cache();
<span class="p_del">-	else</span>
<span class="p_del">-		flush_kernel_dcache_range_asm(start, start + size);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	flush_kernel_dcache_range_asm(start, end);</span>
<span class="p_add">+	flush_tlb_kernel_range(start, end);</span>
 }
 EXPORT_SYMBOL(flush_kernel_vmap_range);
 
 void invalidate_kernel_vmap_range(void *vaddr, int size)
 {
 	unsigned long start = (unsigned long)vaddr;
<span class="p_add">+	unsigned long end = start + size;</span>
 
<span class="p_del">-	if ((unsigned long)size &gt; parisc_cache_flush_threshold)</span>
<span class="p_add">+	if ((!IS_ENABLED(CONFIG_SMP) || !arch_irqs_disabled()) &amp;&amp;</span>
<span class="p_add">+	    (unsigned long)size &gt;= parisc_cache_flush_threshold) {</span>
<span class="p_add">+		flush_tlb_kernel_range(start, end);</span>
 		flush_data_cache();
<span class="p_del">-	else</span>
<span class="p_del">-		flush_kernel_dcache_range_asm(start, start + size);</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	purge_kernel_dcache_range_asm(start, end);</span>
<span class="p_add">+	flush_tlb_kernel_range(start, end);</span>
 }
 EXPORT_SYMBOL(invalidate_kernel_vmap_range);
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index 2d40c4ff3f69..67b0f7532e83 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -1110,6 +1110,28 @@</span> <span class="p_context"> ENTRY_CFI(flush_kernel_dcache_range_asm)</span>
 	.procend
 ENDPROC_CFI(flush_kernel_dcache_range_asm)
 
<span class="p_add">+ENTRY_CFI(purge_kernel_dcache_range_asm)</span>
<span class="p_add">+	.proc</span>
<span class="p_add">+	.callinfo NO_CALLS</span>
<span class="p_add">+	.entry</span>
<span class="p_add">+</span>
<span class="p_add">+	ldil		L%dcache_stride, %r1</span>
<span class="p_add">+	ldw		R%dcache_stride(%r1), %r23</span>
<span class="p_add">+	ldo		-1(%r23), %r21</span>
<span class="p_add">+	ANDCM		%r26, %r21, %r26</span>
<span class="p_add">+</span>
<span class="p_add">+1:      cmpb,COND(&lt;&lt;),n	%r26, %r25,1b</span>
<span class="p_add">+	pdc,m		%r23(%r26)</span>
<span class="p_add">+</span>
<span class="p_add">+	sync</span>
<span class="p_add">+	syncdma</span>
<span class="p_add">+	bv		%r0(%r2)</span>
<span class="p_add">+	nop</span>
<span class="p_add">+	.exit</span>
<span class="p_add">+</span>
<span class="p_add">+	.procend</span>
<span class="p_add">+ENDPROC_CFI(purge_kernel_dcache_range_asm)</span>
<span class="p_add">+</span>
 ENTRY_CFI(flush_user_icache_range_asm)
 	.proc
 	.callinfo NO_CALLS
<span class="p_header">diff --git a/arch/powerpc/net/bpf_jit_comp64.c b/arch/powerpc/net/bpf_jit_comp64.c</span>
<span class="p_header">index 0fe98a567125..be9d968244ad 100644</span>
<span class="p_header">--- a/arch/powerpc/net/bpf_jit_comp64.c</span>
<span class="p_header">+++ b/arch/powerpc/net/bpf_jit_comp64.c</span>
<span class="p_chunk">@@ -245,6 +245,7 @@</span> <span class="p_context"> static void bpf_jit_emit_tail_call(u32 *image, struct codegen_context *ctx, u32</span>
 	 *   goto out;
 	 */
 	PPC_LWZ(b2p[TMP_REG_1], b2p_bpf_array, offsetof(struct bpf_array, map.max_entries));
<span class="p_add">+	PPC_RLWINM(b2p_index, b2p_index, 0, 0, 31);</span>
 	PPC_CMPLW(b2p_index, b2p[TMP_REG_1]);
 	PPC_BCC(COND_GE, out);
 
<span class="p_header">diff --git a/arch/x86/include/asm/mmu.h b/arch/x86/include/asm/mmu.h</span>
<span class="p_header">index 8b272a08d1a8..e2e09347ee3c 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu.h</span>
<span class="p_chunk">@@ -3,12 +3,18 @@</span> <span class="p_context"></span>
 
 #include &lt;linux/spinlock.h&gt;
 #include &lt;linux/mutex.h&gt;
<span class="p_add">+#include &lt;linux/atomic.h&gt;</span>
 
 /*
<span class="p_del">- * The x86 doesn&#39;t have a mmu context, but</span>
<span class="p_del">- * we put the segment information here.</span>
<span class="p_add">+ * x86 has arch-specific MMU state beyond what lives in mm_struct.</span>
  */
 typedef struct {
<span class="p_add">+	/*</span>
<span class="p_add">+	 * ctx_id uniquely identifies this mm_struct.  A ctx_id will never</span>
<span class="p_add">+	 * be reused, and zero is not a valid ctx_id.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	u64 ctx_id;</span>
<span class="p_add">+</span>
 #ifdef CONFIG_MODIFY_LDT_SYSCALL
 	struct ldt_struct *ldt;
 #endif
<span class="p_chunk">@@ -33,6 +39,11 @@</span> <span class="p_context"> typedef struct {</span>
 #endif
 } mm_context_t;
 
<span class="p_add">+#define INIT_MM_CONTEXT(mm)						\</span>
<span class="p_add">+	.context = {							\</span>
<span class="p_add">+		.ctx_id = 1,						\</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 void leave_mm(int cpu);
 
 #endif /* _ASM_X86_MMU_H */
<span class="p_header">diff --git a/arch/x86/include/asm/mmu_context.h b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">index d23e35584f15..5a295bb97103 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/mmu_context.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/mmu_context.h</span>
<span class="p_chunk">@@ -12,6 +12,9 @@</span> <span class="p_context"></span>
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/paravirt.h&gt;
 #include &lt;asm/mpx.h&gt;
<span class="p_add">+</span>
<span class="p_add">+extern atomic64_t last_mm_ctx_id;</span>
<span class="p_add">+</span>
 #ifndef CONFIG_PARAVIRT
 static inline void paravirt_activate_mm(struct mm_struct *prev,
 					struct mm_struct *next)
<span class="p_chunk">@@ -106,6 +109,8 @@</span> <span class="p_context"> static inline void enter_lazy_tlb(struct mm_struct *mm, struct task_struct *tsk)</span>
 static inline int init_new_context(struct task_struct *tsk,
 				   struct mm_struct *mm)
 {
<span class="p_add">+	mm-&gt;context.ctx_id = atomic64_inc_return(&amp;last_mm_ctx_id);</span>
<span class="p_add">+</span>
 	#ifdef CONFIG_X86_INTEL_MEMORY_PROTECTION_KEYS
 	if (cpu_feature_enabled(X86_FEATURE_OSPKE)) {
 		/* pkey 0 is the default and always allocated */
<span class="p_header">diff --git a/arch/x86/include/asm/nospec-branch.h b/arch/x86/include/asm/nospec-branch.h</span>
<span class="p_header">index 76b058533e47..81a1be326571 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/nospec-branch.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/nospec-branch.h</span>
<span class="p_chunk">@@ -177,4 +177,41 @@</span> <span class="p_context"> static inline void indirect_branch_prediction_barrier(void)</span>
 }
 
 #endif /* __ASSEMBLY__ */
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Below is used in the eBPF JIT compiler and emits the byte sequence</span>
<span class="p_add">+ * for the following assembly:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * With retpolines configured:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *    callq do_rop</span>
<span class="p_add">+ *  spec_trap:</span>
<span class="p_add">+ *    pause</span>
<span class="p_add">+ *    lfence</span>
<span class="p_add">+ *    jmp spec_trap</span>
<span class="p_add">+ *  do_rop:</span>
<span class="p_add">+ *    mov %rax,(%rsp)</span>
<span class="p_add">+ *    retq</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Without retpolines configured:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *    jmp *%rax</span>
<span class="p_add">+ */</span>
<span class="p_add">+#ifdef CONFIG_RETPOLINE</span>
<span class="p_add">+# define RETPOLINE_RAX_BPF_JIT_SIZE	17</span>
<span class="p_add">+# define RETPOLINE_RAX_BPF_JIT()				\</span>
<span class="p_add">+	EMIT1_off32(0xE8, 7);	 /* callq do_rop */		\</span>
<span class="p_add">+	/* spec_trap: */					\</span>
<span class="p_add">+	EMIT2(0xF3, 0x90);       /* pause */			\</span>
<span class="p_add">+	EMIT3(0x0F, 0xAE, 0xE8); /* lfence */			\</span>
<span class="p_add">+	EMIT2(0xEB, 0xF9);       /* jmp spec_trap */		\</span>
<span class="p_add">+	/* do_rop: */						\</span>
<span class="p_add">+	EMIT4(0x48, 0x89, 0x04, 0x24); /* mov %rax,(%rsp) */	\</span>
<span class="p_add">+	EMIT1(0xC3);             /* retq */</span>
<span class="p_add">+#else</span>
<span class="p_add">+# define RETPOLINE_RAX_BPF_JIT_SIZE	2</span>
<span class="p_add">+# define RETPOLINE_RAX_BPF_JIT()				\</span>
<span class="p_add">+	EMIT2(0xFF, 0xE0);	 /* jmp *%rax */</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* _ASM_X86_NOSPEC_BRANCH_H_ */
<span class="p_header">diff --git a/arch/x86/include/asm/tlbflush.h b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">index 94146f665a3c..99185a064978 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/tlbflush.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/tlbflush.h</span>
<span class="p_chunk">@@ -68,6 +68,8 @@</span> <span class="p_context"> static inline void invpcid_flush_all_nonglobals(void)</span>
 struct tlb_state {
 	struct mm_struct *active_mm;
 	int state;
<span class="p_add">+	/* last user mm&#39;s ctx id */</span>
<span class="p_add">+	u64 last_ctx_id;</span>
 
 	/*
 	 * Access to this CR4 shadow and to H/W CR4 is protected by
<span class="p_header">diff --git a/arch/x86/kernel/apic/vector.c b/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">index b5229abd1629..4922ab66fd29 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/vector.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/vector.c</span>
<span class="p_chunk">@@ -93,8 +93,12 @@</span> <span class="p_context"> static struct apic_chip_data *alloc_apic_chip_data(int node)</span>
 	return NULL;
 }
 
<span class="p_del">-static void free_apic_chip_data(struct apic_chip_data *data)</span>
<span class="p_add">+static void free_apic_chip_data(unsigned int virq, struct apic_chip_data *data)</span>
 {
<span class="p_add">+#ifdef	CONFIG_X86_IO_APIC</span>
<span class="p_add">+	if (virq  &lt; nr_legacy_irqs())</span>
<span class="p_add">+		legacy_irq_data[virq] = NULL;</span>
<span class="p_add">+#endif</span>
 	if (data) {
 		free_cpumask_var(data-&gt;domain);
 		free_cpumask_var(data-&gt;old_domain);
<span class="p_chunk">@@ -318,11 +322,7 @@</span> <span class="p_context"> static void x86_vector_free_irqs(struct irq_domain *domain,</span>
 			apic_data = irq_data-&gt;chip_data;
 			irq_domain_reset_irq_data(irq_data);
 			raw_spin_unlock_irqrestore(&amp;vector_lock, flags);
<span class="p_del">-			free_apic_chip_data(apic_data);</span>
<span class="p_del">-#ifdef	CONFIG_X86_IO_APIC</span>
<span class="p_del">-			if (virq + i &lt; nr_legacy_irqs())</span>
<span class="p_del">-				legacy_irq_data[virq + i] = NULL;</span>
<span class="p_del">-#endif</span>
<span class="p_add">+			free_apic_chip_data(virq + i, apic_data);</span>
 		}
 	}
 }
<span class="p_chunk">@@ -363,7 +363,7 @@</span> <span class="p_context"> static int x86_vector_alloc_irqs(struct irq_domain *domain, unsigned int virq,</span>
 		err = assign_irq_vector_policy(virq + i, node, data, info);
 		if (err) {
 			irq_data-&gt;chip_data = NULL;
<span class="p_del">-			free_apic_chip_data(data);</span>
<span class="p_add">+			free_apic_chip_data(virq + i, data);</span>
 			goto error;
 		}
 	}
<span class="p_header">diff --git a/arch/x86/kvm/svm.c b/arch/x86/kvm/svm.c</span>
<span class="p_header">index be644afab1bb..24d2a3ee743f 100644</span>
<span class="p_header">--- a/arch/x86/kvm/svm.c</span>
<span class="p_header">+++ b/arch/x86/kvm/svm.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/debugreg.h&gt;
 #include &lt;asm/kvm_para.h&gt;
 #include &lt;asm/irq_remapping.h&gt;
<span class="p_add">+#include &lt;asm/microcode.h&gt;</span>
 #include &lt;asm/nospec-branch.h&gt;
 
 #include &lt;asm/virtext.h&gt;
<span class="p_chunk">@@ -4919,7 +4920,7 @@</span> <span class="p_context"> static void svm_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * being speculatively taken.
 	 */
 	if (svm-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, svm-&gt;spec_ctrl);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, svm-&gt;spec_ctrl);</span>
 
 	asm volatile (
 		&quot;push %%&quot; _ASM_BP &quot;; \n\t&quot;
<span class="p_chunk">@@ -5028,11 +5029,11 @@</span> <span class="p_context"> static void svm_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * If the L02 MSR bitmap does not intercept the MSR, then we need to
 	 * save it.
 	 */
<span class="p_del">-	if (!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL))</span>
<span class="p_del">-		rdmsrl(MSR_IA32_SPEC_CTRL, svm-&gt;spec_ctrl);</span>
<span class="p_add">+	if (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))</span>
<span class="p_add">+		svm-&gt;spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);</span>
 
 	if (svm-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
 
 	/* Eliminate branch target predictions from guest mode */
 	vmexit_fill_RSB();
<span class="p_header">diff --git a/arch/x86/kvm/vmx.c b/arch/x86/kvm/vmx.c</span>
<span class="p_header">index c51aaac953b4..0f3bb4632310 100644</span>
<span class="p_header">--- a/arch/x86/kvm/vmx.c</span>
<span class="p_header">+++ b/arch/x86/kvm/vmx.c</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"></span>
 #include &lt;asm/kexec.h&gt;
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/irq_remapping.h&gt;
<span class="p_add">+#include &lt;asm/microcode.h&gt;</span>
 #include &lt;asm/nospec-branch.h&gt;
 
 #include &quot;trace.h&quot;
<span class="p_chunk">@@ -8906,7 +8907,7 @@</span> <span class="p_context"> static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * being speculatively taken.
 	 */
 	if (vmx-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, vmx-&gt;spec_ctrl);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, vmx-&gt;spec_ctrl);</span>
 
 	vmx-&gt;__launched = vmx-&gt;loaded_vmcs-&gt;launched;
 	asm(
<span class="p_chunk">@@ -9041,11 +9042,11 @@</span> <span class="p_context"> static void __noclone vmx_vcpu_run(struct kvm_vcpu *vcpu)</span>
 	 * If the L02 MSR bitmap does not intercept the MSR, then we need to
 	 * save it.
 	 */
<span class="p_del">-	if (!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL))</span>
<span class="p_del">-		rdmsrl(MSR_IA32_SPEC_CTRL, vmx-&gt;spec_ctrl);</span>
<span class="p_add">+	if (unlikely(!msr_write_intercepted(vcpu, MSR_IA32_SPEC_CTRL)))</span>
<span class="p_add">+		vmx-&gt;spec_ctrl = native_read_msr(MSR_IA32_SPEC_CTRL);</span>
 
 	if (vmx-&gt;spec_ctrl)
<span class="p_del">-		wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
<span class="p_add">+		native_wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
 
 	/* Eliminate branch target predictions from guest mode */
 	vmexit_fill_RSB();
<span class="p_header">diff --git a/arch/x86/mm/tlb.c b/arch/x86/mm/tlb.c</span>
<span class="p_header">index 578973ade71b..eac92e2d171b 100644</span>
<span class="p_header">--- a/arch/x86/mm/tlb.c</span>
<span class="p_header">+++ b/arch/x86/mm/tlb.c</span>
<span class="p_chunk">@@ -10,6 +10,7 @@</span> <span class="p_context"></span>
 
 #include &lt;asm/tlbflush.h&gt;
 #include &lt;asm/mmu_context.h&gt;
<span class="p_add">+#include &lt;asm/nospec-branch.h&gt;</span>
 #include &lt;asm/cache.h&gt;
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/uv/uv.h&gt;
<span class="p_chunk">@@ -29,6 +30,8 @@</span> <span class="p_context"></span>
  *	Implement flush IPI by CALL_FUNCTION_VECTOR, Alex Shi
  */
 
<span class="p_add">+atomic64_t last_mm_ctx_id = ATOMIC64_INIT(1);</span>
<span class="p_add">+</span>
 struct flush_tlb_info {
 	struct mm_struct *flush_mm;
 	unsigned long flush_start;
<span class="p_chunk">@@ -104,6 +107,28 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 	unsigned cpu = smp_processor_id();
 
 	if (likely(prev != next)) {
<span class="p_add">+		u64 last_ctx_id = this_cpu_read(cpu_tlbstate.last_ctx_id);</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Avoid user/user BTB poisoning by flushing the branch</span>
<span class="p_add">+		 * predictor when switching between processes. This stops</span>
<span class="p_add">+		 * one process from doing Spectre-v2 attacks on another.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * As an optimization, flush indirect branches only when</span>
<span class="p_add">+		 * switching into processes that disable dumping. This</span>
<span class="p_add">+		 * protects high value processes like gpg, without having</span>
<span class="p_add">+		 * too high performance overhead. IBPB is *expensive*!</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * This will not flush branches when switching into kernel</span>
<span class="p_add">+		 * threads. It will also not flush if we switch to idle</span>
<span class="p_add">+		 * thread and back to the same process. It will flush if we</span>
<span class="p_add">+		 * switch to a different non-dumpable process.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (tsk &amp;&amp; tsk-&gt;mm &amp;&amp;</span>
<span class="p_add">+		    tsk-&gt;mm-&gt;context.ctx_id != last_ctx_id &amp;&amp;</span>
<span class="p_add">+		    get_dumpable(tsk-&gt;mm) != SUID_DUMP_USER)</span>
<span class="p_add">+			indirect_branch_prediction_barrier();</span>
<span class="p_add">+</span>
 		if (IS_ENABLED(CONFIG_VMAP_STACK)) {
 			/*
 			 * If our current stack is in vmalloc space and isn&#39;t
<span class="p_chunk">@@ -118,6 +143,14 @@</span> <span class="p_context"> void switch_mm_irqs_off(struct mm_struct *prev, struct mm_struct *next,</span>
 				set_pgd(pgd, init_mm.pgd[stack_pgd_index]);
 		}
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Record last user mm&#39;s context id, so we can avoid</span>
<span class="p_add">+		 * flushing branch buffer with IBPB if we switch back</span>
<span class="p_add">+		 * to the same user.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (next != &amp;init_mm)</span>
<span class="p_add">+			this_cpu_write(cpu_tlbstate.last_ctx_id, next-&gt;context.ctx_id);</span>
<span class="p_add">+</span>
 		this_cpu_write(cpu_tlbstate.state, TLBSTATE_OK);
 		this_cpu_write(cpu_tlbstate.active_mm, next);
 
<span class="p_header">diff --git a/arch/x86/net/bpf_jit_comp.c b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">index 7840331d3056..1f7ed2ed6ff7 100644</span>
<span class="p_header">--- a/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_header">+++ b/arch/x86/net/bpf_jit_comp.c</span>
<span class="p_chunk">@@ -12,6 +12,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/filter.h&gt;
 #include &lt;linux/if_vlan.h&gt;
 #include &lt;asm/cacheflush.h&gt;
<span class="p_add">+#include &lt;asm/nospec-branch.h&gt;</span>
 #include &lt;linux/bpf.h&gt;
 
 int bpf_jit_enable __read_mostly;
<span class="p_chunk">@@ -281,7 +282,7 @@</span> <span class="p_context"> static void emit_bpf_tail_call(u8 **pprog)</span>
 	EMIT2(0x89, 0xD2);                        /* mov edx, edx */
 	EMIT3(0x39, 0x56,                         /* cmp dword ptr [rsi + 16], edx */
 	      offsetof(struct bpf_array, map.max_entries));
<span class="p_del">-#define OFFSET1 43 /* number of bytes to jump */</span>
<span class="p_add">+#define OFFSET1 (41 + RETPOLINE_RAX_BPF_JIT_SIZE) /* number of bytes to jump */</span>
 	EMIT2(X86_JBE, OFFSET1);                  /* jbe out */
 	label1 = cnt;
 
<span class="p_chunk">@@ -290,7 +291,7 @@</span> <span class="p_context"> static void emit_bpf_tail_call(u8 **pprog)</span>
 	 */
 	EMIT2_off32(0x8B, 0x85, -STACKSIZE + 36); /* mov eax, dword ptr [rbp - 516] */
 	EMIT3(0x83, 0xF8, MAX_TAIL_CALL_CNT);     /* cmp eax, MAX_TAIL_CALL_CNT */
<span class="p_del">-#define OFFSET2 32</span>
<span class="p_add">+#define OFFSET2 (30 + RETPOLINE_RAX_BPF_JIT_SIZE)</span>
 	EMIT2(X86_JA, OFFSET2);                   /* ja out */
 	label2 = cnt;
 	EMIT3(0x83, 0xC0, 0x01);                  /* add eax, 1 */
<span class="p_chunk">@@ -304,7 +305,7 @@</span> <span class="p_context"> static void emit_bpf_tail_call(u8 **pprog)</span>
 	 *   goto out;
 	 */
 	EMIT3(0x48, 0x85, 0xC0);		  /* test rax,rax */
<span class="p_del">-#define OFFSET3 10</span>
<span class="p_add">+#define OFFSET3 (8 + RETPOLINE_RAX_BPF_JIT_SIZE)</span>
 	EMIT2(X86_JE, OFFSET3);                   /* je out */
 	label3 = cnt;
 
<span class="p_chunk">@@ -317,7 +318,7 @@</span> <span class="p_context"> static void emit_bpf_tail_call(u8 **pprog)</span>
 	 * rdi == ctx (1st arg)
 	 * rax == prog-&gt;bpf_func + prologue_size
 	 */
<span class="p_del">-	EMIT2(0xFF, 0xE0);                        /* jmp rax */</span>
<span class="p_add">+	RETPOLINE_RAX_BPF_JIT();</span>
 
 	/* out: */
 	BUILD_BUG_ON(cnt - label1 != OFFSET1);
<span class="p_header">diff --git a/arch/x86/platform/intel-mid/intel-mid.c b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">index 7850128f0026..834783bc6752 100644</span>
<span class="p_header">--- a/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_header">+++ b/arch/x86/platform/intel-mid/intel-mid.c</span>
<span class="p_chunk">@@ -79,7 +79,7 @@</span> <span class="p_context"> static void intel_mid_power_off(void)</span>
 
 static void intel_mid_reboot(void)
 {
<span class="p_del">-	intel_scu_ipc_simple_command(IPCMSG_COLD_BOOT, 0);</span>
<span class="p_add">+	intel_scu_ipc_simple_command(IPCMSG_COLD_RESET, 0);</span>
 }
 
 static unsigned long __init intel_mid_calibrate_tsc(void)
<span class="p_header">diff --git a/arch/x86/xen/suspend.c b/arch/x86/xen/suspend.c</span>
<span class="p_header">index 7f664c416faf..4ecd0de08557 100644</span>
<span class="p_header">--- a/arch/x86/xen/suspend.c</span>
<span class="p_header">+++ b/arch/x86/xen/suspend.c</span>
<span class="p_chunk">@@ -1,11 +1,14 @@</span> <span class="p_context"></span>
 #include &lt;linux/types.h&gt;
 #include &lt;linux/tick.h&gt;
<span class="p_add">+#include &lt;linux/percpu-defs.h&gt;</span>
 
 #include &lt;xen/xen.h&gt;
 #include &lt;xen/interface/xen.h&gt;
 #include &lt;xen/grant_table.h&gt;
 #include &lt;xen/events.h&gt;
 
<span class="p_add">+#include &lt;asm/cpufeatures.h&gt;</span>
<span class="p_add">+#include &lt;asm/msr-index.h&gt;</span>
 #include &lt;asm/xen/hypercall.h&gt;
 #include &lt;asm/xen/page.h&gt;
 #include &lt;asm/fixmap.h&gt;
<span class="p_chunk">@@ -68,6 +71,8 @@</span> <span class="p_context"> static void xen_pv_post_suspend(int suspend_cancelled)</span>
 	xen_mm_unpin_all();
 }
 
<span class="p_add">+static DEFINE_PER_CPU(u64, spec_ctrl);</span>
<span class="p_add">+</span>
 void xen_arch_pre_suspend(void)
 {
 	if (xen_pv_domain())
<span class="p_chunk">@@ -84,6 +89,9 @@</span> <span class="p_context"> void xen_arch_post_suspend(int cancelled)</span>
 
 static void xen_vcpu_notify_restore(void *data)
 {
<span class="p_add">+	if (xen_pv_domain() &amp;&amp; boot_cpu_has(X86_FEATURE_SPEC_CTRL))</span>
<span class="p_add">+		wrmsrl(MSR_IA32_SPEC_CTRL, this_cpu_read(spec_ctrl));</span>
<span class="p_add">+</span>
 	/* Boot processor notified via generic timekeeping_resume() */
 	if (smp_processor_id() == 0)
 		return;
<span class="p_chunk">@@ -93,7 +101,15 @@</span> <span class="p_context"> static void xen_vcpu_notify_restore(void *data)</span>
 
 static void xen_vcpu_notify_suspend(void *data)
 {
<span class="p_add">+	u64 tmp;</span>
<span class="p_add">+</span>
 	tick_suspend_local();
<span class="p_add">+</span>
<span class="p_add">+	if (xen_pv_domain() &amp;&amp; boot_cpu_has(X86_FEATURE_SPEC_CTRL)) {</span>
<span class="p_add">+		rdmsrl(MSR_IA32_SPEC_CTRL, tmp);</span>
<span class="p_add">+		this_cpu_write(spec_ctrl, tmp);</span>
<span class="p_add">+		wrmsrl(MSR_IA32_SPEC_CTRL, 0);</span>
<span class="p_add">+	}</span>
 }
 
 void xen_arch_resume(void)
<span class="p_header">diff --git a/drivers/char/tpm/st33zp24/st33zp24.c b/drivers/char/tpm/st33zp24/st33zp24.c</span>
<span class="p_header">index 6f060c76217b..7205e6da16cd 100644</span>
<span class="p_header">--- a/drivers/char/tpm/st33zp24/st33zp24.c</span>
<span class="p_header">+++ b/drivers/char/tpm/st33zp24/st33zp24.c</span>
<span class="p_chunk">@@ -458,7 +458,7 @@</span> <span class="p_context"> static int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,</span>
 			    size_t count)
 {
 	int size = 0;
<span class="p_del">-	int expected;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (!chip)
 		return -EBUSY;
<span class="p_chunk">@@ -475,7 +475,7 @@</span> <span class="p_context"> static int st33zp24_recv(struct tpm_chip *chip, unsigned char *buf,</span>
 	}
 
 	expected = be32_to_cpu(*(__be32 *)(buf + 2));
<span class="p_del">-	if (expected &gt; count) {</span>
<span class="p_add">+	if (expected &gt; count || expected &lt; TPM_HEADER_SIZE) {</span>
 		size = -EIO;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/char/tpm/tpm-dev.c b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">index 912ad30be585..65b824954bdc 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm-dev.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm-dev.c</span>
<span class="p_chunk">@@ -136,6 +136,12 @@</span> <span class="p_context"> static ssize_t tpm_write(struct file *file, const char __user *buf,</span>
 		return -EFAULT;
 	}
 
<span class="p_add">+	if (in_size &lt; 6 ||</span>
<span class="p_add">+	    in_size &lt; be32_to_cpu(*((__be32 *) (priv-&gt;data_buffer + 2)))) {</span>
<span class="p_add">+		mutex_unlock(&amp;priv-&gt;buffer_mutex);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* atomic tpm command send and result receive. We only hold the ops
 	 * lock during this period so that the tpm can be unregistered even if
 	 * the char dev is held open.
<span class="p_header">diff --git a/drivers/char/tpm/tpm_i2c_infineon.c b/drivers/char/tpm/tpm_i2c_infineon.c</span>
<span class="p_header">index 62ee44e57ddc..da69ddea56cf 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_i2c_infineon.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_i2c_infineon.c</span>
<span class="p_chunk">@@ -437,7 +437,8 @@</span> <span class="p_context"> static int recv_data(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 static int tpm_tis_i2c_recv(struct tpm_chip *chip, u8 *buf, size_t count)
 {
 	int size = 0;
<span class="p_del">-	int expected, status;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (count &lt; TPM_HEADER_SIZE) {
 		size = -EIO;
<span class="p_chunk">@@ -452,7 +453,7 @@</span> <span class="p_context"> static int tpm_tis_i2c_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 	}
 
 	expected = be32_to_cpu(*(__be32 *)(buf + 2));
<span class="p_del">-	if ((size_t) expected &gt; count) {</span>
<span class="p_add">+	if (((size_t) expected &gt; count) || (expected &lt; TPM_HEADER_SIZE)) {</span>
 		size = -EIO;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/char/tpm/tpm_i2c_nuvoton.c b/drivers/char/tpm/tpm_i2c_nuvoton.c</span>
<span class="p_header">index c6428771841f..caa86b19c76d 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_i2c_nuvoton.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_i2c_nuvoton.c</span>
<span class="p_chunk">@@ -281,7 +281,11 @@</span> <span class="p_context"> static int i2c_nuvoton_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 	struct device *dev = chip-&gt;dev.parent;
 	struct i2c_client *client = to_i2c_client(dev);
 	s32 rc;
<span class="p_del">-	int expected, status, burst_count, retries, size = 0;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	int burst_count;</span>
<span class="p_add">+	int retries;</span>
<span class="p_add">+	int size = 0;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (count &lt; TPM_HEADER_SIZE) {
 		i2c_nuvoton_ready(chip);    /* return to idle */
<span class="p_chunk">@@ -323,7 +327,7 @@</span> <span class="p_context"> static int i2c_nuvoton_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 		 * to machine native
 		 */
 		expected = be32_to_cpu(*(__be32 *) (buf + 2));
<span class="p_del">-		if (expected &gt; count) {</span>
<span class="p_add">+		if (expected &gt; count || expected &lt; size) {</span>
 			dev_err(dev, &quot;%s() expected &gt; count\n&quot;, __func__);
 			size = -EIO;
 			continue;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis.c b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">index 8022bea27fed..06173d2e316f 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis.c</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> static int tpm_tcg_read_bytes(struct tpm_tis_data *data, u32 addr, u16 len,</span>
 }
 
 static int tpm_tcg_write_bytes(struct tpm_tis_data *data, u32 addr, u16 len,
<span class="p_del">-			       u8 *value)</span>
<span class="p_add">+			       const u8 *value)</span>
 {
 	struct tpm_tis_tcg_phy *phy = to_tpm_tis_tcg_phy(data);
 
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis_core.c b/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_header">index 4d24ec3d7cd6..f9aa47ec7af7 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis_core.c</span>
<span class="p_chunk">@@ -208,7 +208,8 @@</span> <span class="p_context"> static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&amp;chip-&gt;dev);
 	int size = 0;
<span class="p_del">-	int expected, status;</span>
<span class="p_add">+	int status;</span>
<span class="p_add">+	u32 expected;</span>
 
 	if (count &lt; TPM_HEADER_SIZE) {
 		size = -EIO;
<span class="p_chunk">@@ -223,7 +224,7 @@</span> <span class="p_context"> static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
 	}
 
 	expected = be32_to_cpu(*(__be32 *) (buf + 2));
<span class="p_del">-	if (expected &gt; count) {</span>
<span class="p_add">+	if (expected &gt; count || expected &lt; TPM_HEADER_SIZE) {</span>
 		size = -EIO;
 		goto out;
 	}
<span class="p_chunk">@@ -256,7 +257,7 @@</span> <span class="p_context"> static int tpm_tis_recv(struct tpm_chip *chip, u8 *buf, size_t count)</span>
  * tpm.c can skip polling for the data to be available as the interrupt is
  * waited for here
  */
<span class="p_del">-static int tpm_tis_send_data(struct tpm_chip *chip, u8 *buf, size_t len)</span>
<span class="p_add">+static int tpm_tis_send_data(struct tpm_chip *chip, const u8 *buf, size_t len)</span>
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&amp;chip-&gt;dev);
 	int rc, status, burstcnt;
<span class="p_chunk">@@ -345,7 +346,7 @@</span> <span class="p_context"> static void disable_interrupts(struct tpm_chip *chip)</span>
  * tpm.c can skip polling for the data to be available as the interrupt is
  * waited for here
  */
<span class="p_del">-static int tpm_tis_send_main(struct tpm_chip *chip, u8 *buf, size_t len)</span>
<span class="p_add">+static int tpm_tis_send_main(struct tpm_chip *chip, const u8 *buf, size_t len)</span>
 {
 	struct tpm_tis_data *priv = dev_get_drvdata(&amp;chip-&gt;dev);
 	int rc;
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis_core.h b/drivers/char/tpm/tpm_tis_core.h</span>
<span class="p_header">index 9191aabbf9c2..e1c2193f2ed3 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis_core.h</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis_core.h</span>
<span class="p_chunk">@@ -98,7 +98,7 @@</span> <span class="p_context"> struct tpm_tis_phy_ops {</span>
 	int (*read_bytes)(struct tpm_tis_data *data, u32 addr, u16 len,
 			  u8 *result);
 	int (*write_bytes)(struct tpm_tis_data *data, u32 addr, u16 len,
<span class="p_del">-			   u8 *value);</span>
<span class="p_add">+			   const u8 *value);</span>
 	int (*read16)(struct tpm_tis_data *data, u32 addr, u16 *result);
 	int (*read32)(struct tpm_tis_data *data, u32 addr, u32 *result);
 	int (*write32)(struct tpm_tis_data *data, u32 addr, u32 src);
<span class="p_chunk">@@ -128,7 +128,7 @@</span> <span class="p_context"> static inline int tpm_tis_read32(struct tpm_tis_data *data, u32 addr,</span>
 }
 
 static inline int tpm_tis_write_bytes(struct tpm_tis_data *data, u32 addr,
<span class="p_del">-				      u16 len, u8 *value)</span>
<span class="p_add">+				      u16 len, const u8 *value)</span>
 {
 	return data-&gt;phy_ops-&gt;write_bytes(data, addr, len, value);
 }
<span class="p_header">diff --git a/drivers/char/tpm/tpm_tis_spi.c b/drivers/char/tpm/tpm_tis_spi.c</span>
<span class="p_header">index 3b97b14c3417..01eccb193b5a 100644</span>
<span class="p_header">--- a/drivers/char/tpm/tpm_tis_spi.c</span>
<span class="p_header">+++ b/drivers/char/tpm/tpm_tis_spi.c</span>
<span class="p_chunk">@@ -47,9 +47,7 @@</span> <span class="p_context"></span>
 struct tpm_tis_spi_phy {
 	struct tpm_tis_data priv;
 	struct spi_device *spi_device;
<span class="p_del">-</span>
<span class="p_del">-	u8 tx_buf[4];</span>
<span class="p_del">-	u8 rx_buf[4];</span>
<span class="p_add">+	u8 *iobuf;</span>
 };
 
 static inline struct tpm_tis_spi_phy *to_tpm_tis_spi_phy(struct tpm_tis_data *data)
<span class="p_chunk">@@ -58,7 +56,7 @@</span> <span class="p_context"> static inline struct tpm_tis_spi_phy *to_tpm_tis_spi_phy(struct tpm_tis_data *da</span>
 }
 
 static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
<span class="p_del">-				u8 *buffer, u8 direction)</span>
<span class="p_add">+				u8 *in, const u8 *out)</span>
 {
 	struct tpm_tis_spi_phy *phy = to_tpm_tis_spi_phy(data);
 	int ret = 0;
<span class="p_chunk">@@ -72,14 +70,14 @@</span> <span class="p_context"> static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,</span>
 	while (len) {
 		transfer_len = min_t(u16, len, MAX_SPI_FRAMESIZE);
 
<span class="p_del">-		phy-&gt;tx_buf[0] = direction | (transfer_len - 1);</span>
<span class="p_del">-		phy-&gt;tx_buf[1] = 0xd4;</span>
<span class="p_del">-		phy-&gt;tx_buf[2] = addr &gt;&gt; 8;</span>
<span class="p_del">-		phy-&gt;tx_buf[3] = addr;</span>
<span class="p_add">+		phy-&gt;iobuf[0] = (in ? 0x80 : 0) | (transfer_len - 1);</span>
<span class="p_add">+		phy-&gt;iobuf[1] = 0xd4;</span>
<span class="p_add">+		phy-&gt;iobuf[2] = addr &gt;&gt; 8;</span>
<span class="p_add">+		phy-&gt;iobuf[3] = addr;</span>
 
 		memset(&amp;spi_xfer, 0, sizeof(spi_xfer));
<span class="p_del">-		spi_xfer.tx_buf = phy-&gt;tx_buf;</span>
<span class="p_del">-		spi_xfer.rx_buf = phy-&gt;rx_buf;</span>
<span class="p_add">+		spi_xfer.tx_buf = phy-&gt;iobuf;</span>
<span class="p_add">+		spi_xfer.rx_buf = phy-&gt;iobuf;</span>
 		spi_xfer.len = 4;
 		spi_xfer.cs_change = 1;
 
<span class="p_chunk">@@ -89,9 +87,9 @@</span> <span class="p_context"> static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,</span>
 		if (ret &lt; 0)
 			goto exit;
 
<span class="p_del">-		if ((phy-&gt;rx_buf[3] &amp; 0x01) == 0) {</span>
<span class="p_add">+		if ((phy-&gt;iobuf[3] &amp; 0x01) == 0) {</span>
 			// handle SPI wait states
<span class="p_del">-			phy-&gt;tx_buf[0] = 0;</span>
<span class="p_add">+			phy-&gt;iobuf[0] = 0;</span>
 
 			for (i = 0; i &lt; TPM_RETRY; i++) {
 				spi_xfer.len = 1;
<span class="p_chunk">@@ -100,7 +98,7 @@</span> <span class="p_context"> static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,</span>
 				ret = spi_sync_locked(phy-&gt;spi_device, &amp;m);
 				if (ret &lt; 0)
 					goto exit;
<span class="p_del">-				if (phy-&gt;rx_buf[0] &amp; 0x01)</span>
<span class="p_add">+				if (phy-&gt;iobuf[0] &amp; 0x01)</span>
 					break;
 			}
 
<span class="p_chunk">@@ -114,12 +112,12 @@</span> <span class="p_context"> static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,</span>
 		spi_xfer.len = transfer_len;
 		spi_xfer.delay_usecs = 5;
 
<span class="p_del">-		if (direction) {</span>
<span class="p_add">+		if (in) {</span>
 			spi_xfer.tx_buf = NULL;
<span class="p_del">-			spi_xfer.rx_buf = buffer;</span>
<span class="p_del">-		} else {</span>
<span class="p_del">-			spi_xfer.tx_buf = buffer;</span>
<span class="p_add">+		} else if (out) {</span>
 			spi_xfer.rx_buf = NULL;
<span class="p_add">+			memcpy(phy-&gt;iobuf, out, transfer_len);</span>
<span class="p_add">+			out += transfer_len;</span>
 		}
 
 		spi_message_init(&amp;m);
<span class="p_chunk">@@ -128,8 +126,12 @@</span> <span class="p_context"> static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,</span>
 		if (ret &lt; 0)
 			goto exit;
 
<span class="p_add">+		if (in) {</span>
<span class="p_add">+			memcpy(in, phy-&gt;iobuf, transfer_len);</span>
<span class="p_add">+			in += transfer_len;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		len -= transfer_len;
<span class="p_del">-		buffer += transfer_len;</span>
 	}
 
 exit:
<span class="p_chunk">@@ -140,13 +142,13 @@</span> <span class="p_context"> static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,</span>
 static int tpm_tis_spi_read_bytes(struct tpm_tis_data *data, u32 addr,
 				  u16 len, u8 *result)
 {
<span class="p_del">-	return tpm_tis_spi_transfer(data, addr, len, result, 0x80);</span>
<span class="p_add">+	return tpm_tis_spi_transfer(data, addr, len, result, NULL);</span>
 }
 
 static int tpm_tis_spi_write_bytes(struct tpm_tis_data *data, u32 addr,
<span class="p_del">-				   u16 len, u8 *value)</span>
<span class="p_add">+				   u16 len, const u8 *value)</span>
 {
<span class="p_del">-	return tpm_tis_spi_transfer(data, addr, len, value, 0);</span>
<span class="p_add">+	return tpm_tis_spi_transfer(data, addr, len, NULL, value);</span>
 }
 
 static int tpm_tis_spi_read16(struct tpm_tis_data *data, u32 addr, u16 *result)
<span class="p_chunk">@@ -195,6 +197,10 @@</span> <span class="p_context"> static int tpm_tis_spi_probe(struct spi_device *dev)</span>
 
 	phy-&gt;spi_device = dev;
 
<span class="p_add">+	phy-&gt;iobuf = devm_kmalloc(&amp;dev-&gt;dev, MAX_SPI_FRAMESIZE, GFP_KERNEL);</span>
<span class="p_add">+	if (!phy-&gt;iobuf)</span>
<span class="p_add">+		return -ENOMEM;</span>
<span class="p_add">+</span>
 	return tpm_tis_core_init(&amp;dev-&gt;dev, &amp;phy-&gt;priv, -1, &amp;tpm_spi_phy_ops,
 				 NULL);
 }
<span class="p_header">diff --git a/drivers/cpufreq/s3c24xx-cpufreq.c b/drivers/cpufreq/s3c24xx-cpufreq.c</span>
<span class="p_header">index 7b596fa38ad2..6bebc1f9f55a 100644</span>
<span class="p_header">--- a/drivers/cpufreq/s3c24xx-cpufreq.c</span>
<span class="p_header">+++ b/drivers/cpufreq/s3c24xx-cpufreq.c</span>
<span class="p_chunk">@@ -351,7 +351,13 @@</span> <span class="p_context"> struct clk *s3c_cpufreq_clk_get(struct device *dev, const char *name)</span>
 static int s3c_cpufreq_init(struct cpufreq_policy *policy)
 {
 	policy-&gt;clk = clk_arm;
<span class="p_del">-	return cpufreq_generic_init(policy, ftab, cpu_cur.info-&gt;latency);</span>
<span class="p_add">+</span>
<span class="p_add">+	policy-&gt;cpuinfo.transition_latency = cpu_cur.info-&gt;latency;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (ftab)</span>
<span class="p_add">+		return cpufreq_table_validate_and_show(policy, ftab);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 static int __init s3c_cpufreq_initclks(void)
<span class="p_header">diff --git a/drivers/md/dm-io.c b/drivers/md/dm-io.c</span>
<span class="p_header">index 0bf1a12e35fe..ee6045d6c0bb 100644</span>
<span class="p_header">--- a/drivers/md/dm-io.c</span>
<span class="p_header">+++ b/drivers/md/dm-io.c</span>
<span class="p_chunk">@@ -302,6 +302,7 @@</span> <span class="p_context"> static void do_region(int op, int op_flags, unsigned region,</span>
 		special_cmd_max_sectors = q-&gt;limits.max_write_same_sectors;
 	if ((op == REQ_OP_DISCARD || op == REQ_OP_WRITE_SAME) &amp;&amp;
 	    special_cmd_max_sectors == 0) {
<span class="p_add">+		atomic_inc(&amp;io-&gt;count);</span>
 		dec_count(io, region, -EOPNOTSUPP);
 		return;
 	}
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 8ebf1b97e1d2..27d8bb21e04f 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -8224,6 +8224,10 @@</span> <span class="p_context"> static int remove_and_add_spares(struct mddev *mddev,</span>
 	int removed = 0;
 	bool remove_some = false;
 
<span class="p_add">+	if (this &amp;&amp; test_bit(MD_RECOVERY_RUNNING, &amp;mddev-&gt;recovery))</span>
<span class="p_add">+		/* Mustn&#39;t remove devices when resync thread is running */</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
 	rdev_for_each(rdev, mddev) {
 		if ((this == NULL || rdev == this) &amp;&amp;
 		    rdev-&gt;raid_disk &gt;= 0 &amp;&amp;
<span class="p_header">diff --git a/drivers/media/dvb-frontends/m88ds3103.c b/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_header">index e0fe5bc9dbce..31f16105184c 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/m88ds3103.c</span>
<span class="p_chunk">@@ -1262,11 +1262,12 @@</span> <span class="p_context"> static int m88ds3103_select(struct i2c_mux_core *muxc, u32 chan)</span>
  * New users must use I2C client binding directly!
  */
 struct dvb_frontend *m88ds3103_attach(const struct m88ds3103_config *cfg,
<span class="p_del">-		struct i2c_adapter *i2c, struct i2c_adapter **tuner_i2c_adapter)</span>
<span class="p_add">+				      struct i2c_adapter *i2c,</span>
<span class="p_add">+				      struct i2c_adapter **tuner_i2c_adapter)</span>
 {
 	struct i2c_client *client;
 	struct i2c_board_info board_info;
<span class="p_del">-	struct m88ds3103_platform_data pdata;</span>
<span class="p_add">+	struct m88ds3103_platform_data pdata = {};</span>
 
 	pdata.clk = cfg-&gt;clock;
 	pdata.i2c_wr_max = cfg-&gt;i2c_wr_max;
<span class="p_chunk">@@ -1409,6 +1410,8 @@</span> <span class="p_context"> static int m88ds3103_probe(struct i2c_client *client,</span>
 	case M88DS3103_CHIP_ID:
 		break;
 	default:
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		dev_err(&amp;client-&gt;dev, &quot;Unknown device. Chip_id=%02x\n&quot;, dev-&gt;chip_id);</span>
 		goto err_kfree;
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c</span>
<span class="p_header">index 1e2c8eca3af1..bea9ae31a769 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlxsw/spectrum_switchdev.c</span>
<span class="p_chunk">@@ -809,6 +809,7 @@</span> <span class="p_context"> static int __mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u8 local_port,</span>
 				     bool dynamic)
 {
 	char *sfd_pl;
<span class="p_add">+	u8 num_rec;</span>
 	int err;
 
 	sfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);
<span class="p_chunk">@@ -818,9 +819,16 @@</span> <span class="p_context"> static int __mlxsw_sp_port_fdb_uc_op(struct mlxsw_sp *mlxsw_sp, u8 local_port,</span>
 	mlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);
 	mlxsw_reg_sfd_uc_pack(sfd_pl, 0, mlxsw_sp_sfd_rec_policy(dynamic),
 			      mac, fid, action, local_port);
<span class="p_add">+	num_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);</span>
 	err = mlxsw_reg_write(mlxsw_sp-&gt;core, MLXSW_REG(sfd), sfd_pl);
<span class="p_del">-	kfree(sfd_pl);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))</span>
<span class="p_add">+		err = -EBUSY;</span>
 
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(sfd_pl);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -845,6 +853,7 @@</span> <span class="p_context"> static int mlxsw_sp_port_fdb_uc_lag_op(struct mlxsw_sp *mlxsw_sp, u16 lag_id,</span>
 				       bool adding, bool dynamic)
 {
 	char *sfd_pl;
<span class="p_add">+	u8 num_rec;</span>
 	int err;
 
 	sfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);
<span class="p_chunk">@@ -855,9 +864,16 @@</span> <span class="p_context"> static int mlxsw_sp_port_fdb_uc_lag_op(struct mlxsw_sp *mlxsw_sp, u16 lag_id,</span>
 	mlxsw_reg_sfd_uc_lag_pack(sfd_pl, 0, mlxsw_sp_sfd_rec_policy(dynamic),
 				  mac, fid, MLXSW_REG_SFD_REC_ACTION_NOP,
 				  lag_vid, lag_id);
<span class="p_add">+	num_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);</span>
 	err = mlxsw_reg_write(mlxsw_sp-&gt;core, MLXSW_REG(sfd), sfd_pl);
<span class="p_del">-	kfree(sfd_pl);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))</span>
<span class="p_add">+		err = -EBUSY;</span>
 
<span class="p_add">+out:</span>
<span class="p_add">+	kfree(sfd_pl);</span>
 	return err;
 }
 
<span class="p_chunk">@@ -891,6 +907,7 @@</span> <span class="p_context"> static int mlxsw_sp_port_mdb_op(struct mlxsw_sp *mlxsw_sp, const char *addr,</span>
 				u16 fid, u16 mid, bool adding)
 {
 	char *sfd_pl;
<span class="p_add">+	u8 num_rec;</span>
 	int err;
 
 	sfd_pl = kmalloc(MLXSW_REG_SFD_LEN, GFP_KERNEL);
<span class="p_chunk">@@ -900,7 +917,15 @@</span> <span class="p_context"> static int mlxsw_sp_port_mdb_op(struct mlxsw_sp *mlxsw_sp, const char *addr,</span>
 	mlxsw_reg_sfd_pack(sfd_pl, mlxsw_sp_sfd_op(adding), 0);
 	mlxsw_reg_sfd_mc_pack(sfd_pl, 0, addr, fid,
 			      MLXSW_REG_SFD_REC_ACTION_NOP, mid);
<span class="p_add">+	num_rec = mlxsw_reg_sfd_num_rec_get(sfd_pl);</span>
 	err = mlxsw_reg_write(mlxsw_sp-&gt;core, MLXSW_REG(sfd), sfd_pl);
<span class="p_add">+	if (err)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (num_rec != mlxsw_reg_sfd_num_rec_get(sfd_pl))</span>
<span class="p_add">+		err = -EBUSY;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
 	kfree(sfd_pl);
 	return err;
 }
<span class="p_header">diff --git a/drivers/net/phy/phy.c b/drivers/net/phy/phy.c</span>
<span class="p_header">index 6e12401b5102..e2d9ca60e467 100644</span>
<span class="p_header">--- a/drivers/net/phy/phy.c</span>
<span class="p_header">+++ b/drivers/net/phy/phy.c</span>
<span class="p_chunk">@@ -925,7 +925,7 @@</span> <span class="p_context"> void phy_start(struct phy_device *phydev)</span>
 		break;
 	case PHY_HALTED:
 		/* make sure interrupts are re-enabled for the PHY */
<span class="p_del">-		if (phydev-&gt;irq != PHY_POLL) {</span>
<span class="p_add">+		if (phy_interrupt_is_valid(phydev)) {</span>
 			err = phy_enable_interrupts(phydev);
 			if (err &lt; 0)
 				break;
<span class="p_header">diff --git a/drivers/net/ppp/ppp_generic.c b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">index fc4c2ccc3d22..114457921890 100644</span>
<span class="p_header">--- a/drivers/net/ppp/ppp_generic.c</span>
<span class="p_header">+++ b/drivers/net/ppp/ppp_generic.c</span>
<span class="p_chunk">@@ -3157,6 +3157,15 @@</span> <span class="p_context"> ppp_connect_channel(struct channel *pch, int unit)</span>
 		goto outl;
 
 	ppp_lock(ppp);
<span class="p_add">+	spin_lock_bh(&amp;pch-&gt;downl);</span>
<span class="p_add">+	if (!pch-&gt;chan) {</span>
<span class="p_add">+		/* Don&#39;t connect unregistered channels */</span>
<span class="p_add">+		spin_unlock_bh(&amp;pch-&gt;downl);</span>
<span class="p_add">+		ppp_unlock(ppp);</span>
<span class="p_add">+		ret = -ENOTCONN;</span>
<span class="p_add">+		goto outl;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_bh(&amp;pch-&gt;downl);</span>
 	if (pch-&gt;file.hdrlen &gt; ppp-&gt;file.hdrlen)
 		ppp-&gt;file.hdrlen = pch-&gt;file.hdrlen;
 	hdrlen = pch-&gt;file.hdrlen + 2;	/* for protocol bytes */
<span class="p_header">diff --git a/drivers/net/wan/hdlc_ppp.c b/drivers/net/wan/hdlc_ppp.c</span>
<span class="p_header">index 47fdb87d3567..8a9aced850be 100644</span>
<span class="p_header">--- a/drivers/net/wan/hdlc_ppp.c</span>
<span class="p_header">+++ b/drivers/net/wan/hdlc_ppp.c</span>
<span class="p_chunk">@@ -574,7 +574,10 @@</span> <span class="p_context"> static void ppp_timer(unsigned long arg)</span>
 			ppp_cp_event(proto-&gt;dev, proto-&gt;pid, TO_GOOD, 0, 0,
 				     0, NULL);
 			proto-&gt;restart_counter--;
<span class="p_del">-		} else</span>
<span class="p_add">+		} else if (netif_carrier_ok(proto-&gt;dev))</span>
<span class="p_add">+			ppp_cp_event(proto-&gt;dev, proto-&gt;pid, TO_GOOD, 0, 0,</span>
<span class="p_add">+				     0, NULL);</span>
<span class="p_add">+		else</span>
 			ppp_cp_event(proto-&gt;dev, proto-&gt;pid, TO_BAD, 0, 0,
 				     0, NULL);
 		break;
<span class="p_header">diff --git a/drivers/pci/pcie/aspm.c b/drivers/pci/pcie/aspm.c</span>
<span class="p_header">index b0916b126923..6643a7bc381c 100644</span>
<span class="p_header">--- a/drivers/pci/pcie/aspm.c</span>
<span class="p_header">+++ b/drivers/pci/pcie/aspm.c</span>
<span class="p_chunk">@@ -526,10 +526,14 @@</span> <span class="p_context"> static struct pcie_link_state *alloc_pcie_link_state(struct pci_dev *pdev)</span>
 
 	/*
 	 * Root Ports and PCI/PCI-X to PCIe Bridges are roots of PCIe
<span class="p_del">-	 * hierarchies.</span>
<span class="p_add">+	 * hierarchies.  Note that some PCIe host implementations omit</span>
<span class="p_add">+	 * the root ports entirely, in which case a downstream port on</span>
<span class="p_add">+	 * a switch may become the root of the link state chain for all</span>
<span class="p_add">+	 * its subordinate endpoints.</span>
 	 */
 	if (pci_pcie_type(pdev) == PCI_EXP_TYPE_ROOT_PORT ||
<span class="p_del">-	    pci_pcie_type(pdev) == PCI_EXP_TYPE_PCIE_BRIDGE) {</span>
<span class="p_add">+	    pci_pcie_type(pdev) == PCI_EXP_TYPE_PCIE_BRIDGE ||</span>
<span class="p_add">+	    !pdev-&gt;bus-&gt;parent-&gt;self) {</span>
 		link-&gt;root = link;
 	} else {
 		struct pcie_link_state *parent;
<span class="p_header">diff --git a/drivers/s390/net/qeth_core.h b/drivers/s390/net/qeth_core.h</span>
<span class="p_header">index 9b5fc502f6a1..403712bf1ddf 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core.h</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core.h</span>
<span class="p_chunk">@@ -592,6 +592,11 @@</span> <span class="p_context"> struct qeth_cmd_buffer {</span>
 	void (*callback) (struct qeth_channel *, struct qeth_cmd_buffer *);
 };
 
<span class="p_add">+static inline struct qeth_ipa_cmd *__ipa_cmd(struct qeth_cmd_buffer *iob)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (struct qeth_ipa_cmd *)(iob-&gt;data + IPA_PDU_HEADER_SIZE);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * definition of a qeth channel, used for read and write
  */
<span class="p_chunk">@@ -849,7 +854,7 @@</span> <span class="p_context"> struct qeth_trap_id {</span>
  */
 static inline int qeth_get_elements_for_range(addr_t start, addr_t end)
 {
<span class="p_del">-	return PFN_UP(end - 1) - PFN_DOWN(start);</span>
<span class="p_add">+	return PFN_UP(end) - PFN_DOWN(start);</span>
 }
 
 static inline int qeth_get_micros(void)
<span class="p_header">diff --git a/drivers/s390/net/qeth_core_main.c b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">index df8f74cb1406..cc28dda322b5 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_core_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_core_main.c</span>
<span class="p_chunk">@@ -2050,7 +2050,7 @@</span> <span class="p_context"> int qeth_send_control_data(struct qeth_card *card, int len,</span>
 	unsigned long flags;
 	struct qeth_reply *reply = NULL;
 	unsigned long timeout, event_timeout;
<span class="p_del">-	struct qeth_ipa_cmd *cmd;</span>
<span class="p_add">+	struct qeth_ipa_cmd *cmd = NULL;</span>
 
 	QETH_CARD_TEXT(card, 2, &quot;sendctl&quot;);
 
<span class="p_chunk">@@ -2064,23 +2064,27 @@</span> <span class="p_context"> int qeth_send_control_data(struct qeth_card *card, int len,</span>
 	}
 	reply-&gt;callback = reply_cb;
 	reply-&gt;param = reply_param;
<span class="p_del">-	if (card-&gt;state == CARD_STATE_DOWN)</span>
<span class="p_del">-		reply-&gt;seqno = QETH_IDX_COMMAND_SEQNO;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		reply-&gt;seqno = card-&gt;seqno.ipa++;</span>
<span class="p_add">+</span>
 	init_waitqueue_head(&amp;reply-&gt;wait_q);
<span class="p_del">-	spin_lock_irqsave(&amp;card-&gt;lock, flags);</span>
<span class="p_del">-	list_add_tail(&amp;reply-&gt;list, &amp;card-&gt;cmd_waiter_list);</span>
<span class="p_del">-	spin_unlock_irqrestore(&amp;card-&gt;lock, flags);</span>
 	QETH_DBF_HEX(CTRL, 2, iob-&gt;data, QETH_DBF_CTRL_LEN);
 
 	while (atomic_cmpxchg(&amp;card-&gt;write.irq_pending, 0, 1)) ;
<span class="p_del">-	qeth_prepare_control_data(card, len, iob);</span>
 
<span class="p_del">-	if (IS_IPA(iob-&gt;data))</span>
<span class="p_add">+	if (IS_IPA(iob-&gt;data)) {</span>
<span class="p_add">+		cmd = __ipa_cmd(iob);</span>
<span class="p_add">+		cmd-&gt;hdr.seqno = card-&gt;seqno.ipa++;</span>
<span class="p_add">+		reply-&gt;seqno = cmd-&gt;hdr.seqno;</span>
 		event_timeout = QETH_IPA_TIMEOUT;
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		reply-&gt;seqno = QETH_IDX_COMMAND_SEQNO;</span>
 		event_timeout = QETH_TIMEOUT;
<span class="p_add">+	}</span>
<span class="p_add">+	qeth_prepare_control_data(card, len, iob);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;card-&gt;lock, flags);</span>
<span class="p_add">+	list_add_tail(&amp;reply-&gt;list, &amp;card-&gt;cmd_waiter_list);</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;card-&gt;lock, flags);</span>
<span class="p_add">+</span>
 	timeout = jiffies + event_timeout;
 
 	QETH_CARD_TEXT(card, 6, &quot;noirqpnd&quot;);
<span class="p_chunk">@@ -2105,9 +2109,8 @@</span> <span class="p_context"> int qeth_send_control_data(struct qeth_card *card, int len,</span>
 
 	/* we have only one long running ipassist, since we can ensure
 	   process context of this command we can sleep */
<span class="p_del">-	cmd = (struct qeth_ipa_cmd *)(iob-&gt;data+IPA_PDU_HEADER_SIZE);</span>
<span class="p_del">-	if ((cmd-&gt;hdr.command == IPA_CMD_SETIP) &amp;&amp;</span>
<span class="p_del">-	    (cmd-&gt;hdr.prot_version == QETH_PROT_IPV4)) {</span>
<span class="p_add">+	if (cmd &amp;&amp; cmd-&gt;hdr.command == IPA_CMD_SETIP &amp;&amp;</span>
<span class="p_add">+	    cmd-&gt;hdr.prot_version == QETH_PROT_IPV4) {</span>
 		if (!wait_event_timeout(reply-&gt;wait_q,
 		    atomic_read(&amp;reply-&gt;received), event_timeout))
 			goto time_err;
<span class="p_chunk">@@ -2871,7 +2874,7 @@</span> <span class="p_context"> static void qeth_fill_ipacmd_header(struct qeth_card *card,</span>
 	memset(cmd, 0, sizeof(struct qeth_ipa_cmd));
 	cmd-&gt;hdr.command = command;
 	cmd-&gt;hdr.initiator = IPA_CMD_INITIATOR_HOST;
<span class="p_del">-	cmd-&gt;hdr.seqno = card-&gt;seqno.ipa;</span>
<span class="p_add">+	/* cmd-&gt;hdr.seqno is set by qeth_send_control_data() */</span>
 	cmd-&gt;hdr.adapter_type = qeth_get_ipa_adp_type(card-&gt;info.link_type);
 	cmd-&gt;hdr.rel_adapter_no = (__u8) card-&gt;info.portno;
 	if (card-&gt;options.layer2)
<span class="p_chunk">@@ -3852,10 +3855,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(qeth_get_elements_for_frags);</span>
 int qeth_get_elements_no(struct qeth_card *card,
 		     struct sk_buff *skb, int extra_elems, int data_offset)
 {
<span class="p_del">-	int elements = qeth_get_elements_for_range(</span>
<span class="p_del">-				(addr_t)skb-&gt;data + data_offset,</span>
<span class="p_del">-				(addr_t)skb-&gt;data + skb_headlen(skb)) +</span>
<span class="p_del">-			qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+	addr_t end = (addr_t)skb-&gt;data + skb_headlen(skb);</span>
<span class="p_add">+	int elements = qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+	addr_t start = (addr_t)skb-&gt;data + data_offset;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (start != end)</span>
<span class="p_add">+		elements += qeth_get_elements_for_range(start, end);</span>
 
 	if ((elements + extra_elems) &gt; QETH_MAX_BUFFER_ELEMENTS(card)) {
 		QETH_DBF_MESSAGE(2, &quot;Invalid size of IP packet &quot;
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3.h b/drivers/s390/net/qeth_l3.h</span>
<span class="p_header">index eedf9b01a496..573569474e44 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3.h</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3.h</span>
<span class="p_chunk">@@ -39,8 +39,40 @@</span> <span class="p_context"> struct qeth_ipaddr {</span>
 			unsigned int pfxlen;
 		} a6;
 	} u;
<span class="p_del">-</span>
 };
<span class="p_add">+</span>
<span class="p_add">+static inline bool qeth_l3_addr_match_ip(struct qeth_ipaddr *a1,</span>
<span class="p_add">+					 struct qeth_ipaddr *a2)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (a1-&gt;proto != a2-&gt;proto)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (a1-&gt;proto == QETH_PROT_IPV6)</span>
<span class="p_add">+		return ipv6_addr_equal(&amp;a1-&gt;u.a6.addr, &amp;a2-&gt;u.a6.addr);</span>
<span class="p_add">+	return a1-&gt;u.a4.addr == a2-&gt;u.a4.addr;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static inline bool qeth_l3_addr_match_all(struct qeth_ipaddr *a1,</span>
<span class="p_add">+					  struct qeth_ipaddr *a2)</span>
<span class="p_add">+{</span>
<span class="p_add">+	/* Assumes that the pair was obtained via qeth_l3_addr_find_by_ip(),</span>
<span class="p_add">+	 * so &#39;proto&#39; and &#39;addr&#39; match for sure.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For ucast:</span>
<span class="p_add">+	 * -	&#39;mac&#39; is always 0.</span>
<span class="p_add">+	 * -	&#39;mask&#39;/&#39;pfxlen&#39; for RXIP/VIPA is always 0. For NORMAL, matching</span>
<span class="p_add">+	 *	values are required to avoid mixups in takeover eligibility.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * For mcast,</span>
<span class="p_add">+	 * -	&#39;mac&#39; is mapped from the IP, and thus always matches.</span>
<span class="p_add">+	 * -	&#39;mask&#39;/&#39;pfxlen&#39; is always 0.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (a1-&gt;type != a2-&gt;type)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	if (a1-&gt;proto == QETH_PROT_IPV6)</span>
<span class="p_add">+		return a1-&gt;u.a6.pfxlen == a2-&gt;u.a6.pfxlen;</span>
<span class="p_add">+	return a1-&gt;u.a4.mask == a2-&gt;u.a4.mask;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline  u64 qeth_l3_ipaddr_hash(struct qeth_ipaddr *addr)
 {
 	u64  ret = 0;
<span class="p_header">diff --git a/drivers/s390/net/qeth_l3_main.c b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">index 1487f8a0c575..a668e6b71a29 100644</span>
<span class="p_header">--- a/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_header">+++ b/drivers/s390/net/qeth_l3_main.c</span>
<span class="p_chunk">@@ -154,6 +154,24 @@</span> <span class="p_context"> int qeth_l3_string_to_ipaddr(const char *buf, enum qeth_prot_versions proto,</span>
 		return -EINVAL;
 }
 
<span class="p_add">+static struct qeth_ipaddr *qeth_l3_find_addr_by_ip(struct qeth_card *card,</span>
<span class="p_add">+						   struct qeth_ipaddr *query)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u64 key = qeth_l3_ipaddr_hash(query);</span>
<span class="p_add">+	struct qeth_ipaddr *addr;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (query-&gt;is_multicast) {</span>
<span class="p_add">+		hash_for_each_possible(card-&gt;ip_mc_htable, addr, hnode, key)</span>
<span class="p_add">+			if (qeth_l3_addr_match_ip(addr, query))</span>
<span class="p_add">+				return addr;</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hash_for_each_possible(card-&gt;ip_htable,  addr, hnode, key)</span>
<span class="p_add">+			if (qeth_l3_addr_match_ip(addr, query))</span>
<span class="p_add">+				return addr;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return NULL;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static void qeth_l3_convert_addr_to_bits(u8 *addr, u8 *bits, int len)
 {
 	int i, j;
<span class="p_chunk">@@ -207,34 +225,6 @@</span> <span class="p_context"> static bool qeth_l3_is_addr_covered_by_ipato(struct qeth_card *card,</span>
 	return rc;
 }
 
<span class="p_del">-inline int</span>
<span class="p_del">-qeth_l3_ipaddrs_is_equal(struct qeth_ipaddr *addr1, struct qeth_ipaddr *addr2)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return addr1-&gt;proto == addr2-&gt;proto &amp;&amp;</span>
<span class="p_del">-		!memcmp(&amp;addr1-&gt;u, &amp;addr2-&gt;u, sizeof(addr1-&gt;u))  &amp;&amp;</span>
<span class="p_del">-		!memcmp(&amp;addr1-&gt;mac, &amp;addr2-&gt;mac, sizeof(addr1-&gt;mac));</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-static struct qeth_ipaddr *</span>
<span class="p_del">-qeth_l3_ip_from_hash(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
<span class="p_del">-{</span>
<span class="p_del">-	struct qeth_ipaddr *addr;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (tmp_addr-&gt;is_multicast) {</span>
<span class="p_del">-		hash_for_each_possible(card-&gt;ip_mc_htable,  addr,</span>
<span class="p_del">-				hnode, qeth_l3_ipaddr_hash(tmp_addr))</span>
<span class="p_del">-			if (qeth_l3_ipaddrs_is_equal(tmp_addr, addr))</span>
<span class="p_del">-				return addr;</span>
<span class="p_del">-	} else {</span>
<span class="p_del">-		hash_for_each_possible(card-&gt;ip_htable,  addr,</span>
<span class="p_del">-				hnode, qeth_l3_ipaddr_hash(tmp_addr))</span>
<span class="p_del">-			if (qeth_l3_ipaddrs_is_equal(tmp_addr, addr))</span>
<span class="p_del">-				return addr;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	return NULL;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int qeth_l3_delete_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)
 {
 	int rc = 0;
<span class="p_chunk">@@ -249,8 +239,8 @@</span> <span class="p_context"> int qeth_l3_delete_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 		QETH_CARD_HEX(card, 4, ((char *)&amp;tmp_addr-&gt;u.a6.addr) + 8, 8);
 	}
 
<span class="p_del">-	addr = qeth_l3_ip_from_hash(card, tmp_addr);</span>
<span class="p_del">-	if (!addr)</span>
<span class="p_add">+	addr = qeth_l3_find_addr_by_ip(card, tmp_addr);</span>
<span class="p_add">+	if (!addr || !qeth_l3_addr_match_all(addr, tmp_addr))</span>
 		return -ENOENT;
 
 	addr-&gt;ref_counter--;
<span class="p_chunk">@@ -259,12 +249,8 @@</span> <span class="p_context"> int qeth_l3_delete_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 	if (addr-&gt;in_progress)
 		return -EINPROGRESS;
 
<span class="p_del">-	if (!qeth_card_hw_is_reachable(card)) {</span>
<span class="p_del">-		addr-&gt;disp_flag = QETH_DISP_ADDR_DELETE;</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	rc = qeth_l3_deregister_addr_entry(card, addr);</span>
<span class="p_add">+	if (qeth_card_hw_is_reachable(card))</span>
<span class="p_add">+		rc = qeth_l3_deregister_addr_entry(card, addr);</span>
 
 	hash_del(&amp;addr-&gt;hnode);
 	kfree(addr);
<span class="p_chunk">@@ -276,6 +262,7 @@</span> <span class="p_context"> int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 {
 	int rc = 0;
 	struct qeth_ipaddr *addr;
<span class="p_add">+	char buf[40];</span>
 
 	QETH_CARD_TEXT(card, 4, &quot;addip&quot;);
 
<span class="p_chunk">@@ -286,8 +273,20 @@</span> <span class="p_context"> int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 		QETH_CARD_HEX(card, 4, ((char *)&amp;tmp_addr-&gt;u.a6.addr) + 8, 8);
 	}
 
<span class="p_del">-	addr = qeth_l3_ip_from_hash(card, tmp_addr);</span>
<span class="p_del">-	if (!addr) {</span>
<span class="p_add">+	addr = qeth_l3_find_addr_by_ip(card, tmp_addr);</span>
<span class="p_add">+	if (addr) {</span>
<span class="p_add">+		if (tmp_addr-&gt;type != QETH_IP_TYPE_NORMAL)</span>
<span class="p_add">+			return -EADDRINUSE;</span>
<span class="p_add">+		if (qeth_l3_addr_match_all(addr, tmp_addr)) {</span>
<span class="p_add">+			addr-&gt;ref_counter++;</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		qeth_l3_ipaddr_to_string(tmp_addr-&gt;proto, (u8 *)&amp;tmp_addr-&gt;u,</span>
<span class="p_add">+					 buf);</span>
<span class="p_add">+		dev_warn(&amp;card-&gt;gdev-&gt;dev,</span>
<span class="p_add">+			 &quot;Registering IP address %s failed\n&quot;, buf);</span>
<span class="p_add">+		return -EADDRINUSE;</span>
<span class="p_add">+	} else {</span>
 		addr = qeth_l3_get_addr_buffer(tmp_addr-&gt;proto);
 		if (!addr)
 			return -ENOMEM;
<span class="p_chunk">@@ -327,18 +326,15 @@</span> <span class="p_context"> int qeth_l3_add_ip(struct qeth_card *card, struct qeth_ipaddr *tmp_addr)</span>
 				(rc == IPA_RC_LAN_OFFLINE)) {
 			addr-&gt;disp_flag = QETH_DISP_ADDR_DO_NOTHING;
 			if (addr-&gt;ref_counter &lt; 1) {
<span class="p_del">-				qeth_l3_delete_ip(card, addr);</span>
<span class="p_add">+				qeth_l3_deregister_addr_entry(card, addr);</span>
<span class="p_add">+				hash_del(&amp;addr-&gt;hnode);</span>
 				kfree(addr);
 			}
 		} else {
 			hash_del(&amp;addr-&gt;hnode);
 			kfree(addr);
 		}
<span class="p_del">-	} else {</span>
<span class="p_del">-			if (addr-&gt;type == QETH_IP_TYPE_NORMAL)</span>
<span class="p_del">-				addr-&gt;ref_counter++;</span>
 	}
<span class="p_del">-</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -406,11 +402,7 @@</span> <span class="p_context"> static void qeth_l3_recover_ip(struct qeth_card *card)</span>
 	spin_lock_bh(&amp;card-&gt;ip_lock);
 
 	hash_for_each_safe(card-&gt;ip_htable, i, tmp, addr, hnode) {
<span class="p_del">-		if (addr-&gt;disp_flag == QETH_DISP_ADDR_DELETE) {</span>
<span class="p_del">-			qeth_l3_deregister_addr_entry(card, addr);</span>
<span class="p_del">-			hash_del(&amp;addr-&gt;hnode);</span>
<span class="p_del">-			kfree(addr);</span>
<span class="p_del">-		} else if (addr-&gt;disp_flag == QETH_DISP_ADDR_ADD) {</span>
<span class="p_add">+		if (addr-&gt;disp_flag == QETH_DISP_ADDR_ADD) {</span>
 			if (addr-&gt;proto == QETH_PROT_IPV4) {
 				addr-&gt;in_progress = 1;
 				spin_unlock_bh(&amp;card-&gt;ip_lock);
<span class="p_chunk">@@ -726,12 +718,7 @@</span> <span class="p_context"> int qeth_l3_add_vipa(struct qeth_card *card, enum qeth_prot_versions proto,</span>
 		return -ENOMEM;
 
 	spin_lock_bh(&amp;card-&gt;ip_lock);
<span class="p_del">-</span>
<span class="p_del">-	if (qeth_l3_ip_from_hash(card, ipaddr))</span>
<span class="p_del">-		rc = -EEXIST;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		qeth_l3_add_ip(card, ipaddr);</span>
<span class="p_del">-</span>
<span class="p_add">+	rc = qeth_l3_add_ip(card, ipaddr);</span>
 	spin_unlock_bh(&amp;card-&gt;ip_lock);
 
 	kfree(ipaddr);
<span class="p_chunk">@@ -794,12 +781,7 @@</span> <span class="p_context"> int qeth_l3_add_rxip(struct qeth_card *card, enum qeth_prot_versions proto,</span>
 		return -ENOMEM;
 
 	spin_lock_bh(&amp;card-&gt;ip_lock);
<span class="p_del">-</span>
<span class="p_del">-	if (qeth_l3_ip_from_hash(card, ipaddr))</span>
<span class="p_del">-		rc = -EEXIST;</span>
<span class="p_del">-	else</span>
<span class="p_del">-		qeth_l3_add_ip(card, ipaddr);</span>
<span class="p_del">-</span>
<span class="p_add">+	rc = qeth_l3_add_ip(card, ipaddr);</span>
 	spin_unlock_bh(&amp;card-&gt;ip_lock);
 
 	kfree(ipaddr);
<span class="p_chunk">@@ -1444,8 +1426,9 @@</span> <span class="p_context"> qeth_l3_add_mc_to_hash(struct qeth_card *card, struct in_device *in4_dev)</span>
 		memcpy(tmp-&gt;mac, buf, sizeof(tmp-&gt;mac));
 		tmp-&gt;is_multicast = 1;
 
<span class="p_del">-		ipm = qeth_l3_ip_from_hash(card, tmp);</span>
<span class="p_add">+		ipm = qeth_l3_find_addr_by_ip(card, tmp);</span>
 		if (ipm) {
<span class="p_add">+			/* for mcast, by-IP match means full match */</span>
 			ipm-&gt;disp_flag = QETH_DISP_ADDR_DO_NOTHING;
 		} else {
 			ipm = qeth_l3_get_addr_buffer(QETH_PROT_IPV4);
<span class="p_chunk">@@ -1528,8 +1511,9 @@</span> <span class="p_context"> qeth_l3_add_mc6_to_hash(struct qeth_card *card, struct inet6_dev *in6_dev)</span>
 		       sizeof(struct in6_addr));
 		tmp-&gt;is_multicast = 1;
 
<span class="p_del">-		ipm = qeth_l3_ip_from_hash(card, tmp);</span>
<span class="p_add">+		ipm = qeth_l3_find_addr_by_ip(card, tmp);</span>
 		if (ipm) {
<span class="p_add">+			/* for mcast, by-IP match means full match */</span>
 			ipm-&gt;disp_flag = QETH_DISP_ADDR_DO_NOTHING;
 			continue;
 		}
<span class="p_chunk">@@ -2784,11 +2768,12 @@</span> <span class="p_context"> static void qeth_tso_fill_header(struct qeth_card *card,</span>
 static int qeth_l3_get_elements_no_tso(struct qeth_card *card,
 			struct sk_buff *skb, int extra_elems)
 {
<span class="p_del">-	addr_t tcpdptr = (addr_t)tcp_hdr(skb) + tcp_hdrlen(skb);</span>
<span class="p_del">-	int elements = qeth_get_elements_for_range(</span>
<span class="p_del">-				tcpdptr,</span>
<span class="p_del">-				(addr_t)skb-&gt;data + skb_headlen(skb)) +</span>
<span class="p_del">-				qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+	addr_t start = (addr_t)tcp_hdr(skb) + tcp_hdrlen(skb);</span>
<span class="p_add">+	addr_t end = (addr_t)skb-&gt;data + skb_headlen(skb);</span>
<span class="p_add">+	int elements = qeth_get_elements_for_frags(skb);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (start != end)</span>
<span class="p_add">+		elements += qeth_get_elements_for_range(start, end);</span>
 
 	if ((elements + extra_elems) &gt; QETH_MAX_BUFFER_ELEMENTS(card)) {
 		QETH_DBF_MESSAGE(2,
<span class="p_header">diff --git a/fs/btrfs/acl.c b/fs/btrfs/acl.c</span>
<span class="p_header">index 8d8370ddb6b2..1ba49ebe67da 100644</span>
<span class="p_header">--- a/fs/btrfs/acl.c</span>
<span class="p_header">+++ b/fs/btrfs/acl.c</span>
<span class="p_chunk">@@ -114,13 +114,17 @@</span> <span class="p_context"> static int __btrfs_set_acl(struct btrfs_trans_handle *trans,</span>
 int btrfs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
 {
 	int ret;
<span class="p_add">+	umode_t old_mode = inode-&gt;i_mode;</span>
 
 	if (type == ACL_TYPE_ACCESS &amp;&amp; acl) {
 		ret = posix_acl_update_mode(inode, &amp;inode-&gt;i_mode, &amp;acl);
 		if (ret)
 			return ret;
 	}
<span class="p_del">-	return __btrfs_set_acl(NULL, inode, acl, type);</span>
<span class="p_add">+	ret = __btrfs_set_acl(NULL, inode, acl, type);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		inode-&gt;i_mode = old_mode;</span>
<span class="p_add">+	return ret;</span>
 }
 
 /*
<span class="p_header">diff --git a/include/linux/fs.h b/include/linux/fs.h</span>
<span class="p_header">index 745ea1b2e02c..18552189560b 100644</span>
<span class="p_header">--- a/include/linux/fs.h</span>
<span class="p_header">+++ b/include/linux/fs.h</span>
<span class="p_chunk">@@ -3048,7 +3048,7 @@</span> <span class="p_context"> static inline bool vma_is_fsdax(struct vm_area_struct *vma)</span>
 	if (!vma_is_dax(vma))
 		return false;
 	inode = file_inode(vma-&gt;vm_file);
<span class="p_del">-	if (inode-&gt;i_mode == S_IFCHR)</span>
<span class="p_add">+	if (S_ISCHR(inode-&gt;i_mode))</span>
 		return false; /* device-dax */
 	return true;
 }
<span class="p_header">diff --git a/include/linux/nospec.h b/include/linux/nospec.h</span>
<span class="p_header">index fbc98e2c8228..132e3f5a2e0d 100644</span>
<span class="p_header">--- a/include/linux/nospec.h</span>
<span class="p_header">+++ b/include/linux/nospec.h</span>
<span class="p_chunk">@@ -72,7 +72,6 @@</span> <span class="p_context"> static inline unsigned long array_index_mask_nospec(unsigned long index,</span>
 	BUILD_BUG_ON(sizeof(_i) &gt; sizeof(long));			\
 	BUILD_BUG_ON(sizeof(_s) &gt; sizeof(long));			\
 									\
<span class="p_del">-	_i &amp;= _mask;							\</span>
<span class="p_del">-	_i;								\</span>
<span class="p_add">+	(typeof(_i)) (_i &amp; _mask);					\</span>
 })
 #endif /* _LINUX_NOSPEC_H */
<span class="p_header">diff --git a/include/net/udplite.h b/include/net/udplite.h</span>
<span class="p_header">index 80761938b9a7..8228155b305e 100644</span>
<span class="p_header">--- a/include/net/udplite.h</span>
<span class="p_header">+++ b/include/net/udplite.h</span>
<span class="p_chunk">@@ -62,6 +62,7 @@</span> <span class="p_context"> static inline int udplite_checksum_init(struct sk_buff *skb, struct udphdr *uh)</span>
 		UDP_SKB_CB(skb)-&gt;cscov = cscov;
 		if (skb-&gt;ip_summed == CHECKSUM_COMPLETE)
 			skb-&gt;ip_summed = CHECKSUM_NONE;
<span class="p_add">+		skb-&gt;csum_valid = 0;</span>
         }
 
 	return 0;
<span class="p_header">diff --git a/kernel/bpf/arraymap.c b/kernel/bpf/arraymap.c</span>
<span class="p_header">index 9a1e6ed7babc..a38119e4a427 100644</span>
<span class="p_header">--- a/kernel/bpf/arraymap.c</span>
<span class="p_header">+++ b/kernel/bpf/arraymap.c</span>
<span class="p_chunk">@@ -20,8 +20,10 @@</span> <span class="p_context"> static void bpf_array_free_percpu(struct bpf_array *array)</span>
 {
 	int i;
 
<span class="p_del">-	for (i = 0; i &lt; array-&gt;map.max_entries; i++)</span>
<span class="p_add">+	for (i = 0; i &lt; array-&gt;map.max_entries; i++) {</span>
 		free_percpu(array-&gt;pptrs[i]);
<span class="p_add">+		cond_resched();</span>
<span class="p_add">+	}</span>
 }
 
 static int bpf_array_alloc_percpu(struct bpf_array *array)
<span class="p_chunk">@@ -37,6 +39,7 @@</span> <span class="p_context"> static int bpf_array_alloc_percpu(struct bpf_array *array)</span>
 			return -ENOMEM;
 		}
 		array-&gt;pptrs[i] = ptr;
<span class="p_add">+		cond_resched();</span>
 	}
 
 	return 0;
<span class="p_chunk">@@ -48,8 +51,9 @@</span> <span class="p_context"> static struct bpf_map *array_map_alloc(union bpf_attr *attr)</span>
 	bool percpu = attr-&gt;map_type == BPF_MAP_TYPE_PERCPU_ARRAY;
 	u32 elem_size, index_mask, max_entries;
 	bool unpriv = !capable(CAP_SYS_ADMIN);
<span class="p_add">+	u64 cost, array_size, mask64;</span>
 	struct bpf_array *array;
<span class="p_del">-	u64 array_size, mask64;</span>
<span class="p_add">+	int ret;</span>
 
 	/* check sanity of attributes */
 	if (attr-&gt;max_entries == 0 || attr-&gt;key_size != 4 ||
<span class="p_chunk">@@ -92,8 +96,19 @@</span> <span class="p_context"> static struct bpf_map *array_map_alloc(union bpf_attr *attr)</span>
 		array_size += (u64) max_entries * elem_size;
 
 	/* make sure there is no u32 overflow later in round_up() */
<span class="p_del">-	if (array_size &gt;= U32_MAX - PAGE_SIZE)</span>
<span class="p_add">+	cost = array_size;</span>
<span class="p_add">+	if (cost &gt;= U32_MAX - PAGE_SIZE)</span>
 		return ERR_PTR(-ENOMEM);
<span class="p_add">+	if (percpu) {</span>
<span class="p_add">+		cost += (u64)attr-&gt;max_entries * elem_size * num_possible_cpus();</span>
<span class="p_add">+		if (cost &gt;= U32_MAX - PAGE_SIZE)</span>
<span class="p_add">+			return ERR_PTR(-ENOMEM);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	cost = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = bpf_map_precharge_memlock(cost);</span>
<span class="p_add">+	if (ret &lt; 0)</span>
<span class="p_add">+		return ERR_PTR(ret);</span>
 
 	/* allocate all map elements and zero-initialize them */
 	array = bpf_map_area_alloc(array_size);
<span class="p_chunk">@@ -107,20 +122,16 @@</span> <span class="p_context"> static struct bpf_map *array_map_alloc(union bpf_attr *attr)</span>
 	array-&gt;map.key_size = attr-&gt;key_size;
 	array-&gt;map.value_size = attr-&gt;value_size;
 	array-&gt;map.max_entries = attr-&gt;max_entries;
<span class="p_add">+	array-&gt;map.map_flags = attr-&gt;map_flags;</span>
<span class="p_add">+	array-&gt;map.pages = cost;</span>
 	array-&gt;elem_size = elem_size;
 
<span class="p_del">-	if (!percpu)</span>
<span class="p_del">-		goto out;</span>
<span class="p_del">-</span>
<span class="p_del">-	array_size += (u64) attr-&gt;max_entries * elem_size * num_possible_cpus();</span>
<span class="p_del">-</span>
<span class="p_del">-	if (array_size &gt;= U32_MAX - PAGE_SIZE ||</span>
<span class="p_del">-	    elem_size &gt; PCPU_MIN_UNIT_SIZE || bpf_array_alloc_percpu(array)) {</span>
<span class="p_add">+	if (percpu &amp;&amp;</span>
<span class="p_add">+	    (elem_size &gt; PCPU_MIN_UNIT_SIZE ||</span>
<span class="p_add">+	     bpf_array_alloc_percpu(array))) {</span>
 		bpf_map_area_free(array);
 		return ERR_PTR(-ENOMEM);
 	}
<span class="p_del">-out:</span>
<span class="p_del">-	array-&gt;map.pages = round_up(array_size, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;</span>
 
 	return &amp;array-&gt;map;
 }
<span class="p_header">diff --git a/kernel/bpf/stackmap.c b/kernel/bpf/stackmap.c</span>
<span class="p_header">index be8519148c25..a2a232dec236 100644</span>
<span class="p_header">--- a/kernel/bpf/stackmap.c</span>
<span class="p_header">+++ b/kernel/bpf/stackmap.c</span>
<span class="p_chunk">@@ -88,6 +88,7 @@</span> <span class="p_context"> static struct bpf_map *stack_map_alloc(union bpf_attr *attr)</span>
 	smap-&gt;map.key_size = attr-&gt;key_size;
 	smap-&gt;map.value_size = value_size;
 	smap-&gt;map.max_entries = attr-&gt;max_entries;
<span class="p_add">+	smap-&gt;map.map_flags = attr-&gt;map_flags;</span>
 	smap-&gt;n_buckets = n_buckets;
 	smap-&gt;map.pages = round_up(cost, PAGE_SIZE) &gt;&gt; PAGE_SHIFT;
 
<span class="p_header">diff --git a/kernel/time/timer.c b/kernel/time/timer.c</span>
<span class="p_header">index 2d5cc7dfee14..7c477912f36d 100644</span>
<span class="p_header">--- a/kernel/time/timer.c</span>
<span class="p_header">+++ b/kernel/time/timer.c</span>
<span class="p_chunk">@@ -1884,6 +1884,12 @@</span> <span class="p_context"> int timers_dead_cpu(unsigned int cpu)</span>
 		spin_lock_irq(&amp;new_base-&gt;lock);
 		spin_lock_nested(&amp;old_base-&gt;lock, SINGLE_DEPTH_NESTING);
 
<span class="p_add">+		/*</span>
<span class="p_add">+		 * The current CPUs base clock might be stale. Update it</span>
<span class="p_add">+		 * before moving the timers over.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		forward_timer_base(new_base);</span>
<span class="p_add">+</span>
 		BUG_ON(old_base-&gt;running_timer);
 
 		for (i = 0; i &lt; WHEEL_SIZE; i++)
<span class="p_header">diff --git a/net/bridge/br_sysfs_if.c b/net/bridge/br_sysfs_if.c</span>
<span class="p_header">index 8bd569695e76..abf711112418 100644</span>
<span class="p_header">--- a/net/bridge/br_sysfs_if.c</span>
<span class="p_header">+++ b/net/bridge/br_sysfs_if.c</span>
<span class="p_chunk">@@ -230,6 +230,9 @@</span> <span class="p_context"> static ssize_t brport_show(struct kobject *kobj,</span>
 	struct brport_attribute *brport_attr = to_brport_attr(attr);
 	struct net_bridge_port *p = to_brport(kobj);
 
<span class="p_add">+	if (!brport_attr-&gt;show)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	return brport_attr-&gt;show(p, buf);
 }
 
<span class="p_header">diff --git a/net/core/dev.c b/net/core/dev.c</span>
<span class="p_header">index 8898618bf341..272f84ad16e0 100644</span>
<span class="p_header">--- a/net/core/dev.c</span>
<span class="p_header">+++ b/net/core/dev.c</span>
<span class="p_chunk">@@ -2199,8 +2199,11 @@</span> <span class="p_context"> EXPORT_SYMBOL(netif_set_xps_queue);</span>
  */
 int netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq)
 {
<span class="p_add">+	bool disabling;</span>
 	int rc;
 
<span class="p_add">+	disabling = txq &lt; dev-&gt;real_num_tx_queues;</span>
<span class="p_add">+</span>
 	if (txq &lt; 1 || txq &gt; dev-&gt;num_tx_queues)
 		return -EINVAL;
 
<span class="p_chunk">@@ -2216,15 +2219,19 @@</span> <span class="p_context"> int netif_set_real_num_tx_queues(struct net_device *dev, unsigned int txq)</span>
 		if (dev-&gt;num_tc)
 			netif_setup_tc(dev, txq);
 
<span class="p_del">-		if (txq &lt; dev-&gt;real_num_tx_queues) {</span>
<span class="p_add">+		dev-&gt;real_num_tx_queues = txq;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (disabling) {</span>
<span class="p_add">+			synchronize_net();</span>
 			qdisc_reset_all_tx_gt(dev, txq);
 #ifdef CONFIG_XPS
 			netif_reset_xps_queues_gt(dev, txq);
 #endif
 		}
<span class="p_add">+	} else {</span>
<span class="p_add">+		dev-&gt;real_num_tx_queues = txq;</span>
 	}
 
<span class="p_del">-	dev-&gt;real_num_tx_queues = txq;</span>
 	return 0;
 }
 EXPORT_SYMBOL(netif_set_real_num_tx_queues);
<span class="p_header">diff --git a/net/ipv4/fib_semantics.c b/net/ipv4/fib_semantics.c</span>
<span class="p_header">index 38c1c979ecb1..7e7b7a3efa99 100644</span>
<span class="p_header">--- a/net/ipv4/fib_semantics.c</span>
<span class="p_header">+++ b/net/ipv4/fib_semantics.c</span>
<span class="p_chunk">@@ -640,6 +640,11 @@</span> <span class="p_context"> int fib_nh_match(struct fib_config *cfg, struct fib_info *fi)</span>
 					    fi-&gt;fib_nh, cfg))
 			    return 1;
 		}
<span class="p_add">+#ifdef CONFIG_IP_ROUTE_CLASSID</span>
<span class="p_add">+		if (cfg-&gt;fc_flow &amp;&amp;</span>
<span class="p_add">+		    cfg-&gt;fc_flow != fi-&gt;fib_nh-&gt;nh_tclassid)</span>
<span class="p_add">+			return 1;</span>
<span class="p_add">+#endif</span>
 		if ((!cfg-&gt;fc_oif || cfg-&gt;fc_oif == fi-&gt;fib_nh-&gt;nh_oif) &amp;&amp;
 		    (!cfg-&gt;fc_gw  || cfg-&gt;fc_gw == fi-&gt;fib_nh-&gt;nh_gw))
 			return 0;
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 7ac319222558..4c9fbf4f5905 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -126,10 +126,13 @@</span> <span class="p_context"> static int ip_rt_redirect_silence __read_mostly	= ((HZ / 50) &lt;&lt; (9 + 1));</span>
 static int ip_rt_error_cost __read_mostly	= HZ;
 static int ip_rt_error_burst __read_mostly	= 5 * HZ;
 static int ip_rt_mtu_expires __read_mostly	= 10 * 60 * HZ;
<span class="p_del">-static int ip_rt_min_pmtu __read_mostly		= 512 + 20 + 20;</span>
<span class="p_add">+static u32 ip_rt_min_pmtu __read_mostly		= 512 + 20 + 20;</span>
 static int ip_rt_min_advmss __read_mostly	= 256;
 
 static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
<span class="p_add">+</span>
<span class="p_add">+static int ip_min_valid_pmtu __read_mostly	= IPV4_MIN_MTU;</span>
<span class="p_add">+</span>
 /*
  *	Interface to generic destination cache.
  */
<span class="p_chunk">@@ -2772,7 +2775,8 @@</span> <span class="p_context"> static struct ctl_table ipv4_route_table[] = {</span>
 		.data		= &amp;ip_rt_min_pmtu,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
<span class="p_del">-		.proc_handler	= proc_dointvec,</span>
<span class="p_add">+		.proc_handler	= proc_dointvec_minmax,</span>
<span class="p_add">+		.extra1		= &amp;ip_min_valid_pmtu,</span>
 	},
 	{
 		.procname	= &quot;min_adv_mss&quot;,
<span class="p_header">diff --git a/net/ipv4/tcp_output.c b/net/ipv4/tcp_output.c</span>
<span class="p_header">index 3d7b59ecc76c..a69606031e5f 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_output.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_output.c</span>
<span class="p_chunk">@@ -1580,7 +1580,7 @@</span> <span class="p_context"> u32 tcp_tso_autosize(const struct sock *sk, unsigned int mss_now,</span>
 	 */
 	segs = max_t(u32, bytes / mss_now, min_tso_segs);
 
<span class="p_del">-	return min_t(u32, segs, sk-&gt;sk_gso_max_segs);</span>
<span class="p_add">+	return segs;</span>
 }
 EXPORT_SYMBOL(tcp_tso_autosize);
 
<span class="p_chunk">@@ -1592,8 +1592,10 @@</span> <span class="p_context"> static u32 tcp_tso_segs(struct sock *sk, unsigned int mss_now)</span>
 	const struct tcp_congestion_ops *ca_ops = inet_csk(sk)-&gt;icsk_ca_ops;
 	u32 tso_segs = ca_ops-&gt;tso_segs_goal ? ca_ops-&gt;tso_segs_goal(sk) : 0;
 
<span class="p_del">-	return tso_segs ? :</span>
<span class="p_del">-		tcp_tso_autosize(sk, mss_now, sysctl_tcp_min_tso_segs);</span>
<span class="p_add">+	if (!tso_segs)</span>
<span class="p_add">+		tso_segs = tcp_tso_autosize(sk, mss_now,</span>
<span class="p_add">+					    sysctl_tcp_min_tso_segs);</span>
<span class="p_add">+	return min_t(u32, tso_segs, sk-&gt;sk_gso_max_segs);</span>
 }
 
 /* Returns the portion of skb which can be sent right away */
<span class="p_chunk">@@ -1907,6 +1909,24 @@</span> <span class="p_context"> static inline void tcp_mtu_check_reprobe(struct sock *sk)</span>
 	}
 }
 
<span class="p_add">+static bool tcp_can_coalesce_send_queue_head(struct sock *sk, int len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct sk_buff *skb, *next;</span>
<span class="p_add">+</span>
<span class="p_add">+	skb = tcp_send_head(sk);</span>
<span class="p_add">+	tcp_for_write_queue_from_safe(skb, next, sk) {</span>
<span class="p_add">+		if (len &lt;= skb-&gt;len)</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (unlikely(TCP_SKB_CB(skb)-&gt;eor))</span>
<span class="p_add">+			return false;</span>
<span class="p_add">+</span>
<span class="p_add">+		len -= skb-&gt;len;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* Create a new MTU probe if we are ready.
  * MTU probe is regularly attempting to increase the path MTU by
  * deliberately sending larger packets.  This discovers routing
<span class="p_chunk">@@ -1979,6 +1999,9 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 			return 0;
 	}
 
<span class="p_add">+	if (!tcp_can_coalesce_send_queue_head(sk, probe_size))</span>
<span class="p_add">+		return -1;</span>
<span class="p_add">+</span>
 	/* We&#39;re allowed to probe.  Build it now. */
 	nskb = sk_stream_alloc_skb(sk, probe_size, GFP_ATOMIC, false);
 	if (!nskb)
<span class="p_chunk">@@ -2014,6 +2037,10 @@</span> <span class="p_context"> static int tcp_mtu_probe(struct sock *sk)</span>
 			/* We&#39;ve eaten all the data from this skb.
 			 * Throw it away. */
 			TCP_SKB_CB(nskb)-&gt;tcp_flags |= TCP_SKB_CB(skb)-&gt;tcp_flags;
<span class="p_add">+			/* If this is the last SKB we copy and eor is set</span>
<span class="p_add">+			 * we need to propagate it to the new skb.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			TCP_SKB_CB(nskb)-&gt;eor = TCP_SKB_CB(skb)-&gt;eor;</span>
 			tcp_unlink_write_queue(skb, sk);
 			sk_wmem_free_skb(sk, skb);
 		} else {
<span class="p_header">diff --git a/net/ipv4/udp.c b/net/ipv4/udp.c</span>
<span class="p_header">index bef4a94ce1a0..4cd943096afa 100644</span>
<span class="p_header">--- a/net/ipv4/udp.c</span>
<span class="p_header">+++ b/net/ipv4/udp.c</span>
<span class="p_chunk">@@ -1713,6 +1713,11 @@</span> <span class="p_context"> static inline int udp4_csum_init(struct sk_buff *skb, struct udphdr *uh,</span>
 		err = udplite_checksum_init(skb, uh);
 		if (err)
 			return err;
<span class="p_add">+</span>
<span class="p_add">+		if (UDP_SKB_CB(skb)-&gt;partial_cov) {</span>
<span class="p_add">+			skb-&gt;csum = inet_compute_pseudo(skb, proto);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* Note, we are only interested in != 0 or == 0, thus the
<span class="p_header">diff --git a/net/ipv6/ip6_checksum.c b/net/ipv6/ip6_checksum.c</span>
<span class="p_header">index c0cbcb259f5a..1dc023ca98fd 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_checksum.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_checksum.c</span>
<span class="p_chunk">@@ -72,6 +72,11 @@</span> <span class="p_context"> int udp6_csum_init(struct sk_buff *skb, struct udphdr *uh, int proto)</span>
 		err = udplite_checksum_init(skb, uh);
 		if (err)
 			return err;
<span class="p_add">+</span>
<span class="p_add">+		if (UDP_SKB_CB(skb)-&gt;partial_cov) {</span>
<span class="p_add">+			skb-&gt;csum = ip6_compute_pseudo(skb, proto);</span>
<span class="p_add">+			return 0;</span>
<span class="p_add">+		}</span>
 	}
 
 	/* To support RFC 6936 (allow zero checksum in UDP/IPV6 for tunnels)
<span class="p_header">diff --git a/net/ipv6/sit.c b/net/ipv6/sit.c</span>
<span class="p_header">index db6d437002a6..d4d84da28672 100644</span>
<span class="p_header">--- a/net/ipv6/sit.c</span>
<span class="p_header">+++ b/net/ipv6/sit.c</span>
<span class="p_chunk">@@ -176,7 +176,7 @@</span> <span class="p_context"> static void ipip6_tunnel_clone_6rd(struct net_device *dev, struct sit_net *sitn)</span>
 #ifdef CONFIG_IPV6_SIT_6RD
 	struct ip_tunnel *t = netdev_priv(dev);
 
<span class="p_del">-	if (t-&gt;dev == sitn-&gt;fb_tunnel_dev) {</span>
<span class="p_add">+	if (dev == sitn-&gt;fb_tunnel_dev) {</span>
 		ipv6_addr_set(&amp;t-&gt;ip6rd.prefix, htonl(0x20020000), 0, 0, 0);
 		t-&gt;ip6rd.relay_prefix = 0;
 		t-&gt;ip6rd.prefixlen = 16;
<span class="p_header">diff --git a/net/mpls/af_mpls.c b/net/mpls/af_mpls.c</span>
<span class="p_header">index c5a5a6959c1b..ffab94d61e1d 100644</span>
<span class="p_header">--- a/net/mpls/af_mpls.c</span>
<span class="p_header">+++ b/net/mpls/af_mpls.c</span>
<span class="p_chunk">@@ -7,6 +7,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/if_arp.h&gt;
 #include &lt;linux/ipv6.h&gt;
 #include &lt;linux/mpls.h&gt;
<span class="p_add">+#include &lt;linux/nospec.h&gt;</span>
 #include &lt;linux/vmalloc.h&gt;
 #include &lt;net/ip.h&gt;
 #include &lt;net/dst.h&gt;
<span class="p_chunk">@@ -756,6 +757,22 @@</span> <span class="p_context"> static int mpls_nh_build_multi(struct mpls_route_config *cfg,</span>
 	return err;
 }
 
<span class="p_add">+static bool mpls_label_ok(struct net *net, unsigned int *index)</span>
<span class="p_add">+{</span>
<span class="p_add">+	bool is_ok = true;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Reserved labels may not be set */</span>
<span class="p_add">+	if (*index &lt; MPLS_LABEL_FIRST_UNRESERVED)</span>
<span class="p_add">+		is_ok = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* The full 20 bit range may not be supported. */</span>
<span class="p_add">+	if (is_ok &amp;&amp; *index &gt;= net-&gt;mpls.platform_labels)</span>
<span class="p_add">+		is_ok = false;</span>
<span class="p_add">+</span>
<span class="p_add">+	*index = array_index_nospec(*index, net-&gt;mpls.platform_labels);</span>
<span class="p_add">+	return is_ok;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int mpls_route_add(struct mpls_route_config *cfg)
 {
 	struct mpls_route __rcu **platform_label;
<span class="p_chunk">@@ -774,12 +791,7 @@</span> <span class="p_context"> static int mpls_route_add(struct mpls_route_config *cfg)</span>
 		index = find_free_label(net);
 	}
 
<span class="p_del">-	/* Reserved labels may not be set */</span>
<span class="p_del">-	if (index &lt; MPLS_LABEL_FIRST_UNRESERVED)</span>
<span class="p_del">-		goto errout;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The full 20 bit range may not be supported. */</span>
<span class="p_del">-	if (index &gt;= net-&gt;mpls.platform_labels)</span>
<span class="p_add">+	if (!mpls_label_ok(net, &amp;index))</span>
 		goto errout;
 
 	/* Append makes no sense with mpls */
<span class="p_chunk">@@ -840,12 +852,7 @@</span> <span class="p_context"> static int mpls_route_del(struct mpls_route_config *cfg)</span>
 
 	index = cfg-&gt;rc_label;
 
<span class="p_del">-	/* Reserved labels may not be removed */</span>
<span class="p_del">-	if (index &lt; MPLS_LABEL_FIRST_UNRESERVED)</span>
<span class="p_del">-		goto errout;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* The full 20 bit range may not be supported */</span>
<span class="p_del">-	if (index &gt;= net-&gt;mpls.platform_labels)</span>
<span class="p_add">+	if (!mpls_label_ok(net, &amp;index))</span>
 		goto errout;
 
 	mpls_route_update(net, index, NULL, &amp;cfg-&gt;rc_nlinfo);
<span class="p_chunk">@@ -1279,10 +1286,9 @@</span> <span class="p_context"> static int rtm_to_route_config(struct sk_buff *skb,  struct nlmsghdr *nlh,</span>
 					   &amp;cfg-&gt;rc_label))
 				goto errout;
 
<span class="p_del">-			/* Reserved labels may not be set */</span>
<span class="p_del">-			if (cfg-&gt;rc_label &lt; MPLS_LABEL_FIRST_UNRESERVED)</span>
<span class="p_add">+			if (!mpls_label_ok(cfg-&gt;rc_nlinfo.nl_net,</span>
<span class="p_add">+					   &amp;cfg-&gt;rc_label))</span>
 				goto errout;
<span class="p_del">-</span>
 			break;
 		}
 		case RTA_VIA:
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index e1c123d4cdda..c1f59a06da6f 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2258,7 +2258,7 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 	if (cb-&gt;start) {
 		ret = cb-&gt;start(cb);
 		if (ret)
<span class="p_del">-			goto error_unlock;</span>
<span class="p_add">+			goto error_put;</span>
 	}
 
 	nlk-&gt;cb_running = true;
<span class="p_chunk">@@ -2278,6 +2278,8 @@</span> <span class="p_context"> int __netlink_dump_start(struct sock *ssk, struct sk_buff *skb,</span>
 	 */
 	return -EINTR;
 
<span class="p_add">+error_put:</span>
<span class="p_add">+	module_put(control-&gt;module);</span>
 error_unlock:
 	sock_put(sk);
 	mutex_unlock(nlk-&gt;cb_mutex);
<span class="p_header">diff --git a/net/netlink/genetlink.c b/net/netlink/genetlink.c</span>
<span class="p_header">index 49c28e8ef01b..11702016c900 100644</span>
<span class="p_header">--- a/net/netlink/genetlink.c</span>
<span class="p_header">+++ b/net/netlink/genetlink.c</span>
<span class="p_chunk">@@ -1103,6 +1103,7 @@</span> <span class="p_context"> static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,</span>
 {
 	struct sk_buff *tmp;
 	struct net *net, *prev = NULL;
<span class="p_add">+	bool delivered = false;</span>
 	int err;
 
 	for_each_net_rcu(net) {
<span class="p_chunk">@@ -1114,14 +1115,21 @@</span> <span class="p_context"> static int genlmsg_mcast(struct sk_buff *skb, u32 portid, unsigned long group,</span>
 			}
 			err = nlmsg_multicast(prev-&gt;genl_sock, tmp,
 					      portid, group, flags);
<span class="p_del">-			if (err)</span>
<span class="p_add">+			if (!err)</span>
<span class="p_add">+				delivered = true;</span>
<span class="p_add">+			else if (err != -ESRCH)</span>
 				goto error;
 		}
 
 		prev = net;
 	}
 
<span class="p_del">-	return nlmsg_multicast(prev-&gt;genl_sock, skb, portid, group, flags);</span>
<span class="p_add">+	err = nlmsg_multicast(prev-&gt;genl_sock, skb, portid, group, flags);</span>
<span class="p_add">+	if (!err)</span>
<span class="p_add">+		delivered = true;</span>
<span class="p_add">+	else if (err != -ESRCH)</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	return delivered ? 0 : -ESRCH;</span>
  error:
 	kfree_skb(skb);
 	return err;
<span class="p_header">diff --git a/net/rxrpc/output.c b/net/rxrpc/output.c</span>
<span class="p_header">index 5dab1ff3a6c2..59d328603312 100644</span>
<span class="p_header">--- a/net/rxrpc/output.c</span>
<span class="p_header">+++ b/net/rxrpc/output.c</span>
<span class="p_chunk">@@ -391,7 +391,7 @@</span> <span class="p_context"> int rxrpc_send_data_packet(struct rxrpc_call *call, struct sk_buff *skb,</span>
 					(char *)&amp;opt, sizeof(opt));
 		if (ret == 0) {
 			ret = kernel_sendmsg(conn-&gt;params.local-&gt;socket, &amp;msg,
<span class="p_del">-					     iov, 1, iov[0].iov_len);</span>
<span class="p_add">+					     iov, 2, len);</span>
 
 			opt = IPV6_PMTUDISC_DO;
 			kernel_setsockopt(conn-&gt;params.local-&gt;socket,
<span class="p_header">diff --git a/net/sctp/ipv6.c b/net/sctp/ipv6.c</span>
<span class="p_header">index 5d015270e454..11f69d4c5619 100644</span>
<span class="p_header">--- a/net/sctp/ipv6.c</span>
<span class="p_header">+++ b/net/sctp/ipv6.c</span>
<span class="p_chunk">@@ -324,8 +324,10 @@</span> <span class="p_context"> static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,</span>
 		final_p = fl6_update_dst(fl6, rcu_dereference(np-&gt;opt), &amp;final);
 		bdst = ip6_dst_lookup_flow(sk, fl6, final_p);
 
<span class="p_del">-		if (!IS_ERR(bdst) &amp;&amp;</span>
<span class="p_del">-		    ipv6_chk_addr(dev_net(bdst-&gt;dev),</span>
<span class="p_add">+		if (IS_ERR(bdst))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (ipv6_chk_addr(dev_net(bdst-&gt;dev),</span>
 				  &amp;laddr-&gt;a.v6.sin6_addr, bdst-&gt;dev, 1)) {
 			if (!IS_ERR_OR_NULL(dst))
 				dst_release(dst);
<span class="p_chunk">@@ -334,8 +336,10 @@</span> <span class="p_context"> static void sctp_v6_get_dst(struct sctp_transport *t, union sctp_addr *saddr,</span>
 		}
 
 		bmatchlen = sctp_v6_addr_match_len(daddr, &amp;laddr-&gt;a);
<span class="p_del">-		if (matchlen &gt; bmatchlen)</span>
<span class="p_add">+		if (matchlen &gt; bmatchlen) {</span>
<span class="p_add">+			dst_release(bdst);</span>
 			continue;
<span class="p_add">+		}</span>
 
 		if (!IS_ERR_OR_NULL(dst))
 			dst_release(dst);
<span class="p_header">diff --git a/net/sctp/protocol.c b/net/sctp/protocol.c</span>
<span class="p_header">index 7b523e3f551f..fb7b7632316a 100644</span>
<span class="p_header">--- a/net/sctp/protocol.c</span>
<span class="p_header">+++ b/net/sctp/protocol.c</span>
<span class="p_chunk">@@ -510,22 +510,20 @@</span> <span class="p_context"> static void sctp_v4_get_dst(struct sctp_transport *t, union sctp_addr *saddr,</span>
 		if (IS_ERR(rt))
 			continue;
 
<span class="p_del">-		if (!dst)</span>
<span class="p_del">-			dst = &amp;rt-&gt;dst;</span>
<span class="p_del">-</span>
 		/* Ensure the src address belongs to the output
 		 * interface.
 		 */
 		odev = __ip_dev_find(sock_net(sk), laddr-&gt;a.v4.sin_addr.s_addr,
 				     false);
 		if (!odev || odev-&gt;ifindex != fl4-&gt;flowi4_oif) {
<span class="p_del">-			if (&amp;rt-&gt;dst != dst)</span>
<span class="p_add">+			if (!dst)</span>
<span class="p_add">+				dst = &amp;rt-&gt;dst;</span>
<span class="p_add">+			else</span>
 				dst_release(&amp;rt-&gt;dst);
 			continue;
 		}
 
<span class="p_del">-		if (dst != &amp;rt-&gt;dst)</span>
<span class="p_del">-			dst_release(dst);</span>
<span class="p_add">+		dst_release(dst);</span>
 		dst = &amp;rt-&gt;dst;
 		break;
 	}
<span class="p_header">diff --git a/net/sctp/sm_make_chunk.c b/net/sctp/sm_make_chunk.c</span>
<span class="p_header">index 9e9690b7afe1..fc67d356b5fa 100644</span>
<span class="p_header">--- a/net/sctp/sm_make_chunk.c</span>
<span class="p_header">+++ b/net/sctp/sm_make_chunk.c</span>
<span class="p_chunk">@@ -1373,9 +1373,14 @@</span> <span class="p_context"> static struct sctp_chunk *_sctp_make_chunk(const struct sctp_association *asoc,</span>
 	sctp_chunkhdr_t *chunk_hdr;
 	struct sk_buff *skb;
 	struct sock *sk;
<span class="p_add">+	int chunklen;</span>
<span class="p_add">+</span>
<span class="p_add">+	chunklen = SCTP_PAD4(sizeof(*chunk_hdr) + paylen);</span>
<span class="p_add">+	if (chunklen &gt; SCTP_MAX_CHUNK_LEN)</span>
<span class="p_add">+		goto nodata;</span>
 
 	/* No need to allocate LL here, as this is only a chunk. */
<span class="p_del">-	skb = alloc_skb(SCTP_PAD4(sizeof(sctp_chunkhdr_t) + paylen), gfp);</span>
<span class="p_add">+	skb = alloc_skb(chunklen, gfp);</span>
 	if (!skb)
 		goto nodata;
 
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 293f3f213776..ceb162a9dcfd 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -180,7 +180,7 @@</span> <span class="p_context"> static const struct kernel_param_ops param_ops_xint = {</span>
 };
 #define param_check_xint param_check_int
 
<span class="p_del">-static int power_save = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;</span>
<span class="p_add">+static int power_save = -1;</span>
 module_param(power_save, xint, 0644);
 MODULE_PARM_DESC(power_save, &quot;Automatic power-saving timeout &quot;
 		 &quot;(in second, 0 = disable).&quot;);
<span class="p_chunk">@@ -2042,6 +2042,24 @@</span> <span class="p_context"> static int azx_probe(struct pci_dev *pci,</span>
 	return err;
 }
 
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+/* On some boards setting power_save to a non 0 value leads to clicking /</span>
<span class="p_add">+ * popping sounds when ever we enter/leave powersaving mode. Ideally we would</span>
<span class="p_add">+ * figure out how to avoid these sounds, but that is not always feasible.</span>
<span class="p_add">+ * So we keep a list of devices where we disable powersaving as its known</span>
<span class="p_add">+ * to causes problems on these devices.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct snd_pci_quirk power_save_blacklist[] = {</span>
<span class="p_add">+	/* https://bugzilla.redhat.com/show_bug.cgi?id=1525104 */</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1849, 0x0c0c, &quot;Asrock B85M-ITX&quot;, 0),</span>
<span class="p_add">+	/* https://bugzilla.redhat.com/show_bug.cgi?id=1525104 */</span>
<span class="p_add">+	SND_PCI_QUIRK(0x1043, 0x8733, &quot;Asus Prime X370-Pro&quot;, 0),</span>
<span class="p_add">+	/* https://bugzilla.kernel.org/show_bug.cgi?id=198611 */</span>
<span class="p_add">+	SND_PCI_QUIRK(0x17aa, 0x2227, &quot;Lenovo X1 Carbon 3rd Gen&quot;, 0),</span>
<span class="p_add">+	{}</span>
<span class="p_add">+};</span>
<span class="p_add">+#endif /* CONFIG_PM */</span>
<span class="p_add">+</span>
 /* number of codec slots for each chipset: 0 = default slots (i.e. 4) */
 static unsigned int azx_max_codecs[AZX_NUM_DRIVERS] = {
 	[AZX_DRIVER_NVIDIA] = 8,
<span class="p_chunk">@@ -2054,6 +2072,7 @@</span> <span class="p_context"> static int azx_probe_continue(struct azx *chip)</span>
 	struct hdac_bus *bus = azx_bus(chip);
 	struct pci_dev *pci = chip-&gt;pci;
 	int dev = chip-&gt;dev_index;
<span class="p_add">+	int val;</span>
 	int err;
 
 	hda-&gt;probe_continued = 1;
<span class="p_chunk">@@ -2129,7 +2148,22 @@</span> <span class="p_context"> static int azx_probe_continue(struct azx *chip)</span>
 
 	chip-&gt;running = 1;
 	azx_add_card_list(chip);
<span class="p_del">-	snd_hda_set_power_save(&amp;chip-&gt;bus, power_save * 1000);</span>
<span class="p_add">+</span>
<span class="p_add">+	val = power_save;</span>
<span class="p_add">+#ifdef CONFIG_PM</span>
<span class="p_add">+	if (val == -1) {</span>
<span class="p_add">+		const struct snd_pci_quirk *q;</span>
<span class="p_add">+</span>
<span class="p_add">+		val = CONFIG_SND_HDA_POWER_SAVE_DEFAULT;</span>
<span class="p_add">+		q = snd_pci_quirk_lookup(chip-&gt;pci, power_save_blacklist);</span>
<span class="p_add">+		if (q &amp;&amp; val) {</span>
<span class="p_add">+			dev_info(chip-&gt;card-&gt;dev, &quot;device %04x:%04x is on the power_save blacklist, forcing power_save to 0\n&quot;,</span>
<span class="p_add">+				 q-&gt;subvendor, q-&gt;subdevice);</span>
<span class="p_add">+			val = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+#endif /* CONFIG_PM */</span>
<span class="p_add">+	snd_hda_set_power_save(&amp;chip-&gt;bus, val * 1000);</span>
 	if (azx_has_pm_runtime(chip) || hda-&gt;use_vga_switcheroo)
 		pm_runtime_put_autosuspend(&amp;pci-&gt;dev);
 
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 89c166b97e81..974b74e91ef0 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -4480,13 +4480,14 @@</span> <span class="p_context"> static void alc_fixup_tpt470_dock(struct hda_codec *codec,</span>
 
 	if (action == HDA_FIXUP_ACT_PRE_PROBE) {
 		spec-&gt;parse_flags = HDA_PINCFG_NO_HP_FIXUP;
<span class="p_add">+		snd_hda_apply_pincfgs(codec, pincfgs);</span>
<span class="p_add">+	} else if (action == HDA_FIXUP_ACT_INIT) {</span>
 		/* Enable DOCK device */
 		snd_hda_codec_write(codec, 0x17, 0,
 			    AC_VERB_SET_CONFIG_DEFAULT_BYTES_3, 0);
 		/* Enable DOCK device */
 		snd_hda_codec_write(codec, 0x19, 0,
 			    AC_VERB_SET_CONFIG_DEFAULT_BYTES_3, 0);
<span class="p_del">-		snd_hda_apply_pincfgs(codec, pincfgs);</span>
 	}
 }
 
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index 8a59d4782a0f..69bf5cf1e91e 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -3277,4 +3277,51 @@</span> <span class="p_context"> AU0828_DEVICE(0x2040, 0x7270, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),</span>
 	}
 },
 
<span class="p_add">+{</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Bower&#39;s &amp; Wilkins PX headphones only support the 48 kHz sample rate</span>
<span class="p_add">+	 * even though it advertises more. The capture interface doesn&#39;t work</span>
<span class="p_add">+	 * even on windows.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	USB_DEVICE(0x19b5, 0x0021),</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp;(const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_COMPOSITE,</span>
<span class="p_add">+		.data = (const struct snd_usb_audio_quirk[]) {</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 0,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_STANDARD_MIXER,</span>
<span class="p_add">+			},</span>
<span class="p_add">+			/* Capture */</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 1,</span>
<span class="p_add">+				.type = QUIRK_IGNORE_INTERFACE,</span>
<span class="p_add">+			},</span>
<span class="p_add">+			/* Playback */</span>
<span class="p_add">+			{</span>
<span class="p_add">+				.ifnum = 2,</span>
<span class="p_add">+				.type = QUIRK_AUDIO_FIXED_ENDPOINT,</span>
<span class="p_add">+				.data = &amp;(const struct audioformat) {</span>
<span class="p_add">+					.formats = SNDRV_PCM_FMTBIT_S16_LE,</span>
<span class="p_add">+					.channels = 2,</span>
<span class="p_add">+					.iface = 2,</span>
<span class="p_add">+					.altsetting = 1,</span>
<span class="p_add">+					.altset_idx = 1,</span>
<span class="p_add">+					.attributes = UAC_EP_CS_ATTR_FILL_MAX |</span>
<span class="p_add">+						UAC_EP_CS_ATTR_SAMPLE_RATE,</span>
<span class="p_add">+					.endpoint = 0x03,</span>
<span class="p_add">+					.ep_attr = USB_ENDPOINT_XFER_ISOC,</span>
<span class="p_add">+					.rates = SNDRV_PCM_RATE_48000,</span>
<span class="p_add">+					.rate_min = 48000,</span>
<span class="p_add">+					.rate_max = 48000,</span>
<span class="p_add">+					.nr_rates = 1,</span>
<span class="p_add">+					.rate_table = (unsigned int[]) {</span>
<span class="p_add">+						48000</span>
<span class="p_add">+					}</span>
<span class="p_add">+				}</span>
<span class="p_add">+			},</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 #undef USB_DEVICE_VENDOR_SPEC
<span class="p_header">diff --git a/virt/kvm/kvm_main.c b/virt/kvm/kvm_main.c</span>
<span class="p_header">index 1b20768e781d..eaae7252f60c 100644</span>
<span class="p_header">--- a/virt/kvm/kvm_main.c</span>
<span class="p_header">+++ b/virt/kvm/kvm_main.c</span>
<span class="p_chunk">@@ -976,8 +976,7 @@</span> <span class="p_context"> int __kvm_set_memory_region(struct kvm *kvm,</span>
 		/* Check for overlaps */
 		r = -EEXIST;
 		kvm_for_each_memslot(slot, __kvm_memslots(kvm, as_id)) {
<span class="p_del">-			if ((slot-&gt;id &gt;= KVM_USER_MEM_SLOTS) ||</span>
<span class="p_del">-			    (slot-&gt;id == id))</span>
<span class="p_add">+			if (slot-&gt;id == id)</span>
 				continue;
 			if (!((base_gfn + npages &lt;= slot-&gt;base_gfn) ||
 			      (base_gfn &gt;= slot-&gt;base_gfn + slot-&gt;npages)))

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



