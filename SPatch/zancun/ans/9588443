
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
 "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
 <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <title>Linux 3.16.40 - Patchwork</title>
  <link rel="stylesheet" type="text/css" href="/static/css/style.css"/>
  <script type="text/javascript" src="/static/js/common.js"></script>
  <script type="text/javascript" src="/static/js/jquery-1.10.1.min.js"></script>

 </head>
 <body>
  <div id="title">
  <h1 style="float: left;">
     <a
      href="/">Patchwork</a>
    Linux 3.16.40</h1>
  <div id="auth">

     <a href="/user/login/">login</a>
     <br/>
     <a href="/register/">register</a>
     <br/>
     <a href="/mail/">mail settings</a>

   </div>
   <div style="clear: both;"></div>
  </div>
  <div id="nav">
   <div id="navleft">
   
    <strong>Project</strong>: LKML
     :
     <a href="/project/LKML/list/"
      >patches</a>
     :
     <a href="/project/LKML/"
      >project info</a>
    
     :
     <a href="/"
     >other projects</a>
     
    
   </div>
   <div id="navright">
    <a href="/help/about/">about</a>
   </div>
   <div style="clear: both"></div>
  </div>

  <div id="content">

<script language="JavaScript" type="text/javascript">
function toggle_headers(link_id, headers_id)
{
    var link = document.getElementById(link_id)
    var headers = document.getElementById(headers_id)

    var hidden = headers.style['display'] == 'none';

    if (hidden) {
        link.innerHTML = 'hide';
        headers.style['display'] = 'block';
    } else {
        link.innerHTML = 'show';
        headers.style['display'] = 'none';
    }

}
</script>

<table class="patchmeta">
 <tr>
  <th>Submitter</th>
  <td><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a></td>
 </tr>
 <tr>
  <th>Date</th>
  <td>Feb. 23, 2017, 3:29 p.m.</td>
 </tr>
 <tr>
  <th>Message ID</th>
  <td>&lt;20170223152920.GL4152@decadent.org.uk&gt;</td>
 </tr>
 <tr>
  <th>Download</th>
  <td>
   <a href="/patch/9588443/mbox/"
   >mbox</a>
|
   <a href="/patch/9588443/raw/"
   >patch</a>

   </td>
 </tr>
 <tr>
  <th>Permalink</th>
  <td><a href="/patch/9588443/">/patch/9588443/</a>
 </tr>
  <tr>
   <th>State</th>
   <td>New</td>
  </tr>


 <tr>
  <th>Headers</th>
  <td><a id="togglepatchheaders"
   href="javascript:toggle_headers('togglepatchheaders', 'patchheaders')"
   >show</a>
   <div id="patchheaders" class="patchheaders" style="display:none;">
    <pre>Return-Path: &lt;linux-kernel-owner@kernel.org&gt;
Received: from mail.wl.linuxfoundation.org (pdx-wl-mail.web.codeaurora.org
	[172.30.200.125])
	by pdx-korg-patchwork.web.codeaurora.org (Postfix) with ESMTP id
	D3EFE60578 for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 23 Feb 2017 15:30:42 +0000 (UTC)
Received: from mail.wl.linuxfoundation.org (localhost [127.0.0.1])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 9F144284F9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 23 Feb 2017 15:30:42 +0000 (UTC)
Received: by mail.wl.linuxfoundation.org (Postfix, from userid 486)
	id 90B85288DD; Thu, 23 Feb 2017 15:30:42 +0000 (UTC)
X-Spam-Checker-Version: SpamAssassin 3.3.1 (2010-03-16) on
	pdx-wl-mail.web.codeaurora.org
X-Spam-Level: 
X-Spam-Status: No, score=-6.9 required=2.0 tests=BAYES_00,RCVD_IN_DNSWL_HI
	autolearn=ham version=3.3.1
Received: from vger.kernel.org (vger.kernel.org [209.132.180.67])
	by mail.wl.linuxfoundation.org (Postfix) with ESMTP id 2285A284F9
	for &lt;patchwork-LKML@patchwork.kernel.org&gt;;
	Thu, 23 Feb 2017 15:30:24 +0000 (UTC)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
	id S1751657AbdBWPaI (ORCPT
	&lt;rfc822;patchwork-LKML@patchwork.kernel.org&gt;);
	Thu, 23 Feb 2017 10:30:08 -0500
Received: from shadbolt.e.decadent.org.uk ([88.96.1.126]:50595 &quot;EHLO
	shadbolt.e.decadent.org.uk&quot; rhost-flags-OK-OK-OK-OK)
	by vger.kernel.org with ESMTP id S1751367AbdBWP3y (ORCPT
	&lt;rfc822;linux-kernel@vger.kernel.org&gt;);
	Thu, 23 Feb 2017 10:29:54 -0500
Received: from ben by shadbolt.decadent.org.uk with local (Exim 4.84_2)
	(envelope-from &lt;ben@decadent.org.uk&gt;)
	id 1cgvKa-0008Me-Qx; Thu, 23 Feb 2017 15:29:39 +0000
Date: Thu, 23 Feb 2017 15:29:20 +0000
From: Ben Hutchings &lt;ben@decadent.org.uk&gt;
To: linux-kernel@vger.kernel.org, Andrew Morton &lt;akpm@linux-foundation.org&gt;,
	torvalds@linux-foundation.org, Jiri Slaby &lt;jslaby@suse.cz&gt;,
	stable@vger.kernel.org
Cc: lwn@lwn.net
Message-ID: &lt;20170223152920.GL4152@decadent.org.uk&gt;
MIME-Version: 1.0
Content-Type: multipart/signed; micalg=pgp-sha512;
	protocol=&quot;application/pgp-signature&quot;; boundary=&quot;dZihrQ6eCIduWT38&quot;
Content-Disposition: inline
X-Mailer: LinuxStableQueue (scripts by bwh)
User-Agent: Mutt/1.5.23 (2014-03-12)
X-SA-Exim-Connect-IP: &lt;locally generated&gt;
X-SA-Exim-Mail-From: ben@decadent.org.uk
Subject: Linux 3.16.40
X-SA-Exim-Version: 4.2.1 (built Mon, 26 Dec 2011 16:24:06 +0000)
X-SA-Exim-Scanned: Yes (on shadbolt.decadent.org.uk)
Sender: linux-kernel-owner@vger.kernel.org
Precedence: bulk
List-ID: &lt;linux-kernel.vger.kernel.org&gt;
X-Mailing-List: linux-kernel@vger.kernel.org
X-Virus-Scanned: ClamAV using ClamSMTP
</pre>
   </div>
  </td>
 </tr>
</table>

<div class="patchforms">





 <div style="clear: both;">
 </div>
</div>



<h2>Comments</h2>

<div class="comment">
<div class="meta"><a href="/project/LKML/list/?submitter=131">Ben Hutchings</a> - Feb. 23, 2017, 3:29 p.m.</div>
<pre class="content">
I&#39;m announcing the release of the 3.16.40 kernel.

All users of the 3.16 kernel series should upgrade.

The updated 3.16.y git tree can be found at:
        https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux-stable.git linux-3.16.y
and can be browsed at the normal kernel.org git web browser:
        https://git.kernel.org/?p=linux/kernel/git/stable/linux-stable.git

The diff from 3.16.39 is attached to this message.

Ben.

------------

 MAINTAINERS                                        |   9 +-
 Makefile                                           |   7 +-
 arch/arc/kernel/signal.c                           |   7 +-
 arch/arm/boot/dts/exynos4210-pinctrl.dtsi          |   2 +-
 arch/arm/mach-pxa/corgi_pm.c                       |  13 +-
 arch/arm/mach-pxa/include/mach/sharpsl_pm.h        |   2 +-
 arch/arm/mach-pxa/sharpsl_pm.c                     |   2 +-
 arch/arm/mach-pxa/spitz_pm.c                       |   9 +-
 arch/arm64/include/asm/kvm_emulate.h               |  11 +-
 arch/arm64/kernel/debug-monitors.c                 |   6 +-
 arch/arm64/kernel/head.S                           |   3 +-
 arch/m68k/include/asm/delay.h                      |   2 +-
 arch/metag/include/asm/atomic.h                    |   3 +-
 arch/mips/cavium-octeon/setup.c                    |  14 +
 arch/mips/include/asm/kexec.h                      |   1 +
 arch/mips/include/asm/kvm_host.h                   |   7 +-
 arch/mips/include/asm/ptrace.h                     |   2 +-
 arch/mips/kernel/crash.c                           |  18 +-
 arch/mips/kernel/machine_kexec.c                   |   1 +
 arch/mips/kvm/kvm_mips_emul.c                      |  39 ++-
 arch/parisc/include/asm/pgtable.h                  |   8 +-
 arch/parisc/kernel/pacache.S                       |  49 ++--
 arch/parisc/kernel/pci-dma.c                       |   2 +-
 arch/parisc/kernel/syscall.S                       |  11 +-
 arch/powerpc/include/asm/kvm_book3s.h              |   1 +
 arch/powerpc/include/asm/kvm_host.h                |   2 +-
 arch/powerpc/include/asm/reg.h                     |   1 +
 arch/powerpc/kernel/asm-offsets.c                  |   2 +-
 arch/powerpc/kernel/eeh_driver.c                   |  12 +-
 arch/powerpc/kernel/idle_power7.S                  |   2 +-
 arch/powerpc/kernel/nvram_64.c                     |   6 +-
 arch/powerpc/kernel/vdso64/datapage.S              |   2 +-
 arch/powerpc/kernel/vdso64/gettimeofday.S          |   2 +-
 arch/powerpc/kvm/book3s_emulate.c                  |   2 +
 arch/powerpc/kvm/book3s_hv.c                       |   4 +-
 arch/powerpc/kvm/book3s_hv_rmhandlers.S            |  14 +-
 arch/powerpc/kvm/book3s_pr.c                       |   6 +
 arch/powerpc/kvm/booke.c                           |   2 +-
 arch/powerpc/lib/copyuser_64.S                     |   2 +-
 arch/powerpc/platforms/powernv/eeh-ioda.c          |   5 +
 arch/powerpc/platforms/powernv/pci.c               |   4 +-
 arch/powerpc/platforms/pseries/lpar.c              |   4 +-
 arch/s390/hypfs/hypfs_diag.c                       |   6 +-
 arch/tile/kernel/time.c                            |   4 +-
 arch/x86/include/asm/kexec.h                       |   1 +
 arch/x86/include/asm/smp.h                         |   1 +
 arch/x86/include/asm/uaccess.h                     |  10 +-
 arch/x86/kernel/apic/x2apic_uv_x.c                 |   4 +-
 arch/x86/kernel/cpu/perf_event.c                   |   2 +-
 arch/x86/kernel/cpu/perf_event_intel.c             |   2 +-
 arch/x86/kernel/crash.c                            |  22 +-
 arch/x86/kernel/head_32.S                          |   2 +-
 arch/x86/kernel/ptrace.c                           |   4 +-
 arch/x86/kernel/smp.c                              |   5 +
 arch/x86/kvm/emulate.c                             |  36 +--
 arch/x86/kvm/x86.c                                 |  20 +-
 block/blk-cgroup.h                                 |   2 +-
 block/bsg.c                                        |   3 +
 crypto/async_tx/async_pq.c                         |   8 +-
 crypto/gcm.c                                       |   2 +-
 drivers/acpi/apei/ghes.c                           |   2 +-
 drivers/base/platform.c                            |   4 +-
 drivers/base/power/main.c                          |   8 +-
 drivers/block/nvme-core.c                          |   6 +-
 drivers/char/hw_random/core.c                      |   6 +-
 drivers/char/virtio_console.c                      |  22 +-
 drivers/clk/clk-divider.c                          |   2 +-
 drivers/firewire/net.c                             |   8 +-
 drivers/gpio/gpio-mvebu.c                          |  94 +++---
 drivers/gpu/drm/i915/intel_crt.c                   |  10 +-
 drivers/gpu/drm/i915/intel_drv.h                   |   2 +-
 drivers/gpu/drm/i915/intel_pm.c                    |   9 +
 drivers/gpu/drm/radeon/ni.c                        |   4 +-
 drivers/gpu/drm/radeon/r600_dpm.c                  |  15 +-
 drivers/gpu/drm/radeon/radeon_device.c             |   5 +-
 drivers/gpu/drm/radeon/si_dpm.c                    |  55 +++-
 drivers/gpu/drm/radeon/sislands_smc.h              |   1 +
 drivers/hid/hid-core.c                             |   3 +
 drivers/hid/hid-ids.h                              |   2 +
 drivers/hid/usbhid/hid-quirks.c                    |   2 +
 drivers/hv/hv_util.c                               |  10 +-
 drivers/i2c/i2c-core.c                             |   2 +-
 .../iio/common/hid-sensors/hid-sensor-attributes.c |  60 ++--
 drivers/infiniband/core/cm.c                       | 125 +++++++-
 drivers/infiniband/core/umem.c                     |   2 +-
 drivers/infiniband/core/uverbs_main.c              |   7 +-
 drivers/infiniband/hw/mlx4/cq.c                    |   5 +-
 drivers/infiniband/hw/mlx5/cq.c                    |   3 +-
 drivers/infiniband/hw/mlx5/mlx5_ib.h               |   2 +
 drivers/infiniband/hw/mlx5/mr.c                    |   6 +-
 drivers/infiniband/hw/mlx5/qp.c                    |   5 +-
 drivers/infiniband/ulp/srp/ib_srp.c                |   8 +-
 drivers/input/mouse/elantech.c                     |  11 +-
 drivers/input/serio/i8042-x86ia64io.h              |   7 +
 drivers/iommu/amd_iommu.c                          |   3 +
 drivers/iommu/dmar.c                               |   4 +-
 drivers/iommu/intel-iommu.c                        |  13 +
 drivers/isdn/gigaset/ser-gigaset.c                 |   4 +-
 drivers/md/dm-mpath.c                              |   6 +-
 drivers/md/dm-table.c                              |  24 +-
 drivers/md/dm.c                                    |   5 +
 drivers/md/md.c                                    |   2 +-
 drivers/media/dvb-frontends/mb86a20s.c             | 104 +++----
 drivers/media/tuners/tuner-xc2028.c                |  37 +--
 drivers/media/usb/cx231xx/cx231xx-avcore.c         |   5 +-
 drivers/media/usb/cx231xx/cx231xx-cards.c          |   2 +-
 drivers/media/usb/cx231xx/cx231xx-core.c           |   3 +-
 drivers/media/usb/dvb-usb/dib0700_core.c           |   5 +-
 drivers/memstick/host/rtsx_usb_ms.c                |   6 +
 drivers/mfd/Kconfig                                |   1 +
 drivers/mfd/mfd-core.c                             |   2 +
 drivers/mfd/rtsx_usb.c                             |  10 +-
 drivers/misc/genwqe/card_utils.c                   |  12 +-
 drivers/misc/mei/hw-txe.c                          |   6 +-
 drivers/misc/mei/nfc.c                             |   2 +-
 drivers/mmc/card/block.c                           |   5 +-
 drivers/mmc/card/queue.h                           |   2 +-
 drivers/mmc/host/moxart-mmc.c                      |   5 +-
 drivers/mmc/host/mxs-mmc.c                         |   4 +-
 drivers/mmc/host/rtsx_usb_sdmmc.c                  |   7 +-
 drivers/mmc/host/sdhci.c                           |   2 +-
 drivers/mtd/ubi/eba.c                              |   4 +-
 drivers/mtd/ubi/fastmap.c                          |  22 +-
 drivers/mtd/ubi/wl.c                               |  45 ++-
 drivers/net/can/usb/peak_usb/pcan_usb_core.c       |   6 +-
 drivers/net/ethernet/broadcom/bcmsysport.c         |   2 +-
 drivers/net/ethernet/broadcom/bgmac.c              |   5 +-
 drivers/net/ethernet/broadcom/genet/bcmgenet.c     |  11 +-
 drivers/net/ethernet/cirrus/ep93xx_eth.c           |   4 +
 drivers/net/ethernet/intel/i40e/i40e_main.c        |   6 +
 drivers/net/ethernet/marvell/mvneta.c              |   2 +-
 drivers/net/ethernet/mellanox/mlx4/cmd.c           |  23 +-
 drivers/net/ethernet/mellanox/mlx4/en_clock.c      |   5 +-
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c     |   7 +
 drivers/net/ethernet/mellanox/mlx4/en_port.c       |   2 +-
 drivers/net/ethernet/mellanox/mlx4/en_rx.c         |   2 +-
 drivers/net/ethernet/mellanox/mlx4/mcg.c           |   7 +-
 drivers/net/ethernet/mellanox/mlx4/mlx4.h          |   7 +-
 drivers/net/ethernet/mellanox/mlx4/port.c          |  13 +-
 .../net/ethernet/mellanox/mlx5/core/pagealloc.c    |  26 +-
 drivers/net/ethernet/renesas/sh_eth.c              |   2 +-
 drivers/net/ethernet/ti/cpsw-phy-sel.c             |   3 +
 drivers/net/ethernet/ti/cpsw.c                     |  16 +-
 drivers/net/wireless/mwifiex/cfg80211.c            |  13 +-
 drivers/net/wireless/rtlwifi/regd.c                |  45 ++-
 drivers/net/wireless/rtlwifi/regd.h                |   1 +
 drivers/of/of_mdio.c                               |   5 +-
 drivers/pci/quirks.c                               |   1 +
 drivers/phy/phy-sun4i-usb.c                        |  11 +-
 drivers/pwm/core.c                                 |   2 +
 drivers/pwm/sysfs.c                                |  20 ++
 drivers/regulator/tps65910-regulator.c             |   6 +
 drivers/s390/char/con3270.c                        |  11 +-
 drivers/s390/scsi/zfcp_dbf.c                       | 162 +++++++++--
 drivers/s390/scsi/zfcp_dbf.h                       |  14 +-
 drivers/s390/scsi/zfcp_erp.c                       |  12 +-
 drivers/s390/scsi/zfcp_ext.h                       |   8 +-
 drivers/s390/scsi/zfcp_fsf.c                       |  22 +-
 drivers/s390/scsi/zfcp_fsf.h                       |   4 +-
 drivers/s390/scsi/zfcp_scsi.c                      |   8 +-
 drivers/scsi/arcmsr/arcmsr_hba.c                   |   9 -
 drivers/scsi/ibmvscsi/ibmvfc.c                     |   1 -
 drivers/scsi/megaraid/megaraid_sas.h               |   2 +-
 drivers/scsi/megaraid/megaraid_sas_base.c          |  13 +-
 drivers/scsi/mpt3sas/mpt3sas_scsih.c               |  15 +-
 drivers/scsi/scsi_debug.c                          |   1 +
 drivers/scsi/scsi_scan.c                           |   2 +-
 drivers/scsi/sg.c                                  |   8 +-
 drivers/staging/android/ion/ion.c                  |  55 +++-
 drivers/staging/iio/impedance-analyzer/ad5933.c    |  17 +-
 drivers/staging/nvec/nvec_ps2.c                    |   8 +-
 drivers/staging/rtl8188eu/os_dep/usb_intf.c        |   4 +-
 drivers/target/target_core_transport.c             |  11 +
 drivers/target/target_core_xcopy.c                 |  34 ++-
 drivers/tty/tty_ldisc.c                            |   7 +
 drivers/tty/vt/vt.c                                |   7 +-
 drivers/uio/uio_dmem_genirq.c                      |   2 +-
 drivers/usb/chipidea/core.c                        |   1 +
 drivers/usb/chipidea/udc.c                         |   2 -
 drivers/usb/class/cdc-acm.c                        |   2 -
 drivers/usb/class/usbtmc.c                         |   3 +-
 drivers/usb/gadget/f_fs.c                          |   1 -
 drivers/usb/gadget/u_ether.c                       |   7 -
 drivers/usb/host/xhci-hub.c                        |  37 +++
 drivers/usb/host/xhci-pci.c                        |  10 +-
 drivers/usb/host/xhci.h                            |   3 +
 drivers/usb/misc/legousbtower.c                    |  35 ++-
 drivers/usb/serial/cp210x.c                        |   2 +
 drivers/usb/serial/ftdi_sio.c                      |   5 +-
 drivers/usb/serial/ftdi_sio_ids.h                  |  11 +-
 drivers/usb/serial/usb-serial.c                    |   3 +-
 drivers/usb/storage/transport.c                    |   7 +-
 drivers/uwb/lc-rc.c                                |  16 +-
 drivers/uwb/pal.c                                  |   2 +
 drivers/video/fbdev/core/fbcmap.c                  |  26 +-
 drivers/video/fbdev/efifb.c                        |   6 +-
 fs/btrfs/tree-log.c                                |  20 +-
 fs/cifs/cifs_debug.c                               |   1 +
 fs/cifs/cifsfs.c                                   |   3 +-
 fs/cifs/cifsglob.h                                 |  30 +-
 fs/cifs/cifssmb.c                                  |   4 +-
 fs/cifs/connect.c                                  |   2 +-
 fs/cifs/file.c                                     |  66 +++--
 fs/cifs/misc.c                                     |  15 +-
 fs/cifs/readdir.c                                  |   6 +-
 fs/cifs/smb2glob.h                                 |  10 +
 fs/cifs/smb2inode.c                                |   6 +
 fs/cifs/smb2misc.c                                 |  16 +-
 fs/cifs/smb2ops.c                                  |   5 +-
 fs/cifs/smb2pdu.c                                  |  21 +-
 fs/cifs/smb2pdu.h                                  |   2 +-
 fs/coredump.c                                      |   3 +
 fs/ext4/ext4.h                                     |   1 +
 fs/ext4/inode.c                                    |  10 +-
 fs/ext4/namei.c                                    |  14 +-
 fs/ext4/super.c                                    |  17 +-
 fs/fuse/dir.c                                      |  62 +++-
 fs/fuse/file.c                                     |   8 +-
 fs/isofs/inode.c                                   |   8 +-
 fs/jbd2/transaction.c                              |   3 +-
 fs/nfs/nfs4state.c                                 |   3 +
 fs/proc/proc_sysctl.c                              |   3 +-
 fs/pstore/ram_core.c                               |  49 +---
 fs/reiserfs/super.c                                |  12 +-
 fs/super.c                                         |   6 +-
 fs/ubifs/dir.c                                     |  16 +-
 fs/ubifs/xattr.c                                   |   2 +
 fs/xfs/xfs_acl.c                                   |   3 +-
 fs/xfs/xfs_file.c                                  |   2 +-
 fs/xfs/xfs_inode.c                                 |   2 +-
 fs/xfs/xfs_ioctl.c                                 |   2 +-
 fs/xfs/xfs_iops.c                                  |  96 +++---
 fs/xfs/xfs_iops.h                                  |   7 +-
 include/linux/compiler.h                           |   2 +-
 include/linux/filter.h                             |   6 +-
 include/linux/hugetlb.h                            |   6 +-
 include/linux/mfd/88pm80x.h                        |   4 +-
 include/linux/pwm.h                                |   5 +
 include/linux/sem.h                                |   1 +
 include/linux/sunrpc/svc_rdma.h                    |   9 +
 include/net/ip6_tunnel.h                           |   1 +
 include/net/netfilter/nf_tables.h                  |   1 +
 include/net/sock.h                                 |   9 +-
 include/net/tcp.h                                  |   1 +
 include/target/target_core_base.h                  |   1 +
 include/uapi/linux/can.h                           |   1 +
 ipc/msg.c                                          |  34 ++-
 ipc/sem.c                                          | 165 ++++++-----
 ipc/shm.c                                          |  42 +--
 ipc/util.c                                         |   6 +-
 kernel/events/core.c                               | 324 +++++++++++++++++----
 kernel/irq/generic-chip.c                          |  22 ++
 kernel/locking/rtmutex.c                           |  68 ++++-
 kernel/panic.c                                     |  48 ++-
 kernel/power/suspend_test.c                        |   4 +-
 lib/genalloc.c                                     |   3 +-
 lib/mpi/mpi-pow.c                                  |   7 +-
 mm/filemap.c                                       |   5 +-
 mm/hugetlb.c                                       |  39 ++-
 mm/memory_hotplug.c                                |   4 +-
 mm/swapfile.c                                      |   2 +
 net/batman-adv/translation-table.c                 |   4 +-
 net/bridge/br_multicast.c                          |  23 +-
 net/can/bcm.c                                      |  32 +-
 net/can/raw.c                                      |   3 +
 net/core/filter.c                                  |  10 +-
 net/core/rtnetlink.c                               |   8 +-
 net/core/sock.c                                    |  30 +-
 net/dccp/ipv4.c                                    |   2 +-
 net/dccp/ipv6.c                                    |   2 +-
 net/ipv4/ip_output.c                               |   7 +-
 net/ipv4/ip_sockglue.c                             |   7 +-
 net/ipv4/netfilter/arp_tables.c                    |   4 +-
 net/ipv4/ping.c                                    |   4 +
 net/ipv4/route.c                                   |   6 +-
 net/ipv4/sysctl_net_ipv4.c                         |   8 +-
 net/ipv4/tcp_ipv4.c                                |  19 +-
 net/ipv6/addrconf.c                                |   2 +-
 net/ipv6/ip6_output.c                              |   2 +-
 net/ipv6/output_core.c                             |   2 +
 net/ipv6/tcp_ipv6.c                                |   6 +-
 net/l2tp/l2tp_ip.c                                 |   5 +-
 net/l2tp/l2tp_ip6.c                                |   5 +-
 net/mac80211/rx.c                                  |  24 +-
 net/netfilter/nf_conntrack_core.c                  |   7 +
 net/netfilter/nf_conntrack_sip.c                   |   5 +-
 net/netfilter/nf_tables_api.c                      |  29 +-
 net/netfilter/nfnetlink.c                          |   9 +-
 net/netfilter/nft_bitwise.c                        |   7 +-
 net/netfilter/nft_byteorder.c                      |  15 +-
 net/netfilter/nft_cmp.c                            |   3 +
 net/netfilter/nft_exthdr.c                         |  13 +-
 net/netfilter/nft_immediate.c                      |   4 +
 net/netlink/af_netlink.c                           |   7 +-
 net/packet/af_packet.c                             |  29 +-
 net/rose/rose_in.c                                 |   3 +-
 net/sched/sch_fq.c                                 |  32 +-
 net/sctp/sm_sideeffect.c                           |  16 +-
 net/sctp/sm_statefuns.c                            |  12 +-
 net/sunrpc/xprtrdma/svc_rdma_recvfrom.c            |   2 +-
 net/sunrpc/xprtrdma/svc_rdma_sendto.c              |  20 +-
 net/sunrpc/xprtrdma/svc_rdma_transport.c           |  20 +-
 net/tipc/bearer.c                                  |  13 +-
 net/tipc/bearer.h                                  |  16 +
 net/wireless/core.h                                |   1 +
 net/wireless/scan.c                                |  69 +++++
 scripts/gcc-x86_64-has-stack-protector.sh          |   2 +-
 security/apparmor/domain.c                         |   6 +-
 sound/core/pcm_lib.c                               |   2 +-
 sound/pci/ali5451/ali5451.c                        |   2 +
 sound/pci/hda/hda_intel.c                          |   7 +-
 sound/pci/hda/patch_realtek.c                      |  14 +
 sound/pci/hda/thinkpad_helper.c                    |   3 +
 sound/soc/codecs/cs4270.c                          |   8 +-
 sound/soc/soc-dapm.c                               |   2 +-
 sound/usb/mixer_quirks.c                           |  22 +-
 sound/usb/quirks-table.h                           |  17 ++
 tools/perf/util/symbol-elf.c                       |   2 +-
 tools/perf/util/symbol.c                           |   2 +-
 319 files changed, 2888 insertions(+), 1273 deletions(-)

Al Viro (2):
      arc: don&#39;t leak bits of kernel stack into coredump
      sg_write()/bsg_write() is not fit to be called under KERNEL_DS

Alan Stern (1):
      memstick: rtsx_usb_ms: Runtime resume the device when polling for cards

Alex Deucher (4):
      drm/radeon: narrow asic_init for virtualization
      drm/radeon/si/dpm: fix phase shedding setup
      drm/radeon: change vblank_time&#39;s calculation method to reduce computational error.
      drm/radeon/si_dpm: workaround for SI kickers

Alexander Usyskin (2):
      mei: txe: don&#39;t clean an unprocessed interrupt cause.
      mei: bus: fix received data size check in NFC fixup

Andrew Bresticker (1):
      pstore/ram: Use memcpy_fromio() to save old buffer

Andrew Donnellan (1):
      powerpc/eeh: Fix deadlock when PE frozen state can&#39;t be cleared

Andrew Lunn (1):
      net: ethernet: mvneta: Remove IFF_UNICAST_FLT which is not implemented

Andrew Lutomirski (1):
      hwrng: core - Don&#39;t use a stack buffer in add_early_randomness()

Andrey Grodzovsky (1):
      scsi: mpt3sas: Fix secure erase premature termination

Andrey Ryabinin (2):
      coredump: fix unfreezable coredumping task
      mpi: Fix NULL ptr dereference in mpi_powm() [ver #3]

Andy Gospodarek (1):
      bgmac: stop clearing DMA receive control register right after it is set

Andy Lutomirski (1):
      x86/traps: Ignore high word of regs-&gt;cs in early_fixup_exception()

Anssi Hannula (1):
      ALSA: usb-audio: Extend DragonFly dB scale quirk to cover other variants

Anton Blanchard (1):
      powerpc/vdso64: Use double word compare on pointers

Ard Biesheuvel (1):
      ALSA: hda - allow 40 bit DMA mask for NVidia devices

Arnaldo Carvalho de Melo (1):
      perf symbols: Fixup symbol sizes before picking best ones

Arnd Bergmann (1):
      staging: iio: ad5933: avoid uninitialized variable in error case

Ashok Raj (1):
      iommu/vt-d: Fix IOMMU lookup for SR-IOV Virtual Functions

Baoquan He (1):
      iommu/amd: Free domain id when free a domain of struct dma_ops_domain

Bart Van Assche (3):
      dm: mark request_queue dead before destroying the DM device
      blkcg: Annotate blkg_hint correctly
      IB/srp: Fix infinite loop when FMR sg[0].offset != 0

Ben Hutchings (3):
      Revert &quot;fs: Give dentry to inode_change_ok() instead of inode&quot;
      net: Add __sock_queue_rcv_skb()
      Linux 3.16.40

Benjamin Tissoires (1):
      HID: core: prevent out-of-bound readings

Boris Brezillon (2):
      UBI: fastmap: scrub PEB when bitflips are detected in a free PEB EC header
      m68k: Fix ndelay() macro

Borislav Petkov (1):
      kbuild: Steal gcc&#39;s pie from the very beginning

Brian King (1):
      scsi: ibmvfc: Fix I/O hang when port is not mapped

Brian Norris (2):
      PM / sleep: don&#39;t suspend parent when async child suspend_{noirq, late} fails
      mwifiex: printk() overflow with 32-byte SSIDs

Calvin Owens (1):
      sg: Fix double-free when drives detach during SG_IO

Chen-Yu Tsai (2):
      ASoC: dapm: Fix value setting for _ENUM_DOUBLE MUX&#39;s second channel
      phy: sun4i-usb: Use spinlock to guard phyctl register access

Ching Huang (1):
      scsi: arcmsr: Send SYNCHRONIZE_CACHE command to firmware

Chris Brandt (1):
      sh_eth: remove unchecked interrupts for RZ/A1

Chris Mason (1):
      btrfs: fix races on root_log_ctx lists

Chris Metcalf (1):
      tile: avoid using clocksource_cyc2ns with absolute cycle count

Chuck Lever (1):
      svcrdma: Tail iovec leaves an orphaned DMA mapping

Daeho Jeong (1):
      ext4: reinforce check of i_dtime when clearing high fields of uid and gid

Dan Carpenter (6):
      KVM: PPC: BookE: Fix a sanity check
      mfd: 88pm80x: Double shifting bug in suspend/resume
      scsi: zfcp: spin_lock_irqsave() is not nestable
      netfilter: nf_tables: underflow in nft_parse_u32_check()
      x86/apic/uv: Silence a shift wrapping warning
      ser_gigaset: return -ENOMEM on error instead of success

Daniel Glöckner (1):
      mmc: block: don&#39;t use CMD23 with very old MMC cards

Daniel Jurgens (1):
      IB/mlx5: Use cache line size to select CQE stride

Daniel Mentz (1):
      lib/genalloc.c: start search from start of chunk

Dave Chinner (1):
      xfs: change mailing list address

David Hsu (1):
      pwm: Unexport children before chip removal

Dinesh Israni (1):
      target: Don&#39;t override EXTENDED_COPY xcopy_pt_cmd SCSI status code

Dmitry Torokhov (1):
      Input: elantech - add Fujitsu Lifebook E556 to force crc_enabled

Dmitry Vyukov (1):
      tty: limit terminal size to 4M chars

Doug Brown (1):
      USB: serial: ftdi_sio: add support for TI CC3200 LaunchPad

Eli Cohen (1):
      IB/mlx5: Fix NULL pointer dereference on debug print

Eli Cooper (3):
      ip6_tunnel: Clear IP6CB in ip6tunnel_xmit()
      ipv4: Set skb-&gt;protocol properly for local output
      ipv6: Set skb-&gt;protocol properly for local output

Erez Shitrit (1):
      net/mlx4_en: Process all completions in RX rings after port goes up

Eric Dumazet (5):
      ipv4: accept u8 in IP_TOS ancillary data
      pkt_sched: fq: use proper locking in fq_dump_stats()
      netlink: do not enter direct reclaim from netlink_dump()
      tcp: take care of truncations done by sk_filter()
      net: avoid signed overflows for SO_{SND|RCV}BUFFORCE

Eugenia Emantayev (1):
      net/mlx4_en: Resolve dividing by zero in 32-bit system

EunTaik Lee (1):
      staging/android/ion : fix a race condition in the ion driver

Ewan D. Milne (1):
      scsi: scsi_debug: Fix memory leak if LBP enabled and module is unloaded

Fabio Estevam (1):
      mmc: mxs: Initialize the spinlock prior to using it

Felipe Balbi (1):
      usb: gadget: u_ether: remove interrupt throttling

Florian Fainelli (3):
      net: systemport: Fix ordering in intrl2_*_mask_clear macro
      net: bcmgenet: Utilize correct struct device for all DMA operations
      net: ep93xx_eth: Do not crash unloading module

Florian Westphal (1):
      netfilter: restart search if moved to other chain

Furquan Shaikh (1):
      pstore/ram: Use memcpy_toio instead of memcpy

Gavin Shan (1):
      powerpc/powernv: Use CPU-endian PEST in pnv_pci_dump_p7ioc_diag_data()

Geert Uytterhoeven (1):
      clk: divider: Fix clk_divider_round_rate() to use clk_readl()

Gerald Schaefer (3):
      mm/hugetlb: fix memory offline with hugepage size &gt; memory block size
      mm/hugetlb: check for reserved hugepages during memory offline
      GenWQE: Fix bad page access during abort of resource allocation

Greg Kroah-Hartman (2):
      usb: misc: legousbtower: Fix NULL pointer deference
      Revert &quot;usbtmc: convert to devm_kzalloc&quot;

Guenter Roeck (1):
      metag: Only define atomic_dec_if_positive conditionally

Guilherme G Piccoli (1):
      i40e: avoid NULL pointer dereference and recursive errors on early PCI error

Guillaume Nault (1):
      l2tp: fix racy SOCK_ZAPPED flag check in l2tp_ip{,6}_bind()

Haibo Chen (1):
      mmc: sdhci: cast unsigned int to unsigned long long to avoid unexpeted error

Hidehiro Kawai (2):
      x86/panic: replace smp_send_stop() with kdump friendly version in panic path
      mips/panic: replace smp_send_stop() with kdump friendly version in panic path

Hongxu Jia (1):
      netfilter: arp_tables: fix invoking 32bit &quot;iptable -P INPUT ACCEPT&quot; failed in 64bit kernel

Hui Wang (2):
      ALSA: hda - Adding one more ALC255 pin definition for headset problem
      ALSA: hda - add a new condition to check if it is thinkpad

Ido Yariv (1):
      KVM: x86: fix wbinvd_dirty_mask use-after-free

Ignacio Alvarado (1):
      KVM: Disable irq while unregistering user notifier

Jack Morgenstein (4):
      net/mlx4_core: Fix deadlock when switching between polling and event fw commands
      net/mlx4_core: Fix the resource-type enum in res tracker to conform to FW spec
      net/mlx4_en: Fix potential deadlock in port statistics flow
      net/mlx4: Fix uninitialized fields in rule when adding promiscuous mode to device managed flow steering

Jakub Sitnicki (1):
      ipv6: Don&#39;t use ufo handling on later transformed packets

James Hogan (2):
      KVM: MIPS: Make ERET handle ERL before EXL
      KVM: MIPS: Precalculate MMIO load resume PC

Jan Kara (4):
      xfs: Propagate dentry down to inode_change_ok()
      fuse: Propagate dentry down to inode_change_ok()
      fs: Give dentry to inode_change_ok() instead of inode
      isofs: Do not return EACCES for unknown filesystems

Jan Remmet (1):
      regulator: tps65910: Work around silicon erratum SWCZ010

Jan Viktorin (1):
      uio: fix dmem_region_start computation

Jann Horn (1):
      swapfile: fix memory corruption via malformed swapfile

Jason Gunthorpe (1):
      gpio/mvebu: Use irq_domain_add_linear

Jiri Slaby (2):
      mmc: core: Annotate cmd_hdr as __le32
      tty: vt, fix bogus division in csi_J

Joe Perches (1):
      ipc: remove use of seq_printf return value

Johan Hovold (11):
      USB: serial: fix potential NULL-dereference at probe
      uwb: fix device reference leaks
      PM / sleep: fix device reference leak in test_suspend
      net: ethernet: ti: cpsw: fix device and of_node leaks
      USB: cdc-acm: fix TIOCMIWAIT
      mfd: core: Fix device reference leak in mfd_clone_cell
      of_mdio: fix node leak in of_phy_register_fixed_link error path
      net: ethernet: ti: cpsw: fix bad register access in probe error path
      net: ethernet: ti: cpsw: fix mdio device reference leak
      net: ethernet: ti: cpsw: fix secondary-emac probe error path
      pwm: Fix device reference leak

Johannes Berg (2):
      mac80211: discard multicast and 4-addr A-MSDUs
      cfg80211: limit scan results cache size

Johannes Weiner (1):
      mm: filemap: fix mapping-&gt;nrpages double accounting in fuse

John David Anglin (5):
      parisc: Ensure consistent state when switching to kernel stack at syscall entry
      parisc: Fix race in pci-dma.c
      parisc: Also flush data TLB in flush_icache_page_asm
      parisc: Purge TLB before setting PTE
      parisc: Remove unnecessary TLB purges from flush_dcache_page_asm and flush_icache_page_asm

John Johansen (1):
      apparmor: fix change_hat not finding hat after policy replacement

John W. Linville (1):
      netfilter: nf_tables: fix type mismatch with error return from nft_parse_u32_check

Josh Poimboeuf (1):
      x86/dumpstack: Fix x86_32 kernel_stack_pointer() previous stack access

Justin Maggard (1):
      async_pq_val: fix DMA memory leak

Kamal Heib (1):
      net/mlx4_en: Fix wrong indentation

Kashyap Desai (1):
      scsi: megaraid_sas: Fix data integrity failure for JBOD (passthrough) devices

Kees Cook (2):
      net: ping: check minimum size on ICMP header length
      fbdev: color map copying bounds checking

Keith Busch (1):
      nvme/pci: Don&#39;t free queues on error

Krzysztof Kozlowski (1):
      ARM: dts: exynos: Fix mismatched value for SD4 pull up/down configuration on exynos4210

Kyle Jones (1):
      USB: serial: cp210x: Add ID for a Juniper console

Lance Richardson (1):
      ipv4: allow local fragmentation in ip_finish_output_gso()

Larry Finger (1):
      rtlwifi: Fix missing country code for Great Britain

Lars-Peter Clausen (1):
      usb: gadget: f_fs: Fix use-after-free

Laura Abbott (1):
      HID: usbhid: Add HID_QUIRK_NOGET for Aten DVI KVM switch

Laura Garcia Liebana (2):
      netfilter: nft_exthdr: Add size check on u8 nft_exthdr attributes
      netfilter: nf_tables: validate maximum value of u32 netlink attributes

Laurent Dufour (1):
      powerpc/pseries: Fix stack corruption in htpe code

Linus Torvalds (2):
      Fix potential infoleak in older kernels
      vfs,mm: fix return value of read() at s_maxbytes

Liping Zhang (1):
      netfilter: nf_tables: destroy the set if fail to add transaction

Long Li (1):
      hv: do not lose pending heartbeat vmbus packets

Lu Baolu (1):
      mfd: rtsx_usb: Avoid setting ucr-&gt;current_sg.status

Lucas Stach (1):
      drm/radeon: drop register readback in cayman_cp_int_cntl_setup

Lyude (2):
      drm/i915/vlv: Make intel_crt_reset() per-encoder
      drm/i915/vlv: Reset the ADPA in vlv_display_power_well_init()

Maik Broemme (1):
      PCI: Mark Atheros AR9580 to avoid bus reset

Manfred Spraul (1):
      ipc/sem.c: fix complex_count vs. simple op race

Marc Dietrich (1):
      staging: nvec: remove managed resource from PS2 driver

Marc Kleine-Budde (1):
      can: raw: raw_setsockopt: limit number of can_filter that can be set

Marc Zyngier (1):
      arm64: kernel: Init MDCR_EL2 even in the absence of a PMU

Marcel Hasler (1):
      ALSA: usb-audio: Add quirk for Syntek STK1160

Marcelo Ricardo Leitner (1):
      sctp: validate chunk len before actually using it

Marcin Nowakowski (1):
      MIPS: ptrace: Fix regs_return_value for kernel context

Mark Bloch (2):
      IB/cm: Mark stale CM id&#39;s whenever the mad agent was unregistered
      IB/core: Avoid unsigned int overflow in sg_alloc_table

Matan Barak (1):
      IB/mlx4: Fix create CQ error flow

Mathias Krause (1):
      rtnl: reset calcit fptr in rtnl_unregister()

Mathias Nyman (2):
      xhci: add restart quirk for Intel Wildcatpoint PCH
      xhci: workaround for hosts missing CAS bit

Matt Redfearn (1):
      virtio: console: Unlock vqs while freeing buffers

Mauro Carvalho Chehab (4):
      mb86a20s: fix the locking logic
      mb86a20s: fix demod settings
      cx231xx: don&#39;t return error on success
      cx231xx: fix GPIOs for Pixelview SBTVD hybrid

Max Staudt (1):
      fbdev/efifb: Fix 16 color palette entry calculation

Michael Holzheu (1):
      s390/hypfs: Use get_free_page() instead of kmalloc to ensure page alignment

Michal Kubeček (1):
      tipc: check minimum bearer MTU

Mike Galbraith (1):
      reiserfs: Unlock superblock before calling reiserfs_quota_on_mount()

Mike Snitzer (1):
      dm mpath: check if path&#39;s request_queue is dying in activate_path()

Miklos Szeredi (5):
      fuse: invalidate dir dentry after chmod
      fuse: fix killing s[ug]id in setattr
      fuse: listxattr: verify xattr list
      fuse: fix fuse_write_end() if zero bytes were copied
      fuse: fix clearing suid, sgid for chown()

Ming Lei (1):
      scsi: Fix use-after-free

Moshe Lazer (1):
      IB/mlx5: Resolve soft lock on massive reg MRs

NeilBrown (1):
      md: be careful not lot leak internal curr_resync value into metadata. -- (all)

Nicholas Bellinger (1):
      target: Make EXTENDED_COPY 0xe4 failure return COPY TARGET DEVICE NOT REACHABLE

Nicholas Mc Guire (2):
      mmc: moxart: fix wait_for_completion_interruptible_timeout return variable type
      MIPS: KVM: Fix unused variable build warning

Nicolas Dichtel (1):
      ipv6: correctly add local routes when lo goes up

Nikolay Aleksandrov (1):
      bridge: multicast: restore perm router ports on multicast enable

Noa Osherovich (1):
      net/mlx5: Avoid passing dma address 0 to firmware

Oleg Nesterov (1):
      fs/super.c: fix race between freeze_super() and thaw_super()

Oliver Hartkopp (1):
      can: bcm: fix warning in bcm_connect/proc_register

Oliver Neukum (1):
      HID: usbhid: add ATEN CS962 to list of quirky devices

Ondrej Mosnáček (1):
      crypto: gcm - Fix IV buffer size in crypto_gcm_setkey

Pan Xinhui (1):
      powerpc/nvram: Fix an incorrect partition merge

Paolo Bonzini (1):
      KVM: x86: fix missed SRCU usage in kvm_lapic_set_vapic_addr

Patrick Scheuring (1):
      Input: i8042 - add XMG C504 to keyboard reset table

Paul E. McKenney (1):
      compiler: Allow 1- and 2-byte smp_load_acquire() and smp_store_release()

Paul Fertser (2):
      drivers: staging: nvec: remove bogus reset command for PS/2 interface
      Revert &quot;staging: nvec: ps2: change serio type to passthrough&quot;

Paul Jakma (1):
      USB: serial: cp210x: add ID for the Zone DPMX

Paul Mackerras (2):
      KVM: PPC: Book3S: Treat VTB as a per-subcore register, not per-thread
      powerpc/64: Fix incorrect return value from __copy_tofrom_user

Peter Chen (1):
      usb: chipidea: move the lock initialization to core file

Peter Hurley (1):
      tty: Prevent ldisc drivers from re-using stale tty fields

Peter Zijlstra (4):
      perf: Fix race in swevent hash
      perf: Fix event-&gt;ctx locking
      perf: Do not double free
      perf/core: Fix concurrent sys_perf_event_open() vs. &#39;move_group&#39; race

Peter Zijlstra (Intel) (1):
      perf/x86: Fix full width counter, counter overflow

Petr Vandrovec (1):
      Fix USB CB/CBI storage devices with CONFIG_VMAP_STACK=y

Phil Turnbull (1):
      netfilter: nfnetlink: correctly validate length of batch messages

Philip Pettersson (1):
      packet: fix race condition in packet_set_ring

Punit Agrawal (1):
      ACPI / APEI: Fix incorrect return value of ghes_proc()

Radim Krčmář (1):
      KVM: x86: drop error recovery in em_jmp_far and em_ret_far

Richard Weinberger (6):
      ubi: Deal with interrupted erasures in WL
      ubi: Fix races around ubi_refill_pools()
      ubi: Fix Fastmap&#39;s update_vol()
      ubifs: Fix xattr_names length in exit paths
      ubifs: Abort readdir upon error
      ubifs: Fix regression in ubifs_readdir()

Robert Jarzmik (1):
      ARM: pxa: fix GPIO double shifts

Ross Lagerwall (1):
      cifs: Limit the overall credit acquired

Russell Currey (1):
      powerpc/eeh: Null check uses of eeh_pe_bus_get

Sabrina Dubroca (1):
      rtnetlink: fix rtnl_vfinfo_size

Sachin Kamat (1):
      iio: hid-sensors: Fix compilation warning

Sascha Silbe (2):
      s390/con3270: fix use of uninitialised data
      s390/con3270: fix insufficient space padding

Scot Doyle (1):
      vt: clear selection before resizing

Sean Young (1):
      dib0700: fix nec repeat handling

Sebastian Andrzej Siewior (3):
      pstore/core: drop cmpxchg based updates
      kbuild: add -fno-PIE
      scripts/has-stack-protector: add -fno-PIE

Sebastian Frias (1):
      genirq/generic_chip: Add irq_unmap callback

Segher Boessenkool (1):
      powerpc: Convert cmp to cmpd in idle enter sequence

Sergei Shtylyov (1):
      platform: don&#39;t return 0 from platform_get_irq[_byname]() on error

Shao Fu (1):
      rtlwifi: Update regulatory database

Song Hongyan (1):
      iio: hid-sensors: Increase the precision of scale to fix wrong reading interpretation.

Stefan Richter (1):
      firewire: net: fix fragmented datagram_size off-by-one

Stefan Tauner (1):
      USB: serial: ftdi_sio: add support for Infineon TriBoard TC2X7

Steffen Maier (10):
      zfcp: fix fc_host port_type with NPIV
      zfcp: fix ELS/GS request&amp;response length for hardware data router
      zfcp: close window with unblocked rport during rport gone
      zfcp: retain trace level for SCSI and HBA FSF response records
      zfcp: restore: Dont use 0 to indicate invalid LUN in rec trace
      zfcp: trace on request for open and close of WKA port
      zfcp: restore tracing of handle for port and LUN with HBA records
      zfcp: fix D_ID field with actual value on tracing SAN responses
      zfcp: fix payload trace length for SAN request&amp;response
      zfcp: trace full payload of all SAN records (req,resp,iels)

Stephen Suryaputra Lin (1):
      ipv4: use new_gw for redirect neigh lookup

Steve French (6):
      Display number of credits available
      Set previous session id correctly on SMB3 reconnect
      SMB3: GUIDs should be constructed as random but valid uuids
      Clarify locking of cifs file and tcon structures and make more granular
      Do not send SMB3 SET_INFO request if nothing is changing
      Cleanup missing frees on some ioctls

Sumit Saxena (1):
      scsi: megaraid_sas: fix macro MEGASAS_IS_LOGICAL to avoid regression

Sven Eckelmann (1):
      batman-adv: Check for alloc errors when preparing TT local data

Taesoo Kim (1):
      jbd2: fix incorrect unlock on j_list_lock

Takashi Iwai (5):
      ALSA: ali5451: Fix out-of-bound position reporting
      ALSA: hda - Fix surround output pins for ASRock B150M mobo
      ALSA: hda - Fix mic regression by ASRock mobo fixup
      xc2028: Fix use-after-free bug properly
      ALSA: pcm : Call kill_fasync() in stream lock

Tariq Toukan (1):
      IB/uverbs: Fix leak of XRC target QPs

Theodore Ts&#39;o (1):
      ext4: sanity check the block and cluster size at mount time

Thomas Gleixner (1):
      locking/rtmutex: Prevent dequeue vs. unlock race

Thomas Huth (1):
      KVM: PPC: Book3s PR: Allow access to unprivileged MMCR2 register

Tom St Denis (1):
      drm/radeon/si_dpm: Limit clocks on HD86xx part

Trond Myklebust (1):
      NFSv4: Open state recovery must account for file permission changes

Ulf Hansson (3):
      mmc: rtsx_usb_sdmmc: Avoid keeping the device runtime resumed when unused
      mmc: rtsx_usb_sdmmc: Handle runtime PM while changing the led
      memstick: rtsx_usb_ms: Manage runtime PM when accessing the device

Ulrich Weber (1):
      netfilter: nf_conntrack_sip: extend request line validation

Uwe Kleine-König (1):
      mfd: wm8350-i2c: Make sure the i2c regmap functions are compiled

Vladimir Zapolskiy (1):
      i2c: core: fix NULL pointer dereference under race condition

WANG Cong (2):
      ipv4: use the right lock for ping_group_range
      neigh: check error pointer instead of NULL for ipv4_neigh_lookup()

Wei Fang (1):
      vfs,mm: fix a dead loop in truncate_inode_pages_range()

Wei Yongjun (2):
      staging: rtl8188eu: fix missing unlock on error in rtw_resume_process()
      staging: rtl8188eu: fix double unlock error in rtw_resume_process()

Will Deacon (2):
      arm64: debug: avoid resetting stepping state machine when TIF_SINGLESTEP
      arm64: KVM: Take S1 walks into account when determining S2 write faults

Willem de Bruijn (3):
      packet: on direct_xmit, limit tso and csum to supported devices
      rose: limit sk_filter trim to payload
      dccp: limit sk_filter trim to payload

Xin Long (1):
      sctp: do not return the transmit err back to sctp_sendmsg

Zhou Chengming (1):
      sysctl: Drop reference added by grab_header in proc_sys_readdir

gmail (1):
      ext4: release bh in make_indexed_dir

murray foster (1):
      ASoC: cs4270: fix DAPM stream name mismatch

tang.junhui (1):
      dm table: fix missing dm_put_target_type() in dm_table_add_target()

wangguang (1):
      ext4: bugfix for mmaped pages in mpage_release_unused_pages()

추지호 (1):
      can: peak: fix bad memory access and free sequence
</pre>
</div>



<h2>Patch</h2>
<div class="patch">
<pre class="content">
<span class="p_header">diff --git a/MAINTAINERS b/MAINTAINERS</span>
<span class="p_header">index 8a5cae0ca281..65791c0891a9 100644</span>
<span class="p_header">--- a/MAINTAINERS</span>
<span class="p_header">+++ b/MAINTAINERS</span>
<span class="p_chunk">@@ -10057,12 +10057,11 @@</span> <span class="p_context"> F:	arch/x86/xen/*swiotlb*</span>
 F:	drivers/xen/*swiotlb*
 
 XFS FILESYSTEM
<span class="p_del">-P:	Silicon Graphics Inc</span>
 M:	Dave Chinner &lt;david@fromorbit.com&gt;
<span class="p_del">-M:	xfs@oss.sgi.com</span>
<span class="p_del">-L:	xfs@oss.sgi.com</span>
<span class="p_del">-W:	http://oss.sgi.com/projects/xfs</span>
<span class="p_del">-T:	git git://oss.sgi.com/xfs/xfs.git</span>
<span class="p_add">+M:	linux-xfs@vger.kernel.org</span>
<span class="p_add">+L:	linux-xfs@vger.kernel.org</span>
<span class="p_add">+W:	http://xfs.org/</span>
<span class="p_add">+T:	git git://git.kernel.org/pub/scm/linux/kernel/git/dgc/linux-xfs.git</span>
 S:	Supported
 F:	Documentation/filesystems/xfs.txt
 F:	fs/xfs/
<span class="p_header">diff --git a/Makefile b/Makefile</span>
<span class="p_header">index 444ddb666ef8..c814b3e2172c 100644</span>
<span class="p_header">--- a/Makefile</span>
<span class="p_header">+++ b/Makefile</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 VERSION = 3
 PATCHLEVEL = 16
<span class="p_del">-SUBLEVEL = 39</span>
<span class="p_add">+SUBLEVEL = 40</span>
 EXTRAVERSION =
 NAME = Museum of Fishiegoodies
 
<span class="p_chunk">@@ -407,11 +407,12 @@</span> <span class="p_context"> KBUILD_CFLAGS   := -Wall -Wundef -Wstrict-prototypes -Wno-trigraphs \</span>
 		   -fno-strict-aliasing -fno-common \
 		   -Werror-implicit-function-declaration \
 		   -Wno-format-security \
<span class="p_del">-		   -std=gnu89</span>
<span class="p_add">+		   -std=gnu89 $(call cc-option,-fno-PIE)</span>
<span class="p_add">+</span>
 
 KBUILD_AFLAGS_KERNEL :=
 KBUILD_CFLAGS_KERNEL :=
<span class="p_del">-KBUILD_AFLAGS   := -D__ASSEMBLY__</span>
<span class="p_add">+KBUILD_AFLAGS   := -D__ASSEMBLY__ $(call cc-option,-fno-PIE)</span>
 KBUILD_AFLAGS_MODULE  := -DMODULE
 KBUILD_CFLAGS_MODULE  := -DMODULE
 KBUILD_LDFLAGS_MODULE := -T $(srctree)/scripts/module-common.lds
<span class="p_header">diff --git a/arch/arc/kernel/signal.c b/arch/arc/kernel/signal.c</span>
<span class="p_header">index a0c63fc48457..0943ff84f28f 100644</span>
<span class="p_header">--- a/arch/arc/kernel/signal.c</span>
<span class="p_header">+++ b/arch/arc/kernel/signal.c</span>
<span class="p_chunk">@@ -80,11 +80,12 @@</span> <span class="p_context"> static int restore_usr_regs(struct pt_regs *regs, struct rt_sigframe __user *sf)</span>
 	int err;
 
 	err = __copy_from_user(&amp;set, &amp;sf-&gt;uc.uc_sigmask, sizeof(set));
<span class="p_del">-	if (!err)</span>
<span class="p_del">-		set_current_blocked(&amp;set);</span>
<span class="p_del">-</span>
 	err |= __copy_from_user(regs, &amp;(sf-&gt;uc.uc_mcontext.regs.scratch),
 				sizeof(sf-&gt;uc.uc_mcontext.regs.scratch));
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	set_current_blocked(&amp;set);</span>
 
 	return err;
 }
<span class="p_header">diff --git a/arch/arm/boot/dts/exynos4210-pinctrl.dtsi b/arch/arm/boot/dts/exynos4210-pinctrl.dtsi</span>
<span class="p_header">index a7c212891674..160d6f213e37 100644</span>
<span class="p_header">--- a/arch/arm/boot/dts/exynos4210-pinctrl.dtsi</span>
<span class="p_header">+++ b/arch/arm/boot/dts/exynos4210-pinctrl.dtsi</span>
<span class="p_chunk">@@ -647,7 +647,7 @@</span> <span class="p_context"></span>
 		sd4_bus8: sd4-bus-width8 {
 			samsung,pins = &quot;gpk1-3&quot;, &quot;gpk1-4&quot;, &quot;gpk1-5&quot;, &quot;gpk1-6&quot;;
 			samsung,pin-function = &lt;3&gt;;
<span class="p_del">-			samsung,pin-pud = &lt;4&gt;;</span>
<span class="p_add">+			samsung,pin-pud = &lt;3&gt;;</span>
 			samsung,pin-drv = &lt;3&gt;;
 		};
 
<span class="p_header">diff --git a/arch/arm/mach-pxa/corgi_pm.c b/arch/arm/mach-pxa/corgi_pm.c</span>
<span class="p_header">index 7a39efc50865..5d01af47afc2 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/corgi_pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/corgi_pm.c</span>
<span class="p_chunk">@@ -131,16 +131,11 @@</span> <span class="p_context"> static int corgi_should_wakeup(unsigned int resume_on_alarm)</span>
 	return is_resume;
 }
 
<span class="p_del">-static unsigned long corgi_charger_wakeup(void)</span>
<span class="p_add">+static bool corgi_charger_wakeup(void)</span>
 {
<span class="p_del">-	unsigned long ret;</span>
<span class="p_del">-</span>
<span class="p_del">-	ret = (!gpio_get_value(CORGI_GPIO_AC_IN) &lt;&lt; GPIO_bit(CORGI_GPIO_AC_IN))</span>
<span class="p_del">-		| (!gpio_get_value(CORGI_GPIO_KEY_INT)</span>
<span class="p_del">-		&lt;&lt; GPIO_bit(CORGI_GPIO_KEY_INT))</span>
<span class="p_del">-		| (!gpio_get_value(CORGI_GPIO_WAKEUP)</span>
<span class="p_del">-		&lt;&lt; GPIO_bit(CORGI_GPIO_WAKEUP));</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return !gpio_get_value(CORGI_GPIO_AC_IN) ||</span>
<span class="p_add">+		!gpio_get_value(CORGI_GPIO_KEY_INT) ||</span>
<span class="p_add">+		!gpio_get_value(CORGI_GPIO_WAKEUP);</span>
 }
 
 unsigned long corgipm_read_devdata(int type)
<span class="p_header">diff --git a/arch/arm/mach-pxa/include/mach/sharpsl_pm.h b/arch/arm/mach-pxa/include/mach/sharpsl_pm.h</span>
<span class="p_header">index 905be6755f04..fa75b6df8134 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/include/mach/sharpsl_pm.h</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/include/mach/sharpsl_pm.h</span>
<span class="p_chunk">@@ -34,7 +34,7 @@</span> <span class="p_context"> struct sharpsl_charger_machinfo {</span>
 #define SHARPSL_STATUS_LOCK     5
 #define SHARPSL_STATUS_CHRGFULL 6
 #define SHARPSL_STATUS_FATAL    7
<span class="p_del">-	unsigned long (*charger_wakeup)(void);</span>
<span class="p_add">+	bool (*charger_wakeup)(void);</span>
 	int (*should_wakeup)(unsigned int resume_on_alarm);
 	void (*backlight_limit)(int);
 	int (*backlight_get_status) (void);
<span class="p_header">diff --git a/arch/arm/mach-pxa/sharpsl_pm.c b/arch/arm/mach-pxa/sharpsl_pm.c</span>
<span class="p_header">index 051a6555cbf9..b8b3379d32cb 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/sharpsl_pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/sharpsl_pm.c</span>
<span class="p_chunk">@@ -744,7 +744,7 @@</span> <span class="p_context"> static int sharpsl_off_charge_battery(void)</span>
 		time = RCNR;
 		while (1) {
 			/* Check if any wakeup event had occurred */
<span class="p_del">-			if (sharpsl_pm.machinfo-&gt;charger_wakeup() != 0)</span>
<span class="p_add">+			if (sharpsl_pm.machinfo-&gt;charger_wakeup())</span>
 				return 0;
 			/* Check for timeout */
 			if ((RCNR - time) &gt; SHARPSL_WAIT_CO_TIME)
<span class="p_header">diff --git a/arch/arm/mach-pxa/spitz_pm.c b/arch/arm/mach-pxa/spitz_pm.c</span>
<span class="p_header">index e191f9996b26..825539b6353b 100644</span>
<span class="p_header">--- a/arch/arm/mach-pxa/spitz_pm.c</span>
<span class="p_header">+++ b/arch/arm/mach-pxa/spitz_pm.c</span>
<span class="p_chunk">@@ -165,13 +165,10 @@</span> <span class="p_context"> static int spitz_should_wakeup(unsigned int resume_on_alarm)</span>
 	return is_resume;
 }
 
<span class="p_del">-static unsigned long spitz_charger_wakeup(void)</span>
<span class="p_add">+static bool spitz_charger_wakeup(void)</span>
 {
<span class="p_del">-	unsigned long ret;</span>
<span class="p_del">-	ret = ((!gpio_get_value(SPITZ_GPIO_KEY_INT)</span>
<span class="p_del">-		&lt;&lt; GPIO_bit(SPITZ_GPIO_KEY_INT))</span>
<span class="p_del">-		| gpio_get_value(SPITZ_GPIO_SYNC));</span>
<span class="p_del">-	return ret;</span>
<span class="p_add">+	return !gpio_get_value(SPITZ_GPIO_KEY_INT) ||</span>
<span class="p_add">+		gpio_get_value(SPITZ_GPIO_SYNC);</span>
 }
 
 unsigned long spitzpm_read_devdata(int type)
<span class="p_header">diff --git a/arch/arm64/include/asm/kvm_emulate.h b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">index eeab71a884cb..2d99a58f7bf8 100644</span>
<span class="p_header">--- a/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_header">+++ b/arch/arm64/include/asm/kvm_emulate.h</span>
<span class="p_chunk">@@ -135,11 +135,6 @@</span> <span class="p_context"> static inline bool kvm_vcpu_dabt_isvalid(const struct kvm_vcpu *vcpu)</span>
 	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_EL2_ISV);
 }
 
<span class="p_del">-static inline bool kvm_vcpu_dabt_iswrite(const struct kvm_vcpu *vcpu)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_EL2_WNR);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static inline bool kvm_vcpu_dabt_issext(const struct kvm_vcpu *vcpu)
 {
 	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_EL2_SSE);
<span class="p_chunk">@@ -160,6 +155,12 @@</span> <span class="p_context"> static inline bool kvm_vcpu_dabt_iss1tw(const struct kvm_vcpu *vcpu)</span>
 	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_EL2_S1PTW);
 }
 
<span class="p_add">+static inline bool kvm_vcpu_dabt_iswrite(const struct kvm_vcpu *vcpu)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return !!(kvm_vcpu_get_hsr(vcpu) &amp; ESR_EL2_WNR) ||</span>
<span class="p_add">+		kvm_vcpu_dabt_iss1tw(vcpu); /* AF/DBM update */</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline int kvm_vcpu_dabt_get_as(const struct kvm_vcpu *vcpu)
 {
 	return 1 &lt;&lt; ((kvm_vcpu_get_hsr(vcpu) &amp; ESR_EL2_SAS) &gt;&gt; ESR_EL2_SAS_SHIFT);
<span class="p_header">diff --git a/arch/arm64/kernel/debug-monitors.c b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">index a2db6f219bbe..108dbbed5322 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_header">+++ b/arch/arm64/kernel/debug-monitors.c</span>
<span class="p_chunk">@@ -427,8 +427,10 @@</span> <span class="p_context"> int kernel_active_single_step(void)</span>
 /* ptrace API */
 void user_enable_single_step(struct task_struct *task)
 {
<span class="p_del">-	set_ti_thread_flag(task_thread_info(task), TIF_SINGLESTEP);</span>
<span class="p_del">-	set_regs_spsr_ss(task_pt_regs(task));</span>
<span class="p_add">+	struct thread_info *ti = task_thread_info(task);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!test_and_set_ti_thread_flag(ti, TIF_SINGLESTEP))</span>
<span class="p_add">+		set_regs_spsr_ss(task_pt_regs(task));</span>
 }
 
 void user_disable_single_step(struct task_struct *task)
<span class="p_header">diff --git a/arch/arm64/kernel/head.S b/arch/arm64/kernel/head.S</span>
<span class="p_header">index e6739fe1effc..cb83c1aabae8 100644</span>
<span class="p_header">--- a/arch/arm64/kernel/head.S</span>
<span class="p_header">+++ b/arch/arm64/kernel/head.S</span>
<span class="p_chunk">@@ -322,8 +322,9 @@</span> <span class="p_context"> CPU_LE(	movk	x0, #0x30d0, lsl #16	)	// Clear EE and E0E on LE systems</span>
 	b.lt	4f				// Skip if no PMU present
 	mrs	x0, pmcr_el0			// Disable debug access traps
 	ubfx	x0, x0, #11, #5			// to EL2 and allow access to
<span class="p_del">-	msr	mdcr_el2, x0			// all PMU counters from EL1</span>
 4:
<span class="p_add">+	csel	x0, xzr, x0, lt			// all PMU counters from EL1</span>
<span class="p_add">+	msr	mdcr_el2, x0			// (if they exist)</span>
 
 	/* Stage-2 translation */
 	msr	vttbr_el2, xzr
<span class="p_header">diff --git a/arch/m68k/include/asm/delay.h b/arch/m68k/include/asm/delay.h</span>
<span class="p_header">index d28fa8fe26fe..c598d847d56b 100644</span>
<span class="p_header">--- a/arch/m68k/include/asm/delay.h</span>
<span class="p_header">+++ b/arch/m68k/include/asm/delay.h</span>
<span class="p_chunk">@@ -114,6 +114,6 @@</span> <span class="p_context"> static inline void __udelay(unsigned long usecs)</span>
  */
 #define	HZSCALE		(268435456 / (1000000 / HZ))
 
<span class="p_del">-#define ndelay(n) __delay(DIV_ROUND_UP((n) * ((((HZSCALE) &gt;&gt; 11) * (loops_per_jiffy &gt;&gt; 11)) &gt;&gt; 6), 1000));</span>
<span class="p_add">+#define ndelay(n) __delay(DIV_ROUND_UP((n) * ((((HZSCALE) &gt;&gt; 11) * (loops_per_jiffy &gt;&gt; 11)) &gt;&gt; 6), 1000))</span>
 
 #endif /* defined(_M68K_DELAY_H) */
<span class="p_header">diff --git a/arch/metag/include/asm/atomic.h b/arch/metag/include/asm/atomic.h</span>
<span class="p_header">index 470e365f04ea..8ff0a70865f6 100644</span>
<span class="p_header">--- a/arch/metag/include/asm/atomic.h</span>
<span class="p_header">+++ b/arch/metag/include/asm/atomic.h</span>
<span class="p_chunk">@@ -39,11 +39,10 @@</span> <span class="p_context"></span>
 #define atomic_dec(v) atomic_sub(1, (v))
 
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
<span class="p_add">+#define atomic_dec_if_positive(v)       atomic_sub_if_positive(1, v)</span>
 
 #endif
 
<span class="p_del">-#define atomic_dec_if_positive(v)       atomic_sub_if_positive(1, v)</span>
<span class="p_del">-</span>
 #include &lt;asm-generic/atomic64.h&gt;
 
 #endif /* __ASM_METAG_ATOMIC_H */
<span class="p_header">diff --git a/arch/mips/cavium-octeon/setup.c b/arch/mips/cavium-octeon/setup.c</span>
<span class="p_header">index c9d9c627e244..0391557ce452 100644</span>
<span class="p_header">--- a/arch/mips/cavium-octeon/setup.c</span>
<span class="p_header">+++ b/arch/mips/cavium-octeon/setup.c</span>
<span class="p_chunk">@@ -247,6 +247,17 @@</span> <span class="p_context"> static void octeon_crash_shutdown(struct pt_regs *regs)</span>
 	default_machine_crash_shutdown(regs);
 }
 
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+void octeon_crash_smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int cpu;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* disable watchdogs */</span>
<span class="p_add">+	for_each_online_cpu(cpu)</span>
<span class="p_add">+		cvmx_write_csr(CVMX_CIU_WDOGX(cpu_logical_map(cpu)), 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+#endif</span>
<span class="p_add">+</span>
 #endif /* CONFIG_KEXEC */
 
 #ifdef CONFIG_CAVIUM_RESERVE32
<span class="p_chunk">@@ -827,6 +838,9 @@</span> <span class="p_context"> void __init prom_init(void)</span>
 	_machine_kexec_shutdown = octeon_shutdown;
 	_machine_crash_shutdown = octeon_crash_shutdown;
 	_machine_kexec_prepare = octeon_kexec_prepare;
<span class="p_add">+#ifdef CONFIG_SMP</span>
<span class="p_add">+	_crash_smp_send_stop = octeon_crash_smp_send_stop;</span>
<span class="p_add">+#endif</span>
 #endif
 
 	octeon_user_io_init();
<span class="p_header">diff --git a/arch/mips/include/asm/kexec.h b/arch/mips/include/asm/kexec.h</span>
<span class="p_header">index ee25ebbf2a28..493a3cc7c39a 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kexec.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kexec.h</span>
<span class="p_chunk">@@ -45,6 +45,7 @@</span> <span class="p_context"> extern const unsigned char kexec_smp_wait[];</span>
 extern unsigned long secondary_kexec_args[4];
 extern void (*relocated_kexec_smp_wait) (void *);
 extern atomic_t kexec_ready_to_reboot;
<span class="p_add">+extern void (*_crash_smp_send_stop)(void);</span>
 #endif
 #endif
 
<span class="p_header">diff --git a/arch/mips/include/asm/kvm_host.h b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">index 5bddbc63fc3b..f8cdc274173a 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -403,7 +403,10 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	/* Host KSEG0 address of the EI/DI offset */
 	void *kseg0_commpage;
 
<span class="p_del">-	u32 io_gpr;		/* GPR used as IO source/target */</span>
<span class="p_add">+	/* Resume PC after MMIO completion */</span>
<span class="p_add">+	unsigned long io_pc;</span>
<span class="p_add">+	/* GPR used as IO source/target */</span>
<span class="p_add">+	u32 io_gpr;</span>
 
 	struct hrtimer comparecount_timer;
 	/* Count timer control KVM register */
<span class="p_chunk">@@ -425,8 +428,6 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	/* Bitmask of pending exceptions to be cleared */
 	unsigned long pending_exceptions_clr;
 
<span class="p_del">-	unsigned long pending_load_cause;</span>
<span class="p_del">-</span>
 	/* Save/Restore the entryhi register when are are preempted/scheduled back in */
 	unsigned long preempt_entryhi;
 
<span class="p_header">diff --git a/arch/mips/include/asm/ptrace.h b/arch/mips/include/asm/ptrace.h</span>
<span class="p_header">index c301fa9b139f..36ec626b429a 100644</span>
<span class="p_header">--- a/arch/mips/include/asm/ptrace.h</span>
<span class="p_header">+++ b/arch/mips/include/asm/ptrace.h</span>
<span class="p_chunk">@@ -70,7 +70,7 @@</span> <span class="p_context"> static inline int is_syscall_success(struct pt_regs *regs)</span>
 
 static inline long regs_return_value(struct pt_regs *regs)
 {
<span class="p_del">-	if (is_syscall_success(regs))</span>
<span class="p_add">+	if (is_syscall_success(regs) || !user_mode(regs))</span>
 		return regs-&gt;regs[2];
 	else
 		return -regs-&gt;regs[2];
<span class="p_header">diff --git a/arch/mips/kernel/crash.c b/arch/mips/kernel/crash.c</span>
<span class="p_header">index d21264681e97..5b5275f8cc1f 100644</span>
<span class="p_header">--- a/arch/mips/kernel/crash.c</span>
<span class="p_header">+++ b/arch/mips/kernel/crash.c</span>
<span class="p_chunk">@@ -37,9 +37,14 @@</span> <span class="p_context"> static void crash_shutdown_secondary(void *ignore)</span>
 
 static void crash_kexec_prepare_cpus(void)
 {
<span class="p_add">+	static int cpus_stopped;</span>
 	unsigned int msecs;
<span class="p_add">+	unsigned int ncpus;</span>
 
<span class="p_del">-	unsigned int ncpus = num_online_cpus() - 1;/* Excluding the panic cpu */</span>
<span class="p_add">+	if (cpus_stopped)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	ncpus = num_online_cpus() - 1;/* Excluding the panic cpu */</span>
 
 	dump_send_ipi(crash_shutdown_secondary);
 	smp_wmb();
<span class="p_chunk">@@ -54,6 +59,17 @@</span> <span class="p_context"> static void crash_kexec_prepare_cpus(void)</span>
 		cpu_relax();
 		mdelay(1);
 	}
<span class="p_add">+</span>
<span class="p_add">+	cpus_stopped = 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/* Override the weak function in kernel/panic.c */</span>
<span class="p_add">+void crash_smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (_crash_smp_send_stop)</span>
<span class="p_add">+		_crash_smp_send_stop();</span>
<span class="p_add">+</span>
<span class="p_add">+	crash_kexec_prepare_cpus();</span>
 }
 
 #else /* !defined(CONFIG_SMP)  */
<span class="p_header">diff --git a/arch/mips/kernel/machine_kexec.c b/arch/mips/kernel/machine_kexec.c</span>
<span class="p_header">index 992e18474da5..4f9f22809e77 100644</span>
<span class="p_header">--- a/arch/mips/kernel/machine_kexec.c</span>
<span class="p_header">+++ b/arch/mips/kernel/machine_kexec.c</span>
<span class="p_chunk">@@ -25,6 +25,7 @@</span> <span class="p_context"> void (*_machine_crash_shutdown)(struct pt_regs *regs) = NULL;</span>
 #ifdef CONFIG_SMP
 void (*relocated_kexec_smp_wait) (void *);
 atomic_t kexec_ready_to_reboot = ATOMIC_INIT(0);
<span class="p_add">+void (*_crash_smp_send_stop)(void) = NULL;</span>
 #endif
 
 int
<span class="p_header">diff --git a/arch/mips/kvm/kvm_mips_emul.c b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">index bac2bba41f38..3a0ccdc0dfac 100644</span>
<span class="p_header">--- a/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_header">+++ b/arch/mips/kvm/kvm_mips_emul.c</span>
<span class="p_chunk">@@ -761,15 +761,15 @@</span> <span class="p_context"> enum emulation_result kvm_mips_emul_eret(struct kvm_vcpu *vcpu)</span>
 	struct mips_coproc *cop0 = vcpu-&gt;arch.cop0;
 	enum emulation_result er = EMULATE_DONE;
 
<span class="p_del">-	if (kvm_read_c0_guest_status(cop0) &amp; ST0_EXL) {</span>
<span class="p_add">+	if (kvm_read_c0_guest_status(cop0) &amp; ST0_ERL) {</span>
<span class="p_add">+		kvm_clear_c0_guest_status(cop0, ST0_ERL);</span>
<span class="p_add">+		vcpu-&gt;arch.pc = kvm_read_c0_guest_errorepc(cop0);</span>
<span class="p_add">+	} else if (kvm_read_c0_guest_status(cop0) &amp; ST0_EXL) {</span>
 		kvm_debug(&quot;[%#lx] ERET to %#lx\n&quot;, vcpu-&gt;arch.pc,
 			  kvm_read_c0_guest_epc(cop0));
 		kvm_clear_c0_guest_status(cop0, ST0_EXL);
 		vcpu-&gt;arch.pc = kvm_read_c0_guest_epc(cop0);
 
<span class="p_del">-	} else if (kvm_read_c0_guest_status(cop0) &amp; ST0_ERL) {</span>
<span class="p_del">-		kvm_clear_c0_guest_status(cop0, ST0_ERL);</span>
<span class="p_del">-		vcpu-&gt;arch.pc = kvm_read_c0_guest_errorepc(cop0);</span>
 	} else {
 		printk(&quot;[%#lx] ERET when MIPS_SR_EXL|MIPS_SR_ERL == 0\n&quot;,
 		       vcpu-&gt;arch.pc);
<span class="p_chunk">@@ -1328,6 +1328,7 @@</span> <span class="p_context"> kvm_mips_emulate_load(uint32_t inst, uint32_t cause,</span>
 		      struct kvm_run *run, struct kvm_vcpu *vcpu)
 {
 	enum emulation_result er = EMULATE_DO_MMIO;
<span class="p_add">+	unsigned long curr_pc;</span>
 	int32_t op, base, rt, offset;
 	uint32_t bytes;
 
<span class="p_chunk">@@ -1336,7 +1337,18 @@</span> <span class="p_context"> kvm_mips_emulate_load(uint32_t inst, uint32_t cause,</span>
 	offset = inst &amp; 0xffff;
 	op = (inst &gt;&gt; 26) &amp; 0x3f;
 
<span class="p_del">-	vcpu-&gt;arch.pending_load_cause = cause;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Find the resume PC now while we have safe and easy access to the</span>
<span class="p_add">+	 * prior branch instruction, and save it for</span>
<span class="p_add">+	 * kvm_mips_complete_mmio_load() to restore later.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	curr_pc = vcpu-&gt;arch.pc;</span>
<span class="p_add">+	er = update_pc(vcpu, cause);</span>
<span class="p_add">+	if (er == EMULATE_FAIL)</span>
<span class="p_add">+		return er;</span>
<span class="p_add">+	vcpu-&gt;arch.io_pc = vcpu-&gt;arch.pc;</span>
<span class="p_add">+	vcpu-&gt;arch.pc = curr_pc;</span>
<span class="p_add">+</span>
 	vcpu-&gt;arch.io_gpr = rt;
 
 	switch (op) {
<span class="p_chunk">@@ -2172,7 +2184,6 @@</span> <span class="p_context"> kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 {
 	unsigned long *gpr = &amp;vcpu-&gt;arch.gprs[vcpu-&gt;arch.io_gpr];
 	enum emulation_result er = EMULATE_DONE;
<span class="p_del">-	unsigned long curr_pc;</span>
 
 	if (run-&gt;mmio.len &gt; sizeof(*gpr)) {
 		printk(&quot;Bad MMIO length: %d&quot;, run-&gt;mmio.len);
<span class="p_chunk">@@ -2180,14 +2191,8 @@</span> <span class="p_context"> kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 		goto done;
 	}
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Update PC and hold onto current PC in case there is</span>
<span class="p_del">-	 * an error and we want to rollback the PC</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	curr_pc = vcpu-&gt;arch.pc;</span>
<span class="p_del">-	er = update_pc(vcpu, vcpu-&gt;arch.pending_load_cause);</span>
<span class="p_del">-	if (er == EMULATE_FAIL)</span>
<span class="p_del">-		return er;</span>
<span class="p_add">+	/* Restore saved resume PC */</span>
<span class="p_add">+	vcpu-&gt;arch.pc = vcpu-&gt;arch.io_pc;</span>
 
 	switch (run-&gt;mmio.len) {
 	case 4:
<span class="p_chunk">@@ -2209,12 +2214,6 @@</span> <span class="p_context"> kvm_mips_complete_mmio_load(struct kvm_vcpu *vcpu, struct kvm_run *run)</span>
 		break;
 	}
 
<span class="p_del">-	if (vcpu-&gt;arch.pending_load_cause &amp; CAUSEF_BD)</span>
<span class="p_del">-		kvm_debug</span>
<span class="p_del">-		    (&quot;[%#lx] Completing %d byte BD Load to gpr %d (0x%08lx) type %d\n&quot;,</span>
<span class="p_del">-		     vcpu-&gt;arch.pc, run-&gt;mmio.len, vcpu-&gt;arch.io_gpr, *gpr,</span>
<span class="p_del">-		     vcpu-&gt;mmio_needed);</span>
<span class="p_del">-</span>
 done:
 	return er;
 }
<span class="p_header">diff --git a/arch/parisc/include/asm/pgtable.h b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">index 22b89d1edba7..b6762dfbe4fe 100644</span>
<span class="p_header">--- a/arch/parisc/include/asm/pgtable.h</span>
<span class="p_header">+++ b/arch/parisc/include/asm/pgtable.h</span>
<span class="p_chunk">@@ -48,8 +48,8 @@</span> <span class="p_context"> extern void purge_tlb_entries(struct mm_struct *, unsigned long);</span>
 	do {                                                    \
 		unsigned long flags;				\
 		spin_lock_irqsave(&amp;pa_dbit_lock, flags);	\
<span class="p_del">-		set_pte(ptep, pteval);                          \</span>
 		purge_tlb_entries(mm, addr);                    \
<span class="p_add">+		set_pte(ptep, pteval);                          \</span>
 		spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);	\
 	} while (0)
 
<span class="p_chunk">@@ -452,8 +452,8 @@</span> <span class="p_context"> static inline int ptep_test_and_clear_young(struct vm_area_struct *vma, unsigned</span>
 		spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);
 		return 0;
 	}
<span class="p_del">-	set_pte(ptep, pte_mkold(pte));</span>
 	purge_tlb_entries(vma-&gt;vm_mm, addr);
<span class="p_add">+	set_pte(ptep, pte_mkold(pte));</span>
 	spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);
 	return 1;
 }
<span class="p_chunk">@@ -466,8 +466,8 @@</span> <span class="p_context"> static inline pte_t ptep_get_and_clear(struct mm_struct *mm, unsigned long addr,</span>
 
 	spin_lock_irqsave(&amp;pa_dbit_lock, flags);
 	old_pte = *ptep;
<span class="p_del">-	pte_clear(mm,addr,ptep);</span>
 	purge_tlb_entries(mm, addr);
<span class="p_add">+	pte_clear(mm,addr,ptep);</span>
 	spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);
 
 	return old_pte;
<span class="p_chunk">@@ -477,8 +477,8 @@</span> <span class="p_context"> static inline void ptep_set_wrprotect(struct mm_struct *mm, unsigned long addr,</span>
 {
 	unsigned long flags;
 	spin_lock_irqsave(&amp;pa_dbit_lock, flags);
<span class="p_del">-	set_pte(ptep, pte_wrprotect(*ptep));</span>
 	purge_tlb_entries(mm, addr);
<span class="p_add">+	set_pte(ptep, pte_wrprotect(*ptep));</span>
 	spin_unlock_irqrestore(&amp;pa_dbit_lock, flags);
 }
 
<span class="p_header">diff --git a/arch/parisc/kernel/pacache.S b/arch/parisc/kernel/pacache.S</span>
<span class="p_header">index b743a80eaba0..a4761b772406 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pacache.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/pacache.S</span>
<span class="p_chunk">@@ -96,7 +96,7 @@</span> <span class="p_context"> fitmanyloop:					/* Loop if LOOP &gt;= 2 */</span>
 
 fitmanymiddle:					/* Loop if LOOP &gt;= 2 */
 	addib,COND(&gt;)		-1, %r31, fitmanymiddle	/* Adjusted inner loop decr */
<span class="p_del">-	pitlbe		0(%sr1, %r28)</span>
<span class="p_add">+	pitlbe		%r0(%sr1, %r28)</span>
 	pitlbe,m	%arg1(%sr1, %r28)	/* Last pitlbe and addr adjust */
 	addib,COND(&gt;)		-1, %r29, fitmanymiddle	/* Middle loop decr */
 	copy		%arg3, %r31		/* Re-init inner loop count */
<span class="p_chunk">@@ -139,7 +139,7 @@</span> <span class="p_context"> fdtmanyloop:					/* Loop if LOOP &gt;= 2 */</span>
 
 fdtmanymiddle:					/* Loop if LOOP &gt;= 2 */
 	addib,COND(&gt;)		-1, %r31, fdtmanymiddle	/* Adjusted inner loop decr */
<span class="p_del">-	pdtlbe		0(%sr1, %r28)</span>
<span class="p_add">+	pdtlbe		%r0(%sr1, %r28)</span>
 	pdtlbe,m	%arg1(%sr1, %r28)	/* Last pdtlbe and addr adjust */
 	addib,COND(&gt;)		-1, %r29, fdtmanymiddle	/* Middle loop decr */
 	copy		%arg3, %r31		/* Re-init inner loop count */
<span class="p_chunk">@@ -620,12 +620,12 @@</span> <span class="p_context"> ENTRY(copy_user_page_asm)</span>
 	/* Purge any old translations */
 
 #ifdef CONFIG_PA20
<span class="p_del">-	pdtlb,l		0(%r28)</span>
<span class="p_del">-	pdtlb,l		0(%r29)</span>
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
<span class="p_add">+	pdtlb,l		%r0(%r29)</span>
 #else
 	tlb_lock	%r20,%r21,%r22
<span class="p_del">-	pdtlb		0(%r28)</span>
<span class="p_del">-	pdtlb		0(%r29)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r29)</span>
 	tlb_unlock	%r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -768,10 +768,10 @@</span> <span class="p_context"> ENTRY(clear_user_page_asm)</span>
 	/* Purge any old translation */
 
 #ifdef CONFIG_PA20
<span class="p_del">-	pdtlb,l		0(%r28)</span>
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
 #else
 	tlb_lock	%r20,%r21,%r22
<span class="p_del">-	pdtlb		0(%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
 	tlb_unlock	%r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -852,10 +852,10 @@</span> <span class="p_context"> ENTRY(flush_dcache_page_asm)</span>
 	/* Purge any old translation */
 
 #ifdef CONFIG_PA20
<span class="p_del">-	pdtlb,l		0(%r28)</span>
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
 #else
 	tlb_lock	%r20,%r21,%r22
<span class="p_del">-	pdtlb		0(%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
 	tlb_unlock	%r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -886,19 +886,10 @@</span> <span class="p_context"> ENTRY(flush_dcache_page_asm)</span>
 	fdc,m		r31(%r28)
 	fdc,m		r31(%r28)
 	fdc,m		r31(%r28)
<span class="p_del">-	cmpb,COND(&lt;&lt;)		%r28, %r25,1b</span>
<span class="p_add">+	cmpb,COND(&lt;&lt;)	%r28, %r25,1b</span>
 	fdc,m		r31(%r28)
 
 	sync
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PA20</span>
<span class="p_del">-	pdtlb,l		0(%r25)</span>
<span class="p_del">-#else</span>
<span class="p_del">-	tlb_lock	%r20,%r21,%r22</span>
<span class="p_del">-	pdtlb		0(%r25)</span>
<span class="p_del">-	tlb_unlock	%r20,%r21,%r22</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	bv		%r0(%r2)
 	nop
 	.exit
<span class="p_chunk">@@ -925,13 +916,18 @@</span> <span class="p_context"> ENTRY(flush_icache_page_asm)</span>
 	depwi		0, 31,PAGE_SHIFT, %r28	/* Clear any offset bits */
 #endif
 
<span class="p_del">-	/* Purge any old translation */</span>
<span class="p_add">+	/* Purge any old translation.  Note that the FIC instruction</span>
<span class="p_add">+	 * may use either the instruction or data TLB.  Given that we</span>
<span class="p_add">+	 * have a flat address space, it&#39;s not clear which TLB will be</span>
<span class="p_add">+	 * used.  So, we purge both entries.  */</span>
 
 #ifdef CONFIG_PA20
<span class="p_add">+	pdtlb,l		%r0(%r28)</span>
 	pitlb,l         %r0(%sr4,%r28)
 #else
 	tlb_lock        %r20,%r21,%r22
<span class="p_del">-	pitlb           (%sr4,%r28)</span>
<span class="p_add">+	pdtlb		%r0(%r28)</span>
<span class="p_add">+	pitlb           %r0(%sr4,%r28)</span>
 	tlb_unlock      %r20,%r21,%r22
 #endif
 
<span class="p_chunk">@@ -968,15 +964,6 @@</span> <span class="p_context"> ENTRY(flush_icache_page_asm)</span>
 	fic,m		%r31(%sr4,%r28)
 
 	sync
<span class="p_del">-</span>
<span class="p_del">-#ifdef CONFIG_PA20</span>
<span class="p_del">-	pitlb,l         %r0(%sr4,%r25)</span>
<span class="p_del">-#else</span>
<span class="p_del">-	tlb_lock        %r20,%r21,%r22</span>
<span class="p_del">-	pitlb           (%sr4,%r25)</span>
<span class="p_del">-	tlb_unlock      %r20,%r21,%r22</span>
<span class="p_del">-#endif</span>
<span class="p_del">-</span>
 	bv		%r0(%r2)
 	nop
 	.exit
<span class="p_header">diff --git a/arch/parisc/kernel/pci-dma.c b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">index d87d1c476d85..13d7b1838609 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/pci-dma.c</span>
<span class="p_header">+++ b/arch/parisc/kernel/pci-dma.c</span>
<span class="p_chunk">@@ -95,8 +95,8 @@</span> <span class="p_context"> static inline int map_pte_uncached(pte_t * pte,</span>
 
 		if (!pte_none(*pte))
 			printk(KERN_ERR &quot;map_pte_uncached: page already exists\n&quot;);
<span class="p_del">-		set_pte(pte, __mk_pte(*paddr_ptr, PAGE_KERNEL_UNC));</span>
 		purge_tlb_start(flags);
<span class="p_add">+		set_pte(pte, __mk_pte(*paddr_ptr, PAGE_KERNEL_UNC));</span>
 		pdtlb_kernel(orig_vaddr);
 		purge_tlb_end(flags);
 		vaddr += PAGE_SIZE;
<span class="p_header">diff --git a/arch/parisc/kernel/syscall.S b/arch/parisc/kernel/syscall.S</span>
<span class="p_header">index 7105610ac3fd..f716e9e65a49 100644</span>
<span class="p_header">--- a/arch/parisc/kernel/syscall.S</span>
<span class="p_header">+++ b/arch/parisc/kernel/syscall.S</span>
<span class="p_chunk">@@ -106,8 +106,6 @@</span> <span class="p_context"> linux_gateway_entry:</span>
 	mtsp	%r0,%sr4			/* get kernel space into sr4 */
 	mtsp	%r0,%sr5			/* get kernel space into sr5 */
 	mtsp	%r0,%sr6			/* get kernel space into sr6 */
<span class="p_del">-	mfsp    %sr7,%r1                        /* save user sr7 */</span>
<span class="p_del">-	mtsp    %r1,%sr3                        /* and store it in sr3 */</span>
 
 #ifdef CONFIG_64BIT
 	/* for now we can *always* set the W bit on entry to the syscall
<span class="p_chunk">@@ -133,6 +131,14 @@</span> <span class="p_context"> linux_gateway_entry:</span>
 	depdi	0, 31, 32, %r21
 1:	
 #endif
<span class="p_add">+</span>
<span class="p_add">+	/* We use a rsm/ssm pair to prevent sr3 from being clobbered</span>
<span class="p_add">+	 * by external interrupts.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mfsp    %sr7,%r1                        /* save user sr7 */</span>
<span class="p_add">+	rsm	PSW_SM_I, %r0			/* disable interrupts */</span>
<span class="p_add">+	mtsp    %r1,%sr3                        /* and store it in sr3 */</span>
<span class="p_add">+</span>
 	mfctl   %cr30,%r1
 	xor     %r1,%r30,%r30                   /* ye olde xor trick */
 	xor     %r1,%r30,%r1
<span class="p_chunk">@@ -147,6 +153,7 @@</span> <span class="p_context"> linux_gateway_entry:</span>
 	 */
 
 	mtsp	%r0,%sr7			/* get kernel space into sr7 */
<span class="p_add">+	ssm	PSW_SM_I, %r0			/* enable interrupts */</span>
 	STREGM	%r1,FRAME_SIZE(%r30)		/* save r1 (usp) here for now */
 	mfctl	%cr30,%r1			/* get task ptr in %r1 */
 	LDREG	TI_TASK(%r1),%r1
<span class="p_header">diff --git a/arch/powerpc/include/asm/kvm_book3s.h b/arch/powerpc/include/asm/kvm_book3s.h</span>
<span class="p_header">index f52f65694527..0689091f9505 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/kvm_book3s.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/kvm_book3s.h</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> struct kvmppc_vcpu_book3s {</span>
 	u64 sdr1;
 	u64 hior;
 	u64 msr_mask;
<span class="p_add">+	u64 vtb;</span>
 	u64 purr_offset;
 	u64 spurr_offset;
 #ifdef CONFIG_PPC_BOOK3S_32
<span class="p_header">diff --git a/arch/powerpc/include/asm/kvm_host.h b/arch/powerpc/include/asm/kvm_host.h</span>
<span class="p_header">index bb66d8b8efdf..2149dbcf8931 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/kvm_host.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/kvm_host.h</span>
<span class="p_chunk">@@ -305,6 +305,7 @@</span> <span class="p_context"> struct kvmppc_vcore {</span>
 	u32 arch_compat;
 	ulong pcr;
 	ulong dpdes;		/* doorbell state (POWER8) */
<span class="p_add">+	ulong vtb;		/* virtual timebase */</span>
 };
 
 #define VCORE_ENTRY_COUNT(vc)	((vc)-&gt;entry_exit_count &amp; 0xff)
<span class="p_chunk">@@ -462,7 +463,6 @@</span> <span class="p_context"> struct kvm_vcpu_arch {</span>
 	ulong purr;
 	ulong spurr;
 	ulong ic;
<span class="p_del">-	ulong vtb;</span>
 	ulong dscr;
 	ulong amr;
 	ulong uamor;
<span class="p_header">diff --git a/arch/powerpc/include/asm/reg.h b/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">index 5df8e5cde4a6..e0b1b8482735 100644</span>
<span class="p_header">--- a/arch/powerpc/include/asm/reg.h</span>
<span class="p_header">+++ b/arch/powerpc/include/asm/reg.h</span>
<span class="p_chunk">@@ -705,6 +705,7 @@</span> <span class="p_context"></span>
 #define   MMCR0_FCHV	0x00000001UL /* freeze conditions in hypervisor mode */
 #define SPRN_MMCR1	798
 #define SPRN_MMCR2	785
<span class="p_add">+#define SPRN_UMMCR2	769</span>
 #define SPRN_MMCRA	0x312
 #define   MMCRA_SDSYNC	0x80000000UL /* SDAR synced with SIAR */
 #define   MMCRA_SDAR_DCACHE_MISS 0x40000000UL
<span class="p_header">diff --git a/arch/powerpc/kernel/asm-offsets.c b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_header">index f5995a912213..88abea889876 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/asm-offsets.c</span>
<span class="p_chunk">@@ -506,7 +506,6 @@</span> <span class="p_context"> int main(void)</span>
 	DEFINE(VCPU_PURR, offsetof(struct kvm_vcpu, arch.purr));
 	DEFINE(VCPU_SPURR, offsetof(struct kvm_vcpu, arch.spurr));
 	DEFINE(VCPU_IC, offsetof(struct kvm_vcpu, arch.ic));
<span class="p_del">-	DEFINE(VCPU_VTB, offsetof(struct kvm_vcpu, arch.vtb));</span>
 	DEFINE(VCPU_DSCR, offsetof(struct kvm_vcpu, arch.dscr));
 	DEFINE(VCPU_AMR, offsetof(struct kvm_vcpu, arch.amr));
 	DEFINE(VCPU_UAMOR, offsetof(struct kvm_vcpu, arch.uamor));
<span class="p_chunk">@@ -560,6 +559,7 @@</span> <span class="p_context"> int main(void)</span>
 	DEFINE(VCORE_LPCR, offsetof(struct kvmppc_vcore, lpcr));
 	DEFINE(VCORE_PCR, offsetof(struct kvmppc_vcore, pcr));
 	DEFINE(VCORE_DPDES, offsetof(struct kvmppc_vcore, dpdes));
<span class="p_add">+	DEFINE(VCORE_VTB, offsetof(struct kvmppc_vcore, vtb));</span>
 	DEFINE(VCPU_SLB_E, offsetof(struct kvmppc_slb, orige));
 	DEFINE(VCPU_SLB_V, offsetof(struct kvmppc_slb, origv));
 	DEFINE(VCPU_SLB_SIZE, sizeof(struct kvmppc_slb));
<span class="p_header">diff --git a/arch/powerpc/kernel/eeh_driver.c b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">index 420da61d4ce0..e25ee5de2f6f 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/eeh_driver.c</span>
<span class="p_chunk">@@ -541,8 +541,10 @@</span> <span class="p_context"> static int eeh_reset_device(struct eeh_pe *pe, struct pci_bus *bus)</span>
 
 	/* Clear frozen state */
 	rc = eeh_clear_pe_frozen_state(pe);
<span class="p_del">-	if (rc)</span>
<span class="p_add">+	if (rc) {</span>
<span class="p_add">+		pci_unlock_rescan_remove();</span>
 		return rc;
<span class="p_add">+	}</span>
 
 	/* Give the system 5 seconds to finish running the user-space
 	 * hotplug shutdown scripts, e.g. ifdown for ethernet.  Yes,
<span class="p_chunk">@@ -828,6 +830,14 @@</span> <span class="p_context"> static void eeh_handle_special_event(void)</span>
 
 				/* Notify all devices to be down */
 				bus = eeh_pe_bus_get(phb_pe);
<span class="p_add">+				if (!bus) {</span>
<span class="p_add">+					pr_err(&quot;%s: Cannot find PCI bus for &quot;</span>
<span class="p_add">+					       &quot;PHB#%d-PE#%x\n&quot;,</span>
<span class="p_add">+					       __func__,</span>
<span class="p_add">+					       pe-&gt;phb-&gt;global_number,</span>
<span class="p_add">+					       pe-&gt;addr);</span>
<span class="p_add">+					break;</span>
<span class="p_add">+				}</span>
 				eeh_pe_dev_traverse(pe,
 					eeh_report_failure, NULL);
 				pcibios_remove_pci_devices(bus);
<span class="p_header">diff --git a/arch/powerpc/kernel/idle_power7.S b/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_header">index a29f5b0f9d3e..099e405680c4 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/idle_power7.S</span>
<span class="p_chunk">@@ -28,7 +28,7 @@</span> <span class="p_context"></span>
 	std	r0,0(r1);					\
 	ptesync;						\
 	ld	r0,0(r1);					\
<span class="p_del">-1:	cmp	cr0,r0,r0;					\</span>
<span class="p_add">+1:	cmpd	cr0,r0,r0;					\</span>
 	bne	1b;						\
 	IDLE_INST;						\
 	b	.
<span class="p_header">diff --git a/arch/powerpc/kernel/nvram_64.c b/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_header">index 28b898e68185..b55d6e83fbb4 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_header">+++ b/arch/powerpc/kernel/nvram_64.c</span>
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> int __init nvram_remove_partition(const char *name, int sig,</span>
 
 		/* Make partition a free partition */
 		part-&gt;header.signature = NVRAM_SIG_FREE;
<span class="p_del">-		strncpy(part-&gt;header.name, &quot;wwwwwwwwwwww&quot;, 12);</span>
<span class="p_add">+		memset(part-&gt;header.name, &#39;w&#39;, 12);</span>
 		part-&gt;header.checksum = nvram_checksum(&amp;part-&gt;header);
 		rc = nvram_write_header(part);
 		if (rc &lt;= 0) {
<span class="p_chunk">@@ -310,8 +310,8 @@</span> <span class="p_context"> int __init nvram_remove_partition(const char *name, int sig,</span>
 		}
 		if (prev) {
 			prev-&gt;header.length += part-&gt;header.length;
<span class="p_del">-			prev-&gt;header.checksum = nvram_checksum(&amp;part-&gt;header);</span>
<span class="p_del">-			rc = nvram_write_header(part);</span>
<span class="p_add">+			prev-&gt;header.checksum = nvram_checksum(&amp;prev-&gt;header);</span>
<span class="p_add">+			rc = nvram_write_header(prev);</span>
 			if (rc &lt;= 0) {
 				printk(KERN_ERR &quot;nvram_remove_partition: nvram_write failed (%d)\n&quot;, rc);
 				return rc;
<span class="p_header">diff --git a/arch/powerpc/kernel/vdso64/datapage.S b/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_header">index 79796de11737..3263ee23170d 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vdso64/datapage.S</span>
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> V_FUNCTION_BEGIN(__kernel_get_syscall_map)</span>
 	bl	V_LOCAL_FUNC(__get_datapage)
 	mtlr	r12
 	addi	r3,r3,CFG_SYSCALL_MAP64
<span class="p_del">-	cmpli	cr0,r4,0</span>
<span class="p_add">+	cmpldi	cr0,r4,0</span>
 	crclr	cr0*4+so
 	beqlr
 	li	r0,__NR_syscalls
<span class="p_header">diff --git a/arch/powerpc/kernel/vdso64/gettimeofday.S b/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_header">index a76b4af37ef2..382021324883 100644</span>
<span class="p_header">--- a/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_header">+++ b/arch/powerpc/kernel/vdso64/gettimeofday.S</span>
<span class="p_chunk">@@ -145,7 +145,7 @@</span> <span class="p_context"> V_FUNCTION_BEGIN(__kernel_clock_getres)</span>
 	bne	cr0,99f
 
 	li	r3,0
<span class="p_del">-	cmpli	cr0,r4,0</span>
<span class="p_add">+	cmpldi	cr0,r4,0</span>
 	crclr	cr0*4+so
 	beqlr
 	lis	r5,CLOCK_REALTIME_RES@h
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_emulate.c b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">index 3f295269af37..70ab968da2e6 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_emulate.c</span>
<span class="p_chunk">@@ -503,6 +503,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mtspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong spr_val)</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 #endif
 		break;
 unprivileged:
<span class="p_chunk">@@ -633,6 +634,7 @@</span> <span class="p_context"> int kvmppc_core_emulate_mfspr_pr(struct kvm_vcpu *vcpu, int sprn, ulong *spr_val</span>
 	case SPRN_MMCR0:
 	case SPRN_MMCR1:
 	case SPRN_MMCR2:
<span class="p_add">+	case SPRN_UMMCR2:</span>
 	case SPRN_TIR:
 #endif
 		*spr_val = 0;
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv.c b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">index 89d4ebd8152b..a416b6bb0d6a 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv.c</span>
<span class="p_chunk">@@ -909,7 +909,7 @@</span> <span class="p_context"> static int kvmppc_get_one_reg_hv(struct kvm_vcpu *vcpu, u64 id,</span>
 		*val = get_reg_val(id, vcpu-&gt;arch.ic);
 		break;
 	case KVM_REG_PPC_VTB:
<span class="p_del">-		*val = get_reg_val(id, vcpu-&gt;arch.vtb);</span>
<span class="p_add">+		*val = get_reg_val(id, vcpu-&gt;arch.vcore-&gt;vtb);</span>
 		break;
 	case KVM_REG_PPC_CSIGR:
 		*val = get_reg_val(id, vcpu-&gt;arch.csigr);
<span class="p_chunk">@@ -1110,7 +1110,7 @@</span> <span class="p_context"> static int kvmppc_set_one_reg_hv(struct kvm_vcpu *vcpu, u64 id,</span>
 		vcpu-&gt;arch.ic = set_reg_val(id, *val);
 		break;
 	case KVM_REG_PPC_VTB:
<span class="p_del">-		vcpu-&gt;arch.vtb = set_reg_val(id, *val);</span>
<span class="p_add">+		vcpu-&gt;arch.vcore-&gt;vtb = set_reg_val(id, *val);</span>
 		break;
 	case KVM_REG_PPC_CSIGR:
 		vcpu-&gt;arch.csigr = set_reg_val(id, *val);
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_hv_rmhandlers.S b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">index 2f0c1394efa8..ab69a5f242d1 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_hv_rmhandlers.S</span>
<span class="p_chunk">@@ -457,9 +457,11 @@</span> <span class="p_context"> ALT_FTR_SECTION_END_IFSET(CPU_FTR_ARCH_207S)</span>
 38:
 
 BEGIN_FTR_SECTION
<span class="p_del">-	/* DPDES is shared between threads */</span>
<span class="p_add">+	/* DPDES and VTB are shared between threads */</span>
 	ld	r8, VCORE_DPDES(r5)
<span class="p_add">+	ld	r7, VCORE_VTB(r5)</span>
 	mtspr	SPRN_DPDES, r8
<span class="p_add">+	mtspr	SPRN_VTB, r7</span>
 END_FTR_SECTION_IFSET(CPU_FTR_ARCH_207S)
 
 	li	r0,1
<span class="p_chunk">@@ -736,10 +738,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 	mtspr	SPRN_CIABR, r7
 	mtspr	SPRN_TAR, r8
 	ld	r5, VCPU_IC(r4)
<span class="p_del">-	ld	r6, VCPU_VTB(r4)</span>
<span class="p_del">-	mtspr	SPRN_IC, r5</span>
<span class="p_del">-	mtspr	SPRN_VTB, r6</span>
 	ld	r8, VCPU_EBBHR(r4)
<span class="p_add">+	mtspr	SPRN_IC, r5</span>
 	mtspr	SPRN_EBBHR, r8
 	ld	r5, VCPU_EBBRR(r4)
 	ld	r6, VCPU_BESCR(r4)
<span class="p_chunk">@@ -1147,10 +1147,8 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_ARCH_207S)</span>
 	stw	r6, VCPU_PSPB(r9)
 	std	r7, VCPU_FSCR(r9)
 	mfspr	r5, SPRN_IC
<span class="p_del">-	mfspr	r6, SPRN_VTB</span>
 	mfspr	r7, SPRN_TAR
 	std	r5, VCPU_IC(r9)
<span class="p_del">-	std	r6, VCPU_VTB(r9)</span>
 	std	r7, VCPU_TAR(r9)
 	mfspr	r8, SPRN_EBBHR
 	std	r8, VCPU_EBBHR(r9)
<span class="p_chunk">@@ -1442,9 +1440,11 @@</span> <span class="p_context"> secondary_too_late:</span>
 	isync
 
 BEGIN_FTR_SECTION
<span class="p_del">-	/* DPDES is shared between threads */</span>
<span class="p_add">+	/* DPDES and VTB are shared between threads */</span>
 	mfspr	r7, SPRN_DPDES
<span class="p_add">+	mfspr	r8, SPRN_VTB</span>
 	std	r7, VCORE_DPDES(r5)
<span class="p_add">+	std	r8, VCORE_VTB(r5)</span>
 	/* clear DPDES so we don&#39;t get guest doorbells in the host */
 	li	r8, 0
 	mtspr	SPRN_DPDES, r8
<span class="p_header">diff --git a/arch/powerpc/kvm/book3s_pr.c b/arch/powerpc/kvm/book3s_pr.c</span>
<span class="p_header">index 66b7afec250f..e587264c2e8c 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/book3s_pr.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/book3s_pr.c</span>
<span class="p_chunk">@@ -1232,6 +1232,9 @@</span> <span class="p_context"> static int kvmppc_get_one_reg_pr(struct kvm_vcpu *vcpu, u64 id,</span>
 	case KVM_REG_PPC_HIOR:
 		*val = get_reg_val(id, to_book3s(vcpu)-&gt;hior);
 		break;
<span class="p_add">+	case KVM_REG_PPC_VTB:</span>
<span class="p_add">+		*val = get_reg_val(id, to_book3s(vcpu)-&gt;vtb);</span>
<span class="p_add">+		break;</span>
 	case KVM_REG_PPC_LPCR:
 	case KVM_REG_PPC_LPCR_64:
 		/*
<span class="p_chunk">@@ -1268,6 +1271,9 @@</span> <span class="p_context"> static int kvmppc_set_one_reg_pr(struct kvm_vcpu *vcpu, u64 id,</span>
 		to_book3s(vcpu)-&gt;hior = set_reg_val(id, *val);
 		to_book3s(vcpu)-&gt;hior_explicit = true;
 		break;
<span class="p_add">+	case KVM_REG_PPC_VTB:</span>
<span class="p_add">+		to_book3s(vcpu)-&gt;vtb = set_reg_val(id, *val);</span>
<span class="p_add">+		break;</span>
 	case KVM_REG_PPC_LPCR:
 	case KVM_REG_PPC_LPCR_64:
 		kvmppc_set_lpcr_pr(vcpu, set_reg_val(id, *val));
<span class="p_header">diff --git a/arch/powerpc/kvm/booke.c b/arch/powerpc/kvm/booke.c</span>
<span class="p_header">index ab62109fdfa3..dcec08ed35da 100644</span>
<span class="p_header">--- a/arch/powerpc/kvm/booke.c</span>
<span class="p_header">+++ b/arch/powerpc/kvm/booke.c</span>
<span class="p_chunk">@@ -1841,7 +1841,7 @@</span> <span class="p_context"> int kvm_arch_vcpu_ioctl_set_guest_debug(struct kvm_vcpu *vcpu,</span>
 		if (type == KVMPPC_DEBUG_NONE)
 			continue;
 
<span class="p_del">-		if (type &amp; !(KVMPPC_DEBUG_WATCH_READ |</span>
<span class="p_add">+		if (type &amp; ~(KVMPPC_DEBUG_WATCH_READ |</span>
 			     KVMPPC_DEBUG_WATCH_WRITE |
 			     KVMPPC_DEBUG_BREAKPOINT))
 			return -EINVAL;
<span class="p_header">diff --git a/arch/powerpc/lib/copyuser_64.S b/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_header">index 0860ee46013c..0632d5398277 100644</span>
<span class="p_header">--- a/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_header">+++ b/arch/powerpc/lib/copyuser_64.S</span>
<span class="p_chunk">@@ -359,6 +359,7 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)</span>
 	addi	r3,r3,8
 171:
 177:
<span class="p_add">+179:</span>
 	addi	r3,r3,8
 370:
 372:
<span class="p_chunk">@@ -373,7 +374,6 @@</span> <span class="p_context"> END_FTR_SECTION_IFCLR(CPU_FTR_UNALIGNED_LD_STD)</span>
 173:
 174:
 175:
<span class="p_del">-179:</span>
 181:
 184:
 186:
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/eeh-ioda.c b/arch/powerpc/platforms/powernv/eeh-ioda.c</span>
<span class="p_header">index 8ad0c5b891f4..491e511f63e3 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/eeh-ioda.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/eeh-ioda.c</span>
<span class="p_chunk">@@ -578,6 +578,11 @@</span> <span class="p_context"> static int ioda_eeh_reset(struct eeh_pe *pe, int option)</span>
 		ret = ioda_eeh_phb_reset(hose, option);
 	} else {
 		bus = eeh_pe_bus_get(pe);
<span class="p_add">+		if (!bus) {</span>
<span class="p_add">+			pr_err(&quot;%s: Cannot find PCI bus for PHB#%d-PE#%x\n&quot;,</span>
<span class="p_add">+			       __func__, pe-&gt;phb-&gt;global_number, pe-&gt;addr);</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+		}</span>
 		if (pci_is_root_bus(bus) ||
 		    pci_is_root_bus(bus-&gt;parent))
 			ret = ioda_eeh_root_reset(hose, option);
<span class="p_header">diff --git a/arch/powerpc/platforms/powernv/pci.c b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">index a6c16d1f06f5..91baa8d04c8f 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/powernv/pci.c</span>
<span class="p_chunk">@@ -189,8 +189,8 @@</span> <span class="p_context"> static void pnv_pci_dump_p7ioc_diag_data(struct pci_controller *hose,</span>
 			data-&gt;dma1ErrorLog0, data-&gt;dma1ErrorLog1);
 
 	for (i = 0; i &lt; OPAL_P7IOC_NUM_PEST_REGS; i++) {
<span class="p_del">-		if ((data-&gt;pestA[i] &gt;&gt; 63) == 0 &amp;&amp;</span>
<span class="p_del">-		    (data-&gt;pestB[i] &gt;&gt; 63) == 0)</span>
<span class="p_add">+		if ((be64_to_cpu(data-&gt;pestA[i]) &gt;&gt; 63) == 0 &amp;&amp;</span>
<span class="p_add">+		    (be64_to_cpu(data-&gt;pestB[i]) &gt;&gt; 63) == 0)</span>
 			continue;
 
 		pr_info(&quot;PE[%3d] A/B: %016llx %016llx\n&quot;,
<span class="p_header">diff --git a/arch/powerpc/platforms/pseries/lpar.c b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">index ccf6f162f69c..fc7e898f46da 100644</span>
<span class="p_header">--- a/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_header">+++ b/arch/powerpc/platforms/pseries/lpar.c</span>
<span class="p_chunk">@@ -391,7 +391,7 @@</span> <span class="p_context"> static void __pSeries_lpar_hugepage_invalidate(unsigned long *slot,</span>
 					     unsigned long *vpn, int count,
 					     int psize, int ssize)
 {
<span class="p_del">-	unsigned long param[8];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	int i = 0, pix = 0, rc;
 	unsigned long flags = 0;
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_chunk">@@ -508,7 +508,7 @@</span> <span class="p_context"> static void pSeries_lpar_flush_hash_range(unsigned long number, int local)</span>
 	unsigned long flags = 0;
 	struct ppc64_tlb_batch *batch = &amp;__get_cpu_var(ppc64_tlb_batch);
 	int lock_tlbie = !mmu_has_feature(MMU_FTR_LOCKLESS_TLBIE);
<span class="p_del">-	unsigned long param[9];</span>
<span class="p_add">+	unsigned long param[PLPAR_HCALL9_BUFSIZE];</span>
 	unsigned long hash, index, shift, hidx, slot;
 	real_pte_t pte;
 	int psize, ssize;
<span class="p_header">diff --git a/arch/s390/hypfs/hypfs_diag.c b/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_header">index 5eeffeefae06..d73124df5d32 100644</span>
<span class="p_header">--- a/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_header">+++ b/arch/s390/hypfs/hypfs_diag.c</span>
<span class="p_chunk">@@ -517,11 +517,11 @@</span> <span class="p_context"> static int diag224(void *ptr)</span>
 static int diag224_get_name_table(void)
 {
 	/* memory must be below 2GB */
<span class="p_del">-	diag224_cpu_names = kmalloc(PAGE_SIZE, GFP_KERNEL | GFP_DMA);</span>
<span class="p_add">+	diag224_cpu_names = (char *) __get_free_page(GFP_KERNEL | GFP_DMA);</span>
 	if (!diag224_cpu_names)
 		return -ENOMEM;
 	if (diag224(diag224_cpu_names)) {
<span class="p_del">-		kfree(diag224_cpu_names);</span>
<span class="p_add">+		free_page((unsigned long) diag224_cpu_names);</span>
 		return -EOPNOTSUPP;
 	}
 	EBCASC(diag224_cpu_names + 16, (*diag224_cpu_names + 1) * 16);
<span class="p_chunk">@@ -530,7 +530,7 @@</span> <span class="p_context"> static int diag224_get_name_table(void)</span>
 
 static void diag224_delete_name_table(void)
 {
<span class="p_del">-	kfree(diag224_cpu_names);</span>
<span class="p_add">+	free_page((unsigned long) diag224_cpu_names);</span>
 }
 
 static int diag224_idx2name(int index, char *name)
<span class="p_header">diff --git a/arch/tile/kernel/time.c b/arch/tile/kernel/time.c</span>
<span class="p_header">index 462dcd0c1700..89f87bd5dda3 100644</span>
<span class="p_header">--- a/arch/tile/kernel/time.c</span>
<span class="p_header">+++ b/arch/tile/kernel/time.c</span>
<span class="p_chunk">@@ -216,8 +216,8 @@</span> <span class="p_context"> void do_timer_interrupt(struct pt_regs *regs, int fault_num)</span>
  */
 unsigned long long sched_clock(void)
 {
<span class="p_del">-	return clocksource_cyc2ns(get_cycles(),</span>
<span class="p_del">-				  sched_clock_mult, SCHED_CLOCK_SHIFT);</span>
<span class="p_add">+	return mult_frac(get_cycles(),</span>
<span class="p_add">+			 sched_clock_mult, 1ULL &lt;&lt; SCHED_CLOCK_SHIFT);</span>
 }
 
 int setup_profiling_timer(unsigned int multiplier)
<span class="p_header">diff --git a/arch/x86/include/asm/kexec.h b/arch/x86/include/asm/kexec.h</span>
<span class="p_header">index 17483a492f18..0c59df3664d5 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/kexec.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/kexec.h</span>
<span class="p_chunk">@@ -165,6 +165,7 @@</span> <span class="p_context"> struct kimage_arch {</span>
 
 typedef void crash_vmclear_fn(void);
 extern crash_vmclear_fn __rcu *crash_vmclear_loaded_vmcss;
<span class="p_add">+extern void kdump_nmi_shootdown_cpus(void);</span>
 
 #endif /* __ASSEMBLY__ */
 
<span class="p_header">diff --git a/arch/x86/include/asm/smp.h b/arch/x86/include/asm/smp.h</span>
<span class="p_header">index 8cd27e08e23c..63baf16934d0 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/smp.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/smp.h</span>
<span class="p_chunk">@@ -69,6 +69,7 @@</span> <span class="p_context"> struct smp_ops {</span>
 	void (*smp_cpus_done)(unsigned max_cpus);
 
 	void (*stop_other_cpus)(int wait);
<span class="p_add">+	void (*crash_stop_other_cpus)(void);</span>
 	void (*smp_send_reschedule)(int cpu);
 
 	int (*cpu_up)(unsigned cpu, struct task_struct *tidle);
<span class="p_header">diff --git a/arch/x86/include/asm/uaccess.h b/arch/x86/include/asm/uaccess.h</span>
<span class="p_header">index 0d592e0a5b84..465504609869 100644</span>
<span class="p_header">--- a/arch/x86/include/asm/uaccess.h</span>
<span class="p_header">+++ b/arch/x86/include/asm/uaccess.h</span>
<span class="p_chunk">@@ -329,7 +329,7 @@</span> <span class="p_context"> do {									\</span>
 #define __get_user_asm_u64(x, ptr, retval, errret) \
 	 __get_user_asm(x, ptr, retval, &quot;q&quot;, &quot;&quot;, &quot;=r&quot;, errret)
 #define __get_user_asm_ex_u64(x, ptr) \
<span class="p_del">-	 __get_user_asm_ex(x, ptr, &quot;q&quot;, &quot;&quot;, &quot;=r&quot;)</span>
<span class="p_add">+	 __get_user_asm_ex(x, ptr, &quot;q&quot;, &quot;&quot;, &quot;=&amp;r&quot;)</span>
 #endif
 
 #define __get_user_size(x, ptr, size, retval, errret)			\
<span class="p_chunk">@@ -372,13 +372,13 @@</span> <span class="p_context"> do {									\</span>
 	__chk_user_ptr(ptr);						\
 	switch (size) {							\
 	case 1:								\
<span class="p_del">-		__get_user_asm_ex(x, ptr, &quot;b&quot;, &quot;b&quot;, &quot;=q&quot;);		\</span>
<span class="p_add">+		__get_user_asm_ex(x, ptr, &quot;b&quot;, &quot;b&quot;, &quot;=&amp;q&quot;);		\</span>
 		break;							\
 	case 2:								\
<span class="p_del">-		__get_user_asm_ex(x, ptr, &quot;w&quot;, &quot;w&quot;, &quot;=r&quot;);		\</span>
<span class="p_add">+		__get_user_asm_ex(x, ptr, &quot;w&quot;, &quot;w&quot;, &quot;=&amp;r&quot;);		\</span>
 		break;							\
 	case 4:								\
<span class="p_del">-		__get_user_asm_ex(x, ptr, &quot;l&quot;, &quot;k&quot;, &quot;=r&quot;);		\</span>
<span class="p_add">+		__get_user_asm_ex(x, ptr, &quot;l&quot;, &quot;k&quot;, &quot;=&amp;r&quot;);		\</span>
 		break;							\
 	case 8:								\
 		__get_user_asm_ex_u64(x, ptr);				\
<span class="p_chunk">@@ -392,7 +392,7 @@</span> <span class="p_context"> do {									\</span>
 	asm volatile(&quot;1:	mov&quot;itype&quot; %1,%&quot;rtype&quot;0\n&quot;		\
 		     &quot;2:\n&quot;						\
 		     _ASM_EXTABLE_EX(1b, 2b)				\
<span class="p_del">-		     : ltype(x) : &quot;m&quot; (__m(addr)))</span>
<span class="p_add">+		     : ltype(x) : &quot;m&quot; (__m(addr)), &quot;0&quot; (0))</span>
 
 #define __put_user_nocheck(x, ptr, size)			\
 ({								\
<span class="p_header">diff --git a/arch/x86/kernel/apic/x2apic_uv_x.c b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">index 293b41df54ef..4bf4b01696f3 100644</span>
<span class="p_header">--- a/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_header">+++ b/arch/x86/kernel/apic/x2apic_uv_x.c</span>
<span class="p_chunk">@@ -633,9 +633,9 @@</span> <span class="p_context"> static __init void map_mmioh_high_uv3(int index, int min_pnode, int max_pnode)</span>
 				l = li;
 			}
 			addr1 = (base &lt;&lt; shift) +
<span class="p_del">-				f * (unsigned long)(1 &lt;&lt; m_io);</span>
<span class="p_add">+				f * (1ULL &lt;&lt; m_io);</span>
 			addr2 = (base &lt;&lt; shift) +
<span class="p_del">-				(l + 1) * (unsigned long)(1 &lt;&lt; m_io);</span>
<span class="p_add">+				(l + 1) * (1ULL &lt;&lt; m_io);</span>
 			pr_info(&quot;UV: %s[%03d..%03d] NASID 0x%04x ADDR 0x%016lx - 0x%016lx\n&quot;,
 				id, fi, li, lnasid, addr1, addr2);
 			if (max_io &lt; l)
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event.c b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">index 70f5eb24557d..10544b9ae3d0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event.c</span>
<span class="p_chunk">@@ -64,7 +64,7 @@</span> <span class="p_context"> u64 x86_perf_event_update(struct perf_event *event)</span>
 	int shift = 64 - x86_pmu.cntval_bits;
 	u64 prev_raw_count, new_raw_count;
 	int idx = hwc-&gt;idx;
<span class="p_del">-	s64 delta;</span>
<span class="p_add">+	u64 delta;</span>
 
 	if (idx == INTEL_PMC_IDX_FIXED_BTS)
 		return 0;
<span class="p_header">diff --git a/arch/x86/kernel/cpu/perf_event_intel.c b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">index 0f56f15573e9..598637302db8 100644</span>
<span class="p_header">--- a/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_header">+++ b/arch/x86/kernel/cpu/perf_event_intel.c</span>
<span class="p_chunk">@@ -2669,7 +2669,7 @@</span> <span class="p_context"> __init int intel_pmu_init(void)</span>
 
 	/* Support full width counters using alternative MSR range */
 	if (x86_pmu.intel_cap.full_width_write) {
<span class="p_del">-		x86_pmu.max_period = x86_pmu.cntval_mask;</span>
<span class="p_add">+		x86_pmu.max_period = x86_pmu.cntval_mask &gt;&gt; 1;</span>
 		x86_pmu.perfctr = MSR_IA32_PMC0;
 		pr_cont(&quot;full-width counters, &quot;);
 	}
<span class="p_header">diff --git a/arch/x86/kernel/crash.c b/arch/x86/kernel/crash.c</span>
<span class="p_header">index 507de8066594..19f10dac8fe6 100644</span>
<span class="p_header">--- a/arch/x86/kernel/crash.c</span>
<span class="p_header">+++ b/arch/x86/kernel/crash.c</span>
<span class="p_chunk">@@ -82,7 +82,7 @@</span> <span class="p_context"> static void kdump_nmi_callback(int cpu, struct pt_regs *regs)</span>
 	disable_local_APIC();
 }
 
<span class="p_del">-static void kdump_nmi_shootdown_cpus(void)</span>
<span class="p_add">+void kdump_nmi_shootdown_cpus(void)</span>
 {
 	in_crash_kexec = 1;
 	nmi_shootdown_cpus(kdump_nmi_callback);
<span class="p_chunk">@@ -90,8 +90,24 @@</span> <span class="p_context"> static void kdump_nmi_shootdown_cpus(void)</span>
 	disable_local_APIC();
 }
 
<span class="p_add">+/* Override the weak function in kernel/panic.c */</span>
<span class="p_add">+void crash_smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int cpus_stopped;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (cpus_stopped)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (smp_ops.crash_stop_other_cpus)</span>
<span class="p_add">+		smp_ops.crash_stop_other_cpus();</span>
<span class="p_add">+	else</span>
<span class="p_add">+		smp_send_stop();</span>
<span class="p_add">+</span>
<span class="p_add">+	cpus_stopped = 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #else
<span class="p_del">-static void kdump_nmi_shootdown_cpus(void)</span>
<span class="p_add">+void crash_smp_send_stop(void)</span>
 {
 	/* There are no cpus to shootdown */
 }
<span class="p_chunk">@@ -110,7 +126,7 @@</span> <span class="p_context"> void native_machine_crash_shutdown(struct pt_regs *regs)</span>
 	/* The kernel is broken so disable interrupts */
 	local_irq_disable();
 
<span class="p_del">-	kdump_nmi_shootdown_cpus();</span>
<span class="p_add">+	crash_smp_send_stop();</span>
 
 	/*
 	 * VMCLEAR VMCSs loaded on this cpu if needed.
<span class="p_header">diff --git a/arch/x86/kernel/head_32.S b/arch/x86/kernel/head_32.S</span>
<span class="p_header">index 30a2aa3782fa..879e67acf463 100644</span>
<span class="p_header">--- a/arch/x86/kernel/head_32.S</span>
<span class="p_header">+++ b/arch/x86/kernel/head_32.S</span>
<span class="p_chunk">@@ -564,7 +564,7 @@</span> <span class="p_context"> early_idt_handler_common:</span>
 	movl %eax,%ds
 	movl %eax,%es
 
<span class="p_del">-	cmpl $(__KERNEL_CS),32(%esp)</span>
<span class="p_add">+	cmpw $(__KERNEL_CS),32(%esp)</span>
 	jne 10f
 
 	leal 28(%esp),%eax	# Pointer to %eip
<span class="p_header">diff --git a/arch/x86/kernel/ptrace.c b/arch/x86/kernel/ptrace.c</span>
<span class="p_header">index b1a5dfa24789..8072696aa20f 100644</span>
<span class="p_header">--- a/arch/x86/kernel/ptrace.c</span>
<span class="p_header">+++ b/arch/x86/kernel/ptrace.c</span>
<span class="p_chunk">@@ -190,8 +190,8 @@</span> <span class="p_context"> unsigned long kernel_stack_pointer(struct pt_regs *regs)</span>
 		return sp;
 
 	prev_esp = (u32 *)(context);
<span class="p_del">-	if (prev_esp)</span>
<span class="p_del">-		return (unsigned long)prev_esp;</span>
<span class="p_add">+	if (*prev_esp)</span>
<span class="p_add">+		return (unsigned long)*prev_esp;</span>
 
 	return (unsigned long)regs;
 }
<span class="p_header">diff --git a/arch/x86/kernel/smp.c b/arch/x86/kernel/smp.c</span>
<span class="p_header">index be8e1bde07aa..00e67d05cbd0 100644</span>
<span class="p_header">--- a/arch/x86/kernel/smp.c</span>
<span class="p_header">+++ b/arch/x86/kernel/smp.c</span>
<span class="p_chunk">@@ -31,6 +31,8 @@</span> <span class="p_context"></span>
 #include &lt;asm/apic.h&gt;
 #include &lt;asm/nmi.h&gt;
 #include &lt;asm/trace/irq_vectors.h&gt;
<span class="p_add">+#include &lt;asm/kexec.h&gt;</span>
<span class="p_add">+</span>
 /*
  *	Some notes on x86 processor bugs affecting SMP operation:
  *
<span class="p_chunk">@@ -347,6 +349,9 @@</span> <span class="p_context"> struct smp_ops smp_ops = {</span>
 	.smp_cpus_done		= native_smp_cpus_done,
 
 	.stop_other_cpus	= native_stop_other_cpus,
<span class="p_add">+#if defined(CONFIG_KEXEC_CORE)</span>
<span class="p_add">+	.crash_stop_other_cpus	= kdump_nmi_shootdown_cpus,</span>
<span class="p_add">+#endif</span>
 	.smp_send_reschedule	= native_smp_send_reschedule,
 
 	.cpu_up			= native_cpu_up,
<span class="p_header">diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c</span>
<span class="p_header">index 57604c0e5a53..f0b7bce7e0ba 100644</span>
<span class="p_header">--- a/arch/x86/kvm/emulate.c</span>
<span class="p_header">+++ b/arch/x86/kvm/emulate.c</span>
<span class="p_chunk">@@ -1981,16 +1981,10 @@</span> <span class="p_context"> static int em_iret(struct x86_emulate_ctxt *ctxt)</span>
 static int em_jmp_far(struct x86_emulate_ctxt *ctxt)
 {
 	int rc;
<span class="p_del">-	unsigned short sel, old_sel;</span>
<span class="p_del">-	struct desc_struct old_desc, new_desc;</span>
<span class="p_del">-	const struct x86_emulate_ops *ops = ctxt-&gt;ops;</span>
<span class="p_add">+	unsigned short sel;</span>
<span class="p_add">+	struct desc_struct new_desc;</span>
 	u8 cpl = ctxt-&gt;ops-&gt;cpl(ctxt);
 
<span class="p_del">-	/* Assignment of RIP may only fail in 64-bit mode */</span>
<span class="p_del">-	if (ctxt-&gt;mode == X86EMUL_MODE_PROT64)</span>
<span class="p_del">-		ops-&gt;get_segment(ctxt, &amp;old_sel, &amp;old_desc, NULL,</span>
<span class="p_del">-				 VCPU_SREG_CS);</span>
<span class="p_del">-</span>
 	memcpy(&amp;sel, ctxt-&gt;src.valptr + ctxt-&gt;op_bytes, 2);
 
 	rc = __load_segment_descriptor(ctxt, sel, VCPU_SREG_CS, cpl, false,
<span class="p_chunk">@@ -1999,12 +1993,10 @@</span> <span class="p_context"> static int em_jmp_far(struct x86_emulate_ctxt *ctxt)</span>
 		return rc;
 
 	rc = assign_eip_far(ctxt, ctxt-&gt;src.val, new_desc.l);
<span class="p_del">-	if (rc != X86EMUL_CONTINUE) {</span>
<span class="p_del">-		WARN_ON(ctxt-&gt;mode != X86EMUL_MODE_PROT64);</span>
<span class="p_del">-		/* assigning eip failed; restore the old cs */</span>
<span class="p_del">-		ops-&gt;set_segment(ctxt, old_sel, &amp;old_desc, 0, VCPU_SREG_CS);</span>
<span class="p_del">-		return rc;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Error handling is not implemented. */</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -2070,14 +2062,8 @@</span> <span class="p_context"> static int em_ret_far(struct x86_emulate_ctxt *ctxt)</span>
 {
 	int rc;
 	unsigned long eip, cs;
<span class="p_del">-	u16 old_cs;</span>
 	int cpl = ctxt-&gt;ops-&gt;cpl(ctxt);
<span class="p_del">-	struct desc_struct old_desc, new_desc;</span>
<span class="p_del">-	const struct x86_emulate_ops *ops = ctxt-&gt;ops;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (ctxt-&gt;mode == X86EMUL_MODE_PROT64)</span>
<span class="p_del">-		ops-&gt;get_segment(ctxt, &amp;old_cs, &amp;old_desc, NULL,</span>
<span class="p_del">-				 VCPU_SREG_CS);</span>
<span class="p_add">+	struct desc_struct new_desc;</span>
 
 	rc = emulate_pop(ctxt, &amp;eip, ctxt-&gt;op_bytes);
 	if (rc != X86EMUL_CONTINUE)
<span class="p_chunk">@@ -2093,10 +2079,10 @@</span> <span class="p_context"> static int em_ret_far(struct x86_emulate_ctxt *ctxt)</span>
 	if (rc != X86EMUL_CONTINUE)
 		return rc;
 	rc = assign_eip_far(ctxt, eip, new_desc.l);
<span class="p_del">-	if (rc != X86EMUL_CONTINUE) {</span>
<span class="p_del">-		WARN_ON(ctxt-&gt;mode != X86EMUL_MODE_PROT64);</span>
<span class="p_del">-		ops-&gt;set_segment(ctxt, old_cs, &amp;old_desc, 0, VCPU_SREG_CS);</span>
<span class="p_del">-	}</span>
<span class="p_add">+	/* Error handling is not implemented. */</span>
<span class="p_add">+	if (rc != X86EMUL_CONTINUE)</span>
<span class="p_add">+		return X86EMUL_UNHANDLEABLE;</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_header">diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c</span>
<span class="p_header">index 4226d8fd93d1..e0a27d684d29 100644</span>
<span class="p_header">--- a/arch/x86/kvm/x86.c</span>
<span class="p_header">+++ b/arch/x86/kvm/x86.c</span>
<span class="p_chunk">@@ -180,7 +180,18 @@</span> <span class="p_context"> static void kvm_on_user_return(struct user_return_notifier *urn)</span>
 	struct kvm_shared_msrs *locals
 		= container_of(urn, struct kvm_shared_msrs, urn);
 	struct kvm_shared_msr_values *values;
<span class="p_add">+	unsigned long flags;</span>
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Disabling irqs at this point since the following code could be</span>
<span class="p_add">+	 * interrupted and executed through kvm_arch_hardware_disable()</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	local_irq_save(flags);</span>
<span class="p_add">+	if (locals-&gt;registered) {</span>
<span class="p_add">+		locals-&gt;registered = false;</span>
<span class="p_add">+		user_return_notifier_unregister(urn);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	local_irq_restore(flags);</span>
 	for (slot = 0; slot &lt; shared_msrs_global.nr; ++slot) {
 		values = &amp;locals-&gt;values[slot];
 		if (values-&gt;host != values-&gt;curr) {
<span class="p_chunk">@@ -188,8 +199,6 @@</span> <span class="p_context"> static void kvm_on_user_return(struct user_return_notifier *urn)</span>
 			values-&gt;curr = values-&gt;host;
 		}
 	}
<span class="p_del">-	locals-&gt;registered = false;</span>
<span class="p_del">-	user_return_notifier_unregister(urn);</span>
 }
 
 static void shared_msr_update(unsigned slot, u32 msr)
<span class="p_chunk">@@ -3296,6 +3305,7 @@</span> <span class="p_context"> long kvm_arch_vcpu_ioctl(struct file *filp,</span>
 	};
 	case KVM_SET_VAPIC_ADDR: {
 		struct kvm_vapic_addr va;
<span class="p_add">+		int idx;</span>
 
 		r = -EINVAL;
 		if (!irqchip_in_kernel(vcpu-&gt;kvm))
<span class="p_chunk">@@ -3303,7 +3313,9 @@</span> <span class="p_context"> long kvm_arch_vcpu_ioctl(struct file *filp,</span>
 		r = -EFAULT;
 		if (copy_from_user(&amp;va, argp, sizeof va))
 			goto out;
<span class="p_add">+		idx = srcu_read_lock(&amp;vcpu-&gt;kvm-&gt;srcu);</span>
 		r = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);
<span class="p_add">+		srcu_read_unlock(&amp;vcpu-&gt;kvm-&gt;srcu, idx);</span>
 		break;
 	}
 	case KVM_X86_SETUP_MCE: {
<span class="p_chunk">@@ -6809,11 +6821,13 @@</span> <span class="p_context"> void kvm_put_guest_fpu(struct kvm_vcpu *vcpu)</span>
 
 void kvm_arch_vcpu_free(struct kvm_vcpu *vcpu)
 {
<span class="p_add">+	void *wbinvd_dirty_mask = vcpu-&gt;arch.wbinvd_dirty_mask;</span>
<span class="p_add">+</span>
 	kvmclock_reset(vcpu);
 
<span class="p_del">-	free_cpumask_var(vcpu-&gt;arch.wbinvd_dirty_mask);</span>
 	fx_free(vcpu);
 	kvm_x86_ops-&gt;vcpu_free(vcpu);
<span class="p_add">+	free_cpumask_var(wbinvd_dirty_mask);</span>
 }
 
 struct kvm_vcpu *kvm_arch_vcpu_create(struct kvm *kvm,
<span class="p_header">diff --git a/block/blk-cgroup.h b/block/blk-cgroup.h</span>
<span class="p_header">index d3fd7aa3d2a3..7485c59ff625 100644</span>
<span class="p_header">--- a/block/blk-cgroup.h</span>
<span class="p_header">+++ b/block/blk-cgroup.h</span>
<span class="p_chunk">@@ -47,7 +47,7 @@</span> <span class="p_context"> struct blkcg {</span>
 	spinlock_t			lock;
 
 	struct radix_tree_root		blkg_tree;
<span class="p_del">-	struct blkcg_gq			*blkg_hint;</span>
<span class="p_add">+	struct blkcg_gq	__rcu		*blkg_hint;</span>
 	struct hlist_head		blkg_list;
 
 	/* for policies to test whether associated blkcg has changed */
<span class="p_header">diff --git a/block/bsg.c b/block/bsg.c</span>
<span class="p_header">index ff46addde5d8..8af4880ab2a2 100644</span>
<span class="p_header">--- a/block/bsg.c</span>
<span class="p_header">+++ b/block/bsg.c</span>
<span class="p_chunk">@@ -676,6 +676,9 @@</span> <span class="p_context"> bsg_write(struct file *file, const char __user *buf, size_t count, loff_t *ppos)</span>
 
 	dprintk(&quot;%s: write %Zd bytes\n&quot;, bd-&gt;name, count);
 
<span class="p_add">+	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	bsg_set_block(bd, file);
 
 	bytes_written = 0;
<span class="p_header">diff --git a/crypto/async_tx/async_pq.c b/crypto/async_tx/async_pq.c</span>
<span class="p_header">index 7eb264e65267..1ce03d38c817 100644</span>
<span class="p_header">--- a/crypto/async_tx/async_pq.c</span>
<span class="p_header">+++ b/crypto/async_tx/async_pq.c</span>
<span class="p_chunk">@@ -355,8 +355,6 @@</span> <span class="p_context"> async_syndrome_val(struct page **blocks, unsigned int offset, int disks,</span>
 
 		dma_set_unmap(tx, unmap);
 		async_tx_submit(chan, tx, submit);
<span class="p_del">-</span>
<span class="p_del">-		return tx;</span>
 	} else {
 		struct page *p_src = P(blocks, disks);
 		struct page *q_src = Q(blocks, disks);
<span class="p_chunk">@@ -411,9 +409,11 @@</span> <span class="p_context"> async_syndrome_val(struct page **blocks, unsigned int offset, int disks,</span>
 		submit-&gt;cb_param = cb_param_orig;
 		submit-&gt;flags = flags_orig;
 		async_tx_sync_epilog(submit);
<span class="p_del">-</span>
<span class="p_del">-		return NULL;</span>
<span class="p_add">+		tx = NULL;</span>
 	}
<span class="p_add">+	dmaengine_unmap_put(unmap);</span>
<span class="p_add">+</span>
<span class="p_add">+	return tx;</span>
 }
 EXPORT_SYMBOL_GPL(async_syndrome_val);
 
<span class="p_header">diff --git a/crypto/gcm.c b/crypto/gcm.c</span>
<span class="p_header">index d2a0f7371cf0..49b6fb20cceb 100644</span>
<span class="p_header">--- a/crypto/gcm.c</span>
<span class="p_header">+++ b/crypto/gcm.c</span>
<span class="p_chunk">@@ -109,7 +109,7 @@</span> <span class="p_context"> static int crypto_gcm_setkey(struct crypto_aead *aead, const u8 *key,</span>
 	struct crypto_ablkcipher *ctr = ctx-&gt;ctr;
 	struct {
 		be128 hash;
<span class="p_del">-		u8 iv[8];</span>
<span class="p_add">+		u8 iv[16];</span>
 
 		struct crypto_gcm_setkey_result result;
 
<span class="p_header">diff --git a/drivers/acpi/apei/ghes.c b/drivers/acpi/apei/ghes.c</span>
<span class="p_header">index dab7cb7349df..282c21c37fc4 100644</span>
<span class="p_header">--- a/drivers/acpi/apei/ghes.c</span>
<span class="p_header">+++ b/drivers/acpi/apei/ghes.c</span>
<span class="p_chunk">@@ -679,7 +679,7 @@</span> <span class="p_context"> static int ghes_proc(struct ghes *ghes)</span>
 	ghes_do_proc(ghes, ghes-&gt;estatus);
 out:
 	ghes_clear_estatus(ghes);
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return rc;</span>
 }
 
 static void ghes_add_timer(struct ghes *ghes)
<span class="p_header">diff --git a/drivers/base/platform.c b/drivers/base/platform.c</span>
<span class="p_header">index 9106f3046569..6e7696db1b76 100644</span>
<span class="p_header">--- a/drivers/base/platform.c</span>
<span class="p_header">+++ b/drivers/base/platform.c</span>
<span class="p_chunk">@@ -93,7 +93,7 @@</span> <span class="p_context"> int platform_get_irq(struct platform_device *dev, unsigned int num)</span>
 		int ret;
 
 		ret = of_irq_get(dev-&gt;dev.of_node, num);
<span class="p_del">-		if (ret &gt;= 0 || ret == -EPROBE_DEFER)</span>
<span class="p_add">+		if (ret &gt; 0 || ret == -EPROBE_DEFER)</span>
 			return ret;
 	}
 
<span class="p_chunk">@@ -142,7 +142,7 @@</span> <span class="p_context"> int platform_get_irq_byname(struct platform_device *dev, const char *name)</span>
 		int ret;
 
 		ret = of_irq_get_byname(dev-&gt;dev.of_node, name);
<span class="p_del">-		if (ret &gt;= 0 || ret == -EPROBE_DEFER)</span>
<span class="p_add">+		if (ret &gt; 0 || ret == -EPROBE_DEFER)</span>
 			return ret;
 	}
 
<span class="p_header">diff --git a/drivers/base/power/main.c b/drivers/base/power/main.c</span>
<span class="p_header">index 0f632958a4dd..3fc787a02fa0 100644</span>
<span class="p_header">--- a/drivers/base/power/main.c</span>
<span class="p_header">+++ b/drivers/base/power/main.c</span>
<span class="p_chunk">@@ -1014,6 +1014,8 @@</span> <span class="p_context"> static int __device_suspend_noirq(struct device *dev, pm_message_t state, bool a</span>
 	char *info = NULL;
 	int error = 0;
 
<span class="p_add">+	dpm_wait_for_children(dev, async);</span>
<span class="p_add">+</span>
 	if (async_error)
 		goto Complete;
 
<span class="p_chunk">@@ -1025,8 +1027,6 @@</span> <span class="p_context"> static int __device_suspend_noirq(struct device *dev, pm_message_t state, bool a</span>
 	if (dev-&gt;power.syscore || dev-&gt;power.direct_complete)
 		goto Complete;
 
<span class="p_del">-	dpm_wait_for_children(dev, async);</span>
<span class="p_del">-</span>
 	if (dev-&gt;pm_domain) {
 		info = &quot;noirq power domain &quot;;
 		callback = pm_noirq_op(&amp;dev-&gt;pm_domain-&gt;ops, state);
<span class="p_chunk">@@ -1155,6 +1155,8 @@</span> <span class="p_context"> static int __device_suspend_late(struct device *dev, pm_message_t state, bool as</span>
 
 	__pm_runtime_disable(dev, false);
 
<span class="p_add">+	dpm_wait_for_children(dev, async);</span>
<span class="p_add">+</span>
 	if (async_error)
 		goto Complete;
 
<span class="p_chunk">@@ -1166,8 +1168,6 @@</span> <span class="p_context"> static int __device_suspend_late(struct device *dev, pm_message_t state, bool as</span>
 	if (dev-&gt;power.syscore || dev-&gt;power.direct_complete)
 		goto Complete;
 
<span class="p_del">-	dpm_wait_for_children(dev, async);</span>
<span class="p_del">-</span>
 	if (dev-&gt;pm_domain) {
 		info = &quot;late power domain &quot;;
 		callback = pm_late_early_op(&amp;dev-&gt;pm_domain-&gt;ops, state);
<span class="p_header">diff --git a/drivers/block/nvme-core.c b/drivers/block/nvme-core.c</span>
<span class="p_header">index 02351e217165..b815b425a099 100644</span>
<span class="p_header">--- a/drivers/block/nvme-core.c</span>
<span class="p_header">+++ b/drivers/block/nvme-core.c</span>
<span class="p_chunk">@@ -2196,7 +2196,7 @@</span> <span class="p_context"> static int nvme_setup_io_queues(struct nvme_dev *dev)</span>
 	result = queue_request_irq(dev, adminq, adminq-&gt;irqname);
 	if (result) {
 		adminq-&gt;q_suspended = 1;
<span class="p_del">-		goto free_queues;</span>
<span class="p_add">+		return result;</span>
 	}
 
 	/* Free previously allocated queues that are no longer usable */
<span class="p_chunk">@@ -2204,10 +2204,6 @@</span> <span class="p_context"> static int nvme_setup_io_queues(struct nvme_dev *dev)</span>
 	nvme_assign_io_queues(dev);
 
 	return 0;
<span class="p_del">-</span>
<span class="p_del">- free_queues:</span>
<span class="p_del">-	nvme_free_queues(dev, 1);</span>
<span class="p_del">-	return result;</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/char/hw_random/core.c b/drivers/char/hw_random/core.c</span>
<span class="p_header">index 2a451b14b3cc..d456303f4625 100644</span>
<span class="p_header">--- a/drivers/char/hw_random/core.c</span>
<span class="p_header">+++ b/drivers/char/hw_random/core.c</span>
<span class="p_chunk">@@ -65,12 +65,12 @@</span> <span class="p_context"> static size_t rng_buffer_size(void)</span>
 
 static void add_early_randomness(struct hwrng *rng)
 {
<span class="p_del">-	unsigned char bytes[16];</span>
 	int bytes_read;
<span class="p_add">+	size_t size = min_t(size_t, 16, rng_buffer_size());</span>
 
<span class="p_del">-	bytes_read = rng_get_data(rng, bytes, sizeof(bytes), 1);</span>
<span class="p_add">+	bytes_read = rng_get_data(rng, rng_buffer, size, 1);</span>
 	if (bytes_read &gt; 0)
<span class="p_del">-		add_device_randomness(bytes, bytes_read);</span>
<span class="p_add">+		add_device_randomness(rng_buffer, bytes_read);</span>
 }
 
 static inline int hwrng_init(struct hwrng *rng)
<span class="p_header">diff --git a/drivers/char/virtio_console.c b/drivers/char/virtio_console.c</span>
<span class="p_header">index 73294b270b93..7d58b2918138 100644</span>
<span class="p_header">--- a/drivers/char/virtio_console.c</span>
<span class="p_header">+++ b/drivers/char/virtio_console.c</span>
<span class="p_chunk">@@ -1532,19 +1532,29 @@</span> <span class="p_context"> static void remove_port_data(struct port *port)</span>
 	spin_lock_irq(&amp;port-&gt;inbuf_lock);
 	/* Remove unused data this port might have received. */
 	discard_port_data(port);
<span class="p_add">+	spin_unlock_irq(&amp;port-&gt;inbuf_lock);</span>
 
 	/* Remove buffers we queued up for the Host to send us data in. */
<span class="p_del">-	while ((buf = virtqueue_detach_unused_buf(port-&gt;in_vq)))</span>
<span class="p_del">-		free_buf(buf, true);</span>
<span class="p_del">-	spin_unlock_irq(&amp;port-&gt;inbuf_lock);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		spin_lock_irq(&amp;port-&gt;inbuf_lock);</span>
<span class="p_add">+		buf = virtqueue_detach_unused_buf(port-&gt;in_vq);</span>
<span class="p_add">+		spin_unlock_irq(&amp;port-&gt;inbuf_lock);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			free_buf(buf, true);</span>
<span class="p_add">+	} while (buf);</span>
 
 	spin_lock_irq(&amp;port-&gt;outvq_lock);
 	reclaim_consumed_buffers(port);
<span class="p_add">+	spin_unlock_irq(&amp;port-&gt;outvq_lock);</span>
 
 	/* Free pending buffers from the out-queue. */
<span class="p_del">-	while ((buf = virtqueue_detach_unused_buf(port-&gt;out_vq)))</span>
<span class="p_del">-		free_buf(buf, true);</span>
<span class="p_del">-	spin_unlock_irq(&amp;port-&gt;outvq_lock);</span>
<span class="p_add">+	do {</span>
<span class="p_add">+		spin_lock_irq(&amp;port-&gt;outvq_lock);</span>
<span class="p_add">+		buf = virtqueue_detach_unused_buf(port-&gt;out_vq);</span>
<span class="p_add">+		spin_unlock_irq(&amp;port-&gt;outvq_lock);</span>
<span class="p_add">+		if (buf)</span>
<span class="p_add">+			free_buf(buf, true);</span>
<span class="p_add">+	} while (buf);</span>
 }
 
 /*
<span class="p_header">diff --git a/drivers/clk/clk-divider.c b/drivers/clk/clk-divider.c</span>
<span class="p_header">index a52154caf526..ff91b6cceff6 100644</span>
<span class="p_header">--- a/drivers/clk/clk-divider.c</span>
<span class="p_header">+++ b/drivers/clk/clk-divider.c</span>
<span class="p_chunk">@@ -263,7 +263,7 @@</span> <span class="p_context"> static int clk_divider_bestdiv(struct clk_hw *hw, unsigned long rate,</span>
 
 	/* if read only, just return current value */
 	if (divider-&gt;flags &amp; CLK_DIVIDER_READ_ONLY) {
<span class="p_del">-		bestdiv = readl(divider-&gt;reg) &gt;&gt; divider-&gt;shift;</span>
<span class="p_add">+		bestdiv = clk_readl(divider-&gt;reg) &gt;&gt; divider-&gt;shift;</span>
 		bestdiv &amp;= div_mask(divider);
 		bestdiv = _get_div(divider, bestdiv);
 		return bestdiv;
<span class="p_header">diff --git a/drivers/firewire/net.c b/drivers/firewire/net.c</span>
<span class="p_header">index 3e8fcbf511e2..0420683a132f 100644</span>
<span class="p_header">--- a/drivers/firewire/net.c</span>
<span class="p_header">+++ b/drivers/firewire/net.c</span>
<span class="p_chunk">@@ -73,13 +73,13 @@</span> <span class="p_context"> struct rfc2734_header {</span>
 
 #define fwnet_get_hdr_lf(h)		(((h)-&gt;w0 &amp; 0xc0000000) &gt;&gt; 30)
 #define fwnet_get_hdr_ether_type(h)	(((h)-&gt;w0 &amp; 0x0000ffff))
<span class="p_del">-#define fwnet_get_hdr_dg_size(h)	(((h)-&gt;w0 &amp; 0x0fff0000) &gt;&gt; 16)</span>
<span class="p_add">+#define fwnet_get_hdr_dg_size(h)	((((h)-&gt;w0 &amp; 0x0fff0000) &gt;&gt; 16) + 1)</span>
 #define fwnet_get_hdr_fg_off(h)		(((h)-&gt;w0 &amp; 0x00000fff))
 #define fwnet_get_hdr_dgl(h)		(((h)-&gt;w1 &amp; 0xffff0000) &gt;&gt; 16)
 
<span class="p_del">-#define fwnet_set_hdr_lf(lf)		((lf)  &lt;&lt; 30)</span>
<span class="p_add">+#define fwnet_set_hdr_lf(lf)		((lf) &lt;&lt; 30)</span>
 #define fwnet_set_hdr_ether_type(et)	(et)
<span class="p_del">-#define fwnet_set_hdr_dg_size(dgs)	((dgs) &lt;&lt; 16)</span>
<span class="p_add">+#define fwnet_set_hdr_dg_size(dgs)	(((dgs) - 1) &lt;&lt; 16)</span>
 #define fwnet_set_hdr_fg_off(fgo)	(fgo)
 
 #define fwnet_set_hdr_dgl(dgl)		((dgl) &lt;&lt; 16)
<span class="p_chunk">@@ -635,7 +635,7 @@</span> <span class="p_context"> static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,</span>
 		fg_off = fwnet_get_hdr_fg_off(&amp;hdr);
 	}
 	datagram_label = fwnet_get_hdr_dgl(&amp;hdr);
<span class="p_del">-	dg_size = fwnet_get_hdr_dg_size(&amp;hdr); /* ??? + 1 */</span>
<span class="p_add">+	dg_size = fwnet_get_hdr_dg_size(&amp;hdr);</span>
 
 	if (fg_off + len &gt; dg_size)
 		return 0;
<span class="p_header">diff --git a/drivers/gpio/gpio-mvebu.c b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">index a93ddbc1948e..5036cc77b4e3 100644</span>
<span class="p_header">--- a/drivers/gpio/gpio-mvebu.c</span>
<span class="p_header">+++ b/drivers/gpio/gpio-mvebu.c</span>
<span class="p_chunk">@@ -294,10 +294,10 @@</span> <span class="p_context"> static void mvebu_gpio_irq_ack(struct irq_data *d)</span>
 {
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
<span class="p_del">-	u32 mask = ~(1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base));</span>
<span class="p_add">+	u32 mask = d-&gt;mask;</span>
 
 	irq_gc_lock(gc);
<span class="p_del">-	writel_relaxed(mask, mvebu_gpioreg_edge_cause(mvchip));</span>
<span class="p_add">+	writel_relaxed(~mask, mvebu_gpioreg_edge_cause(mvchip));</span>
 	irq_gc_unlock(gc);
 }
 
<span class="p_chunk">@@ -306,7 +306,7 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_mask(struct irq_data *d)</span>
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
 	struct irq_chip_type *ct = irq_data_get_chip_type(d);
<span class="p_del">-	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);</span>
<span class="p_add">+	u32 mask = d-&gt;mask;</span>
 
 	irq_gc_lock(gc);
 	ct-&gt;mask_cache_priv &amp;= ~mask;
<span class="p_chunk">@@ -320,8 +320,7 @@</span> <span class="p_context"> static void mvebu_gpio_edge_irq_unmask(struct irq_data *d)</span>
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
 	struct irq_chip_type *ct = irq_data_get_chip_type(d);
<span class="p_del">-</span>
<span class="p_del">-	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);</span>
<span class="p_add">+	u32 mask = d-&gt;mask;</span>
 
 	irq_gc_lock(gc);
 	ct-&gt;mask_cache_priv |= mask;
<span class="p_chunk">@@ -334,8 +333,7 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_mask(struct irq_data *d)</span>
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
 	struct irq_chip_type *ct = irq_data_get_chip_type(d);
<span class="p_del">-</span>
<span class="p_del">-	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);</span>
<span class="p_add">+	u32 mask = d-&gt;mask;</span>
 
 	irq_gc_lock(gc);
 	ct-&gt;mask_cache_priv &amp;= ~mask;
<span class="p_chunk">@@ -348,8 +346,7 @@</span> <span class="p_context"> static void mvebu_gpio_level_irq_unmask(struct irq_data *d)</span>
 	struct irq_chip_generic *gc = irq_data_get_irq_chip_data(d);
 	struct mvebu_gpio_chip *mvchip = gc-&gt;private;
 	struct irq_chip_type *ct = irq_data_get_chip_type(d);
<span class="p_del">-</span>
<span class="p_del">-	u32 mask = 1 &lt;&lt; (d-&gt;irq - gc-&gt;irq_base);</span>
<span class="p_add">+	u32 mask = d-&gt;mask;</span>
 
 	irq_gc_lock(gc);
 	ct-&gt;mask_cache_priv |= mask;
<span class="p_chunk">@@ -464,7 +461,7 @@</span> <span class="p_context"> static void mvebu_gpio_irq_handler(unsigned int irq, struct irq_desc *desc)</span>
 	for (i = 0; i &lt; mvchip-&gt;chip.ngpio; i++) {
 		int irq;
 
<span class="p_del">-		irq = mvchip-&gt;irqbase + i;</span>
<span class="p_add">+		irq = irq_find_mapping(mvchip-&gt;domain, i);</span>
 
 		if (!(cause &amp; (1 &lt;&lt; i)))
 			continue;
<span class="p_chunk">@@ -572,8 +569,10 @@</span> <span class="p_context"> static int mvebu_gpio_probe(struct platform_device *pdev)</span>
 	struct irq_chip_type *ct;
 	struct clk *clk;
 	unsigned int ngpios;
<span class="p_add">+	bool have_irqs;</span>
 	int soc_variant;
 	int i, cpu, id;
<span class="p_add">+	int err;</span>
 
 	match = of_match_device(mvebu_gpio_of_match, &amp;pdev-&gt;dev);
 	if (match)
<span class="p_chunk">@@ -581,6 +580,9 @@</span> <span class="p_context"> static int mvebu_gpio_probe(struct platform_device *pdev)</span>
 	else
 		soc_variant = MVEBU_GPIO_SOC_VARIANT_ORION;
 
<span class="p_add">+	/* Some gpio controllers do not provide irq support */</span>
<span class="p_add">+	have_irqs = of_irq_count(np) != 0;</span>
<span class="p_add">+</span>
 	mvchip = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct mvebu_gpio_chip), GFP_KERNEL);
 	if (!mvchip)
 		return -ENOMEM;
<span class="p_chunk">@@ -610,7 +612,8 @@</span> <span class="p_context"> static int mvebu_gpio_probe(struct platform_device *pdev)</span>
 	mvchip-&gt;chip.get = mvebu_gpio_get;
 	mvchip-&gt;chip.direction_output = mvebu_gpio_direction_output;
 	mvchip-&gt;chip.set = mvebu_gpio_set;
<span class="p_del">-	mvchip-&gt;chip.to_irq = mvebu_gpio_to_irq;</span>
<span class="p_add">+	if (have_irqs)</span>
<span class="p_add">+		mvchip-&gt;chip.to_irq = mvebu_gpio_to_irq;</span>
 	mvchip-&gt;chip.base = id * MVEBU_MAX_GPIO_PER_BANK;
 	mvchip-&gt;chip.ngpio = ngpios;
 	mvchip-&gt;chip.can_sleep = false;
<span class="p_chunk">@@ -671,34 +674,30 @@</span> <span class="p_context"> static int mvebu_gpio_probe(struct platform_device *pdev)</span>
 	gpiochip_add(&amp;mvchip-&gt;chip);
 
 	/* Some gpio controllers do not provide irq support */
<span class="p_del">-	if (!of_irq_count(np))</span>
<span class="p_add">+	if (!have_irqs)</span>
 		return 0;
 
<span class="p_del">-	/* Setup the interrupt handlers. Each chip can have up to 4</span>
<span class="p_del">-	 * interrupt handlers, with each handler dealing with 8 GPIO</span>
<span class="p_del">-	 * pins. */</span>
<span class="p_del">-	for (i = 0; i &lt; 4; i++) {</span>
<span class="p_del">-		int irq;</span>
<span class="p_del">-		irq = platform_get_irq(pdev, i);</span>
<span class="p_del">-		if (irq &lt; 0)</span>
<span class="p_del">-			continue;</span>
<span class="p_del">-		irq_set_handler_data(irq, mvchip);</span>
<span class="p_del">-		irq_set_chained_handler(irq, mvebu_gpio_irq_handler);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	mvchip-&gt;irqbase = irq_alloc_descs(-1, 0, ngpios, -1);</span>
<span class="p_del">-	if (mvchip-&gt;irqbase &lt; 0) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;no irqs\n&quot;);</span>
<span class="p_del">-		return mvchip-&gt;irqbase;</span>
<span class="p_add">+	mvchip-&gt;domain =</span>
<span class="p_add">+	    irq_domain_add_linear(np, ngpios, &amp;irq_generic_chip_ops, NULL);</span>
<span class="p_add">+	if (!mvchip-&gt;domain) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;couldn&#39;t allocate irq domain %s (DT).\n&quot;,</span>
<span class="p_add">+			mvchip-&gt;chip.label);</span>
<span class="p_add">+		return -ENODEV;</span>
 	}
 
<span class="p_del">-	gc = irq_alloc_generic_chip(&quot;mvebu_gpio_irq&quot;, 2, mvchip-&gt;irqbase,</span>
<span class="p_del">-				    mvchip-&gt;membase, handle_level_irq);</span>
<span class="p_del">-	if (!gc) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;Cannot allocate generic irq_chip\n&quot;);</span>
<span class="p_del">-		return -ENOMEM;</span>
<span class="p_add">+	err = irq_alloc_domain_generic_chips(</span>
<span class="p_add">+	    mvchip-&gt;domain, ngpios, 2, np-&gt;name, handle_level_irq,</span>
<span class="p_add">+	    IRQ_NOREQUEST | IRQ_NOPROBE | IRQ_LEVEL, 0, 0);</span>
<span class="p_add">+	if (err) {</span>
<span class="p_add">+		dev_err(&amp;pdev-&gt;dev, &quot;couldn&#39;t allocate irq chips %s (DT).\n&quot;,</span>
<span class="p_add">+			mvchip-&gt;chip.label);</span>
<span class="p_add">+		goto err_domain;</span>
 	}
 
<span class="p_add">+	/* NOTE: The common accessors cannot be used because of the percpu</span>
<span class="p_add">+	 * access to the mask registers</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	gc = irq_get_domain_generic_chip(mvchip-&gt;domain, 0);</span>
 	gc-&gt;private = mvchip;
 	ct = &amp;gc-&gt;chip_types[0];
 	ct-&gt;type = IRQ_TYPE_LEVEL_HIGH | IRQ_TYPE_LEVEL_LOW;
<span class="p_chunk">@@ -716,24 +715,25 @@</span> <span class="p_context"> static int mvebu_gpio_probe(struct platform_device *pdev)</span>
 	ct-&gt;handler = handle_edge_irq;
 	ct-&gt;chip.name = mvchip-&gt;chip.label;
 
<span class="p_del">-	irq_setup_generic_chip(gc, IRQ_MSK(ngpios), 0,</span>
<span class="p_del">-			       IRQ_NOREQUEST, IRQ_LEVEL | IRQ_NOPROBE);</span>
<span class="p_add">+	/* Setup the interrupt handlers. Each chip can have up to 4</span>
<span class="p_add">+	 * interrupt handlers, with each handler dealing with 8 GPIO</span>
<span class="p_add">+	 * pins.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 0; i &lt; 4; i++) {</span>
<span class="p_add">+		int irq = platform_get_irq(pdev, i);</span>
 
<span class="p_del">-	/* Setup irq domain on top of the generic chip. */</span>
<span class="p_del">-	mvchip-&gt;domain = irq_domain_add_simple(np, mvchip-&gt;chip.ngpio,</span>
<span class="p_del">-					       mvchip-&gt;irqbase,</span>
<span class="p_del">-					       &amp;irq_domain_simple_ops,</span>
<span class="p_del">-					       mvchip);</span>
<span class="p_del">-	if (!mvchip-&gt;domain) {</span>
<span class="p_del">-		dev_err(&amp;pdev-&gt;dev, &quot;couldn&#39;t allocate irq domain %s (DT).\n&quot;,</span>
<span class="p_del">-			mvchip-&gt;chip.label);</span>
<span class="p_del">-		irq_remove_generic_chip(gc, IRQ_MSK(ngpios), IRQ_NOREQUEST,</span>
<span class="p_del">-					IRQ_LEVEL | IRQ_NOPROBE);</span>
<span class="p_del">-		kfree(gc);</span>
<span class="p_del">-		return -ENODEV;</span>
<span class="p_add">+		if (irq &lt; 0)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		irq_set_handler_data(irq, mvchip);</span>
<span class="p_add">+		irq_set_chained_handler(irq, mvebu_gpio_irq_handler);</span>
 	}
 
 	return 0;
<span class="p_add">+</span>
<span class="p_add">+err_domain:</span>
<span class="p_add">+	irq_domain_remove(mvchip-&gt;domain);</span>
<span class="p_add">+</span>
<span class="p_add">+	return err;</span>
 }
 
 static struct platform_driver mvebu_gpio_driver = {
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_crt.c b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">index 61183c1642b2..bb3a6209b245 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_crt.c</span>
<span class="p_chunk">@@ -742,11 +742,11 @@</span> <span class="p_context"> static int intel_crt_set_property(struct drm_connector *connector,</span>
 	return 0;
 }
 
<span class="p_del">-static void intel_crt_reset(struct drm_connector *connector)</span>
<span class="p_add">+void intel_crt_reset(struct drm_encoder *encoder)</span>
 {
<span class="p_del">-	struct drm_device *dev = connector-&gt;dev;</span>
<span class="p_add">+	struct drm_device *dev = encoder-&gt;dev;</span>
 	struct drm_i915_private *dev_priv = dev-&gt;dev_private;
<span class="p_del">-	struct intel_crt *crt = intel_attached_crt(connector);</span>
<span class="p_add">+	struct intel_crt *crt = intel_encoder_to_crt(to_intel_encoder(encoder));</span>
 
 	if (INTEL_INFO(dev)-&gt;gen &gt;= 5) {
 		u32 adpa;
<span class="p_chunk">@@ -768,7 +768,6 @@</span> <span class="p_context"> static void intel_crt_reset(struct drm_connector *connector)</span>
  */
 
 static const struct drm_connector_funcs intel_crt_connector_funcs = {
<span class="p_del">-	.reset = intel_crt_reset,</span>
 	.dpms = intel_crt_dpms,
 	.detect = intel_crt_detect,
 	.fill_modes = drm_helper_probe_single_connector_modes,
<span class="p_chunk">@@ -783,6 +782,7 @@</span> <span class="p_context"> static const struct drm_connector_helper_funcs intel_crt_connector_helper_funcs</span>
 };
 
 static const struct drm_encoder_funcs intel_crt_enc_funcs = {
<span class="p_add">+	.reset = intel_crt_reset,</span>
 	.destroy = intel_encoder_destroy,
 };
 
<span class="p_chunk">@@ -902,5 +902,5 @@</span> <span class="p_context"> void intel_crt_init(struct drm_device *dev)</span>
 		dev_priv-&gt;fdi_rx_config = I915_READ(_FDI_RXA_CTL) &amp; fdi_config;
 	}
 
<span class="p_del">-	intel_crt_reset(connector);</span>
<span class="p_add">+	intel_crt_reset(&amp;crt-&gt;base.base);</span>
 }
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_drv.h b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">index e0f88a0669c1..4a2dbcbf13f3 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_drv.h</span>
<span class="p_chunk">@@ -690,7 +690,7 @@</span> <span class="p_context"> void i9xx_check_fifo_underruns(struct drm_device *dev);</span>
 
 /* intel_crt.c */
 void intel_crt_init(struct drm_device *dev);
<span class="p_del">-</span>
<span class="p_add">+void intel_crt_reset(struct drm_encoder *encoder);</span>
 
 /* intel_ddi.c */
 void intel_prepare_ddi(struct drm_device *dev);
<span class="p_header">diff --git a/drivers/gpu/drm/i915/intel_pm.c b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">index 700a7d068204..5010e2c32c23 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/i915/intel_pm.c</span>
<span class="p_chunk">@@ -5897,6 +5897,8 @@</span> <span class="p_context"> static bool vlv_power_well_enabled(struct drm_i915_private *dev_priv,</span>
 static void vlv_display_power_well_enable(struct drm_i915_private *dev_priv,
 					  struct i915_power_well *power_well)
 {
<span class="p_add">+	struct intel_encoder *encoder;</span>
<span class="p_add">+</span>
 	WARN_ON_ONCE(power_well-&gt;data != PUNIT_POWER_WELL_DISP2D);
 
 	vlv_set_power_well(dev_priv, power_well, true);
<span class="p_chunk">@@ -5914,6 +5916,13 @@</span> <span class="p_context"> static void vlv_display_power_well_enable(struct drm_i915_private *dev_priv,</span>
 
 	intel_hpd_init(dev_priv-&gt;dev);
 
<span class="p_add">+	/* Re-enable the ADPA, if we have one */</span>
<span class="p_add">+	list_for_each_entry(encoder, &amp;dev_priv-&gt;dev-&gt;mode_config.encoder_list,</span>
<span class="p_add">+			    base.head) {</span>
<span class="p_add">+		if (encoder-&gt;type == INTEL_OUTPUT_ANALOG)</span>
<span class="p_add">+			intel_crt_reset(&amp;encoder-&gt;base);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	i915_redisable_vga_power_on(dev_priv-&gt;dev);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/ni.c b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">index 41ddc14bfab3..2ecbf2e98424 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/ni.c</span>
<span class="p_chunk">@@ -1333,9 +1333,7 @@</span> <span class="p_context"> static void cayman_pcie_gart_fini(struct radeon_device *rdev)</span>
 void cayman_cp_int_cntl_setup(struct radeon_device *rdev,
 			      int ring, u32 cp_int_cntl)
 {
<span class="p_del">-	u32 srbm_gfx_cntl = RREG32(SRBM_GFX_CNTL) &amp; ~3;</span>
<span class="p_del">-</span>
<span class="p_del">-	WREG32(SRBM_GFX_CNTL, srbm_gfx_cntl | (ring &amp; 3));</span>
<span class="p_add">+	WREG32(SRBM_GFX_CNTL, RINGID(ring));</span>
 	WREG32(CP_INT_CNTL, cp_int_cntl);
 }
 
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/r600_dpm.c b/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_header">index 8eab0d20edad..a962147d6ec7 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/r600_dpm.c</span>
<span class="p_chunk">@@ -155,19 +155,20 @@</span> <span class="p_context"> u32 r600_dpm_get_vblank_time(struct radeon_device *rdev)</span>
 	struct drm_device *dev = rdev-&gt;ddev;
 	struct drm_crtc *crtc;
 	struct radeon_crtc *radeon_crtc;
<span class="p_del">-	u32 line_time_us, vblank_lines;</span>
<span class="p_add">+	u32 vblank_in_pixels;</span>
 	u32 vblank_time_us = 0xffffffff; /* if the displays are off, vblank time is max */
 
 	if (rdev-&gt;num_crtc &amp;&amp; rdev-&gt;mode_info.mode_config_initialized) {
 		list_for_each_entry(crtc, &amp;dev-&gt;mode_config.crtc_list, head) {
 			radeon_crtc = to_radeon_crtc(crtc);
 			if (crtc-&gt;enabled &amp;&amp; radeon_crtc-&gt;enabled &amp;&amp; radeon_crtc-&gt;hw_mode.clock) {
<span class="p_del">-				line_time_us = (radeon_crtc-&gt;hw_mode.crtc_htotal * 1000) /</span>
<span class="p_del">-					radeon_crtc-&gt;hw_mode.clock;</span>
<span class="p_del">-				vblank_lines = radeon_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_del">-					radeon_crtc-&gt;hw_mode.crtc_vdisplay +</span>
<span class="p_del">-					(radeon_crtc-&gt;v_border * 2);</span>
<span class="p_del">-				vblank_time_us = vblank_lines * line_time_us;</span>
<span class="p_add">+				vblank_in_pixels =</span>
<span class="p_add">+					radeon_crtc-&gt;hw_mode.crtc_htotal *</span>
<span class="p_add">+					(radeon_crtc-&gt;hw_mode.crtc_vblank_end -</span>
<span class="p_add">+					 radeon_crtc-&gt;hw_mode.crtc_vdisplay +</span>
<span class="p_add">+					 (radeon_crtc-&gt;v_border * 2));</span>
<span class="p_add">+</span>
<span class="p_add">+				vblank_time_us = vblank_in_pixels * 1000 / radeon_crtc-&gt;hw_mode.clock;</span>
 				break;
 			}
 		}
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">index 7a7a4af75630..93324c9ddfc6 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/radeon_device.c</span>
<span class="p_chunk">@@ -629,8 +629,9 @@</span> <span class="p_context"> bool radeon_card_posted(struct radeon_device *rdev)</span>
 {
 	uint32_t reg;
 
<span class="p_del">-	/* for pass through, always force asic_init */</span>
<span class="p_del">-	if (radeon_device_is_virtual())</span>
<span class="p_add">+	/* for pass through, always force asic_init for CI */</span>
<span class="p_add">+	if (rdev-&gt;family &gt;= CHIP_BONAIRE &amp;&amp;</span>
<span class="p_add">+	    radeon_device_is_virtual())</span>
 		return false;
 
 	/* required for EFI mode on macbook2,1 which uses an r5xx asic */
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/si_dpm.c b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">index 12527d69877c..c9b290b5b52b 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/si_dpm.c</span>
<span class="p_chunk">@@ -2944,6 +2944,49 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 	int i;
 	struct si_dpm_quirk *p = si_dpm_quirk_list;
 
<span class="p_add">+	/* limit all SI kickers */</span>
<span class="p_add">+	if (rdev-&gt;family == CHIP_PITCAIRN) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6810) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6811) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6816) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6817) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6806))</span>
<span class="p_add">+			max_mclk = 120000;</span>
<span class="p_add">+	} else if (rdev-&gt;family == CHIP_VERDE) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x87) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6820) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6821) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6822) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6823) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x682A) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x682B)) {</span>
<span class="p_add">+			max_sclk = 75000;</span>
<span class="p_add">+			max_mclk = 80000;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (rdev-&gt;family == CHIP_OLAND) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0xC7) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x80) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6604) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6605)) {</span>
<span class="p_add">+			max_sclk = 75000;</span>
<span class="p_add">+			max_mclk = 80000;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	} else if (rdev-&gt;family == CHIP_HAINAN) {</span>
<span class="p_add">+		if ((rdev-&gt;pdev-&gt;revision == 0x81) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0x83) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;revision == 0xC3) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6664) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6665) ||</span>
<span class="p_add">+		    (rdev-&gt;pdev-&gt;device == 0x6667)) {</span>
<span class="p_add">+			max_sclk = 75000;</span>
<span class="p_add">+			max_mclk = 80000;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 	/* Apply dpm quirks */
 	while (p &amp;&amp; p-&gt;chip_device != 0) {
 		if (rdev-&gt;pdev-&gt;vendor == p-&gt;chip_vendor &amp;&amp;
<span class="p_chunk">@@ -3018,16 +3061,6 @@</span> <span class="p_context"> static void si_apply_state_adjust_rules(struct radeon_device *rdev,</span>
 				ps-&gt;performance_levels[i].sclk = max_sclk;
 		}
 	}
<span class="p_del">-	/* limit mclk on all R7 370 parts for stability */</span>
<span class="p_del">-	if (rdev-&gt;pdev-&gt;device == 0x6811 &amp;&amp;</span>
<span class="p_del">-	    rdev-&gt;pdev-&gt;revision == 0x81)</span>
<span class="p_del">-		max_mclk = 120000;</span>
<span class="p_del">-	/* limit sclk/mclk on Jet parts for stability */</span>
<span class="p_del">-	if (rdev-&gt;pdev-&gt;device == 0x6665 &amp;&amp;</span>
<span class="p_del">-	    rdev-&gt;pdev-&gt;revision == 0xc3) {</span>
<span class="p_del">-		max_sclk = 75000;</span>
<span class="p_del">-		max_mclk = 80000;</span>
<span class="p_del">-	}</span>
 
 	/* XXX validate the min clocks required for display */
 
<span class="p_chunk">@@ -3982,7 +4015,7 @@</span> <span class="p_context"> static int si_populate_smc_voltage_tables(struct radeon_device *rdev,</span>
 						      &amp;rdev-&gt;pm.dpm.dyn_state.phase_shedding_limits_table)) {
 			si_populate_smc_voltage_table(rdev, &amp;si_pi-&gt;vddc_phase_shed_table, table);
 
<span class="p_del">-			table-&gt;phaseMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC] =</span>
<span class="p_add">+			table-&gt;phaseMaskTable.lowMask[SISLANDS_SMC_VOLTAGEMASK_VDDC_PHASE_SHEDDING] =</span>
 				cpu_to_be32(si_pi-&gt;vddc_phase_shed_table.mask_low);
 
 			si_write_smc_soft_register(rdev, SI_SMC_SOFT_REGISTER_phase_shedding_delay,
<span class="p_header">diff --git a/drivers/gpu/drm/radeon/sislands_smc.h b/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_header">index 10e945a49479..3de716b4d272 100644</span>
<span class="p_header">--- a/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_header">+++ b/drivers/gpu/drm/radeon/sislands_smc.h</span>
<span class="p_chunk">@@ -194,6 +194,7 @@</span> <span class="p_context"> typedef struct SISLANDS_SMC_SWSTATE SISLANDS_SMC_SWSTATE;</span>
 #define SISLANDS_SMC_VOLTAGEMASK_VDDC  0
 #define SISLANDS_SMC_VOLTAGEMASK_MVDD  1
 #define SISLANDS_SMC_VOLTAGEMASK_VDDCI 2
<span class="p_add">+#define SISLANDS_SMC_VOLTAGEMASK_VDDC_PHASE_SHEDDING 3</span>
 #define SISLANDS_SMC_VOLTAGEMASK_MAX   4
 
 struct SISLANDS_SMC_VOLTAGEMASKTABLE
<span class="p_header">diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c</span>
<span class="p_header">index 8c373cde051c..831c834c2d82 100644</span>
<span class="p_header">--- a/drivers/hid/hid-core.c</span>
<span class="p_header">+++ b/drivers/hid/hid-core.c</span>
<span class="p_chunk">@@ -1208,6 +1208,7 @@</span> <span class="p_context"> static void hid_input_field(struct hid_device *hid, struct hid_field *field,</span>
 		/* Ignore report if ErrorRollOver */
 		if (!(field-&gt;flags &amp; HID_MAIN_ITEM_VARIABLE) &amp;&amp;
 		    value[n] &gt;= min &amp;&amp; value[n] &lt;= max &amp;&amp;
<span class="p_add">+		    value[n] - min &lt; field-&gt;maxusage &amp;&amp;</span>
 		    field-&gt;usage[value[n] - min].hid == HID_UP_KEYBOARD + 1)
 			goto exit;
 	}
<span class="p_chunk">@@ -1220,11 +1221,13 @@</span> <span class="p_context"> static void hid_input_field(struct hid_device *hid, struct hid_field *field,</span>
 		}
 
 		if (field-&gt;value[n] &gt;= min &amp;&amp; field-&gt;value[n] &lt;= max
<span class="p_add">+			&amp;&amp; field-&gt;value[n] - min &lt; field-&gt;maxusage</span>
 			&amp;&amp; field-&gt;usage[field-&gt;value[n] - min].hid
 			&amp;&amp; search(value, field-&gt;value[n], count))
 				hid_process_event(hid, field, &amp;field-&gt;usage[field-&gt;value[n] - min], 0, interrupt);
 
 		if (value[n] &gt;= min &amp;&amp; value[n] &lt;= max
<span class="p_add">+			&amp;&amp; value[n] - min &lt; field-&gt;maxusage</span>
 			&amp;&amp; field-&gt;usage[value[n] - min].hid
 			&amp;&amp; search(field-&gt;value, value[n], count))
 				hid_process_event(hid, field, &amp;field-&gt;usage[value[n] - min], 1, interrupt);
<span class="p_header">diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h</span>
<span class="p_header">index 2c04d93cacbd..6a56997d89ed 100644</span>
<span class="p_header">--- a/drivers/hid/hid-ids.h</span>
<span class="p_header">+++ b/drivers/hid/hid-ids.h</span>
<span class="p_chunk">@@ -164,6 +164,8 @@</span> <span class="p_context"></span>
 #define USB_DEVICE_ID_ATEN_2PORTKVM	0x2204
 #define USB_DEVICE_ID_ATEN_4PORTKVM	0x2205
 #define USB_DEVICE_ID_ATEN_4PORTKVMC	0x2208
<span class="p_add">+#define USB_DEVICE_ID_ATEN_CS682	0x2213</span>
<span class="p_add">+#define USB_DEVICE_ID_ATEN_CS692	0x8021</span>
 
 #define USB_VENDOR_ID_ATMEL		0x03eb
 #define USB_DEVICE_ID_ATMEL_MULTITOUCH	0x211c
<span class="p_header">diff --git a/drivers/hid/usbhid/hid-quirks.c b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">index 6579a71095da..c597571b0474 100644</span>
<span class="p_header">--- a/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_header">+++ b/drivers/hid/usbhid/hid-quirks.c</span>
<span class="p_chunk">@@ -61,6 +61,8 @@</span> <span class="p_context"> static const struct hid_blacklist {</span>
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_2PORTKVM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVM, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_4PORTKVMC, HID_QUIRK_NOGET },
<span class="p_add">+	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS682, HID_QUIRK_NOGET },</span>
<span class="p_add">+	{ USB_VENDOR_ID_ATEN, USB_DEVICE_ID_ATEN_CS692, HID_QUIRK_NOGET },</span>
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_FIGHTERSTICK, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_COMBATSTICK, HID_QUIRK_NOGET },
 	{ USB_VENDOR_ID_CH, USB_DEVICE_ID_CH_FLIGHT_SIM_ECLIPSE_YOKE, HID_QUIRK_NOGET },
<span class="p_header">diff --git a/drivers/hv/hv_util.c b/drivers/hv/hv_util.c</span>
<span class="p_header">index 3b9c9ef0deb8..2d1414d07305 100644</span>
<span class="p_header">--- a/drivers/hv/hv_util.c</span>
<span class="p_header">+++ b/drivers/hv/hv_util.c</span>
<span class="p_chunk">@@ -283,10 +283,14 @@</span> <span class="p_context"> static void heartbeat_onchannelcallback(void *context)</span>
 	u8 *hbeat_txf_buf = util_heartbeat.recv_buffer;
 	struct icmsg_negotiate *negop = NULL;
 
<span class="p_del">-	vmbus_recvpacket(channel, hbeat_txf_buf,</span>
<span class="p_del">-			 PAGE_SIZE, &amp;recvlen, &amp;requestid);</span>
<span class="p_add">+	while (1) {</span>
<span class="p_add">+</span>
<span class="p_add">+		vmbus_recvpacket(channel, hbeat_txf_buf,</span>
<span class="p_add">+				 PAGE_SIZE, &amp;recvlen, &amp;requestid);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!recvlen)</span>
<span class="p_add">+			break;</span>
 
<span class="p_del">-	if (recvlen &gt; 0) {</span>
 		icmsghdrp = (struct icmsg_hdr *)&amp;hbeat_txf_buf[
 				sizeof(struct vmbuspipe_hdr)];
 
<span class="p_header">diff --git a/drivers/i2c/i2c-core.c b/drivers/i2c/i2c-core.c</span>
<span class="p_header">index d66af95d3de4..35c0bc6f2eb3 100644</span>
<span class="p_header">--- a/drivers/i2c/i2c-core.c</span>
<span class="p_header">+++ b/drivers/i2c/i2c-core.c</span>
<span class="p_chunk">@@ -1558,6 +1558,7 @@</span> <span class="p_context"> int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span>
 	/* add the driver to the list of i2c drivers in the driver core */
 	driver-&gt;driver.owner = owner;
 	driver-&gt;driver.bus = &amp;i2c_bus_type;
<span class="p_add">+	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span>
 
 	/* When registration returns, the driver core
 	 * will have called probe() for all matching-but-unbound devices.
<span class="p_chunk">@@ -1576,7 +1577,6 @@</span> <span class="p_context"> int i2c_register_driver(struct module *owner, struct i2c_driver *driver)</span>
 
 	pr_debug(&quot;i2c-core: driver [%s] registered\n&quot;, driver-&gt;driver.name);
 
<span class="p_del">-	INIT_LIST_HEAD(&amp;driver-&gt;clients);</span>
 	/* Walk the adapters that are already present */
 	i2c_for_each_dev(driver, __process_new_driver);
 
<span class="p_header">diff --git a/drivers/iio/common/hid-sensors/hid-sensor-attributes.c b/drivers/iio/common/hid-sensors/hid-sensor-attributes.c</span>
<span class="p_header">index b321a253eba8..bd4b6e02a1cb 100644</span>
<span class="p_header">--- a/drivers/iio/common/hid-sensors/hid-sensor-attributes.c</span>
<span class="p_header">+++ b/drivers/iio/common/hid-sensors/hid-sensor-attributes.c</span>
<span class="p_chunk">@@ -26,30 +26,30 @@</span> <span class="p_context"></span>
 #include &lt;linux/iio/iio.h&gt;
 #include &lt;linux/iio/sysfs.h&gt;
 
<span class="p_del">-struct {</span>
<span class="p_add">+static struct {</span>
 	u32 usage_id;
 	int unit; /* 0 for default others from HID sensor spec */
 	int scale_val0; /* scale, whole number */
<span class="p_del">-	int scale_val1; /* scale, fraction in micros */</span>
<span class="p_del">-} static unit_conversion[] = {</span>
<span class="p_del">-	{HID_USAGE_SENSOR_ACCEL_3D, 0, 9, 806650},</span>
<span class="p_add">+	int scale_val1; /* scale, fraction in nanos */</span>
<span class="p_add">+} unit_conversion[] = {</span>
<span class="p_add">+	{HID_USAGE_SENSOR_ACCEL_3D, 0, 9, 806650000},</span>
 	{HID_USAGE_SENSOR_ACCEL_3D,
 		HID_USAGE_SENSOR_UNITS_METERS_PER_SEC_SQRD, 1, 0},
 	{HID_USAGE_SENSOR_ACCEL_3D,
<span class="p_del">-		HID_USAGE_SENSOR_UNITS_G, 9, 806650},</span>
<span class="p_add">+		HID_USAGE_SENSOR_UNITS_G, 9, 806650000},</span>
 
<span class="p_del">-	{HID_USAGE_SENSOR_GYRO_3D, 0, 0, 17453},</span>
<span class="p_add">+	{HID_USAGE_SENSOR_GYRO_3D, 0, 0, 17453293},</span>
 	{HID_USAGE_SENSOR_GYRO_3D,
 		HID_USAGE_SENSOR_UNITS_RADIANS_PER_SECOND, 1, 0},
 	{HID_USAGE_SENSOR_GYRO_3D,
<span class="p_del">-		HID_USAGE_SENSOR_UNITS_DEGREES_PER_SECOND, 0, 17453},</span>
<span class="p_add">+		HID_USAGE_SENSOR_UNITS_DEGREES_PER_SECOND, 0, 17453293},</span>
 
<span class="p_del">-	{HID_USAGE_SENSOR_COMPASS_3D, 0, 0, 1000},</span>
<span class="p_add">+	{HID_USAGE_SENSOR_COMPASS_3D, 0, 0, 1000000},</span>
 	{HID_USAGE_SENSOR_COMPASS_3D, HID_USAGE_SENSOR_UNITS_GAUSS, 1, 0},
 
<span class="p_del">-	{HID_USAGE_SENSOR_INCLINOMETER_3D, 0, 0, 17453},</span>
<span class="p_add">+	{HID_USAGE_SENSOR_INCLINOMETER_3D, 0, 0, 17453293},</span>
 	{HID_USAGE_SENSOR_INCLINOMETER_3D,
<span class="p_del">-		HID_USAGE_SENSOR_UNITS_DEGREES, 0, 17453},</span>
<span class="p_add">+		HID_USAGE_SENSOR_UNITS_DEGREES, 0, 17453293},</span>
 	{HID_USAGE_SENSOR_INCLINOMETER_3D,
 		HID_USAGE_SENSOR_UNITS_RADIANS, 1, 0},
 
<span class="p_chunk">@@ -57,7 +57,7 @@</span> <span class="p_context"> struct {</span>
 	{HID_USAGE_SENSOR_ALS, HID_USAGE_SENSOR_UNITS_LUX, 1, 0},
 
 	{HID_USAGE_SENSOR_PRESSURE, 0, 100, 0},
<span class="p_del">-	{HID_USAGE_SENSOR_PRESSURE, HID_USAGE_SENSOR_UNITS_PASCAL, 0, 1000},</span>
<span class="p_add">+	{HID_USAGE_SENSOR_PRESSURE, HID_USAGE_SENSOR_UNITS_PASCAL, 0, 1000000},</span>
 };
 
 static int pow_10(unsigned power)
<span class="p_chunk">@@ -266,15 +266,15 @@</span> <span class="p_context"> EXPORT_SYMBOL(hid_sensor_write_raw_hyst_value);</span>
 /*
  * This fuction applies the unit exponent to the scale.
  * For example:
<span class="p_del">- * 9.806650 -&gt;exp:2-&gt; val0[980]val1[665000]</span>
<span class="p_del">- * 9.000806 -&gt;exp:2-&gt; val0[900]val1[80600]</span>
<span class="p_del">- * 0.174535 -&gt;exp:2-&gt; val0[17]val1[453500]</span>
<span class="p_del">- * 1.001745 -&gt;exp:0-&gt; val0[1]val1[1745]</span>
<span class="p_del">- * 1.001745 -&gt;exp:2-&gt; val0[100]val1[174500]</span>
<span class="p_del">- * 1.001745 -&gt;exp:4-&gt; val0[10017]val1[450000]</span>
<span class="p_del">- * 9.806650 -&gt;exp:-2-&gt; val0[0]val1[98066]</span>
<span class="p_add">+ * 9.806650000 -&gt;exp:2-&gt; val0[980]val1[665000000]</span>
<span class="p_add">+ * 9.000806000 -&gt;exp:2-&gt; val0[900]val1[80600000]</span>
<span class="p_add">+ * 0.174535293 -&gt;exp:2-&gt; val0[17]val1[453529300]</span>
<span class="p_add">+ * 1.001745329 -&gt;exp:0-&gt; val0[1]val1[1745329]</span>
<span class="p_add">+ * 1.001745329 -&gt;exp:2-&gt; val0[100]val1[174532900]</span>
<span class="p_add">+ * 1.001745329 -&gt;exp:4-&gt; val0[10017]val1[453290000]</span>
<span class="p_add">+ * 9.806650000 -&gt;exp:-2-&gt; val0[0]val1[98066500]</span>
  */
<span class="p_del">-static void adjust_exponent_micro(int *val0, int *val1, int scale0,</span>
<span class="p_add">+static void adjust_exponent_nano(int *val0, int *val1, int scale0,</span>
 				  int scale1, int exp)
 {
 	int i;
<span class="p_chunk">@@ -285,32 +285,32 @@</span> <span class="p_context"> static void adjust_exponent_micro(int *val0, int *val1, int scale0,</span>
 	if (exp &gt; 0) {
 		*val0 = scale0 * pow_10(exp);
 		res = 0;
<span class="p_del">-		if (exp &gt; 6) {</span>
<span class="p_add">+		if (exp &gt; 9) {</span>
 			*val1 = 0;
 			return;
 		}
 		for (i = 0; i &lt; exp; ++i) {
<span class="p_del">-			x = scale1 / pow_10(5 - i);</span>
<span class="p_add">+			x = scale1 / pow_10(8 - i);</span>
 			res += (pow_10(exp - 1 - i) * x);
<span class="p_del">-			scale1 = scale1 % pow_10(5 - i);</span>
<span class="p_add">+			scale1 = scale1 % pow_10(8 - i);</span>
 		}
 		*val0 += res;
 			*val1 = scale1 * pow_10(exp);
 	} else if (exp &lt; 0) {
 		exp = abs(exp);
<span class="p_del">-		if (exp &gt; 6) {</span>
<span class="p_add">+		if (exp &gt; 9) {</span>
 			*val0 = *val1 = 0;
 			return;
 		}
 		*val0 = scale0 / pow_10(exp);
 		rem = scale0 % pow_10(exp);
 		res = 0;
<span class="p_del">-		for (i = 0; i &lt; (6 - exp); ++i) {</span>
<span class="p_del">-			x = scale1 / pow_10(5 - i);</span>
<span class="p_del">-			res += (pow_10(5 - exp - i) * x);</span>
<span class="p_del">-			scale1 = scale1 % pow_10(5 - i);</span>
<span class="p_add">+		for (i = 0; i &lt; (9 - exp); ++i) {</span>
<span class="p_add">+			x = scale1 / pow_10(8 - i);</span>
<span class="p_add">+			res += (pow_10(8 - exp - i) * x);</span>
<span class="p_add">+			scale1 = scale1 % pow_10(8 - i);</span>
 		}
<span class="p_del">-		*val1 = rem * pow_10(6 - exp) + res;</span>
<span class="p_add">+		*val1 = rem * pow_10(9 - exp) + res;</span>
 	} else {
 		*val0 = scale0;
 		*val1 = scale1;
<span class="p_chunk">@@ -332,14 +332,14 @@</span> <span class="p_context"> int hid_sensor_format_scale(u32 usage_id,</span>
 			unit_conversion[i].unit == attr_info-&gt;units) {
 			exp  = hid_sensor_convert_exponent(
 						attr_info-&gt;unit_expo);
<span class="p_del">-			adjust_exponent_micro(val0, val1,</span>
<span class="p_add">+			adjust_exponent_nano(val0, val1,</span>
 					unit_conversion[i].scale_val0,
 					unit_conversion[i].scale_val1, exp);
 			break;
 		}
 	}
 
<span class="p_del">-	return IIO_VAL_INT_PLUS_MICRO;</span>
<span class="p_add">+	return IIO_VAL_INT_PLUS_NANO;</span>
 }
 EXPORT_SYMBOL(hid_sensor_format_scale);
 
<span class="p_header">diff --git a/drivers/infiniband/core/cm.c b/drivers/infiniband/core/cm.c</span>
<span class="p_header">index 5311cac12132..1cf32b827806 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/cm.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/cm.c</span>
<span class="p_chunk">@@ -80,6 +80,8 @@</span> <span class="p_context"> static struct ib_cm {</span>
 	__be32 random_id_operand;
 	struct list_head timewait_list;
 	struct workqueue_struct *wq;
<span class="p_add">+	/* Sync on cm change port state */</span>
<span class="p_add">+	spinlock_t state_lock;</span>
 } cm;
 
 /* Counter indexes ordered by attribute ID */
<span class="p_chunk">@@ -161,6 +163,8 @@</span> <span class="p_context"> struct cm_port {</span>
 	struct ib_mad_agent *mad_agent;
 	struct kobject port_obj;
 	u8 port_num;
<span class="p_add">+	struct list_head cm_priv_prim_list;</span>
<span class="p_add">+	struct list_head cm_priv_altr_list;</span>
 	struct cm_counter_group counter_group[CM_COUNTER_GROUPS];
 };
 
<span class="p_chunk">@@ -240,6 +244,12 @@</span> <span class="p_context"> struct cm_id_private {</span>
 	u8 service_timeout;
 	u8 target_ack_delay;
 
<span class="p_add">+	struct list_head prim_list;</span>
<span class="p_add">+	struct list_head altr_list;</span>
<span class="p_add">+	/* Indicates that the send port mad is registered and av is set */</span>
<span class="p_add">+	int prim_send_port_not_ready;</span>
<span class="p_add">+	int altr_send_port_not_ready;</span>
<span class="p_add">+</span>
 	struct list_head work_list;
 	atomic_t work_count;
 };
<span class="p_chunk">@@ -258,19 +268,46 @@</span> <span class="p_context"> static int cm_alloc_msg(struct cm_id_private *cm_id_priv,</span>
 	struct ib_mad_agent *mad_agent;
 	struct ib_mad_send_buf *m;
 	struct ib_ah *ah;
<span class="p_add">+	struct cm_av *av;</span>
<span class="p_add">+	unsigned long flags, flags2;</span>
<span class="p_add">+	int ret = 0;</span>
 
<span class="p_add">+	/* don&#39;t let the port to be released till the agent is down */</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cm.state_lock, flags2);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cm.lock, flags);</span>
<span class="p_add">+	if (!cm_id_priv-&gt;prim_send_port_not_ready)</span>
<span class="p_add">+		av = &amp;cm_id_priv-&gt;av;</span>
<span class="p_add">+	else if (!cm_id_priv-&gt;altr_send_port_not_ready &amp;&amp;</span>
<span class="p_add">+		 (cm_id_priv-&gt;alt_av.port))</span>
<span class="p_add">+		av = &amp;cm_id_priv-&gt;alt_av;</span>
<span class="p_add">+	else {</span>
<span class="p_add">+		pr_info(&quot;%s: not valid CM id\n&quot;, __func__);</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		spin_unlock_irqrestore(&amp;cm.lock, flags);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cm.lock, flags);</span>
<span class="p_add">+	/* Make sure the port haven&#39;t released the mad yet */</span>
 	mad_agent = cm_id_priv-&gt;av.port-&gt;mad_agent;
<span class="p_del">-	ah = ib_create_ah(mad_agent-&gt;qp-&gt;pd, &amp;cm_id_priv-&gt;av.ah_attr);</span>
<span class="p_del">-	if (IS_ERR(ah))</span>
<span class="p_del">-		return PTR_ERR(ah);</span>
<span class="p_add">+	if (!mad_agent) {</span>
<span class="p_add">+		pr_info(&quot;%s: not a valid MAD agent\n&quot;, __func__);</span>
<span class="p_add">+		ret = -ENODEV;</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	ah = ib_create_ah(mad_agent-&gt;qp-&gt;pd, &amp;av-&gt;ah_attr);</span>
<span class="p_add">+	if (IS_ERR(ah)) {</span>
<span class="p_add">+		ret = PTR_ERR(ah);</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	}</span>
 
 	m = ib_create_send_mad(mad_agent, cm_id_priv-&gt;id.remote_cm_qpn,
<span class="p_del">-			       cm_id_priv-&gt;av.pkey_index,</span>
<span class="p_add">+			       av-&gt;pkey_index,</span>
 			       0, IB_MGMT_MAD_HDR, IB_MGMT_MAD_DATA,
 			       GFP_ATOMIC);
 	if (IS_ERR(m)) {
 		ib_destroy_ah(ah);
<span class="p_del">-		return PTR_ERR(m);</span>
<span class="p_add">+		ret = PTR_ERR(m);</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	/* Timeout set by caller if response is expected. */
<span class="p_chunk">@@ -280,7 +317,10 @@</span> <span class="p_context"> static int cm_alloc_msg(struct cm_id_private *cm_id_priv,</span>
 	atomic_inc(&amp;cm_id_priv-&gt;refcount);
 	m-&gt;context[0] = cm_id_priv;
 	*msg = m;
<span class="p_del">-	return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+out:</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cm.state_lock, flags2);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int cm_alloc_response_msg(struct cm_port *port,
<span class="p_chunk">@@ -349,7 +389,8 @@</span> <span class="p_context"> static void cm_init_av_for_response(struct cm_port *port, struct ib_wc *wc,</span>
 			   grh, &amp;av-&gt;ah_attr);
 }
 
<span class="p_del">-static int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av)</span>
<span class="p_add">+static int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av,</span>
<span class="p_add">+			      struct cm_id_private *cm_id_priv)</span>
 {
 	struct cm_device *cm_dev;
 	struct cm_port *port = NULL;
<span class="p_chunk">@@ -382,7 +423,17 @@</span> <span class="p_context"> static int cm_init_av_by_path(struct ib_sa_path_rec *path, struct cm_av *av)</span>
 	memcpy(av-&gt;smac, path-&gt;smac, sizeof(av-&gt;smac));
 
 	av-&gt;valid = 1;
<span class="p_del">-	return 0;</span>
<span class="p_add">+	spin_lock_irqsave(&amp;cm.lock, flags);</span>
<span class="p_add">+	if (&amp;cm_id_priv-&gt;av == av)</span>
<span class="p_add">+		list_add_tail(&amp;cm_id_priv-&gt;prim_list, &amp;port-&gt;cm_priv_prim_list);</span>
<span class="p_add">+	else if (&amp;cm_id_priv-&gt;alt_av == av)</span>
<span class="p_add">+		list_add_tail(&amp;cm_id_priv-&gt;altr_list, &amp;port-&gt;cm_priv_altr_list);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;cm.lock, flags);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int cm_alloc_id(struct cm_id_private *cm_id_priv)
<span class="p_chunk">@@ -719,6 +770,8 @@</span> <span class="p_context"> struct ib_cm_id *ib_create_cm_id(struct ib_device *device,</span>
 	spin_lock_init(&amp;cm_id_priv-&gt;lock);
 	init_completion(&amp;cm_id_priv-&gt;comp);
 	INIT_LIST_HEAD(&amp;cm_id_priv-&gt;work_list);
<span class="p_add">+	INIT_LIST_HEAD(&amp;cm_id_priv-&gt;prim_list);</span>
<span class="p_add">+	INIT_LIST_HEAD(&amp;cm_id_priv-&gt;altr_list);</span>
 	atomic_set(&amp;cm_id_priv-&gt;work_count, -1);
 	atomic_set(&amp;cm_id_priv-&gt;refcount, 1);
 	return &amp;cm_id_priv-&gt;id;
<span class="p_chunk">@@ -917,6 +970,15 @@</span> <span class="p_context"> retest:</span>
 		break;
 	}
 
<span class="p_add">+	spin_lock_irq(&amp;cm.lock);</span>
<span class="p_add">+	if (!list_empty(&amp;cm_id_priv-&gt;altr_list) &amp;&amp;</span>
<span class="p_add">+	    (!cm_id_priv-&gt;altr_send_port_not_ready))</span>
<span class="p_add">+		list_del(&amp;cm_id_priv-&gt;altr_list);</span>
<span class="p_add">+	if (!list_empty(&amp;cm_id_priv-&gt;prim_list) &amp;&amp;</span>
<span class="p_add">+	    (!cm_id_priv-&gt;prim_send_port_not_ready))</span>
<span class="p_add">+		list_del(&amp;cm_id_priv-&gt;prim_list);</span>
<span class="p_add">+	spin_unlock_irq(&amp;cm.lock);</span>
<span class="p_add">+</span>
 	cm_free_id(cm_id-&gt;local_id);
 	cm_deref_id(cm_id_priv);
 	wait_for_completion(&amp;cm_id_priv-&gt;comp);
<span class="p_chunk">@@ -1140,12 +1202,13 @@</span> <span class="p_context"> int ib_send_cm_req(struct ib_cm_id *cm_id,</span>
 		goto out;
 	}
 
<span class="p_del">-	ret = cm_init_av_by_path(param-&gt;primary_path, &amp;cm_id_priv-&gt;av);</span>
<span class="p_add">+	ret = cm_init_av_by_path(param-&gt;primary_path, &amp;cm_id_priv-&gt;av,</span>
<span class="p_add">+				 cm_id_priv);</span>
 	if (ret)
 		goto error1;
 	if (param-&gt;alternate_path) {
 		ret = cm_init_av_by_path(param-&gt;alternate_path,
<span class="p_del">-					 &amp;cm_id_priv-&gt;alt_av);</span>
<span class="p_add">+					 &amp;cm_id_priv-&gt;alt_av, cm_id_priv);</span>
 		if (ret)
 			goto error1;
 	}
<span class="p_chunk">@@ -1568,7 +1631,7 @@</span> <span class="p_context"> static int cm_req_handler(struct cm_work *work)</span>
 
 	memcpy(work-&gt;path[0].dmac, cm_id_priv-&gt;av.ah_attr.dmac, ETH_ALEN);
 	work-&gt;path[0].vlan_id = cm_id_priv-&gt;av.ah_attr.vlan_id;
<span class="p_del">-	ret = cm_init_av_by_path(&amp;work-&gt;path[0], &amp;cm_id_priv-&gt;av);</span>
<span class="p_add">+	ret = cm_init_av_by_path(&amp;work-&gt;path[0], &amp;cm_id_priv-&gt;av, cm_id_priv);</span>
 	if (ret) {
 		ib_get_cached_gid(work-&gt;port-&gt;cm_dev-&gt;ib_device,
 				  work-&gt;port-&gt;port_num, 0, &amp;work-&gt;path[0].sgid);
<span class="p_chunk">@@ -1578,7 +1641,8 @@</span> <span class="p_context"> static int cm_req_handler(struct cm_work *work)</span>
 		goto rejected;
 	}
 	if (req_msg-&gt;alt_local_lid) {
<span class="p_del">-		ret = cm_init_av_by_path(&amp;work-&gt;path[1], &amp;cm_id_priv-&gt;alt_av);</span>
<span class="p_add">+		ret = cm_init_av_by_path(&amp;work-&gt;path[1], &amp;cm_id_priv-&gt;alt_av,</span>
<span class="p_add">+					 cm_id_priv);</span>
 		if (ret) {
 			ib_send_cm_rej(cm_id, IB_CM_REJ_INVALID_ALT_GID,
 				       &amp;work-&gt;path[0].sgid,
<span class="p_chunk">@@ -2633,7 +2697,8 @@</span> <span class="p_context"> int ib_send_cm_lap(struct ib_cm_id *cm_id,</span>
 		goto out;
 	}
 
<span class="p_del">-	ret = cm_init_av_by_path(alternate_path, &amp;cm_id_priv-&gt;alt_av);</span>
<span class="p_add">+	ret = cm_init_av_by_path(alternate_path, &amp;cm_id_priv-&gt;alt_av,</span>
<span class="p_add">+				 cm_id_priv);</span>
 	if (ret)
 		goto out;
 	cm_id_priv-&gt;alt_av.timeout =
<span class="p_chunk">@@ -2745,7 +2810,8 @@</span> <span class="p_context"> static int cm_lap_handler(struct cm_work *work)</span>
 	cm_init_av_for_response(work-&gt;port, work-&gt;mad_recv_wc-&gt;wc,
 				work-&gt;mad_recv_wc-&gt;recv_buf.grh,
 				&amp;cm_id_priv-&gt;av);
<span class="p_del">-	cm_init_av_by_path(param-&gt;alternate_path, &amp;cm_id_priv-&gt;alt_av);</span>
<span class="p_add">+	cm_init_av_by_path(param-&gt;alternate_path, &amp;cm_id_priv-&gt;alt_av,</span>
<span class="p_add">+			   cm_id_priv);</span>
 	ret = atomic_inc_and_test(&amp;cm_id_priv-&gt;work_count);
 	if (!ret)
 		list_add_tail(&amp;work-&gt;list, &amp;cm_id_priv-&gt;work_list);
<span class="p_chunk">@@ -2937,7 +3003,7 @@</span> <span class="p_context"> int ib_send_cm_sidr_req(struct ib_cm_id *cm_id,</span>
 		return -EINVAL;
 
 	cm_id_priv = container_of(cm_id, struct cm_id_private, id);
<span class="p_del">-	ret = cm_init_av_by_path(param-&gt;path, &amp;cm_id_priv-&gt;av);</span>
<span class="p_add">+	ret = cm_init_av_by_path(param-&gt;path, &amp;cm_id_priv-&gt;av, cm_id_priv);</span>
 	if (ret)
 		goto out;
 
<span class="p_chunk">@@ -3358,7 +3424,9 @@</span> <span class="p_context"> out:</span>
 static int cm_migrate(struct ib_cm_id *cm_id)
 {
 	struct cm_id_private *cm_id_priv;
<span class="p_add">+	struct cm_av tmp_av;</span>
 	unsigned long flags;
<span class="p_add">+	int tmp_send_port_not_ready;</span>
 	int ret = 0;
 
 	cm_id_priv = container_of(cm_id, struct cm_id_private, id);
<span class="p_chunk">@@ -3367,7 +3435,14 @@</span> <span class="p_context"> static int cm_migrate(struct ib_cm_id *cm_id)</span>
 	    (cm_id-&gt;lap_state == IB_CM_LAP_UNINIT ||
 	     cm_id-&gt;lap_state == IB_CM_LAP_IDLE)) {
 		cm_id-&gt;lap_state = IB_CM_LAP_IDLE;
<span class="p_add">+		/* Swap address vector */</span>
<span class="p_add">+		tmp_av = cm_id_priv-&gt;av;</span>
 		cm_id_priv-&gt;av = cm_id_priv-&gt;alt_av;
<span class="p_add">+		cm_id_priv-&gt;alt_av = tmp_av;</span>
<span class="p_add">+		/* Swap port send ready state */</span>
<span class="p_add">+		tmp_send_port_not_ready = cm_id_priv-&gt;prim_send_port_not_ready;</span>
<span class="p_add">+		cm_id_priv-&gt;prim_send_port_not_ready = cm_id_priv-&gt;altr_send_port_not_ready;</span>
<span class="p_add">+		cm_id_priv-&gt;altr_send_port_not_ready = tmp_send_port_not_ready;</span>
 	} else
 		ret = -EINVAL;
 	spin_unlock_irqrestore(&amp;cm_id_priv-&gt;lock, flags);
<span class="p_chunk">@@ -3799,6 +3874,9 @@</span> <span class="p_context"> static void cm_add_one(struct ib_device *ib_device)</span>
 		port-&gt;cm_dev = cm_dev;
 		port-&gt;port_num = i;
 
<span class="p_add">+		INIT_LIST_HEAD(&amp;port-&gt;cm_priv_prim_list);</span>
<span class="p_add">+		INIT_LIST_HEAD(&amp;port-&gt;cm_priv_altr_list);</span>
<span class="p_add">+</span>
 		ret = cm_create_port_fs(port);
 		if (ret)
 			goto error1;
<span class="p_chunk">@@ -3845,6 +3923,8 @@</span> <span class="p_context"> static void cm_remove_one(struct ib_device *ib_device)</span>
 {
 	struct cm_device *cm_dev;
 	struct cm_port *port;
<span class="p_add">+	struct cm_id_private *cm_id_priv;</span>
<span class="p_add">+	struct ib_mad_agent *cur_mad_agent;</span>
 	struct ib_port_modify port_modify = {
 		.clr_port_cap_mask = IB_PORT_CM_SUP
 	};
<span class="p_chunk">@@ -3862,10 +3942,22 @@</span> <span class="p_context"> static void cm_remove_one(struct ib_device *ib_device)</span>
 	for (i = 1; i &lt;= ib_device-&gt;phys_port_cnt; i++) {
 		port = cm_dev-&gt;port[i-1];
 		ib_modify_port(ib_device, port-&gt;port_num, 0, &amp;port_modify);
<span class="p_del">-		ib_unregister_mad_agent(port-&gt;mad_agent);</span>
<span class="p_add">+		/* Mark all the cm_id&#39;s as not valid */</span>
<span class="p_add">+		spin_lock_irq(&amp;cm.lock);</span>
<span class="p_add">+		list_for_each_entry(cm_id_priv, &amp;port-&gt;cm_priv_altr_list, altr_list)</span>
<span class="p_add">+			cm_id_priv-&gt;altr_send_port_not_ready = 1;</span>
<span class="p_add">+		list_for_each_entry(cm_id_priv, &amp;port-&gt;cm_priv_prim_list, prim_list)</span>
<span class="p_add">+			cm_id_priv-&gt;prim_send_port_not_ready = 1;</span>
<span class="p_add">+		spin_unlock_irq(&amp;cm.lock);</span>
<span class="p_add">+		spin_lock_irq(&amp;cm.state_lock);</span>
<span class="p_add">+		cur_mad_agent = port-&gt;mad_agent;</span>
<span class="p_add">+		port-&gt;mad_agent = NULL;</span>
<span class="p_add">+		spin_unlock_irq(&amp;cm.state_lock);</span>
<span class="p_add">+		ib_unregister_mad_agent(cur_mad_agent);</span>
 		flush_workqueue(cm.wq);
 		cm_remove_port_fs(port);
 	}
<span class="p_add">+</span>
 	device_unregister(cm_dev-&gt;device);
 	kfree(cm_dev);
 }
<span class="p_chunk">@@ -3878,6 +3970,7 @@</span> <span class="p_context"> static int __init ib_cm_init(void)</span>
 	INIT_LIST_HEAD(&amp;cm.device_list);
 	rwlock_init(&amp;cm.device_lock);
 	spin_lock_init(&amp;cm.lock);
<span class="p_add">+	spin_lock_init(&amp;cm.state_lock);</span>
 	cm.listen_service_table = RB_ROOT;
 	cm.listen_service_id = be64_to_cpu(IB_CM_ASSIGN_SERVICE_ID);
 	cm.remote_id_table = RB_ROOT;
<span class="p_header">diff --git a/drivers/infiniband/core/umem.c b/drivers/infiniband/core/umem.c</span>
<span class="p_header">index c9fed8f2e070..7a2b42b6c085 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/umem.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/umem.c</span>
<span class="p_chunk">@@ -156,7 +156,7 @@</span> <span class="p_context"> struct ib_umem *ib_umem_get(struct ib_ucontext *context, unsigned long addr,</span>
 
 	cur_base = addr &amp; PAGE_MASK;
 
<span class="p_del">-	if (npages == 0) {</span>
<span class="p_add">+	if (npages == 0 || npages &gt; UINT_MAX) {</span>
 		ret = -EINVAL;
 		goto out;
 	}
<span class="p_header">diff --git a/drivers/infiniband/core/uverbs_main.c b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">index f3ecfe4b9571..5bbfd0ecb31a 100644</span>
<span class="p_header">--- a/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_header">+++ b/drivers/infiniband/core/uverbs_main.c</span>
<span class="p_chunk">@@ -240,12 +240,9 @@</span> <span class="p_context"> static int ib_uverbs_cleanup_ucontext(struct ib_uverbs_file *file,</span>
 			container_of(uobj, struct ib_uqp_object, uevent.uobject);
 
 		idr_remove_uobj(&amp;ib_uverbs_qp_idr, uobj);
<span class="p_del">-		if (qp != qp-&gt;real_qp) {</span>
<span class="p_del">-			ib_close_qp(qp);</span>
<span class="p_del">-		} else {</span>
<span class="p_add">+		if (qp == qp-&gt;real_qp)</span>
 			ib_uverbs_detach_umcast(qp, uqp);
<span class="p_del">-			ib_destroy_qp(qp);</span>
<span class="p_del">-		}</span>
<span class="p_add">+		ib_destroy_qp(qp);</span>
 		ib_uverbs_release_uevent(file, &amp;uqp-&gt;uevent);
 		kfree(uqp);
 	}
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx4/cq.c b/drivers/infiniband/hw/mlx4/cq.c</span>
<span class="p_header">index 1066eec854a9..d4f0cdca36be 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx4/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx4/cq.c</span>
<span class="p_chunk">@@ -239,11 +239,14 @@</span> <span class="p_context"> struct ib_cq *mlx4_ib_create_cq(struct ib_device *ibdev, int entries, int vector</span>
 	if (context)
 		if (ib_copy_to_udata(udata, &amp;cq-&gt;mcq.cqn, sizeof (__u32))) {
 			err = -EFAULT;
<span class="p_del">-			goto err_dbmap;</span>
<span class="p_add">+			goto err_cq_free;</span>
 		}
 
 	return &amp;cq-&gt;ibcq;
 
<span class="p_add">+err_cq_free:</span>
<span class="p_add">+	mlx4_cq_free(dev-&gt;dev, &amp;cq-&gt;mcq);</span>
<span class="p_add">+</span>
 err_dbmap:
 	if (context)
 		mlx4_ib_db_unmap_user(to_mucontext(context), &amp;cq-&gt;db);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/cq.c b/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_header">index 8ae4f896cb41..a3395e4cc721 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/cq.c</span>
<span class="p_chunk">@@ -771,8 +771,7 @@</span> <span class="p_context"> struct ib_cq *mlx5_ib_create_cq(struct ib_device *ibdev, int entries,</span>
 		if (err)
 			goto err_create;
 	} else {
<span class="p_del">-		/* for now choose 64 bytes till we have a proper interface */</span>
<span class="p_del">-		cqe_size = 64;</span>
<span class="p_add">+		cqe_size = cache_line_size() == 128 ? 128 : 64;</span>
 		err = create_cq_kernel(dev, cq, entries, cqe_size, &amp;cqb,
 				       &amp;index, &amp;inlen);
 		if (err)
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mlx5_ib.h b/drivers/infiniband/hw/mlx5/mlx5_ib.h</span>
<span class="p_header">index f2ccf1a5a291..61cf5f18c33a 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mlx5_ib.h</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mlx5_ib.h</span>
<span class="p_chunk">@@ -376,6 +376,8 @@</span> <span class="p_context"> struct mlx5_ib_dev {</span>
 	struct mlx5_ib_resources	devr;
 	struct mlx5_mr_cache		cache;
 	struct timer_list		delay_timer;
<span class="p_add">+	/* Prevents soft lock on massive reg MRs */</span>
<span class="p_add">+	struct mutex			slow_path_mutex;</span>
 	int				fill_delay;
 };
 
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/mr.c b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">index afa873bd028e..bf75b943bc31 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/mr.c</span>
<span class="p_chunk">@@ -554,6 +554,7 @@</span> <span class="p_context"> int mlx5_mr_cache_init(struct mlx5_ib_dev *dev)</span>
 	int err;
 	int i;
 
<span class="p_add">+	mutex_init(&amp;dev-&gt;slow_path_mutex);</span>
 	cache-&gt;wq = create_singlethread_workqueue(&quot;mkey_cache&quot;);
 	if (!cache-&gt;wq) {
 		mlx5_ib_warn(dev, &quot;failed to create work queue\n&quot;);
<span class="p_chunk">@@ -909,9 +910,12 @@</span> <span class="p_context"> struct ib_mr *mlx5_ib_reg_user_mr(struct ib_pd *pd, u64 start, u64 length,</span>
 		}
 	}
 
<span class="p_del">-	if (!mr)</span>
<span class="p_add">+	if (!mr) {</span>
<span class="p_add">+		mutex_lock(&amp;dev-&gt;slow_path_mutex);</span>
 		mr = reg_create(pd, virt_addr, length, umem, ncont, page_shift,
 				access_flags);
<span class="p_add">+		mutex_unlock(&amp;dev-&gt;slow_path_mutex);</span>
<span class="p_add">+	}</span>
 
 	if (IS_ERR(mr)) {
 		err = PTR_ERR(mr);
<span class="p_header">diff --git a/drivers/infiniband/hw/mlx5/qp.c b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">index aaa3a0b0ec95..85707b7d9fde 100644</span>
<span class="p_header">--- a/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_header">+++ b/drivers/infiniband/hw/mlx5/qp.c</span>
<span class="p_chunk">@@ -1205,8 +1205,9 @@</span> <span class="p_context"> struct ib_qp *mlx5_ib_create_qp(struct ib_pd *pd,</span>
 			qp-&gt;ibqp.qp_num = qp-&gt;mqp.qpn;
 
 		mlx5_ib_dbg(dev, &quot;ib qpnum 0x%x, mlx qpn 0x%x, rcqn 0x%x, scqn 0x%x\n&quot;,
<span class="p_del">-			    qp-&gt;ibqp.qp_num, qp-&gt;mqp.qpn, to_mcq(init_attr-&gt;recv_cq)-&gt;mcq.cqn,</span>
<span class="p_del">-			    to_mcq(init_attr-&gt;send_cq)-&gt;mcq.cqn);</span>
<span class="p_add">+			    qp-&gt;ibqp.qp_num, qp-&gt;mqp.qpn,</span>
<span class="p_add">+			    init_attr-&gt;recv_cq ? to_mcq(init_attr-&gt;recv_cq)-&gt;mcq.cqn : -1,</span>
<span class="p_add">+			    init_attr-&gt;send_cq ? to_mcq(init_attr-&gt;send_cq)-&gt;mcq.cqn : -1);</span>
 
 		qp-&gt;xrcdn = xrcdn;
 
<span class="p_header">diff --git a/drivers/infiniband/ulp/srp/ib_srp.c b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">index 36876960f97e..6311fd448c36 100644</span>
<span class="p_header">--- a/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_header">+++ b/drivers/infiniband/ulp/srp/ib_srp.c</span>
<span class="p_chunk">@@ -1310,7 +1310,9 @@</span> <span class="p_context"> static int srp_map_sg_entry(struct srp_map_state *state,</span>
 
 	while (dma_len) {
 		unsigned offset = dma_addr &amp; ~dev-&gt;mr_page_mask;
<span class="p_del">-		if (state-&gt;npages == dev-&gt;max_pages_per_mr || offset != 0) {</span>
<span class="p_add">+</span>
<span class="p_add">+		if (state-&gt;npages == dev-&gt;max_pages_per_mr ||</span>
<span class="p_add">+		    (state-&gt;npages &gt; 0 &amp;&amp; offset != 0)) {</span>
 			ret = srp_finish_mapping(state, target);
 			if (ret)
 				return ret;
<span class="p_chunk">@@ -1329,12 +1331,12 @@</span> <span class="p_context"> static int srp_map_sg_entry(struct srp_map_state *state,</span>
 	}
 
 	/*
<span class="p_del">-	 * If the last entry of the MR wasn&#39;t a full page, then we need to</span>
<span class="p_add">+	 * If the end of the MR is not on a page boundary then we need to</span>
 	 * close it out and start a new one -- we can only merge at page
 	 * boundries.
 	 */
 	ret = 0;
<span class="p_del">-	if (len != dev-&gt;mr_page_size) {</span>
<span class="p_add">+	if ((dma_addr &amp; ~dev-&gt;mr_page_mask) != 0) {</span>
 		ret = srp_finish_mapping(state, target);
 		if (!ret)
 			srp_map_update_start(state, NULL, 0, 0);
<span class="p_header">diff --git a/drivers/input/mouse/elantech.c b/drivers/input/mouse/elantech.c</span>
<span class="p_header">index 92cebaf5d621..25088e40ca06 100644</span>
<span class="p_header">--- a/drivers/input/mouse/elantech.c</span>
<span class="p_header">+++ b/drivers/input/mouse/elantech.c</span>
<span class="p_chunk">@@ -1389,6 +1389,13 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {</span>
 		},
 	},
 	{
<span class="p_add">+		/* Fujitsu LIFEBOOK E544  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E544&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
<span class="p_add">+	{</span>
 		/* Fujitsu LIFEBOOK E554  does not work with crc_enabled == 0 */
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_chunk">@@ -1396,10 +1403,10 @@</span> <span class="p_context"> static const struct dmi_system_id elantech_dmi_force_crc_enabled[] = {</span>
 		},
 	},
 	{
<span class="p_del">-		/* Fujitsu LIFEBOOK E544  does not work with crc_enabled == 0 */</span>
<span class="p_add">+		/* Fujitsu LIFEBOOK E556 does not work with crc_enabled == 0 */</span>
 		.matches = {
 			DMI_MATCH(DMI_SYS_VENDOR, &quot;FUJITSU&quot;),
<span class="p_del">-			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E544&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;LIFEBOOK E556&quot;),</span>
 		},
 	},
 	{
<span class="p_header">diff --git a/drivers/input/serio/i8042-x86ia64io.h b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">index d9ab5c5e8e82..ccb36fb565de 100644</span>
<span class="p_header">--- a/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_header">+++ b/drivers/input/serio/i8042-x86ia64io.h</span>
<span class="p_chunk">@@ -776,6 +776,13 @@</span> <span class="p_context"> static const struct dmi_system_id __initconst i8042_dmi_kbdreset_table[] = {</span>
 			DMI_MATCH(DMI_PRODUCT_NAME, &quot;P34&quot;),
 		},
 	},
<span class="p_add">+	{</span>
<span class="p_add">+		/* Schenker XMG C504 - Elantech touchpad */</span>
<span class="p_add">+		.matches = {</span>
<span class="p_add">+			DMI_MATCH(DMI_SYS_VENDOR, &quot;XMG&quot;),</span>
<span class="p_add">+			DMI_MATCH(DMI_PRODUCT_NAME, &quot;C504&quot;),</span>
<span class="p_add">+		},</span>
<span class="p_add">+	},</span>
 	{ }
 };
 
<span class="p_header">diff --git a/drivers/iommu/amd_iommu.c b/drivers/iommu/amd_iommu.c</span>
<span class="p_header">index b4b133207505..76c71ecba656 100644</span>
<span class="p_header">--- a/drivers/iommu/amd_iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/amd_iommu.c</span>
<span class="p_chunk">@@ -2037,6 +2037,9 @@</span> <span class="p_context"> static void dma_ops_domain_free(struct dma_ops_domain *dom)</span>
 		kfree(dom-&gt;aperture[i]);
 	}
 
<span class="p_add">+	if (dom-&gt;domain.id)</span>
<span class="p_add">+		domain_id_free(dom-&gt;domain.id);</span>
<span class="p_add">+</span>
 	kfree(dom);
 }
 
<span class="p_header">diff --git a/drivers/iommu/dmar.c b/drivers/iommu/dmar.c</span>
<span class="p_header">index 8d3f5d89cfc2..bccfacabbae7 100644</span>
<span class="p_header">--- a/drivers/iommu/dmar.c</span>
<span class="p_header">+++ b/drivers/iommu/dmar.c</span>
<span class="p_chunk">@@ -299,7 +299,9 @@</span> <span class="p_context"> static int dmar_pci_bus_notifier(struct notifier_block *nb,</span>
 	struct pci_dev *pdev = to_pci_dev(data);
 	struct dmar_pci_notify_info *info;
 
<span class="p_del">-	/* Only care about add/remove events for physical functions */</span>
<span class="p_add">+	/* Only care about add/remove events for physical functions.</span>
<span class="p_add">+	 * For VFs we actually do the lookup based on the corresponding</span>
<span class="p_add">+	 * PF in device_to_iommu() anyway. */</span>
 	if (pdev-&gt;is_virtfn)
 		return NOTIFY_DONE;
 	if (action != BUS_NOTIFY_ADD_DEVICE &amp;&amp; action != BUS_NOTIFY_DEL_DEVICE)
<span class="p_header">diff --git a/drivers/iommu/intel-iommu.c b/drivers/iommu/intel-iommu.c</span>
<span class="p_header">index 544f968a440a..d5b5878fa995 100644</span>
<span class="p_header">--- a/drivers/iommu/intel-iommu.c</span>
<span class="p_header">+++ b/drivers/iommu/intel-iommu.c</span>
<span class="p_chunk">@@ -684,7 +684,13 @@</span> <span class="p_context"> static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf</span>
 		return NULL;
 
 	if (dev_is_pci(dev)) {
<span class="p_add">+		struct pci_dev *pf_pdev;</span>
<span class="p_add">+</span>
 		pdev = to_pci_dev(dev);
<span class="p_add">+		/* VFs aren&#39;t listed in scope tables; we need to look up</span>
<span class="p_add">+		 * the PF instead to find the IOMMU. */</span>
<span class="p_add">+		pf_pdev = pci_physfn(pdev);</span>
<span class="p_add">+		dev = &amp;pf_pdev-&gt;dev;</span>
 		segment = pci_domain_nr(pdev-&gt;bus);
 	} else if (ACPI_COMPANION(dev))
 		dev = &amp;ACPI_COMPANION(dev)-&gt;dev;
<span class="p_chunk">@@ -697,6 +703,13 @@</span> <span class="p_context"> static struct intel_iommu *device_to_iommu(struct device *dev, u8 *bus, u8 *devf</span>
 		for_each_active_dev_scope(drhd-&gt;devices,
 					  drhd-&gt;devices_cnt, i, tmp) {
 			if (tmp == dev) {
<span class="p_add">+				/* For a VF use its original BDF# not that of the PF</span>
<span class="p_add">+				 * which we used for the IOMMU lookup. Strictly speaking</span>
<span class="p_add">+				 * we could do this for all PCI devices; we only need to</span>
<span class="p_add">+				 * get the BDF# from the scope table for ACPI matches. */</span>
<span class="p_add">+				if (pdev-&gt;is_virtfn)</span>
<span class="p_add">+					goto got_pdev;</span>
<span class="p_add">+</span>
 				*bus = drhd-&gt;devices[i].bus;
 				*devfn = drhd-&gt;devices[i].devfn;
 				goto out;
<span class="p_header">diff --git a/drivers/isdn/gigaset/ser-gigaset.c b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">index 0ebb52b0336d..397dba6d408f 100644</span>
<span class="p_header">--- a/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_header">+++ b/drivers/isdn/gigaset/ser-gigaset.c</span>
<span class="p_chunk">@@ -791,8 +791,10 @@</span> <span class="p_context"> static int __init ser_gigaset_init(void)</span>
 	driver = gigaset_initdriver(GIGASET_MINOR, GIGASET_MINORS,
 				    GIGASET_MODULENAME, GIGASET_DEVNAME,
 				    &amp;ops, THIS_MODULE);
<span class="p_del">-	if (!driver)</span>
<span class="p_add">+	if (!driver) {</span>
<span class="p_add">+		rc = -ENOMEM;</span>
 		goto error;
<span class="p_add">+	}</span>
 
 	rc = tty_register_ldisc(N_GIGASET_M101, &amp;gigaset_ldisc);
 	if (rc != 0) {
<span class="p_header">diff --git a/drivers/md/dm-mpath.c b/drivers/md/dm-mpath.c</span>
<span class="p_header">index 34601cc0c508..5551c236fb25 100644</span>
<span class="p_header">--- a/drivers/md/dm-mpath.c</span>
<span class="p_header">+++ b/drivers/md/dm-mpath.c</span>
<span class="p_chunk">@@ -1196,10 +1196,10 @@</span> <span class="p_context"> static void activate_path(struct work_struct *work)</span>
 {
 	struct pgpath *pgpath =
 		container_of(work, struct pgpath, activate_path.work);
<span class="p_add">+	struct request_queue *q = bdev_get_queue(pgpath-&gt;path.dev-&gt;bdev);</span>
 
<span class="p_del">-	if (pgpath-&gt;is_active)</span>
<span class="p_del">-		scsi_dh_activate(bdev_get_queue(pgpath-&gt;path.dev-&gt;bdev),</span>
<span class="p_del">-				 pg_init_done, pgpath);</span>
<span class="p_add">+	if (pgpath-&gt;is_active &amp;&amp; !blk_queue_dying(q))</span>
<span class="p_add">+		scsi_dh_activate(q, pg_init_done, pgpath);</span>
 	else
 		pg_init_done(pgpath, SCSI_DH_DEV_OFFLINED);
 }
<span class="p_header">diff --git a/drivers/md/dm-table.c b/drivers/md/dm-table.c</span>
<span class="p_header">index 922791009fc5..c932b6b0d54c 100644</span>
<span class="p_header">--- a/drivers/md/dm-table.c</span>
<span class="p_header">+++ b/drivers/md/dm-table.c</span>
<span class="p_chunk">@@ -725,37 +725,32 @@</span> <span class="p_context"> int dm_table_add_target(struct dm_table *t, const char *type,</span>
 
 	tgt-&gt;type = dm_get_target_type(type);
 	if (!tgt-&gt;type) {
<span class="p_del">-		DMERR(&quot;%s: %s: unknown target type&quot;, dm_device_name(t-&gt;md),</span>
<span class="p_del">-		      type);</span>
<span class="p_add">+		DMERR(&quot;%s: %s: unknown target type&quot;, dm_device_name(t-&gt;md), type);</span>
 		return -EINVAL;
 	}
 
 	if (dm_target_needs_singleton(tgt-&gt;type)) {
 		if (t-&gt;num_targets) {
<span class="p_del">-			DMERR(&quot;%s: target type %s must appear alone in table&quot;,</span>
<span class="p_del">-			      dm_device_name(t-&gt;md), type);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			tgt-&gt;error = &quot;singleton target type must appear alone in table&quot;;</span>
<span class="p_add">+			goto bad;</span>
 		}
 		t-&gt;singleton = 1;
 	}
 
 	if (dm_target_always_writeable(tgt-&gt;type) &amp;&amp; !(t-&gt;mode &amp; FMODE_WRITE)) {
<span class="p_del">-		DMERR(&quot;%s: target type %s may not be included in read-only tables&quot;,</span>
<span class="p_del">-		      dm_device_name(t-&gt;md), type);</span>
<span class="p_del">-		return -EINVAL;</span>
<span class="p_add">+		tgt-&gt;error = &quot;target type may not be included in a read-only table&quot;;</span>
<span class="p_add">+		goto bad;</span>
 	}
 
 	if (t-&gt;immutable_target_type) {
 		if (t-&gt;immutable_target_type != tgt-&gt;type) {
<span class="p_del">-			DMERR(&quot;%s: immutable target type %s cannot be mixed with other target types&quot;,</span>
<span class="p_del">-			      dm_device_name(t-&gt;md), t-&gt;immutable_target_type-&gt;name);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			tgt-&gt;error = &quot;immutable target type cannot be mixed with other target types&quot;;</span>
<span class="p_add">+			goto bad;</span>
 		}
 	} else if (dm_target_is_immutable(tgt-&gt;type)) {
 		if (t-&gt;num_targets) {
<span class="p_del">-			DMERR(&quot;%s: immutable target type %s cannot be mixed with other target types&quot;,</span>
<span class="p_del">-			      dm_device_name(t-&gt;md), tgt-&gt;type-&gt;name);</span>
<span class="p_del">-			return -EINVAL;</span>
<span class="p_add">+			tgt-&gt;error = &quot;immutable target type cannot be mixed with other target types&quot;;</span>
<span class="p_add">+			goto bad;</span>
 		}
 		t-&gt;immutable_target_type = tgt-&gt;type;
 	}
<span class="p_chunk">@@ -770,7 +765,6 @@</span> <span class="p_context"> int dm_table_add_target(struct dm_table *t, const char *type,</span>
 	 */
 	if (!adjoin(t, tgt)) {
 		tgt-&gt;error = &quot;Gap in table&quot;;
<span class="p_del">-		r = -EINVAL;</span>
 		goto bad;
 	}
 
<span class="p_header">diff --git a/drivers/md/dm.c b/drivers/md/dm.c</span>
<span class="p_header">index f62d4c8bd9f9..35caa4c17c3d 100644</span>
<span class="p_header">--- a/drivers/md/dm.c</span>
<span class="p_header">+++ b/drivers/md/dm.c</span>
<span class="p_chunk">@@ -2407,6 +2407,7 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(dm_device_name);</span>
 
 static void __dm_destroy(struct mapped_device *md, bool wait)
 {
<span class="p_add">+	struct request_queue *q = md-&gt;queue;</span>
 	struct dm_table *map;
 	int srcu_idx;
 
<span class="p_chunk">@@ -2417,6 +2418,10 @@</span> <span class="p_context"> static void __dm_destroy(struct mapped_device *md, bool wait)</span>
 	set_bit(DMF_FREEING, &amp;md-&gt;flags);
 	spin_unlock(&amp;_minor_lock);
 
<span class="p_add">+	spin_lock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+	queue_flag_set(QUEUE_FLAG_DYING, q);</span>
<span class="p_add">+	spin_unlock_irq(q-&gt;queue_lock);</span>
<span class="p_add">+</span>
 	/*
 	 * Take suspend_lock so that presuspend and postsuspend methods
 	 * do not race with internal suspend.
<span class="p_header">diff --git a/drivers/md/md.c b/drivers/md/md.c</span>
<span class="p_header">index 4bd7f2729c16..60d57bad30bb 100644</span>
<span class="p_header">--- a/drivers/md/md.c</span>
<span class="p_header">+++ b/drivers/md/md.c</span>
<span class="p_chunk">@@ -7682,7 +7682,7 @@</span> <span class="p_context"> void md_do_sync(struct md_thread *thread)</span>
 	mddev-&gt;pers-&gt;sync_request(mddev, max_sectors, &amp;skipped, 1);
 
 	if (!test_bit(MD_RECOVERY_CHECK, &amp;mddev-&gt;recovery) &amp;&amp;
<span class="p_del">-	    mddev-&gt;curr_resync &gt; 2) {</span>
<span class="p_add">+	    mddev-&gt;curr_resync &gt; 3) {</span>
 		if (test_bit(MD_RECOVERY_SYNC, &amp;mddev-&gt;recovery)) {
 			if (test_bit(MD_RECOVERY_INTR, &amp;mddev-&gt;recovery)) {
 				if (mddev-&gt;curr_resync &gt;= mddev-&gt;recovery_cp) {
<span class="p_header">diff --git a/drivers/media/dvb-frontends/mb86a20s.c b/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_header">index 2f458bb188c7..2d759526d78c 100644</span>
<span class="p_header">--- a/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_header">+++ b/drivers/media/dvb-frontends/mb86a20s.c</span>
<span class="p_chunk">@@ -75,25 +75,27 @@</span> <span class="p_context"> static struct regdata mb86a20s_init1[] = {</span>
 };
 
 static struct regdata mb86a20s_init2[] = {
<span class="p_del">-	{ 0x28, 0x22 }, { 0x29, 0x00 }, { 0x2a, 0x1f }, { 0x2b, 0xf0 },</span>
<span class="p_add">+	{ 0x50, 0xd1 }, { 0x51, 0x22 },</span>
<span class="p_add">+	{ 0x39, 0x01 },</span>
<span class="p_add">+	{ 0x71, 0x00 },</span>
 	{ 0x3b, 0x21 },
<span class="p_del">-	{ 0x3c, 0x38 },</span>
<span class="p_add">+	{ 0x3c, 0x3a },</span>
 	{ 0x01, 0x0d },
<span class="p_del">-	{ 0x04, 0x08 }, { 0x05, 0x03 },</span>
<span class="p_add">+	{ 0x04, 0x08 }, { 0x05, 0x05 },</span>
 	{ 0x04, 0x0e }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x0f }, { 0x05, 0x37 },</span>
<span class="p_del">-	{ 0x04, 0x0b }, { 0x05, 0x78 },</span>
<span class="p_add">+	{ 0x04, 0x0f }, { 0x05, 0x14 },</span>
<span class="p_add">+	{ 0x04, 0x0b }, { 0x05, 0x8c },</span>
 	{ 0x04, 0x00 }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x01 }, { 0x05, 0x1e },</span>
<span class="p_del">-	{ 0x04, 0x02 }, { 0x05, 0x07 },</span>
<span class="p_del">-	{ 0x04, 0x03 }, { 0x05, 0xd0 },</span>
<span class="p_add">+	{ 0x04, 0x01 }, { 0x05, 0x07 },</span>
<span class="p_add">+	{ 0x04, 0x02 }, { 0x05, 0x0f },</span>
<span class="p_add">+	{ 0x04, 0x03 }, { 0x05, 0xa0 },</span>
 	{ 0x04, 0x09 }, { 0x05, 0x00 },
 	{ 0x04, 0x0a }, { 0x05, 0xff },
<span class="p_del">-	{ 0x04, 0x27 }, { 0x05, 0x00 },</span>
<span class="p_add">+	{ 0x04, 0x27 }, { 0x05, 0x64 },</span>
 	{ 0x04, 0x28 }, { 0x05, 0x00 },
<span class="p_del">-	{ 0x04, 0x1e }, { 0x05, 0x00 },</span>
<span class="p_del">-	{ 0x04, 0x29 }, { 0x05, 0x64 },</span>
<span class="p_del">-	{ 0x04, 0x32 }, { 0x05, 0x02 },</span>
<span class="p_add">+	{ 0x04, 0x1e }, { 0x05, 0xff },</span>
<span class="p_add">+	{ 0x04, 0x29 }, { 0x05, 0x0a },</span>
<span class="p_add">+	{ 0x04, 0x32 }, { 0x05, 0x0a },</span>
 	{ 0x04, 0x14 }, { 0x05, 0x02 },
 	{ 0x04, 0x04 }, { 0x05, 0x00 },
 	{ 0x04, 0x05 }, { 0x05, 0x22 },
<span class="p_chunk">@@ -101,8 +103,6 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x04, 0x07 }, { 0x05, 0xd8 },
 	{ 0x04, 0x12 }, { 0x05, 0x00 },
 	{ 0x04, 0x13 }, { 0x05, 0xff },
<span class="p_del">-	{ 0x04, 0x15 }, { 0x05, 0x4e },</span>
<span class="p_del">-	{ 0x04, 0x16 }, { 0x05, 0x20 },</span>
 
 	/*
 	 * On this demod, when the bit count reaches the count below,
<span class="p_chunk">@@ -156,42 +156,36 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x50, 0x51 }, { 0x51, 0x04 },		/* MER symbol 4 */
 	{ 0x45, 0x04 },				/* CN symbol 4 */
 	{ 0x48, 0x04 },				/* CN manual mode */
<span class="p_del">-</span>
<span class="p_add">+	{ 0x50, 0xd5 }, { 0x51, 0x01 },</span>
 	{ 0x50, 0xd6 }, { 0x51, 0x1f },
 	{ 0x50, 0xd2 }, { 0x51, 0x03 },
<span class="p_del">-	{ 0x50, 0xd7 }, { 0x51, 0xbf },</span>
<span class="p_del">-	{ 0x28, 0x74 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0xff },</span>
<span class="p_del">-	{ 0x28, 0x46 }, { 0x29, 0x00 }, { 0x2a, 0x1a }, { 0x2b, 0x0c },</span>
<span class="p_del">-</span>
<span class="p_del">-	{ 0x04, 0x40 }, { 0x05, 0x00 },</span>
<span class="p_del">-	{ 0x28, 0x00 }, { 0x2b, 0x08 },</span>
<span class="p_del">-	{ 0x28, 0x05 }, { 0x2b, 0x00 },</span>
<span class="p_add">+	{ 0x50, 0xd7 }, { 0x51, 0x3f },</span>
 	{ 0x1c, 0x01 },
<span class="p_del">-	{ 0x28, 0x06 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x1f },</span>
<span class="p_del">-	{ 0x28, 0x07 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x18 },</span>
<span class="p_del">-	{ 0x28, 0x08 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x12 },</span>
<span class="p_del">-	{ 0x28, 0x09 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x30 },</span>
<span class="p_del">-	{ 0x28, 0x0a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x37 },</span>
<span class="p_del">-	{ 0x28, 0x0b }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x02 },</span>
<span class="p_del">-	{ 0x28, 0x0c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x09 },</span>
<span class="p_del">-	{ 0x28, 0x0d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x06 },</span>
<span class="p_del">-	{ 0x28, 0x0e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x7b },</span>
<span class="p_del">-	{ 0x28, 0x0f }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x76 },</span>
<span class="p_del">-	{ 0x28, 0x10 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x7d },</span>
<span class="p_del">-	{ 0x28, 0x11 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x08 },</span>
<span class="p_del">-	{ 0x28, 0x12 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0b },</span>
<span class="p_del">-	{ 0x28, 0x13 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x00 },</span>
<span class="p_del">-	{ 0x28, 0x14 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xf2 },</span>
<span class="p_del">-	{ 0x28, 0x15 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xf3 },</span>
<span class="p_del">-	{ 0x28, 0x16 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x05 },</span>
<span class="p_del">-	{ 0x28, 0x17 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x16 },</span>
<span class="p_del">-	{ 0x28, 0x18 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0f },</span>
<span class="p_del">-	{ 0x28, 0x19 }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xef },</span>
<span class="p_del">-	{ 0x28, 0x1a }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xd8 },</span>
<span class="p_del">-	{ 0x28, 0x1b }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xf1 },</span>
<span class="p_del">-	{ 0x28, 0x1c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x3d },</span>
<span class="p_del">-	{ 0x28, 0x1d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x94 },</span>
<span class="p_del">-	{ 0x28, 0x1e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0xba },</span>
<span class="p_add">+	{ 0x28, 0x06 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x03 },</span>
<span class="p_add">+	{ 0x28, 0x07 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0d },</span>
<span class="p_add">+	{ 0x28, 0x08 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x02 },</span>
<span class="p_add">+	{ 0x28, 0x09 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x01 },</span>
<span class="p_add">+	{ 0x28, 0x0a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x21 },</span>
<span class="p_add">+	{ 0x28, 0x0b }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x29 },</span>
<span class="p_add">+	{ 0x28, 0x0c }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x16 },</span>
<span class="p_add">+	{ 0x28, 0x0d }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x31 },</span>
<span class="p_add">+	{ 0x28, 0x0e }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0e },</span>
<span class="p_add">+	{ 0x28, 0x0f }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x4e },</span>
<span class="p_add">+	{ 0x28, 0x10 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x46 },</span>
<span class="p_add">+	{ 0x28, 0x11 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x0f },</span>
<span class="p_add">+	{ 0x28, 0x12 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x56 },</span>
<span class="p_add">+	{ 0x28, 0x13 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x35 },</span>
<span class="p_add">+	{ 0x28, 0x14 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbe },</span>
<span class="p_add">+	{ 0x28, 0x15 }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0x84 },</span>
<span class="p_add">+	{ 0x28, 0x16 }, { 0x29, 0x00 }, { 0x2a, 0x03 }, { 0x2b, 0xee },</span>
<span class="p_add">+	{ 0x28, 0x17 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x98 },</span>
<span class="p_add">+	{ 0x28, 0x18 }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x9f },</span>
<span class="p_add">+	{ 0x28, 0x19 }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0xb2 },</span>
<span class="p_add">+	{ 0x28, 0x1a }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0xc2 },</span>
<span class="p_add">+	{ 0x28, 0x1b }, { 0x29, 0x00 }, { 0x2a, 0x07 }, { 0x2b, 0x4a },</span>
<span class="p_add">+	{ 0x28, 0x1c }, { 0x29, 0x00 }, { 0x2a, 0x01 }, { 0x2b, 0xbc },</span>
<span class="p_add">+	{ 0x28, 0x1d }, { 0x29, 0x00 }, { 0x2a, 0x04 }, { 0x2b, 0xba },</span>
<span class="p_add">+	{ 0x28, 0x1e }, { 0x29, 0x00 }, { 0x2a, 0x06 }, { 0x2b, 0x14 },</span>
 	{ 0x50, 0x1e }, { 0x51, 0x5d },
 	{ 0x50, 0x22 }, { 0x51, 0x00 },
 	{ 0x50, 0x23 }, { 0x51, 0xc8 },
<span class="p_chunk">@@ -200,9 +194,7 @@</span> <span class="p_context"> static struct regdata mb86a20s_init2[] = {</span>
 	{ 0x50, 0x26 }, { 0x51, 0x00 },
 	{ 0x50, 0x27 }, { 0x51, 0xc3 },
 	{ 0x50, 0x39 }, { 0x51, 0x02 },
<span class="p_del">-	{ 0xec, 0x0f },</span>
<span class="p_del">-	{ 0xeb, 0x1f },</span>
<span class="p_del">-	{ 0x28, 0x6a }, { 0x29, 0x00 }, { 0x2a, 0x00 }, { 0x2b, 0x00 },</span>
<span class="p_add">+	{ 0x50, 0xd5 }, { 0x51, 0x01 },</span>
 	{ 0xd0, 0x00 },
 };
 
<span class="p_chunk">@@ -321,7 +313,11 @@</span> <span class="p_context"> static int mb86a20s_read_status(struct dvb_frontend *fe, fe_status_t *status)</span>
 	if (val &gt;= 7)
 		*status |= FE_HAS_SYNC;
 
<span class="p_del">-	if (val &gt;= 8)				/* Maybe 9? */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Actually, on state S8, it starts receiving TS, but the TS</span>
<span class="p_add">+	 * output is only on normal state after the transition to S9.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (val &gt;= 9)</span>
 		*status |= FE_HAS_LOCK;
 
 	dev_dbg(&amp;state-&gt;i2c-&gt;dev, &quot;%s: Status = 0x%02x (state = %d)\n&quot;,
<span class="p_chunk">@@ -2080,6 +2076,11 @@</span> <span class="p_context"> static void mb86a20s_release(struct dvb_frontend *fe)</span>
 	kfree(state);
 }
 
<span class="p_add">+static int mb86a20s_get_frontend_algo(struct dvb_frontend *fe)</span>
<span class="p_add">+{</span>
<span class="p_add">+        return DVBFE_ALGO_HW;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static struct dvb_frontend_ops mb86a20s_ops;
 
 struct dvb_frontend *mb86a20s_attach(const struct mb86a20s_config *config,
<span class="p_chunk">@@ -2153,6 +2154,7 @@</span> <span class="p_context"> static struct dvb_frontend_ops mb86a20s_ops = {</span>
 	.read_status = mb86a20s_read_status_and_stats,
 	.read_signal_strength = mb86a20s_read_signal_strength_from_cache,
 	.tune = mb86a20s_tune,
<span class="p_add">+	.get_frontend_algo = mb86a20s_get_frontend_algo,</span>
 };
 
 MODULE_DESCRIPTION(&quot;DVB Frontend module for Fujitsu mb86A20s hardware&quot;);
<span class="p_header">diff --git a/drivers/media/tuners/tuner-xc2028.c b/drivers/media/tuners/tuner-xc2028.c</span>
<span class="p_header">index b0e8440d33f7..32313a6029b4 100644</span>
<span class="p_header">--- a/drivers/media/tuners/tuner-xc2028.c</span>
<span class="p_header">+++ b/drivers/media/tuners/tuner-xc2028.c</span>
<span class="p_chunk">@@ -281,6 +281,14 @@</span> <span class="p_context"> static void free_firmware(struct xc2028_data *priv)</span>
 	int i;
 	tuner_dbg(&quot;%s called\n&quot;, __func__);
 
<span class="p_add">+	/* free allocated f/w string */</span>
<span class="p_add">+	if (priv-&gt;fname != firmware_name)</span>
<span class="p_add">+		kfree(priv-&gt;fname);</span>
<span class="p_add">+	priv-&gt;fname = NULL;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;state = XC2028_NO_FIRMWARE;</span>
<span class="p_add">+	memset(&amp;priv-&gt;cur_fw, 0, sizeof(priv-&gt;cur_fw));</span>
<span class="p_add">+</span>
 	if (!priv-&gt;firm)
 		return;
 
<span class="p_chunk">@@ -291,9 +299,6 @@</span> <span class="p_context"> static void free_firmware(struct xc2028_data *priv)</span>
 
 	priv-&gt;firm = NULL;
 	priv-&gt;firm_size = 0;
<span class="p_del">-	priv-&gt;state = XC2028_NO_FIRMWARE;</span>
<span class="p_del">-</span>
<span class="p_del">-	memset(&amp;priv-&gt;cur_fw, 0, sizeof(priv-&gt;cur_fw));</span>
 }
 
 static int load_all_firmwares(struct dvb_frontend *fe,
<span class="p_chunk">@@ -884,9 +889,8 @@</span> <span class="p_context"> read_not_reliable:</span>
 	return 0;
 
 fail:
<span class="p_del">-	priv-&gt;state = XC2028_NO_FIRMWARE;</span>
<span class="p_add">+	free_firmware(priv);</span>
 
<span class="p_del">-	memset(&amp;priv-&gt;cur_fw, 0, sizeof(priv-&gt;cur_fw));</span>
 	if (retry_count &lt; 8) {
 		msleep(50);
 		retry_count++;
<span class="p_chunk">@@ -1332,11 +1336,8 @@</span> <span class="p_context"> static int xc2028_dvb_release(struct dvb_frontend *fe)</span>
 	mutex_lock(&amp;xc2028_list_mutex);
 
 	/* only perform final cleanup if this is the last instance */
<span class="p_del">-	if (hybrid_tuner_report_instance_count(priv) == 1) {</span>
<span class="p_add">+	if (hybrid_tuner_report_instance_count(priv) == 1)</span>
 		free_firmware(priv);
<span class="p_del">-		kfree(priv-&gt;ctrl.fname);</span>
<span class="p_del">-		priv-&gt;ctrl.fname = NULL;</span>
<span class="p_del">-	}</span>
 
 	if (priv)
 		hybrid_tuner_release_state(priv);
<span class="p_chunk">@@ -1399,19 +1400,8 @@</span> <span class="p_context"> static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)</span>
 
 	/*
 	 * Copy the config data.
<span class="p_del">-	 * For the firmware name, keep a local copy of the string,</span>
<span class="p_del">-	 * in order to avoid troubles during device release.</span>
 	 */
<span class="p_del">-	kfree(priv-&gt;ctrl.fname);</span>
<span class="p_del">-	priv-&gt;ctrl.fname = NULL;</span>
 	memcpy(&amp;priv-&gt;ctrl, p, sizeof(priv-&gt;ctrl));
<span class="p_del">-	if (p-&gt;fname) {</span>
<span class="p_del">-		priv-&gt;ctrl.fname = kstrdup(p-&gt;fname, GFP_KERNEL);</span>
<span class="p_del">-		if (priv-&gt;ctrl.fname == NULL) {</span>
<span class="p_del">-			rc = -ENOMEM;</span>
<span class="p_del">-			goto unlock;</span>
<span class="p_del">-		}</span>
<span class="p_del">-	}</span>
 
 	/*
 	 * If firmware name changed, frees firmware. As free_firmware will
<span class="p_chunk">@@ -1426,10 +1416,15 @@</span> <span class="p_context"> static int xc2028_set_config(struct dvb_frontend *fe, void *priv_cfg)</span>
 
 	if (priv-&gt;state == XC2028_NO_FIRMWARE) {
 		if (!firmware_name[0])
<span class="p_del">-			priv-&gt;fname = priv-&gt;ctrl.fname;</span>
<span class="p_add">+			priv-&gt;fname = kstrdup(p-&gt;fname, GFP_KERNEL);</span>
 		else
 			priv-&gt;fname = firmware_name;
 
<span class="p_add">+		if (!priv-&gt;fname) {</span>
<span class="p_add">+			rc = -ENOMEM;</span>
<span class="p_add">+			goto unlock;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		rc = request_firmware_nowait(THIS_MODULE, 1,
 					     priv-&gt;fname,
 					     priv-&gt;i2c_props.adap-&gt;dev.parent,
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-avcore.c b/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_header">index 89de00bf4f82..bd45858cc927 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-avcore.c</span>
<span class="p_chunk">@@ -1260,7 +1260,10 @@</span> <span class="p_context"> int cx231xx_set_agc_analog_digital_mux_select(struct cx231xx *dev,</span>
 				   dev-&gt;board.agc_analog_digital_select_gpio,
 				   analog_or_digital);
 
<span class="p_del">-	return status;</span>
<span class="p_add">+	if (status &lt; 0)</span>
<span class="p_add">+		return status;</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 
 int cx231xx_enable_i2c_port_3(struct cx231xx *dev, bool is_port_3)
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-cards.c b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">index 2ee03e4ddd86..b62b37130f07 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-cards.c</span>
<span class="p_chunk">@@ -489,7 +489,7 @@</span> <span class="p_context"> struct cx231xx_board cx231xx_boards[] = {</span>
 		.output_mode = OUT_MODE_VIP11,
 		.demod_xfer_mode = 0,
 		.ctl_pin_status_mask = 0xFFFFFFC4,
<span class="p_del">-		.agc_analog_digital_select_gpio = 0x00,	/* According with PV cxPolaris.inf file */</span>
<span class="p_add">+		.agc_analog_digital_select_gpio = 0x1c,</span>
 		.tuner_sif_gpio = -1,
 		.tuner_scl_gpio = -1,
 		.tuner_sda_gpio = -1,
<span class="p_header">diff --git a/drivers/media/usb/cx231xx/cx231xx-core.c b/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_header">index 4ba3ce09b713..6f5ffcc19356 100644</span>
<span class="p_header">--- a/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_header">+++ b/drivers/media/usb/cx231xx/cx231xx-core.c</span>
<span class="p_chunk">@@ -723,6 +723,7 @@</span> <span class="p_context"> int cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)</span>
 			break;
 		case CX231XX_BOARD_CNXT_RDE_253S:
 		case CX231XX_BOARD_CNXT_RDU_253S:
<span class="p_add">+		case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:</span>
 			errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 1);
 			break;
 		case CX231XX_BOARD_HAUPPAUGE_EXETER:
<span class="p_chunk">@@ -747,7 +748,7 @@</span> <span class="p_context"> int cx231xx_set_mode(struct cx231xx *dev, enum cx231xx_mode set_mode)</span>
 		case CX231XX_BOARD_PV_PLAYTV_USB_HYBRID:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_PAL:
 		case CX231XX_BOARD_HAUPPAUGE_USB2_FM_NTSC:
<span class="p_del">-		errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);</span>
<span class="p_add">+			errCode = cx231xx_set_agc_analog_digital_mux_select(dev, 0);</span>
 			break;
 		default:
 			break;
<span class="p_header">diff --git a/drivers/media/usb/dvb-usb/dib0700_core.c b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">index c14285fa8271..72eccefce9fc 100644</span>
<span class="p_header">--- a/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_header">+++ b/drivers/media/usb/dvb-usb/dib0700_core.c</span>
<span class="p_chunk">@@ -674,7 +674,7 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 {
 	struct dvb_usb_device *d = purb-&gt;context;
 	struct dib0700_rc_response *poll_reply;
<span class="p_del">-	u32 uninitialized_var(keycode);</span>
<span class="p_add">+	u32 keycode;</span>
 	u8 toggle;
 
 	deb_info(&quot;%s()\n&quot;, __func__);
<span class="p_chunk">@@ -713,7 +713,8 @@</span> <span class="p_context"> static void dib0700_rc_urb_completion(struct urb *purb)</span>
 		if ((poll_reply-&gt;system == 0x00) &amp;&amp; (poll_reply-&gt;data == 0x00)
 		    &amp;&amp; (poll_reply-&gt;not_data == 0xff)) {
 			poll_reply-&gt;data_state = 2;
<span class="p_del">-			break;</span>
<span class="p_add">+			rc_repeat(d-&gt;rc_dev);</span>
<span class="p_add">+			goto resubmit;</span>
 		}
 
 		if ((poll_reply-&gt;system ^ poll_reply-&gt;not_system) != 0xff) {
<span class="p_header">diff --git a/drivers/memstick/host/rtsx_usb_ms.c b/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_header">index a7282b7d4de8..021e4252ee04 100644</span>
<span class="p_header">--- a/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_header">+++ b/drivers/memstick/host/rtsx_usb_ms.c</span>
<span class="p_chunk">@@ -524,6 +524,7 @@</span> <span class="p_context"> static void rtsx_usb_ms_handle_req(struct work_struct *work)</span>
 	int rc;
 
 	if (!host-&gt;req) {
<span class="p_add">+		pm_runtime_get_sync(ms_dev(host));</span>
 		do {
 			rc = memstick_next_req(msh, &amp;host-&gt;req);
 			dev_dbg(ms_dev(host), &quot;next req %d\n&quot;, rc);
<span class="p_chunk">@@ -544,6 +545,7 @@</span> <span class="p_context"> static void rtsx_usb_ms_handle_req(struct work_struct *work)</span>
 						host-&gt;req-&gt;error);
 			}
 		} while (!rc);
<span class="p_add">+		pm_runtime_put(ms_dev(host));</span>
 	}
 
 }
<span class="p_chunk">@@ -570,6 +572,7 @@</span> <span class="p_context"> static int rtsx_usb_ms_set_param(struct memstick_host *msh,</span>
 	dev_dbg(ms_dev(host), &quot;%s: param = %d, value = %d\n&quot;,
 			__func__, param, value);
 
<span class="p_add">+	pm_runtime_get_sync(ms_dev(host));</span>
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 	err = rtsx_usb_card_exclusive_check(ucr, RTSX_USB_MS_CARD);
<span class="p_chunk">@@ -635,6 +638,7 @@</span> <span class="p_context"> static int rtsx_usb_ms_set_param(struct memstick_host *msh,</span>
 	}
 out:
 	mutex_unlock(&amp;ucr-&gt;dev_mutex);
<span class="p_add">+	pm_runtime_put(ms_dev(host));</span>
 
 	/* power-on delay */
 	if (param == MEMSTICK_POWER &amp;&amp; value == MEMSTICK_POWER_ON)
<span class="p_chunk">@@ -681,6 +685,7 @@</span> <span class="p_context"> static int rtsx_usb_detect_ms_card(void *__host)</span>
 	int err;
 
 	for (;;) {
<span class="p_add">+		pm_runtime_get_sync(ms_dev(host));</span>
 		mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 		/* Check pending MS card changes */
<span class="p_chunk">@@ -703,6 +708,7 @@</span> <span class="p_context"> static int rtsx_usb_detect_ms_card(void *__host)</span>
 		}
 
 poll_again:
<span class="p_add">+		pm_runtime_put(ms_dev(host));</span>
 		if (host-&gt;eject)
 			break;
 
<span class="p_header">diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig</span>
<span class="p_header">index 6cc4b6acc22a..34e52be5f255 100644</span>
<span class="p_header">--- a/drivers/mfd/Kconfig</span>
<span class="p_header">+++ b/drivers/mfd/Kconfig</span>
<span class="p_chunk">@@ -1203,6 +1203,7 @@</span> <span class="p_context"> config MFD_WM8350</span>
 config MFD_WM8350_I2C
 	bool &quot;Wolfson Microelectronics WM8350 with I2C&quot;
 	select MFD_WM8350
<span class="p_add">+	select REGMAP_I2C</span>
 	depends on I2C=y
 	help
 	  The WM8350 is an integrated audio and power management
<span class="p_header">diff --git a/drivers/mfd/mfd-core.c b/drivers/mfd/mfd-core.c</span>
<span class="p_header">index 892d343193ad..b8296a98e27e 100644</span>
<span class="p_header">--- a/drivers/mfd/mfd-core.c</span>
<span class="p_header">+++ b/drivers/mfd/mfd-core.c</span>
<span class="p_chunk">@@ -285,6 +285,8 @@</span> <span class="p_context"> int mfd_clone_cell(const char *cell, const char **clones, size_t n_clones)</span>
 					clones[i]);
 	}
 
<span class="p_add">+	put_device(dev);</span>
<span class="p_add">+</span>
 	return 0;
 }
 EXPORT_SYMBOL(mfd_clone_cell);
<span class="p_header">diff --git a/drivers/mfd/rtsx_usb.c b/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">index 8ce5aa0f7474..e07e21ede3d9 100644</span>
<span class="p_header">--- a/drivers/mfd/rtsx_usb.c</span>
<span class="p_header">+++ b/drivers/mfd/rtsx_usb.c</span>
<span class="p_chunk">@@ -46,9 +46,6 @@</span> <span class="p_context"> static void rtsx_usb_sg_timed_out(unsigned long data)</span>
 
 	dev_dbg(&amp;ucr-&gt;pusb_intf-&gt;dev, &quot;%s: sg transfer timed out&quot;, __func__);
 	usb_sg_cancel(&amp;ucr-&gt;current_sg);
<span class="p_del">-</span>
<span class="p_del">-	/* we know the cancellation is caused by time-out */</span>
<span class="p_del">-	ucr-&gt;current_sg.status = -ETIMEDOUT;</span>
 }
 
 static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,
<span class="p_chunk">@@ -67,12 +64,15 @@</span> <span class="p_context"> static int rtsx_usb_bulk_transfer_sglist(struct rtsx_ucr *ucr,</span>
 	ucr-&gt;sg_timer.expires = jiffies + msecs_to_jiffies(timeout);
 	add_timer(&amp;ucr-&gt;sg_timer);
 	usb_sg_wait(&amp;ucr-&gt;current_sg);
<span class="p_del">-	del_timer_sync(&amp;ucr-&gt;sg_timer);</span>
<span class="p_add">+	if (!del_timer_sync(&amp;ucr-&gt;sg_timer))</span>
<span class="p_add">+		ret = -ETIMEDOUT;</span>
<span class="p_add">+	else</span>
<span class="p_add">+		ret = ucr-&gt;current_sg.status;</span>
 
 	if (act_len)
 		*act_len = ucr-&gt;current_sg.bytes;
 
<span class="p_del">-	return ucr-&gt;current_sg.status;</span>
<span class="p_add">+	return ret;</span>
 }
 
 int rtsx_usb_transfer_data(struct rtsx_ucr *ucr, unsigned int pipe,
<span class="p_header">diff --git a/drivers/misc/genwqe/card_utils.c b/drivers/misc/genwqe/card_utils.c</span>
<span class="p_header">index ded1c2507d3d..19dfacc37d76 100644</span>
<span class="p_header">--- a/drivers/misc/genwqe/card_utils.c</span>
<span class="p_header">+++ b/drivers/misc/genwqe/card_utils.c</span>
<span class="p_chunk">@@ -341,17 +341,27 @@</span> <span class="p_context"> int genwqe_alloc_sync_sgl(struct genwqe_dev *cd, struct genwqe_sgl *sgl,</span>
 		if (copy_from_user(sgl-&gt;lpage, user_addr + user_size -
 				   sgl-&gt;lpage_size, sgl-&gt;lpage_size)) {
 			rc = -EFAULT;
<span class="p_del">-			goto err_out1;</span>
<span class="p_add">+			goto err_out2;</span>
 		}
 	}
 	return 0;
 
<span class="p_add">+ err_out2:</span>
<span class="p_add">+	__genwqe_free_consistent(cd, PAGE_SIZE, sgl-&gt;lpage,</span>
<span class="p_add">+				 sgl-&gt;lpage_dma_addr);</span>
<span class="p_add">+	sgl-&gt;lpage = NULL;</span>
<span class="p_add">+	sgl-&gt;lpage_dma_addr = 0;</span>
  err_out1:
 	__genwqe_free_consistent(cd, PAGE_SIZE, sgl-&gt;fpage,
 				 sgl-&gt;fpage_dma_addr);
<span class="p_add">+	sgl-&gt;fpage = NULL;</span>
<span class="p_add">+	sgl-&gt;fpage_dma_addr = 0;</span>
  err_out:
 	__genwqe_free_consistent(cd, sgl-&gt;sgl_size, sgl-&gt;sgl,
 				 sgl-&gt;sgl_dma_addr);
<span class="p_add">+	sgl-&gt;sgl = NULL;</span>
<span class="p_add">+	sgl-&gt;sgl_dma_addr = 0;</span>
<span class="p_add">+	sgl-&gt;sgl_size = 0;</span>
 	return -ENOMEM;
 }
 
<span class="p_header">diff --git a/drivers/misc/mei/hw-txe.c b/drivers/misc/mei/hw-txe.c</span>
<span class="p_header">index 93273783dec5..1cb7d9a820df 100644</span>
<span class="p_header">--- a/drivers/misc/mei/hw-txe.c</span>
<span class="p_header">+++ b/drivers/misc/mei/hw-txe.c</span>
<span class="p_chunk">@@ -876,11 +876,13 @@</span> <span class="p_context"> static bool mei_txe_check_and_ack_intrs(struct mei_device *dev, bool do_ack)</span>
 	hisr = mei_txe_br_reg_read(hw, HISR_REG);
 
 	aliveness = mei_txe_aliveness_get(dev);
<span class="p_del">-	if (hhisr &amp; IPC_HHIER_SEC &amp;&amp; aliveness)</span>
<span class="p_add">+	if (hhisr &amp; IPC_HHIER_SEC &amp;&amp; aliveness) {</span>
 		ipc_isr = mei_txe_sec_reg_read_silent(hw,
 				SEC_IPC_HOST_INT_STATUS_REG);
<span class="p_del">-	else</span>
<span class="p_add">+	} else {</span>
 		ipc_isr = 0;
<span class="p_add">+		hhisr &amp;= ~IPC_HHIER_SEC;</span>
<span class="p_add">+	}</span>
 
 	generated = generated ||
 		(hisr &amp; HISR_INT_STS_MSK) ||
<span class="p_header">diff --git a/drivers/misc/mei/nfc.c b/drivers/misc/mei/nfc.c</span>
<span class="p_header">index 5ccc23bc7690..b4d5cdda26cd 100644</span>
<span class="p_header">--- a/drivers/misc/mei/nfc.c</span>
<span class="p_header">+++ b/drivers/misc/mei/nfc.c</span>
<span class="p_chunk">@@ -292,7 +292,7 @@</span> <span class="p_context"> static int mei_nfc_if_version(struct mei_nfc_dev *ndev)</span>
 		return -ENOMEM;
 
 	bytes_recv = __mei_cl_recv(cl, (u8 *)reply, if_version_length);
<span class="p_del">-	if (bytes_recv &lt; 0 || bytes_recv &lt; sizeof(struct mei_nfc_reply)) {</span>
<span class="p_add">+	if (bytes_recv &lt; if_version_length) {</span>
 		dev_err(&amp;dev-&gt;pdev-&gt;dev, &quot;Could not read IF version\n&quot;);
 		ret = -EIO;
 		goto err;
<span class="p_header">diff --git a/drivers/mmc/card/block.c b/drivers/mmc/card/block.c</span>
<span class="p_header">index 619c67b71ecb..26cac35d1adc 100644</span>
<span class="p_header">--- a/drivers/mmc/card/block.c</span>
<span class="p_header">+++ b/drivers/mmc/card/block.c</span>
<span class="p_chunk">@@ -1647,7 +1647,7 @@</span> <span class="p_context"> static void mmc_blk_packed_hdr_wrq_prep(struct mmc_queue_req *mqrq,</span>
 	struct mmc_blk_data *md = mq-&gt;data;
 	struct mmc_packed *packed = mqrq-&gt;packed;
 	bool do_rel_wr, do_data_tag;
<span class="p_del">-	u32 *packed_cmd_hdr;</span>
<span class="p_add">+	__le32 *packed_cmd_hdr;</span>
 	u8 hdr_blocks;
 	u8 i = 1;
 
<span class="p_chunk">@@ -2170,7 +2170,8 @@</span> <span class="p_context"> static struct mmc_blk_data *mmc_blk_alloc_req(struct mmc_card *card,</span>
 	set_capacity(md-&gt;disk, size);
 
 	if (mmc_host_cmd23(card-&gt;host)) {
<span class="p_del">-		if (mmc_card_mmc(card) ||</span>
<span class="p_add">+		if ((mmc_card_mmc(card) &amp;&amp;</span>
<span class="p_add">+		     card-&gt;csd.mmca_vsn &gt;= CSD_SPEC_VER_3) ||</span>
 		    (mmc_card_sd(card) &amp;&amp;
 		     card-&gt;scr.cmds &amp; SD_SCR_CMD23_SUPPORT))
 			md-&gt;flags |= MMC_BLK_CMD23;
<span class="p_header">diff --git a/drivers/mmc/card/queue.h b/drivers/mmc/card/queue.h</span>
<span class="p_header">index 99e6521e6169..f42c11293dd8 100644</span>
<span class="p_header">--- a/drivers/mmc/card/queue.h</span>
<span class="p_header">+++ b/drivers/mmc/card/queue.h</span>
<span class="p_chunk">@@ -24,7 +24,7 @@</span> <span class="p_context"> enum mmc_packed_type {</span>
 
 struct mmc_packed {
 	struct list_head	list;
<span class="p_del">-	u32			cmd_hdr[1024];</span>
<span class="p_add">+	__le32			cmd_hdr[1024];</span>
 	unsigned int		blocks;
 	u8			nr_entries;
 	u8			retries;
<span class="p_header">diff --git a/drivers/mmc/host/moxart-mmc.c b/drivers/mmc/host/moxart-mmc.c</span>
<span class="p_header">index 74924a04026e..1e2321e3bbbd 100644</span>
<span class="p_header">--- a/drivers/mmc/host/moxart-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/moxart-mmc.c</span>
<span class="p_chunk">@@ -257,7 +257,7 @@</span> <span class="p_context"> static void moxart_dma_complete(void *param)</span>
 static void moxart_transfer_dma(struct mmc_data *data, struct moxart_host *host)
 {
 	u32 len, dir_data, dir_slave;
<span class="p_del">-	unsigned long dma_time;</span>
<span class="p_add">+	long dma_time;</span>
 	struct dma_async_tx_descriptor *desc = NULL;
 	struct dma_chan *dma_chan;
 
<span class="p_chunk">@@ -397,7 +397,8 @@</span> <span class="p_context"> static void moxart_prepare_data(struct moxart_host *host)</span>
 static void moxart_request(struct mmc_host *mmc, struct mmc_request *mrq)
 {
 	struct moxart_host *host = mmc_priv(mmc);
<span class="p_del">-	unsigned long pio_time, flags;</span>
<span class="p_add">+	long pio_time;</span>
<span class="p_add">+	unsigned long flags;</span>
 	u32 status;
 
 	spin_lock_irqsave(&amp;host-&gt;lock, flags);
<span class="p_header">diff --git a/drivers/mmc/host/mxs-mmc.c b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">index babfea03ba8a..ad32f235bdb8 100644</span>
<span class="p_header">--- a/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/mxs-mmc.c</span>
<span class="p_chunk">@@ -658,13 +658,13 @@</span> <span class="p_context"> static int mxs_mmc_probe(struct platform_device *pdev)</span>
 
 	platform_set_drvdata(pdev, mmc);
 
<span class="p_add">+	spin_lock_init(&amp;host-&gt;lock);</span>
<span class="p_add">+</span>
 	ret = devm_request_irq(&amp;pdev-&gt;dev, irq_err, mxs_mmc_irq_handler, 0,
 			       DRIVER_NAME, host);
 	if (ret)
 		goto out_free_dma;
 
<span class="p_del">-	spin_lock_init(&amp;host-&gt;lock);</span>
<span class="p_del">-</span>
 	ret = mmc_add_host(mmc);
 	if (ret)
 		goto out_free_dma;
<span class="p_header">diff --git a/drivers/mmc/host/rtsx_usb_sdmmc.c b/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_header">index d9153a7d160d..b74cfc7f9c54 100644</span>
<span class="p_header">--- a/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_header">+++ b/drivers/mmc/host/rtsx_usb_sdmmc.c</span>
<span class="p_chunk">@@ -1138,11 +1138,6 @@</span> <span class="p_context"> static void sdmmc_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)</span>
 	dev_dbg(sdmmc_dev(host), &quot;%s\n&quot;, __func__);
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
<span class="p_del">-	if (rtsx_usb_card_exclusive_check(ucr, RTSX_USB_SD_CARD)) {</span>
<span class="p_del">-		mutex_unlock(&amp;ucr-&gt;dev_mutex);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	sd_set_power_mode(host, ios-&gt;power_mode);
 	sd_set_bus_width(host, ios-&gt;bus_width);
 	sd_set_timing(host, ios-&gt;timing, &amp;host-&gt;ddr_mode);
<span class="p_chunk">@@ -1314,6 +1309,7 @@</span> <span class="p_context"> static void rtsx_usb_update_led(struct work_struct *work)</span>
 		container_of(work, struct rtsx_usb_sdmmc, led_work);
 	struct rtsx_ucr *ucr = host-&gt;ucr;
 
<span class="p_add">+	pm_runtime_get_sync(sdmmc_dev(host));</span>
 	mutex_lock(&amp;ucr-&gt;dev_mutex);
 
 	if (host-&gt;led.brightness == LED_OFF)
<span class="p_chunk">@@ -1322,6 +1318,7 @@</span> <span class="p_context"> static void rtsx_usb_update_led(struct work_struct *work)</span>
 		rtsx_usb_turn_on_led(ucr);
 
 	mutex_unlock(&amp;ucr-&gt;dev_mutex);
<span class="p_add">+	pm_runtime_put(sdmmc_dev(host));</span>
 }
 #endif
 
<span class="p_header">diff --git a/drivers/mmc/host/sdhci.c b/drivers/mmc/host/sdhci.c</span>
<span class="p_header">index a595d7e289ab..5114206df053 100644</span>
<span class="p_header">--- a/drivers/mmc/host/sdhci.c</span>
<span class="p_header">+++ b/drivers/mmc/host/sdhci.c</span>
<span class="p_chunk">@@ -669,7 +669,7 @@</span> <span class="p_context"> static u8 sdhci_calc_timeout(struct sdhci_host *host, struct mmc_command *cmd)</span>
 			 * host-&gt;clock is in Hz.  target_timeout is in us.
 			 * Hence, us = 1000000 * cycles / Hz.  Round up.
 			 */
<span class="p_del">-			val = 1000000 * data-&gt;timeout_clks;</span>
<span class="p_add">+			val = 1000000ULL * data-&gt;timeout_clks;</span>
 			if (do_div(val, host-&gt;clock))
 				target_timeout++;
 			target_timeout += val;
<span class="p_header">diff --git a/drivers/mtd/ubi/eba.c b/drivers/mtd/ubi/eba.c</span>
<span class="p_header">index 0fd03856f8de..6b169968e303 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/eba.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/eba.c</span>
<span class="p_chunk">@@ -1021,6 +1021,8 @@</span> <span class="p_context"> int ubi_eba_copy_leb(struct ubi_device *ubi, int from, int to,</span>
 	struct ubi_volume *vol;
 	uint32_t crc;
 
<span class="p_add">+	ubi_assert(rwsem_is_locked(&amp;ubi-&gt;fm_sem));</span>
<span class="p_add">+</span>
 	vol_id = be32_to_cpu(vid_hdr-&gt;vol_id);
 	lnum = be32_to_cpu(vid_hdr-&gt;lnum);
 
<span class="p_chunk">@@ -1189,9 +1191,7 @@</span> <span class="p_context"> int ubi_eba_copy_leb(struct ubi_device *ubi, int from, int to,</span>
 	}
 
 	ubi_assert(vol-&gt;eba_tbl[lnum] == from);
<span class="p_del">-	down_read(&amp;ubi-&gt;fm_sem);</span>
 	vol-&gt;eba_tbl[lnum] = to;
<span class="p_del">-	up_read(&amp;ubi-&gt;fm_sem);</span>
 
 out_unlock_buf:
 	mutex_unlock(&amp;ubi-&gt;buf_mutex);
<span class="p_header">diff --git a/drivers/mtd/ubi/fastmap.c b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">index 5c0b66ed1ddb..d2ee2576b449 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/fastmap.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/fastmap.c</span>
<span class="p_chunk">@@ -258,6 +258,7 @@</span> <span class="p_context"> static int update_vol(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 			aeb-&gt;pnum = new_aeb-&gt;pnum;
 			aeb-&gt;copy_flag = new_vh-&gt;copy_flag;
 			aeb-&gt;scrub = new_aeb-&gt;scrub;
<span class="p_add">+			aeb-&gt;sqnum = new_aeb-&gt;sqnum;</span>
 			kmem_cache_free(ai-&gt;aeb_slab_cache, new_aeb);
 
 		/* new_aeb is older */
<span class="p_chunk">@@ -445,10 +446,11 @@</span> <span class="p_context"> static int scan_pool(struct ubi_device *ubi, struct ubi_attach_info *ai,</span>
 			unsigned long long ec = be64_to_cpu(ech-&gt;ec);
 			unmap_peb(ai, pnum);
 			dbg_bld(&quot;Adding PEB to free: %i&quot;, pnum);
<span class="p_add">+</span>
 			if (err == UBI_IO_FF_BITFLIPS)
<span class="p_del">-				add_aeb(ai, free, pnum, ec, 1);</span>
<span class="p_del">-			else</span>
<span class="p_del">-				add_aeb(ai, free, pnum, ec, 0);</span>
<span class="p_add">+				scrub = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+			add_aeb(ai, free, pnum, ec, scrub);</span>
 			continue;
 		} else if (err == 0 || err == UBI_IO_BITFLIPS) {
 			dbg_bld(&quot;Found non empty PEB:%i in pool&quot;, pnum);
<span class="p_chunk">@@ -1412,22 +1414,30 @@</span> <span class="p_context"> int ubi_update_fastmap(struct ubi_device *ubi)</span>
 	struct ubi_wl_entry *tmp_e;
 
 	mutex_lock(&amp;ubi-&gt;fm_mutex);
<span class="p_add">+	down_write(&amp;ubi-&gt;work_sem);</span>
<span class="p_add">+	down_write(&amp;ubi-&gt;fm_sem);</span>
 
 	ubi_refill_pools(ubi);
 
 	if (ubi-&gt;ro_mode || ubi-&gt;fm_disabled) {
<span class="p_add">+		up_write(&amp;ubi-&gt;fm_sem);</span>
<span class="p_add">+		up_write(&amp;ubi-&gt;work_sem);</span>
 		mutex_unlock(&amp;ubi-&gt;fm_mutex);
 		return 0;
 	}
 
 	ret = ubi_ensure_anchor_pebs(ubi);
 	if (ret) {
<span class="p_add">+		up_write(&amp;ubi-&gt;fm_sem);</span>
<span class="p_add">+		up_write(&amp;ubi-&gt;work_sem);</span>
 		mutex_unlock(&amp;ubi-&gt;fm_mutex);
 		return ret;
 	}
 
 	new_fm = kzalloc(sizeof(*new_fm), GFP_KERNEL);
 	if (!new_fm) {
<span class="p_add">+		up_write(&amp;ubi-&gt;fm_sem);</span>
<span class="p_add">+		up_write(&amp;ubi-&gt;work_sem);</span>
 		mutex_unlock(&amp;ubi-&gt;fm_mutex);
 		return -ENOMEM;
 	}
<span class="p_chunk">@@ -1538,16 +1548,14 @@</span> <span class="p_context"> int ubi_update_fastmap(struct ubi_device *ubi)</span>
 		new_fm-&gt;e[0]-&gt;ec = tmp_e-&gt;ec;
 	}
 
<span class="p_del">-	down_write(&amp;ubi-&gt;work_sem);</span>
<span class="p_del">-	down_write(&amp;ubi-&gt;fm_sem);</span>
 	ret = ubi_write_fastmap(ubi, new_fm);
<span class="p_del">-	up_write(&amp;ubi-&gt;fm_sem);</span>
<span class="p_del">-	up_write(&amp;ubi-&gt;work_sem);</span>
 
 	if (ret)
 		goto err;
 
 out_unlock:
<span class="p_add">+	up_write(&amp;ubi-&gt;fm_sem);</span>
<span class="p_add">+	up_write(&amp;ubi-&gt;work_sem);</span>
 	mutex_unlock(&amp;ubi-&gt;fm_mutex);
 	kfree(old_fm);
 	return ret;
<span class="p_header">diff --git a/drivers/mtd/ubi/wl.c b/drivers/mtd/ubi/wl.c</span>
<span class="p_header">index a5eb1f667ef8..371a973e718e 100644</span>
<span class="p_header">--- a/drivers/mtd/ubi/wl.c</span>
<span class="p_header">+++ b/drivers/mtd/ubi/wl.c</span>
<span class="p_chunk">@@ -653,6 +653,8 @@</span> <span class="p_context"> static struct ubi_wl_entry *get_peb_for_wl(struct ubi_device *ubi)</span>
 	struct ubi_fm_pool *pool = &amp;ubi-&gt;fm_wl_pool;
 	int pnum;
 
<span class="p_add">+	ubi_assert(rwsem_is_locked(&amp;ubi-&gt;fm_sem));</span>
<span class="p_add">+</span>
 	if (pool-&gt;used == pool-&gt;size || !pool-&gt;size) {
 		/* We cannot update the fastmap here because this
 		 * function is called in atomic context.
<span class="p_chunk">@@ -889,7 +891,7 @@</span> <span class="p_context"> int ubi_is_erase_work(struct ubi_work *wrk)</span>
  * failure.
  */
 static int schedule_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,
<span class="p_del">-			  int vol_id, int lnum, int torture)</span>
<span class="p_add">+			  int vol_id, int lnum, int torture, bool nested)</span>
 {
 	struct ubi_work *wl_wrk;
 
<span class="p_chunk">@@ -909,7 +911,10 @@</span> <span class="p_context"> static int schedule_erase(struct ubi_device *ubi, struct ubi_wl_entry *e,</span>
 	wl_wrk-&gt;lnum = lnum;
 	wl_wrk-&gt;torture = torture;
 
<span class="p_del">-	schedule_ubi_work(ubi, wl_wrk);</span>
<span class="p_add">+	if (nested)</span>
<span class="p_add">+		__schedule_ubi_work(ubi, wl_wrk);</span>
<span class="p_add">+	else</span>
<span class="p_add">+		schedule_ubi_work(ubi, wl_wrk);</span>
 	return 0;
 }
 
<span class="p_chunk">@@ -982,7 +987,7 @@</span> <span class="p_context"> int ubi_wl_put_fm_peb(struct ubi_device *ubi, struct ubi_wl_entry *fm_e,</span>
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 
 	vol_id = lnum ? UBI_FM_DATA_VOLUME_ID : UBI_FM_SB_VOLUME_ID;
<span class="p_del">-	return schedule_erase(ubi, e, vol_id, lnum, torture);</span>
<span class="p_add">+	return schedule_erase(ubi, e, vol_id, lnum, torture, true);</span>
 }
 #endif
 
<span class="p_chunk">@@ -1000,7 +1005,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 				int cancel)
 {
 	int err, scrubbing = 0, torture = 0, protect = 0, erroneous = 0;
<span class="p_del">-	int vol_id = -1, lnum = -1;</span>
<span class="p_add">+	int erase = 0, keep = 0, vol_id = -1, lnum = -1;</span>
 #ifdef CONFIG_MTD_UBI_FASTMAP
 	int anchor = wrk-&gt;anchor;
 #endif
<span class="p_chunk">@@ -1015,6 +1020,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 	if (!vid_hdr)
 		return -ENOMEM;
 
<span class="p_add">+	down_read(&amp;ubi-&gt;fm_sem);</span>
 	mutex_lock(&amp;ubi-&gt;move_mutex);
 	spin_lock(&amp;ubi-&gt;wl_lock);
 	ubi_assert(!ubi-&gt;move_from &amp;&amp; !ubi-&gt;move_to);
<span class="p_chunk">@@ -1134,6 +1140,16 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 			       e1-&gt;pnum);
 			scrubbing = 1;
 			goto out_not_moved;
<span class="p_add">+		} else if (ubi-&gt;fast_attach &amp;&amp; err == UBI_IO_BAD_HDR_EBADMSG) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * While a full scan would detect interrupted erasures</span>
<span class="p_add">+			 * at attach time we can face them here when attached from</span>
<span class="p_add">+			 * Fastmap.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			dbg_wl(&quot;PEB %d has ECC errors, maybe from an interrupted erasure&quot;,</span>
<span class="p_add">+			       e1-&gt;pnum);</span>
<span class="p_add">+			erase = 1;</span>
<span class="p_add">+			goto out_not_moved;</span>
 		}
 
 		ubi_err(&quot;error %d while reading VID header from PEB %d&quot;,
<span class="p_chunk">@@ -1167,6 +1183,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 			 * Target PEB had bit-flips or write error - torture it.
 			 */
 			torture = 1;
<span class="p_add">+			keep = 1;</span>
 			goto out_not_moved;
 		}
 
<span class="p_chunk">@@ -1230,6 +1247,7 @@</span> <span class="p_context"> static int wear_leveling_worker(struct ubi_device *ubi, struct ubi_work *wrk,</span>
 
 	dbg_wl(&quot;done&quot;);
 	mutex_unlock(&amp;ubi-&gt;move_mutex);
<span class="p_add">+	up_read(&amp;ubi-&gt;fm_sem);</span>
 	return 0;
 
 	/*
<span class="p_chunk">@@ -1252,7 +1270,7 @@</span> <span class="p_context"> out_not_moved:</span>
 		ubi-&gt;erroneous_peb_count += 1;
 	} else if (scrubbing)
 		wl_tree_add(e1, &amp;ubi-&gt;scrub);
<span class="p_del">-	else</span>
<span class="p_add">+	else if (keep)</span>
 		wl_tree_add(e1, &amp;ubi-&gt;used);
 	ubi_assert(!ubi-&gt;move_to_put);
 	ubi-&gt;move_from = ubi-&gt;move_to = NULL;
<span class="p_chunk">@@ -1264,7 +1282,14 @@</span> <span class="p_context"> out_not_moved:</span>
 	if (err)
 		goto out_ro;
 
<span class="p_add">+	if (erase) {</span>
<span class="p_add">+		err = do_sync_erase(ubi, e1, vol_id, lnum, 1);</span>
<span class="p_add">+		if (err)</span>
<span class="p_add">+			goto out_ro;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	mutex_unlock(&amp;ubi-&gt;move_mutex);
<span class="p_add">+	up_read(&amp;ubi-&gt;fm_sem);</span>
 	return 0;
 
 out_error:
<span class="p_chunk">@@ -1286,6 +1311,7 @@</span> <span class="p_context"> out_error:</span>
 out_ro:
 	ubi_ro_mode(ubi);
 	mutex_unlock(&amp;ubi-&gt;move_mutex);
<span class="p_add">+	up_read(&amp;ubi-&gt;fm_sem);</span>
 	ubi_assert(err != 0);
 	return err &lt; 0 ? err : -EIO;
 
<span class="p_chunk">@@ -1293,6 +1319,7 @@</span> <span class="p_context"> out_cancel:</span>
 	ubi-&gt;wl_scheduled = 0;
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 	mutex_unlock(&amp;ubi-&gt;move_mutex);
<span class="p_add">+	up_read(&amp;ubi-&gt;fm_sem);</span>
 	ubi_free_vid_hdr(ubi, vid_hdr);
 	return 0;
 }
<span class="p_chunk">@@ -1394,7 +1421,7 @@</span> <span class="p_context"> int ubi_ensure_anchor_pebs(struct ubi_device *ubi)</span>
 
 	wrk-&gt;anchor = 1;
 	wrk-&gt;func = &amp;wear_leveling_worker;
<span class="p_del">-	schedule_ubi_work(ubi, wrk);</span>
<span class="p_add">+	__schedule_ubi_work(ubi, wrk);</span>
 	return 0;
 }
 #endif
<span class="p_chunk">@@ -1460,7 +1487,7 @@</span> <span class="p_context"> static int erase_worker(struct ubi_device *ubi, struct ubi_work *wl_wrk,</span>
 		int err1;
 
 		/* Re-schedule the LEB for erasure */
<span class="p_del">-		err1 = schedule_erase(ubi, e, vol_id, lnum, 0);</span>
<span class="p_add">+		err1 = schedule_erase(ubi, e, vol_id, lnum, 0, false);</span>
 		if (err1) {
 			err = err1;
 			goto out_ro;
<span class="p_chunk">@@ -1616,7 +1643,7 @@</span> <span class="p_context"> retry:</span>
 	}
 	spin_unlock(&amp;ubi-&gt;wl_lock);
 
<span class="p_del">-	err = schedule_erase(ubi, e, vol_id, lnum, torture);</span>
<span class="p_add">+	err = schedule_erase(ubi, e, vol_id, lnum, torture, false);</span>
 	if (err) {
 		spin_lock(&amp;ubi-&gt;wl_lock);
 		wl_tree_add(e, &amp;ubi-&gt;used);
<span class="p_chunk">@@ -1905,7 +1932,7 @@</span> <span class="p_context"> int ubi_wl_init(struct ubi_device *ubi, struct ubi_attach_info *ai)</span>
 		e-&gt;ec = aeb-&gt;ec;
 		ubi_assert(!ubi_is_fm_block(ubi, e-&gt;pnum));
 		ubi-&gt;lookuptbl[e-&gt;pnum] = e;
<span class="p_del">-		if (schedule_erase(ubi, e, aeb-&gt;vol_id, aeb-&gt;lnum, 0)) {</span>
<span class="p_add">+		if (schedule_erase(ubi, e, aeb-&gt;vol_id, aeb-&gt;lnum, 0, false)) {</span>
 			kmem_cache_free(ubi_wl_entry_slab, e);
 			goto out_free;
 		}
<span class="p_header">diff --git a/drivers/net/can/usb/peak_usb/pcan_usb_core.c b/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_header">index dc807e10f802..3f79814f51ce 100644</span>
<span class="p_header">--- a/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_header">+++ b/drivers/net/can/usb/peak_usb/pcan_usb_core.c</span>
<span class="p_chunk">@@ -826,23 +826,25 @@</span> <span class="p_context"> lbl_free_candev:</span>
 static void peak_usb_disconnect(struct usb_interface *intf)
 {
 	struct peak_usb_device *dev;
<span class="p_add">+	struct peak_usb_device *dev_prev_siblings;</span>
 
 	/* unregister as many netdev devices as siblings */
<span class="p_del">-	for (dev = usb_get_intfdata(intf); dev; dev = dev-&gt;prev_siblings) {</span>
<span class="p_add">+	for (dev = usb_get_intfdata(intf); dev; dev = dev_prev_siblings) {</span>
 		struct net_device *netdev = dev-&gt;netdev;
 		char name[IFNAMSIZ];
 
<span class="p_add">+		dev_prev_siblings = dev-&gt;prev_siblings;</span>
 		dev-&gt;state &amp;= ~PCAN_USB_STATE_CONNECTED;
 		strncpy(name, netdev-&gt;name, IFNAMSIZ);
 
 		unregister_netdev(netdev);
<span class="p_del">-		free_candev(netdev);</span>
 
 		kfree(dev-&gt;cmd_buf);
 		dev-&gt;next_siblings = NULL;
 		if (dev-&gt;adapter-&gt;dev_free)
 			dev-&gt;adapter-&gt;dev_free(dev);
 
<span class="p_add">+		free_candev(netdev);</span>
 		dev_info(&amp;intf-&gt;dev, &quot;%s removed\n&quot;, name);
 	}
 
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bcmsysport.c b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">index c583dd58268b..3cca6047578b 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bcmsysport.c</span>
<span class="p_chunk">@@ -58,8 +58,8 @@</span> <span class="p_context"> BCM_SYSPORT_IO_MACRO(topctrl, SYS_PORT_TOPCTRL_OFFSET);</span>
 static inline void intrl2_##which##_mask_clear(struct bcm_sysport_priv *priv, \
 						u32 mask)		\
 {									\
<span class="p_del">-	intrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);	\</span>
 	priv-&gt;irq##which##_mask &amp;= ~(mask);				\
<span class="p_add">+	intrl2_##which##_writel(priv, mask, INTRL2_CPU_MASK_CLEAR);	\</span>
 }									\
 static inline void intrl2_##which##_mask_set(struct bcm_sysport_priv *priv, \
 						u32 mask)		\
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/bgmac.c b/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_header">index 41877a3f8596..4f95e7222834 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/bgmac.c</span>
<span class="p_chunk">@@ -253,6 +253,10 @@</span> <span class="p_context"> static void bgmac_dma_rx_enable(struct bgmac *bgmac,</span>
 	u32 ctl;
 
 	ctl = bgmac_read(bgmac, ring-&gt;mmio_base + BGMAC_DMA_RX_CTL);
<span class="p_add">+</span>
<span class="p_add">+	/* preserve ONLY bits 16-17 from current hardware value */</span>
<span class="p_add">+	ctl &amp;= BGMAC_DMA_RX_ADDREXT_MASK;</span>
<span class="p_add">+</span>
 	if (bgmac-&gt;core-&gt;id.rev &gt;= 4) {
 		ctl &amp;= ~BGMAC_DMA_RX_BL_MASK;
 		ctl |= BGMAC_DMA_RX_BL_128 &lt;&lt; BGMAC_DMA_RX_BL_SHIFT;
<span class="p_chunk">@@ -263,7 +267,6 @@</span> <span class="p_context"> static void bgmac_dma_rx_enable(struct bgmac *bgmac,</span>
 		ctl &amp;= ~BGMAC_DMA_RX_PT_MASK;
 		ctl |= BGMAC_DMA_RX_PT_1 &lt;&lt; BGMAC_DMA_RX_PT_SHIFT;
 	}
<span class="p_del">-	ctl &amp;= BGMAC_DMA_RX_ADDREXT_MASK;</span>
 	ctl |= BGMAC_DMA_RX_ENABLE;
 	ctl |= BGMAC_DMA_RX_PARITY_DISABLE;
 	ctl |= BGMAC_DMA_RX_OVERFLOW_CONT;
<span class="p_header">diff --git a/drivers/net/ethernet/broadcom/genet/bcmgenet.c b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">index 9cbfda2961ec..55a2caa20298 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/broadcom/genet/bcmgenet.c</span>
<span class="p_chunk">@@ -878,6 +878,7 @@</span> <span class="p_context"> static void __bcmgenet_tx_reclaim(struct net_device *dev,</span>
 				struct bcmgenet_tx_ring *ring)
 {
 	struct bcmgenet_priv *priv = netdev_priv(dev);
<span class="p_add">+	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
 	int last_tx_cn, last_c_index, num_tx_bds;
 	struct enet_cb *tx_cb_ptr;
 	struct netdev_queue *txq;
<span class="p_chunk">@@ -907,7 +908,7 @@</span> <span class="p_context"> static void __bcmgenet_tx_reclaim(struct net_device *dev,</span>
 		tx_cb_ptr = ring-&gt;cbs + last_c_index;
 		if (tx_cb_ptr-&gt;skb) {
 			dev-&gt;stats.tx_bytes += tx_cb_ptr-&gt;skb-&gt;len;
<span class="p_del">-			dma_unmap_single(&amp;dev-&gt;dev,</span>
<span class="p_add">+			dma_unmap_single(kdev,</span>
 					dma_unmap_addr(tx_cb_ptr, dma_addr),
 					dma_unmap_len(tx_cb_ptr, dma_len),
 					DMA_TO_DEVICE);
<span class="p_chunk">@@ -915,7 +916,7 @@</span> <span class="p_context"> static void __bcmgenet_tx_reclaim(struct net_device *dev,</span>
 		} else if (dma_unmap_addr(tx_cb_ptr, dma_addr)) {
 			dev-&gt;stats.tx_bytes +=
 				dma_unmap_len(tx_cb_ptr, dma_len);
<span class="p_del">-			dma_unmap_page(&amp;dev-&gt;dev,</span>
<span class="p_add">+			dma_unmap_page(kdev,</span>
 					dma_unmap_addr(tx_cb_ptr, dma_addr),
 					dma_unmap_len(tx_cb_ptr, dma_len),
 					DMA_TO_DEVICE);
<span class="p_chunk">@@ -1257,6 +1258,7 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 				     unsigned int budget)
 {
 	struct net_device *dev = priv-&gt;dev;
<span class="p_add">+	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
 	struct enet_cb *cb;
 	struct sk_buff *skb;
 	u32 dma_length_status;
<span class="p_chunk">@@ -1288,7 +1290,7 @@</span> <span class="p_context"> static unsigned int bcmgenet_desc_rx(struct bcmgenet_priv *priv,</span>
 		 */
 		cb = &amp;priv-&gt;rx_cbs[priv-&gt;rx_read_ptr];
 		skb = cb-&gt;skb;
<span class="p_del">-		dma_unmap_single(&amp;dev-&gt;dev, dma_unmap_addr(cb, dma_addr),</span>
<span class="p_add">+		dma_unmap_single(kdev, dma_unmap_addr(cb, dma_addr),</span>
 				priv-&gt;rx_buf_len, DMA_FROM_DEVICE);
 
 		if (!priv-&gt;desc_64b_en) {
<span class="p_chunk">@@ -1428,6 +1430,7 @@</span> <span class="p_context"> static int bcmgenet_alloc_rx_buffers(struct bcmgenet_priv *priv)</span>
 
 static void bcmgenet_free_rx_buffers(struct bcmgenet_priv *priv)
 {
<span class="p_add">+	struct device *kdev = &amp;priv-&gt;pdev-&gt;dev;</span>
 	struct enet_cb *cb;
 	int i;
 
<span class="p_chunk">@@ -1435,7 +1438,7 @@</span> <span class="p_context"> static void bcmgenet_free_rx_buffers(struct bcmgenet_priv *priv)</span>
 		cb = &amp;priv-&gt;rx_cbs[i];
 
 		if (dma_unmap_addr(cb, dma_addr)) {
<span class="p_del">-			dma_unmap_single(&amp;priv-&gt;dev-&gt;dev,</span>
<span class="p_add">+			dma_unmap_single(kdev,</span>
 					dma_unmap_addr(cb, dma_addr),
 					priv-&gt;rx_buf_len, DMA_FROM_DEVICE);
 			dma_unmap_addr_set(cb, dma_addr, 0);
<span class="p_header">diff --git a/drivers/net/ethernet/cirrus/ep93xx_eth.c b/drivers/net/ethernet/cirrus/ep93xx_eth.c</span>
<span class="p_header">index 2be2a99c5ea3..ea8df797fae2 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/cirrus/ep93xx_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/cirrus/ep93xx_eth.c</span>
<span class="p_chunk">@@ -468,6 +468,9 @@</span> <span class="p_context"> static void ep93xx_free_buffers(struct ep93xx_priv *ep)</span>
 	struct device *dev = ep-&gt;dev-&gt;dev.parent;
 	int i;
 
<span class="p_add">+	if (!ep-&gt;descs)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; RX_QUEUE_ENTRIES; i++) {
 		dma_addr_t d;
 
<span class="p_chunk">@@ -492,6 +495,7 @@</span> <span class="p_context"> static void ep93xx_free_buffers(struct ep93xx_priv *ep)</span>
 
 	dma_free_coherent(dev, sizeof(struct ep93xx_descs), ep-&gt;descs,
 							ep-&gt;descs_dma_addr);
<span class="p_add">+	ep-&gt;descs = NULL;</span>
 }
 
 static int ep93xx_alloc_buffers(struct ep93xx_priv *ep)
<span class="p_header">diff --git a/drivers/net/ethernet/intel/i40e/i40e_main.c b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">index 275ca9a1719e..fd388cc8c22e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c</span>
<span class="p_chunk">@@ -8829,6 +8829,12 @@</span> <span class="p_context"> static pci_ers_result_t i40e_pci_error_detected(struct pci_dev *pdev,</span>
 
 	dev_info(&amp;pdev-&gt;dev, &quot;%s: error %d\n&quot;, __func__, error);
 
<span class="p_add">+	if (!pf) {</span>
<span class="p_add">+		dev_info(&amp;pdev-&gt;dev,</span>
<span class="p_add">+			 &quot;Cannot recover - error happened during device probe\n&quot;);</span>
<span class="p_add">+		return PCI_ERS_RESULT_DISCONNECT;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	/* shutdown all operations */
 	if (!test_bit(__I40E_SUSPENDED, &amp;pf-&gt;state)) {
 		rtnl_lock();
<span class="p_header">diff --git a/drivers/net/ethernet/marvell/mvneta.c b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">index 4d468707a866..eada8449e00e 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/marvell/mvneta.c</span>
<span class="p_chunk">@@ -3078,7 +3078,7 @@</span> <span class="p_context"> static int mvneta_probe(struct platform_device *pdev)</span>
 	dev-&gt;features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_TSO;
 	dev-&gt;hw_features |= dev-&gt;features;
 	dev-&gt;vlan_features |= dev-&gt;features;
<span class="p_del">-	dev-&gt;priv_flags |= IFF_UNICAST_FLT | IFF_LIVE_ADDR_CHANGE;</span>
<span class="p_add">+	dev-&gt;priv_flags |= IFF_LIVE_ADDR_CHANGE;</span>
 	dev-&gt;gso_max_segs = MVNETA_MAX_TSO_SEGS;
 
 	err = register_netdev(dev);
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/cmd.c b/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_header">index 1a12cec9e02a..0c158ec3170d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/cmd.c</span>
<span class="p_chunk">@@ -606,14 +606,20 @@</span> <span class="p_context"> int __mlx4_cmd(struct mlx4_dev *dev, u64 in_param, u64 *out_param,</span>
 		return -EIO;
 
 	if (!mlx4_is_mfunc(dev) || (native &amp;&amp; mlx4_is_master(dev))) {
<span class="p_add">+		int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		down_read(&amp;mlx4_priv(dev)-&gt;cmd.switch_sem);</span>
 		if (mlx4_priv(dev)-&gt;cmd.use_events)
<span class="p_del">-			return mlx4_cmd_wait(dev, in_param, out_param,</span>
<span class="p_del">-					     out_is_imm, in_modifier,</span>
<span class="p_del">-					     op_modifier, op, timeout);</span>
<span class="p_add">+			ret = mlx4_cmd_wait(dev, in_param, out_param,</span>
<span class="p_add">+					    out_is_imm, in_modifier,</span>
<span class="p_add">+					    op_modifier, op, timeout);</span>
 		else
<span class="p_del">-			return mlx4_cmd_poll(dev, in_param, out_param,</span>
<span class="p_del">-					     out_is_imm, in_modifier,</span>
<span class="p_del">-					     op_modifier, op, timeout);</span>
<span class="p_add">+			ret = mlx4_cmd_poll(dev, in_param, out_param,</span>
<span class="p_add">+					    out_is_imm, in_modifier,</span>
<span class="p_add">+					    op_modifier, op, timeout);</span>
<span class="p_add">+</span>
<span class="p_add">+		up_read(&amp;mlx4_priv(dev)-&gt;cmd.switch_sem);</span>
<span class="p_add">+		return ret;</span>
 	}
 	return mlx4_slave_cmd(dev, in_param, out_param, out_is_imm,
 			      in_modifier, op_modifier, op, timeout);
<span class="p_chunk">@@ -2092,6 +2098,7 @@</span> <span class="p_context"> int mlx4_cmd_init(struct mlx4_dev *dev)</span>
 {
 	struct mlx4_priv *priv = mlx4_priv(dev);
 
<span class="p_add">+	init_rwsem(&amp;priv-&gt;cmd.switch_sem);</span>
 	mutex_init(&amp;priv-&gt;cmd.hcr_mutex);
 	mutex_init(&amp;priv-&gt;cmd.slave_cmd_mutex);
 	sema_init(&amp;priv-&gt;cmd.poll_sem, 1);
<span class="p_chunk">@@ -2188,6 +2195,7 @@</span> <span class="p_context"> int mlx4_cmd_use_events(struct mlx4_dev *dev)</span>
 	if (!priv-&gt;cmd.context)
 		return -ENOMEM;
 
<span class="p_add">+	down_write(&amp;priv-&gt;cmd.switch_sem);</span>
 	for (i = 0; i &lt; priv-&gt;cmd.max_cmds; ++i) {
 		priv-&gt;cmd.context[i].token = i;
 		priv-&gt;cmd.context[i].next  = i + 1;
<span class="p_chunk">@@ -2207,6 +2215,7 @@</span> <span class="p_context"> int mlx4_cmd_use_events(struct mlx4_dev *dev)</span>
 
 	down(&amp;priv-&gt;cmd.poll_sem);
 	priv-&gt;cmd.use_events = 1;
<span class="p_add">+	up_write(&amp;priv-&gt;cmd.switch_sem);</span>
 
 	return err;
 }
<span class="p_chunk">@@ -2219,6 +2228,7 @@</span> <span class="p_context"> void mlx4_cmd_use_polling(struct mlx4_dev *dev)</span>
 	struct mlx4_priv *priv = mlx4_priv(dev);
 	int i;
 
<span class="p_add">+	down_write(&amp;priv-&gt;cmd.switch_sem);</span>
 	priv-&gt;cmd.use_events = 0;
 
 	for (i = 0; i &lt; priv-&gt;cmd.max_cmds; ++i)
<span class="p_chunk">@@ -2227,6 +2237,7 @@</span> <span class="p_context"> void mlx4_cmd_use_polling(struct mlx4_dev *dev)</span>
 	kfree(priv-&gt;cmd.context);
 
 	up(&amp;priv-&gt;cmd.poll_sem);
<span class="p_add">+	up_write(&amp;priv-&gt;cmd.switch_sem);</span>
 }
 
 struct mlx4_cmd_mailbox *mlx4_alloc_cmd_mailbox(struct mlx4_dev *dev)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_clock.c b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">index 74e783ba68ea..a6c7737b7001 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_clock.c</span>
<span class="p_chunk">@@ -294,8 +294,11 @@</span> <span class="p_context"> static u32 freq_to_shift(u16 freq)</span>
 {
 	u32 freq_khz = freq * 1000;
 	u64 max_val_cycles = freq_khz * 1000 * MLX4_EN_WRAP_AROUND_SEC;
<span class="p_add">+	u64 tmp_rounded =</span>
<span class="p_add">+		roundup_pow_of_two(max_val_cycles) &gt; max_val_cycles ?</span>
<span class="p_add">+		roundup_pow_of_two(max_val_cycles) - 1 : UINT_MAX;</span>
 	u64 max_val_cycles_rounded = is_power_of_2(max_val_cycles + 1) ?
<span class="p_del">-		max_val_cycles : roundup_pow_of_two(max_val_cycles) - 1;</span>
<span class="p_add">+		max_val_cycles : tmp_rounded;</span>
 	/* calculate max possible multiplier in order to fit in 64bit */
 	u64 max_mul = div_u64(0xffffffffffffffffULL, max_val_cycles_rounded);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">index dea92f1af362..6bf4ea400643 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c</span>
<span class="p_chunk">@@ -1733,6 +1733,13 @@</span> <span class="p_context"> int mlx4_en_start_port(struct net_device *dev)</span>
 		vxlan_get_rx_port(dev);
 #endif
 	priv-&gt;port_up = true;
<span class="p_add">+</span>
<span class="p_add">+	/* Process all completions if exist to prevent</span>
<span class="p_add">+	 * the queues freezing if they are full</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (i = 0; i &lt; priv-&gt;rx_ring_num; i++)</span>
<span class="p_add">+		napi_schedule(&amp;priv-&gt;rx_cq[i]-&gt;napi);</span>
<span class="p_add">+</span>
 	netif_tx_start_all_queues(dev);
 	netif_device_attach(dev);
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_port.c b/drivers/net/ethernet/mellanox/mlx4/en_port.c</span>
<span class="p_header">index 40d6c3c6b3a0..772a24d9fac6 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_port.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_port.c</span>
<span class="p_chunk">@@ -127,7 +127,7 @@</span> <span class="p_context"> int mlx4_en_DUMP_ETH_STATS(struct mlx4_en_dev *mdev, u8 port, u8 reset)</span>
 		return PTR_ERR(mailbox);
 	err = mlx4_cmd_box(mdev-&gt;dev, 0, mailbox-&gt;dma, in_mod, 0,
 			   MLX4_CMD_DUMP_ETH_STATS, MLX4_CMD_TIME_CLASS_B,
<span class="p_del">-			   MLX4_CMD_WRAPPED);</span>
<span class="p_add">+			   MLX4_CMD_NATIVE);</span>
 	if (err)
 		goto out;
 
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">index fa742b1115f9..76879a1cca6f 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c</span>
<span class="p_chunk">@@ -835,7 +835,7 @@</span> <span class="p_context"> int mlx4_en_process_rx_cq(struct net_device *dev, struct mlx4_en_cq *cq, int bud</span>
 			goto next;
 		}
 
<span class="p_del">-                if (unlikely(priv-&gt;validate_loopback)) {</span>
<span class="p_add">+		if (unlikely(priv-&gt;validate_loopback)) {</span>
 			validate_loopback(priv, skb);
 			goto next;
 		}
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/mcg.c b/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_header">index d9afcffee737..5866499a38ca 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/mcg.c</span>
<span class="p_chunk">@@ -1296,7 +1296,12 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(mlx4_multicast_detach);</span>
 int mlx4_flow_steer_promisc_add(struct mlx4_dev *dev, u8 port,
 				u32 qpn, enum mlx4_net_trans_promisc_mode mode)
 {
<span class="p_del">-	struct mlx4_net_trans_rule rule;</span>
<span class="p_add">+	struct mlx4_net_trans_rule rule = {</span>
<span class="p_add">+		.queue_mode = MLX4_NET_TRANS_Q_FIFO,</span>
<span class="p_add">+		.exclusive = 0,</span>
<span class="p_add">+		.allow_loopback = 1,</span>
<span class="p_add">+	};</span>
<span class="p_add">+</span>
 	u64 *regid_p;
 
 	switch (mode) {
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4.h b/drivers/net/ethernet/mellanox/mlx4/mlx4.h</span>
<span class="p_header">index 1d8af7336807..971ba25b919d 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/mlx4.h</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4.h</span>
<span class="p_chunk">@@ -43,6 +43,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/timer.h&gt;
 #include &lt;linux/semaphore.h&gt;
 #include &lt;linux/workqueue.h&gt;
<span class="p_add">+#include &lt;linux/rwsem.h&gt;</span>
 
 #include &lt;linux/mlx4/device.h&gt;
 #include &lt;linux/mlx4/driver.h&gt;
<span class="p_chunk">@@ -152,9 +153,10 @@</span> <span class="p_context"> enum mlx4_resource {</span>
 	RES_MTT,
 	RES_MAC,
 	RES_VLAN,
<span class="p_del">-	RES_EQ,</span>
<span class="p_add">+	RES_NPORT_ID,</span>
 	RES_COUNTER,
 	RES_FS_RULE,
<span class="p_add">+	RES_EQ,</span>
 	MLX4_NUM_OF_RESOURCE_TYPE
 };
 
<span class="p_chunk">@@ -598,6 +600,7 @@</span> <span class="p_context"> struct mlx4_cmd {</span>
 	struct mutex		slave_cmd_mutex;
 	struct semaphore	poll_sem;
 	struct semaphore	event_sem;
<span class="p_add">+	struct rw_semaphore	switch_sem;</span>
 	int			max_cmds;
 	spinlock_t		context_lock;
 	int			free_head;
<span class="p_chunk">@@ -1246,8 +1249,6 @@</span> <span class="p_context"> int mlx4_SET_VLAN_FLTR_wrapper(struct mlx4_dev *dev, int slave,</span>
 			       struct mlx4_cmd_info *cmd);
 int mlx4_common_set_vlan_fltr(struct mlx4_dev *dev, int function,
 				     int port, void *buf);
<span class="p_del">-int mlx4_common_dump_eth_stats(struct mlx4_dev *dev, int slave, u32 in_mod,</span>
<span class="p_del">-				struct mlx4_cmd_mailbox *outbox);</span>
 int mlx4_DUMP_ETH_STATS_wrapper(struct mlx4_dev *dev, int slave,
 				   struct mlx4_vhcr *vhcr,
 				   struct mlx4_cmd_mailbox *inbox,
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx4/port.c b/drivers/net/ethernet/mellanox/mlx4/port.c</span>
<span class="p_header">index 7ab97174886d..548db13ca108 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx4/port.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx4/port.c</span>
<span class="p_chunk">@@ -1143,24 +1143,13 @@</span> <span class="p_context"> int mlx4_SET_VLAN_FLTR_wrapper(struct mlx4_dev *dev, int slave,</span>
 	return err;
 }
 
<span class="p_del">-int mlx4_common_dump_eth_stats(struct mlx4_dev *dev, int slave,</span>
<span class="p_del">-			       u32 in_mod, struct mlx4_cmd_mailbox *outbox)</span>
<span class="p_del">-{</span>
<span class="p_del">-	return mlx4_cmd_box(dev, 0, outbox-&gt;dma, in_mod, 0,</span>
<span class="p_del">-			    MLX4_CMD_DUMP_ETH_STATS, MLX4_CMD_TIME_CLASS_B,</span>
<span class="p_del">-			    MLX4_CMD_NATIVE);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 int mlx4_DUMP_ETH_STATS_wrapper(struct mlx4_dev *dev, int slave,
 				struct mlx4_vhcr *vhcr,
 				struct mlx4_cmd_mailbox *inbox,
 				struct mlx4_cmd_mailbox *outbox,
 				struct mlx4_cmd_info *cmd)
 {
<span class="p_del">-	if (slave != dev-&gt;caps.function)</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	return mlx4_common_dump_eth_stats(dev, slave,</span>
<span class="p_del">-					  vhcr-&gt;in_modifier, outbox);</span>
<span class="p_add">+	return 0;</span>
 }
 
 void mlx4_set_stats_bitmap(struct mlx4_dev *dev, u64 *stats_bitmap)
<span class="p_header">diff --git a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_header">index 7bd9582303e8..07909abc88a3 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/mellanox/mlx5/core/pagealloc.c</span>
<span class="p_chunk">@@ -243,6 +243,7 @@</span> <span class="p_context"> static void free_4k(struct mlx5_core_dev *dev, u64 addr)</span>
 static int alloc_system_page(struct mlx5_core_dev *dev, u16 func_id)
 {
 	struct page *page;
<span class="p_add">+	u64 zero_addr = 1;</span>
 	u64 addr;
 	int err;
 
<span class="p_chunk">@@ -251,26 +252,35 @@</span> <span class="p_context"> static int alloc_system_page(struct mlx5_core_dev *dev, u16 func_id)</span>
 		mlx5_core_warn(dev, &quot;failed to allocate page\n&quot;);
 		return -ENOMEM;
 	}
<span class="p_add">+map:</span>
 	addr = dma_map_page(&amp;dev-&gt;pdev-&gt;dev, page, 0,
 			    PAGE_SIZE, DMA_BIDIRECTIONAL);
 	if (dma_mapping_error(&amp;dev-&gt;pdev-&gt;dev, addr)) {
 		mlx5_core_warn(dev, &quot;failed dma mapping page\n&quot;);
 		err = -ENOMEM;
<span class="p_del">-		goto out_alloc;</span>
<span class="p_add">+		goto err_mapping;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	/* Firmware doesn&#39;t support page with physical address 0 */</span>
<span class="p_add">+	if (addr == 0) {</span>
<span class="p_add">+		zero_addr = addr;</span>
<span class="p_add">+		goto map;</span>
 	}
<span class="p_add">+</span>
 	err = insert_page(dev, addr, page, func_id);
 	if (err) {
 		mlx5_core_err(dev, &quot;failed to track allocated page\n&quot;);
<span class="p_del">-		goto out_mapping;</span>
<span class="p_add">+		dma_unmap_page(&amp;dev-&gt;pdev-&gt;dev, addr, PAGE_SIZE,</span>
<span class="p_add">+			       DMA_BIDIRECTIONAL);</span>
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_del">-</span>
<span class="p_del">-out_mapping:</span>
<span class="p_del">-	dma_unmap_page(&amp;dev-&gt;pdev-&gt;dev, addr, PAGE_SIZE, DMA_BIDIRECTIONAL);</span>
<span class="p_add">+err_mapping:</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		__free_page(page);</span>
 
<span class="p_del">-out_alloc:</span>
<span class="p_del">-	__free_page(page);</span>
<span class="p_add">+	if (zero_addr == 0)</span>
<span class="p_add">+		dma_unmap_page(&amp;dev-&gt;pdev-&gt;dev, zero_addr, PAGE_SIZE,</span>
<span class="p_add">+			       DMA_BIDIRECTIONAL);</span>
 
 	return err;
 }
<span class="p_header">diff --git a/drivers/net/ethernet/renesas/sh_eth.c b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">index c607015f0538..f1ebb1f50f1c 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/renesas/sh_eth.c</span>
<span class="p_chunk">@@ -795,7 +795,7 @@</span> <span class="p_context"> static struct sh_eth_cpu_data r7s72100_data = {</span>
 
 	.ecsr_value	= ECSR_ICD,
 	.ecsipr_value	= ECSIPR_ICDIP,
<span class="p_del">-	.eesipr_value	= 0xff7f009f,</span>
<span class="p_add">+	.eesipr_value	= 0xe77f009f,</span>
 
 	.tx_check	= EESR_TC1 | EESR_FTC,
 	.eesr_err_check	= EESR_TWB1 | EESR_TWB | EESR_TABT | EESR_RABT |
<span class="p_header">diff --git a/drivers/net/ethernet/ti/cpsw-phy-sel.c b/drivers/net/ethernet/ti/cpsw-phy-sel.c</span>
<span class="p_header">index aa8bf45e53dc..7729de6e7aba 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ti/cpsw-phy-sel.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ti/cpsw-phy-sel.c</span>
<span class="p_chunk">@@ -152,9 +152,12 @@</span> <span class="p_context"> void cpsw_phy_sel(struct device *dev, phy_interface_t phy_mode, int slave)</span>
 	}
 
 	dev = bus_find_device(&amp;platform_bus_type, NULL, node, match);
<span class="p_add">+	of_node_put(node);</span>
 	priv = dev_get_drvdata(dev);
 
 	priv-&gt;cpsw_phy_sel(priv, phy_mode, slave);
<span class="p_add">+</span>
<span class="p_add">+	put_device(dev);</span>
 }
 EXPORT_SYMBOL_GPL(cpsw_phy_sel);
 
<span class="p_header">diff --git a/drivers/net/ethernet/ti/cpsw.c b/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_header">index 3a8341c839d5..d7e04d3daf13 100644</span>
<span class="p_header">--- a/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_header">+++ b/drivers/net/ethernet/ti/cpsw.c</span>
<span class="p_chunk">@@ -1939,6 +1939,7 @@</span> <span class="p_context"> static int cpsw_probe_dt(struct cpsw_platform_data *data,</span>
 		}
 		snprintf(slave_data-&gt;phy_id, sizeof(slave_data-&gt;phy_id),
 			 PHY_ID_FMT, mdio-&gt;name, phyid);
<span class="p_add">+		put_device(&amp;mdio-&gt;dev);</span>
 
 		mac_addr = of_get_mac_address(slave_node);
 		if (mac_addr)
<span class="p_chunk">@@ -2140,13 +2141,12 @@</span> <span class="p_context"> static int cpsw_probe(struct platform_device *pdev)</span>
 	 */
 	pm_runtime_get_sync(&amp;pdev-&gt;dev);
 	priv-&gt;version = readl(&amp;priv-&gt;regs-&gt;id_ver);
<span class="p_del">-	pm_runtime_put_sync(&amp;pdev-&gt;dev);</span>
 
 	res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
 	priv-&gt;wr_regs = devm_ioremap_resource(&amp;pdev-&gt;dev, res);
 	if (IS_ERR(priv-&gt;wr_regs)) {
 		ret = PTR_ERR(priv-&gt;wr_regs);
<span class="p_del">-		goto clean_runtime_disable_ret;</span>
<span class="p_add">+		goto clean_pm_runtime_put_ret;</span>
 	}
 
 	memset(&amp;dma_params, 0, sizeof(dma_params));
<span class="p_chunk">@@ -2183,7 +2183,7 @@</span> <span class="p_context"> static int cpsw_probe(struct platform_device *pdev)</span>
 	default:
 		dev_err(priv-&gt;dev, &quot;unknown version 0x%08x\n&quot;, priv-&gt;version);
 		ret = -ENODEV;
<span class="p_del">-		goto clean_runtime_disable_ret;</span>
<span class="p_add">+		goto clean_pm_runtime_put_ret;</span>
 	}
 	for (i = 0; i &lt; priv-&gt;data.slaves; i++) {
 		struct cpsw_slave *slave = &amp;priv-&gt;slaves[i];
<span class="p_chunk">@@ -2211,7 +2211,7 @@</span> <span class="p_context"> static int cpsw_probe(struct platform_device *pdev)</span>
 	if (!priv-&gt;dma) {
 		dev_err(priv-&gt;dev, &quot;error initializing dma\n&quot;);
 		ret = -ENOMEM;
<span class="p_del">-		goto clean_runtime_disable_ret;</span>
<span class="p_add">+		goto clean_pm_runtime_put_ret;</span>
 	}
 
 	priv-&gt;txch = cpdma_chan_create(priv-&gt;dma, tx_chan_num(0),
<span class="p_chunk">@@ -2279,18 +2279,24 @@</span> <span class="p_context"> static int cpsw_probe(struct platform_device *pdev)</span>
 		ret = cpsw_probe_dual_emac(pdev, priv);
 		if (ret) {
 			cpsw_err(priv, probe, &quot;error probe slave 2 emac interface\n&quot;);
<span class="p_del">-			goto clean_ale_ret;</span>
<span class="p_add">+			goto clean_unregister_netdev_ret;</span>
 		}
 	}
 
<span class="p_add">+	pm_runtime_put(&amp;pdev-&gt;dev);</span>
<span class="p_add">+</span>
 	return 0;
 
<span class="p_add">+clean_unregister_netdev_ret:</span>
<span class="p_add">+	unregister_netdev(ndev);</span>
 clean_ale_ret:
 	cpsw_ale_destroy(priv-&gt;ale);
 clean_dma_ret:
 	cpdma_chan_destroy(priv-&gt;txch);
 	cpdma_chan_destroy(priv-&gt;rxch);
 	cpdma_ctlr_destroy(priv-&gt;dma);
<span class="p_add">+clean_pm_runtime_put_ret:</span>
<span class="p_add">+	pm_runtime_put_sync(&amp;pdev-&gt;dev);</span>
 clean_runtime_disable_ret:
 	pm_runtime_disable(&amp;pdev-&gt;dev);
 clean_ndev_ret:
<span class="p_header">diff --git a/drivers/net/wireless/mwifiex/cfg80211.c b/drivers/net/wireless/mwifiex/cfg80211.c</span>
<span class="p_header">index b511613bba2d..4e674c16d091 100644</span>
<span class="p_header">--- a/drivers/net/wireless/mwifiex/cfg80211.c</span>
<span class="p_header">+++ b/drivers/net/wireless/mwifiex/cfg80211.c</span>
<span class="p_chunk">@@ -1734,8 +1734,9 @@</span> <span class="p_context"> done:</span>
 			is_scanning_required = 1;
 		} else {
 			dev_dbg(priv-&gt;adapter-&gt;dev,
<span class="p_del">-				&quot;info: trying to associate to &#39;%s&#39; bssid %pM\n&quot;,</span>
<span class="p_del">-				(char *) req_ssid.ssid, bss-&gt;bssid);</span>
<span class="p_add">+				&quot;info: trying to associate to &#39;%.*s&#39; bssid %pM\n&quot;,</span>
<span class="p_add">+				req_ssid.ssid_len, (char *)req_ssid.ssid,</span>
<span class="p_add">+				bss-&gt;bssid);</span>
 			memcpy(&amp;priv-&gt;cfg_bssid, bss-&gt;bssid, ETH_ALEN);
 			break;
 		}
<span class="p_chunk">@@ -1776,8 +1777,8 @@</span> <span class="p_context"> mwifiex_cfg80211_connect(struct wiphy *wiphy, struct net_device *dev,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	wiphy_dbg(wiphy, &quot;info: Trying to associate to %s and bssid %pM\n&quot;,</span>
<span class="p_del">-		  (char *) sme-&gt;ssid, sme-&gt;bssid);</span>
<span class="p_add">+	wiphy_dbg(wiphy, &quot;info: Trying to associate to %.*s and bssid %pM\n&quot;,</span>
<span class="p_add">+		  (int)sme-&gt;ssid_len, (char *)sme-&gt;ssid, sme-&gt;bssid);</span>
 
 	ret = mwifiex_cfg80211_assoc(priv, sme-&gt;ssid_len, sme-&gt;ssid, sme-&gt;bssid,
 				     priv-&gt;bss_mode, sme-&gt;channel, sme, 0);
<span class="p_chunk">@@ -1900,8 +1901,8 @@</span> <span class="p_context"> mwifiex_cfg80211_join_ibss(struct wiphy *wiphy, struct net_device *dev,</span>
 		goto done;
 	}
 
<span class="p_del">-	wiphy_dbg(wiphy, &quot;info: trying to join to %s and bssid %pM\n&quot;,</span>
<span class="p_del">-		  (char *) params-&gt;ssid, params-&gt;bssid);</span>
<span class="p_add">+	wiphy_dbg(wiphy, &quot;info: trying to join to %.*s and bssid %pM\n&quot;,</span>
<span class="p_add">+		  params-&gt;ssid_len, (char *)params-&gt;ssid, params-&gt;bssid);</span>
 
 	mwifiex_set_ibss_params(priv, params);
 
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/regd.c b/drivers/net/wireless/rtlwifi/regd.c</span>
<span class="p_header">index a4eb9b271438..282474bf259f 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/regd.c</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/regd.c</span>
<span class="p_chunk">@@ -44,6 +44,7 @@</span> <span class="p_context"> static struct country_code_to_enum_rd allCountries[] = {</span>
 	{COUNTRY_CODE_GLOBAL_DOMAIN, &quot;JP&quot;},
 	{COUNTRY_CODE_WORLD_WIDE_13, &quot;EC&quot;},
 	{COUNTRY_CODE_TELEC_NETGEAR, &quot;EC&quot;},
<span class="p_add">+	{COUNTRY_CODE_WORLD_WIDE_13_5G_ALL, &quot;US&quot;},</span>
 };
 
 /*
<span class="p_chunk">@@ -131,6 +132,17 @@</span> <span class="p_context"> static const struct ieee80211_regdomain rtl_regdom_14_60_64 = {</span>
 		      }
 };
 
<span class="p_add">+static const struct ieee80211_regdomain rtl_regdom_12_13_5g_all = {</span>
<span class="p_add">+	.n_reg_rules = 4,</span>
<span class="p_add">+	.alpha2 = &quot;99&quot;,</span>
<span class="p_add">+	.reg_rules = {</span>
<span class="p_add">+			RTL819x_2GHZ_CH01_11,</span>
<span class="p_add">+			RTL819x_2GHZ_CH12_13,</span>
<span class="p_add">+			RTL819x_5GHZ_5150_5350,</span>
<span class="p_add">+			RTL819x_5GHZ_5470_5850,</span>
<span class="p_add">+		}</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 static const struct ieee80211_regdomain rtl_regdom_14 = {
 	.n_reg_rules = 3,
 	.alpha2 = &quot;99&quot;,
<span class="p_chunk">@@ -315,9 +327,9 @@</span> <span class="p_context"> static const struct ieee80211_regdomain *_rtl_regdomain_select(</span>
 		return &amp;rtl_regdom_no_midband;
 	case COUNTRY_CODE_IC:
 		return &amp;rtl_regdom_11;
<span class="p_del">-	case COUNTRY_CODE_ETSI:</span>
 	case COUNTRY_CODE_TELEC_NETGEAR:
 		return &amp;rtl_regdom_60_64;
<span class="p_add">+	case COUNTRY_CODE_ETSI:</span>
 	case COUNTRY_CODE_SPAIN:
 	case COUNTRY_CODE_FRANCE:
 	case COUNTRY_CODE_ISRAEL:
<span class="p_chunk">@@ -330,6 +342,8 @@</span> <span class="p_context"> static const struct ieee80211_regdomain *_rtl_regdomain_select(</span>
 		return &amp;rtl_regdom_14_60_64;
 	case COUNTRY_CODE_GLOBAL_DOMAIN:
 		return &amp;rtl_regdom_14;
<span class="p_add">+	case COUNTRY_CODE_WORLD_WIDE_13_5G_ALL:</span>
<span class="p_add">+		return &amp;rtl_regdom_12_13_5g_all;</span>
 	default:
 		return &amp;rtl_regdom_no_midband;
 	}
<span class="p_chunk">@@ -367,6 +381,27 @@</span> <span class="p_context"> static struct country_code_to_enum_rd *_rtl_regd_find_country(u16 countrycode)</span>
 	return NULL;
 }
 
<span class="p_add">+static u8 channel_plan_to_country_code(u8 channelplan)</span>
<span class="p_add">+{</span>
<span class="p_add">+	switch (channelplan) {</span>
<span class="p_add">+	case 0x20:</span>
<span class="p_add">+	case 0x21:</span>
<span class="p_add">+		return COUNTRY_CODE_WORLD_WIDE_13;</span>
<span class="p_add">+	case 0x22:</span>
<span class="p_add">+		return COUNTRY_CODE_IC;</span>
<span class="p_add">+	case 0x25:</span>
<span class="p_add">+		return COUNTRY_CODE_ETSI;</span>
<span class="p_add">+	case 0x32:</span>
<span class="p_add">+		return COUNTRY_CODE_TELEC_NETGEAR;</span>
<span class="p_add">+	case 0x41:</span>
<span class="p_add">+		return COUNTRY_CODE_GLOBAL_DOMAIN;</span>
<span class="p_add">+	case 0x7f:</span>
<span class="p_add">+		return COUNTRY_CODE_WORLD_WIDE_13_5G_ALL;</span>
<span class="p_add">+	default:</span>
<span class="p_add">+		return COUNTRY_CODE_MAX; /*Error*/</span>
<span class="p_add">+	}</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int rtl_regd_init(struct ieee80211_hw *hw,
 		  void (*reg_notifier) (struct wiphy *wiphy,
 				       struct regulatory_request *request))
<span class="p_chunk">@@ -379,10 +414,12 @@</span> <span class="p_context"> int rtl_regd_init(struct ieee80211_hw *hw,</span>
 		return -EINVAL;
 
 	/* init country_code from efuse channel plan */
<span class="p_del">-	rtlpriv-&gt;regd.country_code = rtlpriv-&gt;efuse.channel_plan;</span>
<span class="p_add">+	rtlpriv-&gt;regd.country_code =</span>
<span class="p_add">+		channel_plan_to_country_code(rtlpriv-&gt;efuse.channel_plan);</span>
 
<span class="p_del">-	RT_TRACE(rtlpriv, COMP_REGD, DBG_TRACE,</span>
<span class="p_del">-		 &quot;rtl: EEPROM regdomain: 0x%0x\n&quot;, rtlpriv-&gt;regd.country_code);</span>
<span class="p_add">+	RT_TRACE(rtlpriv, COMP_REGD, DBG_DMESG,</span>
<span class="p_add">+		 &quot;rtl: EEPROM regdomain: 0x%0x conuntry code: %d\n&quot;,</span>
<span class="p_add">+		 rtlpriv-&gt;efuse.channel_plan, rtlpriv-&gt;regd.country_code);</span>
 
 	if (rtlpriv-&gt;regd.country_code &gt;= COUNTRY_CODE_MAX) {
 		RT_TRACE(rtlpriv, COMP_REGD, DBG_DMESG,
<span class="p_header">diff --git a/drivers/net/wireless/rtlwifi/regd.h b/drivers/net/wireless/rtlwifi/regd.h</span>
<span class="p_header">index 4e1f4f00e6e9..0210253018b6 100644</span>
<span class="p_header">--- a/drivers/net/wireless/rtlwifi/regd.h</span>
<span class="p_header">+++ b/drivers/net/wireless/rtlwifi/regd.h</span>
<span class="p_chunk">@@ -49,6 +49,7 @@</span> <span class="p_context"> enum country_code_type_t {</span>
 	COUNTRY_CODE_GLOBAL_DOMAIN = 10,
 	COUNTRY_CODE_WORLD_WIDE_13 = 11,
 	COUNTRY_CODE_TELEC_NETGEAR = 12,
<span class="p_add">+	COUNTRY_CODE_WORLD_WIDE_13_5G_ALL = 13,</span>
 
 	/*add new channel plan above this line */
 	COUNTRY_CODE_MAX
<span class="p_header">diff --git a/drivers/of/of_mdio.c b/drivers/of/of_mdio.c</span>
<span class="p_header">index 401b2453da45..a89699b5e22f 100644</span>
<span class="p_header">--- a/drivers/of/of_mdio.c</span>
<span class="p_header">+++ b/drivers/of/of_mdio.c</span>
<span class="p_chunk">@@ -291,8 +291,11 @@</span> <span class="p_context"> int of_phy_register_fixed_link(struct device_node *np)</span>
 		status.link = 1;
 		status.duplex = of_property_read_bool(fixed_link_node,
 						      &quot;full-duplex&quot;);
<span class="p_del">-		if (of_property_read_u32(fixed_link_node, &quot;speed&quot;, &amp;status.speed))</span>
<span class="p_add">+		if (of_property_read_u32(fixed_link_node, &quot;speed&quot;,</span>
<span class="p_add">+					 &amp;status.speed)) {</span>
<span class="p_add">+			of_node_put(fixed_link_node);</span>
 			return -EINVAL;
<span class="p_add">+		}</span>
 		status.pause = of_property_read_bool(fixed_link_node, &quot;pause&quot;);
 		status.asym_pause = of_property_read_bool(fixed_link_node,
 							  &quot;asym-pause&quot;);
<span class="p_header">diff --git a/drivers/pci/quirks.c b/drivers/pci/quirks.c</span>
<span class="p_header">index 89ee38869334..09215b036e94 100644</span>
<span class="p_header">--- a/drivers/pci/quirks.c</span>
<span class="p_header">+++ b/drivers/pci/quirks.c</span>
<span class="p_chunk">@@ -3083,6 +3083,7 @@</span> <span class="p_context"> static void quirk_no_bus_reset(struct pci_dev *dev)</span>
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0030, quirk_no_bus_reset);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0032, quirk_no_bus_reset);
 DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x003c, quirk_no_bus_reset);
<span class="p_add">+DECLARE_PCI_FIXUP_HEADER(PCI_VENDOR_ID_ATHEROS, 0x0033, quirk_no_bus_reset);</span>
 
 static void pci_do_fixups(struct pci_dev *dev, struct pci_fixup *f,
 			  struct pci_fixup *end)
<span class="p_header">diff --git a/drivers/phy/phy-sun4i-usb.c b/drivers/phy/phy-sun4i-usb.c</span>
<span class="p_header">index 115d8d5190d5..6e46a0055887 100644</span>
<span class="p_header">--- a/drivers/phy/phy-sun4i-usb.c</span>
<span class="p_header">+++ b/drivers/phy/phy-sun4i-usb.c</span>
<span class="p_chunk">@@ -32,6 +32,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/platform_device.h&gt;
 #include &lt;linux/regulator/consumer.h&gt;
 #include &lt;linux/reset.h&gt;
<span class="p_add">+#include &lt;linux/spinlock.h&gt;</span>
 
 #define REG_ISCR			0x00
 #define REG_PHYCTL			0x04
<span class="p_chunk">@@ -62,7 +63,7 @@</span> <span class="p_context"></span>
 
 struct sun4i_usb_phy_data {
 	void __iomem *base;
<span class="p_del">-	struct mutex mutex;</span>
<span class="p_add">+	spinlock_t reg_lock; /* guard access to phyctl reg */</span>
 	int num_phys;
 	u32 disc_thresh;
 	struct sun4i_usb_phy {
<span class="p_chunk">@@ -83,9 +84,10 @@</span> <span class="p_context"> static void sun4i_usb_phy_write(struct sun4i_usb_phy *phy, u32 addr, u32 data,</span>
 {
 	struct sun4i_usb_phy_data *phy_data = to_sun4i_usb_phy_data(phy);
 	u32 temp, usbc_bit = BIT(phy-&gt;index * 2);
<span class="p_add">+	unsigned long flags;</span>
 	int i;
 
<span class="p_del">-	mutex_lock(&amp;phy_data-&gt;mutex);</span>
<span class="p_add">+	spin_lock_irqsave(&amp;phy_data-&gt;reg_lock, flags);</span>
 
 	for (i = 0; i &lt; len; i++) {
 		temp = readl(phy_data-&gt;base + REG_PHYCTL);
<span class="p_chunk">@@ -117,7 +119,8 @@</span> <span class="p_context"> static void sun4i_usb_phy_write(struct sun4i_usb_phy *phy, u32 addr, u32 data,</span>
 
 		data &gt;&gt;= 1;
 	}
<span class="p_del">-	mutex_unlock(&amp;phy_data-&gt;mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;phy_data-&gt;reg_lock, flags);</span>
 }
 
 static void sun4i_usb_phy_passby(struct sun4i_usb_phy *phy, int enable)
<span class="p_chunk">@@ -232,7 +235,7 @@</span> <span class="p_context"> static int sun4i_usb_phy_probe(struct platform_device *pdev)</span>
 	if (!data)
 		return -ENOMEM;
 
<span class="p_del">-	mutex_init(&amp;data-&gt;mutex);</span>
<span class="p_add">+	spin_lock_init(&amp;data-&gt;reg_lock);</span>
 
 	if (of_device_is_compatible(np, &quot;allwinner,sun5i-a13-usb-phy&quot;))
 		data-&gt;num_phys = 2;
<span class="p_header">diff --git a/drivers/pwm/core.c b/drivers/pwm/core.c</span>
<span class="p_header">index d2c35920ff08..825b5e48be08 100644</span>
<span class="p_header">--- a/drivers/pwm/core.c</span>
<span class="p_header">+++ b/drivers/pwm/core.c</span>
<span class="p_chunk">@@ -293,6 +293,8 @@</span> <span class="p_context"> int pwmchip_remove(struct pwm_chip *chip)</span>
 	unsigned int i;
 	int ret = 0;
 
<span class="p_add">+	pwmchip_sysfs_unexport_children(chip);</span>
<span class="p_add">+</span>
 	mutex_lock(&amp;pwm_lock);
 
 	for (i = 0; i &lt; chip-&gt;npwm; i++) {
<span class="p_header">diff --git a/drivers/pwm/sysfs.c b/drivers/pwm/sysfs.c</span>
<span class="p_header">index 4bd0c639e16d..5b64f09ce314 100644</span>
<span class="p_header">--- a/drivers/pwm/sysfs.c</span>
<span class="p_header">+++ b/drivers/pwm/sysfs.c</span>
<span class="p_chunk">@@ -340,6 +340,26 @@</span> <span class="p_context"> void pwmchip_sysfs_unexport(struct pwm_chip *chip)</span>
 	}
 }
 
<span class="p_add">+void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct device *parent;</span>
<span class="p_add">+	unsigned int i;</span>
<span class="p_add">+</span>
<span class="p_add">+	parent = class_find_device(&amp;pwm_class, NULL, chip,</span>
<span class="p_add">+				   pwmchip_sysfs_match);</span>
<span class="p_add">+	if (!parent)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (i = 0; i &lt; chip-&gt;npwm; i++) {</span>
<span class="p_add">+		struct pwm_device *pwm = &amp;chip-&gt;pwms[i];</span>
<span class="p_add">+</span>
<span class="p_add">+		if (test_bit(PWMF_EXPORTED, &amp;pwm-&gt;flags))</span>
<span class="p_add">+			pwm_unexport_child(parent, pwm);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	put_device(parent);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static int __init pwm_sysfs_init(void)
 {
 	return class_register(&amp;pwm_class);
<span class="p_header">diff --git a/drivers/regulator/tps65910-regulator.c b/drivers/regulator/tps65910-regulator.c</span>
<span class="p_header">index fa7db8847578..92647dc7343a 100644</span>
<span class="p_header">--- a/drivers/regulator/tps65910-regulator.c</span>
<span class="p_header">+++ b/drivers/regulator/tps65910-regulator.c</span>
<span class="p_chunk">@@ -1111,6 +1111,12 @@</span> <span class="p_context"> static int tps65910_probe(struct platform_device *pdev)</span>
 		pmic-&gt;num_regulators = ARRAY_SIZE(tps65910_regs);
 		pmic-&gt;ext_sleep_control = tps65910_ext_sleep_control;
 		info = tps65910_regs;
<span class="p_add">+		/* Work around silicon erratum SWCZ010: output programmed</span>
<span class="p_add">+		 * voltage level can go higher than expected or crash</span>
<span class="p_add">+		 * Workaround: use no synchronization of DCDC clocks</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		tps65910_reg_clear_bits(pmic-&gt;mfd, TPS65910_DCDCCTRL,</span>
<span class="p_add">+					DCDCCTRL_DCDCCKSYNC_MASK);</span>
 		break;
 	case TPS65911:
 		pmic-&gt;get_ctrl_reg = &amp;tps65911_get_ctrl_register;
<span class="p_header">diff --git a/drivers/s390/char/con3270.c b/drivers/s390/char/con3270.c</span>
<span class="p_header">index 75ffe9980c3e..a64875385cbf 100644</span>
<span class="p_header">--- a/drivers/s390/char/con3270.c</span>
<span class="p_header">+++ b/drivers/s390/char/con3270.c</span>
<span class="p_chunk">@@ -124,7 +124,12 @@</span> <span class="p_context"> con3270_create_status(struct con3270 *cp)</span>
 static void
 con3270_update_string(struct con3270 *cp, struct string *s, int nr)
 {
<span class="p_del">-	if (s-&gt;len &gt;= cp-&gt;view.cols - 5)</span>
<span class="p_add">+	if (s-&gt;len &lt; 4) {</span>
<span class="p_add">+		/* This indicates a bug, but printing a warning would</span>
<span class="p_add">+		 * cause a deadlock. */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (s-&gt;string[s-&gt;len - 4] != TO_RA)</span>
 		return;
 	raw3270_buffer_address(cp-&gt;view.dev, s-&gt;string + s-&gt;len - 3,
 			       cp-&gt;view.cols * (nr + 1));
<span class="p_chunk">@@ -457,11 +462,11 @@</span> <span class="p_context"> con3270_cline_end(struct con3270 *cp)</span>
 		cp-&gt;cline-&gt;len + 4 : cp-&gt;view.cols;
 	s = con3270_alloc_string(cp, size);
 	memcpy(s-&gt;string, cp-&gt;cline-&gt;string, cp-&gt;cline-&gt;len);
<span class="p_del">-	if (s-&gt;len &lt; cp-&gt;view.cols - 5) {</span>
<span class="p_add">+	if (cp-&gt;cline-&gt;len &lt; cp-&gt;view.cols - 5) {</span>
 		s-&gt;string[s-&gt;len - 4] = TO_RA;
 		s-&gt;string[s-&gt;len - 1] = 0;
 	} else {
<span class="p_del">-		while (--size &gt; cp-&gt;cline-&gt;len)</span>
<span class="p_add">+		while (--size &gt;= cp-&gt;cline-&gt;len)</span>
 			s-&gt;string[size] = cp-&gt;view.ascebc[&#39; &#39;];
 	}
 	/* Replace cline with allocated line s and reset cline. */
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.c b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">index 0ca64484cfa3..7b1fbd303c29 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Debug traces for zfcp.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2016</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -65,7 +65,7 @@</span> <span class="p_context"> void zfcp_dbf_pl_write(struct zfcp_dbf *dbf, void *data, u16 length, char *area,</span>
  * @tag: tag indicating which kind of unsolicited status has been received
  * @req: request for which a response was received
  */
<span class="p_del">-void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
<span class="p_add">+void zfcp_dbf_hba_fsf_res(char *tag, int level, struct zfcp_fsf_req *req)</span>
 {
 	struct zfcp_dbf *dbf = req-&gt;adapter-&gt;dbf;
 	struct fsf_qtcb_prefix *q_pref = &amp;req-&gt;qtcb-&gt;prefix;
<span class="p_chunk">@@ -85,6 +85,8 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
 	rec-&gt;u.res.req_issued = req-&gt;issued;
 	rec-&gt;u.res.prot_status = q_pref-&gt;prot_status;
 	rec-&gt;u.res.fsf_status = q_head-&gt;fsf_status;
<span class="p_add">+	rec-&gt;u.res.port_handle = q_head-&gt;port_handle;</span>
<span class="p_add">+	rec-&gt;u.res.lun_handle = q_head-&gt;lun_handle;</span>
 
 	memcpy(rec-&gt;u.res.prot_status_qual, &amp;q_pref-&gt;prot_status_qual,
 	       FSF_PROT_STATUS_QUAL_SIZE);
<span class="p_chunk">@@ -97,7 +99,7 @@</span> <span class="p_context"> void zfcp_dbf_hba_fsf_res(char *tag, struct zfcp_fsf_req *req)</span>
 				  rec-&gt;pl_len, &quot;fsf_res&quot;, req-&gt;req_id);
 	}
 
<span class="p_del">-	debug_event(dbf-&gt;hba, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	debug_event(dbf-&gt;hba, level, rec, sizeof(*rec));</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;hba_lock, flags);
 }
 
<span class="p_chunk">@@ -241,7 +243,8 @@</span> <span class="p_context"> static void zfcp_dbf_set_common(struct zfcp_dbf_rec *rec,</span>
 	if (sdev) {
 		rec-&gt;lun_status = atomic_read(&amp;sdev_to_zfcp(sdev)-&gt;status);
 		rec-&gt;lun = zfcp_scsi_dev_lun(sdev);
<span class="p_del">-	}</span>
<span class="p_add">+	} else</span>
<span class="p_add">+		rec-&gt;lun = ZFCP_DBF_INVALID_LUN;</span>
 }
 
 /**
<span class="p_chunk">@@ -320,13 +323,48 @@</span> <span class="p_context"> void zfcp_dbf_rec_run(char *tag, struct zfcp_erp_action *erp)</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;rec_lock, flags);
 }
 
<span class="p_add">+/**</span>
<span class="p_add">+ * zfcp_dbf_rec_run_wka - trace wka port event with info like running recovery</span>
<span class="p_add">+ * @tag: identifier for event</span>
<span class="p_add">+ * @wka_port: well known address port</span>
<span class="p_add">+ * @req_id: request ID to correlate with potential HBA trace record</span>
<span class="p_add">+ */</span>
<span class="p_add">+void zfcp_dbf_rec_run_wka(char *tag, struct zfcp_fc_wka_port *wka_port,</span>
<span class="p_add">+			  u64 req_id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_dbf *dbf = wka_port-&gt;adapter-&gt;dbf;</span>
<span class="p_add">+	struct zfcp_dbf_rec *rec = &amp;dbf-&gt;rec_buf;</span>
<span class="p_add">+	unsigned long flags;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock_irqsave(&amp;dbf-&gt;rec_lock, flags);</span>
<span class="p_add">+	memset(rec, 0, sizeof(*rec));</span>
<span class="p_add">+</span>
<span class="p_add">+	rec-&gt;id = ZFCP_DBF_REC_RUN;</span>
<span class="p_add">+	memcpy(rec-&gt;tag, tag, ZFCP_DBF_TAG_LEN);</span>
<span class="p_add">+	rec-&gt;port_status = wka_port-&gt;status;</span>
<span class="p_add">+	rec-&gt;d_id = wka_port-&gt;d_id;</span>
<span class="p_add">+	rec-&gt;lun = ZFCP_DBF_INVALID_LUN;</span>
<span class="p_add">+</span>
<span class="p_add">+	rec-&gt;u.run.fsf_req_id = req_id;</span>
<span class="p_add">+	rec-&gt;u.run.rec_status = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_step = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_action = ~0;</span>
<span class="p_add">+	rec-&gt;u.run.rec_count = ~0;</span>
<span class="p_add">+</span>
<span class="p_add">+	debug_event(dbf-&gt;rec, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	spin_unlock_irqrestore(&amp;dbf-&gt;rec_lock, flags);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static inline
<span class="p_del">-void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,</span>
<span class="p_del">-		  u64 req_id, u32 d_id)</span>
<span class="p_add">+void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf,</span>
<span class="p_add">+		  char *paytag, struct scatterlist *sg, u8 id, u16 len,</span>
<span class="p_add">+		  u64 req_id, u32 d_id, u16 cap_len)</span>
 {
 	struct zfcp_dbf_san *rec = &amp;dbf-&gt;san_buf;
 	u16 rec_len;
 	unsigned long flags;
<span class="p_add">+	struct zfcp_dbf_pay *payload = &amp;dbf-&gt;pay_buf;</span>
<span class="p_add">+	u16 pay_sum = 0;</span>
 
 	spin_lock_irqsave(&amp;dbf-&gt;san_lock, flags);
 	memset(rec, 0, sizeof(*rec));
<span class="p_chunk">@@ -334,10 +372,41 @@</span> <span class="p_context"> void zfcp_dbf_san(char *tag, struct zfcp_dbf *dbf, void *data, u8 id, u16 len,</span>
 	rec-&gt;id = id;
 	rec-&gt;fsf_req_id = req_id;
 	rec-&gt;d_id = d_id;
<span class="p_del">-	rec_len = min(len, (u16)ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_del">-	memcpy(rec-&gt;payload, data, rec_len);</span>
 	memcpy(rec-&gt;tag, tag, ZFCP_DBF_TAG_LEN);
<span class="p_add">+	rec-&gt;pl_len = len; /* full length even if we cap pay below */</span>
<span class="p_add">+	if (!sg)</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+	rec_len = min_t(unsigned int, sg-&gt;length, ZFCP_DBF_SAN_MAX_PAYLOAD);</span>
<span class="p_add">+	memcpy(rec-&gt;payload, sg_virt(sg), rec_len); /* part of 1st sg entry */</span>
<span class="p_add">+	if (len &lt;= rec_len)</span>
<span class="p_add">+		goto out; /* skip pay record if full content in rec-&gt;payload */</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if (len &gt; rec_len):</span>
<span class="p_add">+	 * dump data up to cap_len ignoring small duplicate in rec-&gt;payload</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	spin_lock(&amp;dbf-&gt;pay_lock);</span>
<span class="p_add">+	memset(payload, 0, sizeof(*payload));</span>
<span class="p_add">+	memcpy(payload-&gt;area, paytag, ZFCP_DBF_TAG_LEN);</span>
<span class="p_add">+	payload-&gt;fsf_req_id = req_id;</span>
<span class="p_add">+	payload-&gt;counter = 0;</span>
<span class="p_add">+	for (; sg &amp;&amp; pay_sum &lt; cap_len; sg = sg_next(sg)) {</span>
<span class="p_add">+		u16 pay_len, offset = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+		while (offset &lt; sg-&gt;length &amp;&amp; pay_sum &lt; cap_len) {</span>
<span class="p_add">+			pay_len = min((u16)ZFCP_DBF_PAY_MAX_REC,</span>
<span class="p_add">+				      (u16)(sg-&gt;length - offset));</span>
<span class="p_add">+			/* cap_len &lt;= pay_sum &lt; cap_len+ZFCP_DBF_PAY_MAX_REC */</span>
<span class="p_add">+			memcpy(payload-&gt;data, sg_virt(sg) + offset, pay_len);</span>
<span class="p_add">+			debug_event(dbf-&gt;pay, 1, payload,</span>
<span class="p_add">+				    zfcp_dbf_plen(pay_len));</span>
<span class="p_add">+			payload-&gt;counter++;</span>
<span class="p_add">+			offset += pay_len;</span>
<span class="p_add">+			pay_sum += pay_len;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	spin_unlock(&amp;dbf-&gt;pay_lock);</span>
 
<span class="p_add">+out:</span>
 	debug_event(dbf-&gt;san, 1, rec, sizeof(*rec));
 	spin_unlock_irqrestore(&amp;dbf-&gt;san_lock, flags);
 }
<span class="p_chunk">@@ -354,9 +423,62 @@</span> <span class="p_context"> void zfcp_dbf_san_req(char *tag, struct zfcp_fsf_req *fsf, u32 d_id)</span>
 	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;
 	u16 length;
 
<span class="p_del">-	length = (u16)(ct_els-&gt;req-&gt;length + FC_CT_HDR_LEN);</span>
<span class="p_del">-	zfcp_dbf_san(tag, dbf, sg_virt(ct_els-&gt;req), ZFCP_DBF_SAN_REQ, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, d_id);</span>
<span class="p_add">+	length = (u16)zfcp_qdio_real_bytes(ct_els-&gt;req);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_req&quot;, ct_els-&gt;req, ZFCP_DBF_SAN_REQ,</span>
<span class="p_add">+		     length, fsf-&gt;req_id, d_id, length);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static u16 zfcp_dbf_san_res_cap_len_if_gpn_ft(char *tag,</span>
<span class="p_add">+					      struct zfcp_fsf_req *fsf,</span>
<span class="p_add">+					      u16 len)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;</span>
<span class="p_add">+	struct fc_ct_hdr *reqh = sg_virt(ct_els-&gt;req);</span>
<span class="p_add">+	struct fc_ns_gid_ft *reqn = (struct fc_ns_gid_ft *)(reqh + 1);</span>
<span class="p_add">+	struct scatterlist *resp_entry = ct_els-&gt;resp;</span>
<span class="p_add">+	struct fc_gpn_ft_resp *acc;</span>
<span class="p_add">+	int max_entries, x, last = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (!(memcmp(tag, &quot;fsscth2&quot;, 7) == 0</span>
<span class="p_add">+	      &amp;&amp; ct_els-&gt;d_id == FC_FID_DIR_SERV</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_rev == FC_CT_REV</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[0] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[1] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_in_id[2] == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_fs_type == FC_FST_DIR</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_fs_subtype == FC_NS_SUBTYPE</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_options == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;_ct_resvd1 == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_cmd == FC_NS_GPN_FT</span>
<span class="p_add">+	      /* reqh-&gt;ct_mr_size can vary so do not match but read below */</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;_ct_resvd2 == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_reason == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_explan == 0</span>
<span class="p_add">+	      &amp;&amp; reqh-&gt;ct_vendor == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_resvd == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_domain_id_scope == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_area_id_scope == 0</span>
<span class="p_add">+	      &amp;&amp; reqn-&gt;fn_fc4_type == FC_TYPE_FCP))</span>
<span class="p_add">+		return len; /* not GPN_FT response so do not cap */</span>
<span class="p_add">+</span>
<span class="p_add">+	acc = sg_virt(resp_entry);</span>
<span class="p_add">+	max_entries = (reqh-&gt;ct_mr_size * 4 / sizeof(struct fc_gpn_ft_resp))</span>
<span class="p_add">+		+ 1 /* zfcp_fc_scan_ports: bytes correct, entries off-by-one</span>
<span class="p_add">+		     * to account for header as 1st pseudo &quot;entry&quot; */;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* the basic CT_IU preamble is the same size as one entry in the GPN_FT</span>
<span class="p_add">+	 * response, allowing us to skip special handling for it - just skip it</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	for (x = 1; x &lt; max_entries &amp;&amp; !last; x++) {</span>
<span class="p_add">+		if (x % (ZFCP_FC_GPN_FT_ENT_PAGE + 1))</span>
<span class="p_add">+			acc++;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			acc = sg_virt(++resp_entry);</span>
<span class="p_add">+</span>
<span class="p_add">+		last = acc-&gt;fp_flags &amp; FC_NS_FID_LAST;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	len = min(len, (u16)(x * sizeof(struct fc_gpn_ft_resp)));</span>
<span class="p_add">+	return len; /* cap after last entry */</span>
 }
 
 /**
<span class="p_chunk">@@ -370,9 +492,10 @@</span> <span class="p_context"> void zfcp_dbf_san_res(char *tag, struct zfcp_fsf_req *fsf)</span>
 	struct zfcp_fsf_ct_els *ct_els = fsf-&gt;data;
 	u16 length;
 
<span class="p_del">-	length = (u16)(ct_els-&gt;resp-&gt;length + FC_CT_HDR_LEN);</span>
<span class="p_del">-	zfcp_dbf_san(tag, dbf, sg_virt(ct_els-&gt;resp), ZFCP_DBF_SAN_RES, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, 0);</span>
<span class="p_add">+	length = (u16)zfcp_qdio_real_bytes(ct_els-&gt;resp);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_res&quot;, ct_els-&gt;resp, ZFCP_DBF_SAN_RES,</span>
<span class="p_add">+		     length, fsf-&gt;req_id, ct_els-&gt;d_id,</span>
<span class="p_add">+		     zfcp_dbf_san_res_cap_len_if_gpn_ft(tag, fsf, length));</span>
 }
 
 /**
<span class="p_chunk">@@ -386,11 +509,13 @@</span> <span class="p_context"> void zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)</span>
 	struct fsf_status_read_buffer *srb =
 		(struct fsf_status_read_buffer *) fsf-&gt;data;
 	u16 length;
<span class="p_add">+	struct scatterlist sg;</span>
 
 	length = (u16)(srb-&gt;length -
 			offsetof(struct fsf_status_read_buffer, payload));
<span class="p_del">-	zfcp_dbf_san(tag, dbf, srb-&gt;payload.data, ZFCP_DBF_SAN_ELS, length,</span>
<span class="p_del">-		     fsf-&gt;req_id, ntoh24(srb-&gt;d_id));</span>
<span class="p_add">+	sg_init_one(&amp;sg, srb-&gt;payload.data, length);</span>
<span class="p_add">+	zfcp_dbf_san(tag, dbf, &quot;san_els&quot;, &amp;sg, ZFCP_DBF_SAN_ELS, length,</span>
<span class="p_add">+		     fsf-&gt;req_id, ntoh24(srb-&gt;d_id), length);</span>
 }
 
 /**
<span class="p_chunk">@@ -399,7 +524,8 @@</span> <span class="p_context"> void zfcp_dbf_san_in_els(char *tag, struct zfcp_fsf_req *fsf)</span>
  * @sc: pointer to struct scsi_cmnd
  * @fsf: pointer to struct zfcp_fsf_req
  */
<span class="p_del">-void zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)</span>
<span class="p_add">+void zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *sc,</span>
<span class="p_add">+		   struct zfcp_fsf_req *fsf)</span>
 {
 	struct zfcp_adapter *adapter =
 		(struct zfcp_adapter *) sc-&gt;device-&gt;host-&gt;hostdata[0];
<span class="p_chunk">@@ -441,7 +567,7 @@</span> <span class="p_context"> void zfcp_dbf_scsi(char *tag, struct scsi_cmnd *sc, struct zfcp_fsf_req *fsf)</span>
 		}
 	}
 
<span class="p_del">-	debug_event(dbf-&gt;scsi, 1, rec, sizeof(*rec));</span>
<span class="p_add">+	debug_event(dbf-&gt;scsi, level, rec, sizeof(*rec));</span>
 	spin_unlock_irqrestore(&amp;dbf-&gt;scsi_lock, flags);
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_dbf.h b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">index 0be3d48681ae..36d07584271d 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_dbf.h</span>
<span class="p_chunk">@@ -2,7 +2,7 @@</span> <span class="p_context"></span>
  * zfcp device driver
  * debug feature declarations
  *
<span class="p_del">- * Copyright IBM Corp. 2008, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2008, 2015</span>
  */
 
 #ifndef ZFCP_DBF_H
<span class="p_chunk">@@ -17,6 +17,11 @@</span> <span class="p_context"></span>
 
 #define ZFCP_DBF_INVALID_LUN	0xFFFFFFFFFFFFFFFFull
 
<span class="p_add">+enum zfcp_dbf_pseudo_erp_act_type {</span>
<span class="p_add">+	ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD = 0xff,</span>
<span class="p_add">+	ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL = 0xfe,</span>
<span class="p_add">+};</span>
<span class="p_add">+</span>
 /**
  * struct zfcp_dbf_rec_trigger - trace record for triggered recovery action
  * @ready: number of ready recovery actions
<span class="p_chunk">@@ -110,6 +115,7 @@</span> <span class="p_context"> struct zfcp_dbf_san {</span>
 	u32 d_id;
 #define ZFCP_DBF_SAN_MAX_PAYLOAD (FC_CT_HDR_LEN + 32)
 	char payload[ZFCP_DBF_SAN_MAX_PAYLOAD];
<span class="p_add">+	u16 pl_len;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -126,6 +132,8 @@</span> <span class="p_context"> struct zfcp_dbf_hba_res {</span>
 	u8  prot_status_qual[FSF_PROT_STATUS_QUAL_SIZE];
 	u32 fsf_status;
 	u8  fsf_status_qual[FSF_STATUS_QUALIFIER_SIZE];
<span class="p_add">+	u32 port_handle;</span>
<span class="p_add">+	u32 lun_handle;</span>
 } __packed;
 
 /**
<span class="p_chunk">@@ -279,7 +287,7 @@</span> <span class="p_context"> static inline</span>
 void zfcp_dbf_hba_fsf_resp(char *tag, int level, struct zfcp_fsf_req *req)
 {
 	if (debug_level_enabled(req-&gt;adapter-&gt;dbf-&gt;hba, level))
<span class="p_del">-		zfcp_dbf_hba_fsf_res(tag, req);</span>
<span class="p_add">+		zfcp_dbf_hba_fsf_res(tag, level, req);</span>
 }
 
 /**
<span class="p_chunk">@@ -318,7 +326,7 @@</span> <span class="p_context"> void _zfcp_dbf_scsi(char *tag, int level, struct scsi_cmnd *scmd,</span>
 					scmd-&gt;device-&gt;host-&gt;hostdata[0];
 
 	if (debug_level_enabled(adapter-&gt;dbf-&gt;scsi, level))
<span class="p_del">-		zfcp_dbf_scsi(tag, scmd, req);</span>
<span class="p_add">+		zfcp_dbf_scsi(tag, level, scmd, req);</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_erp.c b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">index c82fe65c4128..ac86ff90c897 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_erp.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Error Recovery Procedures (ERP).
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -1224,8 +1224,14 @@</span> <span class="p_context"> static void zfcp_erp_action_cleanup(struct zfcp_erp_action *act, int result)</span>
 		break;
 
 	case ZFCP_ERP_ACTION_REOPEN_PORT:
<span class="p_del">-		if (result == ZFCP_ERP_SUCCEEDED)</span>
<span class="p_del">-			zfcp_scsi_schedule_rport_register(port);</span>
<span class="p_add">+		/* This switch case might also happen after a forced reopen</span>
<span class="p_add">+		 * was successfully done and thus overwritten with a new</span>
<span class="p_add">+		 * non-forced reopen at `ersfs_2&#39;. In this case, we must not</span>
<span class="p_add">+		 * do the clean-up of the non-forced version.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (act-&gt;step != ZFCP_ERP_STEP_UNINITIALIZED)</span>
<span class="p_add">+			if (result == ZFCP_ERP_SUCCEEDED)</span>
<span class="p_add">+				zfcp_scsi_schedule_rport_register(port);</span>
 		/* fall through */
 	case ZFCP_ERP_ACTION_REOPEN_PORT_FORCED:
 		put_device(&amp;port-&gt;dev);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_ext.h b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">index a9c570a09b85..1f1fe41ecb97 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_ext.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * External function declarations.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #ifndef ZFCP_EXT_H
<span class="p_chunk">@@ -35,8 +35,9 @@</span> <span class="p_context"> extern void zfcp_dbf_adapter_unregister(struct zfcp_adapter *);</span>
 extern void zfcp_dbf_rec_trig(char *, struct zfcp_adapter *,
 			      struct zfcp_port *, struct scsi_device *, u8, u8);
 extern void zfcp_dbf_rec_run(char *, struct zfcp_erp_action *);
<span class="p_add">+extern void zfcp_dbf_rec_run_wka(char *, struct zfcp_fc_wka_port *, u64);</span>
 extern void zfcp_dbf_hba_fsf_uss(char *, struct zfcp_fsf_req *);
<span class="p_del">-extern void zfcp_dbf_hba_fsf_res(char *, struct zfcp_fsf_req *);</span>
<span class="p_add">+extern void zfcp_dbf_hba_fsf_res(char *, int, struct zfcp_fsf_req *);</span>
 extern void zfcp_dbf_hba_bit_err(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_berr(struct zfcp_dbf *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_hba_def_err(struct zfcp_adapter *, u64, u16, void **);
<span class="p_chunk">@@ -44,7 +45,8 @@</span> <span class="p_context"> extern void zfcp_dbf_hba_basic(char *, struct zfcp_adapter *);</span>
 extern void zfcp_dbf_san_req(char *, struct zfcp_fsf_req *, u32);
 extern void zfcp_dbf_san_res(char *, struct zfcp_fsf_req *);
 extern void zfcp_dbf_san_in_els(char *, struct zfcp_fsf_req *);
<span class="p_del">-extern void zfcp_dbf_scsi(char *, struct scsi_cmnd *, struct zfcp_fsf_req *);</span>
<span class="p_add">+extern void zfcp_dbf_scsi(char *, int, struct scsi_cmnd *,</span>
<span class="p_add">+			  struct zfcp_fsf_req *);</span>
 
 /* zfcp_erp.c */
 extern void zfcp_erp_set_adapter_status(struct zfcp_adapter *, u32);
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.c b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">index 0fe8d5d95119..6065212fdeed 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Implementation of FSF commands.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -508,7 +508,10 @@</span> <span class="p_context"> static int zfcp_fsf_exchange_config_evaluate(struct zfcp_fsf_req *req)</span>
 		fc_host_port_type(shost) = FC_PORTTYPE_PTP;
 		break;
 	case FSF_TOPO_FABRIC:
<span class="p_del">-		fc_host_port_type(shost) = FC_PORTTYPE_NPORT;</span>
<span class="p_add">+		if (bottom-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE)</span>
<span class="p_add">+			fc_host_port_type(shost) = FC_PORTTYPE_NPIV;</span>
<span class="p_add">+		else</span>
<span class="p_add">+			fc_host_port_type(shost) = FC_PORTTYPE_NPORT;</span>
 		break;
 	case FSF_TOPO_AL:
 		fc_host_port_type(shost) = FC_PORTTYPE_NLPORT;
<span class="p_chunk">@@ -613,7 +616,6 @@</span> <span class="p_context"> static void zfcp_fsf_exchange_port_evaluate(struct zfcp_fsf_req *req)</span>
 
 	if (adapter-&gt;connection_features &amp; FSF_FEATURE_NPIV_MODE) {
 		fc_host_permanent_port_name(shost) = bottom-&gt;wwpn;
<span class="p_del">-		fc_host_port_type(shost) = FC_PORTTYPE_NPIV;</span>
 	} else
 		fc_host_permanent_port_name(shost) = fc_host_port_name(shost);
 	fc_host_maxframe_size(shost) = bottom-&gt;maximum_frame_size;
<span class="p_chunk">@@ -982,8 +984,12 @@</span> <span class="p_context"> static int zfcp_fsf_setup_ct_els_sbals(struct zfcp_fsf_req *req,</span>
 	if (zfcp_adapter_multi_buffer_active(adapter)) {
 		if (zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req, sg_req))
 			return -EIO;
<span class="p_add">+		qtcb-&gt;bottom.support.req_buf_length =</span>
<span class="p_add">+			zfcp_qdio_real_bytes(sg_req);</span>
 		if (zfcp_qdio_sbals_from_sg(qdio, &amp;req-&gt;qdio_req, sg_resp))
 			return -EIO;
<span class="p_add">+		qtcb-&gt;bottom.support.resp_buf_length =</span>
<span class="p_add">+			zfcp_qdio_real_bytes(sg_resp);</span>
 
 		zfcp_qdio_set_data_div(qdio, &amp;req-&gt;qdio_req,
 					zfcp_qdio_sbale_count(sg_req));
<span class="p_chunk">@@ -1073,6 +1079,7 @@</span> <span class="p_context"> int zfcp_fsf_send_ct(struct zfcp_fc_wka_port *wka_port,</span>
 
 	req-&gt;handler = zfcp_fsf_send_ct_handler;
 	req-&gt;qtcb-&gt;header.port_handle = wka_port-&gt;handle;
<span class="p_add">+	ct-&gt;d_id = wka_port-&gt;d_id;</span>
 	req-&gt;data = ct;
 
 	zfcp_dbf_san_req(&quot;fssct_1&quot;, req, wka_port-&gt;d_id);
<span class="p_chunk">@@ -1169,6 +1176,7 @@</span> <span class="p_context"> int zfcp_fsf_send_els(struct zfcp_adapter *adapter, u32 d_id,</span>
 
 	hton24(req-&gt;qtcb-&gt;bottom.support.d_id, d_id);
 	req-&gt;handler = zfcp_fsf_send_els_handler;
<span class="p_add">+	els-&gt;d_id = d_id;</span>
 	req-&gt;data = els;
 
 	zfcp_dbf_san_req(&quot;fssels1&quot;, req, d_id);
<span class="p_chunk">@@ -1576,7 +1584,7 @@</span> <span class="p_context"> out:</span>
 int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req;</span>
<span class="p_add">+	struct zfcp_fsf_req *req = NULL;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1605,6 +1613,8 @@</span> <span class="p_context"> int zfcp_fsf_open_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_add">+	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+		zfcp_dbf_rec_run_wka(&quot;fsowp_1&quot;, wka_port, req-&gt;req_id);</span>
 	return retval;
 }
 
<span class="p_chunk">@@ -1629,7 +1639,7 @@</span> <span class="p_context"> static void zfcp_fsf_close_wka_port_handler(struct zfcp_fsf_req *req)</span>
 int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)
 {
 	struct zfcp_qdio *qdio = wka_port-&gt;adapter-&gt;qdio;
<span class="p_del">-	struct zfcp_fsf_req *req;</span>
<span class="p_add">+	struct zfcp_fsf_req *req = NULL;</span>
 	int retval = -EIO;
 
 	spin_lock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_chunk">@@ -1658,6 +1668,8 @@</span> <span class="p_context"> int zfcp_fsf_close_wka_port(struct zfcp_fc_wka_port *wka_port)</span>
 		zfcp_fsf_req_free(req);
 out:
 	spin_unlock_irq(&amp;qdio-&gt;req_q_lock);
<span class="p_add">+	if (req &amp;&amp; !IS_ERR(req))</span>
<span class="p_add">+		zfcp_dbf_rec_run_wka(&quot;fscwp_1&quot;, wka_port, req-&gt;req_id);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_fsf.h b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">index 57ae3ae1046d..be1c04b334c5 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_fsf.h</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to the FSF support functions.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2010</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #ifndef FSF_H
<span class="p_chunk">@@ -436,6 +436,7 @@</span> <span class="p_context"> struct zfcp_blk_drv_data {</span>
  * @handler_data: data passed to handler function
  * @port: Optional pointer to port for zfcp internal ELS (only test link ADISC)
  * @status: used to pass error status to calling function
<span class="p_add">+ * @d_id: Destination ID of either open WKA port for CT or of D_ID for ELS</span>
  */
 struct zfcp_fsf_ct_els {
 	struct scatterlist *req;
<span class="p_chunk">@@ -444,6 +445,7 @@</span> <span class="p_context"> struct zfcp_fsf_ct_els {</span>
 	void *handler_data;
 	struct zfcp_port *port;
 	int status;
<span class="p_add">+	u32 d_id;</span>
 };
 
 #endif				/* FSF_H */
<span class="p_header">diff --git a/drivers/s390/scsi/zfcp_scsi.c b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">index 7b353647cb90..38ee0df633a3 100644</span>
<span class="p_header">--- a/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_header">+++ b/drivers/s390/scsi/zfcp_scsi.c</span>
<span class="p_chunk">@@ -3,7 +3,7 @@</span> <span class="p_context"></span>
  *
  * Interface to Linux SCSI midlayer.
  *
<span class="p_del">- * Copyright IBM Corp. 2002, 2013</span>
<span class="p_add">+ * Copyright IBM Corp. 2002, 2015</span>
  */
 
 #define KMSG_COMPONENT &quot;zfcp&quot;
<span class="p_chunk">@@ -577,6 +577,9 @@</span> <span class="p_context"> static void zfcp_scsi_rport_register(struct zfcp_port *port)</span>
 	ids.port_id = port-&gt;d_id;
 	ids.roles = FC_RPORT_ROLE_FCP_TARGET;
 
<span class="p_add">+	zfcp_dbf_rec_trig(&quot;scpaddy&quot;, port-&gt;adapter, port, NULL,</span>
<span class="p_add">+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD,</span>
<span class="p_add">+			  ZFCP_PSEUDO_ERP_ACTION_RPORT_ADD);</span>
 	rport = fc_remote_port_add(port-&gt;adapter-&gt;scsi_host, 0, &amp;ids);
 	if (!rport) {
 		dev_err(&amp;port-&gt;adapter-&gt;ccw_device-&gt;dev,
<span class="p_chunk">@@ -598,6 +601,9 @@</span> <span class="p_context"> static void zfcp_scsi_rport_block(struct zfcp_port *port)</span>
 	struct fc_rport *rport = port-&gt;rport;
 
 	if (rport) {
<span class="p_add">+		zfcp_dbf_rec_trig(&quot;scpdely&quot;, port-&gt;adapter, port, NULL,</span>
<span class="p_add">+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL,</span>
<span class="p_add">+				  ZFCP_PSEUDO_ERP_ACTION_RPORT_DEL);</span>
 		fc_remote_port_delete(rport);
 		port-&gt;rport = NULL;
 	}
<span class="p_header">diff --git a/drivers/scsi/arcmsr/arcmsr_hba.c b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">index 4494529c4a60..bf87e3973953 100644</span>
<span class="p_header">--- a/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_header">+++ b/drivers/scsi/arcmsr/arcmsr_hba.c</span>
<span class="p_chunk">@@ -2068,18 +2068,9 @@</span> <span class="p_context"> static int arcmsr_queue_command_lck(struct scsi_cmnd *cmd,</span>
 	struct AdapterControlBlock *acb = (struct AdapterControlBlock *) host-&gt;hostdata;
 	struct CommandControlBlock *ccb;
 	int target = cmd-&gt;device-&gt;id;
<span class="p_del">-	int lun = cmd-&gt;device-&gt;lun;</span>
<span class="p_del">-	uint8_t scsicmd = cmd-&gt;cmnd[0];</span>
 	cmd-&gt;scsi_done = done;
 	cmd-&gt;host_scribble = NULL;
 	cmd-&gt;result = 0;
<span class="p_del">-	if ((scsicmd == SYNCHRONIZE_CACHE) ||(scsicmd == SEND_DIAGNOSTIC)){</span>
<span class="p_del">-		if(acb-&gt;devstate[target][lun] == ARECA_RAID_GONE) {</span>
<span class="p_del">-    			cmd-&gt;result = (DID_NO_CONNECT &lt;&lt; 16);</span>
<span class="p_del">-		}</span>
<span class="p_del">-		cmd-&gt;scsi_done(cmd);</span>
<span class="p_del">-		return 0;</span>
<span class="p_del">-	}</span>
 	if (target == 16) {
 		/* virtual device for iop message transfer */
 		arcmsr_handle_virtual_command(acb, cmd);
<span class="p_header">diff --git a/drivers/scsi/ibmvscsi/ibmvfc.c b/drivers/scsi/ibmvscsi/ibmvfc.c</span>
<span class="p_header">index 8dd47689d584..f41feaf50452 100644</span>
<span class="p_header">--- a/drivers/scsi/ibmvscsi/ibmvfc.c</span>
<span class="p_header">+++ b/drivers/scsi/ibmvscsi/ibmvfc.c</span>
<span class="p_chunk">@@ -717,7 +717,6 @@</span> <span class="p_context"> static int ibmvfc_reset_crq(struct ibmvfc_host *vhost)</span>
 	spin_lock_irqsave(vhost-&gt;host-&gt;host_lock, flags);
 	vhost-&gt;state = IBMVFC_NO_CRQ;
 	vhost-&gt;logged_in = 0;
<span class="p_del">-	ibmvfc_set_host_action(vhost, IBMVFC_HOST_ACTION_NONE);</span>
 
 	/* Clean out the queue */
 	memset(crq-&gt;msgs, 0, PAGE_SIZE);
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas.h b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">index 293a396b64ad..5fb8c24dd44a 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas.h</span>
<span class="p_chunk">@@ -1734,7 +1734,7 @@</span> <span class="p_context"> struct megasas_instance_template {</span>
 };
 
 #define MEGASAS_IS_LOGICAL(scp)						\
<span class="p_del">-	(scp-&gt;device-&gt;channel &lt; MEGASAS_MAX_PD_CHANNELS) ? 0 : 1</span>
<span class="p_add">+	((scp-&gt;device-&gt;channel &lt; MEGASAS_MAX_PD_CHANNELS) ? 0 : 1)</span>
 
 #define MEGASAS_DEV_INDEX(inst, scp)					\
 	((scp-&gt;device-&gt;channel % 2) * MEGASAS_MAX_DEV_PER_CHANNEL) + 	\
<span class="p_header">diff --git a/drivers/scsi/megaraid/megaraid_sas_base.c b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">index 0f6f296eaff9..55036079d074 100644</span>
<span class="p_header">--- a/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_header">+++ b/drivers/scsi/megaraid/megaraid_sas_base.c</span>
<span class="p_chunk">@@ -1586,16 +1586,13 @@</span> <span class="p_context"> megasas_queue_command_lck(struct scsi_cmnd *scmd, void (*done) (struct scsi_cmnd</span>
 		goto out_done;
 	}
 
<span class="p_del">-	switch (scmd-&gt;cmnd[0]) {</span>
<span class="p_del">-	case SYNCHRONIZE_CACHE:</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * FW takes care of flush cache on its own</span>
<span class="p_del">-		 * No need to send it down</span>
<span class="p_del">-		 */</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * FW takes care of flush cache on its own for Virtual Disk.</span>
<span class="p_add">+	 * No need to send it down for VD. For JBOD send SYNCHRONIZE_CACHE to FW.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if ((scmd-&gt;cmnd[0] == SYNCHRONIZE_CACHE) &amp;&amp; MEGASAS_IS_LOGICAL(scmd)) {</span>
 		scmd-&gt;result = DID_OK &lt;&lt; 16;
 		goto out_done;
<span class="p_del">-	default:</span>
<span class="p_del">-		break;</span>
 	}
 
 	if (instance-&gt;instancet-&gt;build_and_issue_cmd(instance, scmd)) {
<span class="p_header">diff --git a/drivers/scsi/mpt3sas/mpt3sas_scsih.c b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">index 18e713db1d32..57fb8f040a1c 100644</span>
<span class="p_header">--- a/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_header">+++ b/drivers/scsi/mpt3sas/mpt3sas_scsih.c</span>
<span class="p_chunk">@@ -1625,7 +1625,10 @@</span> <span class="p_context"> _scsih_get_volume_capabilities(struct MPT3SAS_ADAPTER *ioc,</span>
 	return 0;
 }
 
<span class="p_del">-</span>
<span class="p_add">+static inline bool ata_12_16_cmd(struct scsi_cmnd *scmd)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return (scmd-&gt;cmnd[0] == ATA_12 || scmd-&gt;cmnd[0] == ATA_16);</span>
<span class="p_add">+}</span>
 
 /**
  * _scsih_enable_tlr - setting TLR flags
<span class="p_chunk">@@ -3541,6 +3544,13 @@</span> <span class="p_context"> _scsih_qcmd(struct Scsi_Host *shost, struct scsi_cmnd *scmd)</span>
 		scsi_print_command(scmd);
 #endif
 
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Lock the device for any subsequent command until command is</span>
<span class="p_add">+	 * done.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ata_12_16_cmd(scmd))</span>
<span class="p_add">+		scsi_internal_device_block(scmd-&gt;device);</span>
<span class="p_add">+</span>
 	sas_device_priv_data = scmd-&gt;device-&gt;hostdata;
 	if (!sas_device_priv_data || !sas_device_priv_data-&gt;sas_target) {
 		scmd-&gt;result = DID_NO_CONNECT &lt;&lt; 16;
<span class="p_chunk">@@ -4041,6 +4051,9 @@</span> <span class="p_context"> _scsih_io_done(struct MPT3SAS_ADAPTER *ioc, u16 smid, u8 msix_index, u32 reply)</span>
 	if (scmd == NULL)
 		return 1;
 
<span class="p_add">+	if (ata_12_16_cmd(scmd))</span>
<span class="p_add">+		scsi_internal_device_unblock(scmd-&gt;device, SDEV_RUNNING);</span>
<span class="p_add">+</span>
 	mpi_request = mpt3sas_base_get_msg_frame(ioc, smid);
 
 	if (mpi_reply == NULL) {
<span class="p_header">diff --git a/drivers/scsi/scsi_debug.c b/drivers/scsi/scsi_debug.c</span>
<span class="p_header">index 1328a2621070..e9e43f7de656 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_debug.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_debug.c</span>
<span class="p_chunk">@@ -3478,6 +3478,7 @@</span> <span class="p_context"> static void __exit scsi_debug_exit(void)</span>
 	bus_unregister(&amp;pseudo_lld_bus);
 	root_device_unregister(pseudo_primary);
 
<span class="p_add">+	vfree(map_storep);</span>
 	if (dif_storep)
 		vfree(dif_storep);
 
<span class="p_header">diff --git a/drivers/scsi/scsi_scan.c b/drivers/scsi/scsi_scan.c</span>
<span class="p_header">index 98996ba87f3b..81d4151179d8 100644</span>
<span class="p_header">--- a/drivers/scsi/scsi_scan.c</span>
<span class="p_header">+++ b/drivers/scsi/scsi_scan.c</span>
<span class="p_chunk">@@ -1546,12 +1546,12 @@</span> <span class="p_context"> static int scsi_report_lun_scan(struct scsi_target *starget, int bflags,</span>
  out_err:
 	kfree(lun_data);
  out:
<span class="p_del">-	scsi_device_put(sdev);</span>
 	if (scsi_device_created(sdev))
 		/*
 		 * the sdev we used didn&#39;t appear in the report luns scan
 		 */
 		__scsi_remove_device(sdev);
<span class="p_add">+	scsi_device_put(sdev);</span>
 	return ret;
 }
 
<span class="p_header">diff --git a/drivers/scsi/sg.c b/drivers/scsi/sg.c</span>
<span class="p_header">index e1a6abe899f9..b4d50662fc6f 100644</span>
<span class="p_header">--- a/drivers/scsi/sg.c</span>
<span class="p_header">+++ b/drivers/scsi/sg.c</span>
<span class="p_chunk">@@ -568,6 +568,9 @@</span> <span class="p_context"> sg_write(struct file *filp, const char __user *buf, size_t count, loff_t * ppos)</span>
 	sg_io_hdr_t *hp;
 	unsigned char cmnd[MAX_COMMAND_SIZE];
 
<span class="p_add">+	if (unlikely(segment_eq(get_fs(), KERNEL_DS)))</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	if ((!(sfp = (Sg_fd *) filp-&gt;private_data)) || (!(sdp = sfp-&gt;parentdp)))
 		return -ENXIO;
 	SCSI_LOG_TIMEOUT(3, printk(&quot;sg_write: %s, count=%d\n&quot;,
<span class="p_chunk">@@ -766,8 +769,11 @@</span> <span class="p_context"> sg_common_write(Sg_fd * sfp, Sg_request * srp,</span>
 		return k;	/* probably out of space --&gt; ENOMEM */
 	}
 	if (sdp-&gt;detached) {
<span class="p_del">-		if (srp-&gt;bio)</span>
<span class="p_add">+		if (srp-&gt;bio) {</span>
 			blk_end_request_all(srp-&gt;rq, -EIO);
<span class="p_add">+			srp-&gt;rq = NULL;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		sg_finish_rem_req(srp);
 		return -ENODEV;
 	}
<span class="p_header">diff --git a/drivers/staging/android/ion/ion.c b/drivers/staging/android/ion/ion.c</span>
<span class="p_header">index 3eb845baf3f5..c9f69d316ccc 100644</span>
<span class="p_header">--- a/drivers/staging/android/ion/ion.c</span>
<span class="p_header">+++ b/drivers/staging/android/ion/ion.c</span>
<span class="p_chunk">@@ -389,13 +389,22 @@</span> <span class="p_context"> static void ion_handle_get(struct ion_handle *handle)</span>
 	kref_get(&amp;handle-&gt;ref);
 }
 
<span class="p_del">-static int ion_handle_put(struct ion_handle *handle)</span>
<span class="p_add">+static int ion_handle_put_nolock(struct ion_handle *handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = kref_put(&amp;handle-&gt;ref, ion_handle_destroy);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+int ion_handle_put(struct ion_handle *handle)</span>
 {
 	struct ion_client *client = handle-&gt;client;
 	int ret;
 
 	mutex_lock(&amp;client-&gt;lock);
<span class="p_del">-	ret = kref_put(&amp;handle-&gt;ref, ion_handle_destroy);</span>
<span class="p_add">+	ret = ion_handle_put_nolock(handle);</span>
 	mutex_unlock(&amp;client-&gt;lock);
 
 	return ret;
<span class="p_chunk">@@ -419,20 +428,30 @@</span> <span class="p_context"> static struct ion_handle *ion_handle_lookup(struct ion_client *client,</span>
 	return ERR_PTR(-EINVAL);
 }
 
<span class="p_del">-static struct ion_handle *ion_handle_get_by_id(struct ion_client *client,</span>
<span class="p_add">+static struct ion_handle *ion_handle_get_by_id_nolock(struct ion_client *client,</span>
 						int id)
 {
 	struct ion_handle *handle;
 
<span class="p_del">-	mutex_lock(&amp;client-&gt;lock);</span>
 	handle = idr_find(&amp;client-&gt;idr, id);
 	if (handle)
 		ion_handle_get(handle);
<span class="p_del">-	mutex_unlock(&amp;client-&gt;lock);</span>
 
 	return handle ? handle : ERR_PTR(-EINVAL);
 }
 
<span class="p_add">+struct ion_handle *ion_handle_get_by_id(struct ion_client *client,</span>
<span class="p_add">+						int id)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct ion_handle *handle;</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;client-&gt;lock);</span>
<span class="p_add">+	handle = ion_handle_get_by_id_nolock(client, id);</span>
<span class="p_add">+	mutex_unlock(&amp;client-&gt;lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	return handle;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static bool ion_handle_validate(struct ion_client *client,
 				struct ion_handle *handle)
 {
<span class="p_chunk">@@ -534,22 +553,28 @@</span> <span class="p_context"> struct ion_handle *ion_alloc(struct ion_client *client, size_t len,</span>
 }
 EXPORT_SYMBOL(ion_alloc);
 
<span class="p_del">-void ion_free(struct ion_client *client, struct ion_handle *handle)</span>
<span class="p_add">+static void ion_free_nolock(struct ion_client *client, struct ion_handle *handle)</span>
 {
 	bool valid_handle;
 
 	BUG_ON(client != handle-&gt;client);
 
<span class="p_del">-	mutex_lock(&amp;client-&gt;lock);</span>
 	valid_handle = ion_handle_validate(client, handle);
 
 	if (!valid_handle) {
 		WARN(1, &quot;%s: invalid handle passed to free.\n&quot;, __func__);
<span class="p_del">-		mutex_unlock(&amp;client-&gt;lock);</span>
 		return;
 	}
<span class="p_add">+	ion_handle_put_nolock(handle);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+void ion_free(struct ion_client *client, struct ion_handle *handle)</span>
<span class="p_add">+{</span>
<span class="p_add">+	BUG_ON(client != handle-&gt;client);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;client-&gt;lock);</span>
<span class="p_add">+	ion_free_nolock(client, handle);</span>
 	mutex_unlock(&amp;client-&gt;lock);
<span class="p_del">-	ion_handle_put(handle);</span>
 }
 EXPORT_SYMBOL(ion_free);
 
<span class="p_chunk">@@ -1277,11 +1302,15 @@</span> <span class="p_context"> static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)</span>
 	{
 		struct ion_handle *handle;
 
<span class="p_del">-		handle = ion_handle_get_by_id(client, data.handle.handle);</span>
<span class="p_del">-		if (IS_ERR(handle))</span>
<span class="p_add">+		mutex_lock(&amp;client-&gt;lock);</span>
<span class="p_add">+		handle = ion_handle_get_by_id_nolock(client, data.handle.handle);</span>
<span class="p_add">+		if (IS_ERR(handle)) {</span>
<span class="p_add">+			mutex_unlock(&amp;client-&gt;lock);</span>
 			return PTR_ERR(handle);
<span class="p_del">-		ion_free(client, handle);</span>
<span class="p_del">-		ion_handle_put(handle);</span>
<span class="p_add">+		}</span>
<span class="p_add">+		ion_free_nolock(client, handle);</span>
<span class="p_add">+		ion_handle_put_nolock(handle);</span>
<span class="p_add">+		mutex_unlock(&amp;client-&gt;lock);</span>
 		break;
 	}
 	case ION_IOC_SHARE:
<span class="p_header">diff --git a/drivers/staging/iio/impedance-analyzer/ad5933.c b/drivers/staging/iio/impedance-analyzer/ad5933.c</span>
<span class="p_header">index 97d4b3fb7e95..f8ea1b436cfb 100644</span>
<span class="p_header">--- a/drivers/staging/iio/impedance-analyzer/ad5933.c</span>
<span class="p_header">+++ b/drivers/staging/iio/impedance-analyzer/ad5933.c</span>
<span class="p_chunk">@@ -646,6 +646,7 @@</span> <span class="p_context"> static void ad5933_work(struct work_struct *work)</span>
 	struct iio_dev *indio_dev = i2c_get_clientdata(st-&gt;client);
 	signed short buf[2];
 	unsigned char status;
<span class="p_add">+	int ret;</span>
 
 	mutex_lock(&amp;indio_dev-&gt;mlock);
 	if (st-&gt;state == AD5933_CTRL_INIT_START_FREQ) {
<span class="p_chunk">@@ -653,19 +654,22 @@</span> <span class="p_context"> static void ad5933_work(struct work_struct *work)</span>
 		ad5933_cmd(st, AD5933_CTRL_START_SWEEP);
 		st-&gt;state = AD5933_CTRL_START_SWEEP;
 		schedule_delayed_work(&amp;st-&gt;work, st-&gt;poll_time_jiffies);
<span class="p_del">-		mutex_unlock(&amp;indio_dev-&gt;mlock);</span>
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out;</span>
 	}
 
<span class="p_del">-	ad5933_i2c_read(st-&gt;client, AD5933_REG_STATUS, 1, &amp;status);</span>
<span class="p_add">+	ret = ad5933_i2c_read(st-&gt;client, AD5933_REG_STATUS, 1, &amp;status);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto out;</span>
 
 	if (status &amp; AD5933_STAT_DATA_VALID) {
 		int scan_count = bitmap_weight(indio_dev-&gt;active_scan_mask,
 					       indio_dev-&gt;masklength);
<span class="p_del">-		ad5933_i2c_read(st-&gt;client,</span>
<span class="p_add">+		ret = ad5933_i2c_read(st-&gt;client,</span>
 				test_bit(1, indio_dev-&gt;active_scan_mask) ?
 				AD5933_REG_REAL_DATA : AD5933_REG_IMAG_DATA,
 				scan_count * 2, (u8 *)buf);
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			goto out;</span>
 
 		if (scan_count == 2) {
 			buf[0] = be16_to_cpu(buf[0]);
<span class="p_chunk">@@ -677,8 +681,7 @@</span> <span class="p_context"> static void ad5933_work(struct work_struct *work)</span>
 	} else {
 		/* no data available - try again later */
 		schedule_delayed_work(&amp;st-&gt;work, st-&gt;poll_time_jiffies);
<span class="p_del">-		mutex_unlock(&amp;indio_dev-&gt;mlock);</span>
<span class="p_del">-		return;</span>
<span class="p_add">+		goto out;</span>
 	}
 
 	if (status &amp; AD5933_STAT_SWEEP_DONE) {
<span class="p_chunk">@@ -690,7 +693,7 @@</span> <span class="p_context"> static void ad5933_work(struct work_struct *work)</span>
 		ad5933_cmd(st, AD5933_CTRL_INC_FREQ);
 		schedule_delayed_work(&amp;st-&gt;work, st-&gt;poll_time_jiffies);
 	}
<span class="p_del">-</span>
<span class="p_add">+out:</span>
 	mutex_unlock(&amp;indio_dev-&gt;mlock);
 }
 
<span class="p_header">diff --git a/drivers/staging/nvec/nvec_ps2.c b/drivers/staging/nvec/nvec_ps2.c</span>
<span class="p_header">index 45b2f1308e01..90e7d841825b 100644</span>
<span class="p_header">--- a/drivers/staging/nvec/nvec_ps2.c</span>
<span class="p_header">+++ b/drivers/staging/nvec/nvec_ps2.c</span>
<span class="p_chunk">@@ -104,13 +104,12 @@</span> <span class="p_context"> static int nvec_mouse_probe(struct platform_device *pdev)</span>
 {
 	struct nvec_chip *nvec = dev_get_drvdata(pdev-&gt;dev.parent);
 	struct serio *ser_dev;
<span class="p_del">-	char mouse_reset[] = { NVEC_PS2, SEND_COMMAND, PSMOUSE_RST, 3 };</span>
 
<span class="p_del">-	ser_dev = devm_kzalloc(&amp;pdev-&gt;dev, sizeof(struct serio), GFP_KERNEL);</span>
<span class="p_add">+	ser_dev = kzalloc(sizeof(struct serio), GFP_KERNEL);</span>
 	if (ser_dev == NULL)
 		return -ENOMEM;
 
<span class="p_del">-	ser_dev-&gt;id.type = SERIO_PS_PSTHRU;</span>
<span class="p_add">+	ser_dev-&gt;id.type = SERIO_8042;</span>
 	ser_dev-&gt;write = ps2_sendcommand;
 	ser_dev-&gt;start = ps2_startstreaming;
 	ser_dev-&gt;stop = ps2_stopstreaming;
<span class="p_chunk">@@ -125,9 +124,6 @@</span> <span class="p_context"> static int nvec_mouse_probe(struct platform_device *pdev)</span>
 
 	serio_register_port(ser_dev);
 
<span class="p_del">-	/* mouse reset */</span>
<span class="p_del">-	nvec_write_async(nvec, mouse_reset, sizeof(mouse_reset));</span>
<span class="p_del">-</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/drivers/staging/rtl8188eu/os_dep/usb_intf.c b/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_header">index db785c05f01c..d9552ba2c15d 100644</span>
<span class="p_header">--- a/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_header">+++ b/drivers/staging/rtl8188eu/os_dep/usb_intf.c</span>
<span class="p_chunk">@@ -494,8 +494,10 @@</span> <span class="p_context"> int rtw_resume_process(struct adapter *padapter)</span>
 	pwrpriv-&gt;bkeepfwalive = false;
 
 	DBG_88E(&quot;bkeepfwalive(%x)\n&quot;, pwrpriv-&gt;bkeepfwalive);
<span class="p_del">-	if (pm_netdev_open(pnetdev, true) != 0)</span>
<span class="p_add">+	if (pm_netdev_open(pnetdev, true) != 0) {</span>
<span class="p_add">+		_exit_pwrlock(&amp;pwrpriv-&gt;lock);</span>
 		goto exit;
<span class="p_add">+	}</span>
 
 	netif_device_attach(pnetdev);
 	netif_carrier_on(pnetdev);
<span class="p_header">diff --git a/drivers/target/target_core_transport.c b/drivers/target/target_core_transport.c</span>
<span class="p_header">index 7769af94aee2..d3f65523a19d 100644</span>
<span class="p_header">--- a/drivers/target/target_core_transport.c</span>
<span class="p_header">+++ b/drivers/target/target_core_transport.c</span>
<span class="p_chunk">@@ -1634,6 +1634,7 @@</span> <span class="p_context"> void transport_generic_request_failure(struct se_cmd *cmd,</span>
 	case TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED:
 	case TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED:
 	case TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED:
<span class="p_add">+	case TCM_COPY_TARGET_DEVICE_NOT_REACHABLE:</span>
 		break;
 	case TCM_OUT_OF_RESOURCES:
 		sense_reason = TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE;
<span class="p_chunk">@@ -2914,6 +2915,16 @@</span> <span class="p_context"> transport_send_check_condition_and_sense(struct se_cmd *cmd,</span>
 		buffer[SPC_ASCQ_KEY_OFFSET] = 0x03;
 		transport_err_sector_info(buffer, cmd-&gt;bad_sector);
 		break;
<span class="p_add">+	case TCM_COPY_TARGET_DEVICE_NOT_REACHABLE:</span>
<span class="p_add">+		/* CURRENT ERROR */</span>
<span class="p_add">+		buffer[0] = 0x70;</span>
<span class="p_add">+		buffer[SPC_ADD_SENSE_LEN_OFFSET] = 10;</span>
<span class="p_add">+		buffer[SPC_SENSE_KEY_OFFSET] = COPY_ABORTED;</span>
<span class="p_add">+		buffer[SPC_ASC_KEY_OFFSET] = 0x0d;</span>
<span class="p_add">+		/* COPY TARGET DEVICE NOT REACHABLE */</span>
<span class="p_add">+		buffer[SPC_ASCQ_KEY_OFFSET] = 0x02;</span>
<span class="p_add">+		transport_err_sector_info(buffer, cmd-&gt;bad_sector);</span>
<span class="p_add">+		break;</span>
 	case TCM_LOGICAL_UNIT_COMMUNICATION_FAILURE:
 	default:
 		/* CURRENT ERROR */
<span class="p_header">diff --git a/drivers/target/target_core_xcopy.c b/drivers/target/target_core_xcopy.c</span>
<span class="p_header">index e9186cdf35e9..60e611df4818 100644</span>
<span class="p_header">--- a/drivers/target/target_core_xcopy.c</span>
<span class="p_header">+++ b/drivers/target/target_core_xcopy.c</span>
<span class="p_chunk">@@ -116,7 +116,7 @@</span> <span class="p_context"> static int target_xcopy_locate_se_dev_e4(struct se_cmd *se_cmd, struct xcopy_op</span>
 	}
 	mutex_unlock(&amp;g_device_mutex);
 
<span class="p_del">-	pr_err(&quot;Unable to locate 0xe4 descriptor for EXTENDED_COPY\n&quot;);</span>
<span class="p_add">+	pr_debug_ratelimited(&quot;Unable to locate 0xe4 descriptor for EXTENDED_COPY\n&quot;);</span>
 	return -EINVAL;
 }
 
<span class="p_chunk">@@ -197,7 +197,7 @@</span> <span class="p_context"> static int target_xcopy_parse_tiddesc_e4(struct se_cmd *se_cmd, struct xcopy_op</span>
 
 static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,
 				struct xcopy_op *xop, unsigned char *p,
<span class="p_del">-				unsigned short tdll)</span>
<span class="p_add">+				unsigned short tdll, sense_reason_t *sense_ret)</span>
 {
 	struct se_device *local_dev = se_cmd-&gt;se_dev;
 	unsigned char *desc = p;
<span class="p_chunk">@@ -205,6 +205,8 @@</span> <span class="p_context"> static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,</span>
 	unsigned short start = 0;
 	bool src = true;
 
<span class="p_add">+	*sense_ret = TCM_INVALID_PARAMETER_LIST;</span>
<span class="p_add">+</span>
 	if (offset != 0) {
 		pr_err(&quot;XCOPY target descriptor list length is not&quot;
 			&quot; multiple of %d\n&quot;, XCOPY_TARGET_DESC_LEN);
<span class="p_chunk">@@ -255,9 +257,16 @@</span> <span class="p_context"> static int target_xcopy_parse_target_descriptors(struct se_cmd *se_cmd,</span>
 		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, true);
 	else
 		rc = target_xcopy_locate_se_dev_e4(se_cmd, xop, false);
<span class="p_del">-</span>
<span class="p_del">-	if (rc &lt; 0)</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If a matching IEEE NAA 0x83 descriptor for the requested device</span>
<span class="p_add">+	 * is not located on this node, return COPY_ABORTED with ASQ/ASQC</span>
<span class="p_add">+	 * 0x0d/0x02 - COPY_TARGET_DEVICE_NOT_REACHABLE to request the</span>
<span class="p_add">+	 * initiator to fall back to normal copy method.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (rc &lt; 0) {</span>
<span class="p_add">+		*sense_ret = TCM_COPY_TARGET_DEVICE_NOT_REACHABLE;</span>
 		goto out;
<span class="p_add">+	}</span>
 
 	pr_debug(&quot;XCOPY TGT desc: Source dev: %p NAA IEEE WWN: 0x%16phN\n&quot;,
 		 xop-&gt;src_dev, &amp;xop-&gt;src_tid_wwn[0]);
<span class="p_chunk">@@ -698,6 +707,7 @@</span> <span class="p_context"> static int target_xcopy_read_source(</span>
 	rc = target_xcopy_setup_pt_cmd(xpt_cmd, xop, src_dev, &amp;cdb[0],
 				remote_port, true);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
 	}
<span class="p_chunk">@@ -709,6 +719,7 @@</span> <span class="p_context"> static int target_xcopy_read_source(</span>
 
 	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
 	}
<span class="p_chunk">@@ -759,6 +770,7 @@</span> <span class="p_context"> static int target_xcopy_write_destination(</span>
 				remote_port, false);
 	if (rc &lt; 0) {
 		struct se_cmd *src_cmd = &amp;xop-&gt;src_pt_cmd-&gt;se_cmd;
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		/*
 		 * If the failure happened before the t_mem_list hand-off in
 		 * target_xcopy_setup_pt_cmd(), Reset memory + clear flag so that
<span class="p_chunk">@@ -774,6 +786,7 @@</span> <span class="p_context"> static int target_xcopy_write_destination(</span>
 
 	rc = target_xcopy_issue_pt_cmd(xpt_cmd);
 	if (rc &lt; 0) {
<span class="p_add">+		ec_cmd-&gt;scsi_status = xpt_cmd-&gt;se_cmd.scsi_status;</span>
 		se_cmd-&gt;se_cmd_flags &amp;= ~SCF_PASSTHROUGH_SG_TO_MEM_NOALLOC;
 		transport_generic_free_cmd(se_cmd, 0);
 		return rc;
<span class="p_chunk">@@ -860,9 +873,14 @@</span> <span class="p_context"> static void target_xcopy_do_work(struct work_struct *work)</span>
 out:
 	xcopy_pt_undepend_remotedev(xop);
 	kfree(xop);
<span class="p_del">-</span>
<span class="p_del">-	pr_warn(&quot;target_xcopy_do_work: Setting X-COPY CHECK_CONDITION -&gt; sending response\n&quot;);</span>
<span class="p_del">-	ec_cmd-&gt;scsi_status = SAM_STAT_CHECK_CONDITION;</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Don&#39;t override an error scsi status if it has already been set</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (ec_cmd-&gt;scsi_status == SAM_STAT_GOOD) {</span>
<span class="p_add">+		pr_warn_ratelimited(&quot;target_xcopy_do_work: rc: %d, Setting X-COPY&quot;</span>
<span class="p_add">+			&quot; CHECK_CONDITION -&gt; sending response\n&quot;, rc);</span>
<span class="p_add">+		ec_cmd-&gt;scsi_status = SAM_STAT_CHECK_CONDITION;</span>
<span class="p_add">+	}</span>
 	target_complete_cmd(ec_cmd, SAM_STAT_CHECK_CONDITION);
 }
 
<span class="p_chunk">@@ -920,7 +938,7 @@</span> <span class="p_context"> sense_reason_t target_do_xcopy(struct se_cmd *se_cmd)</span>
 		&quot; tdll: %hu sdll: %u inline_dl: %u\n&quot;, list_id, list_id_usage,
 		tdll, sdll, inline_dl);
 
<span class="p_del">-	rc = target_xcopy_parse_target_descriptors(se_cmd, xop, &amp;p[16], tdll);</span>
<span class="p_add">+	rc = target_xcopy_parse_target_descriptors(se_cmd, xop, &amp;p[16], tdll, &amp;ret);</span>
 	if (rc &lt;= 0)
 		goto out;
 
<span class="p_header">diff --git a/drivers/tty/tty_ldisc.c b/drivers/tty/tty_ldisc.c</span>
<span class="p_header">index 2d822aa259b2..2bf08366cd5b 100644</span>
<span class="p_header">--- a/drivers/tty/tty_ldisc.c</span>
<span class="p_header">+++ b/drivers/tty/tty_ldisc.c</span>
<span class="p_chunk">@@ -414,6 +414,10 @@</span> <span class="p_context"> EXPORT_SYMBOL_GPL(tty_ldisc_flush);</span>
  *	they are not on hot paths so a little discipline won&#39;t do
  *	any harm.
  *
<span class="p_add">+ *	The line discipline-related tty_struct fields are reset to</span>
<span class="p_add">+ *	prevent the ldisc driver from re-using stale information for</span>
<span class="p_add">+ *	the new ldisc instance.</span>
<span class="p_add">+ *</span>
  *	Locking: takes termios_rwsem
  */
 
<span class="p_chunk">@@ -422,6 +426,9 @@</span> <span class="p_context"> static void tty_set_termios_ldisc(struct tty_struct *tty, int num)</span>
 	down_write(&amp;tty-&gt;termios_rwsem);
 	tty-&gt;termios.c_line = num;
 	up_write(&amp;tty-&gt;termios_rwsem);
<span class="p_add">+</span>
<span class="p_add">+	tty-&gt;disc_data = NULL;</span>
<span class="p_add">+	tty-&gt;receive_room = 0;</span>
 }
 
 /**
<span class="p_header">diff --git a/drivers/tty/vt/vt.c b/drivers/tty/vt/vt.c</span>
<span class="p_header">index 9062636d3154..a57f3761ab47 100644</span>
<span class="p_header">--- a/drivers/tty/vt/vt.c</span>
<span class="p_header">+++ b/drivers/tty/vt/vt.c</span>
<span class="p_chunk">@@ -863,10 +863,15 @@</span> <span class="p_context"> static int vc_do_resize(struct tty_struct *tty, struct vc_data *vc,</span>
 	if (new_cols == vc-&gt;vc_cols &amp;&amp; new_rows == vc-&gt;vc_rows)
 		return 0;
 
<span class="p_add">+	if (new_screen_size &gt; (4 &lt;&lt; 20))</span>
<span class="p_add">+		return -EINVAL;</span>
 	newscreen = kmalloc(new_screen_size, GFP_USER);
 	if (!newscreen)
 		return -ENOMEM;
 
<span class="p_add">+	if (vc == sel_cons)</span>
<span class="p_add">+		clear_selection();</span>
<span class="p_add">+</span>
 	old_rows = vc-&gt;vc_rows;
 	old_row_size = vc-&gt;vc_size_row;
 
<span class="p_chunk">@@ -1164,7 +1169,7 @@</span> <span class="p_context"> static void csi_J(struct vc_data *vc, int vpar)</span>
 			break;
 		case 3: /* erase scroll-back buffer (and whole display) */
 			scr_memsetw(vc-&gt;vc_screenbuf, vc-&gt;vc_video_erase_char,
<span class="p_del">-				    vc-&gt;vc_screenbuf_size &gt;&gt; 1);</span>
<span class="p_add">+				    vc-&gt;vc_screenbuf_size);</span>
 			set_origin(vc);
 			if (CON_IS_VISIBLE(vc))
 				update_screen(vc);
<span class="p_header">diff --git a/drivers/uio/uio_dmem_genirq.c b/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_header">index 8d0bba469566..7b0c19d4f9b1 100644</span>
<span class="p_header">--- a/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_header">+++ b/drivers/uio/uio_dmem_genirq.c</span>
<span class="p_chunk">@@ -229,7 +229,7 @@</span> <span class="p_context"> static int uio_dmem_genirq_probe(struct platform_device *pdev)</span>
 		++uiomem;
 	}
 
<span class="p_del">-	priv-&gt;dmem_region_start = i;</span>
<span class="p_add">+	priv-&gt;dmem_region_start = uiomem - &amp;uioinfo-&gt;mem[0];</span>
 	priv-&gt;num_dmem_regions = pdata-&gt;num_dynamic_regions;
 
 	for (i = 0; i &lt; pdata-&gt;num_dynamic_regions; ++i) {
<span class="p_header">diff --git a/drivers/usb/chipidea/core.c b/drivers/usb/chipidea/core.c</span>
<span class="p_header">index 4ecb6501a7ea..390d98a50d44 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/core.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/core.c</span>
<span class="p_chunk">@@ -584,6 +584,7 @@</span> <span class="p_context"> static int ci_hdrc_probe(struct platform_device *pdev)</span>
 		return -ENOMEM;
 	}
 
<span class="p_add">+	spin_lock_init(&amp;ci-&gt;lock);</span>
 	ci-&gt;dev = dev;
 	ci-&gt;platdata = dev_get_platdata(dev);
 	ci-&gt;imx28_write_fix = !!(ci-&gt;platdata-&gt;flags &amp;
<span class="p_header">diff --git a/drivers/usb/chipidea/udc.c b/drivers/usb/chipidea/udc.c</span>
<span class="p_header">index 8096116fc661..a887a874d6f3 100644</span>
<span class="p_header">--- a/drivers/usb/chipidea/udc.c</span>
<span class="p_header">+++ b/drivers/usb/chipidea/udc.c</span>
<span class="p_chunk">@@ -1798,8 +1798,6 @@</span> <span class="p_context"> static int udc_start(struct ci_hdrc *ci)</span>
 	struct device *dev = ci-&gt;dev;
 	int retval = 0;
 
<span class="p_del">-	spin_lock_init(&amp;ci-&gt;lock);</span>
<span class="p_del">-</span>
 	ci-&gt;gadget.ops          = &amp;usb_gadget_ops;
 	ci-&gt;gadget.speed        = USB_SPEED_UNKNOWN;
 	ci-&gt;gadget.max_speed    = USB_SPEED_HIGH;
<span class="p_header">diff --git a/drivers/usb/class/cdc-acm.c b/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">index 73b3b054771f..8c779ee044d8 100644</span>
<span class="p_header">--- a/drivers/usb/class/cdc-acm.c</span>
<span class="p_header">+++ b/drivers/usb/class/cdc-acm.c</span>
<span class="p_chunk">@@ -867,8 +867,6 @@</span> <span class="p_context"> static int wait_serial_change(struct acm *acm, unsigned long arg)</span>
 	DECLARE_WAITQUEUE(wait, current);
 	struct async_icount old, new;
 
<span class="p_del">-	if (arg &amp; (TIOCM_DSR | TIOCM_RI | TIOCM_CD ))</span>
<span class="p_del">-		return -EINVAL;</span>
 	do {
 		spin_lock_irq(&amp;acm-&gt;read_lock);
 		old = acm-&gt;oldcount;
<span class="p_header">diff --git a/drivers/usb/class/usbtmc.c b/drivers/usb/class/usbtmc.c</span>
<span class="p_header">index 103a6e9ee49d..4c6d63d4a9e8 100644</span>
<span class="p_header">--- a/drivers/usb/class/usbtmc.c</span>
<span class="p_header">+++ b/drivers/usb/class/usbtmc.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> static void usbtmc_delete(struct kref *kref)</span>
 	struct usbtmc_device_data *data = to_usbtmc_data(kref);
 
 	usb_put_dev(data-&gt;usb_dev);
<span class="p_add">+	kfree(data);</span>
 }
 
 static int usbtmc_open(struct inode *inode, struct file *filp)
<span class="p_chunk">@@ -1103,7 +1104,7 @@</span> <span class="p_context"> static int usbtmc_probe(struct usb_interface *intf,</span>
 
 	dev_dbg(&amp;intf-&gt;dev, &quot;%s called\n&quot;, __func__);
 
<span class="p_del">-	data = devm_kzalloc(&amp;intf-&gt;dev, sizeof(*data), GFP_KERNEL);</span>
<span class="p_add">+	data = kmalloc(sizeof(*data), GFP_KERNEL);</span>
 	if (!data) {
 		dev_err(&amp;intf-&gt;dev, &quot;Unable to allocate kernel memory\n&quot;);
 		return -ENOMEM;
<span class="p_header">diff --git a/drivers/usb/gadget/f_fs.c b/drivers/usb/gadget/f_fs.c</span>
<span class="p_header">index 4d6c0630f1f9..e8bfead449bb 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/f_fs.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/f_fs.c</span>
<span class="p_chunk">@@ -669,7 +669,6 @@</span> <span class="p_context"> static void ffs_user_copy_worker(struct work_struct *work)</span>
 
 	usb_ep_free_request(io_data-&gt;ep, io_data-&gt;req);
 
<span class="p_del">-	io_data-&gt;kiocb-&gt;private = NULL;</span>
 	if (io_data-&gt;read)
 		kfree(io_data-&gt;iovec);
 	kfree(io_data-&gt;buf);
<span class="p_header">diff --git a/drivers/usb/gadget/u_ether.c b/drivers/usb/gadget/u_ether.c</span>
<span class="p_header">index 97b027724ee7..c02d037cb16c 100644</span>
<span class="p_header">--- a/drivers/usb/gadget/u_ether.c</span>
<span class="p_header">+++ b/drivers/usb/gadget/u_ether.c</span>
<span class="p_chunk">@@ -583,13 +583,6 @@</span> <span class="p_context"> static netdev_tx_t eth_start_xmit(struct sk_buff *skb,</span>
 
 	req-&gt;length = length;
 
<span class="p_del">-	/* throttle high/super speed IRQ rate back slightly */</span>
<span class="p_del">-	if (gadget_is_dualspeed(dev-&gt;gadget))</span>
<span class="p_del">-		req-&gt;no_interrupt = (dev-&gt;gadget-&gt;speed == USB_SPEED_HIGH ||</span>
<span class="p_del">-				     dev-&gt;gadget-&gt;speed == USB_SPEED_SUPER)</span>
<span class="p_del">-			? ((atomic_read(&amp;dev-&gt;tx_qlen) % dev-&gt;qmult) != 0)</span>
<span class="p_del">-			: 0;</span>
<span class="p_del">-</span>
 	retval = usb_ep_queue(in, req, GFP_ATOMIC);
 	switch (retval) {
 	default:
<span class="p_header">diff --git a/drivers/usb/host/xhci-hub.c b/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">index 8ae80088d348..56188f231de0 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-hub.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-hub.c</span>
<span class="p_chunk">@@ -1222,6 +1222,35 @@</span> <span class="p_context"> int xhci_bus_suspend(struct usb_hcd *hcd)</span>
 	return 0;
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Workaround for missing Cold Attach Status (CAS) if device re-plugged in S3.</span>
<span class="p_add">+ * warm reset a USB3 device stuck in polling or compliance mode after resume.</span>
<span class="p_add">+ * See Intel 100/c230 series PCH specification update Doc #332692-006 Errata #8</span>
<span class="p_add">+ */</span>
<span class="p_add">+static bool xhci_port_missing_cas_quirk(int port_index,</span>
<span class="p_add">+					     __le32 __iomem **port_array)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 portsc;</span>
<span class="p_add">+</span>
<span class="p_add">+	portsc = readl(port_array[port_index]);</span>
<span class="p_add">+</span>
<span class="p_add">+	/* if any of these are set we are not stuck */</span>
<span class="p_add">+	if (portsc &amp; (PORT_CONNECT | PORT_CAS))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (((portsc &amp; PORT_PLS_MASK) != XDEV_POLLING) &amp;&amp;</span>
<span class="p_add">+	    ((portsc &amp; PORT_PLS_MASK) != XDEV_COMP_MODE))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* clear wakeup/change bits, and do a warm port reset */</span>
<span class="p_add">+	portsc &amp;= ~(PORT_RWC_BITS | PORT_CEC | PORT_WAKE_BITS);</span>
<span class="p_add">+	portsc |= PORT_WR;</span>
<span class="p_add">+	writel(portsc, port_array[port_index]);</span>
<span class="p_add">+	/* flush write */</span>
<span class="p_add">+	readl(port_array[port_index]);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 int xhci_bus_resume(struct usb_hcd *hcd)
 {
 	struct xhci_hcd	*xhci = hcd_to_xhci(hcd);
<span class="p_chunk">@@ -1256,6 +1285,14 @@</span> <span class="p_context"> int xhci_bus_resume(struct usb_hcd *hcd)</span>
 		int slot_id;
 
 		temp = readl(port_array[port_index]);
<span class="p_add">+</span>
<span class="p_add">+		/* warm reset CAS limited ports stuck in polling/compliance */</span>
<span class="p_add">+		if ((xhci-&gt;quirks &amp; XHCI_MISSING_CAS) &amp;&amp;</span>
<span class="p_add">+		    (hcd-&gt;speed &gt;= HCD_USB3) &amp;&amp;</span>
<span class="p_add">+		    xhci_port_missing_cas_quirk(port_index, port_array)) {</span>
<span class="p_add">+			xhci_dbg(xhci, &quot;reset stuck port %d\n&quot;, port_index);</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		}</span>
 		if (DEV_SUPERSPEED(temp))
 			temp &amp;= ~(PORT_RWC_BITS | PORT_CEC | PORT_WAKE_BITS);
 		else
<span class="p_header">diff --git a/drivers/usb/host/xhci-pci.c b/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">index 015d4c08a3cb..e808d8078b2d 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci-pci.c</span>
<span class="p_header">+++ b/drivers/usb/host/xhci-pci.c</span>
<span class="p_chunk">@@ -38,11 +38,13 @@</span> <span class="p_context"></span>
 
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_XHCI	0x8c31
 #define PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI	0x9c31
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI	0x9cb1</span>
 #define PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI		0x22b5
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_H_XHCI		0xa12f
 #define PCI_DEVICE_ID_INTEL_SUNRISEPOINT_LP_XHCI	0x9d2f
 #define PCI_DEVICE_ID_INTEL_BROXTON_M_XHCI		0x0aa8
 #define PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI		0x1aa8
<span class="p_add">+#define PCI_DEVICE_ID_INTEL_APL_XHCI			0x5aa8</span>
 
 static const char hcd_name[] = &quot;xhci_hcd&quot;;
 
<span class="p_chunk">@@ -138,7 +140,8 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
 	}
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;
<span class="p_del">-		pdev-&gt;device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI) {</span>
<span class="p_add">+		(pdev-&gt;device == PCI_DEVICE_ID_INTEL_LYNXPOINT_LP_XHCI ||</span>
<span class="p_add">+		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_WILDCATPOINT_LP_XHCI)) {</span>
 		xhci-&gt;quirks |= XHCI_SPURIOUS_REBOOT;
 		xhci-&gt;quirks |= XHCI_SPURIOUS_WAKEUP;
 	}
<span class="p_chunk">@@ -150,6 +153,11 @@</span> <span class="p_context"> static void xhci_pci_quirks(struct device *dev, struct xhci_hcd *xhci)</span>
 		 pdev-&gt;device == PCI_DEVICE_ID_INTEL_BROXTON_B_XHCI)) {
 		xhci-&gt;quirks |= XHCI_PME_STUCK_QUIRK;
 	}
<span class="p_add">+	if (pdev-&gt;vendor == PCI_VENDOR_ID_INTEL &amp;&amp;</span>
<span class="p_add">+	    (pdev-&gt;device == PCI_DEVICE_ID_INTEL_CHERRYVIEW_XHCI ||</span>
<span class="p_add">+	     pdev-&gt;device == PCI_DEVICE_ID_INTEL_APL_XHCI))</span>
<span class="p_add">+		xhci-&gt;quirks |= XHCI_MISSING_CAS;</span>
<span class="p_add">+</span>
 	if (pdev-&gt;vendor == PCI_VENDOR_ID_ETRON &amp;&amp;
 			pdev-&gt;device == PCI_DEVICE_ID_ASROCK_P67) {
 		xhci-&gt;quirks |= XHCI_RESET_ON_RESUME;
<span class="p_header">diff --git a/drivers/usb/host/xhci.h b/drivers/usb/host/xhci.h</span>
<span class="p_header">index 92cd5a765602..f117bacec41c 100644</span>
<span class="p_header">--- a/drivers/usb/host/xhci.h</span>
<span class="p_header">+++ b/drivers/usb/host/xhci.h</span>
<span class="p_chunk">@@ -286,6 +286,8 @@</span> <span class="p_context"> struct xhci_op_regs {</span>
 #define XDEV_U2		(0x2 &lt;&lt; 5)
 #define XDEV_U3		(0x3 &lt;&lt; 5)
 #define XDEV_INACTIVE	(0x6 &lt;&lt; 5)
<span class="p_add">+#define XDEV_POLLING	(0x7 &lt;&lt; 5)</span>
<span class="p_add">+#define XDEV_COMP_MODE  (0xa &lt;&lt; 5)</span>
 #define XDEV_RESUME	(0xf &lt;&lt; 5)
 /* true: port has power (see HCC_PPC) */
 #define PORT_POWER	(1 &lt;&lt; 9)
<span class="p_chunk">@@ -1566,6 +1568,7 @@</span> <span class="p_context"> struct xhci_hcd {</span>
 /* For controllers with a broken beyond repair streams implementation */
 #define XHCI_BROKEN_STREAMS	(1 &lt;&lt; 19)
 #define XHCI_PME_STUCK_QUIRK	(1 &lt;&lt; 20)
<span class="p_add">+#define XHCI_MISSING_CAS	(1 &lt;&lt; 24)</span>
 	unsigned int		num_active_eps;
 	unsigned int		limit_active_eps;
 	/* There are two roothubs to keep track of bus suspend info for */
<span class="p_header">diff --git a/drivers/usb/misc/legousbtower.c b/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">index 97cd9e24bd25..042a1ad9698a 100644</span>
<span class="p_header">--- a/drivers/usb/misc/legousbtower.c</span>
<span class="p_header">+++ b/drivers/usb/misc/legousbtower.c</span>
<span class="p_chunk">@@ -898,24 +898,6 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 	dev-&gt;interrupt_in_interval = interrupt_in_interval ? interrupt_in_interval : dev-&gt;interrupt_in_endpoint-&gt;bInterval;
 	dev-&gt;interrupt_out_interval = interrupt_out_interval ? interrupt_out_interval : dev-&gt;interrupt_out_endpoint-&gt;bInterval;
 
<span class="p_del">-	/* we can register the device now, as it is ready */</span>
<span class="p_del">-	usb_set_intfdata (interface, dev);</span>
<span class="p_del">-</span>
<span class="p_del">-	retval = usb_register_dev (interface, &amp;tower_class);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (retval) {</span>
<span class="p_del">-		/* something prevented us from registering this driver */</span>
<span class="p_del">-		dev_err(idev, &quot;Not able to get a minor for this device.\n&quot;);</span>
<span class="p_del">-		usb_set_intfdata (interface, NULL);</span>
<span class="p_del">-		goto error;</span>
<span class="p_del">-	}</span>
<span class="p_del">-	dev-&gt;minor = interface-&gt;minor;</span>
<span class="p_del">-</span>
<span class="p_del">-	/* let the user know what node this device is now attached to */</span>
<span class="p_del">-	dev_info(&amp;interface-&gt;dev, &quot;LEGO USB Tower #%d now attached to major &quot;</span>
<span class="p_del">-		 &quot;%d minor %d\n&quot;, (dev-&gt;minor - LEGO_USB_TOWER_MINOR_BASE),</span>
<span class="p_del">-		 USB_MAJOR, dev-&gt;minor);</span>
<span class="p_del">-</span>
 	/* get the firmware version and log it */
 	result = usb_control_msg (udev,
 				  usb_rcvctrlpipe(udev, 0),
<span class="p_chunk">@@ -936,6 +918,23 @@</span> <span class="p_context"> static int tower_probe (struct usb_interface *interface, const struct usb_device</span>
 		 get_version_reply.minor,
 		 le16_to_cpu(get_version_reply.build_no));
 
<span class="p_add">+	/* we can register the device now, as it is ready */</span>
<span class="p_add">+	usb_set_intfdata (interface, dev);</span>
<span class="p_add">+</span>
<span class="p_add">+	retval = usb_register_dev (interface, &amp;tower_class);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (retval) {</span>
<span class="p_add">+		/* something prevented us from registering this driver */</span>
<span class="p_add">+		dev_err(idev, &quot;Not able to get a minor for this device.\n&quot;);</span>
<span class="p_add">+		usb_set_intfdata (interface, NULL);</span>
<span class="p_add">+		goto error;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	dev-&gt;minor = interface-&gt;minor;</span>
<span class="p_add">+</span>
<span class="p_add">+	/* let the user know what node this device is now attached to */</span>
<span class="p_add">+	dev_info(&amp;interface-&gt;dev, &quot;LEGO USB Tower #%d now attached to major &quot;</span>
<span class="p_add">+		 &quot;%d minor %d\n&quot;, (dev-&gt;minor - LEGO_USB_TOWER_MINOR_BASE),</span>
<span class="p_add">+		 USB_MAJOR, dev-&gt;minor);</span>
 
 exit:
 	return retval;
<span class="p_header">diff --git a/drivers/usb/serial/cp210x.c b/drivers/usb/serial/cp210x.c</span>
<span class="p_header">index 16f1b199d46b..5c4ef5a964cc 100644</span>
<span class="p_header">--- a/drivers/usb/serial/cp210x.c</span>
<span class="p_header">+++ b/drivers/usb/serial/cp210x.c</span>
<span class="p_chunk">@@ -117,6 +117,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x8411) }, /* Kyocera GPS Module */
 	{ USB_DEVICE(0x10C4, 0x8418) }, /* IRZ Automation Teleport SG-10 GSM/GPRS Modem */
 	{ USB_DEVICE(0x10C4, 0x846E) }, /* BEI USB Sensor Interface (VCP) */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8470) }, /* Juniper Networks BX Series System Console */</span>
 	{ USB_DEVICE(0x10C4, 0x8477) }, /* Balluff RFID */
 	{ USB_DEVICE(0x10C4, 0x84B6) }, /* Starizona Hyperion */
 	{ USB_DEVICE(0x10C4, 0x85EA) }, /* AC-Services IBUS-IF */
<span class="p_chunk">@@ -129,6 +130,7 @@</span> <span class="p_context"> static const struct usb_device_id id_table[] = {</span>
 	{ USB_DEVICE(0x10C4, 0x88A4) }, /* MMB Networks ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x88A5) }, /* Planet Innovation Ingeni ZigBee USB Device */
 	{ USB_DEVICE(0x10C4, 0x8946) }, /* Ketra N1 Wireless Interface */
<span class="p_add">+	{ USB_DEVICE(0x10C4, 0x8962) }, /* Brim Brothers charging dock */</span>
 	{ USB_DEVICE(0x10C4, 0x8977) },	/* CEL MeshWorks DevKit Device */
 	{ USB_DEVICE(0x10C4, 0x8998) }, /* KCF Technologies PRN */
 	{ USB_DEVICE(0x10C4, 0x8A2A) }, /* HubZ dual ZigBee and Z-Wave dongle */
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio.c b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">index 6103727cd060..99db89ad482e 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio.c</span>
<span class="p_chunk">@@ -999,7 +999,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	/* ekey Devices */
 	{ USB_DEVICE(FTDI_VID, FTDI_EKEY_CONV_USB_PID) },
 	/* Infineon Devices */
<span class="p_del">-	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_PID, 1) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC1798_PID, 1) },</span>
<span class="p_add">+	{ USB_DEVICE_INTERFACE_NUMBER(INFINEON_VID, INFINEON_TRIBOARD_TC2X7_PID, 1) },</span>
 	/* GE Healthcare devices */
 	{ USB_DEVICE(GE_HEALTHCARE_VID, GE_HEALTHCARE_NEMO_TRACKER_PID) },
 	/* Active Research (Actisense) devices */
<span class="p_chunk">@@ -1024,6 +1025,8 @@</span> <span class="p_context"> static const struct usb_device_id id_table_combined[] = {</span>
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7561U_PID) },
 	{ USB_DEVICE(ICPDAS_VID, ICPDAS_I7563U_PID) },
 	{ USB_DEVICE(WICED_VID, WICED_USB20706V2_PID) },
<span class="p_add">+	{ USB_DEVICE(TI_VID, TI_CC3200_LAUNCHPAD_PID),</span>
<span class="p_add">+		.driver_info = (kernel_ulong_t)&amp;ftdi_jtag_quirk },</span>
 	{ }					/* Terminating entry */
 };
 
<span class="p_header">diff --git a/drivers/usb/serial/ftdi_sio_ids.h b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">index 48db84f25cc9..7b2f2056b7ef 100644</span>
<span class="p_header">--- a/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_header">+++ b/drivers/usb/serial/ftdi_sio_ids.h</span>
<span class="p_chunk">@@ -596,6 +596,12 @@</span> <span class="p_context"></span>
 #define STK541_PID		0x2109 /* Zigbee Controller */
 
 /*
<span class="p_add">+ * Texas Instruments</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define TI_VID			0x0451</span>
<span class="p_add">+#define TI_CC3200_LAUNCHPAD_PID	0xC32A /* SimpleLink Wi-Fi CC3200 LaunchPad */</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * Blackfin gnICE JTAG
  * http://docs.blackfin.uclinux.org/doku.php?id=hw:jtag:gnice
  */
<span class="p_chunk">@@ -626,8 +632,9 @@</span> <span class="p_context"></span>
 /*
  * Infineon Technologies
  */
<span class="p_del">-#define INFINEON_VID		0x058b</span>
<span class="p_del">-#define INFINEON_TRIBOARD_PID	0x0028 /* DAS JTAG TriBoard TC1798 V1.0 */</span>
<span class="p_add">+#define INFINEON_VID		        0x058b</span>
<span class="p_add">+#define INFINEON_TRIBOARD_TC1798_PID	0x0028 /* DAS JTAG TriBoard TC1798 V1.0 */</span>
<span class="p_add">+#define INFINEON_TRIBOARD_TC2X7_PID	0x0043 /* DAS JTAG TriBoard TC2X7 V1.0 */</span>
 
 /*
  * Acton Research Corp.
<span class="p_header">diff --git a/drivers/usb/serial/usb-serial.c b/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">index d3bf8348e638..a290891ddd84 100644</span>
<span class="p_header">--- a/drivers/usb/serial/usb-serial.c</span>
<span class="p_header">+++ b/drivers/usb/serial/usb-serial.c</span>
<span class="p_chunk">@@ -1061,7 +1061,8 @@</span> <span class="p_context"> static int usb_serial_probe(struct usb_interface *interface,</span>
 
 	serial-&gt;disconnected = 0;
 
<span class="p_del">-	usb_serial_console_init(serial-&gt;port[0]-&gt;minor);</span>
<span class="p_add">+	if (num_ports &gt; 0)</span>
<span class="p_add">+		usb_serial_console_init(serial-&gt;port[0]-&gt;minor);</span>
 exit:
 	module_put(type-&gt;driver.owner);
 	return 0;
<span class="p_header">diff --git a/drivers/usb/storage/transport.c b/drivers/usb/storage/transport.c</span>
<span class="p_header">index b1d815eb6d0b..8988b268a69a 100644</span>
<span class="p_header">--- a/drivers/usb/storage/transport.c</span>
<span class="p_header">+++ b/drivers/usb/storage/transport.c</span>
<span class="p_chunk">@@ -919,10 +919,15 @@</span> <span class="p_context"> int usb_stor_CB_transport(struct scsi_cmnd *srb, struct us_data *us)</span>
 
 	/* COMMAND STAGE */
 	/* let&#39;s send the command via the control pipe */
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Command is sometime (f.e. after scsi_eh_prep_cmnd) on the stack.</span>
<span class="p_add">+	 * Stack may be vmallocated.  So no DMA for us.  Make a copy.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	memcpy(us-&gt;iobuf, srb-&gt;cmnd, srb-&gt;cmd_len);</span>
 	result = usb_stor_ctrl_transfer(us, us-&gt;send_ctrl_pipe,
 				      US_CBI_ADSC, 
 				      USB_TYPE_CLASS | USB_RECIP_INTERFACE, 0, 
<span class="p_del">-				      us-&gt;ifnum, srb-&gt;cmnd, srb-&gt;cmd_len);</span>
<span class="p_add">+				      us-&gt;ifnum, us-&gt;iobuf, srb-&gt;cmd_len);</span>
 
 	/* check the return code for the command */
 	usb_stor_dbg(us, &quot;Call to usb_stor_ctrl_transfer() returned %d\n&quot;,
<span class="p_header">diff --git a/drivers/uwb/lc-rc.c b/drivers/uwb/lc-rc.c</span>
<span class="p_header">index 3eca6ceb9844..4be2a5d1a9d2 100644</span>
<span class="p_header">--- a/drivers/uwb/lc-rc.c</span>
<span class="p_header">+++ b/drivers/uwb/lc-rc.c</span>
<span class="p_chunk">@@ -56,8 +56,11 @@</span> <span class="p_context"> static struct uwb_rc *uwb_rc_find_by_index(int index)</span>
 	struct uwb_rc *rc = NULL;
 
 	dev = class_find_device(&amp;uwb_rc_class, NULL, &amp;index, uwb_rc_index_match);
<span class="p_del">-	if (dev)</span>
<span class="p_add">+	if (dev) {</span>
 		rc = dev_get_drvdata(dev);
<span class="p_add">+		put_device(dev);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -368,7 +371,9 @@</span> <span class="p_context"> struct uwb_rc *__uwb_rc_try_get(struct uwb_rc *target_rc)</span>
 	if (dev) {
 		rc = dev_get_drvdata(dev);
 		__uwb_rc_get(rc);
<span class="p_add">+		put_device(dev);</span>
 	}
<span class="p_add">+</span>
 	return rc;
 }
 EXPORT_SYMBOL_GPL(__uwb_rc_try_get);
<span class="p_chunk">@@ -421,8 +426,11 @@</span> <span class="p_context"> struct uwb_rc *uwb_rc_get_by_grandpa(const struct device *grandpa_dev)</span>
 
 	dev = class_find_device(&amp;uwb_rc_class, NULL, grandpa_dev,
 				find_rc_grandpa);
<span class="p_del">-	if (dev)</span>
<span class="p_add">+	if (dev) {</span>
 		rc = dev_get_drvdata(dev);
<span class="p_add">+		put_device(dev);</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	return rc;
 }
 EXPORT_SYMBOL_GPL(uwb_rc_get_by_grandpa);
<span class="p_chunk">@@ -454,8 +462,10 @@</span> <span class="p_context"> struct uwb_rc *uwb_rc_get_by_dev(const struct uwb_dev_addr *addr)</span>
 	struct uwb_rc *rc = NULL;
 
 	dev = class_find_device(&amp;uwb_rc_class, NULL, addr, find_rc_dev);
<span class="p_del">-	if (dev)</span>
<span class="p_add">+	if (dev) {</span>
 		rc = dev_get_drvdata(dev);
<span class="p_add">+		put_device(dev);</span>
<span class="p_add">+	}</span>
 
 	return rc;
 }
<span class="p_header">diff --git a/drivers/uwb/pal.c b/drivers/uwb/pal.c</span>
<span class="p_header">index c1304b8d4985..678e93741ae1 100644</span>
<span class="p_header">--- a/drivers/uwb/pal.c</span>
<span class="p_header">+++ b/drivers/uwb/pal.c</span>
<span class="p_chunk">@@ -97,6 +97,8 @@</span> <span class="p_context"> static bool uwb_rc_class_device_exists(struct uwb_rc *target_rc)</span>
 
 	dev = class_find_device(&amp;uwb_rc_class, NULL, target_rc,	find_rc);
 
<span class="p_add">+	put_device(dev);</span>
<span class="p_add">+</span>
 	return (dev != NULL);
 }
 
<span class="p_header">diff --git a/drivers/video/fbdev/core/fbcmap.c b/drivers/video/fbdev/core/fbcmap.c</span>
<span class="p_header">index f89245b8ba8e..68a113594808 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/core/fbcmap.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/core/fbcmap.c</span>
<span class="p_chunk">@@ -163,17 +163,18 @@</span> <span class="p_context"> void fb_dealloc_cmap(struct fb_cmap *cmap)</span>
 
 int fb_copy_cmap(const struct fb_cmap *from, struct fb_cmap *to)
 {
<span class="p_del">-	int tooff = 0, fromoff = 0;</span>
<span class="p_del">-	int size;</span>
<span class="p_add">+	unsigned int tooff = 0, fromoff = 0;</span>
<span class="p_add">+	size_t size;</span>
 
 	if (to-&gt;start &gt; from-&gt;start)
 		fromoff = to-&gt;start - from-&gt;start;
 	else
 		tooff = from-&gt;start - to-&gt;start;
<span class="p_del">-	size = to-&gt;len - tooff;</span>
<span class="p_del">-	if (size &gt; (int) (from-&gt;len - fromoff))</span>
<span class="p_del">-		size = from-&gt;len - fromoff;</span>
<span class="p_del">-	if (size &lt;= 0)</span>
<span class="p_add">+	if (fromoff &gt;= from-&gt;len || tooff &gt;= to-&gt;len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = min_t(size_t, to-&gt;len - tooff, from-&gt;len - fromoff);</span>
<span class="p_add">+	if (size == 0)</span>
 		return -EINVAL;
 	size *= sizeof(u16);
 
<span class="p_chunk">@@ -187,17 +188,18 @@</span> <span class="p_context"> int fb_copy_cmap(const struct fb_cmap *from, struct fb_cmap *to)</span>
 
 int fb_cmap_to_user(const struct fb_cmap *from, struct fb_cmap_user *to)
 {
<span class="p_del">-	int tooff = 0, fromoff = 0;</span>
<span class="p_del">-	int size;</span>
<span class="p_add">+	unsigned int tooff = 0, fromoff = 0;</span>
<span class="p_add">+	size_t size;</span>
 
 	if (to-&gt;start &gt; from-&gt;start)
 		fromoff = to-&gt;start - from-&gt;start;
 	else
 		tooff = from-&gt;start - to-&gt;start;
<span class="p_del">-	size = to-&gt;len - tooff;</span>
<span class="p_del">-	if (size &gt; (int) (from-&gt;len - fromoff))</span>
<span class="p_del">-		size = from-&gt;len - fromoff;</span>
<span class="p_del">-	if (size &lt;= 0)</span>
<span class="p_add">+	if (fromoff &gt;= from-&gt;len || tooff &gt;= to-&gt;len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
<span class="p_add">+	size = min_t(size_t, to-&gt;len - tooff, from-&gt;len - fromoff);</span>
<span class="p_add">+	if (size == 0)</span>
 		return -EINVAL;
 	size *= sizeof(u16);
 
<span class="p_header">diff --git a/drivers/video/fbdev/efifb.c b/drivers/video/fbdev/efifb.c</span>
<span class="p_header">index 982f6abe6faf..d0f9710b9c0b 100644</span>
<span class="p_header">--- a/drivers/video/fbdev/efifb.c</span>
<span class="p_header">+++ b/drivers/video/fbdev/efifb.c</span>
<span class="p_chunk">@@ -52,9 +52,9 @@</span> <span class="p_context"> static int efifb_setcolreg(unsigned regno, unsigned red, unsigned green,</span>
 		return 1;
 
 	if (regno &lt; 16) {
<span class="p_del">-		red   &gt;&gt;= 8;</span>
<span class="p_del">-		green &gt;&gt;= 8;</span>
<span class="p_del">-		blue  &gt;&gt;= 8;</span>
<span class="p_add">+		red   &gt;&gt;= 16 - info-&gt;var.red.length;</span>
<span class="p_add">+		green &gt;&gt;= 16 - info-&gt;var.green.length;</span>
<span class="p_add">+		blue  &gt;&gt;= 16 - info-&gt;var.blue.length;</span>
 		((u32 *)(info-&gt;pseudo_palette))[regno] =
 			(red   &lt;&lt; info-&gt;var.red.offset)   |
 			(green &lt;&lt; info-&gt;var.green.offset) |
<span class="p_header">diff --git a/fs/btrfs/tree-log.c b/fs/btrfs/tree-log.c</span>
<span class="p_header">index 830952d045c9..023c5d905aac 100644</span>
<span class="p_header">--- a/fs/btrfs/tree-log.c</span>
<span class="p_header">+++ b/fs/btrfs/tree-log.c</span>
<span class="p_chunk">@@ -2449,14 +2449,12 @@</span> <span class="p_context"> static inline void btrfs_remove_all_log_ctxs(struct btrfs_root *root,</span>
 					     int index, int error)
 {
 	struct btrfs_log_ctx *ctx;
<span class="p_add">+	struct btrfs_log_ctx *safe;</span>
 
<span class="p_del">-	if (!error) {</span>
<span class="p_del">-		INIT_LIST_HEAD(&amp;root-&gt;log_ctxs[index]);</span>
<span class="p_del">-		return;</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(ctx, &amp;root-&gt;log_ctxs[index], list)</span>
<span class="p_add">+	list_for_each_entry_safe(ctx, safe, &amp;root-&gt;log_ctxs[index], list) {</span>
<span class="p_add">+		list_del_init(&amp;ctx-&gt;list);</span>
 		ctx-&gt;log_ret = error;
<span class="p_add">+	}</span>
 
 	INIT_LIST_HEAD(&amp;root-&gt;log_ctxs[index]);
 }
<span class="p_chunk">@@ -2686,13 +2684,9 @@</span> <span class="p_context"> int btrfs_sync_log(struct btrfs_trans_handle *trans,</span>
 	mutex_unlock(&amp;root-&gt;log_mutex);
 
 out_wake_log_root:
<span class="p_del">-	/*</span>
<span class="p_del">-	 * We needn&#39;t get log_mutex here because we are sure all</span>
<span class="p_del">-	 * the other tasks are blocked.</span>
<span class="p_del">-	 */</span>
<span class="p_add">+	mutex_lock(&amp;log_root_tree-&gt;log_mutex);</span>
 	btrfs_remove_all_log_ctxs(log_root_tree, index2, ret);
 
<span class="p_del">-	mutex_lock(&amp;log_root_tree-&gt;log_mutex);</span>
 	log_root_tree-&gt;log_transid_committed++;
 	atomic_set(&amp;log_root_tree-&gt;log_commit[index2], 0);
 	mutex_unlock(&amp;log_root_tree-&gt;log_mutex);
<span class="p_chunk">@@ -2700,10 +2694,8 @@</span> <span class="p_context"> out_wake_log_root:</span>
 	if (waitqueue_active(&amp;log_root_tree-&gt;log_commit_wait[index2]))
 		wake_up(&amp;log_root_tree-&gt;log_commit_wait[index2]);
 out:
<span class="p_del">-	/* See above. */</span>
<span class="p_del">-	btrfs_remove_all_log_ctxs(root, index1, ret);</span>
<span class="p_del">-</span>
 	mutex_lock(&amp;root-&gt;log_mutex);
<span class="p_add">+	btrfs_remove_all_log_ctxs(root, index1, ret);</span>
 	root-&gt;log_transid_committed++;
 	atomic_set(&amp;root-&gt;log_commit[index1], 0);
 	mutex_unlock(&amp;root-&gt;log_mutex);
<span class="p_header">diff --git a/fs/cifs/cifs_debug.c b/fs/cifs/cifs_debug.c</span>
<span class="p_header">index a7e223bbf8df..ab4f1ce11ed0 100644</span>
<span class="p_header">--- a/fs/cifs/cifs_debug.c</span>
<span class="p_header">+++ b/fs/cifs/cifs_debug.c</span>
<span class="p_chunk">@@ -170,6 +170,7 @@</span> <span class="p_context"> static int cifs_debug_data_proc_show(struct seq_file *m, void *v)</span>
 	list_for_each(tmp1, &amp;cifs_tcp_ses_list) {
 		server = list_entry(tmp1, struct TCP_Server_Info,
 				    tcp_ses_list);
<span class="p_add">+		seq_printf(m, &quot;\nNumber of credits: %d&quot;, server-&gt;credits);</span>
 		i++;
 		list_for_each(tmp2, &amp;server-&gt;smb_ses_list) {
 			ses = list_entry(tmp2, struct cifs_ses,
<span class="p_header">diff --git a/fs/cifs/cifsfs.c b/fs/cifs/cifsfs.c</span>
<span class="p_header">index 445e1b01191a..a219cf00c2f0 100644</span>
<span class="p_header">--- a/fs/cifs/cifsfs.c</span>
<span class="p_header">+++ b/fs/cifs/cifsfs.c</span>
<span class="p_chunk">@@ -256,7 +256,7 @@</span> <span class="p_context"> cifs_alloc_inode(struct super_block *sb)</span>
 	cifs_inode-&gt;createtime = 0;
 	cifs_inode-&gt;epoch = 0;
 #ifdef CONFIG_CIFS_SMB2
<span class="p_del">-	get_random_bytes(cifs_inode-&gt;lease_key, SMB2_LEASE_KEY_SIZE);</span>
<span class="p_add">+	generate_random_uuid(cifs_inode-&gt;lease_key);</span>
 #endif
 	/*
 	 * Can not set i_flags here - they get immediately overwritten to zero
<span class="p_chunk">@@ -1193,7 +1193,6 @@</span> <span class="p_context"> init_cifs(void)</span>
 	GlobalTotalActiveXid = 0;
 	GlobalMaxActiveXid = 0;
 	spin_lock_init(&amp;cifs_tcp_ses_lock);
<span class="p_del">-	spin_lock_init(&amp;cifs_file_list_lock);</span>
 	spin_lock_init(&amp;GlobalMid_Lock);
 
 	if (cifs_max_pending &lt; 2) {
<span class="p_header">diff --git a/fs/cifs/cifsglob.h b/fs/cifs/cifsglob.h</span>
<span class="p_header">index c97fd86cfb1b..1c663a16f78a 100644</span>
<span class="p_header">--- a/fs/cifs/cifsglob.h</span>
<span class="p_header">+++ b/fs/cifs/cifsglob.h</span>
<span class="p_chunk">@@ -796,6 +796,7 @@</span> <span class="p_context"> struct cifs_tcon {</span>
 	struct list_head tcon_list;
 	int tc_count;
 	struct list_head openFileList;
<span class="p_add">+	spinlock_t open_file_lock; /* protects list above */</span>
 	struct cifs_ses *ses;	/* pointer to session associated with */
 	char treeName[MAX_TREE_SIZE + 1]; /* UNC name of resource in ASCII */
 	char *nativeFileSystem;
<span class="p_chunk">@@ -852,7 +853,7 @@</span> <span class="p_context"> struct cifs_tcon {</span>
 #endif /* CONFIG_CIFS_STATS2 */
 	__u64    bytes_read;
 	__u64    bytes_written;
<span class="p_del">-	spinlock_t stat_lock;</span>
<span class="p_add">+	spinlock_t stat_lock;  /* protects the two fields above */</span>
 #endif /* CONFIG_CIFS_STATS */
 	FILE_SYSTEM_DEVICE_INFO fsDevInfo;
 	FILE_SYSTEM_ATTRIBUTE_INFO fsAttrInfo; /* ok if fs name truncated */
<span class="p_chunk">@@ -999,8 +1000,10 @@</span> <span class="p_context"> struct cifs_fid_locks {</span>
 };
 
 struct cifsFileInfo {
<span class="p_add">+	/* following two lists are protected by tcon-&gt;open_file_lock */</span>
 	struct list_head tlist;	/* pointer to next fid owned by tcon */
 	struct list_head flist;	/* next fid (file instance) for this inode */
<span class="p_add">+	/* lock list below protected by cifsi-&gt;lock_sem */</span>
 	struct cifs_fid_locks *llist;	/* brlocks held by this fid */
 	kuid_t uid;		/* allows finding which FileInfo structure */
 	__u32 pid;		/* process id who opened file */
<span class="p_chunk">@@ -1008,11 +1011,12 @@</span> <span class="p_context"> struct cifsFileInfo {</span>
 	/* BB add lock scope info here if needed */ ;
 	/* lock scope id (0 if none) */
 	struct dentry *dentry;
<span class="p_del">-	unsigned int f_flags;</span>
 	struct tcon_link *tlink;
<span class="p_add">+	unsigned int f_flags;</span>
 	bool invalidHandle:1;	/* file closed via session abend */
 	bool oplock_break_cancelled:1;
<span class="p_del">-	int count;		/* refcount protected by cifs_file_list_lock */</span>
<span class="p_add">+	int count;</span>
<span class="p_add">+	spinlock_t file_info_lock; /* protects four flag/count fields above */</span>
 	struct mutex fh_mutex; /* prevents reopen race after dead ses*/
 	struct cifs_search_info srch_inf;
 	struct work_struct oplock_break; /* work for oplock breaks */
<span class="p_chunk">@@ -1076,7 +1080,7 @@</span> <span class="p_context"> struct cifs_writedata {</span>
 
 /*
  * Take a reference on the file private data. Must be called with
<span class="p_del">- * cifs_file_list_lock held.</span>
<span class="p_add">+ * cfile-&gt;file_info_lock held.</span>
  */
 static inline void
 cifsFileInfo_get_locked(struct cifsFileInfo *cifs_file)
<span class="p_chunk">@@ -1463,8 +1467,10 @@</span> <span class="p_context"> require use of the stronger protocol */</span>
  *  GlobalMid_Lock protects:
  *	list operations on pending_mid_q and oplockQ
  *      updates to XID counters, multiplex id  and SMB sequence numbers
<span class="p_del">- *  cifs_file_list_lock protects:</span>
<span class="p_del">- *	list operations on tcp and SMB session lists and tCon lists</span>
<span class="p_add">+ *  tcp_ses_lock protects:</span>
<span class="p_add">+ *	list operations on tcp and SMB session lists</span>
<span class="p_add">+ *  tcon-&gt;open_file_lock protects the list of open files hanging off the tcon</span>
<span class="p_add">+ *  cfile-&gt;file_info_lock protects counters and fields in cifs file struct</span>
  *  f_owner.lock protects certain per file struct operations
  *  mapping-&gt;page_lock protects certain per page operations
  *
<span class="p_chunk">@@ -1496,18 +1502,12 @@</span> <span class="p_context"> GLOBAL_EXTERN struct list_head		cifs_tcp_ses_list;</span>
  * tcp session, and the list of tcon&#39;s per smb session. It also protects
  * the reference counters for the server, smb session, and tcon. Finally,
  * changes to the tcon-&gt;tidStatus should be done while holding this lock.
<span class="p_add">+ * generally the locks should be taken in order tcp_ses_lock before</span>
<span class="p_add">+ * tcon-&gt;open_file_lock and that before file-&gt;file_info_lock since the</span>
<span class="p_add">+ * structure order is cifs_socket--&gt;cifs_ses--&gt;cifs_tcon--&gt;cifs_file</span>
  */
 GLOBAL_EXTERN spinlock_t		cifs_tcp_ses_lock;
 
<span class="p_del">-/*</span>
<span class="p_del">- * This lock protects the cifs_file-&gt;llist and cifs_file-&gt;flist</span>
<span class="p_del">- * list operations, and updates to some flags (cifs_file-&gt;invalidHandle)</span>
<span class="p_del">- * It will be moved to either use the tcon-&gt;stat_lock or equivalent later.</span>
<span class="p_del">- * If cifs_tcp_ses_lock and the lock below are both needed to be held, then</span>
<span class="p_del">- * the cifs_tcp_ses_lock must be grabbed first and released last.</span>
<span class="p_del">- */</span>
<span class="p_del">-GLOBAL_EXTERN spinlock_t	cifs_file_list_lock;</span>
<span class="p_del">-</span>
 #ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL /* unused temporarily */
 /* Outstanding dir notify requests */
 GLOBAL_EXTERN struct list_head GlobalDnotifyReqList;
<span class="p_header">diff --git a/fs/cifs/cifssmb.c b/fs/cifs/cifssmb.c</span>
<span class="p_header">index 2df1390e5d66..1c2981fda63d 100644</span>
<span class="p_header">--- a/fs/cifs/cifssmb.c</span>
<span class="p_header">+++ b/fs/cifs/cifssmb.c</span>
<span class="p_chunk">@@ -98,13 +98,13 @@</span> <span class="p_context"> cifs_mark_open_files_invalid(struct cifs_tcon *tcon)</span>
 	struct list_head *tmp1;
 
 	/* list all files open on tree connection and mark them invalid */
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	list_for_each_safe(tmp, tmp1, &amp;tcon-&gt;openFileList) {
 		open_file = list_entry(tmp, struct cifsFileInfo, tlist);
 		open_file-&gt;invalidHandle = true;
 		open_file-&gt;oplock_break_cancelled = true;
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	/*
 	 * BB Add call to invalidate_inodes(sb) for all superblocks mounted
 	 * to this tcon.
<span class="p_header">diff --git a/fs/cifs/connect.c b/fs/cifs/connect.c</span>
<span class="p_header">index 3c393b9759d8..4392296e6f3f 100644</span>
<span class="p_header">--- a/fs/cifs/connect.c</span>
<span class="p_header">+++ b/fs/cifs/connect.c</span>
<span class="p_chunk">@@ -2147,7 +2147,7 @@</span> <span class="p_context"> cifs_get_tcp_session(struct smb_vol *volume_info)</span>
 	memcpy(&amp;tcp_ses-&gt;dstaddr, &amp;volume_info-&gt;dstaddr,
 		sizeof(tcp_ses-&gt;dstaddr));
 #ifdef CONFIG_CIFS_SMB2
<span class="p_del">-	get_random_bytes(tcp_ses-&gt;client_guid, SMB2_CLIENT_GUID_SIZE);</span>
<span class="p_add">+	generate_random_uuid(tcp_ses-&gt;client_guid);</span>
 #endif
 	/*
 	 * at this point we are the only ones with the pointer
<span class="p_header">diff --git a/fs/cifs/file.c b/fs/cifs/file.c</span>
<span class="p_header">index e645b9f4f6a3..5f82e4905752 100644</span>
<span class="p_header">--- a/fs/cifs/file.c</span>
<span class="p_header">+++ b/fs/cifs/file.c</span>
<span class="p_chunk">@@ -306,6 +306,7 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 	cfile-&gt;tlink = cifs_get_tlink(tlink);
 	INIT_WORK(&amp;cfile-&gt;oplock_break, cifs_oplock_break);
 	mutex_init(&amp;cfile-&gt;fh_mutex);
<span class="p_add">+	spin_lock_init(&amp;cfile-&gt;file_info_lock);</span>
 
 	cifs_sb_active(inode-&gt;i_sb);
 
<span class="p_chunk">@@ -318,7 +319,7 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 		oplock = 0;
 	}
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	if (fid-&gt;pending_open-&gt;oplock != CIFS_OPLOCK_NO_CHANGE &amp;&amp; oplock)
 		oplock = fid-&gt;pending_open-&gt;oplock;
 	list_del(&amp;fid-&gt;pending_open-&gt;olist);
<span class="p_chunk">@@ -327,12 +328,13 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 	server-&gt;ops-&gt;set_fid(cfile, fid, oplock);
 
 	list_add(&amp;cfile-&gt;tlist, &amp;tcon-&gt;openFileList);
<span class="p_add">+</span>
 	/* if readable file instance put first in list*/
 	if (file-&gt;f_mode &amp; FMODE_READ)
 		list_add(&amp;cfile-&gt;flist, &amp;cinode-&gt;openFileList);
 	else
 		list_add_tail(&amp;cfile-&gt;flist, &amp;cinode-&gt;openFileList);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	if (fid-&gt;purge_cache)
 		cifs_zap_mapping(inode);
<span class="p_chunk">@@ -344,16 +346,16 @@</span> <span class="p_context"> cifs_new_fileinfo(struct cifs_fid *fid, struct file *file,</span>
 struct cifsFileInfo *
 cifsFileInfo_get(struct cifsFileInfo *cifs_file)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;cifs_file-&gt;file_info_lock);</span>
 	cifsFileInfo_get_locked(cifs_file);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
 	return cifs_file;
 }
 
 /*
  * Release a reference on the file private data. This may involve closing
  * the filehandle out on the server. Must be called without holding
<span class="p_del">- * cifs_file_list_lock.</span>
<span class="p_add">+ * tcon-&gt;open_file_lock and cifs_file-&gt;file_info_lock.</span>
  */
 void cifsFileInfo_put(struct cifsFileInfo *cifs_file)
 {
<span class="p_chunk">@@ -368,11 +370,15 @@</span> <span class="p_context"> void cifsFileInfo_put(struct cifsFileInfo *cifs_file)</span>
 	struct cifs_pending_open open;
 	bool oplock_break_cancelled;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;cifs_file-&gt;file_info_lock);</span>
 	if (--cifs_file-&gt;count &gt; 0) {
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
<span class="p_add">+		spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 		return;
 	}
<span class="p_add">+	spin_unlock(&amp;cifs_file-&gt;file_info_lock);</span>
 
 	if (server-&gt;ops-&gt;get_lease_key)
 		server-&gt;ops-&gt;get_lease_key(inode, &amp;fid);
<span class="p_chunk">@@ -396,7 +402,8 @@</span> <span class="p_context"> void cifsFileInfo_put(struct cifsFileInfo *cifs_file)</span>
 			set_bit(CIFS_INO_INVALID_MAPPING, &amp;cifsi-&gt;flags);
 		cifs_set_oplock_level(cifsi, 0);
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	oplock_break_cancelled = cancel_work_sync(&amp;cifs_file-&gt;oplock_break);
 
<span class="p_chunk">@@ -765,10 +772,10 @@</span> <span class="p_context"> int cifs_closedir(struct inode *inode, struct file *file)</span>
 	server = tcon-&gt;ses-&gt;server;
 
 	cifs_dbg(FYI, &quot;Freeing private data in close dir\n&quot;);
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 	if (server-&gt;ops-&gt;dir_needs_close(cfile)) {
 		cfile-&gt;invalidHandle = true;
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 		if (server-&gt;ops-&gt;close_dir)
 			rc = server-&gt;ops-&gt;close_dir(xid, tcon, &amp;cfile-&gt;fid);
 		else
<span class="p_chunk">@@ -777,7 +784,7 @@</span> <span class="p_context"> int cifs_closedir(struct inode *inode, struct file *file)</span>
 		/* not much we can do if it fails anyway, ignore rc */
 		rc = 0;
 	} else
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 
 	buf = cfile-&gt;srch_inf.ntwrk_buf_start;
 	if (buf) {
<span class="p_chunk">@@ -1719,12 +1726,13 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 {
 	struct cifsFileInfo *open_file = NULL;
 	struct cifs_sb_info *cifs_sb = CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb);
<span class="p_add">+	struct cifs_tcon *tcon = cifs_sb_master_tcon(cifs_sb);</span>
 
 	/* only filter by fsuid on multiuser mounts */
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER))
 		fsuid_only = false;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	/* we could simply get the first_list_entry since write-only entries
 	   are always at the end of the list but since the first entry might
 	   have a close pending, we go through the whole list */
<span class="p_chunk">@@ -1735,8 +1743,8 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 			if (!open_file-&gt;invalidHandle) {
 				/* found a good file */
 				/* lock it so it will not be closed on us */
<span class="p_del">-				cifsFileInfo_get_locked(open_file);</span>
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				cifsFileInfo_get(open_file);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				return open_file;
 			} /* else might as well continue, and look for
 			     another, or simply have the caller reopen it
<span class="p_chunk">@@ -1744,7 +1752,7 @@</span> <span class="p_context"> struct cifsFileInfo *find_readable_file(struct cifsInodeInfo *cifs_inode,</span>
 		} else /* write only file */
 			break; /* write only files are last so must be done */
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	return NULL;
 }
 
<span class="p_chunk">@@ -1753,6 +1761,7 @@</span> <span class="p_context"> struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,</span>
 {
 	struct cifsFileInfo *open_file, *inv_file = NULL;
 	struct cifs_sb_info *cifs_sb;
<span class="p_add">+	struct cifs_tcon *tcon;</span>
 	bool any_available = false;
 	int rc;
 	unsigned int refind = 0;
<span class="p_chunk">@@ -1768,15 +1777,16 @@</span> <span class="p_context"> struct cifsFileInfo *find_writable_file(struct cifsInodeInfo *cifs_inode,</span>
 	}
 
 	cifs_sb = CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb);
<span class="p_add">+	tcon = cifs_sb_master_tcon(cifs_sb);</span>
 
 	/* only filter by fsuid on multiuser mounts */
 	if (!(cifs_sb-&gt;mnt_cifs_flags &amp; CIFS_MOUNT_MULTIUSER))
 		fsuid_only = false;
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 refind_writable:
 	if (refind &gt; MAX_REOPEN_ATT) {
<span class="p_del">-		spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 		return NULL;
 	}
 	list_for_each_entry(open_file, &amp;cifs_inode-&gt;openFileList, flist) {
<span class="p_chunk">@@ -1787,8 +1797,8 @@</span> <span class="p_context"> refind_writable:</span>
 		if (OPEN_FMODE(open_file-&gt;f_flags) &amp; FMODE_WRITE) {
 			if (!open_file-&gt;invalidHandle) {
 				/* found a good writable file */
<span class="p_del">-				cifsFileInfo_get_locked(open_file);</span>
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				cifsFileInfo_get(open_file);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				return open_file;
 			} else {
 				if (!inv_file)
<span class="p_chunk">@@ -1804,24 +1814,24 @@</span> <span class="p_context"> refind_writable:</span>
 
 	if (inv_file) {
 		any_available = false;
<span class="p_del">-		cifsFileInfo_get_locked(inv_file);</span>
<span class="p_add">+		cifsFileInfo_get(inv_file);</span>
 	}
 
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 
 	if (inv_file) {
 		rc = cifs_reopen_file(inv_file, false);
 		if (!rc)
 			return inv_file;
 		else {
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_move_tail(&amp;inv_file-&gt;flist,
 					&amp;cifs_inode-&gt;openFileList);
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			cifsFileInfo_put(inv_file);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
 			++refind;
 			inv_file = NULL;
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			goto refind_writable;
 		}
 	}
<span class="p_chunk">@@ -3466,15 +3476,17 @@</span> <span class="p_context"> static int cifs_readpage(struct file *file, struct page *page)</span>
 static int is_inode_writable(struct cifsInodeInfo *cifs_inode)
 {
 	struct cifsFileInfo *open_file;
<span class="p_add">+	struct cifs_tcon *tcon =</span>
<span class="p_add">+		cifs_sb_master_tcon(CIFS_SB(cifs_inode-&gt;vfs_inode.i_sb));</span>
 
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 	list_for_each_entry(open_file, &amp;cifs_inode-&gt;openFileList, flist) {
 		if (OPEN_FMODE(open_file-&gt;f_flags) &amp; FMODE_WRITE) {
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			return 1;
 		}
 	}
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 	return 0;
 }
 
<span class="p_header">diff --git a/fs/cifs/misc.c b/fs/cifs/misc.c</span>
<span class="p_header">index 3b0c62e622da..5b3735b3ca85 100644</span>
<span class="p_header">--- a/fs/cifs/misc.c</span>
<span class="p_header">+++ b/fs/cifs/misc.c</span>
<span class="p_chunk">@@ -120,6 +120,7 @@</span> <span class="p_context"> tconInfoAlloc(void)</span>
 		++ret_buf-&gt;tc_count;
 		INIT_LIST_HEAD(&amp;ret_buf-&gt;openFileList);
 		INIT_LIST_HEAD(&amp;ret_buf-&gt;tcon_list);
<span class="p_add">+		spin_lock_init(&amp;ret_buf-&gt;open_file_lock);</span>
 #ifdef CONFIG_CIFS_STATS
 		spin_lock_init(&amp;ret_buf-&gt;stat_lock);
 #endif
<span class="p_chunk">@@ -456,7 +457,7 @@</span> <span class="p_context"> is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)</span>
 				continue;
 
 			cifs_stats_inc(&amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_for_each(tmp2, &amp;tcon-&gt;openFileList) {
 				netfile = list_entry(tmp2, struct cifsFileInfo,
 						     tlist);
<span class="p_chunk">@@ -486,11 +487,11 @@</span> <span class="p_context"> is_valid_oplock_break(char *buffer, struct TCP_Server_Info *srv)</span>
 					   &amp;netfile-&gt;oplock_break);
 				netfile-&gt;oplock_break_cancelled = false;
 
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				spin_unlock(&amp;cifs_tcp_ses_lock);
 				return true;
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			spin_unlock(&amp;cifs_tcp_ses_lock);
 			cifs_dbg(FYI, &quot;No matching file for oplock break\n&quot;);
 			return true;
<span class="p_chunk">@@ -639,9 +640,9 @@</span> <span class="p_context"> backup_cred(struct cifs_sb_info *cifs_sb)</span>
 void
 cifs_del_pending_open(struct cifs_pending_open *open)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 	list_del(&amp;open-&gt;olist);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 }
 
 void
<span class="p_chunk">@@ -661,7 +662,7 @@</span> <span class="p_context"> void</span>
 cifs_add_pending_open(struct cifs_fid *fid, struct tcon_link *tlink,
 		      struct cifs_pending_open *open)
 {
<span class="p_del">-	spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_lock(&amp;tlink_tcon(tlink)-&gt;open_file_lock);</span>
 	cifs_add_pending_open_locked(fid, tlink, open);
<span class="p_del">-	spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+	spin_unlock(&amp;tlink_tcon(open-&gt;tlink)-&gt;open_file_lock);</span>
 }
<span class="p_header">diff --git a/fs/cifs/readdir.c b/fs/cifs/readdir.c</span>
<span class="p_header">index 1320d1ecc630..27e4ad7ef172 100644</span>
<span class="p_header">--- a/fs/cifs/readdir.c</span>
<span class="p_header">+++ b/fs/cifs/readdir.c</span>
<span class="p_chunk">@@ -592,14 +592,14 @@</span> <span class="p_context"> find_cifs_entry(const unsigned int xid, struct cifs_tcon *tcon, loff_t pos,</span>
 	     is_dir_changed(file)) || (index_to_find &lt; first_entry_in_buffer)) {
 		/* close and restart search */
 		cifs_dbg(FYI, &quot;search backing up - close and restart search\n&quot;);
<span class="p_del">-		spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+		spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 		if (server-&gt;ops-&gt;dir_needs_close(cfile)) {
 			cfile-&gt;invalidHandle = true;
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 			if (server-&gt;ops-&gt;close_dir)
 				server-&gt;ops-&gt;close_dir(xid, tcon, &amp;cfile-&gt;fid);
 		} else
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 		if (cfile-&gt;srch_inf.ntwrk_buf_start) {
 			cifs_dbg(FYI, &quot;freeing SMB ff cache buf on search rewind\n&quot;);
 			if (cfile-&gt;srch_inf.smallBuf)
<span class="p_header">diff --git a/fs/cifs/smb2glob.h b/fs/cifs/smb2glob.h</span>
<span class="p_header">index 0ffa18094335..238759c146ba 100644</span>
<span class="p_header">--- a/fs/cifs/smb2glob.h</span>
<span class="p_header">+++ b/fs/cifs/smb2glob.h</span>
<span class="p_chunk">@@ -61,4 +61,14 @@</span> <span class="p_context"></span>
 /* Maximum buffer size value we can send with 1 credit */
 #define SMB2_MAX_BUFFER_SIZE 65536
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Maximum number of credits to keep available.</span>
<span class="p_add">+ * This value is chosen somewhat arbitrarily. The Windows client</span>
<span class="p_add">+ * defaults to 128 credits, the Windows server allows clients up to</span>
<span class="p_add">+ * 512 credits, and the NetApp server does not limit clients at all.</span>
<span class="p_add">+ * Choose a high enough value such that the client shouldn&#39;t limit</span>
<span class="p_add">+ * performance.</span>
<span class="p_add">+ */</span>
<span class="p_add">+#define SMB2_MAX_CREDITS_AVAILABLE 32000</span>
<span class="p_add">+</span>
 #endif	/* _SMB2_GLOB_H */
<span class="p_header">diff --git a/fs/cifs/smb2inode.c b/fs/cifs/smb2inode.c</span>
<span class="p_header">index f970c5d5b253..549676f7b811 100644</span>
<span class="p_header">--- a/fs/cifs/smb2inode.c</span>
<span class="p_header">+++ b/fs/cifs/smb2inode.c</span>
<span class="p_chunk">@@ -266,9 +266,15 @@</span> <span class="p_context"> smb2_set_file_info(struct inode *inode, const char *full_path,</span>
 	struct tcon_link *tlink;
 	int rc;
 
<span class="p_add">+	if ((buf-&gt;CreationTime == 0) &amp;&amp; (buf-&gt;LastAccessTime == 0) &amp;&amp;</span>
<span class="p_add">+	    (buf-&gt;LastWriteTime == 0) &amp;&amp; (buf-&gt;ChangeTime) &amp;&amp;</span>
<span class="p_add">+	    (buf-&gt;Attributes == 0))</span>
<span class="p_add">+		return 0; /* would be a no op, no sense sending this */</span>
<span class="p_add">+</span>
 	tlink = cifs_sb_tlink(cifs_sb);
 	if (IS_ERR(tlink))
 		return PTR_ERR(tlink);
<span class="p_add">+</span>
 	rc = smb2_open_op_close(xid, tlink_tcon(tlink), cifs_sb, full_path,
 				FILE_WRITE_ATTRIBUTES, FILE_OPEN, 0, buf,
 				SMB2_OP_SET_INFO);
<span class="p_header">diff --git a/fs/cifs/smb2misc.c b/fs/cifs/smb2misc.c</span>
<span class="p_header">index b8021fde987d..579645d87f93 100644</span>
<span class="p_header">--- a/fs/cifs/smb2misc.c</span>
<span class="p_header">+++ b/fs/cifs/smb2misc.c</span>
<span class="p_chunk">@@ -502,19 +502,19 @@</span> <span class="p_context"> smb2_is_valid_lease_break(char *buffer)</span>
 		list_for_each(tmp1, &amp;server-&gt;smb_ses_list) {
 			ses = list_entry(tmp1, struct cifs_ses, smb_ses_list);
 
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
 			list_for_each(tmp2, &amp;ses-&gt;tcon_list) {
 				tcon = list_entry(tmp2, struct cifs_tcon,
 						  tcon_list);
<span class="p_add">+				spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 				cifs_stats_inc(
 				    &amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
 				if (smb2_tcon_has_lease(tcon, rsp, lw)) {
<span class="p_del">-					spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+					spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 					spin_unlock(&amp;cifs_tcp_ses_lock);
 					return true;
 				}
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
 		}
 	}
 	spin_unlock(&amp;cifs_tcp_ses_lock);
<span class="p_chunk">@@ -556,7 +556,7 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 			tcon = list_entry(tmp1, struct cifs_tcon, tcon_list);
 
 			cifs_stats_inc(&amp;tcon-&gt;stats.cifs_stats.num_oplock_brks);
<span class="p_del">-			spin_lock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_lock(&amp;tcon-&gt;open_file_lock);</span>
 			list_for_each(tmp2, &amp;tcon-&gt;openFileList) {
 				cfile = list_entry(tmp2, struct cifsFileInfo,
 						     tlist);
<span class="p_chunk">@@ -568,7 +568,7 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 
 				cifs_dbg(FYI, &quot;file id match, oplock break\n&quot;);
 				cinode = CIFS_I(cfile-&gt;dentry-&gt;d_inode);
<span class="p_del">-</span>
<span class="p_add">+				spin_lock(&amp;cfile-&gt;file_info_lock);</span>
 				if (!CIFS_CACHE_WRITE(cinode) &amp;&amp;
 				    rsp-&gt;OplockLevel == SMB2_OPLOCK_LEVEL_NONE)
 					cfile-&gt;oplock_break_cancelled = true;
<span class="p_chunk">@@ -590,14 +590,14 @@</span> <span class="p_context"> smb2_is_valid_oplock_break(char *buffer, struct TCP_Server_Info *server)</span>
 					clear_bit(
 					   CIFS_INODE_DOWNGRADE_OPLOCK_TO_L2,
 					   &amp;cinode-&gt;flags);
<span class="p_del">-</span>
<span class="p_add">+				spin_unlock(&amp;cfile-&gt;file_info_lock);</span>
 				queue_work(cifsiod_wq, &amp;cfile-&gt;oplock_break);
 
<span class="p_del">-				spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+				spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 				spin_unlock(&amp;cifs_tcp_ses_lock);
 				return true;
 			}
<span class="p_del">-			spin_unlock(&amp;cifs_file_list_lock);</span>
<span class="p_add">+			spin_unlock(&amp;tcon-&gt;open_file_lock);</span>
 			spin_unlock(&amp;cifs_tcp_ses_lock);
 			cifs_dbg(FYI, &quot;No matching file for oplock break\n&quot;);
 			return true;
<span class="p_header">diff --git a/fs/cifs/smb2ops.c b/fs/cifs/smb2ops.c</span>
<span class="p_header">index 1059ba829774..6cfc4ea3f3a1 100644</span>
<span class="p_header">--- a/fs/cifs/smb2ops.c</span>
<span class="p_header">+++ b/fs/cifs/smb2ops.c</span>
<span class="p_chunk">@@ -228,7 +228,7 @@</span> <span class="p_context"> SMB3_request_interfaces(const unsigned int xid, struct cifs_tcon *tcon)</span>
 			le64_to_cpu(out_buf-&gt;LinkSpeed));
 	} else
 		cifs_dbg(VFS, &quot;error %d on ioctl to get interface list\n&quot;, rc);
<span class="p_del">-</span>
<span class="p_add">+	kfree(out_buf);</span>
 	return rc;
 }
 #endif /* STATS2 */
<span class="p_chunk">@@ -640,6 +640,7 @@</span> <span class="p_context"> smb2_clone_range(const unsigned int xid,</span>
 
 cchunk_out:
 	kfree(pcchunk);
<span class="p_add">+	kfree(retbuf);</span>
 	return rc;
 }
 
<span class="p_chunk">@@ -855,7 +856,7 @@</span> <span class="p_context"> smb2_set_lease_key(struct inode *inode, struct cifs_fid *fid)</span>
 static void
 smb2_new_lease_key(struct cifs_fid *fid)
 {
<span class="p_del">-	get_random_bytes(fid-&gt;lease_key, SMB2_LEASE_KEY_SIZE);</span>
<span class="p_add">+	generate_random_uuid(fid-&gt;lease_key);</span>
 }
 
 #define SMB2_SYMLINK_STRUCT_SIZE \
<span class="p_header">diff --git a/fs/cifs/smb2pdu.c b/fs/cifs/smb2pdu.c</span>
<span class="p_header">index aa49aaa417be..1da1622aa1ea 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.c</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.c</span>
<span class="p_chunk">@@ -102,7 +102,21 @@</span> <span class="p_context"> smb2_hdr_assemble(struct smb2_hdr *hdr, __le16 smb2_cmd /* command */ ,</span>
 	hdr-&gt;ProtocolId[3] = &#39;B&#39;;
 	hdr-&gt;StructureSize = cpu_to_le16(64);
 	hdr-&gt;Command = smb2_cmd;
<span class="p_del">-	hdr-&gt;CreditRequest = cpu_to_le16(2); /* BB make this dynamic */</span>
<span class="p_add">+	if (tcon &amp;&amp; tcon-&gt;ses &amp;&amp; tcon-&gt;ses-&gt;server) {</span>
<span class="p_add">+		struct TCP_Server_Info *server = tcon-&gt;ses-&gt;server;</span>
<span class="p_add">+</span>
<span class="p_add">+		spin_lock(&amp;server-&gt;req_lock);</span>
<span class="p_add">+		/* Request up to 2 credits but don&#39;t go over the limit. */</span>
<span class="p_add">+		if (server-&gt;credits &gt;= SMB2_MAX_CREDITS_AVAILABLE)</span>
<span class="p_add">+			hdr-&gt;CreditRequest = cpu_to_le16(0);</span>
<span class="p_add">+		else</span>
<span class="p_add">+			hdr-&gt;CreditRequest = cpu_to_le16(</span>
<span class="p_add">+				min_t(int, SMB2_MAX_CREDITS_AVAILABLE -</span>
<span class="p_add">+						server-&gt;credits, 2));</span>
<span class="p_add">+		spin_unlock(&amp;server-&gt;req_lock);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		hdr-&gt;CreditRequest = cpu_to_le16(2);</span>
<span class="p_add">+	}</span>
 	hdr-&gt;ProcessId = cpu_to_le32((__u16)current-&gt;tgid);
 
 	if (!tcon)
<span class="p_chunk">@@ -552,6 +566,7 @@</span> <span class="p_context"> SMB2_sess_setup(const unsigned int xid, struct cifs_ses *ses,</span>
 	char *security_blob;
 	unsigned char *ntlmssp_blob = NULL;
 	bool use_spnego = false; /* else use raw ntlmssp */
<span class="p_add">+	u64 previous_session = ses-&gt;Suid;</span>
 
 	cifs_dbg(FYI, &quot;Session Setup\n&quot;);
 
<span class="p_chunk">@@ -588,6 +603,10 @@</span> <span class="p_context"> ssetup_ntlmssp_authenticate:</span>
 		return rc;
 
 	req-&gt;hdr.SessionId = 0; /* First session, not a reauthenticate */
<span class="p_add">+</span>
<span class="p_add">+	/* if reconnect, we need to send previous sess id, otherwise it is 0 */</span>
<span class="p_add">+	req-&gt;PreviousSessionId = previous_session;</span>
<span class="p_add">+</span>
 	req-&gt;VcNumber = 0; /* MBZ */
 	/* to enable echos and oplocks */
 	req-&gt;hdr.CreditRequest = cpu_to_le16(3);
<span class="p_header">diff --git a/fs/cifs/smb2pdu.h b/fs/cifs/smb2pdu.h</span>
<span class="p_header">index 69f3595d3952..0de9d257fd92 100644</span>
<span class="p_header">--- a/fs/cifs/smb2pdu.h</span>
<span class="p_header">+++ b/fs/cifs/smb2pdu.h</span>
<span class="p_chunk">@@ -245,7 +245,7 @@</span> <span class="p_context"> struct smb2_sess_setup_req {</span>
 	__le32 Channel;
 	__le16 SecurityBufferOffset;
 	__le16 SecurityBufferLength;
<span class="p_del">-	__le64 PreviousSessionId;</span>
<span class="p_add">+	__u64 PreviousSessionId;</span>
 	__u8   Buffer[1];	/* variable length GSS security buffer */
 } __packed;
 
<span class="p_header">diff --git a/fs/coredump.c b/fs/coredump.c</span>
<span class="p_header">index 09c201161bff..caa4ffe5138a 100644</span>
<span class="p_header">--- a/fs/coredump.c</span>
<span class="p_header">+++ b/fs/coredump.c</span>
<span class="p_chunk">@@ -1,6 +1,7 @@</span> <span class="p_context"></span>
 #include &lt;linux/slab.h&gt;
 #include &lt;linux/file.h&gt;
 #include &lt;linux/fdtable.h&gt;
<span class="p_add">+#include &lt;linux/freezer.h&gt;</span>
 #include &lt;linux/mm.h&gt;
 #include &lt;linux/stat.h&gt;
 #include &lt;linux/fcntl.h&gt;
<span class="p_chunk">@@ -385,7 +386,9 @@</span> <span class="p_context"> static int coredump_wait(int exit_code, struct core_state *core_state)</span>
 	if (core_waiters &gt; 0) {
 		struct core_thread *ptr;
 
<span class="p_add">+		freezer_do_not_count();</span>
 		wait_for_completion(&amp;core_state-&gt;startup);
<span class="p_add">+		freezer_count();</span>
 		/*
 		 * Wait for all the threads to become inactive, so that
 		 * all the thread context (extended register state, like
<span class="p_header">diff --git a/fs/ext4/ext4.h b/fs/ext4/ext4.h</span>
<span class="p_header">index 08dc605bec48..7075d70b73af 100644</span>
<span class="p_header">--- a/fs/ext4/ext4.h</span>
<span class="p_header">+++ b/fs/ext4/ext4.h</span>
<span class="p_chunk">@@ -234,6 +234,7 @@</span> <span class="p_context"> struct ext4_io_submit {</span>
 #define	EXT4_MAX_BLOCK_SIZE		65536
 #define EXT4_MIN_BLOCK_LOG_SIZE		10
 #define EXT4_MAX_BLOCK_LOG_SIZE		16
<span class="p_add">+#define EXT4_MAX_CLUSTER_LOG_SIZE	30</span>
 #ifdef __KERNEL__
 # define EXT4_BLOCK_SIZE(s)		((s)-&gt;s_blocksize)
 #else
<span class="p_header">diff --git a/fs/ext4/inode.c b/fs/ext4/inode.c</span>
<span class="p_header">index ae4271d5c6ca..c37dd715060f 100644</span>
<span class="p_header">--- a/fs/ext4/inode.c</span>
<span class="p_header">+++ b/fs/ext4/inode.c</span>
<span class="p_chunk">@@ -1494,6 +1494,8 @@</span> <span class="p_context"> static void mpage_release_unused_pages(struct mpage_da_data *mpd,</span>
 			BUG_ON(!PageLocked(page));
 			BUG_ON(PageWriteback(page));
 			if (invalidate) {
<span class="p_add">+				if (page_mapped(page))</span>
<span class="p_add">+					clear_page_dirty_for_io(page);</span>
 				block_invalidatepage(page, 0, PAGE_CACHE_SIZE);
 				ClearPageUptodate(page);
 			}
<span class="p_chunk">@@ -4422,14 +4424,14 @@</span> <span class="p_context"> static int ext4_do_update_inode(handle_t *handle,</span>
  * Fix up interoperability with old kernels. Otherwise, old inodes get
  * re-used with the upper 16 bits of the uid/gid intact
  */
<span class="p_del">-		if (!ei-&gt;i_dtime) {</span>
<span class="p_add">+		if (ei-&gt;i_dtime &amp;&amp; list_empty(&amp;ei-&gt;i_orphan)) {</span>
<span class="p_add">+			raw_inode-&gt;i_uid_high = 0;</span>
<span class="p_add">+			raw_inode-&gt;i_gid_high = 0;</span>
<span class="p_add">+		} else {</span>
 			raw_inode-&gt;i_uid_high =
 				cpu_to_le16(high_16_bits(i_uid));
 			raw_inode-&gt;i_gid_high =
 				cpu_to_le16(high_16_bits(i_gid));
<span class="p_del">-		} else {</span>
<span class="p_del">-			raw_inode-&gt;i_uid_high = 0;</span>
<span class="p_del">-			raw_inode-&gt;i_gid_high = 0;</span>
 		}
 	} else {
 		raw_inode-&gt;i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));
<span class="p_header">diff --git a/fs/ext4/namei.c b/fs/ext4/namei.c</span>
<span class="p_header">index e253213b39e3..836619009b81 100644</span>
<span class="p_header">--- a/fs/ext4/namei.c</span>
<span class="p_header">+++ b/fs/ext4/namei.c</span>
<span class="p_chunk">@@ -1845,33 +1845,31 @@</span> <span class="p_context"> static int make_indexed_dir(handle_t *handle, struct dentry *dentry,</span>
 	frame-&gt;entries = entries;
 	frame-&gt;at = entries;
 	frame-&gt;bh = bh;
<span class="p_del">-	bh = bh2;</span>
 
 	retval = ext4_handle_dirty_dx_node(handle, dir, frame-&gt;bh);
 	if (retval)
 		goto out_frames;	
<span class="p_del">-	retval = ext4_handle_dirty_dirent_node(handle, dir, bh);</span>
<span class="p_add">+	retval = ext4_handle_dirty_dirent_node(handle, dir, bh2);</span>
 	if (retval)
 		goto out_frames;	
 
<span class="p_del">-	de = do_split(handle,dir, &amp;bh, frame, &amp;hinfo);</span>
<span class="p_add">+	de = do_split(handle,dir, &amp;bh2, frame, &amp;hinfo);</span>
 	if (IS_ERR(de)) {
 		retval = PTR_ERR(de);
 		goto out_frames;
 	}
<span class="p_del">-	dx_release(frames);</span>
 
<span class="p_del">-	retval = add_dirent_to_buf(handle, dentry, inode, de, bh);</span>
<span class="p_del">-	brelse(bh);</span>
<span class="p_del">-	return retval;</span>
<span class="p_add">+	retval = add_dirent_to_buf(handle, dentry, inode, de, bh2);</span>
 out_frames:
 	/*
 	 * Even if the block split failed, we have to properly write
 	 * out all the changes we did so far. Otherwise we can end up
 	 * with corrupted filesystem.
 	 */
<span class="p_del">-	ext4_mark_inode_dirty(handle, dir);</span>
<span class="p_add">+	if (retval)</span>
<span class="p_add">+		ext4_mark_inode_dirty(handle, dir);</span>
 	dx_release(frames);
<span class="p_add">+	brelse(bh2);</span>
 	return retval;
 }
 
<span class="p_header">diff --git a/fs/ext4/super.c b/fs/ext4/super.c</span>
<span class="p_header">index 1c239bba4344..a1fed6689db2 100644</span>
<span class="p_header">--- a/fs/ext4/super.c</span>
<span class="p_header">+++ b/fs/ext4/super.c</span>
<span class="p_chunk">@@ -3666,7 +3666,15 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 	if (blocksize &lt; EXT4_MIN_BLOCK_SIZE ||
 	    blocksize &gt; EXT4_MAX_BLOCK_SIZE) {
 		ext4_msg(sb, KERN_ERR,
<span class="p_del">-		       &quot;Unsupported filesystem blocksize %d&quot;, blocksize);</span>
<span class="p_add">+		       &quot;Unsupported filesystem blocksize %d (%d log_block_size)&quot;,</span>
<span class="p_add">+			 blocksize, le32_to_cpu(es-&gt;s_log_block_size));</span>
<span class="p_add">+		goto failed_mount;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (le32_to_cpu(es-&gt;s_log_block_size) &gt;</span>
<span class="p_add">+	    (EXT4_MAX_BLOCK_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {</span>
<span class="p_add">+		ext4_msg(sb, KERN_ERR,</span>
<span class="p_add">+			 &quot;Invalid log block size: %u&quot;,</span>
<span class="p_add">+			 le32_to_cpu(es-&gt;s_log_block_size));</span>
 		goto failed_mount;
 	}
 
<span class="p_chunk">@@ -3788,6 +3796,13 @@</span> <span class="p_context"> static int ext4_fill_super(struct super_block *sb, void *data, int silent)</span>
 				 &quot;block size (%d)&quot;, clustersize, blocksize);
 			goto failed_mount;
 		}
<span class="p_add">+		if (le32_to_cpu(es-&gt;s_log_cluster_size) &gt;</span>
<span class="p_add">+		    (EXT4_MAX_CLUSTER_LOG_SIZE - EXT4_MIN_BLOCK_LOG_SIZE)) {</span>
<span class="p_add">+			ext4_msg(sb, KERN_ERR,</span>
<span class="p_add">+				 &quot;Invalid log cluster size: %u&quot;,</span>
<span class="p_add">+				 le32_to_cpu(es-&gt;s_log_cluster_size));</span>
<span class="p_add">+			goto failed_mount;</span>
<span class="p_add">+		}</span>
 		sbi-&gt;s_cluster_bits = le32_to_cpu(es-&gt;s_log_cluster_size) -
 			le32_to_cpu(es-&gt;s_log_block_size);
 		sbi-&gt;s_clusters_per_group =
<span class="p_header">diff --git a/fs/fuse/dir.c b/fs/fuse/dir.c</span>
<span class="p_header">index 31ad5fc879b8..a5c32420bfc8 100644</span>
<span class="p_header">--- a/fs/fuse/dir.c</span>
<span class="p_header">+++ b/fs/fuse/dir.c</span>
<span class="p_chunk">@@ -1707,7 +1707,7 @@</span> <span class="p_context"> int fuse_flush_times(struct inode *inode, struct fuse_file *ff)</span>
 int fuse_do_setattr(struct dentry *dentry, struct iattr *attr,
 		    struct file *file)
 {
<span class="p_del">-	struct inode *inode = dentry-&gt;d_inode;</span>
<span class="p_add">+	struct inode *inode = d_inode(dentry);</span>
 	struct fuse_conn *fc = get_fuse_conn(inode);
 	struct fuse_inode *fi = get_fuse_inode(inode);
 	struct fuse_req *req;
<span class="p_chunk">@@ -1822,14 +1822,43 @@</span> <span class="p_context"> error:</span>
 static int fuse_setattr(struct dentry *entry, struct iattr *attr)
 {
 	struct inode *inode = entry-&gt;d_inode;
<span class="p_add">+	struct file *file = (attr-&gt;ia_valid &amp; ATTR_FILE) ? attr-&gt;ia_file : NULL;</span>
<span class="p_add">+	int ret;</span>
 
 	if (!fuse_allow_current_process(get_fuse_conn(inode)))
 		return -EACCES;
 
<span class="p_del">-	if (attr-&gt;ia_valid &amp; ATTR_FILE)</span>
<span class="p_del">-		return fuse_do_setattr(entry, attr, attr-&gt;ia_file);</span>
<span class="p_del">-	else</span>
<span class="p_del">-		return fuse_do_setattr(entry, attr, NULL);</span>
<span class="p_add">+	if (attr-&gt;ia_valid &amp; (ATTR_KILL_SUID | ATTR_KILL_SGID)) {</span>
<span class="p_add">+		attr-&gt;ia_valid &amp;= ~(ATTR_KILL_SUID | ATTR_KILL_SGID |</span>
<span class="p_add">+				    ATTR_MODE);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * ia_mode calculation may have used stale i_mode.  Refresh and</span>
<span class="p_add">+		 * recalculate.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		ret = fuse_do_getattr(inode, NULL, file);</span>
<span class="p_add">+		if (ret)</span>
<span class="p_add">+			return ret;</span>
<span class="p_add">+</span>
<span class="p_add">+		attr-&gt;ia_mode = inode-&gt;i_mode;</span>
<span class="p_add">+		if (inode-&gt;i_mode &amp; S_ISUID) {</span>
<span class="p_add">+			attr-&gt;ia_valid |= ATTR_MODE;</span>
<span class="p_add">+			attr-&gt;ia_mode &amp;= ~S_ISUID;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		if ((inode-&gt;i_mode &amp; (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP)) {</span>
<span class="p_add">+			attr-&gt;ia_valid |= ATTR_MODE;</span>
<span class="p_add">+			attr-&gt;ia_mode &amp;= ~S_ISGID;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
<span class="p_add">+	if (!attr-&gt;ia_valid)</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = fuse_do_setattr(entry, attr, file);</span>
<span class="p_add">+	if (!ret) {</span>
<span class="p_add">+		/* Directory mode changed, may need to revalidate access */</span>
<span class="p_add">+		if (d_is_dir(entry) &amp;&amp; (attr-&gt;ia_valid &amp; ATTR_MODE))</span>
<span class="p_add">+			fuse_invalidate_entry_cache(entry);</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int fuse_getattr(struct vfsmount *mnt, struct dentry *entry,
<span class="p_chunk">@@ -1936,6 +1965,23 @@</span> <span class="p_context"> static ssize_t fuse_getxattr(struct dentry *entry, const char *name,</span>
 	return ret;
 }
 
<span class="p_add">+static int fuse_verify_xattr_list(char *list, size_t size)</span>
<span class="p_add">+{</span>
<span class="p_add">+	size_t origsize = size;</span>
<span class="p_add">+</span>
<span class="p_add">+	while (size) {</span>
<span class="p_add">+		size_t thislen = strnlen(list, size);</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!thislen || thislen == size)</span>
<span class="p_add">+			return -EIO;</span>
<span class="p_add">+</span>
<span class="p_add">+		size -= thislen + 1;</span>
<span class="p_add">+		list += thislen + 1;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return origsize;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)
 {
 	struct inode *inode = entry-&gt;d_inode;
<span class="p_chunk">@@ -1974,9 +2020,11 @@</span> <span class="p_context"> static ssize_t fuse_listxattr(struct dentry *entry, char *list, size_t size)</span>
 	}
 	fuse_request_send(fc, req);
 	ret = req-&gt;out.h.error;
<span class="p_del">-	if (!ret)</span>
<span class="p_add">+	if (!ret) {</span>
 		ret = size ? req-&gt;out.args[0].size : outarg.size;
<span class="p_del">-	else {</span>
<span class="p_add">+		if (ret &gt; 0 &amp;&amp; size)</span>
<span class="p_add">+			ret = fuse_verify_xattr_list(list, ret);</span>
<span class="p_add">+	} else {</span>
 		if (ret == -ENOSYS) {
 			fc-&gt;no_listxattr = 1;
 			ret = -EOPNOTSUPP;
<span class="p_header">diff --git a/fs/fuse/file.c b/fs/fuse/file.c</span>
<span class="p_header">index 5f747cf3a412..4e9cfbc453c7 100644</span>
<span class="p_header">--- a/fs/fuse/file.c</span>
<span class="p_header">+++ b/fs/fuse/file.c</span>
<span class="p_chunk">@@ -2058,6 +2058,10 @@</span> <span class="p_context"> static int fuse_write_end(struct file *file, struct address_space *mapping,</span>
 {
 	struct inode *inode = page-&gt;mapping-&gt;host;
 
<span class="p_add">+	/* Haven&#39;t copied anything?  Skip zeroing, size extending, dirtying. */</span>
<span class="p_add">+	if (!copied)</span>
<span class="p_add">+		goto unlock;</span>
<span class="p_add">+</span>
 	if (!PageUptodate(page)) {
 		/* Zero any unwritten bytes at the end of the page */
 		size_t endoff = (pos + copied) &amp; ~PAGE_CACHE_MASK;
<span class="p_chunk">@@ -2068,6 +2072,8 @@</span> <span class="p_context"> static int fuse_write_end(struct file *file, struct address_space *mapping,</span>
 
 	fuse_write_update_size(inode, pos + copied);
 	set_page_dirty(page);
<span class="p_add">+</span>
<span class="p_add">+unlock:</span>
 	unlock_page(page);
 	page_cache_release(page);
 
<span class="p_chunk">@@ -2879,7 +2885,7 @@</span> <span class="p_context"> static void fuse_do_truncate(struct file *file)</span>
 	attr.ia_file = file;
 	attr.ia_valid |= ATTR_FILE;
 
<span class="p_del">-	fuse_do_setattr(inode, &amp;attr, file);</span>
<span class="p_add">+	fuse_do_setattr(file-&gt;f_dentry, &amp;attr, file);</span>
 }
 
 static inline loff_t fuse_round_up(loff_t off)
<span class="p_header">diff --git a/fs/isofs/inode.c b/fs/isofs/inode.c</span>
<span class="p_header">index 5ddaf8625d3b..4118b7af693b 100644</span>
<span class="p_header">--- a/fs/isofs/inode.c</span>
<span class="p_header">+++ b/fs/isofs/inode.c</span>
<span class="p_chunk">@@ -711,6 +711,11 @@</span> <span class="p_context"> static int isofs_fill_super(struct super_block *s, void *data, int silent)</span>
 	pri_bh = NULL;
 
 root_found:
<span class="p_add">+	/* We don&#39;t support read-write mounts */</span>
<span class="p_add">+	if (!(s-&gt;s_flags &amp; MS_RDONLY)) {</span>
<span class="p_add">+		error = -EACCES;</span>
<span class="p_add">+		goto out_freebh;</span>
<span class="p_add">+	}</span>
 
 	if (joliet_level &amp;&amp; (pri == NULL || !opt.rock)) {
 		/* This is the case of Joliet with the norock mount flag.
<span class="p_chunk">@@ -1523,9 +1528,6 @@</span> <span class="p_context"> struct inode *__isofs_iget(struct super_block *sb,</span>
 static struct dentry *isofs_mount(struct file_system_type *fs_type,
 	int flags, const char *dev_name, void *data)
 {
<span class="p_del">-	/* We don&#39;t support read-write mounts */</span>
<span class="p_del">-	if (!(flags &amp; MS_RDONLY))</span>
<span class="p_del">-		return ERR_PTR(-EACCES);</span>
 	return mount_bdev(fs_type, flags, dev_name, data, isofs_fill_super);
 }
 
<span class="p_header">diff --git a/fs/jbd2/transaction.c b/fs/jbd2/transaction.c</span>
<span class="p_header">index 77303ba0c270..f156390113db 100644</span>
<span class="p_header">--- a/fs/jbd2/transaction.c</span>
<span class="p_header">+++ b/fs/jbd2/transaction.c</span>
<span class="p_chunk">@@ -1093,6 +1093,7 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 		JBUFFER_TRACE(jh, &quot;file as BJ_Reserved&quot;);
 		spin_lock(&amp;journal-&gt;j_list_lock);
 		__jbd2_journal_file_buffer(jh, transaction, BJ_Reserved);
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	} else if (jh-&gt;b_transaction == journal-&gt;j_committing_transaction) {
 		/* first access by this transaction */
 		jh-&gt;b_modified = 0;
<span class="p_chunk">@@ -1100,8 +1101,8 @@</span> <span class="p_context"> int jbd2_journal_get_create_access(handle_t *handle, struct buffer_head *bh)</span>
 		JBUFFER_TRACE(jh, &quot;set next transaction&quot;);
 		spin_lock(&amp;journal-&gt;j_list_lock);
 		jh-&gt;b_next_transaction = transaction;
<span class="p_add">+		spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	}
<span class="p_del">-	spin_unlock(&amp;journal-&gt;j_list_lock);</span>
 	jbd_unlock_bh_state(bh);
 
 	/*
<span class="p_header">diff --git a/fs/nfs/nfs4state.c b/fs/nfs/nfs4state.c</span>
<span class="p_header">index 577bb8d849f7..3d88bc967c8e 100644</span>
<span class="p_header">--- a/fs/nfs/nfs4state.c</span>
<span class="p_header">+++ b/fs/nfs/nfs4state.c</span>
<span class="p_chunk">@@ -1494,6 +1494,9 @@</span> <span class="p_context"> restart:</span>
 					__func__, status);
 			case -ENOENT:
 			case -ENOMEM:
<span class="p_add">+			case -EACCES:</span>
<span class="p_add">+			case -EROFS:</span>
<span class="p_add">+			case -EIO:</span>
 			case -ESTALE:
 				/* Open state on this file cannot be recovered */
 				nfs4_state_mark_recovery_failed(state, status);
<span class="p_header">diff --git a/fs/proc/proc_sysctl.c b/fs/proc/proc_sysctl.c</span>
<span class="p_header">index 728c4657188f..2475585f034b 100644</span>
<span class="p_header">--- a/fs/proc/proc_sysctl.c</span>
<span class="p_header">+++ b/fs/proc/proc_sysctl.c</span>
<span class="p_chunk">@@ -703,7 +703,7 @@</span> <span class="p_context"> static int proc_sys_readdir(struct file *file, struct dir_context *ctx)</span>
 	ctl_dir = container_of(head, struct ctl_dir, header);
 
 	if (!dir_emit_dots(file, ctx))
<span class="p_del">-		return 0;</span>
<span class="p_add">+		goto out;</span>
 
 	pos = 2;
 
<span class="p_chunk">@@ -713,6 +713,7 @@</span> <span class="p_context"> static int proc_sys_readdir(struct file *file, struct dir_context *ctx)</span>
 			break;
 		}
 	}
<span class="p_add">+out:</span>
 	sysctl_head_finish(head);
 	return 0;
 }
<span class="p_header">diff --git a/fs/pstore/ram_core.c b/fs/pstore/ram_core.c</span>
<span class="p_header">index 8475def65880..5fa2200e5b66 100644</span>
<span class="p_header">--- a/fs/pstore/ram_core.c</span>
<span class="p_header">+++ b/fs/pstore/ram_core.c</span>
<span class="p_chunk">@@ -47,43 +47,10 @@</span> <span class="p_context"> static inline size_t buffer_start(struct persistent_ram_zone *prz)</span>
 	return atomic_read(&amp;prz-&gt;buffer-&gt;start);
 }
 
<span class="p_del">-/* increase and wrap the start pointer, returning the old value */</span>
<span class="p_del">-static size_t buffer_start_add_atomic(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_del">-{</span>
<span class="p_del">-	int old;</span>
<span class="p_del">-	int new;</span>
<span class="p_del">-</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		old = atomic_read(&amp;prz-&gt;buffer-&gt;start);</span>
<span class="p_del">-		new = old + a;</span>
<span class="p_del">-		while (unlikely(new &gt;= prz-&gt;buffer_size))</span>
<span class="p_del">-			new -= prz-&gt;buffer_size;</span>
<span class="p_del">-	} while (atomic_cmpxchg(&amp;prz-&gt;buffer-&gt;start, old, new) != old);</span>
<span class="p_del">-</span>
<span class="p_del">-	return old;</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
<span class="p_del">-/* increase the size counter until it hits the max size */</span>
<span class="p_del">-static void buffer_size_add_atomic(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_del">-{</span>
<span class="p_del">-	size_t old;</span>
<span class="p_del">-	size_t new;</span>
<span class="p_del">-</span>
<span class="p_del">-	if (atomic_read(&amp;prz-&gt;buffer-&gt;size) == prz-&gt;buffer_size)</span>
<span class="p_del">-		return;</span>
<span class="p_del">-</span>
<span class="p_del">-	do {</span>
<span class="p_del">-		old = atomic_read(&amp;prz-&gt;buffer-&gt;size);</span>
<span class="p_del">-		new = old + a;</span>
<span class="p_del">-		if (new &gt; prz-&gt;buffer_size)</span>
<span class="p_del">-			new = prz-&gt;buffer_size;</span>
<span class="p_del">-	} while (atomic_cmpxchg(&amp;prz-&gt;buffer-&gt;size, old, new) != old);</span>
<span class="p_del">-}</span>
<span class="p_del">-</span>
 static DEFINE_RAW_SPINLOCK(buffer_lock);
 
 /* increase and wrap the start pointer, returning the old value */
<span class="p_del">-static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_add">+static size_t buffer_start_add(struct persistent_ram_zone *prz, size_t a)</span>
 {
 	int old;
 	int new;
<span class="p_chunk">@@ -103,7 +70,7 @@</span> <span class="p_context"> static size_t buffer_start_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
 }
 
 /* increase the size counter until it hits the max size */
<span class="p_del">-static void buffer_size_add_locked(struct persistent_ram_zone *prz, size_t a)</span>
<span class="p_add">+static void buffer_size_add(struct persistent_ram_zone *prz, size_t a)</span>
 {
 	size_t old;
 	size_t new;
<span class="p_chunk">@@ -124,9 +91,6 @@</span> <span class="p_context"> exit:</span>
 	raw_spin_unlock_irqrestore(&amp;buffer_lock, flags);
 }
 
<span class="p_del">-static size_t (*buffer_start_add)(struct persistent_ram_zone *, size_t) = buffer_start_add_atomic;</span>
<span class="p_del">-static void (*buffer_size_add)(struct persistent_ram_zone *, size_t) = buffer_size_add_atomic;</span>
<span class="p_del">-</span>
 static void notrace persistent_ram_encode_rs8(struct persistent_ram_zone *prz,
 	uint8_t *data, size_t len, uint8_t *ecc)
 {
<span class="p_chunk">@@ -299,7 +263,7 @@</span> <span class="p_context"> static void notrace persistent_ram_update(struct persistent_ram_zone *prz,</span>
 	const void *s, unsigned int start, unsigned int count)
 {
 	struct persistent_ram_buffer *buffer = prz-&gt;buffer;
<span class="p_del">-	memcpy(buffer-&gt;data + start, s, count);</span>
<span class="p_add">+	memcpy_toio(buffer-&gt;data + start, s, count);</span>
 	persistent_ram_update_ecc(prz, start, count);
 }
 
<span class="p_chunk">@@ -322,8 +286,8 @@</span> <span class="p_context"> void persistent_ram_save_old(struct persistent_ram_zone *prz)</span>
 	}
 
 	prz-&gt;old_log_size = size;
<span class="p_del">-	memcpy(prz-&gt;old_log, &amp;buffer-&gt;data[start], size - start);</span>
<span class="p_del">-	memcpy(prz-&gt;old_log + size - start, &amp;buffer-&gt;data[0], start);</span>
<span class="p_add">+	memcpy_fromio(prz-&gt;old_log, &amp;buffer-&gt;data[start], size - start);</span>
<span class="p_add">+	memcpy_fromio(prz-&gt;old_log + size - start, &amp;buffer-&gt;data[0], start);</span>
 }
 
 int notrace persistent_ram_write(struct persistent_ram_zone *prz,
<span class="p_chunk">@@ -426,9 +390,6 @@</span> <span class="p_context"> static void *persistent_ram_iomap(phys_addr_t start, size_t size,</span>
 		return NULL;
 	}
 
<span class="p_del">-	buffer_start_add = buffer_start_add_locked;</span>
<span class="p_del">-	buffer_size_add = buffer_size_add_locked;</span>
<span class="p_del">-</span>
 	if (memtype)
 		va = ioremap(start, size);
 	else
<span class="p_header">diff --git a/fs/reiserfs/super.c b/fs/reiserfs/super.c</span>
<span class="p_header">index 48c6924eba05..7daf9e503f80 100644</span>
<span class="p_header">--- a/fs/reiserfs/super.c</span>
<span class="p_header">+++ b/fs/reiserfs/super.c</span>
<span class="p_chunk">@@ -189,7 +189,15 @@</span> <span class="p_context"> static int remove_save_link_only(struct super_block *s,</span>
 static int reiserfs_quota_on_mount(struct super_block *, int);
 #endif
 
<span class="p_del">-/* look for uncompleted unlinks and truncates and complete them */</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Look for uncompleted unlinks and truncates and complete them</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Called with superblock write locked.  If quotas are enabled, we have to</span>
<span class="p_add">+ * release/retake lest we call dquot_quota_on_mount(), proceed to</span>
<span class="p_add">+ * schedule_on_each_cpu() in invalidate_bdev() and deadlock waiting for the per</span>
<span class="p_add">+ * cpu worklets to complete flush_async_commits() that in turn wait for the</span>
<span class="p_add">+ * superblock write lock.</span>
<span class="p_add">+ */</span>
 static int finish_unfinished(struct super_block *s)
 {
 	INITIALIZE_PATH(path);
<span class="p_chunk">@@ -236,7 +244,9 @@</span> <span class="p_context"> static int finish_unfinished(struct super_block *s)</span>
 				quota_enabled[i] = 0;
 				continue;
 			}
<span class="p_add">+			reiserfs_write_unlock(s);</span>
 			ret = reiserfs_quota_on_mount(s, i);
<span class="p_add">+			reiserfs_write_lock(s);</span>
 			if (ret &lt; 0)
 				reiserfs_warning(s, &quot;reiserfs-2500&quot;,
 						 &quot;cannot turn on journaled &quot;
<span class="p_header">diff --git a/fs/super.c b/fs/super.c</span>
<span class="p_header">index abb8c7f9599b..c6bf2cef2eaf 100644</span>
<span class="p_header">--- a/fs/super.c</span>
<span class="p_header">+++ b/fs/super.c</span>
<span class="p_chunk">@@ -1337,8 +1337,8 @@</span> <span class="p_context"> int freeze_super(struct super_block *sb)</span>
 		}
 	}
 	/*
<span class="p_del">-	 * This is just for debugging purposes so that fs can warn if it</span>
<span class="p_del">-	 * sees write activity when frozen is set to SB_FREEZE_COMPLETE.</span>
<span class="p_add">+	 * For debugging purposes so that fs can warn if it sees write activity</span>
<span class="p_add">+	 * when frozen is set to SB_FREEZE_COMPLETE, and for thaw_super().</span>
 	 */
 	sb-&gt;s_writers.frozen = SB_FREEZE_COMPLETE;
 	up_write(&amp;sb-&gt;s_umount);
<span class="p_chunk">@@ -1357,7 +1357,7 @@</span> <span class="p_context"> int thaw_super(struct super_block *sb)</span>
 	int error;
 
 	down_write(&amp;sb-&gt;s_umount);
<span class="p_del">-	if (sb-&gt;s_writers.frozen == SB_UNFROZEN) {</span>
<span class="p_add">+	if (sb-&gt;s_writers.frozen != SB_FREEZE_COMPLETE) {</span>
 		up_write(&amp;sb-&gt;s_umount);
 		return -EINVAL;
 	}
<span class="p_header">diff --git a/fs/ubifs/dir.c b/fs/ubifs/dir.c</span>
<span class="p_header">index ea41649e4ca5..062f0d63dec6 100644</span>
<span class="p_header">--- a/fs/ubifs/dir.c</span>
<span class="p_header">+++ b/fs/ubifs/dir.c</span>
<span class="p_chunk">@@ -347,7 +347,7 @@</span> <span class="p_context"> static unsigned int vfs_dent_type(uint8_t type)</span>
  */
 static int ubifs_readdir(struct file *file, struct dir_context *ctx)
 {
<span class="p_del">-	int err;</span>
<span class="p_add">+	int err = 0;</span>
 	struct qstr nm;
 	union ubifs_key key;
 	struct ubifs_dent_node *dent;
<span class="p_chunk">@@ -446,16 +446,22 @@</span> <span class="p_context"> static int ubifs_readdir(struct file *file, struct dir_context *ctx)</span>
 	}
 
 out:
<span class="p_del">-	if (err != -ENOENT) {</span>
<span class="p_add">+	if (err != -ENOENT)</span>
 		ubifs_err(&quot;cannot find next direntry, error %d&quot;, err);
<span class="p_del">-		return err;</span>
<span class="p_del">-	}</span>
<span class="p_add">+	else</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * -ENOENT is a non-fatal error in this context, the TNC uses</span>
<span class="p_add">+		 * it to indicate that the cursor moved past the current directory</span>
<span class="p_add">+		 * and readdir() has to stop.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		err = 0;</span>
<span class="p_add">+</span>
 
 	kfree(file-&gt;private_data);
 	file-&gt;private_data = NULL;
 	/* 2 is a special value indicating that there are no more direntries */
 	ctx-&gt;pos = 2;
<span class="p_del">-	return 0;</span>
<span class="p_add">+	return err;</span>
 }
 
 /* Free saved readdir() state when the directory is closed */
<span class="p_header">diff --git a/fs/ubifs/xattr.c b/fs/ubifs/xattr.c</span>
<span class="p_header">index 5e0a63b1b0d5..ce6c0d4aa48d 100644</span>
<span class="p_header">--- a/fs/ubifs/xattr.c</span>
<span class="p_header">+++ b/fs/ubifs/xattr.c</span>
<span class="p_chunk">@@ -167,6 +167,7 @@</span> <span class="p_context"> out_cancel:</span>
 	host_ui-&gt;xattr_cnt -= 1;
 	host_ui-&gt;xattr_size -= CALC_DENT_SIZE(nm-&gt;len);
 	host_ui-&gt;xattr_size -= CALC_XATTR_BYTES(size);
<span class="p_add">+	host_ui-&gt;xattr_names -= nm-&gt;len;</span>
 	mutex_unlock(&amp;host_ui-&gt;ui_mutex);
 out_free:
 	make_bad_inode(inode);
<span class="p_chunk">@@ -514,6 +515,7 @@</span> <span class="p_context"> out_cancel:</span>
 	host_ui-&gt;xattr_cnt += 1;
 	host_ui-&gt;xattr_size += CALC_DENT_SIZE(nm-&gt;len);
 	host_ui-&gt;xattr_size += CALC_XATTR_BYTES(ui-&gt;data_len);
<span class="p_add">+	host_ui-&gt;xattr_names += nm-&gt;len;</span>
 	mutex_unlock(&amp;host_ui-&gt;ui_mutex);
 	ubifs_release_budget(c, &amp;req);
 	make_bad_inode(inode);
<span class="p_header">diff --git a/fs/xfs/xfs_acl.c b/fs/xfs/xfs_acl.c</span>
<span class="p_header">index d1229033a22f..7d65e25eccc5 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_acl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_acl.c</span>
<span class="p_chunk">@@ -244,8 +244,7 @@</span> <span class="p_context"> xfs_set_mode(struct inode *inode, umode_t mode)</span>
 		iattr.ia_mode = mode;
 		iattr.ia_ctime = current_fs_time(inode-&gt;i_sb);
 
<span class="p_del">-		error = -xfs_setattr_nonsize(NULL, XFS_I(inode), &amp;iattr,</span>
<span class="p_del">-					     XFS_ATTR_NOACL);</span>
<span class="p_add">+		error = -xfs_setattr_nonsize(XFS_I(inode), &amp;iattr, XFS_ATTR_NOACL);</span>
 	}
 
 	return error;
<span class="p_header">diff --git a/fs/xfs/xfs_file.c b/fs/xfs/xfs_file.c</span>
<span class="p_header">index eb04981b03b4..d00b21c5d3ec 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_file.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_file.c</span>
<span class="p_chunk">@@ -862,7 +862,7 @@</span> <span class="p_context"> xfs_file_fallocate(</span>
 
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = new_size;
<span class="p_del">-		error = xfs_setattr_size(file-&gt;f_dentry, &amp;iattr);</span>
<span class="p_add">+		error = xfs_vn_setattr_size(file-&gt;f_dentry, &amp;iattr);</span>
 	}
 
 out_unlock:
<span class="p_header">diff --git a/fs/xfs/xfs_inode.c b/fs/xfs/xfs_inode.c</span>
<span class="p_header">index 174379ddf22f..63a77bb81176 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_inode.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_inode.c</span>
<span class="p_chunk">@@ -1776,7 +1776,7 @@</span> <span class="p_context"> xfs_inactive_truncate(</span>
 	/*
 	 * Log the inode size first to prevent stale data exposure in the event
 	 * of a system crash before the truncate completes. See the related
<span class="p_del">-	 * comment in xfs_setattr_size() for details.</span>
<span class="p_add">+	 * comment in xfs_vn_setattr_size() for details.</span>
 	 */
 	ip-&gt;i_d.di_size = 0;
 	xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);
<span class="p_header">diff --git a/fs/xfs/xfs_ioctl.c b/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">index cee62a5afbee..dd2ef05fe64c 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_ioctl.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_ioctl.c</span>
<span class="p_chunk">@@ -717,7 +717,7 @@</span> <span class="p_context"> xfs_ioc_space(</span>
 		iattr.ia_valid = ATTR_SIZE;
 		iattr.ia_size = bf-&gt;l_start;
 
<span class="p_del">-		error = xfs_setattr_size(filp-&gt;f_dentry, &amp;iattr);</span>
<span class="p_add">+		error = xfs_vn_setattr_size(filp-&gt;f_dentry, &amp;iattr);</span>
 		if (!error)
 			clrprealloc = true;
 		break;
<span class="p_header">diff --git a/fs/xfs/xfs_iops.c b/fs/xfs/xfs_iops.c</span>
<span class="p_header">index cfc5c260ecbe..37f6884ae39a 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.c</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.c</span>
<span class="p_chunk">@@ -525,9 +525,30 @@</span> <span class="p_context"> xfs_setattr_time(</span>
 	}
 }
 
<span class="p_add">+static int</span>
<span class="p_add">+xfs_vn_change_ok(</span>
<span class="p_add">+	struct dentry	*dentry,</span>
<span class="p_add">+	struct iattr	*iattr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xfs_mount	*mp = XFS_I(d_inode(dentry))-&gt;i_mount;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (mp-&gt;m_flags &amp; XFS_MOUNT_RDONLY)</span>
<span class="p_add">+		return XFS_ERROR(EROFS);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (XFS_FORCED_SHUTDOWN(mp))</span>
<span class="p_add">+		return XFS_ERROR(EIO);</span>
<span class="p_add">+</span>
<span class="p_add">+	return XFS_ERROR(-setattr_prepare(dentry, iattr));</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Set non-size attributes of an inode.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Caution: The caller of this function is responsible for calling</span>
<span class="p_add">+ * setattr_prepare() or otherwise verifying the change is fine.</span>
<span class="p_add">+ */</span>
 int
 xfs_setattr_nonsize(
<span class="p_del">-	struct dentry		*dentry,</span>
 	struct xfs_inode	*ip,
 	struct iattr		*iattr,
 	int			flags)
<span class="p_chunk">@@ -542,21 +563,6 @@</span> <span class="p_context"> xfs_setattr_nonsize(</span>
 	struct xfs_dquot	*udqp = NULL, *gdqp = NULL;
 	struct xfs_dquot	*olddquot1 = NULL, *olddquot2 = NULL;
 
<span class="p_del">-	trace_xfs_setattr(ip);</span>
<span class="p_del">-</span>
<span class="p_del">-	/* If acls are being inherited, we already have this checked */</span>
<span class="p_del">-	if (!(flags &amp; XFS_ATTR_NOACL)) {</span>
<span class="p_del">-		if (mp-&gt;m_flags &amp; XFS_MOUNT_RDONLY)</span>
<span class="p_del">-			return XFS_ERROR(EROFS);</span>
<span class="p_del">-</span>
<span class="p_del">-		if (XFS_FORCED_SHUTDOWN(mp))</span>
<span class="p_del">-			return XFS_ERROR(EIO);</span>
<span class="p_del">-</span>
<span class="p_del">-		error = -setattr_prepare(dentry, iattr);</span>
<span class="p_del">-		if (error)</span>
<span class="p_del">-			return XFS_ERROR(error);</span>
<span class="p_del">-	}</span>
<span class="p_del">-</span>
 	ASSERT((mask &amp; ATTR_SIZE) == 0);
 
 	/*
<span class="p_chunk">@@ -730,17 +736,35 @@</span> <span class="p_context"> out_dqrele:</span>
 	return error;
 }
 
<span class="p_add">+int</span>
<span class="p_add">+xfs_vn_setattr_nonsize(</span>
<span class="p_add">+	struct dentry		*dentry,</span>
<span class="p_add">+	struct iattr		*iattr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xfs_inode	*ip = XFS_I(d_inode(dentry));</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xfs_setattr(ip);</span>
<span class="p_add">+</span>
<span class="p_add">+	error = xfs_vn_change_ok(dentry, iattr);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	return xfs_setattr_nonsize(ip, iattr, 0);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /*
  * Truncate file.  Must have write permission and not be a directory.
<span class="p_add">+ *</span>
<span class="p_add">+ * Caution: The caller of this function is responsible for calling</span>
<span class="p_add">+ * setattr_prepare() or otherwise verifying the change is fine.</span>
  */
 int
 xfs_setattr_size(
<span class="p_del">-	struct dentry		*dentry,</span>
<span class="p_add">+	struct xfs_inode	*ip,</span>
 	struct iattr		*iattr)
 {
<span class="p_del">-	struct inode		*inode = dentry-&gt;d_inode;</span>
<span class="p_del">-	struct xfs_inode	*ip = XFS_I(inode);</span>
 	struct xfs_mount	*mp = ip-&gt;i_mount;
<span class="p_add">+	struct inode		*inode = VFS_I(ip);</span>
 	xfs_off_t		oldsize, newsize;
 	struct xfs_trans	*tp;
 	int			error;
<span class="p_chunk">@@ -748,18 +772,6 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 	uint			commit_flags = 0;
 	bool			did_zeroing = false;
 
<span class="p_del">-	trace_xfs_setattr(ip);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (mp-&gt;m_flags &amp; XFS_MOUNT_RDONLY)</span>
<span class="p_del">-		return XFS_ERROR(EROFS);</span>
<span class="p_del">-</span>
<span class="p_del">-	if (XFS_FORCED_SHUTDOWN(mp))</span>
<span class="p_del">-		return XFS_ERROR(EIO);</span>
<span class="p_del">-</span>
<span class="p_del">-	error = -setattr_prepare(dentry, iattr);</span>
<span class="p_del">-	if (error)</span>
<span class="p_del">-		return XFS_ERROR(error);</span>
<span class="p_del">-</span>
 	ASSERT(xfs_isilocked(ip, XFS_IOLOCK_EXCL));
 	ASSERT(xfs_isilocked(ip, XFS_MMAPLOCK_EXCL));
 	ASSERT(S_ISREG(ip-&gt;i_d.di_mode));
<span class="p_chunk">@@ -780,7 +792,7 @@</span> <span class="p_context"> xfs_setattr_size(</span>
 		 * Use the regular setattr path to update the timestamps.
 		 */
 		iattr-&gt;ia_valid &amp;= ~ATTR_SIZE;
<span class="p_del">-		return xfs_setattr_nonsize(dentry, ip, iattr, 0);</span>
<span class="p_add">+		return xfs_setattr_nonsize(ip, iattr, 0);</span>
 	}
 
 	/*
<span class="p_chunk">@@ -931,6 +943,22 @@</span> <span class="p_context"> out_trans_cancel:</span>
 	goto out_unlock;
 }
 
<span class="p_add">+int</span>
<span class="p_add">+xfs_vn_setattr_size(</span>
<span class="p_add">+	struct dentry		*dentry,</span>
<span class="p_add">+	struct iattr		*iattr)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct xfs_inode	*ip = XFS_I(d_inode(dentry));</span>
<span class="p_add">+	int error;</span>
<span class="p_add">+</span>
<span class="p_add">+	trace_xfs_setattr(ip);</span>
<span class="p_add">+</span>
<span class="p_add">+	error = xfs_vn_change_ok(dentry, iattr);</span>
<span class="p_add">+	if (error)</span>
<span class="p_add">+		return error;</span>
<span class="p_add">+	return xfs_setattr_size(ip, iattr);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 STATIC int
 xfs_vn_setattr(
 	struct dentry		*dentry,
<span class="p_chunk">@@ -941,10 +969,10 @@</span> <span class="p_context"> xfs_vn_setattr(</span>
 
 	if (iattr-&gt;ia_valid &amp; ATTR_SIZE) {
 		xfs_ilock(ip, XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL);
<span class="p_del">-		error = xfs_setattr_size(dentry, iattr);</span>
<span class="p_add">+		error = xfs_vn_setattr_size(dentry, iattr);</span>
 		xfs_iunlock(ip, XFS_IOLOCK_EXCL | XFS_MMAPLOCK_EXCL);
 	} else {
<span class="p_del">-		error = xfs_setattr_nonsize(dentry, ip, iattr, 0);</span>
<span class="p_add">+		error = xfs_vn_setattr_nonsize(dentry, iattr);</span>
 	}
 
 	return -error;
<span class="p_header">diff --git a/fs/xfs/xfs_iops.h b/fs/xfs/xfs_iops.h</span>
<span class="p_header">index f66a37c0a88a..fec65c088543 100644</span>
<span class="p_header">--- a/fs/xfs/xfs_iops.h</span>
<span class="p_header">+++ b/fs/xfs/xfs_iops.h</span>
<span class="p_chunk">@@ -32,8 +32,9 @@</span> <span class="p_context"> extern void xfs_setup_inode(struct xfs_inode *);</span>
  */
 #define XFS_ATTR_NOACL		0x01	/* Don&#39;t call posix_acl_chmod */
 
<span class="p_del">-extern int xfs_setattr_nonsize(struct dentry *dentry, struct xfs_inode *ip,</span>
<span class="p_del">-			       struct iattr *vap, int flags);</span>
<span class="p_del">-extern int xfs_setattr_size(struct dentry *dentry, struct iattr *vap);</span>
<span class="p_add">+extern int xfs_setattr_nonsize(struct xfs_inode *ip, struct iattr *vap,</span>
<span class="p_add">+			       int flags);</span>
<span class="p_add">+extern int xfs_vn_setattr_nonsize(struct dentry *dentry, struct iattr *vap);</span>
<span class="p_add">+extern int xfs_vn_setattr_size(struct dentry *dentry, struct iattr *vap);</span>
 
 #endif /* __XFS_IOPS_H__ */
<span class="p_header">diff --git a/include/linux/compiler.h b/include/linux/compiler.h</span>
<span class="p_header">index 8f6e7b2d667f..36fc145ffbb6 100644</span>
<span class="p_header">--- a/include/linux/compiler.h</span>
<span class="p_header">+++ b/include/linux/compiler.h</span>
<span class="p_chunk">@@ -311,7 +311,7 @@</span> <span class="p_context"> void ftrace_likely_update(struct ftrace_branch_data *f, int val, int expect);</span>
 
 /* Is this type a native word size -- useful for atomic operations */
 #ifndef __native_word
<span class="p_del">-# define __native_word(t) (sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))</span>
<span class="p_add">+# define __native_word(t) (sizeof(t) == sizeof(char) || sizeof(t) == sizeof(short) || sizeof(t) == sizeof(int) || sizeof(t) == sizeof(long))</span>
 #endif
 
 /* Compile time object size, -1 for unknown */
<span class="p_header">diff --git a/include/linux/filter.h b/include/linux/filter.h</span>
<span class="p_header">index 96509e579d21..bdc6f86e7897 100644</span>
<span class="p_header">--- a/include/linux/filter.h</span>
<span class="p_header">+++ b/include/linux/filter.h</span>
<span class="p_chunk">@@ -346,7 +346,11 @@</span> <span class="p_context"> static inline unsigned int sk_filter_size(unsigned int proglen)</span>
 #define sk_filter_proglen(fprog)			\
 		(fprog-&gt;len * sizeof(fprog-&gt;filter[0]))
 
<span class="p_del">-int sk_filter(struct sock *sk, struct sk_buff *skb);</span>
<span class="p_add">+int sk_filter_trim_cap(struct sock *sk, struct sk_buff *skb, unsigned int cap);</span>
<span class="p_add">+static inline int sk_filter(struct sock *sk, struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return sk_filter_trim_cap(sk, skb, 1);</span>
<span class="p_add">+}</span>
 
 void sk_filter_select_runtime(struct sk_filter *fp);
 void sk_filter_free(struct sk_filter *fp);
<span class="p_header">diff --git a/include/linux/hugetlb.h b/include/linux/hugetlb.h</span>
<span class="p_header">index 62e94d2517bd..6bc75164e68f 100644</span>
<span class="p_header">--- a/include/linux/hugetlb.h</span>
<span class="p_header">+++ b/include/linux/hugetlb.h</span>
<span class="p_chunk">@@ -396,8 +396,8 @@</span> <span class="p_context"> static inline pgoff_t basepage_index(struct page *page)</span>
 	return __basepage_index(page);
 }
 
<span class="p_del">-extern void dissolve_free_huge_pages(unsigned long start_pfn,</span>
<span class="p_del">-				     unsigned long end_pfn);</span>
<span class="p_add">+extern int dissolve_free_huge_pages(unsigned long start_pfn,</span>
<span class="p_add">+				    unsigned long end_pfn);</span>
 static inline int hugepage_migration_supported(struct hstate *h)
 {
 #ifdef CONFIG_ARCH_ENABLE_HUGEPAGE_MIGRATION
<span class="p_chunk">@@ -452,7 +452,7 @@</span> <span class="p_context"> static inline pgoff_t basepage_index(struct page *page)</span>
 {
 	return page-&gt;index;
 }
<span class="p_del">-#define dissolve_free_huge_pages(s, e)	do {} while (0)</span>
<span class="p_add">+#define dissolve_free_huge_pages(s, e)	0</span>
 #define hugepage_migration_supported(h)	0
 
 static inline spinlock_t *huge_pte_lockptr(struct hstate *h,
<span class="p_header">diff --git a/include/linux/mfd/88pm80x.h b/include/linux/mfd/88pm80x.h</span>
<span class="p_header">index 97cb283cc8e1..0d37e8da3654 100644</span>
<span class="p_header">--- a/include/linux/mfd/88pm80x.h</span>
<span class="p_header">+++ b/include/linux/mfd/88pm80x.h</span>
<span class="p_chunk">@@ -349,7 +349,7 @@</span> <span class="p_context"> static inline int pm80x_dev_suspend(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		set_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		set_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -361,7 +361,7 @@</span> <span class="p_context"> static inline int pm80x_dev_resume(struct device *dev)</span>
 	int irq = platform_get_irq(pdev, 0);
 
 	if (device_may_wakeup(dev))
<span class="p_del">-		clear_bit((1 &lt;&lt; irq), &amp;chip-&gt;wu_flag);</span>
<span class="p_add">+		clear_bit(irq, &amp;chip-&gt;wu_flag);</span>
 
 	return 0;
 }
<span class="p_header">diff --git a/include/linux/pwm.h b/include/linux/pwm.h</span>
<span class="p_header">index e90628cac8fa..84e526a12def 100644</span>
<span class="p_header">--- a/include/linux/pwm.h</span>
<span class="p_header">+++ b/include/linux/pwm.h</span>
<span class="p_chunk">@@ -299,6 +299,7 @@</span> <span class="p_context"> static inline void pwm_add_table(struct pwm_lookup *table, size_t num)</span>
 #ifdef CONFIG_PWM_SYSFS
 void pwmchip_sysfs_export(struct pwm_chip *chip);
 void pwmchip_sysfs_unexport(struct pwm_chip *chip);
<span class="p_add">+void pwmchip_sysfs_unexport_children(struct pwm_chip *chip);</span>
 #else
 static inline void pwmchip_sysfs_export(struct pwm_chip *chip)
 {
<span class="p_chunk">@@ -307,6 +308,10 @@</span> <span class="p_context"> static inline void pwmchip_sysfs_export(struct pwm_chip *chip)</span>
 static inline void pwmchip_sysfs_unexport(struct pwm_chip *chip)
 {
 }
<span class="p_add">+</span>
<span class="p_add">+static inline void pwmchip_sysfs_unexport_children(struct pwm_chip *chip)</span>
<span class="p_add">+{</span>
<span class="p_add">+}</span>
 #endif /* CONFIG_PWM_SYSFS */
 
 #endif /* __LINUX_PWM_H */
<span class="p_header">diff --git a/include/linux/sem.h b/include/linux/sem.h</span>
<span class="p_header">index 976ce3a19f1b..d0efd6e6c20a 100644</span>
<span class="p_header">--- a/include/linux/sem.h</span>
<span class="p_header">+++ b/include/linux/sem.h</span>
<span class="p_chunk">@@ -21,6 +21,7 @@</span> <span class="p_context"> struct sem_array {</span>
 	struct list_head	list_id;	/* undo requests on this array */
 	int			sem_nsems;	/* no. of semaphores in array */
 	int			complex_count;	/* pending complex operations */
<span class="p_add">+	bool			complex_mode;	/* no parallel simple ops */</span>
 };
 
 #ifdef CONFIG_SYSVIPC
<span class="p_header">diff --git a/include/linux/sunrpc/svc_rdma.h b/include/linux/sunrpc/svc_rdma.h</span>
<span class="p_header">index 5cf99a016368..45a69411dafc 100644</span>
<span class="p_header">--- a/include/linux/sunrpc/svc_rdma.h</span>
<span class="p_header">+++ b/include/linux/sunrpc/svc_rdma.h</span>
<span class="p_chunk">@@ -83,6 +83,7 @@</span> <span class="p_context"> struct svc_rdma_op_ctxt {</span>
 	unsigned long flags;
 	enum dma_data_direction direction;
 	int count;
<span class="p_add">+	unsigned int mapped_sges;</span>
 	struct ib_sge sge[RPCSVC_MAXPAGES];
 	struct page *pages[RPCSVC_MAXPAGES];
 };
<span class="p_chunk">@@ -178,6 +179,14 @@</span> <span class="p_context"> struct svcxprt_rdma {</span>
 #define RPCRDMA_MAX_REQUESTS    16
 #define RPCRDMA_MAX_REQ_SIZE    4096
 
<span class="p_add">+/* Track DMA maps for this transport and context */</span>
<span class="p_add">+static inline void svc_rdma_count_mappings(struct svcxprt_rdma *rdma,</span>
<span class="p_add">+					   struct svc_rdma_op_ctxt *ctxt)</span>
<span class="p_add">+{</span>
<span class="p_add">+	ctxt-&gt;mapped_sges++;</span>
<span class="p_add">+	atomic_inc(&amp;rdma-&gt;sc_dma_used);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /* svc_rdma_marshal.c */
 extern void svc_rdma_rcl_chunk_counts(struct rpcrdma_read_chunk *,
 				      int *, int *);
<span class="p_header">diff --git a/include/net/ip6_tunnel.h b/include/net/ip6_tunnel.h</span>
<span class="p_header">index ef9557683fec..e2e680c02ff3 100644</span>
<span class="p_header">--- a/include/net/ip6_tunnel.h</span>
<span class="p_header">+++ b/include/net/ip6_tunnel.h</span>
<span class="p_chunk">@@ -75,6 +75,7 @@</span> <span class="p_context"> static inline void ip6tunnel_xmit(struct sk_buff *skb, struct net_device *dev)</span>
 	struct net_device_stats *stats = &amp;dev-&gt;stats;
 	int pkt_len, err;
 
<span class="p_add">+	memset(skb-&gt;cb, 0, sizeof(struct inet6_skb_parm));</span>
 	pkt_len = skb-&gt;len;
 	err = ip6_local_out(skb);
 
<span class="p_header">diff --git a/include/net/netfilter/nf_tables.h b/include/net/netfilter/nf_tables.h</span>
<span class="p_header">index c4d86198d3d6..24097027c5d3 100644</span>
<span class="p_header">--- a/include/net/netfilter/nf_tables.h</span>
<span class="p_header">+++ b/include/net/netfilter/nf_tables.h</span>
<span class="p_chunk">@@ -113,6 +113,7 @@</span> <span class="p_context"> static inline enum nft_registers nft_type_to_reg(enum nft_data_types type)</span>
 	return type == NFT_DATA_VERDICT ? NFT_REG_VERDICT : NFT_REG_1;
 }
 
<span class="p_add">+int nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest);</span>
 int nft_validate_input_register(enum nft_registers reg);
 int nft_validate_output_register(enum nft_registers reg);
 int nft_validate_data_load(const struct nft_ctx *ctx, enum nft_registers reg,
<span class="p_header">diff --git a/include/net/sock.h b/include/net/sock.h</span>
<span class="p_header">index 2b2960fcc878..07ede95596bb 100644</span>
<span class="p_header">--- a/include/net/sock.h</span>
<span class="p_header">+++ b/include/net/sock.h</span>
<span class="p_chunk">@@ -1669,7 +1669,13 @@</span> <span class="p_context"> static inline void sock_put(struct sock *sk)</span>
  */
 void sock_gen_put(struct sock *sk);
 
<span class="p_del">-int sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested);</span>
<span class="p_add">+int __sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested,</span>
<span class="p_add">+		     unsigned int trim_cap);</span>
<span class="p_add">+static inline int sk_receive_skb(struct sock *sk, struct sk_buff *skb,</span>
<span class="p_add">+				 const int nested)</span>
<span class="p_add">+{</span>
<span class="p_add">+	return __sk_receive_skb(sk, skb, nested, 1);</span>
<span class="p_add">+}</span>
 
 static inline void sk_tx_queue_set(struct sock *sk, int tx_queue)
 {
<span class="p_chunk">@@ -2026,6 +2032,7 @@</span> <span class="p_context"> void sk_reset_timer(struct sock *sk, struct timer_list *timer,</span>
 
 void sk_stop_timer(struct sock *sk, struct timer_list *timer);
 
<span class="p_add">+int __sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);</span>
 int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb);
 
 int sock_queue_err_skb(struct sock *sk, struct sk_buff *skb);
<span class="p_header">diff --git a/include/net/tcp.h b/include/net/tcp.h</span>
<span class="p_header">index 60e2dc5cef26..ceaa03fdccf2 100644</span>
<span class="p_header">--- a/include/net/tcp.h</span>
<span class="p_header">+++ b/include/net/tcp.h</span>
<span class="p_chunk">@@ -1053,6 +1053,7 @@</span> <span class="p_context"> static inline void tcp_prequeue_init(struct tcp_sock *tp)</span>
 }
 
 bool tcp_prequeue(struct sock *sk, struct sk_buff *skb);
<span class="p_add">+int tcp_filter(struct sock *sk, struct sk_buff *skb);</span>
 
 #undef STATE_TRACE
 
<span class="p_header">diff --git a/include/target/target_core_base.h b/include/target/target_core_base.h</span>
<span class="p_header">index e193e5d5ae58..5c755a85630b 100644</span>
<span class="p_header">--- a/include/target/target_core_base.h</span>
<span class="p_header">+++ b/include/target/target_core_base.h</span>
<span class="p_chunk">@@ -211,6 +211,7 @@</span> <span class="p_context"> enum tcm_sense_reason_table {</span>
 	TCM_LOGICAL_BLOCK_GUARD_CHECK_FAILED	= R(0x15),
 	TCM_LOGICAL_BLOCK_APP_TAG_CHECK_FAILED	= R(0x16),
 	TCM_LOGICAL_BLOCK_REF_TAG_CHECK_FAILED	= R(0x17),
<span class="p_add">+	TCM_COPY_TARGET_DEVICE_NOT_REACHABLE	= R(0x18),</span>
 #undef R
 };
 
<span class="p_header">diff --git a/include/uapi/linux/can.h b/include/uapi/linux/can.h</span>
<span class="p_header">index 41892f720057..54cfc4d92883 100644</span>
<span class="p_header">--- a/include/uapi/linux/can.h</span>
<span class="p_header">+++ b/include/uapi/linux/can.h</span>
<span class="p_chunk">@@ -190,5 +190,6 @@</span> <span class="p_context"> struct can_filter {</span>
 };
 
 #define CAN_INV_FILTER 0x20000000U /* to be set in can_filter.can_id */
<span class="p_add">+#define CAN_RAW_FILTER_MAX 512 /* maximum number of can_filter set via setsockopt() */</span>
 
 #endif /* !_UAPI_CAN_H */
<span class="p_header">diff --git a/ipc/msg.c b/ipc/msg.c</span>
<span class="p_header">index 02e72d3db498..c804e11bcbf6 100644</span>
<span class="p_header">--- a/ipc/msg.c</span>
<span class="p_header">+++ b/ipc/msg.c</span>
<span class="p_chunk">@@ -1046,22 +1046,24 @@</span> <span class="p_context"> static int sysvipc_msg_proc_show(struct seq_file *s, void *it)</span>
 	struct user_namespace *user_ns = seq_user_ns(s);
 	struct msg_queue *msq = it;
 
<span class="p_del">-	return seq_printf(s,</span>
<span class="p_del">-			&quot;%10d %10d  %4o  %10lu %10lu %5u %5u %5u %5u %5u %5u %10lu %10lu %10lu\n&quot;,</span>
<span class="p_del">-			msq-&gt;q_perm.key,</span>
<span class="p_del">-			msq-&gt;q_perm.id,</span>
<span class="p_del">-			msq-&gt;q_perm.mode,</span>
<span class="p_del">-			msq-&gt;q_cbytes,</span>
<span class="p_del">-			msq-&gt;q_qnum,</span>
<span class="p_del">-			msq-&gt;q_lspid,</span>
<span class="p_del">-			msq-&gt;q_lrpid,</span>
<span class="p_del">-			from_kuid_munged(user_ns, msq-&gt;q_perm.uid),</span>
<span class="p_del">-			from_kgid_munged(user_ns, msq-&gt;q_perm.gid),</span>
<span class="p_del">-			from_kuid_munged(user_ns, msq-&gt;q_perm.cuid),</span>
<span class="p_del">-			from_kgid_munged(user_ns, msq-&gt;q_perm.cgid),</span>
<span class="p_del">-			msq-&gt;q_stime,</span>
<span class="p_del">-			msq-&gt;q_rtime,</span>
<span class="p_del">-			msq-&gt;q_ctime);</span>
<span class="p_add">+	seq_printf(s,</span>
<span class="p_add">+		   &quot;%10d %10d  %4o  %10lu %10lu %5u %5u %5u %5u %5u %5u %10lu %10lu %10lu\n&quot;,</span>
<span class="p_add">+		   msq-&gt;q_perm.key,</span>
<span class="p_add">+		   msq-&gt;q_perm.id,</span>
<span class="p_add">+		   msq-&gt;q_perm.mode,</span>
<span class="p_add">+		   msq-&gt;q_cbytes,</span>
<span class="p_add">+		   msq-&gt;q_qnum,</span>
<span class="p_add">+		   msq-&gt;q_lspid,</span>
<span class="p_add">+		   msq-&gt;q_lrpid,</span>
<span class="p_add">+		   from_kuid_munged(user_ns, msq-&gt;q_perm.uid),</span>
<span class="p_add">+		   from_kgid_munged(user_ns, msq-&gt;q_perm.gid),</span>
<span class="p_add">+		   from_kuid_munged(user_ns, msq-&gt;q_perm.cuid),</span>
<span class="p_add">+		   from_kgid_munged(user_ns, msq-&gt;q_perm.cgid),</span>
<span class="p_add">+		   msq-&gt;q_stime,</span>
<span class="p_add">+		   msq-&gt;q_rtime,</span>
<span class="p_add">+		   msq-&gt;q_ctime);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 #endif
 
<span class="p_header">diff --git a/ipc/sem.c b/ipc/sem.c</span>
<span class="p_header">index fb0c4c96e50a..e289fa838a20 100644</span>
<span class="p_header">--- a/ipc/sem.c</span>
<span class="p_header">+++ b/ipc/sem.c</span>
<span class="p_chunk">@@ -155,14 +155,21 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it);</span>
 
 /*
  * Locking:
<span class="p_add">+ * a) global sem_lock() for read/write</span>
  *	sem_undo.id_next,
  *	sem_array.complex_count,
<span class="p_del">- *	sem_array.pending{_alter,_cont},</span>
<span class="p_del">- *	sem_array.sem_undo: global sem_lock() for read/write</span>
<span class="p_del">- *	sem_undo.proc_next: only &quot;current&quot; is allowed to read/write that field.</span>
<span class="p_add">+ *	sem_array.complex_mode</span>
<span class="p_add">+ *	sem_array.pending{_alter,_const},</span>
<span class="p_add">+ *	sem_array.sem_undo</span>
  *
<span class="p_add">+ * b) global or semaphore sem_lock() for read/write:</span>
  *	sem_array.sem_base[i].pending_{const,alter}:
<span class="p_del">- *		global or semaphore sem_lock() for read/write</span>
<span class="p_add">+ *	sem_array.complex_mode (for read)</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * c) special:</span>
<span class="p_add">+ *	sem_undo_list.list_proc:</span>
<span class="p_add">+ *	* undo_list-&gt;lock for write</span>
<span class="p_add">+ *	* rcu for read</span>
  */
 
 #define sc_semmsl	sem_ctls[0]
<span class="p_chunk">@@ -263,32 +270,62 @@</span> <span class="p_context"> static void sem_rcu_free(struct rcu_head *head)</span>
 #define ipc_smp_acquire__after_spin_is_unlocked()	smp_rmb()
 
 /*
<span class="p_del">- * Wait until all currently ongoing simple ops have completed.</span>
<span class="p_add">+ * Enter the mode suitable for non-simple operations:</span>
  * Caller must own sem_perm.lock.
<span class="p_del">- * New simple ops cannot start, because simple ops first check</span>
<span class="p_del">- * that sem_perm.lock is free.</span>
<span class="p_del">- * that a) sem_perm.lock is free and b) complex_count is 0.</span>
  */
<span class="p_del">-static void sem_wait_array(struct sem_array *sma)</span>
<span class="p_add">+static void complexmode_enter(struct sem_array *sma)</span>
 {
 	int i;
 	struct sem *sem;
 
<span class="p_del">-	if (sma-&gt;complex_count)  {</span>
<span class="p_del">-		/* The thread that increased sma-&gt;complex_count waited on</span>
<span class="p_del">-		 * all sem-&gt;lock locks. Thus we don&#39;t need to wait again.</span>
<span class="p_del">-		 */</span>
<span class="p_add">+	if (sma-&gt;complex_mode)  {</span>
<span class="p_add">+		/* We are already in complex_mode. Nothing to do */</span>
 		return;
 	}
 
<span class="p_add">+	/* We need a full barrier after seting complex_mode:</span>
<span class="p_add">+	 * The write to complex_mode must be visible</span>
<span class="p_add">+	 * before we read the first sem-&gt;lock spinlock state.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	set_mb(sma-&gt;complex_mode, true);</span>
<span class="p_add">+</span>
 	for (i = 0; i &lt; sma-&gt;sem_nsems; i++) {
 		sem = sma-&gt;sem_base + i;
 		spin_unlock_wait(&amp;sem-&gt;lock);
 	}
<span class="p_del">-	ipc_smp_acquire__after_spin_is_unlocked();</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * spin_unlock_wait() is not a memory barriers, it is only a</span>
<span class="p_add">+	 * control barrier. The code must pair with spin_unlock(&amp;sem-&gt;lock),</span>
<span class="p_add">+	 * thus just the control barrier is insufficient.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * smp_rmb() is sufficient, as writes cannot pass the control barrier.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_rmb();</span>
 }
 
 /*
<span class="p_add">+ * Try to leave the mode that disallows simple operations:</span>
<span class="p_add">+ * Caller must own sem_perm.lock.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static void complexmode_tryleave(struct sem_array *sma)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (sma-&gt;complex_count)  {</span>
<span class="p_add">+		/* Complex ops are sleeping.</span>
<span class="p_add">+		 * We must stay in complex mode</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		return;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Immediately after setting complex_mode to false,</span>
<span class="p_add">+	 * a simple op can start. Thus: all memory writes</span>
<span class="p_add">+	 * performed by the current operation must be visible</span>
<span class="p_add">+	 * before we set complex_mode to false.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_store_release(&amp;sma-&gt;complex_mode, false);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+#define SEM_GLOBAL_LOCK	(-1)</span>
<span class="p_add">+/*</span>
  * If the request contains only one semaphore operation, and there are
  * no complex transactions pending, lock only the semaphore involved.
  * Otherwise, lock the entire semaphore array, since we either have
<span class="p_chunk">@@ -304,56 +341,42 @@</span> <span class="p_context"> static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,</span>
 		/* Complex operation - acquire a full lock */
 		ipc_lock_object(&amp;sma-&gt;sem_perm);
 
<span class="p_del">-		/* And wait until all simple ops that are processed</span>
<span class="p_del">-		 * right now have dropped their locks.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		sem_wait_array(sma);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+		/* Prevent parallel simple ops */</span>
<span class="p_add">+		complexmode_enter(sma);</span>
<span class="p_add">+		return SEM_GLOBAL_LOCK;</span>
 	}
 
 	/*
 	 * Only one semaphore affected - try to optimize locking.
<span class="p_del">-	 * The rules are:</span>
<span class="p_del">-	 * - optimized locking is possible if no complex operation</span>
<span class="p_del">-	 *   is either enqueued or processed right now.</span>
<span class="p_del">-	 * - The test for enqueued complex ops is simple:</span>
<span class="p_del">-	 *      sma-&gt;complex_count != 0</span>
<span class="p_del">-	 * - Testing for complex ops that are processed right now is</span>
<span class="p_del">-	 *   a bit more difficult. Complex ops acquire the full lock</span>
<span class="p_del">-	 *   and first wait that the running simple ops have completed.</span>
<span class="p_del">-	 *   (see above)</span>
<span class="p_del">-	 *   Thus: If we own a simple lock and the global lock is free</span>
<span class="p_del">-	 *	and complex_count is now 0, then it will stay 0 and</span>
<span class="p_del">-	 *	thus just locking sem-&gt;lock is sufficient.</span>
<span class="p_add">+	 * Optimized locking is possible if no complex operation</span>
<span class="p_add">+	 * is either enqueued or processed right now.</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * Both facts are tracked by complex_mode.</span>
 	 */
 	sem = sma-&gt;sem_base + sops-&gt;sem_num;
 
<span class="p_del">-	if (sma-&gt;complex_count == 0) {</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Initial check for complex_mode. Just an optimization,</span>
<span class="p_add">+	 * no locking, no memory barrier.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!sma-&gt;complex_mode) {</span>
 		/*
 		 * It appears that no complex operation is around.
 		 * Acquire the per-semaphore lock.
 		 */
 		spin_lock(&amp;sem-&gt;lock);
 
<span class="p_del">-		/* Then check that the global lock is free */</span>
<span class="p_del">-		if (!spin_is_locked(&amp;sma-&gt;sem_perm.lock)) {</span>
<span class="p_del">-			/*</span>
<span class="p_del">-			 * We need a memory barrier with acquire semantics,</span>
<span class="p_del">-			 * otherwise we can race with another thread that does:</span>
<span class="p_del">-			 *	complex_count++;</span>
<span class="p_del">-			 *	spin_unlock(sem_perm.lock);</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			ipc_smp_acquire__after_spin_is_unlocked();</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * See 51d7d5205d33</span>
<span class="p_add">+		 * (&quot;powerpc: Add smp_mb() to arch_spin_is_locked()&quot;):</span>
<span class="p_add">+		 * A full barrier is required: the write of sem-&gt;lock</span>
<span class="p_add">+		 * must be visible before the read is executed</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_mb();</span>
 
<span class="p_del">-			/*</span>
<span class="p_del">-			 * Now repeat the test of complex_count:</span>
<span class="p_del">-			 * It can&#39;t change anymore until we drop sem-&gt;lock.</span>
<span class="p_del">-			 * Thus: if is now 0, then it will stay 0.</span>
<span class="p_del">-			 */</span>
<span class="p_del">-			if (sma-&gt;complex_count == 0) {</span>
<span class="p_del">-				/* fast path successful! */</span>
<span class="p_del">-				return sops-&gt;sem_num;</span>
<span class="p_del">-			}</span>
<span class="p_add">+		if (!smp_load_acquire(&amp;sma-&gt;complex_mode)) {</span>
<span class="p_add">+			/* fast path successful! */</span>
<span class="p_add">+			return sops-&gt;sem_num;</span>
 		}
 		spin_unlock(&amp;sem-&gt;lock);
 	}
<span class="p_chunk">@@ -373,15 +396,16 @@</span> <span class="p_context"> static inline int sem_lock(struct sem_array *sma, struct sembuf *sops,</span>
 		/* Not a false alarm, thus complete the sequence for a
 		 * full lock.
 		 */
<span class="p_del">-		sem_wait_array(sma);</span>
<span class="p_del">-		return -1;</span>
<span class="p_add">+		complexmode_enter(sma);</span>
<span class="p_add">+		return SEM_GLOBAL_LOCK;</span>
 	}
 }
 
 static inline void sem_unlock(struct sem_array *sma, int locknum)
 {
<span class="p_del">-	if (locknum == -1) {</span>
<span class="p_add">+	if (locknum == SEM_GLOBAL_LOCK) {</span>
 		unmerge_queues(sma);
<span class="p_add">+		complexmode_tryleave(sma);</span>
 		ipc_unlock_object(&amp;sma-&gt;sem_perm);
 	} else {
 		struct sem *sem = sma-&gt;sem_base + locknum;
<span class="p_chunk">@@ -533,6 +557,7 @@</span> <span class="p_context"> static int newary(struct ipc_namespace *ns, struct ipc_params *params)</span>
 	}
 
 	sma-&gt;complex_count = 0;
<span class="p_add">+	sma-&gt;complex_mode = true; /* dropped by sem_unlock below */</span>
 	INIT_LIST_HEAD(&amp;sma-&gt;pending_alter);
 	INIT_LIST_HEAD(&amp;sma-&gt;pending_const);
 	INIT_LIST_HEAD(&amp;sma-&gt;list_id);
<span class="p_chunk">@@ -2184,24 +2209,28 @@</span> <span class="p_context"> static int sysvipc_sem_proc_show(struct seq_file *s, void *it)</span>
 	/*
 	 * The proc interface isn&#39;t aware of sem_lock(), it calls
 	 * ipc_lock_object() directly (in sysvipc_find_ipc).
<span class="p_del">-	 * In order to stay compatible with sem_lock(), we must wait until</span>
<span class="p_del">-	 * all simple semop() calls have left their critical regions.</span>
<span class="p_add">+	 * In order to stay compatible with sem_lock(), we must</span>
<span class="p_add">+	 * enter / leave complex_mode.</span>
 	 */
<span class="p_del">-	sem_wait_array(sma);</span>
<span class="p_add">+	complexmode_enter(sma);</span>
 
 	sem_otime = get_semotime(sma);
 
<span class="p_del">-	return seq_printf(s,</span>
<span class="p_del">-			  &quot;%10d %10d  %4o %10u %5u %5u %5u %5u %10lu %10lu\n&quot;,</span>
<span class="p_del">-			  sma-&gt;sem_perm.key,</span>
<span class="p_del">-			  sma-&gt;sem_perm.id,</span>
<span class="p_del">-			  sma-&gt;sem_perm.mode,</span>
<span class="p_del">-			  sma-&gt;sem_nsems,</span>
<span class="p_del">-			  from_kuid_munged(user_ns, sma-&gt;sem_perm.uid),</span>
<span class="p_del">-			  from_kgid_munged(user_ns, sma-&gt;sem_perm.gid),</span>
<span class="p_del">-			  from_kuid_munged(user_ns, sma-&gt;sem_perm.cuid),</span>
<span class="p_del">-			  from_kgid_munged(user_ns, sma-&gt;sem_perm.cgid),</span>
<span class="p_del">-			  sem_otime,</span>
<span class="p_del">-			  sma-&gt;sem_ctime);</span>
<span class="p_add">+	seq_printf(s,</span>
<span class="p_add">+		   &quot;%10d %10d  %4o %10u %5u %5u %5u %5u %10lu %10lu\n&quot;,</span>
<span class="p_add">+		   sma-&gt;sem_perm.key,</span>
<span class="p_add">+		   sma-&gt;sem_perm.id,</span>
<span class="p_add">+		   sma-&gt;sem_perm.mode,</span>
<span class="p_add">+		   sma-&gt;sem_nsems,</span>
<span class="p_add">+		   from_kuid_munged(user_ns, sma-&gt;sem_perm.uid),</span>
<span class="p_add">+		   from_kgid_munged(user_ns, sma-&gt;sem_perm.gid),</span>
<span class="p_add">+		   from_kuid_munged(user_ns, sma-&gt;sem_perm.cuid),</span>
<span class="p_add">+		   from_kgid_munged(user_ns, sma-&gt;sem_perm.cgid),</span>
<span class="p_add">+		   sem_otime,</span>
<span class="p_add">+		   sma-&gt;sem_ctime);</span>
<span class="p_add">+</span>
<span class="p_add">+	complexmode_tryleave(sma);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 #endif
<span class="p_header">diff --git a/ipc/shm.c b/ipc/shm.c</span>
<span class="p_header">index 9438ab9027dc..471f730e8640 100644</span>
<span class="p_header">--- a/ipc/shm.c</span>
<span class="p_header">+++ b/ipc/shm.c</span>
<span class="p_chunk">@@ -1337,25 +1337,27 @@</span> <span class="p_context"> static int sysvipc_shm_proc_show(struct seq_file *s, void *it)</span>
 #define SIZE_SPEC &quot;%21lu&quot;
 #endif
 
<span class="p_del">-	return seq_printf(s,</span>
<span class="p_del">-			  &quot;%10d %10d  %4o &quot; SIZE_SPEC &quot; %5u %5u  &quot;</span>
<span class="p_del">-			  &quot;%5lu %5u %5u %5u %5u %10lu %10lu %10lu &quot;</span>
<span class="p_del">-			  SIZE_SPEC &quot; &quot; SIZE_SPEC &quot;\n&quot;,</span>
<span class="p_del">-			  shp-&gt;shm_perm.key,</span>
<span class="p_del">-			  shp-&gt;shm_perm.id,</span>
<span class="p_del">-			  shp-&gt;shm_perm.mode,</span>
<span class="p_del">-			  shp-&gt;shm_segsz,</span>
<span class="p_del">-			  shp-&gt;shm_cprid,</span>
<span class="p_del">-			  shp-&gt;shm_lprid,</span>
<span class="p_del">-			  shp-&gt;shm_nattch,</span>
<span class="p_del">-			  from_kuid_munged(user_ns, shp-&gt;shm_perm.uid),</span>
<span class="p_del">-			  from_kgid_munged(user_ns, shp-&gt;shm_perm.gid),</span>
<span class="p_del">-			  from_kuid_munged(user_ns, shp-&gt;shm_perm.cuid),</span>
<span class="p_del">-			  from_kgid_munged(user_ns, shp-&gt;shm_perm.cgid),</span>
<span class="p_del">-			  shp-&gt;shm_atim,</span>
<span class="p_del">-			  shp-&gt;shm_dtim,</span>
<span class="p_del">-			  shp-&gt;shm_ctim,</span>
<span class="p_del">-			  rss * PAGE_SIZE,</span>
<span class="p_del">-			  swp * PAGE_SIZE);</span>
<span class="p_add">+	seq_printf(s,</span>
<span class="p_add">+		   &quot;%10d %10d  %4o &quot; SIZE_SPEC &quot; %5u %5u  &quot;</span>
<span class="p_add">+		   &quot;%5lu %5u %5u %5u %5u %10lu %10lu %10lu &quot;</span>
<span class="p_add">+		   SIZE_SPEC &quot; &quot; SIZE_SPEC &quot;\n&quot;,</span>
<span class="p_add">+		   shp-&gt;shm_perm.key,</span>
<span class="p_add">+		   shp-&gt;shm_perm.id,</span>
<span class="p_add">+		   shp-&gt;shm_perm.mode,</span>
<span class="p_add">+		   shp-&gt;shm_segsz,</span>
<span class="p_add">+		   shp-&gt;shm_cprid,</span>
<span class="p_add">+		   shp-&gt;shm_lprid,</span>
<span class="p_add">+		   shp-&gt;shm_nattch,</span>
<span class="p_add">+		   from_kuid_munged(user_ns, shp-&gt;shm_perm.uid),</span>
<span class="p_add">+		   from_kgid_munged(user_ns, shp-&gt;shm_perm.gid),</span>
<span class="p_add">+		   from_kuid_munged(user_ns, shp-&gt;shm_perm.cuid),</span>
<span class="p_add">+		   from_kgid_munged(user_ns, shp-&gt;shm_perm.cgid),</span>
<span class="p_add">+		   shp-&gt;shm_atim,</span>
<span class="p_add">+		   shp-&gt;shm_dtim,</span>
<span class="p_add">+		   shp-&gt;shm_ctim,</span>
<span class="p_add">+		   rss * PAGE_SIZE,</span>
<span class="p_add">+		   swp * PAGE_SIZE);</span>
<span class="p_add">+</span>
<span class="p_add">+	return 0;</span>
 }
 #endif
<span class="p_header">diff --git a/ipc/util.c b/ipc/util.c</span>
<span class="p_header">index a07ec27e1bfa..8085966a1d74 100644</span>
<span class="p_header">--- a/ipc/util.c</span>
<span class="p_header">+++ b/ipc/util.c</span>
<span class="p_chunk">@@ -877,8 +877,10 @@</span> <span class="p_context"> static int sysvipc_proc_show(struct seq_file *s, void *it)</span>
 	struct ipc_proc_iter *iter = s-&gt;private;
 	struct ipc_proc_iface *iface = iter-&gt;iface;
 
<span class="p_del">-	if (it == SEQ_START_TOKEN)</span>
<span class="p_del">-		return seq_puts(s, iface-&gt;header);</span>
<span class="p_add">+	if (it == SEQ_START_TOKEN) {</span>
<span class="p_add">+		seq_puts(s, iface-&gt;header);</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	}</span>
 
 	return iface-&gt;show(s, it);
 }
<span class="p_header">diff --git a/kernel/events/core.c b/kernel/events/core.c</span>
<span class="p_header">index db40ecd0b380..7413ddd1de57 100644</span>
<span class="p_header">--- a/kernel/events/core.c</span>
<span class="p_header">+++ b/kernel/events/core.c</span>
<span class="p_chunk">@@ -903,6 +903,77 @@</span> <span class="p_context"> static void put_ctx(struct perf_event_context *ctx)</span>
 }
 
 /*
<span class="p_add">+ * Because of perf_event::ctx migration in sys_perf_event_open::move_group and</span>
<span class="p_add">+ * perf_pmu_migrate_context() we need some magic.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Those places that change perf_event::ctx will hold both</span>
<span class="p_add">+ * perf_event_ctx::mutex of the &#39;old&#39; and &#39;new&#39; ctx value.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Lock ordering is by mutex address. There is one other site where</span>
<span class="p_add">+ * perf_event_context::mutex nests and that is put_event(). But remember that</span>
<span class="p_add">+ * that is a parent&lt;-&gt;child context relation, and migration does not affect</span>
<span class="p_add">+ * children, therefore these two orderings should not interact.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The change in perf_event::ctx does not affect children (as claimed above)</span>
<span class="p_add">+ * because the sys_perf_event_open() case will install a new event and break</span>
<span class="p_add">+ * the ctx parent&lt;-&gt;child relation, and perf_pmu_migrate_context() is only</span>
<span class="p_add">+ * concerned with cpuctx and that doesn&#39;t have children.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * The places that change perf_event::ctx will issue:</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *   perf_remove_from_context();</span>
<span class="p_add">+ *   synchronize_rcu();</span>
<span class="p_add">+ *   perf_install_in_context();</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * to affect the change. The remove_from_context() + synchronize_rcu() should</span>
<span class="p_add">+ * quiesce the event, after which we can install it in the new location. This</span>
<span class="p_add">+ * means that only external vectors (perf_fops, prctl) can perturb the event</span>
<span class="p_add">+ * while in transit. Therefore all such accessors should also acquire</span>
<span class="p_add">+ * perf_event_context::mutex to serialize against this.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * However; because event-&gt;ctx can change while we&#39;re waiting to acquire</span>
<span class="p_add">+ * ctx-&gt;mutex we must be careful and use the below perf_event_ctx_lock()</span>
<span class="p_add">+ * function.</span>
<span class="p_add">+ *</span>
<span class="p_add">+ * Lock order:</span>
<span class="p_add">+ *	task_struct::perf_event_mutex</span>
<span class="p_add">+ *	  perf_event_context::mutex</span>
<span class="p_add">+ *	    perf_event_context::lock</span>
<span class="p_add">+ *	    perf_event::child_mutex;</span>
<span class="p_add">+ *	    perf_event::mmap_mutex</span>
<span class="p_add">+ *	    mmap_sem</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct perf_event_context *perf_event_ctx_lock(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event_context *ctx;</span>
<span class="p_add">+</span>
<span class="p_add">+again:</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	ctx = ACCESS_ONCE(event-&gt;ctx);</span>
<span class="p_add">+	if (!atomic_inc_not_zero(&amp;ctx-&gt;refcount)) {</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+	if (event-&gt;ctx != ctx) {</span>
<span class="p_add">+		mutex_unlock(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+		put_ctx(ctx);</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return ctx;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+static void perf_event_ctx_unlock(struct perf_event *event,</span>
<span class="p_add">+				  struct perf_event_context *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	mutex_unlock(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+	put_ctx(ctx);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
  * This must be done under the ctx-&gt;lock, such as to serialize against
  * context_equiv(), therefore we cannot call put_ctx() since that might end up
  * calling scheduler related locks and ctx-&gt;lock nests inside those.
<span class="p_chunk">@@ -1606,7 +1677,7 @@</span> <span class="p_context"> int __perf_event_disable(void *info)</span>
  * is the current context on this CPU and preemption is disabled,
  * hence we can&#39;t get into perf_event_task_sched_out for this context.
  */
<span class="p_del">-void perf_event_disable(struct perf_event *event)</span>
<span class="p_add">+static void _perf_event_disable(struct perf_event *event)</span>
 {
 	struct perf_event_context *ctx = event-&gt;ctx;
 	struct task_struct *task = ctx-&gt;task;
<span class="p_chunk">@@ -1647,6 +1718,19 @@</span> <span class="p_context"> retry:</span>
 	}
 	raw_spin_unlock_irq(&amp;ctx-&gt;lock);
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Strictly speaking kernel users cannot create groups and therefore this</span>
<span class="p_add">+ * interface does not need the perf_event_ctx_lock() magic.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void perf_event_disable(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event_context *ctx;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctx = perf_event_ctx_lock(event);</span>
<span class="p_add">+	_perf_event_disable(event);</span>
<span class="p_add">+	perf_event_ctx_unlock(event, ctx);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(perf_event_disable);
 
 static void perf_set_shadow_time(struct perf_event *event,
<span class="p_chunk">@@ -2107,7 +2191,7 @@</span> <span class="p_context"> unlock:</span>
  * perf_event_for_each_child or perf_event_for_each as described
  * for perf_event_disable.
  */
<span class="p_del">-void perf_event_enable(struct perf_event *event)</span>
<span class="p_add">+static void _perf_event_enable(struct perf_event *event)</span>
 {
 	struct perf_event_context *ctx = event-&gt;ctx;
 	struct task_struct *task = ctx-&gt;task;
<span class="p_chunk">@@ -2163,9 +2247,21 @@</span> <span class="p_context"> retry:</span>
 out:
 	raw_spin_unlock_irq(&amp;ctx-&gt;lock);
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * See perf_event_disable();</span>
<span class="p_add">+ */</span>
<span class="p_add">+void perf_event_enable(struct perf_event *event)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event_context *ctx;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctx = perf_event_ctx_lock(event);</span>
<span class="p_add">+	_perf_event_enable(event);</span>
<span class="p_add">+	perf_event_ctx_unlock(event, ctx);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(perf_event_enable);
 
<span class="p_del">-int perf_event_refresh(struct perf_event *event, int refresh)</span>
<span class="p_add">+static int _perf_event_refresh(struct perf_event *event, int refresh)</span>
 {
 	/*
 	 * not supported on inherited events
<span class="p_chunk">@@ -2174,10 +2270,25 @@</span> <span class="p_context"> int perf_event_refresh(struct perf_event *event, int refresh)</span>
 		return -EINVAL;
 
 	atomic_add(refresh, &amp;event-&gt;event_limit);
<span class="p_del">-	perf_event_enable(event);</span>
<span class="p_add">+	_perf_event_enable(event);</span>
 
 	return 0;
 }
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * See perf_event_disable()</span>
<span class="p_add">+ */</span>
<span class="p_add">+int perf_event_refresh(struct perf_event *event, int refresh)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event_context *ctx;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctx = perf_event_ctx_lock(event);</span>
<span class="p_add">+	ret = _perf_event_refresh(event, refresh);</span>
<span class="p_add">+	perf_event_ctx_unlock(event, ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL_GPL(perf_event_refresh);
 
 static void ctx_sched_out(struct perf_event_context *ctx,
<span class="p_chunk">@@ -3373,7 +3484,16 @@</span> <span class="p_context"> static void put_event(struct perf_event *event)</span>
 	rcu_read_unlock();
 
 	if (owner) {
<span class="p_del">-		mutex_lock(&amp;owner-&gt;perf_event_mutex);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we&#39;re here through perf_event_exit_task() we&#39;re already</span>
<span class="p_add">+		 * holding ctx-&gt;mutex which would be an inversion wrt. the</span>
<span class="p_add">+		 * normal lock order.</span>
<span class="p_add">+		 *</span>
<span class="p_add">+		 * However we can safely take this lock because its the child</span>
<span class="p_add">+		 * ctx-&gt;mutex.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		mutex_lock_nested(&amp;owner-&gt;perf_event_mutex, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+</span>
 		/*
 		 * We have to re-check the event-&gt;owner field, if it is cleared
 		 * we raced with perf_event_exit_task(), acquiring the mutex
<span class="p_chunk">@@ -3449,12 +3569,13 @@</span> <span class="p_context"> static int perf_event_read_group(struct perf_event *event,</span>
 				   u64 read_format, char __user *buf)
 {
 	struct perf_event *leader = event-&gt;group_leader, *sub;
<span class="p_del">-	int n = 0, size = 0, ret = -EFAULT;</span>
 	struct perf_event_context *ctx = leader-&gt;ctx;
<span class="p_del">-	u64 values[5];</span>
<span class="p_add">+	int n = 0, size = 0, ret;</span>
 	u64 count, enabled, running;
<span class="p_add">+	u64 values[5];</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held(&amp;ctx-&gt;mutex);</span>
 
<span class="p_del">-	mutex_lock(&amp;ctx-&gt;mutex);</span>
 	count = perf_event_read_value(leader, &amp;enabled, &amp;running);
 
 	values[n++] = 1 + leader-&gt;nr_siblings;
<span class="p_chunk">@@ -3469,7 +3590,7 @@</span> <span class="p_context"> static int perf_event_read_group(struct perf_event *event,</span>
 	size = n * sizeof(u64);
 
 	if (copy_to_user(buf, values, size))
<span class="p_del">-		goto unlock;</span>
<span class="p_add">+		return -EFAULT;</span>
 
 	ret = size;
 
<span class="p_chunk">@@ -3483,14 +3604,11 @@</span> <span class="p_context"> static int perf_event_read_group(struct perf_event *event,</span>
 		size = n * sizeof(u64);
 
 		if (copy_to_user(buf + ret, values, size)) {
<span class="p_del">-			ret = -EFAULT;</span>
<span class="p_del">-			goto unlock;</span>
<span class="p_add">+			return -EFAULT;</span>
 		}
 
 		ret += size;
 	}
<span class="p_del">-unlock:</span>
<span class="p_del">-	mutex_unlock(&amp;ctx-&gt;mutex);</span>
 
 	return ret;
 }
<span class="p_chunk">@@ -3549,8 +3667,14 @@</span> <span class="p_context"> static ssize_t</span>
 perf_read(struct file *file, char __user *buf, size_t count, loff_t *ppos)
 {
 	struct perf_event *event = file-&gt;private_data;
<span class="p_add">+	struct perf_event_context *ctx;</span>
<span class="p_add">+	int ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctx = perf_event_ctx_lock(event);</span>
<span class="p_add">+	ret = perf_read_hw(event, buf, count);</span>
<span class="p_add">+	perf_event_ctx_unlock(event, ctx);</span>
 
<span class="p_del">-	return perf_read_hw(event, buf, count);</span>
<span class="p_add">+	return ret;</span>
 }
 
 static unsigned int perf_poll(struct file *file, poll_table *wait)
<span class="p_chunk">@@ -3574,7 +3698,7 @@</span> <span class="p_context"> static unsigned int perf_poll(struct file *file, poll_table *wait)</span>
 	return events;
 }
 
<span class="p_del">-static void perf_event_reset(struct perf_event *event)</span>
<span class="p_add">+static void _perf_event_reset(struct perf_event *event)</span>
 {
 	(void)perf_event_read(event);
 	local64_set(&amp;event-&gt;count, 0);
<span class="p_chunk">@@ -3593,6 +3717,7 @@</span> <span class="p_context"> static void perf_event_for_each_child(struct perf_event *event,</span>
 	struct perf_event *child;
 
 	WARN_ON_ONCE(event-&gt;ctx-&gt;parent_ctx);
<span class="p_add">+</span>
 	mutex_lock(&amp;event-&gt;child_mutex);
 	func(event);
 	list_for_each_entry(child, &amp;event-&gt;child_list, child_list)
<span class="p_chunk">@@ -3606,14 +3731,13 @@</span> <span class="p_context"> static void perf_event_for_each(struct perf_event *event,</span>
 	struct perf_event_context *ctx = event-&gt;ctx;
 	struct perf_event *sibling;
 
<span class="p_del">-	WARN_ON_ONCE(ctx-&gt;parent_ctx);</span>
<span class="p_del">-	mutex_lock(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+	lockdep_assert_held(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+</span>
 	event = event-&gt;group_leader;
 
 	perf_event_for_each_child(event, func);
 	list_for_each_entry(sibling, &amp;event-&gt;sibling_list, group_entry)
 		perf_event_for_each_child(sibling, func);
<span class="p_del">-	mutex_unlock(&amp;ctx-&gt;mutex);</span>
 }
 
 struct period_event {
<span class="p_chunk">@@ -3725,25 +3849,24 @@</span> <span class="p_context"> static int perf_event_set_output(struct perf_event *event,</span>
 				 struct perf_event *output_event);
 static int perf_event_set_filter(struct perf_event *event, void __user *arg);
 
<span class="p_del">-static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
<span class="p_add">+static long _perf_ioctl(struct perf_event *event, unsigned int cmd, unsigned long arg)</span>
 {
<span class="p_del">-	struct perf_event *event = file-&gt;private_data;</span>
 	void (*func)(struct perf_event *);
 	u32 flags = arg;
 
 	switch (cmd) {
 	case PERF_EVENT_IOC_ENABLE:
<span class="p_del">-		func = perf_event_enable;</span>
<span class="p_add">+		func = _perf_event_enable;</span>
 		break;
 	case PERF_EVENT_IOC_DISABLE:
<span class="p_del">-		func = perf_event_disable;</span>
<span class="p_add">+		func = _perf_event_disable;</span>
 		break;
 	case PERF_EVENT_IOC_RESET:
<span class="p_del">-		func = perf_event_reset;</span>
<span class="p_add">+		func = _perf_event_reset;</span>
 		break;
 
 	case PERF_EVENT_IOC_REFRESH:
<span class="p_del">-		return perf_event_refresh(event, arg);</span>
<span class="p_add">+		return _perf_event_refresh(event, arg);</span>
 
 	case PERF_EVENT_IOC_PERIOD:
 		return perf_event_period(event, (u64 __user *)arg);
<span class="p_chunk">@@ -3790,6 +3913,19 @@</span> <span class="p_context"> static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
 	return 0;
 }
 
<span class="p_add">+static long perf_ioctl(struct file *file, unsigned int cmd, unsigned long arg)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event *event = file-&gt;private_data;</span>
<span class="p_add">+	struct perf_event_context *ctx;</span>
<span class="p_add">+	long ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	ctx = perf_event_ctx_lock(event);</span>
<span class="p_add">+	ret = _perf_ioctl(event, cmd, arg);</span>
<span class="p_add">+	perf_event_ctx_unlock(event, ctx);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #ifdef CONFIG_COMPAT
 static long perf_compat_ioctl(struct file *file, unsigned int cmd,
 				unsigned long arg)
<span class="p_chunk">@@ -3812,11 +3948,15 @@</span> <span class="p_context"> static long perf_compat_ioctl(struct file *file, unsigned int cmd,</span>
 
 int perf_event_task_enable(void)
 {
<span class="p_add">+	struct perf_event_context *ctx;</span>
 	struct perf_event *event;
 
 	mutex_lock(&amp;current-&gt;perf_event_mutex);
<span class="p_del">-	list_for_each_entry(event, &amp;current-&gt;perf_event_list, owner_entry)</span>
<span class="p_del">-		perf_event_for_each_child(event, perf_event_enable);</span>
<span class="p_add">+	list_for_each_entry(event, &amp;current-&gt;perf_event_list, owner_entry) {</span>
<span class="p_add">+		ctx = perf_event_ctx_lock(event);</span>
<span class="p_add">+		perf_event_for_each_child(event, _perf_event_enable);</span>
<span class="p_add">+		perf_event_ctx_unlock(event, ctx);</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;current-&gt;perf_event_mutex);
 
 	return 0;
<span class="p_chunk">@@ -3824,11 +3964,15 @@</span> <span class="p_context"> int perf_event_task_enable(void)</span>
 
 int perf_event_task_disable(void)
 {
<span class="p_add">+	struct perf_event_context *ctx;</span>
 	struct perf_event *event;
 
 	mutex_lock(&amp;current-&gt;perf_event_mutex);
<span class="p_del">-	list_for_each_entry(event, &amp;current-&gt;perf_event_list, owner_entry)</span>
<span class="p_del">-		perf_event_for_each_child(event, perf_event_disable);</span>
<span class="p_add">+	list_for_each_entry(event, &amp;current-&gt;perf_event_list, owner_entry) {</span>
<span class="p_add">+		ctx = perf_event_ctx_lock(event);</span>
<span class="p_add">+		perf_event_for_each_child(event, _perf_event_disable);</span>
<span class="p_add">+		perf_event_ctx_unlock(event, ctx);</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;current-&gt;perf_event_mutex);
 
 	return 0;
<span class="p_chunk">@@ -5595,9 +5739,6 @@</span> <span class="p_context"> struct swevent_htable {</span>
 
 	/* Recursion avoidance in each contexts */
 	int				recursion[PERF_NR_CONTEXTS];
<span class="p_del">-</span>
<span class="p_del">-	/* Keeps track of cpu being initialized/exited */</span>
<span class="p_del">-	bool				online;</span>
 };
 
 static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);
<span class="p_chunk">@@ -5844,14 +5985,8 @@</span> <span class="p_context"> static int perf_swevent_add(struct perf_event *event, int flags)</span>
 	hwc-&gt;state = !(flags &amp; PERF_EF_START);
 
 	head = find_swevent_head(swhash, event);
<span class="p_del">-	if (!head) {</span>
<span class="p_del">-		/*</span>
<span class="p_del">-		 * We can race with cpu hotplug code. Do not</span>
<span class="p_del">-		 * WARN if the cpu just got unplugged.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		WARN_ON_ONCE(swhash-&gt;online);</span>
<span class="p_add">+	if (WARN_ON_ONCE(!head))</span>
 		return -EINVAL;
<span class="p_del">-	}</span>
 
 	hlist_add_head_rcu(&amp;event-&gt;hlist_entry, head);
 
<span class="p_chunk">@@ -5918,7 +6053,6 @@</span> <span class="p_context"> static int swevent_hlist_get_cpu(struct perf_event *event, int cpu)</span>
 	int err = 0;
 
 	mutex_lock(&amp;swhash-&gt;hlist_mutex);
<span class="p_del">-</span>
 	if (!swevent_hlist_deref(swhash) &amp;&amp; cpu_online(cpu)) {
 		struct swevent_hlist *hlist;
 
<span class="p_chunk">@@ -7168,6 +7302,46 @@</span> <span class="p_context"> out:</span>
 	return ret;
 }
 
<span class="p_add">+static void mutex_lock_double(struct mutex *a, struct mutex *b)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (b &lt; a)</span>
<span class="p_add">+		swap(a, b);</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock(a);</span>
<span class="p_add">+	mutex_lock_nested(b, SINGLE_DEPTH_NESTING);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
<span class="p_add">+/*</span>
<span class="p_add">+ * Variation on perf_event_ctx_lock_nested(), except we take two context</span>
<span class="p_add">+ * mutexes.</span>
<span class="p_add">+ */</span>
<span class="p_add">+static struct perf_event_context *</span>
<span class="p_add">+__perf_event_ctx_lock_double(struct perf_event *group_leader,</span>
<span class="p_add">+			     struct perf_event_context *ctx)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct perf_event_context *gctx;</span>
<span class="p_add">+</span>
<span class="p_add">+again:</span>
<span class="p_add">+	rcu_read_lock();</span>
<span class="p_add">+	gctx = ACCESS_ONCE(group_leader-&gt;ctx);</span>
<span class="p_add">+	if (!atomic_inc_not_zero(&amp;gctx-&gt;refcount)) {</span>
<span class="p_add">+		rcu_read_unlock();</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	rcu_read_unlock();</span>
<span class="p_add">+</span>
<span class="p_add">+	mutex_lock_double(&amp;gctx-&gt;mutex, &amp;ctx-&gt;mutex);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (group_leader-&gt;ctx != gctx) {</span>
<span class="p_add">+		mutex_unlock(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+		mutex_unlock(&amp;gctx-&gt;mutex);</span>
<span class="p_add">+		put_ctx(gctx);</span>
<span class="p_add">+		goto again;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	return gctx;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  * sys_perf_event_open - open a performance event, associate it to a task/cpu
  *
<span class="p_chunk">@@ -7183,7 +7357,7 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 	struct perf_event *group_leader = NULL, *output_event = NULL;
 	struct perf_event *event, *sibling;
 	struct perf_event_attr attr;
<span class="p_del">-	struct perf_event_context *ctx;</span>
<span class="p_add">+	struct perf_event_context *ctx, *uninitialized_var(gctx);</span>
 	struct file *event_file = NULL;
 	struct fd group = {NULL, 0};
 	struct task_struct *task = NULL;
<span class="p_chunk">@@ -7379,9 +7553,31 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 	}
 
 	if (move_group) {
<span class="p_del">-		struct perf_event_context *gctx = group_leader-&gt;ctx;</span>
<span class="p_add">+		gctx = __perf_event_ctx_lock_double(group_leader, ctx);</span>
 
<span class="p_del">-		mutex_lock(&amp;gctx-&gt;mutex);</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Check if we raced against another sys_perf_event_open() call</span>
<span class="p_add">+		 * moving the software group underneath us.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		if (!(group_leader-&gt;group_flags &amp; PERF_GROUP_SOFTWARE)) {</span>
<span class="p_add">+			/*</span>
<span class="p_add">+			 * If someone moved the group out from under us, check</span>
<span class="p_add">+			 * if this new event wound up on the same ctx, if so</span>
<span class="p_add">+			 * its the regular !move_group case, otherwise fail.</span>
<span class="p_add">+			 */</span>
<span class="p_add">+			if (gctx != ctx) {</span>
<span class="p_add">+				err = -EINVAL;</span>
<span class="p_add">+				goto err_locked;</span>
<span class="p_add">+			} else {</span>
<span class="p_add">+				perf_event_ctx_unlock(group_leader, gctx);</span>
<span class="p_add">+				move_group = 0;</span>
<span class="p_add">+			}</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * See perf_event_ctx_lock() for comments on the details</span>
<span class="p_add">+		 * of swizzling perf_event::ctx.</span>
<span class="p_add">+		 */</span>
 		perf_remove_from_context(group_leader, false);
 
 		/*
<span class="p_chunk">@@ -7396,15 +7592,19 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 			perf_event__state_init(sibling);
 			put_ctx(gctx);
 		}
<span class="p_del">-		mutex_unlock(&amp;gctx-&gt;mutex);</span>
<span class="p_del">-		put_ctx(gctx);</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		mutex_lock(&amp;ctx-&gt;mutex);</span>
 	}
 
 	WARN_ON_ONCE(ctx-&gt;parent_ctx);
<span class="p_del">-	mutex_lock(&amp;ctx-&gt;mutex);</span>
 
 	if (move_group) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Wait for everybody to stop referencing the events through</span>
<span class="p_add">+		 * the old lists, before installing it on new lists.</span>
<span class="p_add">+		 */</span>
 		synchronize_rcu();
<span class="p_add">+</span>
 		perf_install_in_context(ctx, group_leader, group_leader-&gt;cpu);
 		get_ctx(ctx);
 		list_for_each_entry(sibling, &amp;group_leader-&gt;sibling_list,
<span class="p_chunk">@@ -7416,6 +7616,11 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 
 	perf_install_in_context(ctx, event, event-&gt;cpu);
 	perf_unpin_context(ctx);
<span class="p_add">+</span>
<span class="p_add">+	if (move_group) {</span>
<span class="p_add">+		perf_event_ctx_unlock(group_leader, gctx);</span>
<span class="p_add">+		put_ctx(gctx);</span>
<span class="p_add">+	}</span>
 	mutex_unlock(&amp;ctx-&gt;mutex);
 
 	put_online_cpus();
<span class="p_chunk">@@ -7442,11 +7647,21 @@</span> <span class="p_context"> SYSCALL_DEFINE5(perf_event_open,</span>
 	fd_install(event_fd, event_file);
 	return event_fd;
 
<span class="p_add">+err_locked:</span>
<span class="p_add">+	if (move_group)</span>
<span class="p_add">+		perf_event_ctx_unlock(group_leader, gctx);</span>
<span class="p_add">+	mutex_unlock(&amp;ctx-&gt;mutex);</span>
<span class="p_add">+	fput(event_file);</span>
 err_context:
 	perf_unpin_context(ctx);
 	put_ctx(ctx);
 err_alloc:
<span class="p_del">-	free_event(event);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * If event_file is set, the fput() above will have called -&gt;release()</span>
<span class="p_add">+	 * and that will take care of freeing the event.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (!event_file)</span>
<span class="p_add">+		free_event(event);</span>
 err_cpus:
 	put_online_cpus();
 err_task:
<span class="p_chunk">@@ -7518,7 +7733,11 @@</span> <span class="p_context"> void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)</span>
 	src_ctx = &amp;per_cpu_ptr(pmu-&gt;pmu_cpu_context, src_cpu)-&gt;ctx;
 	dst_ctx = &amp;per_cpu_ptr(pmu-&gt;pmu_cpu_context, dst_cpu)-&gt;ctx;
 
<span class="p_del">-	mutex_lock(&amp;src_ctx-&gt;mutex);</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * See perf_event_ctx_lock() for comments on the details</span>
<span class="p_add">+	 * of swizzling perf_event::ctx.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	mutex_lock_double(&amp;src_ctx-&gt;mutex, &amp;dst_ctx-&gt;mutex);</span>
 	list_for_each_entry_safe(event, tmp, &amp;src_ctx-&gt;event_list,
 				 event_entry) {
 		perf_remove_from_context(event, false);
<span class="p_chunk">@@ -7526,11 +7745,9 @@</span> <span class="p_context"> void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)</span>
 		put_ctx(src_ctx);
 		list_add(&amp;event-&gt;migrate_entry, &amp;events);
 	}
<span class="p_del">-	mutex_unlock(&amp;src_ctx-&gt;mutex);</span>
 
 	synchronize_rcu();
 
<span class="p_del">-	mutex_lock(&amp;dst_ctx-&gt;mutex);</span>
 	list_for_each_entry_safe(event, tmp, &amp;events, migrate_entry) {
 		list_del(&amp;event-&gt;migrate_entry);
 		if (event-&gt;state &gt;= PERF_EVENT_STATE_OFF)
<span class="p_chunk">@@ -7540,6 +7757,7 @@</span> <span class="p_context"> void perf_pmu_migrate_context(struct pmu *pmu, int src_cpu, int dst_cpu)</span>
 		get_ctx(dst_ctx);
 	}
 	mutex_unlock(&amp;dst_ctx-&gt;mutex);
<span class="p_add">+	mutex_unlock(&amp;src_ctx-&gt;mutex);</span>
 }
 EXPORT_SYMBOL_GPL(perf_pmu_migrate_context);
 
<span class="p_chunk">@@ -8050,7 +8268,6 @@</span> <span class="p_context"> static void perf_event_init_cpu(int cpu)</span>
 	struct swevent_htable *swhash = &amp;per_cpu(swevent_htable, cpu);
 
 	mutex_lock(&amp;swhash-&gt;hlist_mutex);
<span class="p_del">-	swhash-&gt;online = true;</span>
 	if (swhash-&gt;hlist_refcount &gt; 0) {
 		struct swevent_hlist *hlist;
 
<span class="p_chunk">@@ -8103,14 +8320,7 @@</span> <span class="p_context"> static void perf_event_exit_cpu_context(int cpu)</span>
 
 static void perf_event_exit_cpu(int cpu)
 {
<span class="p_del">-	struct swevent_htable *swhash = &amp;per_cpu(swevent_htable, cpu);</span>
<span class="p_del">-</span>
 	perf_event_exit_cpu_context(cpu);
<span class="p_del">-</span>
<span class="p_del">-	mutex_lock(&amp;swhash-&gt;hlist_mutex);</span>
<span class="p_del">-	swhash-&gt;online = false;</span>
<span class="p_del">-	swevent_hlist_release(swhash);</span>
<span class="p_del">-	mutex_unlock(&amp;swhash-&gt;hlist_mutex);</span>
 }
 #else
 static inline void perf_event_exit_cpu(int cpu) { }
<span class="p_header">diff --git a/kernel/irq/generic-chip.c b/kernel/irq/generic-chip.c</span>
<span class="p_header">index 452d6f2ba21d..0e8e3dc7a289 100644</span>
<span class="p_header">--- a/kernel/irq/generic-chip.c</span>
<span class="p_header">+++ b/kernel/irq/generic-chip.c</span>
<span class="p_chunk">@@ -395,8 +395,30 @@</span> <span class="p_context"> static int irq_map_generic_chip(struct irq_domain *d, unsigned int virq,</span>
 	return 0;
 }
 
<span class="p_add">+static void irq_unmap_generic_chip(struct irq_domain *d, unsigned int virq)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct irq_data *data = irq_get_irq_data(virq);</span>
<span class="p_add">+	struct irq_domain_chip_generic *dgc = d-&gt;gc;</span>
<span class="p_add">+	unsigned int hw_irq = data-&gt;hwirq;</span>
<span class="p_add">+	struct irq_chip_generic *gc;</span>
<span class="p_add">+	int irq_idx;</span>
<span class="p_add">+</span>
<span class="p_add">+	gc = irq_get_domain_generic_chip(d, hw_irq);</span>
<span class="p_add">+	if (!gc)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	irq_idx = hw_irq % dgc-&gt;irqs_per_chip;</span>
<span class="p_add">+</span>
<span class="p_add">+	clear_bit(irq_idx, &amp;gc-&gt;installed);</span>
<span class="p_add">+	data-&gt;chip = &amp;no_irq_chip;</span>
<span class="p_add">+	data-&gt;chip_data = NULL;</span>
<span class="p_add">+	__irq_set_handler(virq, NULL, 0, NULL);</span>
<span class="p_add">+	irq_set_handler_data(virq, NULL);</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 struct irq_domain_ops irq_generic_chip_ops = {
 	.map	= irq_map_generic_chip,
<span class="p_add">+	.unmap  = irq_unmap_generic_chip,</span>
 	.xlate	= irq_domain_xlate_onetwocell,
 };
 EXPORT_SYMBOL_GPL(irq_generic_chip_ops);
<span class="p_header">diff --git a/kernel/locking/rtmutex.c b/kernel/locking/rtmutex.c</span>
<span class="p_header">index 3c9082036365..5b28de11e4c9 100644</span>
<span class="p_header">--- a/kernel/locking/rtmutex.c</span>
<span class="p_header">+++ b/kernel/locking/rtmutex.c</span>
<span class="p_chunk">@@ -65,8 +65,72 @@</span> <span class="p_context"> static inline void clear_rt_mutex_waiters(struct rt_mutex *lock)</span>
 
 static void fixup_rt_mutex_waiters(struct rt_mutex *lock)
 {
<span class="p_del">-	if (!rt_mutex_has_waiters(lock))</span>
<span class="p_del">-		clear_rt_mutex_waiters(lock);</span>
<span class="p_add">+	unsigned long owner, *p = (unsigned long *) &amp;lock-&gt;owner;</span>
<span class="p_add">+</span>
<span class="p_add">+	if (rt_mutex_has_waiters(lock))</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The rbtree has no waiters enqueued, now make sure that the</span>
<span class="p_add">+	 * lock-&gt;owner still has the waiters bit set, otherwise the</span>
<span class="p_add">+	 * following can happen:</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * CPU 0	CPU 1		CPU2</span>
<span class="p_add">+	 * l-&gt;owner=T1</span>
<span class="p_add">+	 *		rt_mutex_lock(l)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		l-&gt;owner = T1 | HAS_WAITERS;</span>
<span class="p_add">+	 *		enqueue(T2)</span>
<span class="p_add">+	 *		boost()</span>
<span class="p_add">+	 *		  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *		block()</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *				rt_mutex_lock(l)</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 *				l-&gt;owner = T1 | HAS_WAITERS;</span>
<span class="p_add">+	 *				enqueue(T3)</span>
<span class="p_add">+	 *				boost()</span>
<span class="p_add">+	 *				  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *				block()</span>
<span class="p_add">+	 *		signal(-&gt;T2)	signal(-&gt;T3)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		dequeue(T2)</span>
<span class="p_add">+	 *		deboost()</span>
<span class="p_add">+	 *		  unlock(l-&gt;lock)</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 *				dequeue(T3)</span>
<span class="p_add">+	 *				 ==&gt; wait list is empty</span>
<span class="p_add">+	 *				deboost()</span>
<span class="p_add">+	 *				 unlock(l-&gt;lock)</span>
<span class="p_add">+	 *		lock(l-&gt;lock)</span>
<span class="p_add">+	 *		fixup_rt_mutex_waiters()</span>
<span class="p_add">+	 *		  if (wait_list_empty(l) {</span>
<span class="p_add">+	 *		    l-&gt;owner = owner</span>
<span class="p_add">+	 *		    owner = l-&gt;owner &amp; ~HAS_WAITERS;</span>
<span class="p_add">+	 *		      ==&gt; l-&gt;owner = T1</span>
<span class="p_add">+	 *		  }</span>
<span class="p_add">+	 *				lock(l-&gt;lock)</span>
<span class="p_add">+	 * rt_mutex_unlock(l)		fixup_rt_mutex_waiters()</span>
<span class="p_add">+	 *				  if (wait_list_empty(l) {</span>
<span class="p_add">+	 *				    owner = l-&gt;owner &amp; ~HAS_WAITERS;</span>
<span class="p_add">+	 * cmpxchg(l-&gt;owner, T1, NULL)</span>
<span class="p_add">+	 *  ===&gt; Success (l-&gt;owner = NULL)</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 *				    l-&gt;owner = owner</span>
<span class="p_add">+	 *				      ==&gt; l-&gt;owner = T1</span>
<span class="p_add">+	 *				  }</span>
<span class="p_add">+	 *</span>
<span class="p_add">+	 * With the check for the waiter bit in place T3 on CPU2 will not</span>
<span class="p_add">+	 * overwrite. All tasks fiddling with the waiters bit are</span>
<span class="p_add">+	 * serialized by l-&gt;lock, so nothing else can modify the waiters</span>
<span class="p_add">+	 * bit. If the bit is set then nothing can change l-&gt;owner either</span>
<span class="p_add">+	 * so the simple RMW is safe. The cmpxchg() will simply fail if it</span>
<span class="p_add">+	 * happens in the middle of the RMW because the waiters bit is</span>
<span class="p_add">+	 * still set.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	owner = ACCESS_ONCE(*p);</span>
<span class="p_add">+	if (owner &amp; RT_MUTEX_HAS_WAITERS)</span>
<span class="p_add">+		ACCESS_ONCE(*p) = owner &amp; ~RT_MUTEX_HAS_WAITERS;</span>
 }
 
 /*
<span class="p_header">diff --git a/kernel/panic.c b/kernel/panic.c</span>
<span class="p_header">index 51266521e173..4de988c2aaec 100644</span>
<span class="p_header">--- a/kernel/panic.c</span>
<span class="p_header">+++ b/kernel/panic.c</span>
<span class="p_chunk">@@ -60,6 +60,32 @@</span> <span class="p_context"> void __weak panic_smp_self_stop(void)</span>
 		cpu_relax();
 }
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Stop other CPUs in panic.  Architecture dependent code may override this</span>
<span class="p_add">+ * with more suitable version.  For example, if the architecture supports</span>
<span class="p_add">+ * crash dump, it should save registers of each stopped CPU and disable</span>
<span class="p_add">+ * per-CPU features such as virtualization extensions.</span>
<span class="p_add">+ */</span>
<span class="p_add">+void __weak crash_smp_send_stop(void)</span>
<span class="p_add">+{</span>
<span class="p_add">+	static int cpus_stopped;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * This function can be called twice in panic path, but obviously</span>
<span class="p_add">+	 * we execute this only once.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	if (cpus_stopped)</span>
<span class="p_add">+		return;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * Note smp_send_stop is the usual smp shutdown function, which</span>
<span class="p_add">+	 * unfortunately means it may not be hardened to work in a panic</span>
<span class="p_add">+	 * situation.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+	smp_send_stop();</span>
<span class="p_add">+	cpus_stopped = 1;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 /**
  *	panic - halt the system
  *	@fmt: The text string to print
<span class="p_chunk">@@ -117,15 +143,23 @@</span> <span class="p_context"> void panic(const char *fmt, ...)</span>
 	 * If we want to run this after calling panic_notifiers, pass
 	 * the &quot;crash_kexec_post_notifiers&quot; option to the kernel.
 	 */
<span class="p_del">-	if (!crash_kexec_post_notifiers)</span>
<span class="p_add">+	if (!crash_kexec_post_notifiers) {</span>
 		crash_kexec(NULL);
 
<span class="p_del">-	/*</span>
<span class="p_del">-	 * Note smp_send_stop is the usual smp shutdown function, which</span>
<span class="p_del">-	 * unfortunately means it may not be hardened to work in a panic</span>
<span class="p_del">-	 * situation.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	smp_send_stop();</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * Note smp_send_stop is the usual smp shutdown function, which</span>
<span class="p_add">+		 * unfortunately means it may not be hardened to work in a</span>
<span class="p_add">+		 * panic situation.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		smp_send_stop();</span>
<span class="p_add">+	} else {</span>
<span class="p_add">+		/*</span>
<span class="p_add">+		 * If we want to do crash dump after notifier calls and</span>
<span class="p_add">+		 * kmsg_dump, we will need architecture dependent extra</span>
<span class="p_add">+		 * works in addition to stopping other CPUs.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		crash_smp_send_stop();</span>
<span class="p_add">+	}</span>
 
 	/*
 	 * Run any panic handlers, including those that might need to
<span class="p_header">diff --git a/kernel/power/suspend_test.c b/kernel/power/suspend_test.c</span>
<span class="p_header">index 269b097e78ea..743615bfdcec 100644</span>
<span class="p_header">--- a/kernel/power/suspend_test.c</span>
<span class="p_header">+++ b/kernel/power/suspend_test.c</span>
<span class="p_chunk">@@ -169,8 +169,10 @@</span> <span class="p_context"> static int __init test_suspend(void)</span>
 
 	/* RTCs have initialized by now too ... can we use one? */
 	dev = class_find_device(rtc_class, NULL, NULL, has_wakealarm);
<span class="p_del">-	if (dev)</span>
<span class="p_add">+	if (dev) {</span>
 		rtc = rtc_class_open(dev_name(dev));
<span class="p_add">+		put_device(dev);</span>
<span class="p_add">+	}</span>
 	if (!rtc) {
 		printk(warn_no_rtc);
 		goto done;
<span class="p_header">diff --git a/lib/genalloc.c b/lib/genalloc.c</span>
<span class="p_header">index bdb9a456bcbb..6d1e849007dc 100644</span>
<span class="p_header">--- a/lib/genalloc.c</span>
<span class="p_header">+++ b/lib/genalloc.c</span>
<span class="p_chunk">@@ -273,7 +273,7 @@</span> <span class="p_context"> unsigned long gen_pool_alloc(struct gen_pool *pool, size_t size)</span>
 	struct gen_pool_chunk *chunk;
 	unsigned long addr = 0;
 	int order = pool-&gt;min_alloc_order;
<span class="p_del">-	int nbits, start_bit = 0, end_bit, remain;</span>
<span class="p_add">+	int nbits, start_bit, end_bit, remain;</span>
 
 #ifndef CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG
 	BUG_ON(in_nmi());
<span class="p_chunk">@@ -288,6 +288,7 @@</span> <span class="p_context"> unsigned long gen_pool_alloc(struct gen_pool *pool, size_t size)</span>
 		if (size &gt; atomic_read(&amp;chunk-&gt;avail))
 			continue;
 
<span class="p_add">+		start_bit = 0;</span>
 		end_bit = chunk_size(chunk) &gt;&gt; order;
 retry:
 		start_bit = pool-&gt;algo(chunk-&gt;bits, end_bit, start_bit, nbits,
<span class="p_header">diff --git a/lib/mpi/mpi-pow.c b/lib/mpi/mpi-pow.c</span>
<span class="p_header">index 5464c8744ea9..e24388a863a7 100644</span>
<span class="p_header">--- a/lib/mpi/mpi-pow.c</span>
<span class="p_header">+++ b/lib/mpi/mpi-pow.c</span>
<span class="p_chunk">@@ -64,8 +64,13 @@</span> <span class="p_context"> int mpi_powm(MPI res, MPI base, MPI exp, MPI mod)</span>
 	if (!esize) {
 		/* Exponent is zero, result is 1 mod MOD, i.e., 1 or 0
 		 * depending on if MOD equals 1.  */
<span class="p_del">-		rp[0] = 1;</span>
 		res-&gt;nlimbs = (msize == 1 &amp;&amp; mod-&gt;d[0] == 1) ? 0 : 1;
<span class="p_add">+		if (res-&gt;nlimbs) {</span>
<span class="p_add">+			if (mpi_resize(res, 1) &lt; 0)</span>
<span class="p_add">+				goto enomem;</span>
<span class="p_add">+			rp = res-&gt;d;</span>
<span class="p_add">+			rp[0] = 1;</span>
<span class="p_add">+		}</span>
 		res-&gt;sign = 0;
 		goto leave;
 	}
<span class="p_header">diff --git a/mm/filemap.c b/mm/filemap.c</span>
<span class="p_header">index 076282561870..a5024d71fcc3 100644</span>
<span class="p_header">--- a/mm/filemap.c</span>
<span class="p_header">+++ b/mm/filemap.c</span>
<span class="p_chunk">@@ -545,7 +545,6 @@</span> <span class="p_context"> int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask)</span>
 		__delete_from_page_cache(old, NULL);
 		error = page_cache_tree_insert(mapping, new, NULL);
 		BUG_ON(error);
<span class="p_del">-		mapping-&gt;nrpages++;</span>
 		__inc_zone_page_state(new, NR_FILE_PAGES);
 		if (PageSwapBacked(new))
 			__inc_zone_page_state(new, NR_SHMEM);
<span class="p_chunk">@@ -1465,6 +1464,10 @@</span> <span class="p_context"> static ssize_t do_generic_file_read(struct file *filp, loff_t *ppos,</span>
 	unsigned int prev_offset;
 	int error = 0;
 
<span class="p_add">+	if (unlikely(*ppos &gt;= inode-&gt;i_sb-&gt;s_maxbytes))</span>
<span class="p_add">+		return 0;</span>
<span class="p_add">+	iov_iter_truncate(iter, inode-&gt;i_sb-&gt;s_maxbytes);</span>
<span class="p_add">+</span>
 	index = *ppos &gt;&gt; PAGE_CACHE_SHIFT;
 	prev_index = ra-&gt;prev_pos &gt;&gt; PAGE_CACHE_SHIFT;
 	prev_offset = ra-&gt;prev_pos &amp; (PAGE_CACHE_SIZE-1);
<span class="p_header">diff --git a/mm/hugetlb.c b/mm/hugetlb.c</span>
<span class="p_header">index 0225f1c6263a..fca6c6c91d76 100644</span>
<span class="p_header">--- a/mm/hugetlb.c</span>
<span class="p_header">+++ b/mm/hugetlb.c</span>
<span class="p_chunk">@@ -1067,37 +1067,54 @@</span> <span class="p_context"> static int free_pool_huge_page(struct hstate *h, nodemask_t *nodes_allowed,</span>
 
 /*
  * Dissolve a given free hugepage into free buddy pages. This function does
<span class="p_del">- * nothing for in-use (including surplus) hugepages.</span>
<span class="p_add">+ * nothing for in-use (including surplus) hugepages. Returns -EBUSY if the</span>
<span class="p_add">+ * number of free hugepages would be reduced below the number of reserved</span>
<span class="p_add">+ * hugepages.</span>
  */
<span class="p_del">-static void dissolve_free_huge_page(struct page *page)</span>
<span class="p_add">+static int dissolve_free_huge_page(struct page *page)</span>
 {
<span class="p_add">+	int rc = 0;</span>
<span class="p_add">+</span>
 	spin_lock(&amp;hugetlb_lock);
 	if (PageHuge(page) &amp;&amp; !page_count(page)) {
<span class="p_del">-		struct hstate *h = page_hstate(page);</span>
<span class="p_del">-		int nid = page_to_nid(page);</span>
<span class="p_del">-		list_del(&amp;page-&gt;lru);</span>
<span class="p_add">+		struct page *head = compound_head(page);</span>
<span class="p_add">+		struct hstate *h = page_hstate(head);</span>
<span class="p_add">+		int nid = page_to_nid(head);</span>
<span class="p_add">+		if (h-&gt;free_huge_pages - h-&gt;resv_huge_pages == 0) {</span>
<span class="p_add">+			rc = -EBUSY;</span>
<span class="p_add">+			goto out;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		list_del(&amp;head-&gt;lru);</span>
 		h-&gt;free_huge_pages--;
 		h-&gt;free_huge_pages_node[nid]--;
<span class="p_del">-		update_and_free_page(h, page);</span>
<span class="p_add">+		update_and_free_page(h, head);</span>
 	}
<span class="p_add">+out:</span>
 	spin_unlock(&amp;hugetlb_lock);
<span class="p_add">+	return rc;</span>
 }
 
 /*
  * Dissolve free hugepages in a given pfn range. Used by memory hotplug to
  * make specified memory blocks removable from the system.
<span class="p_del">- * Note that start_pfn should aligned with (minimum) hugepage size.</span>
<span class="p_add">+ * Note that this will dissolve a free gigantic hugepage completely, if any</span>
<span class="p_add">+ * part of it lies within the given range.</span>
<span class="p_add">+ * Also note that if dissolve_free_huge_page() returns with an error, all</span>
<span class="p_add">+ * free hugepages that were dissolved before that error are lost.</span>
  */
<span class="p_del">-void dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)</span>
<span class="p_add">+int dissolve_free_huge_pages(unsigned long start_pfn, unsigned long end_pfn)</span>
 {
 	unsigned long pfn;
<span class="p_add">+	int rc = 0;</span>
 
 	if (!hugepages_supported())
<span class="p_del">-		return;</span>
<span class="p_add">+		return rc;</span>
 
<span class="p_del">-	VM_BUG_ON(!IS_ALIGNED(start_pfn, 1 &lt;&lt; minimum_order));</span>
 	for (pfn = start_pfn; pfn &lt; end_pfn; pfn += 1 &lt;&lt; minimum_order)
<span class="p_del">-		dissolve_free_huge_page(pfn_to_page(pfn));</span>
<span class="p_add">+		if (rc = dissolve_free_huge_page(pfn_to_page(pfn)))</span>
<span class="p_add">+			break;</span>
<span class="p_add">+</span>
<span class="p_add">+	return rc;</span>
 }
 
 static struct page *alloc_buddy_huge_page(struct hstate *h, int nid)
<span class="p_header">diff --git a/mm/memory_hotplug.c b/mm/memory_hotplug.c</span>
<span class="p_header">index 4ec1d4d7521a..4174487a1261 100644</span>
<span class="p_header">--- a/mm/memory_hotplug.c</span>
<span class="p_header">+++ b/mm/memory_hotplug.c</span>
<span class="p_chunk">@@ -1732,7 +1732,9 @@</span> <span class="p_context"> repeat:</span>
 	 * dissolve free hugepages in the memory block before doing offlining
 	 * actually in order to make hugetlbfs&#39;s object counting consistent.
 	 */
<span class="p_del">-	dissolve_free_huge_pages(start_pfn, end_pfn);</span>
<span class="p_add">+	ret = dissolve_free_huge_pages(start_pfn, end_pfn);</span>
<span class="p_add">+	if (ret)</span>
<span class="p_add">+		goto failed_removal;</span>
 	/* check again */
 	offlined_pages = check_pages_isolated(start_pfn, end_pfn);
 	if (offlined_pages &lt; 0) {
<span class="p_header">diff --git a/mm/swapfile.c b/mm/swapfile.c</span>
<span class="p_header">index 4c524f7bd0bf..97235887cb5b 100644</span>
<span class="p_header">--- a/mm/swapfile.c</span>
<span class="p_header">+++ b/mm/swapfile.c</span>
<span class="p_chunk">@@ -2185,6 +2185,8 @@</span> <span class="p_context"> static unsigned long read_swap_header(struct swap_info_struct *p,</span>
 		swab32s(&amp;swap_header-&gt;info.version);
 		swab32s(&amp;swap_header-&gt;info.last_page);
 		swab32s(&amp;swap_header-&gt;info.nr_badpages);
<span class="p_add">+		if (swap_header-&gt;info.nr_badpages &gt; MAX_SWAP_BADPAGES)</span>
<span class="p_add">+			return 0;</span>
 		for (i = 0; i &lt; swap_header-&gt;info.nr_badpages; i++)
 			swab32s(&amp;swap_header-&gt;info.badpages[i]);
 	}
<span class="p_header">diff --git a/net/batman-adv/translation-table.c b/net/batman-adv/translation-table.c</span>
<span class="p_header">index 7da3f84fff2f..c93007d9c403 100644</span>
<span class="p_header">--- a/net/batman-adv/translation-table.c</span>
<span class="p_header">+++ b/net/batman-adv/translation-table.c</span>
<span class="p_chunk">@@ -2722,7 +2722,7 @@</span> <span class="p_context"> static bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,</span>
 							     &amp;tvlv_tt_data,
 							     &amp;tt_change,
 							     &amp;tt_len);
<span class="p_del">-		if (!tt_len)</span>
<span class="p_add">+		if (!tt_len || !tvlv_len)</span>
 			goto unlock;
 
 		/* Copy the last orig_node&#39;s OGM buffer */
<span class="p_chunk">@@ -2740,7 +2740,7 @@</span> <span class="p_context"> static bool batadv_send_my_tt_response(struct batadv_priv *bat_priv,</span>
 							     &amp;tvlv_tt_data,
 							     &amp;tt_change,
 							     &amp;tt_len);
<span class="p_del">-		if (!tt_len)</span>
<span class="p_add">+		if (!tt_len || !tvlv_len)</span>
 			goto out;
 
 		/* fill the rest of the tvlv with the real TT entries */
<span class="p_header">diff --git a/net/bridge/br_multicast.c b/net/bridge/br_multicast.c</span>
<span class="p_header">index 3b104a6d796c..3c594185de36 100644</span>
<span class="p_header">--- a/net/bridge/br_multicast.c</span>
<span class="p_header">+++ b/net/bridge/br_multicast.c</span>
<span class="p_chunk">@@ -928,13 +928,12 @@</span> <span class="p_context"> static void br_multicast_enable(struct bridge_mcast_own_query *query)</span>
 		mod_timer(&amp;query-&gt;timer, jiffies);
 }
 
<span class="p_del">-void br_multicast_enable_port(struct net_bridge_port *port)</span>
<span class="p_add">+static void __br_multicast_enable_port(struct net_bridge_port *port)</span>
 {
 	struct net_bridge *br = port-&gt;br;
 
<span class="p_del">-	spin_lock(&amp;br-&gt;multicast_lock);</span>
 	if (br-&gt;multicast_disabled || !netif_running(br-&gt;dev))
<span class="p_del">-		goto out;</span>
<span class="p_add">+		return;</span>
 
 	br_multicast_enable(&amp;port-&gt;ip4_own_query);
 #if IS_ENABLED(CONFIG_IPV6)
<span class="p_chunk">@@ -942,8 +941,14 @@</span> <span class="p_context"> void br_multicast_enable_port(struct net_bridge_port *port)</span>
 #endif
 	if (port-&gt;multicast_router == 2 &amp;&amp; hlist_unhashed(&amp;port-&gt;rlist))
 		br_multicast_add_router(br, port);
<span class="p_add">+}</span>
 
<span class="p_del">-out:</span>
<span class="p_add">+void br_multicast_enable_port(struct net_bridge_port *port)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct net_bridge *br = port-&gt;br;</span>
<span class="p_add">+</span>
<span class="p_add">+	spin_lock(&amp;br-&gt;multicast_lock);</span>
<span class="p_add">+	__br_multicast_enable_port(port);</span>
 	spin_unlock(&amp;br-&gt;multicast_lock);
 }
 
<span class="p_chunk">@@ -2047,8 +2052,9 @@</span> <span class="p_context"> static void br_multicast_start_querier(struct net_bridge *br,</span>
 
 int br_multicast_toggle(struct net_bridge *br, unsigned long val)
 {
<span class="p_del">-	int err = 0;</span>
 	struct net_bridge_mdb_htable *mdb;
<span class="p_add">+	struct net_bridge_port *port;</span>
<span class="p_add">+	int err = 0;</span>
 
 	spin_lock_bh(&amp;br-&gt;multicast_lock);
 	if (br-&gt;multicast_disabled == !val)
<span class="p_chunk">@@ -2076,10 +2082,9 @@</span> <span class="p_context"> rollback:</span>
 			goto rollback;
 	}
 
<span class="p_del">-	br_multicast_start_querier(br, &amp;br-&gt;ip4_own_query);</span>
<span class="p_del">-#if IS_ENABLED(CONFIG_IPV6)</span>
<span class="p_del">-	br_multicast_start_querier(br, &amp;br-&gt;ip6_own_query);</span>
<span class="p_del">-#endif</span>
<span class="p_add">+	br_multicast_open(br);</span>
<span class="p_add">+	list_for_each_entry(port, &amp;br-&gt;port_list, list)</span>
<span class="p_add">+		__br_multicast_enable_port(port);</span>
 
 unlock:
 	spin_unlock_bh(&amp;br-&gt;multicast_lock);
<span class="p_header">diff --git a/net/can/bcm.c b/net/can/bcm.c</span>
<span class="p_header">index dcb75c0e66c1..b96434d09177 100644</span>
<span class="p_header">--- a/net/can/bcm.c</span>
<span class="p_header">+++ b/net/can/bcm.c</span>
<span class="p_chunk">@@ -1499,24 +1499,31 @@</span> <span class="p_context"> static int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,</span>
 	struct sockaddr_can *addr = (struct sockaddr_can *)uaddr;
 	struct sock *sk = sock-&gt;sk;
 	struct bcm_sock *bo = bcm_sk(sk);
<span class="p_add">+	int ret = 0;</span>
 
 	if (len &lt; sizeof(*addr))
 		return -EINVAL;
 
<span class="p_del">-	if (bo-&gt;bound)</span>
<span class="p_del">-		return -EISCONN;</span>
<span class="p_add">+	lock_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	if (bo-&gt;bound) {</span>
<span class="p_add">+		ret = -EISCONN;</span>
<span class="p_add">+		goto fail;</span>
<span class="p_add">+	}</span>
 
 	/* bind a device to this socket */
 	if (addr-&gt;can_ifindex) {
 		struct net_device *dev;
 
 		dev = dev_get_by_index(&amp;init_net, addr-&gt;can_ifindex);
<span class="p_del">-		if (!dev)</span>
<span class="p_del">-			return -ENODEV;</span>
<span class="p_del">-</span>
<span class="p_add">+		if (!dev) {</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto fail;</span>
<span class="p_add">+		}</span>
 		if (dev-&gt;type != ARPHRD_CAN) {
 			dev_put(dev);
<span class="p_del">-			return -ENODEV;</span>
<span class="p_add">+			ret = -ENODEV;</span>
<span class="p_add">+			goto fail;</span>
 		}
 
 		bo-&gt;ifindex = dev-&gt;ifindex;
<span class="p_chunk">@@ -1527,17 +1534,24 @@</span> <span class="p_context"> static int bcm_connect(struct socket *sock, struct sockaddr *uaddr, int len,</span>
 		bo-&gt;ifindex = 0;
 	}
 
<span class="p_del">-	bo-&gt;bound = 1;</span>
<span class="p_del">-</span>
 	if (proc_dir) {
 		/* unique socket address as filename */
 		sprintf(bo-&gt;procname, &quot;%lu&quot;, sock_i_ino(sk));
 		bo-&gt;bcm_proc_read = proc_create_data(bo-&gt;procname, 0644,
 						     proc_dir,
 						     &amp;bcm_proc_fops, sk);
<span class="p_add">+		if (!bo-&gt;bcm_proc_read) {</span>
<span class="p_add">+			ret = -ENOMEM;</span>
<span class="p_add">+			goto fail;</span>
<span class="p_add">+		}</span>
 	}
 
<span class="p_del">-	return 0;</span>
<span class="p_add">+	bo-&gt;bound = 1;</span>
<span class="p_add">+</span>
<span class="p_add">+fail:</span>
<span class="p_add">+	release_sock(sk);</span>
<span class="p_add">+</span>
<span class="p_add">+	return ret;</span>
 }
 
 static int bcm_recvmsg(struct kiocb *iocb, struct socket *sock,
<span class="p_header">diff --git a/net/can/raw.c b/net/can/raw.c</span>
<span class="p_header">index 081e81fd017f..9f5ee3a6b666 100644</span>
<span class="p_header">--- a/net/can/raw.c</span>
<span class="p_header">+++ b/net/can/raw.c</span>
<span class="p_chunk">@@ -466,6 +466,9 @@</span> <span class="p_context"> static int raw_setsockopt(struct socket *sock, int level, int optname,</span>
 		if (optlen % sizeof(struct can_filter) != 0)
 			return -EINVAL;
 
<span class="p_add">+		if (optlen &gt; CAN_RAW_FILTER_MAX * sizeof(struct can_filter))</span>
<span class="p_add">+			return -EINVAL;</span>
<span class="p_add">+</span>
 		count = optlen / sizeof(struct can_filter);
 
 		if (count &gt; 1) {
<span class="p_header">diff --git a/net/core/filter.c b/net/core/filter.c</span>
<span class="p_header">index b275c5559dc0..fd6da397ea8c 100644</span>
<span class="p_header">--- a/net/core/filter.c</span>
<span class="p_header">+++ b/net/core/filter.c</span>
<span class="p_chunk">@@ -94,9 +94,10 @@</span> <span class="p_context"> static inline void *load_pointer(const struct sk_buff *skb, int k,</span>
 }
 
 /**
<span class="p_del">- *	sk_filter - run a packet through a socket filter</span>
<span class="p_add">+ *	sk_filter_trim_cap - run a packet through a socket filter</span>
  *	@sk: sock associated with &amp;sk_buff
  *	@skb: buffer to filter
<span class="p_add">+ *	@cap: limit on how short the eBPF program may trim the packet</span>
  *
  * Run the filter code and then cut skb-&gt;data to correct size returned by
  * sk_run_filter. If pkt_len is 0 we toss packet. If skb-&gt;len is smaller
<span class="p_chunk">@@ -105,7 +106,7 @@</span> <span class="p_context"> static inline void *load_pointer(const struct sk_buff *skb, int k,</span>
  * be accepted or -EPERM if the packet should be tossed.
  *
  */
<span class="p_del">-int sk_filter(struct sock *sk, struct sk_buff *skb)</span>
<span class="p_add">+int sk_filter_trim_cap(struct sock *sk, struct sk_buff *skb, unsigned int cap)</span>
 {
 	int err;
 	struct sk_filter *filter;
<span class="p_chunk">@@ -126,14 +127,13 @@</span> <span class="p_context"> int sk_filter(struct sock *sk, struct sk_buff *skb)</span>
 	filter = rcu_dereference(sk-&gt;sk_filter);
 	if (filter) {
 		unsigned int pkt_len = SK_RUN_FILTER(filter, skb);
<span class="p_del">-</span>
<span class="p_del">-		err = pkt_len ? pskb_trim(skb, pkt_len) : -EPERM;</span>
<span class="p_add">+		err = pkt_len ? pskb_trim(skb, max(cap, pkt_len)) : -EPERM;</span>
 	}
 	rcu_read_unlock();
 
 	return err;
 }
<span class="p_del">-EXPORT_SYMBOL(sk_filter);</span>
<span class="p_add">+EXPORT_SYMBOL(sk_filter_trim_cap);</span>
 
 /* Base function for offset calculation. Needs to go into .text section,
  * therefore keeping it non-static as well; will also be used by JITs
<span class="p_header">diff --git a/net/core/rtnetlink.c b/net/core/rtnetlink.c</span>
<span class="p_header">index e4666af74141..96e9c5f51704 100644</span>
<span class="p_header">--- a/net/core/rtnetlink.c</span>
<span class="p_header">+++ b/net/core/rtnetlink.c</span>
<span class="p_chunk">@@ -250,6 +250,7 @@</span> <span class="p_context"> int rtnl_unregister(int protocol, int msgtype)</span>
 
 	rtnl_msg_handlers[protocol][msgindex].doit = NULL;
 	rtnl_msg_handlers[protocol][msgindex].dumpit = NULL;
<span class="p_add">+	rtnl_msg_handlers[protocol][msgindex].calcit = NULL;</span>
 
 	return 0;
 }
<span class="p_chunk">@@ -793,12 +794,13 @@</span> <span class="p_context"> static inline int rtnl_vfinfo_size(const struct net_device *dev,</span>
 	if (dev-&gt;dev.parent &amp;&amp; dev_is_pci(dev-&gt;dev.parent) &amp;&amp;
 	    (ext_filter_mask &amp; RTEXT_FILTER_VF)) {
 		int num_vfs = dev_num_vf(dev-&gt;dev.parent);
<span class="p_del">-		size_t size = nla_total_size(sizeof(struct nlattr));</span>
<span class="p_del">-		size += nla_total_size(num_vfs * sizeof(struct nlattr));</span>
<span class="p_add">+		size_t size = nla_total_size(0);</span>
 		size += num_vfs *
<span class="p_del">-			(nla_total_size(sizeof(struct ifla_vf_mac)) +</span>
<span class="p_add">+			(nla_total_size(0) +</span>
<span class="p_add">+			 nla_total_size(sizeof(struct ifla_vf_mac)) +</span>
 			 nla_total_size(sizeof(struct ifla_vf_vlan)) +
 			 nla_total_size(sizeof(struct ifla_vf_spoofchk)) +
<span class="p_add">+			 nla_total_size(sizeof(struct ifla_vf_tx_rate)) +</span>
 			 nla_total_size(sizeof(struct ifla_vf_rate)) +
 			 nla_total_size(sizeof(struct ifla_vf_link_state)));
 		return size;
<span class="p_header">diff --git a/net/core/sock.c b/net/core/sock.c</span>
<span class="p_header">index ac9aa2878d99..9cb00d1ea140 100644</span>
<span class="p_header">--- a/net/core/sock.c</span>
<span class="p_header">+++ b/net/core/sock.c</span>
<span class="p_chunk">@@ -432,9 +432,8 @@</span> <span class="p_context"> static void sock_disable_timestamp(struct sock *sk, unsigned long flags)</span>
 }
 
 
<span class="p_del">-int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
<span class="p_add">+int __sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 {
<span class="p_del">-	int err;</span>
 	int skb_len;
 	unsigned long flags;
 	struct sk_buff_head *list = &amp;sk-&gt;sk_receive_queue;
<span class="p_chunk">@@ -445,10 +444,6 @@</span> <span class="p_context"> int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 		return -ENOMEM;
 	}
 
<span class="p_del">-	err = sk_filter(sk, skb);</span>
<span class="p_del">-	if (err)</span>
<span class="p_del">-		return err;</span>
<span class="p_del">-</span>
 	if (!sk_rmem_schedule(sk, skb, skb-&gt;truesize)) {
 		atomic_inc(&amp;sk-&gt;sk_drops);
 		return -ENOBUFS;
<span class="p_chunk">@@ -478,13 +473,26 @@</span> <span class="p_context"> int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
 		sk-&gt;sk_data_ready(sk);
 	return 0;
 }
<span class="p_add">+EXPORT_SYMBOL(__sock_queue_rcv_skb);</span>
<span class="p_add">+</span>
<span class="p_add">+int sock_queue_rcv_skb(struct sock *sk, struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = sk_filter(sk, skb);</span>
<span class="p_add">+	if (err)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	return __sock_queue_rcv_skb(sk, skb);</span>
<span class="p_add">+}</span>
 EXPORT_SYMBOL(sock_queue_rcv_skb);
 
<span class="p_del">-int sk_receive_skb(struct sock *sk, struct sk_buff *skb, const int nested)</span>
<span class="p_add">+int __sk_receive_skb(struct sock *sk, struct sk_buff *skb,</span>
<span class="p_add">+		     const int nested, unsigned int trim_cap)</span>
 {
 	int rc = NET_RX_SUCCESS;
 
<span class="p_del">-	if (sk_filter(sk, skb))</span>
<span class="p_add">+	if (sk_filter_trim_cap(sk, skb, trim_cap))</span>
 		goto discard_and_relse;
 
 	skb-&gt;dev = NULL;
<span class="p_chunk">@@ -520,7 +528,7 @@</span> <span class="p_context"> discard_and_relse:</span>
 	kfree_skb(skb);
 	goto out;
 }
<span class="p_del">-EXPORT_SYMBOL(sk_receive_skb);</span>
<span class="p_add">+EXPORT_SYMBOL(__sk_receive_skb);</span>
 
 struct dst_entry *__sk_dst_check(struct sock *sk, u32 cookie)
 {
<span class="p_chunk">@@ -741,7 +749,7 @@</span> <span class="p_context"> int sock_setsockopt(struct socket *sock, int level, int optname,</span>
 		val = min_t(u32, val, sysctl_wmem_max);
 set_sndbuf:
 		sk-&gt;sk_userlocks |= SOCK_SNDBUF_LOCK;
<span class="p_del">-		sk-&gt;sk_sndbuf = max_t(u32, val * 2, SOCK_MIN_SNDBUF);</span>
<span class="p_add">+		sk-&gt;sk_sndbuf = max_t(int, val * 2, SOCK_MIN_SNDBUF);</span>
 		/* Wake up sending tasks if we upped the value. */
 		sk-&gt;sk_write_space(sk);
 		break;
<span class="p_chunk">@@ -777,7 +785,7 @@</span> <span class="p_context"> set_rcvbuf:</span>
 		 * returning the value we actually used in getsockopt
 		 * is the most desirable behavior.
 		 */
<span class="p_del">-		sk-&gt;sk_rcvbuf = max_t(u32, val * 2, SOCK_MIN_RCVBUF);</span>
<span class="p_add">+		sk-&gt;sk_rcvbuf = max_t(int, val * 2, SOCK_MIN_RCVBUF);</span>
 		break;
 
 	case SO_RCVBUFFORCE:
<span class="p_header">diff --git a/net/dccp/ipv4.c b/net/dccp/ipv4.c</span>
<span class="p_header">index 6ca645c4b48e..b371341d899d 100644</span>
<span class="p_header">--- a/net/dccp/ipv4.c</span>
<span class="p_header">+++ b/net/dccp/ipv4.c</span>
<span class="p_chunk">@@ -890,7 +890,7 @@</span> <span class="p_context"> static int dccp_v4_rcv(struct sk_buff *skb)</span>
 		goto discard_and_relse;
 	nf_reset(skb);
 
<span class="p_del">-	return sk_receive_skb(sk, skb, 1);</span>
<span class="p_add">+	return __sk_receive_skb(sk, skb, 1, dh-&gt;dccph_doff * 4);</span>
 
 no_dccp_socket:
 	if (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))
<span class="p_header">diff --git a/net/dccp/ipv6.c b/net/dccp/ipv6.c</span>
<span class="p_header">index 1149e345bba9..9f2dc1d15e43 100644</span>
<span class="p_header">--- a/net/dccp/ipv6.c</span>
<span class="p_header">+++ b/net/dccp/ipv6.c</span>
<span class="p_chunk">@@ -804,7 +804,7 @@</span> <span class="p_context"> static int dccp_v6_rcv(struct sk_buff *skb)</span>
 	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_and_relse;
 
<span class="p_del">-	return sk_receive_skb(sk, skb, 1) ? -1 : 0;</span>
<span class="p_add">+	return __sk_receive_skb(sk, skb, 1, dh-&gt;dccph_doff * 4) ? -1 : 0;</span>
 
 no_dccp_socket:
 	if (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))
<span class="p_header">diff --git a/net/ipv4/ip_output.c b/net/ipv4/ip_output.c</span>
<span class="p_header">index d91fda8257bc..edab725feccc 100644</span>
<span class="p_header">--- a/net/ipv4/ip_output.c</span>
<span class="p_header">+++ b/net/ipv4/ip_output.c</span>
<span class="p_chunk">@@ -97,6 +97,8 @@</span> <span class="p_context"> int __ip_local_out(struct sk_buff *skb)</span>
 
 	iph-&gt;tot_len = htons(skb-&gt;len);
 	ip_send_check(iph);
<span class="p_add">+	skb-&gt;protocol = htons(ETH_P_IP);</span>
<span class="p_add">+</span>
 	return nf_hook(NFPROTO_IPV4, NF_INET_LOCAL_OUT, skb, NULL,
 		       skb_dst(skb)-&gt;dev, dst_output);
 }
<span class="p_chunk">@@ -217,9 +219,8 @@</span> <span class="p_context"> static int ip_finish_output_gso(struct sk_buff *skb)</span>
 	struct sk_buff *segs;
 	int ret = 0;
 
<span class="p_del">-	/* common case: locally created skb or seglen is &lt;= mtu */</span>
<span class="p_del">-	if (((IPCB(skb)-&gt;flags &amp; IPSKB_FORWARDED) == 0) ||</span>
<span class="p_del">-	      skb_gso_network_seglen(skb) &lt;= ip_skb_dst_mtu(skb))</span>
<span class="p_add">+	/* common case: seglen is &lt;= mtu */</span>
<span class="p_add">+	if (skb_gso_network_seglen(skb) &lt;= ip_skb_dst_mtu(skb))</span>
 		return ip_finish_output2(skb);
 
 	/* Slowpath -  GSO segment length is exceeding the dst MTU.
<span class="p_header">diff --git a/net/ipv4/ip_sockglue.c b/net/ipv4/ip_sockglue.c</span>
<span class="p_header">index c7ec866adac9..cf377702852d 100644</span>
<span class="p_header">--- a/net/ipv4/ip_sockglue.c</span>
<span class="p_header">+++ b/net/ipv4/ip_sockglue.c</span>
<span class="p_chunk">@@ -242,9 +242,12 @@</span> <span class="p_context"> int ip_cmsg_send(struct net *net, struct msghdr *msg, struct ipcm_cookie *ipc,</span>
 			ipc-&gt;ttl = val;
 			break;
 		case IP_TOS:
<span class="p_del">-			if (cmsg-&gt;cmsg_len != CMSG_LEN(sizeof(int)))</span>
<span class="p_add">+			if (cmsg-&gt;cmsg_len == CMSG_LEN(sizeof(int)))</span>
<span class="p_add">+				val = *(int *)CMSG_DATA(cmsg);</span>
<span class="p_add">+			else if (cmsg-&gt;cmsg_len == CMSG_LEN(sizeof(u8)))</span>
<span class="p_add">+				val = *(u8 *)CMSG_DATA(cmsg);</span>
<span class="p_add">+			else</span>
 				return -EINVAL;
<span class="p_del">-			val = *(int *)CMSG_DATA(cmsg);</span>
 			if (val &lt; 0 || val &gt; 255)
 				return -EINVAL;
 			ipc-&gt;tos = val;
<span class="p_header">diff --git a/net/ipv4/netfilter/arp_tables.c b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">index 106db177a91c..15019c2408c2 100644</span>
<span class="p_header">--- a/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_header">+++ b/net/ipv4/netfilter/arp_tables.c</span>
<span class="p_chunk">@@ -1332,8 +1332,8 @@</span> <span class="p_context"> static int translate_compat_table(struct xt_table_info **pinfo,</span>
 
 	newinfo-&gt;number = compatr-&gt;num_entries;
 	for (i = 0; i &lt; NF_ARP_NUMHOOKS; i++) {
<span class="p_del">-		newinfo-&gt;hook_entry[i] = info-&gt;hook_entry[i];</span>
<span class="p_del">-		newinfo-&gt;underflow[i] = info-&gt;underflow[i];</span>
<span class="p_add">+		newinfo-&gt;hook_entry[i] = compatr-&gt;hook_entry[i];</span>
<span class="p_add">+		newinfo-&gt;underflow[i] = compatr-&gt;underflow[i];</span>
 	}
 	entry1 = newinfo-&gt;entries[raw_smp_processor_id()];
 	pos = entry1;
<span class="p_header">diff --git a/net/ipv4/ping.c b/net/ipv4/ping.c</span>
<span class="p_header">index 9c68e94cd66d..181d5de8ba52 100644</span>
<span class="p_header">--- a/net/ipv4/ping.c</span>
<span class="p_header">+++ b/net/ipv4/ping.c</span>
<span class="p_chunk">@@ -661,6 +661,10 @@</span> <span class="p_context"> int ping_common_sendmsg(int family, struct msghdr *msg, size_t len,</span>
 	if (len &gt; 0xFFFF)
 		return -EMSGSIZE;
 
<span class="p_add">+	/* Must have at least a full ICMP header. */</span>
<span class="p_add">+	if (len &lt; icmph_len)</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+</span>
 	/*
 	 *	Check the flags.
 	 */
<span class="p_header">diff --git a/net/ipv4/route.c b/net/ipv4/route.c</span>
<span class="p_header">index 2548c2274cb8..7cd37b04f3a6 100644</span>
<span class="p_header">--- a/net/ipv4/route.c</span>
<span class="p_header">+++ b/net/ipv4/route.c</span>
<span class="p_chunk">@@ -746,8 +746,10 @@</span> <span class="p_context"> static void __ip_do_redirect(struct rtable *rt, struct sk_buff *skb, struct flow</span>
 			goto reject_redirect;
 	}
 
<span class="p_del">-	n = ipv4_neigh_lookup(&amp;rt-&gt;dst, NULL, &amp;new_gw);</span>
<span class="p_del">-	if (n) {</span>
<span class="p_add">+	n = __ipv4_neigh_lookup(rt-&gt;dst.dev, new_gw);</span>
<span class="p_add">+	if (!n)</span>
<span class="p_add">+		n = neigh_create(&amp;arp_tbl, &amp;new_gw, rt-&gt;dst.dev);</span>
<span class="p_add">+	if (!IS_ERR(n)) {</span>
 		if (!(n-&gt;nud_state &amp; NUD_VALID)) {
 			neigh_event_send(n, NULL);
 		} else {
<span class="p_header">diff --git a/net/ipv4/sysctl_net_ipv4.c b/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_header">index 79a007c52558..e1ceafe68cb1 100644</span>
<span class="p_header">--- a/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/sysctl_net_ipv4.c</span>
<span class="p_chunk">@@ -90,11 +90,11 @@</span> <span class="p_context"> static void inet_get_ping_group_range_table(struct ctl_table *table, kgid_t *low</span>
 		container_of(table-&gt;data, struct net, ipv4.ping_group_range.range);
 	unsigned int seq;
 	do {
<span class="p_del">-		seq = read_seqbegin(&amp;net-&gt;ipv4.ip_local_ports.lock);</span>
<span class="p_add">+		seq = read_seqbegin(&amp;net-&gt;ipv4.ping_group_range.lock);</span>
 
 		*low = data[0];
 		*high = data[1];
<span class="p_del">-	} while (read_seqretry(&amp;net-&gt;ipv4.ip_local_ports.lock, seq));</span>
<span class="p_add">+	} while (read_seqretry(&amp;net-&gt;ipv4.ping_group_range.lock, seq));</span>
 }
 
 /* Update system visible IP port range */
<span class="p_chunk">@@ -103,10 +103,10 @@</span> <span class="p_context"> static void set_ping_group_range(struct ctl_table *table, kgid_t low, kgid_t hig</span>
 	kgid_t *data = table-&gt;data;
 	struct net *net =
 		container_of(table-&gt;data, struct net, ipv4.ping_group_range.range);
<span class="p_del">-	write_seqlock(&amp;net-&gt;ipv4.ip_local_ports.lock);</span>
<span class="p_add">+	write_seqlock(&amp;net-&gt;ipv4.ping_group_range.lock);</span>
 	data[0] = low;
 	data[1] = high;
<span class="p_del">-	write_sequnlock(&amp;net-&gt;ipv4.ip_local_ports.lock);</span>
<span class="p_add">+	write_sequnlock(&amp;net-&gt;ipv4.ping_group_range.lock);</span>
 }
 
 /* Validate changes from /proc interface. */
<span class="p_header">diff --git a/net/ipv4/tcp_ipv4.c b/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">index 6b4c3e3639bf..f66f033c51fe 100644</span>
<span class="p_header">--- a/net/ipv4/tcp_ipv4.c</span>
<span class="p_header">+++ b/net/ipv4/tcp_ipv4.c</span>
<span class="p_chunk">@@ -1697,6 +1697,21 @@</span> <span class="p_context"> bool tcp_prequeue(struct sock *sk, struct sk_buff *skb)</span>
 }
 EXPORT_SYMBOL(tcp_prequeue);
 
<span class="p_add">+int tcp_filter(struct sock *sk, struct sk_buff *skb)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct tcphdr *th = (struct tcphdr *)skb-&gt;data;</span>
<span class="p_add">+	unsigned int eaten = skb-&gt;len;</span>
<span class="p_add">+	int err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = sk_filter_trim_cap(sk, skb, th-&gt;doff * 4);</span>
<span class="p_add">+	if (!err) {</span>
<span class="p_add">+		eaten -= skb-&gt;len;</span>
<span class="p_add">+		TCP_SKB_CB(skb)-&gt;end_seq -= eaten;</span>
<span class="p_add">+	}</span>
<span class="p_add">+	return err;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL(tcp_filter);</span>
<span class="p_add">+</span>
 /*
  *	From tcp_input.c
  */
<span class="p_chunk">@@ -1760,8 +1775,10 @@</span> <span class="p_context"> process:</span>
 		goto discard_and_relse;
 	nf_reset(skb);
 
<span class="p_del">-	if (sk_filter(sk, skb))</span>
<span class="p_add">+	if (tcp_filter(sk, skb))</span>
 		goto discard_and_relse;
<span class="p_add">+	th = (const struct tcphdr *)skb-&gt;data;</span>
<span class="p_add">+	iph = ip_hdr(skb);</span>
 
 	sk_mark_napi_id(sk, skb);
 	skb-&gt;dev = NULL;
<span class="p_header">diff --git a/net/ipv6/addrconf.c b/net/ipv6/addrconf.c</span>
<span class="p_header">index 213fc4f9b265..011a4c710c94 100644</span>
<span class="p_header">--- a/net/ipv6/addrconf.c</span>
<span class="p_header">+++ b/net/ipv6/addrconf.c</span>
<span class="p_chunk">@@ -2692,7 +2692,7 @@</span> <span class="p_context"> static void init_loopback(struct net_device *dev)</span>
 				 * lo device down, release this obsolete dst and
 				 * reallocate a new router for ifa.
 				 */
<span class="p_del">-				if (sp_ifa-&gt;rt-&gt;dst.obsolete &gt; 0) {</span>
<span class="p_add">+				if (!atomic_read(&amp;sp_ifa-&gt;rt-&gt;rt6i_ref)) {</span>
 					ip6_rt_put(sp_ifa-&gt;rt);
 					sp_ifa-&gt;rt = NULL;
 				} else {
<span class="p_header">diff --git a/net/ipv6/ip6_output.c b/net/ipv6/ip6_output.c</span>
<span class="p_header">index 0fdda4d8b75d..cdd0bc79383a 100644</span>
<span class="p_header">--- a/net/ipv6/ip6_output.c</span>
<span class="p_header">+++ b/net/ipv6/ip6_output.c</span>
<span class="p_chunk">@@ -1296,7 +1296,7 @@</span> <span class="p_context"> emsgsize:</span>
 	if (((length &gt; mtu) ||
 	     (skb &amp;&amp; skb_is_gso(skb))) &amp;&amp;
 	    (sk-&gt;sk_protocol == IPPROTO_UDP) &amp;&amp;
<span class="p_del">-	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp;</span>
<span class="p_add">+	    (rt-&gt;dst.dev-&gt;features &amp; NETIF_F_UFO) &amp;&amp; !rt-&gt;dst.header_len &amp;&amp;</span>
 	    (sk-&gt;sk_type == SOCK_DGRAM)) {
 		err = ip6_ufo_append_data(sk, getfrag, from, length,
 					  hh_len, fragheaderlen, exthdrlen,
<span class="p_header">diff --git a/net/ipv6/output_core.c b/net/ipv6/output_core.c</span>
<span class="p_header">index 1d4156ddf355..1e987e68e510 100644</span>
<span class="p_header">--- a/net/ipv6/output_core.c</span>
<span class="p_header">+++ b/net/ipv6/output_core.c</span>
<span class="p_chunk">@@ -114,6 +114,8 @@</span> <span class="p_context"> int __ip6_local_out(struct sk_buff *skb)</span>
 	ipv6_hdr(skb)-&gt;payload_len = htons(len);
 	IP6CB(skb)-&gt;nhoff = offsetof(struct ipv6hdr, nexthdr);
 
<span class="p_add">+	skb-&gt;protocol = htons(ETH_P_IPV6);</span>
<span class="p_add">+</span>
 	return nf_hook(NFPROTO_IPV6, NF_INET_LOCAL_OUT, skb, NULL,
 		       skb_dst(skb)-&gt;dev, dst_output);
 }
<span class="p_header">diff --git a/net/ipv6/tcp_ipv6.c b/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">index 427d164aad46..c6c921d15de4 100644</span>
<span class="p_header">--- a/net/ipv6/tcp_ipv6.c</span>
<span class="p_header">+++ b/net/ipv6/tcp_ipv6.c</span>
<span class="p_chunk">@@ -1359,7 +1359,7 @@</span> <span class="p_context"> static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)</span>
 		goto discard;
 #endif
 
<span class="p_del">-	if (sk_filter(sk, skb))</span>
<span class="p_add">+	if (tcp_filter(sk, skb))</span>
 		goto discard;
 
 	/*
<span class="p_chunk">@@ -1531,8 +1531,10 @@</span> <span class="p_context"> process:</span>
 	if (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))
 		goto discard_and_relse;
 
<span class="p_del">-	if (sk_filter(sk, skb))</span>
<span class="p_add">+	if (tcp_filter(sk, skb))</span>
 		goto discard_and_relse;
<span class="p_add">+	th = (const struct tcphdr *)skb-&gt;data;</span>
<span class="p_add">+	hdr = ipv6_hdr(skb);</span>
 
 	sk_mark_napi_id(sk, skb);
 	skb-&gt;dev = NULL;
<span class="p_header">diff --git a/net/l2tp/l2tp_ip.c b/net/l2tp/l2tp_ip.c</span>
<span class="p_header">index e45d2b77bb42..5d53249a2e84 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip.c</span>
<span class="p_chunk">@@ -251,8 +251,6 @@</span> <span class="p_context"> static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	int ret;
 	int chk_addr_ret;
 
<span class="p_del">-	if (!sock_flag(sk, SOCK_ZAPPED))</span>
<span class="p_del">-		return -EINVAL;</span>
 	if (addr_len &lt; sizeof(struct sockaddr_l2tpip))
 		return -EINVAL;
 	if (addr-&gt;l2tp_family != AF_INET)
<span class="p_chunk">@@ -267,6 +265,9 @@</span> <span class="p_context"> static int l2tp_ip_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	read_unlock_bh(&amp;l2tp_ip_lock);
 
 	lock_sock(sk);
<span class="p_add">+	if (!sock_flag(sk, SOCK_ZAPPED))</span>
<span class="p_add">+		goto out;</span>
<span class="p_add">+</span>
 	if (sk-&gt;sk_state != TCP_CLOSE || addr_len &lt; sizeof(struct sockaddr_l2tpip))
 		goto out;
 
<span class="p_header">diff --git a/net/l2tp/l2tp_ip6.c b/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">index 45808d916b7e..a6e69677a6a1 100644</span>
<span class="p_header">--- a/net/l2tp/l2tp_ip6.c</span>
<span class="p_header">+++ b/net/l2tp/l2tp_ip6.c</span>
<span class="p_chunk">@@ -266,8 +266,6 @@</span> <span class="p_context"> static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	int addr_type;
 	int err;
 
<span class="p_del">-	if (!sock_flag(sk, SOCK_ZAPPED))</span>
<span class="p_del">-		return -EINVAL;</span>
 	if (addr-&gt;l2tp_family != AF_INET6)
 		return -EINVAL;
 	if (addr_len &lt; sizeof(*addr))
<span class="p_chunk">@@ -293,6 +291,9 @@</span> <span class="p_context"> static int l2tp_ip6_bind(struct sock *sk, struct sockaddr *uaddr, int addr_len)</span>
 	lock_sock(sk);
 
 	err = -EINVAL;
<span class="p_add">+	if (!sock_flag(sk, SOCK_ZAPPED))</span>
<span class="p_add">+		goto out_unlock;</span>
<span class="p_add">+</span>
 	if (sk-&gt;sk_state != TCP_CLOSE)
 		goto out_unlock;
 
<span class="p_header">diff --git a/net/mac80211/rx.c b/net/mac80211/rx.c</span>
<span class="p_header">index 94d816b52e56..bf25f1399c6c 100644</span>
<span class="p_header">--- a/net/mac80211/rx.c</span>
<span class="p_header">+++ b/net/mac80211/rx.c</span>
<span class="p_chunk">@@ -2008,16 +2008,22 @@</span> <span class="p_context"> ieee80211_rx_h_amsdu(struct ieee80211_rx_data *rx)</span>
 	if (!(status-&gt;rx_flags &amp; IEEE80211_RX_AMSDU))
 		return RX_CONTINUE;
 
<span class="p_del">-	if (ieee80211_has_a4(hdr-&gt;frame_control) &amp;&amp;</span>
<span class="p_del">-	    rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN &amp;&amp;</span>
<span class="p_del">-	    !rx-&gt;sdata-&gt;u.vlan.sta)</span>
<span class="p_del">-		return RX_DROP_UNUSABLE;</span>
<span class="p_add">+	if (unlikely(ieee80211_has_a4(hdr-&gt;frame_control))) {</span>
<span class="p_add">+		switch (rx-&gt;sdata-&gt;vif.type) {</span>
<span class="p_add">+		case NL80211_IFTYPE_AP_VLAN:</span>
<span class="p_add">+			if (!rx-&gt;sdata-&gt;u.vlan.sta)</span>
<span class="p_add">+				return RX_DROP_UNUSABLE;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		case NL80211_IFTYPE_STATION:</span>
<span class="p_add">+			if (!rx-&gt;sdata-&gt;u.mgd.use_4addr)</span>
<span class="p_add">+				return RX_DROP_UNUSABLE;</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		default:</span>
<span class="p_add">+			return RX_DROP_UNUSABLE;</span>
<span class="p_add">+		}</span>
<span class="p_add">+	}</span>
 
<span class="p_del">-	if (is_multicast_ether_addr(hdr-&gt;addr1) &amp;&amp;</span>
<span class="p_del">-	    ((rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_AP_VLAN &amp;&amp;</span>
<span class="p_del">-	      rx-&gt;sdata-&gt;u.vlan.sta) ||</span>
<span class="p_del">-	     (rx-&gt;sdata-&gt;vif.type == NL80211_IFTYPE_STATION &amp;&amp;</span>
<span class="p_del">-	      rx-&gt;sdata-&gt;u.mgd.use_4addr)))</span>
<span class="p_add">+	if (is_multicast_ether_addr(hdr-&gt;addr1))</span>
 		return RX_DROP_UNUSABLE;
 
 	skb-&gt;dev = dev;
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_core.c b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">index 054638c824dd..cdd47388723b 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_core.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_core.c</span>
<span class="p_chunk">@@ -726,6 +726,7 @@</span> <span class="p_context"> nf_conntrack_tuple_taken(const struct nf_conntrack_tuple *tuple,</span>
 	 * least once for the stats anyway.
 	 */
 	rcu_read_lock_bh();
<span class="p_add">+ begin:</span>
 	hlist_nulls_for_each_entry_rcu(h, n, &amp;net-&gt;ct.hash[hash], hnnode) {
 		ct = nf_ct_tuplehash_to_ctrack(h);
 		if (ct != ignored_conntrack &amp;&amp;
<span class="p_chunk">@@ -737,6 +738,12 @@</span> <span class="p_context"> nf_conntrack_tuple_taken(const struct nf_conntrack_tuple *tuple,</span>
 		}
 		NF_CT_STAT_INC(net, searched);
 	}
<span class="p_add">+</span>
<span class="p_add">+	if (get_nulls_value(n) != hash) {</span>
<span class="p_add">+		NF_CT_STAT_INC(net, search_restart);</span>
<span class="p_add">+		goto begin;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
 	rcu_read_unlock_bh();
 
 	return 0;
<span class="p_header">diff --git a/net/netfilter/nf_conntrack_sip.c b/net/netfilter/nf_conntrack_sip.c</span>
<span class="p_header">index 4c3ba1c8d682..32ba99ca6030 100644</span>
<span class="p_header">--- a/net/netfilter/nf_conntrack_sip.c</span>
<span class="p_header">+++ b/net/netfilter/nf_conntrack_sip.c</span>
<span class="p_chunk">@@ -1434,9 +1434,12 @@</span> <span class="p_context"> static int process_sip_request(struct sk_buff *skb, unsigned int protoff,</span>
 		handler = &amp;sip_handlers[i];
 		if (handler-&gt;request == NULL)
 			continue;
<span class="p_del">-		if (*datalen &lt; handler-&gt;len ||</span>
<span class="p_add">+		if (*datalen &lt; handler-&gt;len + 2 ||</span>
 		    strnicmp(*dptr, handler-&gt;method, handler-&gt;len))
 			continue;
<span class="p_add">+		if ((*dptr)[handler-&gt;len] != &#39; &#39; ||</span>
<span class="p_add">+		    !isalpha((*dptr)[handler-&gt;len+1]))</span>
<span class="p_add">+			continue;</span>
 
 		if (ct_sip_get_header(ct, *dptr, 0, *datalen, SIP_HDR_CSEQ,
 				      &amp;matchoff, &amp;matchlen) &lt;= 0) {
<span class="p_header">diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c</span>
<span class="p_header">index 3ea4109486ce..0ae0662ce385 100644</span>
<span class="p_header">--- a/net/netfilter/nf_tables_api.c</span>
<span class="p_header">+++ b/net/netfilter/nf_tables_api.c</span>
<span class="p_chunk">@@ -2642,12 +2642,14 @@</span> <span class="p_context"> static int nf_tables_newset(struct sock *nlsk, struct sk_buff *skb,</span>
 
 	err = nft_trans_set_add(&amp;ctx, NFT_MSG_NEWSET, set);
 	if (err &lt; 0)
<span class="p_del">-		goto err2;</span>
<span class="p_add">+		goto err3;</span>
 
 	list_add_tail_rcu(&amp;set-&gt;list, &amp;table-&gt;sets);
 	table-&gt;use++;
 	return 0;
 
<span class="p_add">+err3:</span>
<span class="p_add">+	ops-&gt;destroy(set);</span>
 err2:
 	kfree(set);
 err1:
<span class="p_chunk">@@ -3712,6 +3714,31 @@</span> <span class="p_context"> static int nf_tables_check_loops(const struct nft_ctx *ctx,</span>
 }
 
 /**
<span class="p_add">+ *	nft_parse_u32_check - fetch u32 attribute and check for maximum value</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	@attr: netlink attribute to fetch value from</span>
<span class="p_add">+ *	@max: maximum value to be stored in dest</span>
<span class="p_add">+ *	@dest: pointer to the variable</span>
<span class="p_add">+ *</span>
<span class="p_add">+ *	Parse, check and store a given u32 netlink attribute into variable.</span>
<span class="p_add">+ *	This function returns -ERANGE if the value goes over maximum value.</span>
<span class="p_add">+ *	Otherwise a 0 is returned and the attribute value is stored in the</span>
<span class="p_add">+ *	destination variable.</span>
<span class="p_add">+ */</span>
<span class="p_add">+int nft_parse_u32_check(const struct nlattr *attr, int max, u32 *dest)</span>
<span class="p_add">+{</span>
<span class="p_add">+	u32 val;</span>
<span class="p_add">+</span>
<span class="p_add">+	val = ntohl(nla_get_be32(attr));</span>
<span class="p_add">+	if (val &gt; max)</span>
<span class="p_add">+		return -ERANGE;</span>
<span class="p_add">+</span>
<span class="p_add">+	*dest = val;</span>
<span class="p_add">+	return 0;</span>
<span class="p_add">+}</span>
<span class="p_add">+EXPORT_SYMBOL_GPL(nft_parse_u32_check);</span>
<span class="p_add">+</span>
<span class="p_add">+/**</span>
  *	nft_validate_input_register - validate an expressions&#39; input register
  *
  *	@reg: the register number
<span class="p_header">diff --git a/net/netfilter/nfnetlink.c b/net/netfilter/nfnetlink.c</span>
<span class="p_header">index cddab2101569..1123af4ad66c 100644</span>
<span class="p_header">--- a/net/netfilter/nfnetlink.c</span>
<span class="p_header">+++ b/net/netfilter/nfnetlink.c</span>
<span class="p_chunk">@@ -273,10 +273,11 @@</span> <span class="p_context"> replay:</span>
 		nlh = nlmsg_hdr(skb);
 		err = 0;
 
<span class="p_del">-		if (nlmsg_len(nlh) &lt; sizeof(struct nfgenmsg) ||</span>
<span class="p_del">-		    skb-&gt;len &lt; nlh-&gt;nlmsg_len) {</span>
<span class="p_del">-			err = -EINVAL;</span>
<span class="p_del">-			goto ack;</span>
<span class="p_add">+		if (nlh-&gt;nlmsg_len &lt; NLMSG_HDRLEN ||</span>
<span class="p_add">+		    skb-&gt;len &lt; nlh-&gt;nlmsg_len ||</span>
<span class="p_add">+		    nlmsg_len(nlh) &lt; sizeof(struct nfgenmsg)) {</span>
<span class="p_add">+			success = false;</span>
<span class="p_add">+			goto done;</span>
 		}
 
 		/* Only requests are handled by the kernel */
<span class="p_header">diff --git a/net/netfilter/nft_bitwise.c b/net/netfilter/nft_bitwise.c</span>
<span class="p_header">index 4fb6ee2c1106..c9e847ff6451 100644</span>
<span class="p_header">--- a/net/netfilter/nft_bitwise.c</span>
<span class="p_header">+++ b/net/netfilter/nft_bitwise.c</span>
<span class="p_chunk">@@ -54,6 +54,7 @@</span> <span class="p_context"> static int nft_bitwise_init(const struct nft_ctx *ctx,</span>
 {
 	struct nft_bitwise *priv = nft_expr_priv(expr);
 	struct nft_data_desc d1, d2;
<span class="p_add">+	u32 len;</span>
 	int err;
 
 	if (tb[NFTA_BITWISE_SREG] == NULL ||
<span class="p_chunk">@@ -76,7 +77,11 @@</span> <span class="p_context"> static int nft_bitwise_init(const struct nft_ctx *ctx,</span>
 	if (err &lt; 0)
 		return err;
 
<span class="p_del">-	priv-&gt;len = ntohl(nla_get_be32(tb[NFTA_BITWISE_LEN]));</span>
<span class="p_add">+	err = nft_parse_u32_check(tb[NFTA_BITWISE_LEN], U8_MAX, &amp;len);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;len = len;</span>
 
 	err = nft_data_init(NULL, &amp;priv-&gt;mask, &amp;d1, tb[NFTA_BITWISE_MASK]);
 	if (err &lt; 0)
<span class="p_header">diff --git a/net/netfilter/nft_byteorder.c b/net/netfilter/nft_byteorder.c</span>
<span class="p_header">index c39ed8d29df1..a21d4167e807 100644</span>
<span class="p_header">--- a/net/netfilter/nft_byteorder.c</span>
<span class="p_header">+++ b/net/netfilter/nft_byteorder.c</span>
<span class="p_chunk">@@ -78,6 +78,7 @@</span> <span class="p_context"> static int nft_byteorder_init(const struct nft_ctx *ctx,</span>
 			      const struct nlattr * const tb[])
 {
 	struct nft_byteorder *priv = nft_expr_priv(expr);
<span class="p_add">+	u32 size, len;</span>
 	int err;
 
 	if (tb[NFTA_BYTEORDER_SREG] == NULL ||
<span class="p_chunk">@@ -109,11 +110,21 @@</span> <span class="p_context"> static int nft_byteorder_init(const struct nft_ctx *ctx,</span>
 		return -EINVAL;
 	}
 
<span class="p_del">-	priv-&gt;len = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_LEN]));</span>
<span class="p_add">+	err = nft_parse_u32_check(tb[NFTA_BYTEORDER_LEN], U8_MAX, &amp;len);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;len = len;</span>
<span class="p_add">+</span>
 	if (priv-&gt;len == 0 || priv-&gt;len &gt; FIELD_SIZEOF(struct nft_data, data))
 		return -EINVAL;
 
<span class="p_del">-	priv-&gt;size = ntohl(nla_get_be32(tb[NFTA_BYTEORDER_SIZE]));</span>
<span class="p_add">+	err = nft_parse_u32_check(tb[NFTA_BYTEORDER_SIZE], U8_MAX, &amp;size);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	priv-&gt;size = size;</span>
<span class="p_add">+</span>
 	switch (priv-&gt;size) {
 	case 2:
 	case 4:
<span class="p_header">diff --git a/net/netfilter/nft_cmp.c b/net/netfilter/nft_cmp.c</span>
<span class="p_header">index e2b3f51c81f1..109b91deb69a 100644</span>
<span class="p_header">--- a/net/netfilter/nft_cmp.c</span>
<span class="p_header">+++ b/net/netfilter/nft_cmp.c</span>
<span class="p_chunk">@@ -81,6 +81,9 @@</span> <span class="p_context"> static int nft_cmp_init(const struct nft_ctx *ctx, const struct nft_expr *expr,</span>
 	err = nft_data_init(NULL, &amp;priv-&gt;data, &amp;desc, tb[NFTA_CMP_DATA]);
 	BUG_ON(err &lt; 0);
 
<span class="p_add">+	if (desc.len &gt; U8_MAX)</span>
<span class="p_add">+		return -ERANGE;</span>
<span class="p_add">+</span>
 	priv-&gt;len = desc.len;
 	return 0;
 }
<span class="p_header">diff --git a/net/netfilter/nft_exthdr.c b/net/netfilter/nft_exthdr.c</span>
<span class="p_header">index 55c939f5371f..cc9681a81266 100644</span>
<span class="p_header">--- a/net/netfilter/nft_exthdr.c</span>
<span class="p_header">+++ b/net/netfilter/nft_exthdr.c</span>
<span class="p_chunk">@@ -59,6 +59,7 @@</span> <span class="p_context"> static int nft_exthdr_init(const struct nft_ctx *ctx,</span>
 {
 	struct nft_exthdr *priv = nft_expr_priv(expr);
 	int err;
<span class="p_add">+	u32 offset, len;</span>
 
 	if (tb[NFTA_EXTHDR_DREG] == NULL ||
 	    tb[NFTA_EXTHDR_TYPE] == NULL ||
<span class="p_chunk">@@ -66,9 +67,17 @@</span> <span class="p_context"> static int nft_exthdr_init(const struct nft_ctx *ctx,</span>
 	    tb[NFTA_EXTHDR_LEN] == NULL)
 		return -EINVAL;
 
<span class="p_add">+	err = nft_parse_u32_check(tb[NFTA_EXTHDR_OFFSET], U8_MAX, &amp;offset);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
<span class="p_add">+	err = nft_parse_u32_check(tb[NFTA_EXTHDR_LEN], U8_MAX, &amp;len);</span>
<span class="p_add">+	if (err &lt; 0)</span>
<span class="p_add">+		return err;</span>
<span class="p_add">+</span>
 	priv-&gt;type   = nla_get_u8(tb[NFTA_EXTHDR_TYPE]);
<span class="p_del">-	priv-&gt;offset = ntohl(nla_get_be32(tb[NFTA_EXTHDR_OFFSET]));</span>
<span class="p_del">-	priv-&gt;len    = ntohl(nla_get_be32(tb[NFTA_EXTHDR_LEN]));</span>
<span class="p_add">+	priv-&gt;offset = offset;</span>
<span class="p_add">+	priv-&gt;len    = len;</span>
 	if (priv-&gt;len == 0 ||
 	    priv-&gt;len &gt; FIELD_SIZEOF(struct nft_data, data))
 		return -EINVAL;
<span class="p_header">diff --git a/net/netfilter/nft_immediate.c b/net/netfilter/nft_immediate.c</span>
<span class="p_header">index 810385eb7249..ff679d808837 100644</span>
<span class="p_header">--- a/net/netfilter/nft_immediate.c</span>
<span class="p_header">+++ b/net/netfilter/nft_immediate.c</span>
<span class="p_chunk">@@ -57,6 +57,10 @@</span> <span class="p_context"> static int nft_immediate_init(const struct nft_ctx *ctx,</span>
 	err = nft_data_init(ctx, &amp;priv-&gt;data, &amp;desc, tb[NFTA_IMMEDIATE_DATA]);
 	if (err &lt; 0)
 		return err;
<span class="p_add">+</span>
<span class="p_add">+	if (desc.len &gt; U8_MAX)</span>
<span class="p_add">+		return -ERANGE;</span>
<span class="p_add">+</span>
 	priv-&gt;dlen = desc.len;
 
 	err = nft_validate_data_load(ctx, priv-&gt;dreg, &amp;priv-&gt;data, desc.type);
<span class="p_header">diff --git a/net/netlink/af_netlink.c b/net/netlink/af_netlink.c</span>
<span class="p_header">index 24876492f26a..381b004c857a 100644</span>
<span class="p_header">--- a/net/netlink/af_netlink.c</span>
<span class="p_header">+++ b/net/netlink/af_netlink.c</span>
<span class="p_chunk">@@ -2461,7 +2461,7 @@</span> <span class="p_context"> static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,</span>
 	/* Record the max length of recvmsg() calls for future allocations */
 	nlk-&gt;max_recvmsg_len = max(nlk-&gt;max_recvmsg_len, len);
 	nlk-&gt;max_recvmsg_len = min_t(size_t, nlk-&gt;max_recvmsg_len,
<span class="p_del">-				     16384);</span>
<span class="p_add">+				     SKB_WITH_OVERHEAD(32768));</span>
 
 	copied = data_skb-&gt;len;
 	if (len &lt; copied) {
<span class="p_chunk">@@ -2719,9 +2719,8 @@</span> <span class="p_context"> static int netlink_dump(struct sock *sk)</span>
 	if (alloc_min_size &lt; nlk-&gt;max_recvmsg_len) {
 		alloc_size = nlk-&gt;max_recvmsg_len;
 		skb = netlink_alloc_skb(sk, alloc_size, nlk-&gt;portid,
<span class="p_del">-					GFP_KERNEL |</span>
<span class="p_del">-					__GFP_NOWARN |</span>
<span class="p_del">-					__GFP_NORETRY);</span>
<span class="p_add">+					(GFP_KERNEL &amp; ~__GFP_WAIT) |</span>
<span class="p_add">+					__GFP_NOWARN | __GFP_NORETRY);</span>
 	}
 	if (!skb) {
 		alloc_size = alloc_min_size;
<span class="p_header">diff --git a/net/packet/af_packet.c b/net/packet/af_packet.c</span>
<span class="p_header">index d6dfe65f4a74..062624c1be7e 100644</span>
<span class="p_header">--- a/net/packet/af_packet.c</span>
<span class="p_header">+++ b/net/packet/af_packet.c</span>
<span class="p_chunk">@@ -251,9 +251,20 @@</span> <span class="p_context"> static int packet_direct_xmit(struct sk_buff *skb)</span>
 		goto drop;
 
 	features = netif_skb_features(skb);
<span class="p_add">+	if (vlan_tx_tag_present(skb) &amp;&amp;</span>
<span class="p_add">+	    !vlan_hw_offload_capable(features, skb-&gt;vlan_proto))</span>
<span class="p_add">+		goto drop;</span>
<span class="p_add">+	if (netif_needs_gso(skb, features))</span>
<span class="p_add">+		goto drop;</span>
 	if (skb_needs_linearize(skb, features) &amp;&amp;
 	    __skb_linearize(skb))
 		goto drop;
<span class="p_add">+	if (skb-&gt;ip_summed == CHECKSUM_PARTIAL) {</span>
<span class="p_add">+		skb_set_transport_header(skb, skb_checksum_start_offset(skb));</span>
<span class="p_add">+		if (!(features &amp; NETIF_F_ALL_CSUM) &amp;&amp;</span>
<span class="p_add">+		    skb_checksum_help(skb))</span>
<span class="p_add">+			goto drop;</span>
<span class="p_add">+	}</span>
 
 	queue_map = skb_get_queue_mapping(skb);
 	txq = netdev_get_tx_queue(dev, queue_map);
<span class="p_chunk">@@ -3293,19 +3304,25 @@</span> <span class="p_context"> packet_setsockopt(struct socket *sock, int level, int optname, char __user *optv</span>
 
 		if (optlen != sizeof(val))
 			return -EINVAL;
<span class="p_del">-		if (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec)</span>
<span class="p_del">-			return -EBUSY;</span>
 		if (copy_from_user(&amp;val, optval, sizeof(val)))
 			return -EFAULT;
 		switch (val) {
 		case TPACKET_V1:
 		case TPACKET_V2:
 		case TPACKET_V3:
<span class="p_del">-			po-&gt;tp_version = val;</span>
<span class="p_del">-			return 0;</span>
<span class="p_add">+			break;</span>
 		default:
 			return -EINVAL;
 		}
<span class="p_add">+		lock_sock(sk);</span>
<span class="p_add">+		if (po-&gt;rx_ring.pg_vec || po-&gt;tx_ring.pg_vec) {</span>
<span class="p_add">+			ret = -EBUSY;</span>
<span class="p_add">+		} else {</span>
<span class="p_add">+			po-&gt;tp_version = val;</span>
<span class="p_add">+			ret = 0;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		release_sock(sk);</span>
<span class="p_add">+		return ret;</span>
 	}
 	case PACKET_RESERVE:
 	{
<span class="p_chunk">@@ -3768,6 +3785,7 @@</span> <span class="p_context"> static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,</span>
 	/* Added to avoid minimal code churn */
 	struct tpacket_req *req = &amp;req_u-&gt;req;
 
<span class="p_add">+	lock_sock(sk);</span>
 	/* Opening a Tx-ring is NOT supported in TPACKET_V3 */
 	if (!closing &amp;&amp; tx_ring &amp;&amp; (po-&gt;tp_version &gt; TPACKET_V2)) {
 		WARN(1, &quot;Tx-ring is not supported.\n&quot;);
<span class="p_chunk">@@ -3849,7 +3867,6 @@</span> <span class="p_context"> static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,</span>
 			goto out;
 	}
 
<span class="p_del">-	lock_sock(sk);</span>
 
 	/* Detach socket from network */
 	spin_lock(&amp;po-&gt;bind_lock);
<span class="p_chunk">@@ -3898,11 +3915,11 @@</span> <span class="p_context"> static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,</span>
 		if (!tx_ring)
 			prb_shutdown_retire_blk_timer(po, tx_ring, rb_queue);
 	}
<span class="p_del">-	release_sock(sk);</span>
 
 	if (pg_vec)
 		free_pg_vec(pg_vec, order, req-&gt;tp_block_nr);
 out:
<span class="p_add">+	release_sock(sk);</span>
 	return err;
 }
 
<span class="p_header">diff --git a/net/rose/rose_in.c b/net/rose/rose_in.c</span>
<span class="p_header">index 79c4abcfa6b4..0a6394754e81 100644</span>
<span class="p_header">--- a/net/rose/rose_in.c</span>
<span class="p_header">+++ b/net/rose/rose_in.c</span>
<span class="p_chunk">@@ -164,7 +164,8 @@</span> <span class="p_context"> static int rose_state3_machine(struct sock *sk, struct sk_buff *skb, int framety</span>
 		rose_frames_acked(sk, nr);
 		if (ns == rose-&gt;vr) {
 			rose_start_idletimer(sk);
<span class="p_del">-			if (sock_queue_rcv_skb(sk, skb) == 0) {</span>
<span class="p_add">+			if (sk_filter_trim_cap(sk, skb, ROSE_MIN_LEN) == 0 &amp;&amp;</span>
<span class="p_add">+			    __sock_queue_rcv_skb(sk, skb) == 0) {</span>
 				rose-&gt;vr = (rose-&gt;vr + 1) % ROSE_MODULUS;
 				queued = 1;
 			} else {
<span class="p_header">diff --git a/net/sched/sch_fq.c b/net/sched/sch_fq.c</span>
<span class="p_header">index 820eceb98d24..bdcedfedc489 100644</span>
<span class="p_header">--- a/net/sched/sch_fq.c</span>
<span class="p_header">+++ b/net/sched/sch_fq.c</span>
<span class="p_chunk">@@ -789,20 +789,24 @@</span> <span class="p_context"> nla_put_failure:</span>
 static int fq_dump_stats(struct Qdisc *sch, struct gnet_dump *d)
 {
 	struct fq_sched_data *q = qdisc_priv(sch);
<span class="p_del">-	u64 now = ktime_to_ns(ktime_get());</span>
<span class="p_del">-	struct tc_fq_qd_stats st = {</span>
<span class="p_del">-		.gc_flows		= q-&gt;stat_gc_flows,</span>
<span class="p_del">-		.highprio_packets	= q-&gt;stat_internal_packets,</span>
<span class="p_del">-		.tcp_retrans		= q-&gt;stat_tcp_retrans,</span>
<span class="p_del">-		.throttled		= q-&gt;stat_throttled,</span>
<span class="p_del">-		.flows_plimit		= q-&gt;stat_flows_plimit,</span>
<span class="p_del">-		.pkts_too_long		= q-&gt;stat_pkts_too_long,</span>
<span class="p_del">-		.allocation_errors	= q-&gt;stat_allocation_errors,</span>
<span class="p_del">-		.flows			= q-&gt;flows,</span>
<span class="p_del">-		.inactive_flows		= q-&gt;inactive_flows,</span>
<span class="p_del">-		.throttled_flows	= q-&gt;throttled_flows,</span>
<span class="p_del">-		.time_next_delayed_flow	= q-&gt;time_next_delayed_flow - now,</span>
<span class="p_del">-	};</span>
<span class="p_add">+	struct tc_fq_qd_stats st;</span>
<span class="p_add">+</span>
<span class="p_add">+	sch_tree_lock(sch);</span>
<span class="p_add">+</span>
<span class="p_add">+	st.gc_flows		  = q-&gt;stat_gc_flows;</span>
<span class="p_add">+	st.highprio_packets	  = q-&gt;stat_internal_packets;</span>
<span class="p_add">+	st.tcp_retrans		  = q-&gt;stat_tcp_retrans;</span>
<span class="p_add">+	st.throttled		  = q-&gt;stat_throttled;</span>
<span class="p_add">+	st.flows_plimit		  = q-&gt;stat_flows_plimit;</span>
<span class="p_add">+	st.pkts_too_long	  = q-&gt;stat_pkts_too_long;</span>
<span class="p_add">+	st.allocation_errors	  = q-&gt;stat_allocation_errors;</span>
<span class="p_add">+	st.time_next_delayed_flow = q-&gt;time_next_delayed_flow - ktime_to_ns(ktime_get());</span>
<span class="p_add">+	st.flows		  = q-&gt;flows;</span>
<span class="p_add">+	st.inactive_flows	  = q-&gt;inactive_flows;</span>
<span class="p_add">+	st.throttled_flows	  = q-&gt;throttled_flows;</span>
<span class="p_add">+	st.pad			  = 0;</span>
<span class="p_add">+</span>
<span class="p_add">+	sch_tree_unlock(sch);</span>
 
 	return gnet_stats_copy_app(d, &amp;st, sizeof(st));
 }
<span class="p_header">diff --git a/net/sctp/sm_sideeffect.c b/net/sctp/sm_sideeffect.c</span>
<span class="p_header">index 9366510a5867..198ceb721794 100644</span>
<span class="p_header">--- a/net/sctp/sm_sideeffect.c</span>
<span class="p_header">+++ b/net/sctp/sm_sideeffect.c</span>
<span class="p_chunk">@@ -1028,19 +1028,13 @@</span> <span class="p_context"> static void sctp_cmd_t1_timer_update(struct sctp_association *asoc,</span>
  * This way the whole message is queued up and bundling if
  * encouraged for small fragments.
  */
<span class="p_del">-static int sctp_cmd_send_msg(struct sctp_association *asoc,</span>
<span class="p_del">-				struct sctp_datamsg *msg)</span>
<span class="p_add">+static void sctp_cmd_send_msg(struct sctp_association *asoc,</span>
<span class="p_add">+			      struct sctp_datamsg *msg)</span>
 {
 	struct sctp_chunk *chunk;
<span class="p_del">-	int error = 0;</span>
<span class="p_del">-</span>
<span class="p_del">-	list_for_each_entry(chunk, &amp;msg-&gt;chunks, frag_list) {</span>
<span class="p_del">-		error = sctp_outq_tail(&amp;asoc-&gt;outqueue, chunk);</span>
<span class="p_del">-		if (error)</span>
<span class="p_del">-			break;</span>
<span class="p_del">-	}</span>
 
<span class="p_del">-	return error;</span>
<span class="p_add">+	list_for_each_entry(chunk, &amp;msg-&gt;chunks, frag_list)</span>
<span class="p_add">+		sctp_outq_tail(&amp;asoc-&gt;outqueue, chunk);</span>
 }
 
 
<span class="p_chunk">@@ -1714,7 +1708,7 @@</span> <span class="p_context"> static int sctp_cmd_interpreter(sctp_event_t event_type,</span>
 				sctp_outq_cork(&amp;asoc-&gt;outqueue);
 				local_cork = 1;
 			}
<span class="p_del">-			error = sctp_cmd_send_msg(asoc, cmd-&gt;obj.msg);</span>
<span class="p_add">+			sctp_cmd_send_msg(asoc, cmd-&gt;obj.msg);</span>
 			break;
 		case SCTP_CMD_SEND_NEXT_ASCONF:
 			sctp_cmd_send_asconf(asoc);
<span class="p_header">diff --git a/net/sctp/sm_statefuns.c b/net/sctp/sm_statefuns.c</span>
<span class="p_header">index 4f03bd0cb44d..b6c2d8107a06 100644</span>
<span class="p_header">--- a/net/sctp/sm_statefuns.c</span>
<span class="p_header">+++ b/net/sctp/sm_statefuns.c</span>
<span class="p_chunk">@@ -3426,6 +3426,12 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_ootb(struct net *net,</span>
 			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
 						  commands);
 
<span class="p_add">+		/* Report violation if chunk len overflows */</span>
<span class="p_add">+		ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch-&gt;length));</span>
<span class="p_add">+		if (ch_end &gt; skb_tail_pointer(skb))</span>
<span class="p_add">+			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,</span>
<span class="p_add">+						  commands);</span>
<span class="p_add">+</span>
 		/* Now that we know we at least have a chunk header,
 		 * do things that are type appropriate.
 		 */
<span class="p_chunk">@@ -3457,12 +3463,6 @@</span> <span class="p_context"> sctp_disposition_t sctp_sf_ootb(struct net *net,</span>
 			}
 		}
 
<span class="p_del">-		/* Report violation if chunk len overflows */</span>
<span class="p_del">-		ch_end = ((__u8 *)ch) + WORD_ROUND(ntohs(ch-&gt;length));</span>
<span class="p_del">-		if (ch_end &gt; skb_tail_pointer(skb))</span>
<span class="p_del">-			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,</span>
<span class="p_del">-						  commands);</span>
<span class="p_del">-</span>
 		ch = (sctp_chunkhdr_t *) ch_end;
 	} while (ch_end &lt; skb_tail_pointer(skb));
 
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_header">index 1b6929583a34..e15e9fa6a071 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/svc_rdma_recvfrom.c</span>
<span class="p_chunk">@@ -178,7 +178,7 @@</span> <span class="p_context"> static int rdma_read_chunk_lcl(struct svcxprt_rdma *xprt,</span>
 					   ctxt-&gt;sge[pno].addr);
 		if (ret)
 			goto err;
<span class="p_del">-		atomic_inc(&amp;xprt-&gt;sc_dma_used);</span>
<span class="p_add">+		svc_rdma_count_mappings(xprt, ctxt);</span>
 
 		/* The lkey here is either a local dma lkey or a dma_mr lkey */
 		ctxt-&gt;sge[pno].lkey = xprt-&gt;sc_dma_lkey;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/svc_rdma_sendto.c b/net/sunrpc/xprtrdma/svc_rdma_sendto.c</span>
<span class="p_header">index 0cf9f439025e..f3cfabe598e1 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/svc_rdma_sendto.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/svc_rdma_sendto.c</span>
<span class="p_chunk">@@ -184,7 +184,7 @@</span> <span class="p_context"> static int send_write(struct svcxprt_rdma *xprt, struct svc_rqst *rqstp,</span>
 		if (ib_dma_mapping_error(xprt-&gt;sc_cm_id-&gt;device,
 					 sge[sge_no].addr))
 			goto err;
<span class="p_del">-		atomic_inc(&amp;xprt-&gt;sc_dma_used);</span>
<span class="p_add">+		svc_rdma_count_mappings(xprt, ctxt);</span>
 		sge[sge_no].lkey = xprt-&gt;sc_dma_lkey;
 		ctxt-&gt;count++;
 		sge_off = 0;
<span class="p_chunk">@@ -411,7 +411,7 @@</span> <span class="p_context"> static int send_reply(struct svcxprt_rdma *rdma,</span>
 			    ctxt-&gt;sge[0].length, DMA_TO_DEVICE);
 	if (ib_dma_mapping_error(rdma-&gt;sc_cm_id-&gt;device, ctxt-&gt;sge[0].addr))
 		goto err;
<span class="p_del">-	atomic_inc(&amp;rdma-&gt;sc_dma_used);</span>
<span class="p_add">+	svc_rdma_count_mappings(rdma, ctxt);</span>
 
 	ctxt-&gt;direction = DMA_TO_DEVICE;
 
<span class="p_chunk">@@ -427,7 +427,7 @@</span> <span class="p_context"> static int send_reply(struct svcxprt_rdma *rdma,</span>
 		if (ib_dma_mapping_error(rdma-&gt;sc_cm_id-&gt;device,
 					 ctxt-&gt;sge[sge_no].addr))
 			goto err;
<span class="p_del">-		atomic_inc(&amp;rdma-&gt;sc_dma_used);</span>
<span class="p_add">+		svc_rdma_count_mappings(rdma, ctxt);</span>
 		ctxt-&gt;sge[sge_no].lkey = rdma-&gt;sc_dma_lkey;
 		ctxt-&gt;sge[sge_no].length = sge_bytes;
 	}
<span class="p_chunk">@@ -442,23 +442,9 @@</span> <span class="p_context"> static int send_reply(struct svcxprt_rdma *rdma,</span>
 		ctxt-&gt;pages[page_no+1] = rqstp-&gt;rq_respages[page_no];
 		ctxt-&gt;count++;
 		rqstp-&gt;rq_respages[page_no] = NULL;
<span class="p_del">-		/*</span>
<span class="p_del">-		 * If there are more pages than SGE, terminate SGE</span>
<span class="p_del">-		 * list so that svc_rdma_unmap_dma doesn&#39;t attempt to</span>
<span class="p_del">-		 * unmap garbage.</span>
<span class="p_del">-		 */</span>
<span class="p_del">-		if (page_no+1 &gt;= sge_no)</span>
<span class="p_del">-			ctxt-&gt;sge[page_no+1].length = 0;</span>
 	}
 	rqstp-&gt;rq_next_page = rqstp-&gt;rq_respages + 1;
 
<span class="p_del">-	/* The loop above bumps sc_dma_used for each sge. The</span>
<span class="p_del">-	 * xdr_buf.tail gets a separate sge, but resides in the</span>
<span class="p_del">-	 * same page as xdr_buf.head. Don&#39;t count it twice.</span>
<span class="p_del">-	 */</span>
<span class="p_del">-	if (sge_no &gt; ctxt-&gt;count)</span>
<span class="p_del">-		atomic_dec(&amp;rdma-&gt;sc_dma_used);</span>
<span class="p_del">-</span>
 	BUG_ON(sge_no &gt; rdma-&gt;sc_max_sge);
 	memset(&amp;send_wr, 0, sizeof send_wr);
 	ctxt-&gt;wr_op = IB_WR_SEND;
<span class="p_header">diff --git a/net/sunrpc/xprtrdma/svc_rdma_transport.c b/net/sunrpc/xprtrdma/svc_rdma_transport.c</span>
<span class="p_header">index 06a5d9235107..2f67c5ee9caf 100644</span>
<span class="p_header">--- a/net/sunrpc/xprtrdma/svc_rdma_transport.c</span>
<span class="p_header">+++ b/net/sunrpc/xprtrdma/svc_rdma_transport.c</span>
<span class="p_chunk">@@ -108,6 +108,7 @@</span> <span class="p_context"> struct svc_rdma_op_ctxt *svc_rdma_get_context(struct svcxprt_rdma *xprt)</span>
 	ctxt-&gt;xprt = xprt;
 	INIT_LIST_HEAD(&amp;ctxt-&gt;dto_q);
 	ctxt-&gt;count = 0;
<span class="p_add">+	ctxt-&gt;mapped_sges = 0;</span>
 	ctxt-&gt;frmr = NULL;
 	atomic_inc(&amp;xprt-&gt;sc_ctxt_used);
 	return ctxt;
<span class="p_chunk">@@ -116,22 +117,27 @@</span> <span class="p_context"> struct svc_rdma_op_ctxt *svc_rdma_get_context(struct svcxprt_rdma *xprt)</span>
 void svc_rdma_unmap_dma(struct svc_rdma_op_ctxt *ctxt)
 {
 	struct svcxprt_rdma *xprt = ctxt-&gt;xprt;
<span class="p_del">-	int i;</span>
<span class="p_del">-	for (i = 0; i &lt; ctxt-&gt;count &amp;&amp; ctxt-&gt;sge[i].length; i++) {</span>
<span class="p_add">+	struct ib_device *device = xprt-&gt;sc_cm_id-&gt;device;</span>
<span class="p_add">+	u32 lkey = xprt-&gt;sc_dma_lkey;</span>
<span class="p_add">+	unsigned int i, count;</span>
<span class="p_add">+</span>
<span class="p_add">+	for (count = 0, i = 0; i &lt; ctxt-&gt;mapped_sges; i++) {</span>
 		/*
 		 * Unmap the DMA addr in the SGE if the lkey matches
 		 * the sc_dma_lkey, otherwise, ignore it since it is
 		 * an FRMR lkey and will be unmapped later when the
 		 * last WR that uses it completes.
 		 */
<span class="p_del">-		if (ctxt-&gt;sge[i].lkey == xprt-&gt;sc_dma_lkey) {</span>
<span class="p_del">-			atomic_dec(&amp;xprt-&gt;sc_dma_used);</span>
<span class="p_del">-			ib_dma_unmap_page(xprt-&gt;sc_cm_id-&gt;device,</span>
<span class="p_add">+		if (ctxt-&gt;sge[i].lkey == lkey) {</span>
<span class="p_add">+			count++;</span>
<span class="p_add">+			ib_dma_unmap_page(device,</span>
 					    ctxt-&gt;sge[i].addr,
 					    ctxt-&gt;sge[i].length,
 					    ctxt-&gt;direction);
 		}
 	}
<span class="p_add">+	ctxt-&gt;mapped_sges = 0;</span>
<span class="p_add">+	atomic_sub(count, &amp;xprt-&gt;sc_dma_used);</span>
 }
 
 void svc_rdma_put_context(struct svc_rdma_op_ctxt *ctxt, int free_pages)
<span class="p_chunk">@@ -521,7 +527,7 @@</span> <span class="p_context"> int svc_rdma_post_recv(struct svcxprt_rdma *xprt)</span>
 				     DMA_FROM_DEVICE);
 		if (ib_dma_mapping_error(xprt-&gt;sc_cm_id-&gt;device, pa))
 			goto err_put_ctxt;
<span class="p_del">-		atomic_inc(&amp;xprt-&gt;sc_dma_used);</span>
<span class="p_add">+		svc_rdma_count_mappings(xprt, ctxt);</span>
 		ctxt-&gt;sge[sge_no].addr = pa;
 		ctxt-&gt;sge[sge_no].length = PAGE_SIZE;
 		ctxt-&gt;sge[sge_no].lkey = xprt-&gt;sc_dma_lkey;
<span class="p_chunk">@@ -1346,7 +1352,7 @@</span> <span class="p_context"> void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,</span>
 		svc_rdma_put_context(ctxt, 1);
 		return;
 	}
<span class="p_del">-	atomic_inc(&amp;xprt-&gt;sc_dma_used);</span>
<span class="p_add">+	svc_rdma_count_mappings(xprt, ctxt);</span>
 	ctxt-&gt;sge[0].lkey = xprt-&gt;sc_dma_lkey;
 	ctxt-&gt;sge[0].length = length;
 
<span class="p_header">diff --git a/net/tipc/bearer.c b/net/tipc/bearer.c</span>
<span class="p_header">index 264474394f9f..000d1ba48b8b 100644</span>
<span class="p_header">--- a/net/tipc/bearer.c</span>
<span class="p_header">+++ b/net/tipc/bearer.c</span>
<span class="p_chunk">@@ -420,6 +420,10 @@</span> <span class="p_context"> int tipc_enable_l2_media(struct tipc_bearer *b)</span>
 	dev = dev_get_by_name(&amp;init_net, driver_name);
 	if (!dev)
 		return -ENODEV;
<span class="p_add">+	if (tipc_mtu_bad(dev, 0)) {</span>
<span class="p_add">+		dev_put(dev);</span>
<span class="p_add">+		return -EINVAL;</span>
<span class="p_add">+	}</span>
 
 	/* Associate TIPC bearer with L2 bearer */
 	rcu_assign_pointer(b-&gt;media_ptr, dev);
<span class="p_chunk">@@ -564,14 +568,19 @@</span> <span class="p_context"> static int tipc_l2_device_event(struct notifier_block *nb, unsigned long evt,</span>
 	if (!b_ptr)
 		return NOTIFY_DONE;
 
<span class="p_del">-	b_ptr-&gt;mtu = dev-&gt;mtu;</span>
<span class="p_del">-</span>
 	switch (evt) {
 	case NETDEV_CHANGE:
 		if (netif_carrier_ok(dev))
 			break;
 	case NETDEV_DOWN:
<span class="p_add">+		tipc_reset_bearer(b_ptr);</span>
<span class="p_add">+		break;</span>
 	case NETDEV_CHANGEMTU:
<span class="p_add">+		if (tipc_mtu_bad(dev, 0)) {</span>
<span class="p_add">+			bearer_disable(b_ptr, false);</span>
<span class="p_add">+			break;</span>
<span class="p_add">+		}</span>
<span class="p_add">+		b_ptr-&gt;mtu = dev-&gt;mtu;</span>
 		tipc_reset_bearer(b_ptr);
 		break;
 	case NETDEV_CHANGEADDR:
<span class="p_header">diff --git a/net/tipc/bearer.h b/net/tipc/bearer.h</span>
<span class="p_header">index 78fccc49de23..8e0242501318 100644</span>
<span class="p_header">--- a/net/tipc/bearer.h</span>
<span class="p_header">+++ b/net/tipc/bearer.h</span>
<span class="p_chunk">@@ -50,6 +50,13 @@</span> <span class="p_context"></span>
 #define TIPC_MEDIA_ADDR_SIZE	32
 #define TIPC_MEDIA_TYPE_OFFSET	3
 
<span class="p_add">+/* Message header sizes from msg.h - duplicated to avoid mutual inclusion */</span>
<span class="p_add">+#define INT_H_SIZE                40</span>
<span class="p_add">+#define MAX_H_SIZE                60</span>
<span class="p_add">+</span>
<span class="p_add">+/* minimum bearer MTU */</span>
<span class="p_add">+#define TIPC_MIN_BEARER_MTU	(MAX_H_SIZE + INT_H_SIZE)</span>
<span class="p_add">+</span>
 /*
  * Identifiers of supported TIPC media types
  */
<span class="p_chunk">@@ -196,4 +203,13 @@</span> <span class="p_context"> void tipc_bearer_stop(void);</span>
 void tipc_bearer_send(u32 bearer_id, struct sk_buff *buf,
 		      struct tipc_media_addr *dest);
 
<span class="p_add">+/* check if device MTU is too low for tipc headers */</span>
<span class="p_add">+static inline bool tipc_mtu_bad(struct net_device *dev, unsigned int reserve)</span>
<span class="p_add">+{</span>
<span class="p_add">+	if (dev-&gt;mtu &gt;= TIPC_MIN_BEARER_MTU + reserve)</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+	netdev_warn(dev, &quot;MTU too low for tipc bearer\n&quot;);</span>
<span class="p_add">+	return true;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 #endif	/* _TIPC_BEARER_H */
<span class="p_header">diff --git a/net/wireless/core.h b/net/wireless/core.h</span>
<span class="p_header">index 7e3a3cef7df9..c4d4b0c4f0e6 100644</span>
<span class="p_header">--- a/net/wireless/core.h</span>
<span class="p_header">+++ b/net/wireless/core.h</span>
<span class="p_chunk">@@ -61,6 +61,7 @@</span> <span class="p_context"> struct cfg80211_registered_device {</span>
 	struct list_head bss_list;
 	struct rb_root bss_tree;
 	u32 bss_generation;
<span class="p_add">+	u32 bss_entries;</span>
 	struct cfg80211_scan_request *scan_req; /* protected by RTNL */
 	struct sk_buff *scan_msg;
 	struct cfg80211_sched_scan_request *sched_scan_req;
<span class="p_header">diff --git a/net/wireless/scan.c b/net/wireless/scan.c</span>
<span class="p_header">index 0798c62e6085..b650a358fe8e 100644</span>
<span class="p_header">--- a/net/wireless/scan.c</span>
<span class="p_header">+++ b/net/wireless/scan.c</span>
<span class="p_chunk">@@ -55,6 +55,19 @@</span> <span class="p_context"></span>
  * also linked into the probe response struct.
  */
 
<span class="p_add">+/*</span>
<span class="p_add">+ * Limit the number of BSS entries stored in mac80211. Each one is</span>
<span class="p_add">+ * a bit over 4k at most, so this limits to roughly 4-5M of memory.</span>
<span class="p_add">+ * If somebody wants to really attack this though, they&#39;d likely</span>
<span class="p_add">+ * use small beacons, and only one type of frame, limiting each of</span>
<span class="p_add">+ * the entries to a much smaller size (in order to generate more</span>
<span class="p_add">+ * entries in total, so overhead is bigger.)</span>
<span class="p_add">+ */</span>
<span class="p_add">+static int bss_entries_limit = 1000;</span>
<span class="p_add">+module_param(bss_entries_limit, int, 0644);</span>
<span class="p_add">+MODULE_PARM_DESC(bss_entries_limit,</span>
<span class="p_add">+                 &quot;limit to number of scan BSS entries (per wiphy, default 1000)&quot;);</span>
<span class="p_add">+</span>
 #define IEEE80211_SCAN_RESULT_EXPIRE	(30 * HZ)
 
 static void bss_free(struct cfg80211_internal_bss *bss)
<span class="p_chunk">@@ -135,6 +148,10 @@</span> <span class="p_context"> static bool __cfg80211_unlink_bss(struct cfg80211_registered_device *rdev,</span>
 
 	list_del_init(&amp;bss-&gt;list);
 	rb_erase(&amp;bss-&gt;rbn, &amp;rdev-&gt;bss_tree);
<span class="p_add">+	rdev-&gt;bss_entries--;</span>
<span class="p_add">+	WARN_ONCE((rdev-&gt;bss_entries == 0) ^ list_empty(&amp;rdev-&gt;bss_list),</span>
<span class="p_add">+		  &quot;rdev bss entries[%d]/list[empty:%d] corruption\n&quot;,</span>
<span class="p_add">+		  rdev-&gt;bss_entries, list_empty(&amp;rdev-&gt;bss_list));</span>
 	bss_ref_put(rdev, bss);
 	return true;
 }
<span class="p_chunk">@@ -161,6 +178,40 @@</span> <span class="p_context"> static void __cfg80211_bss_expire(struct cfg80211_registered_device *rdev,</span>
 		rdev-&gt;bss_generation++;
 }
 
<span class="p_add">+static bool cfg80211_bss_expire_oldest(struct cfg80211_registered_device *rdev)</span>
<span class="p_add">+{</span>
<span class="p_add">+	struct cfg80211_internal_bss *bss, *oldest = NULL;</span>
<span class="p_add">+	bool ret;</span>
<span class="p_add">+</span>
<span class="p_add">+	lockdep_assert_held(&amp;rdev-&gt;bss_lock);</span>
<span class="p_add">+</span>
<span class="p_add">+	list_for_each_entry(bss, &amp;rdev-&gt;bss_list, list) {</span>
<span class="p_add">+		if (atomic_read(&amp;bss-&gt;hold))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (!list_empty(&amp;bss-&gt;hidden_list) &amp;&amp;</span>
<span class="p_add">+		    !bss-&gt;pub.hidden_beacon_bss)</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+</span>
<span class="p_add">+		if (oldest &amp;&amp; time_before(oldest-&gt;ts, bss-&gt;ts))</span>
<span class="p_add">+			continue;</span>
<span class="p_add">+		oldest = bss;</span>
<span class="p_add">+	}</span>
<span class="p_add">+</span>
<span class="p_add">+	if (WARN_ON(!oldest))</span>
<span class="p_add">+		return false;</span>
<span class="p_add">+</span>
<span class="p_add">+	/*</span>
<span class="p_add">+	 * The callers make sure to increase rdev-&gt;bss_generation if anything</span>
<span class="p_add">+	 * gets removed (and a new entry added), so there&#39;s no need to also do</span>
<span class="p_add">+	 * it here.</span>
<span class="p_add">+	 */</span>
<span class="p_add">+</span>
<span class="p_add">+	ret = __cfg80211_unlink_bss(rdev, oldest);</span>
<span class="p_add">+	WARN_ON(!ret);</span>
<span class="p_add">+	return ret;</span>
<span class="p_add">+}</span>
<span class="p_add">+</span>
 void ___cfg80211_scan_done(struct cfg80211_registered_device *rdev,
 			   bool send_message)
 {
<span class="p_chunk">@@ -630,6 +681,7 @@</span> <span class="p_context"> static bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,</span>
 	const u8 *ie;
 	int i, ssidlen;
 	u8 fold = 0;
<span class="p_add">+	u32 n_entries = 0;</span>
 
 	ies = rcu_access_pointer(new-&gt;pub.beacon_ies);
 	if (WARN_ON(!ies))
<span class="p_chunk">@@ -653,6 +705,12 @@</span> <span class="p_context"> static bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,</span>
 	/* This is the bad part ... */
 
 	list_for_each_entry(bss, &amp;rdev-&gt;bss_list, list) {
<span class="p_add">+		/*</span>
<span class="p_add">+		 * we&#39;re iterating all the entries anyway, so take the</span>
<span class="p_add">+		 * opportunity to validate the list length accounting</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		n_entries++;</span>
<span class="p_add">+</span>
 		if (!ether_addr_equal(bss-&gt;pub.bssid, new-&gt;pub.bssid))
 			continue;
 		if (bss-&gt;pub.channel != new-&gt;pub.channel)
<span class="p_chunk">@@ -681,6 +739,10 @@</span> <span class="p_context"> static bool cfg80211_combine_bsses(struct cfg80211_registered_device *rdev,</span>
 				   new-&gt;pub.beacon_ies);
 	}
 
<span class="p_add">+	WARN_ONCE(n_entries != rdev-&gt;bss_entries,</span>
<span class="p_add">+		  &quot;rdev bss entries[%d]/list[len:%d] corruption\n&quot;,</span>
<span class="p_add">+		  rdev-&gt;bss_entries, n_entries);</span>
<span class="p_add">+</span>
 	return true;
 }
 
<span class="p_chunk">@@ -832,7 +894,14 @@</span> <span class="p_context"> cfg80211_bss_update(struct cfg80211_registered_device *rdev,</span>
 			}
 		}
 
<span class="p_add">+		if (rdev-&gt;bss_entries &gt;= bss_entries_limit &amp;&amp;</span>
<span class="p_add">+		    !cfg80211_bss_expire_oldest(rdev)) {</span>
<span class="p_add">+			kfree(new);</span>
<span class="p_add">+			goto drop;</span>
<span class="p_add">+		}</span>
<span class="p_add">+</span>
 		list_add_tail(&amp;new-&gt;list, &amp;rdev-&gt;bss_list);
<span class="p_add">+		rdev-&gt;bss_entries++;</span>
 		rb_insert_bss(rdev, new);
 		found = new;
 	}
<span class="p_header">diff --git a/scripts/gcc-x86_64-has-stack-protector.sh b/scripts/gcc-x86_64-has-stack-protector.sh</span>
<span class="p_header">index 973e8c141567..17867e723a51 100644</span>
<span class="p_header">--- a/scripts/gcc-x86_64-has-stack-protector.sh</span>
<span class="p_header">+++ b/scripts/gcc-x86_64-has-stack-protector.sh</span>
<span class="p_chunk">@@ -1,6 +1,6 @@</span> <span class="p_context"></span>
 #!/bin/sh
 
<span class="p_del">-echo &quot;int foo(void) { char X[200]; return 3; }&quot; | $* -S -x c -c -O0 -mcmodel=kernel -fstack-protector - -o - 2&gt; /dev/null | grep -q &quot;%gs&quot;</span>
<span class="p_add">+echo &quot;int foo(void) { char X[200]; return 3; }&quot; | $* -S -x c -c -O0 -mcmodel=kernel -fno-PIE -fstack-protector - -o - 2&gt; /dev/null | grep -q &quot;%gs&quot;</span>
 if [ &quot;$?&quot; -eq &quot;0&quot; ] ; then
 	echo y
 else
<span class="p_header">diff --git a/security/apparmor/domain.c b/security/apparmor/domain.c</span>
<span class="p_header">index 452567d3a08e..c0ee04da93e6 100644</span>
<span class="p_header">--- a/security/apparmor/domain.c</span>
<span class="p_header">+++ b/security/apparmor/domain.c</span>
<span class="p_chunk">@@ -627,8 +627,8 @@</span> <span class="p_context"> int aa_change_hat(const char *hats[], int count, u64 token, bool permtest)</span>
 	/* released below */
 	cred = get_current_cred();
 	cxt = cred_cxt(cred);
<span class="p_del">-	profile = aa_cred_profile(cred);</span>
<span class="p_del">-	previous_profile = cxt-&gt;previous;</span>
<span class="p_add">+	profile = aa_get_newest_profile(aa_cred_profile(cred));</span>
<span class="p_add">+	previous_profile = aa_get_newest_profile(cxt-&gt;previous);</span>
 
 	if (unconfined(profile)) {
 		info = &quot;unconfined&quot;;
<span class="p_chunk">@@ -724,6 +724,8 @@</span> <span class="p_context"> audit:</span>
 out:
 	aa_put_profile(hat);
 	kfree(name);
<span class="p_add">+	aa_put_profile(profile);</span>
<span class="p_add">+	aa_put_profile(previous_profile);</span>
 	put_cred(cred);
 
 	return error;
<span class="p_header">diff --git a/sound/core/pcm_lib.c b/sound/core/pcm_lib.c</span>
<span class="p_header">index 0032278567ad..0b4d286cbd3c 100644</span>
<span class="p_header">--- a/sound/core/pcm_lib.c</span>
<span class="p_header">+++ b/sound/core/pcm_lib.c</span>
<span class="p_chunk">@@ -1856,10 +1856,10 @@</span> <span class="p_context"> void snd_pcm_period_elapsed(struct snd_pcm_substream *substream)</span>
 	if (substream-&gt;timer_running)
 		snd_timer_interrupt(substream-&gt;timer, 1);
  _end:
<span class="p_del">-	snd_pcm_stream_unlock_irqrestore(substream, flags);</span>
 	if (runtime-&gt;transfer_ack_end)
 		runtime-&gt;transfer_ack_end(substream);
 	kill_fasync(&amp;runtime-&gt;fasync, SIGIO, POLL_IN);
<span class="p_add">+	snd_pcm_stream_unlock_irqrestore(substream, flags);</span>
 }
 
 EXPORT_SYMBOL(snd_pcm_period_elapsed);
<span class="p_header">diff --git a/sound/pci/ali5451/ali5451.c b/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">index feb29c24cab1..f87f91b460c6 100644</span>
<span class="p_header">--- a/sound/pci/ali5451/ali5451.c</span>
<span class="p_header">+++ b/sound/pci/ali5451/ali5451.c</span>
<span class="p_chunk">@@ -1408,6 +1408,7 @@</span> <span class="p_context"> snd_ali_playback_pointer(struct snd_pcm_substream *substream)</span>
 	spin_unlock(&amp;codec-&gt;reg_lock);
 	dev_dbg(codec-&gt;card-&gt;dev, &quot;playback pointer returned cso=%xh.\n&quot;, cso);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_chunk">@@ -1428,6 +1429,7 @@</span> <span class="p_context"> static snd_pcm_uframes_t snd_ali_pointer(struct snd_pcm_substream *substream)</span>
 	cso = inw(ALI_REG(codec, ALI_CSO_ALPHA_FMS + 2));
 	spin_unlock(&amp;codec-&gt;reg_lock);
 
<span class="p_add">+	cso %= runtime-&gt;buffer_size;</span>
 	return cso;
 }
 
<span class="p_header">diff --git a/sound/pci/hda/hda_intel.c b/sound/pci/hda/hda_intel.c</span>
<span class="p_header">index 8ff15d834ace..7823dc0aabd7 100644</span>
<span class="p_header">--- a/sound/pci/hda/hda_intel.c</span>
<span class="p_header">+++ b/sound/pci/hda/hda_intel.c</span>
<span class="p_chunk">@@ -258,8 +258,7 @@</span> <span class="p_context"> enum {</span>
 /* quirks for Nvidia */
 #define AZX_DCAPS_PRESET_NVIDIA \
 	(AZX_DCAPS_NVIDIA_SNOOP | AZX_DCAPS_RIRB_DELAY | AZX_DCAPS_NO_MSI |\
<span class="p_del">-	 AZX_DCAPS_ALIGN_BUFSIZE | AZX_DCAPS_NO_64BIT |\</span>
<span class="p_del">-	 AZX_DCAPS_CORBRP_SELF_CLEAR)</span>
<span class="p_add">+	 AZX_DCAPS_ALIGN_BUFSIZE | AZX_DCAPS_CORBRP_SELF_CLEAR)</span>
 
 #define AZX_DCAPS_PRESET_CTHDA \
 	(AZX_DCAPS_NO_MSI | AZX_DCAPS_POSFIX_LPIB | AZX_DCAPS_4K_BDLE_BOUNDARY |\
<span class="p_chunk">@@ -1371,6 +1370,10 @@</span> <span class="p_context"> static int azx_first_init(struct azx *chip)</span>
 		}
 	}
 
<span class="p_add">+	/* NVidia hardware normally only supports up to 40 bits of DMA */</span>
<span class="p_add">+	if (chip-&gt;pci-&gt;vendor == PCI_VENDOR_ID_NVIDIA)</span>
<span class="p_add">+		dma_bits = 40;</span>
<span class="p_add">+</span>
 	/* disable 64bit DMA address on some devices */
 	if (chip-&gt;driver_caps &amp; AZX_DCAPS_NO_64BIT) {
 		dev_dbg(card-&gt;dev, &quot;Disabling 64bit DMA\n&quot;);
<span class="p_header">diff --git a/sound/pci/hda/patch_realtek.c b/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">index 187d33729b50..b76f4ff117a2 100644</span>
<span class="p_header">--- a/sound/pci/hda/patch_realtek.c</span>
<span class="p_header">+++ b/sound/pci/hda/patch_realtek.c</span>
<span class="p_chunk">@@ -5103,6 +5103,10 @@</span> <span class="p_context"> static const struct hda_model_fixup alc269_fixup_models[] = {</span>
 
 static const struct snd_hda_pin_quirk alc269_pin_fixup_tbl[] = {
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_add">+		{0x14, 0x90170110},</span>
<span class="p_add">+		{0x1b, 0x02011020},</span>
<span class="p_add">+		{0x21, 0x0221101f}),</span>
<span class="p_add">+	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,</span>
 		{0x14, 0x90170130},
 		{0x21, 0x02211040}),
 	SND_HDA_PIN_QUIRK(0x10ec0255, 0x1028, &quot;Dell&quot;, ALC255_FIXUP_DELL1_MIC_NO_PRESENCE,
<span class="p_chunk">@@ -5838,6 +5842,7 @@</span> <span class="p_context"> enum {</span>
 	ALC662_FIXUP_ASUS_Nx50,
 	ALC668_FIXUP_ASUS_Nx51,
 	ALC662_FIXUP_ACER_VERITON,
<span class="p_add">+	ALC892_FIXUP_ASROCK_MOBO,</span>
 };
 
 static const struct hda_fixup alc662_fixups[] = {
<span class="p_chunk">@@ -6086,6 +6091,14 @@</span> <span class="p_context"> static const struct hda_fixup alc662_fixups[] = {</span>
 			{ }
 		}
 	},
<span class="p_add">+	[ALC892_FIXUP_ASROCK_MOBO] = {</span>
<span class="p_add">+		.type = HDA_FIXUP_PINS,</span>
<span class="p_add">+		.v.pins = (const struct hda_pintbl[]) {</span>
<span class="p_add">+			{ 0x15, 0x40f000f0 }, /* disabled */</span>
<span class="p_add">+			{ 0x16, 0x40f000f0 }, /* disabled */</span>
<span class="p_add">+			{ }</span>
<span class="p_add">+		}</span>
<span class="p_add">+	},</span>
 };
 
 static const struct snd_pci_quirk alc662_fixup_tbl[] = {
<span class="p_chunk">@@ -6120,6 +6133,7 @@</span> <span class="p_context"> static const struct snd_pci_quirk alc662_fixup_tbl[] = {</span>
 	SND_PCI_QUIRK(0x144d, 0xc051, &quot;Samsung R720&quot;, ALC662_FIXUP_IDEAPAD),
 	SND_PCI_QUIRK(0x17aa, 0x38af, &quot;Lenovo Ideapad Y550P&quot;, ALC662_FIXUP_IDEAPAD),
 	SND_PCI_QUIRK(0x17aa, 0x3a0d, &quot;Lenovo Ideapad Y550&quot;, ALC662_FIXUP_IDEAPAD),
<span class="p_add">+	SND_PCI_QUIRK(0x1849, 0x5892, &quot;ASRock B150M&quot;, ALC892_FIXUP_ASROCK_MOBO),</span>
 	SND_PCI_QUIRK(0x19da, 0xa130, &quot;Zotac Z68&quot;, ALC662_FIXUP_ZOTAC_Z68),
 	SND_PCI_QUIRK(0x1b0a, 0x01b8, &quot;ACER Veriton&quot;, ALC662_FIXUP_ACER_VERITON),
 	SND_PCI_QUIRK(0x1b35, 0x2206, &quot;CZC P10T&quot;, ALC662_FIXUP_CZC_P10T),
<span class="p_header">diff --git a/sound/pci/hda/thinkpad_helper.c b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">index 6ba0b5517c40..f233e90fa614 100644</span>
<span class="p_header">--- a/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_header">+++ b/sound/pci/hda/thinkpad_helper.c</span>
<span class="p_chunk">@@ -26,6 +26,9 @@</span> <span class="p_context"> static bool is_thinkpad(struct hda_codec *codec)</span>
 	if (ACPI_SUCCESS(acpi_get_devices(&quot;LEN0068&quot;, acpi_check_cb, &amp;found, NULL)) &amp;&amp; found)
 		return true;
 	found = false;
<span class="p_add">+	if (ACPI_SUCCESS(acpi_get_devices(&quot;LEN0268&quot;, acpi_check_cb, &amp;found, NULL)) &amp;&amp; found)</span>
<span class="p_add">+		return true;</span>
<span class="p_add">+	found = false;</span>
 	return ACPI_SUCCESS(acpi_get_devices(&quot;IBM0068&quot;, acpi_check_cb, &amp;found, NULL)) &amp;&amp; found;
 }
 
<span class="p_header">diff --git a/sound/soc/codecs/cs4270.c b/sound/soc/codecs/cs4270.c</span>
<span class="p_header">index 9947a9583679..6399ffbd1a61 100644</span>
<span class="p_header">--- a/sound/soc/codecs/cs4270.c</span>
<span class="p_header">+++ b/sound/soc/codecs/cs4270.c</span>
<span class="p_chunk">@@ -148,11 +148,11 @@</span> <span class="p_context"> SND_SOC_DAPM_OUTPUT(&quot;AOUTR&quot;),</span>
 };
 
 static const struct snd_soc_dapm_route cs4270_dapm_routes[] = {
<span class="p_del">-	{ &quot;Capture&quot;, NULL, &quot;AINA&quot; },</span>
<span class="p_del">-	{ &quot;Capture&quot;, NULL, &quot;AINB&quot; },</span>
<span class="p_add">+	{ &quot;Capture&quot;, NULL, &quot;AINL&quot; },</span>
<span class="p_add">+	{ &quot;Capture&quot;, NULL, &quot;AINR&quot; },</span>
 
<span class="p_del">-	{ &quot;AOUTA&quot;, NULL, &quot;Playback&quot; },</span>
<span class="p_del">-	{ &quot;AOUTB&quot;, NULL, &quot;Playback&quot; },</span>
<span class="p_add">+	{ &quot;AOUTL&quot;, NULL, &quot;Playback&quot; },</span>
<span class="p_add">+	{ &quot;AOUTR&quot;, NULL, &quot;Playback&quot; },</span>
 };
 
 /**
<span class="p_header">diff --git a/sound/soc/soc-dapm.c b/sound/soc/soc-dapm.c</span>
<span class="p_header">index 8065fd81b40c..ba2e25318d7e 100644</span>
<span class="p_header">--- a/sound/soc/soc-dapm.c</span>
<span class="p_header">+++ b/sound/soc/soc-dapm.c</span>
<span class="p_chunk">@@ -2870,7 +2870,7 @@</span> <span class="p_context"> int snd_soc_dapm_put_enum_double(struct snd_kcontrol *kcontrol,</span>
 	if (e-&gt;shift_l != e-&gt;shift_r) {
 		if (item[1] &gt; e-&gt;items)
 			return -EINVAL;
<span class="p_del">-		val |= snd_soc_enum_item_to_val(e, item[1]) &lt;&lt; e-&gt;shift_l;</span>
<span class="p_add">+		val |= snd_soc_enum_item_to_val(e, item[1]) &lt;&lt; e-&gt;shift_r;</span>
 		mask |= e-&gt;mask &lt;&lt; e-&gt;shift_r;
 	}
 
<span class="p_header">diff --git a/sound/usb/mixer_quirks.c b/sound/usb/mixer_quirks.c</span>
<span class="p_header">index 5bcf542b3a38..10ef6ce8f8bb 100644</span>
<span class="p_header">--- a/sound/usb/mixer_quirks.c</span>
<span class="p_header">+++ b/sound/usb/mixer_quirks.c</span>
<span class="p_chunk">@@ -1717,6 +1717,7 @@</span> <span class="p_context"> void snd_usb_mixer_rc_memory_change(struct usb_mixer_interface *mixer,</span>
 }
 
 static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,
<span class="p_add">+					 struct usb_mixer_elem_info *cval,</span>
 					 struct snd_kcontrol *kctl)
 {
 	/* Approximation using 10 ranges based on output measurement on hw v1.2.
<span class="p_chunk">@@ -1734,10 +1735,19 @@</span> <span class="p_context"> static void snd_dragonfly_quirk_db_scale(struct usb_mixer_interface *mixer,</span>
 		41, 50, TLV_DB_MINMAX_ITEM(-441, 0),
 	);
 
<span class="p_del">-	usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk\n&quot;);</span>
<span class="p_del">-	kctl-&gt;tlv.p = scale;</span>
<span class="p_del">-	kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_del">-	kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50) {</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;applying DragonFly dB scale quirk (0-50 variant)\n&quot;);</span>
<span class="p_add">+		kctl-&gt;tlv.p = scale;</span>
<span class="p_add">+		kctl-&gt;vd[0].access |= SNDRV_CTL_ELEM_ACCESS_TLV_READ;</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+</span>
<span class="p_add">+	} else if (cval-&gt;min == 0 &amp;&amp; cval-&gt;max &lt;= 1000) {</span>
<span class="p_add">+		/* Some other clearly broken DragonFly variant.</span>
<span class="p_add">+		 * At least a 0..53 variant (hw v1.0) exists.</span>
<span class="p_add">+		 */</span>
<span class="p_add">+		usb_audio_info(mixer-&gt;chip, &quot;ignoring too narrow dB range on a DragonFly device&quot;);</span>
<span class="p_add">+		kctl-&gt;vd[0].access &amp;= ~SNDRV_CTL_ELEM_ACCESS_TLV_CALLBACK;</span>
<span class="p_add">+	}</span>
 }
 
 void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,
<span class="p_chunk">@@ -1746,8 +1756,8 @@</span> <span class="p_context"> void snd_usb_mixer_fu_apply_quirk(struct usb_mixer_interface *mixer,</span>
 {
 	switch (mixer-&gt;chip-&gt;usb_id) {
 	case USB_ID(0x21b4, 0x0081): /* AudioQuest DragonFly */
<span class="p_del">-		if (unitid == 7 &amp;&amp; cval-&gt;min == 0 &amp;&amp; cval-&gt;max == 50)</span>
<span class="p_del">-			snd_dragonfly_quirk_db_scale(mixer, kctl);</span>
<span class="p_add">+		if (unitid == 7 &amp;&amp; cval-&gt;control == UAC_FU_VOLUME)</span>
<span class="p_add">+			snd_dragonfly_quirk_db_scale(mixer, cval, kctl);</span>
 		break;
 	}
 }
<span class="p_header">diff --git a/sound/usb/quirks-table.h b/sound/usb/quirks-table.h</span>
<span class="p_header">index c600d4277974..a1f08d8c7bd2 100644</span>
<span class="p_header">--- a/sound/usb/quirks-table.h</span>
<span class="p_header">+++ b/sound/usb/quirks-table.h</span>
<span class="p_chunk">@@ -2953,6 +2953,23 @@</span> <span class="p_context"> AU0828_DEVICE(0x2040, 0x7260, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),</span>
 AU0828_DEVICE(0x2040, 0x7213, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),
 AU0828_DEVICE(0x2040, 0x7270, &quot;Hauppauge&quot;, &quot;HVR-950Q&quot;),
 
<span class="p_add">+/* Syntek STK1160 */</span>
<span class="p_add">+{</span>
<span class="p_add">+	.match_flags = USB_DEVICE_ID_MATCH_DEVICE |</span>
<span class="p_add">+		       USB_DEVICE_ID_MATCH_INT_CLASS |</span>
<span class="p_add">+		       USB_DEVICE_ID_MATCH_INT_SUBCLASS,</span>
<span class="p_add">+	.idVendor = 0x05e1,</span>
<span class="p_add">+	.idProduct = 0x0408,</span>
<span class="p_add">+	.bInterfaceClass = USB_CLASS_AUDIO,</span>
<span class="p_add">+	.bInterfaceSubClass = USB_SUBCLASS_AUDIOCONTROL,</span>
<span class="p_add">+	.driver_info = (unsigned long) &amp;(const struct snd_usb_audio_quirk) {</span>
<span class="p_add">+		.vendor_name = &quot;Syntek&quot;,</span>
<span class="p_add">+		.product_name = &quot;STK1160&quot;,</span>
<span class="p_add">+		.ifnum = QUIRK_ANY_INTERFACE,</span>
<span class="p_add">+		.type = QUIRK_AUDIO_ALIGN_TRANSFER</span>
<span class="p_add">+	}</span>
<span class="p_add">+},</span>
<span class="p_add">+</span>
 /* Digidesign Mbox */
 {
 	/* Thanks to Clemens Ladisch &lt;clemens@ladisch.de&gt; */
<span class="p_header">diff --git a/tools/perf/util/symbol-elf.c b/tools/perf/util/symbol-elf.c</span>
<span class="p_header">index a9ef5c1f78df..e99293b9c76f 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol-elf.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol-elf.c</span>
<span class="p_chunk">@@ -958,8 +958,8 @@</span> <span class="p_context"> new_symbol:</span>
 	 * For misannotated, zeroed, ASM function sizes.
 	 */
 	if (nr &gt; 0) {
<span class="p_del">-		symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 		symbols__fixup_end(&amp;dso-&gt;symbols[map-&gt;type]);
<span class="p_add">+		symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 		if (kmap) {
 			/*
 			 * We need to fixup this here too because we create new
<span class="p_header">diff --git a/tools/perf/util/symbol.c b/tools/perf/util/symbol.c</span>
<span class="p_header">index f8bdba0971cc..a3f03908f421 100644</span>
<span class="p_header">--- a/tools/perf/util/symbol.c</span>
<span class="p_header">+++ b/tools/perf/util/symbol.c</span>
<span class="p_chunk">@@ -1176,8 +1176,8 @@</span> <span class="p_context"> int dso__load_kallsyms(struct dso *dso, const char *filename,</span>
 	if (kallsyms__delta(map, filename, &amp;delta))
 		return -1;
 
<span class="p_del">-	symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 	symbols__fixup_end(&amp;dso-&gt;symbols[map-&gt;type]);
<span class="p_add">+	symbols__fixup_duplicate(&amp;dso-&gt;symbols[map-&gt;type]);</span>
 
 	if (dso-&gt;kernel == DSO_TYPE_GUEST_KERNEL)
 		dso-&gt;symtab_type = DSO_BINARY_TYPE__GUEST_KALLSYMS;

</pre>
</div>




  </div>
  <div id="footer">
   <a href="http://jk.ozlabs.org/projects/patchwork/">patchwork</a>
   patch tracking system
  </div>
 </body>
</html>



